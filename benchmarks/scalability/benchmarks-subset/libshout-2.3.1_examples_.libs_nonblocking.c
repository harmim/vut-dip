// #anon_enum$OC_CS_UNSPECIFIED=0$OC_CS_ITU_REC_470M=1$OC_CS_ITU_REC_470BG=2$OC_CS_NSPACES=3
// file /usr/include/theora/theora.h line 164
enum anonymous$3 { OC_CS_UNSPECIFIED=0, OC_CS_ITU_REC_470M=1, OC_CS_ITU_REC_470BG=2, OC_CS_NSPACES=3 };

// #anon_enum$OC_PF_420=0$OC_PF_RSVD=1$OC_PF_422=2$OC_PF_444=3
// file /usr/include/theora/theora.h line 178
enum anonymous$4 { OC_PF_420=0, OC_PF_RSVD=1, OC_PF_422=2, OC_PF_444=3 };

// #anon_enum$SHOUT_STATE_UNCONNECTED=0$SHOUT_STATE_CONNECT_PENDING=1$SHOUT_STATE_REQ_PENDING=2$SHOUT_STATE_RESP_PENDING=3$SHOUT_STATE_CONNECTED=4
// file shout_private.h line 49
enum anonymous$9 { SHOUT_STATE_UNCONNECTED=0, SHOUT_STATE_CONNECT_PENDING=1, SHOUT_STATE_REQ_PENDING=2, SHOUT_STATE_RESP_PENDING=3, SHOUT_STATE_CONNECTED=4 };

// tag-#anon#ST[*{SYM#tag-SpeexHeader#}$SYM#tag-SpeexHeader#$'sh'|]
// file speex.c line 32
struct anonymous$11;

// tag-#anon#ST[*{SYM#tag-_shout_buf#}$SYM#tag-_shout_buf#$'head'||U64'len'|]
// file shout_private.h line 44
struct anonymous$10;

// tag-#anon#ST[*{U8}$U8$'body_data'||S64'body_storage'||S64'body_fill'||S64'body_returned'||*{S32}$S32$'lacing_vals'||*{S64}$S64$'granule_vals'||S64'lacing_storage'||S64'lacing_fill'||S64'lacing_packet'||S64'lacing_returned'||ARR282{U8}$U8$'header'||U16'$pad0'||S32'header_fill'||S32'e_o_s'||S32'b_o_s'||S64'serialno'||S64'pageno'||S64'packetno'||S64'granulepos'|]
// file /usr/include/ogg/ogg.h line 53
struct anonymous$15;

// tag-#anon#ST[*{U8}$U8$'data'||S32'storage'||S32'fill'||S32'returned'||S32'unsynced'||S32'headerbytes'||S32'bodybytes'|]
// file /usr/include/ogg/ogg.h line 105
struct anonymous$16;

// tag-#anon#ST[*{U8}$U8$'header'||S64'header_len'||*{U8}$U8$'body'||S64'body_len'|]
// file /usr/include/ogg/ogg.h line 43
struct anonymous$7;

// tag-#anon#ST[*{U8}$U8$'packet'||S64'bytes'||S64'b_o_s'||S64'e_o_s'||S64'granulepos'||S64'packetno'|]
// file /usr/include/ogg/ogg.h line 90
struct anonymous$2;

// tag-#anon#ST[*{cU8}$cU8$'data'||S32'maxlen'||S32'pos'|]
// file opus.c line 55
struct anonymous$0;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$12;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$19;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$23;

// tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous$21;

// tag-#anon#ST[S32'syncword'||S32'layer'||S32'version'||S32'error_protection'||S32'bitrate_index'||S32'samplerate_index'||S32'padding'||S32'extension'||S32'mode'||S32'mode_ext'||S32'copyright'||S32'original'||S32'emphasis'||S32'stereo'||S32'bitrate'||U32'samplerate'||U32'samples'||U32'framesize'|]
// file mp3.c line 50
struct anonymous$32;

// tag-#anon#ST[S32'version'||S32'channels'||S32'preskip'||U32'input_sample_rate'||S32'gain'||S32'channel_mapping'||S32'nb_streams'||S32'nb_coupled'||ARR255{U8}$U8$'stream_map'||U8'$pad0'|]
// file opus.c line 37
struct anonymous;

// tag-#anon#ST[S64'thread_id'||*{S8}$S8$'name'||S64'create_time'||*{S8}$S8$'file'||S32'line'||S32'detached'||U64'sys_thread'|]
// file ./../thread/thread.h line 28
struct anonymous$18;

// tag-#anon#ST[SYM#tag-#anon#ST[*{U8}$U8$'data'||S32'storage'||S32'fill'||S32'returned'||S32'unsynced'||S32'headerbytes'||S32'bodybytes'|]#'oy'||*{SYM#tag-_ogg_codec_tag#}$SYM#tag-_ogg_codec_tag#$'codecs'||S8'bos'||U56'$pad0'|]
// file ogg.c line 40
struct anonymous$17;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'version'||S32'channels'||S32'preskip'||U32'input_sample_rate'||S32'gain'||S32'channel_mapping'||S32'nb_streams'||S32'nb_coupled'||ARR255{U8}$U8$'stream_map'||U8'$pad0'|]#'oh'||S32'skipped'|]
// file opus.c line 50
struct anonymous$1;

// tag-#anon#ST[SYM#tag-#anon#ST[U32'width'||U32'height'||U32'frame_width'||U32'frame_height'||U32'offset_x'||U32'offset_y'||U32'fps_numerator'||U32'fps_denominator'||U32'aspect_numerator'||U32'aspect_denominator'||EN#anon_enum$OC_CS_UNSPECIFIED=0$OC_CS_ITU_REC_470M=1$OC_CS_ITU_REC_470BG=2$OC_CS_NSPACES=3#{U32}$U32$'colorspace'||S32'target_bitrate'||S32'quality'||S32'quick_p'||U8'version_major'||U8'version_minor'||U8'version_subminor'||U40'$pad0'||*{V}$V$'codec_setup'||S32'dropframes_p'||S32'keyframe_auto_p'||U32'keyframe_frequency'||U32'keyframe_frequency_force'||U32'keyframe_data_target_bitrate'||S32'keyframe_auto_threshold'||U32'keyframe_mindistance'||S32'noise_sensitivity'||S32'sharpness'||EN#anon_enum$OC_PF_420=0$OC_PF_RSVD=1$OC_PF_422=2$OC_PF_444=3#{U32}$U32$'pixelformat'|]#'ti'||SYM#tag-theora_comment#'tc'||U32'granule_shift'||U32'$pad0'||F64'per_frame'||U64'start_frame'||S32'initial_frames'||S32'get_start_frame'|]
// file theora.c line 37
struct anonymous$6;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]#'sys_rwlock'|]
// file ./thread/thread.h line 76
struct anonymous$8;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'cond_mutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'sys_cond'|]
// file ./../thread/thread.h line 66
struct anonymous$26;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'sys_mutex'|]
// file ./../thread/thread.h line 47
struct anonymous$31;

// tag-#anon#ST[SYM#tag-vorbis_info#'vi'||SYM#tag-vorbis_comment#'vc'||S32'prevW'||U32'$pad0'|]
// file vorbis.c line 37
struct anonymous$30;

// tag-#anon#ST[U32'frames'||S32'frame_samples'||S32'frame_samplerate'||U32'frame_left'||S32'header_bridges'||ARR3{U8}$U8$'header_bridge'||U8'$pad0'|]
// file mp3.c line 36
struct anonymous$33;

// tag-#anon#ST[U32'width'||U32'height'||U32'frame_width'||U32'frame_height'||U32'offset_x'||U32'offset_y'||U32'fps_numerator'||U32'fps_denominator'||U32'aspect_numerator'||U32'aspect_denominator'||EN#anon_enum$OC_CS_UNSPECIFIED=0$OC_CS_ITU_REC_470M=1$OC_CS_ITU_REC_470BG=2$OC_CS_NSPACES=3#{U32}$U32$'colorspace'||S32'target_bitrate'||S32'quality'||S32'quick_p'||U8'version_major'||U8'version_minor'||U8'version_subminor'||U40'$pad0'||*{V}$V$'codec_setup'||S32'dropframes_p'||S32'keyframe_auto_p'||U32'keyframe_frequency'||U32'keyframe_frequency_force'||U32'keyframe_data_target_bitrate'||S32'keyframe_auto_threshold'||U32'keyframe_mindistance'||S32'noise_sensitivity'||S32'sharpness'||EN#anon_enum$OC_PF_420=0$OC_PF_RSVD=1$OC_PF_422=2$OC_PF_444=3#{U32}$U32$'pixelformat'|]
// file /usr/include/theora/theora.h line 206
struct anonymous$5;

// tag-#anon#ST[vS32'lock'|]
// file ./../thread/thread.h line 93
struct anonymous$27;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$13;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$28;

// tag-#anon#UN[ARR8{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 224
union anonymous$20;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$24;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}$U8$'__pad1'||U64'__pad2'||U32'__flags'||U32'$pad0'|]#'__data'||ARR56{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous$22;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$25;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$29;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$14;

// tag-SpeexHeader
// file /usr/include/speex/speex_header.h line 59
struct SpeexHeader;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_avl_tree
// file ./avl/avl.h line 52
struct _avl_tree;

// tag-_link_node
// file avl.c line 1066
struct _link_node;

// tag-_ogg_codec_tag
// file shout_ogg.h line 33
struct _ogg_codec_tag;

// tag-_shout_buf
// file shout_private.h line 35
struct _shout_buf;

// tag-_util_dict
// file ../include/shout/shout.h line 58
struct _util_dict;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-avl_node_tag
// file ./avl/avl.h line 24
struct avl_node_tag;

// tag-http_parser_tag
// file httpp/httpp.h line 39
struct http_parser_tag;

// tag-http_var_tag
// file httpp/httpp.h line 29
struct http_var_tag;

// tag-http_varlist_tag
// file httpp/httpp.h line 34
struct http_varlist_tag;

// tag-httpp_request_type_tag
// file httpp/httpp.h line 24
enum httpp_request_type_tag { httpp_req_none=0, httpp_req_get=1, httpp_req_post=2, httpp_req_head=3, httpp_req_source=4, httpp_req_play=5, httpp_req_stats=6, httpp_req_unknown=7 };

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-linger
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 379
struct linger;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-shout
// file ../include/shout/shout.h line 57
struct shout;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 162
struct sockaddr_storage;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-theora_comment
// file /usr/include/theora/theora.h line 275
struct theora_comment;

// tag-thread_start_tag
// file thread.c line 74
struct thread_start_tag;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-vorbis_comment
// file /usr/include/vorbis/codec.h line 140
struct vorbis_comment;

// tag-vorbis_info
// file /usr/include/vorbis/codec.h line 28
struct vorbis_info;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _block_signals
// file thread.c line 215
static void _block_signals(void);
// _catch_signals
// file thread.c line 241
static void _catch_signals(void);
// _compare_threads
// file thread.c line 767
static signed int _compare_threads(void *compare_arg, void *a, void *b);
// _compare_vars
// file httpp.c line 543
static signed int _compare_vars(void *compare_arg, void *a, void *b);
// _free_thread
// file thread.c line 799
static signed int _free_thread(void *key);
// _free_vars
// file httpp.c line 553
static signed int _free_vars(void *key);
// _isip
// file resolver.c line 62
static signed int _isip(const char *what);
// _lowercase
// file httpp.c line 534
static char * _lowercase(char *str);
// _mutex_create
// file thread.c line 326
static void _mutex_create(struct anonymous$31 *mutex);
// _mutex_lock
// file thread.c line 717
static void _mutex_lock(struct anonymous$31 *mutex);
// _mutex_unlock
// file thread.c line 722
static void _mutex_unlock(struct anonymous$31 *mutex);
// _shout_avl_delete
// file avl.c line 351
signed int _shout_avl_delete(struct _avl_tree *tree, void *key, signed int (*free_key_fun)(void *));
// _shout_avl_delete::free_key_fun$object
// 
signed int free_key_fun$object(void *);
// _shout_avl_get_by_index
// file avl.c line 299
signed int _shout_avl_get_by_index(struct _avl_tree *tree, unsigned long int index, void **value_address);
// _shout_avl_get_by_key
// file avl.c line 322
signed int _shout_avl_get_by_key(struct _avl_tree *tree, void *key, void **value_address);
// _shout_avl_get_first
// file avl.c line 666
struct avl_node_tag * _shout_avl_get_first(struct _avl_tree *tree);
// _shout_avl_get_item_by_key_least
// file avl.c line 951
signed int _shout_avl_get_item_by_key_least(struct _avl_tree *tree, void *key, void **value_address);
// _shout_avl_get_item_by_key_most
// file avl.c line 907
signed int _shout_avl_get_item_by_key_most(struct _avl_tree *tree, void *key, void **value_address);
// _shout_avl_get_next
// file avl.c line 702
struct avl_node_tag * _shout_avl_get_next(struct avl_node_tag *node);
// _shout_avl_get_prev
// file avl.c line 679
struct avl_node_tag * _shout_avl_get_prev(struct avl_node_tag *node);
// _shout_avl_get_span_by_key
// file avl.c line 813
signed int _shout_avl_get_span_by_key(struct _avl_tree *tree, void *key, unsigned long int *low, unsigned long int *high);
// _shout_avl_get_span_by_two_keys
// file avl.c line 856
signed int _shout_avl_get_span_by_two_keys(struct _avl_tree *tree, void *low_key, void *high_key, unsigned long int *low, unsigned long int *high);
// _shout_avl_insert
// file avl.c line 123
signed int _shout_avl_insert(struct _avl_tree *ob, void *key);
// _shout_avl_iterate_index_range
// file avl.c line 728
signed int _shout_avl_iterate_index_range(struct _avl_tree *tree, signed int (*iter_fun)(unsigned long int, void *, void *), unsigned long int low, unsigned long int high, void *iter_arg);
// _shout_avl_iterate_index_range::iter_fun$object
// 
//signed int iter_fun$object(unsigned long int, void *, void *);
// _shout_avl_iterate_inorder
// file avl.c line 652
signed int _shout_avl_iterate_inorder(struct _avl_tree *tree, signed int (*iter_fun)(void *, void *), void *iter_arg);
// _shout_avl_iterate_inorder::iter_fun$object
// 
//signed int iter_fun$object(void *, void *);
// _shout_avl_node_new
// file avl.c line 42
struct avl_node_tag * _shout_avl_node_new(void *key, struct avl_node_tag *parent);
// _shout_avl_print_tree
// file avl.c line 1150
void _shout_avl_print_tree(struct _avl_tree *tree, signed int (*key_printer)(char *, void *));
// _shout_avl_print_tree::key_printer$object
// 
signed int key_printer$object(char *, void *);
// _shout_avl_tree_free
// file avl.c line 107
void _shout_avl_tree_free(struct _avl_tree *tree, signed int (*free_key_fun)(void *));
// _shout_avl_tree_free::free_key_fun$object
// 
signed int free_key_fun$object(void *);
// _shout_avl_tree_new
// file avl.c line 65
struct _avl_tree * _shout_avl_tree_new(signed int (*compare_fun)(void *, void *, void *), void *compare_arg);
// _shout_avl_tree_new::compare_fun$object
// 
signed int compare_fun$object(void *, void *, void *);
// _shout_avl_tree_rlock
// file avl.c line 1164
void _shout_avl_tree_rlock(struct _avl_tree *tree);
// _shout_avl_tree_unlock
// file avl.c line 1174
void _shout_avl_tree_unlock(struct _avl_tree *tree);
// _shout_avl_tree_wlock
// file avl.c line 1169
void _shout_avl_tree_wlock(struct _avl_tree *tree);
// _shout_avl_verify
// file avl.c line 1050
signed int _shout_avl_verify(struct _avl_tree *tree);
// _shout_httpp_clear
// file httpp.c line 517
void _shout_httpp_clear(struct http_parser_tag *parser);
// _shout_httpp_create_parser
// file httpp/httpp.h line 60
struct http_parser_tag * _shout_httpp_create_parser(void);
// _shout_httpp_destroy
// file httpp/httpp.h line 70
void _shout_httpp_destroy(struct http_parser_tag *parser);
// _shout_httpp_get_query_param
// file httpp.c line 501
const char * _shout_httpp_get_query_param(struct http_parser_tag *parser, const char *name);
// _shout_httpp_getvar
// file httpp/httpp.h line 67
const char * _shout_httpp_getvar(struct http_parser_tag *parser, const char *name);
// _shout_httpp_initialize
// file httpp/httpp.h line 61
void _shout_httpp_initialize(struct http_parser_tag *parser, struct http_varlist_tag *defaults);
// _shout_httpp_parse
// file httpp.c line 288
signed int _shout_httpp_parse(struct http_parser_tag *parser, const char *http_data, unsigned long int len);
// _shout_httpp_parse_response
// file httpp/httpp.h line 64
signed int _shout_httpp_parse_response(struct http_parser_tag *parser, const char *http_data, unsigned long int len, const char *uri);
// _shout_httpp_set_query_param
// file httpp.c line 480
void _shout_httpp_set_query_param(struct http_parser_tag *parser, const char *name, const char *value);
// _shout_httpp_setvar
// file httpp.c line 440
void _shout_httpp_setvar(struct http_parser_tag *parser, const char *name, const char *value);
// _shout_open_opus
// file shout_ogg.h line 54
signed int _shout_open_opus(struct _ogg_codec_tag *codec, struct anonymous$7 *page);
// _shout_open_speex
// file shout_ogg.h line 52
signed int _shout_open_speex(struct _ogg_codec_tag *codec, struct anonymous$7 *page);
// _shout_open_theora
// file shout_ogg.h line 49
signed int _shout_open_theora(struct _ogg_codec_tag *codec, struct anonymous$7 *page);
// _shout_open_vorbis
// file shout_ogg.h line 47
signed int _shout_open_vorbis(struct _ogg_codec_tag *codec, struct anonymous$7 *page);
// _shout_resolver_getip
// file resolver.h line 34
char * _shout_resolver_getip(const char *name, char *buff, signed int len);
// _shout_resolver_getname
// file resolver.c line 86
char * _shout_resolver_getname(const char *ip, char *buff, signed int len);
// _shout_resolver_initialize
// file resolver.h line 30
void _shout_resolver_initialize(void);
// _shout_resolver_shutdown
// file resolver.h line 31
void _shout_resolver_shutdown(void);
// _shout_sock_accept
// file sock.c line 922
signed int _shout_sock_accept(signed int serversock, char *ip, unsigned long int len);
// _shout_sock_close
// file ./net/sock.h line 117
signed int _shout_sock_close(signed int sock);
// _shout_sock_connect_non_blocking
// file ./net/sock.h line 122
signed int _shout_sock_connect_non_blocking(const char *hostname, unsigned int port);
// _shout_sock_connect_wto
// file ./net/sock.h line 120
signed int _shout_sock_connect_wto(const char *hostname, signed int port, signed int timeout);
// _shout_sock_connect_wto_bind
// file sock.c line 633
signed int _shout_sock_connect_wto_bind(const char *hostname, signed int port, const char *bnd, signed int timeout);
// _shout_sock_connected
// file ./net/sock.h line 123
signed int _shout_sock_connected(signed int sock, signed int timeout);
// _shout_sock_error
// file ./net/sock.h line 106
signed int _shout_sock_error(void);
// _shout_sock_get_localip
// file sock.c line 108
char * _shout_sock_get_localip(char *buff, signed int len);
// _shout_sock_get_server_socket
// file sock.c line 705
signed int _shout_sock_get_server_socket(signed int port, const char *sinterface);
// _shout_sock_initialize
// file ./net/sock.h line 103
void _shout_sock_initialize(void);
// _shout_sock_listen
// file sock.c line 911
signed int _shout_sock_listen(signed int serversock, signed int backlog);
// _shout_sock_read_bytes
// file ./net/sock.h line 134
signed int _shout_sock_read_bytes(signed int sock, char *buff, unsigned long int len);
// _shout_sock_read_line
// file sock.c line 474
signed int _shout_sock_read_line(signed int sock, char *buff, const signed int len);
// _shout_sock_recoverable
// file ./net/sock.h line 107
signed int _shout_sock_recoverable(signed int error);
// _shout_sock_set_blocking
// file sock.c line 250
signed int _shout_sock_set_blocking(signed int sock, signed int block);
// _shout_sock_set_error
// file sock.c line 134
void _shout_sock_set_error(signed int val);
// _shout_sock_set_keepalive
// file sock.c line 286
signed int _shout_sock_set_keepalive(signed int sock);
// _shout_sock_set_nodelay
// file sock.c line 278
signed int _shout_sock_set_nodelay(signed int sock);
// _shout_sock_set_nolinger
// file sock.c line 271
signed int _shout_sock_set_nolinger(signed int sock);
// _shout_sock_set_send_buffer
// file sock.c line 906
void _shout_sock_set_send_buffer(signed int sock, signed int win_size);
// _shout_sock_shutdown
// file ./net/sock.h line 104
void _shout_sock_shutdown(void);
// _shout_sock_stalled
// file sock.c line 168
signed int _shout_sock_stalled(signed int error);
// _shout_sock_valid_socket
// file sock.c line 197
signed int _shout_sock_valid_socket(signed int sock);
// _shout_sock_write
// file ./net/sock.h line 127
signed int _shout_sock_write(signed int sock, const char *fmt, ...);
// _shout_sock_write_bytes
// file ./net/sock.h line 126
signed int _shout_sock_write_bytes(signed int sock, const void *buff, unsigned long int len);
// _shout_sock_write_fmt
// file sock.c line 421
signed int _shout_sock_write_fmt(signed int sock, const char *fmt, void **ap);
// _shout_sock_write_string
// file sock.c line 369
signed int _shout_sock_write_string(signed int sock, const char *buff);
// _shout_sock_writev
// file sock.c line 312
signed long int _shout_sock_writev(signed int sock, struct iovec *iov, unsigned long int count);
// _shout_thread_cond_broadcast_c
// file thread.c line 513
void _shout_thread_cond_broadcast_c(struct anonymous$26 *cond, signed int line, char *file);
// _shout_thread_cond_create_c
// file thread.c line 496
void _shout_thread_cond_create_c(struct anonymous$26 *cond, signed int line, char *file);
// _shout_thread_cond_destroy
// file thread.c line 502
void _shout_thread_cond_destroy(struct anonymous$26 *cond);
// _shout_thread_cond_signal_c
// file thread.c line 508
void _shout_thread_cond_signal_c(struct anonymous$26 *cond, signed int line, char *file);
// _shout_thread_cond_timedwait_c
// file thread.c line 518
void _shout_thread_cond_timedwait_c(struct anonymous$26 *cond, signed int millis, signed int line, char *file);
// _shout_thread_cond_wait_c
// file thread.c line 530
void _shout_thread_cond_wait_c(struct anonymous$26 *cond, signed int line, char *file);
// _shout_thread_create_c
// file thread.c line 264
struct anonymous$18 * _shout_thread_create_c(char *name, void * (*start_routine)(void *), void *arg, signed int detached, signed int line, char *file);
// _shout_thread_create_c::start_routine$object
// 
void * start_routine$object(void *);
// _shout_thread_exit_c
// file thread.c line 562
void _shout_thread_exit_c(signed long int val, signed int line, char *file);
// _shout_thread_initialize
// file thread.c line 138
void _shout_thread_initialize(void);
// _shout_thread_join
// file thread.c line 738
void _shout_thread_join(struct anonymous$18 *thread);
// _shout_thread_library_lock
// file thread.c line 728
void _shout_thread_library_lock(void);
// _shout_thread_library_unlock
// file thread.c line 733
void _shout_thread_library_unlock(void);
// _shout_thread_mutex_create
// file ./../thread/thread.h line 168
void _shout_thread_mutex_create(struct anonymous$31 *mutex, signed int line, char *file);
// _shout_thread_mutex_destroy
// file ./../thread/thread.h line 171
void _shout_thread_mutex_destroy(struct anonymous$31 *mutex);
// _shout_thread_mutex_lock_c
// file thread.c line 359
void _shout_thread_mutex_lock_c(struct anonymous$31 *mutex, signed int line, char *file);
// _shout_thread_mutex_unlock_c
// file thread.c line 431
void _shout_thread_mutex_unlock_c(struct anonymous$31 *mutex, signed int line, char *file);
// _shout_thread_rename
// file thread.c line 707
void _shout_thread_rename(const char *name);
// _shout_thread_rwlock_create_c
// file ./../thread/thread.h line 178
void _shout_thread_rwlock_create_c(struct anonymous$8 *rwlock, signed int line, char *file);
// _shout_thread_rwlock_destroy
// file ./../thread/thread.h line 182
void _shout_thread_rwlock_destroy(struct anonymous$8 *rwlock);
// _shout_thread_rwlock_rlock_c
// file ./../thread/thread.h line 179
void _shout_thread_rwlock_rlock_c(struct anonymous$8 *rwlock, signed int line, char *file);
// _shout_thread_rwlock_unlock_c
// file ./../thread/thread.h line 181
void _shout_thread_rwlock_unlock_c(struct anonymous$8 *rwlock, signed int line, char *file);
// _shout_thread_rwlock_wlock_c
// file ./../thread/thread.h line 180
void _shout_thread_rwlock_wlock_c(struct anonymous$8 *rwlock, signed int line, char *file);
// _shout_thread_self
// file thread.c line 669
struct anonymous$18 * _shout_thread_self(void);
// _shout_thread_shutdown
// file thread.c line 187
void _shout_thread_shutdown(void);
// _shout_thread_sleep
// file thread.c line 604
void _shout_thread_sleep(unsigned long int len);
// _shout_timing_get_time
// file timing/timing.h line 29
unsigned long int _shout_timing_get_time(void);
// _shout_timing_sleep
// file timing/timing.h line 30
void _shout_timing_sleep(unsigned long int sleeptime);
// _shout_util_base64_encode
// file util.h line 23
char * _shout_util_base64_encode(char *data);
// _shout_util_dict_free
// file util.h line 17
void _shout_util_dict_free(struct _util_dict *dict);
// _shout_util_dict_get
// file util.h line 20
const char * _shout_util_dict_get(struct _util_dict *dict, const char *key);
// _shout_util_dict_new
// file util.h line 16
struct _util_dict * _shout_util_dict_new(void);
// _shout_util_dict_set
// file util.h line 19
signed int _shout_util_dict_set(struct _util_dict *dict, const char *key, const char *val);
// _shout_util_dict_urlencode
// file util.h line 21
char * _shout_util_dict_urlencode(struct _util_dict *dict, char delim);
// _shout_util_read_header
// file util.c line 47
signed int _shout_util_read_header(signed int sock, char *buff, unsigned long int len);
// _shout_util_strdup
// file util.h line 14
char * _shout_util_strdup(const char *s);
// _shout_util_url_encode
// file util.c line 144
char * _shout_util_url_encode(const char *data);
// _start_routine
// file thread.c line 635
static void * _start_routine(void *arg);
// _start_routine::1::start_routine$object
// 
void * start_routine$object(void *);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous$14, unsigned int *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// avl_get_index_by_key
// file avl.c line 772
static struct avl_node_tag * avl_get_index_by_key(struct _avl_tree *tree, void *key, unsigned long int *index);
// avl_iterate_inorder_helper
// file avl.c line 627
static signed int avl_iterate_inorder_helper(struct avl_node_tag *node, signed int (*iter_fun)(void *, void *), void *iter_arg);
// avl_iterate_inorder_helper::iter_fun$object
// 
//signed int iter_fun$object(void *, void *);
// avl_tree_free_helper
// file avl.c line 90
static void avl_tree_free_helper(struct avl_node_tag *node, signed int (*free_key_fun)(void *));
// avl_tree_free_helper::free_key_fun$object
// 
signed int free_key_fun$object(void *);
// avl_verify_balance
// file avl.c line 995
static signed long int avl_verify_balance(struct avl_node_tag *node);
// avl_verify_parent
// file avl.c line 1013
static void avl_verify_parent(struct avl_node_tag *node, struct avl_node_tag *parent);
// avl_verify_rank
// file avl.c line 1027
static signed long int avl_verify_rank(struct avl_node_tag *node);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$14, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_mp3
// file mp3.c line 314
static void close_mp3(struct shout *self);
// close_ogg
// file ogg.c line 141
static void close_ogg(struct shout *self);
// close_webm
// file webm.c line 64
static void close_webm(struct shout *self);
// collect_queue
// file shout.c line 1050
static signed int collect_queue(struct _shout_buf *queue, char **buf);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous$14, unsigned int);
// create_http_request
// file shout.c line 1111
static signed int create_http_request(struct shout *self);
// create_icy_request
// file shout.c line 1290
static signed int create_icy_request(struct shout *self);
// create_request
// file shout.c line 1099
static signed int create_request(struct shout *self);
// create_xaudiocast_request
// file shout.c line 1237
static signed int create_xaudiocast_request(struct shout *self);
// default_key_printer
// file avl.c line 1075
static signed int default_key_printer(char *buffer, void *key);
// endhostent
// file /usr/include/netdb.h line 123
extern void endhostent(void);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_codec
// file ogg.c line 185
static void free_codec(struct _ogg_codec_tag *codec);
// free_codecs
// file ogg.c line 169
static void free_codecs(struct anonymous$17 *ogg_data);
// free_opus_data
// file opus.c line 277
static void free_opus_data(void *codec_data);
// free_speex_data
// file speex.c line 78
static void free_speex_data(void *codec_data);
// free_theora_data
// file theora.c line 133
static void free_theora_data(void *codec_data);
// free_vorbis_data
// file vorbis.c line 99
static void free_vorbis_data(void *codec_data);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// get_response
// file shout.c line 889
static signed int get_response(struct shout *self);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file timing.c line 53 function _shout_timing_get_time
//signed int gettimeofday(void);
// hex
// file httpp.c line 192
static signed int hex(char c);
// http_basic_authorization
// file shout.c line 1166
static char * http_basic_authorization(struct shout *self);
// httpp_deletevar
// file httpp.c line 429
void httpp_deletevar(struct http_parser_tag *parser, const char *name);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mp3_header
// file mp3.c line 290
static signed int mp3_header(unsigned int head, struct anonymous$32 *mh);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// ogg_page_bos
// file /usr/include/ogg/ogg.h line 196
extern signed int ogg_page_bos(const struct anonymous$7 *);
// ogg_page_granulepos
// file /usr/include/ogg/ogg.h line 198
extern signed long int ogg_page_granulepos(const struct anonymous$7 *);
// ogg_page_serialno
// file /usr/include/ogg/ogg.h line 199
extern signed int ogg_page_serialno(const struct anonymous$7 *);
// ogg_stream_clear
// file /usr/include/ogg/ogg.h line 185
extern signed int ogg_stream_clear(struct anonymous$15 *);
// ogg_stream_init
// file /usr/include/ogg/ogg.h line 184
extern signed int ogg_stream_init(struct anonymous$15 *, signed int);
// ogg_stream_packetout
// file /usr/include/ogg/ogg.h line 179
extern signed int ogg_stream_packetout(struct anonymous$15 *, struct anonymous$2 *);
// ogg_stream_pagein
// file /usr/include/ogg/ogg.h line 178
extern signed int ogg_stream_pagein(struct anonymous$15 *, struct anonymous$7 *);
// ogg_sync_buffer
// file /usr/include/ogg/ogg.h line 174
extern char * ogg_sync_buffer(struct anonymous$16 *, signed long int);
// ogg_sync_clear
// file /usr/include/ogg/ogg.h line 169
extern signed int ogg_sync_clear(struct anonymous$16 *);
// ogg_sync_init
// file /usr/include/ogg/ogg.h line 168
extern signed int ogg_sync_init(struct anonymous$16 *);
// ogg_sync_pageout
// file /usr/include/ogg/ogg.h line 177
extern signed int ogg_sync_pageout(struct anonymous$16 *, struct anonymous$7 *);
// ogg_sync_wrote
// file /usr/include/ogg/ogg.h line 175
extern signed int ogg_sync_wrote(struct anonymous$16 *, signed long int);
// open_codec
// file ogg.c line 149
static signed int open_codec(struct _ogg_codec_tag *codec, struct anonymous$7 *page);
// open_codec::1::this_codec$object
// 
signed int this_codec$object(struct _ogg_codec_tag *, struct anonymous$7 *);
// opus_header_parse
// file opus.c line 100
static signed int opus_header_parse(const unsigned char *packet, signed int len, struct anonymous *h);
// packet_get_nb_frames
// file opus.c line 195
static signed int packet_get_nb_frames(const unsigned char *packet, signed int len);
// packet_get_samples_per_frame
// file opus.c line 174
static signed int packet_get_samples_per_frame(const unsigned char *data, signed int Fs);
// parse_header
// file mp3.c line 258
static void parse_header(struct anonymous$32 *mh, unsigned int header);
// parse_headers
// file httpp.c line 92
static void parse_headers(struct http_parser_tag *parser, char **line, signed int lines);
// parse_http_response
// file shout.c line 1203
static signed int parse_http_response(struct shout *self);
// parse_query
// file httpp.c line 255
static void parse_query(struct http_parser_tag *parser, char *query);
// parse_response
// file shout.c line 1192
static signed int parse_response(struct shout *self);
// parse_xaudiocast_response
// file shout.c line 1273
static signed int parse_xaudiocast_response(struct shout *self);
// print_connectors
// file avl.c line 1088
static void print_connectors(struct _link_node *link);
// print_node
// file avl.c line 1115
static void print_node(signed int (*key_printer)(char *, void *), struct avl_node_tag *node, struct _link_node *link);
// print_node::key_printer$object
// 
signed int key_printer$object(char *, void *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_attr_setinheritsched
// file /usr/include/pthread.h line 342
extern signed int pthread_attr_setinheritsched(union pthread_attr_t *, signed int);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 377
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$24 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$24 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$24 *, const union anonymous$28 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$24 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$24 *, union anonymous$25 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$24 *, union anonymous$25 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_equal
// file /usr/include/pthread.h line 280
extern signed int pthread_equal(unsigned long int, unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$25 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$25 *, const union anonymous$28 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$25 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$25 *);
// pthread_rwlock_destroy
// file /usr/include/pthread.h line 895
extern signed int pthread_rwlock_destroy(union anonymous$22 *);
// pthread_rwlock_init
// file /usr/include/pthread.h line 890
extern signed int pthread_rwlock_init(union anonymous$22 *, const union anonymous$20 *);
// pthread_rwlock_rdlock
// file /usr/include/pthread.h line 899
extern signed int pthread_rwlock_rdlock(union anonymous$22 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 929
extern signed int pthread_rwlock_unlock(union anonymous$22 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 914
extern signed int pthread_rwlock_wrlock(union anonymous$22 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$19 *, struct anonymous$19 *);
// pthread_spin_destroy
// file /usr/include/pthread.h line 1050
extern signed int pthread_spin_destroy(volatile signed int *);
// pthread_spin_init
// file /usr/include/pthread.h line 1046
extern signed int pthread_spin_init(volatile signed int *, signed int);
// pthread_spin_lock
// file /usr/include/pthread.h line 1054
extern signed int pthread_spin_lock(volatile signed int *);
// pthread_spin_unlock
// file /usr/include/pthread.h line 1062
extern signed int pthread_spin_unlock(volatile signed int *);
// queue_data
// file shout.c line 797
static signed int queue_data(struct anonymous$10 *queue, const unsigned char *data, unsigned long int len);
// queue_free
// file shout.c line 877
static inline void queue_free(struct anonymous$10 *queue);
// queue_printf
// file shout.c line 842
static signed int queue_printf(struct shout *self, const char *fmt, ...);
// queue_str
// file shout.c line 836
static inline signed int queue_str(struct shout *self, const char *str);
// read_chars
// file opus.c line 90
static signed int read_chars(struct anonymous$0 *p, unsigned char *str, signed int nb_chars);
// read_opus_page
// file opus.c line 235
static signed int read_opus_page(struct _ogg_codec_tag *codec, struct anonymous$7 *page);
// read_speex_page
// file speex.c line 64
static signed int read_speex_page(struct _ogg_codec_tag *codec, struct anonymous$7 *page);
// read_theora_page
// file theora.c line 81
static signed int read_theora_page(struct _ogg_codec_tag *codec, struct anonymous$7 *page);
// read_uint16
// file opus.c line 80
static signed int read_uint16(struct anonymous$0 *p, unsigned short int *val);
// read_uint32
// file opus.c line 68
static signed int read_uint32(struct anonymous$0 *p, unsigned int *val);
// read_vorbis_page
// file vorbis.c line 75
static signed int read_vorbis_page(struct _ogg_codec_tag *codec, struct anonymous$7 *page);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$12 *, struct anonymous$12 *, struct anonymous$12 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// send_mp3
// file mp3.c line 117
static signed int send_mp3(struct shout *self, const unsigned char *buff, unsigned long int len);
// send_ogg
// file ogg.c line 84
static signed int send_ogg(struct shout *self, const unsigned char *data, unsigned long int len);
// send_page
// file ogg.c line 193
static signed int send_page(struct shout *self, struct anonymous$7 *page);
// send_queue
// file shout.c line 1070
static signed int send_queue(struct shout *self);
// send_webm
// file webm.c line 53
static signed int send_webm(struct shout *self, const unsigned char *data, unsigned long int len);
// sethostent
// file /usr/include/netdb.h line 117
extern void sethostent(signed int);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shout_close
// file ../include/shout/shout.h line 152
signed int shout_close(struct shout *self);
// shout_delay
// file shout.c line 265
signed int shout_delay(struct shout *self);
// shout_free
// file shout.c line 132
void shout_free(struct shout *self);
// shout_get_agent
// file shout.c line 606
const char * shout_get_agent(struct shout *self);
// shout_get_audio_info
// file shout.c line 695
const char * shout_get_audio_info(struct shout *self, const char *name);
// shout_get_connected
// file ../include/shout/shout.h line 90
signed int shout_get_connected(struct shout *self);
// shout_get_description
// file shout.c line 657
const char * shout_get_description(struct shout *self);
// shout_get_dumpfile
// file shout.c line 682
const char * shout_get_dumpfile(struct shout *self);
// shout_get_errno
// file shout.c line 351
signed int shout_get_errno(struct shout *self);
// shout_get_error
// file ../include/shout/shout.h line 84
const char * shout_get_error(struct shout *self);
// shout_get_format
// file shout.c line 739
unsigned int shout_get_format(struct shout *self);
// shout_get_genre
// file shout.c line 581
const char * shout_get_genre(struct shout *self);
// shout_get_host
// file shout.c line 427
const char * shout_get_host(struct shout *self);
// shout_get_mount
// file shout.c line 506
const char * shout_get_mount(struct shout *self);
// shout_get_name
// file shout.c line 531
const char * shout_get_name(struct shout *self);
// shout_get_nonblocking
// file shout.c line 786
unsigned int shout_get_nonblocking(struct shout *self);
// shout_get_password
// file shout.c line 473
const char * shout_get_password(struct shout *self);
// shout_get_port
// file shout.c line 448
unsigned short int shout_get_port(struct shout *self);
// shout_get_protocol
// file shout.c line 765
unsigned int shout_get_protocol(struct shout *self);
// shout_get_public
// file shout.c line 713
unsigned int shout_get_public(struct shout *self);
// shout_get_url
// file shout.c line 556
const char * shout_get_url(struct shout *self);
// shout_get_user
// file shout.c line 632
const char * shout_get_user(struct shout *self);
// shout_init
// file ../include/shout/shout.h line 65
void shout_init(void);
// shout_metadata_add
// file shout.c line 290
signed int shout_metadata_add(struct _util_dict *self, const char *name, const char *value);
// shout_metadata_free
// file shout.c line 282
void shout_metadata_free(struct _util_dict *self);
// shout_metadata_new
// file shout.c line 277
struct _util_dict * shout_metadata_new(void);
// shout_new
// file ../include/shout/shout.h line 77
struct shout * shout_new(void);
// shout_open
// file ../include/shout/shout.h line 149
signed int shout_open(struct shout *self);
// shout_open_mp3
// file shout_private.h line 111
signed int shout_open_mp3(struct shout *self);
// shout_open_ogg
// file shout_private.h line 110
signed int shout_open_ogg(struct shout *self);
// shout_open_webm
// file webm.c line 44
signed int shout_open_webm(struct shout *self);
// shout_queuelen
// file ../include/shout/shout.h line 165
signed long int shout_queuelen(struct shout *self);
// shout_send
// file ../include/shout/shout.h line 155
signed int shout_send(struct shout *self, const unsigned char *data, unsigned long int len);
// shout_send_raw
// file shout.c line 204
signed long int shout_send_raw(struct shout *self, const unsigned char *data, unsigned long int len);
// shout_set_agent
// file shout.c line 589
signed int shout_set_agent(struct shout *self, const char *agent);
// shout_set_audio_info
// file shout.c line 690
signed int shout_set_audio_info(struct shout *self, const char *name, const char *value);
// shout_set_description
// file shout.c line 640
signed int shout_set_description(struct shout *self, const char *description);
// shout_set_dumpfile
// file shout.c line 665
signed int shout_set_dumpfile(struct shout *self, const char *dumpfile);
// shout_set_format
// file ../include/shout/shout.h line 136
signed int shout_set_format(struct shout *self, unsigned int format);
// shout_set_genre
// file shout.c line 564
signed int shout_set_genre(struct shout *self, const char *genre);
// shout_set_host
// file ../include/shout/shout.h line 96
signed int shout_set_host(struct shout *self, const char *host);
// shout_set_metadata
// file shout.c line 300
signed int shout_set_metadata(struct shout *self, struct _util_dict *metadata);
// shout_set_mount
// file ../include/shout/shout.h line 105
signed int shout_set_mount(struct shout *self, const char *mount);
// shout_set_name
// file shout.c line 514
signed int shout_set_name(struct shout *self, const char *name);
// shout_set_nonblocking
// file ../include/shout/shout.h line 145
signed int shout_set_nonblocking(struct shout *self, unsigned int nonblocking);
// shout_set_password
// file ../include/shout/shout.h line 102
signed int shout_set_password(struct shout *self, const char *password);
// shout_set_port
// file ../include/shout/shout.h line 99
signed int shout_set_port(struct shout *self, unsigned short int port);
// shout_set_protocol
// file ../include/shout/shout.h line 140
signed int shout_set_protocol(struct shout *self, unsigned int protocol);
// shout_set_public
// file shout.c line 700
signed int shout_set_public(struct shout *self, unsigned int public);
// shout_set_url
// file shout.c line 539
signed int shout_set_url(struct shout *self, const char *url);
// shout_set_user
// file ../include/shout/shout.h line 117
signed int shout_set_user(struct shout *self, const char *username);
// shout_shutdown
// file ../include/shout/shout.h line 69
void shout_shutdown(void);
// shout_sync
// file ../include/shout/shout.h line 168
void shout_sync(struct shout *self);
// shout_version
// file shout.c line 339
const char * shout_version(signed int *major, signed int *minor, signed int *patch);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous$19 *, signed int);
// sigdelset
// file /usr/include/signal.h line 224
extern signed int sigdelset(struct anonymous$19 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$19 *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous$19 *);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sock_active
// file sock.c line 212
signed int sock_active(signed int sock);
// sock_connect_pending
// file sock.c line 188
static signed int sock_connect_pending(signed int error);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// speex_packet_to_header
// file /usr/include/speex/speex_header.h line 84
struct SpeexHeader * speex_packet_to_header(char *, signed int);
// split_headers
// file httpp.c line 62
static signed int split_headers(char *data, unsigned long int len, char **line);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// theora_comment_clear
// file /usr/include/theora/theora.h line 766
extern void theora_comment_clear(struct theora_comment *);
// theora_comment_init
// file /usr/include/theora/theora.h line 704
extern void theora_comment_init(struct theora_comment *);
// theora_decode_header
// file /usr/include/theora/theora.h line 557
extern signed int theora_decode_header(struct anonymous$5 *, struct theora_comment *, struct anonymous$2 *);
// theora_ilog
// file theora.c line 142
static signed int theora_ilog(unsigned int v);
// theora_info_clear
// file /usr/include/theora/theora.h line 692
extern void theora_info_clear(struct anonymous$5 *);
// theora_info_init
// file /usr/include/theora/theora.h line 685
extern void theora_info_init(struct anonymous$5 *);
// thread_spin_create
// file thread.c line 817
void thread_spin_create(struct anonymous$27 *spin);
// thread_spin_destroy
// file thread.c line 824
void thread_spin_destroy(struct anonymous$27 *spin);
// thread_spin_lock
// file thread.c line 829
void thread_spin_lock(struct anonymous$27 *spin);
// thread_spin_unlock
// file thread.c line 836
void thread_spin_unlock(struct anonymous$27 *spin);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// try_connect
// file shout.c line 936
static signed int try_connect(struct shout *self);
// try_write
// file shout.c line 1022
static signed int try_write(struct shout *self, const void *data_p, unsigned long int len);
// url_escape
// file httpp.c line 204
static char * url_escape(const char *src);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vorbis_blocksize
// file vorbis.c line 108
static signed int vorbis_blocksize(struct anonymous$30 *vd, struct anonymous$2 *p);
// vorbis_comment_clear
// file /usr/include/vorbis/codec.h line 174
extern void vorbis_comment_clear(struct vorbis_comment *);
// vorbis_comment_init
// file /usr/include/vorbis/codec.h line 168
extern void vorbis_comment_init(struct vorbis_comment *);
// vorbis_info_clear
// file /usr/include/vorbis/codec.h line 166
extern void vorbis_info_clear(struct vorbis_info *);
// vorbis_info_init
// file /usr/include/vorbis/codec.h line 165
extern void vorbis_info_init(struct vorbis_info *);
// vorbis_packet_blocksize
// file /usr/include/vorbis/codec.h line 215
extern signed long int vorbis_packet_blocksize(struct vorbis_info *, struct anonymous$2 *);
// vorbis_synthesis_headerin
// file /usr/include/vorbis/codec.h line 204
extern signed int vorbis_synthesis_headerin(struct vorbis_info *, struct vorbis_comment *, struct anonymous$2 *);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// writev
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 50
extern signed long int writev(signed int, struct iovec *, signed int);

struct anonymous$11
{
  // sh
  struct SpeexHeader *sh;
};

struct anonymous$10
{
  // head
  struct _shout_buf *head;
  // len
  unsigned long int len;
};

struct anonymous$15
{
  // body_data
  unsigned char *body_data;
  // body_storage
  signed long int body_storage;
  // body_fill
  signed long int body_fill;
  // body_returned
  signed long int body_returned;
  // lacing_vals
  signed int *lacing_vals;
  // granule_vals
  signed long int *granule_vals;
  // lacing_storage
  signed long int lacing_storage;
  // lacing_fill
  signed long int lacing_fill;
  // lacing_packet
  signed long int lacing_packet;
  // lacing_returned
  signed long int lacing_returned;
  // header
  unsigned char header[282l];
  // header_fill
  signed int header_fill;
  // e_o_s
  signed int e_o_s;
  // b_o_s
  signed int b_o_s;
  // serialno
  signed long int serialno;
  // pageno
  signed long int pageno;
  // packetno
  signed long int packetno;
  // granulepos
  signed long int granulepos;
};

struct anonymous$16
{
  // data
  unsigned char *data;
  // storage
  signed int storage;
  // fill
  signed int fill;
  // returned
  signed int returned;
  // unsynced
  signed int unsynced;
  // headerbytes
  signed int headerbytes;
  // bodybytes
  signed int bodybytes;
};

struct anonymous$7
{
  // header
  unsigned char *header;
  // header_len
  signed long int header_len;
  // body
  unsigned char *body;
  // body_len
  signed long int body_len;
};

struct anonymous$2
{
  // packet
  unsigned char *packet;
  // bytes
  signed long int bytes;
  // b_o_s
  signed long int b_o_s;
  // e_o_s
  signed long int e_o_s;
  // granulepos
  signed long int granulepos;
  // packetno
  signed long int packetno;
};

struct anonymous$0
{
  // data
  const unsigned char *data;
  // maxlen
  signed int maxlen;
  // pos
  signed int pos;
};

struct anonymous$12
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$19
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$23
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$21
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

struct anonymous$32
{
  // syncword
  signed int syncword;
  // layer
  signed int layer;
  // version
  signed int version;
  // error_protection
  signed int error_protection;
  // bitrate_index
  signed int bitrate_index;
  // samplerate_index
  signed int samplerate_index;
  // padding
  signed int padding;
  // extension
  signed int extension;
  // mode
  signed int mode;
  // mode_ext
  signed int mode_ext;
  // copyright
  signed int copyright;
  // original
  signed int original;
  // emphasis
  signed int emphasis;
  // stereo
  signed int stereo;
  // bitrate
  signed int bitrate;
  // samplerate
  unsigned int samplerate;
  // samples
  unsigned int samples;
  // framesize
  unsigned int framesize;
};

struct anonymous
{
  // version
  signed int version;
  // channels
  signed int channels;
  // preskip
  signed int preskip;
  // input_sample_rate
  unsigned int input_sample_rate;
  // gain
  signed int gain;
  // channel_mapping
  signed int channel_mapping;
  // nb_streams
  signed int nb_streams;
  // nb_coupled
  signed int nb_coupled;
  // stream_map
  unsigned char stream_map[255l];
};

struct anonymous$18
{
  // thread_id
  signed long int thread_id;
  // name
  char *name;
  // create_time
  signed long int create_time;
  // file
  char *file;
  // line
  signed int line;
  // detached
  signed int detached;
  // sys_thread
  unsigned long int sys_thread;
};

struct anonymous$17
{
  // oy
  struct anonymous$16 oy;
  // codecs
  struct _ogg_codec_tag *codecs;
  // bos
  char bos;
};

struct anonymous$1
{
  // oh
  struct anonymous oh;
  // skipped
  signed int skipped;
};

struct anonymous$5
{
  // width
  unsigned int width;
  // height
  unsigned int height;
  // frame_width
  unsigned int frame_width;
  // frame_height
  unsigned int frame_height;
  // offset_x
  unsigned int offset_x;
  // offset_y
  unsigned int offset_y;
  // fps_numerator
  unsigned int fps_numerator;
  // fps_denominator
  unsigned int fps_denominator;
  // aspect_numerator
  unsigned int aspect_numerator;
  // aspect_denominator
  unsigned int aspect_denominator;
  // colorspace
  enum anonymous$3 colorspace;
  // target_bitrate
  signed int target_bitrate;
  // quality
  signed int quality;
  // quick_p
  signed int quick_p;
  // version_major
  unsigned char version_major;
  // version_minor
  unsigned char version_minor;
  // version_subminor
  unsigned char version_subminor;
  // codec_setup
  void *codec_setup;
  // dropframes_p
  signed int dropframes_p;
  // keyframe_auto_p
  signed int keyframe_auto_p;
  // keyframe_frequency
  unsigned int keyframe_frequency;
  // keyframe_frequency_force
  unsigned int keyframe_frequency_force;
  // keyframe_data_target_bitrate
  unsigned int keyframe_data_target_bitrate;
  // keyframe_auto_threshold
  signed int keyframe_auto_threshold;
  // keyframe_mindistance
  unsigned int keyframe_mindistance;
  // noise_sensitivity
  signed int noise_sensitivity;
  // sharpness
  signed int sharpness;
  // pixelformat
  enum anonymous$4 pixelformat;
};

struct theora_comment
{
  // user_comments
  char **user_comments;
  // comment_lengths
  signed int *comment_lengths;
  // comments
  signed int comments;
  // vendor
  char *vendor;
};

struct anonymous$6
{
  // ti
  struct anonymous$5 ti;
  // tc
  struct theora_comment tc;
  // granule_shift
  unsigned int granule_shift;
  // per_frame
  double per_frame;
  // start_frame
  unsigned long int start_frame;
  // initial_frames
  signed int initial_frames;
  // get_start_frame
  signed int get_start_frame;
};

union anonymous$22
{
  // __data
  struct anonymous$21 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct anonymous$8
{
  // sys_rwlock
  union anonymous$22 sys_rwlock;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$25
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$24
{
  // __data
  struct anonymous$23 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct anonymous$26
{
  // cond_mutex
  union anonymous$25 cond_mutex;
  // sys_cond
  union anonymous$24 sys_cond;
};

struct anonymous$31
{
  // sys_mutex
  union anonymous$25 sys_mutex;
};

struct vorbis_info
{
  // version
  signed int version;
  // channels
  signed int channels;
  // rate
  signed long int rate;
  // bitrate_upper
  signed long int bitrate_upper;
  // bitrate_nominal
  signed long int bitrate_nominal;
  // bitrate_lower
  signed long int bitrate_lower;
  // bitrate_window
  signed long int bitrate_window;
  // codec_setup
  void *codec_setup;
};

struct vorbis_comment
{
  // user_comments
  char **user_comments;
  // comment_lengths
  signed int *comment_lengths;
  // comments
  signed int comments;
  // vendor
  char *vendor;
};

struct anonymous$30
{
  // vi
  struct vorbis_info vi;
  // vc
  struct vorbis_comment vc;
  // prevW
  signed int prevW;
};

struct anonymous$33
{
  // frames
  unsigned int frames;
  // frame_samples
  signed int frame_samples;
  // frame_samplerate
  signed int frame_samplerate;
  // frame_left
  unsigned int frame_left;
  // header_bridges
  signed int header_bridges;
  // header_bridge
  unsigned char header_bridge[3l];
};

struct anonymous$27
{
  // lock
  volatile signed int lock;
};

union anonymous$13
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$28
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$20
{
  // __size
  char __size[8l];
  // __align
  signed long int __align;
};

union anonymous$29
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$14
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct SpeexHeader
{
  // speex_string
  char speex_string[8l];
  // speex_version
  char speex_version[20l];
  // speex_version_id
  signed int speex_version_id;
  // header_size
  signed int header_size;
  // rate
  signed int rate;
  // mode
  signed int mode;
  // mode_bitstream_version
  signed int mode_bitstream_version;
  // nb_channels
  signed int nb_channels;
  // bitrate
  signed int bitrate;
  // frame_size
  signed int frame_size;
  // vbr
  signed int vbr;
  // frames_per_packet
  signed int frames_per_packet;
  // extra_headers
  signed int extra_headers;
  // reserved1
  signed int reserved1;
  // reserved2
  signed int reserved2;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _avl_tree
{
  // root
  struct avl_node_tag *root;
  // height
  unsigned int height;
  // length
  unsigned int length;
  // compare_fun
  signed int (*compare_fun)(void *, void *, void *);
  // compare_arg
  void *compare_arg;
  // rwlock
  struct anonymous$8 rwlock;
};

struct _link_node
{
  // parent
  struct _link_node *parent;
  // direction
  char direction;
  // width
  signed int width;
};

struct _ogg_codec_tag
{
  // os
  struct anonymous$15 os;
  // headers
  unsigned int headers;
  // senttime
  unsigned long int senttime;
  // codec_data
  void *codec_data;
  // read_page
  signed int (*read_page)(struct _ogg_codec_tag *, struct anonymous$7 *);
  // free_data
  void (*free_data)(void *);
  // next
  struct _ogg_codec_tag *next;
};

struct _shout_buf
{
  // data
  unsigned char data[4096l];
  // len
  unsigned int len;
  // pos
  unsigned int pos;
  // prev
  struct _shout_buf *prev;
  // next
  struct _shout_buf *next;
};

struct _util_dict
{
  // key
  char *key;
  // val
  char *val;
  // next
  struct _util_dict *next;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct avl_node_tag
{
  // key
  void *key;
  // left
  struct avl_node_tag *left;
  // right
  struct avl_node_tag *right;
  // parent
  struct avl_node_tag *parent;
  // rank_and_balance
  unsigned int rank_and_balance;
};

struct http_parser_tag
{
  // req_type
  enum httpp_request_type_tag req_type;
  // uri
  char *uri;
  // vars
  struct _avl_tree *vars;
  // queryvars
  struct _avl_tree *queryvars;
};

struct http_var_tag
{
  // name
  char *name;
  // value
  char *value;
};

struct http_varlist_tag
{
  // var
  struct http_var_tag var;
  // next
  struct http_varlist_tag *next;
};

struct in6_addr
{
  // __in6_u
  union anonymous$13 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct linger
{
  // l_onoff
  signed int l_onoff;
  // l_linger
  signed int l_linger;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct shout
{
  // host
  char *host;
  // port
  signed int port;
  // password
  char *password;
  // protocol
  unsigned int protocol;
  // format
  unsigned int format;
  // audio_info
  struct _util_dict *audio_info;
  // useragent
  char *useragent;
  // mount
  char *mount;
  // name
  char *name;
  // url
  char *url;
  // genre
  char *genre;
  // description
  char *description;
  // dumpfile
  char *dumpfile;
  // user
  char *user;
  // public
  signed int public;
  // socket
  signed int socket;
  // state
  enum anonymous$9 state;
  // nonblocking
  signed int nonblocking;
  // format_data
  void *format_data;
  // send
  signed int (*send)(struct shout *, const unsigned char *, unsigned long int);
  // close
  void (*close)(struct shout *);
  // rqueue
  struct anonymous$10 rqueue;
  // wqueue
  struct anonymous$10 wqueue;
  // starttime
  unsigned long int starttime;
  // senttime
  unsigned long int senttime;
  // error
  signed int error;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

struct thread_start_tag
{
  // start_routine
  void * (*start_routine)(void *);
  // arg
  void *arg;
  // thread
  struct anonymous$18 *thread;
  // sys_thread
  unsigned long int sys_thread;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};


// _initialized
// file shout.c line 70
static signed int _initialized = 0;
// _initialized$link1
// file resolver.c line 59
static signed int _initialized$link1 = 0;
// _initialized$link2
// file thread.c line 87
static signed int _initialized$link2 = 0;
// _library_mutex
// file thread.c line 112
static struct anonymous$31 _library_mutex = { .sys_mutex={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } };
// _next_thread_id
// file thread.c line 86
static signed long int _next_thread_id = (signed long int)0;
// _resolver_mutex
// file resolver.c line 57
static struct anonymous$31 _resolver_mutex;
// _threadtree
// file thread.c line 88
static struct _avl_tree *_threadtree = (struct _avl_tree *)(void *)0;
// _threadtree_mutex
// file thread.c line 94
static struct anonymous$31 _threadtree_mutex = { .sys_mutex={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } };
// balance_chars
// file avl.c line 1072
static char balance_chars[3l] = { (char)92, (char)45, (char)47 };
// base64table
// file util.c line 77
static char base64table[65l] = { (char)65, (char)66, (char)67, (char)68, (char)69, (char)70, (char)71, (char)72, (char)73, (char)74, (char)75, (char)76, (char)77, (char)78, (char)79, (char)80, (char)81, (char)82, (char)83, (char)84, (char)85, (char)86, (char)87, (char)88, (char)89, (char)90, (char)97, (char)98, (char)99, (char)100, (char)101, (char)102, (char)103, (char)104, (char)105, (char)106, (char)107, (char)108, (char)109, (char)110, (char)111, (char)112, (char)113, (char)114, (char)115, (char)116, (char)117, (char)118, (char)119, (char)120, (char)121, (char)122, (char)48, (char)49, (char)50, (char)51, (char)52, (char)53, (char)54, (char)55, (char)56, (char)57, (char)43, (char)47, 0 };
// bitrate
// file mp3.c line 72
static const unsigned int bitrate[3l][3l][16l] = { { { (const unsigned int)0, (const unsigned int)32, (const unsigned int)64, (const unsigned int)96, (const unsigned int)128, (const unsigned int)160, (const unsigned int)192, (const unsigned int)224, (const unsigned int)256, (const unsigned int)288, (const unsigned int)320, (const unsigned int)352, (const unsigned int)384, (const unsigned int)416, (const unsigned int)448, (const unsigned int)0 }, 
    { (const unsigned int)0, (const unsigned int)32, (const unsigned int)48, (const unsigned int)56, (const unsigned int)64, (const unsigned int)80, (const unsigned int)96, (const unsigned int)112, (const unsigned int)128, (const unsigned int)160, (const unsigned int)192, (const unsigned int)224, (const unsigned int)256, (const unsigned int)320, (const unsigned int)384, (const unsigned int)0 }, 
    { (const unsigned int)0, (const unsigned int)32, (const unsigned int)40, (const unsigned int)48, (const unsigned int)56, (const unsigned int)64, (const unsigned int)80, (const unsigned int)96, (const unsigned int)112, (const unsigned int)128, (const unsigned int)160, (const unsigned int)192, (const unsigned int)224, (const unsigned int)256, (const unsigned int)320, (const unsigned int)0 } }, 
    { { (const unsigned int)0, (const unsigned int)32, (const unsigned int)48, (const unsigned int)56, (const unsigned int)64, (const unsigned int)80, (const unsigned int)96, (const unsigned int)112, (const unsigned int)128, (const unsigned int)144, (const unsigned int)160, (const unsigned int)176, (const unsigned int)192, (const unsigned int)224, (const unsigned int)256, (const unsigned int)0 }, 
    { (const unsigned int)0, (const unsigned int)8, (const unsigned int)16, (const unsigned int)24, (const unsigned int)32, (const unsigned int)40, (const unsigned int)48, (const unsigned int)56, (const unsigned int)64, (const unsigned int)80, (const unsigned int)96, (const unsigned int)112, (const unsigned int)128, (const unsigned int)144, (const unsigned int)160, (const unsigned int)0 }, 
    { (const unsigned int)0, (const unsigned int)8, (const unsigned int)16, (const unsigned int)24, (const unsigned int)32, (const unsigned int)40, (const unsigned int)48, (const unsigned int)56, (const unsigned int)64, (const unsigned int)80, (const unsigned int)96, (const unsigned int)112, (const unsigned int)128, (const unsigned int)144, (const unsigned int)160, (const unsigned int)0 } }, 
    { { (const unsigned int)0, (const unsigned int)32, (const unsigned int)48, (const unsigned int)56, (const unsigned int)64, (const unsigned int)80, (const unsigned int)96, (const unsigned int)112, (const unsigned int)128, (const unsigned int)144, (const unsigned int)160, (const unsigned int)176, (const unsigned int)192, (const unsigned int)224, (const unsigned int)256, (const unsigned int)0 }, 
    { (const unsigned int)0, (const unsigned int)8, (const unsigned int)16, (const unsigned int)24, (const unsigned int)32, (const unsigned int)40, (const unsigned int)48, (const unsigned int)56, (const unsigned int)64, (const unsigned int)80, (const unsigned int)96, (const unsigned int)112, (const unsigned int)128, (const unsigned int)144, (const unsigned int)160, (const unsigned int)0 }, 
    { (const unsigned int)0, (const unsigned int)8, (const unsigned int)16, (const unsigned int)24, (const unsigned int)32, (const unsigned int)40, (const unsigned int)48, (const unsigned int)56, (const unsigned int)64, (const unsigned int)80, (const unsigned int)96, (const unsigned int)112, (const unsigned int)128, (const unsigned int)144, (const unsigned int)160, (const unsigned int)0 } } };
// codecs
// file ogg.c line 55
static signed int (*codecs[5l])(struct _ogg_codec_tag *, struct anonymous$7 *);
// codecs
// file ogg.c line 55
static signed int (*codecs[5l])(struct _ogg_codec_tag *, struct anonymous$7 *) = { _shout_open_vorbis, _shout_open_theora, _shout_open_opus, _shout_open_speex, (signed int (*)(struct _ogg_codec_tag *, struct anonymous$7 *))(void *)0 };
// safechars
// file util.c line 123
static char safechars[256l] = { (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)1, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0 };
// samplerate
// file mp3.c line 89
static const unsigned int samplerate[3l][4l] = { { (const unsigned int)44100, (const unsigned int)48000, (const unsigned int)32000, (const unsigned int)0 }, 
    { (const unsigned int)22050, (const unsigned int)24000, (const unsigned int)16000, (const unsigned int)0 }, 
    { (const unsigned int)11025, (const unsigned int)8000, (const unsigned int)8000, (const unsigned int)0 } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// urltable
// file util.c line 119
static char urltable[16l] = { (char)48, (char)49, (char)50, (char)51, (char)52, (char)53, (char)54, (char)55, (char)56, (char)57, (char)97, (char)98, (char)99, (char)100, (char)101, (char)102 };

// _block_signals
// file thread.c line 215
static void _block_signals(void)
{
  struct anonymous$19 ss;
  sigfillset(&ss);
  sigdelset(&ss, 9);
  sigdelset(&ss, 19);
  sigdelset(&ss, 11);
  sigdelset(&ss, 17);
  sigdelset(&ss, 7);
  signed int return_value_pthread_sigmask$1;
  return_value_pthread_sigmask$1=pthread_sigmask(0, &ss, (struct anonymous$19 *)(void *)0);
}

// _catch_signals
// file thread.c line 241
static void _catch_signals(void)
{
  struct anonymous$19 ss;
  sigemptyset(&ss);
  sigaddset(&ss, 1);
  sigaddset(&ss, 17);
  sigaddset(&ss, 2);
  sigaddset(&ss, 13);
  sigaddset(&ss, 15);
  signed int return_value_pthread_sigmask$1;
  return_value_pthread_sigmask$1=pthread_sigmask(1, &ss, (struct anonymous$19 *)(void *)0);
}

// _compare_threads
// file thread.c line 767
static signed int _compare_threads(void *compare_arg, void *a, void *b)
{
  struct anonymous$18 *t1;
  struct anonymous$18 *t2;
  t1 = (struct anonymous$18 *)a;
  t2 = (struct anonymous$18 *)b;
  if(!(t2->thread_id >= t1->thread_id))
    return 1;

  else
    if(!(t1->thread_id >= t2->thread_id))
      return -1;

    else
      return 0;
}

// _compare_vars
// file httpp.c line 543
static signed int _compare_vars(void *compare_arg, void *a, void *b)
{
  struct http_var_tag *vara;
  struct http_var_tag *varb;
  vara = (struct http_var_tag *)a;
  varb = (struct http_var_tag *)b;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(vara->name, varb->name);
  return return_value_strcmp$1;
}

// _free_thread
// file thread.c line 799
static signed int _free_thread(void *key)
{
  struct anonymous$18 *t = (struct anonymous$18 *)key;
  if(!(t->file == ((char *)NULL)))
    free((void *)t->file);

  if(!(t->name == ((char *)NULL)))
    free((void *)t->name);

  free((void *)t);
  return 1;
}

// _free_vars
// file httpp.c line 553
static signed int _free_vars(void *key)
{
  struct http_var_tag *var = (struct http_var_tag *)key;
  if(!(var->name == ((char *)NULL)))
    free((void *)var->name);

  if(!(var->value == ((char *)NULL)))
    free((void *)var->value);

  free((void *)var);
  return 1;
}

// _isip
// file resolver.c line 62
static signed int _isip(const char *what)
{
  /* tag-#anon#lUN[lSYM#tag-in_addr#'v4addr'||lSYM#tag-in6_addr#'v6addr'|] */
union anonymous$34
{
  // v4addr
  struct in_addr v4addr;
  // v6addr
  struct in6_addr v6addr;
};

/* */
  ;
  union anonymous$34 addr_u;
  signed int return_value_inet_pton$2;
  return_value_inet_pton$2=inet_pton(2, what, (void *)&addr_u.v4addr);
  signed int return_value_inet_pton$1;
  if(!(return_value_inet_pton$2 >= 1))
  {
    return_value_inet_pton$1=inet_pton(10, what, (void *)&addr_u.v6addr);
    return return_value_inet_pton$1 > 0 ? 1 : 0;
  }

  else
    return 1;
}

// _lowercase
// file httpp.c line 534
static char * _lowercase(char *str)
{
  char *p = str;
  signed int return_value_tolower$1;
  for( ; !((signed int)*p == 0); p = p + 1l)
  {
    return_value_tolower$1=tolower((signed int)*p);
    *p = (char)return_value_tolower$1;
  }
  return str;
}

// _mutex_create
// file thread.c line 326
static void _mutex_create(struct anonymous$31 *mutex)
{
  pthread_mutex_init(&mutex->sys_mutex, (const union anonymous$28 *)(void *)0);
}

// _mutex_lock
// file thread.c line 717
static void _mutex_lock(struct anonymous$31 *mutex)
{
  pthread_mutex_lock(&mutex->sys_mutex);
}

// _mutex_unlock
// file thread.c line 722
static void _mutex_unlock(struct anonymous$31 *mutex)
{
  pthread_mutex_unlock(&mutex->sys_mutex);
}

// _shout_avl_delete
// file avl.c line 351
signed int _shout_avl_delete(struct _avl_tree *tree, void *key, signed int (*free_key_fun)(void *))
{
  struct avl_node_tag *x;
  struct avl_node_tag *y;
  struct avl_node_tag *p;
  struct avl_node_tag *q;
  struct avl_node_tag *r;
  struct avl_node_tag *top;
  struct avl_node_tag *x_child;
  signed int shortened_side;
  signed int shorter;
  x = tree->root->right;
  if(x == ((struct avl_node_tag *)NULL))
    return -1;

  else
  {
    {
      signed int compare_result;
      compare_result=tree->compare_fun(tree->compare_arg, key, x->key);
      if(!(compare_result >= 0))
      {
        x->rank_and_balance = x->rank_and_balance & (unsigned int)3 | (x->rank_and_balance >> 2) - (unsigned int)1 << 2;
        if(!(x->left == ((struct avl_node_tag *)NULL)))
          x = x->left;

        else
        {
          x->rank_and_balance = x->rank_and_balance & (unsigned int)3 | (x->rank_and_balance >> 2) + (unsigned int)1 << 2;
          if(!(x == tree->root->right))
          {
            if(x->parent->left == x)
              x->parent->rank_and_balance = x->parent->rank_and_balance & (unsigned int)3 | (x->parent->rank_and_balance >> 2) + (unsigned int)1 << 2;

            x = x->parent;
          }

          return -1;
        }
      }

      else
        if(compare_result >= 1)
        {
          if(!(x->right == ((struct avl_node_tag *)NULL)))
            x = x->right;

          else
          {
            x->rank_and_balance = x->rank_and_balance & (unsigned int)3 | (x->rank_and_balance >> 2) + (unsigned int)1 << 2;
            if(!(x == tree->root->right))
            {
              if(x->parent->left == x)
                x->parent->rank_and_balance = x->parent->rank_and_balance & (unsigned int)3 | (x->parent->rank_and_balance >> 2) + (unsigned int)1 << 2;

              x = x->parent;
            }

            return -1;
          }
        }

    }
    if(!(x->left == ((struct avl_node_tag *)NULL)))
    {
      if(!(x->right == ((struct avl_node_tag *)NULL)))
      {
        void *temp_key;
        y = x->left;
        for( ; !(y->right == ((struct avl_node_tag *)NULL)); y = y->right)
          ;
        temp_key = x->key;
        x->key = y->key;
        y->key = temp_key;
        x->rank_and_balance = x->rank_and_balance & (unsigned int)3 | (x->rank_and_balance >> 2) - (unsigned int)1 << 2;
        x = y;
      }

    }

    if(!(x->left == ((struct avl_node_tag *)NULL)))
    {
      x_child = x->left;
      x_child->parent = x->parent;
    }

    else
      if(!(x->right == ((struct avl_node_tag *)NULL)))
      {
        x_child = x->right;
        x_child->parent = x->parent;
      }

      else
        x_child = (struct avl_node_tag *)(void *)0;
    if(x == x->parent->left)
    {
      x->parent->left = x_child;
      shortened_side = -1;
    }

    else
    {
      x->parent->right = x_child;
      shortened_side = +1;
    }
    shorter = 1;
    p = x->parent;
    if(!(free_key_fun == ((signed int (*)(void *))NULL)))
      free_key_fun(x->key);

    free((void *)x);
    while(!(shorter == 0))
    {
      if(p->parent == ((struct avl_node_tag *)NULL))
        break;

      if((3 & (signed int)p->rank_and_balance) == 1)
      {
        if(shortened_side == -1)
          p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(+1 + 1);

        else
          p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(-1 + 1);
        shorter = 0;
      }

      else
        if((3 & (signed int)p->rank_and_balance) + -1 == shortened_side)
          p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);

        else
        {
          top = p->parent;
          if(shortened_side == 1)
            q = p->left;

          else
            q = p->right;
          if((3 & (signed int)q->rank_and_balance) == 1)
          {
            if(shortened_side == -1)
            {
              q->parent = p->parent;
              p->right = q->left;
              if(!(q->left == ((struct avl_node_tag *)NULL)))
                q->left->parent = p;

              q->left = p;
              p->parent = q;
              q->rank_and_balance = q->rank_and_balance & (unsigned int)3 | (q->rank_and_balance >> 2) + (p->rank_and_balance >> 2) << 2;
            }

            else
            {
              q->parent = p->parent;
              p->left = q->right;
              if(!(q->right == ((struct avl_node_tag *)NULL)))
                q->right->parent = p;

              q->right = p;
              p->parent = q;
              p->rank_and_balance = p->rank_and_balance & (unsigned int)3 | (p->rank_and_balance >> 2) - (q->rank_and_balance >> 2) << 2;
            }
            shorter = 0;
            q->rank_and_balance = q->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(shortened_side + 1);
            p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(-shortened_side + 1);
          }

          else
            if((3 & (signed int)q->rank_and_balance) == (3 & (signed int)p->rank_and_balance))
            {
              if(shortened_side == -1)
              {
                q->parent = p->parent;
                p->right = q->left;
                if(!(q->left == ((struct avl_node_tag *)NULL)))
                  q->left->parent = p;

                q->left = p;
                p->parent = q;
                q->rank_and_balance = q->rank_and_balance & (unsigned int)3 | (q->rank_and_balance >> 2) + (p->rank_and_balance >> 2) << 2;
              }

              else
              {
                q->parent = p->parent;
                p->left = q->right;
                if(!(q->right == ((struct avl_node_tag *)NULL)))
                  q->right->parent = p;

                q->right = p;
                p->parent = q;
                p->rank_and_balance = p->rank_and_balance & (unsigned int)3 | (p->rank_and_balance >> 2) - (q->rank_and_balance >> 2) << 2;
              }
              shorter = 1;
              q->rank_and_balance = q->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
              p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
            }

            else
            {
              if(shortened_side == 1)
              {
                r = q->right;
                r->parent = p->parent;
                q->right = r->left;
                if(!(r->left == ((struct avl_node_tag *)NULL)))
                  r->left->parent = q;

                r->left = q;
                q->parent = r;
                p->left = r->right;
                if(!(r->right == ((struct avl_node_tag *)NULL)))
                  r->right->parent = p;

                r->right = p;
                p->parent = r;
                r->rank_and_balance = r->rank_and_balance & (unsigned int)3 | (r->rank_and_balance >> 2) + (q->rank_and_balance >> 2) << 2;
                p->rank_and_balance = p->rank_and_balance & (unsigned int)3 | (p->rank_and_balance >> 2) - (r->rank_and_balance >> 2) << 2;
              }

              else
              {
                r = q->left;
                r->parent = p->parent;
                q->left = r->right;
                if(!(r->right == ((struct avl_node_tag *)NULL)))
                  r->right->parent = q;

                r->right = q;
                q->parent = r;
                p->right = r->left;
                if(!(r->left == ((struct avl_node_tag *)NULL)))
                  r->left->parent = p;

                r->left = p;
                p->parent = r;
                q->rank_and_balance = q->rank_and_balance & (unsigned int)3 | (q->rank_and_balance >> 2) - (r->rank_and_balance >> 2) << 2;
                r->rank_and_balance = r->rank_and_balance & (unsigned int)3 | (r->rank_and_balance >> 2) + (p->rank_and_balance >> 2) << 2;
              }
              if((3 & (signed int)r->rank_and_balance) + -1 == shortened_side)
              {
                q->rank_and_balance = q->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(-shortened_side + 1);
                p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
              }

              else
                if((3 & (signed int)r->rank_and_balance) + -1 == -shortened_side)
                {
                  q->rank_and_balance = q->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
                  p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(shortened_side + 1);
                }

                else
                {
                  q->rank_and_balance = q->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
                  p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
                }
              r->rank_and_balance = r->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
              q = r;
            }
          if(top->left == p)
            top->left = q;

          else
            top->right = q;
          p = q;
        }
      x = p;
      p = x->parent;
      if(x == p->left)
        shortened_side = -1;

      else
        shortened_side = +1;
    }
    tree->length = tree->length - (unsigned int)1;
    return 0;
  }
}

// _shout_avl_get_by_index
// file avl.c line 299
signed int _shout_avl_get_by_index(struct _avl_tree *tree, unsigned long int index, void **value_address)
{
  struct avl_node_tag *p = tree->root->right;
  unsigned long int m = index + (unsigned long int)1;
  while((_Bool)1)
  {
    if(p == ((struct avl_node_tag *)NULL))
      return -1;

    if(!(m >= (unsigned long int)(p->rank_and_balance >> 2)))
      p = p->left;

    else
      if(!((unsigned long int)(p->rank_and_balance >> 2) >= m))
      {
        m = m - (unsigned long int)(p->rank_and_balance >> 2);
        p = p->right;
      }

      else
      {
        *value_address = p->key;
        return 0;
      }
  }
}

// _shout_avl_get_by_key
// file avl.c line 322
signed int _shout_avl_get_by_key(struct _avl_tree *tree, void *key, void **value_address)
{
  struct avl_node_tag *x = tree->root->right;
  if(x == ((struct avl_node_tag *)NULL))
    return -1;

  else
  {
    signed int compare_result;
    compare_result=tree->compare_fun(tree->compare_arg, key, x->key);
    if(!(compare_result >= 0))
    {
      if(!(x->left == ((struct avl_node_tag *)NULL)))
        x = x->left;

      else
        return -1;
    }

    else
      if(compare_result >= 1)
      {
        if(!(x->right == ((struct avl_node_tag *)NULL)))
          x = x->right;

        else
          return -1;
      }

      else
      {
        *value_address = x->key;
        return 0;
      }
  }
}

// _shout_avl_get_first
// file avl.c line 666
struct avl_node_tag * _shout_avl_get_first(struct _avl_tree *tree)
{
  struct avl_node_tag *node = tree->root->right;
  _Bool tmp_if_expr$1;
  if(node == ((struct avl_node_tag *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = node->key == (void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return (struct avl_node_tag *)(void *)0;

  else
  {
    for( ; !(node->left == ((struct avl_node_tag *)NULL)); node = node->left)
      ;
    return node;
  }
}

// _shout_avl_get_item_by_key_least
// file avl.c line 951
signed int _shout_avl_get_item_by_key_least(struct _avl_tree *tree, void *key, void **value_address)
{
  struct avl_node_tag *x = tree->root->right;
  *value_address = (void *)0;
  if(x == ((struct avl_node_tag *)NULL))
    return -1;

  else
  {
    signed int compare_result;
    compare_result=tree->compare_fun(tree->compare_arg, key, x->key);
    if(compare_result == 0)
    {
      *value_address = x->key;
      return 0;
    }

    else
      if(!(compare_result >= 0))
      {
        *value_address = x->key;
        if(!(x->left == ((struct avl_node_tag *)NULL)))
          x = x->left;

        else
          if(!(*value_address == NULL))
            return 0;

          else
            return -1;
      }

      else
        if(!(x->right == ((struct avl_node_tag *)NULL)))
          x = x->right;

        else
          if(!(*value_address == NULL))
            return 0;

          else
            return -1;
  }
}

// _shout_avl_get_item_by_key_most
// file avl.c line 907
signed int _shout_avl_get_item_by_key_most(struct _avl_tree *tree, void *key, void **value_address)
{
  struct avl_node_tag *x = tree->root->right;
  *value_address = (void *)0;
  if(x == ((struct avl_node_tag *)NULL))
    return -1;

  else
  {
    signed int compare_result;
    compare_result=tree->compare_fun(tree->compare_arg, key, x->key);
    if(compare_result == 0)
    {
      *value_address = x->key;
      return 0;
    }

    else
      if(!(compare_result >= 0))
      {
        if(!(x->left == ((struct avl_node_tag *)NULL)))
          x = x->left;

        else
          if(!(*value_address == NULL))
            return 0;

          else
            return -1;
      }

      else
      {
        *value_address = x->key;
        if(!(x->right == ((struct avl_node_tag *)NULL)))
          x = x->right;

        else
          if(!(*value_address == NULL))
            return 0;

          else
            return -1;
      }
  }
}

// _shout_avl_get_next
// file avl.c line 702
struct avl_node_tag * _shout_avl_get_next(struct avl_node_tag *node)
{
  if(!(node->right == ((struct avl_node_tag *)NULL)))
  {
    node = node->right;
    for( ; !(node->left == ((struct avl_node_tag *)NULL)); node = node->left)
      ;
    return node;
  }

  else
  {
    struct avl_node_tag *child = node;
    for( ; !(node->parent == ((struct avl_node_tag *)NULL)); child = node)
    {
      if(node->parent->key == NULL)
        break;

      node = node->parent;
      if(child == node->left)
        return node;

    }
    return (struct avl_node_tag *)(void *)0;
  }
}

// _shout_avl_get_prev
// file avl.c line 679
struct avl_node_tag * _shout_avl_get_prev(struct avl_node_tag *node)
{
  if(!(node->left == ((struct avl_node_tag *)NULL)))
  {
    node = node->left;
    for( ; !(node->right == ((struct avl_node_tag *)NULL)); node = node->right)
      ;
    return node;
  }

  else
  {
    struct avl_node_tag *child = node;
    for( ; !(node->parent == ((struct avl_node_tag *)NULL)); child = node)
    {
      if(node->parent->key == NULL)
        break;

      node = node->parent;
      if(child == node->right)
        return node;

    }
    return (struct avl_node_tag *)(void *)0;
  }
}

// _shout_avl_get_span_by_key
// file avl.c line 813
signed int _shout_avl_get_span_by_key(struct _avl_tree *tree, void *key, unsigned long int *low, unsigned long int *high)
{
  unsigned long int m;
  unsigned long int i;
  unsigned long int j;
  struct avl_node_tag *node;
  node=avl_get_index_by_key(tree, key, &m);
  signed int return_value;
  signed int return_value_1;
  if(!(node == ((struct avl_node_tag *)NULL)))
  {
    struct avl_node_tag *left;
    struct avl_node_tag *right;
    left=_shout_avl_get_prev(node);
    i = m;
    if(!(left == ((struct avl_node_tag *)NULL)))
    {
      if(i >= 1ul)
      {
        return_value=tree->compare_fun(tree->compare_arg, key, left->key);
        if(return_value == 0)
        {
          left=_shout_avl_get_prev(left);
          i = i - (unsigned long int)1;
        }

      }

    }

    right=_shout_avl_get_next(node);
    j = m;
    if(!(right == ((struct avl_node_tag *)NULL)))
    {
      if((unsigned long int)tree->length >= j)
      {
        return_value_1=tree->compare_fun(tree->compare_arg, key, right->key);
        if(return_value_1 == 0)
        {
          right=_shout_avl_get_next(right);
          j = j + (unsigned long int)1;
        }

      }

    }

    *low = i;
    *high = j + (unsigned long int)1;
    return 0;
  }

  else
  {
    *high = m;
    *low = *high;
  }
  return 0;
}

// _shout_avl_get_span_by_two_keys
// file avl.c line 856
signed int _shout_avl_get_span_by_two_keys(struct _avl_tree *tree, void *low_key, void *high_key, unsigned long int *low, unsigned long int *high)
{
  unsigned long int i;
  unsigned long int j;
  struct avl_node_tag *low_node;
  struct avl_node_tag *high_node;
  signed int order;
  order=tree->compare_fun(tree->compare_arg, low_key, high_key);
  if(order >= 1)
  {
    void *temp = low_key;
    low_key = high_key;
    high_key = temp;
  }

  low_node=avl_get_index_by_key(tree, low_key, &i);
  high_node=avl_get_index_by_key(tree, high_key, &j);
  signed int return_value;
  if(!(low_node == ((struct avl_node_tag *)NULL)))
  {
    struct avl_node_tag *left;
    left=_shout_avl_get_prev(low_node);
    if(!(left == ((struct avl_node_tag *)NULL)))
    {
      if(i >= 1ul)
      {
        return_value=tree->compare_fun(tree->compare_arg, low_key, left->key);
        if(return_value == 0)
        {
          left=_shout_avl_get_prev(left);
          i = i - (unsigned long int)1;
        }

      }

    }

  }

  else
    i = i + (unsigned long int)1;
  signed int return_value_1;
  if(!(high_node == ((struct avl_node_tag *)NULL)))
  {
    struct avl_node_tag *right;
    right=_shout_avl_get_next(high_node);
    if(!(right == ((struct avl_node_tag *)NULL)))
    {
      if((unsigned long int)tree->length >= j)
      {
        return_value_1=tree->compare_fun(tree->compare_arg, high_key, right->key);
        if(return_value_1 == 0)
        {
          right=_shout_avl_get_next(right);
          j = j + (unsigned long int)1;
        }

      }

    }

  }

  else
    j = j + (unsigned long int)1;
  *low = i;
  *high = j;
  return 0;
}

// _shout_avl_insert
// file avl.c line 123
signed int _shout_avl_insert(struct _avl_tree *ob, void *key)
{
  if(ob->root->right == ((struct avl_node_tag *)NULL))
  {
    struct avl_node_tag *node;
    node=_shout_avl_node_new(key, ob->root);
    if(node == ((struct avl_node_tag *)NULL))
      return -1;

    else
    {
      ob->root->right = node;
      ob->length = ob->length + (unsigned int)1;
      return 0;
    }
  }

  else
  {
    struct avl_node_tag *t;
    struct avl_node_tag *p;
    struct avl_node_tag *s;
    struct avl_node_tag *q;
    struct avl_node_tag *r;
    signed int a;
    t = ob->root;
    p = t->right;
    s = p;
    {
      signed int return_value;
      return_value=ob->compare_fun(ob->compare_arg, key, p->key);
      if(!(return_value >= 1))
      {
        p->rank_and_balance = p->rank_and_balance & (unsigned int)3 | (p->rank_and_balance >> 2) + (unsigned int)1 << 2;
        q = p->left;
        if(q == ((struct avl_node_tag *)NULL))
        {
          struct avl_node_tag *q_node;
          q_node=_shout_avl_node_new(key, p);
          if(q_node == ((struct avl_node_tag *)NULL))
            return -1;

          else
          {
            q = q_node;
            p->left = q;
          }
        }

        else
          if(!((3 & (signed int)q->rank_and_balance) == 1))
          {
            t = p;
            s = q;
          }

        p = q;
      }

      else
      {
        q = p->right;
        if(q == ((struct avl_node_tag *)NULL))
        {
          struct avl_node_tag *_shout_avl_insert$$1$$2$$1$$2$$1$$q_node;
          _shout_avl_insert$$1$$2$$1$$2$$1$$q_node=_shout_avl_node_new(key, p);
          if(_shout_avl_insert$$1$$2$$1$$2$$1$$q_node == ((struct avl_node_tag *)NULL))
            return -1;

          else
          {
            q = _shout_avl_insert$$1$$2$$1$$2$$1$$q_node;
            p->right = q;
          }
        }

        else
          if(!((3 & (signed int)q->rank_and_balance) == 1))
          {
            t = p;
            s = q;
          }

        p = q;
      }
    }
    ob->length = ob->length + (unsigned int)1;
    signed int return_value_1;
    return_value_1=ob->compare_fun(ob->compare_arg, key, s->key);
    if(!(return_value_1 >= 1))
    {
      p = s->left;
      r = p;
    }

    else
    {
      p = s->right;
      r = p;
    }
    if(!(p == q))
    {
      signed int return_value_2;
      return_value_2=ob->compare_fun(ob->compare_arg, key, p->key);
      if(!(return_value_2 >= 1))
      {
        p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(-1 + 1);
        p = p->left;
      }

      else
      {
        p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(+1 + 1);
        p = p->right;
      }
    }

    signed int return_value_3;
    return_value_3=ob->compare_fun(ob->compare_arg, key, s->key);
    if(!(return_value_3 >= 1))
      a = -1;

    else
      a = +1;
    if((3 & (signed int)s->rank_and_balance) == 1)
    {
      s->rank_and_balance = s->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(a + 1);
      ob->height = ob->height + (unsigned int)1;
      return 0;
    }

    else
      if((3 & (signed int)s->rank_and_balance) + -1 == -a)
      {
        s->rank_and_balance = s->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
        return 0;
      }

      else
        if((3 & (signed int)s->rank_and_balance) + -1 == a)
        {
          if((3 & (signed int)r->rank_and_balance) + -1 == a)
          {
            p = r;
            if(a == -1)
            {
              s->left = r->right;
              if(!(r->right == ((struct avl_node_tag *)NULL)))
                r->right->parent = s;

              r->right = s;
              s->parent = r;
              s->rank_and_balance = s->rank_and_balance & (unsigned int)3 | (s->rank_and_balance >> 2) - (r->rank_and_balance >> 2) << 2;
            }

            else
            {
              s->right = r->left;
              if(!(r->left == ((struct avl_node_tag *)NULL)))
                r->left->parent = s;

              r->left = s;
              s->parent = r;
              r->rank_and_balance = r->rank_and_balance & (unsigned int)3 | (r->rank_and_balance >> 2) + (s->rank_and_balance >> 2) << 2;
            }
            s->rank_and_balance = s->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
            r->rank_and_balance = r->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
          }

          else
            if((3 & (signed int)r->rank_and_balance) + -1 == -a)
            {
              if(a == -1)
              {
                p = r->right;
                r->right = p->left;
                if(!(p->left == ((struct avl_node_tag *)NULL)))
                  p->left->parent = r;

                p->left = r;
                r->parent = p;
                s->left = p->right;
                if(!(p->right == ((struct avl_node_tag *)NULL)))
                  p->right->parent = s;

                p->right = s;
                s->parent = p;
                p->rank_and_balance = p->rank_and_balance & (unsigned int)3 | (p->rank_and_balance >> 2) + (r->rank_and_balance >> 2) << 2;
                s->rank_and_balance = s->rank_and_balance & (unsigned int)3 | (s->rank_and_balance >> 2) - (p->rank_and_balance >> 2) << 2;
              }

              else
              {
                p = r->left;
                r->left = p->right;
                if(!(p->right == ((struct avl_node_tag *)NULL)))
                  p->right->parent = r;

                p->right = r;
                r->parent = p;
                s->right = p->left;
                if(!(p->left == ((struct avl_node_tag *)NULL)))
                  p->left->parent = s;

                p->left = s;
                s->parent = p;
                r->rank_and_balance = r->rank_and_balance & (unsigned int)3 | (r->rank_and_balance >> 2) - (p->rank_and_balance >> 2) << 2;
                p->rank_and_balance = p->rank_and_balance & (unsigned int)3 | (p->rank_and_balance >> 2) + (s->rank_and_balance >> 2) << 2;
              }
              if((3 & (signed int)p->rank_and_balance) + -1 == a)
              {
                s->rank_and_balance = s->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(-a + 1);
                r->rank_and_balance = r->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
              }

              else
                if((3 & (signed int)p->rank_and_balance) + -1 == -a)
                {
                  s->rank_and_balance = s->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
                  r->rank_and_balance = r->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(a + 1);
                }

                else
                {
                  s->rank_and_balance = s->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
                  r->rank_and_balance = r->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
                }
              p->rank_and_balance = p->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
            }

          if(s == t->right)
            t->right = p;

          else
            t->left = p;
          p->parent = t;
        }

  }
  return 0;
}

// _shout_avl_iterate_index_range
// file avl.c line 728
signed int _shout_avl_iterate_index_range(struct _avl_tree *tree, signed int (*iter_fun)(unsigned long int, void *, void *), unsigned long int low, unsigned long int high, void *iter_arg)
{
  unsigned long int m;
  unsigned long int num_left;
  struct avl_node_tag *node;
  if(!((unsigned long int)tree->length >= high))
    return -1;

  else
  {
    num_left = high - low;
    m = high;
    node = tree->root->right;
    while((_Bool)1)
      if(!(m >= (unsigned long int)(node->rank_and_balance >> 2)))
        node = node->left;

      else
        if(!((unsigned long int)(node->rank_and_balance >> 2) >= m))
        {
          m = m - (unsigned long int)(node->rank_and_balance >> 2);
          node = node->right;
        }

        else
          break;
    if(!(num_left == 0ul))
    {
      num_left = num_left - (unsigned long int)1;
      signed int return_value;
      return_value=iter_fun(num_left, node->key, iter_arg);
      if(!(return_value == 0))
        return -1;

      node=_shout_avl_get_prev(node);
    }

    return 0;
  }
}

// _shout_avl_iterate_inorder
// file avl.c line 652
signed int _shout_avl_iterate_inorder(struct _avl_tree *tree, signed int (*iter_fun)(void *, void *), void *iter_arg)
{
  signed int result;
  if(!(tree->length == 0u))
  {
    result=avl_iterate_inorder_helper(tree->root->right, iter_fun, iter_arg);
    return result;
  }

  else
    return 0;
}

// _shout_avl_node_new
// file avl.c line 42
struct avl_node_tag * _shout_avl_node_new(void *key, struct avl_node_tag *parent)
{
  struct avl_node_tag *node;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct avl_node_tag) /*40ul*/ );
  node = (struct avl_node_tag *)return_value_malloc$1;
  if(node == ((struct avl_node_tag *)NULL))
    return (struct avl_node_tag *)(void *)0;

  else
  {
    node->parent = parent;
    node->key = key;
    node->left = (struct avl_node_tag *)(void *)0;
    node->right = (struct avl_node_tag *)(void *)0;
    node->rank_and_balance = (unsigned int)0;
    node->rank_and_balance = node->rank_and_balance & (unsigned int)~3 | (unsigned int)(signed int)(0 + 1);
    node->rank_and_balance = node->rank_and_balance & (unsigned int)3 | (unsigned int)(1 << 2);
    return node;
  }
}

// _shout_avl_print_tree
// file avl.c line 1150
void _shout_avl_print_tree(struct _avl_tree *tree, signed int (*key_printer)(char *, void *))
{
  struct _link_node top = { .parent=(struct _link_node *)(void *)0, .direction=(char)0,
    .width=0 };
  if(key_printer == ((signed int (*)(char *, void *))NULL))
    key_printer = default_key_printer;

  if(!(tree->length == 0u))
    print_node(key_printer, tree->root->right, &top);

  else
    fprintf(stdout, "<empty tree>\n");
}

// _shout_avl_tree_free
// file avl.c line 107
void _shout_avl_tree_free(struct _avl_tree *tree, signed int (*free_key_fun)(void *))
{
  if(!(tree->length == 0u))
    avl_tree_free_helper(tree->root->right, free_key_fun);

  if(!(tree->root == ((struct avl_node_tag *)NULL)))
    free((void *)tree->root);

  _shout_thread_rwlock_destroy(&tree->rwlock);
  free((void *)tree);
}

// _shout_avl_tree_new
// file avl.c line 65
struct _avl_tree * _shout_avl_tree_new(signed int (*compare_fun)(void *, void *, void *), void *compare_arg)
{
  struct _avl_tree *t;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _avl_tree) /*88ul*/ );
  t = (struct _avl_tree *)return_value_malloc$1;
  if(t == ((struct _avl_tree *)NULL))
    return (struct _avl_tree *)(void *)0;

  else
  {
    struct avl_node_tag *root;
    root=_shout_avl_node_new((void *)0, (struct avl_node_tag *)(void *)0);
    if(root == ((struct avl_node_tag *)NULL))
    {
      free((void *)t);
      return (struct _avl_tree *)(void *)0;
    }

    else
    {
      t->root = root;
      t->height = (unsigned int)0;
      t->length = (unsigned int)0;
      t->compare_fun = compare_fun;
      t->compare_arg = compare_arg;
      _shout_thread_rwlock_create_c(&t->rwlock, 83, "avl.c");
      return t;
    }
  }
}

// _shout_avl_tree_rlock
// file avl.c line 1164
void _shout_avl_tree_rlock(struct _avl_tree *tree)
{
  _shout_thread_rwlock_rlock_c(&tree->rwlock, 1166, "avl.c");
}

// _shout_avl_tree_unlock
// file avl.c line 1174
void _shout_avl_tree_unlock(struct _avl_tree *tree)
{
  _shout_thread_rwlock_unlock_c(&tree->rwlock, 1176, "avl.c");
}

// _shout_avl_tree_wlock
// file avl.c line 1169
void _shout_avl_tree_wlock(struct _avl_tree *tree)
{
  _shout_thread_rwlock_wlock_c(&tree->rwlock, 1171, "avl.c");
}

// _shout_avl_verify
// file avl.c line 1050
signed int _shout_avl_verify(struct _avl_tree *tree)
{
  if(!(tree->length == 0u))
  {
    avl_verify_balance(tree->root->right);
    avl_verify_parent(tree->root->right, tree->root);
    avl_verify_rank(tree->root->right);
  }

  return 0;
}

// _shout_httpp_clear
// file httpp.c line 517
void _shout_httpp_clear(struct http_parser_tag *parser)
{
  parser->req_type = (enum httpp_request_type_tag)httpp_req_none;
  if(!(parser->uri == ((char *)NULL)))
    free((void *)parser->uri);

  parser->uri = (char *)(void *)0;
  _shout_avl_tree_free(parser->vars, _free_vars);
  _shout_avl_tree_free(parser->queryvars, _free_vars);
  parser->vars = (struct _avl_tree *)(void *)0;
}

// _shout_httpp_create_parser
// file httpp/httpp.h line 60
struct http_parser_tag * _shout_httpp_create_parser(void)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct http_parser_tag) /*32ul*/ );
  return (struct http_parser_tag *)return_value_malloc$1;
}

// _shout_httpp_destroy
// file httpp/httpp.h line 70
void _shout_httpp_destroy(struct http_parser_tag *parser)
{
  _shout_httpp_clear(parser);
  free((void *)parser);
}

// _shout_httpp_get_query_param
// file httpp.c line 501
const char * _shout_httpp_get_query_param(struct http_parser_tag *parser, const char *name)
{
  struct http_var_tag var;
  struct http_var_tag *found;
  void *fp = (void *)&found;
  var.name = (char *)name;
  var.value = (char *)(void *)0;
  signed int return_value__shout_avl_get_by_key$1;
  return_value__shout_avl_get_by_key$1=_shout_avl_get_by_key(parser->queryvars, (void *)&var, (void **)fp);
  if(return_value__shout_avl_get_by_key$1 == 0)
    return found->value;

  else
    return (const char *)(void *)0;
}

// _shout_httpp_getvar
// file httpp/httpp.h line 67
const char * _shout_httpp_getvar(struct http_parser_tag *parser, const char *name)
{
  struct http_var_tag var;
  struct http_var_tag *found;
  void *fp;
  if(name == ((const char *)NULL) || parser == ((struct http_parser_tag *)NULL))
    return (const char *)(void *)0;

  else
  {
    fp = (void *)&found;
    var.name = (char *)name;
    var.value = (char *)(void *)0;
    signed int return_value__shout_avl_get_by_key$1;
    return_value__shout_avl_get_by_key$1=_shout_avl_get_by_key(parser->vars, (void *)&var, (void **)fp);
    if(return_value__shout_avl_get_by_key$1 == 0)
      return found->value;

    else
      return (const char *)(void *)0;
  }
}

// _shout_httpp_initialize
// file httpp/httpp.h line 61
void _shout_httpp_initialize(struct http_parser_tag *parser, struct http_varlist_tag *defaults)
{
  struct http_varlist_tag *list;
  parser->req_type = (enum httpp_request_type_tag)httpp_req_none;
  parser->uri = (char *)(void *)0;
  parser->vars=_shout_avl_tree_new(_compare_vars, (void *)0);
  parser->queryvars=_shout_avl_tree_new(_compare_vars, (void *)0);
  list = defaults;
  for( ; !(list == ((struct http_varlist_tag *)NULL)); list = list->next)
    _shout_httpp_setvar(parser, list->var.name, list->var.value);
}

// _shout_httpp_parse
// file httpp.c line 288
signed int _shout_httpp_parse(struct http_parser_tag *parser, const char *http_data, unsigned long int len)
{
  char *data;
  char *tmp;
  char *line[32l];
  signed int i;
  signed int lines;
  char *req_type = (char *)(void *)0;
  char *uri = (char *)(void *)0;
  char *version = (char *)(void *)0;
  signed int whitespace;
  signed int where;
  signed int slen;
  signed int return_value_strcasecmp$7;
  signed int return_value_strcasecmp$6;
  signed int return_value_strcasecmp$5;
  signed int return_value_strcasecmp$4;
  signed int return_value_strcasecmp$3;
  _Bool tmp_if_expr$10;
  unsigned long int return_value_strlen$9;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$13;
  unsigned long int return_value_strlen$12;
  _Bool tmp_if_expr$15;
  if(http_data == ((const char *)NULL))
    return 0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(len + (unsigned long int)1);
    data = (char *)return_value_malloc$1;
    if(data == ((char *)NULL))
      return 0;

    else
    {
      memcpy((void *)data, (const void *)http_data, len);
      data[(signed long int)len] = (char)0;
      lines=split_headers(data, len, line);
      where = 0;
      whitespace = 0;
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(line[(signed long int)0]);
      slen = (signed int)return_value_strlen$2;
      req_type = line[(signed long int)0];
      i = 0;
      for( ; !(i >= slen); i = i + 1)
        if((signed int)line[0l][(signed long int)i] == 32)
        {
          whitespace = 1;
          line[(signed long int)0][(signed long int)i] = (char)0;
        }

        else
          if(!(whitespace == 0))
          {
            whitespace = 0;
            where = where + 1;
            switch(where)
            {
              case 1:
              {
                uri = &line[(signed long int)0][(signed long int)i];
                break;
              }
              case 2:
                version = &line[(signed long int)0][(signed long int)i];
            }
          }

      signed int return_value_strcasecmp$8;
      return_value_strcasecmp$8=strcasecmp("GET", req_type);
      if(return_value_strcasecmp$8 == 0)
        parser->req_type = (enum httpp_request_type_tag)httpp_req_get;

      else
      {
        return_value_strcasecmp$7=strcasecmp("POST", req_type);
        if(return_value_strcasecmp$7 == 0)
          parser->req_type = (enum httpp_request_type_tag)httpp_req_post;

        else
        {
          return_value_strcasecmp$6=strcasecmp("HEAD", req_type);
          if(return_value_strcasecmp$6 == 0)
            parser->req_type = (enum httpp_request_type_tag)httpp_req_head;

          else
          {
            return_value_strcasecmp$5=strcasecmp("SOURCE", req_type);
            if(return_value_strcasecmp$5 == 0)
              parser->req_type = (enum httpp_request_type_tag)httpp_req_source;

            else
            {
              return_value_strcasecmp$4=strcasecmp("PLAY", req_type);
              if(return_value_strcasecmp$4 == 0)
                parser->req_type = (enum httpp_request_type_tag)httpp_req_play;

              else
              {
                return_value_strcasecmp$3=strcasecmp("STATS", req_type);
                if(return_value_strcasecmp$3 == 0)
                  parser->req_type = (enum httpp_request_type_tag)httpp_req_stats;

                else
                  parser->req_type = (enum httpp_request_type_tag)httpp_req_unknown;
              }
            }
          }
        }
      }
      if(!(uri == ((char *)NULL)))
      {
        return_value_strlen$9=strlen(uri);
        tmp_if_expr$10 = return_value_strlen$9 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$10 = (_Bool)0;
      if(tmp_if_expr$10)
      {
        char *query;
        query=strchr(uri, 63);
        if(!(query == ((char *)NULL)))
        {
          _shout_httpp_setvar(parser, "__rawuri", uri);
          _shout_httpp_setvar(parser, " __queryargs", query);
          *query = (char)0;
          query = query + 1l;
          parse_query(parser, query);
        }

        parser->uri=strdup(uri);
      }

      else
      {
        free((void *)data);
        return 0;
      }
      if(!(version == ((char *)NULL)))
      {
        tmp=strchr(version, 47);
        tmp_if_expr$14 = tmp != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$14 = (_Bool)0;
      if(tmp_if_expr$14)
      {
        tmp[(signed long int)0] = (char)0;
        unsigned long int return_value_strlen$11;
        return_value_strlen$11=strlen(version);
        if(return_value_strlen$11 >= 1ul)
        {
          return_value_strlen$12=strlen(&tmp[(signed long int)1]);
          tmp_if_expr$13 = return_value_strlen$12 > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$13 = (_Bool)0;
        if(tmp_if_expr$13)
        {
          _shout_httpp_setvar(parser, "__protocol", version);
          _shout_httpp_setvar(parser, "__version", &tmp[(signed long int)1]);
        }

        else
        {
          free((void *)data);
          return 0;
        }
      }

      else
      {
        free((void *)data);
        return 0;
      }
      if(!((signed int)parser->req_type == httpp_req_none))
        tmp_if_expr$15 = (signed int)parser->req_type != httpp_req_unknown ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$15 = (_Bool)0;
      if(tmp_if_expr$15)
        switch((signed int)parser->req_type)
        {
          case httpp_req_get:
          {
            _shout_httpp_setvar(parser, "__req_type", "GET");
            break;
          }
          case httpp_req_post:
          {
            _shout_httpp_setvar(parser, "__req_type", "POST");
            break;
          }
          case httpp_req_head:
          {
            _shout_httpp_setvar(parser, "__req_type", "HEAD");
            break;
          }
          case httpp_req_source:
          {
            _shout_httpp_setvar(parser, "__req_type", "SOURCE");
            break;
          }
          case httpp_req_play:
          {
            _shout_httpp_setvar(parser, "__req_type", "PLAY");
            break;
          }
          case httpp_req_stats:
            _shout_httpp_setvar(parser, "__req_type", "STATS");
        }

      else
      {
        free((void *)data);
        return 0;
      }
      if(!(parser->uri == ((char *)NULL)))
        _shout_httpp_setvar(parser, "__uri", parser->uri);

      else
      {
        free((void *)data);
        return 0;
      }
      parse_headers(parser, line, lines);
      free((void *)data);
      return 1;
    }
  }
}

// _shout_httpp_parse_response
// file httpp/httpp.h line 64
signed int _shout_httpp_parse_response(struct http_parser_tag *parser, const char *http_data, unsigned long int len, const char *uri)
{
  char *data;
  char *line[32l];
  signed int lines;
  signed int slen;
  signed int i;
  signed int whitespace = 0;
  signed int where = 0;
  signed int code;
  char *version = (char *)(void *)0;
  char *resp_code = (char *)(void *)0;
  char *message = (char *)(void *)0;
  if(http_data == ((const char *)NULL))
    return 0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(len + (unsigned long int)1);
    data = (char *)return_value_malloc$1;
    if(data == ((char *)NULL))
      return 0;

    else
    {
      memcpy((void *)data, (const void *)http_data, len);
      data[(signed long int)len] = (char)0;
      lines=split_headers(data, len, line);
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(line[(signed long int)0]);
      slen = (signed int)return_value_strlen$2;
      version = line[(signed long int)0];
      i = 0;
      for( ; !(i >= slen); i = i + 1)
        if((signed int)line[0l][(signed long int)i] == 32)
        {
          line[(signed long int)0][(signed long int)i] = (char)0;
          whitespace = 1;
        }

        else
          if(!(whitespace == 0))
          {
            whitespace = 0;
            where = where + 1;
            if(where == 1)
              resp_code = &line[(signed long int)0][(signed long int)i];

            else
            {
              message = &line[(signed long int)0][(signed long int)i];
              break;
            }
          }

      if(message == ((char *)NULL) || resp_code == ((char *)NULL) || version == ((char *)NULL))
      {
        free((void *)data);
        return 0;
      }

      else
      {
        _shout_httpp_setvar(parser, "__errorcode", resp_code);
        code=atoi(resp_code);
        if(code >= 300 || !(code >= 200))
          _shout_httpp_setvar(parser, "__errormessage", message);

        _shout_httpp_setvar(parser, "__uri", uri);
        _shout_httpp_setvar(parser, "__req_type", "NONE");
        parse_headers(parser, line, lines);
        free((void *)data);
        return 1;
      }
    }
  }
}

// _shout_httpp_set_query_param
// file httpp.c line 480
void _shout_httpp_set_query_param(struct http_parser_tag *parser, const char *name, const char *value)
{
  struct http_var_tag *var;
  if(!(name == ((const char *)NULL)) && !(value == ((const char *)NULL)))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct http_var_tag) /*16ul*/ );
    var = (struct http_var_tag *)return_value_malloc$1;
    if(!(var == ((struct http_var_tag *)NULL)))
    {
      var->name=strdup(name);
      var->value=url_escape(value);
      const char *return_value__shout_httpp_get_query_param$2;
      return_value__shout_httpp_get_query_param$2=_shout_httpp_get_query_param(parser, name);
      if(return_value__shout_httpp_get_query_param$2 == ((const char *)NULL))
        _shout_avl_insert(parser->queryvars, (void *)var);

      else
      {
        _shout_avl_delete(parser->queryvars, (void *)var, _free_vars);
        _shout_avl_insert(parser->queryvars, (void *)var);
      }
    }

  }

}

// _shout_httpp_setvar
// file httpp.c line 440
void _shout_httpp_setvar(struct http_parser_tag *parser, const char *name, const char *value)
{
  struct http_var_tag *var;
  if(!(name == ((const char *)NULL)) && !(value == ((const char *)NULL)))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct http_var_tag) /*16ul*/ );
    var = (struct http_var_tag *)return_value_malloc$1;
    if(!(var == ((struct http_var_tag *)NULL)))
    {
      var->name=strdup(name);
      var->value=strdup(value);
      const char *return_value__shout_httpp_getvar$2;
      return_value__shout_httpp_getvar$2=_shout_httpp_getvar(parser, name);
      if(return_value__shout_httpp_getvar$2 == ((const char *)NULL))
        _shout_avl_insert(parser->vars, (void *)var);

      else
      {
        _shout_avl_delete(parser->vars, (void *)var, _free_vars);
        _shout_avl_insert(parser->vars, (void *)var);
      }
    }

  }

}

// _shout_open_opus
// file shout_ogg.h line 54
signed int _shout_open_opus(struct _ogg_codec_tag *codec, struct anonymous$7 *page)
{
  struct anonymous$1 *opus_data;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$1) /*292ul*/ );
  opus_data = (struct anonymous$1 *)return_value_calloc$1;
  struct anonymous$2 packet;
  if(opus_data == ((struct anonymous$1 *)NULL))
    return -5;

  else
  {
    ogg_stream_packetout(&codec->os, &packet);
    signed int return_value_opus_header_parse$2;
    return_value_opus_header_parse$2=opus_header_parse(packet.packet, (signed int)packet.bytes, &opus_data->oh);
    if(return_value_opus_header_parse$2 == 0)
    {
      free_opus_data((void *)opus_data);
      return -9;
    }

    else
    {
      opus_data->skipped = 0;
      codec->codec_data = (void *)opus_data;
      codec->read_page = read_opus_page;
      codec->free_data = free_opus_data;
      return 0;
    }
  }
}

// _shout_open_speex
// file shout_ogg.h line 52
signed int _shout_open_speex(struct _ogg_codec_tag *codec, struct anonymous$7 *page)
{
  struct anonymous$11 *speex_data;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$11) /*8ul*/ );
  speex_data = (struct anonymous$11 *)return_value_calloc$1;
  struct anonymous$2 packet;
  if(speex_data == ((struct anonymous$11 *)NULL))
    return -5;

  else
  {
    ogg_stream_packetout(&codec->os, &packet);
    speex_data->sh=speex_packet_to_header((char *)packet.packet, (signed int)packet.bytes);
    if(speex_data->sh == ((struct SpeexHeader *)NULL))
    {
      free_speex_data((void *)speex_data);
      return -9;
    }

    else
    {
      codec->codec_data = (void *)speex_data;
      codec->read_page = read_speex_page;
      codec->free_data = free_speex_data;
      return 0;
    }
  }
}

// _shout_open_theora
// file shout_ogg.h line 49
signed int _shout_open_theora(struct _ogg_codec_tag *codec, struct anonymous$7 *page)
{
  struct anonymous$2 packet;
  struct anonymous$6 *theora_data;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$6) /*176ul*/ );
  theora_data = (struct anonymous$6 *)return_value_calloc$1;
  if(theora_data == ((struct anonymous$6 *)NULL))
    return -5;

  else
  {
    theora_info_init(&theora_data->ti);
    theora_comment_init(&theora_data->tc);
    ogg_stream_packetout(&codec->os, &packet);
    signed int return_value_theora_decode_header$2;
    return_value_theora_decode_header$2=theora_decode_header(&theora_data->ti, &theora_data->tc, &packet);
    if(!(return_value_theora_decode_header$2 >= 0))
    {
      free_theora_data((void *)theora_data);
      return -9;
    }

    else
    {
      codec->codec_data = (void *)theora_data;
      codec->read_page = read_theora_page;
      codec->free_data = free_theora_data;
      codec->headers = (unsigned int)1;
      theora_data->initial_frames = 0;
      return 0;
    }
  }
}

// _shout_open_vorbis
// file shout_ogg.h line 47
signed int _shout_open_vorbis(struct _ogg_codec_tag *codec, struct anonymous$7 *page)
{
  struct anonymous$30 *vorbis_data;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$30) /*96ul*/ );
  vorbis_data = (struct anonymous$30 *)return_value_calloc$1;
  struct anonymous$2 packet;
  if(vorbis_data == ((struct anonymous$30 *)NULL))
    return -5;

  else
  {
    vorbis_info_init(&vorbis_data->vi);
    vorbis_comment_init(&vorbis_data->vc);
    ogg_stream_packetout(&codec->os, &packet);
    signed int return_value_vorbis_synthesis_headerin$2;
    return_value_vorbis_synthesis_headerin$2=vorbis_synthesis_headerin(&vorbis_data->vi, &vorbis_data->vc, &packet);
    if(!(return_value_vorbis_synthesis_headerin$2 >= 0))
    {
      free_vorbis_data((void *)vorbis_data);
      return -9;
    }

    else
    {
      codec->codec_data = (void *)vorbis_data;
      codec->read_page = read_vorbis_page;
      codec->free_data = free_vorbis_data;
      return 0;
    }
  }
}

// _shout_resolver_getip
// file resolver.h line 34
char * _shout_resolver_getip(const char *name, char *buff, signed int len)
{
  struct addrinfo *head;
  struct addrinfo hints;
  char *ret = (char *)(void *)0;
  signed int return_value__isip$1;
  return_value__isip$1=_isip(name);
  if(!(return_value__isip$1 == 0))
  {
    strncpy(buff, name, (unsigned long int)len);
    buff[(signed long int)(len - 1)] = (char)0;
    return buff;
  }

  else
  {
    memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
    hints.ai_family = 0;
    hints.ai_socktype = 1;
    signed int return_value_getaddrinfo$2;
    return_value_getaddrinfo$2=getaddrinfo(name, (const char *)(void *)0, &hints, &head);
    if(!(return_value_getaddrinfo$2 == 0))
      return (char *)(void *)0;

    else
    {
      if(!(head == ((struct addrinfo *)NULL)))
      {
        signed int return_value_getnameinfo$3;
        return_value_getnameinfo$3=getnameinfo(head->ai_addr, head->ai_addrlen, buff, (unsigned int)len, (char *)(void *)0, (unsigned int)0, 1);
        if(return_value_getnameinfo$3 == 0)
          ret = buff;

        freeaddrinfo(head);
      }

      return ret;
    }
  }
}

// _shout_resolver_getname
// file resolver.c line 86
char * _shout_resolver_getname(const char *ip, char *buff, signed int len)
{
  struct addrinfo *head = (struct addrinfo *)(void *)0;
  struct addrinfo hints;
  char *ret = (char *)(void *)0;
  signed int return_value__isip$1;
  return_value__isip$1=_isip(ip);
  if(return_value__isip$1 == 0)
  {
    strncpy(buff, ip, (unsigned long int)len);
    buff[(signed long int)(len - 1)] = (char)0;
    return buff;
  }

  else
  {
    memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
    hints.ai_family = 0;
    hints.ai_socktype = 1;
    hints.ai_flags = 0x0002;
    signed int return_value_getaddrinfo$2;
    return_value_getaddrinfo$2=getaddrinfo(ip, (const char *)(void *)0, &hints, &head);
    if(!(return_value_getaddrinfo$2 == 0))
      return (char *)(void *)0;

    else
    {
      if(!(head == ((struct addrinfo *)NULL)))
      {
        signed int return_value_getnameinfo$3;
        return_value_getnameinfo$3=getnameinfo(head->ai_addr, head->ai_addrlen, buff, (unsigned int)len, (char *)(void *)0, (unsigned int)0, 8);
        if(return_value_getnameinfo$3 == 0)
          ret = buff;

        freeaddrinfo(head);
      }

      return ret;
    }
  }
}

// _shout_resolver_initialize
// file resolver.h line 30
void _shout_resolver_initialize(void)
{
  if(_initialized$link1 == 0)
  {
    _initialized$link1 = 1;
    _shout_thread_mutex_create(&_resolver_mutex, 206, "resolver.c");
    sethostent(1);
  }

}

// _shout_resolver_shutdown
// file resolver.h line 31
void _shout_resolver_shutdown(void)
{
  if(!(_initialized$link1 == 0))
  {
    _shout_thread_mutex_destroy(&_resolver_mutex);
    _initialized$link1 = 0;
    endhostent();
  }

}

// _shout_sock_accept
// file sock.c line 922
signed int _shout_sock_accept(signed int serversock, char *ip, unsigned long int len)
{
  struct sockaddr_storage sa;
  signed int ret;
  unsigned int slen;
  _Bool tmp_if_expr$2;
  signed int return_value__shout_sock_valid_socket$1;
  if(ip == ((char *)NULL) || len == 0ul)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value__shout_sock_valid_socket$1=_shout_sock_valid_socket(serversock);
    tmp_if_expr$2 = !(return_value__shout_sock_valid_socket$1 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    return (signed int)-1;

  else
  {
    slen = (unsigned int)sizeof(struct sockaddr_storage) /*128ul*/ ;
    ret=accept(serversock, (struct sockaddr *)&sa, &slen);
    if(!(ret == -1))
    {
      signed int return_value_getnameinfo$3;
      return_value_getnameinfo$3=getnameinfo((struct sockaddr *)&sa, slen, ip, (unsigned int)len, (char *)(void *)0, (unsigned int)0, 1);
      if(!(return_value_getnameinfo$3 == 0))
        snprintf(ip, len, "unknown");

      _shout_sock_set_nolinger(ret);
      _shout_sock_set_keepalive(ret);
    }

    return ret;
  }
}

// _shout_sock_close
// file ./net/sock.h line 117
signed int _shout_sock_close(signed int sock)
{
  signed int return_value_close$1;
  return_value_close$1=close(sock);
  return return_value_close$1;
}

// _shout_sock_connect_non_blocking
// file ./net/sock.h line 122
signed int _shout_sock_connect_non_blocking(const char *hostname, unsigned int port)
{
  signed int sock = (signed int)-1;
  struct addrinfo *ai;
  struct addrinfo *head;
  struct addrinfo hints;
  char service[8l];
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  snprintf(service, sizeof(char [8l]) /*8ul*/ , "%u", port);
  signed int return_value_getaddrinfo$1;
  return_value_getaddrinfo$1=getaddrinfo(hostname, service, &hints, &head);
  _Bool tmp_if_expr$5;
  signed int return_value__shout_sock_error$3;
  signed int return_value_sock_connect_pending$4;
  if(!(return_value_getaddrinfo$1 == 0))
    return (signed int)-1;

  else
  {
    ai = head;
    for( ; !(ai == ((struct addrinfo *)NULL)); ai = ai->ai_next)
    {
      sock=socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
      if(sock >= 0)
      {
        _shout_sock_set_blocking(sock, 0);
        signed int return_value_connect$2;
        return_value_connect$2=connect(sock, ai->ai_addr, ai->ai_addrlen);
        if(!(return_value_connect$2 >= 0))
        {
          return_value__shout_sock_error$3=_shout_sock_error();
          return_value_sock_connect_pending$4=sock_connect_pending(return_value__shout_sock_error$3);
          tmp_if_expr$5 = !(return_value_sock_connect_pending$4 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$5 = (_Bool)0;
        if(tmp_if_expr$5)
        {
          _shout_sock_close(sock);
          sock = (signed int)-1;
        }

        else
          break;
      }

    }
    if(!(head == ((struct addrinfo *)NULL)))
      freeaddrinfo(head);

    return sock;
  }
}

// _shout_sock_connect_wto
// file ./net/sock.h line 120
signed int _shout_sock_connect_wto(const char *hostname, signed int port, signed int timeout)
{
  signed int return_value__shout_sock_connect_wto_bind$1;
  return_value__shout_sock_connect_wto_bind$1=_shout_sock_connect_wto_bind(hostname, port, (const char *)(void *)0, timeout);
  return return_value__shout_sock_connect_wto_bind$1;
}

// _shout_sock_connect_wto_bind
// file sock.c line 633
signed int _shout_sock_connect_wto_bind(const char *hostname, signed int port, const char *bnd, signed int timeout)
{
  signed int sock = (signed int)-1;
  struct addrinfo *ai;
  struct addrinfo *head;
  struct addrinfo *b_head = (struct addrinfo *)(void *)0;
  struct addrinfo hints;
  char service[8l];
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  snprintf(service, sizeof(char [8l]) /*8ul*/ , "%u", port);
  signed int return_value_getaddrinfo$1;
  return_value_getaddrinfo$1=getaddrinfo(hostname, service, &hints, &head);
  _Bool tmp_if_expr$4;
  signed int return_value_bind$3;
  if(!(return_value_getaddrinfo$1 == 0))
    return (signed int)-1;

  else
  {
    ai = head;
    for( ; !(ai == ((struct addrinfo *)NULL)); ai = ai->ai_next)
    {
      sock=socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
      if(sock >= 0)
      {
        if(timeout >= 1)
          _shout_sock_set_blocking(sock, 0);

        if(!(bnd == ((const char *)NULL)))
        {
          struct addrinfo b_hints;
          memset((void *)&b_hints, 0, sizeof(struct addrinfo) /*48ul*/ );
          b_hints.ai_family = ai->ai_family;
          b_hints.ai_socktype = ai->ai_socktype;
          b_hints.ai_protocol = ai->ai_protocol;
          signed int return_value_getaddrinfo$2;
          return_value_getaddrinfo$2=getaddrinfo(bnd, (const char *)(void *)0, &b_hints, &b_head);
          if(!(return_value_getaddrinfo$2 == 0))
            tmp_if_expr$4 = (_Bool)1;

          else
          {
            return_value_bind$3=bind(sock, b_head->ai_addr, b_head->ai_addrlen);
            tmp_if_expr$4 = return_value_bind$3 < 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$4)
          {
            _shout_sock_close(sock);
            sock = (signed int)-1;
            break;
          }

        }

        signed int return_value_connect$5;
        return_value_connect$5=connect(sock, ai->ai_addr, ai->ai_addrlen);
        if(return_value_connect$5 == 0)
          break;

        while(!(sock == -1))
        {
          signed int return_value__shout_sock_error$6;
          return_value__shout_sock_error$6=_shout_sock_error();
          signed int return_value__shout_sock_recoverable$7;
          return_value__shout_sock_recoverable$7=_shout_sock_recoverable(return_value__shout_sock_error$6);
          if(!(return_value__shout_sock_recoverable$7 == 0))
          {
            signed int connected;
            connected=_shout_sock_connected(sock, timeout);
            if(connected == 0)
              continue;

            if(connected == 1)
            {
              if(timeout >= 0)
                _shout_sock_set_blocking(sock, 1);

              break;
            }

          }

          _shout_sock_close(sock);
          sock = (signed int)-1;
        }
        if(!(sock == -1))
          break;

      }

    }
    if(!(b_head == ((struct addrinfo *)NULL)))
      freeaddrinfo(b_head);

    freeaddrinfo(head);
    return sock;
  }
}

// _shout_sock_connected
// file ./net/sock.h line 123
signed int _shout_sock_connected(signed int sock, signed int timeout)
{
  struct anonymous$12 wfds;
  signed int val = (signed int)-1;
  unsigned int size = (unsigned int)sizeof(signed int) /*4ul*/ ;
  struct timeval tv;
  struct timeval *timeval = (struct timeval *)(void *)0;
  if(timeout >= 0)
  {
    tv.tv_sec = (signed long int)timeout;
    tv.tv_usec = (signed long int)0;
    timeval = &tv;
  }

  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$12) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wfds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&wfds)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wfds)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  signed int return_value_select$1;
  return_value_select$1=select(sock + 1, (struct anonymous$12 *)(void *)0, &wfds, (struct anonymous$12 *)(void *)0, timeval);
  if(!(return_value_select$1 == 0))
  {
    if(return_value_select$1 == -1)
      goto __CPROVER_DUMP_L5;

  }

  else
    return -2;
  signed int return_value_getsockopt$2;
  return_value_getsockopt$2=getsockopt(sock, 1, 4, (void *)&val, &size);
  if(return_value_getsockopt$2 == 0)
  {
    if(val == 0)
      return 1;

    _shout_sock_set_error(val);
  }


__CPROVER_DUMP_L5:
  ;
  signed int return_value__shout_sock_error$3;
  return_value__shout_sock_error$3=_shout_sock_error();
  signed int return_value__shout_sock_recoverable$4;
  return_value__shout_sock_recoverable$4=_shout_sock_recoverable(return_value__shout_sock_error$3);
  if(!(return_value__shout_sock_recoverable$4 == 0))
    return 0;

  else
    return (signed int)-1;
}

// _shout_sock_error
// file ./net/sock.h line 106
signed int _shout_sock_error(void)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  return *return_value___errno_location$1;
}

// _shout_sock_get_localip
// file sock.c line 108
char * _shout_sock_get_localip(char *buff, signed int len)
{
  char temp[1024l];
  signed int return_value_gethostname$1;
  return_value_gethostname$1=gethostname(temp, sizeof(char [1024l]) /*1024ul*/ );
  if(!(return_value_gethostname$1 == 0))
    return (char *)(void *)0;

  else
  {
    char *return_value__shout_resolver_getip$2;
    return_value__shout_resolver_getip$2=_shout_resolver_getip(temp, buff, len);
    if(!(return_value__shout_resolver_getip$2 == ((char *)NULL)))
      return buff;

    else
      return (char *)(void *)0;
  }
}

// _shout_sock_get_server_socket
// file sock.c line 705
signed int _shout_sock_get_server_socket(signed int port, const char *sinterface)
{
  struct sockaddr_storage sa;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *ai;
  char service[10l];
  signed int sock;
  if(!(port >= 0))
    return (signed int)-1;

  else
  {
    memset((void *)&sa, 0, sizeof(struct sockaddr_storage) /*128ul*/ );
    memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
    hints.ai_family = 0;
    hints.ai_flags = 0x0001 | 0x0020 | 0x0400 | 0x0004;
    hints.ai_socktype = 1;
    snprintf(service, sizeof(char [10l]) /*10ul*/ , "%d", port);
    signed int return_value_getaddrinfo$1;
    return_value_getaddrinfo$1=getaddrinfo(sinterface, service, &hints, &res);
    if(!(return_value_getaddrinfo$1 == 0))
      return (signed int)-1;

    else
    {
      ai = res;
      do
      {
        signed int on = 1;
        sock=socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if(sock >= 0)
        {
          setsockopt(sock, 1, 2, (const void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
          on = 0;
          setsockopt(sock, 41, 26, (const void *)&on, (unsigned int)sizeof(signed int) /*4ul*/ );
          signed int return_value_bind$2;
          return_value_bind$2=bind(sock, ai->ai_addr, ai->ai_addrlen);
          if(!(return_value_bind$2 >= 0))
            _shout_sock_close(sock);

          else
          {
            freeaddrinfo(res);
            return sock;
          }
        }

        ai = ai->ai_next;
      }
      while(!(ai == ((struct addrinfo *)NULL)));
      freeaddrinfo(res);
      return (signed int)-1;
    }
  }
}

// _shout_sock_initialize
// file ./net/sock.h line 103
void _shout_sock_initialize(void)
{
  _shout_resolver_initialize();
}

// _shout_sock_listen
// file sock.c line 911
signed int _shout_sock_listen(signed int serversock, signed int backlog)
{
  signed int return_value__shout_sock_valid_socket$1;
  return_value__shout_sock_valid_socket$1=_shout_sock_valid_socket(serversock);
  if(return_value__shout_sock_valid_socket$1 == 0)
    return 0;

  else
  {
    if(!(backlog >= 1))
      backlog = 10;

    signed int return_value_listen$2;
    return_value_listen$2=listen(serversock, backlog);
    return (signed int)(return_value_listen$2 == 0);
  }
}

// _shout_sock_read_bytes
// file ./net/sock.h line 134
signed int _shout_sock_read_bytes(signed int sock, char *buff, unsigned long int len)
{
  if(buff == ((char *)NULL))
    return 0;

  else
    if(!(len >= 1ul))
      return 0;

    else
    {
      signed long int return_value_recv$1;
      return_value_recv$1=recv(sock, (void *)buff, len, 0);
      return (signed int)return_value_recv$1;
    }
}

// _shout_sock_read_line
// file sock.c line 474
signed int _shout_sock_read_line(signed int sock, char *buff, const signed int len)
{
  char c = (char)0;
  signed int read_bytes;
  signed int pos;
  if(buff == ((char *)NULL))
    return 0;

  else
    if(!(len >= 1))
      return 0;

  pos = 0;
  signed long int return_value_recv$1;
  return_value_recv$1=recv(sock, (void *)&c, (unsigned long int)1, 0);
  read_bytes = (signed int)return_value_recv$1;
  signed int tmp_post$2;
  if(!(read_bytes >= 0))
    return 0;

  else
  {
    while(read_bytes == 1 && !((signed int)c == 10) && !(pos >= len))
    {
      if(!((signed int)c == 13))
      {
        tmp_post$2 = pos;
        pos = pos + 1;
        buff[(signed long int)tmp_post$2] = c;
      }

      signed long int return_value_recv$3;
      return_value_recv$3=recv(sock, (void *)&c, (unsigned long int)1, 0);
      read_bytes = (signed int)return_value_recv$3;
    }
    if(read_bytes == 1)
    {
      buff[(signed long int)pos] = (char)0;
      return 1;
    }

    else
      return 0;
  }
}

// _shout_sock_recoverable
// file ./net/sock.h line 107
signed int _shout_sock_recoverable(signed int error)
{
  if(error == 0 || error == 4 || error == 11 || error == 85 || error == 115)
    return 1;

  return 0;
}

// _shout_sock_set_blocking
// file sock.c line 250
signed int _shout_sock_set_blocking(signed int sock, signed int block)
{
  signed int return_value__shout_sock_valid_socket$1;
  return_value__shout_sock_valid_socket$1=_shout_sock_valid_socket(sock);
  if(return_value__shout_sock_valid_socket$1 == 0 || block >= 2 || !(block >= 0))
    return (signed int)-1;

  else
  {
    signed int return_value_fcntl$2;
    return_value_fcntl$2=fcntl(sock, 4, block != 0 ? 0 : 04000);
    return return_value_fcntl$2;
  }
}

// _shout_sock_set_error
// file sock.c line 134
void _shout_sock_set_error(signed int val)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = val;
}

// _shout_sock_set_keepalive
// file sock.c line 286
signed int _shout_sock_set_keepalive(signed int sock)
{
  signed int keepalive = 1;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(sock, 1, 9, (void *)&keepalive, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt$1;
}

// _shout_sock_set_nodelay
// file sock.c line 278
signed int _shout_sock_set_nodelay(signed int sock)
{
  signed int nodelay = 1;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(sock, 6, 1, (void *)&nodelay, (unsigned int)sizeof(signed int) /*4ul*/ );
  return return_value_setsockopt$1;
}

// _shout_sock_set_nolinger
// file sock.c line 271
signed int _shout_sock_set_nolinger(signed int sock)
{
  struct linger lin = { .l_onoff=0, .l_linger=0 };
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(sock, 1, 13, (void *)&lin, (unsigned int)sizeof(struct linger) /*8ul*/ );
  return return_value_setsockopt$1;
}

// _shout_sock_set_send_buffer
// file sock.c line 906
void _shout_sock_set_send_buffer(signed int sock, signed int win_size)
{
  setsockopt(sock, 1, 7, (const void *)(char *)&win_size, (unsigned int)sizeof(signed int) /*4ul*/ );
}

// _shout_sock_shutdown
// file ./net/sock.h line 104
void _shout_sock_shutdown(void)
{
  _shout_resolver_shutdown();
}

// _shout_sock_stalled
// file sock.c line 168
signed int _shout_sock_stalled(signed int error)
{
  if(error == 11 || error == 85 || error == 114 || error == 115)
    return 1;

  return 0;
}

// _shout_sock_valid_socket
// file sock.c line 197
signed int _shout_sock_valid_socket(signed int sock)
{
  signed int ret;
  signed int optval;
  unsigned int optlen = (unsigned int)sizeof(signed int) /*4ul*/ ;
  ret=getsockopt(sock, 1, 3, (void *)&optval, &optlen);
  return (signed int)(ret == 0);
}

// _shout_sock_write
// file ./net/sock.h line 127
signed int _shout_sock_write(signed int sock, const char *fmt, ...)
{
  signed int rc;
  void **ap = (void **)&fmt;
  rc=_shout_sock_write_fmt(sock, fmt, ap);
  ap = ((void **)NULL);
  return rc;
}

// _shout_sock_write_bytes
// file ./net/sock.h line 126
signed int _shout_sock_write_bytes(signed int sock, const void *buff, unsigned long int len)
{
  if(buff == NULL)
    return (signed int)-1;

  else
    if(!(len >= 1ul))
      return (signed int)-1;

  signed long int return_value_send$1;
  return_value_send$1=send(sock, buff, len, 0);
  return (signed int)return_value_send$1;
}

// _shout_sock_write_fmt
// file sock.c line 421
signed int _shout_sock_write_fmt(signed int sock, const char *fmt, void **ap)
{
  char buffer[1024l];
  char *buff = buffer;
  signed int len;
  signed int rc = (signed int)-1;
  void **ap_retry = (void **)ap;
  len=vsnprintf(buff, sizeof(char [1024l]) /*1024ul*/ , fmt, ap);
  if(len >= 1)
  {
    if(!((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ ))
      rc=_shout_sock_write_bytes(sock, (const void *)buff, (unsigned long int)len);

    else
    {
      len = len + 1;
      void *return_value_malloc$1;
      return_value_malloc$1=malloc((unsigned long int)len);
      buff = (char *)return_value_malloc$1;
      if(!(buff == ((char *)NULL)))
      {
        len=vsnprintf(buff, (unsigned long int)len, fmt, ap_retry);
        if(len >= 1)
          rc=_shout_sock_write_bytes(sock, (const void *)buff, (unsigned long int)len);

        free((void *)buff);
      }

    }
  }

  ap_retry = ((void **)NULL);
  return rc;
}

// _shout_sock_write_string
// file sock.c line 369
signed int _shout_sock_write_string(signed int sock, const char *buff)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(buff);
  signed int return_value__shout_sock_write_bytes$2;
  return_value__shout_sock_write_bytes$2=_shout_sock_write_bytes(sock, (const void *)buff, return_value_strlen$1);
  return (signed int)(return_value__shout_sock_write_bytes$2 > 0);
}

// _shout_sock_writev
// file sock.c line 312
signed long int _shout_sock_writev(signed int sock, struct iovec *iov, unsigned long int count)
{
  signed long int return_value_writev$1;
  return_value_writev$1=writev(sock, iov, (signed int)count);
  return return_value_writev$1;
}

// _shout_thread_cond_broadcast_c
// file thread.c line 513
void _shout_thread_cond_broadcast_c(struct anonymous$26 *cond, signed int line, char *file)
{
  pthread_cond_broadcast(&cond->sys_cond);
}

// _shout_thread_cond_create_c
// file thread.c line 496
void _shout_thread_cond_create_c(struct anonymous$26 *cond, signed int line, char *file)
{
  pthread_cond_init(&cond->sys_cond, (const union anonymous$28 *)(void *)0);
  pthread_mutex_init(&cond->cond_mutex, (const union anonymous$28 *)(void *)0);
}

// _shout_thread_cond_destroy
// file thread.c line 502
void _shout_thread_cond_destroy(struct anonymous$26 *cond)
{
  pthread_mutex_destroy(&cond->cond_mutex);
  pthread_cond_destroy(&cond->sys_cond);
}

// _shout_thread_cond_signal_c
// file thread.c line 508
void _shout_thread_cond_signal_c(struct anonymous$26 *cond, signed int line, char *file)
{
  pthread_cond_signal(&cond->sys_cond);
}

// _shout_thread_cond_timedwait_c
// file thread.c line 518
void _shout_thread_cond_timedwait_c(struct anonymous$26 *cond, signed int millis, signed int line, char *file)
{
  struct timespec _shout_thread_cond_timedwait_c$$1$$time;
  _shout_thread_cond_timedwait_c$$1$$time.tv_sec = (signed long int)(millis / 1000);
  _shout_thread_cond_timedwait_c$$1$$time.tv_nsec = ((signed long int)millis - _shout_thread_cond_timedwait_c$$1$$time.tv_sec * (signed long int)1000) * (signed long int)1000000;
  pthread_mutex_lock(&cond->cond_mutex);
  pthread_cond_timedwait(&cond->sys_cond, &cond->cond_mutex, &_shout_thread_cond_timedwait_c$$1$$time);
  pthread_mutex_unlock(&cond->cond_mutex);
}

// _shout_thread_cond_wait_c
// file thread.c line 530
void _shout_thread_cond_wait_c(struct anonymous$26 *cond, signed int line, char *file)
{
  pthread_mutex_lock(&cond->cond_mutex);
  pthread_cond_wait(&cond->sys_cond, &cond->cond_mutex);
  pthread_mutex_unlock(&cond->cond_mutex);
}

// _shout_thread_create_c
// file thread.c line 264
struct anonymous$18 * _shout_thread_create_c(char *name, void * (*start_routine)(void *), void *arg, signed int detached, signed int line, char *file)
{
  signed int ok = 1;
  struct anonymous$18 *thread = (struct anonymous$18 *)(void *)0;
  struct thread_start_tag *start = (struct thread_start_tag *)(void *)0;
  union pthread_attr_t attr;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$18) /*48ul*/ );
  thread = (struct anonymous$18 *)return_value_calloc$1;
  signed long int tmp_post$4;
  while(!(thread == ((struct anonymous$18 *)NULL)))
  {
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct thread_start_tag) /*32ul*/ );
    start = (struct thread_start_tag *)return_value_calloc$2;
    if(start == ((struct thread_start_tag *)NULL))
      break;

    signed int return_value_pthread_attr_init$3;
    return_value_pthread_attr_init$3=pthread_attr_init(&attr);
    if(!(return_value_pthread_attr_init$3 >= 0))
      break;

    thread->line = line;
    thread->file=strdup(file);
    _mutex_lock(&_threadtree_mutex);
    tmp_post$4 = _next_thread_id;
    _next_thread_id = _next_thread_id + 1l;
    thread->thread_id = tmp_post$4;
    _mutex_unlock(&_threadtree_mutex);
    thread->name=strdup(name);
    thread->create_time=time((signed long int *)(void *)0);
    start->start_routine = start_routine;
    start->arg = arg;
    start->thread = thread;
    pthread_attr_setstacksize(&attr, (unsigned long int)(512 * 1024));
    pthread_attr_setinheritsched(&attr, 0);
    if(!(detached == 0))
    {
      pthread_attr_setdetachstate(&attr, 1);
      thread->detached = 1;
    }

    signed int return_value_pthread_create$5;
    return_value_pthread_create$5=pthread_create(&thread->sys_thread, &attr, _start_routine, (void *)start);
    if(return_value_pthread_create$5 == 0)
    {
      pthread_attr_destroy(&attr);
      return thread;
    }

    else
      pthread_attr_destroy(&attr);
    break;
  }
  if(!(start == ((struct thread_start_tag *)NULL)))
    free((void *)start);

  if(!(thread == ((struct anonymous$18 *)NULL)))
    free((void *)thread);

  return (struct anonymous$18 *)(void *)0;
}

// _shout_thread_exit_c
// file thread.c line 562
void _shout_thread_exit_c(signed long int val, signed int line, char *file)
{
  struct anonymous$18 *th;
  th=_shout_thread_self();
  if(!(th == ((struct anonymous$18 *)NULL)))
  {
    if(!(th->detached == 0))
    {
      _mutex_lock(&_threadtree_mutex);
      _shout_avl_delete(_threadtree, (void *)th, _free_thread);
      _mutex_unlock(&_threadtree_mutex);
    }

  }

  pthread_exit((void *)val);
}

// _shout_thread_initialize
// file thread.c line 138
void _shout_thread_initialize(void)
{
  struct anonymous$18 *thread;
  _shout_thread_mutex_create(&_threadtree_mutex, 164, "thread.c");
  _shout_thread_mutex_create(&_library_mutex, 165, "thread.c");
  _threadtree=_shout_avl_tree_new(_compare_threads, (void *)0);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$18) /*48ul*/ );
  thread = (struct anonymous$18 *)return_value_malloc$1;
  signed long int tmp_post$2 = _next_thread_id;
  _next_thread_id = _next_thread_id + 1l;
  thread->thread_id = tmp_post$2;
  thread->line = 0;
  thread->file=strdup("main.c");
  thread->sys_thread=pthread_self();
  thread->create_time=time((signed long int *)(void *)0);
  thread->name=strdup("Main Thread");
  _shout_avl_insert(_threadtree, (void *)thread);
  _catch_signals();
  _initialized$link2 = 1;
}

// _shout_thread_join
// file thread.c line 738
void _shout_thread_join(struct anonymous$18 *thread)
{
  void *ret;
  signed int i;
  i=pthread_join(thread->sys_thread, &ret);
  _mutex_lock(&_threadtree_mutex);
  _shout_avl_delete(_threadtree, (void *)thread, _free_thread);
  _mutex_unlock(&_threadtree_mutex);
}

// _shout_thread_library_lock
// file thread.c line 728
void _shout_thread_library_lock(void)
{
  _mutex_lock(&_library_mutex);
}

// _shout_thread_library_unlock
// file thread.c line 733
void _shout_thread_library_unlock(void)
{
  _mutex_unlock(&_library_mutex);
}

// _shout_thread_mutex_create
// file ./../thread/thread.h line 168
void _shout_thread_mutex_create(struct anonymous$31 *mutex, signed int line, char *file)
{
  _mutex_create(mutex);
}

// _shout_thread_mutex_destroy
// file ./../thread/thread.h line 171
void _shout_thread_mutex_destroy(struct anonymous$31 *mutex)
{
  pthread_mutex_destroy(&mutex->sys_mutex);
}

// _shout_thread_mutex_lock_c
// file thread.c line 359
void _shout_thread_mutex_lock_c(struct anonymous$31 *mutex, signed int line, char *file)
{
  _mutex_lock(mutex);
}

// _shout_thread_mutex_unlock_c
// file thread.c line 431
void _shout_thread_mutex_unlock_c(struct anonymous$31 *mutex, signed int line, char *file)
{
  _mutex_unlock(mutex);
}

// _shout_thread_rename
// file thread.c line 707
void _shout_thread_rename(const char *name)
{
  struct anonymous$18 *th;
  th=_shout_thread_self();
  if(!(th->name == ((char *)NULL)))
    free((void *)th->name);

  th->name=strdup(name);
}

// _shout_thread_rwlock_create_c
// file ./../thread/thread.h line 178
void _shout_thread_rwlock_create_c(struct anonymous$8 *rwlock, signed int line, char *file)
{
  pthread_rwlock_init(&rwlock->sys_rwlock, (const union anonymous$20 *)(void *)0);
}

// _shout_thread_rwlock_destroy
// file ./../thread/thread.h line 182
void _shout_thread_rwlock_destroy(struct anonymous$8 *rwlock)
{
  pthread_rwlock_destroy(&rwlock->sys_rwlock);
}

// _shout_thread_rwlock_rlock_c
// file ./../thread/thread.h line 179
void _shout_thread_rwlock_rlock_c(struct anonymous$8 *rwlock, signed int line, char *file)
{
  pthread_rwlock_rdlock(&rwlock->sys_rwlock);
}

// _shout_thread_rwlock_unlock_c
// file ./../thread/thread.h line 181
void _shout_thread_rwlock_unlock_c(struct anonymous$8 *rwlock, signed int line, char *file)
{
  pthread_rwlock_unlock(&rwlock->sys_rwlock);
}

// _shout_thread_rwlock_wlock_c
// file ./../thread/thread.h line 180
void _shout_thread_rwlock_wlock_c(struct anonymous$8 *rwlock, signed int line, char *file)
{
  pthread_rwlock_wrlock(&rwlock->sys_rwlock);
}

// _shout_thread_self
// file thread.c line 669
struct anonymous$18 * _shout_thread_self(void)
{
  struct avl_node_tag *node;
  struct anonymous$18 *th;
  unsigned long int sys_thread;
  sys_thread=pthread_self();
  _mutex_lock(&_threadtree_mutex);
  signed int return_value_pthread_equal$1;
  if(_threadtree == ((struct _avl_tree *)NULL))
  {
    _mutex_unlock(&_threadtree_mutex);
    return (struct anonymous$18 *)(void *)0;
  }

  else
  {
    node=_shout_avl_get_first(_threadtree);
    while(!(node == ((struct avl_node_tag *)NULL)))
    {
      th = (struct anonymous$18 *)node->key;
      if(!(th == ((struct anonymous$18 *)NULL)))
      {
        return_value_pthread_equal$1=pthread_equal(sys_thread, th->sys_thread);
        if(!(return_value_pthread_equal$1 == 0))
        {
          _mutex_unlock(&_threadtree_mutex);
          return th;
        }

      }

      node=_shout_avl_get_next(node);
    }
    _mutex_unlock(&_threadtree_mutex);
    return (struct anonymous$18 *)(void *)0;
  }
}

// _shout_thread_shutdown
// file thread.c line 187
void _shout_thread_shutdown(void)
{
  if(_initialized$link2 == 1)
  {
    _shout_thread_mutex_destroy(&_library_mutex);
    _shout_thread_mutex_destroy(&_threadtree_mutex);
    _shout_avl_tree_free(_threadtree, _free_thread);
    _threadtree = (struct _avl_tree *)(void *)0;
  }

}

// _shout_thread_sleep
// file thread.c line 604
void _shout_thread_sleep(unsigned long int len)
{
  struct timespec time_sleep;
  struct timespec time_remaining;
  signed int ret;
  time_sleep.tv_sec = (signed long int)(len / (unsigned long int)1000000);
  time_sleep.tv_nsec = (signed long int)((len % (unsigned long int)1000000) * (unsigned long int)1000);
  ret=nanosleep(&time_sleep, &time_remaining);
  signed int *return_value___errno_location$1;
  while(!(ret == 0))
  {
    return_value___errno_location$1=__errno_location();
    if(!(*return_value___errno_location$1 == 4))
      break;

    time_sleep.tv_sec = time_remaining.tv_sec;
    time_sleep.tv_nsec = time_remaining.tv_nsec;
    ret=nanosleep(&time_sleep, &time_remaining);
  }
}

// _shout_timing_get_time
// file timing/timing.h line 29
unsigned long int _shout_timing_get_time(void)
{
  struct timeval mtv;
  gettimeofday(&mtv, (void *)0);
  return (unsigned long int)mtv.tv_sec * (unsigned long int)1000 + (unsigned long int)mtv.tv_usec / (unsigned long int)1000;
}

// _shout_timing_sleep
// file timing/timing.h line 30
void _shout_timing_sleep(unsigned long int sleeptime)
{
  struct timeval sleeper;
  sleeper.tv_sec = (signed long int)(sleeptime / (unsigned long int)1000);
  sleeper.tv_usec = (signed long int)((sleeptime % (unsigned long int)1000) * (unsigned long int)1000);
  select(1, (struct anonymous$12 *)(void *)0, (struct anonymous$12 *)(void *)0, (struct anonymous$12 *)(void *)0, &sleeper);
}

// _shout_util_base64_encode
// file util.h line 23
char * _shout_util_base64_encode(char *data)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(data);
  len = (signed int)return_value_strlen$1;
  char *out;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)((len * 4) / 3 + 4));
  out = (char *)return_value_malloc$2;
  char *result = out;
  signed int chunk;
  char *tmp_post$3;
  char *tmp_post$4;
  char *tmp_post$5;
  char *tmp_post$6;
  char *tmp_post$7;
  char *tmp_post$8;
  char *tmp_post$9;
  char *tmp_post$10;
  for( ; len >= 1; len = len - chunk)
  {
    chunk = len > 3 ? 3 : len;
    tmp_post$3 = out;
    out = out + 1l;
    *tmp_post$3 = base64table[(signed long int)(((signed int)*data & 0xFC) >> 2)];
    tmp_post$4 = out;
    out = out + 1l;
    *tmp_post$4 = base64table[(signed long int)(((signed int)*data & 0x03) << 4 | ((signed int)data[(signed long int)1] & 0xF0) >> 4)];
    switch(chunk)
    {
      case 3:
      {
        tmp_post$5 = out;
        out = out + 1l;
        *tmp_post$5 = base64table[(signed long int)(((signed int)data[(signed long int)1] & 0x0F) << 2 | ((signed int)data[(signed long int)2] & 0xC0) >> 6)];
        tmp_post$6 = out;
        out = out + 1l;
        *tmp_post$6 = base64table[(signed long int)((signed int)data[(signed long int)2] & 0x3F)];
        break;
      }
      case 2:
      {
        tmp_post$7 = out;
        out = out + 1l;
        *tmp_post$7 = base64table[(signed long int)(((signed int)data[(signed long int)1] & 0x0F) << 2)];
        tmp_post$8 = out;
        out = out + 1l;
        *tmp_post$8 = (char)61;
        break;
      }
      case 1:
      {
        tmp_post$9 = out;
        out = out + 1l;
        *tmp_post$9 = (char)61;
        tmp_post$10 = out;
        out = out + 1l;
        *tmp_post$10 = (char)61;
      }
    }
    data = data + (signed long int)chunk;
  }
  *out = (char)0;
  return result;
}

// _shout_util_dict_free
// file util.h line 17
void _shout_util_dict_free(struct _util_dict *dict)
{
  struct _util_dict *next;
  for( ; !(dict == ((struct _util_dict *)NULL)); dict = next)
  {
    next = dict->next;
    if(!(dict->key == ((char *)NULL)))
      free((void *)dict->key);

    if(!(dict->val == ((char *)NULL)))
      free((void *)dict->val);

    free((void *)dict);
  }
}

// _shout_util_dict_get
// file util.h line 20
const char * _shout_util_dict_get(struct _util_dict *dict, const char *key)
{
  signed int return_value_strcmp$1;
  while(!(dict == ((struct _util_dict *)NULL)))
  {
    if(!(dict->key == ((char *)NULL)))
    {
      return_value_strcmp$1=strcmp(key, dict->key);
      if(return_value_strcmp$1 == 0)
        return dict->val;

    }

    dict = dict->next;
  }
  return (const char *)(void *)0;
}

// _shout_util_dict_new
// file util.h line 16
struct _util_dict * _shout_util_dict_new(void)
{
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct _util_dict) /*24ul*/ );
  return (struct _util_dict *)return_value_calloc$1;
}

// _shout_util_dict_set
// file util.h line 19
signed int _shout_util_dict_set(struct _util_dict *dict, const char *key, const char *val)
{
  struct _util_dict *prev;
  _Bool tmp_if_expr$2;
  signed int return_value_strcmp$1;
  if(key == ((const char *)NULL) || dict == ((struct _util_dict *)NULL))
    return -1;

  else
  {
    prev = (struct _util_dict *)(void *)0;
    while(!(dict == ((struct _util_dict *)NULL)))
    {
      if(dict->key == ((char *)NULL))
        tmp_if_expr$2 = (_Bool)1;

      else
      {
        return_value_strcmp$1=strcmp(dict->key, key);
        tmp_if_expr$2 = !(return_value_strcmp$1 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$2)
        break;

      prev = dict;
      dict = dict->next;
    }
    if(dict == ((struct _util_dict *)NULL))
    {
      dict=_shout_util_dict_new();
      if(dict == ((struct _util_dict *)NULL))
        return -5;

      if(!(prev == ((struct _util_dict *)NULL)))
        prev->next = dict;

    }

    if(!(dict->key == ((char *)NULL)))
      free((void *)dict->val);

    else
    {
      dict->key=strdup(key);
      if(dict->key == ((char *)NULL))
      {
        if(!(prev == ((struct _util_dict *)NULL)))
          prev->next = (struct _util_dict *)(void *)0;

        _shout_util_dict_free(dict);
        return -5;
      }

    }
    dict->val=strdup(val);
    if(dict->val == ((char *)NULL))
      return -5;

    else
      return 0;
  }
}

// _shout_util_dict_urlencode
// file util.h line 21
char * _shout_util_dict_urlencode(struct _util_dict *dict, char delim)
{
  char *res;
  char *tmp;
  char *enc;
  signed int start = 1;
  res = (char *)(void *)0;
  for( ; !(dict == ((struct _util_dict *)NULL)); dict = dict->next)
    if(!(dict->key == ((char *)NULL)))
    {
      enc=_shout_util_url_encode(dict->key);
      if(enc == ((char *)NULL))
      {
        if(!(res == ((char *)NULL)))
          free((void *)res);

        return (char *)(void *)0;
      }

      if(!(start == 0))
      {
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(enc);
        void *return_value_malloc$2;
        return_value_malloc$2=malloc(return_value_strlen$1 + (unsigned long int)1);
        res = (char *)return_value_malloc$2;
        if(res == ((char *)NULL))
        {
          free((void *)enc);
          return (char *)(void *)0;
        }

        sprintf(res, "%s", enc);
        free((void *)enc);
        start = 0;
      }

      else
      {
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(res);
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(enc);
        void *return_value_realloc$5;
        return_value_realloc$5=realloc((void *)res, return_value_strlen$3 + return_value_strlen$4 + (unsigned long int)2);
        tmp = (char *)return_value_realloc$5;
        if(tmp == ((char *)NULL))
        {
          free((void *)enc);
          free((void *)res);
          return (char *)(void *)0;
        }

        else
          res = tmp;
        unsigned long int return_value_strlen$6;
        return_value_strlen$6=strlen(res);
        sprintf(res + (signed long int)return_value_strlen$6, "%c%s", delim, enc);
        free((void *)enc);
      }
      if(!(dict->val == ((char *)NULL)))
      {
        enc=_shout_util_url_encode(dict->val);
        if(enc == ((char *)NULL))
        {
          free((void *)res);
          return (char *)(void *)0;
        }

        unsigned long int return_value_strlen$7;
        return_value_strlen$7=strlen(res);
        unsigned long int return_value_strlen$8;
        return_value_strlen$8=strlen(enc);
        void *return_value_realloc$9;
        return_value_realloc$9=realloc((void *)res, return_value_strlen$7 + return_value_strlen$8 + (unsigned long int)2);
        tmp = (char *)return_value_realloc$9;
        if(tmp == ((char *)NULL))
        {
          free((void *)enc);
          free((void *)res);
          return (char *)(void *)0;
        }

        else
          res = tmp;
        unsigned long int return_value_strlen$10;
        return_value_strlen$10=strlen(res);
        sprintf(res + (signed long int)return_value_strlen$10, "=%s", enc);
        free((void *)enc);
      }

    }

  return res;
}

// _shout_util_read_header
// file util.c line 47
signed int _shout_util_read_header(signed int sock, char *buff, unsigned long int len)
{
  signed int read_bytes;
  signed int ret;
  unsigned long int pos;
  char c;
  read_bytes = 1;
  pos = (unsigned long int)0;
  ret = 0;
  unsigned long int tmp_post$1;
  while(read_bytes == 1 && !(pos >= len + 18446744073709551615ul))
  {
    read_bytes = 0;
    signed long int return_value_recv$2;
    return_value_recv$2=recv(sock, (void *)&c, (unsigned long int)1, 0);
    read_bytes = (signed int)return_value_recv$2;
    if(!(read_bytes == 0))
    {
      if(!((signed int)c == 13))
      {
        tmp_post$1 = pos;
        pos = pos + 1ul;
        buff[(signed long int)tmp_post$1] = c;
      }

      if(pos >= 2ul)
      {
        if((signed int)buff[-1l + (signed long int)pos] == 10)
        {
          if((signed int)buff[-2l + (signed long int)pos] == 10)
          {
            ret = 1;
            break;
          }

        }

      }

    }

    else
      break;
  }
  if(!(ret == 0))
    buff[(signed long int)pos] = (char)0;

  return ret;
}

// _shout_util_strdup
// file util.h line 14
char * _shout_util_strdup(const char *s)
{
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    char *return_value_strdup$1;
    return_value_strdup$1=strdup(s);
    return return_value_strdup$1;
  }
}

// _shout_util_url_encode
// file util.c line 144
char * _shout_util_url_encode(const char *data)
{
  const char *p;
  char *q;
  char *dest;
  signed int digit;
  unsigned long int n;
  p = data;
  n = (unsigned long int)0;
  for( ; !(*p == 0); p = p + 1l)
  {
    n = n + 1ul;
    if(safechars[(signed long int)(unsigned char)*p] == 0)
      n = n + (unsigned long int)2;

  }
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(n + (unsigned long int)1);
  dest = (char *)return_value_malloc$1;
  char *tmp_post$2;
  char *tmp_post$3;
  if(dest == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    p = data;
    q = dest;
    for( ; !(*p == 0); q = q + 1l)
    {
      if(!(safechars[(signed long int)(unsigned char)*p] == 0))
        *q = *p;

      else
      {
        tmp_post$2 = q;
        q = q + 1l;
        *tmp_post$2 = (char)37;
        digit = (signed int)*p >> 4 & 0xF;
        tmp_post$3 = q;
        q = q + 1l;
        *tmp_post$3 = urltable[(signed long int)digit];
        digit = (signed int)*p & 0xf;
        *q = urltable[(signed long int)digit];
        n = n + (unsigned long int)2;
      }
      p = p + 1l;
    }
    *q = (char)0;
    return dest;
  }
}

// _start_routine
// file thread.c line 635
static void * _start_routine(void *arg)
{
  struct thread_start_tag *start = (struct thread_start_tag *)arg;
  void * (*start_routine)(void *) = start->start_routine;
  void *real_arg = start->arg;
  struct anonymous$18 *thread = start->thread;
  _block_signals();
  _mutex_lock(&_threadtree_mutex);
  thread->sys_thread=pthread_self();
  _shout_avl_insert(_threadtree, (void *)thread);
  _mutex_unlock(&_threadtree_mutex);
  pthread_setcancelstate(0, (signed int *)(void *)0);
  free((void *)start);
  start_routine(real_arg);
  if(!(thread->detached == 0))
  {
    _mutex_lock(&_threadtree_mutex);
    _shout_avl_delete(_threadtree, (void *)thread, _free_thread);
    _mutex_unlock(&_threadtree_mutex);
  }

  return (void *)0;
}

// avl_get_index_by_key
// file avl.c line 772
static struct avl_node_tag * avl_get_index_by_key(struct _avl_tree *tree, void *key, unsigned long int *index)
{
  struct avl_node_tag *x = tree->root->right;
  unsigned long int m;
  if(x == ((struct avl_node_tag *)NULL))
    return (struct avl_node_tag *)(void *)0;

  else
  {
    m = (unsigned long int)(x->rank_and_balance >> 2);
    {
      signed int compare_result;
      compare_result=tree->compare_fun(tree->compare_arg, key, x->key);
      if(!(compare_result >= 0))
      {
        if(!(x->left == ((struct avl_node_tag *)NULL)))
        {
          m = m - (unsigned long int)(x->rank_and_balance >> 2);
          x = x->left;
          m = m + (unsigned long int)(x->rank_and_balance >> 2);
        }

        else
        {
          *index = m - (unsigned long int)2;
          return (struct avl_node_tag *)(void *)0;
        }
      }

      else
        if(compare_result >= 1)
        {
          if(!(x->right == ((struct avl_node_tag *)NULL)))
          {
            x = x->right;
            m = m + (unsigned long int)(x->rank_and_balance >> 2);
          }

          else
          {
            *index = m - (unsigned long int)1;
            return (struct avl_node_tag *)(void *)0;
          }
        }

        else
        {
          *index = m - (unsigned long int)1;
          return x;
        }
    }
  }
}

// avl_iterate_inorder_helper
// file avl.c line 627
static signed int avl_iterate_inorder_helper(struct avl_node_tag *node, signed int (*iter_fun)(void *, void *), void *iter_arg)
{
  signed int result;
  if(!(node->left == ((struct avl_node_tag *)NULL)))
  {
    result=avl_iterate_inorder_helper(node->left, iter_fun, iter_arg);
    if(result == 0)
      goto __CPROVER_DUMP_L1;

    return result;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    result=iter_fun(node->key, iter_arg);
    if(!(result == 0))
      return result;

    else
      if(!(node->right == ((struct avl_node_tag *)NULL)))
      {
        result=avl_iterate_inorder_helper(node->right, iter_fun, iter_arg);
        return result;
      }

      else
        return 0;
  }
}

// avl_tree_free_helper
// file avl.c line 90
static void avl_tree_free_helper(struct avl_node_tag *node, signed int (*free_key_fun)(void *))
{
  if(!(node->left == ((struct avl_node_tag *)NULL)))
    avl_tree_free_helper(node->left, free_key_fun);

  if(!(free_key_fun == ((signed int (*)(void *))NULL)))
    free_key_fun(node->key);

  if(!(node->right == ((struct avl_node_tag *)NULL)))
    avl_tree_free_helper(node->right, free_key_fun);

  free((void *)node);
}

// avl_verify_balance
// file avl.c line 995
static signed long int avl_verify_balance(struct avl_node_tag *node)
{
  if(node == ((struct avl_node_tag *)NULL))
    return (signed long int)0;

  else
  {
    signed long int lh;
    lh=avl_verify_balance(node->left);
    signed long int rh;
    rh=avl_verify_balance(node->right);
    if(!(rh + -lh == (signed long int)((3 & (signed int)node->rank_and_balance) + -1)))
      return (signed long int)0;

    if(lh + -rh >= 2l || !(lh + -rh >= -1l))
      return (signed long int)0;

    return (signed long int)1 + (lh > rh ? lh : rh);
  }
}

// avl_verify_parent
// file avl.c line 1013
static void avl_verify_parent(struct avl_node_tag *node, struct avl_node_tag *parent)
{
  if(node->parent == parent)
  {
    if(!(node->left == ((struct avl_node_tag *)NULL)))
      avl_verify_parent(node->left, node);

    if(!(node->right == ((struct avl_node_tag *)NULL)))
      avl_verify_parent(node->right, node);

  }

}

// avl_verify_rank
// file avl.c line 1027
static signed long int avl_verify_rank(struct avl_node_tag *node)
{
  if(node == ((struct avl_node_tag *)NULL))
    return (signed long int)0;

  else
  {
    unsigned long int num_left = (unsigned long int)0;
    unsigned long int num_right = (unsigned long int)0;
    if(!(node->left == ((struct avl_node_tag *)NULL)))
    {
      signed long int return_value_avl_verify_rank$1;
      return_value_avl_verify_rank$1=avl_verify_rank(node->left);
      num_left = (unsigned long int)return_value_avl_verify_rank$1;
    }

    if(!(node->right == ((struct avl_node_tag *)NULL)))
    {
      signed long int return_value_avl_verify_rank$2;
      return_value_avl_verify_rank$2=avl_verify_rank(node->right);
      num_right = (unsigned long int)return_value_avl_verify_rank$2;
    }

    if(!((unsigned long int)(node->rank_and_balance >> 2) == 1ul + num_left))
    {
      fprintf(stderr, "invalid rank at node %ld\n", (signed long int)node->key);
      exit(1);
    }

    return (signed long int)(num_left + num_right + (unsigned long int)1);
  }
}

// close_mp3
// file mp3.c line 314
static void close_mp3(struct shout *self)
{
  struct anonymous$33 *mp3_data = (struct anonymous$33 *)self->format_data;
  free((void *)mp3_data);
}

// close_ogg
// file ogg.c line 141
static void close_ogg(struct shout *self)
{
  struct anonymous$17 *ogg_data = (struct anonymous$17 *)self->format_data;
  free_codecs(ogg_data);
  ogg_sync_clear(&ogg_data->oy);
  free((void *)ogg_data);
}

// close_webm
// file webm.c line 64
static void close_webm(struct shout *self)
{
  ;
}

// collect_queue
// file shout.c line 1050
static signed int collect_queue(struct _shout_buf *queue, char **buf)
{
  struct _shout_buf *node;
  signed int pos = 0;
  signed int len = 0;
  node = queue;
  for( ; !(node == ((struct _shout_buf *)NULL)); node = node->next)
    len = len + (signed int)node->len;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)len);
  *buf = (char *)return_value_malloc$1;
  if(*buf == ((char *)NULL))
    return -5;

  else
  {
    node = queue;
    for( ; !(node == ((struct _shout_buf *)NULL)); node = node->next)
    {
      memcpy((void *)(*buf + (signed long int)pos), (const void *)node->data, (unsigned long int)node->len);
      pos = pos + (signed int)node->len;
    }
    return len;
  }
}

// create_http_request
// file shout.c line 1111
static signed int create_http_request(struct shout *self)
{
  char *auth;
  char *ai;
  signed int ret = -5;
  signed int return_value_queue_printf$3;
  signed int return_value_queue_printf$4;
  signed int return_value_queue_printf$5;
  signed int return_value_queue_printf$6;
  char *tmp_if_expr$7;
  signed int return_value_queue_printf$10;
  signed int return_value_queue_printf$11;
  signed int return_value_queue_printf$13;
  do
  {
    signed int return_value_queue_printf$1;
    return_value_queue_printf$1=queue_printf(self, "SOURCE %s HTTP/1.0\r\n", self->mount);
    if(!(return_value_queue_printf$1 == 0))
      break;

    if(!(self->password == ((char *)NULL)))
    {
      auth=http_basic_authorization(self);
      if(auth == ((char *)NULL))
        break;

      signed int return_value_queue_str$2;
      return_value_queue_str$2=queue_str(self, auth);
      if(!(return_value_queue_str$2 == 0))
      {
        free((void *)auth);
        break;
      }

      free((void *)auth);
    }

    if(!(self->useragent == ((char *)NULL)))
    {
      return_value_queue_printf$3=queue_printf(self, "User-Agent: %s\r\n", self->useragent);
      if(!(return_value_queue_printf$3 == 0))
        break;

    }

    if(self->format == 0u)
    {
      return_value_queue_printf$4=queue_printf(self, "Content-Type: application/ogg\r\n");
      if(!(return_value_queue_printf$4 == 0))
        break;

    }

    if(self->format == 1u)
    {
      return_value_queue_printf$5=queue_printf(self, "Content-Type: audio/mpeg\r\n");
      if(!(return_value_queue_printf$5 == 0))
        break;

    }

    if(self->format == 2u)
    {
      return_value_queue_printf$6=queue_printf(self, "Content-Type: video/webm\r\n");
      if(!(return_value_queue_printf$6 == 0))
        break;

    }

    if(!(self->name == ((char *)NULL)))
      tmp_if_expr$7 = self->name;

    else
      tmp_if_expr$7 = "no name";
    signed int return_value_queue_printf$8;
    return_value_queue_printf$8=queue_printf(self, "ice-name: %s\r\n", tmp_if_expr$7);
    if(!(return_value_queue_printf$8 == 0))
      break;

    signed int return_value_queue_printf$9;
    return_value_queue_printf$9=queue_printf(self, "ice-public: %d\r\n", self->public);
    if(!(return_value_queue_printf$9 == 0))
      break;

    if(!(self->url == ((char *)NULL)))
    {
      return_value_queue_printf$10=queue_printf(self, "ice-url: %s\r\n", self->url);
      if(!(return_value_queue_printf$10 == 0))
        break;

    }

    if(!(self->genre == ((char *)NULL)))
    {
      return_value_queue_printf$11=queue_printf(self, "ice-genre: %s\r\n", self->genre);
      if(!(return_value_queue_printf$11 == 0))
        break;

    }

    ai=_shout_util_dict_urlencode(self->audio_info, (char)59);
    if(!(ai == ((char *)NULL)))
    {
      signed int return_value_queue_printf$12;
      return_value_queue_printf$12=queue_printf(self, "ice-audio-info: %s\r\n", ai);
      if(!(return_value_queue_printf$12 == 0))
      {
        free((void *)ai);
        break;
      }

      free((void *)ai);
    }

    if(!(self->description == ((char *)NULL)))
    {
      return_value_queue_printf$13=queue_printf(self, "ice-description: %s\r\n", self->description);
      if(!(return_value_queue_printf$13 == 0))
        break;

    }

    signed int return_value_queue_str$14;
    return_value_queue_str$14=queue_str(self, "\r\n");
    if(!(return_value_queue_str$14 == 0))
      break;

    ret = 0;
  }
  while((_Bool)0);
  return ret;
}

// create_icy_request
// file shout.c line 1290
static signed int create_icy_request(struct shout *self)
{
  const char *create_icy_request$$1$$bitrate;
  signed int ret;
  create_icy_request$$1$$bitrate=shout_get_audio_info(self, "bitrate");
  if(create_icy_request$$1$$bitrate == ((const char *)NULL))
    create_icy_request$$1$$bitrate = "0";

  ret = -5;
  char *tmp_if_expr$2;
  char *tmp_if_expr$4;
  char *tmp_if_expr$8;
  do
  {
    signed int return_value_queue_printf$1;
    return_value_queue_printf$1=queue_printf(self, "%s\n", self->password);
    if(!(return_value_queue_printf$1 == 0))
      break;

    if(!(self->name == ((char *)NULL)))
      tmp_if_expr$2 = self->name;

    else
      tmp_if_expr$2 = "unnamed";
    signed int return_value_queue_printf$3;
    return_value_queue_printf$3=queue_printf(self, "icy-name:%s\n", tmp_if_expr$2);
    if(!(return_value_queue_printf$3 == 0))
      break;

    if(!(self->url == ((char *)NULL)))
      tmp_if_expr$4 = self->url;

    else
      tmp_if_expr$4 = "http://www.icecast.org/";
    signed int return_value_queue_printf$5;
    return_value_queue_printf$5=queue_printf(self, "icy-url:%s\n", tmp_if_expr$4);
    if(!(return_value_queue_printf$5 == 0))
      break;

    signed int return_value_queue_str$6;
    return_value_queue_str$6=queue_str(self, "icy-irc:\nicy-aim:\nicy-icq:\n");
    if(!(return_value_queue_str$6 == 0))
      break;

    signed int return_value_queue_printf$7;
    return_value_queue_printf$7=queue_printf(self, "icy-pub:%i\n", self->public);
    if(!(return_value_queue_printf$7 == 0))
      break;

    if(!(self->genre == ((char *)NULL)))
      tmp_if_expr$8 = self->genre;

    else
      tmp_if_expr$8 = "icecast";
    signed int return_value_queue_printf$9;
    return_value_queue_printf$9=queue_printf(self, "icy-genre:%s\n", tmp_if_expr$8);
    if(!(return_value_queue_printf$9 == 0))
      break;

    signed int return_value_queue_printf$10;
    return_value_queue_printf$10=queue_printf(self, "icy-br:%s\n\n", create_icy_request$$1$$bitrate);
    if(!(return_value_queue_printf$10 == 0))
      break;

    ret = 0;
  }
  while((_Bool)0);
  return ret;
}

// create_request
// file shout.c line 1099
static signed int create_request(struct shout *self)
{
  signed int return_value_create_http_request$1;
  signed int return_value_create_xaudiocast_request$2;
  signed int return_value_create_icy_request$3;
  if(self->protocol == 0u)
  {
    return_value_create_http_request$1=create_http_request(self);
    return return_value_create_http_request$1;
  }

  else
    if(self->protocol == 1u)
    {
      return_value_create_xaudiocast_request$2=create_xaudiocast_request(self);
      return return_value_create_xaudiocast_request$2;
    }

    else
      if(self->protocol == 2u)
      {
        return_value_create_icy_request$3=create_icy_request(self);
        return return_value_create_icy_request$3;
      }

  self->error = -9;
  return self->error;
}

// create_xaudiocast_request
// file shout.c line 1237
static signed int create_xaudiocast_request(struct shout *self)
{
  const char *create_xaudiocast_request$$1$$bitrate;
  signed int ret;
  create_xaudiocast_request$$1$$bitrate=shout_get_audio_info(self, "bitrate");
  if(create_xaudiocast_request$$1$$bitrate == ((const char *)NULL))
    create_xaudiocast_request$$1$$bitrate = "0";

  ret = -5;
  char *tmp_if_expr$2;
  char *tmp_if_expr$4;
  char *tmp_if_expr$6;
  char *tmp_if_expr$10;
  signed int return_value_queue_printf$12;
  do
  {
    signed int return_value_queue_printf$1;
    return_value_queue_printf$1=queue_printf(self, "SOURCE %s %s\n", self->password, self->mount);
    if(!(return_value_queue_printf$1 == 0))
      break;

    if(!(self->name == ((char *)NULL)))
      tmp_if_expr$2 = self->name;

    else
      tmp_if_expr$2 = "unnamed";
    signed int return_value_queue_printf$3;
    return_value_queue_printf$3=queue_printf(self, "x-audiocast-name: %s\n", tmp_if_expr$2);
    if(!(return_value_queue_printf$3 == 0))
      break;

    if(!(self->url == ((char *)NULL)))
      tmp_if_expr$4 = self->url;

    else
      tmp_if_expr$4 = "http://www.icecast.org/";
    signed int return_value_queue_printf$5;
    return_value_queue_printf$5=queue_printf(self, "x-audiocast-url: %s\n", tmp_if_expr$4);
    if(!(return_value_queue_printf$5 == 0))
      break;

    if(!(self->genre == ((char *)NULL)))
      tmp_if_expr$6 = self->genre;

    else
      tmp_if_expr$6 = "icecast";
    signed int return_value_queue_printf$7;
    return_value_queue_printf$7=queue_printf(self, "x-audiocast-genre: %s\n", tmp_if_expr$6);
    if(!(return_value_queue_printf$7 == 0))
      break;

    signed int return_value_queue_printf$8;
    return_value_queue_printf$8=queue_printf(self, "x-audiocast-bitrate: %s\n", create_xaudiocast_request$$1$$bitrate);
    if(!(return_value_queue_printf$8 == 0))
      break;

    signed int return_value_queue_printf$9;
    return_value_queue_printf$9=queue_printf(self, "x-audiocast-public: %i\n", self->public);
    if(!(return_value_queue_printf$9 == 0))
      break;

    if(!(self->description == ((char *)NULL)))
      tmp_if_expr$10 = self->description;

    else
      tmp_if_expr$10 = "Broadcasting with the icecast streaming media server!";
    signed int return_value_queue_printf$11;
    return_value_queue_printf$11=queue_printf(self, "x-audiocast-description: %s\n", tmp_if_expr$10);
    if(!(return_value_queue_printf$11 == 0))
      break;

    if(!(self->dumpfile == ((char *)NULL)))
    {
      return_value_queue_printf$12=queue_printf(self, "x-audiocast-dumpfile: %s\n", self->dumpfile);
      if(!(return_value_queue_printf$12 == 0))
        break;

    }

    signed int return_value_queue_str$13;
    return_value_queue_str$13=queue_str(self, "\n");
    if(!(return_value_queue_str$13 == 0))
      break;

    ret = 0;
  }
  while((_Bool)0);
  return ret;
}

// default_key_printer
// file avl.c line 1075
static signed int default_key_printer(char *buffer, void *key)
{
  signed int return_value_sprintf$1;
  return_value_sprintf$1=sprintf(buffer, "%p", key);
  return return_value_sprintf$1;
}

// free_codec
// file ogg.c line 185
static void free_codec(struct _ogg_codec_tag *codec)
{
  if(!(codec->free_data == ((void (*)(void *))NULL)))
    codec->free_data(codec->codec_data);

  ogg_stream_clear(&codec->os);
  free((void *)codec);
}

// free_codecs
// file ogg.c line 169
static void free_codecs(struct anonymous$17 *ogg_data)
{
  struct _ogg_codec_tag *codec;
  struct _ogg_codec_tag *next;
  if(!(ogg_data == ((struct anonymous$17 *)NULL)))
  {
    codec = ogg_data->codecs;
    for( ; !(codec == ((struct _ogg_codec_tag *)NULL)); codec = next)
    {
      next = codec->next;
      free_codec(codec);
    }
    ogg_data->codecs = (struct _ogg_codec_tag *)(void *)0;
  }

}

// free_opus_data
// file opus.c line 277
static void free_opus_data(void *codec_data)
{
  free(codec_data);
}

// free_speex_data
// file speex.c line 78
static void free_speex_data(void *codec_data)
{
  struct anonymous$11 *speex_data = (struct anonymous$11 *)codec_data;
  if(!(speex_data->sh == ((struct SpeexHeader *)NULL)))
    free((void *)speex_data->sh);

  free((void *)speex_data);
}

// free_theora_data
// file theora.c line 133
static void free_theora_data(void *codec_data)
{
  struct anonymous$6 *theora_data = (struct anonymous$6 *)codec_data;
  theora_info_clear(&theora_data->ti);
  theora_comment_clear(&theora_data->tc);
  free((void *)theora_data);
}

// free_vorbis_data
// file vorbis.c line 99
static void free_vorbis_data(void *codec_data)
{
  struct anonymous$30 *vorbis_data = (struct anonymous$30 *)codec_data;
  vorbis_info_clear(&vorbis_data->vi);
  vorbis_comment_clear(&vorbis_data->vc);
  free((void *)vorbis_data);
}

// get_response
// file shout.c line 889
static signed int get_response(struct shout *self)
{
  char buf[1024l];
  signed int rc;
  signed int blen;
  char *pc;
  struct _shout_buf *queue;
  signed int newlines = 0;
  rc=_shout_sock_read_bytes(self->socket, buf, sizeof(char [1024l]) /*1024ul*/ );
  signed int return_value__shout_sock_error$1;
  signed int return_value__shout_sock_recoverable$2;
  if(!(rc >= 0))
  {
    return_value__shout_sock_error$1=_shout_sock_error();
    return_value__shout_sock_recoverable$2=_shout_sock_recoverable(return_value__shout_sock_error$1);
    if(return_value__shout_sock_recoverable$2 == 0)
      goto __CPROVER_DUMP_L1;

    return -10;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(rc >= 1))
      return -4;

    else
    {
      rc=queue_data(&self->rqueue, (unsigned char *)buf, (unsigned long int)rc);
      if(!(rc == 0))
        return rc;

      else
      {
        queue = self->rqueue.head;
        for( ; !(queue->next == ((struct _shout_buf *)NULL)); queue = queue->next)
          ;
        pc = ((char *)queue->data + (signed long int)queue->len) - (signed long int)1;
        blen = (signed int)queue->len;
        while(!(blen == 0))
        {
          if((signed int)*pc == 10)
            newlines = newlines + 1;

          else
            if(!((signed int)*pc == 13))
              newlines = 0;

          if(newlines == 2)
            return 0;

          blen = blen - 1;
          pc = pc - 1l;
          if(blen == 0)
          {
            if(!(queue->prev == ((struct _shout_buf *)NULL)))
            {
              queue = queue->prev;
              pc = ((char *)queue->data + (signed long int)queue->len) - (signed long int)1;
              blen = (signed int)queue->len;
            }

          }

        }
        return -10;
      }
    }
  }
}

// hex
// file httpp.c line 192
static signed int hex(char c)
{
  if((signed int)c >= 48 && !((signed int)c >= 58))
    return (signed int)c - 48;

  else
    if((signed int)c >= 65 && !((signed int)c >= 71))
      return ((signed int)c - 65) + 10;

    else
      if((signed int)c >= 97 && !((signed int)c >= 103))
        return ((signed int)c - 97) + 10;

      else
        return -1;
}

// http_basic_authorization
// file shout.c line 1166
static char * http_basic_authorization(struct shout *self)
{
  char *out;
  char *in;
  signed int len;
  _Bool tmp_if_expr$1;
  if(self == ((struct shout *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(self->user != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(self->password != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(self->user);
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(self->password);
    len = (signed int)(return_value_strlen$3 + return_value_strlen$4 + (unsigned long int)2);
    void *return_value_malloc$5;
    return_value_malloc$5=malloc((unsigned long int)len);
    in = (char *)return_value_malloc$5;
    if(in == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      sprintf(in, "%s:%s", self->user, self->password);
      out=_shout_util_base64_encode(in);
      free((void *)in);
      unsigned long int return_value_strlen$6;
      return_value_strlen$6=strlen(out);
      len = (signed int)(return_value_strlen$6 + (unsigned long int)24);
      void *return_value_malloc$7;
      return_value_malloc$7=malloc((unsigned long int)len);
      in = (char *)return_value_malloc$7;
      if(in == ((char *)NULL))
      {
        free((void *)out);
        return (char *)(void *)0;
      }

      else
      {
        sprintf(in, "Authorization: Basic %s\r\n", out);
        free((void *)out);
        return in;
      }
    }
  }
}

// httpp_deletevar
// file httpp.c line 429
void httpp_deletevar(struct http_parser_tag *parser, const char *name)
{
  struct http_var_tag var;
  if(!(name == ((const char *)NULL)) && !(parser == ((struct http_parser_tag *)NULL)))
  {
    var.name = (char *)name;
    var.value = (char *)(void *)0;
    _shout_avl_delete(parser->vars, (void *)&var, _free_vars);
  }

}

// main
// file nonblocking.c line 13
signed int main()
{
  struct shout *shout;
  char buff[4096l];
  signed long int read;
  signed long int ret;
  signed long int total;
  shout_init();
  shout=shout_new();
  signed long int return_value_shout_queuelen$22;
  if(shout == ((struct shout *)NULL))
  {
    printf("Could not allocate shout_t\n");
    return 1;
  }

  else
  {
    signed int return_value_shout_set_host$2;
    return_value_shout_set_host$2=shout_set_host(shout, "127.0.0.1");
    if(!(return_value_shout_set_host$2 == 0))
    {
      const char *return_value_shout_get_error$1;
      return_value_shout_get_error$1=shout_get_error(shout);
      printf("Error setting hostname: %s\n", return_value_shout_get_error$1);
      return 1;
    }

    signed int return_value_shout_set_protocol$4;
    return_value_shout_set_protocol$4=shout_set_protocol(shout, (unsigned int)0);
    if(!(return_value_shout_set_protocol$4 == 0))
    {
      const char *return_value_shout_get_error$3;
      return_value_shout_get_error$3=shout_get_error(shout);
      printf("Error setting protocol: %s\n", return_value_shout_get_error$3);
      return 1;
    }

    signed int return_value_shout_set_port$6;
    return_value_shout_set_port$6=shout_set_port(shout, (unsigned short int)8000);
    if(!(return_value_shout_set_port$6 == 0))
    {
      const char *return_value_shout_get_error$5;
      return_value_shout_get_error$5=shout_get_error(shout);
      printf("Error setting port: %s\n", return_value_shout_get_error$5);
      return 1;
    }

    signed int return_value_shout_set_password$8;
    return_value_shout_set_password$8=shout_set_password(shout, "hackme");
    if(!(return_value_shout_set_password$8 == 0))
    {
      const char *return_value_shout_get_error$7;
      return_value_shout_get_error$7=shout_get_error(shout);
      printf("Error setting password: %s\n", return_value_shout_get_error$7);
      return 1;
    }

    signed int return_value_shout_set_mount$10;
    return_value_shout_set_mount$10=shout_set_mount(shout, "/example.ogg");
    if(!(return_value_shout_set_mount$10 == 0))
    {
      const char *return_value_shout_get_error$9;
      return_value_shout_get_error$9=shout_get_error(shout);
      printf("Error setting mount: %s\n", return_value_shout_get_error$9);
      return 1;
    }

    signed int return_value_shout_set_user$12;
    return_value_shout_set_user$12=shout_set_user(shout, "source");
    if(!(return_value_shout_set_user$12 == 0))
    {
      const char *return_value_shout_get_error$11;
      return_value_shout_get_error$11=shout_get_error(shout);
      printf("Error setting user: %s\n", return_value_shout_get_error$11);
      return 1;
    }

    signed int return_value_shout_set_format$14;
    return_value_shout_set_format$14=shout_set_format(shout, (unsigned int)0);
    if(!(return_value_shout_set_format$14 == 0))
    {
      const char *return_value_shout_get_error$13;
      return_value_shout_get_error$13=shout_get_error(shout);
      printf("Error setting user: %s\n", return_value_shout_get_error$13);
      return 1;
    }

    signed int return_value_shout_set_nonblocking$16;
    return_value_shout_set_nonblocking$16=shout_set_nonblocking(shout, (unsigned int)1);
    if(!(return_value_shout_set_nonblocking$16 == 0))
    {
      const char *return_value_shout_get_error$15;
      return_value_shout_get_error$15=shout_get_error(shout);
      printf("Error setting non-blocking mode: %s\n", return_value_shout_get_error$15);
      return 1;
    }

    signed int return_value_shout_open$17;
    return_value_shout_open$17=shout_open(shout);
    ret = (signed long int)return_value_shout_open$17;
    if(ret == 0l)
      ret = (signed long int)-7;

    if(ret == -10l)
      printf("Connection pending...\n");

    while(ret == -10l)
    {
      usleep((unsigned int)10000);
      signed int return_value_shout_get_connected$18;
      return_value_shout_get_connected$18=shout_get_connected(shout);
      ret = (signed long int)return_value_shout_get_connected$18;
    }
    if(ret == -7l)
    {
      printf("Connected to server...\n");
      total = (signed long int)0;
      while((_Bool)1)
      {
        unsigned long int return_value_fread$19;
        return_value_fread$19=fread((void *)buff, (unsigned long int)1, sizeof(char [4096l]) /*4096ul*/ , stdin);
        read = (signed long int)return_value_fread$19;
        total = total + read;
        if(read >= 1l)
        {
          signed int return_value_shout_send$20;
          return_value_shout_send$20=shout_send(shout, (const unsigned char *)buff, (unsigned long int)read);
          ret = (signed long int)return_value_shout_send$20;
          if(!(ret == 0l))
          {
            const char *return_value_shout_get_error$21;
            return_value_shout_get_error$21=shout_get_error(shout);
            printf("DEBUG: Send error: %s\n", return_value_shout_get_error$21);
            break;
          }

        }

        else
          break;
        signed long int return_value_shout_queuelen$23;
        return_value_shout_queuelen$23=shout_queuelen(shout);
        if(return_value_shout_queuelen$23 >= 1l)
        {
          return_value_shout_queuelen$22=shout_queuelen(shout);
          printf("DEBUG: queue length: %d\n", (signed int)return_value_shout_queuelen$22);
        }

        shout_sync(shout);
      }
    }

    else
    {
      const char *return_value_shout_get_error$24;
      return_value_shout_get_error$24=shout_get_error(shout);
      printf("Error connecting: %s\n", return_value_shout_get_error$24);
    }
    shout_close(shout);
    shout_shutdown();
    return 0;
  }
}

// mp3_header
// file mp3.c line 290
static signed int mp3_header(unsigned int head, struct anonymous$32 *mh)
{
  parse_header(mh, head);
  if(!((0x0ffe & mh->syncword) == 0x0ffe))
    return 0;

  else
    if(mh->layer == 0)
      return 0;

    else
      if(mh->bitrate == 0)
        return 0;

      else
        if(mh->samplerate == 0u)
          return 0;

        else
          return 1;
}

// open_codec
// file ogg.c line 149
static signed int open_codec(struct _ogg_codec_tag *codec, struct anonymous$7 *page)
{
  signed int (*this_codec)(struct _ogg_codec_tag *, struct anonymous$7 *);
  signed int i = 0;
  this_codec = codecs[(signed long int)i];
  if(!(this_codec == ((signed int (*)(struct _ogg_codec_tag *, struct anonymous$7 *))NULL)))
  {
    signed int return_value_ogg_page_serialno$1;
    return_value_ogg_page_serialno$1=ogg_page_serialno(page);
    ogg_stream_init(&codec->os, return_value_ogg_page_serialno$1);
    ogg_stream_pagein(&codec->os, page);
    signed int return_value;
    return_value=this_codec(codec, page);
    if(return_value == 0)
      return 0;

    ogg_stream_clear(&codec->os);
    i = i + 1;
  }

  return 0;
}

// opus_header_parse
// file opus.c line 100
static signed int opus_header_parse(const unsigned char *packet, signed int len, struct anonymous *h)
{
  signed int i;
  char str[9l];
  struct anonymous$0 p;
  unsigned char ch;
  unsigned short int shortval;
  p.data = packet;
  p.maxlen = len;
  p.pos = 0;
  str[(signed long int)8] = (char)0;
  _Bool tmp_if_expr$11;
  if(!(len >= 19))
    return 0;

  else
  {
    read_chars(&p, (unsigned char *)str, 8);
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(str, "OpusHead");
    if(!(return_value_strcmp$1 == 0))
      return 0;

    else
    {
      signed int return_value_read_chars$2;
      return_value_read_chars$2=read_chars(&p, &ch, 1);
      if(return_value_read_chars$2 == 0)
        return 0;

      else
      {
        h->version = (signed int)ch;
        if(!((240 & h->version) == 0))
          return 0;

        else
        {
          signed int return_value_read_chars$3;
          return_value_read_chars$3=read_chars(&p, &ch, 1);
          if(return_value_read_chars$3 == 0)
            return 0;

          else
          {
            h->channels = (signed int)ch;
            if(h->channels == 0)
              return 0;

            else
            {
              signed int return_value_read_uint16$4;
              return_value_read_uint16$4=read_uint16(&p, &shortval);
              if(return_value_read_uint16$4 == 0)
                return 0;

              else
              {
                h->preskip = (signed int)shortval;
                signed int return_value_read_uint32$5;
                return_value_read_uint32$5=read_uint32(&p, &h->input_sample_rate);
                if(return_value_read_uint32$5 == 0)
                  return 0;

                else
                {
                  signed int return_value_read_uint16$6;
                  return_value_read_uint16$6=read_uint16(&p, &shortval);
                  if(return_value_read_uint16$6 == 0)
                    return 0;

                  else
                  {
                    h->gain = (signed int)(signed short int)shortval;
                    signed int return_value_read_chars$7;
                    return_value_read_chars$7=read_chars(&p, &ch, 1);
                    if(return_value_read_chars$7 == 0)
                      return 0;

                    else
                    {
                      h->channel_mapping = (signed int)ch;
                      if(!(h->channel_mapping == 0))
                      {
                        signed int return_value_read_chars$8;
                        return_value_read_chars$8=read_chars(&p, &ch, 1);
                        if(return_value_read_chars$8 == 0)
                          return 0;

                        h->nb_streams = (signed int)ch;
                        signed int return_value_read_chars$9;
                        return_value_read_chars$9=read_chars(&p, &ch, 1);
                        if(return_value_read_chars$9 == 0)
                          return 0;

                        h->nb_coupled = (signed int)ch;
                        i = 0;
                        for( ; !(i >= h->channels); i = i + 1)
                        {
                          signed int return_value_read_chars$10;
                          return_value_read_chars$10=read_chars(&p, &h->stream_map[(signed long int)i], 1);
                          if(return_value_read_chars$10 == 0)
                            return 0;

                        }
                      }

                      else
                      {
                        h->nb_streams = 1;
                        h->nb_coupled = (signed int)(h->channels > 1);
                        h->stream_map[(signed long int)0] = (unsigned char)0;
                        h->stream_map[(signed long int)1] = (unsigned char)1;
                      }
                      if(h->version == 0)
                        tmp_if_expr$11 = (_Bool)1;

                      else
                        tmp_if_expr$11 = h->version == 1 ? (_Bool)1 : (_Bool)0;
                      if(tmp_if_expr$11)
                      {
                        if(p.pos == len)
                          goto __CPROVER_DUMP_L20;

                        return 0;
                      }

                      else
                      {

                      __CPROVER_DUMP_L20:
                        ;
                        return 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// packet_get_nb_frames
// file opus.c line 195
static signed int packet_get_nb_frames(const unsigned char *packet, signed int len)
{
  signed int count;
  if(!(len >= 1))
    return -1;

  else
  {
    count = (signed int)packet[(signed long int)0] & 0x3;
    if(count == 0)
      return 1;

    else
      if(!(count == 3))
        return 2;

      else
        if(!(len >= 2))
          return -4;

        else
          return (signed int)packet[(signed long int)1] & 0x3F;
  }
}

// packet_get_samples_per_frame
// file opus.c line 174
static signed int packet_get_samples_per_frame(const unsigned char *data, signed int Fs)
{
  signed int audiosize;
  if(!((0x80 & (signed int)*data) == 0))
  {
    audiosize = (signed int)data[(signed long int)0] >> 3 & 0x3;
    audiosize = (Fs << audiosize) / 400;
  }

  else
    if((0x60 & (signed int)*data) == 0x60)
      audiosize = ((signed int)data[(signed long int)0] & 0x08) != 0 ? Fs / 50 : Fs / 100;

    else
    {
      audiosize = (signed int)data[(signed long int)0] >> 3 & 0x3;
      if(audiosize == 3)
        audiosize = (Fs * 60) / 1000;

      else
        audiosize = (Fs << audiosize) / 100;
    }
  return audiosize;
}

// parse_header
// file mp3.c line 258
static void parse_header(struct anonymous$32 *mh, unsigned int header)
{
  mh->syncword = (signed int)(header >> 20 & (unsigned int)0x0fff);
  mh->version = (header >> 19 & (unsigned int)0x01) != 0u ? 0 : 1;
  if((0x01 & mh->syncword) == 0)
    mh->version = 2;

  mh->layer = (signed int)((unsigned int)3 - (header >> 17 & (unsigned int)0x03));
  mh->error_protection = (header >> 16 & (unsigned int)0x01) != 0u ? 0 : 1;
  mh->bitrate_index = (signed int)(header >> 12 & (unsigned int)0x0F);
  mh->samplerate_index = (signed int)(header >> 10 & (unsigned int)0x03);
  mh->padding = (signed int)(header >> 9 & (unsigned int)0x01);
  mh->extension = (signed int)(header >> 8 & (unsigned int)0x01);
  mh->mode = (signed int)(header >> 6 & (unsigned int)0x03);
  mh->mode_ext = (signed int)(header >> 4 & (unsigned int)0x03);
  mh->copyright = (signed int)(header >> 3 & (unsigned int)0x01);
  mh->original = (signed int)(header >> 2 & (unsigned int)0x01);
  mh->emphasis = (signed int)(header & (unsigned int)0x03);
  mh->stereo = mh->mode == 3 ? 1 : 2;
  mh->bitrate = (signed int)bitrate[(signed long int)mh->version][(signed long int)mh->layer][(signed long int)mh->bitrate_index];
  mh->samplerate = samplerate[(signed long int)mh->version][(signed long int)mh->samplerate_index];
  if(mh->version == 0)
    mh->samples = (unsigned int)1152;

  else
    mh->samples = (unsigned int)576;
  if(!(mh->samplerate == 0u))
    mh->framesize = ((mh->samples * (unsigned int)mh->bitrate * (unsigned int)1000) / mh->samplerate) / (unsigned int)8 + (unsigned int)mh->padding;

}

// parse_headers
// file httpp.c line 92
static void parse_headers(struct http_parser_tag *parser, char **line, signed int lines)
{
  signed int i;
  signed int l;
  signed int whitespace;
  signed int where;
  signed int slen;
  char *name = (char *)(void *)0;
  char *value = (char *)(void *)0;
  l = 1;
  for( ; !(l >= lines); l = l + 1)
  {
    where = 0;
    whitespace = 0;
    name = line[(signed long int)l];
    value = (char *)(void *)0;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(line[(signed long int)l]);
    slen = (signed int)return_value_strlen$1;
    i = 0;
    for( ; !(i >= slen); i = i + 1)
      if((signed int)line[(signed long int)l][(signed long int)i] == 58)
      {
        whitespace = 1;
        line[(signed long int)l][(signed long int)i] = (char)0;
      }

      else
        if(!(whitespace == 0))
        {
          whitespace = 0;
          for( ; !(i >= slen); i = i + 1)
            if(!((signed int)line[(signed long int)l][(signed long int)i] == 32))
              break;

          if(!(i >= slen))
            value = &line[(signed long int)l][(signed long int)i];

          break;
        }

    if(!(name == ((char *)NULL)) && !(value == ((char *)NULL)))
    {
      char *return_value__lowercase$2;
      return_value__lowercase$2=_lowercase(name);
      _shout_httpp_setvar(parser, return_value__lowercase$2, value);
      name = (char *)(void *)0;
      value = (char *)(void *)0;
    }

  }
}

// parse_http_response
// file shout.c line 1203
static signed int parse_http_response(struct shout *self)
{
  struct http_parser_tag *parser;
  char *header = (char *)(void *)0;
  signed int hlen = 0;
  signed int code;
  char *retcode;
  hlen=collect_queue(self->rqueue.head, &header);
  if(!(hlen >= 1))
    return -5;

  else
  {
    queue_free(&self->rqueue);
    parser=_shout_httpp_create_parser();
    _shout_httpp_initialize(parser, (struct http_varlist_tag *)(void *)0);
    signed int return_value__shout_httpp_parse_response$1;
    return_value__shout_httpp_parse_response$1=_shout_httpp_parse_response(parser, header, (unsigned long int)hlen, self->mount);
    if(!(return_value__shout_httpp_parse_response$1 == 0))
    {
      retcode=_shout_httpp_getvar(parser, "__errorcode");
      code=atoi(retcode);
      if(!(code >= 200) || code >= 300)
        goto __CPROVER_DUMP_L2;

      _shout_httpp_destroy(parser);
      free((void *)header);
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      free((void *)header);
      _shout_httpp_destroy(parser);
      self->error = -3;
      return self->error;
    }
  }
}

// parse_query
// file httpp.c line 255
static void parse_query(struct http_parser_tag *parser, char *query)
{
  signed int len;
  signed int i = 0;
  char *key = query;
  char *val = (char *)(void *)0;
  _Bool tmp_if_expr$1;
  if(query == ((char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(*query != 0) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(query);
    len = (signed int)return_value_strlen$2;
    for( ; !(i >= len); i = i + 1)
      switch((signed int)query[(signed long int)i])
      {
        case 38:
        {
          query[(signed long int)i] = (char)0;
          if(!(key == ((char *)NULL)) && !(val == ((char *)NULL)))
            _shout_httpp_set_query_param(parser, key, val);

          key = query + (signed long int)i + (signed long int)1;
          break;
        }
        case 61:
        {
          query[(signed long int)i] = (char)0;
          val = query + (signed long int)i + (signed long int)1;
        }
      }
    if(!(key == ((char *)NULL)) && !(val == ((char *)NULL)))
      _shout_httpp_set_query_param(parser, key, val);

  }

}

// parse_response
// file shout.c line 1192
static signed int parse_response(struct shout *self)
{
  signed int return_value_parse_http_response$1;
  _Bool tmp_if_expr$3;
  signed int return_value_parse_xaudiocast_response$2;
  if(self->protocol == 0u)
  {
    return_value_parse_http_response$1=parse_http_response(self);
    return return_value_parse_http_response$1;
  }

  else
  {
    if(self->protocol == 1u)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = self->protocol == (unsigned int)2 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      return_value_parse_xaudiocast_response$2=parse_xaudiocast_response(self);
      return return_value_parse_xaudiocast_response$2;
    }

  }
  self->error = -9;
  return self->error;
}

// parse_xaudiocast_response
// file shout.c line 1273
static signed int parse_xaudiocast_response(struct shout *self)
{
  char *response;
  signed int return_value_collect_queue$1;
  return_value_collect_queue$1=collect_queue(self->rqueue.head, &response);
  if(!(return_value_collect_queue$1 >= 1))
    return -5;

  else
  {
    queue_free(&self->rqueue);
    char *return_value_strstr$2;
    return_value_strstr$2=strstr(response, "OK");
    if(return_value_strstr$2 == ((char *)NULL))
    {
      free((void *)response);
      return -3;
    }

    else
    {
      free((void *)response);
      return 0;
    }
  }
}

// print_connectors
// file avl.c line 1088
static void print_connectors(struct _link_node *link)
{
  if(!(link->parent == ((struct _link_node *)NULL)))
    print_connectors(link->parent);

  _Bool tmp_if_expr$1;
  if(!(link->parent == ((struct _link_node *)NULL)))
    tmp_if_expr$1 = link->parent->direction != link->direction ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = link->parent->parent != ((struct _link_node *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
  {
    signed int print_connectors$$1$$2$$i;
    fprintf(stdout, "|");
    print_connectors$$1$$2$$i = 0;
    for( ; !(print_connectors$$1$$2$$i >= link->width + -1); print_connectors$$1$$2$$i = print_connectors$$1$$2$$i + 1)
      fprintf(stdout, " ");
  }

  else
  {
    signed int i = 0;
    for( ; !(i >= link->width); i = i + 1)
      fprintf(stdout, " ");
  }
}

// print_node
// file avl.c line 1115
static void print_node(signed int (*key_printer)(char *, void *), struct avl_node_tag *node, struct _link_node *link)
{
  char buffer[256l];
  unsigned int width;
  signed int return_value;
  return_value=key_printer(buffer, node->key);
  width = (unsigned int)return_value;
  if(!(node->right == ((struct avl_node_tag *)NULL)))
  {
    struct _link_node here;
    here.parent = link;
    here.direction = (char)1;
    here.width = (signed int)(width + (unsigned int)11);
    print_node(key_printer, node->right, &here);
  }

  print_connectors(link);
  fprintf(stdout, "+-[%c %s %03d]", balance_chars[(signed long int)((signed int)((node->rank_and_balance & (unsigned int)3) - (unsigned int)1) + 1)], (const void *)buffer, (signed int)(node->rank_and_balance >> 2));
  _Bool tmp_if_expr$1;
  if(!(node->left == ((struct avl_node_tag *)NULL)))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = node->right != ((struct avl_node_tag *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    fprintf(stdout, "-|\n");

  else
    fprintf(stdout, "\n");
  if(!(node->left == ((struct avl_node_tag *)NULL)))
  {
    struct _link_node print_node$$1$$4$$here;
    print_node$$1$$4$$here.parent = link;
    print_node$$1$$4$$here.direction = (char)-1;
    print_node$$1$$4$$here.width = (signed int)(width + (unsigned int)11);
    print_node(key_printer, node->left, &print_node$$1$$4$$here);
  }

}

// queue_data
// file shout.c line 797
static signed int queue_data(struct anonymous$10 *queue, const unsigned char *data, unsigned long int len)
{
  struct _shout_buf *buf;
  unsigned long int plen;
  unsigned long int tmp_if_expr$3;
  if(len == 0ul)
    return 0;

  else
  {
    if(queue->len == 0ul)
    {
      void *return_value_calloc$1;
      return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct _shout_buf) /*4120ul*/ );
      queue->head = (struct _shout_buf *)return_value_calloc$1;
      if(queue->head == ((struct _shout_buf *)NULL))
        return -5;

    }

    buf = queue->head;
    for( ; !(buf->next == ((struct _shout_buf *)NULL)); buf = buf->next)
      ;
    for( ; len >= 1ul; queue->len = queue->len + plen)
    {
      if(buf->len == 4096u)
      {
        void *return_value_calloc$2;
        return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct _shout_buf) /*4120ul*/ );
        buf->next = (struct _shout_buf *)return_value_calloc$2;
        if(buf->next == ((struct _shout_buf *)NULL))
          return -5;

        buf->next->prev = buf;
        buf = buf->next;
      }

      if(!((unsigned long int)(4096u + -buf->len) >= len))
        tmp_if_expr$3 = (unsigned long int)((unsigned int)4096 - buf->len);

      else
        tmp_if_expr$3 = len;
      plen = tmp_if_expr$3;
      memcpy((void *)(buf->data + (signed long int)buf->len), (const void *)data, plen);
      buf->len = buf->len + (unsigned int)plen;
      data = data + (signed long int)plen;
      len = len - plen;
    }
    return 0;
  }
}

// queue_free
// file shout.c line 877
static inline void queue_free(struct anonymous$10 *queue)
{
  struct _shout_buf *prev;
  while(!(queue->head == ((struct _shout_buf *)NULL)))
  {
    prev = queue->head;
    queue->head = queue->head->next;
    free((void *)prev);
  }
  queue->len = (unsigned long int)0;
}

// queue_printf
// file shout.c line 842
static signed int queue_printf(struct shout *self, const char *fmt, ...)
{
  char buffer[1024l];
  char *buf;
  void **ap;
  void **ap_retry;
  signed int len;
  buf = buffer;
  ap = (void **)&fmt;
  ap_retry = (void **)ap;
  len=vsnprintf(buf, sizeof(char [1024l]) /*1024ul*/ , fmt, ap);
  self->error = 0;
  if(len >= 1)
  {
    if(!((unsigned long int)len >= sizeof(char [1024l]) /*1024ul*/ ))
      queue_data(&self->wqueue, (unsigned char *)buf, (unsigned long int)len);

    else
    {
      len = len + 1;
      void *return_value_malloc$1;
      return_value_malloc$1=malloc((unsigned long int)len);
      buf = (char *)return_value_malloc$1;
      if(!(buf == ((char *)NULL)))
      {
        len=vsnprintf(buf, (unsigned long int)len, fmt, ap_retry);
        queue_data(&self->wqueue, (unsigned char *)buf, (unsigned long int)len);
        free((void *)buf);
      }

      else
        self->error = -5;
    }
  }

  ap_retry = ((void **)NULL);
  ap = ((void **)NULL);
  return self->error;
}

// queue_str
// file shout.c line 836
static inline signed int queue_str(struct shout *self, const char *str)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  signed int return_value_queue_data$2;
  return_value_queue_data$2=queue_data(&self->wqueue, (const unsigned char *)str, return_value_strlen$1);
  return return_value_queue_data$2;
}

// read_chars
// file opus.c line 90
static signed int read_chars(struct anonymous$0 *p, unsigned char *str, signed int nb_chars)
{
  signed int i;
  signed int tmp_post$1;
  if(!(p->maxlen + -nb_chars >= p->pos))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= nb_chars); i = i + 1)
    {
      tmp_post$1 = p->pos;
      p->pos = p->pos + 1;
      str[(signed long int)i] = p->data[(signed long int)tmp_post$1];
    }
    return 1;
  }
}

// read_opus_page
// file opus.c line 235
static signed int read_opus_page(struct _ogg_codec_tag *codec, struct anonymous$7 *page)
{
  struct anonymous$2 packet;
  struct anonymous$1 *opus_data = (struct anonymous$1 *)codec->codec_data;
  signed int return_value_ogg_stream_packetout$1;
  signed int return_value_memcmp$4;
  signed int return_value_memcmp$3;
  do
  {
    return_value_ogg_stream_packetout$1=ogg_stream_packetout(&codec->os, &packet);
    if(!(return_value_ogg_stream_packetout$1 >= 1))
      break;

    if(packet.bytes >= 1l)
    {
      return_value_memcmp$4=memcmp((const void *)packet.packet, (const void *)"Op", (unsigned long int)2);
      if(!(return_value_memcmp$4 == 0))
      {
        signed int spf;
        spf=packet_get_samples_per_frame(packet.packet, 48000);
        if(spf >= 1)
        {
          signed int spp;
          spp=packet_get_nb_frames(packet.packet, (signed int)packet.bytes);
          if(spp >= 1)
          {
            signed int needskip = opus_data->oh.preskip - opus_data->skipped;
            spp = spp * spf;
            if(needskip >= 1)
            {
              signed int skip = spp < needskip ? spp : needskip;
              spp = spp - skip;
              opus_data->skipped = opus_data->skipped + skip;
            }

            codec->senttime = codec->senttime + ((unsigned long int)spp * 1000000ULL) / 48000ULL;
          }

        }

        else
          if(packet.bytes >= 19l)
          {
            return_value_memcmp$3=memcmp((const void *)packet.packet, (const void *)"OpusHead", (unsigned long int)8);
            if(return_value_memcmp$3 == 0)
            {
              signed int return_value_opus_header_parse$2;
              return_value_opus_header_parse$2=opus_header_parse(packet.packet, (signed int)packet.bytes, &opus_data->oh);
              if(!(return_value_opus_header_parse$2 == 0))
                opus_data->skipped = 0;

            }

          }

      }

    }

  }
  while((_Bool)1);
  return 0;
}

// read_speex_page
// file speex.c line 64
static signed int read_speex_page(struct _ogg_codec_tag *codec, struct anonymous$7 *page)
{
  struct anonymous$2 packet;
  struct anonymous$11 *speex_data = (struct anonymous$11 *)codec->codec_data;
  unsigned long int samples = (unsigned long int)0;
  signed int return_value_ogg_stream_packetout$1;
  do
  {
    return_value_ogg_stream_packetout$1=ogg_stream_packetout(&codec->os, &packet);
    if(!(return_value_ogg_stream_packetout$1 >= 1))
      break;

    samples = samples + (unsigned long int)(speex_data->sh->frames_per_packet * speex_data->sh->frame_size);
  }
  while((_Bool)1);
  codec->senttime = codec->senttime + (samples * (unsigned long int)1000000) / (unsigned long int)speex_data->sh->rate;
  return 0;
}

// read_theora_page
// file theora.c line 81
static signed int read_theora_page(struct _ogg_codec_tag *codec, struct anonymous$7 *page)
{
  struct anonymous$6 *theora_data = (struct anonymous$6 *)codec->codec_data;
  struct anonymous$2 packet;
  signed long int granulepos;
  signed long int iframe;
  signed long int pframe;
  granulepos=ogg_page_granulepos(page);
  signed int return_value_ogg_stream_packetout$1;
  if(granulepos == 0l)
  {
    do
    {
      return_value_ogg_stream_packetout$1=ogg_stream_packetout(&codec->os, &packet);
      if(!(return_value_ogg_stream_packetout$1 >= 1))
        break;

      signed int return_value_theora_decode_header$2;
      return_value_theora_decode_header$2=theora_decode_header(&theora_data->ti, &theora_data->tc, &packet);
      if(!(return_value_theora_decode_header$2 >= 0))
        return -1;

      codec->headers = codec->headers + 1u;
    }
    while((_Bool)1);
    if(codec->headers == 3u)
    {
      signed int return_value_theora_ilog$3;
      return_value_theora_ilog$3=theora_ilog(theora_data->ti.keyframe_frequency_force - (unsigned int)1);
      theora_data->granule_shift = (unsigned int)return_value_theora_ilog$3;
      theora_data->per_frame = ((double)theora_data->ti.fps_denominator / (double)theora_data->ti.fps_numerator) * (double)1000000;
      theora_data->get_start_frame = 1;
    }

    return 0;
  }

  signed int return_value_ogg_stream_packetout$4;
  do
  {
    return_value_ogg_stream_packetout$4=ogg_stream_packetout(&codec->os, &packet);
    if(!(return_value_ogg_stream_packetout$4 >= 1))
      break;

    if(!(theora_data->get_start_frame == 0))
      theora_data->initial_frames = theora_data->initial_frames + 1;

  }
  while((_Bool)1);
  if(granulepos >= 1l)
  {
    if(codec->headers >= 3u)
    {
      iframe = granulepos >> theora_data->granule_shift;
      pframe = granulepos - (iframe << theora_data->granule_shift);
      if(!(theora_data->get_start_frame == 0))
      {
        theora_data->start_frame = (unsigned long int)((iframe + pframe) - (signed long int)theora_data->initial_frames);
        codec->senttime = (unsigned long int)0;
        theora_data->get_start_frame = 0;
      }

      else
      {
        unsigned long int frames = (unsigned long int)(iframe + pframe) - theora_data->start_frame;
        codec->senttime = (unsigned long int)((double)frames * theora_data->per_frame);
      }
    }

  }

  return 0;
}

// read_uint16
// file opus.c line 80
static signed int read_uint16(struct anonymous$0 *p, unsigned short int *val)
{
  if(!(p->maxlen + -2 >= p->pos))
    return 0;

  else
  {
    *val = (unsigned short int)p->data[(signed long int)p->pos];
    *val = *val | (unsigned short int)((signed int)(unsigned short int)p->data[(signed long int)(p->pos + 1)] << 8);
    p->pos = p->pos + 2;
    return 1;
  }
}

// read_uint32
// file opus.c line 68
static signed int read_uint32(struct anonymous$0 *p, unsigned int *val)
{
  if(!(p->maxlen + -4 >= p->pos))
    return 0;

  else
  {
    *val = (unsigned int)p->data[(signed long int)p->pos];
    *val = *val | (unsigned int)p->data[(signed long int)(p->pos + 1)] << 8;
    *val = *val | (unsigned int)p->data[(signed long int)(p->pos + 2)] << 16;
    *val = *val | (unsigned int)p->data[(signed long int)(p->pos + 3)] << 24;
    p->pos = p->pos + 4;
    return 1;
  }
}

// read_vorbis_page
// file vorbis.c line 75
static signed int read_vorbis_page(struct _ogg_codec_tag *codec, struct anonymous$7 *page)
{
  struct anonymous$2 packet;
  struct anonymous$30 *vorbis_data = (struct anonymous$30 *)codec->codec_data;
  unsigned long int samples = (unsigned long int)0;
  signed int return_value_ogg_stream_packetout$1;
  if(!(codec->headers >= 3u))
  {
    do
    {
      return_value_ogg_stream_packetout$1=ogg_stream_packetout(&codec->os, &packet);
      if(!(return_value_ogg_stream_packetout$1 >= 1))
        break;

      signed int return_value_vorbis_synthesis_headerin$2;
      return_value_vorbis_synthesis_headerin$2=vorbis_synthesis_headerin(&vorbis_data->vi, &vorbis_data->vc, &packet);
      if(!(return_value_vorbis_synthesis_headerin$2 >= 0))
        return -1;

      codec->headers = codec->headers + 1u;
    }
    while((_Bool)1);
    return 0;
  }

  signed int return_value_ogg_stream_packetout$3;
  signed int return_value_vorbis_blocksize$4;
  do
  {
    return_value_ogg_stream_packetout$3=ogg_stream_packetout(&codec->os, &packet);
    if(!(return_value_ogg_stream_packetout$3 >= 1))
      break;

    return_value_vorbis_blocksize$4=vorbis_blocksize(vorbis_data, &packet);
    samples = samples + (unsigned long int)return_value_vorbis_blocksize$4;
  }
  while((_Bool)1);
  codec->senttime = codec->senttime + (samples * (unsigned long int)1000000) / (unsigned long int)vorbis_data->vi.rate;
  return 0;
}

// send_mp3
// file mp3.c line 117
static signed int send_mp3(struct shout *self, const unsigned char *buff, unsigned long int len)
{
  struct anonymous$33 *mp3_data = (struct anonymous$33 *)self->format_data;
  unsigned long int pos;
  unsigned int head;
  signed int ret;
  signed int count;
  signed int start;
  signed int end;
  signed int error;
  signed int i;
  unsigned char *bridge_buff;
  struct anonymous$32 mh;
  bridge_buff = (unsigned char *)(void *)0;
  pos = (unsigned long int)0;
  start = 0;
  error = 0;
  end = (signed int)(len - (unsigned long int)1);
  memset((void *)&mh, 0, sizeof(struct anonymous$32) /*72ul*/ );
  if(mp3_data->frame_left >= 1u)
  {
    if(len >= (unsigned long int)mp3_data->frame_left)
    {
      self->senttime = self->senttime + (unsigned long int)(signed long int)(((double)mp3_data->frame_samples / (double)mp3_data->frame_samplerate) * (double)1000000);
      mp3_data->frames = mp3_data->frames + 1u;
      pos = pos + (unsigned long int)mp3_data->frame_left;
      mp3_data->frame_left = (unsigned int)0;
    }

    else
    {
      mp3_data->frame_left = mp3_data->frame_left - (unsigned int)len;
      pos = len;
    }
  }

  if(!(mp3_data->header_bridges == 0))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(len + (unsigned long int)mp3_data->header_bridges);
    bridge_buff = (unsigned char *)return_value_malloc$1;
    if(bridge_buff == ((unsigned char *)NULL))
    {
      self->error = -5;
      return self->error;
    }

    bridge_buff[(signed long int)0] = mp3_data->header_bridge[(signed long int)0];
    bridge_buff[(signed long int)1] = mp3_data->header_bridge[(signed long int)1];
    bridge_buff[(signed long int)2] = mp3_data->header_bridge[(signed long int)2];
    memcpy((void *)&bridge_buff[(signed long int)mp3_data->header_bridges], (const void *)buff, len);
    buff = bridge_buff;
    len = len + (unsigned long int)mp3_data->header_bridges;
    end = (signed int)(len - (unsigned long int)1);
    mp3_data->header_bridges = 0;
  }

  signed long int return_value_shout_send_raw$2;
  while(len >= 4ul + pos)
  {
    head = (unsigned int)((signed int)buff[(signed long int)pos] << 24 | (signed int)buff[(signed long int)(pos + (unsigned long int)1)] << 16 | (signed int)buff[(signed long int)(pos + (unsigned long int)2)] << 8 | (signed int)buff[(signed long int)(pos + (unsigned long int)3)]);
    signed int return_value_mp3_header$3;
    return_value_mp3_header$3=mp3_header(head, &mh);
    if(!(return_value_mp3_header$3 == 0))
    {
      if(!(error == 0))
      {
        start = (signed int)pos;
        end = (signed int)(len - (unsigned long int)1);
        error = 0;
      }

      mp3_data->frame_samples = (signed int)mh.samples;
      mp3_data->frame_samplerate = (signed int)mh.samplerate;
      if(len + -pos >= (unsigned long int)mh.framesize)
      {
        self->senttime = self->senttime + (unsigned long int)(signed long int)(((double)mp3_data->frame_samples / (double)mp3_data->frame_samplerate) * (double)1000000);
        mp3_data->frames = mp3_data->frames + 1u;
        pos = pos + (unsigned long int)mh.framesize;
      }

      else
      {
        mp3_data->frame_left = (unsigned int)((unsigned long int)mh.framesize - (len - pos));
        pos = len;
      }
    }

    else
    {
      if(error == 0)
      {
        error = 1;
        end = (signed int)(pos - (unsigned long int)1);
        count = (end - start) + 1;
        if(count >= 1)
        {
          return_value_shout_send_raw$2=shout_send_raw(self, (const unsigned char *)(char *)&buff[(signed long int)start], (unsigned long int)count);
          ret = (signed int)return_value_shout_send_raw$2;
        }

        else
          ret = 0;
        if(!(ret == count))
        {
          if(!(bridge_buff == ((unsigned char *)NULL)))
            free((void *)bridge_buff);

          self->error = -4;
          return self->error;
        }

      }

      pos = pos + 1ul;
    }
  }
  if(!(len + 18446744073709551612ul >= pos) && !(pos >= len))
  {
    end = (signed int)(pos - (unsigned long int)1);
    i = 0;
    for( ; !(pos >= len); i = i + 1)
    {
      mp3_data->header_bridge[(signed long int)i] = buff[(signed long int)pos];
      pos = pos + 1ul;
    }
    mp3_data->header_bridges = i;
  }

  signed long int return_value_shout_send_raw$4;
  if(error == 0)
  {
    count = (end - start) + 1;
    if(count >= 1)
    {
      return_value_shout_send_raw$4=shout_send_raw(self, (const unsigned char *)(char *)&buff[(signed long int)start], (unsigned long int)count);
      ret = (signed int)return_value_shout_send_raw$4;
    }

    else
      ret = 0;
    if(!(bridge_buff == ((unsigned char *)NULL)))
      free((void *)bridge_buff);

    if(ret == count)
    {
      self->error = 0;
      return self->error;
    }

    else
    {
      self->error = -4;
      return self->error;
    }
  }

  if(!(bridge_buff == ((unsigned char *)NULL)))
    free((void *)bridge_buff);

  self->error = 0;
  return self->error;
}

// send_ogg
// file ogg.c line 84
static signed int send_ogg(struct shout *self, const unsigned char *data, unsigned long int len)
{
  struct anonymous$17 *ogg_data = (struct anonymous$17 *)self->format_data;
  struct _ogg_codec_tag *codec;
  char *buffer;
  struct anonymous$7 page;
  buffer=ogg_sync_buffer(&ogg_data->oy, (signed long int)len);
  memcpy((void *)buffer, (const void *)data, len);
  ogg_sync_wrote(&ogg_data->oy, (signed long int)len);
  signed int return_value_ogg_sync_pageout$1;
  do
  {
    return_value_ogg_sync_pageout$1=ogg_sync_pageout(&ogg_data->oy, &page);
    if(!(return_value_ogg_sync_pageout$1 == 1))
      break;

    signed int return_value_ogg_page_bos$4;
    return_value_ogg_page_bos$4=ogg_page_bos(&page);
    if(!(return_value_ogg_page_bos$4 == 0))
    {
      if(ogg_data->bos == 0)
      {
        free_codecs(ogg_data);
        ogg_data->bos = (char)1;
      }

      void *return_value_calloc$2;
      return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct _ogg_codec_tag) /*456ul*/ );
      codec = (struct _ogg_codec_tag *)return_value_calloc$2;
      if(codec == ((struct _ogg_codec_tag *)NULL))
      {
        self->error = -5;
        return self->error;
      }

      self->error=open_codec(codec, &page);
      if(!(self->error == 0))
        return self->error;

      codec->headers = (unsigned int)1;
      codec->senttime = self->senttime;
      codec->next = ogg_data->codecs;
      ogg_data->codecs = codec;
    }

    else
    {
      ogg_data->bos = (char)0;
      codec = ogg_data->codecs;
      while(!(codec == ((struct _ogg_codec_tag *)NULL)))
      {
        signed int return_value_ogg_page_serialno$3;
        return_value_ogg_page_serialno$3=ogg_page_serialno(&page);
        if((signed long int)return_value_ogg_page_serialno$3 == codec->os.serialno)
        {
          if(!(codec->read_page == ((signed int (*)(struct _ogg_codec_tag *, struct anonymous$7 *))NULL)))
          {
            ogg_stream_pagein(&codec->os, &page);
            codec->read_page(codec, &page);
            if(!(self->senttime >= codec->senttime))
              self->senttime = codec->senttime;

          }

          break;
        }

        codec = codec->next;
      }
    }
    self->error=send_page(self, &page);
    if(!(self->error == 0))
      return self->error;

  }
  while((_Bool)1);
  self->error = 0;
  return self->error;
}

// send_page
// file ogg.c line 193
static signed int send_page(struct shout *self, struct anonymous$7 *page)
{
  signed int ret;
  signed long int return_value_shout_send_raw$1;
  return_value_shout_send_raw$1=shout_send_raw(self, page->header, (unsigned long int)page->header_len);
  ret = (signed int)return_value_shout_send_raw$1;
  if(!((signed long int)ret == page->header_len))
  {
    self->error = -4;
    return self->error;
  }

  else
  {
    signed long int return_value_shout_send_raw$2;
    return_value_shout_send_raw$2=shout_send_raw(self, page->body, (unsigned long int)page->body_len);
    ret = (signed int)return_value_shout_send_raw$2;
    if(!((signed long int)ret == page->body_len))
    {
      self->error = -4;
      return self->error;
    }

    else
      return 0;
  }
}

// send_queue
// file shout.c line 1070
static signed int send_queue(struct shout *self)
{
  struct _shout_buf *buf;
  signed int ret;
  if(self->wqueue.len == 0ul)
    return 0;

  else
  {
    buf = self->wqueue.head;
    while(!(buf == ((struct _shout_buf *)NULL)))
    {
      ret=try_write(self, (const void *)(buf->data + (signed long int)buf->pos), (unsigned long int)(buf->len - buf->pos));
      if(!(ret >= 0))
        return self->error;

      buf->pos = buf->pos + (unsigned int)ret;
      self->wqueue.len = self->wqueue.len - (unsigned long int)ret;
      if(buf->pos == buf->len)
      {
        self->wqueue.head = buf->next;
        free((void *)buf);
        buf = self->wqueue.head;
        if(!(buf == ((struct _shout_buf *)NULL)))
          buf->prev = (struct _shout_buf *)(void *)0;

      }

      else
        return -10;
    }
    self->error = 0;
    return self->error;
  }
}

// send_webm
// file webm.c line 53
static signed int send_webm(struct shout *self, const unsigned char *data, unsigned long int len)
{
  signed int ret;
  signed long int return_value_shout_send_raw$1;
  return_value_shout_send_raw$1=shout_send_raw(self, data, len);
  ret = (signed int)return_value_shout_send_raw$1;
  if(!((unsigned long int)ret == len))
  {
    self->error = -4;
    return self->error;
  }

  else
  {
    self->error = 0;
    return self->error;
  }
}

// shout_close
// file ../include/shout/shout.h line 152
signed int shout_close(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if((signed int)self->state == SHOUT_STATE_UNCONNECTED)
    {
      self->error = -8;
      return self->error;
    }

    else
    {
      if((signed int)self->state == SHOUT_STATE_CONNECTED)
      {
        if(!(self->close == ((void (*)(struct shout *))NULL)))
          self->close(self);

      }

      _shout_sock_close(self->socket);
      self->state = (enum anonymous$9)SHOUT_STATE_UNCONNECTED;
      self->starttime = (unsigned long int)0;
      self->senttime = (unsigned long int)0;
      queue_free(&self->rqueue);
      queue_free(&self->wqueue);
      self->error = 0;
      return self->error;
    }
}

// shout_delay
// file shout.c line 265
signed int shout_delay(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return 0;

  else
    if(self->senttime == 0ul)
      return 0;

    else
    {
      unsigned long int return_value__shout_timing_get_time$1;
      return_value__shout_timing_get_time$1=_shout_timing_get_time();
      return (signed int)(self->senttime / (unsigned long int)1000 - (return_value__shout_timing_get_time$1 - self->starttime));
    }
}

// shout_free
// file shout.c line 132
void shout_free(struct shout *self)
{
  if(!(self == ((struct shout *)NULL)))
  {
    if(!(self->host == ((char *)NULL)))
      free((void *)self->host);

    if(!(self->password == ((char *)NULL)))
      free((void *)self->password);

    if(!(self->mount == ((char *)NULL)))
      free((void *)self->mount);

    if(!(self->name == ((char *)NULL)))
      free((void *)self->name);

    if(!(self->url == ((char *)NULL)))
      free((void *)self->url);

    if(!(self->genre == ((char *)NULL)))
      free((void *)self->genre);

    if(!(self->description == ((char *)NULL)))
      free((void *)self->description);

    if(!(self->user == ((char *)NULL)))
      free((void *)self->user);

    if(!(self->useragent == ((char *)NULL)))
      free((void *)self->useragent);

    if(!(self->audio_info == ((struct _util_dict *)NULL)))
      _shout_util_dict_free(self->audio_info);

    free((void *)self);
  }

}

// shout_get_agent
// file shout.c line 606
const char * shout_get_agent(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (const char *)(void *)0;

  else
    return self->useragent;
}

// shout_get_audio_info
// file shout.c line 695
const char * shout_get_audio_info(struct shout *self, const char *name)
{
  const char *return_value__shout_util_dict_get$1;
  return_value__shout_util_dict_get$1=_shout_util_dict_get(self->audio_info, name);
  return return_value__shout_util_dict_get$1;
}

// shout_get_connected
// file ../include/shout/shout.h line 90
signed int shout_get_connected(struct shout *self)
{
  signed int rc;
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if((signed int)self->state == SHOUT_STATE_CONNECTED)
      return -7;

    else
      if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
      {
        rc=try_connect(self);
        if(rc == 0)
          return -7;

        return rc;
      }

      else
        return -8;
}

// shout_get_description
// file shout.c line 657
const char * shout_get_description(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (const char *)(void *)0;

  else
    return self->description;
}

// shout_get_dumpfile
// file shout.c line 682
const char * shout_get_dumpfile(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (const char *)(void *)0;

  else
    return self->dumpfile;
}

// shout_get_errno
// file shout.c line 351
signed int shout_get_errno(struct shout *self)
{
  return self->error;
}

// shout_get_error
// file ../include/shout/shout.h line 84
const char * shout_get_error(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return "Invalid shout_t";

  else
  {
    if(!(self->error == 0))
    {
      if(self->error == -1)
        goto __CPROVER_DUMP_L3;

      if(self->error == -2)
        goto __CPROVER_DUMP_L4;

      if(self->error == -3)
        goto __CPROVER_DUMP_L5;

      if(self->error == -4)
        goto __CPROVER_DUMP_L6;

      if(self->error == -5)
        goto __CPROVER_DUMP_L7;

      if(self->error == -7)
        goto __CPROVER_DUMP_L8;

      if(self->error == -8)
        goto __CPROVER_DUMP_L9;

      if(self->error == -10)
        goto __CPROVER_DUMP_L10;

      if(self->error == -9)
        goto __CPROVER_DUMP_L11;

    }

    else
    {
      return "No error";

    __CPROVER_DUMP_L3:
      ;
      return "Nonsensical arguments";

    __CPROVER_DUMP_L4:
      ;
      return "Couldn't connect";

    __CPROVER_DUMP_L5:
      ;
      return "Login failed";

    __CPROVER_DUMP_L6:
      ;
      return "Socket error";

    __CPROVER_DUMP_L7:
      ;
      return "Out of memory";

    __CPROVER_DUMP_L8:
      ;
      return "Cannot set parameter while connected";

    __CPROVER_DUMP_L9:
      ;
      return "Not connected";

    __CPROVER_DUMP_L10:
      ;
      return "Socket is busy";

    __CPROVER_DUMP_L11:
      ;
      return "This libshout doesn't support the requested option";
    }
    return "Unknown error";
  }
}

// shout_get_format
// file shout.c line 739
unsigned int shout_get_format(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (unsigned int)0;

  else
    return self->format;
}

// shout_get_genre
// file shout.c line 581
const char * shout_get_genre(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (const char *)(void *)0;

  else
    return self->genre;
}

// shout_get_host
// file shout.c line 427
const char * shout_get_host(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (const char *)(void *)0;

  else
    return self->host;
}

// shout_get_mount
// file shout.c line 506
const char * shout_get_mount(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (const char *)(void *)0;

  else
    return self->mount;
}

// shout_get_name
// file shout.c line 531
const char * shout_get_name(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (const char *)(void *)0;

  else
    return self->name;
}

// shout_get_nonblocking
// file shout.c line 786
unsigned int shout_get_nonblocking(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)self->nonblocking;
}

// shout_get_password
// file shout.c line 473
const char * shout_get_password(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (const char *)(void *)0;

  else
    return self->password;
}

// shout_get_port
// file shout.c line 448
unsigned short int shout_get_port(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (unsigned short int)0;

  else
    return (unsigned short int)self->port;
}

// shout_get_protocol
// file shout.c line 765
unsigned int shout_get_protocol(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (unsigned int)0;

  else
    return self->protocol;
}

// shout_get_public
// file shout.c line 713
unsigned int shout_get_public(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (unsigned int)0;

  else
    return (unsigned int)self->public;
}

// shout_get_url
// file shout.c line 556
const char * shout_get_url(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (const char *)(void *)0;

  else
    return self->url;
}

// shout_get_user
// file shout.c line 632
const char * shout_get_user(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (const char *)(void *)0;

  else
    return self->user;
}

// shout_init
// file ../include/shout/shout.h line 65
void shout_init(void)
{
  if(_initialized == 0)
  {
    _shout_sock_initialize();
    _initialized = 1;
  }

}

// shout_metadata_add
// file shout.c line 290
signed int shout_metadata_add(struct _util_dict *self, const char *name, const char *value)
{
  if(name == ((const char *)NULL) || self == ((struct _util_dict *)NULL))
    return -1;

  else
  {
    signed int return_value__shout_util_dict_set$1;
    return_value__shout_util_dict_set$1=_shout_util_dict_set(self, name, value);
    return return_value__shout_util_dict_set$1;
  }
}

// shout_metadata_free
// file shout.c line 282
void shout_metadata_free(struct _util_dict *self)
{
  if(!(self == ((struct _util_dict *)NULL)))
    _shout_util_dict_free(self);

}

// shout_metadata_new
// file shout.c line 277
struct _util_dict * shout_metadata_new(void)
{
  struct _util_dict *return_value__shout_util_dict_new$1;
  return_value__shout_util_dict_new$1=_shout_util_dict_new();
  return return_value__shout_util_dict_new$1;
}

// shout_new
// file ../include/shout/shout.h line 77
struct shout * shout_new(void)
{
  struct shout *self;
  shout_init();
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct shout) /*200ul*/ );
  self = (struct shout *)return_value_calloc$1;
  if(self == ((struct shout *)NULL))
    return (struct shout *)(void *)0;

  else
  {
    signed int return_value_shout_set_host$2;
    return_value_shout_set_host$2=shout_set_host(self, "localhost");
    if(!(return_value_shout_set_host$2 == 0))
    {
      shout_free(self);
      return (struct shout *)(void *)0;
    }

    else
    {
      signed int return_value_shout_set_user$3;
      return_value_shout_set_user$3=shout_set_user(self, "source");
      if(!(return_value_shout_set_user$3 == 0))
      {
        shout_free(self);
        return (struct shout *)(void *)0;
      }

      else
      {
        signed int return_value_shout_set_agent$4;
        return_value_shout_set_agent$4=shout_set_agent(self, "libshout/2.3.1");
        if(!(return_value_shout_set_agent$4 == 0))
        {
          shout_free(self);
          return (struct shout *)(void *)0;
        }

        else
        {
          self->audio_info=_shout_util_dict_new();
          if(self->audio_info == ((struct _util_dict *)NULL))
          {
            shout_free(self);
            return (struct shout *)(void *)0;
          }

          else
          {
            self->port = 8000;
            self->format = (unsigned int)0;
            self->protocol = (unsigned int)0;
            return self;
          }
        }
      }
    }
  }
}

// shout_open
// file ../include/shout/shout.h line 149
signed int shout_open(struct shout *self)
{
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
      return -7;

    else
    {
      if(self->host == ((char *)NULL))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = !(self->password != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = !(self->port != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
      {
        self->error = -1;
        return self->error;
      }

      else
        if(self->format == 0u)
        {
          if(self->protocol == 0u)
            goto __CPROVER_DUMP_L8;

          self->error = -9;
          return self->error;
        }

        else
        {

        __CPROVER_DUMP_L8:
          ;
          self->error=try_connect(self);
          return self->error;
        }
    }
}

// shout_open_mp3
// file shout_private.h line 111
signed int shout_open_mp3(struct shout *self)
{
  struct anonymous$33 *mp3_data;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$33) /*24ul*/ );
  mp3_data = (struct anonymous$33 *)return_value_calloc$1;
  if(mp3_data == ((struct anonymous$33 *)NULL))
    return -5;

  else
  {
    self->format_data = (void *)mp3_data;
    self->send = send_mp3;
    self->close = close_mp3;
    return 0;
  }
}

// shout_open_ogg
// file shout_private.h line 110
signed int shout_open_ogg(struct shout *self)
{
  struct anonymous$17 *ogg_data;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$17) /*48ul*/ );
  ogg_data = (struct anonymous$17 *)return_value_calloc$1;
  if(ogg_data == ((struct anonymous$17 *)NULL))
  {
    self->error = -5;
    return self->error;
  }

  else
  {
    self->format_data = (void *)ogg_data;
    ogg_sync_init(&ogg_data->oy);
    ogg_data->bos = (char)1;
    self->send = send_ogg;
    self->close = close_ogg;
    return 0;
  }
}

// shout_open_webm
// file webm.c line 44
signed int shout_open_webm(struct shout *self)
{
  self->format_data = (void *)0;
  self->send = send_webm;
  self->close = close_webm;
  return 0;
}

// shout_queuelen
// file ../include/shout/shout.h line 165
signed long int shout_queuelen(struct shout *self)
{
  if(self == ((struct shout *)NULL))
    return (signed long int)-1;

  else
    return (signed long int)self->wqueue.len;
}

// shout_send
// file ../include/shout/shout.h line 155
signed int shout_send(struct shout *self, const unsigned char *data, unsigned long int len)
{
  signed int return_value_send_queue$1;
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_CONNECTED))
    {
      self->error = -8;
      return self->error;
    }

    else
    {
      if(!(self->starttime >= 1ul))
        self->starttime=_shout_timing_get_time();

      if(len == 0ul)
      {
        return_value_send_queue$1=send_queue(self);
        return return_value_send_queue$1;
      }

      else
      {
        signed int return_value;
        return_value=self->send(self, data, len);
        return return_value;
      }
    }
}

// shout_send_raw
// file shout.c line 204
signed long int shout_send_raw(struct shout *self, const unsigned char *data, unsigned long int len)
{
  signed long int ret;
  if(self == ((struct shout *)NULL))
    return (signed long int)-1;

  else
    if(!((signed int)self->state == SHOUT_STATE_CONNECTED))
      return (signed long int)-8;

    else
    {
      self->error = 0;
      if(!(len == 0ul))
      {
        if(self->wqueue.len == 0ul)
        {
          signed int return_value_try_write$1;
          return_value_try_write$1=try_write(self, (const void *)data, len);
          ret = (signed long int)return_value_try_write$1;
          if(!(ret >= 0l))
            return (signed long int)self->error;

          if(!((unsigned long int)ret >= len))
          {
            self->error=queue_data(&self->wqueue, data + ret, len - (unsigned long int)ret);
            if(!(self->error == 0))
              return (signed long int)self->error;

          }

          return (signed long int)len;
        }

      }

      self->error=queue_data(&self->wqueue, data, len);
      if(!(self->error == 0))
        return (signed long int)self->error;

      else
      {
        signed int return_value_send_queue$2;
        return_value_send_queue$2=send_queue(self);
        ret = (signed long int)return_value_send_queue$2;
        if(ret == 0l || ret == -10l && !(len == 0ul))
          return (signed long int)len;

        else
          return ret;
      }
    }
}

// shout_set_agent
// file shout.c line 589
signed int shout_set_agent(struct shout *self, const char *agent)
{
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
    {
      self->error = -7;
      return self->error;
    }

    else
    {
      if(!(self->useragent == ((char *)NULL)))
        free((void *)self->useragent);

      self->useragent=_shout_util_strdup(agent);
      if(self->useragent == ((char *)NULL))
      {
        self->error = -5;
        return self->error;
      }

      else
      {
        self->error = 0;
        return self->error;
      }
    }
}

// shout_set_audio_info
// file shout.c line 690
signed int shout_set_audio_info(struct shout *self, const char *name, const char *value)
{
  self->error=_shout_util_dict_set(self->audio_info, name, value);
  return self->error;
}

// shout_set_description
// file shout.c line 640
signed int shout_set_description(struct shout *self, const char *description)
{
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
    {
      self->error = -7;
      return self->error;
    }

    else
    {
      if(!(self->description == ((char *)NULL)))
        free((void *)self->description);

      self->description=_shout_util_strdup(description);
      if(self->description == ((char *)NULL))
      {
        self->error = -5;
        return self->error;
      }

      else
      {
        self->error = 0;
        return self->error;
      }
    }
}

// shout_set_dumpfile
// file shout.c line 665
signed int shout_set_dumpfile(struct shout *self, const char *dumpfile)
{
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
      return -7;

    else
    {
      if(!(self->dumpfile == ((char *)NULL)))
        free((void *)self->dumpfile);

      self->dumpfile=_shout_util_strdup(dumpfile);
      if(self->dumpfile == ((char *)NULL))
      {
        self->error = -5;
        return self->error;
      }

      else
      {
        self->error = 0;
        return self->error;
      }
    }
}

// shout_set_format
// file ../include/shout/shout.h line 136
signed int shout_set_format(struct shout *self, unsigned int format)
{
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
    {
      self->error = -7;
      return self->error;
    }

    else
      if(!(format == 0u) && !(format == 1u) && !(format == 2u))
      {
        self->error = -9;
        return self->error;
      }

      else
      {
        self->format = format;
        self->error = 0;
        return self->error;
      }
}

// shout_set_genre
// file shout.c line 564
signed int shout_set_genre(struct shout *self, const char *genre)
{
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
    {
      self->error = -7;
      return self->error;
    }

    else
    {
      if(!(self->genre == ((char *)NULL)))
        free((void *)self->genre);

      self->genre=_shout_util_strdup(genre);
      if(self->genre == ((char *)NULL))
      {
        self->error = -5;
        return self->error;
      }

      else
      {
        self->error = 0;
        return self->error;
      }
    }
}

// shout_set_host
// file ../include/shout/shout.h line 96
signed int shout_set_host(struct shout *self, const char *host)
{
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
    {
      self->error = -7;
      return self->error;
    }

    else
    {
      if(!(self->host == ((char *)NULL)))
        free((void *)self->host);

      self->host=_shout_util_strdup(host);
      if(self->host == ((char *)NULL))
      {
        self->error = -5;
        return self->error;
      }

      else
      {
        self->error = 0;
        return self->error;
      }
    }
}

// shout_set_metadata
// file shout.c line 300
signed int shout_set_metadata(struct shout *self, struct _util_dict *metadata)
{
  signed int shout_set_metadata$$1$$socket;
  signed int rv;
  char *encvalue;
  const char *return_value_shout_get_agent$1;
  const char *return_value_shout_get_agent$3;
  if(metadata == ((struct _util_dict *)NULL) || self == ((struct shout *)NULL))
    return -1;

  else
  {
    encvalue=_shout_util_dict_urlencode(metadata, (char)38);
    if(encvalue == ((char *)NULL))
      return -5;

    else
    {
      shout_set_metadata$$1$$socket=_shout_sock_connect_wto(self->host, self->port, 0);
      if(!(shout_set_metadata$$1$$socket >= 1))
        return -2;

      else
      {
        if(self->protocol == 2u)
        {
          return_value_shout_get_agent$1=shout_get_agent(self);
          rv=_shout_sock_write(shout_set_metadata$$1$$socket, "GET /admin.cgi?mode=updinfo&pass=%s&%s HTTP/1.0\r\nUser-Agent: %s (Mozilla compatible)\r\n\r\n", self->password, encvalue, return_value_shout_get_agent$1);
        }

        else
          if(self->protocol == 0u)
          {
            char *auth;
            auth=http_basic_authorization(self);
            const char *return_value_shout_get_agent$2;
            return_value_shout_get_agent$2=shout_get_agent(self);
            rv=_shout_sock_write(shout_set_metadata$$1$$socket, "GET /admin/metadata?mode=updinfo&mount=%s&%s HTTP/1.0\r\nUser-Agent: %s\r\n%s\r\n", self->mount, encvalue, return_value_shout_get_agent$2, auth != ((char *)NULL) ? auth : "");
            free((void *)auth);
          }

          else
          {
            return_value_shout_get_agent$3=shout_get_agent(self);
            rv=_shout_sock_write(shout_set_metadata$$1$$socket, "GET /admin.cgi?mode=updinfo&pass=%s&mount=%s&%s HTTP/1.0\r\nUser-Agent: %s\r\n\r\n", self->password, self->mount, encvalue, return_value_shout_get_agent$3);
          }
        free((void *)encvalue);
        if(rv == 0)
        {
          _shout_sock_close(shout_set_metadata$$1$$socket);
          return -4;
        }

        else
        {
          _shout_sock_close(shout_set_metadata$$1$$socket);
          return 0;
        }
      }
    }
  }
}

// shout_set_mount
// file ../include/shout/shout.h line 105
signed int shout_set_mount(struct shout *self, const char *mount)
{
  unsigned long int len;
  if(mount == ((const char *)NULL) || self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
    {
      self->error = -7;
      return self->error;
    }

    else
    {
      if(!(self->mount == ((char *)NULL)))
        free((void *)self->mount);

      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(mount);
      len = return_value_strlen$1 + (unsigned long int)1;
      if(!((signed int)*mount == 47))
        len = len + 1ul;

      void *return_value_malloc$2;
      return_value_malloc$2=malloc(len);
      self->mount = (char *)return_value_malloc$2;
      if(self->mount == ((char *)NULL))
      {
        self->error = -5;
        return self->error;
      }

      else
      {
        sprintf(self->mount, "%s%s", (signed int)mount[(signed long int)0] == 47 ? "" : "/", mount);
        self->error = 0;
        return self->error;
      }
    }
}

// shout_set_name
// file shout.c line 514
signed int shout_set_name(struct shout *self, const char *name)
{
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
    {
      self->error = -7;
      return self->error;
    }

    else
    {
      if(!(self->name == ((char *)NULL)))
        free((void *)self->name);

      self->name=_shout_util_strdup(name);
      if(self->name == ((char *)NULL))
      {
        self->error = -5;
        return self->error;
      }

      else
      {
        self->error = 0;
        return self->error;
      }
    }
}

// shout_set_nonblocking
// file ../include/shout/shout.h line 145
signed int shout_set_nonblocking(struct shout *self, unsigned int nonblocking)
{
  if(self == ((struct shout *)NULL) || !(nonblocking == 0u) && !(nonblocking == 1u))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
    {
      self->error = -7;
      return self->error;
    }

    else
    {
      self->nonblocking = (signed int)nonblocking;
      return 0;
    }
}

// shout_set_password
// file ../include/shout/shout.h line 102
signed int shout_set_password(struct shout *self, const char *password)
{
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
    {
      self->error = -7;
      return self->error;
    }

    else
    {
      if(!(self->password == ((char *)NULL)))
        free((void *)self->password);

      self->password=_shout_util_strdup(password);
      if(self->password == ((char *)NULL))
      {
        self->error = -5;
        return self->error;
      }

      else
      {
        self->error = 0;
        return self->error;
      }
    }
}

// shout_set_port
// file ../include/shout/shout.h line 99
signed int shout_set_port(struct shout *self, unsigned short int port)
{
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
    {
      self->error = -7;
      return self->error;
    }

    else
    {
      self->port = (signed int)port;
      self->error = 0;
      return self->error;
    }
}

// shout_set_protocol
// file ../include/shout/shout.h line 140
signed int shout_set_protocol(struct shout *self, unsigned int protocol)
{
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
    {
      self->error = -7;
      return self->error;
    }

    else
      if(!(protocol == 0u) && !(protocol == 1u) && !(protocol == 2u))
      {
        self->error = -9;
        return self->error;
      }

      else
      {
        self->protocol = protocol;
        self->error = 0;
        return self->error;
      }
}

// shout_set_public
// file shout.c line 700
signed int shout_set_public(struct shout *self, unsigned int public)
{
  if(self == ((struct shout *)NULL) || !(public == 0u) && !(public == 1u))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
    {
      self->error = -7;
      return self->error;
    }

    else
    {
      self->public = (signed int)public;
      self->error = 0;
      return self->error;
    }
}

// shout_set_url
// file shout.c line 539
signed int shout_set_url(struct shout *self, const char *url)
{
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
    {
      self->error = -7;
      return self->error;
    }

    else
    {
      if(!(self->url == ((char *)NULL)))
        free((void *)self->url);

      self->url=_shout_util_strdup(url);
      if(self->url == ((char *)NULL))
      {
        self->error = -5;
        return self->error;
      }

      else
      {
        self->error = 0;
        return self->error;
      }
    }
}

// shout_set_user
// file ../include/shout/shout.h line 117
signed int shout_set_user(struct shout *self, const char *username)
{
  if(self == ((struct shout *)NULL))
    return -1;

  else
    if(!((signed int)self->state == SHOUT_STATE_UNCONNECTED))
    {
      self->error = -7;
      return self->error;
    }

    else
    {
      if(!(self->user == ((char *)NULL)))
        free((void *)self->user);

      self->user=_shout_util_strdup(username);
      if(self->user == ((char *)NULL))
      {
        self->error = -5;
        return self->error;
      }

      else
      {
        self->error = 0;
        return self->error;
      }
    }
}

// shout_shutdown
// file ../include/shout/shout.h line 69
void shout_shutdown(void)
{
  if(!(_initialized == 0))
  {
    _shout_sock_shutdown();
    _initialized = 0;
  }

}

// shout_sync
// file ../include/shout/shout.h line 168
void shout_sync(struct shout *self)
{
  signed long int sleep;
  if(!(self == ((struct shout *)NULL)))
  {
    if(!(self->senttime == 0ul))
    {
      unsigned long int return_value__shout_timing_get_time$1;
      return_value__shout_timing_get_time$1=_shout_timing_get_time();
      sleep = (signed long int)(self->senttime / (unsigned long int)1000 - (return_value__shout_timing_get_time$1 - self->starttime));
      if(sleep >= 1l)
        _shout_timing_sleep((unsigned long int)sleep);

    }

  }

}

// shout_version
// file shout.c line 339
const char * shout_version(signed int *major, signed int *minor, signed int *patch)
{
  if(!(major == ((signed int *)NULL)))
    *major = 2;

  if(!(minor == ((signed int *)NULL)))
    *minor = 3;

  if(!(patch == ((signed int *)NULL)))
    *patch = 1;

  return "2.3.1";
}

// sock_active
// file sock.c line 212
signed int sock_active(signed int sock)
{
  char c;
  signed int l;
  signed long int return_value_recv$1;
  return_value_recv$1=recv(sock, (void *)&c, (unsigned long int)1, 2);
  l = (signed int)return_value_recv$1;
  signed int return_value__shout_sock_error$2;
  signed int return_value__shout_sock_recoverable$3;
  if(l == 0)
    return 0;

  else
    if(l == -1)
    {
      return_value__shout_sock_error$2=_shout_sock_error();
      return_value__shout_sock_recoverable$3=_shout_sock_recoverable(return_value__shout_sock_error$2);
      if(return_value__shout_sock_recoverable$3 == 0)
        goto __CPROVER_DUMP_L2;

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      return 0;
    }
}

// sock_connect_pending
// file sock.c line 188
static signed int sock_connect_pending(signed int error)
{
  return (signed int)(error == 115 || error == 114);
}

// split_headers
// file httpp.c line 62
static signed int split_headers(char *data, unsigned long int len, char **line)
{
  signed int lines = 0;
  unsigned long int i;
  line[(signed long int)lines] = data;
  i = (unsigned long int)0;
  _Bool tmp_if_expr$1;
  for( ; !(lines >= 32) && !(i >= len); i = i + 1ul)
  {
    if((signed int)data[(signed long int)i] == 13)
      data[(signed long int)i] = (char)0;

    if((signed int)data[(signed long int)i] == 10)
    {
      lines = lines + 1;
      data[(signed long int)i] = (char)0;
      if(lines >= 32)
        return 32;

      if(!(1ul + i >= len))
      {
        if((signed int)data[1l + (signed long int)i] == 10)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (signed int)data[(signed long int)(i + (unsigned long int)1)] == 13 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
          break;

        line[(signed long int)lines] = &data[(signed long int)(i + (unsigned long int)1)];
      }

    }

  }
  i = i + 1ul;
  for( ; !(i >= len); i = i + 1ul)
    if(!((signed int)data[(signed long int)i] == 10))
      break;

  return lines;
}

// theora_ilog
// file theora.c line 142
static signed int theora_ilog(unsigned int v)
{
  signed int ret = 0;
  for( ; !(v == 0u); v = v >> 1)
    ret = ret + 1;
  return ret;
}

// thread_spin_create
// file thread.c line 817
void thread_spin_create(struct anonymous$27 *spin)
{
  signed int x;
  x=pthread_spin_init(&spin->lock, 0);
  if(!(x == 0))
    abort();

}

// thread_spin_destroy
// file thread.c line 824
void thread_spin_destroy(struct anonymous$27 *spin)
{
  pthread_spin_destroy(&spin->lock);
}

// thread_spin_lock
// file thread.c line 829
void thread_spin_lock(struct anonymous$27 *spin)
{
  signed int x;
  x=pthread_spin_lock(&spin->lock);
  if(!(x == 0))
    abort();

}

// thread_spin_unlock
// file thread.c line 836
void thread_spin_unlock(struct anonymous$27 *spin)
{
  pthread_spin_unlock(&spin->lock);
}

// try_connect
// file shout.c line 936
static signed int try_connect(struct shout *self)
{
  signed int rc;
  signed int port;
  unsigned int return_value_shout_get_protocol$1;
  unsigned int return_value_shout_get_nonblocking$2;
  unsigned int return_value_shout_get_nonblocking$3;
  unsigned int return_value_shout_get_nonblocking$4;
  unsigned int return_value_shout_get_nonblocking$5;
  switch((signed int)self->state)
  {
    case SHOUT_STATE_UNCONNECTED:
    {
      port = self->port;
      return_value_shout_get_protocol$1=shout_get_protocol(self);
      if(return_value_shout_get_protocol$1 == 2u)
        port = port + 1;

      return_value_shout_get_nonblocking$2=shout_get_nonblocking(self);
      if(!(return_value_shout_get_nonblocking$2 == 0u))
      {
        self->socket=_shout_sock_connect_non_blocking(self->host, (unsigned int)port);
        if(!(self->socket >= 0))
        {
          self->error = -2;
          return self->error;
        }

        self->state = (enum anonymous$9)SHOUT_STATE_CONNECT_PENDING;
      }

      else
      {
        self->socket=_shout_sock_connect_wto(self->host, port, 0);
        if(!(self->socket >= 0))
        {
          self->error = -2;
          return self->error;
        }

        rc=create_request(self);
        if(!(rc == 0))
          return rc;

        self->state = (enum anonymous$9)SHOUT_STATE_REQ_PENDING;
      }
    }
    case SHOUT_STATE_CONNECT_PENDING:
    {
      return_value_shout_get_nonblocking$3=shout_get_nonblocking(self);
      if(!(return_value_shout_get_nonblocking$3 == 0u))
      {
        rc=_shout_sock_connected(self->socket, 0);
        if(!(rc >= 1))
        {
          if(rc == -1)
          {
            rc = -4;
            break;
          }

          else
            return -10;
        }

        rc=create_request(self);
        if(!(rc == 0))
          break;

      }

      self->state = (enum anonymous$9)SHOUT_STATE_REQ_PENDING;
    }
    case SHOUT_STATE_REQ_PENDING:
    {
      do
      {
        rc=send_queue(self);
        return_value_shout_get_nonblocking$4=shout_get_nonblocking(self);
      }
      while(rc == -10 && return_value_shout_get_nonblocking$4 == 0u);
      if(rc == -10)
        return rc;

      if(!(rc == 0))
        break;

      self->state = (enum anonymous$9)SHOUT_STATE_RESP_PENDING;
    }
    case SHOUT_STATE_RESP_PENDING:
    {
      do
      {
        rc=get_response(self);
        return_value_shout_get_nonblocking$5=shout_get_nonblocking(self);
      }
      while(rc == -10 && return_value_shout_get_nonblocking$5 == 0u);
      if(rc == -10)
        return rc;

      if(!(rc == 0))
        break;

      rc=parse_response(self);
      if(!(rc == 0))
        break;

      if(self->format == 0u)
      {
        self->error=shout_open_ogg(self);
        rc = self->error;
        if(!(rc == 0))
          break;

      }

      else
        if(self->format == 1u)
        {
          self->error=shout_open_mp3(self);
          rc = self->error;
          if(!(rc == 0))
            break;

        }

        else
          if(self->format == 2u)
          {
            self->error=shout_open_webm(self);
            rc = self->error;
            if(!(rc == 0))
              break;

          }

          else
          {
            rc = -1;
            break;
          }
    }
    case SHOUT_STATE_CONNECTED:
      self->state = (enum anonymous$9)SHOUT_STATE_CONNECTED;
    default:
      return 0;
  }

failure:
  ;
  shout_close(self);
  return rc;
}

// try_write
// file shout.c line 1022
static signed int try_write(struct shout *self, const void *data_p, unsigned long int len)
{
  signed int ret;
  unsigned long int pos = (unsigned long int)0;
  unsigned char *data = (unsigned char *)data_p;
  do
  {
    ret=_shout_sock_write_bytes(self->socket, (const void *)(data + (signed long int)pos), len - pos);
    if(ret >= 1)
      pos = pos + (unsigned long int)ret;

  }
  while(ret >= 0 && !(pos >= len));
  if(!(ret >= 0))
  {
    signed int return_value__shout_sock_error$1;
    return_value__shout_sock_error$1=_shout_sock_error();
    signed int return_value__shout_sock_recoverable$2;
    return_value__shout_sock_recoverable$2=_shout_sock_recoverable(return_value__shout_sock_error$1);
    if(!(return_value__shout_sock_recoverable$2 == 0))
    {
      self->error = -10;
      return (signed int)pos;
    }

    self->error = -4;
    return ret;
  }

  return (signed int)pos;
}

// url_escape
// file httpp.c line 204
static char * url_escape(const char *src)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(src);
  len = (signed int)return_value_strlen$1;
  unsigned char *decoded;
  signed int i;
  char *dst;
  signed int done = 0;
  void *return_value_calloc$2;
  return_value_calloc$2=calloc((unsigned long int)1, (unsigned long int)(len + 1));
  decoded = (unsigned char *)return_value_calloc$2;
  dst = (char *)decoded;
  i = 0;
  signed int return_value_hex$3;
  _Bool tmp_if_expr$5;
  signed int return_value_hex$4;
  char *tmp_post$6;
  signed int return_value_hex$7;
  signed int return_value_hex$8;
  char *tmp_post$9;
  char *tmp_post$10;
  for( ; !(i >= len); i = i + 1)
  {
    switch((signed int)src[(signed long int)i])
    {
      case 37:
      {
        if(2 + i >= len)
        {
          free((void *)decoded);
          return (char *)(void *)0;
        }

        return_value_hex$3=hex(src[(signed long int)(i + 1)]);
        if(return_value_hex$3 == -1)
          tmp_if_expr$5 = (_Bool)1;

        else
        {
          return_value_hex$4=hex(src[(signed long int)(i + 2)]);
          tmp_if_expr$5 = return_value_hex$4 == -1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$5)
        {
          free((void *)decoded);
          return (char *)(void *)0;
        }

        tmp_post$6 = dst;
        dst = dst + 1l;
        return_value_hex$7=hex(src[(signed long int)(i + 1)]);
        return_value_hex$8=hex(src[(signed long int)(i + 2)]);
        *tmp_post$6 = (char)(return_value_hex$7 * 16 + return_value_hex$8);
        i = i + 2;
        break;
      }
      case 43:
      {
        tmp_post$9 = dst;
        dst = dst + 1l;
        *tmp_post$9 = (char)32;
        break;
      }
      case 35:
      {
        done = 1;
        break;
      }
      case 0:
      {
        free((void *)decoded);
        return (char *)(void *)0;
      }
      default:
      {
        tmp_post$10 = dst;
        dst = dst + 1l;
        *tmp_post$10 = src[(signed long int)i];
      }
    }
    if(!(done == 0))
      break;

  }
  *dst = (char)0;
  return (char *)decoded;
}

// vorbis_blocksize
// file vorbis.c line 108
static signed int vorbis_blocksize(struct anonymous$30 *vd, struct anonymous$2 *p)
{
  signed int this;
  signed long int return_value_vorbis_packet_blocksize$1;
  return_value_vorbis_packet_blocksize$1=vorbis_packet_blocksize(&vd->vi, p);
  this = (signed int)return_value_vorbis_packet_blocksize$1;
  signed int ret = (this + vd->prevW) / 4;
  if(vd->prevW == 0)
  {
    vd->prevW = this;
    return 0;
  }

  else
  {
    vd->prevW = this;
    return ret;
  }
}

