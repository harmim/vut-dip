// #anon_enum$SDP_ATTR_REQ_INDIVIDUAL=1$SDP_ATTR_REQ_RANGE=2
// file /usr/include/bluetooth/sdp_lib.h line 98
enum anonymous$34 { SDP_ATTR_REQ_INDIVIDUAL=1, SDP_ATTR_REQ_RANGE=2 };

// #anon_enum$XML_ATTRIBUTE_CDATA=1$XML_ATTRIBUTE_ID=2$XML_ATTRIBUTE_IDREF=3$XML_ATTRIBUTE_IDREFS=4$XML_ATTRIBUTE_ENTITY=5$XML_ATTRIBUTE_ENTITIES=6$XML_ATTRIBUTE_NMTOKEN=7$XML_ATTRIBUTE_NMTOKENS=8$XML_ATTRIBUTE_ENUMERATION=9$XML_ATTRIBUTE_NOTATION=10
// file /usr/include/libxml2/libxml/tree.h line 206
enum anonymous$11 { XML_ATTRIBUTE_CDATA=1, XML_ATTRIBUTE_ID=2, XML_ATTRIBUTE_IDREF=3, XML_ATTRIBUTE_IDREFS=4, XML_ATTRIBUTE_ENTITY=5, XML_ATTRIBUTE_ENTITIES=6, XML_ATTRIBUTE_NMTOKEN=7, XML_ATTRIBUTE_NMTOKENS=8, XML_ATTRIBUTE_ENUMERATION=9, XML_ATTRIBUTE_NOTATION=10 };

// #anon_enum$XML_ELEMENT_CONTENT_ONCE=1$XML_ELEMENT_CONTENT_OPT=2$XML_ELEMENT_CONTENT_MULT=3$XML_ELEMENT_CONTENT_PLUS=4
// file /usr/include/libxml2/libxml/tree.h line 290
enum anonymous$27 { XML_ELEMENT_CONTENT_ONCE=1, XML_ELEMENT_CONTENT_OPT=2, XML_ELEMENT_CONTENT_MULT=3, XML_ELEMENT_CONTENT_PLUS=4 };

// #anon_enum$XML_ELEMENT_CONTENT_PCDATA=1$XML_ELEMENT_CONTENT_ELEMENT=2$XML_ELEMENT_CONTENT_SEQ=3$XML_ELEMENT_CONTENT_OR=4
// file /usr/include/libxml2/libxml/tree.h line 278
enum anonymous$26 { XML_ELEMENT_CONTENT_PCDATA=1, XML_ELEMENT_CONTENT_ELEMENT=2, XML_ELEMENT_CONTENT_SEQ=3, XML_ELEMENT_CONTENT_OR=4 };

// #anon_enum$XML_ELEMENT_NODE=1$XML_ATTRIBUTE_NODE=2$XML_TEXT_NODE=3$XML_CDATA_SECTION_NODE=4$XML_ENTITY_REF_NODE=5$XML_ENTITY_NODE=6$XML_PI_NODE=7$XML_COMMENT_NODE=8$XML_DOCUMENT_NODE=9$XML_DOCUMENT_TYPE_NODE=10$XML_DOCUMENT_FRAG_NODE=11$XML_NOTATION_NODE=12$XML_HTML_DOCUMENT_NODE=13$XML_DTD_NODE=14$XML_ELEMENT_DECL=15$XML_ATTRIBUTE_DECL=16$XML_ENTITY_DECL=17$XML_NAMESPACE_DECL=18$XML_XINCLUDE_START=19$XML_XINCLUDE_END=20$XML_DOCB_DOCUMENT_NODE=21
// file /usr/include/libxml2/libxml/tree.h line 159
enum anonymous$9 { XML_ELEMENT_NODE=1, XML_ATTRIBUTE_NODE=2, XML_TEXT_NODE=3, XML_CDATA_SECTION_NODE=4, XML_ENTITY_REF_NODE=5, XML_ENTITY_NODE=6, XML_PI_NODE=7, XML_COMMENT_NODE=8, XML_DOCUMENT_NODE=9, XML_DOCUMENT_TYPE_NODE=10, XML_DOCUMENT_FRAG_NODE=11, XML_NOTATION_NODE=12, XML_HTML_DOCUMENT_NODE=13, XML_DTD_NODE=14, XML_ELEMENT_DECL=15, XML_ATTRIBUTE_DECL=16, XML_ENTITY_DECL=17, XML_NAMESPACE_DECL=18, XML_XINCLUDE_START=19, XML_XINCLUDE_END=20, XML_DOCB_DOCUMENT_NODE=21 };

// #anon_enum$XML_ERR_NONE=0$XML_ERR_WARNING=1$XML_ERR_ERROR=2$XML_ERR_FATAL=3
// file /usr/include/libxml2/libxml/xmlerror.h line 24
enum anonymous$12 { XML_ERR_NONE=0, XML_ERR_WARNING=1, XML_ERR_ERROR=2, XML_ERR_FATAL=3 };

// #anon_enum$XML_INTERNAL_GENERAL_ENTITY=1$XML_EXTERNAL_GENERAL_PARSED_ENTITY=2$XML_EXTERNAL_GENERAL_UNPARSED_ENTITY=3$XML_INTERNAL_PARAMETER_ENTITY=4$XML_EXTERNAL_PARAMETER_ENTITY=5$XML_INTERNAL_PREDEFINED_ENTITY=6
// file /usr/include/libxml2/libxml/entities.h line 24
enum anonymous$35 { XML_INTERNAL_GENERAL_ENTITY=1, XML_EXTERNAL_GENERAL_PARSED_ENTITY=2, XML_EXTERNAL_GENERAL_UNPARSED_ENTITY=3, XML_INTERNAL_PARAMETER_ENTITY=4, XML_EXTERNAL_PARAMETER_ENTITY=5, XML_INTERNAL_PREDEFINED_ENTITY=6 };

// #anon_enum$XML_PARSER_EOF=-1$XML_PARSER_START=0$XML_PARSER_MISC=1$XML_PARSER_PI=2$XML_PARSER_DTD=3$XML_PARSER_PROLOG=4$XML_PARSER_COMMENT=5$XML_PARSER_START_TAG=6$XML_PARSER_CONTENT=7$XML_PARSER_CDATA_SECTION=8$XML_PARSER_END_TAG=9$XML_PARSER_ENTITY_DECL=10$XML_PARSER_ENTITY_VALUE=11$XML_PARSER_ATTRIBUTE_VALUE=12$XML_PARSER_SYSTEM_LITERAL=13$XML_PARSER_EPILOG=14$XML_PARSER_IGNORE=15$XML_PARSER_PUBLIC_LITERAL=16
// file /usr/include/libxml2/libxml/parser.h line 112
enum anonymous$16 { XML_PARSER_EOF=-1, XML_PARSER_START=0, XML_PARSER_MISC=1, XML_PARSER_PI=2, XML_PARSER_DTD=3, XML_PARSER_PROLOG=4, XML_PARSER_COMMENT=5, XML_PARSER_START_TAG=6, XML_PARSER_CONTENT=7, XML_PARSER_CDATA_SECTION=8, XML_PARSER_END_TAG=9, XML_PARSER_ENTITY_DECL=10, XML_PARSER_ENTITY_VALUE=11, XML_PARSER_ATTRIBUTE_VALUE=12, XML_PARSER_SYSTEM_LITERAL=13, XML_PARSER_EPILOG=14, XML_PARSER_IGNORE=15, XML_PARSER_PUBLIC_LITERAL=16 };

// #anon_enum$XML_PARSE_UNKNOWN=0$XML_PARSE_DOM=1$XML_PARSE_SAX=2$XML_PARSE_PUSH_DOM=3$XML_PARSE_PUSH_SAX=4$XML_PARSE_READER=5
// file /usr/include/libxml2/libxml/parser.h line 163
enum anonymous$21 { XML_PARSE_UNKNOWN=0, XML_PARSE_DOM=1, XML_PARSE_SAX=2, XML_PARSE_PUSH_DOM=3, XML_PARSE_PUSH_SAX=4, XML_PARSE_READER=5 };

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$19;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$17;

// tag-#anon#ST[*{cS8}$cS8$'str'||U16'length'||U48'$pad0'|]
// file /usr/include/menu.h line 63
struct anonymous;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$25;

// tag-#anon#ST[ARR16{U8}$U8$'data'|]
// file /usr/include/bluetooth/bluetooth.h line 342
struct anonymous$4;

// tag-#anon#ST[ARR6{U8}$U8$'b'|]
// file /usr/include/bluetooth/bluetooth.h line 300
struct anonymous$28;

// tag-#anon#ST[ENtag-screen_types#{U32}$U32$'type'||U32'$pad0'||*{V()->V}$V()->V$'title'||*{S32()->S32}$S32()->S32$'changed'||*{S32(S32)->S32}$S32(S32)->S32$'get_content'||*{SYM#tag-screen_keys#}$SYM#tag-screen_keys#$'keymap'|]
// file screen.c line 503
struct anonymous$0;

// tag-#anon#ST[ENtag-threader_scan_types#{U32}$U32$'what'||U32'$pad0'||*{cS8}$cS8$'desc'||*{*{V}$V$(*{V}$V$)->*{V}$V$}$*{V}$V$(*{V}$V$)->*{V}$V$$'func'|]
// file threader.c line 83
struct anonymous$6;

// tag-#anon#ST[S16'pmin'||S16'pmax'||S16'smin'||S16'smax'|]
// file /usr/include/form.h line 61
struct anonymous$38;

// tag-#anon#ST[S32'num_items'||U32'$pad0'||*{U64}$U64$'ids'||U64'selected'||*{*{S8}$S8$}$*{S8}$S8$$'labels'||*{*{SYM#tag-tagITEM#}$SYM#tag-tagITEM#$}$*{SYM#tag-tagITEM#}$SYM#tag-tagITEM#$$'items'||*{SYM#tag-tagMENU#}$SYM#tag-tagMENU#$'m'||*{SYM#tag-_win_st#}$SYM#tag-_win_st#$'sw'|]
// file screen.c line 170
struct anonymous$32;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/regex.h line 452
struct anonymous$23;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$10;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$15;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$14;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$22;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$13;

// tag-#anon#ST[S32'sock'||S32'state'||S32'local'||S32'flags'||U16'tid'||U48'$pad0'||*{V}$V$'priv'|]
// file /usr/include/bluetooth/sdp_lib.h line 89
struct anonymous$33;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$18;

// tag-#anon#ST[SYM#tag-#anon#ST[ARR6{U8}$U8$'b'|]#'bdaddr'||U8'pscan_rep_mode'||U8'pscan_period_mode'||U8'pscan_mode'||ARR3{U8}$U8$'dev_class'||U16'clock_offset'|]
// file /usr/include/bluetooth/hci.h line 1748
struct anonymous$36;

// tag-#anon#ST[SYM#tag-#anon#ST[U8'type'||U24'$pad0'||SYM#tag-#anon#UN[U16'uuid16'||U32'uuid32'||SYM#tag-#anon#ST[ARR16{U8}$U8$'data'|]#'uuid128'|]#'value'|]#'uuid'||U16'version'||U16'$pad0'|]
// file /usr/include/bluetooth/sdp.h line 489
struct anonymous$8;

// tag-#anon#ST[U16'code_ISO639'||U16'encoding'||U16'base_offset'|]
// file /usr/include/bluetooth/sdp.h line 477
struct anonymous$7;

// tag-#anon#ST[U32'handle'||U32'$pad0'||*{SYM#tag-_sdp_list#}$SYM#tag-_sdp_list#$'pattern'||*{SYM#tag-_sdp_list#}$SYM#tag-_sdp_list#$'attrlist'||SYM#tag-#anon#ST[U8'type'||U24'$pad0'||SYM#tag-#anon#UN[U16'uuid16'||U32'uuid32'||SYM#tag-#anon#ST[ARR16{U8}$U8$'data'|]#'uuid128'|]#'value'|]#'svclass'||U32'$pad1'|]
// file /usr/include/bluetooth/sdp.h line 505
struct anonymous$2;

// tag-#anon#ST[U64'attr'||ARR5{S32}$S32$'chars'||U32'$pad0'|]
// file /usr/include/curses.h line 397
struct anonymous$29;

// tag-#anon#ST[U64'sx'||U64'sy'||U64'mcols'||U64'mrows'||SYM#tag-cbuf#'text'||S64'updated'|]
// file screen.c line 160
struct anonymous$31;

// tag-#anon#ST[U64'x'||U64'y'||U64'rows'||U64'cols'||*{SYM#tag-_win_st#}$SYM#tag-_win_st#$'w'|]
// file screen.c line 151
struct anonymous$30;

// tag-#anon#ST[U8'type'||U24'$pad0'||SYM#tag-#anon#UN[U16'uuid16'||U32'uuid32'||SYM#tag-#anon#ST[ARR16{U8}$U8$'data'|]#'uuid128'|]#'value'|]
// file /usr/include/bluetooth/sdp.h line 445
struct anonymous$1;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$24;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$20;

// tag-#anon#UN[S8'int8'||S16'int16'||S32'int32'||S64'int64'||SYM#tag-#anon#ST[ARR16{U8}$U8$'data'|]#'int128'||U8'uint8'||U16'uint16'||U32'uint32'||U64'uint64'||SYM#tag-#anon#ST[ARR16{U8}$U8$'data'|]#'uint128'||SYM#tag-#anon#ST[U8'type'||U24'$pad0'||SYM#tag-#anon#UN[U16'uuid16'||U32'uuid32'||SYM#tag-#anon#ST[ARR16{U8}$U8$'data'|]#'uuid128'|]#'value'|]#'uuid'||*{S8}$S8$'str'||*{SYM#tag-sdp_data_struct#}$SYM#tag-sdp_data_struct#$'dataseq'||U192'$pad'|]
// file /usr/include/bluetooth/sdp.h line 520
union anonymous$3;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$37;

// tag-#anon#UN[U16'uuid16'||U32'uuid32'||SYM#tag-#anon#ST[ARR16{U8}$U8$'data'|]#'uuid128'|]
// file /usr/include/bluetooth/sdp.h line 447
union anonymous$5;

// tag-UConverter
// file /usr/include/x86_64-linux-gnu/unicode/ucnv_err.h line 91
struct UConverter;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_sdp_list
// file /usr/include/bluetooth/sdp.h line 461
struct _sdp_list;

// tag-_uconv_t
// file /usr/include/libxml2/libxml/encoding.h line 132
struct _uconv_t;

// tag-_win_st
// file /usr/include/curses.h line 365
struct _win_st;

// tag-_xmlAttr
// file /usr/include/libxml2/libxml/tree.h line 432
struct _xmlAttr;

// tag-_xmlAutomata
// file /usr/include/libxml2/libxml/xmlautomata.h line 29
struct _xmlAutomata;

// tag-_xmlAutomataState
// file /usr/include/libxml2/libxml/xmlautomata.h line 37
struct _xmlAutomataState;

// tag-_xmlBuf
// file /usr/include/libxml2/libxml/tree.h line 105
struct _xmlBuf;

// tag-_xmlCharEncodingHandler
// file /usr/include/libxml2/libxml/encoding.h line 139
struct _xmlCharEncodingHandler;

// tag-_xmlDict
// file /usr/include/libxml2/libxml/dict.h line 25
struct _xmlDict;

// tag-_xmlDoc
// file /usr/include/libxml2/libxml/tree.h line 262
struct _xmlDoc;

// tag-_xmlDtd
// file /usr/include/libxml2/libxml/tree.h line 259
struct _xmlDtd;

// tag-_xmlElementContent
// file /usr/include/libxml2/libxml/tree.h line 304
struct _xmlElementContent;

// tag-_xmlEntity
// file /usr/include/libxml2/libxml/tree.h line 48
struct _xmlEntity;

// tag-_xmlEnumeration
// file /usr/include/libxml2/libxml/tree.h line 238
struct _xmlEnumeration;

// tag-_xmlError
// file /usr/include/libxml2/libxml/xmlerror.h line 76
struct _xmlError;

// tag-_xmlHashTable
// file /usr/include/libxml2/libxml/hash.h line 21
struct _xmlHashTable;

// tag-_xmlNode
// file /usr/include/libxml2/libxml/tree.h line 257
struct _xmlNode;

// tag-_xmlNs
// file /usr/include/libxml2/libxml/tree.h line 387
struct _xmlNs;

// tag-_xmlParserCtxt
// file /usr/include/libxml2/libxml/tree.h line 38
struct _xmlParserCtxt;

// tag-_xmlParserInput
// file /usr/include/libxml2/libxml/tree.h line 35
struct _xmlParserInput;

// tag-_xmlParserInputBuffer
// file /usr/include/libxml2/libxml/tree.h line 28
struct _xmlParserInputBuffer;

// tag-_xmlParserNodeInfo
// file /usr/include/libxml2/libxml/parser.h line 86
struct _xmlParserNodeInfo;

// tag-_xmlParserNodeInfoSeq
// file /usr/include/libxml2/libxml/parser.h line 98
struct _xmlParserNodeInfoSeq;

// tag-_xmlSAXHandler
// file /usr/include/libxml2/libxml/tree.h line 44
struct _xmlSAXHandler;

// tag-_xmlSAXLocator
// file /usr/include/libxml2/libxml/tree.h line 41
struct _xmlSAXLocator;

// tag-_xmlValidCtxt
// file /usr/include/libxml2/libxml/valid.h line 80
struct _xmlValidCtxt;

// tag-_xmlValidState
// file /usr/include/libxml2/libxml/valid.h line 28
struct _xmlValidState;

// tag-cbuf
// file ./misc.h line 32
struct cbuf;

// tag-classes
// file sdp.c line 79
struct classes;

// tag-device
// file ./ll.h line 41
struct device;

// tag-fieldnode
// file /usr/include/form.h line 72
struct fieldnode;

// tag-formnode
// file /usr/include/form.h line 93
struct formnode;

// tag-hci_conn_info
// file /usr/include/bluetooth/hci.h line 2400
struct hci_conn_info;

// tag-hci_conn_list_req
// file /usr/include/bluetooth/hci.h line 2419
struct hci_conn_list_req;

// tag-hci_dev_info
// file /usr/include/bluetooth/hci.h line 2377
struct hci_dev_info;

// tag-hci_dev_list_req
// file /usr/include/bluetooth/hci.h line 2414
struct hci_dev_list_req;

// tag-hci_dev_req
// file /usr/include/bluetooth/hci.h line 2409
struct hci_dev_req;

// tag-hci_dev_stats
// file /usr/include/bluetooth/hci.h line 2364
struct hci_dev_stats;

// tag-hci_version
// file /usr/include/bluetooth/hci_lib.h line 43
struct hci_version;

// tag-hcicfg
// file ./main.h line 36
struct hcicfg;

// tag-ldat
// file /usr/include/curses.h line 412
struct ldat;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-oui
// file oui.c line 73
struct oui;

// tag-pdat
// file /usr/include/curses.h line 452
struct pdat;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rangedef
// file ./cfg.h line 39
struct rangedef;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-screen_keys
// file screen.c line 181
struct screen_keys;

// tag-screen_types
// file screen.c line 142
enum screen_types { LINE=0, BLOCK=1 };

// tag-sdp_data_struct
// file /usr/include/bluetooth/sdp.h line 516
struct sdp_data_struct;

// tag-search_context
// file scan.c line 86
struct search_context;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-sub_classes
// file sdp.c line 72
struct sub_classes;

// tag-tagITEM
// file /usr/include/menu.h line 69
struct tagITEM;

// tag-tagMENU
// file /usr/include/menu.h line 73
struct tagMENU;

// tag-threader_scan_types
// file ./threader.h line 32
enum threader_scan_types { SCAN_NONE=0, SCAN_INQ=1, SCAN_BF=2 };

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-typenode
// file /usr/include/form.h line 94
struct typenode;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// applog
// file ./log.h line 34
signed int applog(signed int level, const char *fmt, ...);
// assume_default_colors
// file /usr/include/curses.h line 897
extern signed int assume_default_colors(signed int, signed int);
// ba2int
// file oui.c line 84
unsigned int ba2int(struct anonymous$28 *ba);
// ba2str
// file /usr/include/bluetooth/bluetooth.h line 326
signed int ba2str(const struct anonymous$28 *, char *);
// bacmp
// file /usr/include/bluetooth/bluetooth.h line 314
static inline signed int bacmp(const struct anonymous$28 *ba1, const struct anonymous$28 *ba2);
// bacpy
// file /usr/include/bluetooth/bluetooth.h line 318
static inline void bacpy(struct anonymous$28 *dst, const struct anonymous$28 *src);
// bacpy$link1
// file /usr/include/bluetooth/bluetooth.h line 318
static inline void bacpy$link1(struct anonymous$28 *dst$link1, const struct anonymous$28 *src$link1);
// bacpy$link2
// file /usr/include/bluetooth/bluetooth.h line 318
static inline void bacpy$link2(struct anonymous$28 *dst$link2, const struct anonymous$28 *src$link2);
// bd2int
// file ./misc.h line 40
unsigned long int bd2int(struct anonymous$28 *bd);
// bf_run
// file ./scan.h line 34
void * bf_run(void *arg);
// bt_compidtostr
// file /usr/include/bluetooth/bluetooth.h line 340
const char * bt_compidtostr(signed int);
// cbreak
// file /usr/include/curses.h line 594
extern signed int cbreak(void);
// cfg_cleanup
// file ./cfg.h line 50
signed int cfg_cleanup(void);
// cfg_copy_content
// file cfg.c line 97
char * cfg_copy_content(struct _xmlNode *node);
// cfg_get_range
// file cfg.c line 434
struct rangedef * cfg_get_range(unsigned long int did);
// cfg_log_filename
// file cfg.c line 419
const char * cfg_log_filename(void);
// cfg_oui_filename
// file ./cfg.h line 54
const char * cfg_oui_filename(void);
// cfg_parse_files
// file cfg.c line 144
signed int cfg_parse_files(struct _xmlNode *node);
// cfg_parse_rangedef
// file cfg.c line 172
signed int cfg_parse_rangedef(struct _xmlNode *node, struct rangedef *rd);
// cfg_parse_root
// file cfg.c line 246
signed int cfg_parse_root(struct _xmlNode *node);
// cfg_parse_xml
// file cfg.c line 294
signed int cfg_parse_xml(char *filename);
// cfg_parsefile
// file ./cfg.h line 49
signed int cfg_parsefile(char *filename);
// cfg_store_filename
// file cfg.c line 427
const char * cfg_store_filename(void);
// cfg_xml_err
// file cfg.c line 281
void cfg_xml_err(void *ctx, const char *fmt, ...);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// current_item
// file /usr/include/menu.h line 176
extern struct tagITEM * current_item(const struct tagMENU *);
// curs_set
// file /usr/include/curses.h line 604
extern signed int curs_set(signed int);
// delwin
// file /usr/include/curses.h line 610
extern signed int delwin(struct _win_st *);
// derwin
// file /usr/include/curses.h line 612
extern struct _win_st * derwin(struct _win_st *, signed int, signed int, signed int, signed int);
// dointerrupt
// file main.c line 97
static void dointerrupt(signed int sig);
// doupdate
// file /usr/include/curses.h line 613
extern signed int doupdate(void);
// endwin
// file /usr/include/curses.h line 618
extern signed int endwin(void);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// field_buffer
// file /usr/include/form.h line 362
extern char * field_buffer(const struct fieldnode *, signed int);
// field_opts_off
// file /usr/include/form.h line 348
extern signed int field_opts_off(struct fieldnode *, signed int);
// find_conn
// file scan.c line 129
unsigned short int find_conn(signed int dev_id, struct anonymous$28 *bdaddr);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// form_driver
// file /usr/include/form.h line 400
extern signed int form_driver(struct formnode *, signed int);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_field
// file /usr/include/form.h line 330
extern signed int free_field(struct fieldnode *);
// free_form
// file /usr/include/form.h line 383
extern signed int free_form(struct formnode *);
// free_item
// file /usr/include/menu.h line 206
extern signed int free_item(struct tagITEM *);
// free_menu
// file /usr/include/menu.h line 207
extern signed int free_menu(struct tagMENU *);
// get_max_devices
// file main.c line 146
signed int get_max_devices(signed int s);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpagesize
// file /usr/include/unistd.h line 978
extern signed int getpagesize(void);
// halfdelay
// file /usr/include/curses.h line 628
extern signed int halfdelay(signed int);
// handlesig
// file main.c line 89
static void handlesig(signed int sig);
// has_colors
// file /usr/include/curses.h line 629
extern _Bool has_colors(void);
// hci_close_dev
// file /usr/include/bluetooth/hci_lib.h line 52
signed int hci_close_dev(signed int);
// hci_create_connection
// file /usr/include/bluetooth/hci_lib.h line 56
signed int hci_create_connection(signed int, const struct anonymous$28 *, unsigned short int, unsigned short int, unsigned char, unsigned short int *, signed int);
// hci_devices_append
// file main.c line 131
void hci_devices_append(struct hcicfg *h, struct hcicfg *n);
// hci_devices_free
// file main.c line 123
void hci_devices_free(struct hcicfg *h);
// hci_disconnect
// file /usr/include/bluetooth/hci_lib.h line 57
signed int hci_disconnect(signed int, unsigned short int, unsigned char, signed int);
// hci_inquiry
// file /usr/include/bluetooth/hci_lib.h line 59
signed int hci_inquiry(signed int, signed int, signed int, const unsigned char *, struct anonymous$36 **, signed long int);
// hci_open_dev
// file /usr/include/bluetooth/hci_lib.h line 51
signed int hci_open_dev(signed int);
// hci_read_link_quality
// file /usr/include/bluetooth/hci_lib.h line 113
signed int hci_read_link_quality(signed int, unsigned short int, unsigned char *, signed int);
// hci_read_remote_features
// file /usr/include/bluetooth/hci_lib.h line 70
signed int hci_read_remote_features(signed int, unsigned short int, unsigned char *, signed int);
// hci_read_remote_name
// file /usr/include/bluetooth/hci_lib.h line 66
signed int hci_read_remote_name(signed int, const struct anonymous$28 *, signed int, char *, signed int);
// hci_read_remote_version
// file /usr/include/bluetooth/hci_lib.h line 69
signed int hci_read_remote_version(signed int, unsigned short int, struct hci_version *, signed int);
// hci_read_rssi
// file /usr/include/bluetooth/hci_lib.h line 114
signed int hci_read_rssi(signed int, unsigned short int, signed char *, signed int);
// hci_read_transmit_power_level
// file /usr/include/bluetooth/hci_lib.h line 107
signed int hci_read_transmit_power_level(signed int, unsigned short int, unsigned char, signed char *, signed int);
// hci_test_bit
// file /usr/include/bluetooth/hci_lib.h line 183
static inline signed int hci_test_bit(signed int nr, void *addr);
// idlok
// file /usr/include/curses.h line 634
extern signed int idlok(struct _win_st *, _Bool);
// init_pair
// file /usr/include/curses.h line 641
extern signed int init_pair(signed short int, signed short int, signed short int);
// initscr
// file /usr/include/curses.h line 639
extern struct _win_st * initscr(void);
// int2bd
// file misc.c line 77
signed int int2bd(unsigned long int i, struct anonymous$28 *bd);
// intrflush
// file /usr/include/curses.h line 649
extern signed int intrflush(struct _win_st *, _Bool);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// item_index
// file /usr/include/menu.h line 209
extern signed int item_index(const struct tagITEM *);
// keypad
// file /usr/include/curses.h line 654
extern signed int keypad(struct _win_st *, _Bool);
// leaveok
// file /usr/include/curses.h line 656
extern signed int leaveok(struct _win_st *, _Bool);
// ll_check_got_features
// file ll.c line 535
unsigned char ll_check_got_features(struct device *dev);
// ll_check_got_name
// file ll.c line 519
unsigned char ll_check_got_name(struct device *dev);
// ll_check_got_oui
// file ll.c line 543
unsigned char ll_check_got_oui(struct device *dev);
// ll_check_got_sdp
// file ll.c line 551
unsigned char ll_check_got_sdp(struct device *dev);
// ll_check_got_version
// file ll.c line 527
unsigned char ll_check_got_version(struct device *dev);
// ll_copy_name
// file ll.c line 486
signed int ll_copy_name(struct device *td, char *name);
// ll_dev_count
// file ./ll.h line 126
unsigned long int ll_dev_count(void);
// ll_do_swap
// file ll.c line 586
void ll_do_swap(struct device *pdev, struct device *dev);
// ll_find_device
// file ./ll.h line 128
struct device * ll_find_device(unsigned long int did);
// ll_first
// file ./ll.h line 117
struct device * ll_first(void);
// ll_free
// file ./ll.h line 102
signed int ll_free(void);
// ll_get_last_update_time
// file ./ll.h line 127
signed int ll_get_last_update_time(unsigned long int did, signed long int *t);
// ll_init
// file ./ll.h line 101
signed int ll_init(void);
// ll_ischanged
// file ./ll.h line 111
signed int ll_ischanged(void);
// ll_lock_device
// file ll.c line 143
struct device * ll_lock_device(struct anonymous$28 *bdaddr);
// ll_lock_list
// file ./ll.h line 104
signed int ll_lock_list(void);
// ll_need_swap
// file ll.c line 599
signed int ll_need_swap(struct device *dev, signed int sort);
// ll_next
// file ./ll.h line 118
struct device * ll_next(struct device *curr);
// ll_print_dev_info
// file ./ll.h line 113
signed int ll_print_dev_info(unsigned long int did, struct cbuf *cb);
// ll_print_dev_line
// file ./ll.h line 112
signed int ll_print_dev_line(struct device *item, unsigned long int *id, char *s, signed int len);
// ll_print_item
// file ll.c line 218
signed int ll_print_item(struct device *item);
// ll_print_timestamp
// file ./ll.h line 114
signed int ll_print_timestamp(struct device *dev, struct cbuf *cb);
// ll_save_summary
// file ./ll.h line 130
signed int ll_save_summary(const char *filename);
// ll_sortlist
// file ./ll.h line 131
signed int ll_sortlist(signed int sort);
// ll_unlock_device
// file ll.c line 186
signed int ll_unlock_device(struct device *dev);
// ll_unlock_list
// file ./ll.h line 105
signed int ll_unlock_list(void);
// lmp_featurestostr
// file /usr/include/bluetooth/hci_lib.h line 171
char * lmp_featurestostr(unsigned char *, char *, signed int);
// lmp_vertostr
// file /usr/include/bluetooth/hci_lib.h line 166
char * lmp_vertostr(unsigned int);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// log_close
// file ./log.h line 33
signed int log_close(void);
// log_init
// file ./log.h line 32
signed int log_init(void);
// log_sum_close
// file ./log.h line 38
signed int log_sum_close(void);
// log_sum_open
// file ./log.h line 36
signed int log_sum_open(const char *filename);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// menu_driver
// file /usr/include/menu.h line 212
extern signed int menu_driver(struct tagMENU *, signed int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// new_field
// file /usr/include/form.h line 326
extern struct fieldnode * new_field(signed int, signed int, signed int, signed int, signed int, signed int);
// new_form
// file /usr/include/form.h line 370
extern struct formnode * new_form(struct fieldnode **);
// new_item
// file /usr/include/menu.h line 177
extern struct tagITEM * new_item(const char *, const char *);
// new_menu
// file /usr/include/menu.h line 179
extern struct tagMENU * new_menu(struct tagITEM **);
// newpad
// file /usr/include/curses.h line 712
extern struct _win_st * newpad(signed int, signed int);
// noecho
// file /usr/include/curses.h line 718
extern signed int noecho(void);
// nonl
// file /usr/include/curses.h line 719
extern signed int nonl(void);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// ouidb_close
// file ./oui.h line 34
signed int ouidb_close(void);
// ouidb_init
// file ./oui.h line 32
signed int ouidb_init(const char *filename);
// ouidb_query
// file oui.c line 167
char * ouidb_query(struct anonymous$28 *ba);
// pnoutrefresh
// file /usr/include/curses.h line 728
extern signed int pnoutrefresh(struct _win_st *, signed int, signed int, signed int, signed int, signed int, signed int);
// post_form
// file /usr/include/form.h line 397
extern signed int post_form(struct formnode *);
// post_menu
// file /usr/include/menu.h line 217
extern signed int post_menu(struct tagMENU *);
// print_access_protos
// file sdp.c line 446
void print_access_protos(void *value, void *userData);
// print_lang_attr
// file sdp.c line 318
void print_lang_attr(void *value, void *user);
// print_profile_desc
// file sdp.c line 452
void print_profile_desc(void *value, void *userData);
// print_service_class
// file sdp.c line 429
static void print_service_class(void *value, void *userData);
// print_service_desc
// file sdp.c line 337
static void print_service_desc(void *value, void *user);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$37 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$37 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$37 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$25 *, struct anonymous$25 *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous$23 *, signed int);
// regfree
// file /usr/include/regex.h line 574
extern void regfree(struct re_pattern_buffer *);
// scale_menu
// file /usr/include/menu.h line 218
extern signed int scale_menu(const struct tagMENU *, signed int *, signed int *);
// scan_bf_getcurr
// file scan.c line 753
signed int scan_bf_getcurr(struct anonymous$28 *bd);
// scan_bf_getnext
// file scan.c line 728
signed int scan_bf_getnext(struct anonymous$28 *bd);
// scan_bf_getpercentage
// file scan.c line 766
signed int scan_bf_getpercentage(void);
// scan_bf_init
// file ./scan.h line 36
signed int scan_bf_init(struct anonymous$28 *start, struct anonymous$28 *end);
// scan_inquiry
// file scan.c line 271
signed int scan_inquiry(struct hcicfg *hci);
// scan_probe_bf
// file scan.c line 483
signed int scan_probe_bf(struct hcicfg *hci);
// scan_reset_device
// file scan.c line 94
signed int scan_reset_device(signed int devid);
// scan_run
// file ./scan.h line 33
void * scan_run(void *arg);
// scan_sdp
// file scan.c line 173
signed int scan_sdp(struct hcicfg *hci, struct device *d, struct cbuf *sdpstr, struct search_context *context);
// screen_block_move
// file screen.c line 289
signed int screen_block_move(signed int ch);
// screen_chksize
// file screen.c line 523
signed int screen_chksize(void);
// screen_create
// file screen.c line 555
signed int screen_create(void);
// screen_destroy
// file screen.c line 581
void screen_destroy(void);
// screen_get_sort
// file screen.c line 1047
signed int screen_get_sort(void);
// screen_info_get_content
// file screen.c line 416
signed int screen_info_get_content(signed int width);
// screen_info_is_changed
// file screen.c line 431
signed int screen_info_is_changed(void);
// screen_info_print_title
// file screen.c line 445
void screen_info_print_title(void);
// screen_info_quit
// file screen.c line 347
signed int screen_info_quit(signed int ch);
// screen_init_bf
// file screen.c line 981
signed int screen_init_bf(void);
// screen_line_move
// file screen.c line 264
signed int screen_line_move(signed int ch);
// screen_log
// file screen.c line 190
signed int screen_log(char *fmt, ...);
// screen_log_redisplay
// file screen.c line 242
signed int screen_log_redisplay(void);
// screen_main_get_content
// file screen.c line 356
signed int screen_main_get_content(signed int width);
// screen_main_key_enter
// file screen.c line 332
signed int screen_main_key_enter(signed int ch);
// screen_main_print_title
// file screen.c line 441
void screen_main_print_title(void);
// screen_make_windows
// file screen.c line 1089
signed int screen_make_windows(void);
// screen_off
// file ./screen.h line 33
signed int screen_off(void);
// screen_on
// file ./screen.h line 32
signed int screen_on(void);
// screen_redraw
// file screen.c line 629
signed int screen_redraw(void);
// screen_run
// file ./screen.h line 34
signed int screen_run(void);
// screen_textbox
// file screen.c line 821
signed int screen_textbox(const char *label, const char *re, struct cbuf *cb);
// scrollok
// file /usr/include/curses.h line 748
extern signed int scrollok(struct _win_st *, _Bool);
// sdp_close
// file /usr/include/bluetooth/sdp_lib.h line 133
signed int sdp_close(struct anonymous$33 *);
// sdp_connect
// file /usr/include/bluetooth/sdp_lib.h line 132
struct anonymous$33 * sdp_connect(const struct anonymous$28 *, const struct anonymous$28 *, unsigned int);
// sdp_data_free
// file /usr/include/bluetooth/sdp_lib.h line 164
void sdp_data_free(struct sdp_data_struct *);
// sdp_data_get
// file /usr/include/bluetooth/sdp_lib.h line 165
struct sdp_data_struct * sdp_data_get(const struct anonymous$2 *, unsigned short int);
// sdp_format_classes
// file ./sdp.h line 33
signed int sdp_format_classes(struct device *p, char *buf, signed int sz, signed int len);
// sdp_get_access_protos
// file /usr/include/bluetooth/sdp_lib.h line 511
signed int sdp_get_access_protos(const struct anonymous$2 *, struct _sdp_list **);
// sdp_get_group_id
// file /usr/include/bluetooth/sdp_lib.h line 553
signed int sdp_get_group_id(const struct anonymous$2 *, struct anonymous$1 *);
// sdp_get_lang_attr
// file /usr/include/bluetooth/sdp_lib.h line 532
signed int sdp_get_lang_attr(const struct anonymous$2 *, struct _sdp_list **);
// sdp_get_profile_descs
// file /usr/include/bluetooth/sdp_lib.h line 541
signed int sdp_get_profile_descs(const struct anonymous$2 *, struct _sdp_list **);
// sdp_get_service_classes
// file /usr/include/bluetooth/sdp_lib.h line 215
static inline signed int sdp_get_service_classes(const struct anonymous$2 *rec, struct _sdp_list **seqp);
// sdp_get_uuidseq_attr
// file /usr/include/bluetooth/sdp_lib.h line 175
signed int sdp_get_uuidseq_attr(const struct anonymous$2 *, unsigned short int, struct _sdp_list **);
// sdp_list_append
// file /usr/include/bluetooth/sdp_lib.h line 45
struct _sdp_list * sdp_list_append(struct _sdp_list *, void *);
// sdp_list_foreach
// file /usr/include/bluetooth/sdp_lib.h line 66
static inline void sdp_list_foreach(struct _sdp_list *list, void (*f)(void *, void *), void *u);
// sdp_list_foreach::f$object
// 
void f$object(void *, void *);
// sdp_list_free
// file /usr/include/bluetooth/sdp_lib.h line 48
void sdp_list_free(struct _sdp_list *, void (*)(void *));
// sdp_profile_uuid2strn
// file /usr/include/bluetooth/sdp_lib.h line 494
signed int sdp_profile_uuid2strn(const struct anonymous$1 *, char *, unsigned long int);
// sdp_proto_uuid2strn
// file /usr/include/bluetooth/sdp_lib.h line 492
signed int sdp_proto_uuid2strn(const struct anonymous$1 *, char *, unsigned long int);
// sdp_record_free
// file /usr/include/bluetooth/sdp_lib.h line 435
void sdp_record_free(struct anonymous$2 *);
// sdp_service_search_attr_req
// file /usr/include/bluetooth/sdp_lib.h line 429
signed int sdp_service_search_attr_req(struct anonymous$33 *, const struct _sdp_list *, enum anonymous$34, const struct _sdp_list *, struct _sdp_list **);
// sdp_sprint_service_attr
// file sdp.c line 477
signed int sdp_sprint_service_attr(struct cbuf *str, struct anonymous$2 *rec);
// sdp_svclass_uuid2strn
// file /usr/include/bluetooth/sdp_lib.h line 493
signed int sdp_svclass_uuid2strn(const struct anonymous$1 *, char *, unsigned long int);
// sdp_uuid16_create
// file /usr/include/bluetooth/sdp_lib.h line 472
struct anonymous$1 * sdp_uuid16_create(struct anonymous$1 *, unsigned short int);
// sdp_uuid2strn
// file /usr/include/bluetooth/sdp_lib.h line 491
signed int sdp_uuid2strn(const struct anonymous$1 *, char *, unsigned long int);
// sdp_uuid_to_proto
// file /usr/include/bluetooth/sdp_lib.h line 482
signed int sdp_uuid_to_proto(struct anonymous$1 *);
// set_current_item
// file /usr/include/menu.h line 219
extern signed int set_current_item(struct tagMENU *, struct tagITEM *);
// set_field_back
// file /usr/include/form.h line 340
extern signed int set_field_back(struct fieldnode *, unsigned long int);
// set_field_type
// file /usr/include/form.h line 335
extern signed int set_field_type(struct fieldnode *, struct typenode *, ...);
// set_form_sub
// file /usr/include/form.h line 387
extern signed int set_form_sub(struct formnode *, struct _win_st *);
// set_form_win
// file /usr/include/form.h line 386
extern signed int set_form_win(struct formnode *, struct _win_st *);
// set_menu_format
// file /usr/include/menu.h line 227
extern signed int set_menu_format(struct tagMENU *, signed int, signed int);
// set_menu_mark
// file /usr/include/menu.h line 231
extern signed int set_menu_mark(struct tagMENU *, const char *);
// set_menu_sub
// file /usr/include/menu.h line 235
extern signed int set_menu_sub(struct tagMENU *, struct _win_st *);
// set_menu_win
// file /usr/include/menu.h line 238
extern signed int set_menu_win(struct tagMENU *, struct _win_st *);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigdelset
// file /usr/include/signal.h line 224
extern signed int sigdelset(struct anonymous$25 *, signed int);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous$25 *);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous$25 *, struct anonymous$25 *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// start_color
// file /usr/include/curses.h line 771
extern signed int start_color(void);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// store_appendfile
// file store.c line 197
signed int store_appendfile(char *fn, unsigned long int fn_len, struct cbuf *cb);
// store_conv_filename
// file store.c line 235
void store_conv_filename(char *tmp);
// store_device
// file store.c line 244
signed int store_device(struct device *dev);
// store_mkdir_from_filename
// file store.c line 141
signed int store_mkdir_from_filename(char *d, unsigned long int d_len, struct stat *sbuf);
// store_mkdir_recursive
// file store.c line 87
signed int store_mkdir_recursive(const char *d, struct stat *sbuf);
// store_timestamp
// file store.c line 325
signed int store_timestamp(struct device *dev);
// store_writefile
// file store.c line 158
signed int store_writefile(char *fn, unsigned long int fn_len, struct cbuf *cb);
// str2ba
// file /usr/include/bluetooth/bluetooth.h line 327
signed int str2ba(const char *, struct anonymous$28 *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strlen_minus_spaces
// file screen.c line 810
unsigned long int strlen_minus_spaces(const char *s);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// summary
// file ./log.h line 37
signed int summary(const char *fmt, ...);
// threader_reap
// file threader.c line 146
signed int threader_reap(void);
// threader_running
// file threader.c line 192
signed int threader_running(void);
// threader_running_desc
// file threader.c line 196
const char * threader_running_desc(enum threader_scan_types what);
// threader_start
// file threader.c line 98
signed int threader_start(enum threader_scan_types what);
// threader_stop
// file threader.c line 179
signed int threader_stop(void);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// unpost_form
// file /usr/include/form.h line 398
extern signed int unpost_form(struct formnode *);
// unpost_menu
// file /usr/include/menu.h line 241
extern signed int unpost_menu(struct tagMENU *);
// usage
// file main.c line 105
void usage(char *pname);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waddch
// file /usr/include/curses.h line 792
extern signed int waddch(struct _win_st *, const unsigned long int);
// waddnstr
// file /usr/include/curses.h line 795
extern signed int waddnstr(struct _win_st *, const char *, signed int);
// wbkgd
// file /usr/include/curses.h line 804
extern signed int wbkgd(struct _win_st *, unsigned long int);
// wborder
// file /usr/include/curses.h line 806
extern signed int wborder(struct _win_st *, unsigned long int, unsigned long int, unsigned long int, unsigned long int, unsigned long int, unsigned long int, unsigned long int, unsigned long int);
// werase
// file /usr/include/curses.h line 816
extern signed int werase(struct _win_st *);
// wgetch
// file /usr/include/curses.h line 817
extern signed int wgetch(struct _win_st *);
// whline
// file /usr/include/curses.h line 820
extern signed int whline(struct _win_st *, unsigned long int, signed int);
// wmove
// file /usr/include/curses.h line 831
extern signed int wmove(struct _win_st *, signed int, signed int);
// wnoutrefresh
// file /usr/include/curses.h line 832
extern signed int wnoutrefresh(struct _win_st *);
// wprintw
// file /usr/include/curses.h line 833
extern signed int wprintw(struct _win_st *, const char *, ...);
// wrefresh
// file /usr/include/curses.h line 836
extern signed int wrefresh(struct _win_st *);
// wresize
// file /usr/include/curses.h line 911
extern signed int wresize(struct _win_st *, signed int, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// wscrl
// file /usr/include/curses.h line 839
extern signed int wscrl(struct _win_st *, signed int);
// wtouchln
// file /usr/include/curses.h line 846
extern signed int wtouchln(struct _win_st *, signed int, signed int, signed int);
// xmlCtxtReadFile
// file /usr/include/libxml2/libxml/parser.h line 1162
struct _xmlDoc * xmlCtxtReadFile(struct _xmlParserCtxt *, const char *, const char *, signed int);
// xmlDocGetRootElement
// file /usr/include/libxml2/libxml/tree.h line 920
struct _xmlNode * xmlDocGetRootElement(const struct _xmlDoc *);
// xmlFree$object
// 
void xmlFree$object(void *);
// xmlFreeDoc
// file /usr/include/libxml2/libxml/tree.h line 782
void xmlFreeDoc(struct _xmlDoc *);
// xmlFreeParserCtxt
// file /usr/include/libxml2/libxml/parser.h line 983
void xmlFreeParserCtxt(struct _xmlParserCtxt *);
// xmlGetProp
// file /usr/include/libxml2/libxml/tree.h line 1029
unsigned char * xmlGetProp(const struct _xmlNode *, const unsigned char *);
// xmlNewParserCtxt
// file /usr/include/libxml2/libxml/parser.h line 977
struct _xmlParserCtxt * xmlNewParserCtxt(void);
// xmlSetGenericErrorFunc
// file /usr/include/libxml2/libxml/xmlerror.h line 863
void xmlSetGenericErrorFunc(void *, void (*)(void *, const char *, ...));
// xmlSetStructuredErrorFunc
// file /usr/include/libxml2/libxml/xmlerror.h line 869
void xmlSetStructuredErrorFunc(void *, void (*)(void *, struct _xmlError *));
// xmlStrncmp
// file /usr/include/libxml2/libxml/xmlstring.h line 67
signed int xmlStrncmp(const unsigned char *, const unsigned char *, signed int);

struct anonymous$19
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$17
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous
{
  // str
  const char *str;
  // length
  unsigned short int length;
};

struct anonymous$25
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$4
{
  // data
  unsigned char data[16l];
};

struct anonymous$28
{
  // b
  unsigned char b[6l];
} __attribute__ ((__packed__));

struct anonymous$0
{
  // type
  enum screen_types type;
  // title
  void (*title)(void);
  // changed
  signed int (*changed)(void);
  // get_content
  signed int (*get_content)(signed int);
  // keymap
  struct screen_keys *keymap;
};

struct anonymous$6
{
  // what
  enum threader_scan_types what;
  // desc
  const char *desc;
  // func
  void * (*func)(void *);
};

struct anonymous$38
{
  // pmin
  signed short int pmin;
  // pmax
  signed short int pmax;
  // smin
  signed short int smin;
  // smax
  signed short int smax;
};

struct anonymous$32
{
  // num_items
  signed int num_items;
  // ids
  unsigned long int *ids;
  // selected
  unsigned long int selected;
  // labels
  char **labels;
  // items
  struct tagITEM **items;
  // m
  struct tagMENU *m;
  // sw
  struct _win_st *sw;
};

struct anonymous$23
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous$10
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$15
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$14
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$13
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$18
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$20
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$10 _kill;
  // _timer
  struct anonymous$13 _timer;
  // _rt
  struct anonymous$14 _rt;
  // _sigchld
  struct anonymous$15 _sigchld;
  // _sigfault
  struct anonymous$17 _sigfault;
  // _sigpoll
  struct anonymous$18 _sigpoll;
  // _sigsys
  struct anonymous$19 _sigsys;
};

struct anonymous$22
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$20 _sifields;
};

struct anonymous$33
{
  // sock
  signed int sock;
  // state
  signed int state;
  // local
  signed int local;
  // flags
  signed int flags;
  // tid
  unsigned short int tid;
  // priv
  void *priv;
};

struct anonymous$36
{
  // bdaddr
  struct anonymous$28 bdaddr;
  // pscan_rep_mode
  unsigned char pscan_rep_mode;
  // pscan_period_mode
  unsigned char pscan_period_mode;
  // pscan_mode
  unsigned char pscan_mode;
  // dev_class
  unsigned char dev_class[3l];
  // clock_offset
  unsigned short int clock_offset;
} __attribute__ ((__packed__));

union anonymous$5
{
  // uuid16
  unsigned short int uuid16;
  // uuid32
  unsigned int uuid32;
  // uuid128
  struct anonymous$4 uuid128;
};

struct anonymous$1
{
  // type
  unsigned char type;
  // value
  union anonymous$5 value;
};

struct anonymous$8
{
  // uuid
  struct anonymous$1 uuid;
  // version
  unsigned short int version;
};

struct anonymous$7
{
  // code_ISO639
  unsigned short int code_ISO639;
  // encoding
  unsigned short int encoding;
  // base_offset
  unsigned short int base_offset;
};

struct anonymous$2
{
  // handle
  unsigned int handle;
  // pattern
  struct _sdp_list *pattern;
  // attrlist
  struct _sdp_list *attrlist;
  // svclass
  struct anonymous$1 svclass;
};

struct anonymous$29
{
  // attr
  unsigned long int attr;
  // chars
  signed int chars[5l];
};

struct cbuf
{
  // buf
  char *buf;
  // sz
  unsigned long int sz;
  // len
  unsigned long int len;
};

struct anonymous$31
{
  // sx
  unsigned long int sx;
  // sy
  unsigned long int sy;
  // mcols
  unsigned long int mcols;
  // mrows
  unsigned long int mrows;
  // text
  struct cbuf text;
  // updated
  signed long int updated;
};

struct anonymous$30
{
  // x
  unsigned long int x;
  // y
  unsigned long int y;
  // rows
  unsigned long int rows;
  // cols
  unsigned long int cols;
  // w
  struct _win_st *w;
};

union anonymous$24
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$22 *, void *);
};

union anonymous$3
{
  // int8
  signed char int8;
  // int16
  signed short int int16;
  // int32
  signed int int32;
  // int64
  signed long int int64;
  // int128
  struct anonymous$4 int128;
  // uint8
  unsigned char uint8;
  // uint16
  unsigned short int uint16;
  // uint32
  unsigned int uint32;
  // uint64
  unsigned long int uint64;
  // uint128
  struct anonymous$4 uint128;
  // uuid
  struct anonymous$1 uuid;
  // str
  char *str;
  // dataseq
  struct sdp_data_struct *dataseq;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$37
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _sdp_list
{
  // next
  struct _sdp_list *next;
  // data
  void *data;
};

struct _uconv_t
{
  // uconv
  struct UConverter *uconv;
  // utf8
  struct UConverter *utf8;
};

struct pdat
{
  // _pad_y
  signed short int _pad_y;
  // _pad_x
  signed short int _pad_x;
  // _pad_top
  signed short int _pad_top;
  // _pad_left
  signed short int _pad_left;
  // _pad_bottom
  signed short int _pad_bottom;
  // _pad_right
  signed short int _pad_right;
};

struct _win_st
{
  // _cury
  signed short int _cury;
  // _curx
  signed short int _curx;
  // _maxy
  signed short int _maxy;
  // _maxx
  signed short int _maxx;
  // _begy
  signed short int _begy;
  // _begx
  signed short int _begx;
  // _flags
  signed short int _flags;
  // _attrs
  unsigned long int _attrs;
  // _bkgd
  unsigned long int _bkgd;
  // _notimeout
  _Bool _notimeout;
  // _clear
  _Bool _clear;
  // _leaveok
  _Bool _leaveok;
  // _scroll
  _Bool _scroll;
  // _idlok
  _Bool _idlok;
  // _idcok
  _Bool _idcok;
  // _immed
  _Bool _immed;
  // _sync
  _Bool _sync;
  // _use_keypad
  _Bool _use_keypad;
  // _delay
  signed int _delay;
  // _line
  struct ldat *_line;
  // _regtop
  signed short int _regtop;
  // _regbottom
  signed short int _regbottom;
  // _parx
  signed int _parx;
  // _pary
  signed int _pary;
  // _parent
  struct _win_st *_parent;
  // _pad
  struct pdat _pad;
  // _yoffset
  signed short int _yoffset;
  // _bkgrnd
  struct anonymous$29 _bkgrnd;
};

struct _xmlAttr
{
  // _private
  void *_private;
  // type
  enum anonymous$9 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlAttr *next;
  // prev
  struct _xmlAttr *prev;
  // doc
  struct _xmlDoc *doc;
  // ns
  struct _xmlNs *ns;
  // atype
  enum anonymous$11 atype;
  // psvi
  void *psvi;
};

struct _xmlCharEncodingHandler
{
  // name
  char *name;
  // input
  signed int (*input)(unsigned char *, signed int *, const unsigned char *, signed int *);
  // output
  signed int (*output)(unsigned char *, signed int *, const unsigned char *, signed int *);
  // iconv_in
  void *iconv_in;
  // iconv_out
  void *iconv_out;
  // uconv_in
  struct _uconv_t *uconv_in;
  // uconv_out
  struct _uconv_t *uconv_out;
};

struct _xmlDoc
{
  // _private
  void *_private;
  // type
  enum anonymous$9 type;
  // name
  char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // compression
  signed int compression;
  // standalone
  signed int standalone;
  // intSubset
  struct _xmlDtd *intSubset;
  // extSubset
  struct _xmlDtd *extSubset;
  // oldNs
  struct _xmlNs *oldNs;
  // version
  const unsigned char *version;
  // encoding
  const unsigned char *encoding;
  // ids
  void *ids;
  // refs
  void *refs;
  // URL
  const unsigned char *URL;
  // charset
  signed int charset;
  // dict
  struct _xmlDict *dict;
  // psvi
  void *psvi;
  // parseFlags
  signed int parseFlags;
  // properties
  signed int properties;
};

struct _xmlDtd
{
  // _private
  void *_private;
  // type
  enum anonymous$9 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlDoc *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // notations
  void *notations;
  // elements
  void *elements;
  // attributes
  void *attributes;
  // entities
  void *entities;
  // ExternalID
  const unsigned char *ExternalID;
  // SystemID
  const unsigned char *SystemID;
  // pentities
  void *pentities;
};

struct _xmlElementContent
{
  // type
  enum anonymous$26 type;
  // ocur
  enum anonymous$27 ocur;
  // name
  const unsigned char *name;
  // c1
  struct _xmlElementContent *c1;
  // c2
  struct _xmlElementContent *c2;
  // parent
  struct _xmlElementContent *parent;
  // prefix
  const unsigned char *prefix;
};

struct _xmlEntity
{
  // _private
  void *_private;
  // type
  enum anonymous$9 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlDtd *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // orig
  unsigned char *orig;
  // content
  unsigned char *content;
  // length
  signed int length;
  // etype
  enum anonymous$35 etype;
  // ExternalID
  const unsigned char *ExternalID;
  // SystemID
  const unsigned char *SystemID;
  // nexte
  struct _xmlEntity *nexte;
  // URI
  const unsigned char *URI;
  // owner
  signed int owner;
  // checked
  signed int checked;
};

struct _xmlEnumeration
{
  // next
  struct _xmlEnumeration *next;
  // name
  const unsigned char *name;
};

struct _xmlError
{
  // domain
  signed int domain;
  // code
  signed int code;
  // message
  char *message;
  // level
  enum anonymous$12 level;
  // file
  char *file;
  // line
  signed int line;
  // str1
  char *str1;
  // str2
  char *str2;
  // str3
  char *str3;
  // int1
  signed int int1;
  // int2
  signed int int2;
  // ctxt
  void *ctxt;
  // node
  void *node;
};

struct _xmlNode
{
  // _private
  void *_private;
  // type
  enum anonymous$9 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // ns
  struct _xmlNs *ns;
  // content
  unsigned char *content;
  // properties
  struct _xmlAttr *properties;
  // nsDef
  struct _xmlNs *nsDef;
  // psvi
  void *psvi;
  // line
  unsigned short int line;
  // extra
  unsigned short int extra;
};

struct _xmlNs
{
  // next
  struct _xmlNs *next;
  // type
  enum anonymous$9 type;
  // href
  const unsigned char *href;
  // prefix
  const unsigned char *prefix;
  // _private
  void *_private;
  // context
  struct _xmlDoc *context;
};

struct _xmlParserNodeInfoSeq
{
  // maximum
  unsigned long int maximum;
  // length
  unsigned long int length;
  // buffer
  struct _xmlParserNodeInfo *buffer;
};

struct _xmlValidCtxt
{
  // userData
  void *userData;
  // error
  void (*error)(void *, const char *, ...);
  // warning
  void (*warning)(void *, const char *, ...);
  // node
  struct _xmlNode *node;
  // nodeNr
  signed int nodeNr;
  // nodeMax
  signed int nodeMax;
  // nodeTab
  struct _xmlNode **nodeTab;
  // finishDtd
  unsigned int finishDtd;
  // doc
  struct _xmlDoc *doc;
  // valid
  signed int valid;
  // vstate
  struct _xmlValidState *vstate;
  // vstateNr
  signed int vstateNr;
  // vstateMax
  signed int vstateMax;
  // vstateTab
  struct _xmlValidState *vstateTab;
  // am
  struct _xmlAutomata *am;
  // state
  struct _xmlAutomataState *state;
};

struct _xmlParserCtxt
{
  // sax
  struct _xmlSAXHandler *sax;
  // userData
  void *userData;
  // myDoc
  struct _xmlDoc *myDoc;
  // wellFormed
  signed int wellFormed;
  // replaceEntities
  signed int replaceEntities;
  // version
  const unsigned char *version;
  // encoding
  const unsigned char *encoding;
  // standalone
  signed int standalone;
  // html
  signed int html;
  // input
  struct _xmlParserInput *input;
  // inputNr
  signed int inputNr;
  // inputMax
  signed int inputMax;
  // inputTab
  struct _xmlParserInput **inputTab;
  // node
  struct _xmlNode *node;
  // nodeNr
  signed int nodeNr;
  // nodeMax
  signed int nodeMax;
  // nodeTab
  struct _xmlNode **nodeTab;
  // record_info
  signed int record_info;
  // node_seq
  struct _xmlParserNodeInfoSeq node_seq;
  // errNo
  signed int errNo;
  // hasExternalSubset
  signed int hasExternalSubset;
  // hasPErefs
  signed int hasPErefs;
  // external
  signed int external;
  // valid
  signed int valid;
  // validate
  signed int validate;
  // vctxt
  struct _xmlValidCtxt vctxt;
  // instate
  enum anonymous$16 instate;
  // token
  signed int token;
  // directory
  char *directory;
  // name
  const unsigned char *name;
  // nameNr
  signed int nameNr;
  // nameMax
  signed int nameMax;
  // nameTab
  const unsigned char **nameTab;
  // nbChars
  signed long int nbChars;
  // checkIndex
  signed long int checkIndex;
  // keepBlanks
  signed int keepBlanks;
  // disableSAX
  signed int disableSAX;
  // inSubset
  signed int inSubset;
  // intSubName
  const unsigned char *intSubName;
  // extSubURI
  unsigned char *extSubURI;
  // extSubSystem
  unsigned char *extSubSystem;
  // space
  signed int *space;
  // spaceNr
  signed int spaceNr;
  // spaceMax
  signed int spaceMax;
  // spaceTab
  signed int *spaceTab;
  // depth
  signed int depth;
  // entity
  struct _xmlParserInput *entity;
  // charset
  signed int charset;
  // nodelen
  signed int nodelen;
  // nodemem
  signed int nodemem;
  // pedantic
  signed int pedantic;
  // _private
  void *_private;
  // loadsubset
  signed int loadsubset;
  // linenumbers
  signed int linenumbers;
  // catalogs
  void *catalogs;
  // recovery
  signed int recovery;
  // progressive
  signed int progressive;
  // dict
  struct _xmlDict *dict;
  // atts
  const unsigned char **atts;
  // maxatts
  signed int maxatts;
  // docdict
  signed int docdict;
  // str_xml
  const unsigned char *str_xml;
  // str_xmlns
  const unsigned char *str_xmlns;
  // str_xml_ns
  const unsigned char *str_xml_ns;
  // sax2
  signed int sax2;
  // nsNr
  signed int nsNr;
  // nsMax
  signed int nsMax;
  // nsTab
  const unsigned char **nsTab;
  // attallocs
  signed int *attallocs;
  // pushTab
  void **pushTab;
  // attsDefault
  struct _xmlHashTable *attsDefault;
  // attsSpecial
  struct _xmlHashTable *attsSpecial;
  // nsWellFormed
  signed int nsWellFormed;
  // options
  signed int options;
  // dictNames
  signed int dictNames;
  // freeElemsNr
  signed int freeElemsNr;
  // freeElems
  struct _xmlNode *freeElems;
  // freeAttrsNr
  signed int freeAttrsNr;
  // freeAttrs
  struct _xmlAttr *freeAttrs;
  // lastError
  struct _xmlError lastError;
  // parseMode
  enum anonymous$21 parseMode;
  // nbentities
  unsigned long int nbentities;
  // sizeentities
  unsigned long int sizeentities;
  // nodeInfo
  struct _xmlParserNodeInfo *nodeInfo;
  // nodeInfoNr
  signed int nodeInfoNr;
  // nodeInfoMax
  signed int nodeInfoMax;
  // nodeInfoTab
  struct _xmlParserNodeInfo *nodeInfoTab;
  // input_id
  signed int input_id;
  // sizeentcopy
  unsigned long int sizeentcopy;
};

struct _xmlParserInput
{
  // buf
  struct _xmlParserInputBuffer *buf;
  // filename
  const char *filename;
  // directory
  const char *directory;
  // base
  const unsigned char *base;
  // cur
  const unsigned char *cur;
  // end
  const unsigned char *end;
  // length
  signed int length;
  // line
  signed int line;
  // col
  signed int col;
  // consumed
  unsigned long int consumed;
  // free
  void (*free)(unsigned char *);
  // encoding
  const unsigned char *encoding;
  // version
  const unsigned char *version;
  // standalone
  signed int standalone;
  // id
  signed int id;
};

struct _xmlParserInputBuffer
{
  // context
  void *context;
  // readcallback
  signed int (*readcallback)(void *, char *, signed int);
  // closecallback
  signed int (*closecallback)(void *);
  // encoder
  struct _xmlCharEncodingHandler *encoder;
  // buffer
  struct _xmlBuf *buffer;
  // raw
  struct _xmlBuf *raw;
  // compressed
  signed int compressed;
  // error
  signed int error;
  // rawconsumed
  unsigned long int rawconsumed;
};

struct _xmlParserNodeInfo
{
  // node
  struct _xmlNode *node;
  // begin_pos
  unsigned long int begin_pos;
  // begin_line
  unsigned long int begin_line;
  // end_pos
  unsigned long int end_pos;
  // end_line
  unsigned long int end_line;
};

struct _xmlSAXHandler
{
  // internalSubset
  void (*internalSubset)(void *, const unsigned char *, const unsigned char *, const unsigned char *);
  // isStandalone
  signed int (*isStandalone)(void *);
  // hasInternalSubset
  signed int (*hasInternalSubset)(void *);
  // hasExternalSubset
  signed int (*hasExternalSubset)(void *);
  // resolveEntity
  struct _xmlParserInput * (*resolveEntity)(void *, const unsigned char *, const unsigned char *);
  // getEntity
  struct _xmlEntity * (*getEntity)(void *, const unsigned char *);
  // entityDecl
  void (*entityDecl)(void *, const unsigned char *, signed int, const unsigned char *, const unsigned char *, unsigned char *);
  // notationDecl
  void (*notationDecl)(void *, const unsigned char *, const unsigned char *, const unsigned char *);
  // attributeDecl
  void (*attributeDecl)(void *, const unsigned char *, const unsigned char *, signed int, signed int, const unsigned char *, struct _xmlEnumeration *);
  // elementDecl
  void (*elementDecl)(void *, const unsigned char *, signed int, struct _xmlElementContent *);
  // unparsedEntityDecl
  void (*unparsedEntityDecl)(void *, const unsigned char *, const unsigned char *, const unsigned char *, const unsigned char *);
  // setDocumentLocator
  void (*setDocumentLocator)(void *, struct _xmlSAXLocator *);
  // startDocument
  void (*startDocument)(void *);
  // endDocument
  void (*endDocument)(void *);
  // startElement
  void (*startElement)(void *, const unsigned char *, const unsigned char **);
  // endElement
  void (*endElement)(void *, const unsigned char *);
  // reference
  void (*reference)(void *, const unsigned char *);
  // characters
  void (*characters)(void *, const unsigned char *, signed int);
  // ignorableWhitespace
  void (*ignorableWhitespace)(void *, const unsigned char *, signed int);
  // processingInstruction
  void (*processingInstruction)(void *, const unsigned char *, const unsigned char *);
  // comment
  void (*comment)(void *, const unsigned char *);
  // warning
  void (*warning)(void *, const char *, ...);
  // error
  void (*error)(void *, const char *, ...);
  // fatalError
  void (*fatalError)(void *, const char *, ...);
  // getParameterEntity
  struct _xmlEntity * (*getParameterEntity)(void *, const unsigned char *);
  // cdataBlock
  void (*cdataBlock)(void *, const unsigned char *, signed int);
  // externalSubset
  void (*externalSubset)(void *, const unsigned char *, const unsigned char *, const unsigned char *);
  // initialized
  unsigned int initialized;
  // _private
  void *_private;
  // startElementNs
  void (*startElementNs)(void *, const unsigned char *, const unsigned char *, const unsigned char *, signed int, const unsigned char **, signed int, signed int, const unsigned char **);
  // endElementNs
  void (*endElementNs)(void *, const unsigned char *, const unsigned char *, const unsigned char *);
  // serror
  void (*serror)(void *, struct _xmlError *);
};

struct _xmlSAXLocator
{
  // getPublicId
  const unsigned char * (*getPublicId)(void *);
  // getSystemId
  const unsigned char * (*getSystemId)(void *);
  // getLineNumber
  signed int (*getLineNumber)(void *);
  // getColumnNumber
  signed int (*getColumnNumber)(void *);
};

struct classes
{
  // class_id
  unsigned int class_id;
  // sub_major_mask
  unsigned int sub_major_mask;
  // sub_minor_mask
  unsigned int sub_minor_mask;
  // type
  unsigned char type;
  // sub_major
  struct sub_classes *sub_major;
  // sub_minor
  struct sub_classes *sub_minor;
  // class_name
  char *class_name;
};

struct hci_version
{
  // manufacturer
  unsigned short int manufacturer;
  // hci_ver
  unsigned char hci_ver;
  // hci_rev
  unsigned short int hci_rev;
  // lmp_ver
  unsigned char lmp_ver;
  // lmp_subver
  unsigned short int lmp_subver;
};

struct device
{
  // next
  struct device *next;
  // locked
  unsigned char locked;
  // locked_by
  unsigned long int locked_by;
  // updated
  unsigned char updated;
  // bdaddr
  struct anonymous$28 bdaddr;
  // clk_off
  unsigned short int clk_off;
  // got_class
  unsigned char got_class;
  // class
  unsigned int class;
  // got_name
  unsigned char got_name;
  // name
  char *name;
  // got_oui
  unsigned char got_oui;
  // oui
  const char *oui;
  // version
  struct hci_version version;
  // got_version
  unsigned char got_version;
  // features
  unsigned char features[8l];
  // got_features
  unsigned char got_features;
  // rssi
  signed char rssi;
  // rssi_status
  unsigned char rssi_status;
  // lq
  unsigned char lq;
  // lq_status
  unsigned char lq_status;
  // txpwr_status
  unsigned char txpwr_status;
  // txpwr_type
  unsigned char txpwr_type;
  // txpwr_level
  signed char txpwr_level;
  // sdp
  char *sdp;
  // bd_scan
  struct anonymous$28 bd_scan;
  // scan_count
  unsigned int scan_count;
  // last_scanned
  signed long int last_scanned;
  // first_scanned
  signed long int first_scanned;
};

struct fieldnode
{
  // status
  unsigned short int status;
  // rows
  signed short int rows;
  // cols
  signed short int cols;
  // frow
  signed short int frow;
  // fcol
  signed short int fcol;
  // drows
  signed int drows;
  // dcols
  signed int dcols;
  // maxgrow
  signed int maxgrow;
  // nrow
  signed int nrow;
  // nbuf
  signed short int nbuf;
  // just
  signed short int just;
  // page
  signed short int page;
  // index
  signed short int index;
  // pad
  signed int pad;
  // fore
  unsigned long int fore;
  // back
  unsigned long int back;
  // opts
  signed int opts;
  // snext
  struct fieldnode *snext;
  // sprev
  struct fieldnode *sprev;
  // link
  struct fieldnode *link;
  // form
  struct formnode *form;
  // type
  struct typenode *type;
  // arg
  void *arg;
  // buf
  void **buf;
  // usrptr
  void *usrptr;
};

struct formnode
{
  // status
  unsigned short int status;
  // rows
  signed short int rows;
  // cols
  signed short int cols;
  // currow
  signed int currow;
  // curcol
  signed int curcol;
  // toprow
  signed int toprow;
  // begincol
  signed int begincol;
  // maxfield
  signed short int maxfield;
  // maxpage
  signed short int maxpage;
  // curpage
  signed short int curpage;
  // opts
  signed int opts;
  // win
  struct _win_st *win;
  // sub
  struct _win_st *sub;
  // w
  struct _win_st *w;
  // field
  struct fieldnode **field;
  // current
  struct fieldnode *current;
  // page
  struct anonymous$38 *page;
  // usrptr
  void *usrptr;
  // forminit
  void (*forminit)(struct formnode *);
  // formterm
  void (*formterm)(struct formnode *);
  // fieldinit
  void (*fieldinit)(struct formnode *);
  // fieldterm
  void (*fieldterm)(struct formnode *);
};

struct hci_conn_info
{
  // handle
  unsigned short int handle;
  // bdaddr
  struct anonymous$28 bdaddr;
  // type
  unsigned char type;
  // out
  unsigned char out;
  // state
  unsigned short int state;
  // link_mode
  unsigned int link_mode;
};

struct hci_conn_list_req
{
  // dev_id
  unsigned short int dev_id;
  // conn_num
  unsigned short int conn_num;
  // conn_info
  struct hci_conn_info conn_info[0l];
};

struct hci_dev_stats
{
  // err_rx
  unsigned int err_rx;
  // err_tx
  unsigned int err_tx;
  // cmd_tx
  unsigned int cmd_tx;
  // evt_rx
  unsigned int evt_rx;
  // acl_tx
  unsigned int acl_tx;
  // acl_rx
  unsigned int acl_rx;
  // sco_tx
  unsigned int sco_tx;
  // sco_rx
  unsigned int sco_rx;
  // byte_rx
  unsigned int byte_rx;
  // byte_tx
  unsigned int byte_tx;
};

struct hci_dev_info
{
  // dev_id
  unsigned short int dev_id;
  // name
  char name[8l];
  // bdaddr
  struct anonymous$28 bdaddr;
  // flags
  unsigned int flags;
  // type
  unsigned char type;
  // features
  unsigned char features[8l];
  // pkt_type
  unsigned int pkt_type;
  // link_policy
  unsigned int link_policy;
  // link_mode
  unsigned int link_mode;
  // acl_mtu
  unsigned short int acl_mtu;
  // acl_pkts
  unsigned short int acl_pkts;
  // sco_mtu
  unsigned short int sco_mtu;
  // sco_pkts
  unsigned short int sco_pkts;
  // stat
  struct hci_dev_stats stat;
};

struct hci_dev_req
{
  // dev_id
  unsigned short int dev_id;
  // dev_opt
  unsigned int dev_opt;
};

struct hci_dev_list_req
{
  // dev_num
  unsigned short int dev_num;
  // dev_req
  struct hci_dev_req dev_req[0l];
};

struct hcicfg
{
  // id
  signed int id;
  // bdaddr
  struct anonymous$28 bdaddr;
  // enabled
  char enabled;
  // tid
  unsigned long int tid;
  // died
  unsigned char died;
  // next
  struct hcicfg *next;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct oui
{
  // id
  unsigned int id;
  // name
  char *name;
  // next
  struct oui *next;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rangedef
{
  // sf
  unsigned char sf;
  // start
  unsigned long int start;
  // end
  unsigned long int end;
  // vulns
  char *vulns;
};

struct re_pattern_buffer
{
  // buffer
  unsigned char *buffer;
  // allocated
  unsigned long int allocated;
  // used
  unsigned long int used;
  // syntax
  unsigned long int syntax;
  // fastmap
  char *fastmap;
  // translate
  unsigned char *translate;
  // re_nsub
  unsigned long int re_nsub;
  // can_be_null
  unsigned int can_be_null : 1;
  // regs_allocated
  unsigned int regs_allocated : 2;
  // fastmap_accurate
  unsigned int fastmap_accurate : 1;
  // no_sub
  unsigned int no_sub : 1;
  // not_bol
  unsigned int not_bol : 1;
  // not_eol
  unsigned int not_eol : 1;
  // newline_anchor
  unsigned int newline_anchor : 1;
};

struct screen_keys
{
  // key
  signed int key;
  // func
  signed int (*func)(signed int);
};

struct sdp_data_struct
{
  // dtd
  unsigned char dtd;
  // attrId
  unsigned short int attrId;
  // val
  union anonymous$3 val;
  // next
  struct sdp_data_struct *next;
  // unitSize
  signed int unitSize;
};

struct search_context
{
  // svc
  char *svc;
  // group
  struct anonymous$1 group;
  // tree
  signed int tree;
  // handle
  unsigned int handle;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$24 __sigaction_handler;
  // sa_mask
  struct anonymous$25 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct sub_classes
{
  // class_id
  unsigned int class_id;
  // class_name
  char *class_name;
};

struct tagITEM
{
  // name
  struct anonymous name;
  // description
  struct anonymous description;
  // imenu
  struct tagMENU *imenu;
  // userptr
  void *userptr;
  // opt
  signed int opt;
  // index
  signed short int index;
  // y
  signed short int y;
  // x
  signed short int x;
  // value
  _Bool value;
  // left
  struct tagITEM *left;
  // right
  struct tagITEM *right;
  // up
  struct tagITEM *up;
  // down
  struct tagITEM *down;
};

struct tagMENU
{
  // height
  signed short int height;
  // width
  signed short int width;
  // rows
  signed short int rows;
  // cols
  signed short int cols;
  // frows
  signed short int frows;
  // fcols
  signed short int fcols;
  // arows
  signed short int arows;
  // namelen
  signed short int namelen;
  // desclen
  signed short int desclen;
  // marklen
  signed short int marklen;
  // itemlen
  signed short int itemlen;
  // spc_desc
  signed short int spc_desc;
  // spc_cols
  signed short int spc_cols;
  // spc_rows
  signed short int spc_rows;
  // pattern
  char *pattern;
  // pindex
  signed short int pindex;
  // win
  struct _win_st *win;
  // sub
  struct _win_st *sub;
  // userwin
  struct _win_st *userwin;
  // usersub
  struct _win_st *usersub;
  // items
  struct tagITEM **items;
  // nitems
  signed short int nitems;
  // curitem
  struct tagITEM *curitem;
  // toprow
  signed short int toprow;
  // fore
  unsigned long int fore;
  // back
  unsigned long int back;
  // grey
  unsigned long int grey;
  // pad
  unsigned char pad;
  // menuinit
  void (*menuinit)(struct tagMENU *);
  // menuterm
  void (*menuterm)(struct tagMENU *);
  // iteminit
  void (*iteminit)(struct tagMENU *);
  // itemterm
  void (*itemterm)(struct tagMENU *);
  // userptr
  void *userptr;
  // mark
  char *mark;
  // opt
  signed int opt;
  // status
  unsigned short int status;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct typenode
{
  // status
  unsigned short int status;
  // ref
  signed long int ref;
  // left
  struct typenode *left;
  // right
  struct typenode *right;
  // makearg
  void * (*makearg)(void ***);
  // copyarg
  void * (*copyarg)(const void *);
  // freearg
  void (*freearg)(void *);
  // fcheck
  _Bool (*fcheck)(struct fieldnode *, const void *);
  // ccheck
  _Bool (*ccheck)(signed int, const void *);
  // next
  _Bool (*next)(struct fieldnode *, const void *);
  // prev
  _Bool (*prev)(struct fieldnode *, const void *);
};


// COLS
// file /usr/include/curses.h line 1399
extern signed int COLS;
// LINES
// file /usr/include/curses.h line 1401
extern signed int LINES;
// TYPE_REGEXP
// file /usr/include/form.h line 297
extern struct typenode *TYPE_REGEXP;
// UUID_str
// file sdp.c line 65
static char UUID_str[37l];
// acs_map
// file /usr/include/curses.h line 274
extern unsigned long int acs_map[];
// bts_reset
// file main.c line 85
signed int bts_reset = 1;
// bts_run
// file main.c line 83
char bts_run = (char)1;
// bts_run_scan
// file main.c line 84
char bts_run_scan = (char)1;
// cfg_file
// file cfg.c line 89
static char *cfg_file = "/etc/btscanner.xml";
// cfg_log
// file cfg.c line 86
static char *cfg_log = (char *)(void *)0;
// cfg_oui
// file cfg.c line 87
static char *cfg_oui = (char *)(void *)0;
// cfg_ranges
// file cfg.c line 92
static struct rangedef *cfg_ranges = (struct rangedef *)(void *)0;
// cfg_ranges_sz
// file cfg.c line 93
static unsigned long int cfg_ranges_sz = (unsigned long int)0;
// cfg_store
// file cfg.c line 88
static char *cfg_store = (char *)(void *)0;
// class_av
// file sdp.c line 124
struct sub_classes class_av[20l] = { { .class_id=(unsigned int)0x00, .class_name="Uncategorised" }, 
    { .class_id=(unsigned int)0x04, .class_name="Headset" }, 
    { .class_id=(unsigned int)0x08, .class_name="Hands free" }, 
    { .class_id=(unsigned int)0x0c, .class_name="Reserved" }, 
    { .class_id=(unsigned int)0x10, .class_name="Microphone" }, 
    { .class_id=(unsigned int)0x14, .class_name="Loudspeaker" }, 
    { .class_id=(unsigned int)0x18, .class_name="Headphones" }, 
    { .class_id=(unsigned int)0x1c, .class_name="Portable Audio" }, 
    { .class_id=(unsigned int)0x20, .class_name="Car Audio" }, 
    { .class_id=(unsigned int)0x24, .class_name="Set top box" }, 
    { .class_id=(unsigned int)0x28, .class_name="HiFi Audio" }, 
    { .class_id=(unsigned int)0x2c, .class_name="VCR" }, 
    { .class_id=(unsigned int)0x30, .class_name="Video Camera" }, 
    { .class_id=(unsigned int)0x34, .class_name="Camcorder" }, 
    { .class_id=(unsigned int)0x38, .class_name="Video Monitor" }, 
    { .class_id=(unsigned int)0x3c, .class_name="Video Display and Loudspeaker" }, 
    { .class_id=(unsigned int)0x40, .class_name="Video Conferencing" }, 
    { .class_id=(unsigned int)0x44, .class_name="Reserved" }, 
    { .class_id=(unsigned int)0x48, .class_name="Gaming" }, 
    { .class_id=(unsigned int)0x00, .class_name=(char *)(void *)0 } };
// class_computer
// file sdp.c line 91
struct sub_classes class_computer[8l] = { { .class_id=(unsigned int)0x00, .class_name="Uncategorised" }, 
    { .class_id=(unsigned int)0x04, .class_name="Desktop" }, 
    { .class_id=(unsigned int)0x08, .class_name="Server" }, 
    { .class_id=(unsigned int)0x0c, .class_name="Laptop" }, 
    { .class_id=(unsigned int)0x10, .class_name="Handheld PC-PDA" }, 
    { .class_id=(unsigned int)0x14, .class_name="Palm sized PC-PDA" }, 
    { .class_id=(unsigned int)0x18, .class_name="Wearable computer" }, 
    { .class_id=(unsigned int)0x00, .class_name=(char *)(void *)0 } };
// class_imaging
// file sdp.c line 165
struct sub_classes class_imaging[5l] = { { .class_id=(unsigned int)0x10, .class_name="Display" }, 
    { .class_id=(unsigned int)0x20, .class_name="Camera" }, 
    { .class_id=(unsigned int)0x40, .class_name="Scanner" }, 
    { .class_id=(unsigned int)0x80, .class_name="Printer" }, 
    { .class_id=(unsigned int)0x00, .class_name=(char *)(void *)0 } };
// class_network
// file sdp.c line 112
struct sub_classes class_network[9l] = { { .class_id=(unsigned int)0x00, .class_name="0% utilised" }, 
    { .class_id=(unsigned int)0x20, .class_name="1 - 17% utilised" }, 
    { .class_id=(unsigned int)0x40, .class_name="17 - 33% utilised" }, 
    { .class_id=(unsigned int)0x60, .class_name="33 - 50% utilised" }, 
    { .class_id=(unsigned int)0x80, .class_name="50 - 67% utilised" }, 
    { .class_id=(unsigned int)0xa0, .class_name="67 - 83% utilised" }, 
    { .class_id=(unsigned int)0xc0, .class_name="83 - 99% utilised" }, 
    { .class_id=(unsigned int)0xe0, .class_name="100% utilised" }, 
    { .class_id=(unsigned int)0x00, .class_name=(char *)(void *)0 } };
// class_peripheral1
// file sdp.c line 147
struct sub_classes class_peripheral1[4l] = { { .class_id=(unsigned int)0x40, .class_name="Keyboard" }, 
    { .class_id=(unsigned int)0x80, .class_name="Pointing device" }, 
    { .class_id=(unsigned int)0xC0, .class_name="Combo" }, 
    { .class_id=(unsigned int)0x00, .class_name=(char *)(void *)0 } };
// class_peripheral2
// file sdp.c line 154
struct sub_classes class_peripheral2[8l] = { { .class_id=(unsigned int)0x00, .class_name="Uncategorised" }, 
    { .class_id=(unsigned int)0x04, .class_name="Joystick" }, 
    { .class_id=(unsigned int)0x08, .class_name="Gamepad" }, 
    { .class_id=(unsigned int)0x0c, .class_name="Remote control" }, 
    { .class_id=(unsigned int)0x10, .class_name="Sensing device" }, 
    { .class_id=(unsigned int)0x14, .class_name="Digitiser tablet" }, 
    { .class_id=(unsigned int)0x18, .class_name="Card Reader" }, 
    { .class_id=(unsigned int)0x00, .class_name=(char *)(void *)0 } };
// class_phone
// file sdp.c line 102
struct sub_classes class_phone[7l] = { { .class_id=(unsigned int)0x00, .class_name="Uncategorised" }, 
    { .class_id=(unsigned int)0x04, .class_name="Mobile" }, 
    { .class_id=(unsigned int)0x08, .class_name="Cordless" }, 
    { .class_id=(unsigned int)0x0c, .class_name="Smart phone" }, 
    { .class_id=(unsigned int)0x10, .class_name="Wired modem or voice gateway" }, 
    { .class_id=(unsigned int)0x14, .class_name="Common ISDN Access" }, 
    { .class_id=(unsigned int)0x00, .class_name=(char *)(void *)0 } };
// devhead
// file ll.c line 81
static struct device *devhead = (struct device *)(void *)0;
// devhead_mutex
// file ll.c line 82
static union anonymous$37 devhead_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// hcihead
// file main.c line 82
struct hcicfg *hcihead = (struct hcicfg *)(void *)0;
// ll_last_summary
// file ll.c line 84
static signed long int ll_last_summary = (signed long int)0;
// ll_list_changed
// file ll.c line 80
static unsigned char ll_list_changed = (unsigned char)0;
// ll_list_len
// file ll.c line 83
static unsigned long int ll_list_len = (unsigned long int)0;
// log_fd
// file log.c line 81
static signed int log_fd = -1;
// log_fp
// file log.c line 80
static struct _IO_FILE *log_fp = (struct _IO_FILE *)(void *)0;
// log_smux
// file log.c line 84
static union anonymous$37 log_smux = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// log_sum_fd
// file log.c line 83
static signed int log_sum_fd = -1;
// log_sum_fp
// file log.c line 82
static struct _IO_FILE *log_sum_fp = (struct _IO_FILE *)(void *)0;
// main_options
// file main.c line 114
static struct option main_options[4l];
// main_options
// file main.c line 114
static struct option main_options[4l] = { { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 }, 
    { .name="cfg", .has_arg=1, .flag=((signed int *)NULL), .val=99 }, 
    { .name="no-reset", .has_arg=0, .flag=&bts_reset, .val=0 }, 
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
// major_device_classes
// file sdp.c line 174
struct classes major_device_classes[9l];
// major_device_classes
// file sdp.c line 174
struct classes major_device_classes[9l] = { { .class_id=(unsigned int)0x00, .sub_major_mask=(unsigned int)0x00, .sub_minor_mask=(unsigned int)0x00,
    .type=(unsigned char)1, .sub_major=(struct sub_classes *)(void *)0,
    .sub_minor=(struct sub_classes *)(void *)0,
    .class_name="Miscellaneous" }, 
    { .class_id=(unsigned int)0x01, .sub_major_mask=(unsigned int)0xfc, .sub_minor_mask=(unsigned int)0x00,
    .type=(unsigned char)1, .sub_major=class_computer,
    .sub_minor=(struct sub_classes *)(void *)0, .class_name="Computer" }, 
    { .class_id=(unsigned int)0x02, .sub_major_mask=(unsigned int)0xfc, .sub_minor_mask=(unsigned int)0x00,
    .type=(unsigned char)1, .sub_major=class_phone,
    .sub_minor=(struct sub_classes *)(void *)0, .class_name="Phone" }, 
    { .class_id=(unsigned int)0x03, .sub_major_mask=(unsigned int)0xe0, .sub_minor_mask=(unsigned int)0x00,
    .type=(unsigned char)1, .sub_major=class_network,
    .sub_minor=(struct sub_classes *)(void *)0, .class_name="Network" }, 
    { .class_id=(unsigned int)0x04, .sub_major_mask=(unsigned int)0xfc, .sub_minor_mask=(unsigned int)0x00,
    .type=(unsigned char)1, .sub_major=class_av,
    .sub_minor=(struct sub_classes *)(void *)0, .class_name="Audio-Video" }, 
    { .class_id=(unsigned int)0x05, .sub_major_mask=(unsigned int)0xc0, .sub_minor_mask=(unsigned int)0x3c,
    .type=(unsigned char)1, .sub_major=class_peripheral1,
    .sub_minor=class_peripheral2, .class_name="Peripheral" }, 
    { .class_id=(unsigned int)0x06, .sub_major_mask=(unsigned int)0xf0, .sub_minor_mask=(unsigned int)0x00,
    .type=(unsigned char)0, .sub_major=class_imaging,
    .sub_minor=(struct sub_classes *)(void *)0, .class_name="Imaging" }, 
    { .class_id=(unsigned int)0x1f, .sub_major_mask=(unsigned int)0x00, .sub_minor_mask=(unsigned int)0x00,
    .type=(unsigned char)1, .sub_major=(struct sub_classes *)(void *)0,
    .sub_minor=(struct sub_classes *)(void *)0,
    .class_name="Uncategorised" }, 
    { .class_id=(unsigned int)0x00, .sub_major_mask=(unsigned int)0x00, .sub_minor_mask=(unsigned int)0x00,
    .type=(unsigned char)1, .sub_major=(struct sub_classes *)(void *)0,
    .sub_minor=(struct sub_classes *)(void *)0,
    .class_name=(char *)(void *)0 } };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// opterr
// file /usr/include/getopt.h line 76
extern signed int opterr;
// ouihead
// file oui.c line 81
static struct oui *ouihead = (struct oui *)(void *)0;
// scan_bf_curr
// file scan.c line 714
static unsigned long int scan_bf_curr;
// scan_bf_end
// file scan.c line 715
static unsigned long int scan_bf_end;
// scan_bf_mutex
// file scan.c line 717
union anonymous$37 scan_bf_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// scan_bf_perc
// file scan.c line 716
static signed int scan_bf_perc;
// scan_bf_start
// file scan.c line 713
static unsigned long int scan_bf_start;
// screen_block_info
// file screen.c line 167
static struct anonymous$31 screen_block_info;
// screen_info_keys
// file screen.c line 491
static struct screen_keys screen_info_keys[8l];
// screen_info_keys
// file screen.c line 491
static struct screen_keys screen_info_keys[8l] = { { .key=0403, .func=screen_block_move }, { .key=107, .func=screen_block_move }, { .key=0402, .func=screen_block_move }, { .key=106, .func=screen_block_move }, { .key=0522, .func=screen_block_move }, { .key=0523, .func=screen_block_move }, { .key=113, .func=screen_info_quit }, { .key=-1, .func=(signed int (*)(signed int))(void *)0 } };
// screen_line_info
// file screen.c line 178
static struct anonymous$32 screen_line_info;
// screen_log_lines
// file screen.c line 91
struct cbuf screen_log_lines[4l];
// screen_log_mux
// file screen.c line 90
static union anonymous$37 screen_log_mux = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// screen_main_keys
// file screen.c line 480
static struct screen_keys screen_main_keys[9l];
// screen_main_keys
// file screen.c line 480
static struct screen_keys screen_main_keys[9l] = { { .key=0403, .func=screen_line_move }, { .key=107, .func=screen_line_move }, { .key=0402, .func=screen_line_move }, { .key=106, .func=screen_line_move }, { .key=0522, .func=screen_line_move }, { .key=0523, .func=screen_line_move }, { .key=0527, .func=screen_main_key_enter }, 
    { .key=0x0d, .func=screen_main_key_enter }, 
    { .key=-1, .func=(signed int (*)(signed int))(void *)0 } };
// screen_mm
// file screen.c line 88
static const char *screen_mm = "";
// screen_sizes
// file screen.c line 157
static struct anonymous$30 screen_sizes[3l];
// screen_sort
// file screen.c line 89
static signed int screen_sort = 0x00;
// screens_cfg
// file screen.c line 509
static struct anonymous$0 screens_cfg[2l];
// screens_cfg
// file screen.c line 509
static struct anonymous$0 screens_cfg[2l] = { { .type=(enum screen_types)0, .title=screen_main_print_title, .changed=ll_ischanged,
    .get_content=screen_main_get_content, .keymap=screen_main_keys }, 
    { .type=(enum screen_types)1, .title=screen_info_print_title, .changed=screen_info_is_changed,
    .get_content=screen_info_get_content, .keymap=screen_info_keys } };
// screens_curr
// file screen.c line 145
static signed int screens_curr = 0;
// screens_max
// file screen.c line 144
static signed int screens_max = 2;
// service_classes
// file sdp.c line 187
struct sub_classes service_classes[12l] = { { .class_id=(unsigned int)0x001, .class_name="Limited Discoverable mode" }, 
    { .class_id=(unsigned int)0x002, .class_name="Reserved" }, 
    { .class_id=(unsigned int)0x004, .class_name="Reserved" }, 
    { .class_id=(unsigned int)0x008, .class_name="Positioning" }, 
    { .class_id=(unsigned int)0x010, .class_name="Networking" }, 
    { .class_id=(unsigned int)0x020, .class_name="Rendering" }, 
    { .class_id=(unsigned int)0x040, .class_name="Capturing" }, 
    { .class_id=(unsigned int)0x080, .class_name="Object Transfer" }, 
    { .class_id=(unsigned int)0x100, .class_name="Audio" }, 
    { .class_id=(unsigned int)0x200, .class_name="Telephony" }, 
    { .class_id=(unsigned int)0x400, .class_name="Information" }, 
    { .class_id=(unsigned int)0, .class_name=(char *)(void *)0 } };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// stdscr
// file /usr/include/curses.h line 1395
extern struct _win_st *stdscr;
// thread_starter
// file threader.c line 88
struct anonymous$6 thread_starter[3l];
// thread_starter
// file threader.c line 88
struct anonymous$6 thread_starter[3l] = { { .what=(enum threader_scan_types)SCAN_INQ, .desc="inquiry scan",
    .func=scan_run }, 
    { .what=(enum threader_scan_types)SCAN_BF, .desc="brute force scan",
    .func=bf_run }, 
    { .what=(enum threader_scan_types)SCAN_NONE, .desc=(const char *)(void *)0,
    .func=(void * (*)(void *))(void *)0 } };
// threader_current
// file threader.c line 94
static enum threader_scan_types threader_current = (enum threader_scan_types)0;
// xmlFree
// file /usr/include/libxml2/libxml/globals.h line 251
extern void (*xmlFree)(void *);

// applog
// file ./log.h line 34
signed int applog(signed int level, const char *fmt, ...)
{
  void **ap;
  struct tm now;
  signed long int tnow;
  char *s;
  if(log_fp == ((struct _IO_FILE *)NULL))
    return 1;

  else
  {
    pthread_mutex_lock(&log_smux);
    time(&tnow);
    localtime_r(&tnow, &now);
    now.tm_year = now.tm_year + 1900;
    now.tm_mon = now.tm_mon + 1;
    switch(level)
    {
      case 6:
      {
        s = "info";
        break;
      }
      case 4:
      {
        s = "warning";
        break;
      }
      case 3:
      {
        s = "error";
        break;
      }
      default:
        s = "unknown";
    }
    fprintf(log_fp, "%04d/%02d/%02d %02d:%02d:%02d: %s: ", now.tm_year, now.tm_mon, now.tm_mday, now.tm_hour, now.tm_min, now.tm_sec, s);
    ap = (void **)&fmt;
    vfprintf(log_fp, fmt, ap);
    ap = ((void **)NULL);
    fprintf(log_fp, "\n");
    fflush(log_fp);
    pthread_mutex_unlock(&log_smux);
    return 0;
  }
}

// ba2int
// file oui.c line 84
unsigned int ba2int(struct anonymous$28 *ba)
{
  unsigned int oui = (unsigned int)ba->b[(signed long int)5];
  oui = oui << 8;
  oui = oui | (unsigned int)ba->b[(signed long int)4];
  oui = oui << 8;
  oui = oui | (unsigned int)ba->b[(signed long int)3];
  return oui;
}

// bacmp
// file /usr/include/bluetooth/bluetooth.h line 314
static inline signed int bacmp(const struct anonymous$28 *ba1, const struct anonymous$28 *ba2)
{
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp((const void *)ba1, (const void *)ba2, sizeof(struct anonymous$28) /*6ul*/ );
  return return_value_memcmp$1;
}

// bacpy
// file /usr/include/bluetooth/bluetooth.h line 318
static inline void bacpy(struct anonymous$28 *dst, const struct anonymous$28 *src)
{
  memcpy((void *)dst, (const void *)src, sizeof(struct anonymous$28) /*6ul*/ );
}

// bacpy$link1
// file /usr/include/bluetooth/bluetooth.h line 318
static inline void bacpy$link1(struct anonymous$28 *dst$link1, const struct anonymous$28 *src$link1)
{
  memcpy((void *)dst$link1, (const void *)src$link1, sizeof(struct anonymous$28) /*6ul*/ );
}

// bacpy$link2
// file /usr/include/bluetooth/bluetooth.h line 318
static inline void bacpy$link2(struct anonymous$28 *dst$link2, const struct anonymous$28 *src$link2)
{
  memcpy((void *)dst$link2, (const void *)src$link2, sizeof(struct anonymous$28) /*6ul*/ );
}

// bd2int
// file ./misc.h line 40
unsigned long int bd2int(struct anonymous$28 *bd)
{
  unsigned long int ret = (unsigned long int)0;
  ret = (unsigned long int)bd->b[(signed long int)5];
  ret = ret << 8;
  ret = ret | (unsigned long int)bd->b[(signed long int)4];
  ret = ret << 8;
  ret = ret | (unsigned long int)bd->b[(signed long int)3];
  ret = ret << 8;
  ret = ret | (unsigned long int)bd->b[(signed long int)2];
  ret = ret << 8;
  ret = ret | (unsigned long int)bd->b[(signed long int)1];
  ret = ret << 8;
  ret = ret | (unsigned long int)bd->b[(signed long int)0];
  return ret;
}

// bf_run
// file ./scan.h line 34
void * bf_run(void *arg)
{
  struct anonymous$25 sset;
  struct hcicfg *hci = (struct hcicfg *)arg;
  memset((void *)&sset, 0, sizeof(struct anonymous$25) /*128ul*/ );
  sigfillset(&sset);
  sigdelset(&sset, 9);
  sigdelset(&sset, 19);
  sigdelset(&sset, 15);
  sigdelset(&sset, 2);
  sigdelset(&sset, 11);
  sigdelset(&sset, 10);
  signed int return_value_pthread_sigmask$1;
  return_value_pthread_sigmask$1=pthread_sigmask(2, &sset, (struct anonymous$25 *)(void *)0);
  signed int return_value_scan_reset_device$2;
  if(return_value_pthread_sigmask$1 == 0)
  {
    return_value_scan_reset_device$2=scan_reset_device(hci->id);
    if(return_value_scan_reset_device$2 == 0)
      scan_probe_bf(hci);

  }


bf_run_leave:
  ;
  hci->died = (unsigned char)1;
  pthread_exit(NULL);
}

// cfg_cleanup
// file ./cfg.h line 50
signed int cfg_cleanup(void)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= cfg_ranges_sz); i = i + 1ul)
    if(!((cfg_ranges + (signed long int)i)->vulns == ((char *)NULL)))
      free((void *)(cfg_ranges + (signed long int)i)->vulns);

  free((void *)cfg_ranges);
  cfg_ranges = (struct rangedef *)(void *)0;
  if(!(cfg_log == ((char *)NULL)))
    free((void *)cfg_log);

  if(!(cfg_oui == ((char *)NULL)))
    free((void *)cfg_oui);

  if(!(cfg_store == ((char *)NULL)))
    free((void *)cfg_store);

  cfg_store = (char *)(void *)0;
  cfg_oui = cfg_store;
  cfg_log = cfg_oui;
  return 0;
}

// cfg_copy_content
// file cfg.c line 97
char * cfg_copy_content(struct _xmlNode *node)
{
  char *s;
  char *h;
  unsigned long int hlen;
  unsigned long int len;
  _Bool tmp_if_expr$1;
  if(node->children == ((struct _xmlNode *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(node->children->content != ((unsigned char *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    fprintf(stderr, "%s(): 'log' item found but no content\n", (const void *)"cfg_copy_content");
    return (char *)(void *)0;
  }

  else
  {
    if((signed int)*node->children->content == 126)
    {
      h=getenv("HOME");
      if(h == ((char *)NULL))
      {
        fprintf(stderr, "%s(): cannot expand '~', $HOME not defined\n", (const void *)"cfg_copy_content");
        return (char *)(void *)0;
      }

      hlen=strlen(h);
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen((char *)node->children->content);
      len = return_value_strlen$2 + hlen;
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(char) /*1ul*/  * (len + (unsigned long int)1));
      s = (char *)return_value_malloc$3;
      if(s == ((char *)NULL))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        char *return_value_strerror$5;
        return_value_strerror$5=strerror(*return_value___errno_location$4);
        fprintf(stderr, "%s::malloc(): %s\n", (const void *)"cfg_copy_content", return_value_strerror$5);
        return (char *)(void *)0;
      }

      strncpy(s, h, len);
      strncpy(s + (signed long int)hlen, (char *)node->children->content + (signed long int)1, len - hlen);
      if((signed int)s[-1l + (signed long int)len] == 47)
        s[(signed long int)(len - (unsigned long int)1)] = (char)0;

    }

    else
    {
      s=strdup((char *)node->children->content);
      if(s == ((char *)NULL))
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        char *return_value_strerror$7;
        return_value_strerror$7=strerror(*return_value___errno_location$6);
        fprintf(stderr, "%s::xmlCharStrdup(): %s\n", (const void *)"cfg_copy_content", return_value_strerror$7);
        return (char *)(void *)0;
      }

    }
    return s;
  }
}

// cfg_get_range
// file cfg.c line 434
struct rangedef * cfg_get_range(unsigned long int did)
{
  struct rangedef *ret = (struct rangedef *)(void *)0;
  unsigned long int i = (unsigned long int)0;
  _Bool tmp_if_expr$1;
  for( ; !(i >= cfg_ranges_sz); i = i + 1ul)
  {
    if(!(did >= (cfg_ranges + (signed long int)i)->start))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (cfg_ranges + (signed long int)i)->end < did ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1)
    {
      if(ret == ((struct rangedef *)NULL))
        ret = &cfg_ranges[(signed long int)i];

      else
        if(!((cfg_ranges + (signed long int)i)->end + -(cfg_ranges + (signed long int)i)->start >= ret->end + -ret->start))
          ret = &cfg_ranges[(signed long int)i];

    }

  }
  return ret;
}

// cfg_log_filename
// file cfg.c line 419
const char * cfg_log_filename(void)
{
  return cfg_log;
}

// cfg_oui_filename
// file ./cfg.h line 54
const char * cfg_oui_filename(void)
{
  return cfg_oui;
}

// cfg_parse_files
// file cfg.c line 144
signed int cfg_parse_files(struct _xmlNode *node)
{
  struct _xmlNode *n;
  _Bool tmp_if_expr$1;
  if(node == ((struct _xmlNode *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(node->children != ((struct _xmlNode *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int return_value_xmlStrncmp$3;
  signed int return_value_xmlStrncmp$2;
  if(tmp_if_expr$1)
    return 1;

  else
  {
    n = node->children;
    for( ; !(n == ((struct _xmlNode *)NULL)); n = n->next)
      if((signed int)n->type == XML_ELEMENT_NODE)
      {
        signed int return_value_xmlStrncmp$4;
        return_value_xmlStrncmp$4=xmlStrncmp((const unsigned char *)"log", n->name, 3);
        if(return_value_xmlStrncmp$4 == 0)
          cfg_log=cfg_copy_content(n);

        else
        {
          return_value_xmlStrncmp$3=xmlStrncmp((const unsigned char *)"oui", n->name, 3);
          if(return_value_xmlStrncmp$3 == 0)
            cfg_oui=cfg_copy_content(n);

          else
          {
            return_value_xmlStrncmp$2=xmlStrncmp((const unsigned char *)"store", n->name, 5);
            if(return_value_xmlStrncmp$2 == 0)
              cfg_store=cfg_copy_content(n);

          }
        }
      }

    if(cfg_log == ((char *)NULL) || cfg_oui == ((char *)NULL) || cfg_store == ((char *)NULL))
    {
      fprintf(stderr, "%s(): Not all file variables were defined\n", (const void *)"cfg_parse_files");
      return 1;
    }

    else
      return 0;
  }
}

// cfg_parse_rangedef
// file cfg.c line 172
signed int cfg_parse_rangedef(struct _xmlNode *node, struct rangedef *rd)
{
  signed int ret;
  unsigned char *p;
  struct _xmlNode *n;
  struct anonymous$28 bd;
  _Bool tmp_if_expr$1;
  if(node == ((struct _xmlNode *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(node->children != ((struct _xmlNode *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int return_value_xmlStrncmp$9;
  signed int return_value_xmlStrncmp$8;
  signed int return_value_xmlStrncmp$7;
  signed int return_value_xmlStrncmp$6;
  signed int return_value_xmlStrncmp$5;
  signed int return_value_xmlStrncmp$4;
  if(tmp_if_expr$1)
    return 1;

  else
  {
    ret = 1;
    memset((void *)rd, 0, sizeof(struct rangedef) /*32ul*/ );
    p=xmlGetProp(node, (unsigned char *)"start");
    if(p == ((unsigned char *)NULL))
      fprintf(stderr, "%s(): Mandatory start attribute not found\n", (const void *)"cfg_parse_rangedef");

    else
    {
      str2ba((const char *)p, &bd);
      rd->start=bd2int(&bd);
      xmlFree((void *)p);
      p=xmlGetProp(node, (unsigned char *)"end");
      if(p == ((unsigned char *)NULL))
        fprintf(stderr, "%s(): Mandatory end attribute not found\n", (const void *)"cfg_parse_rangedef");

      else
      {
        str2ba((const char *)p, &bd);
        rd->end=bd2int(&bd);
        xmlFree((void *)p);
        if(!(rd->end >= rd->start))
          fprintf(stderr, "%s(): start address is greater than the end address", (const void *)"cfg_parse_rangedef");

        else
        {
          n = node->children;
          if(!(n == ((struct _xmlNode *)NULL)))
          {
            if((signed int)n->type == XML_ELEMENT_NODE)
            {
              signed int return_value_xmlStrncmp$10;
              return_value_xmlStrncmp$10=xmlStrncmp((const unsigned char *)"vulnerabilities", n->name, 15);
              if(return_value_xmlStrncmp$10 == 0)
              {
                if(!(n->children == ((struct _xmlNode *)NULL)))
                {
                  rd->vulns=strdup((char *)n->children->content);
                  if(rd->vulns == ((char *)NULL))
                  {
                    signed int *return_value___errno_location$2;
                    return_value___errno_location$2=__errno_location();
                    char *return_value_strerror$3;
                    return_value_strerror$3=strerror(*return_value___errno_location$2);
                    fprintf(stderr, "%s::xmlCharStrdup(): %s\n", (const void *)"cfg_parse_rangedef", return_value_strerror$3);
                  }

                }

              }

              else
              {
                return_value_xmlStrncmp$9=xmlStrncmp((const unsigned char *)"name", n->name, 4);
                if(return_value_xmlStrncmp$9 == 0)
                  rd->sf = rd->sf | (unsigned char)0x01;

                else
                {
                  return_value_xmlStrncmp$8=xmlStrncmp((const unsigned char *)"hci", n->name, 3);
                  if(return_value_xmlStrncmp$8 == 0)
                    rd->sf = rd->sf | (unsigned char)0x02;

                  else
                  {
                    return_value_xmlStrncmp$7=xmlStrncmp((const unsigned char *)"rssi", n->name, 4);
                    if(return_value_xmlStrncmp$7 == 0)
                      rd->sf = rd->sf | (unsigned char)0x04;

                    else
                    {
                      return_value_xmlStrncmp$6=xmlStrncmp((const unsigned char *)"lq", n->name, 2);
                      if(return_value_xmlStrncmp$6 == 0)
                        rd->sf = rd->sf | (unsigned char)0x08;

                      else
                      {
                        return_value_xmlStrncmp$5=xmlStrncmp((const unsigned char *)"txpwr", n->name, 5);
                        if(return_value_xmlStrncmp$5 == 0)
                          rd->sf = rd->sf | (unsigned char)0x10;

                        else
                        {
                          return_value_xmlStrncmp$4=xmlStrncmp((const unsigned char *)"sdp", n->name, 3);
                          if(return_value_xmlStrncmp$4 == 0)
                            rd->sf = rd->sf | (unsigned char)0x20;

                        }
                      }
                    }
                  }
                }
              }
            }

            n = n->next;
          }

          ret = 0;
        }
      }
    }

  cfg_parse_rangedef_leave:
    ;
    return ret;
  }
}

// cfg_parse_root
// file cfg.c line 246
signed int cfg_parse_root(struct _xmlNode *node)
{
  struct _xmlNode *n;
  signed int ret = 0;
  n = node;
  signed int return_value_xmlStrncmp$4;
  for( ; !(n == ((struct _xmlNode *)NULL)); n = n->next)
    if((signed int)n->type == XML_ELEMENT_NODE)
    {
      signed int return_value_xmlStrncmp$5;
      return_value_xmlStrncmp$5=xmlStrncmp((const unsigned char *)"files", n->name, 5);
      if(return_value_xmlStrncmp$5 == 0)
      {
        ret=cfg_parse_files(n);
        if(!(ret == 0))
          break;

      }

      else
      {
        return_value_xmlStrncmp$4=xmlStrncmp((const unsigned char *)"rangedef", n->name, 8);
        if(return_value_xmlStrncmp$4 == 0)
        {
          cfg_ranges_sz = cfg_ranges_sz + 1ul;
          void *return_value_realloc$1;
          return_value_realloc$1=realloc((void *)cfg_ranges, sizeof(struct rangedef) /*32ul*/  * cfg_ranges_sz);
          cfg_ranges = (struct rangedef *)return_value_realloc$1;
          if(cfg_ranges == ((struct rangedef *)NULL))
          {
            signed int *return_value___errno_location$2;
            return_value___errno_location$2=__errno_location();
            char *return_value_strerror$3;
            return_value_strerror$3=strerror(*return_value___errno_location$2);
            fprintf(stderr, "%s::realloc(): %s\n", (const void *)"cfg_parse_root", return_value_strerror$3);
            ret = 1;
            break;
          }

          ret=cfg_parse_rangedef(n, &cfg_ranges[(signed long int)(cfg_ranges_sz - (unsigned long int)1)]);
          if(!(ret == 0))
            break;

        }

      }
    }

  return ret;
}

// cfg_parse_xml
// file cfg.c line 294
signed int cfg_parse_xml(char *filename)
{
  struct _xmlParserCtxt *ctxt = (struct _xmlParserCtxt *)(void *)0;
  struct _xmlNode *root_element = (struct _xmlNode *)(void *)0;
  struct _xmlNode *n = (struct _xmlNode *)(void *)0;
  struct _xmlDoc *doc = (struct _xmlDoc *)(void *)0;
  struct stat sbuf;
  signed int ret = 1;
  if(!(filename == ((char *)NULL)))
    cfg_file = filename;

  signed int return_value_stat$3;
  return_value_stat$3=stat(cfg_file, &sbuf);
  if(!(return_value_stat$3 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    fprintf(stderr, "%s::stat(): %s\n", (const void *)"cfg_parse_xml", return_value_strerror$2);
    return 1;
  }

  if(!((256u & sbuf.st_mode) == 256u))
  {
    fprintf(stderr, "%s::stat(): config file is not readable\n", (const void *)"cfg_parse_xml");
    return 1;
  }

  else
  {
    ctxt=xmlNewParserCtxt();
    if(ctxt == ((struct _xmlParserCtxt *)NULL))
      fprintf(stderr, "%s::xmlNewParserCtxt(): context allocation failed\n", (const void *)"cfg_parse_xml");

    else
    {
      doc=xmlCtxtReadFile(ctxt, cfg_file, (const char *)(void *)0, 128 | 16 | 4);
      if(doc == ((struct _xmlDoc *)NULL))
        fprintf(stderr, "%s::xmlCtxtReadFile(): failed to parse config file\n", (const void *)"cfg_parse_xml");

      else
        if(doc->intSubset == ((struct _xmlDtd *)NULL))
          fprintf(stderr, "%s(): no DTD was specified in the config file\n", (const void *)"cfg_parse_xml");

        else
        {
          root_element=xmlDocGetRootElement(doc);
          if(root_element == ((struct _xmlNode *)NULL))
            fprintf(stderr, "%s(): could not locate root element\n", (const void *)"cfg_parse_xml");

          else
          {
            ret = 0;
            n = root_element;
            for( ; !(n == ((struct _xmlNode *)NULL)); n = n->next)
              if((signed int)n->type == XML_ELEMENT_NODE)
              {
                signed int return_value_xmlStrncmp$4;
                return_value_xmlStrncmp$4=xmlStrncmp((const unsigned char *)"btscanner", n->name, 9);
                if(return_value_xmlStrncmp$4 == 0)
                {
                  ret=cfg_parse_root(n->children);
                  if(!(ret == 0))
                    break;

                }

              }

          }
        }
    }

  cfg_parse_xml_leave:
    ;
    if(!(doc == ((struct _xmlDoc *)NULL)))
      xmlFreeDoc(doc);

    if(!(ctxt == ((struct _xmlParserCtxt *)NULL)))
      xmlFreeParserCtxt(ctxt);

    return ret;
  }
}

// cfg_parsefile
// file ./cfg.h line 49
signed int cfg_parsefile(char *filename)
{
  unsigned long int i;
  unsigned long int cv = (unsigned long int)0xffffffffffff;
  xmlSetGenericErrorFunc((void *)stdout, (void (*)(void *, const char *, ...))(void *)0);
  xmlSetStructuredErrorFunc((void *)stdout, (void (*)(void *, struct _xmlError *))(void *)0);
  signed int return_value_cfg_parse_xml$1;
  return_value_cfg_parse_xml$1=cfg_parse_xml(filename);
  if(!(return_value_cfg_parse_xml$1 == 0))
  {
    fprintf(stderr, "%s::cfg_parse_xml(): parse failed\n", (const void *)"cfg_parsefile");
    return 1;
  }

  else
  {
    i = (unsigned long int)0;
    for( ; !(i >= cfg_ranges_sz); i = i + 1ul)
      if((cfg_ranges + (signed long int)i)->start == 0ul)
      {
        if(cv == (cfg_ranges + (signed long int)i)->end)
          break;

      }

    if(i == cfg_ranges_sz)
    {
      fprintf(stderr, "%s(): No global rangedef was found\n", (const void *)"cfg_parsefile");
      return 1;
    }

    else
      return 0;
  }
}

// cfg_store_filename
// file cfg.c line 427
const char * cfg_store_filename(void)
{
  return cfg_store;
}

// cfg_xml_err
// file cfg.c line 281
void cfg_xml_err(void *ctx, const char *fmt, ...)
{
  void **ap;
  ctx = ctx;
  ap = (void **)&fmt;
  vfprintf(stderr, fmt, ap);
  ap = ((void **)NULL);
}

// dointerrupt
// file main.c line 97
static void dointerrupt(signed int sig)
{
  sig = sig;
}

// find_conn
// file scan.c line 129
unsigned short int find_conn(signed int dev_id, struct anonymous$28 *bdaddr)
{
  struct hci_conn_list_req *cl;
  struct hci_conn_info *ci;
  signed int i;
  signed int s;
  unsigned short int rv = (unsigned short int)-1;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  s=socket(31, 3, 1);
  if(s == -1)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    applog(4, "%s::socket(): %s", (const void *)"find_conn", return_value_strerror$3);
    return (unsigned short int)-1;
  }

  void *return_value_malloc$6;
  return_value_malloc$6=malloc((unsigned long int)10 * sizeof(struct hci_conn_info) /*16ul*/  + sizeof(struct hci_conn_list_req) /*4ul*/ );
  cl = (struct hci_conn_list_req *)return_value_malloc$6;
  if(cl == ((struct hci_conn_list_req *)NULL))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    applog(4, "%s::malloc(): %s", (const void *)"find_conn", return_value_strerror$5);
    close(s);
    return (unsigned short int)-1;
  }

  cl->dev_id = (unsigned short int)dev_id;
  cl->conn_num = (unsigned short int)10;
  ci = cl->conn_info;
  signed int return_value_ioctl$9;
  return_value_ioctl$9=ioctl(s, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(72 << 0 + 8) | (unsigned int)(212 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, (void *)cl);
  if(!(return_value_ioctl$9 == 0))
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    char *return_value_strerror$8;
    return_value_strerror$8=strerror(*return_value___errno_location$7);
    applog(4, "%s::ioctl(): %s", (const void *)"find_conn", return_value_strerror$8);
    free((void *)cl);
    close(s);
    return (unsigned short int)-1;
  }

  i = 0;
  for( ; !(i >= (signed int)cl->conn_num); ci = ci + 1l)
  {
    signed int return_value_bacmp$10;
    return_value_bacmp$10=bacmp(bdaddr, &ci->bdaddr);
    if(return_value_bacmp$10 == 0)
    {
      if((signed int)ci->type == 0x01)
      {
        rv = ci->handle;
        break;
      }

    }

    i = i + 1;
  }
  signed int *return_value___errno_location$11;
  return_value___errno_location$11=__errno_location();
  *return_value___errno_location$11 = 0;
  free((void *)cl);
  close(s);
  return rv;
}

// get_max_devices
// file main.c line 146
signed int get_max_devices(signed int s)
{
  struct hci_dev_list_req *dl = (struct hci_dev_list_req *)(void *)0;
  struct hci_dev_req *dr = (struct hci_dev_req *)(void *)0;
  struct hci_dev_info di;
  signed int i;
  signed int ret;
  signed int up;
  struct hcicfg *hci;
  ret = 1;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)16 * sizeof(struct hci_dev_req) /*8ul*/  + sizeof(unsigned short int) /*2ul*/ );
  dl = (struct hci_dev_list_req *)return_value_malloc$1;
  if(dl == ((struct hci_dev_list_req *)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    applog(3, "%s::malloc(): %s", (const void *)"get_max_devices", return_value_strerror$3);
    goto get_max_devices_leave;
  }

  memset((void *)dl, 0, (unsigned long int)16 * sizeof(struct hci_dev_req) /*8ul*/  + sizeof(unsigned short int) /*2ul*/ );
  dl->dev_num = (unsigned short int)16;
  dr = dl->dev_req;
  signed int return_value_ioctl$6;
  return_value_ioctl$6=ioctl(s, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(72 << 0 + 8) | (unsigned int)(210 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, (void *)dl);
  if(!(return_value_ioctl$6 == 0))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    applog(3, "%s::ioctl(): %s", (const void *)"get_max_devices", return_value_strerror$5);
    goto get_max_devices_leave;
  }

  ret = 0;
  i = 0;
  up = i;
  for( ; !(i >= (signed int)dl->dev_num); dr = dr + 1l)
  {
    di.dev_id = dr->dev_id;
    signed int return_value_ioctl$7;
    return_value_ioctl$7=ioctl(s, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(72 << 0 + 8) | (unsigned int)(211 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, (void *)&di);
    if(return_value_ioctl$7 == 0)
    {
      void *return_value_malloc$8;
      return_value_malloc$8=malloc(sizeof(struct hcicfg) /*40ul*/ );
      hci = (struct hcicfg *)return_value_malloc$8;
      if(hci == ((struct hcicfg *)NULL))
      {
        ret = 1;
        signed int *return_value___errno_location$9;
        return_value___errno_location$9=__errno_location();
        char *return_value_strerror$10;
        return_value_strerror$10=strerror(*return_value___errno_location$9);
        applog(3, "%s::malloc(): %s", (const void *)"get_max_devices", return_value_strerror$10);
        break;
      }

      memset((void *)hci, 0, sizeof(struct hcicfg) /*40ul*/ );
      hci->id = (signed int)di.dev_id;
      bacpy(&hci->bdaddr, &di.bdaddr);
      signed int return_value_hci_test_bit$11;
      return_value_hci_test_bit$11=hci_test_bit(0, (void *)&dr->dev_opt);
      if(!(return_value_hci_test_bit$11 == 0))
      {
        hci->enabled = (char)0x01;
        up = up + 1;
      }

      else
        hci->enabled = (char)0x00;
      hci_devices_append(hcihead, hci);
    }

    i = i + 1;
  }
  if(up == 0)
  {
    applog(3, "%s(): no valid HCI devices were found", (const void *)"get_max_devices");
    ret = 1;
  }


get_max_devices_leave:
  ;
  if(!(dl == ((struct hci_dev_list_req *)NULL)))
    free((void *)dl);

  return ret;
}

// handlesig
// file main.c line 89
static void handlesig(signed int sig)
{
  sig = sig;
  bts_run = (char)0;
  bts_run_scan = (char)0;
}

// hci_devices_append
// file main.c line 131
void hci_devices_append(struct hcicfg *h, struct hcicfg *n)
{
  if(hcihead == ((struct hcicfg *)NULL))
    hcihead = n;

  else
    if(!(h->next == ((struct hcicfg *)NULL)))
      hci_devices_append(h->next, n);

    else
      h->next = n;
}

// hci_devices_free
// file main.c line 123
void hci_devices_free(struct hcicfg *h)
{
  if(!(h->next == ((struct hcicfg *)NULL)))
    hci_devices_free(h->next);

  free((void *)h);
}

// hci_test_bit
// file /usr/include/bluetooth/hci_lib.h line 183
static inline signed int hci_test_bit(signed int nr, void *addr)
{
  return (signed int)(((unsigned int *)addr)[(signed long int)(nr >> 5)] & (unsigned int)(1 << (nr & 31)));
}

// int2bd
// file misc.c line 77
signed int int2bd(unsigned long int i, struct anonymous$28 *bd)
{
  bd->b[(signed long int)0] = (unsigned char)(i & (unsigned long int)0xff);
  i = i >> 8;
  bd->b[(signed long int)1] = (unsigned char)(i & (unsigned long int)0xff);
  i = i >> 8;
  bd->b[(signed long int)2] = (unsigned char)(i & (unsigned long int)0xff);
  i = i >> 8;
  bd->b[(signed long int)3] = (unsigned char)(i & (unsigned long int)0xff);
  i = i >> 8;
  bd->b[(signed long int)4] = (unsigned char)(i & (unsigned long int)0xff);
  i = i >> 8;
  bd->b[(signed long int)5] = (unsigned char)(i & (unsigned long int)0xff);
  return 0;
}

// ll_check_got_features
// file ll.c line 535
unsigned char ll_check_got_features(struct device *dev)
{
  unsigned char ret;
  ll_lock_list();
  ret = dev->got_features;
  ll_unlock_list();
  return ret;
}

// ll_check_got_name
// file ll.c line 519
unsigned char ll_check_got_name(struct device *dev)
{
  unsigned char ret;
  ll_lock_list();
  ret = dev->got_name;
  ll_unlock_list();
  return ret;
}

// ll_check_got_oui
// file ll.c line 543
unsigned char ll_check_got_oui(struct device *dev)
{
  unsigned char ret;
  ll_lock_list();
  ret = dev->got_oui;
  ll_unlock_list();
  return ret;
}

// ll_check_got_sdp
// file ll.c line 551
unsigned char ll_check_got_sdp(struct device *dev)
{
  unsigned char ret;
  ll_lock_list();
  if(!(dev->sdp == ((char *)NULL)))
    ret = (unsigned char)1;

  else
    ret = (unsigned char)0;
  ll_unlock_list();
  return ret;
}

// ll_check_got_version
// file ll.c line 527
unsigned char ll_check_got_version(struct device *dev)
{
  unsigned char ret;
  ll_lock_list();
  ret = dev->got_version;
  ll_unlock_list();
  return ret;
}

// ll_copy_name
// file ll.c line 486
signed int ll_copy_name(struct device *td, char *name)
{
  unsigned long int i;
  if(!(td->name == ((char *)NULL)))
    free((void *)td->name);

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(name);
  i = return_value_strlen$1 + (unsigned long int)1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((i + (unsigned long int)1) * sizeof(char) /*1ul*/ );
  td->name = (char *)return_value_malloc$2;
  if(td->name == ((char *)NULL))
    return 1;

  else
  {
    strncpy(td->name, name, i);
    return 0;
  }
}

// ll_dev_count
// file ./ll.h line 126
unsigned long int ll_dev_count(void)
{
  return ll_list_len;
}

// ll_do_swap
// file ll.c line 586
void ll_do_swap(struct device *pdev, struct device *dev)
{
  struct device *tmp = dev->next;
  dev->next = tmp->next;
  tmp->next = dev;
  if(pdev == ((struct device *)NULL))
    devhead = tmp;

  else
    pdev->next = tmp;
}

// ll_find_device
// file ./ll.h line 128
struct device * ll_find_device(unsigned long int did)
{
  struct device *dev = devhead;
  _Bool tmp_if_expr$2;
  unsigned long int return_value_bd2int$1;
  do
  {
    if(!(dev == ((struct device *)NULL)))
    {
      return_value_bd2int$1=bd2int(&dev->bdaddr);
      tmp_if_expr$2 = did != return_value_bd2int$1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    dev = dev->next;
  }
  while((_Bool)1);
  return dev;
}

// ll_first
// file ./ll.h line 117
struct device * ll_first(void)
{
  struct device *d = devhead;
  return d;
}

// ll_free
// file ./ll.h line 102
signed int ll_free(void)
{
  struct device *p;
  struct device *pp;
  ll_lock_list();
  p = devhead;
  pp = (struct device *)(void *)0;
  while(!(p == ((struct device *)NULL)))
  {
    pp = p;
    p = p->next;
    if(!(pp->name == ((char *)NULL)))
      free((void *)pp->name);

    if(!(pp->sdp == ((char *)NULL)))
      free((void *)pp->sdp);

    free((void *)pp);
  }
  devhead = (struct device *)(void *)0;
  ll_unlock_list();
  pthread_mutex_destroy(&devhead_mutex);
  return 0;
}

// ll_get_last_update_time
// file ./ll.h line 127
signed int ll_get_last_update_time(unsigned long int did, signed long int *t)
{
  struct device *dev;
  if(t == ((signed long int *)NULL))
    return 1;

  else
  {
    ll_lock_list();
    dev=ll_find_device(did);
    ll_unlock_list();
    if(dev == ((struct device *)NULL))
      return 1;

    else
    {
      *t = dev->last_scanned;
      return 0;
    }
  }
}

// ll_init
// file ./ll.h line 101
signed int ll_init(void)
{
  ll_list_changed = (unsigned char)0;
  devhead = (struct device *)(void *)0;
  ll_list_len = (unsigned long int)0;
  return 0;
}

// ll_ischanged
// file ./ll.h line 111
signed int ll_ischanged(void)
{
  unsigned char i;
  ll_lock_list();
  i = ll_list_changed;
  ll_list_changed = (unsigned char)0;
  ll_unlock_list();
  return (signed int)i;
}

// ll_lock_device
// file ll.c line 143
struct device * ll_lock_device(struct anonymous$28 *bdaddr)
{
  struct device *p;
  unsigned long int dc;
  dc=bd2int(bdaddr);
  ll_lock_list();
  p=ll_find_device(dc);
  if(!(p == ((struct device *)NULL)))
  {
    if(!(p->locked == 0))
      p = (struct device *)(void *)0;

  }

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct device) /*144ul*/ );
    p = (struct device *)return_value_malloc$1;
    if(p == ((struct device *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      applog(3, "%s::malloc(): %s", (const void *)"ll_lock_device", return_value_strerror$3);
    }

    else
    {
      memset((void *)p, 0, sizeof(struct device) /*144ul*/ );
      bacpy$link1(&p->bdaddr, bdaddr);
      time(&p->first_scanned);
      p->next = devhead;
      devhead = p;
      ll_list_len = ll_list_len + 1ul;
    }
  }
  if(!(p == ((struct device *)NULL)))
  {
    p->locked = (unsigned char)1;
    p->locked_by=pthread_self();
  }

  ll_unlock_list();
  return p;
}

// ll_lock_list
// file ./ll.h line 104
signed int ll_lock_list(void)
{
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&devhead_mutex);
  return return_value_pthread_mutex_lock$1;
}

// ll_need_swap
// file ll.c line 599
signed int ll_need_swap(struct device *dev, signed int sort)
{
  signed int ret = 0;
  _Bool tmp_if_expr$1;
  if(dev == ((struct device *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (struct device *)(void *)0 == dev->next ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    if((0x01 & sort) == 0x01)
    {
      unsigned long int return_value_bd2int$2;
      return_value_bd2int$2=bd2int(&dev->bdaddr);
      unsigned long int return_value_bd2int$3;
      return_value_bd2int$3=bd2int(&dev->next->bdaddr);
      if(!(return_value_bd2int$3 >= return_value_bd2int$2))
        ret = 1;

    }

    else
      if((0x02 & sort) == 0x02)
      {
        if(!(dev->next->first_scanned >= dev->first_scanned))
          ret = 1;

      }

      else
        if((0x04 & sort) == 0x04)
        {
          if(!(dev->next->last_scanned >= dev->last_scanned))
            ret = 1;

        }

    if((0x80 & sort) == 0x80)
      ret = (signed int)!(ret != 0);

    return ret;
  }
}

// ll_next
// file ./ll.h line 118
struct device * ll_next(struct device *curr)
{
  struct device *d = curr->next;
  return d;
}

// ll_print_dev_info
// file ./ll.h line 113
signed int ll_print_dev_info(unsigned long int did, struct cbuf *cb)
{
  struct device *dev;
  unsigned long int initial;
  signed int inc;
  char tmp[32l];
  char foundby[32l];
  char *lmpi;
  struct tm fs;
  struct tm ls;
  struct rangedef *range;
  ll_lock_list();
  dev=ll_find_device(did);
  ll_unlock_list();
  const char *tmp_if_expr$4;
  char *tmp_if_expr$5;
  char *tmp_if_expr$6;
  if(dev == ((struct device *)NULL))
    return 1;

  else
  {
    range=cfg_get_range(did);
    memset((void *)&fs, 0, sizeof(struct tm) /*56ul*/ );
    localtime_r(&dev->first_scanned, &fs);
    memset((void *)&ls, 0, sizeof(struct tm) /*56ul*/ );
    localtime_r(&dev->last_scanned, &ls);
    inc=getpagesize();
    initial = cb->len;
    while((_Bool)1)
    {
      if(cb->len >= cb->sz)
      {
        cb->len = initial;
        cb->sz = cb->sz + (unsigned long int)inc;
        void *return_value_realloc$1;
        return_value_realloc$1=realloc((void *)cb->buf, sizeof(char) /*1ul*/  * cb->sz);
        cb->buf = (char *)return_value_realloc$1;
        if(cb->buf == ((char *)NULL))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          char *return_value_strerror$3;
          return_value_strerror$3=strerror(*return_value___errno_location$2);
          applog(3, "%s::realloc(): %s", (const void *)"ll_print_dev_info", return_value_strerror$3);
          return 1;
        }

      }

      ll_lock_list();
      ba2str(&dev->bdaddr, tmp);
      ba2str(&dev->bd_scan, foundby);
      if(!(dev->oui == ((const char *)NULL)))
        tmp_if_expr$4 = dev->oui;

      else
        tmp_if_expr$4 = "";
      if(!(dev->name == ((char *)NULL)))
        tmp_if_expr$5 = dev->name;

      else
        tmp_if_expr$5 = "unknown";
      if(!(range->vulns == ((char *)NULL)))
        tmp_if_expr$6 = range->vulns;

      else
        tmp_if_expr$6 = "";
      signed int return_value_snprintf$7;
      return_value_snprintf$7=snprintf(cb->buf, cb->sz, "Address:       %s\nFound by:      %s\nOUI owner:     %s\nFirst seen:    %04d/%02d/%02d %02d:%02d:%02d\nLast seen:     %04d/%02d/%02d %02d:%02d:%02d\nName:          %s\nVulnerable to: %s\nClk off:       0x%4.4x\nClass:         0x%6.6x\n               ", (const void *)tmp, (const void *)foundby, tmp_if_expr$4, fs.tm_year + 1900, fs.tm_mon + 1, fs.tm_mday, fs.tm_hour, fs.tm_min, fs.tm_sec, ls.tm_year + 1900, ls.tm_mon + 1, ls.tm_mday, ls.tm_hour, ls.tm_min, ls.tm_sec, tmp_if_expr$5, tmp_if_expr$6, dev->clk_off, dev->class);
      cb->len = (unsigned long int)return_value_snprintf$7;
      ll_unlock_list();
      if(!(cb->len >= cb->sz))
      {
        ll_lock_list();
        signed int return_value_sdp_format_classes$8;
        return_value_sdp_format_classes$8=sdp_format_classes(dev, cb->buf, (signed int)cb->sz, (signed int)cb->len);
        cb->len = (unsigned long int)return_value_sdp_format_classes$8;
        ll_unlock_list();
        if(!(cb->len >= cb->sz))
        {
          ll_lock_list();
          if(!(dev->got_version == 0))
          {
            lmpi=lmp_vertostr((unsigned int)dev->version.lmp_ver);
            const char *return_value_bt_compidtostr$9;
            return_value_bt_compidtostr$9=bt_compidtostr((signed int)dev->version.manufacturer);
            signed int return_value_snprintf$10;
            return_value_snprintf$10=snprintf(cb->buf + (signed long int)cb->len, cb->sz - cb->len, "\nHCI Version\n-----------\nLMP Version: %s (0x%x) LMP Subversion: 0x%x\nManufacturer: %s (%d)\n", lmpi != ((char *)NULL) ? lmpi : "", dev->version.lmp_ver, dev->version.lmp_subver, return_value_bt_compidtostr$9, dev->version.manufacturer);
            cb->len = cb->len + (unsigned long int)return_value_snprintf$10;
            if(!(lmpi == ((char *)NULL)))
              free((void *)lmpi);

            lmpi = (char *)(void *)0;
          }

          else
          {
            signed int return_value_snprintf$11;
            return_value_snprintf$11=snprintf(cb->buf + (signed long int)cb->len, cb->sz - cb->len, "\nHCI Version\n-----------\nLMP Version:  n/a (n/a) LMP Subversion: n/a\nManufacturer: n/a (n/a)\n");
            cb->len = cb->len + (unsigned long int)return_value_snprintf$11;
          }
          ll_unlock_list();
          if(!(cb->len >= cb->sz))
          {
            ll_lock_list();
            if(!(dev->got_features == 0))
            {
              lmpi=lmp_featurestostr(dev->features, "    ", 70);
              signed int return_value_snprintf$12;
              return_value_snprintf$12=snprintf(cb->buf + (signed long int)cb->len, cb->sz - cb->len, "\nHCI Features\n------------\nFeatures:     0x%2.2x 0x%2.2x 0x%2.2x 0x%2.2x\n%s\n", dev->features[(signed long int)0], dev->features[(signed long int)1], dev->features[(signed long int)2], dev->features[(signed long int)3], lmpi != ((char *)NULL) ? lmpi : "");
              cb->len = cb->len + (unsigned long int)return_value_snprintf$12;
              if(!(lmpi == ((char *)NULL)))
                free((void *)lmpi);

              lmpi = (char *)(void *)0;
            }

            else
            {
              signed int return_value_snprintf$13;
              return_value_snprintf$13=snprintf(cb->buf + (signed long int)cb->len, cb->sz - cb->len, "\nHCI Features\n------------\nFeatures:     n/a n/a n/a n/a\n");
              cb->len = cb->len + (unsigned long int)return_value_snprintf$13;
            }
            ll_unlock_list();
            if(!(cb->len >= cb->sz))
            {
              ll_lock_list();
              if(!(dev->sdp == ((char *)NULL)))
              {
                signed int return_value_snprintf$14;
                return_value_snprintf$14=snprintf(cb->buf + (signed long int)cb->len, cb->sz - cb->len, "\nSDP probe\n---------\n%s", dev->sdp);
                cb->len = cb->len + (unsigned long int)return_value_snprintf$14;
              }

              ll_unlock_list();
              if(!(cb->len >= cb->sz))
                break;

            }

          }

        }

      }

    }
    return 0;
  }
}

// ll_print_dev_line
// file ./ll.h line 112
signed int ll_print_dev_line(struct device *item, unsigned long int *id, char *s, signed int len)
{
  signed int i;
  struct tm tm;
  char tmp[32l];
  char *tmp_if_expr$1;
  if(s == ((char *)NULL) || item == ((struct device *)NULL))
    return 0;

  else
  {
    *id=bd2int(&item->bdaddr);
    localtime_r(&item->last_scanned, &tm);
    tm.tm_year = tm.tm_year + 1900;
    tm.tm_mon = tm.tm_mon + 1;
    ba2str(&item->bdaddr, tmp);
    if(!(item->name == ((char *)NULL)))
      tmp_if_expr$1 = item->name;

    else
      tmp_if_expr$1 = "(unknown)";
    i=snprintf(s, (unsigned long int)len, "%04d/%02d/%02d %02d:%02d:%02d  %s  0x%4.4x   0x%6.6x  %s", tm.tm_year, tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, (const void *)tmp, item->clk_off, item->class, tmp_if_expr$1);
    for( ; !(i >= len); i = i + 1)
      s[(signed long int)i] = (char)32;
    s[(signed long int)len] = (char)0;
    return 0;
  }
}

// ll_print_item
// file ll.c line 218
signed int ll_print_item(struct device *item)
{
  char tmp[32l];
  ba2str(&item->bdaddr, tmp);
  applog(6, "Found Addr: %s Name: \"%s\" Clk off: 0x%4.4x Class: 0x%6.6x", (const void *)tmp, item->name, item->clk_off, item->class);
  return 0;
}

// ll_print_timestamp
// file ./ll.h line 114
signed int ll_print_timestamp(struct device *dev, struct cbuf *cb)
{
  signed int inc;
  unsigned long int initial;
  struct tm ls;
  memset((void *)&ls, 0, sizeof(struct tm) /*56ul*/ );
  ll_lock_list();
  localtime_r(&dev->last_scanned, &ls);
  ll_unlock_list();
  inc=getpagesize();
  initial = cb->len;
  while((_Bool)1)
  {
    if(cb->len >= cb->sz)
    {
      cb->len = initial;
      cb->sz = cb->sz + (unsigned long int)inc;
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)cb->buf, sizeof(char) /*1ul*/  * cb->sz);
      cb->buf = (char *)return_value_realloc$1;
      if(cb->buf == ((char *)NULL))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        char *return_value_strerror$3;
        return_value_strerror$3=strerror(*return_value___errno_location$2);
        applog(3, "%s::realloc(): %s", (const void *)"ll_print_timestamp", return_value_strerror$3);
        return 1;
      }

    }

    signed int return_value_snprintf$4;
    return_value_snprintf$4=snprintf(cb->buf, cb->sz, "%04d/%02d/%02d %02d:%02d:%02d\n", ls.tm_year + 1900, ls.tm_mon + 1, ls.tm_mday, ls.tm_hour, ls.tm_min, ls.tm_sec);
    cb->len = (unsigned long int)return_value_snprintf$4;
    if(!(cb->len >= cb->sz))
      break;

  }
  return 0;
}

// ll_save_summary
// file ./ll.h line 130
signed int ll_save_summary(const char *filename)
{
  struct device *dev;
  struct tm f;
  struct tm l;
  char tmp[32l];
  signed long int now;
  signed int return_value_log_sum_open$2;
  return_value_log_sum_open$2=log_sum_open(filename);
  if(!(return_value_log_sum_open$2 == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 17)
      screen_log("File already exists");

    else
      screen_log("Unable to save, please check the logfile");
    return 1;
  }

  time(&now);
  localtime_r(&now, &f);
  f.tm_year = f.tm_year + 1900;
  f.tm_mon = f.tm_mon + 1;
  summary("Summary saved at %04d/%02d/%02d %02d:%02d:%02d", f.tm_year, f.tm_mon, f.tm_mday, f.tm_hour, f.tm_min, f.tm_sec);
  ll_lock_list();
  dev = devhead;
  char *tmp_if_expr$3;
  for( ; !(dev == ((struct device *)NULL)); dev = dev->next)
    if(dev->last_scanned >= ll_last_summary)
    {
      localtime_r(&dev->first_scanned, &f);
      localtime_r(&dev->last_scanned, &l);
      f.tm_year = f.tm_year + 1900;
      l.tm_year = l.tm_year + 1900;
      f.tm_mon = f.tm_mon + 1;
      l.tm_mon = l.tm_mon + 1;
      ba2str(&dev->bdaddr, tmp);
      if(!(dev->name == ((char *)NULL)))
        tmp_if_expr$3 = dev->name;

      else
        tmp_if_expr$3 = "";
      summary("%04d/%02d/%02d %02d:%02d:%02d,%04d/%02d/%02d %02d:%02d:%02d,%s,%s", f.tm_year, f.tm_mon, f.tm_mday, f.tm_hour, f.tm_min, f.tm_sec, l.tm_year, l.tm_mon, l.tm_mday, l.tm_hour, l.tm_min, l.tm_sec, (const void *)tmp, tmp_if_expr$3);
    }

  time(&ll_last_summary);
  ll_unlock_list();
  log_sum_close();
  return 0;
}

// ll_sortlist
// file ./ll.h line 131
signed int ll_sortlist(signed int sort)
{
  struct device *dev;
  struct device *pdev;
  signed int swaps;
  signed int return_value_ll_need_swap$1;
  if(sort == 0x00 || sort == 0x80)
    return 0;

  else
  {
    do
    {
      pdev = (struct device *)(void *)0;
      swaps = 0;
      dev = devhead;
      for( ; !(dev == ((struct device *)NULL)); dev = dev->next)
      {
        return_value_ll_need_swap$1=ll_need_swap(dev, sort);
        if(!(return_value_ll_need_swap$1 == 0))
        {
          ll_do_swap(pdev, dev);
          swaps = swaps + 1;
        }

        pdev = dev;
      }
    }
    while(!(swaps == 0));
    return 0;
  }
}

// ll_unlock_device
// file ll.c line 186
signed int ll_unlock_device(struct device *dev)
{
  unsigned long int return_value_pthread_self$1;
  if(dev == ((struct device *)NULL))
    return 1;

  else
  {
    ll_lock_list();
    if(!(dev->locked == 0))
    {
      return_value_pthread_self$1=pthread_self();
      if(dev->locked_by == return_value_pthread_self$1)
      {
        dev->locked = (unsigned char)0;
        dev->locked_by = (unsigned long int)0;
        if(!(dev->updated == 0))
        {
          ll_list_changed = (unsigned char)1;
          dev->updated = (unsigned char)0;
        }

      }

    }

    ll_unlock_list();
    return 0;
  }
}

// ll_unlock_list
// file ./ll.h line 105
signed int ll_unlock_list(void)
{
  signed int return_value_pthread_mutex_unlock$1;
  return_value_pthread_mutex_unlock$1=pthread_mutex_unlock(&devhead_mutex);
  return return_value_pthread_mutex_unlock$1;
}

// log_close
// file ./log.h line 33
signed int log_close(void)
{
  if(!(log_fp == ((struct _IO_FILE *)NULL)))
  {
    applog(6, "btscanner shutting down");
    fflush(log_fp);
    fclose(log_fp);
    log_fp = (struct _IO_FILE *)(void *)0;
    log_fd = -1;
  }

  return 0;
}

// log_init
// file ./log.h line 32
signed int log_init(void)
{
  const char *s;
  s=cfg_log_filename();
  if(s == ((const char *)NULL))
  {
    fprintf(stderr, "%s(): NULL logfile\n", (const void *)"log_init");
    return 1;
  }

  else
  {
    log_fd=open(s, 01 | 0100 | 02000, 0400 | 0200);
    if(log_fd == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      fprintf(stderr, "%s::open(): %s\n", (const void *)"log_init", return_value_strerror$2);
      return 1;
    }

    log_fp=fdopen(log_fd, "w");
    if(log_fp == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      fprintf(stderr, "%s::open(): %s\n", (const void *)"log_init", return_value_strerror$4);
      return 1;
    }

    applog(6, "btscanner starting");
    return 0;
  }
}

// log_sum_close
// file ./log.h line 38
signed int log_sum_close(void)
{
  if(!(log_sum_fp == ((struct _IO_FILE *)NULL)))
  {
    fflush(log_sum_fp);
    fclose(log_sum_fp);
    log_sum_fp = (struct _IO_FILE *)(void *)0;
    log_sum_fd = -1;
  }

  return 0;
}

// log_sum_open
// file ./log.h line 36
signed int log_sum_open(const char *filename)
{
  if(filename == ((const char *)NULL))
    return 1;

  else
  {
    log_sum_fd=open(filename, 01 | 0100 | 0200, 0400 | 0200);
    if(log_sum_fd == -1)
      return 1;

    else
    {
      log_sum_fp=fdopen(log_sum_fd, "w");
      if(log_sum_fp == ((struct _IO_FILE *)NULL))
        return 1;

      else
        return 0;
    }
  }
}

// main
// file main.c line 220
signed int main(signed int argc, char **argv)
{
  signed int opt;
  signed int ctl;
  struct sigaction act;
  struct anonymous$25 sset;
  char *cfg_filename = (char *)(void *)0;
  opterr = 0;
  do
  {
    opt=getopt_long(argc, argv, "+hc:r", main_options, (signed int *)(void *)0);
    if(opt == -1)
      break;

    switch(opt)
    {
      case 99:
      {
        cfg_filename = optarg;
        break;
      }
      case 104:
        opterr = opterr + 1;
    }
  }
  while((_Bool)1);
  if(!(opterr == 0))
  {
    usage(argv[(signed long int)0]);
    exit(0);
  }

  signed int return_value_cfg_parsefile$1;
  return_value_cfg_parsefile$1=cfg_parsefile(cfg_filename);
  if(!(return_value_cfg_parsefile$1 == 0))
  {
    fprintf(stderr, "Config file validation error\n");
    exit(1);
  }

  signed int return_value_log_init$2;
  return_value_log_init$2=log_init();
  if(!(return_value_log_init$2 == 0))
  {
    fprintf(stderr, "Logging failed to initialise\n");
    exit(1);
  }

  memset((void *)&sset, 0, sizeof(struct anonymous$25) /*128ul*/ );
  sigfillset(&sset);
  sigdelset(&sset, 9);
  sigdelset(&sset, 19);
  sigdelset(&sset, 15);
  sigdelset(&sset, 2);
  sigdelset(&sset, 11);
  sigdelset(&sset, 28);
  signed int return_value_sigprocmask$5;
  return_value_sigprocmask$5=sigprocmask(2, &sset, (struct anonymous$25 *)(void *)0);
  if(return_value_sigprocmask$5 == -1)
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    applog(3, "%s::sigprocmask(): %s", (const void *)"main", return_value_strerror$4);
    exit(0);
  }

  signed int return_value_pthread_sigmask$8;
  return_value_pthread_sigmask$8=pthread_sigmask(2, &sset, (struct anonymous$25 *)(void *)0);
  if(!(return_value_pthread_sigmask$8 == 0))
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    char *return_value_strerror$7;
    return_value_strerror$7=strerror(*return_value___errno_location$6);
    applog(3, "%s::sigprocmask(): %s", (const void *)"main", return_value_strerror$7);
    exit(0);
  }

  memset((void *)&act, 0, sizeof(struct sigaction) /*152ul*/ );
  act.__sigaction_handler.sa_handler = handlesig;
  sigfillset(&act.sa_mask);
  sigdelset(&act.sa_mask, 9);
  sigdelset(&act.sa_mask, 19);
  signed int return_value_sigaction$11;
  return_value_sigaction$11=sigaction(15, &act, (struct sigaction *)(void *)0);
  if(return_value_sigaction$11 == -1)
  {
    signed int *return_value___errno_location$9;
    return_value___errno_location$9=__errno_location();
    char *return_value_strerror$10;
    return_value_strerror$10=strerror(*return_value___errno_location$9);
    applog(3, "%s::sigaction(): %s", (const void *)"main", return_value_strerror$10);
    exit(0);
  }

  signed int return_value_sigaction$14;
  return_value_sigaction$14=sigaction(2, &act, (struct sigaction *)(void *)0);
  if(return_value_sigaction$14 == -1)
  {
    signed int *return_value___errno_location$12;
    return_value___errno_location$12=__errno_location();
    char *return_value_strerror$13;
    return_value_strerror$13=strerror(*return_value___errno_location$12);
    applog(3, "%s::sigaction(): %s", (const void *)"main", return_value_strerror$13);
    exit(0);
  }

  act.__sigaction_handler.sa_handler = dointerrupt;
  signed int return_value_sigaction$17;
  return_value_sigaction$17=sigaction(10, &act, (struct sigaction *)(void *)0);
  if(return_value_sigaction$17 == -1)
  {
    signed int *return_value___errno_location$15;
    return_value___errno_location$15=__errno_location();
    char *return_value_strerror$16;
    return_value_strerror$16=strerror(*return_value___errno_location$15);
    applog(3, "%s::sigaction(): %s", (const void *)"main", return_value_strerror$16);
    exit(0);
  }

  const char *return_value_cfg_oui_filename$18;
  return_value_cfg_oui_filename$18=cfg_oui_filename();
  signed int return_value_ouidb_init$19;
  return_value_ouidb_init$19=ouidb_init(return_value_cfg_oui_filename$18);
  if(!(return_value_ouidb_init$19 == 0))
    exit(0);

  ll_init();
  ctl=socket(31, 3, 1);
  if(!(ctl >= 0))
  {
    signed int *return_value___errno_location$20;
    return_value___errno_location$20=__errno_location();
    char *return_value_strerror$21;
    return_value_strerror$21=strerror(*return_value___errno_location$20);
    applog(3, "%s::socket(): %s", (const void *)"main", return_value_strerror$21);
    exit(0);
  }

  hcihead = (struct hcicfg *)(void *)0;
  signed int return_value_get_max_devices$22;
  return_value_get_max_devices$22=get_max_devices(ctl);
  if(!(return_value_get_max_devices$22 == 0))
    fprintf(stderr, "No Bluetooth devices available\n");

  else
  {
    screen_on();
    screen_run();
    screen_off();
  }

btscanner_leave:
  ;
  if(!(hcihead == ((struct hcicfg *)NULL)))
    hci_devices_free(hcihead);

  if(!(ctl == -1))
  {
    shutdown(ctl, 2);
    close(ctl);
  }

  ouidb_close();
  ll_free();
  log_close();
  cfg_cleanup();
  exit(0);
}

// ouidb_close
// file ./oui.h line 34
signed int ouidb_close(void)
{
  struct oui *curr;
  struct oui *next;
  curr = ouihead;
  for( ; !(curr == ((struct oui *)NULL)); curr = next)
  {
    next = curr->next;
    free((void *)curr->name);
    free((void *)curr);
  }
  ouihead = (struct oui *)(void *)0;
  return 0;
}

// ouidb_init
// file ./oui.h line 32
signed int ouidb_init(const char *filename)
{
  struct _IO_FILE *f;
  char buf[128l];
  char *s;
  struct re_pattern_buffer preg;
  struct anonymous$23 pmatch[4l];
  signed int i;
  struct oui *ouitail;
  struct oui *ouinew;
  ouitail = (struct oui *)(void *)0;
  ouihead = ouitail;
  i=regcomp(&preg, "^([0-9a-zA-Z]{6}) (.*)[\n\r \t]+$", 1);
  char *return_value_fgets$3;
  if(!(i == 0))
  {
    fprintf(stderr, "Unable to compile re: \"%s\"\n", (const void *)"^([0-9a-zA-Z]{6}) (.*)[\n\r \t]+$");
    return 1;
  }

  else
  {
    fprintf(stdout, "Opening the OUI database\n");
    f=fopen(filename, "r");
    if(f == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      fprintf(stdout, "Error opening the OUI database: %s\n", return_value_strerror$2);
      return 1;
    }

    fprintf(stdout, "Reading the OUI database\n");
    do
    {
      return_value_fgets$3=fgets(buf, 128, f);
      if(return_value_fgets$3 == ((char *)NULL))
        break;

      signed int return_value_regexec$4;
      return_value_regexec$4=regexec(&preg, buf, (unsigned long int)4, pmatch, 0);
      if(return_value_regexec$4 == 0)
      {
        buf[(signed long int)pmatch[(signed long int)1].rm_eo] = (char)0;
        buf[(signed long int)pmatch[(signed long int)2].rm_eo] = (char)0;
        void *return_value_malloc$5;
        return_value_malloc$5=malloc(sizeof(struct oui) /*24ul*/ );
        ouinew = (struct oui *)return_value_malloc$5;
        if(ouinew == ((struct oui *)NULL))
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          char *return_value_strerror$7;
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          fprintf(stderr, "%s:malloc(): %s\n", (const void *)"ouidb_init", return_value_strerror$7);
          return 1;
        }

        memset((void *)ouinew, 0, sizeof(struct oui) /*24ul*/ );
        signed long int return_value_strtol$8;
        return_value_strtol$8=strtol(buf + (signed long int)pmatch[(signed long int)1].rm_so, (char **)(void *)0, 16);
        ouinew->id = (unsigned int)return_value_strtol$8;
        i = pmatch[(signed long int)2].rm_eo - pmatch[(signed long int)2].rm_so;
        void *return_value_malloc$9;
        return_value_malloc$9=malloc(sizeof(char) /*1ul*/  * (unsigned long int)(i + 1));
        s = (char *)return_value_malloc$9;
        if(s == ((char *)NULL))
        {
          signed int *return_value___errno_location$10;
          return_value___errno_location$10=__errno_location();
          char *return_value_strerror$11;
          return_value_strerror$11=strerror(*return_value___errno_location$10);
          fprintf(stderr, "%s:malloc(): %s\n", (const void *)"ouidb_init", return_value_strerror$11);
          return 1;
        }

        strncpy(s, buf + (signed long int)pmatch[(signed long int)2].rm_so, (unsigned long int)i);
        s[(signed long int)i] = (char)0;
        ouinew->name = s;
        if(!(ouitail == ((struct oui *)NULL)))
          ouitail->next = ouinew;

        else
          ouihead = ouinew;
        ouitail = ouinew;
      }

    }
    while((_Bool)1);
    fprintf(stdout, "Finished reading the OUI database\n");
    fclose(f);
    regfree(&preg);
    return 0;
  }
}

// ouidb_query
// file oui.c line 167
char * ouidb_query(struct anonymous$28 *ba)
{
  struct oui *curr;
  unsigned int id;
  id=ba2int(ba);
  curr = ouihead;
  for( ; !(curr == ((struct oui *)NULL)); curr = curr->next)
    if(curr->id == id)
      return curr->name;

  return (char *)(void *)0;
}

// print_access_protos
// file sdp.c line 446
void print_access_protos(void *value, void *userData)
{
  struct _sdp_list *protDescSeq = (struct _sdp_list *)value;
  sdp_list_foreach(protDescSeq, print_service_desc, userData);
}

// print_lang_attr
// file sdp.c line 318
void print_lang_attr(void *value, void *user)
{
  struct anonymous$7 *lang = (struct anonymous$7 *)value;
  struct cbuf *str = (struct cbuf *)user;
  if(!(str->len >= str->sz))
  {
    signed int return_value_snprintf$1;
    return_value_snprintf$1=snprintf(str->buf + (signed long int)str->len, str->sz, "  code_ISO639: 0x%02x\n", lang->code_ISO639);
    str->len = str->len + (unsigned long int)return_value_snprintf$1;
    if(!(str->len >= str->sz))
    {
      signed int return_value_snprintf$2;
      return_value_snprintf$2=snprintf(str->buf + (signed long int)str->len, str->sz, "  encoding:    0x%02x\n", lang->encoding);
      str->len = str->len + (unsigned long int)return_value_snprintf$2;
      if(!(str->len >= str->sz))
      {
        signed int return_value_snprintf$3;
        return_value_snprintf$3=snprintf(str->buf + (signed long int)str->len, str->sz, "  base_offset: 0x%02x\n", lang->base_offset);
        str->len = str->len + (unsigned long int)return_value_snprintf$3;
      }

    }

  }

}

// print_profile_desc
// file sdp.c line 452
void print_profile_desc(void *value, void *userData)
{
  struct cbuf *str = (struct cbuf *)userData;
  struct anonymous$8 *desc = (struct anonymous$8 *)value;
  char pstr[28l];
  if(!(str->len >= str->sz))
  {
    sdp_uuid2strn(&desc->uuid, UUID_str, (unsigned long int)37);
    sdp_profile_uuid2strn(&desc->uuid, pstr, (unsigned long int)28);
    signed int return_value_snprintf$1;
    return_value_snprintf$1=snprintf(str->buf + (signed long int)str->len, str->sz, "  \"%s\" (0x%s)\n", (const void *)pstr, (const void *)UUID_str);
    str->len = str->len + (unsigned long int)return_value_snprintf$1;
    if(!(str->len >= str->sz))
    {
      if(!(desc->version == 0))
      {
        signed int return_value_snprintf$2;
        return_value_snprintf$2=snprintf(str->buf + (signed long int)str->len, str->sz, "    Version: 0x%04x\n", desc->version);
        str->len = str->len + (unsigned long int)return_value_snprintf$2;
        if(str->len >= str->sz)
          goto __CPROVER_DUMP_L5;

      }

    }

  }


__CPROVER_DUMP_L5:
  ;
}

// print_service_class
// file sdp.c line 429
static void print_service_class(void *value, void *userData)
{
  char ServiceClassUUID_str[28l];
  struct anonymous$1 *uuid = (struct anonymous$1 *)value;
  struct cbuf *str = (struct cbuf *)userData;
  if(!(str->len >= str->sz))
  {
    sdp_uuid2strn(uuid, UUID_str, (unsigned long int)37);
    sdp_svclass_uuid2strn(uuid, ServiceClassUUID_str, (unsigned long int)28);
    signed int return_value_snprintf$1;
    return_value_snprintf$1=snprintf(str->buf + (signed long int)str->len, str->sz, "  \"%s\" (0x%s)\n", (const void *)ServiceClassUUID_str, (const void *)UUID_str);
    str->len = str->len + (unsigned long int)return_value_snprintf$1;
  }

}

// print_service_desc
// file sdp.c line 337
static void print_service_desc(void *value, void *user)
{
  char uustr[8l];
  struct sdp_data_struct *p = (struct sdp_data_struct *)value;
  struct sdp_data_struct *s;
  signed int i = 0;
  signed int proto = 0;
  struct cbuf *str = (struct cbuf *)user;
  signed int return_value_snprintf$1;
  signed int return_value_snprintf$4;
  signed int return_value_snprintf$5;
  signed int return_value_snprintf$6;
  signed int return_value_snprintf$7;
  signed int return_value_snprintf$8;
  signed int return_value_snprintf$11;
  if(!(str->len >= str->sz))
    for( ; !(p == ((struct sdp_data_struct *)NULL)); i = i + 1)
    {
      switch((signed int)p->dtd)
      {
        case 0x19:

        case 0x1A:

        case 0x1C:
        {
          sdp_uuid2strn(&p->val.uuid, UUID_str, (unsigned long int)37);
          sdp_proto_uuid2strn(&p->val.uuid, uustr, sizeof(char [8l]) /*8ul*/ );
          proto=sdp_uuid_to_proto(&p->val.uuid);
          return_value_snprintf$1=snprintf(str->buf + (signed long int)str->len, str->sz, "  \"%s\" (0x%s)\n", (const void *)uustr, (const void *)UUID_str);
          str->len = str->len + (unsigned long int)return_value_snprintf$1;
          if(str->len >= str->sz)
            goto __CPROVER_DUMP_L33;

          break;
        }
        case 0x08:
        {
          if(proto == 0x0003)
          {
            signed int return_value_snprintf$2;
            return_value_snprintf$2=snprintf(str->buf + (signed long int)str->len, str->sz, "    Channel: %d\n", p->val.uint8);
            str->len = str->len + (unsigned long int)return_value_snprintf$2;
          }

          else
          {
            signed int return_value_snprintf$3;
            return_value_snprintf$3=snprintf(str->buf + (signed long int)str->len, str->sz, "    uint8: 0x%x\n", p->val.uint8);
            str->len = str->len + (unsigned long int)return_value_snprintf$3;
          }
          if(str->len >= str->sz)
            goto __CPROVER_DUMP_L33;

          break;
        }
        case 0x09:
        {
          if(proto == 0x0100)
          {
            if(i == 1)
            {
              return_value_snprintf$4=snprintf(str->buf + (signed long int)str->len, str->sz, "    PSM: %d\n", p->val.uint16);
              str->len = str->len + (unsigned long int)return_value_snprintf$4;
            }

            else
            {
              return_value_snprintf$5=snprintf(str->buf + (signed long int)str->len, str->sz, "    Version: 0x%04x\n", p->val.uint16);
              str->len = str->len + (unsigned long int)return_value_snprintf$5;
            }
          }

          else
            if(proto == 0x000f)
            {
              if(i == 1)
              {
                return_value_snprintf$6=snprintf(str->buf + (signed long int)str->len, str->sz, "    Version: 0x%04x\n", p->val.uint16);
                str->len = str->len + (unsigned long int)return_value_snprintf$6;
              }

              else
              {
                return_value_snprintf$7=snprintf(str->buf + (signed long int)str->len, str->sz, "    uint16: 0x%x\n", p->val.uint16);
                str->len = str->len + (unsigned long int)return_value_snprintf$7;
              }
            }

            else
            {
              return_value_snprintf$8=snprintf(str->buf + (signed long int)str->len, str->sz, "    uint16: 0x%x\n", p->val.uint16);
              str->len = str->len + (unsigned long int)return_value_snprintf$8;
            }
          if(str->len >= str->sz)
            goto __CPROVER_DUMP_L33;

          break;
        }
        case 0x36:
        {
          strncpy(str->buf + (signed long int)str->len, "    SEQ16:", str->sz - str->len);
          str->len = str->len + (unsigned long int)10;
          if(str->len >= str->sz)
            goto __CPROVER_DUMP_L33;

          s = p->val.dataseq;
          for( ; !(s == ((struct sdp_data_struct *)NULL)); s = s->next)
          {
            signed int return_value_snprintf$9;
            return_value_snprintf$9=snprintf(str->buf + (signed long int)str->len, str->sz, " %x", s->val.uint16);
            str->len = str->len + (unsigned long int)return_value_snprintf$9;
            if(str->len >= str->sz)
              goto __CPROVER_DUMP_L33;

          }
          strncpy(str->buf + (signed long int)str->len, "\n", str->sz - str->len);
          str->len = str->len + 1ul;
          if(str->len >= str->sz)
            goto __CPROVER_DUMP_L33;

          break;
        }
        case 0x35:
        {
          strncpy(str->buf + (signed long int)str->len, "    SEQ8:", str->sz - str->len);
          str->len = str->len + (unsigned long int)9;
          if(str->len >= str->sz)
            goto __CPROVER_DUMP_L33;

          s = p->val.dataseq;
          for( ; !(s == ((struct sdp_data_struct *)NULL)); s = s->next)
          {
            signed int return_value_snprintf$10;
            return_value_snprintf$10=snprintf(str->buf + (signed long int)str->len, str->sz, " %x", s->val.uint8);
            str->len = str->len + (unsigned long int)return_value_snprintf$10;
            if(str->len >= str->sz)
              goto __CPROVER_DUMP_L33;

          }
          strncpy(str->buf + (signed long int)str->len, "\n", str->sz - str->len);
          str->len = str->len + 1ul;
          if(str->len >= str->sz)
            goto __CPROVER_DUMP_L33;

          break;
        }
        default:
        {
          return_value_snprintf$11=snprintf(str->buf + (signed long int)str->len, str->sz, "    FIXME: dtd=0%x\n", p->dtd);
          str->len = str->len + (unsigned long int)return_value_snprintf$11;
          if(str->len >= str->sz)
            goto __CPROVER_DUMP_L33;

        }
      }
      p = p->next;
    }


__CPROVER_DUMP_L33:
  ;
}

// scan_bf_getcurr
// file scan.c line 753
signed int scan_bf_getcurr(struct anonymous$28 *bd)
{
  signed int ret;
  pthread_mutex_lock(&scan_bf_mutex);
  if(!(scan_bf_end >= scan_bf_curr))
    ret = 1;

  else
  {
    int2bd(scan_bf_curr, bd);
    ret = 0;
  }
  pthread_mutex_unlock(&scan_bf_mutex);
  return ret;
}

// scan_bf_getnext
// file scan.c line 728
signed int scan_bf_getnext(struct anonymous$28 *bd)
{
  signed int ret;
  double d;
  pthread_mutex_lock(&scan_bf_mutex);
  if(!(scan_bf_end >= scan_bf_curr))
  {
    ret = 1;
    scan_bf_perc = 100;
  }

  else
  {
    int2bd(scan_bf_curr, bd);
    if(scan_bf_end == scan_bf_start)
      d = (double)1;

    else
      d = (double)(scan_bf_curr - scan_bf_start) / (double)(scan_bf_end - scan_bf_start);
    d = d * (double)100;
    scan_bf_perc = (signed int)d;
    ret = 0;
    scan_bf_curr = scan_bf_curr + 1ul;
  }
  pthread_mutex_unlock(&scan_bf_mutex);
  return ret;
}

// scan_bf_getpercentage
// file scan.c line 766
signed int scan_bf_getpercentage(void)
{
  signed int ret;
  pthread_mutex_lock(&scan_bf_mutex);
  ret = scan_bf_perc;
  pthread_mutex_unlock(&scan_bf_mutex);
  return ret;
}

// scan_bf_init
// file ./scan.h line 36
signed int scan_bf_init(struct anonymous$28 *start, struct anonymous$28 *end)
{
  scan_bf_curr=bd2int(start);
  scan_bf_start = scan_bf_curr;
  scan_bf_end=bd2int(end);
  scan_bf_perc = 0;
  return 0;
}

// scan_inquiry
// file scan.c line 271
signed int scan_inquiry(struct hcicfg *hci)
{
  signed int num_rsp;
  signed int length;
  signed int flags;
  signed int dd;
  signed int i;
  signed int cc;
  signed int rv;
  struct anonymous$36 *info = (struct anonymous$36 *)(void *)0;
  struct device *dev;
  char buf[512l];
  char tmp[32l];
  unsigned short int handle;
  struct search_context context;
  struct rangedef *range;
  unsigned char do_store;
  unsigned char uval;
  signed char val;
  length = 8;
  flags = 0x0001;
  num_rsp = 10;
  cc = 0;
  do_store = (unsigned char)0;
  num_rsp=hci_inquiry(hci->id, length, num_rsp, (const unsigned char *)(void *)0, &info, (signed long int)flags);
  unsigned char return_value_ll_check_got_name$3;
  unsigned char return_value_ll_check_got_version$10;
  unsigned char return_value_ll_check_got_features$12;
  unsigned char return_value_ll_check_got_sdp$19;
  if(!(num_rsp >= 0))
    return -1;

  else
  {
    dd=hci_open_dev(hci->id);
    if(!(dd >= 0))
      return -1;

    else
    {
      i = 0;
      for( ; !(bts_run_scan == 0) && !(i >= num_rsp); cc = 0)
      {
        unsigned long int return_value_bd2int$1;
        return_value_bd2int$1=bd2int(&(info + (signed long int)i)->bdaddr);
        range=cfg_get_range(return_value_bd2int$1);
        if(!(range == ((struct rangedef *)NULL)))
        {
          ba2str(&(info + (signed long int)i)->bdaddr, tmp);
          screen_log("Found device %s", (const void *)tmp);
          dev=ll_lock_device(&(info + (signed long int)i)->bdaddr);
          if(!(dev == ((struct device *)NULL)))
          {
            ll_lock_list();
            dev->clk_off = (info + (signed long int)i)->clock_offset;
            if(dev->got_class == 0)
            {
              dev->class = (unsigned int)((signed int)(info + (signed long int)i)->dev_class[(signed long int)2] << 16);
              dev->class = dev->class | (unsigned int)((signed int)(info + (signed long int)i)->dev_class[(signed long int)1] << 8);
              dev->class = dev->class | (unsigned int)(info + (signed long int)i)->dev_class[(signed long int)0];
              dev->got_class = (unsigned char)1;
              do_store = (unsigned char)1;
            }

            dev->updated = (unsigned char)1;
            time(&dev->last_scanned);
            bacpy$link2(&dev->bd_scan, &hci->bdaddr);
            dev->scan_count = dev->scan_count + 1u;
            ll_unlock_list();
            if(!((0x01 & (signed int)range->sf) == 0))
            {
              return_value_ll_check_got_name$3=ll_check_got_name(dev);
              if(return_value_ll_check_got_name$3 == 0)
              {
                signed int return_value_hci_read_remote_name$2;
                return_value_hci_read_remote_name$2=hci_read_remote_name(dd, &(info + (signed long int)i)->bdaddr, (signed int)((unsigned long int)512 * sizeof(char) /*1ul*/ ), buf, 100000);
                if(return_value_hci_read_remote_name$2 == 0)
                {
                  ll_lock_list();
                  ll_copy_name(dev, buf);
                  dev->got_name = (unsigned char)1;
                  do_store = (unsigned char)1;
                  ll_unlock_list();
                }

              }

            }

            unsigned char return_value_ll_check_got_oui$4;
            return_value_ll_check_got_oui$4=ll_check_got_oui(dev);
            if(return_value_ll_check_got_oui$4 == 0)
            {
              ll_lock_list();
              dev->oui=ouidb_query(&dev->bdaddr);
              dev->got_oui = (unsigned char)1;
              ll_unlock_list();
            }

            if(!((-63 & (signed int)range->sf) == 0))
            {
              handle=find_conn(hci->id, &dev->bdaddr);
              if(handle == 65535)
              {
                signed int *return_value___errno_location$5;
                return_value___errno_location$5=__errno_location();
                if(!(*return_value___errno_location$5 == 0))
                  break;

                cc = 1;
                signed int return_value_hci_create_connection$8;
                return_value_hci_create_connection$8=hci_create_connection(dd, &dev->bdaddr, (unsigned short int)(0x0008 | 0x0010), (unsigned short int)0, (unsigned char)0, &handle, 25000);
                if(!(return_value_hci_create_connection$8 >= 0))
                {
                  signed int *return_value___errno_location$6;
                  return_value___errno_location$6=__errno_location();
                  char *return_value_strerror$7;
                  return_value_strerror$7=strerror(*return_value___errno_location$6);
                  applog(4, "%s::hci_create_connection(): Cant create: %s", (const void *)"scan_inquiry", return_value_strerror$7);
                  goto scan_inquiry_nextdev;
                }

              }

              if(!((0x02 & (signed int)range->sf) == 0))
              {
                return_value_ll_check_got_version$10=ll_check_got_version(dev);
                if(return_value_ll_check_got_version$10 == 0)
                {
                  signed int return_value_hci_read_remote_version$9;
                  return_value_hci_read_remote_version$9=hci_read_remote_version(dd, handle, &dev->version, 20000);
                  if(return_value_hci_read_remote_version$9 == 0)
                  {
                    ll_lock_list();
                    dev->got_version = (unsigned char)1;
                    do_store = (unsigned char)1;
                    ll_unlock_list();
                  }

                }

              }

              if(!((0x02 & (signed int)range->sf) == 0))
              {
                return_value_ll_check_got_features$12=ll_check_got_features(dev);
                if(return_value_ll_check_got_features$12 == 0)
                {
                  signed int return_value_hci_read_remote_features$11;
                  return_value_hci_read_remote_features$11=hci_read_remote_features(dd, handle, dev->features, 20000);
                  if(return_value_hci_read_remote_features$11 == 0)
                  {
                    ll_lock_list();
                    dev->got_features = (unsigned char)1;
                    do_store = (unsigned char)1;
                    ll_unlock_list();
                  }

                }

              }

              if(!((0x04 & (signed int)range->sf) == 0))
              {
                rv=hci_read_rssi(dd, handle, &val, 100);
                if(!(rv >= 0))
                {
                  signed int *return_value___errno_location$13;
                  return_value___errno_location$13=__errno_location();
                  char *return_value_strerror$14;
                  return_value_strerror$14=strerror(*return_value___errno_location$13);
                  applog(4, "%s::hci_send_req(): rssi read failed: ", (const void *)"scan_inquiry", return_value_strerror$14);
                }

                ll_lock_list();
                dev->rssi_status = (unsigned char)rv;
                dev->rssi = val;
                ll_unlock_list();
              }

              if(!((0x08 & (signed int)range->sf) == 0))
              {
                rv=hci_read_link_quality(dd, handle, &uval, 100);
                if(!(rv >= 0))
                {
                  signed int *return_value___errno_location$15;
                  return_value___errno_location$15=__errno_location();
                  char *return_value_strerror$16;
                  return_value_strerror$16=strerror(*return_value___errno_location$15);
                  applog(4, "%s::hci_send_req(): lq read failed: ", (const void *)"scan_inquiry", return_value_strerror$16);
                }

                ll_lock_list();
                dev->lq_status = (unsigned char)rv;
                dev->lq = uval;
                ll_unlock_list();
              }

              if(!((0x10 & (signed int)range->sf) == 0))
              {
                rv=hci_read_transmit_power_level(dd, handle, (unsigned char)0, &val, 100);
                if(!(rv >= 0))
                {
                  signed int *return_value___errno_location$17;
                  return_value___errno_location$17=__errno_location();
                  char *return_value_strerror$18;
                  return_value_strerror$18=strerror(*return_value___errno_location$17);
                  applog(4, "%s::hci_send_req(): tpl read failed: ", (const void *)"scan_inquiry", return_value_strerror$18);
                }

                ll_lock_list();
                dev->txpwr_status = (unsigned char)rv;
                dev->txpwr_type = (unsigned char)0;
                dev->txpwr_level = val;
                ll_unlock_list();
              }

              if(!((0x20 & (signed int)range->sf) == 0))
              {
                return_value_ll_check_got_sdp$19=ll_check_got_sdp(dev);
                if(return_value_ll_check_got_sdp$19 == 0)
                {
                  struct cbuf sdpstr;
                  memset((void *)&sdpstr, 0, sizeof(struct cbuf) /*24ul*/ );
                  memset((void *)&context, 0, sizeof(struct search_context) /*40ul*/ );
                  sdp_uuid16_create(&context.group, (unsigned short int)0x1002);
                  scan_sdp(hci, dev, &sdpstr, &context);
                  ll_lock_list();
                  if(!(sdpstr.buf == ((char *)NULL)))
                    sdpstr.buf[(signed long int)sdpstr.len] = (char)0;

                  dev->sdp = sdpstr.buf;
                  do_store = (unsigned char)1;
                  ll_unlock_list();
                }

              }

            }


          scan_inquiry_nextdev:
            ;
            store_timestamp(dev);
            if(!(do_store == 0))
            {
              store_device(dev);
              do_store = (unsigned char)0;
            }

            ll_unlock_device(dev);
            if(!(cc == 0))
              hci_disconnect(dd, handle, (unsigned char)0x13, 10000);

          }

        }

        i = i + 1;
      }
      hci_close_dev(dd);
      free((void *)info);
      info = (struct anonymous$36 *)(void *)0;
      return 0;
    }
  }
}

// scan_probe_bf
// file scan.c line 483
signed int scan_probe_bf(struct hcicfg *hci)
{
  signed int dd;
  signed int sr;
  signed int cc = 0;
  signed int rv;
  struct device *dev;
  char buf[512l];
  char tmp[32l];
  unsigned short int handle;
  struct search_context context;
  struct rangedef *range;
  unsigned char do_store = (unsigned char)0;
  unsigned char uval;
  signed char val;
  struct anonymous$28 ba;
  dd=hci_open_dev(hci->id);
  _Bool tmp_if_expr$2;
  signed int return_value_scan_bf_getnext$1;
  unsigned char return_value_ll_check_got_version$12;
  unsigned char return_value_ll_check_got_features$14;
  unsigned char return_value_ll_check_got_sdp$21;
  if(!(dd >= 0))
    return -1;

  else
  {
    do
    {
      if(!(bts_run_scan == 0))
      {
        return_value_scan_bf_getnext$1=scan_bf_getnext(&ba);
        tmp_if_expr$2 = 0 == return_value_scan_bf_getnext$1 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        break;

      unsigned long int return_value_bd2int$3;
      return_value_bd2int$3=bd2int(&ba);
      range=cfg_get_range(return_value_bd2int$3);
      if(!(range == ((struct rangedef *)NULL)))
      {
        sr=hci_read_remote_name(dd, &ba, (signed int)((unsigned long int)512 * sizeof(char) /*1ul*/ ), buf, 100000);
        ba2str(&ba, tmp);
        signed int return_value_scan_bf_getpercentage$4;
        return_value_scan_bf_getpercentage$4=scan_bf_getpercentage();
        screen_log("%s device %s (%d%%)", sr != 0 ? "Scanned" : "Found", (const void *)tmp, return_value_scan_bf_getpercentage$4);
        if(sr == 0)
        {
          dev=ll_lock_device(&ba);
          if(!(dev == ((struct device *)NULL)))
          {
            ll_lock_list();
            dev->updated = (unsigned char)1;
            time(&dev->last_scanned);
            bacpy$link2(&dev->bd_scan, &hci->bdaddr);
            dev->scan_count = dev->scan_count + 1u;
            ll_unlock_list();
            unsigned char return_value_ll_check_got_name$5;
            return_value_ll_check_got_name$5=ll_check_got_name(dev);
            if(return_value_ll_check_got_name$5 == 0)
            {
              ll_lock_list();
              ll_copy_name(dev, buf);
              dev->got_name = (unsigned char)1;
              do_store = (unsigned char)1;
              ll_unlock_list();
            }

            unsigned char return_value_ll_check_got_oui$6;
            return_value_ll_check_got_oui$6=ll_check_got_oui(dev);
            if(return_value_ll_check_got_oui$6 == 0)
            {
              ll_lock_list();
              dev->oui=ouidb_query(&dev->bdaddr);
              dev->got_oui = (unsigned char)1;
              ll_unlock_list();
            }

            if(!((-63 & (signed int)range->sf) == 0))
            {
              handle=find_conn(hci->id, &dev->bdaddr);
              if(handle == 65535)
              {
                signed int *return_value___errno_location$7;
                return_value___errno_location$7=__errno_location();
                if(!(*return_value___errno_location$7 == 0))
                  break;

                cc = 1;
                signed int return_value_hci_create_connection$10;
                return_value_hci_create_connection$10=hci_create_connection(dd, &dev->bdaddr, (unsigned short int)(0x0008 | 0x0010), (unsigned short int)0, (unsigned char)0, &handle, 25000);
                if(!(return_value_hci_create_connection$10 >= 0))
                {
                  signed int *return_value___errno_location$8;
                  return_value___errno_location$8=__errno_location();
                  char *return_value_strerror$9;
                  return_value_strerror$9=strerror(*return_value___errno_location$8);
                  applog(4, "%s::hci_create_connection(): Cant create: %s", (const void *)"scan_probe_bf", return_value_strerror$9);
                  goto scan_inquiry_nextdev;
                }

              }

              if(!((0x02 & (signed int)range->sf) == 0))
              {
                return_value_ll_check_got_version$12=ll_check_got_version(dev);
                if(return_value_ll_check_got_version$12 == 0)
                {
                  signed int return_value_hci_read_remote_version$11;
                  return_value_hci_read_remote_version$11=hci_read_remote_version(dd, handle, &dev->version, 20000);
                  if(return_value_hci_read_remote_version$11 == 0)
                  {
                    ll_lock_list();
                    dev->got_version = (unsigned char)1;
                    do_store = (unsigned char)1;
                    ll_unlock_list();
                  }

                }

              }

              if(!((0x02 & (signed int)range->sf) == 0))
              {
                return_value_ll_check_got_features$14=ll_check_got_features(dev);
                if(return_value_ll_check_got_features$14 == 0)
                {
                  signed int return_value_hci_read_remote_features$13;
                  return_value_hci_read_remote_features$13=hci_read_remote_features(dd, handle, dev->features, 20000);
                  if(return_value_hci_read_remote_features$13 == 0)
                  {
                    ll_lock_list();
                    dev->got_features = (unsigned char)1;
                    do_store = (unsigned char)1;
                    ll_unlock_list();
                  }

                }

              }

              if(!((0x04 & (signed int)range->sf) == 0))
              {
                rv=hci_read_rssi(dd, handle, &val, 100);
                if(!(rv >= 0))
                {
                  signed int *return_value___errno_location$15;
                  return_value___errno_location$15=__errno_location();
                  char *return_value_strerror$16;
                  return_value_strerror$16=strerror(*return_value___errno_location$15);
                  applog(4, "%s::hci_send_req(): rssi read failed: ", (const void *)"scan_probe_bf", return_value_strerror$16);
                }

                ll_lock_list();
                dev->rssi_status = (unsigned char)rv;
                dev->rssi = val;
                ll_unlock_list();
              }

              if(!((0x08 & (signed int)range->sf) == 0))
              {
                rv=hci_read_link_quality(dd, handle, &uval, 100);
                if(!(rv >= 0))
                {
                  signed int *return_value___errno_location$17;
                  return_value___errno_location$17=__errno_location();
                  char *return_value_strerror$18;
                  return_value_strerror$18=strerror(*return_value___errno_location$17);
                  applog(4, "%s::hci_send_req(): lq read failed: ", (const void *)"scan_probe_bf", return_value_strerror$18);
                }

                ll_lock_list();
                dev->lq_status = (unsigned char)rv;
                dev->lq = uval;
                ll_unlock_list();
              }

              if(!((0x10 & (signed int)range->sf) == 0))
              {
                rv=hci_read_transmit_power_level(dd, handle, (unsigned char)0, &val, 100);
                if(!(rv >= 0))
                {
                  signed int *return_value___errno_location$19;
                  return_value___errno_location$19=__errno_location();
                  char *return_value_strerror$20;
                  return_value_strerror$20=strerror(*return_value___errno_location$19);
                  applog(4, "%s::hci_send_req(): tpl read failed: ", (const void *)"scan_probe_bf", return_value_strerror$20);
                }

                ll_lock_list();
                dev->txpwr_status = (unsigned char)rv;
                dev->txpwr_type = (unsigned char)0;
                dev->txpwr_level = val;
                ll_unlock_list();
              }

              if(!((0x20 & (signed int)range->sf) == 0))
              {
                return_value_ll_check_got_sdp$21=ll_check_got_sdp(dev);
                if(return_value_ll_check_got_sdp$21 == 0)
                {
                  struct cbuf sdpstr;
                  memset((void *)&sdpstr, 0, sizeof(struct cbuf) /*24ul*/ );
                  memset((void *)&context, 0, sizeof(struct search_context) /*40ul*/ );
                  sdp_uuid16_create(&context.group, (unsigned short int)0x1002);
                  scan_sdp(hci, dev, &sdpstr, &context);
                  ll_lock_list();
                  if(!(sdpstr.buf == ((char *)NULL)))
                    sdpstr.buf[(signed long int)sdpstr.len] = (char)0;

                  dev->sdp = sdpstr.buf;
                  do_store = (unsigned char)1;
                  ll_unlock_list();
                }

              }

            }


          scan_inquiry_nextdev:
            ;
            if(!(do_store == 0))
            {
              store_device(dev);
              do_store = (unsigned char)0;
            }

            ll_unlock_device(dev);
            if(!(cc == 0))
              hci_disconnect(dd, handle, (unsigned char)0x13, 10000);

          }

        }

      }

      cc = 0;
      do_store = (unsigned char)cc;
    }
    while((_Bool)1);
    hci_close_dev(dd);
    return 0;
  }
}

// scan_reset_device
// file scan.c line 94
signed int scan_reset_device(signed int devid)
{
  signed int ctl;
  if(bts_reset == 0)
    return 0;

  else
  {
    ctl=socket(31, 3, 1);
    if(!(ctl >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      applog(3, "%s::socket(): %s", (const void *)"scan_reset_device", return_value_strerror$2);
      return -1;
    }

    signed int return_value_ioctl$6;
    return_value_ioctl$6=ioctl(ctl, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(72 << 0 + 8) | (unsigned int)(202 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, devid);
    if(return_value_ioctl$6 == -1)
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      if(!(*return_value___errno_location$5 == 114))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        char *return_value_strerror$4;
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        applog(3, "%s(): unable to bring device %d down: %s", (const void *)"scan_reset_device", devid, return_value_strerror$4);
        return -1;
      }

    }

    signed int return_value_ioctl$10;
    return_value_ioctl$10=ioctl(ctl, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(72 << 0 + 8) | (unsigned int)(201 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, devid);
    if(return_value_ioctl$10 == -1)
    {
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      if(!(*return_value___errno_location$9 == 114))
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        char *return_value_strerror$8;
        return_value_strerror$8=strerror(*return_value___errno_location$7);
        applog(3, "%s(): unable to bring device %d up: %s", (const void *)"scan_reset_device", devid, return_value_strerror$8);
        return -1;
      }

    }

    shutdown(ctl, 2);
    close(ctl);
    return 0;
  }
}

// scan_run
// file ./scan.h line 33
void * scan_run(void *arg)
{
  struct anonymous$25 sset;
  signed int i;
  struct hcicfg *hci = (struct hcicfg *)arg;
  memset((void *)&sset, 0, sizeof(struct anonymous$25) /*128ul*/ );
  sigfillset(&sset);
  sigdelset(&sset, 9);
  sigdelset(&sset, 19);
  sigdelset(&sset, 15);
  sigdelset(&sset, 2);
  sigdelset(&sset, 11);
  sigdelset(&sset, 10);
  signed int return_value_pthread_sigmask$1;
  return_value_pthread_sigmask$1=pthread_sigmask(2, &sset, (struct anonymous$25 *)(void *)0);
  signed int return_value_scan_reset_device$2;
  if(return_value_pthread_sigmask$1 == 0)
  {
    return_value_scan_reset_device$2=scan_reset_device(hci->id);
    if(return_value_scan_reset_device$2 == 0)
      while(!(bts_run_scan == 0))
      {
        i=scan_inquiry(hci);
        if(!(i == 0))
          sleep((unsigned int)1);

      }

  }


scan_run_leave:
  ;
  hci->died = (unsigned char)1;
  pthread_exit(NULL);
}

// scan_sdp
// file scan.c line 173
signed int scan_sdp(struct hcicfg *hci, struct device *d, struct cbuf *sdpstr, struct search_context *context)
{
  struct anonymous$33 *sess;
  struct _sdp_list *attrid;
  struct _sdp_list *search;
  struct _sdp_list *seq;
  struct _sdp_list *next;
  struct _sdp_list *first;
  unsigned int range = (unsigned int)0x0000ffff;
  char str[20l];
  struct cbuf buf;
  sess=sdp_connect(&hci->bdaddr, &d->bdaddr, (unsigned int)0x01);
  signed int return_value_sdp_sprint_service_attr$7;
  signed int return_value_sdp_get_group_id$14;
  if(sess == ((struct anonymous$33 *)NULL))
  {
    ba2str(&d->bdaddr, str);
    applog(4, "%s::sdp_connect(): failed to connect on %s", (const void *)"scan_sdp", (const void *)str);
    return 1;
  }

  else
  {
    attrid=sdp_list_append(((struct _sdp_list *)NULL), (void *)&range);
    search=sdp_list_append(((struct _sdp_list *)NULL), (void *)&context->group);
    signed int return_value_sdp_service_search_attr_req$3;
    return_value_sdp_service_search_attr_req$3=sdp_service_search_attr_req(sess, search, (enum anonymous$34)SDP_ATTR_REQ_RANGE, attrid, &seq);
    if(!(return_value_sdp_service_search_attr_req$3 == 0))
    {
      ba2str(&d->bdaddr, str);
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      applog(4, "%s::sdp_service_search_attr_req(): search failed on %s: %s", (const void *)"scan_sdp", (const void *)str, return_value_strerror$2);
      sdp_close(sess);
      return 1;
    }

    sdp_list_free(attrid, ((void (*)(void *))NULL));
    sdp_list_free(search, ((void (*)(void *))NULL));
    buf.sz = (unsigned long int)1024;
    buf.len = (unsigned long int)0;
    void *return_value_malloc$4;
    return_value_malloc$4=malloc(buf.sz * sizeof(char) /*1ul*/ );
    buf.buf = (char *)return_value_malloc$4;
    if(buf.buf == ((char *)NULL))
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      char *return_value_strerror$6;
      return_value_strerror$6=strerror(*return_value___errno_location$5);
      applog(3, "%s::realloc(): %s", (const void *)"scan_sdp", return_value_strerror$6);
      return 1;
    }

    first = seq;
    for( ; !(seq == ((struct _sdp_list *)NULL)); seq = next)
    {
      struct anonymous$2 *rec = (struct anonymous$2 *)seq->data;
      struct search_context sub_context;
      buf.len = (unsigned long int)0;
      do
      {
        return_value_sdp_sprint_service_attr$7=sdp_sprint_service_attr(&buf, rec);
        if(return_value_sdp_sprint_service_attr$7 == 0)
          break;

        buf.sz = buf.sz + (unsigned long int)1024;
        buf.len = (unsigned long int)0;
        void *return_value_realloc$8;
        return_value_realloc$8=realloc((void *)buf.buf, buf.sz * sizeof(char) /*1ul*/ );
        buf.buf = (char *)return_value_realloc$8;
        if(buf.buf == ((char *)NULL))
        {
          signed int *return_value___errno_location$9;
          return_value___errno_location$9=__errno_location();
          char *return_value_strerror$10;
          return_value_strerror$10=strerror(*return_value___errno_location$9);
          applog(3, "%s::realloc(): %s", (const void *)"scan_sdp", return_value_strerror$10);
          return 1;
        }

      }
      while((_Bool)1);
      if(!(buf.buf == ((char *)NULL)))
      {
        if(sdpstr->len + buf.len >= sdpstr->sz)
        {
          sdpstr->sz = sdpstr->sz + buf.len + (unsigned long int)1;
          void *return_value_realloc$11;
          return_value_realloc$11=realloc((void *)sdpstr->buf, sdpstr->sz * sizeof(char) /*1ul*/ );
          sdpstr->buf = (char *)return_value_realloc$11;
          if(sdpstr->buf == ((char *)NULL))
          {
            signed int *return_value___errno_location$12;
            return_value___errno_location$12=__errno_location();
            char *return_value_strerror$13;
            return_value_strerror$13=strerror(*return_value___errno_location$12);
            applog(3, "%s::realloc(): %s", (const void *)"scan_sdp", return_value_strerror$13);
            return 1;
          }

        }

        strncpy(sdpstr->buf + (signed long int)sdpstr->len, buf.buf, buf.len);
        sdpstr->len = sdpstr->len + buf.len;
        return_value_sdp_get_group_id$14=sdp_get_group_id(rec, &sub_context.group);
        if(!(return_value_sdp_get_group_id$14 == -1))
        {
          memcpy((void *)&sub_context, (const void *)context, sizeof(struct search_context) /*40ul*/ );
          if(!(sub_context.group.value.uuid16 == context->group.value.uuid16))
            scan_sdp(hci, d, sdpstr, &sub_context);

        }

      }


    scan_sdp_next:
      ;
      next = seq->next;
      free((void *)seq);
      sdp_record_free(rec);
    }
    if(!(buf.buf == ((char *)NULL)))
      free((void *)buf.buf);

    sdp_close(sess);
    return 0;
  }
}

// screen_block_move
// file screen.c line 289
signed int screen_block_move(signed int ch)
{
  switch(ch)
  {
    case 0403:

    case 107:
    {
      if(screen_block_info.sy >= 1ul)
        screen_block_info.sy = screen_block_info.sy - 1ul;

      break;
    }
    case 0402:

    case 106:
    {
      if(!(screen_sizes[0l].rows + screen_block_info.sy >= screen_block_info.mrows))
        screen_block_info.sy = screen_block_info.sy + 1ul;

      break;
    }
    case 0522:
    {
      if(!(screen_sizes[0l].rows >= screen_block_info.mrows))
      {
        if(!(2ul * screen_sizes[0l].rows + screen_block_info.sy >= screen_block_info.mrows))
          screen_block_info.sy = screen_block_info.sy + screen_sizes[(signed long int)0].rows;

        else
          screen_block_info.sy = screen_block_info.mrows - screen_sizes[(signed long int)0].rows;
      }

      break;
    }
    case 0523:
    {
      if(!(screen_sizes[0l].rows >= screen_block_info.mrows))
      {
        if(!((signed int)screen_block_info.sy + -((signed int)screen_sizes[0l].rows) >= 0))
          screen_block_info.sy = (unsigned long int)0;

        else
          screen_block_info.sy = screen_block_info.sy - screen_sizes[(signed long int)0].rows;
      }

      break;
    }
    default:
      return -8;
  }
  pnoutrefresh(screen_sizes[(signed long int)0].w, (signed int)screen_block_info.sy, (signed int)screen_block_info.sx, (signed int)screen_sizes[(signed long int)0].y, (signed int)screen_sizes[(signed long int)0].x, (signed int)((screen_sizes[(signed long int)0].rows + screen_sizes[(signed long int)0].y) - (unsigned long int)1), (signed int)((screen_sizes[(signed long int)0].cols + screen_sizes[(signed long int)0].x) - (unsigned long int)1));
  doupdate();
  return 0;
}

// screen_chksize
// file screen.c line 523
signed int screen_chksize(void)
{
  signed int y;
  signed int x;
  signed int tmp_if_expr$1;
  if(!(stdscr == ((struct _win_st *)NULL)))
    tmp_if_expr$1 = (signed int)stdscr->_maxy + 1;

  else
    tmp_if_expr$1 = -1;
  y = tmp_if_expr$1;
  signed int tmp_if_expr$2;
  if(!(stdscr == ((struct _win_st *)NULL)))
    tmp_if_expr$2 = (signed int)stdscr->_maxx + 1;

  else
    tmp_if_expr$2 = -1;
  x = tmp_if_expr$2;
  if(!(x >= 80) || !(y >= 11))
  {
    applog(3, "Screen size too small");
    return 1;
  }

  else
  {
    screen_sizes[(signed long int)0].x = (unsigned long int)1;
    screen_sizes[(signed long int)0].y = (unsigned long int)2;
    screen_sizes[(signed long int)0].rows = (unsigned long int)(y - 8);
    screen_sizes[(signed long int)0].cols = (unsigned long int)(x - 2);
    screen_sizes[(signed long int)1].x = (unsigned long int)1;
    screen_sizes[(signed long int)1].y = (unsigned long int)(y - 5);
    screen_sizes[(signed long int)1].rows = (unsigned long int)4;
    screen_sizes[(signed long int)1].cols = (unsigned long int)(x - 2);
    screen_sizes[(signed long int)2].x = (unsigned long int)1;
    screen_sizes[(signed long int)2].y = (unsigned long int)1;
    screen_sizes[(signed long int)2].rows = (unsigned long int)1;
    screen_sizes[(signed long int)2].cols = (unsigned long int)(x - 2);
    return 0;
  }
}

// screen_create
// file screen.c line 555
signed int screen_create(void)
{
  if((signed int)screens_cfg[(signed long int)screens_curr].type == LINE)
  {
    screen_line_info.selected = (unsigned long int)0;
    screen_sizes[(signed long int)0].w=derwin(stdscr, (signed int)screen_sizes[(signed long int)0].rows, (signed int)screen_sizes[(signed long int)0].cols, (signed int)screen_sizes[(signed long int)0].y, (signed int)screen_sizes[(signed long int)0].x);
  }

  else
  {
    screen_sizes[(signed long int)0].w=newpad((signed int)screen_block_info.mrows, (signed int)screen_block_info.mcols);
    memset((void *)&screen_block_info.text, 0, sizeof(struct cbuf) /*24ul*/ );
  }
  if(screen_sizes[0l].w == ((struct _win_st *)NULL))
  {
    applog(3, "%s::newpad(): unable to create pad", (const void *)"screen_create");
    return 1;
  }

  else
    return 0;
}

// screen_destroy
// file screen.c line 581
void screen_destroy(void)
{
  signed int i;
  if((signed int)screens_cfg[(signed long int)screens_curr].type == LINE)
  {
    if(!(screen_line_info.m == ((struct tagMENU *)NULL)))
    {
      unpost_menu(screen_line_info.m);
      delwin(screen_line_info.sw);
      screen_line_info.sw = (struct _win_st *)(void *)0;
      free_menu(screen_line_info.m);
      screen_line_info.m = (struct tagMENU *)(void *)0;
      free((void *)screen_line_info.ids);
      screen_line_info.ids = (unsigned long int *)(void *)0;
      i = 0;
      for( ; !(i >= screen_line_info.num_items); i = i + 1)
      {
        if(!(screen_line_info.items[(signed long int)i] == ((struct tagITEM *)NULL)))
          free_item(screen_line_info.items[(signed long int)i]);

        if(!(screen_line_info.labels[(signed long int)i] == ((char *)NULL)))
          free((void *)screen_line_info.labels[(signed long int)i]);

      }
      free((void *)screen_line_info.items);
      screen_line_info.items = (struct tagITEM **)(void *)0;
      free((void *)screen_line_info.labels);
      screen_line_info.labels = (char **)(void *)0;
      screen_line_info.num_items = 0;
    }

  }

  else
  {
    screen_block_info.mrows = screen_sizes[(signed long int)0].rows;
    screen_block_info.mcols = screen_sizes[(signed long int)0].cols;
    screen_block_info.sx = (unsigned long int)0;
    screen_block_info.sy = (unsigned long int)0;
    if(!(screen_block_info.text.buf == ((char *)NULL)))
      free((void *)screen_block_info.text.buf);

    memset((void *)&screen_block_info.text, 0, sizeof(struct cbuf) /*24ul*/ );
  }
  if(!(screen_sizes[0l].w == ((struct _win_st *)NULL)))
  {
    delwin(screen_sizes[(signed long int)0].w);
    screen_sizes[(signed long int)0].w = (struct _win_st *)(void *)0;
  }

}

// screen_get_sort
// file screen.c line 1047
signed int screen_get_sort(void)
{
  signed int i;
  signed int rev;
  struct cbuf cb;
  memset((void *)&cb, 0, sizeof(struct cbuf) /*24ul*/ );
  signed int return_value_screen_textbox$1;
  return_value_screen_textbox$1=screen_textbox("Enter a sort method\n b = Bluetooth address\n f = First seen\n l = Last seen\n r = Reverse sort\n E.G. br", "^[bflr]* *$", &cb);
  if(!(return_value_screen_textbox$1 == 0))
    return 1;

  else
    if(cb.len == 0ul)
    {
      free((void *)cb.buf);
      return 0;
    }

    else
    {
      rev = 0;
      i = rev;
      for( ; !((signed int)cb.buf[(signed long int)i] == 0); i = i + 1)
        switch((signed int)cb.buf[(signed long int)i])
        {
          case 98:
          {
            screen_sort = 0x01;
            break;
          }
          case 108:
          {
            screen_sort = 0x04;
            break;
          }
          case 102:
          {
            screen_sort = 0x02;
            break;
          }
          case 114:
            rev = 0x80;
        }
      screen_sort = screen_sort | rev;
      return 0;
    }
}

// screen_info_get_content
// file screen.c line 416
signed int screen_info_get_content(signed int width)
{
  width = width;
  signed int return_value_ll_print_dev_info$1;
  return_value_ll_print_dev_info$1=ll_print_dev_info(screen_line_info.selected, &screen_block_info.text);
  if(!(return_value_ll_print_dev_info$1 == 0))
    return 1;

  else
  {
    ll_get_last_update_time(screen_line_info.selected, &screen_block_info.updated);
    return 0;
  }
}

// screen_info_is_changed
// file screen.c line 431
signed int screen_info_is_changed(void)
{
  signed long int t;
  ll_get_last_update_time(screen_line_info.selected, &t);
  if(t == screen_block_info.updated)
    return 0;

  else
  {
    screen_block_info.updated = t;
    return 1;
  }
}

// screen_info_print_title
// file screen.c line 445
void screen_info_print_title(void)
{
  struct device *dev;
  ll_lock_list();
  dev=ll_find_device(screen_line_info.selected);
  ll_unlock_list();
  if(dev == ((struct device *)NULL))
  {
    signed int return_value_wmove$1;
    return_value_wmove$1=wmove(screen_sizes[(signed long int)2].w, 0, 0);
    if(return_value_wmove$1 == -1)
      -1;

    else
      waddnstr(screen_sizes[(signed long int)2].w, "RSSI:          LQ:          TXPWR:", -1);
    goto __CPROVER_DUMP_L10;
  }

  wmove(screen_sizes[(signed long int)2].w, 0, 0);
  if(!(dev->rssi_status == 0))
    wprintw(screen_sizes[(signed long int)2].w, "RSSI:  E0x%2.2x", dev->rssi_status);

  else
    wprintw(screen_sizes[(signed long int)2].w, "RSSI:  %+4d ", dev->rssi);
  if(!(dev->lq_status == 0))
    wprintw(screen_sizes[(signed long int)2].w, "  LQ:  E0x%2.2x", dev->lq_status);

  else
    wprintw(screen_sizes[(signed long int)2].w, "  LQ:  %03d  ", dev->lq);
  if(!(dev->txpwr_status == 0))
    wprintw(screen_sizes[(signed long int)2].w, "  TXPWR:  E0x%2.2x", dev->txpwr_status);

  else
    wprintw(screen_sizes[(signed long int)2].w, "  TXPWR:  %s %+4d  ", (signed int)dev->txpwr_type == 0 ? "Cur" : "Max", dev->txpwr_level);

__CPROVER_DUMP_L10:
  ;
}

// screen_info_quit
// file screen.c line 347
signed int screen_info_quit(signed int ch)
{
  ch = ch;
  screen_destroy();
  screens_curr = 0;
  return 0;
}

// screen_init_bf
// file screen.c line 981
signed int screen_init_bf(void)
{
  struct cbuf cb;
  signed int dl;
  signed int ret;
  struct anonymous$28 start;
  struct anonymous$28 end;
  unsigned long int return_value_bd2int$3;
  unsigned long int return_value_bd2int$4;
  do
  {

  screen_init_bf_retry:
    ;
    memset((void *)&cb, 0, sizeof(struct cbuf) /*24ul*/ );
    memset((void *)&start, 0, sizeof(struct cbuf) /*24ul*/ );
    memset((void *)&end, 0, sizeof(struct cbuf) /*24ul*/ );
    ret = 0;
    dl = 1;
    while(!(dl == 0) && !(bts_run == 0))
    {
      signed int return_value_screen_textbox$1;
      return_value_screen_textbox$1=screen_textbox("Start address", "^[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2} *$", &cb);
      if(!(return_value_screen_textbox$1 == 0))
      {
        if(return_value_screen_textbox$1 == -1)
          goto __CPROVER_DUMP_L6;

      }

      else
      {
        if(cb.len >= 1ul)
          str2ba(cb.buf, &start);

        else
          ret = 1;
        free((void *)cb.buf);
        dl = 0;
        goto __CPROVER_DUMP_L7;

      __CPROVER_DUMP_L6:
        ;
        dl = 0;
        ret = 1;
      }

    __CPROVER_DUMP_L7:
      ;
    }
    if(ret == 1)
      return ret;

    memset((void *)&cb, 0, sizeof(struct cbuf) /*24ul*/ );
    dl = 1;
    while(!(dl == 0) && !(bts_run == 0))
    {
      signed int return_value_screen_textbox$2;
      return_value_screen_textbox$2=screen_textbox("End address", "^[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2} *$", &cb);
      if(!(return_value_screen_textbox$2 == 0))
      {
        if(return_value_screen_textbox$2 == -1)
          goto __CPROVER_DUMP_L14;

      }

      else
      {
        if(cb.len >= 1ul)
          str2ba(cb.buf, &end);

        else
          ret = 1;
        free((void *)cb.buf);
        dl = 0;
        goto __CPROVER_DUMP_L15;

      __CPROVER_DUMP_L14:
        ;
        dl = 0;
        ret = 1;
      }

    __CPROVER_DUMP_L15:
      ;
    }
    if(ret == 1)
      return ret;

    return_value_bd2int$3=bd2int(&end);
    return_value_bd2int$4=bd2int(&start);
    if(return_value_bd2int$3 >= return_value_bd2int$4)
      break;

    screen_log("End address is smaller than start address");
  }
  while((_Bool)1);
  char s[32l];
  char e[32l];
  scan_bf_init(&start, &end);
  ba2str(&start, s);
  ba2str(&end, e);
  screen_log("Starting bruteforce scan from %s to %s", (const void *)s, (const void *)e);
  return ret;
}

// screen_line_move
// file screen.c line 264
signed int screen_line_move(signed int ch)
{
  signed int cmd = 0;
  switch(ch)
  {
    case 0403:

    case 107:
    {
      cmd = 0777 + 12;
      break;
    }
    case 0402:

    case 106:
    {
      cmd = 0777 + 11;
      break;
    }
    case 0522:
    {
      cmd = 0777 + 7;
      break;
    }
    case 0523:
    {
      cmd = 0777 + 8;
      break;
    }
    default:
      return -8;
  }
  signed int return_value_menu_driver$1;
  return_value_menu_driver$1=menu_driver(screen_line_info.m, cmd);
  return return_value_menu_driver$1;
}

// screen_log
// file screen.c line 190
signed int screen_log(char *fmt, ...)
{
  void **ap;
  signed int y;
  signed int x;
  signed int ret = 0;
  struct cbuf new;
  signed int tmp_if_expr$3;
  signed int tmp_if_expr$4;
  if(screen_sizes[1l].w == ((struct _win_st *)NULL))
    return 1;

  else
  {
    memset((void *)&new, 0, sizeof(struct cbuf) /*24ul*/ );
    pthread_mutex_lock(&screen_log_mux);
    while((_Bool)1)
    {
      if(new.len >= 1ul)
      {
        new.sz = new.len + (unsigned long int)1;
        void *return_value_realloc$1;
        return_value_realloc$1=realloc((void *)new.buf, sizeof(char) /*1ul*/  * new.sz);
        new.buf = (char *)return_value_realloc$1;
        if(new.buf == ((char *)NULL))
        {
          ret = 1;
          goto screen_log_leave;
        }

      }

      ap = (void **)&fmt;
      signed int return_value_vsnprintf$2;
      return_value_vsnprintf$2=vsnprintf(new.buf, new.sz, fmt, ap);
      new.len = (unsigned long int)return_value_vsnprintf$2;
      ap = ((void **)NULL);
      if(!(new.len >= new.sz))
        break;

    }
    if(!(screen_log_lines[0l].buf == ((char *)NULL)))
      free((void *)screen_log_lines[(signed long int)0].buf);

    y = 1;
    for( ; !(y >= 4); y = y + 1)
      memcpy((void *)&screen_log_lines[(signed long int)(y - 1)], (const void *)&screen_log_lines[(signed long int)y], sizeof(struct cbuf) /*24ul*/ );
    memcpy((void *)&screen_log_lines[(signed long int)3], (const void *)&new, sizeof(struct cbuf) /*24ul*/ );
    if(!(screen_sizes[1l].w == ((struct _win_st *)NULL)))
    {
      if(!(screen_sizes[1l].w == ((struct _win_st *)NULL)))
        tmp_if_expr$3 = (signed int)screen_sizes[(signed long int)1].w->_maxy + 1;

      else
        tmp_if_expr$3 = -1;
      y = tmp_if_expr$3;
      if(!(screen_sizes[1l].w == ((struct _win_st *)NULL)))
        tmp_if_expr$4 = (signed int)screen_sizes[(signed long int)1].w->_maxx + 1;

      else
        tmp_if_expr$4 = -1;
      x = tmp_if_expr$4;
      wscrl(screen_sizes[(signed long int)1].w, 1);
      signed int return_value_wmove$5;
      return_value_wmove$5=wmove(screen_sizes[(signed long int)1].w, y - 1, 0);
      if(return_value_wmove$5 == -1)
        -1;

      else
        waddnstr(screen_sizes[(signed long int)1].w, screen_log_lines[(signed long int)3].buf, -1);
      wrefresh(screen_sizes[(signed long int)1].w);
    }


  screen_log_leave:
    ;
    pthread_mutex_unlock(&screen_log_mux);
    return ret;
  }
}

// screen_log_redisplay
// file screen.c line 242
signed int screen_log_redisplay(void)
{
  signed int i;
  signed int return_value_wmove$1;
  if(screen_sizes[1l].w == ((struct _win_st *)NULL))
    return 1;

  else
  {
    pthread_mutex_lock(&screen_log_mux);
    werase(screen_sizes[(signed long int)1].w);
    i = 0;
    for( ; !(i >= 4); i = i + 1)
      if(!(screen_log_lines[(signed long int)i].buf == ((char *)NULL)))
      {
        return_value_wmove$1=wmove(screen_sizes[(signed long int)1].w, i, 0);
        if(return_value_wmove$1 == -1)
          -1;

        else
          waddnstr(screen_sizes[(signed long int)1].w, screen_log_lines[(signed long int)i].buf, -1);
      }

    wnoutrefresh(screen_sizes[(signed long int)1].w);
    pthread_mutex_unlock(&screen_log_mux);
    return 0;
  }
}

// screen_main_get_content
// file screen.c line 356
signed int screen_main_get_content(signed int width)
{
  signed int i;
  signed int ret;
  struct device *d = (struct device *)(void *)0;
  ret = 0;
  ll_lock_list();
  unsigned long int return_value_ll_dev_count$1;
  return_value_ll_dev_count$1=ll_dev_count();
  screen_line_info.num_items = (signed int)return_value_ll_dev_count$1;
  void *return_value_malloc$2;
  void *return_value_malloc$5;
  if(!(screen_line_info.num_items == 0))
  {
    ll_sortlist(screen_sort);
    return_value_malloc$2=malloc((unsigned long int)screen_line_info.num_items * sizeof(char *) /*8ul*/ );
    screen_line_info.labels = (char **)return_value_malloc$2;
    if(screen_line_info.labels == ((char **)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      applog(3, "%s::malloc(): %s", (const void *)"screen_main_get_content", return_value_strerror$4);
      ret = 1;
      goto screen_main_get_content_leave;
    }

    return_value_malloc$5=malloc((unsigned long int)screen_line_info.num_items * sizeof(unsigned long int) /*8ul*/ );
    screen_line_info.ids = (unsigned long int *)return_value_malloc$5;
    if(screen_line_info.ids == ((unsigned long int *)NULL))
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      applog(3, "%s::malloc(): %s", (const void *)"screen_main_get_content", return_value_strerror$7);
      ret = 1;
      goto screen_main_get_content_leave;
    }

    i = 0;
    for( ; !(i >= screen_line_info.num_items); i = i + 1)
    {
      if(i == 0)
        d=ll_first();

      else
        d=ll_next(d);
      void *return_value_malloc$8;
      return_value_malloc$8=malloc((unsigned long int)(width + 1) * sizeof(char) /*1ul*/ );
      screen_line_info.labels[(signed long int)i] = (char *)return_value_malloc$8;
      if(screen_line_info.labels[(signed long int)i] == ((char *)NULL))
      {
        signed int *return_value___errno_location$9;
        return_value___errno_location$9=__errno_location();
        char *return_value_strerror$10;
        return_value_strerror$10=strerror(*return_value___errno_location$9);
        applog(3, "%s::malloc(): %s", (const void *)"screen_main_get_content", return_value_strerror$10);
        ret = 1;
        break;
      }

      ll_print_dev_line(d, &screen_line_info.ids[(signed long int)i], screen_line_info.labels[(signed long int)i], width);
    }
  }


screen_main_get_content_leave:
  ;
  ll_unlock_list();
  return ret;
}

// screen_main_key_enter
// file screen.c line 332
signed int screen_main_key_enter(signed int ch)
{
  signed int i;
  ch = ch;
  struct tagITEM *return_value_current_item$1;
  return_value_current_item$1=current_item(screen_line_info.m);
  i=item_index(return_value_current_item$1);
  if(i == -1)
    return 0;

  else
  {
    screen_line_info.selected = screen_line_info.ids[(signed long int)i];
    screen_destroy();
    screens_curr = 1;
    return 0;
  }
}

// screen_main_print_title
// file screen.c line 441
void screen_main_print_title(void)
{
  signed int return_value_wmove$1;
  return_value_wmove$1=wmove(screen_sizes[(signed long int)2].w, 0, 0);
  if(return_value_wmove$1 == -1)
    -1;

  else
    waddnstr(screen_sizes[(signed long int)2].w, "Time                 Address            Clk off  Class     Name", -1);
}

// screen_make_windows
// file screen.c line 1089
signed int screen_make_windows(void)
{
  signed int i;
  unsigned long int sel;
  screen_destroy();
  i = 1;
  for( ; !(i >= 3); i = i + 1)
    if(!(screen_sizes[(signed long int)i].w == ((struct _win_st *)NULL)))
    {
      delwin(screen_sizes[(signed long int)i].w);
      screen_sizes[(signed long int)i].w = (struct _win_st *)(void *)0;
    }

  werase(stdscr);
  signed int tmp_if_expr$1;
  if(!(stdscr == ((struct _win_st *)NULL)))
    tmp_if_expr$1 = (signed int)stdscr->_maxy + 1;

  else
    tmp_if_expr$1 = -1;
  wtouchln(stdscr, 0, tmp_if_expr$1, 1);
  wborder(stdscr, acs_map[(signed long int)(unsigned char)120], acs_map[(signed long int)(unsigned char)120], acs_map[(signed long int)(unsigned char)113], acs_map[(signed long int)(unsigned char)113], acs_map[(signed long int)(unsigned char)108], acs_map[(signed long int)(unsigned char)107], acs_map[(signed long int)(unsigned char)109], acs_map[(signed long int)(unsigned char)106]);
  signed int return_value_wmove$2;
  return_value_wmove$2=wmove(stdscr, (signed int)(screen_sizes[(signed long int)0].rows + screen_sizes[(signed long int)0].y), (signed int)screen_sizes[(signed long int)0].x);
  if(return_value_wmove$2 == -1)
    -1;

  else
    whline(stdscr, acs_map[(signed long int)(unsigned char)113], (signed int)screen_sizes[(signed long int)0].cols);
  signed int return_value_wmove$3;
  return_value_wmove$3=wmove(stdscr, (signed int)(screen_sizes[(signed long int)0].rows + screen_sizes[(signed long int)0].y), 0);
  if(return_value_wmove$3 == -1)
    -1;

  else
    waddch(stdscr, acs_map[(signed long int)(unsigned char)116]);
  signed int return_value_wmove$4;
  return_value_wmove$4=wmove(stdscr, (signed int)(screen_sizes[(signed long int)0].rows + screen_sizes[(signed long int)0].y), (signed int)(screen_sizes[(signed long int)0].cols + (unsigned long int)1));
  if(return_value_wmove$4 == -1)
    -1;

  else
    waddch(stdscr, acs_map[(signed long int)(unsigned char)117]);
  screen_sizes[(signed long int)1].w=derwin(stdscr, (signed int)screen_sizes[(signed long int)1].rows, (signed int)screen_sizes[(signed long int)1].cols, (signed int)screen_sizes[(signed long int)1].y, (signed int)screen_sizes[(signed long int)1].x);
  if(screen_sizes[1l].w == ((struct _win_st *)NULL))
  {
    applog(3, "%s::derwin(): unable to create window", (const void *)"screen_make_windows");
    return 1;
  }

  else
  {
    screen_sizes[(signed long int)2].w=derwin(stdscr, (signed int)screen_sizes[(signed long int)2].rows, (signed int)screen_sizes[(signed long int)2].cols, (signed int)screen_sizes[(signed long int)2].y, (signed int)screen_sizes[(signed long int)2].x);
    if(screen_sizes[2l].w == ((struct _win_st *)NULL))
    {
      applog(3, "%s::derwin(): unable to create window", (const void *)"screen_make_windows");
      return 1;
    }

    else
    {
      scrollok(screen_sizes[(signed long int)1].w, (_Bool)1);
      screen_sizes[(signed long int)0].w = (struct _win_st *)(void *)0;
      screen_block_info.sy = (unsigned long int)0;
      screen_block_info.sx = screen_block_info.sy;
      screen_block_info.mrows = screen_sizes[(signed long int)0].rows;
      screen_block_info.mcols = screen_sizes[(signed long int)0].cols;
      sel = screen_line_info.selected;
      memset((void *)&screen_line_info, 0, sizeof(struct anonymous$32) /*56ul*/ );
      screen_line_info.selected = sel;
      signed int return_value_screen_create$5;
      return_value_screen_create$5=screen_create();
      if(!(return_value_screen_create$5 == 0))
        return 1;

      else
      {
        i = 0;
        for( ; !(i >= 3); i = i + 1)
        {
          keypad(screen_sizes[(signed long int)i].w, (_Bool)1);
          idlok(screen_sizes[(signed long int)i].w, (_Bool)1);
          leaveok(screen_sizes[(signed long int)i].w, (_Bool)1);
          intrflush(screen_sizes[(signed long int)i].w, (_Bool)0);
        }
        screen_log_redisplay();
        return 0;
      }
    }
  }
}

// screen_off
// file ./screen.h line 33
signed int screen_off(void)
{
  curs_set(1);
  delwin(stdscr);
  endwin();
  return 0;
}

// screen_on
// file ./screen.h line 32
signed int screen_on(void)
{
  initscr();
  keypad(stdscr, (_Bool)1);
  nonl();
  cbreak();
  halfdelay(5);
  noecho();
  idlok(stdscr, (_Bool)1);
  leaveok(stdscr, (_Bool)1);
  intrflush(stdscr, (_Bool)0);
  curs_set(0);
  assume_default_colors(0, 7);
  _Bool return_value_has_colors$1;
  return_value_has_colors$1=has_colors();
  if(!(return_value_has_colors$1 == (_Bool)0))
  {
    start_color();
    init_pair((signed short int)1, (signed short int)0, (signed short int)7);
    wbkgd(stdscr, (unsigned long int)1 << 0 + 8);
  }

  set_menu_mark((struct tagMENU *)(void *)0, screen_mm);
  signed int tmp_if_expr$2;
  if(!(stdscr == ((struct _win_st *)NULL)))
    tmp_if_expr$2 = (signed int)stdscr->_maxy + 1;

  else
    tmp_if_expr$2 = -1;
  wtouchln(stdscr, 0, tmp_if_expr$2, 1);
  wrefresh(stdscr);
  return 0;
}

// screen_redraw
// file screen.c line 629
signed int screen_redraw(void)
{
  signed int ret;
  signed int mrows;
  signed int mcols;
  struct tagITEM *cur;
  werase(screen_sizes[(signed long int)0].w);
  ret = 0;
  werase(screen_sizes[(signed long int)2].w);
  if(!(screens_cfg[(signed long int)screens_curr].title == ((void (*)(void))NULL)))
    screens_cfg[(signed long int)screens_curr].title();

  wnoutrefresh(screen_sizes[(signed long int)2].w);
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  unsigned long int tmp_if_expr$10;
  unsigned long int tmp_if_expr$11;
  if((signed int)screens_cfg[(signed long int)screens_curr].type == LINE)
  {
    signed int i;
    if(!(screen_line_info.m == ((struct tagMENU *)NULL)))
    {
      struct tagITEM *return_value_current_item$1;
      return_value_current_item$1=current_item(screen_line_info.m);
      i=item_index(return_value_current_item$1);
      if(!(i >= 0))
        i = 0;

      screen_line_info.selected = screen_line_info.ids[(signed long int)i];
      unpost_menu(screen_line_info.m);
      delwin(screen_line_info.sw);
      screen_line_info.sw = (struct _win_st *)(void *)0;
      free_menu(screen_line_info.m);
      screen_line_info.m = (struct tagMENU *)(void *)0;
      free((void *)screen_line_info.ids);
      screen_line_info.ids = (unsigned long int *)(void *)0;
      i = 0;
      for( ; !(i >= screen_line_info.num_items); i = i + 1)
      {
        if(!(screen_line_info.items[(signed long int)i] == ((struct tagITEM *)NULL)))
          free_item(screen_line_info.items[(signed long int)i]);

        if(!(screen_line_info.labels[(signed long int)i] == ((char *)NULL)))
          free((void *)screen_line_info.labels[(signed long int)i]);

      }
      free((void *)screen_line_info.items);
      screen_line_info.items = (struct tagITEM **)(void *)0;
      free((void *)screen_line_info.labels);
      screen_line_info.labels = (char **)(void *)0;
      screen_line_info.num_items = 0;
    }

    signed int return_value;
    return_value=screens_cfg[(signed long int)screens_curr].get_content((signed int)screen_sizes[(signed long int)0].cols);
    if(!(return_value == 0))
      ret = 1;

    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct tagITEM *) /*8ul*/  * (unsigned long int)(screen_line_info.num_items + 1));
    screen_line_info.items = (struct tagITEM **)return_value_malloc$2;
    if(screen_line_info.items == ((struct tagITEM **)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      applog(3, "%s::malloc(): %s", (const void *)"screen_redraw", return_value_strerror$4);
      ret = 1;
    }

    cur = (struct tagITEM *)(void *)0;
    i = 0;
    if(!(i >= screen_line_info.num_items))
    {
      screen_line_info.items[(signed long int)i]=new_item(screen_line_info.labels[(signed long int)i], "");
      if(screen_line_info.selected == screen_line_info.ids[(signed long int)i])
        cur = screen_line_info.items[(signed long int)i];

      i = i + 1;
    }

    screen_line_info.items[(signed long int)i] = (struct tagITEM *)(void *)0;
    screen_line_info.m=new_menu(screen_line_info.items);
    set_menu_format(screen_line_info.m, (signed int)screen_sizes[(signed long int)0].rows, 1);
    scale_menu(screen_line_info.m, &mrows, &mcols);
    set_menu_win(screen_line_info.m, screen_sizes[(signed long int)0].w);
    screen_line_info.sw=derwin(screen_sizes[(signed long int)0].w, (signed int)screen_sizes[(signed long int)0].rows, (signed int)screen_sizes[(signed long int)0].cols, 0, 0);
    set_menu_sub(screen_line_info.m, screen_line_info.sw);
    post_menu(screen_line_info.m);
    if(!(cur == ((struct tagITEM *)NULL)))
      set_current_item(screen_line_info.m, cur);

  }

  else
  {
    unsigned long int screen_redraw$$1$$2$$i;
    unsigned long int j;
    unsigned long int trows;
    unsigned long int tcols;
    unsigned long int len;
    struct cbuf cb;
    memset((void *)&screen_block_info.text, 0, sizeof(struct cbuf) /*24ul*/ );
    if(!(screen_block_info.text.buf == ((char *)NULL)))
      free((void *)screen_block_info.text.buf);

    memset((void *)&screen_block_info.text, 0, sizeof(struct cbuf) /*24ul*/ );
    signed int return_value_1;
    return_value_1=screens_cfg[(signed long int)screens_curr].get_content((signed int)screen_sizes[(signed long int)0].cols);
    if(!(return_value_1 == 0))
      ret = 1;

    else
    {
      cb.sz = screen_block_info.text.sz;
      void *return_value_malloc$5;
      return_value_malloc$5=malloc(sizeof(char) /*1ul*/  * cb.sz);
      cb.buf = (char *)return_value_malloc$5;
      if(cb.buf == ((char *)NULL))
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        char *return_value_strerror$7;
        return_value_strerror$7=strerror(*return_value___errno_location$6);
        applog(3, "%s::malloc(): %s", (const void *)"screen_redraw", return_value_strerror$7);
        ret = 1;
      }

      if(screen_block_info.text.len >= 1ul)
      {
        screen_redraw$$1$$2$$i = screen_block_info.text.len - (unsigned long int)1;
        if((signed int)screen_block_info.text.buf[(signed long int)screen_redraw$$1$$2$$i] == 10)
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = (signed int)screen_block_info.text.buf[(signed long int)screen_redraw$$1$$2$$i] == 13 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$8)
          tmp_if_expr$9 = (_Bool)1;

        else
          tmp_if_expr$9 = (signed int)screen_block_info.text.buf[(signed long int)screen_redraw$$1$$2$$i] == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$9)
          screen_redraw$$1$$2$$i = screen_redraw$$1$$2$$i - 1ul;

        screen_block_info.text.len = screen_redraw$$1$$2$$i + (unsigned long int)1;
        screen_block_info.text.buf[(signed long int)screen_block_info.text.len] = (char)0;
      }

      tcols = (unsigned long int)1;
      trows = tcols;
      screen_redraw$$1$$2$$i = (unsigned long int)0;
      j = screen_redraw$$1$$2$$i;
      cb.len = j;
      if(!(screen_redraw$$1$$2$$i >= screen_block_info.text.len))
      {
        cb.buf[(signed long int)cb.len] = screen_block_info.text.buf[(signed long int)screen_redraw$$1$$2$$i];
        if((signed int)screen_block_info.text.buf[(signed long int)screen_redraw$$1$$2$$i] == 10)
        {
          trows = trows + 1ul;
          len = screen_redraw$$1$$2$$i - j;
          if(!(tcols >= len))
            tcols = len;

          j = screen_redraw$$1$$2$$i + (unsigned long int)1;
        }

        if((signed int)screen_block_info.text.buf[(signed long int)screen_redraw$$1$$2$$i] == 13)
          cb.len = cb.len - 1ul;

        cb.len = cb.len + 1ul;
        screen_redraw$$1$$2$$i = screen_redraw$$1$$2$$i + 1ul;
      }

      cb.buf[(signed long int)cb.len] = (char)0;
      free((void *)screen_block_info.text.buf);
      screen_block_info.text.buf = cb.buf;
      screen_block_info.text.len = cb.len;
      if(!(screen_sizes[0l].rows >= trows))
        tmp_if_expr$10 = trows;

      else
        tmp_if_expr$10 = screen_sizes[(signed long int)0].rows;
      screen_block_info.mrows = tmp_if_expr$10;
      if(!(screen_sizes[0l].cols >= tcols))
        tmp_if_expr$11 = tcols;

      else
        tmp_if_expr$11 = screen_sizes[(signed long int)0].cols;
      screen_block_info.mcols = tmp_if_expr$11;
      wresize(screen_sizes[(signed long int)0].w, (signed int)screen_block_info.mrows, (signed int)screen_block_info.mcols);
      signed int return_value_wmove$12;
      return_value_wmove$12=wmove(screen_sizes[(signed long int)0].w, 0, 0);
      if(return_value_wmove$12 == -1)
        -1;

      else
        waddnstr(screen_sizes[(signed long int)0].w, screen_block_info.text.buf, (signed int)screen_block_info.text.len);
    }
  }

screen_redraw_leave:
  ;
  if((signed int)screens_cfg[(signed long int)screens_curr].type == LINE)
    wnoutrefresh(screen_sizes[(signed long int)0].w);

  else
    pnoutrefresh(screen_sizes[(signed long int)0].w, (signed int)screen_block_info.sy, (signed int)screen_block_info.sx, (signed int)screen_sizes[(signed long int)0].y, (signed int)screen_sizes[(signed long int)0].x, (signed int)((screen_sizes[(signed long int)0].rows + screen_sizes[(signed long int)0].y) - (unsigned long int)1), (signed int)((screen_sizes[(signed long int)0].cols + screen_sizes[(signed long int)0].x) - (unsigned long int)1));
  return ret;
}

// screen_run
// file ./screen.h line 34
signed int screen_run(void)
{
  signed int ch;
  signed int ret;
  signed int i;
  signed int found;
  signed int do_resize;
  signed int do_update;
  memset((void *)screen_log_lines, 0, (unsigned long int)4 * sizeof(struct cbuf) /*24ul*/ );
  memset((void *)&screen_line_info, 0, sizeof(struct anonymous$32) /*56ul*/ );
  signed int return_value_screen_chksize$1;
  return_value_screen_chksize$1=screen_chksize();
  signed int return_value_threader_running$7;
  signed int return_value_threader_running$10;
  signed int return_value_screen_init_bf$9;
  signed int return_value_threader_running$11;
  signed int return_value;
  if(!(return_value_screen_chksize$1 == 0))
    return 1;

  else
  {
    signed int return_value_screen_make_windows$2;
    return_value_screen_make_windows$2=screen_make_windows();
    if(!(return_value_screen_make_windows$2 == 0))
      return 1;

    else
    {
      screen_log("%s %s", (const void *)"btscanner", (const void *)"2.0");
      screen_log("keys: h=help, i=inquiry scan, b=brute force scan, a=abort scan, s=save summary, o=select sort, enter=select, Q=quit");
      ret = 0;
      do_update = ret;
      do_resize = do_update;
      while(!(bts_run == 0))
      {
        if(screens_curr == -1)
        {
          bts_run = (char)0;
          break;
        }

        if(!(do_resize == 0))
        {
          signed int return_value_screen_chksize$3;
          return_value_screen_chksize$3=screen_chksize();
          if(!(return_value_screen_chksize$3 == 0))
          {
            bts_run = (char)0;
            break;
          }

          if(screens_curr >= screens_max)
            screens_curr = 0;

          signed int return_value_screen_make_windows$4;
          return_value_screen_make_windows$4=screen_make_windows();
          if(!(return_value_screen_make_windows$4 == 0))
          {
            bts_run = (char)0;
            break;
          }

          do_update = 1;
          do_resize = 0;
        }

        if(screen_sizes[0l].w == ((struct _win_st *)NULL))
        {
          if(screens_curr >= screens_max)
            screens_curr = 0;

          signed int return_value_screen_create$5;
          return_value_screen_create$5=screen_create();
          if(!(return_value_screen_create$5 == 0))
          {
            bts_run = (char)0;
            break;
          }

          do_update = 1;
        }

        if(!(do_update == 0))
        {
          wnoutrefresh(stdscr);
          screen_redraw();
          do_update = 0;
        }

        doupdate();
        ch=wgetch(stdscr);
        i = 0;
        found = i;
        for( ; !((screens_cfg[(signed long int)screens_curr].keymap + (signed long int)i)->key == -1); i = i + 1)
          if(ch == (screens_cfg[(signed long int)screens_curr].keymap + (signed long int)i)->key)
          {
            (screens_cfg[(signed long int)screens_curr].keymap + (signed long int)i)->func(ch);
            found = 1;
            break;
          }

        if(found == 0)
          switch(ch)
          {
            case 0551:

            case 81:
            {
              bts_run = (char)0;
              break;
            }
            case 0632:
            {
              wresize(stdscr, LINES, COLS);
              do_resize = 1;
              break;
            }
            case 105:
            {
              return_value_threader_running$7=threader_running();
              if(return_value_threader_running$7 == SCAN_NONE)
              {
                signed int return_value_threader_start$6;
                return_value_threader_start$6=threader_start((enum threader_scan_types)SCAN_INQ);
                if(return_value_threader_start$6 == 0)
                  screen_log("error: no threads started, check the log");

                else
                  screen_log("starting inquiry scan");
              }

              else
                screen_log("a scan is already running");
              break;
            }
            case 98:
            {
              return_value_threader_running$10=threader_running();
              if(return_value_threader_running$10 == SCAN_NONE)
              {
                return_value_screen_init_bf$9=screen_init_bf();
                if(return_value_screen_init_bf$9 == 0)
                {
                  signed int return_value_threader_start$8;
                  return_value_threader_start$8=threader_start((enum threader_scan_types)SCAN_BF);
                  if(return_value_threader_start$8 == 0)
                    screen_log("error: no threads started, check the log");

                }

              }

              do_update = 1;
              break;
            }
            case 97:
            {
              return_value_threader_running$11=threader_running();
              if(!(return_value_threader_running$11 == SCAN_NONE))
              {
                screen_log("aborting scan");
                threader_stop();
                screen_log("aborted");
              }

              break;
            }
            case 104:
            {
              screen_log("keys: h=help, i=inquiry scan, b=brute force scan, a=abort scan, s=save summary, o=select sort, enter=select, Q=quit");
              break;
            }
            case 115:
            {
              do_update = 1;
              struct cbuf cb;
              memset((void *)&cb, 0, sizeof(struct cbuf) /*24ul*/ );
              signed int return_value_screen_textbox$12;
              return_value_screen_textbox$12=screen_textbox("Enter filename", "^[a-zA-Z0-9/.]* *$", &cb);
              if(!(return_value_screen_textbox$12 == 0))
                break;

              if(cb.len == 0ul)
              {
                free((void *)cb.buf);
                break;
              }

              ll_save_summary(cb.buf);
              free((void *)cb.buf);
              break;
            }
            case 111:
            {
              do_update = 1;
              screen_get_sort();
            }
          }

        if(!(screens_cfg[(signed long int)screens_curr].changed == ((signed int (*)(void))NULL)))
        {
          return_value=screens_cfg[(signed long int)screens_curr].changed();
          do_update = do_update | return_value;
        }

      }
      signed int return_value_threader_running$13;
      return_value_threader_running$13=threader_running();
      if(!(return_value_threader_running$13 == SCAN_NONE))
      {
        screen_log("stopping scan");
        threader_stop();
      }

      if(!(screen_sizes[1l].w == ((struct _win_st *)NULL)))
        delwin(screen_sizes[(signed long int)1].w);

      if(!(screen_sizes[2l].w == ((struct _win_st *)NULL)))
        delwin(screen_sizes[(signed long int)2].w);

      screen_destroy();
      return ret;
    }
  }
}

// screen_textbox
// file screen.c line 821
signed int screen_textbox(const char *label, const char *re, struct cbuf *cb)
{
  signed int i;
  signed int j;
  signed int ret;
  signed int ch;
  signed int width;
  signed int height;
  signed int x;
  signed int y;
  struct fieldnode *fields[2l];
  struct formnode *f = (struct formnode *)(void *)0;
  struct _win_st *mw;
  struct _win_st *sw;
  struct _win_st *tw;
  signed int return_value_wmove$2;
  _Bool tmp_if_expr$3;
  signed int return_value_form_driver$9;
  if(label == ((const char *)NULL))
    return 1;

  else
  {
    width = (signed int)(screen_sizes[(signed long int)0].cols / (unsigned long int)3);
    height = 2;
    tw = (struct _win_st *)(void *)0;
    sw = tw;
    mw = sw;
    fields[(signed long int)0] = (struct fieldnode *)(void *)0;
    ret = 0;
    i = 0;
    j = i;
    for( ; !((signed int)label[(signed long int)i] == 0); i = i + 1)
    {
      if(j == width + -1 || (signed int)label[(signed long int)i] == 10)
      {
        j = 0;
        height = height + 1;
      }

      j = j + 1;
    }
    y = (signed int)((screen_sizes[(signed long int)0].rows - (unsigned long int)height) / (unsigned long int)2 - (unsigned long int)1);
    x = width;
    sw = (struct _win_st *)(void *)0;
    mw = sw;
    fields[(signed long int)0]=new_field(1, width, 0, 0, 0, 0);
    fields[(signed long int)1] = (struct fieldnode *)(void *)0;
    set_field_back(fields[(signed long int)0], (unsigned long int)1UL << 9 + 8);
    field_opts_off(fields[(signed long int)0], (signed int)0x0040U);
    field_opts_off(fields[(signed long int)0], (signed int)0x0200U);
    signed int return_value_set_field_type$1;
    return_value_set_field_type$1=set_field_type(fields[(signed long int)0], TYPE_REGEXP, re);
    if(!(return_value_set_field_type$1 == 0))
    {
      summary("Failed to apply regexp to field");
      ret = -1;
    }

    else
    {
      f=new_form(fields);
      if(f == ((struct formnode *)NULL))
      {
        applog(3, "%s:new_form(): unable to create form");
        ret = -1;
      }

      else
      {
        mw=derwin(screen_sizes[(signed long int)0].w, height + 2, width + 2, y - 1, x - 1);
        if(mw == ((struct _win_st *)NULL))
        {
          applog(3, "%s:derwin(): unable to create subwindow");
          ret = -1;
        }

        else
        {
          tw=derwin(mw, height, width, 1, 1);
          if(mw == ((struct _win_st *)NULL))
          {
            applog(3, "%s:derwin(): unable to create subwindow");
            ret = -1;
          }

          else
          {
            sw=derwin(mw, 1, width, height, 1);
            if(mw == ((struct _win_st *)NULL))
            {
              applog(3, "%s:derwin(): unable to create subwindow");
              ret = -1;
            }

            else
            {
              set_form_win(f, mw);
              set_form_sub(f, sw);
              wborder(mw, acs_map[(signed long int)(unsigned char)120], acs_map[(signed long int)(unsigned char)120], acs_map[(signed long int)(unsigned char)113], acs_map[(signed long int)(unsigned char)113], acs_map[(signed long int)(unsigned char)108], acs_map[(signed long int)(unsigned char)107], acs_map[(signed long int)(unsigned char)109], acs_map[(signed long int)(unsigned char)106]);
              return_value_wmove$2=wmove(tw, 0, 0);
              if(return_value_wmove$2 == -1)
                -1;

              else
                waddnstr(tw, label, -1);
              post_form(f);
              curs_set(1);
              wrefresh(mw);
              i = 1;
              do
              {
                if(!(i == 0) && !(bts_run == 0))
                {
                  ch=wgetch(stdscr);
                  tmp_if_expr$3 = ch != 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$3 = (_Bool)0;
                if(!tmp_if_expr$3)
                  break;

                if(!(ch == 0632))
                {
                  if(ch == 0x0d || ch == 0527)
                    goto __CPROVER_DUMP_L16;

                  if(ch == 0404)
                    goto __CPROVER_DUMP_L17;

                  if(ch == 0405)
                    goto __CPROVER_DUMP_L18;

                  if(ch == 0407)
                    goto __CPROVER_DUMP_L19;

                  if(ch == 1)
                    goto __CPROVER_DUMP_L20;

                  if(ch == 5)
                    goto __CPROVER_DUMP_L21;

                  if(ch == 21)
                    goto __CPROVER_DUMP_L22;

                  if(ch == 23)
                    goto __CPROVER_DUMP_L23;

                  if(ch == 22)
                    goto __CPROVER_DUMP_L24;

                }

                else
                {
                  ret = 1;

                __CPROVER_DUMP_L16:
                  ;
                  i = 0;
                  goto __CPROVER_DUMP_L25;

                __CPROVER_DUMP_L17:
                  ;
                  ch = 0777 + 27;
                  goto __CPROVER_DUMP_L25;

                __CPROVER_DUMP_L18:
                  ;
                  ch = 0777 + 28;
                  goto __CPROVER_DUMP_L25;

                __CPROVER_DUMP_L19:
                  ;
                  ch = 0777 + 35;
                  goto __CPROVER_DUMP_L25;

                __CPROVER_DUMP_L20:
                  ;
                  ch = 0777 + 23;
                  goto __CPROVER_DUMP_L25;

                __CPROVER_DUMP_L21:
                  ;
                  ch = 0777 + 24;
                  goto __CPROVER_DUMP_L25;

                __CPROVER_DUMP_L22:
                  ;
                  ch = 0777 + 36;
                  goto __CPROVER_DUMP_L25;

                __CPROVER_DUMP_L23:
                  ;
                  ch = 0777 + 37;
                  goto __CPROVER_DUMP_L25;

                __CPROVER_DUMP_L24:
                  ;
                  ch = 0777 + 34;
                }

              __CPROVER_DUMP_L25:
                ;
                if(i == 1)
                  form_driver(f, ch);

              }
              while((_Bool)1);
              curs_set(0);
              if((signed int)bts_run == 0)
                ret = -1;

              else
              {
                return_value_form_driver$9=form_driver(f, 0777 + 55);
                if(!(return_value_form_driver$9 == 0))
                {
                  screen_log("validation failed, input needs to be: %s", re);
                  ret = 1;
                }

                else
                {
                  char *return_value_field_buffer$4;
                  return_value_field_buffer$4=field_buffer(fields[(signed long int)0], 0);
                  cb->len=strlen_minus_spaces(return_value_field_buffer$4);
                  cb->sz = cb->len + (unsigned long int)1;
                  void *return_value_malloc$5;
                  return_value_malloc$5=malloc(sizeof(char) /*1ul*/  * cb->sz);
                  cb->buf = (char *)return_value_malloc$5;
                  if(cb->buf == ((char *)NULL))
                  {
                    signed int *return_value___errno_location$6;
                    return_value___errno_location$6=__errno_location();
                    char *return_value_strerror$7;
                    return_value_strerror$7=strerror(*return_value___errno_location$6);
                    applog(3, "%s::malloc(): %s", (const void *)"screen_textbox", return_value_strerror$7);
                    ret = -1;
                    goto screen_textbox_leave;
                  }

                  char *return_value_field_buffer$8;
                  return_value_field_buffer$8=field_buffer(fields[(signed long int)0], 0);
                  strncpy(cb->buf, return_value_field_buffer$8, cb->len);
                  cb->buf[(signed long int)cb->len] = (char)0;
                }
              }
            }
          }
        }
      }
    }

  screen_textbox_leave:
    ;
    if(!(f == ((struct formnode *)NULL)))
    {
      unpost_form(f);
      free_form(f);
    }

    if(!(fields[0l] == ((struct fieldnode *)NULL)))
      free_field(fields[(signed long int)0]);

    if(!(sw == ((struct _win_st *)NULL)))
      delwin(sw);

    if(!(tw == ((struct _win_st *)NULL)))
      delwin(tw);

    if(!(mw == ((struct _win_st *)NULL)))
      delwin(mw);

    return ret;
  }
}

// sdp_format_classes
// file ./sdp.h line 33
signed int sdp_format_classes(struct device *p, char *buf, signed int sz, signed int len)
{
  unsigned int services;
  unsigned int majorc;
  unsigned int minorc;
  signed int majorc_id;
  signed int found;
  signed int i;
  struct sub_classes *scp;
  services = (p->class & (unsigned int)0x00ffe000) >> 13;
  majorc = (p->class & (unsigned int)0x00001f00) >> 8;
  minorc = p->class & (unsigned int)0x000000fc;
  i = 0;
  found = i;
  majorc_id = found;
  for( ; !(major_device_classes[(signed long int)i].class_name == ((char *)NULL)); i = i + 1)
    if(major_device_classes[(signed long int)i].class_id == majorc)
    {
      found = 1;
      majorc_id = i;
      strncpy(buf + (signed long int)len, major_device_classes[(signed long int)i].class_name, (unsigned long int)(sz - len));
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(major_device_classes[(signed long int)i].class_name);
      len = len + (signed int)return_value_strlen$1;
      break;
    }

  _Bool tmp_if_expr$3;
  if(len >= sz)
    return len;

  else
    if(found == 0)
    {
      i = 0;
      for( ; !(major_device_classes[(signed long int)i].class_name == ((char *)NULL)); i = i + 1)
        if(major_device_classes[(signed long int)i].class_id == 31u)
        {
          strncpy(buf + (signed long int)len, major_device_classes[(signed long int)i].class_name, (unsigned long int)(sz - len));
          unsigned long int return_value_strlen$2;
          return_value_strlen$2=strlen(major_device_classes[(signed long int)i].class_name);
          len = len + (signed int)return_value_strlen$2;
          break;
        }

      if(!(len >= sz))
        goto __CPROVER_DUMP_L8;

      return len;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      if(found == 0)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = !(major_device_classes[(signed long int)majorc_id].sub_major != ((struct sub_classes *)NULL)) ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$3)
      {
        scp = major_device_classes[(signed long int)majorc_id].sub_major;
        i = 0;
        found = i;
        for( ; !((scp + (signed long int)i)->class_name == ((char *)NULL)); i = i + 1)
          if((major_device_classes[(signed long int)majorc_id].sub_major_mask & minorc) == (scp + (signed long int)i)->class_id)
          {
            if(!(found == 0))
              strncpy(buf + (signed long int)len, ",", (unsigned long int)(sz - len));

            else
              strncpy(buf + (signed long int)len, "/", (unsigned long int)(sz - len));
            len = len + 1;
            if(len >= sz)
              return len;

            strncpy(buf + (signed long int)len, (scp + (signed long int)i)->class_name, (unsigned long int)(sz - len));
            unsigned long int return_value_strlen$4;
            return_value_strlen$4=strlen((scp + (signed long int)i)->class_name);
            len = len + (signed int)return_value_strlen$4;
            if(len >= sz)
              return len;

            found = found + 1;
            if((signed int)major_device_classes[(signed long int)majorc_id].type == 1)
              break;

          }

        if(!(major_device_classes[(signed long int)majorc_id].sub_minor == ((struct sub_classes *)NULL)))
        {
          scp = major_device_classes[(signed long int)majorc_id].sub_minor;
          i = 0;
          found = i;
          for( ; !((scp + (signed long int)i)->class_name == ((char *)NULL)); i = i + 1)
            if((major_device_classes[(signed long int)majorc_id].sub_minor_mask & minorc) == (scp + (signed long int)i)->class_id)
            {
              if(!(found == 0))
                strncpy(buf + (signed long int)len, ",", (unsigned long int)(sz - len));

              else
                strncpy(buf + (signed long int)len, "/", (unsigned long int)(sz - len));
              len = len + 1;
              if(len >= sz)
                return len;

              strncpy(buf + (signed long int)len, (scp + (signed long int)i)->class_name, (unsigned long int)(sz - len));
              unsigned long int return_value_strlen$5;
              return_value_strlen$5=strlen((scp + (signed long int)i)->class_name);
              len = len + (signed int)return_value_strlen$5;
              if(len >= sz)
                return len;

              found = found + 1;
              if((signed int)major_device_classes[(signed long int)majorc_id].type == 1)
                break;

            }

        }

      }


    sdp_format_classes_services:
      ;
      strncpy(buf + (signed long int)len, "\nServices:      ", (unsigned long int)(sz - len));
      len = len + 16;
      if(len >= sz)
        return len;

      else
      {
        i = 0;
        found = i;
        for( ; !(service_classes[(signed long int)i].class_name == ((char *)NULL)); i = i + 1)
          if(!((service_classes[(signed long int)i].class_id & services) == 0u))
          {
            if(!(found == 0))
            {
              strncpy(buf + (signed long int)len, ",", (unsigned long int)(sz - len));
              len = len + 1;
              if(len >= sz)
                return len;

            }

            strncpy(buf + (signed long int)len, service_classes[(signed long int)i].class_name, (unsigned long int)(sz - len));
            unsigned long int return_value_strlen$6;
            return_value_strlen$6=strlen(service_classes[(signed long int)i].class_name);
            len = len + (signed int)return_value_strlen$6;
            if(len >= sz)
              return len;

            found = 1;
          }

        strncpy(buf + (signed long int)len, "\n", (unsigned long int)(sz - len));
        len = len + 1;
        return len;
      }
    }
}

// sdp_get_service_classes
// file /usr/include/bluetooth/sdp_lib.h line 215
static inline signed int sdp_get_service_classes(const struct anonymous$2 *rec, struct _sdp_list **seqp)
{
  signed int return_value_sdp_get_uuidseq_attr$1;
  return_value_sdp_get_uuidseq_attr$1=sdp_get_uuidseq_attr(rec, (unsigned short int)0x0001, seqp);
  return return_value_sdp_get_uuidseq_attr$1;
}

// sdp_list_foreach
// file /usr/include/bluetooth/sdp_lib.h line 66
static inline void sdp_list_foreach(struct _sdp_list *list, void (*f)(void *, void *), void *u)
{
  if(!(list == ((struct _sdp_list *)NULL)))
  {
    f(list->data, u);
    list = list->next;
  }

}

// sdp_sprint_service_attr
// file sdp.c line 477
signed int sdp_sprint_service_attr(struct cbuf *str, struct anonymous$2 *rec)
{
  struct _sdp_list *list = ((struct _sdp_list *)NULL);
  struct _sdp_list *proto = ((struct _sdp_list *)NULL);
  struct sdp_data_struct *d;
  if(str == ((struct cbuf *)NULL))
    return 0;

  else
    if(str->len >= str->sz)
      return 1;

    else
    {
      d=sdp_data_get(rec, (unsigned short int)(0x0000 + 0x0100));
      if(!(d == ((struct sdp_data_struct *)NULL)))
      {
        signed int return_value_snprintf$1;
        return_value_snprintf$1=snprintf(str->buf + (signed long int)str->len, str->sz, "Service Name: %s\n", d->val.str);
        str->len = str->len + (unsigned long int)return_value_snprintf$1;
        if(str->len >= str->sz)
          return 1;

      }

      d=sdp_data_get(rec, (unsigned short int)(0x0001 + 0x0100));
      if(!(d == ((struct sdp_data_struct *)NULL)))
      {
        signed int return_value_snprintf$2;
        return_value_snprintf$2=snprintf(str->buf + (signed long int)str->len, str->sz, "Service Description: %s\n", d->val.str);
        str->len = str->len + (unsigned long int)return_value_snprintf$2;
        if(str->len >= str->sz)
          return 1;

      }

      d=sdp_data_get(rec, (unsigned short int)(0x0002 + 0x0100));
      if(!(d == ((struct sdp_data_struct *)NULL)))
      {
        signed int return_value_snprintf$3;
        return_value_snprintf$3=snprintf(str->buf + (signed long int)str->len, str->sz, "Service Provider: %s\n", d->val.str);
        str->len = str->len + (unsigned long int)return_value_snprintf$3;
        if(str->len >= str->sz)
          return 1;

      }

      signed int return_value_snprintf$4;
      return_value_snprintf$4=snprintf(str->buf + (signed long int)str->len, str->sz, "Service RecHandle: 0x%x\n", rec->handle);
      str->len = str->len + (unsigned long int)return_value_snprintf$4;
      if(str->len >= str->sz)
        return 1;

      else
      {
        signed int return_value_sdp_get_service_classes$6;
        return_value_sdp_get_service_classes$6=sdp_get_service_classes(rec, &list);
        if(return_value_sdp_get_service_classes$6 == 0)
        {
          signed int return_value_snprintf$5;
          return_value_snprintf$5=snprintf(str->buf + (signed long int)str->len, str->sz, "Service Class ID List:\n");
          str->len = str->len + (unsigned long int)return_value_snprintf$5;
          if(str->len >= str->sz)
            return 1;

          sdp_list_foreach(list, print_service_class, (void *)str);
          sdp_list_free(list, free);
          if(str->len >= str->sz)
            return 1;

        }

        signed int return_value_sdp_get_access_protos$8;
        return_value_sdp_get_access_protos$8=sdp_get_access_protos(rec, &proto);
        if(return_value_sdp_get_access_protos$8 == 0)
        {
          signed int return_value_snprintf$7;
          return_value_snprintf$7=snprintf(str->buf + (signed long int)str->len, str->sz, "Protocol Descriptor List:\n");
          str->len = str->len + (unsigned long int)return_value_snprintf$7;
          if(str->len >= str->sz)
            return 1;

          sdp_list_foreach(proto, print_access_protos, (void *)str);
          sdp_list_free(proto, (void (*)(void *))sdp_data_free);
          if(str->len >= str->sz)
            return 1;

        }

        signed int return_value_sdp_get_lang_attr$10;
        return_value_sdp_get_lang_attr$10=sdp_get_lang_attr(rec, &list);
        if(return_value_sdp_get_lang_attr$10 == 0)
        {
          signed int return_value_snprintf$9;
          return_value_snprintf$9=snprintf(str->buf + (signed long int)str->len, str->sz, "Language Base Attr List:\n");
          str->len = str->len + (unsigned long int)return_value_snprintf$9;
          if(str->len >= str->sz)
            return 1;

          sdp_list_foreach(list, print_lang_attr, (void *)str);
          sdp_list_free(list, free);
          if(str->len >= str->sz)
            return 1;

        }

        signed int return_value_sdp_get_profile_descs$12;
        return_value_sdp_get_profile_descs$12=sdp_get_profile_descs(rec, &list);
        if(return_value_sdp_get_profile_descs$12 == 0)
        {
          signed int return_value_snprintf$11;
          return_value_snprintf$11=snprintf(str->buf + (signed long int)str->len, str->sz, "Profile Descriptor List:\n");
          str->len = str->len + (unsigned long int)return_value_snprintf$11;
          if(str->len >= str->sz)
            return 1;

          sdp_list_foreach(list, print_profile_desc, (void *)str);
          sdp_list_free(list, free);
          if(str->len >= str->sz)
            return 1;

        }

        strncpy(str->buf + (signed long int)str->len, "\n", str->sz - str->len);
        str->len = str->len + 1ul;
        if(str->len >= str->sz)
          return 1;

        else
          return 0;
      }
    }
}

// store_appendfile
// file store.c line 197
signed int store_appendfile(char *fn, unsigned long int fn_len, struct cbuf *cb)
{
  struct stat sbuf;
  signed int fd;
  unsigned long int ret;
  _Bool tmp_if_expr$1;
  if(fn == ((char *)NULL) || cb == ((struct cbuf *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(cb->buf != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 1;

  else
  {
    signed int return_value_store_mkdir_from_filename$2;
    return_value_store_mkdir_from_filename$2=store_mkdir_from_filename(fn, fn_len, &sbuf);
    if(!(return_value_store_mkdir_from_filename$2 == 0))
      return 1;

    else
      if(!((128u & sbuf.st_mode) == 128u))
      {
        applog(4, "%s(): store device directory is not writable", (const void *)"store_appendfile");
        return 1;
      }

      else
      {
        fd=open(fn, 01 | 0100 | 02000, 0400 >> 3 | 0200 >> 3);
        if(fd == -1)
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          char *return_value_strerror$4;
          return_value_strerror$4=strerror(*return_value___errno_location$3);
          applog(4, "%s::open(): %s", (const void *)"store_appendfile", return_value_strerror$4);
          return 1;
        }

        signed long int return_value_write$5;
        return_value_write$5=write(fd, (const void *)cb->buf, cb->len);
        ret = (unsigned long int)return_value_write$5;
        if((signed int)ret == -1)
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          char *return_value_strerror$7;
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          applog(4, "%s::write(): %s", (const void *)"store_appendfile", return_value_strerror$7);
          return 1;
        }

        else
          if(!(ret == cb->len))
          {
            applog(4, "%s::write(): not all bytes written", (const void *)"store_appendfile");
            return 1;
          }

        close(fd);
        return 0;
      }
  }
}

// store_conv_filename
// file store.c line 235
void store_conv_filename(char *tmp)
{
  signed int i = 0;
  for( ; !((signed int)tmp[(signed long int)i] == 0); i = i + 1)
    if((signed int)tmp[(signed long int)i] == 58)
      tmp[(signed long int)i] = (char)95;

}

// store_device
// file store.c line 244
signed int store_device(struct device *dev)
{
  const char *d;
  char *fn;
  char tmp[32l];
  struct stat sbuf;
  struct cbuf cb;
  unsigned long int fn_sz;
  unsigned long int fn_len;
  signed int ret = 0;
  unsigned long int did;
  d=cfg_store_filename();
  if(d == ((const char *)NULL))
  {
    applog(4, "%s(): Null store directory", (const void *)"store_device");
    return 1;
  }

  else
  {
    signed int return_value_stat$5;
    return_value_stat$5=stat(d, &sbuf);
    if(!(return_value_stat$5 == 0))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      if(*return_value___errno_location$4 == 2)
      {
        signed int return_value_store_mkdir_recursive$1;
        return_value_store_mkdir_recursive$1=store_mkdir_recursive(d, &sbuf);
        if(!(return_value_store_mkdir_recursive$1 == 0))
          return 1;

      }

      else
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        char *return_value_strerror$3;
        return_value_strerror$3=strerror(*return_value___errno_location$2);
        applog(4, "%s::stat(): %s", (const void *)"store_device", return_value_strerror$3);
        return 1;
      }
    }

    if(!((128u & sbuf.st_mode) == 128u))
    {
      applog(4, "%s(): store directory is not writable", (const void *)"store_device");
      return 1;
    }

    else
    {
      memset((void *)&cb, 0, sizeof(struct cbuf) /*24ul*/ );
      fn_len = (unsigned long int)0;
      fn_sz = fn_len;
      did=bd2int(&dev->bdaddr);
      signed int return_value_ll_print_dev_info$6;
      return_value_ll_print_dev_info$6=ll_print_dev_info(did, &cb);
      if(!(return_value_ll_print_dev_info$6 == 0))
        return 1;

      else
      {
        ll_lock_list();
        ba2str(&dev->bdaddr, tmp);
        ll_unlock_list();
        tmp[(signed long int)31] = (char)0;
        store_conv_filename(tmp);
        fn = (char *)(void *)0;
        while((_Bool)1)
        {
          fn_sz = fn_sz + (unsigned long int)2048;
          void *return_value_realloc$7;
          return_value_realloc$7=realloc((void *)fn, sizeof(char) /*1ul*/  * fn_sz);
          fn = (char *)return_value_realloc$7;
          if(fn == ((char *)NULL))
          {
            signed int *return_value___errno_location$8;
            return_value___errno_location$8=__errno_location();
            char *return_value_strerror$9;
            return_value_strerror$9=strerror(*return_value___errno_location$8);
            applog(3, "%s::malloc(): %s", (const void *)"store_device", return_value_strerror$9);
            if(!(cb.buf == ((char *)NULL)))
              free((void *)cb.buf);

            return 1;
          }

          signed int return_value_snprintf$10;
          return_value_snprintf$10=snprintf(fn, fn_sz, "%s/%s/info", d, (const void *)tmp);
          fn_len = (unsigned long int)return_value_snprintf$10;
          if(!(fn_len >= fn_sz))
            break;

        }
        signed int return_value_store_writefile$11;
        return_value_store_writefile$11=store_writefile(fn, fn_len, &cb);
        if(!(return_value_store_writefile$11 == 0))
        {
          if(!(cb.buf == ((char *)NULL)))
            free((void *)cb.buf);

          if(!(fn == ((char *)NULL)))
            free((void *)fn);

          return 1;
        }

        else
        {
          fn_len = (unsigned long int)0;
          if(!(cb.buf == ((char *)NULL)))
            free((void *)cb.buf);

          cb.buf = (char *)(void *)0;
          if(!(fn == ((char *)NULL)))
            free((void *)fn);

          return ret;
        }
      }
    }
  }
}

// store_mkdir_from_filename
// file store.c line 141
signed int store_mkdir_from_filename(char *d, unsigned long int d_len, struct stat *sbuf)
{
  signed int ret = 0;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(d_len == 0ul))
      tmp_if_expr$1 = 47 != (signed int)d[(signed long int)d_len] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    d_len = d_len - 1ul;
  }
  while((_Bool)1);
  if(d_len == 0ul)
    return 1;

  else
  {
    d[(signed long int)d_len] = (char)0;
    ret=store_mkdir_recursive(d, sbuf);
    d[(signed long int)d_len] = (char)47;
    return ret;
  }
}

// store_mkdir_recursive
// file store.c line 87
signed int store_mkdir_recursive(const char *d, struct stat *sbuf)
{
  char *dir;
  unsigned long int i;
  dir=strdup(d);
  if(dir == ((char *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    applog(3, "%s::strdup(): %s", (const void *)"store_mkdir_recursive", return_value_strerror$2);
    return 1;
  }

  i = (unsigned long int)0;
  _Bool tmp_if_expr$10;
  do
  {
    if((signed int)dir[(signed long int)i] == 47)
      tmp_if_expr$10 = (_Bool)1;

    else
      tmp_if_expr$10 = 0 == (signed int)dir[(signed long int)i] ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$10)
    {
      if(i >= 1ul)
      {
        dir[(signed long int)i] = (char)0;
        signed int return_value_stat$6;
        return_value_stat$6=stat(dir, sbuf);
        if(!(return_value_stat$6 == 0))
        {
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          if(!(*return_value___errno_location$5 == 2))
          {
            signed int *return_value___errno_location$3;
            return_value___errno_location$3=__errno_location();
            char *return_value_strerror$4;
            return_value_strerror$4=strerror(*return_value___errno_location$3);
            applog(4, "%s::stat(): %s", (const void *)"store_mkdir_recursive", return_value_strerror$4);
            free((void *)dir);
            return 1;
          }

        }

        else
          goto store_mkdir_recursive_next;
        signed int return_value_mkdir$9;
        return_value_mkdir$9=mkdir(dir, (unsigned int)(0400 | 0200 | 0100));
        if(!(return_value_mkdir$9 == 0))
        {
          signed int *return_value___errno_location$7;
          return_value___errno_location$7=__errno_location();
          char *return_value_strerror$8;
          return_value_strerror$8=strerror(*return_value___errno_location$7);
          applog(4, "%s::mkdir(): %s", (const void *)"store_mkdir_recursive", return_value_strerror$8);
          free((void *)dir);
          return 1;
        }


      store_mkdir_recursive_next:
        ;
        if((signed int)d[(signed long int)i] == 0)
          break;

        else
          dir[(signed long int)i] = (char)47;
      }

    }

    i = i + 1ul;
  }
  while((_Bool)1);
  free((void *)dir);
  signed int return_value_stat$13;
  return_value_stat$13=stat(d, sbuf);
  if(!(return_value_stat$13 == 0))
  {
    signed int *return_value___errno_location$11;
    return_value___errno_location$11=__errno_location();
    char *return_value_strerror$12;
    return_value_strerror$12=strerror(*return_value___errno_location$11);
    applog(4, "%s::stat(): %s", (const void *)"store_mkdir_recursive", return_value_strerror$12);
    return 1;
  }

  return 0;
}

// store_timestamp
// file store.c line 325
signed int store_timestamp(struct device *dev)
{
  const char *d;
  char *fn;
  char tmp[32l];
  struct stat sbuf;
  struct cbuf cb;
  unsigned long int fn_sz;
  unsigned long int fn_len;
  signed int ret = 0;
  d=cfg_store_filename();
  if(d == ((const char *)NULL))
  {
    applog(4, "%s(): Null store directory", (const void *)"store_timestamp");
    return 1;
  }

  else
  {
    signed int return_value_stat$5;
    return_value_stat$5=stat(d, &sbuf);
    if(!(return_value_stat$5 == 0))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      if(*return_value___errno_location$4 == 2)
      {
        signed int return_value_store_mkdir_recursive$1;
        return_value_store_mkdir_recursive$1=store_mkdir_recursive(d, &sbuf);
        if(!(return_value_store_mkdir_recursive$1 == 0))
          return 1;

      }

      else
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        char *return_value_strerror$3;
        return_value_strerror$3=strerror(*return_value___errno_location$2);
        applog(4, "%s::stat(): %s", (const void *)"store_timestamp", return_value_strerror$3);
        return 1;
      }
    }

    if(!((128u & sbuf.st_mode) == 128u))
    {
      applog(4, "%s(): store directory is not writable", (const void *)"store_timestamp");
      return 1;
    }

    else
    {
      memset((void *)&cb, 0, sizeof(struct cbuf) /*24ul*/ );
      fn_len = (unsigned long int)0;
      fn_sz = fn_len;
      signed int return_value_ll_print_timestamp$6;
      return_value_ll_print_timestamp$6=ll_print_timestamp(dev, &cb);
      if(!(return_value_ll_print_timestamp$6 == 0))
        return 1;

      else
      {
        ll_lock_list();
        ba2str(&dev->bdaddr, tmp);
        ll_unlock_list();
        tmp[(signed long int)31] = (char)0;
        store_conv_filename(tmp);
        fn = (char *)(void *)0;
        while((_Bool)1)
        {
          fn_sz = fn_sz + (unsigned long int)2048;
          void *return_value_realloc$7;
          return_value_realloc$7=realloc((void *)fn, sizeof(char) /*1ul*/  * fn_sz);
          fn = (char *)return_value_realloc$7;
          if(fn == ((char *)NULL))
          {
            signed int *return_value___errno_location$8;
            return_value___errno_location$8=__errno_location();
            char *return_value_strerror$9;
            return_value_strerror$9=strerror(*return_value___errno_location$8);
            applog(3, "%s::malloc(): %s", (const void *)"store_timestamp", return_value_strerror$9);
            if(!(cb.buf == ((char *)NULL)))
              free((void *)cb.buf);

            return 1;
          }

          signed int return_value_snprintf$10;
          return_value_snprintf$10=snprintf(fn, fn_sz, "%s/%s/timestamps", d, (const void *)tmp);
          fn_len = (unsigned long int)return_value_snprintf$10;
          if(!(fn_len >= fn_sz))
            break;

        }
        signed int return_value_store_appendfile$11;
        return_value_store_appendfile$11=store_appendfile(fn, fn_len, &cb);
        if(!(return_value_store_appendfile$11 == 0))
        {
          if(!(cb.buf == ((char *)NULL)))
            free((void *)cb.buf);

          if(!(fn == ((char *)NULL)))
            free((void *)fn);

          return 1;
        }

        else
        {
          if(!(cb.buf == ((char *)NULL)))
            free((void *)cb.buf);

          if(!(fn == ((char *)NULL)))
            free((void *)fn);

          return ret;
        }
      }
    }
  }
}

// store_writefile
// file store.c line 158
signed int store_writefile(char *fn, unsigned long int fn_len, struct cbuf *cb)
{
  struct stat sbuf;
  signed int fd;
  unsigned long int ret;
  _Bool tmp_if_expr$1;
  if(fn == ((char *)NULL) || cb == ((struct cbuf *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(cb->buf != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 1;

  else
  {
    signed int return_value_store_mkdir_from_filename$2;
    return_value_store_mkdir_from_filename$2=store_mkdir_from_filename(fn, fn_len, &sbuf);
    if(!(return_value_store_mkdir_from_filename$2 == 0))
      return 1;

    else
      if(!((128u & sbuf.st_mode) == 128u))
      {
        applog(4, "%s(): store device directory is not writable", (const void *)"store_writefile");
        return 1;
      }

      else
      {
        fd=open(fn, 01 | 0100 | 01000, 0400 >> 3 | 0200 >> 3);
        if(fd == -1)
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          char *return_value_strerror$4;
          return_value_strerror$4=strerror(*return_value___errno_location$3);
          applog(4, "%s::open(): %s", (const void *)"store_writefile", return_value_strerror$4);
          return 1;
        }

        signed long int return_value_write$5;
        return_value_write$5=write(fd, (const void *)cb->buf, cb->len);
        ret = (unsigned long int)return_value_write$5;
        if((signed int)ret == -1)
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          char *return_value_strerror$7;
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          applog(4, "%s::write(): %s", (const void *)"store_writefile", return_value_strerror$7);
          return 1;
        }

        else
          if(!(ret == cb->len))
          {
            applog(4, "%s::write(): not all bytes written", (const void *)"store_writefile");
            return 1;
          }

        close(fd);
        return 0;
      }
  }
}

// strlen_minus_spaces
// file screen.c line 810
unsigned long int strlen_minus_spaces(const char *s)
{
  unsigned long int i;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(s);
  i = return_value_strlen$1 - (unsigned long int)1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  do
  {
    if((signed int)i >= 0)
    {
      if((signed int)s[(signed long int)i] == 32)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)s[(signed long int)i] == 0 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    i = i - 1ul;
  }
  while((_Bool)1);
  return i + (unsigned long int)1;
}

// summary
// file ./log.h line 37
signed int summary(const char *fmt, ...)
{
  void **ap;
  if(log_sum_fp == ((struct _IO_FILE *)NULL))
    return 1;

  else
  {
    pthread_mutex_lock(&log_smux);
    ap = (void **)&fmt;
    vfprintf(log_sum_fp, fmt, ap);
    ap = ((void **)NULL);
    fprintf(log_sum_fp, "\n");
    fflush(log_sum_fp);
    pthread_mutex_unlock(&log_smux);
    return 0;
  }
}

// threader_reap
// file threader.c line 146
signed int threader_reap(void)
{
  struct hcicfg *h;
  signed int i = 0;
  h = hcihead;
  for( ; !(h == ((struct hcicfg *)NULL)); h = h->next)
    if(!(h->tid == 0ul))
    {
      if((signed int)h->died == 0)
        i = i + 1;

      else
      {
        signed int return_value_pthread_join$3;
        return_value_pthread_join$3=pthread_join(h->tid, (void **)(void *)0);
        if(!(return_value_pthread_join$3 == 0))
        {
          signed int *return_value___errno_location$1;
          return_value___errno_location$1=__errno_location();
          char *return_value_strerror$2;
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          applog(4, "%s::pthread_join(): %s", (const void *)"threader_reap", return_value_strerror$2);
        }

        else
          applog(6, "%s::pthread_join(): joined thread %d", (const void *)"threader_reap", h->tid);
        h->tid = (unsigned long int)0;
      }
    }

  return i;
}

// threader_running
// file threader.c line 192
signed int threader_running(void)
{
  return (signed int)threader_current;
}

// threader_running_desc
// file threader.c line 196
const char * threader_running_desc(enum threader_scan_types what)
{
  signed int i = 0;
  for( ; !((signed int)thread_starter[(signed long int)i].what == SCAN_NONE); i = i + 1)
    if(what == thread_starter[(signed long int)i].what)
      break;

  return thread_starter[(signed long int)i].desc;
}

// threader_start
// file threader.c line 98
signed int threader_start(enum threader_scan_types what)
{
  struct hcicfg *h;
  signed int i;
  signed int j;
  signed int st;
  bts_run_scan = (char)1;
  st = 0;
  h = hcihead;
  _Bool tmp_if_expr$1;
  for( ; !(h == ((struct hcicfg *)NULL)); h = h->next)
    if(!(h->enabled == 0))
    {
      i = 0;
      do
      {
        if(!((signed int)thread_starter[(signed long int)i].what == SCAN_NONE))
          tmp_if_expr$1 = thread_starter[(signed long int)i].what != what ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(!tmp_if_expr$1)
          break;

        i = i + 1;
      }
      while((_Bool)1);
      if(!((signed int)thread_starter[(signed long int)i].what == SCAN_NONE))
      {
        h->died = (unsigned char)0;
        j=pthread_create(&h->tid, (const union pthread_attr_t *)(void *)0, thread_starter[(signed long int)i].func, (void *)h);
        if(!(j == 0))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          char *return_value_strerror$3;
          return_value_strerror$3=strerror(*return_value___errno_location$2);
          applog(4, "%s::pthread_create(): %s", (const void *)"threader_start", return_value_strerror$3);
          h->tid = (unsigned long int)0;
          return -1;
        }

        else
        {
          st = st + 1;
          applog(6, "%s::pthread_create(): created thread %d", (const void *)"threader_start", h->tid);
        }
      }

    }

  if(st >= 1)
    threader_current = what;

  return st;
}

// threader_stop
// file threader.c line 179
signed int threader_stop(void)
{
  signed int return_value_threader_reap$1;
  if((signed int)threader_current == SCAN_NONE)
    return 0;

  else
  {
    bts_run_scan = (char)0;
    do
    {
      return_value_threader_reap$1=threader_reap();
      if(return_value_threader_reap$1 == 0)
        break;

      sleep((unsigned int)2);
    }
    while((_Bool)1);
    threader_current = (enum threader_scan_types)SCAN_NONE;
    return 0;
  }
}

// usage
// file main.c line 105
void usage(char *pname)
{
  fprintf(stderr, "Usage: %s [options]\n", pname);
  fprintf(stderr, "options\n\t--help\tDisplay help\n");
  fprintf(stderr, "\t--cfg=<file>\tUse <file> as the config file\n");
  fprintf(stderr, "\t--no-reset\tDo not reset the Bluetooth adapter before scanning\n");
}

