// tag-#anon#ST[*{*{S32}$S32$(*{V}$V$)->*{S32}$S32$}$*{S32}$S32$(*{V}$V$)->*{S32}$S32$$'fun'||*{V}$V$'state'|]
// file lglib.c line 838
struct anonymous$93;

// tag-#anon#ST[*{S32(*{V}$V$)->S32}$S32(*{V}$V$)->S32$'fun'||*{V}$V$'state'||S32'done'||U32'$pad0'|]
// file lglib.c line 832
struct anonymous$89;

// tag-#anon#ST[*{S32}$S32$'cls'||S32'origlhs'||U32'$pad0'|]
// file lglib.c line 723
struct anonymous$56;

// tag-#anon#ST[*{SYM#tag-LGL#}$SYM#tag-LGL#$'lgl'||S32'count'||S32'bcount'||S64'decs'||S64'confs'||S64'props'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'lock'|]
// file ilingeling.c line 82
struct anonymous$1;

// tag-#anon#ST[*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'lock'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'unlock'||*{V}$V$'state'|]
// file lglib.c line 841
struct anonymous$96;

// tag-#anon#ST[*{V(*{V}$V$|*{*{S32}$S32$}$*{S32}$S32$$|*{*{S32}$S32$}$*{S32}$S32$$)->V}$V(*{V}$V$|*{*{S32}$S32$}$*{S32}$S32$$|*{*{S32}$S32$}$*{S32}$S32$$)->V$'fun'||*{V}$V$'state'|]
// file lglib.c line 835
struct anonymous$91;

// tag-#anon#ST[*{V(*{V}$V$|S32)->V}$V(*{V}$V$|S32)->V$'fun'||*{V}$V$'state'|]
// file lglib.c line 834
struct anonymous$90;

// tag-#anon#ST[*{V(*{V}$V$|S32|S32)->V}$V(*{V}$V$|S32|S32)->V$'fun'||*{V}$V$'state'|]
// file lglib.c line 839
struct anonymous$94;

// tag-#anon#ST[F64'all'||F64'basic'|]
// file lglib.c line 808
struct anonymous$76;

// tag-#anon#ST[S32'all'||S32'and'||S32'xor'||S32'ite'|]
// file lglib.c line 756
struct anonymous$63;

// tag-#anon#ST[S32'all'||S32'and'||S32'xor'||S32'ite'||S32'org'|]
// file lglib.c line 848
struct anonymous$98;

// tag-#anon#ST[S32'basic'|]
// file lglib.c line 822
struct anonymous$83;

// tag-#anon#ST[S32'bin'||S32'trn'||S32'lrg'|]
// file lglib.c line 750
struct anonymous$15;

// tag-#anon#ST[S32'bin'||S32'trn'||S32'lrg'||S32'red'|]
// file lglib.c line 768
struct anonymous$68;

// tag-#anon#ST[S32'clauses'|]
// file lglib.c line 733
struct anonymous$6;

// tag-#anon#ST[S32'clauses'||U32'$pad0'||S64'added'||S64'reduced'||S64'resolved'||S64'forcing'||S64'conflicts'||S64'saved'|]
// file lglib.c line 782
struct anonymous$30;

// tag-#anon#ST[S32'cnt'||S32'trn'||S32'lrg'||S32'sub'|]
// file lglib.c line 751
struct anonymous$16;

// tag-#anon#ST[S32'cond'||S32'pos'||S32'neg'|]
// file lglib.c line 724
struct anonymous$57;

// tag-#anon#ST[S32'count'||S32'bin'||S32'trn'||U32'$pad0'||S64'steps'|]
// file lglib.c line 753
struct anonymous$18;

// tag-#anon#ST[S32'count'||S32'clauses'||S32'lits'||S32'pure'||S64'res'||S64'steps'|]
// file lglib.c line 754
struct anonymous$19;

// tag-#anon#ST[S32'count'||S32'eliminated'||S32'ate'||S32'abce'||S32'failed'||S32'lifted'||S64'steps'||S64'probed'|]
// file lglib.c line 796
struct anonymous$37;

// tag-#anon#ST[S32'count'||S32'elmd'||S32'large'||S32'sub'||S32'str'||S32'blkd'||SYM#tag-#anon#ST[S32'elm'||S32'tried'||S32'failed'|]#'small'||U32'$pad0'||S64'resolutions'||S64'copies'||S64'subchks'||S64'strchks'||S64'ipos'||S64'steps'|]
// file lglib.c line 773
struct anonymous$26;

// tag-#anon#ST[S32'count'||S32'eq'||S32'units'||U32'$pad0'||S64'esteps'||S64'csteps'||SYM#tag-#anon#ST[S32'all'||S32'and'||S32'xor'||S32'ite'|]#'matched'||SYM#tag-#anon#ST[S32'all'||S32'and'||S32'xor'||S32'ite'|]#'simplified'||SYM#tag-#anon#ST[S64'all'||S64'and'||S64'xor'||S64'ite'|]#'extracted'|]
// file lglib.c line 755
struct anonymous$20;

// tag-#anon#ST[S32'count'||S32'eqs'||S32'units'||S32'impls'||S64'probed0'||S64'probed1'|]
// file lglib.c line 762
struct anonymous$22;

// tag-#anon#ST[S32'count'||S32'failed'||S32'lifted'||U32'$pad0'||S64'decisions'||S64'steps'|]
// file lglib.c line 798
struct anonymous$38;

// tag-#anon#ST[S32'count'||S32'failed'||S32'lifted'||U32'$pad0'||S64'probed'||S64'steps'|]
// file lglib.c line 760
struct anonymous$65;

// tag-#anon#ST[S32'count'||S32'gcs'||S32'units'||S32'equivs'||S32'trneqs'||U32'$pad0'||SYM#tag-#anon#ST[S32'max'||U32'$pad0'||S64'sum'|]#'arity'||SYM#tag-#anon#ST[S64'extr'||S64'elim'|]#'steps'||S64'extracted'|]
// file lglib.c line 792
struct anonymous$36;

// tag-#anon#ST[S32'count'||S32'plimhit'||S32'ilimhit'||S32'climhit'|]
// file lglib.c line 788
struct anonymous$33;

// tag-#anon#ST[S32'count'||S32'red'||S32'failed'||U32'$pad0'||S64'lits'||S64'bins'||S64'steps'|]
// file lglib.c line 763
struct anonymous$23;

// tag-#anon#ST[S32'count'||S32'reset'||S32'geom'||S32'arith'||S32'arith2'|]
// file lglib.c line 736
struct anonymous$8;

// tag-#anon#ST[S32'count'||S32'rounds'||SYM#tag-#anon#ST[S32'trds'||S32'failed'||S32'sccs'||U32'$pad0'||S64'sumsccsizes'|]#'stamp'||SYM#tag-#anon#ST[S32'lits'||S32'bin'||S32'trn'||S32'lrg'|]#'failed'||SYM#tag-#anon#ST[S32'bin'||S32'trn'||S32'lrg'||S32'red'|]#'tauts'||SYM#tag-#anon#ST[S32'bin'||S32'trn'||S32'lrg'|]#'units'||SYM#tag-#anon#ST[S32'trn'||S32'lrg'||S32'red'|]#'hbrs'||SYM#tag-#anon#ST[S32'trn'||S32'lrg'||S32'red'|]#'str'||U32'$pad0'||S64'steps'|]
// file lglib.c line 765
struct anonymous$25;

// tag-#anon#ST[S32'count'||S32'skipped'||SYM#tag-#anon#ST[S32'count'||U32'$pad0'||S64'sum'|]#'kept'|]
// file lglib.c line 734
struct anonymous$7;

// tag-#anon#ST[S32'count'||U32'$pad0'||S64'set'||S64'pos'||S64'neg'|]
// file lglib.c line 787
struct anonymous$32;

// tag-#anon#ST[S32'count'||U32'$pad0'||S64'steps'|]
// file lglib.c line 789
struct anonymous$34;

// tag-#anon#ST[S32'count'||U32'$pad0'||S64'sum'|]
// file lglib.c line 699
struct anonymous$4;

// tag-#anon#ST[S32'cur'||S32'max'||S64'add'|]
// file lglib.c line 739
struct anonymous$40;

// tag-#anon#ST[S32'current'||S32'sum'|]
// file lglib.c line 752
struct anonymous$17;

// tag-#anon#ST[S32'elm'||S32'tried'||S32'failed'|]
// file lglib.c line 775
struct anonymous$70;

// tag-#anon#ST[S32'inner'||S32'outer'||S32'extra'|]
// file lglib.c line 816
struct anonymous$77;

// tag-#anon#ST[S32'irr'||S32'red'|]
// file lglib.c line 778
struct anonymous$75;

// tag-#anon#ST[S32'lits'||S32'bin'||S32'trn'||S32'lrg'|]
// file lglib.c line 767
struct anonymous$67;

// tag-#anon#ST[S32'max'||S32'min'|]
// file lglib.c line 732
struct anonymous$59;

// tag-#anon#ST[S32'max'||U32'$pad0'||S64'sum'|]
// file lglib.c line 793
struct anonymous$72;

// tag-#anon#ST[S32'min'||S32'avg'||S32'max'|]
// file lglib.c line 745
struct anonymous$74;

// tag-#anon#ST[S32'pen'||U32'$pad0'||S64'esteps'||S64'csteps'|]
// file lglib.c line 817
struct anonymous$78;

// tag-#anon#ST[S32'pen'||U32'$pad0'||S64'steps'|]
// file lglib.c line 819
struct anonymous$80;

// tag-#anon#ST[S32'pen'||U32'$pad0'||S64'steps'||S64'irrprgss'|]
// file lglib.c line 818
struct anonymous$79;

// tag-#anon#ST[S32'pen'||U32'$pad0'||SYM#tag-#anon#ST[S64'extr'||S64'elim'|]#'steps'|]
// file lglib.c line 820
struct anonymous$81;

// tag-#anon#ST[S32'removed'||S32'red'|]
// file lglib.c line 764
struct anonymous$24;

// tag-#anon#ST[S32'total'||S32'pos'||S32'neg'|]
// file lglib.c line 743
struct anonymous$60;

// tag-#anon#ST[S32'total'||S32'unit'||S32'bin'||S32'trn'||S32'lrg'|]
// file lglib.c line 744
struct anonymous$61;

// tag-#anon#ST[S32'trds'||S32'failed'||S32'sccs'||U32'$pad0'||S64'sumsccsizes'|]
// file lglib.c line 766
struct anonymous$66;

// tag-#anon#ST[S32'trn'||S32'lrg'||S32'red'|]
// file lglib.c line 770
struct anonymous$69;

// tag-#anon#ST[S32'units'||S32'eq'||S32'all'||S32'and'||S32'xor'||S32'ite'||S32'org'|]
// file lglib.c line 847
struct anonymous$97;

// tag-#anon#ST[S32'vars'||SYM#tag-#anon#ST[S32'total'||S32'pos'||S32'neg'|]#'lits'||SYM#tag-#anon#ST[S32'total'||S32'unit'||S32'bin'||S32'trn'||S32'lrg'|]#'clauses'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32'min'||S32'avg'||S32'max'|]#'val'||SYM#tag-#anon#ST[S32'min'||S32'avg'||S32'max'|]#'var'|]#'cog'|]
// file lglib.c line 742
struct anonymous$11;

// tag-#anon#ST[S64'all'||S64'and'||S64'xor'||S64'ite'|]
// file lglib.c line 758
struct anonymous$64;

// tag-#anon#ST[S64'bin'||S64'trn'|]
// file lglib.c line 799
struct anonymous$39;

// tag-#anon#ST[S64'confs'||S32'wasmaxdelta'||S32'maxdelta'||S32'luby'||S32'inout'|]
// file lglib.c line 821
struct anonymous$82;

// tag-#anon#ST[S64'count'||SYM#tag-#anon#ST[S32'max'||S32'min'|]#'mincut'|]
// file lglib.c line 732
struct anonymous$5;

// tag-#anon#ST[S64'extr'||S64'elim'|]
// file lglib.c line 794
struct anonymous$73;

// tag-#anon#ST[S64'fixed'|]
// file lglib.c line 826
struct anonymous$88;

// tag-#anon#ST[S64'irr'||S64'prgss'||S64'confs'||S64'cinc'||S32'pen'||U32'$pad0'|]
// file lglib.c line 823
struct anonymous$85;

// tag-#anon#ST[S64'learned'||S64'glue'||S64'nonmaxglue'||S64'maxglue'||S64'scglue'|]
// file lglib.c line 781
struct anonymous$29;

// tag-#anon#ST[S64'new'||S64'del'||S64'merged'||S64'col'||S64'gcs'||SYM#tag-#anon#ST[S64'sum'||S32'count'||U32'$pad0'|]#'deprior'||S32'max'||U32'$pad0'|]
// file lglib.c line 790
struct anonymous$35;

// tag-#anon#ST[S64'nonmin'||S64'learned'|]
// file lglib.c line 780
struct anonymous$28;

// tag-#anon#ST[S64'pshwchs'||S64'prgss'|]
// file lglib.c line 824
struct anonymous$86;

// tag-#anon#ST[S64'sat'||S64'mosat'||S64'simp'||S64'deref'||S64'fixed'||S64'freeze'||S64'melt'||S64'add'||S64'assume'||S64'cassume'||S64'failed'||S64'repr'|]
// file lglib.c line 740
struct anonymous$10;

// tag-#anon#ST[S64'search'||S64'hits'|]
// file lglib.c line 747
struct anonymous$12;

// tag-#anon#ST[S64'search'||S64'simp'||S64'lkhd'|]
// file lglib.c line 748
struct anonymous$13;

// tag-#anon#ST[S64'steps'|]
// file lglib.c line 825
struct anonymous$87;

// tag-#anon#ST[S64'steps'||SYM#tag-#anon#ST[S32'basic'|]#'pen'||U32'$pad0'|]
// file lglib.c line 822
struct anonymous$84;

// tag-#anon#ST[S64'sum'||S32'count'||U32'$pad0'|]
// file lglib.c line 786
struct anonymous$31;

// tag-#anon#ST[SYM#tag-#anon#ST[*{*{S32}$S32$(*{V}$V$)->*{S32}$S32$}$*{S32}$S32$(*{V}$V$)->*{S32}$S32$$'fun'||*{V}$V$'state'|]#'lock'||SYM#tag-#anon#ST[*{V(*{V}$V$|S32|S32)->V}$V(*{V}$V$|S32|S32)->V$'fun'||*{V}$V$'state'|]#'unlock'|]
// file lglib.c line 837
struct anonymous$95;

// tag-#anon#ST[SYM#tag-#anon#ST[*{V(*{V}$V$|S32)->V}$V(*{V}$V$|S32)->V$'fun'||*{V}$V$'state'|]#'produce'||SYM#tag-#anon#ST[*{V(*{V}$V$|S32)->V}$V(*{V}$V$|S32)->V$'fun'||*{V}$V$'state'|]#'consumed'||SYM#tag-#anon#ST[*{V(*{V}$V$|*{*{S32}$S32$}$*{S32}$S32$$|*{*{S32}$S32$}$*{S32}$S32$$)->V}$V(*{V}$V$|*{*{S32}$S32$}$*{S32}$S32$$|*{*{S32}$S32$}$*{S32}$S32$$)->V$'fun'||*{V}$V$'state'|]#'consume'|]
// file lglib.c line 833
struct anonymous$92;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'count'||S32'failed'||S32'lifted'||U32'$pad0'||S64'probed'||S64'steps'|]#'basic'|]
// file lglib.c line 759
struct anonymous$21;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'cur'||S32'max'||S64'add'|]#'clauses'||SYM#tag-#anon#ST[S32'cur'||S32'max'||S64'add'|]#'lits'|]
// file lglib.c line 739
struct anonymous$9;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'irr'||S32'red'|]#'dyn'|]
// file lglib.c line 778
struct anonymous$71;

// tag-#anon#ST[SYM#tag-#anon#ST[S32'min'||S32'avg'||S32'max'|]#'val'||SYM#tag-#anon#ST[S32'min'||S32'avg'||S32'max'|]#'var'|]
// file lglib.c line 745
struct anonymous$62;

// tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32'irr'||S32'red'|]#'dyn'|]#'sub'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[S32'irr'||S32'red'|]#'dyn'|]#'str'||S32'driving'||S32'restarting'|]
// file lglib.c line 777
struct anonymous$27;

// tag-#anon#ST[SYM#tag-Stk#'bin'||SYM#tag-Stk#'trn'|]
// file lglib.c line 855
struct anonymous$99;

// tag-#anon#ST[U64'current'||U64'max'|]
// file lglib.c line 749
struct anonymous$14;

// tag-#anon#UN[*{SYM#tag-Elm#}$SYM#tag-Elm#$'elm'||*{SYM#tag-Cgr#}$SYM#tag-Cgr#$'cgr'||*{SYM#tag-Gauss#}$SYM#tag-Gauss#$'gauss'||*{SYM#tag-CCE#}$SYM#tag-CCE#$'cce'||*{SYM#tag-Cliff#}$SYM#tag-Cliff#$'cliff'|]
// file lglib.c line 930
union anonymous;

// tag-#anon#UN[ARR2{S32}$S32$'lits'||SYM#tag-#anon#ST[*{S32}$S32$'cls'||S32'origlhs'||U32'$pad0'|]#'$anon0'||SYM#tag-#anon#ST[S32'cond'||S32'pos'||S32'neg'|]#'$anon1'|]
// file lglib.c line 721
union anonymous$55;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$3;

// tag-#anon#UN[S32'lit'||S32'sign'|]
// file lglib.c line 710
union anonymous$58;

// tag-#anon#UN[S64'ru_idrss'||S64'__ru_idrss_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 208
union anonymous$43;

// tag-#anon#UN[S64'ru_inblock'||S64'__ru_inblock_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 240
union anonymous$48;

// tag-#anon#UN[S64'ru_isrss'||S64'__ru_isrss_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 214
union anonymous$44;

// tag-#anon#UN[S64'ru_ixrss'||S64'__ru_ixrss_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 202
union anonymous$42;

// tag-#anon#UN[S64'ru_majflt'||S64'__ru_majflt_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 227
union anonymous$46;

// tag-#anon#UN[S64'ru_maxrss'||S64'__ru_maxrss_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 194
union anonymous$41;

// tag-#anon#UN[S64'ru_minflt'||S64'__ru_minflt_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 221
union anonymous$45;

// tag-#anon#UN[S64'ru_msgrcv'||S64'__ru_msgrcv_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 258
union anonymous$51;

// tag-#anon#UN[S64'ru_msgsnd'||S64'__ru_msgsnd_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 252
union anonymous$50;

// tag-#anon#UN[S64'ru_nivcsw'||S64'__ru_nivcsw_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 279
union anonymous$54;

// tag-#anon#UN[S64'ru_nsignals'||S64'__ru_nsignals_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 264
union anonymous$52;

// tag-#anon#UN[S64'ru_nswap'||S64'__ru_nswap_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 233
union anonymous$47;

// tag-#anon#UN[S64'ru_nvcsw'||S64'__ru_nvcsw_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 272
union anonymous$53;

// tag-#anon#UN[S64'ru_oublock'||S64'__ru_oublock_word'|]
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 246
union anonymous$49;

// tag-#anon#UN[SYM#tag-Stk#'lcaseen'||SYM#tag-Stk#'sortstk'||SYM#tag-Stk#'resolvent'|]
// file lglib.c line 932
union anonymous$0;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$2;

// tag-ASL
// file lglib.c line 637
struct ASL;

// tag-AVar
// file lglib.c line 681
struct AVar;

// tag-CCE
// file lglib.c line 872
struct CCE;

// tag-Cbs
// file lglib.c line 831
struct Cbs;

// tag-Cgr
// file lglib.c line 846
struct Cgr;

// tag-Cliff
// file lglib.c line 853
struct Cliff;

// tag-Conf
// file lglib.c line 638
struct Conf;

// tag-Ctk
// file lglib.c line 639
struct Ctk;

// tag-Ctr
// file lglib.c line 639
struct Ctr;

// tag-DFL
// file lglib.c line 708
struct DFL;

// tag-DFOPF
// file lglib.c line 640
struct DFOPF;

// tag-DFPR
// file lglib.c line 641
struct DFPR;

// tag-DVar
// file lglib.c line 662
struct DVar;

// tag-Dis
// file lglib.c line 855
struct Dis;

// tag-EVar
// file lglib.c line 642
struct EVar;

// tag-Elm
// file lglib.c line 857
struct Elm;

// tag-Ext
// file lglib.c line 694
struct Ext;

// tag-FltStr
// file lglib.c line 862
struct FltStr;

// tag-ForceData
// file lglib.c line 7432
struct ForceData;

// tag-GTag
// file lglib.c line 466
enum GTag { ANDTAG=0, ITETAG=1, XORTAG=2 };

// tag-Gat
// file lglib.c line 716
struct Gat;

// tag-Gauss
// file lglib.c line 866
struct Gauss;

// tag-HTS
// file lglib.c line 643
struct HTS;

// tag-ITEC
// file lglib.c line 644
struct ITEC;

// tag-LGL
// file lglib.h line 19
struct LGL;

// tag-Lim
// file lglib.c line 645
struct Lim;

// tag-Limits
// file lglib.c line 813
struct Limits;

// tag-Mem
// file lglib.c line 874
struct Mem;

// tag-Opt
// file lglib.c line 470
struct Opt;

// tag-Opts
// file lglib.c line 476
struct Opts;

// tag-Qln
// file lglib.c line 647
struct Qln;

// tag-Qnd
// file lglib.c line 647
struct Qnd;

// tag-Queue
// file lglib.c line 669
struct Queue;

// tag-RNG
// file lglib.c line 648
struct RNG;

// tag-State
// file lglib.c line 445
enum State { UNUSED=1, OPTSET=2, USED=4, READY=8, UNKNOWN=16, SATISFIED=32, EXTENDED=64, UNSATISFIED=128, FAILED=256, LOOKED=512, RESET=1024 };

// tag-Stats
// file lglib.c line 730
struct Stats;

// tag-Stk
// file lglib.c line 649
struct Stk;

// tag-TD
// file lglib.c line 675
struct TD;

// tag-Tag
// file lglib.c line 427
enum Tag { FREEVAR=0, FIXEDVAR=1, EQUIVAR=2, ELIMVAR=3, DECISION=0, UNITCS=1, OCCS=1, BINCS=2, TRNCS=3, LRGCS=4, MASKCS=7, REDCS=8, RMSHFT=4 };

// tag-Times
// file lglib.c line 804
struct Times;

// tag-Tmrs
// file lglib.c line 650
struct Tmrs;

// tag-Trv
// file lglib.c line 651
struct Trv;

// tag-Wchs
// file lglib.c line 879
struct Wchs;

// tag-Work
// file lglib.c line 653
struct Work;

// tag-Worker
// file ilingeling.c line 80
struct Worker;

// tag-Wrag
// file lglib.c line 459
enum Wrag { PREFIX=0, BEFORE=1, AFTER=2, POSTFIX=3 };

// tag-Wrk
// file lglib.c line 881
struct Wrk;

// tag-Wtk
// file lglib.c line 653
struct Wtk;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rusage
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 187
struct rusage;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// _IO_getc
// file /usr/include/libio.h line 434
extern signed int _IO_getc(struct _IO_FILE *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __ctype_tolower_loc
// file /usr/include/ctype.h line 81
extern const signed int ** __ctype_tolower_loc(void);
// __ctype_toupper_loc
// file /usr/include/ctype.h line 83
extern const signed int ** __ctype_toupper_loc(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// add
// file ilingeling.c line 471
static void add(signed int lit);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// atoi$link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link1(const char *__nptr$link1);
// catchsig
// file ilingeling.c line 737
static void catchsig(signed int sig);
// caughtsigmsg
// file ilingeling.c line 731
static void caughtsigmsg(signed int sig);
// cmpdblptr
// file ilingeling.c line 619
static signed int cmpdblptr(const void *p, const void *q);
// currentime
// file ilingeling.c line 167
static double currentime(void);
// die
// file ilingeling.c line 146
static void die(const char *fmt, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeze
// file ilingeling.c line 579
static void freeze(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getime
// file ilingeling.c line 174
static double getime();
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getrusage
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 87
extern signed int getrusage(signed int, struct rusage *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// hist
// file ilingeling.c line 710
static void hist(void);
// init
// file ilingeling.c line 423
static void init(void);
// initlgl
// file ilingeling.c line 240
static void initlgl(struct LGL *lgl, struct Worker *w, signed int opts);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// isnum
// file ilingeling.c line 176
static signed int isnum(const char *str);
// justreturn
// file ilingeling.c line 253
static signed int justreturn(struct Worker *w);
// lgl2manyoccs4blk
// file lglib.c line 11134
static signed int lgl2manyoccs4blk(struct LGL *lgl, signed int lit);
// lgl2manyoccs4elm
// file lglib.c line 11014
static signed int lgl2manyoccs4elm(struct LGL *lgl, signed int lit);
// lglabce
// file lglib.c line 11516
static signed int lglabce(struct LGL *lgl, signed int lit);
// lglabcecls
// file lglib.c line 11506
static signed int lglabcecls(struct LGL *lgl, signed int lit, const signed int *c);
// lglabort
// file lglib.c line 1171
static void lglabort(struct LGL *lgl);
// lgladd
// file lglib.h line 180
void lgladd(struct LGL *lgl, signed int elit);
// lgladdcls
// file lglib.c line 3511
static signed int lgladdcls(struct LGL *lgl, signed int red, signed int origlue, signed int force);
// lgladdecl
// file lglib.c line 9309
static void lgladdecl(struct LGL *lgl, const signed int *c);
// lgladdflt
// file lglib.c line 1108
static signed long int lgladdflt(signed long int a, signed long int b);
// lgladdliftbincls
// file lglib.c line 13914
static void lgladdliftbincls(struct LGL *lgl, signed int a, signed int b);
// lgladdunits
// file lglib.c line 13703
static signed int lgladdunits(struct LGL *lgl);
// lgladecide
// file lglib.c line 7716
static signed int lgladecide(struct LGL *lgl);
// lgladjext
// file lglib.c line 2490
static void lgladjext(struct LGL *lgl, signed int eidx);
// lglagile
// file lglib.c line 5178
static signed int lglagile(struct LGL *lgl);
// lglagility
// file lglib.c line 5012
static double lglagility(struct LGL *lgl);
// lglana
// file lglib.c line 6027
static signed int lglana(struct LGL *lgl);
// lglanafailed
// file lglib.c line 14447
static void lglanafailed(struct LGL *lgl);
// lglanalit
// file lglib.c line 14399
static signed int lglanalit(struct LGL *lgl, signed int lit);
// lgland3fun
// file lglib.c line 10575
static void lgland3fun(unsigned long int *a, unsigned long int *b, unsigned long int *c);
// lgland3negfun
// file lglib.c line 10581
static void lgland3negfun(unsigned long int *a, unsigned long int *b, unsigned long int *c);
// lglandfun
// file lglib.c line 10569
static void lglandfun(unsigned long int *a, unsigned long int *b);
// lglandornegfun
// file lglib.c line 10563
static void lglandornegfun(unsigned long int *a, unsigned long int *b, unsigned long int *c);
// lglassign
// file lglib.c line 2611
static void lglassign(struct LGL *lgl, signed int lit, signed int r0, signed int r1);
// lglassume
// file lglib.h line 181
void lglassume(struct LGL *lgl, signed int elit);
// lglassumption
// file lglib.c line 4805
static signed int lglassumption(struct LGL *lgl, signed int lit);
// lglavar
// file lglib.c line 2318
static struct AVar * lglavar(struct LGL *lgl, signed int lit);
// lglavg
// file lglib.c line 5014
static double lglavg(double n, double d);
// lglavglue
// file lglib.c line 5022
static signed long int lglavglue(struct LGL *lgl);
// lglbacksub
// file lglib.c line 9546
static signed int lglbacksub(struct LGL *lgl, signed int *c, signed int str);
// lglbacktrack
// file lglib.c line 2801
static void lglbacktrack(struct LGL *lgl, signed int level);
// lglbasicprobe
// file lglib.c line 8966
static signed int lglbasicprobe(struct LGL *lgl);
// lglbasicprobelit
// file lglib.c line 8735
static void lglbasicprobelit(struct LGL *lgl, signed int root);
// lglbcp
// file lglib.c line 4732
static signed int lglbcp(struct LGL *lgl);
// lglbcpsearch
// file lglib.c line 4756
static signed int lglbcpsearch(struct LGL *lgl);
// lglbcptop
// file lglib.c line 17200
static signed int lglbcptop(struct LGL *lgl);
// lglblock
// file lglib.c line 11378
static void lglblock(struct LGL *lgl);
// lglblockcls
// file lglib.c line 11069
static signed int lglblockcls(struct LGL *lgl, signed int lit);
// lglblocking
// file lglib.c line 16961
static signed int lglblocking(struct LGL *lgl);
// lglblockinglit
// file lglib.c line 10012
static void lglblockinglit(struct LGL *lgl, signed int ilit);
// lglblocklit
// file lglib.c line 11180
static signed int lglblocklit(struct LGL *lgl, signed int lit, struct Stk *stk);
// lglbnr
// file lglib.h line 100
void lglbnr(const char *name, const char *prefix, struct _IO_FILE *file);
// lglbonflict
// file lglib.c line 4011
static void lglbonflict(struct LGL *lgl, signed int lit, signed int blit);
// lglboundredl
// file lglib.c line 5182
static void lglboundredl(struct LGL *lgl);
// lglbrutefork
// file lglib.h line 79
struct LGL * lglbrutefork(struct LGL *lgl, signed int complete);
// lglbumplidx
// file lglib.c line 3491
static signed int lglbumplidx(struct LGL *lgl, signed int lidx);
// lglbumplits
// file lglib.c line 5994
static void lglbumplits(struct LGL *lgl);
// lglbytes
// file lglib.c line 5002
unsigned long int lglbytes(struct LGL *lgl);
// lglca
// file lglib.c line 4161
static signed int lglca(struct LGL *lgl, signed int a, signed int b);
// lglcamark
// file lglib.c line 4147
static void lglcamark(struct LGL *lgl, signed int lit, signed int mark);
// lglcamarked
// file lglib.c line 4137
static signed int lglcamarked(struct LGL *lgl, signed int lit);
// lglcard
// file lglib.c line 16873
static void lglcard(struct LGL *lgl);
// lglcassume
// file lglib.c line 3980
void lglcassume(struct LGL *lgl, signed int elit);
// lglcce
// file lglib.c line 11856
static signed int lglcce(struct LGL *lgl);
// lglcceclause
// file lglib.c line 11542
static signed int lglcceclause(struct LGL *lgl, const signed int *c, const signed int *ignwch, signed int igntag);
// lglcceing
// file lglib.c line 11478
static signed int lglcceing(struct LGL *lgl);
// lglccelit
// file lglib.c line 11808
static void lglccelit(struct LGL *lgl, signed int lit);
// lglceilld
// file lglib.c line 984
static signed int lglceilld(signed int n);
// lglceilsqrt32
// file lglib.c line 990
static signed int lglceilsqrt32(signed int x);
// lglceilsqrt64
// file lglib.c line 1014
static signed int lglceilsqrt64(signed int x);
// lglcgeq
// file lglib.c line 12379
static signed int lglcgeq(struct LGL *lgl, signed int a, signed int b);
// lglcgextractands
// file lglib.c line 12613
static signed int lglcgextractands(struct LGL *lgl, signed int lit);
// lglcgextractidx
// file lglib.c line 12937
static signed int lglcgextractidx(struct LGL *lgl, signed int idx);
// lglcgextractitecands
// file lglib.c line 12834
static void lglcgextractitecands(struct LGL *lgl, signed int lhs, struct ITEC *cands, signed int ncands);
// lglcgextractites
// file lglib.c line 12865
static signed int lglcgextractites(struct LGL *lgl, signed int lit);
// lglcgextractlimhit
// file lglib.c line 12576
static signed int lglcgextractlimhit(struct LGL *lgl);
// lglcgextractxors
// file lglib.c line 12748
static signed int lglcgextractxors(struct LGL *lgl, signed int lit);
// lglcginit
// file lglib.c line 13002
static void lglcginit(struct LGL *lgl);
// lglcgmerge
// file lglib.c line 12520
static void lglcgmerge(struct LGL *lgl, signed int other, signed int repr);
// lglcgmergelhsrhs
// file lglib.c line 12816
static signed int lglcgmergelhsrhs(struct LGL *lgl, signed int lhs, signed int rhs);
// lglcgrclosing
// file lglib.c line 16955
static signed int lglcgrclosing(struct LGL *lgl);
// lglcgrclsr
// file lglib.c line 13782
static signed int lglcgrclsr(struct LGL *lgl);
// lglcgrepr
// file lglib.c line 12319
static signed int lglcgrepr(struct LGL *lgl, signed int lit);
// lglcgreprnotconst
// file lglib.c line 12341
static signed int lglcgreprnotconst(struct LGL *lgl, signed int lit);
// lglcgreset
// file lglib.c line 13031
static void lglcgreset(struct LGL *lgl);
// lglcgrlimhit
// file lglib.c line 13330
static signed int lglcgrlimhit(struct LGL *lgl);
// lglcgrlit
// file lglib.c line 13614
static void lglcgrlit(struct LGL *lgl, signed int lit);
// lglcgunit
// file lglib.c line 12585
static signed int lglcgunit(struct LGL *lgl, signed int lit);
// lglchanged
// file lglib.c line 17865
signed int lglchanged(struct LGL *lgl);
// lglchkassumeclean
// file lglib.c line 3726
static void lglchkassumeclean(struct LGL *lgl);
// lglchkbcpclean
// file lglib.c line 6871
static void lglchkbcpclean(struct LGL *lgl, const char *where);
// lglchkclone
// file lglib.c line 2076
void lglchkclone(struct LGL *lgl);
// lglchkclonesamestats
// file lglib.c line 17640
static void lglchkclonesamestats(struct LGL *orig);
// lglchkeassumeclean
// file lglib.c line 3714
static void lglchkeassumeclean(struct LGL *lgl);
// lglchkenv
// file lglib.c line 1632
static void lglchkenv(struct LGL *lgl);
// lglchkflt
// file lglib.c line 1038
static void lglchkflt(signed long int a);
// lglchkirrstats
// file lglib.c line 3421
static void lglchkirrstats(struct LGL *lgl);
// lglchkoccs4elm
// file lglib.c line 11052
static signed int lglchkoccs4elm(struct LGL *lgl, signed int idx);
// lglchkoccs4elmlit
// file lglib.c line 11018
static signed int lglchkoccs4elmlit(struct LGL *lgl, signed int lit);
// lglchkqueue
// file lglib.c line 2346
static void lglchkqueue(struct LGL *lgl);
// lglchkred
// file lglib.c line 5076
static void lglchkred(struct LGL *lgl);
// lglchksimpcls
// file lglib.c line 2945
static void lglchksimpcls(struct LGL *lgl);
// lglclass
// file lglib.c line 17518
static void lglclass(struct LGL *lgl, struct LGL *from);
// lglcleanrepr
// file lglib.c line 13904
static void lglcleanrepr(struct LGL *lgl, struct Stk *represented, signed int *repr);
// lglcliff
// file lglib.c line 12065
static signed int lglcliff(struct LGL *lgl);
// lglcliffclause
// file lglib.c line 11924
static void lglcliffclause(struct LGL *lgl, const signed int *c);
// lglcliffclauses
// file lglib.c line 11987
static signed int lglcliffclauses(struct LGL *lgl, struct Stk *stk);
// lglcliffing
// file lglib.c line 17015
static signed int lglcliffing(struct LGL *lgl);
// lglclifflit
// file lglib.c line 12000
static signed int lglclifflit(struct LGL *lgl, signed int lit);
// lglclnana
// file lglib.c line 5830
static void lglclnana(struct LGL *lgl);
// lglclnframes
// file lglib.c line 5813
static void lglclnframes(struct LGL *lgl);
// lglclnpoisoned
// file lglib.c line 5818
static void lglclnpoisoned(struct LGL *lgl);
// lglclnstk
// file lglib.c line 1472
static void lglclnstk(struct Stk *s);
// lglclone
// file lglib.c line 1990
struct LGL * lglclone(struct LGL *orig);
// lglclsr
// file lglib.c line 13663
static void lglclsr(struct LGL *lgl);
// lglcmpagsl
// file lglib.c line 5128
static signed int lglcmpagsl(struct ASL *a, struct ASL *b);
// lglcmpasgl
// file lglib.c line 5136
static signed int lglcmpasgl(struct ASL *a, struct ASL *b);
// lglcmpdfl
// file lglib.c line 15489
static signed int lglcmpdfl(const struct DFL *a, const struct DFL *b);
// lglcmpfdat
// file lglib.c line 7440
static signed int lglcmpfdat(struct ForceData *fdat, signed int l, signed int k);
// lglcmpgauss
// file lglib.c line 16499
static signed int lglcmpgauss(struct LGL *lgl, signed int a, signed int b);
// lglcmpgoccs
// file lglib.c line 13081
static signed int lglcmpgoccs(struct LGL *lgl, signed int a, signed int b);
// lglcmphase
// file lglib.c line 6484
static signed int lglcmphase(struct LGL *lgl, signed int a, signed int b);
// lglcmpitecands
// file lglib.c line 12808
static signed int lglcmpitecands(const struct ITEC *c, const struct ITEC *d);
// lglcmpocc
// file lglib.c line 12570
static signed int lglcmpocc(struct LGL *lgl, signed int a, signed int b);
// lglcmprepr
// file lglib.c line 8187
static signed int lglcmprepr(struct LGL *lgl, signed int a, signed int b);
// lglcnf
// file lglib.c line 10734
static signed long int lglcnf(signed int pos, signed int size);
// lglcnf2pos
// file lglib.c line 10731
static signed int lglcnf2pos(signed long int cnf);
// lglcnf2size
// file lglib.c line 10732
static signed int lglcnf2size(signed long int cnf);
// lglcntctk
// file lglib.c line 1544
static signed int lglcntctk(struct Ctk *ctk);
// lglcntstk
// file lglib.c line 1388
static unsigned long int lglcntstk(struct Stk *s);
// lglcntwtk
// file lglib.c line 14993
static signed int lglcntwtk(struct Wtk *wtk);
// lglcompact
// file lglib.c line 7609
static void lglcompact(struct LGL *lgl);
// lglcompactify
// file lglib.c line 17573
static signed int lglcompactify(struct LGL *lgl, signed int res);
// lglcompletefork
// file lglib.c line 18926
static void lglcompletefork(struct LGL *dst, struct LGL *src);
// lglcomputechanged
// file lglib.c line 17371
static void lglcomputechanged(struct LGL *lgl);
// lglcomputecog
// file lglib.c line 18522
static void lglcomputecog(struct LGL *lgl);
// lglcon
// file lglib.c line 6572
static void lglcon(struct LGL *lgl);
// lglconnaux
// file lglib.c line 6490
static void lglconnaux(struct LGL *lgl, signed int glue);
// lglcount
// file lglib.c line 6578
static void lglcount(struct LGL *lgl);
// lglcpyopts
// file lglib.c line 18907
static void lglcpyopts(struct LGL *dst, const struct LGL *src);
// lglcpystk
// file lglib.c line 16551
static void lglcpystk(struct LGL *lgl, struct Stk *dst, struct Stk *src);
// lglctrav
// file lglib.c line 18746
void lglctrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int));
// lglctrav::trav$object
// 
//void trav$object(void *, signed int);
// lglcutwidth
// file lglib.c line 6877
static signed int lglcutwidth(struct LGL *lgl);
// lglcval
// file lglib.c line 2961
static signed int lglcval(struct LGL *lgl, signed int litorval);
// lgldassume
// file lglib.c line 7730
static void lgldassume(struct LGL *lgl, signed int lit);
// lgldcpcln
// file lglib.c line 8043
static void lgldcpcln(struct LGL *lgl);
// lgldcpclnstk
// file lglib.c line 7904
static void lgldcpclnstk(struct LGL *lgl, signed int red, struct Stk *s);
// lgldcpcon
// file lglib.c line 8023
static void lgldcpcon(struct LGL *lgl);
// lgldcpconnaux
// file lglib.c line 7982
static void lgldcpconnaux(struct LGL *lgl, signed int red, signed int glue, struct Stk *s);
// lgldcpdis
// file lglib.c line 7852
static void lgldcpdis(struct LGL *lgl);
// lgldec
// file lglib.c line 1253
static void lgldec(struct LGL *lgl, unsigned long int bytes);
// lgldec64
// file lglib.c line 16230
static unsigned long int lgldec64(unsigned long int i);
// lgldecide
// file lglib.c line 7832
static signed int lgldecide(struct LGL *lgl);
// lgldecidephase
// file lglib.c line 7758
static signed int lgldecidephase(struct LGL *lgl, signed int lit);
// lgldecirr
// file lglib.c line 3481
static void lgldecirr(struct LGL *lgl, signed int size);
// lgldecision
// file lglib.c line 4799
static signed int lgldecision(struct LGL *lgl, signed int lit);
// lgldeclscnt
// file lglib.c line 4071
static void lgldeclscnt(struct LGL *lgl, signed int size, signed int red, signed int glue);
// lgldecocc
// file lglib.c line 5650
static void lgldecocc(struct LGL *lgl, signed int lit);
// lgldecomp
// file lglib.c line 12274
static signed int lgldecomp(struct LGL *lgl);
// lgldecomposing
// file lglib.c line 16953
static signed int lgldecomposing(struct LGL *lgl);
// lgldefphase
// file lglib.c line 7738
static signed int lgldefphase(struct LGL *lgl, signed int idx);
// lgldefrag
// file lglib.c line 6362
static void lgldefrag(struct LGL *lgl);
// lgldefragmenting
// file lglib.c line 16988
static signed int lgldefragmenting(struct LGL *lgl);
// lgldel
// file lglib.c line 1271
static void lgldel(struct LGL *lgl, void *ptr, unsigned long int bytes);
// lgldelstr
// file lglib.c line 1306
static void lgldelstr(struct LGL *lgl, char *str);
// lgldense
// file lglib.c line 9121
static void lgldense(struct LGL *lgl, signed int occstoo);
// lgldeprioritize
// file lglib.c line 5862
static void lgldeprioritize(struct LGL *lgl);
// lglderef
// file lglib.h line 192
signed int lglderef(struct LGL *lgl, signed int elit);
// lgldie
// file lglib.c line 1160
static void lgldie(struct LGL *lgl, const char *msg, ...);
// lgldis
// file lglib.c line 6408
static void lgldis(struct LGL *lgl);
// lgldstpull
// file lglib.c line 14382
static signed int lgldstpull(struct LGL *lgl, signed int lit);
// lgldvar
// file lglib.c line 2313
static struct DVar * lgldvar(struct LGL *lgl, signed int lit);
// lgldynstr
// file lglib.c line 5725
static void lgldynstr(struct LGL *lgl, signed int del, signed int lit, signed int r0, signed int r1);
// lgldynsub
// file lglib.c line 5707
static void lgldynsub(struct LGL *lgl, signed int lit, signed int r0, signed int r1);
// lgleadd
// file lglib.c line 3850
static void lgleadd(struct LGL *lgl, signed int elit);
// lgleassign
// file lglib.c line 17364
static void lgleassign(struct LGL *lgl, signed int lit);
// lgleassume
// file lglib.c line 3916
static void lgleassume(struct LGL *lgl, signed int elit);
// lglecalc
// file lglib.c line 3362
static signed int lglecalc(struct LGL *lgl, struct EVar *ev);
// lglecassume
// file lglib.c line 3959
static void lglecassume(struct LGL *lgl, signed int elit);
// lglecls
// file lglib.c line 9371
static signed int lglecls(struct LGL *lgl, signed int lit);
// lglecmp
// file lglib.c line 3194
static signed int lglecmp(struct LGL *lgl, signed int l, signed int k);
// lglederef
// file lglib.c line 8448
static signed int lglederef(struct LGL *lgl, signed int elit);
// lgledown
// file lglib.c line 3250
static void lgledown(struct LGL *lgl, signed int lit);
// lglefixed
// file lglib.c line 17958
static signed int lglefixed(struct LGL *lgl, signed int elit);
// lglelim
// file lglib.c line 12128
static signed int lglelim(struct LGL *lgl);
// lgleliminated
// file lglib.c line 10121
static void lgleliminated(struct LGL *lgl, signed int pivot);
// lgleliminating
// file lglib.c line 16970
static signed int lgleliminating(struct LGL *lgl);
// lglelimlit
// file lglib.c line 11059
static void lglelimlit(struct LGL *lgl, signed int idx);
// lglelimlitaux
// file lglib.c line 10453
static void lglelimlitaux(struct LGL *lgl, signed int idx);
// lglelit2ext
// file lglib.c line 2461
static struct Ext * lglelit2ext(struct LGL *lgl, signed int elit);
// lglelitblockingoreliminated
// file lglib.c line 12199
static signed int lglelitblockingoreliminated(struct LGL *lgl, signed int elit);
// lglelmfre
// file lglib.c line 10111
static void lglelmfre(struct LGL *lgl);
// lglelmfrelit
// file lglib.c line 10024
static void lglelmfrelit(struct LGL *lgl, signed int mpivot, signed int *sop, signed int *eop, signed int *son, signed int *eon);
// lglelmstr
// file lglib.c line 9658
static signed int lglelmstr(struct LGL *lgl);
// lglelmsub
// file lglib.c line 9635
static void lglelmsub(struct LGL *lgl);
// lglelrmcls
// file lglib.c line 9481
static void lglelrmcls(struct LGL *lgl, signed int lit, signed int *c, signed int clidx);
// lglemerge
// file lglib.c line 8068
static void lglemerge(struct LGL *lgl, signed int ilit0, signed int ilit1);
// lglenlargegates
// file lglib.c line 12334
static void lglenlargegates(struct LGL *lgl);
// lglenlctk
// file lglib.c line 1551
static void lglenlctk(struct LGL *lgl, struct Ctk *ctk);
// lglenlstk
// file lglib.c line 1401
static void lglenlstk(struct LGL *lgl, struct Stk *s);
// lglenlvars
// file lglib.c line 2292
static void lglenlvars(struct LGL *lgl);
// lglenlwchs
// file lglib.c line 3041
static signed long int lglenlwchs(struct LGL *lgl, struct HTS *hts);
// lglenlwtk
// file lglib.c line 15000
static void lglenlwtk(struct LGL *lgl, struct Wtk *wtk);
// lglepos
// file lglib.c line 3186
static signed int * lglepos(struct LGL *lgl, signed int lit);
// lglepush
// file lglib.c line 8062
static void lglepush(struct LGL *lgl, signed int ilit);
// lglepusheliminated
// file lglib.c line 10141
static void lglepusheliminated(struct LGL *lgl, signed int idx);
// lglerepr
// file lglib.c line 2467
static signed int lglerepr(struct LGL *lgl, signed int elit);
// lglesched
// file lglib.c line 3294
static void lglesched(struct LGL *lgl, signed int lit);
// lgleschedrem
// file lglib.c line 11318
static signed int lgleschedrem(struct LGL *lgl, signed int this_time);
// lglesetphase
// file lglib.c line 3891
static void lglesetphase(struct LGL *lgl, signed int elit, signed int phase);
// lgletrav
// file lglib.c line 18731
void lgletrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int, signed int));
// lgletrav::trav$object
// 
//void trav$object(void *, signed int, signed int);
// lgleunassignall
// file lglib.c line 3708
static void lgleunassignall(struct LGL *lgl);
// lgleup
// file lglib.c line 3220
static void lgleup(struct LGL *lgl, signed int lit);
// lglevar
// file lglib.c line 3180
static struct EVar * lglevar(struct LGL *lgl, signed int lit);
// lglevel
// file lglib.c line 2340
static signed int lglevel(struct LGL *lgl, signed int lit);
// lglevelused
// file lglib.c line 1579
static signed int lglevelused(struct LGL *lgl, signed int level);
// lglexp
// file lglib.c line 1047
static signed int lglexp(signed long int a);
// lglexport
// file lglib.c line 2573
static signed int lglexport(struct LGL *lgl, signed int ilit);
// lglextend
// file lglib.c line 17383
static void lglextend(struct LGL *lgl);
// lglf2rce
// file lglib.c line 2713
static void lglf2rce(struct LGL *lgl, signed int lit, signed int other, signed int red);
// lglf3rce
// file lglib.c line 2720
static void lglf3rce(struct LGL *lgl, signed int lit, signed int other, signed int other2, signed int red);
// lglfadd
// file lglib.c line 3812
static void lglfadd(struct LGL *lgl, signed int elit);
// lglfailed
// file lglib.h line 195
signed int lglfailed(struct LGL *lgl, signed int elit);
// lglfailedass
// file lglib.c line 14442
static signed int lglfailedass(struct LGL *lgl);
// lglfalsefun
// file lglib.c line 10513
static void lglfalsefun(unsigned long int *res);
// lglfirstopt
// file lglib.c line 2142
void * lglfirstopt(struct LGL *lgl);
// lglfitlir
// file lglib.c line 5072
static void lglfitlir(struct LGL *lgl, struct Stk *lir);
// lglfitstk
// file lglib.c line 1427
static void lglfitstk(struct LGL *lgl, struct Stk *s);
// lglfixate
// file lglib.c line 3995
void lglfixate(struct LGL *lgl);
// lglfixed
// file lglib.c line 17969
signed int lglfixed(struct LGL *lgl, signed int elit);
// lglfixlrgwchs
// file lglib.c line 15880
static void lglfixlrgwchs(struct LGL *lgl);
// lglfjadd
// file lglib.c line 18891
static void lglfjadd(struct LGL *lgl, signed int elit);
// lglfjradd
// file lglib.c line 18899
static void lglfjradd(struct LGL *lgl, signed int elit, signed int glue);
// lglfloorld
// file lglib.c line 971
static signed int lglfloorld(signed int n);
// lglflrce
// file lglib.c line 2729
static void lglflrce(struct LGL *lgl, signed int lit, signed int red, signed int lidx);
// lglflshrep
// file lglib.c line 5066
static void lglflshrep(struct LGL *lgl);
// lglflt
// file lglib.c line 1061
static signed long int lglflt(signed int e, unsigned long int m);
// lglflt2str
// file lglib.c line 1094
static const char * lglflt2str(struct LGL *lgl, signed long int a);
// lglflush
// file lglib.c line 9991
static signed int lglflush(struct LGL *lgl);
// lglflushcache
// file lglib.h line 198
void lglflushcache(struct LGL *lgl);
// lglflushclauses
// file lglib.c line 9711
static signed int lglflushclauses(struct LGL *lgl, signed int lit);
// lglflushlits
// file lglib.c line 9813
static signed int lglflushlits(struct LGL *lgl, signed int lit);
// lglflushphases
// file lglib.c line 6830
static void lglflushphases(struct LGL *lgl);
// lglflushqmerged
// file lglib.c line 5839
static void lglflushqmerged(struct LGL *lgl);
// lglflushremovedoccs
// file lglib.c line 4392
static void lglflushremovedoccs(struct LGL *lgl, signed int lit);
// lglflushtimers
// file lglib.h line 278
void lglflushtimers(struct LGL *lgl);
// lglforce
// file lglib.c line 7455
static void lglforce(struct LGL *lgl, signed int *map);
// lglfork
// file lglib.h line 72
struct LGL * lglfork(struct LGL *lgl, signed int complete);
// lglforkaux
// file lglib.c line 18955
static struct LGL * lglforkaux(struct LGL *lgl, signed int brutefork, signed int complete);
// lglforkmerge
// file lglib.c line 18996
static void lglforkmerge(struct LGL *to, struct LGL *from);
// lglfreewch
// file lglib.c line 3018
static void lglfreewch(struct LGL *lgl, signed int oldoffset, signed int oldhcount);
// lglfreeze
// file lglib.h line 262
void lglfreeze(struct LGL *lgl, signed int elit);
// lglfreezer
// file lglib.c line 8118
static void lglfreezer(struct LGL *lgl);
// lglfullctk
// file lglib.c line 1540
static signed int lglfullctk(struct Ctk *ctk);
// lglfullstk
// file lglib.c line 1386
static signed int lglfullstk(struct Stk *s);
// lglfullwtk
// file lglib.c line 14989
static signed int lglfullwtk(struct Wtk *wtk);
// lglfullyconnected
// file lglib.c line 6566
static void lglfullyconnected(struct LGL *lgl);
// lglfuncpy
// file lglib.c line 10507
static void lglfuncpy(unsigned long int *dst, unsigned long int *src);
// lglgat2idx
// file lglib.c line 12373
static signed int lglgat2idx(struct LGL *lgl, struct Gat *g);
// lglgateextract
// file lglib.c line 12951
static void lglgateextract(struct LGL *lgl);
// lglgauss
// file lglib.c line 16810
static signed int lglgauss(struct LGL *lgl);
// lglgaussaddeqn
// file lglib.c line 16557
static signed int lglgaussaddeqn(struct LGL *lgl, signed int eqn);
// lglgausschkeliminated
// file lglib.c line 16606
static void lglgausschkeliminated(struct LGL *lgl);
// lglgaussconeqn
// file lglib.c line 16413
static void lglgaussconeqn(struct LGL *lgl, signed int eqn);
// lglgaussconnect
// file lglib.c line 16433
static void lglgaussconnect(struct LGL *lgl);
// lglgaussdisconnect
// file lglib.c line 16467
static void lglgaussdisconnect(struct LGL *lgl);
// lglgaussdiseqn
// file lglib.c line 16421
static void lglgaussdiseqn(struct LGL *lgl, signed int eqn);
// lglgausselim
// file lglib.c line 16667
static void lglgausselim(struct LGL *lgl);
// lglgausselimvar
// file lglib.c line 16637
static signed int lglgausselimvar(struct LGL *lgl, signed int pivot);
// lglgaussexp2
// file lglib.c line 16692
static signed int lglgaussexp2(struct LGL *lgl, signed int a, signed int b);
// lglgaussexp3
// file lglib.c line 16708
static signed int lglgaussexp3(struct LGL *lgl, signed int a, signed int b, signed int c);
// lglgaussexport
// file lglib.c line 16725
static signed int lglgaussexport(struct LGL *lgl);
// lglgaussextract
// file lglib.c line 16477
static void lglgaussextract(struct LGL *lgl);
// lglgaussextractlarge
// file lglib.c line 16401
static signed int lglgaussextractlarge(struct LGL *lgl);
// lglgaussextractsmall
// file lglib.c line 16391
static signed int lglgaussextractsmall(struct LGL *lgl);
// lglgaussextractsmallit
// file lglib.c line 16357
static signed int lglgaussextractsmallit(struct LGL *lgl, signed int lit);
// lglgaussextractxor
// file lglib.c line 16350
static signed int lglgaussextractxor(struct LGL *lgl, const signed int *c);
// lglgaussextractxoraux
// file lglib.c line 16308
static signed int lglgaussextractxoraux(struct LGL *lgl, const signed int *c);
// lglgaussgc
// file lglib.c line 16619
static void lglgaussgc(struct LGL *lgl);
// lglgaussing
// file lglib.c line 17010
static signed int lglgaussing(struct LGL *lgl);
// lglgaussinit
// file lglib.c line 16678
static void lglgaussinit(struct LGL *lgl);
// lglgaussoccs
// file lglib.c line 16495
static signed int lglgaussoccs(struct LGL *lgl, signed int a);
// lglgaussorder
// file lglib.c line 16462
static void lglgaussorder(struct LGL *lgl);
// lglgaussorderidx
// file lglib.c line 16455
static signed int lglgaussorderidx(struct LGL *lgl, signed int var);
// lglgaussort
// file lglib.c line 16507
static void lglgaussort(struct LGL *lgl);
// lglgausspickeqn
// file lglib.c line 16519
static signed int lglgausspickeqn(struct LGL *lgl, signed int pivot);
// lglgaussreset
// file lglib.c line 16683
static void lglgaussreset(struct LGL *lgl);
// lglgaussubcls
// file lglib.c line 16301
static signed int lglgaussubcls(struct LGL *lgl, unsigned long int signs, const signed int *c);
// lglgaussubclsaux
// file lglib.c line 16251
static signed int lglgaussubclsaux(struct LGL *lgl, unsigned long int signs, const signed int *c);
// lglgaussubst
// file lglib.c line 16569
static void lglgaussubst(struct LGL *lgl, signed int pivot, signed int subst);
// lglgc
// file lglib.c line 7634
static void lglgc(struct LGL *lgl);
// lglgcd
// file lglib.c line 3319
static unsigned int lglgcd(unsigned int a, unsigned int b);
// lglgcnotnecessary
// file lglib.c line 7603
static signed int lglgcnotnecessary(struct LGL *lgl);
// lglgdump
// file lglib.c line 16237
static void lglgdump(struct LGL *lgl);
// lglgetconfs
// file lglib.h line 282
signed long int lglgetconfs(struct LGL *lgl);
// lglgetdecs
// file lglib.h line 283
signed long int lglgetdecs(struct LGL *lgl);
// lglgetdom
// file lglib.c line 2591
static signed int lglgetdom(struct LGL *lgl, signed int lit);
// lglgetenv
// file lglib.c line 1606
static void lglgetenv(struct LGL *lgl, struct Opt *opt, const char *lname);
// lglgetime
// file lglib.c line 4956
static double lglgetime(struct LGL *lgl);
// lglgetopt
// file lglib.c line 2263
signed int lglgetopt(struct LGL *lgl, const char *opt);
// lglgetoptminmax
// file lglib.c line 2268
signed int lglgetoptminmax(struct LGL *lgl, const char *opt, signed int *min_ptr, signed int *max_ptr);
// lglgetout
// file lglib.c line 2244
struct _IO_FILE * lglgetout(struct LGL *lgl);
// lglgetprefix
// file lglib.c line 2251
const char * lglgetprefix(struct LGL *lgl);
// lglgetprops
// file lglib.h line 284
signed long int lglgetprops(struct LGL *lgl);
// lglgidx2gat
// file lglib.c line 12368
static struct Gat * lglgidx2gat(struct LGL *lgl, signed int gidx);
// lglgluestats
// file lglib.c line 18095
static void lglgluestats(struct LGL *lgl);
// lglgoccsmatchcand
// file lglib.c line 13092
static signed int lglgoccsmatchcand(struct LGL *lgl, signed int a, signed int b);
// lglhasbin
// file lglib.c line 8465
static signed int lglhasbin(struct LGL *lgl, signed int a, signed int b);
// lglhasbingate
// file lglib.c line 12431
static signed int lglhasbingate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int rhs0, signed int rhs1);
// lglhasbins
// file lglib.c line 7787
static signed int lglhasbins(struct LGL *lgl, signed int lit);
// lglhasitegate
// file lglib.c line 12383
static signed int lglhasitegate(struct LGL *lgl, signed int lhs, signed int cond, signed int pos, signed int neg);
// lglhasopt
// file lglib.h line 121
signed int lglhasopt(struct LGL *lgl, const char *opt);
// lglhastrn
// file lglib.c line 10204
static signed int lglhastrn(struct LGL *lgl, signed int a, signed int b, signed int c);
// lglhbred
// file lglib.c line 4355
static signed int lglhbred(struct LGL *lgl, signed int subsumed, signed int red);
// lglheight
// file lglib.c line 5018
static double lglheight(struct LGL *lgl);
// lglhts
// file lglib.c line 2599
static struct HTS * lglhts(struct LGL *lgl, signed int lit);
// lglhts2wchs
// file lglib.c line 2603
static signed int * lglhts2wchs(struct LGL *lgl, struct HTS *hts);
// lgli2m
// file lglib.c line 9273
static signed int lgli2m(struct LGL *lgl, signed int ilit);
// lgliadd
// file lglib.c line 3685
static void lgliadd(struct LGL *lgl, signed int ilit);
// lgliassume
// file lglib.c line 7678
static void lgliassume(struct LGL *lgl, signed int lit);
// lglidx2lits
// file lglib.c line 2537
static signed int * lglidx2lits(struct LGL *lgl, signed int tag, signed int red, signed int lidx);
// lglifixed
// file lglib.c line 2794
static signed char lglifixed(struct LGL *lgl, signed int lit);
// lglifrozen
// file lglib.c line 3288
static signed int lglifrozen(struct LGL *lgl, signed int ilit);
// lglift
// file lglib.c line 14342
static signed int lglift(struct LGL *lgl);
// lgliftaux
// file lglib.c line 13973
static signed int lgliftaux(struct LGL *lgl);
// lglifting
// file lglib.c line 16959
static signed int lglifting(struct LGL *lgl);
// lgligetopt
// file lglib.c line 2253
static struct Opt * lgligetopt(struct LGL *lgl, const char *opt);
// lglilit
// file lglib.c line 6651
static signed int lglilit(signed int ulit);
// lglimerge
// file lglib.c line 8096
static void lglimerge(struct LGL *lgl, signed int lit, signed int repr);
// lglimhit
// file lglib.c line 17218
static signed int lglimhit(struct LGL *lgl, struct Lim *lim);
// lglimport
// file lglib.c line 2510
static signed int lglimport(struct LGL *lgl, signed int elit);
// lglinc
// file lglib.c line 1245
static void lglinc(struct LGL *lgl, unsigned long int bytes);
// lglincextractlimhit
// file lglib.c line 12580
static signed int lglincextractlimhit(struct LGL *lgl);
// lglincfdat
// file lglib.c line 7434
static void lglincfdat(struct ForceData *fdat, signed int lit, double cog);
// lglincirr
// file lglib.c line 3468
static void lglincirr(struct LGL *lgl, signed int size);
// lglincjwh
// file lglib.c line 6658
static void lglincjwh(struct LGL *lgl, signed int lit, signed long int inc);
// lglinclause
// file lglib.c line 12709
static void lglinclause(struct LGL *lgl, signed int parity);
// lglincocc
// file lglib.c line 3372
static void lglincocc(struct LGL *lgl, signed int lit);
// lglinconsistent
// file lglib.c line 17950
signed int lglinconsistent(struct LGL *lgl);
// lglincrestartaux
// file lglib.c line 6267
static void lglincrestartaux(struct LGL *lgl, signed int skip);
// lglincrestartl
// file lglib.c line 6287
static void lglincrestartl(struct LGL *lgl, signed int skip);
// lglincrestartlfixed
// file lglib.c line 6261
static void lglincrestartlfixed(struct LGL *lgl);
// lglincvar
// file lglib.c line 17902
signed int lglincvar(struct LGL *lgl);
// lglinit
// file lglib.h line 23
struct LGL * lglinit(void);
// lglinitcbs
// file lglib.c line 1312
static void lglinitcbs(struct LGL *lgl);
// lglinitecls
// file lglib.c line 9435
static void lglinitecls(struct LGL *lgl, signed int idx);
// lglinitsmallve
// file lglib.c line 10633
static signed int lglinitsmallve(struct LGL *lgl, signed int lit, unsigned long int *res);
// lglinitsolve
// file lglib.c line 17331
static void lglinitsolve(struct LGL *lgl);
// lglinnerprobe
// file lglib.c line 13860
static signed int lglinnerprobe(struct LGL *lgl, signed int old, struct Stk *outer, struct Stk *tmp);
// lglinout
// file lglib.c line 5262
static signed long int lglinout(struct LGL *lgl, signed int c, signed int relincpcnt);
// lglinprocessing
// file lglib.c line 17186
static signed int lglinprocessing(struct LGL *lgl);
// lgliphase
// file lglib.c line 6478
static signed char lgliphase(struct LGL *lgl, signed int lit);
// lglirepr
// file lglib.c line 7181
static signed int lglirepr(struct LGL *lgl, signed int lit);
// lglis
// file lglib.c line 6735
static signed int * lglis(struct LGL *lgl);
// lglisact
// file lglib.c line 3390
static signed int lglisact(signed int act);
// lglisat
// file lglib.c line 17581
static signed int lglisat(struct LGL *lgl, struct Lim *lim, signed int simpits);
// lgliselim
// file lglib.c line 2568
static signed int lgliselim(struct LGL *lgl, signed int lit);
// lglisetphase
// file lglib.c line 3883
static void lglisetphase(struct LGL *lgl, signed int lit, signed int phase);
// lglisfalsefun
// file lglib.c line 10525
static signed int lglisfalsefun(unsigned long int *f);
// lglisfree
// file lglib.c line 2342
static signed int lglisfree(struct LGL *lgl, signed int lit);
// lglisimp
// file lglib.c line 17019
static signed int lglisimp(struct LGL *lgl);
// lglislook
// file lglib.c line 8841
static signed int lglislook(struct LGL *lgl);
// lglispow2
// file lglib.c line 979
static signed int lglispow2(signed int n);
// lglistruefun
// file lglib.c line 10532
static signed int lglistruefun(unsigned long int *f);
// lglitcanbemelted
// file lglib.c line 18027
signed int lglitcanbemelted(struct LGL *lgl, signed int elit);
// lglitgone
// file lglib.c line 18014
signed int lglitgone(struct LGL *lgl, signed int elit);
// lgljoin
// file lglib.h line 83
signed int lgljoin(struct LGL *to, struct LGL *from);
// lgljwh
// file lglib.c line 6665
static void lgljwh(struct LGL *lgl);
// lgljwhlook
// file lglib.c line 8804
static signed int lgljwhlook(struct LGL *lgl);
// lglm2i
// file lglib.c line 9265
static signed int lglm2i(struct LGL *lgl, signed int mlit);
// lglmap
// file lglib.c line 7574
static void lglmap(struct LGL *lgl);
// lglmapass
// file lglib.c line 7230
static void lglmapass(struct LGL *lgl, signed int *map);
// lglmapequiv
// file lglib.c line 7413
static void lglmapequiv(struct LGL *lgl, signed int *map);
// lglmapext
// file lglib.c line 7186
static void lglmapext(struct LGL *lgl, signed int *map);
// lglmapglue
// file lglib.c line 6973
static void lglmapglue(struct LGL *lgl, signed int *map, struct Stk *lits);
// lglmaphts
// file lglib.c line 7054
static void lglmaphts(struct LGL *lgl, signed int *map);
// lglmaplit
// file lglib.c line 6962
static signed int lglmaplit(signed int *map, signed int lit);
// lglmaplits
// file lglib.c line 6980
static void lglmaplits(struct LGL *lgl, signed int *map);
// lglmapnonequiv
// file lglib.c line 7382
static void lglmapnonequiv(struct LGL *lgl, signed int *map, signed int size);
// lglmapqln
// file lglib.c line 7098
static void lglmapqln(struct LGL *lgl, struct Qln *line, signed int *map);
// lglmapqueue
// file lglib.c line 7125
static void lglmapqueue(struct LGL *lgl, signed int *map);
// lglmapsize
// file lglib.c line 7374
static signed int lglmapsize(struct LGL *lgl);
// lglmapstk
// file lglib.c line 6966
static void lglmapstk(struct LGL *lgl, signed int *map, struct Stk *lits);
// lglmaptrail
// file lglib.c line 7084
static void lglmaptrail(struct LGL *lgl, signed int *map);
// lglmapvars
// file lglib.c line 6987
static void lglmapvars(struct LGL *lgl, signed int *map, signed int nvars);
// lglmark
// file lglib.c line 2939
static void lglmark(struct LGL *lgl, signed int lit);
// lglmarked
// file lglib.c line 2843
static signed int lglmarked(struct LGL *lgl, signed int lit);
// lglmatchbingate
// file lglib.c line 13124
static signed int lglmatchbingate(struct LGL *lgl, struct Gat *g, struct Gat *h);
// lglmatchgate
// file lglib.c line 13295
static signed int lglmatchgate(struct LGL *lgl, signed int fixed, struct Gat *g, struct Gat *h);
// lglmatchitegate
// file lglib.c line 13098
static signed int lglmatchitegate(struct LGL *lgl, struct Gat *g, struct Gat *h);
// lglmatchlrgand
// file lglib.c line 13216
static signed int lglmatchlrgand(struct LGL *lgl, struct Gat *g, struct Gat *h);
// lglmatchlrgandaux
// file lglib.c line 13144
static signed int lglmatchlrgandaux(struct LGL *lgl, struct Gat *g, struct Gat *h);
// lglmatchlrgxor
// file lglib.c line 13223
static signed int lglmatchlrgxor(struct LGL *lgl, struct Gat *g, struct Gat *h);
// lglmax
// file lglib.c line 2309
static signed int lglmax(signed int a, signed int b);
// lglmaxmb
// file lglib.c line 4997
double lglmaxmb(struct LGL *lgl);
// lglmaxoptnamelen
// file lglib.c line 2087
static signed int lglmaxoptnamelen(struct LGL *lgl);
// lglmaxvar
// file lglib.c line 17893
signed int lglmaxvar(struct LGL *lgl);
// lglmb
// file lglib.h line 287
double lglmb(struct LGL *lgl);
// lglmelt
// file lglib.h line 263
void lglmelt(struct LGL *lgl, signed int elit);
// lglmeltall
// file lglib.c line 18043
void lglmeltall(struct LGL *lgl);
// lglmelter
// file lglib.c line 2504
static void lglmelter(struct LGL *lgl);
// lglmin
// file lglib.c line 2311
static signed int lglmin(signed int a, signed int b);
// lglmincls
// file lglib.c line 6003
static void lglmincls(struct LGL *lgl, signed int uip);
// lglminclslit
// file lglib.c line 4873
static signed int lglminclslit(struct LGL *lgl, signed int start);
// lglminit
// file lglib.c line 1700
struct LGL * lglminit(void *mem, void * (*alloc)(void *, unsigned long int), void * (*realloc)(void *, void *, unsigned long int, unsigned long int), void (*dealloc)(void *, void *, unsigned long int));
// lglminit::alloc$object
// 
void * alloc$object(void *, unsigned long int);
// lglminit::dealloc$object
// 
void dealloc$object(void *, void *, unsigned long int);
// lglminit::realloc$object
// 
void * realloc$object(void *, void *, unsigned long int, unsigned long int);
// lglmnt
// file lglib.c line 1054
static unsigned long int lglmnt(signed long int a);
// lglmosat
// file lglib.c line 17745
signed int lglmosat(struct LGL *lgl, void *state, signed int (*f)(void *, signed int, signed int), signed int *targets);
// lglmosat::f$object
// 
signed int f$object(void *, signed int, signed int);
// lglmsgend
// file lglib.c line 1199
static void lglmsgend(struct LGL *lgl);
// lglmsgstart
// file lglib.c line 1190
static signed int lglmsgstart(struct LGL *lgl, signed int level);
// lglmtstk
// file lglib.c line 1387
static signed int lglmtstk(struct Stk *s);
// lglmtwtk
// file lglib.c line 14987
static signed int lglmtwtk(struct Wtk *wtk);
// lglmulflt
// file lglib.c line 1126
static signed long int lglmulflt(signed long int a, signed long int b);
// lglmvbcls
// file lglib.c line 11138
static void lglmvbcls(struct LGL *lgl, signed int a, signed int b);
// lglmvtcls
// file lglib.c line 11157
static void lglmvtcls(struct LGL *lgl, signed int a, signed int b, signed int c);
// lglneedacts
// file lglib.c line 5144
static signed int lglneedacts(struct LGL *lgl, signed int *glueuselessptr, signed int *needmoreglueptr);
// lglnegass
// file lglib.c line 17554
static void lglnegass(struct LGL *lgl);
// lglnegcofactorfun
// file lglib.c line 10751
static void lglnegcofactorfun(unsigned long int *f, signed int v, unsigned long int *res);
// lglnegvar2fun
// file lglib.c line 10503
static void lglnegvar2fun(signed int v, unsigned long int *res);
// lglnew
// file lglib.c line 1258
static void * lglnew(struct LGL *lgl, unsigned long int bytes);
// lglnewbingate
// file lglib.c line 12451
static signed int lglnewbingate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int rhs0, signed int rhs1);
// lglnewgate
// file lglib.c line 12349
static struct Gat * lglnewgate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int size);
// lglnewirrlim
// file lglib.c line 6799
static signed long int lglnewirrlim(struct LGL *lgl);
// lglnewitegate
// file lglib.c line 12406
static void lglnewitegate(struct LGL *lgl, signed int lhs, signed int cond, signed int pos, signed int neg);
// lglnewlgl
// file lglib.c line 1669
static struct LGL * lglnewlgl(void *mem, void * (*alloc)(void *, unsigned long int), void * (*realloc)(void *, void *, unsigned long int, unsigned long int), void (*dealloc)(void *, void *, unsigned long int));
// lglnewlgl::alloc$object
// 
void * alloc$object(void *, unsigned long int);
// lglnewlgl::dealloc$object
// 
void dealloc$object(void *, void *, unsigned long int);
// lglnewlgl::realloc$object
// 
void * realloc$object(void *, void *, unsigned long int, unsigned long int);
// lglnewlrgate
// file lglib.c line 12478
static void lglnewlrgate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int *cls, signed int size);
// lglnewvar
// file lglib.c line 2435
static signed int lglnewvar(struct LGL *lgl);
// lglnextdecision
// file lglib.c line 6295
static signed int lglnextdecision(struct LGL *lgl);
// lglnextopt
// file lglib.c line 2144
void * lglnextopt(struct LGL *lgl, void *current, const char **nameptr, signed int *valptr, signed int *minptr, signed int *maxptr);
// lglnvars
// file lglib.c line 12317
signed int lglnvars(struct LGL *lgl);
// lglobalftlim
// file lglib.c line 13929
static signed long int lglobalftlim(struct LGL *lgl);
// lglocc
// file lglib.c line 3368
static signed int lglocc(struct LGL *lgl, signed int lit);
// lglonabort
// file lglib.c line 1316
void lglonabort(struct LGL *lgl, void *abortstate, void (*onabort)(void *));
// lglonabort::onabort$object
// 
void onabort$object(void *);
// lglonflict
// file lglib.c line 4035
static void lglonflict(struct LGL *lgl, signed int check, signed int lit, signed int red, signed int lidx);
// lglookahead
// file lglib.c line 17832
signed int lglookahead(struct LGL *lgl);
// lgloop
// file lglib.c line 17233
static signed int lgloop(struct LGL *lgl, struct Lim *lim);
// lglopenapitrace
// file lglib.c line 1485
static void lglopenapitrace(struct LGL *lgl, const char *name);
// lglopts
// file lglib.c line 2111
void lglopts(struct LGL *lgl, const char *prefix, signed int ignsome);
// lglor3fun
// file lglib.c line 10551
static void lglor3fun(unsigned long int *a, unsigned long int *b, unsigned long int *c);
// lglor3negfun
// file lglib.c line 10557
static void lglor3negfun(unsigned long int *a, unsigned long int *b, unsigned long int *c);
// lglordercls
// file lglib.c line 3007
static void lglordercls(struct LGL *lgl);
// lglorderclsaux
// file lglib.c line 2995
static void lglorderclsaux(struct LGL *lgl, signed int *start);
// lglorfun
// file lglib.c line 10539
static void lglorfun(unsigned long int *a, unsigned long int *b);
// lglornegfun
// file lglib.c line 10545
static void lglornegfun(unsigned long int *a, unsigned long int *b);
// lglpar64
// file lglib.c line 16222
static signed int lglpar64(unsigned long int i);
// lglparity
// file lglib.c line 12701
static signed int lglparity(struct LGL *lgl);
// lglpcnt
// file lglib.c line 3357
static double lglpcnt(double n, double d);
// lglpeek
// file lglib.c line 1391
static signed int lglpeek(struct Stk *s, signed int pos);
// lglphase
// file lglib.c line 6846
static void lglphase(struct LGL *lgl);
// lglpicosatchkall
// file lglib.c line 7337
static void lglpicosatchkall(struct LGL *lgl);
// lglpicosatrestart
// file lglib.c line 7356
static void lglpicosatrestart(struct LGL *lgl);
// lglpoison
// file lglib.c line 4841
static signed int lglpoison(struct LGL *lgl, signed int lit, struct Stk *stk);
// lglpoke
// file lglib.c line 1396
static void lglpoke(struct Stk *s, signed int pos, signed int val);
// lglpopcontrol
// file lglib.c line 1569
static void lglpopcontrol(struct LGL *lgl);
// lglpopesched
// file lglib.c line 5628
static signed int lglpopesched(struct LGL *lgl);
// lglpopnunlcamarkstk
// file lglib.c line 4132
static void lglpopnunlcamarkstk(struct LGL *lgl, struct Stk *stk);
// lglpopnunmarkstk
// file lglib.c line 4127
static void lglpopnunmarkstk(struct LGL *lgl, struct Stk *stk);
// lglpopstk
// file lglib.c line 1447
static signed int lglpopstk(struct Stk *s);
// lglpos2cnf
// file lglib.c line 10729
static signed long int lglpos2cnf(signed int pos);
// lglposcofactorfun
// file lglib.c line 10760
static void lglposcofactorfun(unsigned long int *f, signed int v, unsigned long int *res);
// lglprbana
// file lglib.c line 8406
static signed int lglprbana(struct LGL *lgl, signed int probe);
// lglprbpull
// file lglib.c line 8393
static signed int lglprbpull(struct LGL *lgl, signed int lit, signed int probe);
// lglprefix
// file lglib.c line 1186
static const char * lglprefix(struct LGL *lgl);
// lglpreprocessing
// file lglib.c line 17151
static signed int lglpreprocessing(struct LGL *lgl, signed int forced);
// lglprint
// file lglib.c line 18806
void lglprint(struct LGL *lgl, struct _IO_FILE *file);
// lglprintfeatures
// file lglib.c line 18556
void lglprintfeatures(struct LGL *lgl);
// lglprobe
// file lglib.c line 9113
static signed int lglprobe(struct LGL *lgl);
// lglprobing
// file lglib.c line 16864
static signed int lglprobing(struct LGL *lgl);
// lglprocesstime
// file lglib.h line 290
double lglprocesstime(void);
// lglprop
// file lglib.c line 4420
static void lglprop(struct LGL *lgl, signed int lit);
// lglprop2
// file lglib.c line 4697
static void lglprop2(struct LGL *lgl, signed int lit);
// lglpropsearch
// file lglib.c line 4245
static void lglpropsearch(struct LGL *lgl, signed int lit);
// lglpropunits
// file lglib.c line 13725
static signed int lglpropunits(struct LGL *lgl);
// lglprs
// file lglib.c line 18084
static void lglprs(struct LGL *lgl, const char *fmt, ...);
// lglprstart
// file lglib.c line 18078
static void lglprstart(struct LGL *lgl);
// lglprt
// file lglib.c line 1206
static void lglprt(struct LGL *lgl, signed int level, const char *msg, ...);
// lglprtcgrem
// file lglib.c line 12985
static void lglprtcgrem(struct LGL *lgl);
// lglprternresrem
// file lglib.c line 14689
static void lglprternresrem(struct LGL *lgl);
// lglprtlftrem
// file lglib.c line 13956
static void lglprtlftrem(struct LGL *lgl);
// lglptrjmp
// file lglib.c line 7151
static signed int lglptrjmp(signed int *repr, signed int max, signed int start);
// lglpull
// file lglib.c line 4809
static signed int lglpull(struct LGL *lgl, signed int lit);
// lglpurelit
// file lglib.c line 11122
static signed int lglpurelit(struct LGL *lgl, signed int lit);
// lglpushcontrol
// file lglib.c line 1560
static void lglpushcontrol(struct LGL *lgl, signed int decision);
// lglpushgocc
// file lglib.c line 12323
static void lglpushgocc(struct LGL *lgl, signed int lit, signed int gidx);
// lglpushnmarkseen
// file lglib.c line 11116
static void lglpushnmarkseen(struct LGL *lgl, signed int lit);
// lglpushstk
// file lglib.c line 1431
static void lglpushstk(struct LGL *lgl, struct Stk *s, signed int elem);
// lglpushwch
// file lglib.c line 3115
static signed long int lglpushwch(struct LGL *lgl, struct HTS *hts, signed int wch);
// lglpushwtk
// file lglib.c line 15009
static void lglpushwtk(struct LGL *lgl, struct Wtk *wtk, enum Wrag wrag, signed int lit, signed int other, signed int red);
// lglqclone
// file lglib.c line 1906
static void lglqclone(struct LGL *lgl, struct LGL *orig);
// lglqcmp
// file lglib.c line 2753
static signed int lglqcmp(struct LGL *lgl, signed int l, signed int k);
// lglqdump
// file lglib.c line 2421
static void lglqdump(struct LGL *lgl);
// lglqln
// file lglib.c line 2741
static struct Qln * lglqln(struct LGL *lgl, signed int lit);
// lglqnd
// file lglib.c line 1900
static struct Qnd * lglqnd(struct LGL *lgl, signed int lit);
// lglqsched
// file lglib.c line 2372
static void lglqsched(struct LGL *lgl, signed int idx);
// lglqschedall
// file lglib.c line 17259
static void lglqschedall(struct LGL *lgl);
// lglrand
// file lglib.c line 1529
static unsigned int lglrand(struct LGL *lgl);
// lglrandec
// file lglib.c line 7686
static signed int lglrandec(struct LGL *lgl);
// lglrandidxtrav
// file lglib.c line 3327
static signed int lglrandidxtrav(struct LGL *lgl, signed int (*fun)(struct LGL *, signed int));
// lglrandidxtrav::fun$object
// 
//signed int fun$object(struct LGL *, signed int);
// lglrandlitrav
// file lglib.c line 8594
static signed int lglrandlitrav(struct LGL *lgl, signed int (*fun)(struct LGL *, signed int));
// lglrandlitrav::fun$object
// 
//signed int fun$object(struct LGL *, signed int);
// lglrandomprobe
// file lglib.c line 13848
static signed int lglrandomprobe(struct LGL *lgl, struct Stk *outer);
// lglreadopts
// file lglib.c line 2203
signed int lglreadopts(struct LGL *lgl, struct _IO_FILE *file);
// lglredstk
// file lglib.c line 1456
static void lglredstk(struct LGL *lgl, struct Stk *s, signed int minsize, signed int pow2smaller);
// lglreduce
// file lglib.c line 5281
static void lglreduce(struct LGL *lgl, signed int forced);
// lglreducing
// file lglib.c line 16979
static signed int lglreducing(struct LGL *lgl);
// lglredvars
// file lglib.c line 2300
static void lglredvars(struct LGL *lgl);
// lglregularly
// file lglib.c line 17087
static void lglregularly(struct LGL *lgl);
// lglrelctk
// file lglib.c line 1546
static void lglrelctk(struct LGL *lgl, struct Ctk *ctk);
// lglrelease
// file lglib.h line 24
void lglrelease(struct LGL *lgl);
// lglrelease::1::dealloc$object
// 
void dealloc$object(void *, void *, unsigned long int);
// lglrelecls
// file lglib.c line 9422
static void lglrelecls(struct LGL *lgl);
// lglrelqueue
// file lglib.c line 18614
static void lglrelqueue(struct LGL *lgl);
// lglrelstk
// file lglib.c line 1410
static void lglrelstk(struct LGL *lgl, struct Stk *s);
// lglrelwtk
// file lglib.c line 14995
static void lglrelwtk(struct LGL *lgl, struct Wtk *wtk);
// lglrem
// file lglib.c line 3348
static signed int lglrem(struct LGL *lgl);
// lglrep
// file lglib.c line 5046
static void lglrep(struct LGL *lgl, signed int level, char type);
// lglrephead
// file lglib.c line 5028
static void lglrephead(struct LGL *lgl);
// lglrepr
// file lglib.c line 17980
signed int lglrepr(struct LGL *lgl, signed int elit);
// lglreqinit
// file lglib.c line 18994
static void lglreqinit(struct LGL *lgl);
// lglrescoreclauses
// file lglib.c line 3414
static void lglrescoreclauses(struct LGL *lgl);
// lglrescoreglue
// file lglib.c line 3392
static void lglrescoreglue(struct LGL *lgl, signed int glue);
// lglreset
// file lglib.c line 3744
static void lglreset(struct LGL *lgl);
// lglresetforked
// file lglib.c line 18920
void lglresetforked(struct LGL *lgl);
// lglresetphase
// file lglib.c line 3908
void lglresetphase(struct LGL *lgl, signed int elit);
// lglresetsmallve
// file lglib.c line 10708
static void lglresetsmallve(struct LGL *lgl);
// lglrestart
// file lglib.c line 6334
static void lglrestart(struct LGL *lgl);
// lglrestarting
// file lglib.c line 16996
static signed int lglrestarting(struct LGL *lgl);
// lglreusetrail
// file lglib.c line 6315
static signed int lglreusetrail(struct LGL *lgl);
// lglrgopts
// file lglib.c line 2125
void lglrgopts(struct LGL *lgl);
// lglrmbcls
// file lglib.c line 5668
static void lglrmbcls(struct LGL *lgl, signed int a, signed int b, signed int red);
// lglrmbindup
// file lglib.c line 15958
static void lglrmbindup(struct LGL *lgl);
// lglrmbwch
// file lglib.c line 5603
static void lglrmbwch(struct LGL *lgl, signed int lit, signed int other, signed int red);
// lglrminc
// file lglib.c line 4086
static void lglrminc(struct LGL *lgl, const signed int *w, const signed int *eow);
// lglrmlcls
// file lglib.c line 5686
static void lglrmlcls(struct LGL *lgl, signed int lidx, signed int red);
// lglrmlocc
// file lglib.c line 4363
static void lglrmlocc(struct LGL *lgl, signed int lit, signed int red, signed int lidx);
// lglrmlwch
// file lglib.c line 4210
static void lglrmlwch(struct LGL *lgl, signed int lit, signed int red, signed int lidx);
// lglrmstk
// file lglib.c line 1436
static void lglrmstk(struct Stk *s, signed int elem);
// lglrmtcls
// file lglib.c line 5676
static void lglrmtcls(struct LGL *lgl, signed int a, signed int b, signed int c, signed int red);
// lglrmtwch
// file lglib.c line 4099
static void lglrmtwch(struct LGL *lgl, signed int lit, signed int other1, signed int other2, signed int red);
// lglrmvbcls
// file lglib.c line 11792
static void lglrmvbcls(struct LGL *lgl, signed int a, signed int b);
// lglrmvtcls
// file lglib.c line 11797
static void lglrmvtcls(struct LGL *lgl, signed int a, signed int b, signed int c);
// lglrsn
// file lglib.c line 2578
static signed int * lglrsn(struct LGL *lgl, signed int lit);
// lglrstcontrol
// file lglib.c line 1574
static void lglrstcontrol(struct LGL *lgl, signed int count);
// lglrstecls
// file lglib.c line 9407
static void lglrstecls(struct LGL *lgl);
// lglrststk
// file lglib.c line 1451
static void lglrststk(struct Stk *s, signed int newsz);
// lglrsz
// file lglib.c line 1279
static void * lglrsz(struct LGL *lgl, void *ptr, unsigned long int old, unsigned long int new);
// lglrszvars
// file lglib.c line 2279
static void lglrszvars(struct LGL *lgl, signed int new_size);
// lglrtrav
// file lglib.c line 18813
void lglrtrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int, signed int));
// lglrtrav::trav$object
// 
//void trav$object(void *, signed int, signed int);
// lgls2fun
// file lglib.c line 10626
static void lgls2fun(signed int mlit, unsigned long int *res);
// lgls2m
// file lglib.c line 10460
static signed int lgls2m(struct LGL *lgl, signed int ilit);
// lglsat
// file lglib.h line 189
signed int lglsat(struct LGL *lgl);
// lglschedbasicprobe
// file lglib.c line 8877
static signed int lglschedbasicprobe(struct LGL *lgl, struct Stk *probes, signed int round);
// lglsearch
// file lglib.c line 17247
static signed int lglsearch(struct LGL *lgl, struct Lim *lim);
// lglsec
// file lglib.c line 4985
double lglsec(struct LGL *lgl);
// lglsetallphases
// file lglib.c line 6823
static void lglsetallphases(struct LGL *lgl);
// lglsetbinminrhs
// file lglib.c line 13045
static void lglsetbinminrhs(struct LGL *lgl, struct Gat *g);
// lglsetblklim
// file lglib.c line 11284
static void lglsetblklim(struct LGL *lgl);
// lglsetccelim
// file lglib.c line 11450
static void lglsetccelim(struct LGL *lgl);
// lglsetcgrclsrlim
// file lglib.c line 13759
static void lglsetcgrclsrlim(struct LGL *lgl);
// lglsetclifflim
// file lglib.c line 12037
static void lglsetclifflim(struct LGL *lgl);
// lglsetconsumedunits
// file lglib.c line 1360
void lglsetconsumedunits(struct LGL *lgl, void (*fun)(void *, signed int), void *state);
// lglsetconsumedunits::fun$object
// 
//void fun$object(void *, signed int);
// lglsetconsumeunits
// file lglib.c line 1337
void lglsetconsumeunits(struct LGL *lgl, void (*fun)(void *, signed int **, signed int **), void *state);
// lglsetconsumeunits::fun$object
// 
//void fun$object(void *, signed int **, signed int **);
// lglsetdom
// file lglib.c line 2582
static void lglsetdom(struct LGL *lgl, signed int lit, signed int dom);
// lglsetdonotesched
// file lglib.c line 11356
static void lglsetdonotesched(struct LGL *lgl, signed int completed);
// lglsetelmlim
// file lglib.c line 12095
static void lglsetelmlim(struct LGL *lgl);
// lglseterm
// file lglib.h line 295
void lglseterm(struct LGL *lgl, signed int (*fun)(void *), void *state);
// lglseterm::fun$object
// 
//signed int fun$object(void *);
// lglseternreslim
// file lglib.c line 14656
static void lglseternreslim(struct LGL *lgl);
// lglsetgausslim
// file lglib.c line 16781
static void lglsetgausslim(struct LGL *lgl);
// lglsetid
// file lglib.h line 134
void lglsetid(struct LGL *lgl, signed int tid, signed int tids);
// lglsetime
// file lglib.h line 306
void lglsetime(struct LGL *lgl, double (*time)(void));
// lglsetime::time$object
// 
double time$object(void);
// lglsetiteminrhs
// file lglib.c line 13069
static void lglsetiteminrhs(struct LGL *lgl, struct Gat *g);
// lglsetjwhbias
// file lglib.c line 6809
static signed int lglsetjwhbias(struct LGL *lgl, signed int idx);
// lglsetlim
// file lglib.c line 17705
static void lglsetlim(struct LGL *lgl, struct Lim *lim);
// lglsetlockeq
// file lglib.c line 1346
void lglsetlockeq(struct LGL *lgl, signed int * (*fun)(void *), void *state);
// lglsetlockeq::fun$object
// 
signed int * fun$object(void *);
// lglsetlrgminrhs
// file lglib.c line 13056
static void lglsetlrgminrhs(struct LGL *lgl, struct Gat *g);
// lglsetminrhs
// file lglib.c line 13074
static void lglsetminrhs(struct LGL *lgl, struct Gat *g);
// lglsetmsglock
// file lglib.h line 305
void lglsetmsglock(struct LGL *lgl, void (*lock)(void *), void (*unlock)(void *), void *state);
// lglsetmsglock::lock$object
// 
void lock$object(void *);
// lglsetmsglock::unlock$object
// 
void unlock$object(void *);
// lglsetopt
// file lglib.h line 118
void lglsetopt(struct LGL *lgl, const char *opt, signed int val);
// lglsetout
// file lglib.h line 112
void lglsetout(struct LGL *lgl, struct _IO_FILE *out);
// lglsetphase
// file lglib.c line 3899
void lglsetphase(struct LGL *lgl, signed int elit);
// lglsetphases
// file lglib.c line 17463
void lglsetphases(struct LGL *lgl);
// lglsetplain
// file lglib.c line 1652
static void lglsetplain(struct LGL *lgl, signed int val);
// lglsetprbasiclim
// file lglib.c line 8941
static void lglsetprbasiclim(struct LGL *lgl);
// lglsetprefix
// file lglib.h line 113
void lglsetprefix(struct LGL *lgl, const char *prefix);
// lglsetproduceunit
// file lglib.c line 1330
void lglsetproduceunit(struct LGL *lgl, void (*fun)(void *, signed int), void *state);
// lglsetproduceunit::fun$object
// 
//void fun$object(void *, signed int);
// lglsetrdlim
// file lglib.c line 14886
static void lglsetrdlim(struct LGL *lgl);
// lglsetunhdlim
// file lglib.c line 16124
static void lglsetunhdlim(struct LGL *lgl);
// lglsetunlockeq
// file lglib.c line 1353
void lglsetunlockeq(struct LGL *lgl, void (*fun)(void *, signed int, signed int), void *state);
// lglsetunlockeq::fun$object
// 
//void fun$object(void *, signed int, signed int);
// lglsetup
// file lglib.c line 17294
static void lglsetup(struct LGL *lgl);
// lglsgn
// file lglib.c line 2459
static signed int lglsgn(signed int lit);
// lglshrinkhts
// file lglib.c line 3029
static void lglshrinkhts(struct LGL *lgl, struct HTS *hts, signed int newcount);
// lglshrstk
// file lglib.c line 1415
static void lglshrstk(struct LGL *lgl, struct Stk *s, signed int new_size);
// lglsig
// file lglib.c line 9301
static unsigned int lglsig(signed int lit);
// lglsignedmark
// file lglib.c line 7205
static void lglsignedmark(struct LGL *lgl, signed int lit);
// lglsignedmark2
// file lglib.c line 11486
static void lglsignedmark2(struct LGL *lgl, signed int lit);
// lglsignedmarked
// file lglib.c line 7224
static signed int lglsignedmarked(struct LGL *lgl, signed int lit);
// lglsignedmarked2
// file lglib.c line 11500
static signed int lglsignedmarked2(struct LGL *lgl, signed int lit);
// lglsignedmarknpushseen
// file lglib.c line 7219
static void lglsignedmarknpushseen(struct LGL *lgl, signed int lit);
// lglsignedunmark
// file lglib.c line 7212
static void lglsignedunmark(struct LGL *lgl, signed int lit);
// lglsignedunmark2
// file lglib.c line 11493
static void lglsignedunmark2(struct LGL *lgl, signed int lit);
// lglsimp
// file lglib.c line 17875
signed int lglsimp(struct LGL *lgl, signed int iterations);
// lglsimpand
// file lglib.c line 13437
static signed int lglsimpand(struct LGL *lgl, struct Gat *g);
// lglsimpbinand
// file lglib.c line 13334
static signed int lglsimpbinand(struct LGL *lgl, struct Gat *g);
// lglsimpbinxor
// file lglib.c line 13443
static signed int lglsimpbinxor(struct LGL *lgl, struct Gat *g);
// lglsimpcls
// file lglib.c line 2969
static signed int lglsimpcls(struct LGL *lgl);
// lglsimpcntrem
// file lglib.c line 17137
static signed int lglsimpcntrem(struct LGL *lgl, signed int oldrem);
// lglsimpgate
// file lglib.c line 13608
static signed int lglsimpgate(struct LGL *lgl, struct Gat *g);
// lglsimpite
// file lglib.c line 13523
static signed int lglsimpite(struct LGL *lgl, struct Gat *g);
// lglsimpleprobebinexists
// file lglib.c line 8617
static signed int lglsimpleprobebinexists(struct LGL *lgl, signed int a, signed int b);
// lglsimpleprobeclausexists
// file lglib.c line 8703
static signed int lglsimpleprobeclausexists(struct LGL *lgl);
// lglsimpleprobelrgexists
// file lglib.c line 8663
static signed int lglsimpleprobelrgexists(struct LGL *lgl, signed int a);
// lglsimpleprobetrnexists
// file lglib.c line 8637
static signed int lglsimpleprobetrnexists(struct LGL *lgl, signed int a, signed int b, signed int c);
// lglsimplimhit
// file lglib.c line 17165
static signed int lglsimplimhit(struct LGL *lgl);
// lglsimplrgand
// file lglib.c line 13375
static signed int lglsimplrgand(struct LGL *lgl, struct Gat *g);
// lglsimplrgxor
// file lglib.c line 13479
static signed int lglsimplrgxor(struct LGL *lgl, struct Gat *g);
// lglsimpxor
// file lglib.c line 13517
static signed int lglsimpxor(struct LGL *lgl, struct Gat *g);
// lglsize2cnf
// file lglib.c line 10730
static signed long int lglsize2cnf(signed int s);
// lglsizectk
// file lglib.c line 1542
static signed int lglsizectk(struct Ctk *ctk);
// lglsizes
// file lglib.c line 18590
void lglsizes(struct LGL *lgl);
// lglsizewtk
// file lglib.c line 14991
static signed int lglsizewtk(struct Wtk *wtk);
// lglslfun
// file lglib.c line 10607
static void lglslfun(unsigned long int *a, signed int shift);
// lglsmalladdlit2cnf
// file lglib.c line 10842
static signed long int lglsmalladdlit2cnf(struct LGL *lgl, signed long int cnf, signed int lit);
// lglsmallcnfunits
// file lglib.c line 10957
static signed int lglsmallcnfunits(struct LGL *lgl, signed long int cnf);
// lglsmallevalcls
// file lglib.c line 10714
static void lglsmallevalcls(unsigned int cls, unsigned long int *res);
// lglsmallevalcnf
// file lglib.c line 10738
static void lglsmallevalcnf(struct LGL *lgl, signed long int cnf, unsigned long int *res);
// lglsmallfundeps0
// file lglib.c line 10769
static signed int lglsmallfundeps0(unsigned long int *f);
// lglsmallfundeps1
// file lglib.c line 10777
static signed int lglsmallfundeps1(unsigned long int *f);
// lglsmallfundeps2
// file lglib.c line 10785
static signed int lglsmallfundeps2(unsigned long int *f);
// lglsmallfundeps3
// file lglib.c line 10793
static signed int lglsmallfundeps3(unsigned long int *f);
// lglsmallfundeps4
// file lglib.c line 10801
static signed int lglsmallfundeps4(unsigned long int *f);
// lglsmallfundeps5
// file lglib.c line 10809
static signed int lglsmallfundeps5(unsigned long int *f);
// lglsmallfundepsgen
// file lglib.c line 10817
static signed int lglsmallfundepsgen(unsigned long int *f, signed int min);
// lglsmallipos
// file lglib.c line 10874
static signed long int lglsmallipos(struct LGL *lgl, unsigned long int *U, unsigned long int *L, signed int min);
// lglsmallirr
// file lglib.c line 9103
static signed int lglsmallirr(struct LGL *lgl);
// lglsmallisunitcls
// file lglib.c line 10943
static signed int lglsmallisunitcls(struct LGL *lgl, signed int cls);
// lglsmalltopvar
// file lglib.c line 10827
static signed int lglsmalltopvar(unsigned long int *f, signed int min);
// lglsmallve
// file lglib.c line 10911
static void lglsmallve(struct LGL *lgl, signed long int cnf);
// lglsolve
// file lglib.c line 17284
static signed int lglsolve(struct LGL *lgl, struct Lim *lim, signed int forcesimp);
// lglsparse
// file lglib.c line 9229
static void lglsparse(struct LGL *lgl);
// lglsqr
// file lglib.c line 18093
static double lglsqr(double a);
// lglsrfun
// file lglib.c line 10587
static void lglsrfun(unsigned long int *a, signed int shift);
// lglstamp
// file lglib.c line 15021
static signed int lglstamp(struct LGL *lgl, signed int root, struct DFPR *dfpr, struct DFOPF *dfopf, struct Wtk *work, struct Stk *units, struct Stk *sccs, struct Stk *trds, signed int *visitedptr, signed int stamp, signed int irronly);
// lglstampall
// file lglib.c line 16012
static struct DFPR * lglstampall(struct LGL *lgl, signed int irronly);
// lglstart
// file lglib.c line 4961
static void lglstart(struct LGL *lgl, double *timestatsptr);
// lglstats
// file lglib.h line 280
void lglstats(struct LGL *lgl);
// lglsteps
// file lglib.c line 8309
static signed long int lglsteps(struct LGL *lgl);
// lglstop
// file lglib.c line 4991
static void lglstop(struct LGL *lgl);
// lglstrdup
// file lglib.c line 1300
static char * lglstrdup(struct LGL *lgl, const char *str);
// lglsynceqs
// file lglib.c line 12204
static signed int lglsynceqs(struct LGL *lgl);
// lglsyncunits
// file lglib.c line 8333
static signed int lglsyncunits(struct LGL *lgl);
// lglsyncunits::1::produce$object
// 
void produce$object(void *, signed int);
// lglszpen
// file lglib.c line 8728
static signed int lglszpen(struct LGL *lgl);
// lglszstk
// file lglib.c line 1389
static unsigned long int lglszstk(struct Stk *s);
// lgltarjan
// file lglib.c line 8194
static signed int lgltarjan(struct LGL *lgl);
// lgltd
// file lglib.c line 2334
static struct TD * lgltd(struct LGL *lgl, signed int lit);
// lglterminate
// file lglib.c line 8319
static signed int lglterminate(struct LGL *lgl);
// lglternres
// file lglib.c line 14734
static signed int lglternres(struct LGL *lgl);
// lglternresidx
// file lglib.c line 14651
static void lglternresidx(struct LGL *lgl, signed int idx);
// lglternresinit
// file lglib.c line 14706
static void lglternresinit(struct LGL *lgl);
// lglternreslit
// file lglib.c line 14550
static void lglternreslit(struct LGL *lgl, signed int lit);
// lglternresolving
// file lglib.c line 17008
static signed int lglternresolving(struct LGL *lgl);
// lgltonflict
// file lglib.c line 4021
static void lgltonflict(struct LGL *lgl, signed int lit, signed int blit, signed int other2);
// lgltopgc
// file lglib.c line 7668
static signed int lgltopgc(struct LGL *lgl);
// lgltopsimp
// file lglib.c line 17267
static signed int lgltopsimp(struct LGL *lgl, signed int forcesimp);
// lgltopstk
// file lglib.c line 1449
static signed int lgltopstk(struct Stk *s);
// lgltrail
// file lglib.c line 2332
static signed int lgltrail(struct LGL *lgl, signed int lit);
// lgltrapi
// file lglib.c line 1476
static void lgltrapi(struct LGL *lgl, const char *msg, ...);
// lgltravall
// file lglib.c line 18882
void lgltravall(struct LGL *lgl, void *state, void (*trav)(void *, signed int));
// lgltravall::trav$object
// 
//void trav$object(void *, signed int);
// lgltravalle
// file lglib.c line 18872
static void lgltravalle(void *voidptr, signed int lit, signed int repr);
// lgltravallu
// file lglib.c line 18866
static void lgltravallu(void *voidptr, signed int unit);
// lgltravcounter
// file lglib.c line 18795
static void lgltravcounter(void *voidptr, signed int lit);
// lgltravprinter
// file lglib.c line 18800
static void lgltravprinter(void *voidptr, signed int lit);
// lgltrd
// file lglib.c line 14908
static signed int lgltrd(struct LGL *lgl);
// lgltrdbin
// file lglib.c line 14784
static signed int lgltrdbin(struct LGL *lgl, signed int start, signed int target, signed int irr);
// lgltrdlit
// file lglib.c line 14845
static void lgltrdlit(struct LGL *lgl, signed int start);
// lgltreducing
// file lglib.c line 16949
static signed int lgltreducing(struct LGL *lgl);
// lgltruefun
// file lglib.c line 10519
static void lgltruefun(unsigned long int *res);
// lgltrylargeve
// file lglib.c line 10247
static signed int lgltrylargeve(struct LGL *lgl);
// lgltrysmallve
// file lglib.c line 10973
static signed int lgltrysmallve(struct LGL *lgl, signed int idx);
// lgluby
// file lglib.c line 5256
static signed long int lgluby(struct LGL *lgl, signed int i);
// lglubyrec
// file lglib.c line 5237
static signed long int lglubyrec(struct LGL *lgl, signed int i);
// lglulit
// file lglib.c line 2580
static signed int lglulit(signed int lit);
// lglunassign
// file lglib.c line 2759
static void lglunassign(struct LGL *lgl, signed int lit);
// lglunclone
// file lglib.c line 17616
signed int lglunclone(struct LGL *lgl, struct LGL *from);
// lglunflict
// file lglib.c line 5719
static void lglunflict(struct LGL *lgl, signed int lit);
// lglunhdfailed
// file lglib.c line 15928
static signed int lglunhdfailed(struct LGL *lgl);
// lglunhdhasbins
// file lglib.c line 14955
static signed int lglunhdhasbins(struct LGL *lgl, const struct DFPR *dfpr, signed int lit, signed int irronly);
// lglunhdhbrs
// file lglib.c line 15937
static signed int lglunhdhbrs(struct LGL *lgl);
// lglunhdisroot
// file lglib.c line 14981
static signed int lglunhdisroot(struct LGL *lgl, signed int lit, struct DFPR *dfpr, signed int irronly);
// lglunhdstrd
// file lglib.c line 15951
static signed int lglunhdstrd(struct LGL *lgl);
// lglunhdtauts
// file lglib.c line 15943
static signed int lglunhdtauts(struct LGL *lgl);
// lglunhdunits
// file lglib.c line 15921
static signed int lglunhdunits(struct LGL *lgl);
// lglunhide
// file lglib.c line 16151
static signed int lglunhide(struct LGL *lgl);
// lglunhidebintrn
// file lglib.c line 15283
static signed int lglunhidebintrn(struct LGL *lgl, const struct DFPR *dfpr, signed int irronly);
// lglunhidefailed
// file lglib.c line 15247
static signed int lglunhidefailed(struct LGL *lgl, const struct DFPR *dfpr);
// lglunhideglue
// file lglib.c line 15493
static signed int lglunhideglue(struct LGL *lgl, const struct DFPR *dfpr, signed int glue, signed int irronly);
// lglunhidelrg
// file lglib.c line 15913
static signed int lglunhidelrg(struct LGL *lgl, const struct DFPR *dfpr, signed int irronly);
// lglunhiding
// file lglib.c line 16951
static signed int lglunhiding(struct LGL *lgl);
// lglunhimpl
// file lglib.c line 10176
static signed int lglunhimpl(const struct DFPR *dfpr, signed int a, signed int b);
// lglunhimplies2
// file lglib.c line 10186
static signed int lglunhimplies2(const struct DFPR *dfpr, signed int a, signed int b);
// lglunhimplies2incl
// file lglib.c line 10200
static signed int lglunhimplies2incl(const struct DFPR *dfpr, signed int a, signed int b);
// lglunhimplincl
// file lglib.c line 10190
static signed int lglunhimplincl(const struct DFPR *dfpr, signed int a, signed int b);
// lglunhlca
// file lglib.c line 15222
static signed int lglunhlca(struct LGL *lgl, const struct DFPR *dfpr, signed int a, signed int b);
// lglunhroot
// file lglib.c line 15279
static signed int lglunhroot(const struct DFPR *dfpr, signed int lit);
// lglunit
// file lglib.c line 2932
static void lglunit(struct LGL *lgl, signed int lit);
// lglunitnocheck
// file lglib.c line 2926
static void lglunitnocheck(struct LGL *lgl, signed int lit);
// lglunmark
// file lglib.c line 2943
static void lglunmark(struct LGL *lgl, signed int lit);
// lglunuselevel
// file lglib.c line 1595
static void lglunuselevel(struct LGL *lgl, signed int level);
// lglupdblkint
// file lglib.c line 11312
static void lglupdblkint(struct LGL *lgl, signed int success);
// lglupdcceint
// file lglib.c line 11473
static void lglupdcceint(struct LGL *lgl, signed int success);
// lglupdcgrpen
// file lglib.c line 13754
static void lglupdcgrpen(struct LGL *lgl, signed int success);
// lglupdcliffint
// file lglib.c line 12059
static void lglupdcliffint(struct LGL *lgl, signed int success);
// lglupdelmint
// file lglib.c line 12122
static void lglupdelmint(struct LGL *lgl, signed int success);
// lglupdflipint
// file lglib.c line 7752
static void lglupdflipint(struct LGL *lgl);
// lglupdgausspen
// file lglib.c line 16803
static void lglupdgausspen(struct LGL *lgl, signed int success);
// lglupdlftpen
// file lglib.c line 13951
static void lglupdlftpen(struct LGL *lgl, signed int success);
// lglupdprbasicpen
// file lglib.c line 8934
static void lglupdprbasicpen(struct LGL *lgl, signed int success);
// lglupdprepint
// file lglib.c line 17092
static void lglupdprepint(struct LGL *lgl, signed int red);
// lglupdternrespen
// file lglib.c line 14684
static void lglupdternrespen(struct LGL *lgl, signed int success);
// lglupdunhdpen
// file lglib.c line 16146
static void lglupdunhdpen(struct LGL *lgl, signed int success);
// lglusage
// file lglib.c line 2096
void lglusage(struct LGL *lgl);
// lgluse
// file lglib.c line 3806
static void lgluse(struct LGL *lgl);
// lgluselevel
// file lglib.c line 1587
static void lgluselevel(struct LGL *lgl, signed int level);
// lglutrav
// file lglib.c line 18718
void lglutrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int));
// lglutrav::trav$object
// 
//void trav$object(void *, signed int);
// lglval
// file lglib.c line 2323
static signed char lglval(struct LGL *lgl, signed int lit);
// lglvar2fun
// file lglib.c line 10499
static void lglvar2fun(signed int v, unsigned long int *res);
// lglvar2funaux
// file lglib.c line 10477
static void lglvar2funaux(signed int v, unsigned long int *res, signed int negate);
// lglversion
// file lglbnr.c line 52
const char * lglversion(void);
// lglvmtf
// file lglib.c line 5915
static void lglvmtf(struct LGL *lgl, signed int lit);
// lglwchbin
// file lglib.c line 3132
static signed long int lglwchbin(struct LGL *lgl, signed int lit, signed int other, signed int red);
// lglwchlrg
// file lglib.c line 3153
static signed long int lglwchlrg(struct LGL *lgl, signed int lit, signed int other, signed int red, signed int lidx);
// lglwchtrn
// file lglib.c line 3142
static signed long int lglwchtrn(struct LGL *lgl, signed int a, signed int b, signed int c, signed int red);
// lglwrkcompact
// file lglib.c line 8514
static void lglwrkcompact(struct LGL *lgl);
// lglwrkdeq
// file lglib.c line 8557
static signed int lglwrkdeq(struct LGL *lgl);
// lglwrkinit
// file lglib.c line 8488
static void lglwrkinit(struct LGL *lgl, signed int posonly, signed int fifo);
// lglwrknext
// file lglib.c line 8590
static signed int lglwrknext(struct LGL *lgl);
// lglwrkpop
// file lglib.c line 8573
static signed int lglwrkpop(struct LGL *lgl);
// lglwrkreset
// file lglib.c line 8504
static void lglwrkreset(struct LGL *lgl);
// lglwrktouch
// file lglib.c line 8535
static signed int lglwrktouch(struct LGL *lgl, signed int lit);
// lglwrn
// file lglib.c line 1150
static void lglwrn(struct LGL *lgl, const char *msg, ...);
// lglws
// file lglib.c line 2199
static signed int lglws(signed int ch);
// lglwtrapi
// file lglib.c line 1506
void lglwtrapi(struct LGL *lgl, struct _IO_FILE *apitrace);
// lglxorhascls
// file lglib.c line 12718
static signed int lglxorhascls(struct LGL *lgl);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// msg
// file ilingeling.c line 133
static void msg(struct Worker *w, signed int level, const char *fmt, ...);
// msglock
// file ilingeling.c line 123
static void msglock(void *voidptr);
// msgunlock
// file ilingeling.c line 128
static void msgunlock(void *voidptr);
// next
// file ilingeling.c line 464
static signed int next(void);
// parse
// file ilingeling.c line 476
static void parse(void);
// pclose
// file /usr/include/stdio.h line 878
extern signed int pclose(struct _IO_FILE *);
// perr
// file ilingeling.c line 454
static void perr(const char *fmt, ...);
// popen
// file /usr/include/stdio.h line 872
extern struct _IO_FILE * popen(const char *, const char *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// progress
// file ilingeling.c line 196
static void progress(signed int pmille, signed int total, signed int max, double avg, signed int nl);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$2 *, const union anonymous$3 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$2 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$2 *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// raise
// file /usr/include/signal.h line 139
extern signed int raise(signed int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reset
// file ilingeling.c line 436
static void reset(void);
// resetsighandlers
// file ilingeling.c line 724
static void resetsighandlers(void);
// sat
// file ilingeling.c line 263
static signed int sat(struct Worker *w);
// setsighandlers
// file ilingeling.c line 751
static void setsighandlers(void);
// sig_abrt_handler$object
// 
void sig_abrt_handler$object(signed int);
// sig_int_handler$object
// 
void sig_int_handler$object(signed int);
// sig_segv_handler$object
// 
void sig_segv_handler$object(signed int);
// sig_term_handler$object
// 
void sig_term_handler$object(signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// start
// file ilingeling.c line 587
static void start(void);
// stats
// file ilingeling.c line 627
static void stats(void);
// statsps
// file ilingeling.c line 608
static void statsps(struct _IO_FILE *file, const char *name, signed long long int stats, double time);
// stop
// file ilingeling.c line 595
static void stop(void);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// term
// file ilingeling.c line 183
static signed int term(void *voidptr);
// tolower
// file /usr/include/ctype.h line 215
static inline signed int tolower(signed int __c);
// toupper
// file /usr/include/ctype.h line 221
static inline signed int toupper(signed int __c);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 36
static inline signed int vprintf(const char * restrict __fmt, void **__arg);
// warn
// file ilingeling.c line 157
static void warn(const char *fmt, ...);
// work
// file ilingeling.c line 350
static void * work(void *voidptr);

struct anonymous$93
{
  // fun
  signed int * (*fun)(void *);
  // state
  void *state;
};

struct anonymous$89
{
  // fun
  signed int (*fun)(void *);
  // state
  void *state;
  // done
  signed int done;
};

struct anonymous$56
{
  // cls
  signed int *cls;
  // origlhs
  signed int origlhs;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$2
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous$1
{
  // lgl
  struct LGL *lgl;
  // count
  signed int count;
  // bcount
  signed int bcount;
  // decs
  signed long int decs;
  // confs
  signed long int confs;
  // props
  signed long int props;
  // lock
  union anonymous$2 lock;
};

struct anonymous$96
{
  // lock
  void (*lock)(void *);
  // unlock
  void (*unlock)(void *);
  // state
  void *state;
};

struct anonymous$91
{
  // fun
  void (*fun)(void *, signed int **, signed int **);
  // state
  void *state;
};

struct anonymous$90
{
  // fun
  void (*fun)(void *, signed int);
  // state
  void *state;
};

struct anonymous$94
{
  // fun
  void (*fun)(void *, signed int, signed int);
  // state
  void *state;
};

struct anonymous$76
{
  // all
  double all;
  // basic
  double basic;
};

struct anonymous$63
{
  // all
  signed int all;
  // and
  signed int and;
  // xor
  signed int xor;
  // ite
  signed int ite;
};

struct anonymous$98
{
  // all
  signed int all;
  // and
  signed int and;
  // xor
  signed int xor;
  // ite
  signed int ite;
  // org
  signed int org;
};

struct anonymous$83
{
  // basic
  signed int basic;
};

struct anonymous$15
{
  // bin
  signed int bin;
  // trn
  signed int trn;
  // lrg
  signed int lrg;
};

struct anonymous$68
{
  // bin
  signed int bin;
  // trn
  signed int trn;
  // lrg
  signed int lrg;
  // red
  signed int red;
};

struct anonymous$6
{
  // clauses
  signed int clauses;
};

struct anonymous$30
{
  // clauses
  signed int clauses;
  // added
  signed long int added;
  // reduced
  signed long int reduced;
  // resolved
  signed long int resolved;
  // forcing
  signed long int forcing;
  // conflicts
  signed long int conflicts;
  // saved
  signed long int saved;
};

struct anonymous$16
{
  // cnt
  signed int cnt;
  // trn
  signed int trn;
  // lrg
  signed int lrg;
  // sub
  signed int sub;
};

struct anonymous$57
{
  // cond
  signed int cond;
  // pos
  signed int pos;
  // neg
  signed int neg;
};

struct anonymous$18
{
  // count
  signed int count;
  // bin
  signed int bin;
  // trn
  signed int trn;
  // steps
  signed long int steps;
};

struct anonymous$19
{
  // count
  signed int count;
  // clauses
  signed int clauses;
  // lits
  signed int lits;
  // pure
  signed int pure;
  // res
  signed long int res;
  // steps
  signed long int steps;
};

struct anonymous$37
{
  // count
  signed int count;
  // eliminated
  signed int eliminated;
  // ate
  signed int ate;
  // abce
  signed int abce;
  // failed
  signed int failed;
  // lifted
  signed int lifted;
  // steps
  signed long int steps;
  // probed
  signed long int probed;
};

struct anonymous$70
{
  // elm
  signed int elm;
  // tried
  signed int tried;
  // failed
  signed int failed;
};

struct anonymous$26
{
  // count
  signed int count;
  // elmd
  signed int elmd;
  // large
  signed int large;
  // sub
  signed int sub;
  // str
  signed int str;
  // blkd
  signed int blkd;
  // small
  struct anonymous$70 small;
  // resolutions
  signed long int resolutions;
  // copies
  signed long int copies;
  // subchks
  signed long int subchks;
  // strchks
  signed long int strchks;
  // ipos
  signed long int ipos;
  // steps
  signed long int steps;
};

struct anonymous$64
{
  // all
  signed long int all;
  // and
  signed long int and;
  // xor
  signed long int xor;
  // ite
  signed long int ite;
};

struct anonymous$20
{
  // count
  signed int count;
  // eq
  signed int eq;
  // units
  signed int units;
  // esteps
  signed long int esteps;
  // csteps
  signed long int csteps;
  // matched
  struct anonymous$63 matched;
  // simplified
  struct anonymous$63 simplified;
  // extracted
  struct anonymous$64 extracted;
};

struct anonymous$22
{
  // count
  signed int count;
  // eqs
  signed int eqs;
  // units
  signed int units;
  // impls
  signed int impls;
  // probed0
  signed long int probed0;
  // probed1
  signed long int probed1;
};

struct anonymous$38
{
  // count
  signed int count;
  // failed
  signed int failed;
  // lifted
  signed int lifted;
  // decisions
  signed long int decisions;
  // steps
  signed long int steps;
};

struct anonymous$65
{
  // count
  signed int count;
  // failed
  signed int failed;
  // lifted
  signed int lifted;
  // probed
  signed long int probed;
  // steps
  signed long int steps;
};

struct anonymous$72
{
  // max
  signed int max;
  // sum
  signed long int sum;
};

struct anonymous$73
{
  // extr
  signed long int extr;
  // elim
  signed long int elim;
};

struct anonymous$36
{
  // count
  signed int count;
  // gcs
  signed int gcs;
  // units
  signed int units;
  // equivs
  signed int equivs;
  // trneqs
  signed int trneqs;
  // arity
  struct anonymous$72 arity;
  // steps
  struct anonymous$73 steps;
  // extracted
  signed long int extracted;
};

struct anonymous$33
{
  // count
  signed int count;
  // plimhit
  signed int plimhit;
  // ilimhit
  signed int ilimhit;
  // climhit
  signed int climhit;
};

struct anonymous$23
{
  // count
  signed int count;
  // red
  signed int red;
  // failed
  signed int failed;
  // lits
  signed long int lits;
  // bins
  signed long int bins;
  // steps
  signed long int steps;
};

struct anonymous$8
{
  // count
  signed int count;
  // reset
  signed int reset;
  // geom
  signed int geom;
  // arith
  signed int arith;
  // arith2
  signed int arith2;
};

struct anonymous$66
{
  // trds
  signed int trds;
  // failed
  signed int failed;
  // sccs
  signed int sccs;
  // sumsccsizes
  signed long int sumsccsizes;
};

struct anonymous$67
{
  // lits
  signed int lits;
  // bin
  signed int bin;
  // trn
  signed int trn;
  // lrg
  signed int lrg;
};

struct anonymous$69
{
  // trn
  signed int trn;
  // lrg
  signed int lrg;
  // red
  signed int red;
};

struct anonymous$25
{
  // count
  signed int count;
  // rounds
  signed int rounds;
  // stamp
  struct anonymous$66 stamp;
  // failed
  struct anonymous$67 failed;
  // tauts
  struct anonymous$68 tauts;
  // units
  struct anonymous$15 units;
  // hbrs
  struct anonymous$69 hbrs;
  // str
  struct anonymous$69 str;
  // steps
  signed long int steps;
};

struct anonymous$4
{
  // count
  signed int count;
  // sum
  signed long int sum;
};

struct anonymous$7
{
  // count
  signed int count;
  // skipped
  signed int skipped;
  // kept
  struct anonymous$4 kept;
};

struct anonymous$32
{
  // count
  signed int count;
  // set
  signed long int set;
  // pos
  signed long int pos;
  // neg
  signed long int neg;
};

struct anonymous$34
{
  // count
  signed int count;
  // steps
  signed long int steps;
};

struct anonymous$40
{
  // cur
  signed int cur;
  // max
  signed int max;
  // add
  signed long int add;
};

struct anonymous$17
{
  // current
  signed int current;
  // sum
  signed int sum;
};

struct anonymous$77
{
  // inner
  signed int inner;
  // outer
  signed int outer;
  // extra
  signed int extra;
};

struct anonymous$75
{
  // irr
  signed int irr;
  // red
  signed int red;
};

struct anonymous$59
{
  // max
  signed int max;
  // min
  signed int min;
};

struct anonymous$74
{
  // min
  signed int min;
  // avg
  signed int avg;
  // max
  signed int max;
};

struct anonymous$78
{
  // pen
  signed int pen;
  // esteps
  signed long int esteps;
  // csteps
  signed long int csteps;
};

struct anonymous$80
{
  // pen
  signed int pen;
  // steps
  signed long int steps;
};

struct anonymous$79
{
  // pen
  signed int pen;
  // steps
  signed long int steps;
  // irrprgss
  signed long int irrprgss;
};

struct anonymous$81
{
  // pen
  signed int pen;
  // steps
  struct anonymous$73 steps;
};

struct anonymous$24
{
  // removed
  signed int removed;
  // red
  signed int red;
};

struct anonymous$60
{
  // total
  signed int total;
  // pos
  signed int pos;
  // neg
  signed int neg;
};

struct anonymous$61
{
  // total
  signed int total;
  // unit
  signed int unit;
  // bin
  signed int bin;
  // trn
  signed int trn;
  // lrg
  signed int lrg;
};

struct anonymous$97
{
  // units
  signed int units;
  // eq
  signed int eq;
  // all
  signed int all;
  // and
  signed int and;
  // xor
  signed int xor;
  // ite
  signed int ite;
  // org
  signed int org;
};

struct anonymous$62
{
  // val
  struct anonymous$74 val;
  // var
  struct anonymous$74 var;
};

struct anonymous$11
{
  // vars
  signed int vars;
  // lits
  struct anonymous$60 lits;
  // clauses
  struct anonymous$61 clauses;
  // cog
  struct anonymous$62 cog;
};

struct anonymous$39
{
  // bin
  signed long int bin;
  // trn
  signed long int trn;
};

struct anonymous$82
{
  // confs
  signed long int confs;
  // wasmaxdelta
  signed int wasmaxdelta;
  // maxdelta
  signed int maxdelta;
  // luby
  signed int luby;
  // inout
  signed int inout;
};

struct anonymous$5
{
  // count
  signed long int count;
  // mincut
  struct anonymous$59 mincut;
};

struct anonymous$88
{
  // fixed
  signed long int fixed;
};

struct anonymous$85
{
  // irr
  signed long int irr;
  // prgss
  signed long int prgss;
  // confs
  signed long int confs;
  // cinc
  signed long int cinc;
  // pen
  signed int pen;
};

struct anonymous$29
{
  // learned
  signed long int learned;
  // glue
  signed long int glue;
  // nonmaxglue
  signed long int nonmaxglue;
  // maxglue
  signed long int maxglue;
  // scglue
  signed long int scglue;
};

struct anonymous$31
{
  // sum
  signed long int sum;
  // count
  signed int count;
};

struct anonymous$35
{
  // new
  signed long int new;
  // del
  signed long int del;
  // merged
  signed long int merged;
  // col
  signed long int col;
  // gcs
  signed long int gcs;
  // deprior
  struct anonymous$31 deprior;
  // max
  signed int max;
};

struct anonymous$28
{
  // nonmin
  signed long int nonmin;
  // learned
  signed long int learned;
};

struct anonymous$86
{
  // pshwchs
  signed long int pshwchs;
  // prgss
  signed long int prgss;
};

struct anonymous$10
{
  // sat
  signed long int sat;
  // mosat
  signed long int mosat;
  // simp
  signed long int simp;
  // deref
  signed long int deref;
  // fixed
  signed long int fixed;
  // freeze
  signed long int freeze;
  // melt
  signed long int melt;
  // add
  signed long int add;
  // assume
  signed long int assume;
  // cassume
  signed long int cassume;
  // failed
  signed long int failed;
  // repr
  signed long int repr;
};

struct anonymous$12
{
  // search
  signed long int search;
  // hits
  signed long int hits;
};

struct anonymous$13
{
  // search
  signed long int search;
  // simp
  signed long int simp;
  // lkhd
  signed long int lkhd;
};

struct anonymous$87
{
  // steps
  signed long int steps;
};

struct anonymous$84
{
  // steps
  signed long int steps;
  // pen
  struct anonymous$83 pen;
};

struct anonymous$95
{
  // lock
  struct anonymous$93 lock;
  // unlock
  struct anonymous$94 unlock;
};

struct anonymous$92
{
  // produce
  struct anonymous$90 produce;
  // consumed
  struct anonymous$90 consumed;
  // consume
  struct anonymous$91 consume;
};

struct anonymous$21
{
  // basic
  struct anonymous$65 basic;
};

struct anonymous$9
{
  // clauses
  struct anonymous$40 clauses;
  // lits
  struct anonymous$40 lits;
};

struct anonymous$71
{
  // dyn
  struct anonymous$75 dyn;
};

struct anonymous$27
{
  // sub
  struct anonymous$71 sub;
  // str
  struct anonymous$71 str;
  // driving
  signed int driving;
  // restarting
  signed int restarting;
};

struct Stk
{
  // start
  signed int *start;
  // top
  signed int *top;
  // end
  signed int *end;
};

struct anonymous$99
{
  // bin
  struct Stk bin;
  // trn
  struct Stk trn;
};

struct anonymous$14
{
  // current
  unsigned long int current;
  // max
  unsigned long int max;
};

union anonymous
{
  // elm
  struct Elm *elm;
  // cgr
  struct Cgr *cgr;
  // gauss
  struct Gauss *gauss;
  // cce
  struct CCE *cce;
  // cliff
  struct Cliff *cliff;
};

union anonymous$55
{
  // lits
  signed int lits[2l];
  // $anon0
  struct anonymous$56 $anon0;
  // $anon1
  struct anonymous$57 $anon1;
};

union anonymous$3
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$58
{
  // lit
  signed int lit;
  // sign
  signed int sign;
};

union anonymous$43
{
  // ru_idrss
  signed long int ru_idrss;
  // __ru_idrss_word
  signed long int __ru_idrss_word;
};

union anonymous$48
{
  // ru_inblock
  signed long int ru_inblock;
  // __ru_inblock_word
  signed long int __ru_inblock_word;
};

union anonymous$44
{
  // ru_isrss
  signed long int ru_isrss;
  // __ru_isrss_word
  signed long int __ru_isrss_word;
};

union anonymous$42
{
  // ru_ixrss
  signed long int ru_ixrss;
  // __ru_ixrss_word
  signed long int __ru_ixrss_word;
};

union anonymous$46
{
  // ru_majflt
  signed long int ru_majflt;
  // __ru_majflt_word
  signed long int __ru_majflt_word;
};

union anonymous$41
{
  // ru_maxrss
  signed long int ru_maxrss;
  // __ru_maxrss_word
  signed long int __ru_maxrss_word;
};

union anonymous$45
{
  // ru_minflt
  signed long int ru_minflt;
  // __ru_minflt_word
  signed long int __ru_minflt_word;
};

union anonymous$51
{
  // ru_msgrcv
  signed long int ru_msgrcv;
  // __ru_msgrcv_word
  signed long int __ru_msgrcv_word;
};

union anonymous$50
{
  // ru_msgsnd
  signed long int ru_msgsnd;
  // __ru_msgsnd_word
  signed long int __ru_msgsnd_word;
};

union anonymous$54
{
  // ru_nivcsw
  signed long int ru_nivcsw;
  // __ru_nivcsw_word
  signed long int __ru_nivcsw_word;
};

union anonymous$52
{
  // ru_nsignals
  signed long int ru_nsignals;
  // __ru_nsignals_word
  signed long int __ru_nsignals_word;
};

union anonymous$47
{
  // ru_nswap
  signed long int ru_nswap;
  // __ru_nswap_word
  signed long int __ru_nswap_word;
};

union anonymous$53
{
  // ru_nvcsw
  signed long int ru_nvcsw;
  // __ru_nvcsw_word
  signed long int __ru_nvcsw_word;
};

union anonymous$49
{
  // ru_oublock
  signed long int ru_oublock;
  // __ru_oublock_word
  signed long int __ru_oublock_word;
};

union anonymous$0
{
  // lcaseen
  struct Stk lcaseen;
  // sortstk
  struct Stk sortstk;
  // resolvent
  struct Stk resolvent;
};

struct ASL
{
  // act
  signed int act;
  // size
  signed int size;
  // lidx
  signed int lidx;
};

struct AVar
{
  // type
  unsigned int type : 4;
  // equiv
  unsigned int equiv : 1;
  // lcamark
  unsigned int lcamark : 4;
  // phase
  signed int phase : 2;
  // bias
  signed int bias : 2;
  // fase
  signed int fase : 2;
  // poisoned
  unsigned int poisoned : 1;
  // assumed
  unsigned int assumed : 2;
  // failed
  unsigned int failed : 2;
  // gate
  unsigned int gate : 1;
  // donotelm
  unsigned int donotelm : 1;
  // donotblk
  unsigned int donotblk : 1;
  // donotcgrcls
  unsigned int donotcgrcls : 1;
  // donotlft
  unsigned int donotlft : 1;
  // donoternres
  unsigned int donoternres : 1;
  // donotbasicprobe
  unsigned int donotbasicprobe : 1;
  // donotcce
  unsigned int donotcce : 1;
  // mark
  signed int mark;
  // trail
  signed int trail;
};

struct CCE
{
  // cla
  struct Stk cla;
  // extend
  struct Stk extend;
  // rem
  signed int *rem;
};

struct Cbs
{
  // term
  struct anonymous$89 term;
  // units
  struct anonymous$92 units;
  // eqs
  struct anonymous$95 eqs;
  // msglock
  struct anonymous$96 msglock;
  // getime
  double (*getime)(void);
  // onabort
  void (*onabort)(void *);
  // abortstate
  void *abortstate;
};

struct Cgr
{
  // extracted
  struct anonymous$97 extracted;
  // simplified
  struct anonymous$98 simplified;
  // matched
  struct anonymous$98 matched;
  // goccs
  struct Stk *goccs;
  // units
  struct Stk units;
  // gates
  struct Gat *gates;
  // szgates
  signed int szgates;
};

struct Cliff
{
  // lift
  struct Stk lift;
  // lits
  struct Stk lits;
};

struct Conf
{
  // lit
  signed int lit;
  // rsn
  signed int rsn[2l];
};

struct Ctk
{
  // start
  struct Ctr *start;
  // top
  struct Ctr *top;
  // end
  struct Ctr *end;
};

struct Ctr
{
  // decision
  signed int decision : 31;
  // used
  unsigned int used : 1;
};

struct DFL
{
  // discovered
  signed int discovered;
  // finished
  signed int finished;
  // $anon0
  union anonymous$58 $anon0;
};

struct DFOPF
{
  // observed
  signed int observed;
  // pushed
  signed int pushed;
  // flag
  signed int flag;
};

struct DFPR
{
  // discovered
  signed int discovered;
  // finished
  signed int finished;
  // parent
  signed int parent;
  // root
  signed int root;
};

struct HTS
{
  // offset
  signed int offset;
  // count
  signed int count;
};

struct DVar
{
  // hts
  struct HTS hts[2l];
};

struct Dis
{
  // red
  struct anonymous$99 red;
  // irr
  struct anonymous$99 irr;
};

struct EVar
{
  // occ
  signed int occ[2l];
  // pos
  signed int pos;
  // score
  signed int score;
};

struct Elm
{
  // pivot
  signed int pivot;
  // negcls
  signed int negcls;
  // necls
  signed int necls;
  // neglidx
  signed int neglidx;
  // lits
  struct Stk lits;
  // next
  struct Stk next;
  // clv
  struct Stk clv;
  // csigs
  struct Stk csigs;
  // lsigs
  struct Stk lsigs;
  // sizes
  struct Stk sizes;
  // occs
  struct Stk occs;
  // noccs
  struct Stk noccs;
  // mark
  struct Stk mark;
  // m2i
  struct Stk m2i;
};

struct Ext
{
  // equiv
  unsigned int equiv : 1;
  // melted
  unsigned int melted : 1;
  // blocking
  unsigned int blocking : 2;
  // eliminated
  unsigned int eliminated : 1;
  // tmpfrozen
  unsigned int tmpfrozen : 1;
  // imported
  unsigned int imported : 1;
  // assumed
  unsigned int assumed : 2;
  // failed
  unsigned int failed : 2;
  // val
  signed int val : 2;
  // oldval
  signed int oldval : 2;
  // repr
  signed int repr;
  // frozen
  signed int frozen;
  // cog
  struct anonymous$4 cog;
};

struct FltStr
{
  // current
  signed int current;
  // str
  char str[6l][100l];
};

struct ForceData
{
  // pos
  signed int pos;
  // count
  signed int count;
  // sum
  double sum;
};

struct Gat
{
  // lhs
  signed int lhs;
  // minrhs
  signed int minrhs;
  // tag
  unsigned int tag : 2;
  // mark
  unsigned int mark : 1;
  // size
  signed int size : 29;
  // $anon0
  union anonymous$55 $anon0;
};

struct Gauss
{
  // xors
  struct Stk xors;
  // order
  struct Stk order;
  // occs
  struct Stk *occs;
  // eliminated
  signed char *eliminated;
  // garbage
  signed int garbage;
  // next
  signed int next;
};

struct ITEC
{
  // other
  signed int other;
  // other2
  signed int other2;
};

struct RNG
{
  // z
  unsigned int z;
  // w
  unsigned int w;
};

struct Queue
{
  // bottom
  struct Qln *bottom;
  // top
  struct Qln *top;
  // unassigned
  struct Qln *unassigned;
  // merged
  struct Qln *merged;
  // free
  struct Qln *free;
  // nodes
  struct Qnd *nodes;
  // nmerged
  signed int nmerged;
  // nlines
  signed int nlines;
};

struct LGL
{
  // state
  enum State state;
  // probing
  signed int probing;
  // flipping
  signed int flipping;
  // notflipped
  signed int notflipped;
  // tid
  signed int tid;
  // tids
  signed int tids;
  // bias
  signed int bias;
  // phaseneg
  signed int phaseneg;
  // nvars
  signed int nvars;
  // szvars
  signed int szvars;
  // maxext
  signed int maxext;
  // szext
  signed int szext;
  // changed
  signed int changed;
  // mt
  signed int mt;
  // szdrail
  signed int szdrail;
  // bnext
  signed int bnext;
  // next
  signed int next;
  // next2
  signed int next2;
  // flushed
  signed int flushed;
  // level
  signed int level;
  // alevel
  signed int alevel;
  // unassigned
  signed int unassigned;
  // lrgluereasons
  signed int lrgluereasons;
  // failed
  signed int failed;
  // assumed
  signed int assumed;
  // cassumed
  signed int cassumed;
  // ncassumed
  signed int ncassumed;
  // cgrclosing
  char cgrclosing;
  // searching
  char searching;
  // simp
  char simp;
  // allphaseset
  char allphaseset;
  // flushphases
  char flushphases;
  // forked
  char forked;
  // bruteforked
  char bruteforked;
  // qscheduling
  char qscheduling;
  // decomposing
  char decomposing;
  // lifting
  char lifting;
  // cceing
  char cceing;
  // gaussing
  char gaussing;
  // cliffing
  char cliffing;
  // unhiding
  char unhiding;
  // basicprobing
  char basicprobing;
  // eliminating
  char eliminating;
  // donotsched
  char donotsched;
  // blocking
  char blocking;
  // ternresing
  char ternresing;
  // lkhd
  char lkhd;
  // blkall
  char blkall;
  // blkrem
  char blkrem;
  // elmall
  char elmall;
  // elmrem
  char elmrem;
  // cceall
  char cceall;
  // ccerem
  char ccerem;
  // frozen
  char frozen;
  // dense
  char dense;
  // notfullyconnected
  char notfullyconnected;
  // forcegc
  char forcegc;
  // allowforce
  char allowforce;
  // flips
  unsigned long long int flips;
  // conf
  struct Conf conf;
  // rng
  struct RNG rng;
  // mem
  struct Mem *mem;
  // opts
  struct Opts *opts;
  // stats
  struct Stats *stats;
  // times
  struct Times *times;
  // timers
  struct Tmrs *timers;
  // limits
  struct Limits *limits;
  // ext
  struct Ext *ext;
  // i2e
  signed int *i2e;
  // doms
  signed int *doms;
  // dvars
  struct DVar *dvars;
  // avars
  struct AVar *avars;
  // vals
  signed char *vals;
  // jwh
  signed long int *jwh;
  // drail
  struct TD *drail;
  // queue
  struct Queue queue;
  // red
  struct Stk *red;
  // wchs
  struct Wchs *wchs;
  // control
  struct Ctk control;
  // clause
  struct Stk clause;
  // eclause
  struct Stk eclause;
  // extend
  struct Stk extend;
  // irr
  struct Stk irr;
  // trail
  struct Stk trail;
  // frames
  struct Stk frames;
  // eassume
  struct Stk eassume;
  // assume
  struct Stk assume;
  // cassume
  struct Stk cassume;
  // fassume
  struct Stk fassume;
  // $anon0
  union anonymous $anon0;
  // $anon1
  union anonymous$0 $anon1;
  // poisoned
  struct Stk poisoned;
  // seen
  struct Stk seen;
  // esched
  struct Stk esched;
  // evars
  struct EVar *evars;
  // dis
  struct Dis *dis;
  // wrk
  struct Wrk *wrk;
  // repr
  signed int *repr;
  // closeapitrace
  char closeapitrace;
  // out
  struct _IO_FILE *out;
  // apitrace
  struct _IO_FILE *apitrace;
  // prefix
  char *prefix;
  // cbs
  struct Cbs *cbs;
  // clone
  struct LGL *clone;
  // fltstr
  struct FltStr *fltstr;
};

struct Lim
{
  // confs
  signed long int confs;
  // decs
  signed long int decs;
};

struct Limits
{
  // flipint
  signed int flipint;
  // lkhdpen
  signed int lkhdpen;
  // randec
  signed long int randec;
  // reduce
  struct anonymous$77 reduce;
  // cgr
  struct anonymous$78 cgr;
  // elm
  struct anonymous$79 elm;
  // blk
  struct anonymous$79 blk;
  // cliff
  struct anonymous$79 cliff;
  // trd
  struct anonymous$80 trd;
  // unhd
  struct anonymous$80 unhd;
  // trnr
  struct anonymous$80 trnr;
  // lft
  struct anonymous$80 lft;
  // cce
  struct anonymous$80 cce;
  // gauss
  struct anonymous$81 gauss;
  // restart
  struct anonymous$82 restart;
  // prb
  struct anonymous$84 prb;
  // simp
  struct anonymous$85 simp;
  // dfg
  struct anonymous$86 dfg;
  // term
  struct anonymous$87 term;
  // sync
  struct anonymous$87 sync;
  // gc
  struct anonymous$88 gc;
};

struct Mem
{
  // state
  void *state;
  // alloc
  void * (*alloc)(void *, unsigned long int);
  // realloc
  void * (*realloc)(void *, void *, unsigned long int, unsigned long int);
  // dealloc
  void (*dealloc)(void *, void *, unsigned long int);
};

struct Opt
{
  // shrt
  char shrt;
  // lng
  const char *lng;
  // descrp
  const char *descrp;
  // val
  signed int val;
  // min
  signed int min;
  // max
  signed int max;
};

struct Opts
{
  // beforefirst
  struct Opt beforefirst;
  // abstime
  struct Opt abstime;
  // acts
  struct Opt acts;
  // actavgmax
  struct Opt actavgmax;
  // actstdmin
  struct Opt actstdmin;
  // actstdmax
  struct Opt actstdmax;
  // agile
  struct Opt agile;
  // bias
  struct Opt bias;
  // block
  struct Opt block;
  // blkrtc
  struct Opt blkrtc;
  // blkclslim
  struct Opt blkclslim;
  // blkocclim
  struct Opt blkocclim;
  // blkmaxeff
  struct Opt blkmaxeff;
  // blkmineff
  struct Opt blkmineff;
  // blkreleff
  struct Opt blkreleff;
  // card
  struct Opt card;
  // cce
  struct Opt cce;
  // ccemaxeff
  struct Opt ccemaxeff;
  // ccemineff
  struct Opt ccemineff;
  // ccereleff
  struct Opt ccereleff;
  // check
  struct Opt check;
  // cgrclsr
  struct Opt cgrclsr;
  // cgrmaxority
  struct Opt cgrmaxority;
  // cgrmaxeff
  struct Opt cgrmaxeff;
  // cgrmineff
  struct Opt cgrmineff;
  // cgreleff
  struct Opt cgreleff;
  // cgrexteq
  struct Opt cgrexteq;
  // cgrextand
  struct Opt cgrextand;
  // cgrextunits
  struct Opt cgrextunits;
  // cgrextite
  struct Opt cgrextite;
  // cgrextxor
  struct Opt cgrextxor;
  // cliff
  struct Opt cliff;
  // cliffreleff
  struct Opt cliffreleff;
  // cliffmineff
  struct Opt cliffmineff;
  // cliffmaxeff
  struct Opt cliffmaxeff;
  // compact
  struct Opt compact;
  // decompose
  struct Opt decompose;
  // defragint
  struct Opt defragint;
  // defragfree
  struct Opt defragfree;
  // elim
  struct Opt elim;
  // elmrtc
  struct Opt elmrtc;
  // elmblk
  struct Opt elmblk;
  // elmclslim
  struct Opt elmclslim;
  // elmocclim
  struct Opt elmocclim;
  // elmaxeff
  struct Opt elmaxeff;
  // elmineff
  struct Opt elmineff;
  // elmreleff
  struct Opt elmreleff;
  // sleeponabort
  struct Opt sleeponabort;
  // exitonabort
  struct Opt exitonabort;
  // flipping
  struct Opt flipping;
  // flipint
  struct Opt flipint;
  // flipdur
  struct Opt flipdur;
  // fliptop
  struct Opt fliptop;
  // force
  struct Opt force;
  // gauss
  struct Opt gauss;
  // gaussextrall
  struct Opt gaussextrall;
  // gaussmaxor
  struct Opt gaussmaxor;
  // gaussexptrn
  struct Opt gaussexptrn;
  // gaussmaxeff
  struct Opt gaussmaxeff;
  // gaussmineff
  struct Opt gaussmineff;
  // gaussreleff
  struct Opt gaussreleff;
  // gluescale
  struct Opt gluescale;
  // gluekeep
  struct Opt gluekeep;
  // inprocessing
  struct Opt inprocessing;
  // cintinc
  struct Opt cintinc;
  // irrlim
  struct Opt irrlim;
  // lift
  struct Opt lift;
  // lftmaxeff
  struct Opt lftmaxeff;
  // lftmineff
  struct Opt lftmineff;
  // lftreleff
  struct Opt lftreleff;
  // lhbr
  struct Opt lhbr;
  // lkhd
  struct Opt lkhd;
  // clim
  struct Opt clim;
  // mocint
  struct Opt mocint;
  // move
  struct Opt move;
  // log
  struct Opt log;
  // otfs
  struct Opt otfs;
  // phase
  struct Opt phase;
  // phaseneginit
  struct Opt phaseneginit;
  // plain
  struct Opt plain;
  // probe
  struct Opt probe;
  // prbasicmaxeff
  struct Opt prbasicmaxeff;
  // prbasicmineff
  struct Opt prbasicmineff;
  // prbasicreleff
  struct Opt prbasicreleff;
  // prbasic
  struct Opt prbasic;
  // prbasicroundlim
  struct Opt prbasicroundlim;
  // queuemergelim
  struct Opt queuemergelim;
  // queuefactor
  struct Opt queuefactor;
  // queueinc
  struct Opt queueinc;
  // rmincpen
  struct Opt rmincpen;
  // seed
  struct Opt seed;
  // smallirr
  struct Opt smallirr;
  // smallve
  struct Opt smallve;
  // smallvevars
  struct Opt smallvevars;
  // randec
  struct Opt randec;
  // randecint
  struct Opt randecint;
  // redfixed
  struct Opt redfixed;
  // redlbound
  struct Opt redlbound;
  // redlexpfac
  struct Opt redlexpfac;
  // redldoutfac
  struct Opt redldoutfac;
  // redloutinc
  struct Opt redloutinc;
  // redlinit
  struct Opt redlinit;
  // redlinc
  struct Opt redlinc;
  // redinoutinc
  struct Opt redinoutinc;
  // redlmininc
  struct Opt redlmininc;
  // redlmaxinc
  struct Opt redlmaxinc;
  // redlminrel
  struct Opt redlminrel;
  // redlmaxrel
  struct Opt redlmaxrel;
  // redlminabs
  struct Opt redlminabs;
  // redlmaxabs
  struct Opt redlmaxabs;
  // reduce
  struct Opt reduce;
  // restart
  struct Opt restart;
  // restartint
  struct Opt restartint;
  // rstinoutinc
  struct Opt rstinoutinc;
  // simplify
  struct Opt simplify;
  // simpdelay
  struct Opt simpdelay;
  // simpen
  struct Opt simpen;
  // sizepen
  struct Opt sizepen;
  // sizemaxpen
  struct Opt sizemaxpen;
  // sortlits
  struct Opt sortlits;
  // syncint
  struct Opt syncint;
  // termint
  struct Opt termint;
  // ternres
  struct Opt ternres;
  // ternresrtc
  struct Opt ternresrtc;
  // trnrmineff
  struct Opt trnrmineff;
  // trnrmaxeff
  struct Opt trnrmaxeff;
  // trnreleff
  struct Opt trnreleff;
  // transred
  struct Opt transred;
  // trdmineff
  struct Opt trdmineff;
  // trdmaxeff
  struct Opt trdmaxeff;
  // trdreleff
  struct Opt trdreleff;
  // unhide
  struct Opt unhide;
  // unhdextstamp
  struct Opt unhdextstamp;
  // unhdhbr
  struct Opt unhdhbr;
  // unhdmaxeff
  struct Opt unhdmaxeff;
  // unhdmineff
  struct Opt unhdmineff;
  // unhdreleff
  struct Opt unhdreleff;
  // unhdlnpr
  struct Opt unhdlnpr;
  // unhdroundlim
  struct Opt unhdroundlim;
  // verbose
  struct Opt verbose;
  // witness
  struct Opt witness;
  // afterlast
  struct Opt afterlast;
};

struct Qln
{
  // prior
  signed int prior;
  // first
  signed int first;
  // last
  signed int last;
  // unassigned
  signed int unassigned;
  // up
  struct Qln *up;
  // down
  struct Qln *down;
  // repr
  struct Qln *repr;
};

struct Qnd
{
  // prev
  signed int prev;
  // next
  signed int next;
  // line
  struct Qln *line;
};

struct Stats
{
  // defrags
  signed int defrags;
  // iterations
  signed int iterations;
  // acts
  signed int acts;
  // reported
  signed int reported;
  // gcs
  signed int gcs;
  // decomps
  signed int decomps;
  // force
  struct anonymous$5 force;
  // rescored
  struct anonymous$6 rescored;
  // restarts
  struct anonymous$7 restarts;
  // reduced
  struct anonymous$8 reduced;
  // prgss
  signed long int prgss;
  // irrprgss
  signed long int irrprgss;
  // enlwchs
  signed long int enlwchs;
  // pshwchs
  signed long int pshwchs;
  // height
  signed long int height;
  // dense
  signed long int dense;
  // sparse
  signed long int sparse;
  // confs
  signed long int confs;
  // decisions
  signed long int decisions;
  // randecs
  signed long int randecs;
  // flipped
  signed long int flipped;
  // fliphases
  signed long int fliphases;
  // uips
  signed long int uips;
  // irr
  struct anonymous$9 irr;
  // calls
  struct anonymous$10 calls;
  // features
  struct anonymous$11 features;
  // poison
  struct anonymous$12 poison;
  // props
  struct anonymous$13 props;
  // visits
  struct anonymous$13 visits;
  // bytes
  struct anonymous$14 bytes;
  // red
  struct anonymous$15 red;
  // hbr
  struct anonymous$16 hbr;
  // fixed
  struct anonymous$17 fixed;
  // equiv
  struct anonymous$17 equiv;
  // trnr
  struct anonymous$18 trnr;
  // blk
  struct anonymous$19 blk;
  // cgr
  struct anonymous$20 cgr;
  // prb
  struct anonymous$21 prb;
  // lift
  struct anonymous$22 lift;
  // trd
  struct anonymous$23 trd;
  // bindup
  struct anonymous$24 bindup;
  // unhd
  struct anonymous$25 unhd;
  // elm
  struct anonymous$26 elm;
  // otfs
  struct anonymous$27 otfs;
  // lits
  struct anonymous$28 lits;
  // clauses
  struct anonymous$29 clauses;
  // lir
  struct anonymous$30 lir[16l];
  // glues
  struct anonymous$31 glues;
  // phase
  struct anonymous$32 phase;
  // simp
  struct anonymous$33 simp;
  // luby
  struct anonymous$34 luby;
  // inout
  struct anonymous$34 inout;
  // queue
  struct anonymous$35 queue;
  // gauss
  struct anonymous$36 gauss;
  // cce
  struct anonymous$37 cce;
  // cliff
  struct anonymous$38 cliff;
  // moved
  struct anonymous$39 moved;
};

struct TD
{
  // level
  signed int level : 30;
  // lrglue
  unsigned int lrglue : 1;
  // rsn
  signed int rsn[2l];
};

struct Times
{
  // all
  double all;
  // dcp
  double dcp;
  // elm
  double elm;
  // trd
  double trd;
  // gc
  double gc;
  // dfg
  double dfg;
  // red
  double red;
  // blk
  double blk;
  // ana
  double ana;
  // unhd
  double unhd;
  // dec
  double dec;
  // lkhd
  double lkhd;
  // rsts
  double rsts;
  // lft
  double lft;
  // trn
  double trn;
  // cgr
  double cgr;
  // phs
  double phs;
  // srch
  double srch;
  // prep
  double prep;
  // inpr
  double inpr;
  // bump
  double bump;
  // mcls
  double mcls;
  // gauss
  double gauss;
  // card
  double card;
  // cce
  double cce;
  // cliff
  double cliff;
  // ctw
  double ctw;
  // force
  double force;
  // prb
  struct anonymous$76 prb;
};

struct Tmrs
{
  // phase
  double phase[10l];
  // idx
  signed int idx[10l];
  // nest
  signed int nest;
};

struct Trv
{
  // state
  void *state;
  // trav
  void (*trav)(void *, signed int);
};

struct Wchs
{
  // stk
  struct Stk stk;
  // start
  signed int start[31l];
  // free
  signed int free;
};

struct Work
{
  // wrag
  unsigned int wrag : 2;
  // lit
  signed int lit : 30;
  // other
  signed int other : 30;
  // red
  unsigned int red : 1;
  // removed
  unsigned int removed : 1;
};

struct Worker
{
  // lgl
  struct LGL *lgl;
  // forked
  struct anonymous$1 forked;
  // last
  signed int last;
  // res
  signed int res;
  // thread
  unsigned long int thread;
};

struct Wrk
{
  // queue
  struct Stk queue;
  // count
  signed int count;
  // head
  signed int head;
  // size
  signed int size;
  // posonly
  signed int posonly;
  // fifo
  signed int fifo;
  // pos
  signed int *pos;
};

struct Wtk
{
  // start
  struct Work *start;
  // top
  struct Work *top;
  // end
  struct Work *end;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct rusage
{
  // ru_utime
  struct timeval ru_utime;
  // ru_stime
  struct timeval ru_stime;
  // $anon0
  union anonymous$41 $anon0;
  // $anon1
  union anonymous$42 $anon1;
  // $anon2
  union anonymous$43 $anon2;
  // $anon3
  union anonymous$44 $anon3;
  // $anon4
  union anonymous$45 $anon4;
  // $anon5
  union anonymous$46 $anon5;
  // $anon6
  union anonymous$47 $anon6;
  // $anon7
  union anonymous$48 $anon7;
  // $anon8
  union anonymous$49 $anon8;
  // $anon9
  union anonymous$50 $anon9;
  // $anon10
  union anonymous$51 $anon10;
  // $anon11
  union anonymous$52 $anon11;
  // $anon12
  union anonymous$53 $anon12;
  // $anon13
  union anonymous$54 $anon13;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};


// addassumptions
// file ilingeling.c line 108
static signed int addassumptions;
// allocated
// file ilingeling.c line 17
static unsigned long int allocated;
// assumptions
// file ilingeling.c line 101
static signed int **assumptions;
// bar
// file ilingeling.c line 108
static signed int bar;
// catchedsig
// file ilingeling.c line 718
static signed int catchedsig;
// dofork
// file ilingeling.c line 108
static signed int dofork = 2;
// done
// file ilingeling.c line 114
static signed int done;
// donemutex
// file ilingeling.c line 117
static union anonymous$2 donemutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// environ
// file lglib.c line 1633 function lglchkenv
extern char **environ;
// finished
// file ilingeling.c line 121
static signed int finished;
// finishedmutex
// file ilingeling.c line 119
static union anonymous$2 finishedmutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// histfile
// file ilingeling.c line 18
static struct _IO_FILE *histfile;
// inputfile
// file ilingeling.c line 112
static struct _IO_FILE *inputfile;
// inputname
// file ilingeling.c line 111
static char *inputname;
// lglbasevar2funtab
// file lglib.c line 964
static const unsigned long int lglbasevar2funtab[6l] = { 0xaaaaaaaaaaaaaaaaull, 0xccccccccccccccccull, 0xf0f0f0f0f0f0f0f0ull, 0xff00ff00ff00ff00ull, 0xffff0000ffff0000ull, 0xffffffff00000000ull };
// lglfloorldtab
// file lglib.c line 956
static const char lglfloorldtab[256l] = { (const char)-1, (const char)0, (const char)1, (const char)1, (const char)2, (const char)2, (const char)2, (const char)2, (const char)3, (const char)3, (const char)3, (const char)3, (const char)3, (const char)3, (const char)3, (const char)3, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)5, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)6, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7, (const char)7 };
// lineno
// file ilingeling.c line 110
static signed int lineno = 1;
// lits
// file ilingeling.c line 106
static signed int *lits;
// maxallocated
// file ilingeling.c line 17
static unsigned long int maxallocated;
// msgmutex
// file ilingeling.c line 116
static union anonymous$2 msgmutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// nassumptions
// file ilingeling.c line 98
static signed int nassumptions;
// nclauses
// file ilingeling.c line 103
static signed int nclauses;
// nlits
// file ilingeling.c line 105
static signed int nlits;
// nowitness
// file ilingeling.c line 108
static signed int nowitness;
// nused
// file ilingeling.c line 103
static signed int nused;
// nvars
// file ilingeling.c line 103
static signed int nvars;
// nworkers
// file ilingeling.c line 93
static signed int nworkers;
// plain
// file ilingeling.c line 108
static signed int plain;
// queue
// file ilingeling.c line 98
static signed int queue;
// queuemutex
// file ilingeling.c line 118
static union anonymous$2 queuemutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// redassumptions
// file ilingeling.c line 99
static signed int redassumptions;
// sig_abrt_handler
// file ilingeling.c line 721
static void (*sig_abrt_handler)(signed int);
// sig_int_handler
// file ilingeling.c line 719
static void (*sig_int_handler)(signed int);
// sig_segv_handler
// file ilingeling.c line 720
static void (*sig_segv_handler)(signed int);
// sig_term_handler
// file ilingeling.c line 722
static void (*sig_term_handler)(signed int);
// startime
// file ilingeling.c line 16
static double startime;
// statsfile
// file ilingeling.c line 18
static struct _IO_FILE *statsfile;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// sumassumptions
// file ilingeling.c line 99
static signed int sumassumptions;
// sumtimes
// file ilingeling.c line 100
static double sumtimes;
// szassumptions
// file ilingeling.c line 98
static signed int szassumptions;
// szlits
// file ilingeling.c line 105
static signed int szlits;
// szvars
// file ilingeling.c line 103
static signed int szvars;
// times
// file ilingeling.c line 100
static double *times;
// used
// file ilingeling.c line 103
static signed int *used;
// vals
// file ilingeling.c line 104
static signed char *vals;
// verbose
// file ilingeling.c line 108
static signed int verbose;
// workers
// file ilingeling.c line 92
static struct Worker *workers;

// add
// file ilingeling.c line 471
static void add(signed int lit)
{
  signed int i = 0;
  for( ; !(i >= nworkers); i = i + 1)
    lgladd((workers + (signed long int)i)->lgl, lit);
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1;
}

// atoi$link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi$link1(const char *__nptr$link1)
{
  signed long int return_value_strtol$1$link1;
  return_value_strtol$1$link1=strtol(__nptr$link1, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1$link1;
}

// catchsig
// file ilingeling.c line 737
static void catchsig(signed int sig)
{
  if(catchedsig == 0)
  {
    fputs("s UNKNOWN\n", stdout);
    fflush(stdout);
    catchedsig = 1;
    caughtsigmsg(sig);
    if(!(statsfile == ((struct _IO_FILE *)NULL)))
      stats();

    if(!(histfile == ((struct _IO_FILE *)NULL)))
      hist();

    if(!(histfile == ((struct _IO_FILE *)NULL)) || !(statsfile == ((struct _IO_FILE *)NULL)))
      caughtsigmsg(sig);

  }

  resetsighandlers();
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("LGLNABORT");
  if(return_value_getenv$1 == ((char *)NULL))
    raise(sig);

  else
    exit(1);
}

// caughtsigmsg
// file ilingeling.c line 731
static void caughtsigmsg(signed int sig)
{
  if(!(verbose == 0))
  {
    printf("c\nc CAUGHT SIGNAL %d\nc\n", sig);
    fflush(stdout);
  }

}

// cmpdblptr
// file ilingeling.c line 619
static signed int cmpdblptr(const void *p, const void *q)
{
  double a = *((double *)p);
  double b = *((double *)q);
  if(a < b)
    return -1;

  else
    if(a > b)
      return 1;

    else
      return 0;
}

// currentime
// file ilingeling.c line 167
static double currentime(void)
{
  double res = (double)0;
  struct timeval tv;
  signed int return_value_gettimeofday$1;
  return_value_gettimeofday$1=gettimeofday(&tv, ((struct timezone *)NULL));
  if(return_value_gettimeofday$1 == 0)
  {
    res = 1e-6 * (double)tv.tv_usec;
    res = res + (double)tv.tv_sec;
  }

  return res;
}

// die
// file ilingeling.c line 146
static void die(const char *fmt, ...)
{
  void **ap;
  fputs("*** [ilingeling] ", stderr);
  ap = (void **)&fmt;
  vfprintf(stderr, fmt, ap);
  ap = ((void **)NULL);
  fputc(10, stderr);
  fflush(stderr);
  exit(1);
}

// freeze
// file ilingeling.c line 579
static void freeze(void)
{
  signed int idx;
  signed int i;
  idx = 1;
  for( ; !(idx >= nvars); idx = idx + 1)
    if(used[(signed long int)idx] >= 0)
    {
      i = 0;
      for( ; !(i >= nworkers); i = i + 1)
        lglfreeze((workers + (signed long int)i)->lgl, idx);
    }

}

// getime
// file ilingeling.c line 174
static double getime()
{
  double return_value_currentime$1;
  return_value_currentime$1=currentime();
  return return_value_currentime$1 - startime;
}

// hist
// file ilingeling.c line 710
static void hist(void)
{
  struct _IO_FILE *file = histfile != ((struct _IO_FILE *)NULL) ? histfile : stdout;
  signed int i = 0;
  for( ; !(i >= nassumptions); i = i + 1)
    fprintf(file, "%.3f\n", times[(signed long int)i]);
  fflush(file);
}

// init
// file ilingeling.c line 423
static void init(void)
{
  struct Worker *w;
  do
  {
    unsigned long int BYTES = (unsigned long int)nworkers * sizeof(struct Worker) /*104ul*/ ;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(BYTES);
    workers = (struct Worker *)return_value_malloc$1;
    if(workers == ((struct Worker *)NULL))
    {
      die("out of memory");
      exit(1);
    }

    memset((void *)workers, 0, BYTES);
    do
    {
      allocated = allocated + BYTES;
      if(!(maxallocated >= allocated))
        maxallocated = allocated;

    }
    while((_Bool)0);
  }
  while((_Bool)0);
  w = workers;
  for( ; !(w >= workers + (signed long int)nworkers); w = w + 1l)
  {
    w->last = -1;
    w->lgl=lglinit();
    pthread_mutex_init(&w->forked.lock, ((const union anonymous$3 *)NULL));
    initlgl(w->lgl, w, 1);
  }
  msg(((struct Worker *)NULL), 1, "allocated %d workers", nworkers);
}

// initlgl
// file ilingeling.c line 240
static void initlgl(struct LGL *lgl, struct Worker *w, signed int opts)
{
  lglsetid(lgl, (signed int)(w - workers), nworkers);
  lglsetime(lgl, (double (*)(void))getime);
  lglseterm(lgl, term, (void *)w);
  lglsetmsglock(lgl, msglock, msgunlock, (void *)w);
  if(!(opts == 0))
  {
    signed int return_value_lglhasopt$1;
    return_value_lglhasopt$1=lglhasopt(lgl, "boost");
    if(!(return_value_lglhasopt$1 == 0))
      lglsetopt(lgl, "boost", 0);

    signed int return_value_lglhasopt$2;
    return_value_lglhasopt$2=lglhasopt(lgl, "cgrboost");
    if(!(return_value_lglhasopt$2 == 0))
      lglsetopt(lgl, "cgrboost", 0);

    signed int return_value_lglhasopt$3;
    return_value_lglhasopt$3=lglhasopt(lgl, "restartint");
    if(!(return_value_lglhasopt$3 == 0))
      lglsetopt(lgl, "restartint", 100);

    if(!(verbose == 0))
      lglsetopt(lgl, "verbose", verbose - 1);

    if(!(plain == 0))
      lglsetopt(lgl, "plain", 1);

  }

}

// isnum
// file ilingeling.c line 176
static signed int isnum(const char *str)
{
  const char *p = str;
  const unsigned short int **return_value___ctype_b_loc$1;
  return_value___ctype_b_loc$1=__ctype_b_loc();
  const char *tmp_post$2 = p;
  p = p + 1l;
  const unsigned short int **return_value___ctype_b_loc$3;
  if((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*tmp_post$2]) == 0)
    return 0;

  else
  {
    for( ; !(*p == 0); p = p + 1l)
    {
      return_value___ctype_b_loc$3=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*p]) == 0)
        break;

    }
    return (signed int)!(*p != 0);
  }
}

// justreturn
// file ilingeling.c line 253
static signed int justreturn(struct Worker *w)
{
  signed int res;
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&donemutex);
  if(!(return_value_pthread_mutex_lock$1 == 0))
    warn("worker %d failed to lock 'done' mutex", (signed int)(w - workers));

  res = done;
  signed int return_value_pthread_mutex_unlock$2;
  return_value_pthread_mutex_unlock$2=pthread_mutex_unlock(&donemutex);
  if(!(return_value_pthread_mutex_unlock$2 == 0))
    warn("worker %d failed to unlock 'done' mutex", (signed int)(w - workers));

  return res;
}

// lgl2manyoccs4blk
// file lglib.c line 11134
static signed int lgl2manyoccs4blk(struct LGL *lgl, signed int lit)
{
  struct HTS *return_value_lglhts$1;
  return_value_lglhts$1=lglhts(lgl, lit);
  return (signed int)(return_value_lglhts$1->count > lgl->opts->blkocclim.val);
}

// lgl2manyoccs4elm
// file lglib.c line 11014
static signed int lgl2manyoccs4elm(struct LGL *lgl, signed int lit)
{
  signed int return_value_lglocc$1;
  return_value_lglocc$1=lglocc(lgl, lit);
  return (signed int)(return_value_lglocc$1 > lgl->opts->elmocclim.val);
}

// lglabce
// file lglib.c line 11516
static signed int lglabce(struct LGL *lgl, signed int lit)
{
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  signed int blit;
  signed int tag;
  signed int other;
  signed int cls[4l];
  struct HTS *hts;
  hts=lglhts(lgl, -lit);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  cls[(signed long int)0] = -lit;
  cls[(signed long int)3] = 0;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    lgl->stats->cce.steps = lgl->stats->cce.steps + 1l;
    if(lgl->stats->cce.steps >= lgl->limits->cce.steps)
      return 0;

    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if((REDCS & blit) == 0)
    {
      if(!(tag == LRGCS))
      {
        other = blit >> RMSHFT;
        cls[(signed long int)1] = other;
        if(tag == BINCS)
        {
          cls[(signed long int)2] = 0;
          c = cls;
        }

        else
          if(tag == TRNCS)
          {
            cls[(signed long int)2] = *p;
            c = cls;
          }

          else
            c=lglidx2lits(lgl, OCCS, 0, other);
        signed int return_value_lglabcecls$1;
        return_value_lglabcecls$1=lglabcecls(lgl, lit, c);
        if(return_value_lglabcecls$1 == 0)
          return 0;

      }

    }

  }
  return 1;
}

// lglabcecls
// file lglib.c line 11506
static signed int lglabcecls(struct LGL *lgl, signed int lit, const signed int *c)
{
  signed int other;
  signed int found = 0;
  const signed int *p = c;
  signed int return_value_lglsignedmarked$1;
  do
  {
    other = *p;
    if(other == 0)
      break;

    if(other == -lit)
      found = found + 1;

    else
    {
      return_value_lglsignedmarked$1=lglsignedmarked(lgl, -other);
      if(!(return_value_lglsignedmarked$1 == 0))
        return 1;

    }
    p = p + 1l;
  }
  while((_Bool)1);
  return 0;
}

// lglabort
// file lglib.c line 1171
static void lglabort(struct LGL *lgl)
{
  if(lgl == ((struct LGL *)NULL))
    exit(1);

  if(!(lgl->opts == ((struct Opts *)NULL)))
  {
    if(!(lgl->opts->sleeponabort.val == 0))
    {
      signed int return_value_getpid$1;
      return_value_getpid$1=getpid();
      fprintf(stderr, "liblgl.a: Process %d will sleep for %d seconds  before continuing with 'lglabort' procedure.\n", return_value_getpid$1, lgl->opts->sleeponabort.val);
      sleep((unsigned int)lgl->opts->sleeponabort.val);
    }

  }

  if(!(lgl->cbs == ((struct Cbs *)NULL)))
  {
    if(!(lgl->cbs->onabort == ((void (*)(void *))NULL)))
      lgl->cbs->onabort(lgl->cbs->abortstate);

  }

  if(!(lgl->opts == ((struct Opts *)NULL)))
  {
    if(!(lgl->opts->exitonabort.val == 0))
      exit(1);

  }

  abort();
}

// lgladd
// file lglib.h line 180
void lgladd(struct LGL *lgl, signed int elit)
{
  signed int eidx;
  eidx=abs(elit);
  struct Ext *ext;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lgladd");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "add %d", elit);
    break;
  }
  while(!(lgl->forked == 0))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lgladd");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not add literal to forked instance");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  if(eidx >= 1)
  {
    if(lgl->maxext >= eidx)
    {
      ext=lglelit2ext(lgl, elit);
      while(!(ext->melted == 0u))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lgladd");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "adding melted literal %d", elit);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
    }

  }

  lgl->stats->calls.add = lgl->stats->calls.add + 1l;
  lgleadd(lgl, elit);
  lgluse(lgl);
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lgladd(lgl->clone, elit);

}

// lgladdcls
// file lglib.c line 3511
static signed int lgladdcls(struct LGL *lgl, signed int red, signed int origlue, signed int force)
{
  signed int size;
  signed int lit;
  signed int other;
  signed int other2;
  signed int *p;
  signed int lidx;
  signed int unit;
  signed int blit;
  signed int scaledglue;
  signed int redglue;
  signed int prevglue;
  signed char val;
  struct Stk *w;
  lgl->stats->prgss = lgl->stats->prgss + 1l;
  unsigned long int return_value_lglcntstk$1;
  if(!(lgl->eliminating == 0))
  {
    return_value_lglcntstk$1=lglcntstk(&lgl->clause);
    lgl->stats->elm.steps = lgl->stats->elm.steps + (signed long int)return_value_lglcntstk$1;
  }

  if(red == 0)
    lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;

  if(!(force == 0))
    lglchksimpcls(lgl);

  unsigned long int return_value_lglcntstk$2;
  return_value_lglcntstk$2=lglcntstk(&lgl->clause);
  size = (signed int)(return_value_lglcntstk$2 - (unsigned long int)1);
  if(red == 0)
    lglincirr(lgl, size);

  else
    if(size == 2)
      lgl->stats->red.bin = lgl->stats->red.bin + 1;

    else
      if(size == 3)
        lgl->stats->red.trn = lgl->stats->red.trn + 1;

  signed char return_value_lglval$4;
  signed char return_value_lglval$5;
  signed char return_value_lglval$7;
  signed char return_value_lglval$6;
  signed char return_value_lglval$9;
  signed char return_value_lglval$8;
  signed char return_value_lglval$11;
  signed char return_value_lglval$10;
  signed int return_value_lglceilld$12;
  signed int return_value_lglmtstk$19;
  if(size == 0)
  {

  __CPROVER_DUMP_L7:
    ;
    lgl->mt = 1;
    return 0;
  }

  else
  {
    lit = lgl->clause.start[(signed long int)0];
    if(size == 1)
    {
      signed char return_value_lglval$3;
      return_value_lglval$3=lglval(lgl, lit);
      if(return_value_lglval$3 == 0)
      {
        if(!(red == 0))
          lglunit(lgl, lit);

        else
          lglunitnocheck(lgl, lit);
      }

      return 0;
    }

    other = lgl->clause.start[(signed long int)1];
    if(size == 2)
    {
      lglwchbin(lgl, lit, other, red);
      lglwchbin(lgl, other, lit, red);
      if(!(red == 0))
      {
        if(!(force == 0))
        {
          return_value_lglval$4=lglval(lgl, lit);
          if(!((signed int)return_value_lglval$4 >= 0))
            lglf2rce(lgl, other, lit, REDCS);

        }

        if(!(force == 0))
        {
          return_value_lglval$5=lglval(lgl, other);
          if(!((signed int)return_value_lglval$5 >= 0))
            lglf2rce(lgl, lit, other, REDCS);

        }

      }

      else
        if(!(lgl->dense == 0))
        {
          lglincocc(lgl, lit);
          lglincocc(lgl, other);
        }

      return 0;
    }

    else
    {
      lglordercls(lgl);
      lit = lgl->clause.start[(signed long int)0];
      other = lgl->clause.start[(signed long int)1];
      if(size == 3)
      {
        other2 = lgl->clause.start[(signed long int)2];
        lglwchtrn(lgl, lit, other, other2, red);
        lglwchtrn(lgl, other, lit, other2, red);
        lglwchtrn(lgl, other2, lit, other, red);
        if(!(red == 0))
        {
          if(!(force == 0))
          {
            return_value_lglval$7=lglval(lgl, lit);
            if(!((signed int)return_value_lglval$7 >= 0))
            {
              return_value_lglval$6=lglval(lgl, other);
              if(!((signed int)return_value_lglval$6 >= 0))
                lglf3rce(lgl, other2, lit, other, REDCS);

            }

          }

          if(!(force == 0))
          {
            return_value_lglval$9=lglval(lgl, lit);
            if(!((signed int)return_value_lglval$9 >= 0))
            {
              return_value_lglval$8=lglval(lgl, other2);
              if(!((signed int)return_value_lglval$8 >= 0))
                lglf3rce(lgl, other, lit, other2, REDCS);

            }

          }

          if(!(force == 0))
          {
            return_value_lglval$11=lglval(lgl, other);
            if(!((signed int)return_value_lglval$11 >= 0))
            {
              return_value_lglval$10=lglval(lgl, other2);
              if(!((signed int)return_value_lglval$10 >= 0))
                lglf3rce(lgl, lit, other, other2, REDCS);

            }

          }

        }

        else
          if(!(lgl->dense == 0))
          {
            lglincocc(lgl, lit);
            lglincocc(lgl, other);
            lglincocc(lgl, other2);
          }

        return 0;
      }

      else
      {
        if(!(red == 0))
        {
          if(lgl->opts->gluekeep.val >= origlue)
            scaledglue = 0;

          else
          {
            redglue = origlue - lgl->opts->gluekeep.val;
            scaledglue = redglue;
            switch(lgl->opts->gluescale.val)
            {
              case 3:
              {
                return_value_lglceilld$12=lglceilld(redglue);
                scaledglue = 1 + return_value_lglceilld$12;
                break;
              }
              case 2:
                scaledglue=lglceilsqrt32(redglue);
            }
          }
          if(scaledglue >= 15)
            scaledglue = (1 << 4) - 1;

          lgl->stats->clauses.scglue = lgl->stats->clauses.scglue + (signed long int)scaledglue;
          if(scaledglue == 15)
            lgl->stats->clauses.maxglue = lgl->stats->clauses.maxglue + 1l;

          else
            lgl->stats->clauses.nonmaxglue = lgl->stats->clauses.nonmaxglue + 1l;
          w = lgl->red + (signed long int)scaledglue;
          unsigned long int return_value_lglcntstk$13;
          return_value_lglcntstk$13=lglcntstk(w);
          lidx = (signed int)(return_value_lglcntstk$13 + (unsigned long int)1);
          if(lidx >= 134217727)
          {
            prevglue = scaledglue;
            if(lidx >= 134217727)
            {
              scaledglue = prevglue;
              while(lidx >= 134217727 && !(1 + scaledglue >= 15))
              {
                scaledglue = scaledglue + 1;
                w = lgl->red + (signed long int)scaledglue;
                unsigned long int return_value_lglcntstk$14;
                return_value_lglcntstk$14=lglcntstk(w);
                lidx = (signed int)(return_value_lglcntstk$14 + (unsigned long int)1);
              }
            }

            if(lidx >= 134217727)
            {
              scaledglue = prevglue;
              while(lidx >= 134217727 && scaledglue >= 1)
              {
                scaledglue = scaledglue - 1;
                w = lgl->red + (signed long int)scaledglue;
                unsigned long int return_value_lglcntstk$15;
                return_value_lglcntstk$15=lglcntstk(w);
                lidx = (signed int)(return_value_lglcntstk$15 + (unsigned long int)1);
              }
            }

            if(lidx >= 134217727 && !(scaledglue >= 15))
            {
              scaledglue = (1 << 4) - 1;
              w = lgl->red + (signed long int)scaledglue;
              unsigned long int return_value_lglcntstk$16;
              return_value_lglcntstk$16=lglcntstk(w);
              lidx = (signed int)(return_value_lglcntstk$16 + (unsigned long int)1);
            }

            if(scaledglue == 15 && lidx >= 134217727)
            {
              lglbacktrack(lgl, 0);
              unsigned long int return_value_lglcntstk$17;
              return_value_lglcntstk$17=lglcntstk(w);
              lidx = (signed int)return_value_lglcntstk$17;
            }

            if(lidx >= 134217727)
              lgldie(lgl, "number of redundant large clause literals exhausted");

          }

          lglpushstk(lgl, w, 0x7fffffff >> RMSHFT);
          lidx = lidx << 4;
          lidx = lidx | scaledglue;
          lgl->stats->lir[(signed long int)scaledglue].clauses = lgl->stats->lir[(signed long int)scaledglue].clauses + 1;
          lgl->stats->lir[(signed long int)scaledglue].added = lgl->stats->lir[(signed long int)scaledglue].added + 1l;
        }

        else
        {
          w = &lgl->irr;
          unsigned long int return_value_lglcntstk$18;
          return_value_lglcntstk$18=lglcntstk(w);
          lidx = (signed int)return_value_lglcntstk$18;
          scaledglue = 0;
          if(!(lidx >= 1))
          {
            return_value_lglmtstk$19=lglmtstk(w);
            if(return_value_lglmtstk$19 == 0)
              lgldie(lgl, "number of irredundant large clause literals exhausted");

          }

        }
        p = lgl->clause.start;
        do
        {
          other2 = *p;
          if(other2 == 0)
            break;

          lglpushstk(lgl, w, other2);
          p = p + 1l;
        }
        while((_Bool)1);
        lglpushstk(lgl, w, 0);
        if(!(red == 0))
        {
          unit = 0;
          p = lgl->clause.start;
          do
          {
            other2 = *p;
            if(other2 == 0)
              break;

            val=lglval(lgl, other2);
            if((signed int)val >= 0)
            {
              if(!(unit == 0))
                unit = 0x7fffffff;

              else
                unit = other2;
            }

            p = p + 1l;
          }
          while((_Bool)1);
          if(!(unit == 0) && !(unit == 0x7fffffff) && !(force == 0))
            lglflrce(lgl, unit, red, lidx);

        }

        if(red == 0 || !(red == 0) && !(scaledglue >= 15))
        {
          lglwchlrg(lgl, lit, other, red, lidx);
          lglwchlrg(lgl, other, lit, red, lidx);
        }

        if(!(scaledglue == 15) && !(red == 0))
        {
          lglbumplidx(lgl, lidx);
          lgl->stats->red.lrg = lgl->stats->red.lrg + 1;
        }

        if(red == 0)
        {
          if((signed int)lgl->dense >= 2)
          {
            if(lidx >= 134217727)
              lgldie(lgl, "number of irredundant large clause literals exhausted");

            blit = lidx << RMSHFT | OCCS;
            p = lgl->clause.start;
            do
            {
              other2 = *p;
              if(other2 == 0)
                break;

              lglincocc(lgl, other2);
              struct HTS *return_value_lglhts$20;
              return_value_lglhts$20=lglhts(lgl, other2);
              lglpushwch(lgl, return_value_lglhts$20, blit);
              p = p + 1l;
            }
            while((_Bool)1);
          }

        }

        lglchkirrstats(lgl);
        return lidx;
      }
    }
  }
}

// lgladdecl
// file lglib.c line 9309
static void lgladdecl(struct LGL *lgl, const signed int *c)
{
  signed int ilit;
  signed int mlit;
  signed int umlit;
  signed int size = 0;
  signed int lgladdecl$$1$$next;
  signed int prev;
  unsigned int csig = (unsigned int)0;
  const signed int *p;
  signed char val;

__CPROVER_DUMP_L1:
  ;
  lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
  lgl->stats->elm.copies = lgl->stats->elm.copies + 1l;
  size = 0;
  p = c;
  do
  {
    ilit = *p;
    if(ilit == 0)
      break;

    val=lglval(lgl, ilit);
    if((signed int)val >= 0)
    {
      size = size + 1;
      signed int return_value_abs$1;
      return_value_abs$1=abs(ilit);
      if(!(return_value_abs$1 == lgl->$anon0.elm->pivot))
      {
        mlit=lgli2m(lgl, ilit);
        unsigned int return_value_lglsig$2;
        return_value_lglsig$2=lglsig(mlit);
        csig = csig | return_value_lglsig$2;
      }

    }

    p = p + 1l;
  }
  while((_Bool)1);
  unsigned long int return_value_lglcntstk$3;
  return_value_lglcntstk$3=lglcntstk(&lgl->$anon0.elm->lits);
  lgladdecl$$1$$next = (signed int)return_value_lglcntstk$3;
  p = c;
  signed int tmp_post$4;
  do
  {
    ilit = *p;
    if(ilit == 0)
      break;

    val=lglval(lgl, ilit);
    if((signed int)val >= 0)
    {
      mlit=lgli2m(lgl, ilit);
      lglpushstk(lgl, &lgl->$anon0.elm->lits, mlit);
      umlit=lglulit(mlit);
      prev=lglpeek(&lgl->$anon0.elm->occs, umlit);
      lglpushstk(lgl, &lgl->$anon0.elm->next, prev);
      tmp_post$4 = lgladdecl$$1$$next;
      lgladdecl$$1$$next = lgladdecl$$1$$next + 1;
      lglpoke(&lgl->$anon0.elm->occs, umlit, tmp_post$4);
      lglpushstk(lgl, &lgl->$anon0.elm->csigs, (signed int)csig);
      lglpushstk(lgl, &lgl->$anon0.elm->sizes, size);
      lgl->$anon0.elm->noccs.start[(signed long int)umlit] = lgl->$anon0.elm->noccs.start[(signed long int)umlit] + 1;
      lgl->$anon0.elm->lsigs.start[(signed long int)umlit] = lgl->$anon0.elm->lsigs.start[(signed long int)umlit] | (signed int)csig;
    }

    p = p + 1l;
  }
  while((_Bool)1);
  lglpushstk(lgl, &lgl->$anon0.elm->lits, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->next, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->csigs, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->sizes, 0);
  lgl->$anon0.elm->necls = lgl->$anon0.elm->necls + 1;

__CPROVER_DUMP_L8:
  ;
}

// lgladdflt
// file lglib.c line 1108
static signed long int lgladdflt(signed long int a, signed long int b)
{
  signed int e;
  signed int f;
  signed int g;
  unsigned long int m;
  unsigned long int n;
  unsigned long int o;
  lglchkflt(a);
  lglchkflt(b);
  if(a == 0x7fffffffffffffffll)
    return 0x7fffffffffffffffll;

  else
    if(b == 0x7fffffffffffffffll)
      return 0x7fffffffffffffffll;

    else
      if(a == 0x0000000000000000ll)
        return b;

      else
        if(b == 0x0000000000000000ll)
          return a;

        else
        {
          e=lglexp(a);
          f=lglexp(b);
          if(!(e >= f))
          {
            g = e;
            e = f;
            f = g;
            o = (unsigned long int)a;
            a = b;
            b = (signed long int)o;
          }

          m=lglmnt(a);
          n=lglmnt(b);
          m = m + (n >> e - f);
          signed long int return_value_lglflt$1;
          return_value_lglflt$1=lglflt(e, m);
          return return_value_lglflt$1;
        }
}

// lgladdliftbincls
// file lglib.c line 13914
static void lgladdliftbincls(struct LGL *lgl, signed int a, signed int b)
{
  lglpushstk(lgl, &lgl->clause, a);
  lglpushstk(lgl, &lgl->clause, b);
  lglpushstk(lgl, &lgl->clause, 0);

__CPROVER_DUMP_L1:
  ;
  lgladdcls(lgl, REDCS, 0, 1);
  lglclnstk(&lgl->clause);
  lgl->stats->lift.impls = lgl->stats->lift.impls + 1;
}

// lgladdunits
// file lglib.c line 13703
static signed int lgladdunits(struct LGL *lgl)
{
  signed int idx;
  signed int lit;
  signed int repr;
  signed char val;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    repr=lglcgrepr(lgl, idx);
    signed int return_value_abs$1;
    return_value_abs$1=abs(repr);
    if(!(return_value_abs$1 >= 2))
    {
      lit = repr > 0 ? idx : -idx;
      val=lglval(lgl, lit);
      if(!((signed int)val >= 1))
      {
        if(!((signed int)val >= 0))
        {

        __CPROVER_DUMP_L3:
          ;
          lgl->mt = 1;
          return 0;
        }


      __CPROVER_DUMP_L4:
        ;
        lglpushstk(lgl, &lgl->$anon0.cgr->units, lit);
      }

    }

  }
  return 1;
}

// lgladecide
// file lglib.c line 7716
static signed int lgladecide(struct LGL *lgl)
{
  signed int res;
  signed int val;
  unsigned long int return_value_lglcntstk$1;
  do
  {
    return_value_lglcntstk$1=lglcntstk(&lgl->assume);
    if((unsigned long int)lgl->assumed >= return_value_lglcntstk$1)
      break;

    res=lglpeek(&lgl->assume, lgl->assumed);
    val=lglcval(lgl, res);
    if(val >= 1)

      __CPROVER_DUMP_L2:
        ;

    lgl->assumed = lgl->assumed + 1;

  __CPROVER_DUMP_L4:
    ;
    if(val == 0)
      return res;

  }
  while((_Bool)1);
  return 0;
}

// lgladjext
// file lglib.c line 2490
static void lgladjext(struct LGL *lgl, signed int eidx)
{
  unsigned long int old;
  unsigned long int new;
  old = (unsigned long int)lgl->szext;
  new = old != 0ul ? (unsigned long int)2 * old : (unsigned long int)2;
  for( ; (unsigned long int)eidx >= new; new = new * (unsigned long int)2)
    ;

__CPROVER_DUMP_L2:
  ;
  do
  {
    void *return_value_lglrsz$1;
    return_value_lglrsz$1=lglrsz(lgl, (void *)lgl->ext, old * sizeof(struct Ext) /*32ul*/ , new * sizeof(struct Ext) /*32ul*/ );
    lgl->ext = (struct Ext *)return_value_lglrsz$1;
  }
  while((_Bool)0);
  lgl->szext = (signed int)new;
}

// lglagile
// file lglib.c line 5178
static signed int lglagile(struct LGL *lgl)
{
  return (signed int)(lgl->flips >= (unsigned long int)lgl->opts->agile.val * 10000000ull);
}

// lglagility
// file lglib.c line 5012
static double lglagility(struct LGL *lgl)
{
  return (double)lgl->flips / 1e7;
}

// lglana
// file lglib.c line 6027
static signed int lglana(struct LGL *lgl)
{
  signed int size;
  signed int savedsize;
  signed int resolventsize;
  signed int level;
  signed int mlevel;
  signed int jlevel;
  signed int red;
  signed int glue;
  signed int open;
  signed int resolved;
  signed int tag;
  signed int lit;
  signed int uip;
  signed int r0;
  signed int r1;
  signed int other;
  signed int *p;
  signed int del;
  signed int cl;
  signed int c0;
  signed int c1;
  signed int sl;
  signed int s0;
  signed int s1;
  signed int rescore_clauses;
  signed int len;
  signed int *rsn;
  signed int return_value_lglpull$1;
  signed int tmp_post$2;
  signed int *tmp_post$7;
  signed int return_value_lglbumplidx$10;
  unsigned long int return_value_lglcntstk$11;
  signed int *tmp_post$12;
  signed int return_value_lglbumplidx$13;
  signed int return_value_lglmarked$14;
  if(!(lgl->mt == 0))
    return 0;

  else
    if(!(lgl->failed == 0))
      return 0;

    else
      if(lgl->conf.lit == 0)
        return 1;

      else
        if(lgl->level == 0)
        {
          lgl->mt = 1;
          return 0;
        }

        else
        {
          if(!(lgl->flipping == 0))
          {
            if(lgl->flipping == 1)

              __CPROVER_DUMP_L5:
                ;

            lgl->flipping = lgl->flipping - 1;
          }

          if(!(lgl->phaseneg == 0))
          {
            if(lgl->phaseneg == 1)

              __CPROVER_DUMP_L8:
                ;

            lgl->phaseneg = lgl->phaseneg - 1;
          }

          lglstart(lgl, &lgl->times->ana);
          lgl->stats->confs = lgl->stats->confs + 1l;
          do
          {

          RESTART:
            ;
            (void)0;
            open = 0;
            lit = lgl->conf.lit;
            r0 = lgl->conf.rsn[(signed long int)0];
            r1 = lgl->conf.rsn[(signed long int)1];
            rescore_clauses = 0;
            resolved = 0;
            savedsize = resolved;
            return_value_lglpull$1=lglpull(lgl, lit);
            open = open + return_value_lglpull$1;

          __CPROVER_DUMP_L12:
            ;

          __CPROVER_DUMP_L13:
            ;
            tmp_post$2 = resolved;
            resolved = resolved + 1;
            tag = r0 & MASKCS;
            if(tag == BINCS || tag == TRNCS)
            {
              other = r0 >> RMSHFT;
              signed int return_value_lglevel$3;
              return_value_lglevel$3=lglevel(lgl, other);
              size = return_value_lglevel$3 != 0 ? 2 : 1;
              signed int return_value_lglpull$4;
              return_value_lglpull$4=lglpull(lgl, other);
              if(!(return_value_lglpull$4 == 0))
                open = open + 1;

              if(tag == TRNCS)
              {
                signed int return_value_lglevel$5;
                return_value_lglevel$5=lglevel(lgl, r1);
                if(!(return_value_lglevel$5 == 0))
                  size = size + 1;

                signed int return_value_lglpull$6;
                return_value_lglpull$6=lglpull(lgl, r1);
                if(!(return_value_lglpull$6 == 0))
                  open = open + 1;

              }

            }

            else
            {
              red = r0 & REDCS;
              p=lglidx2lits(lgl, LRGCS, red, r1);
              size = 0;
              do
              {
                tmp_post$7 = p;
                p = p + 1l;
                other = *tmp_post$7;
                if(other == 0)
                  break;

                signed int return_value_lglevel$8;
                return_value_lglevel$8=lglevel(lgl, other);
                if(!(return_value_lglevel$8 == 0))
                  size = size + 1;

                signed int return_value_lglpull$9;
                return_value_lglpull$9=lglpull(lgl, other);
                if(!(return_value_lglpull$9 == 0))
                  open = open + 1;

              }
              while((_Bool)1);
              if(!(red == 0))
              {
                return_value_lglbumplidx$10=lglbumplidx(lgl, r1);
                if(!(return_value_lglbumplidx$10 == 0))
                  rescore_clauses = 1;

              }

            }

          __CPROVER_DUMP_L24:
            ;
            return_value_lglcntstk$11=lglcntstk(&lgl->clause);
            resolventsize = (signed int)((unsigned long int)open + return_value_lglcntstk$11);
            if(lgl->opts->otfs.val == 0)
              goto __CPROVER_DUMP_L45;

            if(!(resolved >= 2))
              goto __CPROVER_DUMP_L45;

            if((!(resolved == 2) || resolventsize >= savedsize) && resolventsize >= size)
              goto __CPROVER_DUMP_L45;

            cl = lgl->conf.lit;
            c0 = lgl->conf.rsn[(signed long int)0];
            c1 = lgl->conf.rsn[(signed long int)1];
            del = lit;
            if(!(resolved >= 3))
            {
              if(resolventsize >= size)
              {
                del = -lit;
                lit = cl;
                r0 = c0;
                r1 = c1;
              }

              else
                if(!(resolventsize >= savedsize))
                {
                  if(!((REDCS & r0) == 0))
                  {
                    sl = lit;
                    s0 = r0;
                    s1 = r1;
                    del = -lit;
                    lit = cl;
                    r0 = c0;
                    r1 = c1;
                  }

                  else
                  {
                    sl = cl;
                    s0 = c0;
                    s1 = c1;
                  }
                  lgldynsub(lgl, sl, s0, s1);
                }

            }

            lgldynstr(lgl, del, lit, r0, r1);
            lit = lgl->conf.lit;
            r0 = lgl->conf.rsn[(signed long int)0];
            r1 = lgl->conf.rsn[(signed long int)1];
            jlevel = 0;
            tag = r0 & MASKCS;
            if(!(tag == UNITCS))
            {
              if(tag == BINCS)
              {
                other = r0 >> RMSHFT;
                level=lglevel(lgl, other);
                if(!(jlevel >= level))
                  jlevel = level;

              }

              else
                if(tag == TRNCS)
                {
                  other = r0 >> RMSHFT;
                  level=lglevel(lgl, other);
                  if(!(jlevel >= level))
                    jlevel = level;

                  if(!(jlevel >= lgl->level))
                  {
                    other = r1;
                    level=lglevel(lgl, other);
                    if(!(jlevel >= level))
                      jlevel = level;

                  }

                }

                else
                {
                  red = r0 & REDCS;
                  p=lglidx2lits(lgl, LRGCS, red, r1);
                  while(!(jlevel >= lgl->level))
                  {
                    tmp_post$12 = p;
                    p = p + 1l;
                    other = *tmp_post$12;
                    if(other == 0)
                      break;

                    level=lglevel(lgl, other);
                    if(!(jlevel >= level))
                      jlevel = level;

                  }
                  if(!(red == 0))
                  {
                    return_value_lglbumplidx$13=lglbumplidx(lgl, r1);
                    if(!(return_value_lglbumplidx$13 == 0))
                      rescore_clauses = 1;

                  }

                }
            }

            if(!(jlevel >= lgl->level))
              break;


          __CPROVER_DUMP_L42:
            ;
            lgl->stats->otfs.restarting = lgl->stats->otfs.restarting + 1;
            lglbumplits(lgl);
            if(!(rescore_clauses == 0))
              lglrescoreclauses(lgl);

            lglclnana(lgl);
          }
          while((_Bool)1);

        __CPROVER_DUMP_L44:
          ;
          lgl->stats->otfs.driving = lgl->stats->otfs.driving + 1;
          lglbacktrack(lgl, jlevel);
          lglassign(lgl, lit, r0, r1);
          lglbumplits(lgl);
          goto DONE;

        __CPROVER_DUMP_L45:
          ;
          savedsize = size;
          do
          {
            lit=lglpopstk(&lgl->trail);
            return_value_lglmarked$14=lglmarked(lgl, lit);
            if(!(return_value_lglmarked$14 == 0))
              break;

            lglunassign(lgl, lit);
          }
          while((_Bool)1);
          lglunassign(lgl, lit);
          open = open - 1;
          if(open == 0)
            uip = -lit;

          else
          {

          __CPROVER_DUMP_L48:
            ;
            rsn=lglrsn(lgl, lit);
            r0 = rsn[(signed long int)0];
            r1 = rsn[(signed long int)1];
            goto __CPROVER_DUMP_L13;
          }

        __CPROVER_DUMP_L49:
          ;
          lglpushstk(lgl, &lgl->clause, uip);
          lglpushstk(lgl, &lgl->clause, 0);

        __CPROVER_DUMP_L50:
          ;
          unsigned long int return_value_lglcntstk$15;
          return_value_lglcntstk$15=lglcntstk(&lgl->frames);
          glue = (signed int)return_value_lglcntstk$15;
          lgl->stats->glues.count = lgl->stats->glues.count + 1;
          lgl->stats->glues.sum = lgl->stats->glues.sum + (signed long int)glue;
          lglbumplits(lgl);
          lglmincls(lgl, uip);
          mlevel = lgl->level;
          jlevel = 0;
          p = lgl->frames.start;
          for( ; !(p >= lgl->frames.top); p = p + 1l)
          {
            level = *p;
            if(!(level >= mlevel))
              mlevel = level;

            if(!(jlevel >= level))
              jlevel = level;

          }

        __CPROVER_DUMP_L54:
          ;

        __CPROVER_DUMP_L55:
          ;

        __CPROVER_DUMP_L56:
          ;
          signed int *return_value_lglrsn$16;
          return_value_lglrsn$16=lglrsn(lgl, uip);
          if(!(*return_value_lglrsn$16 == 0))
            lgl->stats->uips = lgl->stats->uips + 1l;

          lglbacktrack(lgl, jlevel);
          unsigned long int return_value_lglcntstk$17;
          return_value_lglcntstk$17=lglcntstk(&lgl->clause);
          len = (signed int)(return_value_lglcntstk$17 - (unsigned long int)1);
          lgl->stats->clauses.glue = lgl->stats->clauses.glue + (signed long int)glue;
          lgl->stats->lits.learned = lgl->stats->lits.learned + (signed long int)len;
          lgl->stats->clauses.learned = lgl->stats->clauses.learned + 1l;
          lgladdcls(lgl, REDCS, glue, 1);

        DONE:
          ;
          lglclnana(lgl);
          if(lgl->level == 0)
          {
            if(lgl->simp == 0)
            {
              lgl->stats->iterations = lgl->stats->iterations + 1;
              lglrep(lgl, 1, (char)105);
            }

          }

          if(!(rescore_clauses == 0))
            lglrescoreclauses(lgl);

          lglstop(lgl);
          return 1;
        }
}

// lglanafailed
// file lglib.c line 14447
static void lglanafailed(struct LGL *lgl)
{
  signed int ilit;
  signed int elit;
  signed int erepr;
  signed int failed;
  signed int size;
  unsigned int bit;
  unsigned int rbit;
  unsigned int ibit;
  unsigned int count;
  struct Ext *ext;
  struct Ext *rext;
  const signed int *p;
  struct AVar *av;
  _Bool tmp_if_expr$1;
  if(!(lgl->mt == 0))

    __CPROVER_DUMP_L1:
      ;

  else
  {
    failed = lgl->failed;
    if(failed == -1)
    {
      elit = 0;
      p = lgl->eassume.start;
      do
      {
        if(elit == 0)
          tmp_if_expr$1 = p < lgl->eassume.top ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(!tmp_if_expr$1)
          break;

        erepr=lglerepr(lgl, *p);
        signed int return_value_lglederef$2;
        return_value_lglederef$2=lglederef(lgl, erepr);
        if(!(return_value_lglederef$2 >= 0))
          elit = *p;

        p = p + 1l;
      }
      while((_Bool)1);

    __CPROVER_DUMP_L7:
      ;
      ext=lglelit2ext(lgl, elit);
      bit = 1u << (signed int)(elit < 0);
      ext->failed = (unsigned int)ext->failed | bit;
    }

    else
    {
      av=lglavar(lgl, failed);
      if((signed int)av->assumed == 3)
      {

      __CPROVER_DUMP_L9:
        ;
        av->failed = (unsigned int)3;
      }

      else
      {
        lglanalit(lgl, -failed);
        p = lgl->clause.start;
        for( ; !(p >= lgl->clause.top); p = p + 1l)
        {
          ilit = *p;
          av=lglavar(lgl, ilit);
          bit = 1u << (signed int)(ilit > 0);
          av->failed = (unsigned int)av->failed | bit;
        }
        unsigned long int return_value_lglcntstk$3;
        return_value_lglcntstk$3=lglcntstk(&lgl->clause);
        size = (signed int)return_value_lglcntstk$3;
        lglpushstk(lgl, &lgl->clause, 0);
        unsigned long int return_value_lglcntstk$4;
        return_value_lglcntstk$4=lglcntstk(&lgl->eassume);
        lglprt(lgl, 2, "[analyze-final] learned clause with size %d out of %d", size, return_value_lglcntstk$4);

      __CPROVER_DUMP_L13:
        ;
        lgladdcls(lgl, REDCS, size, 0);
        lglpopstk(&lgl->clause);
        lglpopnunmarkstk(lgl, &lgl->clause);
      }
      count = (unsigned int)0;
      p = lgl->eassume.start;
      for( ; !(p >= lgl->eassume.top); p = p + 1l)
      {
        elit = *p;
        bit = 1u << (signed int)(elit < 0);
        ext=lglelit2ext(lgl, elit);
        if((bit & (unsigned int)ext->failed) == 0u)
        {
          if(!(ext->equiv == 0u))
          {
            erepr = ext->repr;
            rbit = bit;
            if(!(erepr >= 0))
              rbit = rbit ^ (unsigned int)3;

            if(!(elit >= 0))
              erepr = -erepr;

            rext=lglelit2ext(lgl, erepr);
            if(!((rbit & (unsigned int)rext->failed) == 0u))
              goto __CPROVER_DUMP_L25;

            ilit = rext->repr;
            ibit = rbit;
            if(!(ilit >= 0))
            {
              ilit = -ilit;
              ibit = ibit ^ (unsigned int)3;
            }

            if(ilit == 1)
              goto __CPROVER_DUMP_L25;

            av=lglavar(lgl, ilit);
            if((ibit & (unsigned int)av->failed) == 0u)
              goto __CPROVER_DUMP_L25;

            rext->failed = (unsigned int)rext->failed | rbit;
            count = count + 1u;
            if(!((rbit & (unsigned int)rext->assumed) == 0u))

              __CPROVER_DUMP_L19:
                ;

            else
            {

            __CPROVER_DUMP_L20:
              ;
              ext->failed = (unsigned int)ext->failed | bit;
            }
          }

          else
          {
            ilit = ext->repr;
            ibit = bit;
            if(!(ilit >= 0))
            {
              ilit = -ilit;
              ibit = ibit ^ (unsigned int)3;
            }

            if(!(ilit == 1))
            {
              av=lglavar(lgl, ilit);
              if(!((ibit & (unsigned int)av->failed) == 0u))
              {

              __CPROVER_DUMP_L24:
                ;
                ext->failed = (unsigned int)ext->failed | bit;
                count = count + 1u;
              }

            }

          }
        }


      __CPROVER_DUMP_L25:
        ;
      }
    }
  }

__CPROVER_DUMP_L26:
  ;

__CPROVER_DUMP_L27:
  ;
  do
    lgl->state = (enum State)FAILED;
  while((_Bool)0);
}

// lglanalit
// file lglib.c line 14399
static signed int lglanalit(struct LGL *lgl, signed int lit)
{
  signed int r0;
  signed int r1;
  signed int antecedents;
  signed int other;
  signed int lglanalit$$1$$next;
  signed int tag;
  signed int *p;
  signed int *rsn;
  struct AVar *av;
  antecedents = 1;
  av=lglavar(lgl, lit);
  rsn=lglrsn(lgl, lit);
  r0 = rsn[(signed long int)0];
  r1 = rsn[(signed long int)1];

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;
  lglpushstk(lgl, &lgl->clause, lit);
  av->mark = 1;
  lglanalit$$1$$next = 0;
  signed int tmp_post$2;
  do
  {
    tag = r0 & MASKCS;
    if(tag == BINCS || tag == TRNCS)
    {
      other = r0 >> RMSHFT;
      lgldstpull(lgl, other);
      if(tag == TRNCS)
        lgldstpull(lgl, r1);

    }

    else
      if(!(tag == UNITCS))
      {
        if(!(tag == DECISION))
        {
          p=lglidx2lits(lgl, LRGCS, r0 & REDCS, r1);
          do
          {
            other = *p;
            if(other == 0)
              break;

            if(!(other == lit))
              lgldstpull(lgl, *p);

            p = p + 1l;
          }
          while((_Bool)1);
        }

      }

    unsigned long int return_value_lglcntstk$1;
    return_value_lglcntstk$1=lglcntstk(&lgl->seen);
    if((unsigned long int)lglanalit$$1$$next == return_value_lglcntstk$1)
      break;

    tmp_post$2 = lglanalit$$1$$next;
    lglanalit$$1$$next = lglanalit$$1$$next + 1;
    lit=lglpeek(&lgl->seen, tmp_post$2);
    rsn=lglrsn(lgl, lit);
    r0 = rsn[(signed long int)0];
    r1 = rsn[(signed long int)1];

  __CPROVER_DUMP_L11:
    ;
    antecedents = antecedents + 1;
  }
  while((_Bool)1);
  lglpopnunmarkstk(lgl, &lgl->seen);

__CPROVER_DUMP_L13:
  ;
  return antecedents;
}

// lgland3fun
// file lglib.c line 10575
static void lgland3fun(unsigned long int *a, unsigned long int *b, unsigned long int *c)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = b[(signed long int)i] & c[(signed long int)i];
}

// lgland3negfun
// file lglib.c line 10581
static void lgland3negfun(unsigned long int *a, unsigned long int *b, unsigned long int *c)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = b[(signed long int)i] & ~c[(signed long int)i];
}

// lglandfun
// file lglib.c line 10569
static void lglandfun(unsigned long int *a, unsigned long int *b)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = a[(signed long int)i] & b[(signed long int)i];
}

// lglandornegfun
// file lglib.c line 10563
static void lglandornegfun(unsigned long int *a, unsigned long int *b, unsigned long int *c)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = a[(signed long int)i] & (b[(signed long int)i] | ~c[(signed long int)i]);
}

// lglassign
// file lglib.c line 2611
static void lglassign(struct LGL *lgl, signed int lit, signed int r0, signed int r1)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int idx;
  signed int phase;
  signed int glue;
  signed int tag;
  signed int dom;
  struct TD *td;

__CPROVER_DUMP_L1:
  ;
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(&lgl->trail);
  av->trail = (signed int)return_value_lglcntstk$1;
  signed int tmp_if_expr$2;
  if(av->trail >= lgl->szdrail)
  {
    signed int newszdrail;
    if(!(lgl->szdrail == 0))
      tmp_if_expr$2 = 2 * lgl->szdrail;

    else
      tmp_if_expr$2 = 1;
    newszdrail = tmp_if_expr$2;
    do
    {
      void *return_value_lglrsz$3;
      return_value_lglrsz$3=lglrsz(lgl, (void *)lgl->drail, (unsigned long int)lgl->szdrail * sizeof(struct TD) /*12ul*/ , (unsigned long int)newszdrail * sizeof(struct TD) /*12ul*/ );
      lgl->drail = (struct TD *)return_value_lglrsz$3;
    }
    while((_Bool)0);
    lgl->szdrail = newszdrail;
  }

  td=lgltd(lgl, lit);
  tag = r0 & MASKCS;
  signed int tmp_if_expr$5;
  signed int return_value_lglgetdom$4;
  if(tag == BINCS)
  {
    return_value_lglgetdom$4=lglgetdom(lgl, -(r0 >> RMSHFT));
    tmp_if_expr$5 = return_value_lglgetdom$4;
  }

  else
    tmp_if_expr$5 = lit;
  dom = tmp_if_expr$5;
  lglsetdom(lgl, lit, dom);
  idx=abs(lit);
  phase=lglsgn(lit);
  lgl->vals[(signed long int)idx] = (signed char)phase;
  if(lgl->simp == 0)
  {
    if(lgl->flipping == 0)
    {
      if(lgl->phaseneg == 0)
      {
        lgl->flips = lgl->flips - lgl->flips / 100000ull;
        if(!((signed int)av->phase == phase))
          lgl->flips = lgl->flips + 10000ull;

        av->phase = phase;
      }

    }

  }

  td->level = lgl->level;
  if(lgl->level == 0)
  {
    if((signed int)av->type == EQUIVAR)
    {
      lgl->stats->equiv.current = lgl->stats->equiv.current - 1;
      lgl->stats->equiv.sum = lgl->stats->equiv.sum - 1;
    }

    else
      av->type = (unsigned int)FIXEDVAR;
    lgl->stats->fixed.sum = lgl->stats->fixed.sum + 1;
    lgl->stats->fixed.current = lgl->stats->fixed.current + 1;
    lgl->stats->prgss = lgl->stats->prgss + 1l;
    lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;
    td->rsn[(signed long int)0] = UNITCS | lit << RMSHFT;
    td->rsn[(signed long int)1] = 0;
    if(!(lgl->cbs == ((struct Cbs *)NULL)))
    {
      if(!(lgl->cbs->units.produce.fun == ((void (*)(void *, signed int))NULL)))
      {

      __CPROVER_DUMP_L12:
        ;
        signed int return_value_lglexport$6;
        return_value_lglexport$6=lglexport(lgl, lit);
        lgl->cbs->units.produce.fun(lgl->cbs->units.produce.state, return_value_lglexport$6);
      }

    }

  }

  else
  {
    td->rsn[(signed long int)0] = r0;
    td->rsn[(signed long int)1] = r1;
  }
  lglpushstk(lgl, &lgl->trail, lit);
  if(lgl->failed == 0)
  {
    if(!((1u << (signed int)(lit >= 1) & (unsigned int)av->assumed) == 0u))
    {

    __CPROVER_DUMP_L17:
      ;
      lgl->failed = -lit;
    }

  }

  lgl->unassigned = lgl->unassigned - 1;
  td->lrglue = (unsigned int)0;
  if((MASKCS & r0) == LRGCS && !((REDCS & r0) == 0))
  {
    glue = r1 & (1 << 4) - 1;
    lgl->stats->lir[(signed long int)glue].forcing = lgl->stats->lir[(signed long int)glue].forcing + 1l;
    if(!(lgl->level == 0))
    {
      if(glue >= 1)
      {
        if(!(glue >= 15))
        {
          lgl->lrgluereasons = lgl->lrgluereasons + 1;
          td->lrglue = (unsigned int)1;
        }

      }

    }

  }

  struct HTS *return_value_lglhts$7;
  return_value_lglhts$7=lglhts(lgl, -lit);
  signed int *return_value_lglhts2wchs$8;
  return_value_lglhts2wchs$8=lglhts2wchs(lgl, return_value_lglhts$7);
}

// lglassume
// file lglib.h line 181
void lglassume(struct LGL *lgl, signed int elit)
{
  signed int eidx;
  eidx=abs(elit);
  struct Ext *ext;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglassume");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "assume %d", elit);
    break;
  }
  while(!(lgl->forked == 0))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglassume");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not assume literal in forked instance");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lgl->stats->calls.assume = lgl->stats->calls.assume + 1l;
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglassume");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not assume invalid literal 0");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  if(eidx >= 1)
  {
    if(lgl->maxext >= eidx)
    {
      ext=lglelit2ext(lgl, elit);
      while(!(ext->melted == 0u))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglassume");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "assuming melted literal %d", elit);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
    }

  }

  lgleassume(lgl, elit);
  lgluse(lgl);
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglassume(lgl->clone, elit);

}

// lglassumption
// file lglib.c line 4805
static signed int lglassumption(struct LGL *lgl, signed int lit)
{
  struct AVar *return_value_lglavar$1;
  return_value_lglavar$1=lglavar(lgl, lit);
  return (signed int)return_value_lglavar$1->assumed;
}

// lglavar
// file lglib.c line 2318
static struct AVar * lglavar(struct LGL *lgl, signed int lit)
{
  signed int return_value_abs$1;
  return_value_abs$1=abs(lit);
  return lgl->avars + (signed long int)return_value_abs$1;
}

// lglavg
// file lglib.c line 5014
static double lglavg(double n, double d)
{
  return IEEE_FLOAT_NOTEQUAL(d, (double)0) ? n / d : 0.0;
}

// lglavglue
// file lglib.c line 5022
static signed long int lglavglue(struct LGL *lgl)
{
  signed int count = lgl->stats->glues.count;
  if(count == 0)
    return (signed long int)0;

  else
    return ((signed long int)100 * lgl->stats->glues.sum) / (signed long int)count;
}

// lglbacksub
// file lglib.c line 9546
static signed int lglbacksub(struct LGL *lgl, signed int *c, signed int str)
{
  signed int *lglbacksub$$1$$start = lgl->$anon0.elm->lits.start;
  signed int *p;
  signed int *q;
  signed int marked = 0;
  signed int res;
  signed int *d;
  signed int lit;
  signed int ulit;
  signed int occ;
  signed int lglbacksub$$1$$next;
  signed int osize;
  signed int other;
  signed int uolit;
  signed int size;
  signed int plit;
  signed int phase;
  signed int clidx;
  unsigned int ocsig;
  unsigned int lsig;
  unsigned int csig = (unsigned int)0;

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;
  phase = (signed int)(c - lglbacksub$$1$$start >= (signed long int)lgl->$anon0.elm->neglidx);
  p = c;
  signed int return_value_abs$2;
  unsigned int return_value_lglsig$1;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    return_value_abs$2=abs(lit);
    if(!(return_value_abs$2 == 1))
    {
      return_value_lglsig$1=lglsig(lit);
      csig = csig | return_value_lglsig$1;
    }

    p = p + 1l;
  }
  while((_Bool)1);
  size = (signed int)(p - c);
  res = 0;
  if(!(str == 0))
    phase = (signed int)!(phase != 0);

  lit = phase != 0 ? -1 : 1;
  ulit=lglulit(lit);
  occ=lglpeek(&lgl->$anon0.elm->noccs, ulit);
  signed int return_value_abs$5;
  _Bool tmp_if_expr$6;
  signed int *tmp_post$7;
  signed int *tmp_post$8;
  signed int return_value_abs$9;
  if(str == 0 && !(occ >= 2))
    return 0;

  else
    if(occ == 0 && !(str == 0))
      return 0;

    else
    {
      signed int return_value_lglpeek$3;
      return_value_lglpeek$3=lglpeek(&lgl->$anon0.elm->lsigs, ulit);
      lsig = (unsigned int)return_value_lglpeek$3;
      if(!((~lsig & csig) == 0u))
        return 0;

      else
      {
        lglbacksub$$1$$next=lglpeek(&lgl->$anon0.elm->occs, ulit);
        while(res == 0 && !(lglbacksub$$1$$next == 0))
        {
          lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
          if(!((signed long int)lglbacksub$$1$$next == p - lglbacksub$$1$$start))
          {
            if(phase == (signed int)(lglbacksub$$1$$next >= lgl->$anon0.elm->neglidx))
            {
              plit=lglpeek(&lgl->$anon0.elm->lits, lglbacksub$$1$$next);
              if(!(plit >= 134217727))
              {
                osize=lglpeek(&lgl->$anon0.elm->sizes, lglbacksub$$1$$next);
                if(size >= osize)
                {
                  signed int return_value_lglpeek$4;
                  return_value_lglpeek$4=lglpeek(&lgl->$anon0.elm->csigs, lglbacksub$$1$$next);
                  ocsig = (unsigned int)return_value_lglpeek$4;
                  if((~csig & ocsig) == 0u)
                  {
                    if(marked == 0)
                    {
                      q = c;
                      do
                      {
                        other = *q;
                        if(other == 0)
                          break;

                        if(!(str == 0))
                        {
                          return_value_abs$5=abs(other);
                          if(return_value_abs$5 == 1)
                            other = -other;

                        }

                        uolit=lglulit(other);
                        lglpoke(&lgl->$anon0.elm->mark, uolit, 1);
                        q = q + 1l;
                      }
                      while((_Bool)1);
                      marked = 1;
                    }

                    d = lgl->$anon0.elm->lits.start + (signed long int)lglbacksub$$1$$next;
                    if(!(d >= c) || d >= c + (signed long int)size)
                    {
                      if(!(str == 0))
                        lgl->stats->elm.strchks = lgl->stats->elm.strchks + 1l;

                      else
                        lgl->stats->elm.subchks = lgl->stats->elm.subchks + 1l;
                      for( ; !(d[-1l] == 0); d = d - 1l)
                        ;

                    __CPROVER_DUMP_L18:
                      ;
                      res = 1;
                      q = d;
                      do
                      {
                        if(!(res == 0))
                        {
                          other = *q;
                          tmp_if_expr$6 = other != 0 ? (_Bool)1 : (_Bool)0;
                        }

                        else
                          tmp_if_expr$6 = (_Bool)0;
                        if(!tmp_if_expr$6)
                          break;

                        uolit=lglulit(other);
                        res=lglpeek(&lgl->$anon0.elm->mark, uolit);
                        q = q + 1l;
                      }
                      while((_Bool)1);
                      if(!(res == 0) && !(str == 0) && osize >= size)
                      {

                      __CPROVER_DUMP_L23:
                        ;
                        clidx = 0;
                        q = lgl->$anon0.elm->lits.start + (signed long int)lgl->$anon0.elm->neglidx;
                        while(!(q >= d))
                        {
                          tmp_post$7 = q;
                          q = q + 1l;
                          other = *tmp_post$7;
                          if(other >= 134217727)
                            do
                            {
                              tmp_post$8 = q;
                              q = q + 1l;
                              if(*tmp_post$8 == 0)
                                break;

                            }
                            while((_Bool)1);

                          else
                            if(other == 0)
                              clidx = clidx + 1;

                        }

                      __CPROVER_DUMP_L29:
                        ;

                      __CPROVER_DUMP_L30:
                        ;
                        lglelrmcls(lgl, -lgl->$anon0.elm->pivot, d, clidx);
                      }

                    }

                  }

                }

              }

            }

          }

          lglbacksub$$1$$next=lglpeek(&lgl->$anon0.elm->next, lglbacksub$$1$$next);
        }
        if(!(marked == 0))
        {
          p = c;
          do
          {
            lit = *p;
            if(lit == 0)
              break;

            if(!(str == 0))
            {
              return_value_abs$9=abs(lit);
              if(return_value_abs$9 == 1)
                lit = -lit;

            }

            ulit=lglulit(lit);
            lglpoke(&lgl->$anon0.elm->mark, ulit, 0);
            p = p + 1l;
          }
          while((_Bool)1);
        }

        return res;
      }
    }
}

// lglbacktrack
// file lglib.c line 2801
static void lglbacktrack(struct LGL *lgl, signed int level)
{
  signed int lit;

__CPROVER_DUMP_L1:
  ;
  signed int return_value_lglevel$1;
  if(!(lgl->failed == 0))
  {
    if(!(lgl->failed == -1))
    {
      return_value_lglevel$1=lglevel(lgl, lgl->failed);
      if(!(level >= return_value_lglevel$1))
      {

      __CPROVER_DUMP_L2:
        ;
        lgl->failed = 0;
      }

    }

  }

  signed int return_value_lglmtstk$2;
  do
  {
    return_value_lglmtstk$2=lglmtstk(&lgl->trail);
    if(!(return_value_lglmtstk$2 == 0))
      break;

    lit=lgltopstk(&lgl->trail);
    signed int return_value_lglevel$3;
    return_value_lglevel$3=lglevel(lgl, lit);
    if(level >= return_value_lglevel$3)
      break;

    lglunassign(lgl, lit);
    lgl->trail.top = lgl->trail.top - 1l;
  }
  while((_Bool)1);
  if(!(level >= lgl->alevel))
  {

  __CPROVER_DUMP_L5:
    ;
    lgl->alevel = level;
    if(!(lgl->assumed == 0))
    {

    __CPROVER_DUMP_L6:
      ;
      lgl->assumed = 0;
    }

  }

  lgl->level = level;
  lglrstcontrol(lgl, level + 1);
  lgl->conf.lit = 0;
  lgl->conf.rsn[(signed long int)1] = 0;
  lgl->conf.rsn[(signed long int)0] = lgl->conf.rsn[(signed long int)1];
  unsigned long int return_value_lglcntstk$4;
  return_value_lglcntstk$4=lglcntstk(&lgl->trail);
  lgl->next = (signed int)return_value_lglcntstk$4;
  lgl->next2 = lgl->next;

__CPROVER_DUMP_L8:
  ;
}

// lglbasicprobe
// file lglib.c line 8966
static signed int lglbasicprobe(struct LGL *lgl)
{
  signed int origfailed = lgl->stats->prb.basic.failed;
  signed int origlifted = lgl->stats->prb.basic.lifted;
  signed int orighbr = lgl->stats->hbr.cnt;
  signed int root;
  signed int failed;
  signed int lifted;
  signed int units;
  signed int first;
  signed int idx;
  signed int oldrem;
  signed int deltarem;
  signed int deltahbr;
  signed int remprobes;
  signed int oldhbr;
  signed int oldfailed;
  signed int oldlifted;
  signed int nprobes;
  signed int success;
  signed int round;
  struct Stk probes;
  struct Stk lift;
  struct Stk saved;
  unsigned int pos;
  unsigned int delta;
  unsigned int return_value_lglrand$1;
  unsigned int return_value_lglrand$2;
  unsigned int return_value_lglgcd$3;
  struct AVar *return_value_lglavar$8;
  signed int return_value_lglmtstk$11;
  signed int return_value_lglisfree$12;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$18;
  signed int return_value_lgldecomp$15;
  struct AVar *return_value_lglavar$16;
  if(lgl->nvars == 0)
    return 1;

  else
    if(lgl->opts->probe.val == 0)
      return 1;

    else
    {
      lglstart(lgl, &lgl->times->prb.basic);
      lgl->stats->prb.basic.count = lgl->stats->prb.basic.count + 1;
      if(lgl->level >= 1)
        lglbacktrack(lgl, 0);

      lgl->basicprobing = (char)1;
      lgl->probing = (signed int)lgl->basicprobing;
      lgl->simp = (char)lgl->probing;
      do
        memset((void *)&lift, 0, sizeof(struct Stk) /*24ul*/ );
      while((_Bool)0);
      do
        memset((void *)&probes, 0, sizeof(struct Stk) /*24ul*/ );
      while((_Bool)0);
      do
        memset((void *)&saved, 0, sizeof(struct Stk) /*24ul*/ );
      while((_Bool)0);
      lglsetprbasiclim(lgl);
      oldfailed = origfailed;
      oldlifted = origlifted;
      oldhbr = lgl->stats->hbr.cnt;
      oldrem=lglrem(lgl);
      round = 0;
      do
      {

      RESTART:
        ;
        nprobes=lglschedbasicprobe(lgl, &probes, round);
        remprobes = 0;
        if(nprobes == 0)
          goto DONE;

        return_value_lglrand$1=lglrand(lgl);
        pos = return_value_lglrand$1 % (unsigned int)nprobes;
        return_value_lglrand$2=lglrand(lgl);
        delta = return_value_lglrand$2 % (unsigned int)nprobes;
        if(delta == 0u)
          delta = delta + 1u;

        do
        {
          return_value_lglgcd$3=lglgcd(delta, (unsigned int)nprobes);
          if(!(return_value_lglgcd$3 >= 2u))
            break;

          delta = delta + 1u;
          if(delta == (unsigned int)nprobes)
            delta = (unsigned int)1;

        }
        while((_Bool)1);

      __CPROVER_DUMP_L10:
        ;
        first = 0;
        while(lgl->mt == 0)
        {
          if(lgl->stats->prb.basic.steps >= lgl->limits->prb.steps)
            break;

          signed int return_value_lglterminate$4;
          return_value_lglterminate$4=lglterminate(lgl);
          if(!(return_value_lglterminate$4 == 0))
            break;

          signed int return_value_lglsyncunits$5;
          return_value_lglsyncunits$5=lglsyncunits(lgl);
          if(return_value_lglsyncunits$5 == 0)
            break;

          root = probes.start[(signed long int)pos];
          probes.start[(signed long int)pos] = 0;
          if(root == 0 || root == first)
          {
            signed int return_value_lglrem$6;
            return_value_lglrem$6=lglrem(lgl);
            double return_value_lglpcnt$7;
            return_value_lglpcnt$7=lglpcnt((double)nprobes, (double)return_value_lglrem$6);
            lglprt(lgl, 1, "[basicprobe-%d-%d] %d sched %.0f%%, %d failed, %d lifted, %d hbrs", lgl->stats->prb.basic.count, round, nprobes, return_value_lglpcnt$7, lgl->stats->prb.basic.failed - oldfailed, lgl->stats->prb.basic.lifted - oldlifted, lgl->stats->hbr.cnt - oldhbr);
            idx = 2;
            for( ; !(idx >= lgl->nvars); idx = idx + 1)
            {
              return_value_lglavar$8=lglavar(lgl, idx);
              return_value_lglavar$8->donotbasicprobe = (unsigned int)0;
            }
            break;
          }

          struct AVar *return_value_lglavar$9;
          return_value_lglavar$9=lglavar(lgl, root);
          return_value_lglavar$9->donotbasicprobe = (unsigned int)1;
          if(first == 0)
            first = root;

          pos = pos + delta;
          if(pos >= (unsigned int)nprobes)
            pos = pos - (unsigned int)nprobes;

          signed int return_value_lglisfree$10;
          return_value_lglisfree$10=lglisfree(lgl, root);
          if(!(return_value_lglisfree$10 == 0))
            lglbasicprobelit(lgl, root);

        }
        if(!(lgl->mt == 0))
          goto DONE;

        if(lgl->stats->prb.basic.steps >= lgl->limits->prb.steps)
        {
          do
          {
            return_value_lglmtstk$11=lglmtstk(&probes);
            if(!(return_value_lglmtstk$11 == 0))
              break;

            idx=lglpopstk(&probes);
            if(!(idx == 0))
            {
              return_value_lglisfree$12=lglisfree(lgl, idx);
              if(!(return_value_lglisfree$12 == 0))
                remprobes = remprobes + 1;

            }

          }
          while((_Bool)1);
          signed int return_value_lglrem$13;
          return_value_lglrem$13=lglrem(lgl);
          double return_value_lglpcnt$14;
          return_value_lglpcnt$14=lglpcnt((double)remprobes, (double)return_value_lglrem$13);
          lglprt(lgl, 1, "[basicprobe-%d-%d] %d probes remain %.0f%% after last round", lgl->stats->prb.basic.count, round, remprobes, return_value_lglpcnt$14);
          goto DONE;
        }

        if(round >= lgl->opts->prbasicroundlim.val)
        {
          lglprt(lgl, 1, "[basicprobe-%d-%d] round limit %d hit", lgl->stats->prb.basic.count, round, lgl->opts->prbasicroundlim.val);
          goto DONE;
        }

        if(!(oldfailed >= lgl->stats->prb.basic.failed))
          tmp_if_expr$17 = (_Bool)1;

        else
          tmp_if_expr$17 = lgl->stats->prb.basic.lifted > oldlifted ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$17)
          tmp_if_expr$18 = (_Bool)1;

        else
          tmp_if_expr$18 = lgl->stats->hbr.cnt > oldhbr ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$18)
          break;

        oldfailed = lgl->stats->prb.basic.failed;
        oldlifted = lgl->stats->prb.basic.lifted;
        lglclnstk(&probes);
        if(!(oldhbr >= lgl->stats->hbr.cnt))
        {
          return_value_lgldecomp$15=lgldecomp(lgl);
          if(return_value_lgldecomp$15 == 0)
            goto DONE;

        }

        oldhbr = lgl->stats->hbr.cnt;
        round = round + 1;
      }
      while((_Bool)1);
      lglprt(lgl, 1, "[basicprobe-%d-%d] fully completed probing", lgl->stats->prb.basic.count, round);
      idx = 2;
      for( ; !(idx >= lgl->nvars); idx = idx + 1)
      {
        return_value_lglavar$16=lglavar(lgl, idx);
        return_value_lglavar$16->donotbasicprobe = (unsigned int)0;
      }

    DONE:
      ;
      lglrelstk(lgl, &lift);
      lglrelstk(lgl, &probes);
      lglrelstk(lgl, &saved);
      signed int return_value_lglrem$19;
      return_value_lglrem$19=lglrem(lgl);
      deltarem = oldrem - return_value_lglrem$19;
      deltahbr = lgl->stats->hbr.cnt - orighbr;
      success = (signed int)(deltarem != 0 || deltahbr != 0);
      lglupdprbasicpen(lgl, deltarem);
      failed = lgl->stats->prb.basic.failed - origfailed;
      lifted = lgl->stats->prb.basic.lifted - origlifted;
      lgl->basicprobing = (char)0;
      lgl->probing = (signed int)lgl->basicprobing;
      lgl->simp = (char)lgl->probing;
      units = failed + lifted;
      double return_value_lglpcnt$20;
      return_value_lglpcnt$20=lglpcnt((double)failed, (double)units);
      double return_value_lglpcnt$21;
      return_value_lglpcnt$21=lglpcnt((double)lifted, (double)units);
      lglprt(lgl, 1 + (signed int)!(units != 0), "[basicprobe-%d-%d] %d units = %d failed (%.0f%%) + %d lifted (%.0f%%)", lgl->stats->prb.basic.count, round, units, failed, return_value_lglpcnt$20, lifted, return_value_lglpcnt$21);
      lglprt(lgl, 1 + (signed int)!(success != 0), "[basicprobe-%d-%d] removed %d variables, found %d hbrs", lgl->stats->prb.basic.count, round, deltarem, deltahbr);
      lglrep(lgl, 1 + (signed int)!(success != 0), (char)112);
      lglstop(lgl);
      return (signed int)!(lgl->mt != 0);
    }
}

// lglbasicprobelit
// file lglib.c line 8735
static void lglbasicprobelit(struct LGL *lgl, signed int root)
{
  signed int old;
  signed int ok;
  signed int dom;
  signed int lit;
  signed int val;
  struct Stk lift;
  struct Stk saved;
  const signed int *p;
  do
    memset((void *)&lift, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  do
    memset((void *)&saved, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);

__CPROVER_DUMP_L3:
  ;
  if(!(lgl->cceing == 0))
    lgl->stats->cce.probed = lgl->stats->cce.probed + 1l;

  else
    lgl->stats->prb.basic.probed = lgl->stats->prb.basic.probed + 1l;
  lgliassume(lgl, root);
  old = lgl->next;
  ok=lglbcp(lgl);
  dom = 0;
  if(!(ok == 0))
  {
    lglclnstk(&saved);
    p = lgl->trail.start + (signed long int)old;
    for( ; !(p >= lgl->trail.top); p = p + 1l)
    {
      lit = *p;
      if(!(lit == root))
        lglpushstk(lgl, &saved, lit);

    }
  }

  else
    dom=lglprbana(lgl, root);
  lglbacktrack(lgl, 0);
  if(ok == 0)
  {

  __CPROVER_DUMP_L11:
    ;
    lglpushstk(lgl, &lift, -dom);
  }

  else
  {

  __CPROVER_DUMP_L12:
    ;
    if(!(lgl->cceing == 0))
      lgl->stats->cce.probed = lgl->stats->cce.probed + 1l;

    else
      lgl->stats->prb.basic.probed = lgl->stats->prb.basic.probed + 1l;
    lgliassume(lgl, -root);
    ok=lglbcp(lgl);
    if(!(ok == 0))
    {
      p = saved.start;
      for( ; !(p >= saved.top); p = p + 1l)
      {
        lit = *p;
        signed char return_value_lglval$1;
        return_value_lglval$1=lglval(lgl, lit);
        val = (signed int)return_value_lglval$1;
        if(val >= 1)
        {
          if(!(lgl->cceing == 0))
            lgl->stats->cce.lifted = lgl->stats->cce.lifted + 1;

          else
            lgl->stats->prb.basic.lifted = lgl->stats->prb.basic.lifted + 1;
          lglpushstk(lgl, &lift, lit);
        }


      __CPROVER_DUMP_L19:
        ;
      }
    }

    else
      dom=lglprbana(lgl, -root);
    lglbacktrack(lgl, 0);
    if(ok == 0)
    {

    __CPROVER_DUMP_L24:
      ;
      lglpushstk(lgl, &lift, -dom);
    }

  }
  signed int return_value_lglmtstk$2;
  signed int return_value_lglbcp$4;
  do
  {

  MERGE:
    ;
    return_value_lglmtstk$2=lglmtstk(&lift);
    if(!(return_value_lglmtstk$2 == 0))
      break;

    lit=lglpopstk(&lift);
    signed char return_value_lglval$3;
    return_value_lglval$3=lglval(lgl, lit);
    val = (signed int)return_value_lglval$3;
    if(!(val >= 1))
    {
      if(val >= 0)
      {
        lglunit(lgl, lit);
        if(!(lgl->cceing == 0))
          lgl->stats->cce.failed = lgl->stats->cce.failed + 1;

        else
          lgl->stats->prb.basic.failed = lgl->stats->prb.basic.failed + 1;
        return_value_lglbcp$4=lglbcp(lgl);
        if(return_value_lglbcp$4 == 0)
          goto EMPTY;

      }

      else
      {
        do

          EMPTY:
            ;
        while((_Bool)0);
        lgl->mt = 1;
      }
    }

  }
  while((_Bool)1);
  lglrelstk(lgl, &lift);
  lglrelstk(lgl, &saved);
}

// lglbcp
// file lglib.c line 4732
static signed int lglbcp(struct LGL *lgl)
{
  signed int lit;
  signed int trail;
  signed int count = 0;
  signed int tmp_post$2;
  signed int tmp_post$3;
  while(lgl->conf.lit == 0)
  {
    unsigned long int return_value_lglcntstk$1;
    return_value_lglcntstk$1=lglcntstk(&lgl->trail);
    trail = (signed int)return_value_lglcntstk$1;
    if(!(lgl->next2 >= trail))
    {
      tmp_post$2 = lgl->next2;
      lgl->next2 = lgl->next2 + 1;
      lit=lglpeek(&lgl->trail, tmp_post$2);
      lglprop2(lgl, lit);
    }

    else
    {
      if(lgl->next >= trail)
        break;

      count = count + 1;
      tmp_post$3 = lgl->next;
      lgl->next = lgl->next + 1;
      lit=lglpeek(&lgl->trail, tmp_post$3);
      lglprop(lgl, lit);
    }
  }
  if(!(lgl->lkhd == 0))
    lgl->stats->props.lkhd = lgl->stats->props.lkhd + (signed long int)count;

  else
    if(!(lgl->simp == 0))
      lgl->stats->props.simp = lgl->stats->props.simp + (signed long int)count;

    else
      lgl->stats->props.search = lgl->stats->props.search + (signed long int)count;
  return (signed int)!(lgl->conf.lit != 0);
}

// lglbcpsearch
// file lglib.c line 4756
static signed int lglbcpsearch(struct LGL *lgl)
{
  signed int lit;
  signed int count = 0;
  unsigned long int return_value_lglcntstk$1;
  signed int tmp_post$2;
  for( ; (_Bool)1; count = count + 1)
  {
    if(!(lgl->failed == 0))
    {
      if(!(lgl->level == 0))
        goto __CPROVER_DUMP_L3;

    }

    if(!(lgl->conf.lit == 0))
      break;

    return_value_lglcntstk$1=lglcntstk(&lgl->trail);
    if((unsigned long int)lgl->next >= return_value_lglcntstk$1)
      break;

    tmp_post$2 = lgl->next;
    lgl->next = lgl->next + 1;
    lit=lglpeek(&lgl->trail, tmp_post$2);
    lglpropsearch(lgl, lit);
  }

__CPROVER_DUMP_L3:
  ;
  lgl->stats->props.search = lgl->stats->props.search + (signed long int)count;
  lgl->next2 = lgl->next;
  if(!(lgl->conf.lit == 0))
  {
    if(!(lgl->failed == 0))
    {

    __CPROVER_DUMP_L4:
      ;
      lgl->failed = 0;
    }

  }

  _Bool tmp_if_expr$3;
  if(lgl->conf.lit == 0)
    tmp_if_expr$3 = !(lgl->failed != 0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  return (signed int)tmp_if_expr$3;
}

// lglbcptop
// file lglib.c line 17200
static signed int lglbcptop(struct LGL *lgl)
{
  signed int res;
  signed int return_value_lglbcp$1;
  return_value_lglbcp$1=lglbcp(lgl);
  if(!(return_value_lglbcp$1 == 0))
    res = 1;

  else
  {
    lglana(lgl);
    if(!(lgl->conf.lit == 0))
    {

    __CPROVER_DUMP_L2:
      ;
      if(lgl->mt == 0)
        lgl->mt = 1;

    }

    res = 0;
  }
  return res;
}

// lglblock
// file lglib.c line 11378
static void lglblock(struct LGL *lgl)
{
  signed int oldrem = (signed int)lgl->blkrem;
  signed int oldall = (signed int)lgl->blkall;
  signed int idx;
  signed int count;
  signed int frozen;
  signed int all;
  signed int rem;
  struct Stk blocked[5l];
  lglstart(lgl, &lgl->times->blk);
  if(!(lgl->level == 0))
    lglbacktrack(lgl, 0);

  lgl->blocking = (char)1;
  lgl->simp = lgl->blocking;
  lgl->stats->blk.count = lgl->stats->blk.count + 1;
  lglgc(lgl);
  lglfreezer(lgl);
  all = (signed int)(!(oldrem != 0) || !(oldall != 0));
  signed int return_value_lgleschedrem$1;
  if(!(all == 0))
    lglprt(lgl, 1, "[block-%d] scheduling all variables this time", lgl->stats->blk.count);

  else
  {
    return_value_lgleschedrem$1=lgleschedrem(lgl, 1);
    if(return_value_lgleschedrem$1 == 0)
    {
      all = 1;
      oldrem = 0;
    }

  }
  if(all == 0)
    lgl->donotsched = (char)1;

  lgldense(lgl, 1);
  if(all == 0)
    lgl->donotsched = (char)0;

  lglsetblklim(lgl);
  do
    memset((void *)&blocked, 0, sizeof(struct Stk [5l]) /*120ul*/ );
  while((_Bool)0);
  count = 0;
  signed int return_value_lglterminate$2;
  signed int return_value_lglmtstk$3;
  _Bool tmp_if_expr$13;
  signed int return_value_lglocc$12;
  signed int return_value_lglpurelit$6;
  _Bool tmp_if_expr$11;
  signed int return_value_lglocc$10;
  signed int return_value_lglpurelit$7;
  do
  {
    return_value_lglterminate$2=lglterminate(lgl);
    if(!(return_value_lglterminate$2 == 0))
      break;

    if(lgl->stats->blk.steps >= lgl->limits->blk.steps)
      break;

    return_value_lglmtstk$3=lglmtstk(&lgl->esched);
    if(!(return_value_lglmtstk$3 == 0))
      break;

    idx=lglpopesched(lgl);
    struct AVar *return_value_lglavar$4;
    return_value_lglavar$4=lglavar(lgl, idx);
    return_value_lglavar$4->donotblk = (unsigned int)1;
    frozen=lglifrozen(lgl, idx);
    signed int return_value_lglisfree$5;
    return_value_lglisfree$5=lglisfree(lgl, idx);
    if(!(return_value_lglisfree$5 == 0))
    {
      if(frozen == 0)
      {
        return_value_lglocc$12=lglocc(lgl, idx);
        tmp_if_expr$13 = !(return_value_lglocc$12 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$13 = (_Bool)0;
      if(tmp_if_expr$13)
      {
        return_value_lglpurelit$6=lglpurelit(lgl, -idx);
        count = count + return_value_lglpurelit$6;
      }

      else
      {
        if(frozen == 0)
        {
          return_value_lglocc$10=lglocc(lgl, -idx);
          tmp_if_expr$11 = !(return_value_lglocc$10 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$11 = (_Bool)0;
        if(tmp_if_expr$11)
        {
          return_value_lglpurelit$7=lglpurelit(lgl, idx);
          count = count + return_value_lglpurelit$7;
        }

        else
        {
          signed int return_value_lglblocklit$8;
          return_value_lglblocklit$8=lglblocklit(lgl, idx, blocked);
          count = count + return_value_lglblocklit$8;
          signed int return_value_lglblocklit$9;
          return_value_lglblocklit$9=lglblocklit(lgl, -idx, blocked);
          count = count + return_value_lglblocklit$9;
        }
      }
    }

  }
  while((_Bool)1);
  unsigned long int return_value_lglcntstk$14;
  return_value_lglcntstk$14=lglcntstk(&lgl->esched);
  rem = (signed int)return_value_lglcntstk$14;
  double return_value_lglpcnt$15;
  if(rem == 0)
    lglprt(lgl, 1, "[block-%d] fully completed blocked clause elimination", lgl->stats->blk.count);

  else
    if(oldrem == 0)
    {
      return_value_lglpcnt$15=lglpcnt((double)rem, (double)(lgl->nvars - 2));
      lglprt(lgl, 1, "[block-%d] incomplete blocked clause elimination %d not tried %.0f%%", lgl->stats->blk.count, rem, return_value_lglpcnt$15);
    }

    else
      rem=lgleschedrem(lgl, 0);
  lglsetdonotesched(lgl, (signed int)!(rem != 0));
  lglrelstk(lgl, &lgl->esched);
  lglsparse(lgl);
  lglgc(lgl);
  lglrelstk(lgl, blocked + (signed long int)2);
  lglrelstk(lgl, blocked + (signed long int)3);
  lglrelstk(lgl, blocked + (signed long int)4);
  lgl->blkrem = (char)(rem > 0);
  lgl->blkall = (char)(all != 0 && rem != 0);
  lglprt(lgl, 1, "[block-%d] transition to [ all %d rem %d ] state", lgl->stats->blk.count, lgl->blkall, lgl->blkrem);
  lgl->simp = (char)0;
  lgl->blocking = lgl->simp;
  lgl->stats->irrprgss = lgl->stats->irrprgss + (signed long int)count;
  lglupdblkint(lgl, count);
  lglprt(lgl, 1, "[block-%d] eliminated %d blocked clauses", lgl->stats->blk.count, count);
  lglrep(lgl, 1 + (signed int)!(count != 0), (char)107);
  lglstop(lgl);
}

// lglblockcls
// file lglib.c line 11069
static signed int lglblockcls(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int lidx;
  signed int val;
  signed int count;
  signed int size;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  const signed int *l;
  struct HTS *hts;
  lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;
  hts=lglhts(lgl, lit);
  if(hts->count == 0)
    return 1;

  else
  {
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    count = 0;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      blit = *p;
      tag = blit & MASKCS;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      if(!(tag == LRGCS))
      {
        red = blit & REDCS;
        if(red == 0)
        {
          count = count + 1;
          lgl->stats->blk.res = lgl->stats->blk.res + 1l;
          lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;
          if(tag == BINCS || tag == TRNCS)
          {
            other = blit >> RMSHFT;
            val=lglmarked(lgl, other);
            if(!(val >= 0))
              goto __CPROVER_DUMP_L10;

            if(tag == TRNCS)
            {
              other2 = *p;
              val=lglmarked(lgl, other2);
              if(!(val >= 0))
                goto __CPROVER_DUMP_L10;

            }

          }

          else
          {
            lidx = blit >> RMSHFT;
            c=lglidx2lits(lgl, OCCS, 0, lidx);
            size = 0;
            l = c;
            do
            {
              other = *l;
              if(other == 0)
                break;

              val=lglmarked(lgl, other);
              size = size + 1;
              if(!(lgl->opts->blkclslim.val >= size))
                return 0;

              if(!(val >= 0))
                break;

              l = l + 1l;
            }
            while((_Bool)1);
            if(!(other == 0))
              goto __CPROVER_DUMP_L10;

          }
          return 0;
        }

      }


    __CPROVER_DUMP_L10:
      ;
    }

  __CPROVER_DUMP_L11:
    ;
    return 1;
  }
}

// lglblocking
// file lglib.c line 16961
static signed int lglblocking(struct LGL *lgl)
{
  if(lgl->opts->block.val == 0)
    return 0;

  else
  {
    signed int return_value_lglsmallirr$1;
    return_value_lglsmallirr$1=lglsmallirr(lgl);
    if(return_value_lglsmallirr$1 == 0)
      return 0;

    else
      if(!(lgl->nvars >= 3))
        return 0;

      else
        if(!(lgl->mt == 0))
          return 0;

        else
          if(!(lgl->blkrem == 0))
            return 1;

          else
            return (signed int)(lgl->stats->irrprgss > lgl->limits->blk.irrprgss);
  }
}

// lglblockinglit
// file lglib.c line 10012
static void lglblockinglit(struct LGL *lgl, signed int ilit)
{
  signed int elit;
  elit=lglexport(lgl, ilit);
  signed int sgnbit = 1 << (signed int)(elit < 0);
  struct Ext *ext;
  ext=lglelit2ext(lgl, elit);
  if((sgnbit & (signed int)ext->blocking) == 0)
  {
    ext->blocking = (unsigned int)ext->blocking | (unsigned int)sgnbit;

  __CPROVER_DUMP_L2:
    ;
    lgl->stats->blk.lits = lgl->stats->blk.lits + 1;
  }

}

// lglblocklit
// file lglib.c line 11180
static signed int lglblocklit(struct LGL *lgl, signed int lit, struct Stk *stk)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int blocked;
  signed int other;
  signed int other2;
  signed int lidx;
  signed int count;
  signed int size;
  signed int *p;
  signed int *w;
  signed int *eow;
  signed int *c;
  signed int *l;
  struct HTS *hts;
  signed char return_value_lglval$1;
  return_value_lglval$1=lglval(lgl, lit);
  signed long int tmp_post$3;
  signed int return_value_lglmtstk$7;
  signed long int tmp_post$8;
  signed int return_value_lglmtstk$9;
  signed long int tmp_post$10;
  signed int return_value_lglmtstk$11;
  signed long int tmp_post$12;
  if(!(return_value_lglval$1 == 0))
    return 0;

  else
  {
    signed int return_value_lgl2manyoccs4blk$2;
    return_value_lgl2manyoccs4blk$2=lgl2manyoccs4blk(lgl, lit);
    if(!(return_value_lgl2manyoccs4blk$2 == 0))
      return 0;

    else
    {
      hts=lglhts(lgl, lit);
      w=lglhts2wchs(lgl, hts);
      eow = w + (signed long int)hts->count;
      count = 0;
      p = w;
      for( ; !(p >= eow); p = p + 1l)
      {
        tmp_post$3 = lgl->stats->blk.steps;
        lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;
        if(tmp_post$3 >= lgl->limits->blk.steps)
          break;

        blit = *p;
        tag = blit & MASKCS;
        if(tag == TRNCS || tag == LRGCS)
          p = p + 1l;

        if(!(tag == LRGCS))
        {
          red = blit & REDCS;
          if(red == 0)
          {
            blocked = 0;
            if(tag == BINCS || tag == TRNCS)
            {
              other = blit >> RMSHFT;
              signed int return_value_lgl2manyoccs4blk$4;
              return_value_lgl2manyoccs4blk$4=lgl2manyoccs4blk(lgl, other);
              if(!(return_value_lgl2manyoccs4blk$4 == 0))
                goto __CPROVER_DUMP_L13;

              lglpushnmarkseen(lgl, other);
              if(tag == TRNCS)
              {
                other2 = *p;
                signed int return_value_lgl2manyoccs4blk$5;
                return_value_lgl2manyoccs4blk$5=lgl2manyoccs4blk(lgl, other2);
                if(!(return_value_lgl2manyoccs4blk$5 == 0))
                  goto CONTINUE;

                lglpushnmarkseen(lgl, other2);
              }

            }

            else
            {
              lidx = blit >> RMSHFT;
              c=lglidx2lits(lgl, OCCS, 0, lidx);
              size = 0;
              l = c;
              do
              {
                other = *l;
                if(other == 0)
                  break;

                if(!(other == lit))
                {
                  signed int return_value_lgl2manyoccs4blk$6;
                  return_value_lgl2manyoccs4blk$6=lgl2manyoccs4blk(lgl, other);
                  if(!(return_value_lgl2manyoccs4blk$6 == 0))
                    goto CONTINUE;

                  size = size + 1;
                  if(!(lgl->opts->blkclslim.val >= size))
                    goto CONTINUE;

                  lglpushnmarkseen(lgl, other);
                }

                l = l + 1l;
              }
              while((_Bool)1);
            }
            blocked=lglblockcls(lgl, -lit);

          CONTINUE:
            ;
            lglpopnunmarkstk(lgl, &lgl->seen);
            if(!(blocked == 0))
            {
              if(tag == BINCS)
              {
                other = blit >> RMSHFT;
                lglpushstk(lgl, stk + (signed long int)2, other);
              }

              else
                if(tag == TRNCS)
                {
                  other = blit >> RMSHFT;
                  lglpushstk(lgl, stk + (signed long int)3, other);
                  other2 = *p;
                  lglpushstk(lgl, stk + (signed long int)3, other2);
                }

                else
                {
                  lidx = blit >> RMSHFT;
                  lglpushstk(lgl, stk + (signed long int)4, lidx);
                }
            }

          }

        }


      __CPROVER_DUMP_L13:
        ;
      }
      do
      {
        return_value_lglmtstk$7=lglmtstk(stk + (signed long int)2);
        if(!(return_value_lglmtstk$7 == 0))
          break;

        tmp_post$8 = lgl->stats->blk.steps;
        lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;
        if(tmp_post$8 >= lgl->limits->blk.steps)
          break;

        count = count + 1;
        other=lglpopstk(stk + (signed long int)2);

      __CPROVER_DUMP_L15:
        ;
        lglrmbcls(lgl, lit, other, 0);
        lglepush(lgl, 0);
        lglepush(lgl, lit);
        lglepush(lgl, other);
        if(!(lgl->opts->move.val == 0))
          lglmvbcls(lgl, lit, other);

      }
      while((_Bool)1);
      do
      {
        return_value_lglmtstk$9=lglmtstk(stk + (signed long int)3);
        if(!(return_value_lglmtstk$9 == 0))
          break;

        tmp_post$10 = lgl->stats->blk.steps;
        lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;
        if(tmp_post$10 >= lgl->limits->blk.steps)
          break;

        count = count + 1;
        other2=lglpopstk(stk + (signed long int)3);
        other=lglpopstk(stk + (signed long int)3);

      __CPROVER_DUMP_L18:
        ;
        lglrmtcls(lgl, lit, other, other2, 0);
        lglepush(lgl, 0);
        lglepush(lgl, lit);
        lglepush(lgl, other);
        lglepush(lgl, other2);
        if(lgl->opts->move.val >= 2)
          lglmvtcls(lgl, lit, other, other2);

      }
      while((_Bool)1);
      do
      {
        return_value_lglmtstk$11=lglmtstk(stk + (signed long int)4);
        if(!(return_value_lglmtstk$11 == 0))
          break;

        tmp_post$12 = lgl->stats->blk.steps;
        lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;
        if(tmp_post$12 >= lgl->limits->blk.steps)
          break;

        lidx=lglpopstk(stk + (signed long int)4);
        count = count + 1;
        c=lglidx2lits(lgl, LRGCS, 0, lidx);

      __CPROVER_DUMP_L21:
        ;
        lglepush(lgl, 0);
        lglepush(lgl, lit);
        l = c;
        do
        {
          other = *l;
          if(other == 0)
            break;

          if(!(other == lit))
            lglepush(lgl, other);

          l = l + 1l;
        }
        while((_Bool)1);
        lglrmlcls(lgl, lidx, 0);
      }
      while((_Bool)1);

    __CPROVER_DUMP_L25:
      ;
      lgl->stats->blk.clauses = lgl->stats->blk.clauses + count;
      if(count >= 1)
        lglblockinglit(lgl, lit);

      lglclnstk(stk + (signed long int)2);
      lglclnstk(stk + (signed long int)3);
      lglclnstk(stk + (signed long int)4);
      return count;
    }
  }
}

// lglbnr
// file lglib.h line 100
void lglbnr(const char *name, const char *prefix, struct _IO_FILE *file)
{
  const char *p = "-Wall -O3 -DNLGLOG -DNDEBUG -DNCHKSOL -DNLGLPICOSAT ";
  const char *q;
  const char *n;
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(prefix);
  len = (signed int)((unsigned long int)78 - return_value_strlen$1);
  fprintf(file, "%s%s\n", prefix, name);
  fprintf(file, "%s\n", prefix);
  fprintf(file, "%sVersion %s %s\n", prefix, (const void *)"ala", (const void *)"b02aa1a04343558c4252b5f4a723be021964f652");
  fprintf(file, "%s\n", prefix);
  fprintf(file, "%sCopyright (C) 2010-2012 Armin Biere JKU Linz Austria.\n", prefix);
  fprintf(file, "%sAll rights reserved.\n", prefix);
  fprintf(file, "%s\n", prefix);
  fprintf(file, "%sreleased %s\n", prefix, (const void *)"Sat Oct 13 14:05:26 CEST 2012");
  fprintf(file, "%scompiled %s\n", prefix, (const void *)"Sat Jan 23 21:15:39 UTC 2016");
  fprintf(file, "%s\n", prefix);
  fprintf(file, "%s%s\n", prefix, (const void *)"gcc-5.orig (Debian 5.3.1-7) 5.3.1 20160121");
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  const char *tmp_post$4;
  do
  {
    fputs(prefix, file);
    q = p;
    do
    {
      if(!(*q == 0))
        tmp_if_expr$2 = (signed int)*q != 32 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        break;

      q = q + 1l;
    }
    while((_Bool)1);
    if(!(*q == 0))
    {
      if(!(q - p >= (signed long int)len))
        do
        {
          n = q + (signed long int)1;
          do
          {
            if(!(*n == 0))
              tmp_if_expr$3 = (signed int)*n != 32 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$3 = (_Bool)0;
            if(!tmp_if_expr$3)
              break;

            n = n + 1l;
          }
          while((_Bool)1);
          if(n - p >= (signed long int)len)
            break;

          q = n;
          if(*n == 0)
            break;

        }
        while((_Bool)1);

    }

    while(!(p >= q))
    {
      tmp_post$4 = p;
      p = p + 1l;
      fputc((signed int)*tmp_post$4, file);
    }
    fputc(10, file);
    if(*p == 0)
      break;

    p = p + 1l;
  }
  while((_Bool)1);
  fprintf(file, "%s%s\n", prefix, (const void *)"Linux mt-farm05 3.16.0-4-amd64 x86_64");
  fprintf(file, "%s\n", prefix);
  fflush(file);
}

// lglbonflict
// file lglib.c line 4011
static void lglbonflict(struct LGL *lgl, signed int lit, signed int blit)
{
  lgl->conf.lit = lit;
  lgl->conf.rsn[(signed long int)0] = blit;

__CPROVER_DUMP_L1:
  ;
}

// lglboundredl
// file lglib.c line 5182
static void lglboundredl(struct LGL *lgl)
{
  signed long int minabs;
  signed long int minrel;
  signed long int maxabs;
  signed long int maxrel;
  signed long int oldlim;
  signed long int newlim;
  oldlim = (signed long int)lgl->limits->reduce.inner;
  newlim = oldlim;
  if(!(lgl->opts->redlbound.val == 0))
  {
    lglprt(lgl, 2, "preliminary reduce limit %d before bounding", oldlim);
    minrel = (signed long int)lgl->opts->redlminrel.val;
    minrel = minrel * (((signed long int)lgl->stats->irr.clauses.cur + 99ll) / 100ll);
    minabs = (signed long int)lgl->opts->redlminabs.val;
    lglprt(lgl, 2, "minrel = %d, minabs = %d", minrel, minabs);
    if(!(minrel >= minabs))
    {
      if(!((signed long int)lgl->limits->reduce.inner >= minrel))
      {
        lglprt(lgl, 2, "relative minimum reduce limit %d hit", minrel);
        newlim = minrel;
      }

    }

    else
      if(!((signed long int)lgl->limits->reduce.inner >= minabs))
      {
        lglprt(lgl, 2, "absolute minimum reduce limit of %d hit", minabs);
        newlim = minabs;
      }

    maxrel = (signed long int)lgl->opts->redlmaxrel.val;
    maxrel = maxrel * (((signed long int)lgl->stats->irr.clauses.cur + 99ll) / 100ll);
    maxrel = maxrel + (signed long int)lgl->opts->redlmininc.val * (signed long int)lgl->limits->reduce.extra;
    maxabs = (signed long int)lgl->opts->redlmaxabs.val;
    lglprt(lgl, 2, "maxrel = %d, maxabs = %d", maxrel, maxabs);
    if(!(maxrel >= maxabs))
    {
      lgl->limits->reduce.extra = lgl->limits->reduce.extra + 1;
      if(!(maxrel >= (signed long int)lgl->limits->reduce.inner))
      {
        lglprt(lgl, 2, "relative maximum reduce limit %d hit", maxrel);
        newlim = maxrel;
      }

    }

    else
      if(!(maxabs >= (signed long int)lgl->limits->reduce.inner))
      {
        lglprt(lgl, 2, "absolute maximum reduce limit of %d hit", maxabs);
        newlim = maxabs;
      }

  }


SKIP:
  ;
  lgl->limits->reduce.inner = (signed int)newlim;
  lglprt(lgl, 2, "new reduce limit of %d redundant clauses after %lld conflicts", lgl->limits->reduce.inner, (signed long long int)lgl->stats->confs);
}

// lglbrutefork
// file lglib.h line 79
struct LGL * lglbrutefork(struct LGL *lgl, signed int complete)
{
  struct LGL *return_value_lglforkaux$1;
  return_value_lglforkaux$1=lglforkaux(lgl, 1, complete);
  return return_value_lglforkaux$1;
}

// lglbumplidx
// file lglib.c line 3491
static signed int lglbumplidx(struct LGL *lgl, signed int lidx)
{
  signed int glue = lidx & (1 << 4) - 1;
  signed int *c;
  signed int *ap;
  signed int act;
  struct Stk *lir = lgl->red + (signed long int)glue;
  lidx = lidx >> 4;
  c = lir->start + (signed long int)lidx;
  ap = c - (signed long int)1;
  act = *ap;
  if(!(act >= 0x7fffffff))
  {

  __CPROVER_DUMP_L1:
    ;
    act = act + 1;

  __CPROVER_DUMP_L2:
    ;
    *ap = act;
  }


__CPROVER_DUMP_L3:
  ;
  lgl->stats->lir[(signed long int)glue].resolved = lgl->stats->lir[(signed long int)glue].resolved + 1l;
  return (signed int)(act >= 0x7fffffff - 1);
}

// lglbumplits
// file lglib.c line 5994
static void lglbumplits(struct LGL *lgl)
{
  const signed int *p;
  lglstart(lgl, &lgl->times->bump);
  p = lgl->seen.start;
  for( ; !(p >= lgl->seen.top); p = p + 1l)
    lglvmtf(lgl, *p);
  lgldeprioritize(lgl);
  lglstop(lgl);
}

// lglbytes
// file lglib.c line 5002
unsigned long int lglbytes(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglbytes");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  return lgl->stats->bytes.current;
}

// lglca
// file lglib.c line 4161
static signed int lglca(struct LGL *lgl, signed int a, signed int b)
{
  signed int blit;
  signed int tag;
  signed int mark;
  signed int negmark;
  signed int prevmark;
  signed int c;
  signed int res;
  signed int prev;
  signed int lglca$$1$$next;
  signed int al;
  signed int bl;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  struct HTS *hts;
  unsigned long int return_value_lglcntstk$1;
  signed int tmp_post$2;
  if(a == 0)
    return b;

  else
    if(b == 0)
      return a;

    else
      if(a == b)
        return a;

      else
        if(a == -b)
          return 0;

        else
        {
          al=lglevel(lgl, a);
          bl=lglevel(lgl, b);
          if(al == 0)
            return b;

          else
            if(bl == 0)
              return a;

            else
            {
              lglcamark(lgl, a, 1);
              lglcamark(lgl, b, 2);
              lglca$$1$$next = 0;
              res = lglca$$1$$next;
              do
              {
                return_value_lglcntstk$1=lglcntstk(&lgl->$anon1.lcaseen);
                if((unsigned long int)lglca$$1$$next >= return_value_lglcntstk$1)
                  break;

                tmp_post$2 = lglca$$1$$next;
                lglca$$1$$next = lglca$$1$$next + 1;
                c=lglpeek(&lgl->$anon1.lcaseen, tmp_post$2);
                mark=lglcamarked(lgl, c);
                negmark = mark ^ 3;
                hts=lglhts(lgl, c);
                if(!(hts->count == 0))
                {
                  w=lglhts2wchs(lgl, hts);
                  eow = w + (signed long int)hts->count;
                  p = w;
                  for( ; !(p >= eow); p = p + 1l)
                  {
                    blit = *p;
                    tag = blit & MASKCS;
                    if(tag == TRNCS || tag == LRGCS)
                      p = p + 1l;

                    if(tag == BINCS)
                    {
                      prev = -(blit >> RMSHFT);
                      signed int return_value_lglevel$3;
                      return_value_lglevel$3=lglevel(lgl, prev);
                      if(!(return_value_lglevel$3 == 0))
                      {
                        signed char return_value_lglval$4;
                        return_value_lglval$4=lglval(lgl, prev);
                        if((signed int)return_value_lglval$4 >= 1)
                        {
                          prevmark=lglcamarked(lgl, prev);
                          if(prevmark >= 0)
                          {
                            if(!(mark == prevmark))
                            {
                              if(prevmark == negmark)
                              {
                                res = prev;
                                goto DONE;
                              }

                              lglcamark(lgl, prev, mark);
                            }

                          }

                        }

                      }

                    }

                  }
                }

              }
              while((_Bool)1);

            DONE:
              ;
              lglpopnunlcamarkstk(lgl, &lgl->$anon1.lcaseen);

            __CPROVER_DUMP_L17:
              ;
              return res;
            }
        }
}

// lglcamark
// file lglib.c line 4147
static void lglcamark(struct LGL *lgl, signed int lit, signed int mark)
{
  signed int newmark;
  struct AVar *av;
  av=lglavar(lgl, lit);
  newmark = mark;
  if(!(lit >= 0))
    newmark = newmark << 2;

  av->lcamark = (unsigned int)newmark;
  lglpushstk(lgl, &lgl->$anon1.lcaseen, lit);
}

// lglcamarked
// file lglib.c line 4137
static signed int lglcamarked(struct LGL *lgl, signed int lit)
{
  struct AVar *return_value_lglavar$1;
  return_value_lglavar$1=lglavar(lgl, lit);
  switch((signed int)return_value_lglavar$1->lcamark)
  {
    case 1:
      return lit < 0 ? -1 : 1;
    case 2:
      return lit < 0 ? -2 : 2;
    case 4:
      return lit < 0 ? 1 : -1;
    case 8:
      return lit < 0 ? 2 : -2;
    default:
      return 0;
  }
}

// lglcard
// file lglib.c line 16873
static void lglcard(struct LGL *lgl)
{
  signed int *card;
  signed int idx;
  signed int sign;
  signed int lit;
  signed int lglcard$$1$$start;
  signed int size;
  signed int count;
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  signed int i;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  struct Stk atmostone;
  signed long int sum;
  struct HTS *hts;
  lglstart(lgl, &lgl->times->card);
  do
    memset((void *)&atmostone, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  lglpushstk(lgl, &atmostone, 0);
  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
    card = (signed int *)return_value_lglnew$1;
  }
  while((_Bool)0);
  card = card + (signed long int)lgl->nvars;
  count = 0;
  sum = (signed long int)0;
  idx = 2;
  unsigned long int return_value_lglcntstk$3;
  unsigned long int return_value_lglcntstk$7;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = idx * sign;
      if(card[(signed long int)lit] == 0)
      {
        unsigned long int return_value_lglcntstk$2;
        return_value_lglcntstk$2=lglcntstk(&atmostone);
        lglcard$$1$$start = (signed int)return_value_lglcntstk$2;

      __CPROVER_DUMP_L5:
        ;
        lglpushstk(lgl, &atmostone, lit);
        card[(signed long int)lit] = lglcard$$1$$start;
        hts=lglhts(lgl, -lit);
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          tag = blit & MASKCS;
          if(tag == TRNCS || tag == LRGCS)
            p = p + 1l;

          if(tag == BINCS)
          {
            other = -(blit >> RMSHFT);
            if(card[(signed long int)other] == 0)
            {
              i = lglcard$$1$$start + 1;
              do
              {
                return_value_lglcntstk$3=lglcntstk(&atmostone);
                if((unsigned long int)i >= return_value_lglcntstk$3)
                  break;

                other2=lglpeek(&atmostone, i);
                signed int return_value_lglhasbin$4;
                return_value_lglhasbin$4=lglhasbin(lgl, -other, -other2);
                if(return_value_lglhasbin$4 == 0)
                  break;

                i = i + 1;
              }
              while((_Bool)1);
              unsigned long int return_value_lglcntstk$5;
              return_value_lglcntstk$5=lglcntstk(&atmostone);
              if((unsigned long int)i >= return_value_lglcntstk$5)
              {
                card[(signed long int)other] = lglcard$$1$$start;
                lglpushstk(lgl, &atmostone, other);
              }

            }

          }


        __CPROVER_DUMP_L10:
          ;
        }
        unsigned long int return_value_lglcntstk$6;
        return_value_lglcntstk$6=lglcntstk(&atmostone);
        size = (signed int)(return_value_lglcntstk$6 - (unsigned long int)lglcard$$1$$start);
        if(!(size >= 3))
        {

        __CPROVER_DUMP_L13:
          ;
          do
          {
            return_value_lglcntstk$7=lglcntstk(&atmostone);
            if((unsigned long int)lglcard$$1$$start >= return_value_lglcntstk$7)
              break;

            other=lglpopstk(&atmostone);
            card[(signed long int)other] = 0;
          }
          while((_Bool)1);
        }

        else
        {
          lglpushstk(lgl, &atmostone, 0);
          sum = sum + (signed long int)size;
          count = count + 1;
        }
      }

    }
  }
  card = card - (signed long int)lgl->nvars;
  do
  {
    lgldel(lgl, (void *)card, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
    card = ((signed int *)NULL);
  }
  while((_Bool)0);
  lglrelstk(lgl, &atmostone);
  double return_value_lglavg$8;
  return_value_lglavg$8=lglavg((double)sum, (double)count);
  lglprt(lgl, 1, "[card] found %d at-most-one constraints of average size %.1f", count, return_value_lglavg$8);
  lglstop(lgl);
}

// lglcassume
// file lglib.c line 3980
void lglcassume(struct LGL *lgl, signed int elit)
{
  signed int eidx;
  eidx=abs(elit);
  struct Ext *ext;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglcassume");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "cassume %d", elit);
    break;
  }
  lgl->stats->calls.cassume = lgl->stats->calls.cassume + 1l;
  if(eidx >= 1)
  {
    if(lgl->maxext >= eidx)
    {
      ext=lglelit2ext(lgl, elit);
      while(!(ext->melted == 0u))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglcassume");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "assuming melted literal %d", elit);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
    }

  }

  lglecassume(lgl, elit);
  lgluse(lgl);
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglcassume(lgl->clone, elit);

}

// lglcce
// file lglib.c line 11856
static signed int lglcce(struct LGL *lgl)
{
  signed int oldrem = (signed int)lgl->ccerem;
  signed int oldall = (signed int)lgl->cceall;
  signed int oldirr;
  signed int eliminated;
  signed int idx;
  signed int all;
  signed int rem;
  signed int oldvars = lgl->nvars;
  lglstart(lgl, &lgl->times->cce);
  lgl->stats->cce.count = lgl->stats->cce.count + 1;
  lgl->simp = (char)1;
  lgl->cceing = lgl->simp;
  if(lgl->level >= 1)
    lglbacktrack(lgl, 0);

  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)1 * sizeof(struct CCE) /*56ul*/ );
    lgl->$anon0.cce = (struct CCE *)return_value_lglnew$1;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew$2;
    return_value_lglnew$2=lglnew(lgl, (unsigned long int)oldvars * sizeof(signed int) /*4ul*/ );
    lgl->$anon0.cce->rem = (signed int *)return_value_lglnew$2;
  }
  while((_Bool)0);
  idx = 2;
  for( ; !(idx >= oldvars); idx = idx + 1)
    lgl->$anon0.cce->rem[(signed long int)idx] = 0x7fffffff;
  lglgc(lgl);
  lglfreezer(lgl);
  all = (signed int)(!(oldrem != 0) || !(oldall != 0));
  signed int return_value_lgleschedrem$3;
  if(!(all == 0))
    lglprt(lgl, 1, "[cce-%d] scheduling all variables this time", lgl->stats->cce.count);

  else
  {
    return_value_lgleschedrem$3=lgleschedrem(lgl, 1);
    if(return_value_lgleschedrem$3 == 0)
    {
      all = 1;
      oldrem = 0;
    }

  }
  if(all == 0)
    lgl->donotsched = (char)1;

  lgldense(lgl, 1);
  if(all == 0)
    lgl->donotsched = (char)0;

  lglsetccelim(lgl);
  oldirr = lgl->stats->irr.clauses.cur;
  signed int return_value_lglmtstk$4;
  while(lgl->mt == 0)
  {
    return_value_lglmtstk$4=lglmtstk(&lgl->esched);
    if(!(return_value_lglmtstk$4 == 0))
      break;

    if(lgl->stats->cce.steps >= lgl->limits->cce.steps)
      break;

    idx=lglpopesched(lgl);
    struct AVar *return_value_lglavar$5;
    return_value_lglavar$5=lglavar(lgl, idx);
    return_value_lglavar$5->donotcce = (unsigned int)1;
    signed int return_value_lglocc$6;
    return_value_lglocc$6=lglocc(lgl, -idx);
    signed int return_value_lglocc$7;
    return_value_lglocc$7=lglocc(lgl, idx);
    if(!(return_value_lglocc$6 >= return_value_lglocc$7))
      idx = -idx;

    lglccelit(lgl, idx);
    if(!(lgl->mt == 0))
      break;

    lglccelit(lgl, -idx);
    lgl->stats->cce.steps = lgl->stats->cce.steps + 1l;
  }
  unsigned long int return_value_lglcntstk$8;
  return_value_lglcntstk$8=lglcntstk(&lgl->esched);
  rem = (signed int)return_value_lglcntstk$8;
  double return_value_lglpcnt$9;
  if(rem == 0)
    lglprt(lgl, 1, "[cce-%d] fully completed covered clause elimination", lgl->stats->cce.count);

  else
    if(oldrem == 0)
    {
      return_value_lglpcnt$9=lglpcnt((double)rem, (double)(lgl->nvars - 2));
      lglprt(lgl, 1, "[cce-%d] incomplete covered clause elimination %d not tried %.0f%%", lgl->stats->cce.count, rem, return_value_lglpcnt$9);
    }

    else
      rem=lgleschedrem(lgl, 0);
  lglsetdonotesched(lgl, (signed int)!(rem != 0));
  lglsparse(lgl);
  lglgc(lgl);
  lglrelstk(lgl, &lgl->$anon0.cce->extend);
  lglrelstk(lgl, &lgl->$anon0.cce->cla);
  do
  {
    lgldel(lgl, (void *)lgl->$anon0.cce->rem, (unsigned long int)oldvars * sizeof(signed int) /*4ul*/ );
    lgl->$anon0.cce->rem = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->$anon0.cce, (unsigned long int)1 * sizeof(struct CCE) /*56ul*/ );
    lgl->$anon0.cce = ((struct CCE *)NULL);
  }
  while((_Bool)0);
  lgl->ccerem = (char)(rem > 0);
  lgl->cceall = (char)(all != 0 && rem != 0);
  lglprt(lgl, 1, "[cce-%d] transition to [ all %d rem %d ] state", lgl->stats->cce.count, lgl->cceall, lgl->ccerem);
  eliminated = oldirr - lgl->stats->irr.clauses.cur;
  lglprt(lgl, 1, "[cce-%d] eliminated %d covered clauses", lgl->stats->cce.count, eliminated);
  lglupdcceint(lgl, eliminated);
  lgl->simp = (char)0;
  lgl->cceing = lgl->simp;
  lglrep(lgl, 1 + (signed int)!(eliminated != 0), (char)69);
  lglstop(lgl);
  return (signed int)!(lgl->mt != 0);
}

// lglcceclause
// file lglib.c line 11542
static signed int lglcceclause(struct LGL *lgl, const signed int *c, const signed int *ignwch, signed int igntag)
{
  signed int other;
  signed int res;
  signed int nextala;
  signed int nextcla;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int other2;
  const signed int *p;
  const signed int *eow;
  const signed int *w;
  const signed int *d;
  const signed int *q;
  signed int unit;
  signed int first;
  signed int old;
  signed int prev;
  struct HTS *hts;
  signed int *r;

__CPROVER_DUMP_L1:
  ;
  p = c;
  do
  {
    other = *p;
    if(other == 0)
      break;

    lglpushstk(lgl, &lgl->seen, other);
    lglpushstk(lgl, &lgl->$anon0.cce->cla, other);
    lglsignedmark(lgl, other);
    p = p + 1l;
  }
  while((_Bool)1);
  res = 0;
  nextala = res;
  nextcla = nextala;

ALA:
  ;
  unsigned long int return_value_lglcntstk$1;
  signed int tmp_post$2;
  signed int return_value_lglsignedmarked$3;
  signed int return_value_lglsignedmarked$8;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$13;
  unsigned long int return_value_lglcntstk$14;
  signed int tmp_post$15;
  signed int return_value_lglifrozen$16;
  unsigned long int return_value_lglcntstk$17;
  signed int return_value_lglsignedmarked$24;
  signed int return_value_lglsignedmarked$25;
  signed int *tmp_post$27;
  _Bool tmp_if_expr$31;
  signed int *tmp_post$30;
  signed int return_value_lglsignedmarked$32;
  signed int return_value_lglsignedmarked2$34;
  signed int *tmp_post$33;
  unsigned long int return_value_lglcntstk$35;
  _Bool tmp_if_expr$36;
  unsigned long int return_value_lglcntstk$38;
  while((_Bool)1)
  {
    if(res == 0)
    {
      return_value_lglcntstk$1=lglcntstk(&lgl->seen);
      if(!((unsigned long int)nextala >= return_value_lglcntstk$1))
      {
        tmp_post$2 = nextala;
        nextala = nextala + 1;
        lit=lglpeek(&lgl->seen, tmp_post$2);
        hts=lglhts(lgl, lit);
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; res == 0 && !(p >= eow); p = p + 1l)
        {
          lgl->stats->cce.steps = lgl->stats->cce.steps + 1l;
          if(lgl->stats->cce.steps >= lgl->limits->cce.steps)
            goto DONE;

          blit = *p;
          tag = blit & MASKCS;
          if(tag == TRNCS || tag == LRGCS)
            p = p + 1l;

          if(!(p == ignwch))
          {
            if(!(tag == LRGCS))
            {
              if((REDCS & blit) == 0)
              {
                other = blit >> RMSHFT;
                if(tag == BINCS)
                {
                  signed int return_value_lglsignedmarked$4;
                  return_value_lglsignedmarked$4=lglsignedmarked(lgl, -other);
                  if(!(return_value_lglsignedmarked$4 == 0))
                    goto __CPROVER_DUMP_L33;

                  else
                  {
                    return_value_lglsignedmarked$3=lglsignedmarked(lgl, other);
                    if(!(return_value_lglsignedmarked$3 == 0))
                    {
                      if(igntag == BINCS)
                      {
                        if(*c == lit)
                        {
                          if(c[1l] == other)
                            goto __CPROVER_DUMP_L33;

                        }

                        if(c[1l] == lit)
                        {
                          if(*c == other)
                            goto __CPROVER_DUMP_L33;

                        }

                      }


                    __CPROVER_DUMP_L9:
                      ;
                      res = 1;
                    }

                    else
                    {

                    __CPROVER_DUMP_L10:
                      ;
                      lglsignedmark(lgl, -other);
                      lglpushstk(lgl, &lgl->seen, -other);
                    }
                  }
                }

                else
                  if(tag == TRNCS)
                  {
                    signed int return_value_lglsignedmarked$5;
                    return_value_lglsignedmarked$5=lglsignedmarked(lgl, -other);
                    if(!(return_value_lglsignedmarked$5 == 0))
                      goto __CPROVER_DUMP_L33;

                    other2 = *p;
                    signed int return_value_lglsignedmarked$6;
                    return_value_lglsignedmarked$6=lglsignedmarked(lgl, -other2);
                    if(!(return_value_lglsignedmarked$6 == 0))
                      goto __CPROVER_DUMP_L33;

                    signed int return_value_lglsignedmarked$9;
                    return_value_lglsignedmarked$9=lglsignedmarked(lgl, other);
                    if(!(return_value_lglsignedmarked$9 == 0))
                    {
                      signed int return_value_lglsignedmarked$7;
                      return_value_lglsignedmarked$7=lglsignedmarked(lgl, other2);
                      if(!(return_value_lglsignedmarked$7 == 0))
                      {
                        if(igntag == TRNCS)
                        {
                          if(*c == lit)
                          {
                            if(c[1l] == other)
                            {
                              if(c[2l] == other2)
                                goto __CPROVER_DUMP_L33;

                            }

                          }

                          if(*c == lit)
                          {
                            if(c[2l] == other)
                            {
                              if(c[1l] == other2)
                                goto __CPROVER_DUMP_L33;

                            }

                          }

                          if(c[1l] == lit)
                          {
                            if(*c == other)
                            {
                              if(c[2l] == other2)
                                goto __CPROVER_DUMP_L33;

                            }

                          }

                          if(c[1l] == lit)
                          {
                            if(c[2l] == other)
                            {
                              if(*c == other2)
                                goto __CPROVER_DUMP_L33;

                            }

                          }

                          if(c[2l] == lit)
                          {
                            if(*c == other)
                            {
                              if(c[1l] == other2)
                                goto __CPROVER_DUMP_L33;

                            }

                          }

                          if(c[2l] == lit)
                          {
                            if(c[1l] == other)
                            {
                              if(*c == other2)
                                goto __CPROVER_DUMP_L33;

                            }

                          }

                        }


                      __CPROVER_DUMP_L19:
                        ;
                        res = 1;
                      }

                      else
                      {

                      __CPROVER_DUMP_L20:
                        ;
                        lglsignedmark(lgl, -other2);
                        lglpushstk(lgl, &lgl->seen, -other2);
                      }
                    }

                    else
                    {
                      return_value_lglsignedmarked$8=lglsignedmarked(lgl, other2);
                      if(!(return_value_lglsignedmarked$8 == 0))
                      {

                      __CPROVER_DUMP_L23:
                        ;
                        lglsignedmark(lgl, -other);
                        lglpushstk(lgl, &lgl->seen, -other);
                      }

                    }
                  }

                  else
                  {
                    d=lglidx2lits(lgl, OCCS, 0, other);
                    if(!(d == c))
                    {
                      unit = 0;
                      q = d;
                      do
                      {
                        other = *q;
                        if(other == 0)
                          break;

                        if(!(other == lit))
                        {
                          signed int return_value_lglsignedmarked$10;
                          return_value_lglsignedmarked$10=lglsignedmarked(lgl, -other);
                          if(!(return_value_lglsignedmarked$10 == 0))
                            break;

                          signed int return_value_lglsignedmarked$11;
                          return_value_lglsignedmarked$11=lglsignedmarked(lgl, other);
                          if(return_value_lglsignedmarked$11 == 0)
                          {
                            if(!(unit == 0))
                              break;

                            unit = -other;
                          }

                        }

                        q = q + 1l;
                      }
                      while((_Bool)1);
                      if(other == 0)
                      {
                        if(unit == 0)
                        {

                        __CPROVER_DUMP_L31:
                          ;
                          res = 1;
                        }

                        else
                        {

                        __CPROVER_DUMP_L32:
                          ;
                          lglsignedmark(lgl, unit);
                          lglpushstk(lgl, &lgl->seen, unit);
                        }
                      }

                    }

                  }
              }

            }

          }


        __CPROVER_DUMP_L33:
          ;
        }
        goto ALA;
      }

    }

    if(!(res == 0))
      tmp_if_expr$12 = (_Bool)1;

    else
      tmp_if_expr$12 = !(lgl->opts->block.val != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$12)
      tmp_if_expr$13 = (_Bool)1;

    else
      tmp_if_expr$13 = lgl->opts->cce.val < 3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$13)
      goto SKIPCLA;


  __CPROVER_DUMP_L40:
    ;
    if(!(res == 0))
      goto SKIPCLA;

    return_value_lglcntstk$14=lglcntstk(&lgl->$anon0.cce->cla);
    if((unsigned long int)nextcla >= return_value_lglcntstk$14)
      goto SKIPCLA;

    tmp_post$15 = nextcla;
    nextcla = nextcla + 1;
    lit=lglpeek(&lgl->$anon0.cce->cla, tmp_post$15);
    return_value_lglifrozen$16=lglifrozen(lgl, lit);
    if(!(return_value_lglifrozen$16 == 0))
      goto __CPROVER_DUMP_L92;

    hts=lglhts(lgl, -lit);
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    return_value_lglcntstk$17=lglcntstk(&lgl->$anon0.cce->cla);
    old = (signed int)return_value_lglcntstk$17;
    first = 1;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      lgl->stats->cce.steps = lgl->stats->cce.steps + 1l;
      if(lgl->stats->cce.steps >= lgl->limits->cce.steps)
        goto DONE;

      blit = *p;
      tag = blit & MASKCS;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      if(!(tag == LRGCS))
      {
        if((REDCS & blit) == 0)
        {
          other = blit >> RMSHFT;
          if(!(first == 0))
          {
            if(tag == BINCS)
            {
              signed int return_value_lglsignedmarked$18;
              return_value_lglsignedmarked$18=lglsignedmarked(lgl, -other);
              if(!(return_value_lglsignedmarked$18 == 0))
                goto __CPROVER_DUMP_L79;

              signed int return_value_lglsignedmarked$19;
              return_value_lglsignedmarked$19=lglsignedmarked(lgl, other);
              if(return_value_lglsignedmarked$19 == 0)
                lglpushstk(lgl, &lgl->$anon0.cce->cla, other);

            }

            else
              if(tag == TRNCS)
              {
                signed int return_value_lglsignedmarked$20;
                return_value_lglsignedmarked$20=lglsignedmarked(lgl, -other);
                if(!(return_value_lglsignedmarked$20 == 0))
                  goto __CPROVER_DUMP_L79;

                signed int return_value_lglsignedmarked$21;
                return_value_lglsignedmarked$21=lglsignedmarked(lgl, -(*p));
                if(!(return_value_lglsignedmarked$21 == 0))
                  goto __CPROVER_DUMP_L79;

                signed int return_value_lglsignedmarked$22;
                return_value_lglsignedmarked$22=lglsignedmarked(lgl, other);
                if(return_value_lglsignedmarked$22 == 0)
                  lglpushstk(lgl, &lgl->$anon0.cce->cla, other);

                signed int return_value_lglsignedmarked$23;
                return_value_lglsignedmarked$23=lglsignedmarked(lgl, *p);
                if(return_value_lglsignedmarked$23 == 0)
                  lglpushstk(lgl, &lgl->$anon0.cce->cla, *p);

              }

              else
              {
                d=lglidx2lits(lgl, OCCS, 0, other);
                q = d;
                do
                {
                  other = *q;
                  if(other == 0)
                    break;

                  if(!(other == -lit))
                  {
                    return_value_lglsignedmarked$24=lglsignedmarked(lgl, -other);
                    if(!(return_value_lglsignedmarked$24 == 0))
                      break;

                  }

                  q = q + 1l;
                }
                while((_Bool)1);
                if(!(other == 0))
                  goto __CPROVER_DUMP_L79;

                q = d;
                do
                {
                  other = *q;
                  if(other == 0)
                    break;

                  if(!(other == -lit))
                  {
                    return_value_lglsignedmarked$25=lglsignedmarked(lgl, other);
                    if(return_value_lglsignedmarked$25 == 0)
                      lglpushstk(lgl, &lgl->$anon0.cce->cla, other);

                  }

                  q = q + 1l;
                }
                while((_Bool)1);
              }
            first = 0;
          }

          else
          {
            r = lgl->$anon0.cce->cla.start + (signed long int)old;
            if(tag == BINCS)
            {
              signed int return_value_lglsignedmarked$26;
              return_value_lglsignedmarked$26=lglsignedmarked(lgl, -other);
              if(!(return_value_lglsignedmarked$26 == 0))
                goto __CPROVER_DUMP_L79;

              q = r;
              for( ; !(q >= lgl->$anon0.cce->cla.top); q = q + 1l)
                if(*q == other)
                {
                  tmp_post$27 = r;
                  r = r + 1l;
                  *tmp_post$27 = *q;
                }

            }

            else
              if(tag == TRNCS)
              {
                signed int return_value_lglsignedmarked$28;
                return_value_lglsignedmarked$28=lglsignedmarked(lgl, -other);
                if(!(return_value_lglsignedmarked$28 == 0))
                  goto __CPROVER_DUMP_L79;

                other2 = *p;
                signed int return_value_lglsignedmarked$29;
                return_value_lglsignedmarked$29=lglsignedmarked(lgl, -other2);
                if(!(return_value_lglsignedmarked$29 == 0))
                  goto __CPROVER_DUMP_L79;

                q = r;
                for( ; !(q >= lgl->$anon0.cce->cla.top); q = q + 1l)
                {
                  if(*q == other)
                    tmp_if_expr$31 = (_Bool)1;

                  else
                    tmp_if_expr$31 = *q == other2 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr$31)
                  {
                    tmp_post$30 = r;
                    r = r + 1l;
                    *tmp_post$30 = *q;
                  }

                }
              }

              else
              {
                d=lglidx2lits(lgl, OCCS, 0, other);
                q = d;
                do
                {
                  other = *q;
                  if(other == 0)
                    break;

                  if(!(other == -lit))
                  {
                    return_value_lglsignedmarked$32=lglsignedmarked(lgl, -other);
                    if(!(return_value_lglsignedmarked$32 == 0))
                      break;

                  }

                  q = q + 1l;
                }
                while((_Bool)1);
                if(!(other == 0))
                  goto __CPROVER_DUMP_L79;

                q = d;
                do
                {
                  other = *q;
                  if(other == 0)
                    break;

                  if(!(other == -lit))
                    lglsignedmark2(lgl, other);

                  q = q + 1l;
                }
                while((_Bool)1);
                q = r;
                for( ; !(q >= lgl->$anon0.cce->cla.top); q = q + 1l)
                {
                  other = *q;
                  return_value_lglsignedmarked2$34=lglsignedmarked2(lgl, other);
                  if(!(return_value_lglsignedmarked2$34 == 0))
                  {
                    tmp_post$33 = r;
                    r = r + 1l;
                    *tmp_post$33 = other;
                  }

                }
                q = d;
                do
                {
                  other = *q;
                  if(other == 0)
                    break;

                  if(!(other == -lit))
                    lglsignedunmark2(lgl, other);

                  q = q + 1l;
                }
                while((_Bool)1);
              }
            lgl->$anon0.cce->cla.top = r;
            if(lgl->$anon0.cce->cla.top == lgl->$anon0.cce->cla.start + (signed long int)old)
              break;

          }
        }

      }


    __CPROVER_DUMP_L79:
      ;
    }
    return_value_lglcntstk$35=lglcntstk(&lgl->$anon0.cce->cla);
    if(!((unsigned long int)old >= return_value_lglcntstk$35))
    {
      nextcla = 0;
      lglpushstk(lgl, &lgl->$anon0.cce->extend, 0);
      lglpushstk(lgl, &lgl->$anon0.cce->extend, lit);
      q = lgl->$anon0.cce->cla.start;
      for( ; !(q >= lgl->$anon0.cce->cla.start + (signed long int)old); q = q + 1l)
        if(!(*q == lit))
          lglpushstk(lgl, &lgl->$anon0.cce->extend, *q);

    }

    q = lgl->$anon0.cce->cla.start + (signed long int)old;
    do
    {
      if(res == 0)
        tmp_if_expr$36 = q < lgl->$anon0.cce->cla.top ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$36 = (_Bool)0;
      if(!tmp_if_expr$36)
        break;

      signed int return_value_lglsignedmarked$37;
      return_value_lglsignedmarked$37=lglsignedmarked(lgl, -(*q));
      if(!(return_value_lglsignedmarked$37 == 0))
      {

      __CPROVER_DUMP_L87:
        ;
        res = 1;
      }

      else
      {

      __CPROVER_DUMP_L88:
        ;
        lglpushstk(lgl, &lgl->seen, *q);
        lglsignedmark(lgl, *q);
      }
      q = q + 1l;
    }
    while((_Bool)1);
    if(!(p == eow) || !(res == 0))
      break;

    return_value_lglcntstk$38=lglcntstk(&lgl->seen);
    if((unsigned long int)nextala >= return_value_lglcntstk$38)
      break;

  }

__CPROVER_DUMP_L92:
  ;
  goto __CPROVER_DUMP_L40;

SKIPCLA:
  ;
  signed int return_value_lglifrozen$39;
  if(!(res == 0))
  {

  __CPROVER_DUMP_L94:
    ;
    lgl->stats->cce.ate = lgl->stats->cce.ate + 1;
  }

  else
    if(!(lgl->opts->block.val == 0))
    {
      if(lgl->opts->cce.val >= 2)
      {
        p = lgl->$anon0.cce->cla.start;
        for( ; !(p >= lgl->$anon0.cce->cla.top); p = p + 1l)
        {
          other = *p;
          return_value_lglifrozen$39=lglifrozen(lgl, other);
          if(return_value_lglifrozen$39 == 0)
          {
            res=lglabce(lgl, other);
            if(!(res == 0))
              break;

          }

        }
        if(!(res == 0))
        {

        __CPROVER_DUMP_L99:
          ;
          lglpushstk(lgl, &lgl->$anon0.cce->extend, 0);
          lglpushstk(lgl, &lgl->$anon0.cce->extend, other);
          p = lgl->$anon0.cce->cla.start;
          for( ; !(p >= lgl->$anon0.cce->cla.top); p = p + 1l)
            if(!(*p == other))
              lglpushstk(lgl, &lgl->$anon0.cce->extend, *p);

          lgl->stats->cce.abce = lgl->stats->cce.abce + 1;
        }

      }

    }

  if(!(res == 0))
    lgl->stats->cce.eliminated = lgl->stats->cce.eliminated + 1;


DONE:
  ;
  lglpopnunmarkstk(lgl, &lgl->seen);
  lglclnstk(&lgl->$anon0.cce->cla);
  signed int return_value_lglmtstk$40;
  if(!(res == 0))
  {
    return_value_lglmtstk$40=lglmtstk(&lgl->$anon0.cce->extend);
    if(return_value_lglmtstk$40 == 0)
    {
      prev = 0x7fffffff;
      p = lgl->$anon0.cce->extend.start;
      for( ; !(p >= lgl->$anon0.cce->extend.top); p = p + 1l)
      {
        lit = *p;
        lglepush(lgl, lit);
        if(prev == 0)
          lglblockinglit(lgl, lit);

        prev = lit;
      }
    }

  }

  lglclnstk(&lgl->$anon0.cce->extend);
  return res;
}

// lglcceing
// file lglib.c line 11478
static signed int lglcceing(struct LGL *lgl)
{
  if(lgl->opts->cce.val == 0)
    return 0;

  else
  {
    signed int return_value_lglsmallirr$1;
    return_value_lglsmallirr$1=lglsmallirr(lgl);
    if(return_value_lglsmallirr$1 == 0)
      return 0;

    else
      return 1;
  }
}

// lglccelit
// file lglib.c line 11808
static void lglccelit(struct LGL *lgl, signed int lit)
{
  signed int cls[4l];
  signed int blit;
  signed int tag;
  signed int *c;
  signed int other;
  signed int lidx;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *l;
  struct HTS *hts;
  signed int return_value_lglisfree$1;
  return_value_lglisfree$1=lglisfree(lgl, lit);
  signed int return_value_abs$12;
  signed int return_value_abs$13;
  if(!(return_value_lglisfree$1 == 0))
  {
    signed int return_value_lglrem$4;
    return_value_lglrem$4=lglrem(lgl);
    signed int return_value_abs$5;
    return_value_abs$5=abs(lit);
    if(!(return_value_lglrem$4 >= lgl->$anon0.cce->rem[(signed long int)return_value_abs$5]))
    {

    __CPROVER_DUMP_L2:
      ;
      lglbasicprobelit(lgl, -lit);
      signed int return_value_lglflush$2;
      return_value_lglflush$2=lglflush(lgl);
      if(return_value_lglflush$2 == 0)
        goto __CPROVER_DUMP_L18;

      signed int return_value_abs$3;
      return_value_abs$3=abs(lit);
      lgl->$anon0.cce->rem[(signed long int)return_value_abs$3]=lglrem(lgl);
    }


  __CPROVER_DUMP_L4:
    ;
    hts=lglhts(lgl, lit);
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    cls[(signed long int)0] = lit;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      lgl->stats->cce.steps = lgl->stats->cce.steps + 1l;
      if(lgl->stats->cce.steps >= lgl->limits->cce.steps)
        break;

      blit = *p;
      tag = blit & MASKCS;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      if(!(tag == LRGCS))
      {
        if((REDCS & blit) == 0)
        {
          other = blit >> RMSHFT;
          lidx = other;
          c = cls;
          if(tag == BINCS)
          {
            signed int return_value_abs$6;
            return_value_abs$6=abs(other);
            signed int return_value_abs$7;
            return_value_abs$7=abs(lit);
            if(!(return_value_abs$6 >= return_value_abs$7))
              goto __CPROVER_DUMP_L16;

            cls[(signed long int)1] = other;
            cls[(signed long int)2] = 0;
          }

          else
            if(tag == TRNCS)
            {
              signed int return_value_abs$8;
              return_value_abs$8=abs(other);
              signed int return_value_abs$9;
              return_value_abs$9=abs(lit);
              if(!(return_value_abs$8 >= return_value_abs$9))
                goto __CPROVER_DUMP_L16;

              signed int return_value_abs$10;
              return_value_abs$10=abs(*p);
              signed int return_value_abs$11;
              return_value_abs$11=abs(lit);
              if(!(return_value_abs$10 >= return_value_abs$11))
                goto __CPROVER_DUMP_L16;

              cls[(signed long int)1] = other;
              cls[(signed long int)2] = *p;
              cls[(signed long int)3] = 0;
            }

            else
            {
              c=lglidx2lits(lgl, OCCS, 0, lidx);
              l = c;
              do
              {
                other = *l;
                if(other == 0)
                  break;

                return_value_abs$12=abs(other);
                return_value_abs$13=abs(lit);
                if(!(return_value_abs$12 >= return_value_abs$13))
                  break;

                l = l + 1l;
              }
              while((_Bool)1);
              if(!(other == 0))
                goto __CPROVER_DUMP_L16;

            }
          signed int return_value_lglcceclause$14;
          return_value_lglcceclause$14=lglcceclause(lgl, c, p, tag);
          if(!(return_value_lglcceclause$14 == 0))
          {
            if(tag == BINCS)
              lglrmvbcls(lgl, lit, other);

            else
              if(tag == TRNCS)
                lglrmvtcls(lgl, lit, other, *p);

              else
                lglrmlcls(lgl, lidx, 0);
            goto __CPROVER_DUMP_L18;
          }

        }

      }


    __CPROVER_DUMP_L16:
      ;
    }
  }


__CPROVER_DUMP_L17:
  ;

__CPROVER_DUMP_L18:
  ;
}

// lglceilld
// file lglib.c line 984
static signed int lglceilld(signed int n)
{
  signed int res;
  res=lglfloorld(n);
  signed int return_value_lglispow2$1;
  return_value_lglispow2$1=lglispow2(n);
  if(return_value_lglispow2$1 == 0)
    res = res + 1;

  return res;
}

// lglceilsqrt32
// file lglib.c line 990
static signed int lglceilsqrt32(signed int x)
{
  signed int l = 0;
  signed int m;
  signed int r;
  signed int mm;
  signed int rr;
  if(!(x >= 1))
    return 0;

  else
  {
    r = 46340;
    rr = r * r;
    if(x >= rr)
      return r;

    else
      while((_Bool)1)
      {
        if(r + -l == 1)
          return r;

        m = (l + r) / 2;
        mm = m * m;
        if(mm == x)
          return m;

        if(!(mm >= x))
          l = m;

        else
        {
          r = m;
          rr = mm;
        }
      }
  }
}

// lglceilsqrt64
// file lglib.c line 1014
static signed int lglceilsqrt64(signed int x)
{
  signed long int l = (signed long int)0;
  signed long int m;
  signed long int r;
  signed long int mm;
  signed long int rr;
  if(!(x >= 1))
    return 0;

  else
  {
    r = 3037000499ll;
    rr = r * r;
    if((signed long int)x >= rr)
      return (signed int)r;

    else
      while((_Bool)1)
      {
        if(r + -l == 1l)
          return (signed int)r;

        m = (l + r) / (signed long int)2;
        mm = m * m;
        if(mm == (signed long int)x)
          return (signed int)m;

        if(!(mm >= (signed long int)x))
          l = m;

        else
        {
          r = m;
          rr = mm;
        }
      }
  }
}

// lglcgeq
// file lglib.c line 12379
static signed int lglcgeq(struct LGL *lgl, signed int a, signed int b)
{
  signed int return_value_lglcgrepr$1;
  return_value_lglcgrepr$1=lglcgrepr(lgl, a);
  signed int return_value_lglcgrepr$2;
  return_value_lglcgrepr$2=lglcgrepr(lgl, b);
  return (signed int)(return_value_lglcgrepr$1 == return_value_lglcgrepr$2);
}

// lglcgextractands
// file lglib.c line 12613
static signed int lglcgextractands(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  signed int lidx;
  signed int size;
  signed int tmp;
  signed int repr;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *l;
  struct HTS *hts;
  signed char val;
  signed int *c;
  _Bool tmp_if_expr$9;
  signed int return_value_lglhasbin$8;
  signed int return_value_lglhasbin$7;
  signed int return_value_lglcmpocc$21;
  signed int return_value_lglmtstk$22;
  signed int return_value_lglcmpocc$24;
  if(lgl->opts->cgrextand.val == 0)
    return 1;

  else
  {
    repr=lglcgrepr(lgl, lit);
    signed char return_value_lglval$1;
    return_value_lglval$1=lglval(lgl, lit);
    if(!(return_value_lglval$1 == 0))
      return 1;

    else
    {
      signed int return_value_abs$2;
      return_value_abs$2=abs(repr);
      if(return_value_abs$2 == 1)
        return 1;

      else
      {
        hts=lglhts(lgl, lit);
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          signed int return_value_lglincextractlimhit$3;
          return_value_lglincextractlimhit$3=lglincextractlimhit(lgl);
          if(!(return_value_lglincextractlimhit$3 == 0))
            return 0;

          blit = *p;
          tag = blit & MASKCS;
          if(tag == BINCS)
          {
            if(lgl->opts->cgrexteq.val == 0)
            {
              if(lgl->opts->cgrextunits.val == 0)
                goto __CPROVER_DUMP_L78;

            }

            tmp = blit >> RMSHFT;
            val=lglval(lgl, tmp);
            if(!(val == 0))
              goto __CPROVER_DUMP_L78;

            repr=lglcgrepr(lgl, lit);
            other=lglcgrepr(lgl, -tmp);
            if(repr == other)
              goto __CPROVER_DUMP_L78;

            signed int return_value_lglincextractlimhit$4;
            return_value_lglincextractlimhit$4=lglincextractlimhit(lgl);
            if(!(return_value_lglincextractlimhit$4 == 0))
              return 0;

            if(!(lgl->opts->cgrextunits.val == 0) && !(repr == 1))
            {
              return_value_lglhasbin$8=lglhasbin(lgl, lit, -tmp);
              tmp_if_expr$9 = return_value_lglhasbin$8 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$9 = (_Bool)0;
            if(tmp_if_expr$9)
            {

            __CPROVER_DUMP_L12:
              ;
              lgl->$anon0.cgr->extracted.units = lgl->$anon0.cgr->extracted.units + 1;
              lgl->stats->cgr.units = lgl->stats->cgr.units + 1;
              if(repr == -1)
              {

              __CPROVER_DUMP_L13:
                ;
                lgl->mt = 1;
                return 0;
              }

              signed int return_value_lglcgunit$5;
              return_value_lglcgunit$5=lglcgunit(lgl, repr);
              if(return_value_lglcgunit$5 == 0)
                return 0;

              signed char return_value_lglval$6;
              return_value_lglval$6=lglval(lgl, lit);
              if(!(return_value_lglval$6 == 0))
                return 1;

            }

            else
              if(!(lgl->opts->cgrexteq.val == 0))
              {
                return_value_lglhasbin$7=lglhasbin(lgl, -lit, -tmp);
                if(!(return_value_lglhasbin$7 == 0))
                {
                  lgl->$anon0.cgr->extracted.eq = lgl->$anon0.cgr->extracted.eq + 1;
                  lgl->stats->cgr.eq = lgl->stats->cgr.eq + 1;

                __CPROVER_DUMP_L18:
                  ;
                  if(repr == -other)
                  {

                  __CPROVER_DUMP_L19:
                    ;
                    lgl->mt = 1;
                    return 0;
                  }

                  lglcgmerge(lgl, other, repr);
                }

              }

            goto __CPROVER_DUMP_L78;
          }

          if(tag == TRNCS || tag == LRGCS)
            p = p + 1l;

          if(!(tag == LRGCS))
          {
            if(tag == TRNCS)
            {
              other = blit >> RMSHFT;
              other2 = *p;
              signed int return_value_lglocc$10;
              return_value_lglocc$10=lglocc(lgl, other);
              signed int return_value_lglocc$11;
              return_value_lglocc$11=lglocc(lgl, other2);
              if(!(return_value_lglocc$11 >= return_value_lglocc$10))
                do
                {
                  signed int lglcgextractands$$1$$2$$1$$2$$1$$TMP = other;
                  other = other2;
                  other2 = lglcgextractands$$1$$2$$1$$2$$1$$TMP;
                }
                while((_Bool)0);

              signed int return_value_lglincextractlimhit$12;
              return_value_lglincextractlimhit$12=lglincextractlimhit(lgl);
              if(!(return_value_lglincextractlimhit$12 == 0))
                return 0;

              signed int return_value_lglhasbin$13;
              return_value_lglhasbin$13=lglhasbin(lgl, -lit, -other);
              if(return_value_lglhasbin$13 == 0)
                goto __CPROVER_DUMP_L78;

              signed int return_value_lglincextractlimhit$14;
              return_value_lglincextractlimhit$14=lglincextractlimhit(lgl);
              if(!(return_value_lglincextractlimhit$14 == 0))
                return 0;

              signed int return_value_lglhasbin$15;
              return_value_lglhasbin$15=lglhasbin(lgl, -lit, -other2);
              if(return_value_lglhasbin$15 == 0)
                goto __CPROVER_DUMP_L78;

              lglnewbingate(lgl, (enum GTag)ANDTAG, lit, other, other2);
            }

            else
            {
              signed int return_value_lglincextractlimhit$16;
              return_value_lglincextractlimhit$16=lglincextractlimhit(lgl);
              if(!(return_value_lglincextractlimhit$16 == 0))
                return 0;

              lidx = blit >> RMSHFT;
              c=lglidx2lits(lgl, OCCS, blit & REDCS, lidx);
              l = c;
              do
              {
                other = *l;
                if(other == 0)
                  break;

                if(!(other == lit))
                  lglpushstk(lgl, &lgl->clause, other);

                l = l + 1l;
              }
              while((_Bool)1);
              size = (signed int)((l - c) - (signed long int)1);
              do
              {
                signed int *AA = lgl->clause.start;
                signed int NN = size;
                do
                {
                  signed int L = 0;
                  signed int R = NN - 1;
                  signed int M;
                  signed int LL;
                  signed int RR;
                  signed int I;
                  if(!(R + -L >= 11))
                    break;

                  do
                  {
                    M = (L + R) / 2;
                    do
                    {
                      signed int TMP = AA[(signed long int)M];
                      AA[(signed long int)M] = AA[(signed long int)(R - 1)];
                      AA[(signed long int)(R - 1)] = TMP;
                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpocc$17;
                      return_value_lglcmpocc$17=lglcmpocc(lgl, *(&AA[(signed long int)L]), *(&AA[(signed long int)(R - 1)]));
                      if(return_value_lglcmpocc$17 >= 1)
                        do
                        {
                          signed int lglcgextractands$$1$$2$$1$$3$$2$$1$$1$$1$$2$$1$$TMP = AA[(signed long int)L];
                          AA[(signed long int)L] = AA[(signed long int)(R - 1)];
                          AA[(signed long int)(R - 1)] = lglcgextractands$$1$$2$$1$$3$$2$$1$$1$$1$$2$$1$$TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpocc$18;
                      return_value_lglcmpocc$18=lglcmpocc(lgl, *(&AA[(signed long int)L]), *(&AA[(signed long int)R]));
                      if(return_value_lglcmpocc$18 >= 1)
                        do
                        {
                          signed int lglcgextractands$$1$$2$$1$$3$$2$$1$$1$$1$$3$$1$$TMP = AA[(signed long int)L];
                          AA[(signed long int)L] = AA[(signed long int)R];
                          AA[(signed long int)R] = lglcgextractands$$1$$2$$1$$3$$2$$1$$1$$1$$3$$1$$TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpocc$19;
                      return_value_lglcmpocc$19=lglcmpocc(lgl, *(&AA[(signed long int)(R - 1)]), *(&AA[(signed long int)R]));
                      if(return_value_lglcmpocc$19 >= 1)
                        do
                        {
                          signed int lglcgextractands$$1$$2$$1$$3$$2$$1$$1$$1$$4$$1$$TMP = AA[(signed long int)(R - 1)];
                          AA[(signed long int)(R - 1)] = AA[(signed long int)R];
                          AA[(signed long int)R] = lglcgextractands$$1$$2$$1$$3$$2$$1$$1$$1$$4$$1$$TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      signed int PIVOT;
                      signed int J = R - 1;
                      I = (L + 1) - 1;
                      PIVOT = AA[(signed long int)J];
                      do
                      {

                      __CPROVER_DUMP_L49:
                        ;
                        I = I + 1;
                        signed int return_value_lglcmpocc$20;
                        return_value_lglcmpocc$20=lglcmpocc(lgl, *(&AA[(signed long int)I]), *(&PIVOT));
                        if(!(return_value_lglcmpocc$20 >= 0))
                          goto __CPROVER_DUMP_L49;

                        do
                        {
                          J = J - 1;
                          return_value_lglcmpocc$21=lglcmpocc(lgl, *(&PIVOT), *(&AA[(signed long int)J]));
                          if(return_value_lglcmpocc$21 >= 0)
                            break;

                          if(J == 1 + L)
                            break;

                        }
                        while((_Bool)1);
                        if(I >= J)
                          break;

                        do
                        {
                          signed int lglcgextractands$$1$$2$$1$$3$$2$$1$$1$$1$$5$$1$$1$$1$$TMP = AA[(signed long int)I];
                          AA[(signed long int)I] = AA[(signed long int)J];
                          AA[(signed long int)J] = lglcgextractands$$1$$2$$1$$3$$2$$1$$1$$1$$5$$1$$1$$1$$TMP;
                        }
                        while((_Bool)0);
                      }
                      while((_Bool)1);
                      do
                      {
                        signed int lglcgextractands$$1$$2$$1$$3$$2$$1$$1$$1$$5$$2$$TMP = AA[(signed long int)I];
                        AA[(signed long int)I] = AA[(signed long int)(R - 1)];
                        AA[(signed long int)(R - 1)] = lglcgextractands$$1$$2$$1$$3$$2$$1$$1$$1$$5$$2$$TMP;
                      }
                      while((_Bool)0);
                    }
                    while((_Bool)0);
                    if(!(I + -L >= R + -I))
                    {
                      LL = I + 1;
                      RR = R;
                      R = I - 1;
                    }

                    else
                    {
                      LL = L;
                      RR = I - 1;
                      L = I + 1;
                    }
                    if(R + -L >= 11)
                    {
                      lglpushstk(lgl, &lgl->$anon1.sortstk, LL);
                      lglpushstk(lgl, &lgl->$anon1.sortstk, RR);
                    }

                    else
                      if(RR + -LL >= 11)
                      {
                        L = LL;
                        R = RR;
                      }

                      else
                      {
                        return_value_lglmtstk$22=lglmtstk(&lgl->$anon1.sortstk);
                        if(return_value_lglmtstk$22 == 0)
                        {
                          R=lglpopstk(&lgl->$anon1.sortstk);
                          L=lglpopstk(&lgl->$anon1.sortstk);
                        }

                        else
                          break;
                      }
                  }
                  while((_Bool)1);
                }
                while((_Bool)0);
                do
                {
                  signed int lglcgextractands$$1$$2$$1$$3$$2$$2$$PIVOT;
                  signed int lglcgextractands$$1$$2$$1$$3$$2$$2$$L = 0;
                  signed int lglcgextractands$$1$$2$$1$$3$$2$$2$$R = NN - 1;
                  signed int lglcgextractands$$1$$2$$1$$3$$2$$2$$I;
                  signed int lglcgextractands$$1$$2$$1$$3$$2$$2$$J;
                  lglcgextractands$$1$$2$$1$$3$$2$$2$$I = lglcgextractands$$1$$2$$1$$3$$2$$2$$R;
                  for( ; !(lglcgextractands$$1$$2$$1$$3$$2$$2$$L >= lglcgextractands$$1$$2$$1$$3$$2$$2$$I); lglcgextractands$$1$$2$$1$$3$$2$$2$$I = lglcgextractands$$1$$2$$1$$3$$2$$2$$I - 1)
                    do
                    {
                      signed int return_value_lglcmpocc$23;
                      return_value_lglcmpocc$23=lglcmpocc(lgl, *(&AA[(signed long int)(lglcgextractands$$1$$2$$1$$3$$2$$2$$I - 1)]), *(&AA[(signed long int)lglcgextractands$$1$$2$$1$$3$$2$$2$$I]));
                      if(return_value_lglcmpocc$23 >= 1)
                        do
                        {
                          signed int lglcgextractands$$1$$2$$1$$3$$2$$2$$1$$1$$1$$TMP = AA[(signed long int)(lglcgextractands$$1$$2$$1$$3$$2$$2$$I - 1)];
                          AA[(signed long int)(lglcgextractands$$1$$2$$1$$3$$2$$2$$I - 1)] = AA[(signed long int)lglcgextractands$$1$$2$$1$$3$$2$$2$$I];
                          AA[(signed long int)lglcgextractands$$1$$2$$1$$3$$2$$2$$I] = lglcgextractands$$1$$2$$1$$3$$2$$2$$1$$1$$1$$TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                  lglcgextractands$$1$$2$$1$$3$$2$$2$$I = lglcgextractands$$1$$2$$1$$3$$2$$2$$L + 2;
                  for( ; lglcgextractands$$1$$2$$1$$3$$2$$2$$R >= lglcgextractands$$1$$2$$1$$3$$2$$2$$I; lglcgextractands$$1$$2$$1$$3$$2$$2$$I = lglcgextractands$$1$$2$$1$$3$$2$$2$$I + 1)
                  {
                    lglcgextractands$$1$$2$$1$$3$$2$$2$$J = lglcgextractands$$1$$2$$1$$3$$2$$2$$I;
                    lglcgextractands$$1$$2$$1$$3$$2$$2$$PIVOT = AA[(signed long int)lglcgextractands$$1$$2$$1$$3$$2$$2$$I];
                    do
                    {
                      return_value_lglcmpocc$24=lglcmpocc(lgl, *(&lglcgextractands$$1$$2$$1$$3$$2$$2$$PIVOT), *(&AA[(signed long int)(lglcgextractands$$1$$2$$1$$3$$2$$2$$J - 1)]));
                      if(return_value_lglcmpocc$24 >= 0)
                        break;

                      AA[(signed long int)lglcgextractands$$1$$2$$1$$3$$2$$2$$J] = AA[(signed long int)(lglcgextractands$$1$$2$$1$$3$$2$$2$$J - 1)];
                      lglcgextractands$$1$$2$$1$$3$$2$$2$$J = lglcgextractands$$1$$2$$1$$3$$2$$2$$J - 1;
                    }
                    while((_Bool)1);
                    AA[(signed long int)lglcgextractands$$1$$2$$1$$3$$2$$2$$J] = lglcgextractands$$1$$2$$1$$3$$2$$2$$PIVOT;
                  }
                }
                while((_Bool)0);

              __CPROVER_DUMP_L71:
                ;
              }
              while((_Bool)0);
              l = lgl->clause.start;
              for( ; !(l >= lgl->clause.top); l = l + 1l)
              {
                signed int return_value_lglincextractlimhit$25;
                return_value_lglincextractlimhit$25=lglincextractlimhit(lgl);
                if(!(return_value_lglincextractlimhit$25 == 0))
                {
                  lglclnstk(&lgl->clause);
                  return 0;
                }

                signed int return_value_lglhasbin$26;
                return_value_lglhasbin$26=lglhasbin(lgl, -lit, -(*l));
                if(return_value_lglhasbin$26 == 0)
                  break;

              }
              if(l == lgl->clause.top)
                lglnewlrgate(lgl, (enum GTag)ANDTAG, lit, c, size);

              lglclnstk(&lgl->clause);
            }
          }


        __CPROVER_DUMP_L78:
          ;
        }
        return 1;
      }
    }
  }
}

// lglcgextractidx
// file lglib.c line 12937
static signed int lglcgextractidx(struct LGL *lgl, signed int idx)
{
  signed int return_value_lglisfree$1;
  return_value_lglisfree$1=lglisfree(lgl, idx);
  signed int return_value_lglcgextractands$5;
  signed int return_value_lglcgextractands$6;
  signed int return_value_lglcgextractxors$7;
  signed int return_value_lglcgextractxors$8;
  signed int return_value_lglcgextractites$9;
  signed int return_value_lglcgextractites$10;
  if(return_value_lglisfree$1 == 0)
    return 1;

  else
  {
    struct AVar *return_value_lglavar$2;
    return_value_lglavar$2=lglavar(lgl, idx);
    if(!(return_value_lglavar$2->donotcgrcls == 0u))
      return 1;

    else
    {
      signed int return_value_lglcgextractlimhit$3;
      return_value_lglcgextractlimhit$3=lglcgextractlimhit(lgl);
      if(!(return_value_lglcgextractlimhit$3 == 0))
        return 0;

      else
      {
        signed int return_value_lglterminate$4;
        return_value_lglterminate$4=lglterminate(lgl);
        if(!(return_value_lglterminate$4 == 0))
          return 0;

        else
          if(lgl->mt == 0)
          {
            return_value_lglcgextractands$5=lglcgextractands(lgl, idx);
            if(!(return_value_lglcgextractands$5 == 0))
              goto __CPROVER_DUMP_L5;

            return 0;
          }

          else
          {

          __CPROVER_DUMP_L5:
            ;
            if(lgl->mt == 0)
            {
              return_value_lglcgextractands$6=lglcgextractands(lgl, -idx);
              if(!(return_value_lglcgextractands$6 == 0))
                goto __CPROVER_DUMP_L6;

              return 0;
            }

            else
            {

            __CPROVER_DUMP_L6:
              ;
              if(lgl->mt == 0)
              {
                return_value_lglcgextractxors$7=lglcgextractxors(lgl, idx);
                if(!(return_value_lglcgextractxors$7 == 0))
                  goto __CPROVER_DUMP_L7;

                return 0;
              }

              else
              {

              __CPROVER_DUMP_L7:
                ;
                if(lgl->mt == 0)
                {
                  return_value_lglcgextractxors$8=lglcgextractxors(lgl, -idx);
                  if(!(return_value_lglcgextractxors$8 == 0))
                    goto __CPROVER_DUMP_L8;

                  return 0;
                }

                else
                {

                __CPROVER_DUMP_L8:
                  ;
                  if(lgl->mt == 0)
                  {
                    return_value_lglcgextractites$9=lglcgextractites(lgl, idx);
                    if(!(return_value_lglcgextractites$9 == 0))
                      goto __CPROVER_DUMP_L9;

                    return 0;
                  }

                  else
                  {

                  __CPROVER_DUMP_L9:
                    ;
                    if(lgl->mt == 0)
                    {
                      return_value_lglcgextractites$10=lglcgextractites(lgl, -idx);
                      if(!(return_value_lglcgextractites$10 == 0))
                        goto __CPROVER_DUMP_L10;

                      return 0;
                    }

                    else
                    {

                    __CPROVER_DUMP_L10:
                      ;
                      return 1;
                    }
                  }
                }
              }
            }
          }
      }
    }
  }
}

// lglcgextractitecands
// file lglib.c line 12834
static void lglcgextractitecands(struct LGL *lgl, signed int lhs, struct ITEC *cands, signed int ncands)
{
  signed int cond;
  signed int pos;
  signed int neg;
  signed int l;
  signed int m;
  signed int r;
  signed int i;
  signed int j;
  l = 0;
  signed int return_value_abs$1;
  signed int return_value_abs$2;
  signed int return_value_lglcgmergelhsrhs$3;
  for( ; !(l >= ncands); l = r)
  {
    r = l + 1;
    for( ; !(r >= ncands); r = r + 1)
    {
      return_value_abs$1=abs((cands + (signed long int)l)->other);
      return_value_abs$2=abs((cands + (signed long int)r)->other);
      if(!(return_value_abs$1 == return_value_abs$2))
        break;

    }
    if(!((cands + (signed long int)l)->other == (cands + (signed long int)(r + -1))->other))
    {
      m = l + 1;
      for( ; !((cands + (signed long int)m)->other >= 0); m = m + 1)
        ;
      i = l;
      for( ; !(1 + i >= m); i = i + 1)
        ;
      i = m;
      for( ; !(1 + i >= r); i = i + 1)
        ;
      i = l;
      for( ; !(i >= m); i = i + 1)
      {
        j = m;
        for( ; !(j >= r); j = j + 1)
        {
          lhs=lglcgreprnotconst(lgl, lhs);
          lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
          cond = -(cands + (signed long int)l)->other;
          pos = -(cands + (signed long int)l)->other2;
          neg = -(cands + (signed long int)m)->other2;
          pos=lglcgreprnotconst(lgl, pos);
          neg=lglcgreprnotconst(lgl, neg);
          if(!(pos == -neg))
          {
            if(pos == neg)
            {
              if(!(lhs == pos))
              {
                return_value_lglcgmergelhsrhs$3=lglcgmergelhsrhs(lgl, lhs, pos);
                if(!(return_value_lglcgmergelhsrhs$3 == 0))
                  goto __CPROVER_DUMP_L18;

              }

            }

            else
              lglnewitegate(lgl, lhs, cond, pos, neg);
          }

        }
      }
    }

  }

__CPROVER_DUMP_L18:
  ;
}

// lglcgextractites
// file lglib.c line 12865
static signed int lglcgextractites(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  struct ITEC *cands;
  signed int ncands;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  struct HTS *hts;
  signed int return_value_lglcmpitecands$9;
  signed int return_value_lglmtstk$10;
  signed int return_value_lglcmpitecands$12;
  if(lgl->opts->cgrextite.val == 0)
    return 1;

  else
  {
    hts=lglhts(lgl, lit);
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
      blit = *p;
      tag = blit & MASKCS;
      if(!(tag == OCCS) && !(tag == BINCS))
      {
        p = p + 1l;
        if(!(tag == LRGCS))
        {
          other = blit >> RMSHFT;
          other2 = *p;
          lglsignedmark(lgl, other);
          lglsignedmark(lgl, other2);
        }

      }

    }
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      blit = *p;
      tag = blit & MASKCS;
      if(!(tag == OCCS) && !(tag == BINCS))
      {
        p = p + 1l;
        if(!(tag == LRGCS))
        {
          lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
          other = blit >> RMSHFT;
          other2 = *p;
          signed int return_value_lglsignedmarked$2;
          return_value_lglsignedmarked$2=lglsignedmarked(lgl, -other);
          if(!(return_value_lglsignedmarked$2 == 0))
          {
            lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
            signed int return_value_lglhastrn$1;
            return_value_lglhastrn$1=lglhastrn(lgl, -lit, other, -other2);
            if(!(return_value_lglhastrn$1 == 0))
            {
              lglpushstk(lgl, &lgl->seen, other);
              lglpushstk(lgl, &lgl->seen, other2);
            }

          }

          signed int return_value_lglsignedmarked$4;
          return_value_lglsignedmarked$4=lglsignedmarked(lgl, -other2);
          if(!(return_value_lglsignedmarked$4 == 0))
          {
            lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
            signed int return_value_lglhastrn$3;
            return_value_lglhastrn$3=lglhastrn(lgl, -lit, -other, other2);
            if(!(return_value_lglhastrn$3 == 0))
            {
              lglpushstk(lgl, &lgl->seen, other2);
              lglpushstk(lgl, &lgl->seen, other);
            }

          }

        }

      }

    }
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
      blit = *p;
      tag = blit & MASKCS;
      if(!(tag == OCCS) && !(tag == BINCS))
      {
        p = p + 1l;
        if(!(tag == LRGCS))
        {
          other = blit >> RMSHFT;
          other2 = *p;
          lglunmark(lgl, other);
          lglunmark(lgl, other2);
        }

      }

    }
    unsigned long int return_value_lglcntstk$13;
    return_value_lglcntstk$13=lglcntstk(&lgl->seen);
    ncands = (signed int)return_value_lglcntstk$13;
    if(!(ncands == 0))
    {
      cands = (struct ITEC *)lgl->seen.start;
      ncands = ncands / 2;
      do
      {
        struct ITEC *AA = cands;
        signed int NN = ncands;
        do
        {
          signed int L = 0;
          signed int R = NN - 1;
          signed int M;
          signed int LL;
          signed int RR;
          signed int I;
          if(!(R + -L >= 11))
            break;

          do
          {
            M = (L + R) / 2;
            do
            {
              struct ITEC TMP = AA[(signed long int)M];
              AA[(signed long int)M] = AA[(signed long int)(R - 1)];
              AA[(signed long int)(R - 1)] = TMP;
            }
            while((_Bool)0);
            do
            {
              signed int return_value_lglcmpitecands$5;
              return_value_lglcmpitecands$5=lglcmpitecands(&AA[(signed long int)L], &AA[(signed long int)(R - 1)]);
              if(return_value_lglcmpitecands$5 >= 1)
                do
                {
                  struct ITEC lglcgextractites$$1$$4$$1$$1$$1$$1$$2$$1$$TMP = AA[(signed long int)L];
                  AA[(signed long int)L] = AA[(signed long int)(R - 1)];
                  AA[(signed long int)(R - 1)] = lglcgextractites$$1$$4$$1$$1$$1$$1$$2$$1$$TMP;
                }
                while((_Bool)0);

            }
            while((_Bool)0);
            do
            {
              signed int return_value_lglcmpitecands$6;
              return_value_lglcmpitecands$6=lglcmpitecands(&AA[(signed long int)L], &AA[(signed long int)R]);
              if(return_value_lglcmpitecands$6 >= 1)
                do
                {
                  struct ITEC lglcgextractites$$1$$4$$1$$1$$1$$1$$3$$1$$TMP = AA[(signed long int)L];
                  AA[(signed long int)L] = AA[(signed long int)R];
                  AA[(signed long int)R] = lglcgextractites$$1$$4$$1$$1$$1$$1$$3$$1$$TMP;
                }
                while((_Bool)0);

            }
            while((_Bool)0);
            do
            {
              signed int return_value_lglcmpitecands$7;
              return_value_lglcmpitecands$7=lglcmpitecands(&AA[(signed long int)(R - 1)], &AA[(signed long int)R]);
              if(return_value_lglcmpitecands$7 >= 1)
                do
                {
                  struct ITEC lglcgextractites$$1$$4$$1$$1$$1$$1$$4$$1$$TMP = AA[(signed long int)(R - 1)];
                  AA[(signed long int)(R - 1)] = AA[(signed long int)R];
                  AA[(signed long int)R] = lglcgextractites$$1$$4$$1$$1$$1$$1$$4$$1$$TMP;
                }
                while((_Bool)0);

            }
            while((_Bool)0);
            do
            {
              struct ITEC PIVOT;
              signed int J = R - 1;
              I = (L + 1) - 1;
              PIVOT = AA[(signed long int)J];
              do
              {

              __CPROVER_DUMP_L29:
                ;
                I = I + 1;
                signed int return_value_lglcmpitecands$8;
                return_value_lglcmpitecands$8=lglcmpitecands(&AA[(signed long int)I], &PIVOT);
                if(!(return_value_lglcmpitecands$8 >= 0))
                  goto __CPROVER_DUMP_L29;

                do
                {
                  J = J - 1;
                  return_value_lglcmpitecands$9=lglcmpitecands(&PIVOT, &AA[(signed long int)J]);
                  if(return_value_lglcmpitecands$9 >= 0)
                    break;

                  if(J == 1 + L)
                    break;

                }
                while((_Bool)1);
                if(I >= J)
                  break;

                do
                {
                  struct ITEC lglcgextractites$$1$$4$$1$$1$$1$$1$$5$$1$$1$$1$$TMP = AA[(signed long int)I];
                  AA[(signed long int)I] = AA[(signed long int)J];
                  AA[(signed long int)J] = lglcgextractites$$1$$4$$1$$1$$1$$1$$5$$1$$1$$1$$TMP;
                }
                while((_Bool)0);
              }
              while((_Bool)1);
              do
              {
                struct ITEC lglcgextractites$$1$$4$$1$$1$$1$$1$$5$$2$$TMP = AA[(signed long int)I];
                AA[(signed long int)I] = AA[(signed long int)(R - 1)];
                AA[(signed long int)(R - 1)] = lglcgextractites$$1$$4$$1$$1$$1$$1$$5$$2$$TMP;
              }
              while((_Bool)0);
            }
            while((_Bool)0);
            if(!(I + -L >= R + -I))
            {
              LL = I + 1;
              RR = R;
              R = I - 1;
            }

            else
            {
              LL = L;
              RR = I - 1;
              L = I + 1;
            }
            if(R + -L >= 11)
            {
              lglpushstk(lgl, &lgl->$anon1.sortstk, LL);
              lglpushstk(lgl, &lgl->$anon1.sortstk, RR);
            }

            else
              if(RR + -LL >= 11)
              {
                L = LL;
                R = RR;
              }

              else
              {
                return_value_lglmtstk$10=lglmtstk(&lgl->$anon1.sortstk);
                if(return_value_lglmtstk$10 == 0)
                {
                  R=lglpopstk(&lgl->$anon1.sortstk);
                  L=lglpopstk(&lgl->$anon1.sortstk);
                }

                else
                  break;
              }
          }
          while((_Bool)1);
        }
        while((_Bool)0);
        do
        {
          struct ITEC lglcgextractites$$1$$4$$1$$2$$PIVOT;
          signed int lglcgextractites$$1$$4$$1$$2$$L = 0;
          signed int lglcgextractites$$1$$4$$1$$2$$R = NN - 1;
          signed int lglcgextractites$$1$$4$$1$$2$$I;
          signed int lglcgextractites$$1$$4$$1$$2$$J;
          lglcgextractites$$1$$4$$1$$2$$I = lglcgextractites$$1$$4$$1$$2$$R;
          for( ; !(lglcgextractites$$1$$4$$1$$2$$L >= lglcgextractites$$1$$4$$1$$2$$I); lglcgextractites$$1$$4$$1$$2$$I = lglcgextractites$$1$$4$$1$$2$$I - 1)
            do
            {
              signed int return_value_lglcmpitecands$11;
              return_value_lglcmpitecands$11=lglcmpitecands(&AA[(signed long int)(lglcgextractites$$1$$4$$1$$2$$I - 1)], &AA[(signed long int)lglcgextractites$$1$$4$$1$$2$$I]);
              if(return_value_lglcmpitecands$11 >= 1)
                do
                {
                  struct ITEC lglcgextractites$$1$$4$$1$$2$$1$$1$$1$$TMP = AA[(signed long int)(lglcgextractites$$1$$4$$1$$2$$I - 1)];
                  AA[(signed long int)(lglcgextractites$$1$$4$$1$$2$$I - 1)] = AA[(signed long int)lglcgextractites$$1$$4$$1$$2$$I];
                  AA[(signed long int)lglcgextractites$$1$$4$$1$$2$$I] = lglcgextractites$$1$$4$$1$$2$$1$$1$$1$$TMP;
                }
                while((_Bool)0);

            }
            while((_Bool)0);
          lglcgextractites$$1$$4$$1$$2$$I = lglcgextractites$$1$$4$$1$$2$$L + 2;
          for( ; lglcgextractites$$1$$4$$1$$2$$R >= lglcgextractites$$1$$4$$1$$2$$I; lglcgextractites$$1$$4$$1$$2$$I = lglcgextractites$$1$$4$$1$$2$$I + 1)
          {
            lglcgextractites$$1$$4$$1$$2$$J = lglcgextractites$$1$$4$$1$$2$$I;
            lglcgextractites$$1$$4$$1$$2$$PIVOT = AA[(signed long int)lglcgextractites$$1$$4$$1$$2$$I];
            do
            {
              return_value_lglcmpitecands$12=lglcmpitecands(&lglcgextractites$$1$$4$$1$$2$$PIVOT, &AA[(signed long int)(lglcgextractites$$1$$4$$1$$2$$J - 1)]);
              if(return_value_lglcmpitecands$12 >= 0)
                break;

              AA[(signed long int)lglcgextractites$$1$$4$$1$$2$$J] = AA[(signed long int)(lglcgextractites$$1$$4$$1$$2$$J - 1)];
              lglcgextractites$$1$$4$$1$$2$$J = lglcgextractites$$1$$4$$1$$2$$J - 1;
            }
            while((_Bool)1);
            AA[(signed long int)lglcgextractites$$1$$4$$1$$2$$J] = lglcgextractites$$1$$4$$1$$2$$PIVOT;
          }
        }
        while((_Bool)0);

      __CPROVER_DUMP_L51:
        ;
      }
      while((_Bool)0);
      lglcgextractitecands(lgl, lit, cands, ncands);
    }

    lglclnstk(&lgl->seen);
    signed int return_value_lglcgextractlimhit$14;
    return_value_lglcgextractlimhit$14=lglcgextractlimhit(lgl);
    return (signed int)!(return_value_lglcgextractlimhit$14 != 0);
  }
}

// lglcgextractlimhit
// file lglib.c line 12576
static signed int lglcgextractlimhit(struct LGL *lgl)
{
  return (signed int)(lgl->stats->cgr.esteps >= lgl->limits->cgr.esteps);
}

// lglcgextractxors
// file lglib.c line 12748
static signed int lglcgextractxors(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  signed int lidx;
  signed int size;
  signed int count;
  signed int parity;
  signed int *c;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *l;
  struct HTS *hts;
  if(lgl->opts->cgrextxor.val == 0)
    return 1;

  else
  {
    hts=lglhts(lgl, lit);
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      signed int return_value_lglincextractlimhit$1;
      return_value_lglincextractlimhit$1=lglincextractlimhit(lgl);
      if(!(return_value_lglincextractlimhit$1 == 0))
        return 0;

      blit = *p;
      tag = blit & MASKCS;
      if(!(tag == BINCS))
      {
        if(tag == TRNCS || tag == LRGCS)
          p = p + 1l;

        if(!(tag == LRGCS))
        {
          if(tag == TRNCS)
          {
            other = blit >> RMSHFT;
            if(!(other >= 0))
              goto __CPROVER_DUMP_L20;

            other2 = *p;
            if(!(other2 >= 0))
              goto __CPROVER_DUMP_L20;

            lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
            signed int return_value_lglhastrn$2;
            return_value_lglhastrn$2=lglhastrn(lgl, lit, -other, -other2);
            if(return_value_lglhastrn$2 == 0)
              goto __CPROVER_DUMP_L20;

            lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
            signed int return_value_lglhastrn$3;
            return_value_lglhastrn$3=lglhastrn(lgl, -lit, other, -other2);
            if(return_value_lglhastrn$3 == 0)
              goto __CPROVER_DUMP_L20;

            lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
            signed int return_value_lglhastrn$4;
            return_value_lglhastrn$4=lglhastrn(lgl, -lit, -other, other2);
            if(return_value_lglhastrn$4 == 0)
              goto __CPROVER_DUMP_L20;

            lglnewbingate(lgl, (enum GTag)XORTAG, lit, other, other2);
          }

          else
          {
            signed int return_value_lglincextractlimhit$5;
            return_value_lglincextractlimhit$5=lglincextractlimhit(lgl);
            if(!(return_value_lglincextractlimhit$5 == 0))
              return 0;

            lidx = blit >> RMSHFT;
            c=lglidx2lits(lgl, OCCS, blit & REDCS, lidx);
            l = c;
            do
            {
              other = *l;
              if(other == 0)
                break;

              if(!(other == lit) && !(other >= 0))
                break;

              lglpushstk(lgl, &lgl->clause, other);
              l = l + 1l;
            }
            while((_Bool)1);
            if(other == 0)
            {
              size = (signed int)((l - c) - (signed long int)1);
              if(lgl->opts->cgrmaxority.val >= size)
              {
                count = 1 << size;
                parity = (signed int)(lit < 0);
                do
                {
                  count = count - 1;
                  if(count == 0)
                    break;

                  lglinclause(lgl, parity);
                  lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
                  signed int return_value_lglxorhascls$6;
                  return_value_lglxorhascls$6=lglxorhascls(lgl);
                  if(return_value_lglxorhascls$6 == 0)
                    break;

                }
                while((_Bool)1);
                if(count == 0)
                  lglnewlrgate(lgl, (enum GTag)XORTAG, lit, c, size);

              }

            }

            lglclnstk(&lgl->clause);
          }
        }

      }


    __CPROVER_DUMP_L20:
      ;
    }
    signed int return_value_lglcgextractlimhit$7;
    return_value_lglcgextractlimhit$7=lglcgextractlimhit(lgl);
    return (signed int)!(return_value_lglcgextractlimhit$7 != 0);
  }
}

// lglcginit
// file lglib.c line 13002
static void lglcginit(struct LGL *lgl)
{
  signed int idx;
  signed int schedulable = 0;
  signed int donotcgrcls = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree$1;
    return_value_lglisfree$1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree$1 == 0))
    {
      struct AVar *return_value_lglavar$2;
      return_value_lglavar$2=lglavar(lgl, idx);
      if(!(return_value_lglavar$2->donotcgrcls == 0u))
        donotcgrcls = donotcgrcls + 1;

      else
        schedulable = schedulable + 1;
    }

  }
  if(schedulable == 0)
  {
    donotcgrcls = 0;
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      signed int return_value_lglisfree$3;
      return_value_lglisfree$3=lglisfree(lgl, idx);
      if(!(return_value_lglisfree$3 == 0))
      {
        struct AVar *return_value_lglavar$4;
        return_value_lglavar$4=lglavar(lgl, idx);
        return_value_lglavar$4->donotcgrcls = (unsigned int)0;
        schedulable = schedulable + 1;
      }

    }
  }

  signed int return_value_lglrem$5;
  double return_value_lglpcnt$6;
  if(donotcgrcls == 0)
    lglprt(lgl, 1, "[cgrclsr-%d] all %d free variables schedulable", lgl->stats->cgr.count, schedulable);

  else
  {
    return_value_lglrem$5=lglrem(lgl);
    return_value_lglpcnt$6=lglpcnt((double)schedulable, (double)return_value_lglrem$5);
    lglprt(lgl, 1, "[cgrclsr-%d] %d schedulable variables %.0f%%", lgl->stats->cgr.count, schedulable, return_value_lglpcnt$6);
  }
  lglwrkinit(lgl, 1, 1);
  lgl->donotsched = (char)1;
  lglrandidxtrav(lgl, lglwrktouch);
  lgl->donotsched = (char)0;
  do
  {
    void *return_value_lglnew$7;
    return_value_lglnew$7=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(struct Stk) /*24ul*/ );
    lgl->$anon0.cgr->goccs = (struct Stk *)return_value_lglnew$7;
  }
  while((_Bool)0);
}

// lglcgmerge
// file lglib.c line 12520
static void lglcgmerge(struct LGL *lgl, signed int other, signed int repr)
{
  signed int *p;
  signed int *q;
  signed int gidx;
  struct Stk *from;
  struct Stk *to;
  struct Gat *g;
  signed int return_value_abs$1;
  return_value_abs$1=abs(other);
  if(return_value_abs$1 == 1)
    do
    {
      signed int TMP = other;
      other = repr;
      repr = TMP;
    }
    while((_Bool)0);

  if(repr == -1)
  {
    other = -other;
    repr = 1;
  }

  signed int *tmp_post$5;
  if(repr == 1)
  {
    if(!(other >= 0))
    {
      other = -other;
      repr = -repr;
    }

    lgl->repr[(signed long int)other] = repr;
    lglwrktouch(lgl, other);
  }

  else
  {
    signed int return_value_lglcmprepr$2;
    return_value_lglcmprepr$2=lglcmprepr(lgl, other, repr);
    if(!(return_value_lglcmprepr$2 >= 0))
      do
      {
        signed int lglcgmerge$$1$$3$$1$$TMP = repr;
        repr = other;
        other = lglcgmerge$$1$$3$$1$$TMP;
      }
      while((_Bool)0);

    if(!(other >= 0))
    {
      other = -other;
      repr = -repr;
    }

    lglimerge(lgl, other, repr);
    signed int return_value_abs$3;
    return_value_abs$3=abs(other);
    from = lgl->$anon0.cgr->goccs + (signed long int)return_value_abs$3;
    signed int return_value_abs$4;
    return_value_abs$4=abs(repr);
    to = lgl->$anon0.cgr->goccs + (signed long int)return_value_abs$4;
    q = to->start;
    p = q;
    for( ; !(p >= to->top); p = p + 1l)
    {
      gidx = *p;
      g=lglgidx2gat(lgl, gidx);
      if(g->mark == 0u)
      {
        tmp_post$5 = q;
        q = q + 1l;
        *tmp_post$5 = gidx;
        g->mark = (unsigned int)1;
      }

    }
    to->top = q;

  __CPROVER_DUMP_L12:
    ;
    p = from->start;
    for( ; !(p >= from->top); p = p + 1l)
    {
      gidx = *p;
      g=lglgidx2gat(lgl, gidx);
      if(g->mark == 0u)
      {
        g->mark = (unsigned int)1;
        lglpushstk(lgl, to, gidx);
      }

    }
    lglrelstk(lgl, from);
    p = to->start;
    for( ; !(p >= to->top); p = p + 1l)
    {
      g=lglgidx2gat(lgl, *p);
      g->mark = (unsigned int)0;
    }
    lglwrktouch(lgl, repr);
  }
}

// lglcgmergelhsrhs
// file lglib.c line 12816
static signed int lglcgmergelhsrhs(struct LGL *lgl, signed int lhs, signed int rhs)
{
  signed int conflict = 0;
  lhs=lglcgrepr(lgl, lhs);
  rhs=lglcgrepr(lgl, rhs);
  signed int return_value_lglcgunit$1;
  signed int return_value_lglcgunit$2;
  signed int return_value_lglcgunit$3;
  signed int return_value_lglcgunit$4;
  if(lhs == rhs)
    return 0;

  else
  {
    if(lhs == -rhs)
      conflict = 1;

    else
      if(lhs == 1)
      {
        if(rhs == -1)
          conflict = 1;

        else
        {
          return_value_lglcgunit$1=lglcgunit(lgl, rhs);
          conflict = (signed int)!(return_value_lglcgunit$1 != 0);
        }
      }

      else
        if(lhs == -1)
        {
          if(rhs == 1)
            conflict = 1;

          else
          {
            return_value_lglcgunit$2=lglcgunit(lgl, -rhs);
            conflict = (signed int)!(return_value_lglcgunit$2 != 0);
          }
        }

        else
          if(rhs == 1)
          {
            return_value_lglcgunit$3=lglcgunit(lgl, lhs);
            conflict = (signed int)!(return_value_lglcgunit$3 != 0);
          }

          else
            if(rhs == -1)
            {
              return_value_lglcgunit$4=lglcgunit(lgl, -lhs);
              conflict = (signed int)!(return_value_lglcgunit$4 != 0);
            }

            else
              lglcgmerge(lgl, lhs, rhs);
    return conflict;
  }
}

// lglcgrclosing
// file lglib.c line 16955
static signed int lglcgrclosing(struct LGL *lgl)
{
  _Bool tmp_if_expr$2;
  signed int return_value_lglsmallirr$1;
  if(!(lgl->opts->cgrclsr.val == 0))
  {
    return_value_lglsmallirr$1=lglsmallirr(lgl);
    tmp_if_expr$2 = return_value_lglsmallirr$1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  return (signed int)tmp_if_expr$2;
}

// lglcgrclsr
// file lglib.c line 13782
static signed int lglcgrclsr(struct LGL *lgl)
{
  signed int lglcgrclsr$$1$$nvars;
  signed int oldrem;
  signed int removed;
  lglstart(lgl, &lgl->times->cgr);
  oldrem=lglrem(lgl);
  lgl->stats->cgr.count = lgl->stats->cgr.count + 1;
  lgl->simp = (char)1;
  lgl->cgrclosing = lgl->simp;
  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Cgr) /*120ul*/ );
    lgl->$anon0.cgr = (struct Cgr *)return_value_lglnew$1;
  }
  while((_Bool)0);
  if(lgl->level >= 1)
    lglbacktrack(lgl, 0);

  lglgc(lgl);
  lglfreezer(lgl);
  lgldense(lgl, 1);
  lglcgrclsr$$1$$nvars = lgl->nvars;
  do
  {
    void *return_value_lglnew$2;
    return_value_lglnew$2=lglnew(lgl, (unsigned long int)lglcgrclsr$$1$$nvars * sizeof(signed int) /*4ul*/ );
    lgl->repr = (signed int *)return_value_lglnew$2;
  }
  while((_Bool)0);
  lglsetcgrclsrlim(lgl);
  lglcginit(lgl);
  lglgateextract(lgl);
  if(lgl->mt == 0)
    lglclsr(lgl);

  lglcgreset(lgl);
  lglsparse(lgl);
  signed int return_value_lgladdunits$3;
  signed int return_value_lglbcp$4;
  signed int return_value_lglpropunits$5;
  if(lgl->mt == 0)
  {
    return_value_lgladdunits$3=lgladdunits(lgl);
    if(!(return_value_lgladdunits$3 == 0))
    {
      lglchkred(lgl);
      lgldcpdis(lgl);
      lgldcpcln(lgl);
      lgldcpcon(lgl);
      lglcompact(lgl);
      lglmap(lgl);
      if(lgl->mt == 0)
      {
        return_value_lglbcp$4=lglbcp(lgl);
        if(!(return_value_lglbcp$4 == 0))
        {
          return_value_lglpropunits$5=lglpropunits(lgl);
          if(!(return_value_lglpropunits$5 == 0))
          {
            lglcount(lgl);
            lglgc(lgl);
            if(lgl->mt == 0)
            {
              if(lgl->mt == 0)
              {
                lglpicosatchkall(lgl);
                lglpicosatrestart(lgl);
              }

            }

          }

        }

      }

    }

  }


DONE:
  ;
  lglrelstk(lgl, &lgl->$anon0.cgr->units);
  if(!(lgl->repr == ((signed int *)NULL)))
    do
    {
      lgldel(lgl, (void *)lgl->repr, (unsigned long int)lglcgrclsr$$1$$nvars * sizeof(signed int) /*4ul*/ );
      lgl->repr = ((signed int *)NULL);
    }
    while((_Bool)0);

  signed int return_value_lglrem$6;
  return_value_lglrem$6=lglrem(lgl);
  removed = oldrem - return_value_lglrem$6;
  lglupdcgrpen(lgl, removed);
  do
  {
    lgldel(lgl, (void *)lgl->$anon0.cgr, (unsigned long int)1 * sizeof(struct Cgr) /*120ul*/ );
    lgl->$anon0.cgr = ((struct Cgr *)NULL);
  }
  while((_Bool)0);
  lgl->simp = (char)0;
  lgl->cgrclosing = lgl->simp;
  lglprtcgrem(lgl);
  lglprt(lgl, 1 + (signed int)!(removed != 0), "[cgrclsr-%d] removed %d variables", lgl->stats->cgr.count, removed);
  lglrep(lgl, 1 + (signed int)!(removed != 0), (char)67);
  lglstop(lgl);
  return (signed int)!(lgl->mt != 0);
}

// lglcgrepr
// file lglib.c line 12319
static signed int lglcgrepr(struct LGL *lgl, signed int lit)
{
  signed int return_value_lglptrjmp$1;
  return_value_lglptrjmp$1=lglptrjmp(lgl->repr, lgl->nvars - 1, lit);
  return return_value_lglptrjmp$1;
}

// lglcgreprnotconst
// file lglib.c line 12341
static signed int lglcgreprnotconst(struct LGL *lgl, signed int lit)
{
  signed int res;
  res=lglcgrepr(lgl, lit);
  signed int return_value_abs$1;
  return_value_abs$1=abs(res);
  if(return_value_abs$1 == 1)
    res = lit;

  return res;
}

// lglcgreset
// file lglib.c line 13031
static void lglcgreset(struct LGL *lgl)
{
  const signed int *p;
  signed int idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
    (lgl->avars + (signed long int)idx)->donotcgrcls = (unsigned int)1;
  p = lgl->wrk->queue.start;
  signed int return_value_abs$1;
  for( ; !(p >= lgl->wrk->queue.top); p = p + 1l)
  {
    return_value_abs$1=abs(*p);
    (lgl->avars + (signed long int)return_value_abs$1)->donotcgrcls = (unsigned int)0;
  }
  lglwrkreset(lgl);
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
    (lgl->avars + (signed long int)idx)->gate = (unsigned int)0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
    lglrelstk(lgl, lgl->$anon0.cgr->goccs + (signed long int)idx);
  do
  {
    lgldel(lgl, (void *)lgl->$anon0.cgr->goccs, (unsigned long int)lgl->nvars * sizeof(struct Stk) /*24ul*/ );
    lgl->$anon0.cgr->goccs = ((struct Stk *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->$anon0.cgr->gates, (unsigned long int)lgl->$anon0.cgr->szgates * sizeof(struct Gat) /*32ul*/ );
    lgl->$anon0.cgr->gates = ((struct Gat *)NULL);
  }
  while((_Bool)0);
  lgl->$anon0.cgr->szgates = 0;
}

// lglcgrlimhit
// file lglib.c line 13330
static signed int lglcgrlimhit(struct LGL *lgl)
{
  return (signed int)(lgl->stats->cgr.csteps >= lgl->limits->cgr.csteps);
}

// lglcgrlit
// file lglib.c line 13614
static void lglcgrlit(struct LGL *lgl, signed int lit)
{
  signed int *p;
  signed int *q;
  signed int *l;
  signed int *r;
  signed int round;
  struct Gat *g;
  struct Gat *h;
  struct Stk *goccs;
  round = 0;

RESTART:
  ;
  signed int return_value_abs$1;
  signed int return_value_lglmtstk$2;
  _Bool tmp_if_expr$3;
  signed int return_value_lglcmpgoccs$12;
  signed int return_value_lglmtstk$13;
  signed int return_value_lglcmpgoccs$15;
  signed int *tmp_post$16;
  _Bool tmp_if_expr$17;
  signed int return_value_lglcgrlimhit$18;
  _Bool tmp_if_expr$20;
  signed int return_value_lglgoccsmatchcand$19;
  signed int return_value_lglcgrepr$21;
  signed int return_value_abs$22;
  signed int return_value_lglcgrepr$23;
  signed int return_value_abs$24;
  signed int return_value_lglsimpgate$25;
  signed int return_value_lglmatchgate$26;
  while((_Bool)1)
  {
    if(!(lgl->mt == 0))
      goto __CPROVER_DUMP_L67;

    return_value_abs$1=abs(lit);
    goccs = lgl->$anon0.cgr->goccs + (signed long int)return_value_abs$1;
    return_value_lglmtstk$2=lglmtstk(goccs);
    if(!(return_value_lglmtstk$2 == 0))
      goto __CPROVER_DUMP_L67;

    round = round + 1;

  __CPROVER_DUMP_L4:
    ;
    l = goccs->start;
    do
    {
      if(lgl->mt == 0)
        tmp_if_expr$3 = l < goccs->top ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(!tmp_if_expr$3)
        break;

      lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
      signed int return_value_lglcgrlimhit$4;
      return_value_lglcgrlimhit$4=lglcgrlimhit(lgl);
      if(!(return_value_lglcgrlimhit$4 == 0))
        goto __CPROVER_DUMP_L67;

      g=lglgidx2gat(lgl, *l);
      signed int return_value_lglsimpgate$5;
      return_value_lglsimpgate$5=lglsimpgate(lgl, g);
      if(!(return_value_lglsimpgate$5 == 0))
        goto RESTART;

      l = l + 1l;
    }
    while((_Bool)1);

  __CPROVER_DUMP_L9:
    ;
    p = goccs->start;
    for( ; !(p >= goccs->top); p = p + 1l)
    {
      lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
      signed int return_value_lglcgrlimhit$6;
      return_value_lglcgrlimhit$6=lglcgrlimhit(lgl);
      if(!(return_value_lglcgrlimhit$6 == 0))
        goto __CPROVER_DUMP_L67;

      g=lglgidx2gat(lgl, *p);
      lglsetminrhs(lgl, g);
    }
    do
    {
      signed int *AA = goccs->start;
      signed int NN;
      unsigned long int return_value_lglcntstk$7;
      return_value_lglcntstk$7=lglcntstk(goccs);
      NN = (signed int)return_value_lglcntstk$7;
      do
      {
        signed int L = 0;
        signed int R = NN - 1;
        signed int M;
        signed int LL;
        signed int RR;
        signed int I;
        if(!(R + -L >= 11))
          break;

        do
        {
          M = (L + R) / 2;
          do
          {
            signed int TMP = AA[(signed long int)M];
            AA[(signed long int)M] = AA[(signed long int)(R - 1)];
            AA[(signed long int)(R - 1)] = TMP;
          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpgoccs$8;
            return_value_lglcmpgoccs$8=lglcmpgoccs(lgl, *(&AA[(signed long int)L]), *(&AA[(signed long int)(R - 1)]));
            if(return_value_lglcmpgoccs$8 >= 1)
              do
              {
                signed int lglcgrlit$$1$$5$$1$$1$$1$$2$$1$$TMP = AA[(signed long int)L];
                AA[(signed long int)L] = AA[(signed long int)(R - 1)];
                AA[(signed long int)(R - 1)] = lglcgrlit$$1$$5$$1$$1$$1$$2$$1$$TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpgoccs$9;
            return_value_lglcmpgoccs$9=lglcmpgoccs(lgl, *(&AA[(signed long int)L]), *(&AA[(signed long int)R]));
            if(return_value_lglcmpgoccs$9 >= 1)
              do
              {
                signed int lglcgrlit$$1$$5$$1$$1$$1$$3$$1$$TMP = AA[(signed long int)L];
                AA[(signed long int)L] = AA[(signed long int)R];
                AA[(signed long int)R] = lglcgrlit$$1$$5$$1$$1$$1$$3$$1$$TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpgoccs$10;
            return_value_lglcmpgoccs$10=lglcmpgoccs(lgl, *(&AA[(signed long int)(R - 1)]), *(&AA[(signed long int)R]));
            if(return_value_lglcmpgoccs$10 >= 1)
              do
              {
                signed int lglcgrlit$$1$$5$$1$$1$$1$$4$$1$$TMP = AA[(signed long int)(R - 1)];
                AA[(signed long int)(R - 1)] = AA[(signed long int)R];
                AA[(signed long int)R] = lglcgrlit$$1$$5$$1$$1$$1$$4$$1$$TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            signed int PIVOT;
            signed int J = R - 1;
            I = (L + 1) - 1;
            PIVOT = AA[(signed long int)J];
            do
            {

            __CPROVER_DUMP_L26:
              ;
              I = I + 1;
              signed int return_value_lglcmpgoccs$11;
              return_value_lglcmpgoccs$11=lglcmpgoccs(lgl, *(&AA[(signed long int)I]), *(&PIVOT));
              if(!(return_value_lglcmpgoccs$11 >= 0))
                goto __CPROVER_DUMP_L26;

              do
              {
                J = J - 1;
                return_value_lglcmpgoccs$12=lglcmpgoccs(lgl, *(&PIVOT), *(&AA[(signed long int)J]));
                if(return_value_lglcmpgoccs$12 >= 0)
                  break;

                if(J == 1 + L)
                  break;

              }
              while((_Bool)1);
              if(I >= J)
                break;

              do
              {
                signed int lglcgrlit$$1$$5$$1$$1$$1$$5$$1$$1$$1$$TMP = AA[(signed long int)I];
                AA[(signed long int)I] = AA[(signed long int)J];
                AA[(signed long int)J] = lglcgrlit$$1$$5$$1$$1$$1$$5$$1$$1$$1$$TMP;
              }
              while((_Bool)0);
            }
            while((_Bool)1);
            do
            {
              signed int lglcgrlit$$1$$5$$1$$1$$1$$5$$2$$TMP = AA[(signed long int)I];
              AA[(signed long int)I] = AA[(signed long int)(R - 1)];
              AA[(signed long int)(R - 1)] = lglcgrlit$$1$$5$$1$$1$$1$$5$$2$$TMP;
            }
            while((_Bool)0);
          }
          while((_Bool)0);
          if(!(I + -L >= R + -I))
          {
            LL = I + 1;
            RR = R;
            R = I - 1;
          }

          else
          {
            LL = L;
            RR = I - 1;
            L = I + 1;
          }
          if(R + -L >= 11)
          {
            lglpushstk(lgl, &lgl->$anon1.sortstk, LL);
            lglpushstk(lgl, &lgl->$anon1.sortstk, RR);
          }

          else
            if(RR + -LL >= 11)
            {
              L = LL;
              R = RR;
            }

            else
            {
              return_value_lglmtstk$13=lglmtstk(&lgl->$anon1.sortstk);
              if(return_value_lglmtstk$13 == 0)
              {
                R=lglpopstk(&lgl->$anon1.sortstk);
                L=lglpopstk(&lgl->$anon1.sortstk);
              }

              else
                break;
            }
        }
        while((_Bool)1);
      }
      while((_Bool)0);
      do
      {
        signed int lglcgrlit$$1$$5$$2$$PIVOT;
        signed int lglcgrlit$$1$$5$$2$$L = 0;
        signed int lglcgrlit$$1$$5$$2$$R = NN - 1;
        signed int lglcgrlit$$1$$5$$2$$I;
        signed int lglcgrlit$$1$$5$$2$$J;
        lglcgrlit$$1$$5$$2$$I = lglcgrlit$$1$$5$$2$$R;
        for( ; !(lglcgrlit$$1$$5$$2$$L >= lglcgrlit$$1$$5$$2$$I); lglcgrlit$$1$$5$$2$$I = lglcgrlit$$1$$5$$2$$I - 1)
          do
          {
            signed int return_value_lglcmpgoccs$14;
            return_value_lglcmpgoccs$14=lglcmpgoccs(lgl, *(&AA[(signed long int)(lglcgrlit$$1$$5$$2$$I - 1)]), *(&AA[(signed long int)lglcgrlit$$1$$5$$2$$I]));
            if(return_value_lglcmpgoccs$14 >= 1)
              do
              {
                signed int lglcgrlit$$1$$5$$2$$1$$1$$1$$TMP = AA[(signed long int)(lglcgrlit$$1$$5$$2$$I - 1)];
                AA[(signed long int)(lglcgrlit$$1$$5$$2$$I - 1)] = AA[(signed long int)lglcgrlit$$1$$5$$2$$I];
                AA[(signed long int)lglcgrlit$$1$$5$$2$$I] = lglcgrlit$$1$$5$$2$$1$$1$$1$$TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
        lglcgrlit$$1$$5$$2$$I = lglcgrlit$$1$$5$$2$$L + 2;
        for( ; lglcgrlit$$1$$5$$2$$R >= lglcgrlit$$1$$5$$2$$I; lglcgrlit$$1$$5$$2$$I = lglcgrlit$$1$$5$$2$$I + 1)
        {
          lglcgrlit$$1$$5$$2$$J = lglcgrlit$$1$$5$$2$$I;
          lglcgrlit$$1$$5$$2$$PIVOT = AA[(signed long int)lglcgrlit$$1$$5$$2$$I];
          do
          {
            return_value_lglcmpgoccs$15=lglcmpgoccs(lgl, *(&lglcgrlit$$1$$5$$2$$PIVOT), *(&AA[(signed long int)(lglcgrlit$$1$$5$$2$$J - 1)]));
            if(return_value_lglcmpgoccs$15 >= 0)
              break;

            AA[(signed long int)lglcgrlit$$1$$5$$2$$J] = AA[(signed long int)(lglcgrlit$$1$$5$$2$$J - 1)];
            lglcgrlit$$1$$5$$2$$J = lglcgrlit$$1$$5$$2$$J - 1;
          }
          while((_Bool)1);
          AA[(signed long int)lglcgrlit$$1$$5$$2$$J] = lglcgrlit$$1$$5$$2$$PIVOT;
        }
      }
      while((_Bool)0);

    __CPROVER_DUMP_L48:
      ;
    }
    while((_Bool)0);
    q = goccs->start + (signed long int)1;
    p = q;
    for( ; !(p >= goccs->top); p = p + 1l)
      if(!(*p == q[-1l]))
      {
        tmp_post$16 = q;
        q = q + 1l;
        *tmp_post$16 = *p;
      }

    goccs->top = q;
    l = goccs->start;

  __CPROVER_DUMP_L52:
    ;
    if(lgl->mt == 0)
      tmp_if_expr$17 = l < goccs->top ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$17 = (_Bool)0;
    if(!tmp_if_expr$17)
      goto __CPROVER_DUMP_L66;

    lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
    return_value_lglcgrlimhit$18=lglcgrlimhit(lgl);
    if(!(return_value_lglcgrlimhit$18 == 0))
      goto __CPROVER_DUMP_L67;

    r = l + (signed long int)1;
    do
    {
      if(!(r >= goccs->top))
      {
        return_value_lglgoccsmatchcand$19=lglgoccsmatchcand(lgl, *l, *r);
        tmp_if_expr$20 = return_value_lglgoccsmatchcand$19 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$20 = (_Bool)0;
      if(!tmp_if_expr$20)
        break;

      r = r + 1l;
    }
    while((_Bool)1);
    p = l;

  __CPROVER_DUMP_L60:
    ;
    if(!(lgl->mt == 0) || p + 1l >= r)
      goto __CPROVER_DUMP_L65;

    g=lglgidx2gat(lgl, *p);
    return_value_lglcgrepr$21=lglcgrepr(lgl, g->lhs);
    return_value_abs$22=abs(return_value_lglcgrepr$21);
    if(return_value_abs$22 == 1)
      goto __CPROVER_DUMP_L64;

    q = p + (signed long int)1;

  __CPROVER_DUMP_L61:
    ;
    if(!(lgl->mt == 0) || q >= r)
      goto __CPROVER_DUMP_L63;

    h=lglgidx2gat(lgl, *q);
    return_value_lglcgrepr$23=lglcgrepr(lgl, h->lhs);
    return_value_abs$24=abs(return_value_lglcgrepr$23);
    if(return_value_abs$24 == 1)
      goto __CPROVER_DUMP_L62;

    return_value_lglsimpgate$25=lglsimpgate(lgl, h);
    if(!(return_value_lglsimpgate$25 == 0))
      goto RESTART;

    return_value_lglmatchgate$26=lglmatchgate(lgl, lit, g, h);
    if(return_value_lglmatchgate$26 == 0)
      break;

  }

__CPROVER_DUMP_L62:
  ;
  q = q + 1l;
  goto __CPROVER_DUMP_L61;

__CPROVER_DUMP_L63:
  ;

__CPROVER_DUMP_L64:
  ;
  p = p + 1l;
  goto __CPROVER_DUMP_L60;

__CPROVER_DUMP_L65:
  ;
  l = r;
  goto __CPROVER_DUMP_L52;

__CPROVER_DUMP_L66:
  ;

__CPROVER_DUMP_L67:
  ;
}

// lglcgunit
// file lglib.c line 12585
static signed int lglcgunit(struct LGL *lgl, signed int lit)
{
  signed int lglcgunit$$1$$next;
  signed int repr;
  signed int other;
  signed int ok;
  signed char val;
  val=lglval(lgl, lit);
  signed int tmp_post$1;
  if((signed int)val >= 1)
    return 1;

  else
    if(!((signed int)val >= 0))
    {

    __CPROVER_DUMP_L2:
      ;
      lgl->mt = 1;
      return 0;
    }

    else
    {
      lglcgunit$$1$$next = lgl->next;
      lglunit(lgl, lit);
      ok=lglbcp(lgl);
      if(!(ok == 0))
        while(!(lglcgunit$$1$$next >= lgl->next))
        {
          tmp_post$1 = lglcgunit$$1$$next;
          lglcgunit$$1$$next = lglcgunit$$1$$next + 1;
          other=lglpeek(&lgl->trail, tmp_post$1);
          repr=lglcgrepr(lgl, other);
          if(!(repr == 1))
          {
            if(repr == -1)
            {
              ok = 0;
              break;
            }

            lglcgmerge(lgl, repr, 1);
          }

        }

      if(ok == 0)
      {

      __CPROVER_DUMP_L8:
        ;
        lgl->mt = 1;
      }

      return ok;
    }
}

// lglchanged
// file lglib.c line 17865
signed int lglchanged(struct LGL *lgl)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglchanged");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "changed");
    break;
  }

__CPROVER_DUMP_L5:
  ;
  do
  {
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglchanged");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

    while((EXTENDED & (signed int)lgl->state) == 0)
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglchanged");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "!(%s)", (const void *)"EXTENDED");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
  }
  while((_Bool)0);
  res = lgl->changed;

__CPROVER_DUMP_L11:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglchanged(lgl->clone);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglchanged");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone) = %d differs from %s (lgl) = %d", (const void *)"lglchanged", CLONERES, (const void *)"lglchanged", res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglchkassumeclean
// file lglib.c line 3726
static void lglchkassumeclean(struct LGL *lgl)
{
  ;
}

// lglchkbcpclean
// file lglib.c line 6871
static void lglchkbcpclean(struct LGL *lgl, const char *where)
{

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L2:
  ;

__CPROVER_DUMP_L3:
  ;
}

// lglchkclone
// file lglib.c line 2076
void lglchkclone(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglchkclone");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "chkclone");
    break;
  }
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglrelease(lgl->clone);

  lgl->clone=lglclone(lgl);
}

// lglchkclonesamestats
// file lglib.c line 17640
static void lglchkclonesamestats(struct LGL *orig)
{
  ;
}

// lglchkeassumeclean
// file lglib.c line 3714
static void lglchkeassumeclean(struct LGL *lgl)
{
  ;
}

// lglchkenv
// file lglib.c line 1632
static void lglchkenv(struct LGL *lgl)
{
  char *src;
  char *eos;
  char *dst;
  char **p;
  char *s;
  char *d;
  signed int len;
  p = environ;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  char *tmp_post$5;
  signed int tmp_statement_expression$6;
  signed int tmp_if_expr$8;
  const signed int **return_value___ctype_tolower_loc$7;
  const signed int **return_value___ctype_tolower_loc$9;
  signed int tmp_statement_expression$10;
  do
  {
    src = *p;
    if(src == ((char *)NULL))
      break;

    if(!((signed int)*src == 76))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)src[(signed long int)1] != 71 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)src[(signed long int)2] != 76 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$2)
    {
      eos = src;
      do
      {
        if(!(*eos == 0))
          tmp_if_expr$3 = (signed int)*eos != 61 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(!tmp_if_expr$3)
          break;

        eos = eos + 1l;
      }
      while((_Bool)1);
      len = (signed int)(eos - (src + (signed long int)3));
      do
      {
        void *return_value_lglnew$4;
        return_value_lglnew$4=lglnew(lgl, (unsigned long int)(len + 1) * sizeof(char) /*1ul*/ );
        dst = (char *)return_value_lglnew$4;
      }
      while((_Bool)0);
      d = dst;
      s = src + (signed long int)3;
      for( ; !(s >= eos); s = s + 1l)
      {
        tmp_post$5 = d;
        d = d + 1l;
        signed int __res;
        return_value___ctype_tolower_loc$9=__ctype_tolower_loc();
        __res = (*return_value___ctype_tolower_loc$9)[(signed long int)(signed int)*s];
        tmp_statement_expression$6 = __res;
        *tmp_post$5 = (char)tmp_statement_expression$6;
      }
      *d = (char)0;
      signed int return_value_lglhasopt$12;
      return_value_lglhasopt$12=lglhasopt(lgl, dst);
      if(return_value_lglhasopt$12 == 0)
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp$11;
        return_value___builtin_strcmp$11=__builtin_strcmp(dst, "apitrace");
        tmp_statement_expression$10 = return_value___builtin_strcmp$11;
        if(!(tmp_statement_expression$10 == 0))
          lglwrn(lgl, "invalid 'LGL...' environment '%s'", src);

      }

      do
      {
        lgldel(lgl, (void *)dst, (unsigned long int)(len + 1) * sizeof(char) /*1ul*/ );
        dst = ((char *)NULL);
      }
      while((_Bool)0);
    }

    p = p + 1l;
  }
  while((_Bool)1);
}

// lglchkflt
// file lglib.c line 1038
static void lglchkflt(signed long int a)
{
  (void)a;
}

// lglchkirrstats
// file lglib.c line 3421
static void lglchkirrstats(struct LGL *lgl)
{
  (void)lgl;
}

// lglchkoccs4elm
// file lglib.c line 11052
static signed int lglchkoccs4elm(struct LGL *lgl, signed int idx)
{
  signed int return_value_lgl2manyoccs4elm$1;
  return_value_lgl2manyoccs4elm$1=lgl2manyoccs4elm(lgl, idx);
  if(!(return_value_lgl2manyoccs4elm$1 == 0))
    return 0;

  else
  {
    signed int return_value_lgl2manyoccs4elm$2;
    return_value_lgl2manyoccs4elm$2=lgl2manyoccs4elm(lgl, -idx);
    if(!(return_value_lgl2manyoccs4elm$2 == 0))
      return 0;

    else
    {
      signed int return_value_lglchkoccs4elmlit$3;
      return_value_lglchkoccs4elmlit$3=lglchkoccs4elmlit(lgl, idx);
      if(return_value_lglchkoccs4elmlit$3 == 0)
        return 0;

      else
      {
        signed int return_value_lglchkoccs4elmlit$4;
        return_value_lglchkoccs4elmlit$4=lglchkoccs4elmlit(lgl, -idx);
        return return_value_lglchkoccs4elmlit$4;
      }
    }
  }
}

// lglchkoccs4elmlit
// file lglib.c line 11018
static signed int lglchkoccs4elmlit(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int lidx;
  signed int size;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  const signed int *l;
  struct HTS *hts;
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    red = blit & REDCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(!(tag == LRGCS) && red == 0)
    {
      if(tag == BINCS || tag == TRNCS)
      {
        other = blit >> RMSHFT;
        signed int return_value_lgl2manyoccs4elm$1;
        return_value_lgl2manyoccs4elm$1=lgl2manyoccs4elm(lgl, other);
        if(!(return_value_lgl2manyoccs4elm$1 == 0))
          return 0;

        if(tag == TRNCS)
        {
          other2 = *p;
          signed int return_value_lgl2manyoccs4elm$2;
          return_value_lgl2manyoccs4elm$2=lgl2manyoccs4elm(lgl, other2);
          if(!(return_value_lgl2manyoccs4elm$2 == 0))
            return 0;

        }

      }

      else
      {
        lidx = blit >> RMSHFT;
        c=lglidx2lits(lgl, OCCS, 0, lidx);
        size = 0;
        l = c;
        do
        {
          other = *l;
          if(other == 0)
            break;

          signed int return_value_lgl2manyoccs4elm$3;
          return_value_lgl2manyoccs4elm$3=lgl2manyoccs4elm(lgl, other);
          if(!(return_value_lgl2manyoccs4elm$3 == 0))
            return 0;

          size = size + 1;
          if(!(lgl->opts->elmclslim.val >= size))
            return 0;

          l = l + 1l;
        }
        while((_Bool)1);
      }
    }

  }
  return 1;
}

// lglchkqueue
// file lglib.c line 2346
static void lglchkqueue(struct LGL *lgl)
{
  ;
}

// lglchkred
// file lglib.c line 5076
static void lglchkred(struct LGL *lgl)
{
  ;
}

// lglchksimpcls
// file lglib.c line 2945
static void lglchksimpcls(struct LGL *lgl)
{
  ;
}

// lglclass
// file lglib.c line 17518
static void lglclass(struct LGL *lgl, struct LGL *from)
{
  struct Ext *extfrom;
  struct Ext *extlgl;
  signed int eidx;
  signed int cloned;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglclass");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->mt == 0))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglclass");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not clone assignment into inconsistent manager");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  while(from == ((struct LGL *)NULL))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglclass");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "uninitialized 'from' solver");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  while((96 & (signed int)from->state) == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglclass");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "require 'from' state to be (SATISFIED | EXTENDED)");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  while(!(from->maxext == lgl->maxext))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglclass");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not clone assignments for different sets of variables");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  if((EXTENDED & (signed int)from->state) == 0)
    lglextend(from);

  lglreset(lgl);
  lgleunassignall(lgl);
  lgl->changed = 0;
  cloned = lgl->changed;
  eidx = 1;
  for( ; lgl->maxext >= eidx; eidx = eidx + 1)
  {
    extlgl=lglelit2ext(lgl, eidx);
    if(!(extlgl->imported == 0u))
    {
      extfrom=lglelit2ext(from, eidx);
      while(extfrom->imported == 0u)
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglclass");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "can not clone assignment of literal imported only by 'to'");
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      lgleassign(lgl, (signed int)extfrom->val * eidx);
      cloned = cloned + 1;
    }

  }
  lglcomputechanged(lgl);
  lglprt(lgl, 1, "[class] cloned %d assignments (%d changed)", cloned, lgl->changed);

__CPROVER_DUMP_L20:
  ;
  do
    lgl->state = (enum State)EXTENDED;
  while((_Bool)0);
}

// lglcleanrepr
// file lglib.c line 13904
static void lglcleanrepr(struct LGL *lgl, struct Stk *represented, signed int *repr)
{
  signed int idx;
  signed int return_value_lglmtstk$1;
  do
  {
    return_value_lglmtstk$1=lglmtstk(represented);
    if(!(return_value_lglmtstk$1 == 0))
      break;

    idx=lglpopstk(represented);
    repr[(signed long int)idx] = 0;
  }
  while((_Bool)1);
}

// lglcliff
// file lglib.c line 12065
static signed int lglcliff(struct LGL *lgl)
{
  signed int lifted;
  signed int failed;
  signed int oldlifted;
  signed int oldfailed;
  signed int success;
  lglstart(lgl, &lgl->times->cliff);
  lgl->stats->cliff.count = lgl->stats->cliff.count + 1;
  lgl->cliffing = (char)1;
  lgl->simp = lgl->cliffing;
  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Cliff) /*48ul*/ );
    lgl->$anon0.cliff = (struct Cliff *)return_value_lglnew$1;
  }
  while((_Bool)0);
  if(lgl->level >= 1)
    lglbacktrack(lgl, 0);

  oldlifted = lgl->stats->cliff.lifted;
  oldfailed = lgl->stats->cliff.failed;
  lglsetclifflim(lgl);
  signed int return_value_lglrandlitrav$2;
  return_value_lglrandlitrav$2=lglrandlitrav(lgl, lglclifflit);
  if(!(return_value_lglrandlitrav$2 == 0))
    lglcliffclauses(lgl, &lgl->irr);

  lifted = lgl->stats->cliff.lifted - oldlifted;
  failed = lgl->stats->cliff.failed - oldfailed;
  lglprt(lgl, 1, "[cliff-%d] failed %d, lifted %d", lgl->stats->cliff.count, failed, lifted);
  lgl->cliffing = (char)0;
  lgl->simp = lgl->cliffing;
  lglrelstk(lgl, &lgl->$anon0.cliff->lift);
  lglrelstk(lgl, &lgl->$anon0.cliff->lits);
  do
  {
    lgldel(lgl, (void *)lgl->$anon0.cliff, (unsigned long int)1 * sizeof(struct Cliff) /*48ul*/ );
    lgl->$anon0.cliff = ((struct Cliff *)NULL);
  }
  while((_Bool)0);
  success = (signed int)(failed != 0 || lifted != 0);
  lglupdcliffint(lgl, success);
  lglrep(lgl, 1 + (signed int)!(success != 0), (char)75);
  lglstop(lgl);
  return (signed int)!(lgl->mt != 0);
}

// lglcliffclause
// file lglib.c line 11924
static void lglcliffclause(struct LGL *lgl, const signed int *c)
{
  signed int lit;
  signed int lglcliffclause$$1$$start;
  signed int i;
  signed int first;
  signed int dom;
  signed int other;
  signed int *r;
  const signed int *p;
  const signed int *q;
  p = c;
  signed char return_value_lglval$1;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    return_value_lglval$1=lglval(lgl, lit);
    if((signed int)return_value_lglval$1 >= 1)
      goto __CPROVER_DUMP_L27;

    p = p + 1l;
  }
  while((_Bool)1);

__CPROVER_DUMP_L4:
  ;
  unsigned long int return_value_lglcntstk$2;
  return_value_lglcntstk$2=lglcntstk(&lgl->trail);
  lglcliffclause$$1$$start = (signed int)return_value_lglcntstk$2;
  first = 1;
  p = c;
  unsigned long int return_value_lglcntstk$6;
  signed char return_value_lglval$8;
  signed int *tmp_post$7;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    signed char return_value_lglval$3;
    return_value_lglval$3=lglval(lgl, lit);
    if((signed int)return_value_lglval$3 >= 0)
    {
      lgl->stats->cliff.decisions = lgl->stats->cliff.decisions + 1l;
      lgliassume(lgl, lit);
      signed int return_value_lglbcp$5;
      return_value_lglbcp$5=lglbcp(lgl);
      if(return_value_lglbcp$5 == 0)
      {

      __CPROVER_DUMP_L6:
        ;
        dom=lglprbana(lgl, lit);
        lglbacktrack(lgl, 0);
        lgl->stats->cliff.failed = lgl->stats->cliff.failed + 1;
        lglunit(lgl, -dom);
        signed int return_value_lglbcp$4;
        return_value_lglbcp$4=lglbcp(lgl);
        if(return_value_lglbcp$4 == 0)
        {

        __CPROVER_DUMP_L7:
          ;
          lgl->mt = 1;
        }

        goto DONE;
      }

      if(!(first == 0))
      {
        i = lglcliffclause$$1$$start;
        do
        {
          return_value_lglcntstk$6=lglcntstk(&lgl->trail);
          if((unsigned long int)i >= return_value_lglcntstk$6)
            break;

          other=lglpeek(&lgl->trail, i);
          lglpushstk(lgl, &lgl->$anon0.cliff->lift, other);
          i = i + 1;
        }
        while((_Bool)1);
        first = 0;
      }

      else
      {
        r = lgl->$anon0.cliff->lift.start;
        q = r;
        for( ; !(q >= lgl->$anon0.cliff->lift.top); q = q + 1l)
        {
          other = *q;
          return_value_lglval$8=lglval(lgl, other);
          if((signed int)return_value_lglval$8 >= 1)
          {
            tmp_post$7 = r;
            r = r + 1l;
            *tmp_post$7 = other;
          }

        }
        lgl->$anon0.cliff->lift.top = r;
      }
      lglbacktrack(lgl, 0);
      signed int return_value_lglmtstk$9;
      return_value_lglmtstk$9=lglmtstk(&lgl->$anon0.cliff->lift);
      if(!(return_value_lglmtstk$9 == 0))
        goto __CPROVER_DUMP_L27;

    }

    p = p + 1l;
  }
  while((_Bool)1);
  signed int return_value_lglmtstk$10;
  do
  {
    return_value_lglmtstk$10=lglmtstk(&lgl->$anon0.cliff->lift);
    if(!(return_value_lglmtstk$10 == 0))
      break;

    lit=lglpopstk(&lgl->$anon0.cliff->lift);

  __CPROVER_DUMP_L20:
    ;
    lgl->stats->cliff.lifted = lgl->stats->cliff.lifted + 1;
    signed char return_value_lglval$11;
    return_value_lglval$11=lglval(lgl, lit);
    if(!((signed int)return_value_lglval$11 >= 1))
    {
      signed char return_value_lglval$12;
      return_value_lglval$12=lglval(lgl, lit);
      if(!((signed int)return_value_lglval$12 >= 0))
      {

      __CPROVER_DUMP_L21:
        ;
        lgl->mt = 1;
        break;
      }

      lglunit(lgl, lit);
      signed int return_value_lglbcp$13;
      return_value_lglbcp$13=lglbcp(lgl);
      if(return_value_lglbcp$13 == 0)
      {

      __CPROVER_DUMP_L23:
        ;
        lgl->mt = 1;
        break;
      }

    }

  }
  while((_Bool)1);

DONE:
  ;
  lglclnstk(&lgl->$anon0.cliff->lift);

__CPROVER_DUMP_L27:
  ;
}

// lglcliffclauses
// file lglib.c line 11987
static signed int lglcliffclauses(struct LGL *lgl, struct Stk *stk)
{
  const signed int *c;
  const signed int *p;
  c = stk->start;
  signed long int tmp_post$1;
  for( ; !(c >= stk->top); c = p + (signed long int)1)
  {
    p = c;
    if(!(*p >= 0x7fffffff))
    {
      tmp_post$1 = lgl->stats->cliff.steps;
      lgl->stats->cliff.steps = lgl->stats->cliff.steps + 1l;
      if(tmp_post$1 >= lgl->limits->cliff.steps)
        return 0;

      lglcliffclause(lgl, c);
      if(!(lgl->mt == 0))
        return 0;

      p = c;
      for( ; !(*p == 0); p = p + 1l)
        ;
    }

  }
  return 1;
}

// lglcliffing
// file lglib.c line 17015
static signed int lglcliffing(struct LGL *lgl)
{
  return lgl->opts->cliff.val;
}

// lglclifflit
// file lglib.c line 12000
static signed int lglclifflit(struct LGL *lgl, signed int lit)
{
  const signed int *w;
  const signed int *eow;
  const signed int *p;
  const signed int *c;
  const signed int *l;
  signed int res;
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  struct HTS *hts;
  signed int return_value_lglisfree$1;
  return_value_lglisfree$1=lglisfree(lgl, lit);
  signed long int tmp_post$2;
  _Bool tmp_if_expr$7;
  if(return_value_lglisfree$1 == 0)
    return 1;

  else
  {
    tmp_post$2 = lgl->stats->cliff.steps;
    lgl->stats->cliff.steps = lgl->stats->cliff.steps + 1l;
    if(tmp_post$2 >= lgl->limits->cliff.steps)
      return 0;

    else
    {
      hts=lglhts(lgl, lit);
      w=lglhts2wchs(lgl, hts);
      eow = w + (signed long int)hts->count;
      p = w;
      for( ; !(p >= eow); p = p + 1l)
      {
        blit = *p;
        tag = blit & MASKCS;
        if(tag == TRNCS || tag == LRGCS)
          p = p + 1l;

        if(!(tag == BINCS))
        {
          if(tag == TRNCS)
          {
            other = blit >> RMSHFT;
            signed int return_value_abs$3;
            return_value_abs$3=abs(other);
            signed int return_value_abs$4;
            return_value_abs$4=abs(lit);
            if(!(return_value_abs$3 >= return_value_abs$4))
              goto __CPROVER_DUMP_L9;

            other2 = *p;
            signed int return_value_abs$5;
            return_value_abs$5=abs(other2);
            signed int return_value_abs$6;
            return_value_abs$6=abs(lit);
            if(!(return_value_abs$5 >= return_value_abs$6))
              goto __CPROVER_DUMP_L9;

            lglpushstk(lgl, &lgl->$anon0.cliff->lits, lit);
            lglpushstk(lgl, &lgl->$anon0.cliff->lits, other);
            lglpushstk(lgl, &lgl->$anon0.cliff->lits, other2);
          }

          else
          {
            c=lglidx2lits(lgl, LRGCS, blit & REDCS, *p);
            if(!(*c == lit))
              goto __CPROVER_DUMP_L9;

            l = c;
            do
            {
              other = *l;
              if(other == 0)
                break;

              lglpushstk(lgl, &lgl->$anon0.cliff->lits, other);
              l = l + 1l;
            }
            while((_Bool)1);
          }
          lglpushstk(lgl, &lgl->$anon0.cliff->lits, 0);
        }


      __CPROVER_DUMP_L9:
        ;
      }
      res=lglcliffclauses(lgl, &lgl->$anon0.cliff->lits);
      lglclnstk(&lgl->$anon0.cliff->lits);
      if(!(res == 0))
        tmp_if_expr$7 = !(lgl->mt != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$7 = (_Bool)0;
      return (signed int)tmp_if_expr$7;
    }
  }
}

// lglclnana
// file lglib.c line 5830
static void lglclnana(struct LGL *lgl)
{
  lglclnstk(&lgl->clause);
  lglpopnunmarkstk(lgl, &lgl->seen);
  lglclnframes(lgl);
}

// lglclnframes
// file lglib.c line 5813
static void lglclnframes(struct LGL *lgl)
{
  signed int return_value_lglmtstk$1;
  signed int return_value_lglpopstk$2;
  do
  {
    return_value_lglmtstk$1=lglmtstk(&lgl->frames);
    if(!(return_value_lglmtstk$1 == 0))
      break;

    return_value_lglpopstk$2=lglpopstk(&lgl->frames);
    lglunuselevel(lgl, return_value_lglpopstk$2);
  }
  while((_Bool)1);
}

// lglclnpoisoned
// file lglib.c line 5818
static void lglclnpoisoned(struct LGL *lgl)
{
  struct AVar *av;
  signed int lit;
  signed int return_value_lglmtstk$1;
  do
  {
    return_value_lglmtstk$1=lglmtstk(&lgl->poisoned);
    if(!(return_value_lglmtstk$1 == 0))
      break;

    lit=lglpopstk(&lgl->poisoned);
    av=lglavar(lgl, lit);
    av->poisoned = (unsigned int)0;
  }
  while((_Bool)1);
}

// lglclnstk
// file lglib.c line 1472
static void lglclnstk(struct Stk *s)
{
  lglrststk(s, 0);
}

// lglclone
// file lglib.c line 1990
struct LGL * lglclone(struct LGL *orig)
{
  unsigned long int max_bytes;
  unsigned long int current_bytes;
  struct LGL *lgl = orig;
  signed int glue;
  if(orig == ((struct LGL *)NULL))
    return ((struct LGL *)NULL);

  else
  {
    lglcompact(orig);

  __CPROVER_DUMP_L2:
    ;
    lgl=lglnewlgl(orig->mem->state, orig->mem->alloc, orig->mem->realloc, orig->mem->dealloc);
    memcpy((void *)lgl, (const void *)orig, (unsigned long int)((char *)&orig->mem - (char *)orig));
    max_bytes = lgl->stats->bytes.max;
    current_bytes = lgl->stats->bytes.current;
    memcpy((void *)lgl->stats, (const void *)orig->stats, sizeof(struct Stats) /*2272ul*/ );
    lgl->stats->bytes.current = current_bytes;
    lgl->stats->bytes.max = max_bytes;
    memcpy((void *)lgl->opts, (const void *)orig->opts, sizeof(struct Opts) /*5680ul*/ );
    lgl->out = orig->out;
    lgl->prefix=lglstrdup(lgl, orig->prefix);
    if(!(orig->cbs == ((struct Cbs *)NULL)))
    {
      lglinitcbs(lgl);
      if(!(orig->cbs->onabort == ((void (*)(void *))NULL)))
      {
        lgl->cbs->abortstate = orig->cbs->abortstate;
        lgl->cbs->onabort = orig->cbs->onabort;
      }

      if(!(orig->cbs->getime == ((double (*)(void))NULL)))
        lgl->cbs->getime = orig->cbs->getime;

    }

    do
    {

    __CPROVER_DUMP_L4:
      ;
      void *return_value_lglnew$1;
      return_value_lglnew$1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Limits) /*352ul*/ );
      lgl->limits = (struct Limits *)return_value_lglnew$1;
      memcpy((void *)lgl->limits, (const void *)orig->limits, (unsigned long int)1 * sizeof(struct Limits) /*352ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L5:
      ;
      void *return_value_lglnew$2;
      return_value_lglnew$2=lglnew(lgl, (unsigned long int)1 * sizeof(struct Times) /*240ul*/ );
      lgl->times = (struct Times *)return_value_lglnew$2;
      memcpy((void *)lgl->times, (const void *)orig->times, (unsigned long int)1 * sizeof(struct Times) /*240ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L6:
      ;
      void *return_value_lglnew$3;
      return_value_lglnew$3=lglnew(lgl, (unsigned long int)1 * sizeof(struct Tmrs) /*128ul*/ );
      lgl->timers = (struct Tmrs *)return_value_lglnew$3;
      memcpy((void *)lgl->timers, (const void *)orig->timers, (unsigned long int)1 * sizeof(struct Tmrs) /*128ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L7:
      ;
      void *return_value_lglnew$4;
      return_value_lglnew$4=lglnew(lgl, (unsigned long int)1 * sizeof(struct FltStr) /*604ul*/ );
      lgl->fltstr = (struct FltStr *)return_value_lglnew$4;
      memcpy((void *)lgl->fltstr, (const void *)orig->fltstr, (unsigned long int)1 * sizeof(struct FltStr) /*604ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L8:
      ;
      void *return_value_lglnew$5;
      return_value_lglnew$5=lglnew(lgl, (unsigned long int)orig->szext * sizeof(struct Ext) /*32ul*/ );
      lgl->ext = (struct Ext *)return_value_lglnew$5;
      memcpy((void *)lgl->ext, (const void *)orig->ext, (unsigned long int)orig->szext * sizeof(struct Ext) /*32ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L9:
      ;
      void *return_value_lglnew$6;
      return_value_lglnew$6=lglnew(lgl, (unsigned long int)orig->szvars * sizeof(signed int) /*4ul*/ );
      lgl->i2e = (signed int *)return_value_lglnew$6;
      memcpy((void *)lgl->i2e, (const void *)orig->i2e, (unsigned long int)orig->szvars * sizeof(signed int) /*4ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L10:
      ;
      void *return_value_lglnew$7;
      return_value_lglnew$7=lglnew(lgl, (unsigned long int)(2 * orig->szvars) * sizeof(signed int) /*4ul*/ );
      lgl->doms = (signed int *)return_value_lglnew$7;
      memcpy((void *)lgl->doms, (const void *)orig->doms, (unsigned long int)(2 * orig->szvars) * sizeof(signed int) /*4ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L11:
      ;
      void *return_value_lglnew$8;
      return_value_lglnew$8=lglnew(lgl, (unsigned long int)orig->szvars * sizeof(struct DVar) /*16ul*/ );
      lgl->dvars = (struct DVar *)return_value_lglnew$8;
      memcpy((void *)lgl->dvars, (const void *)orig->dvars, (unsigned long int)orig->szvars * sizeof(struct DVar) /*16ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L12:
      ;
      void *return_value_lglnew$9;
      return_value_lglnew$9=lglnew(lgl, (unsigned long int)orig->szvars * sizeof(struct AVar) /*12ul*/ );
      lgl->avars = (struct AVar *)return_value_lglnew$9;
      memcpy((void *)lgl->avars, (const void *)orig->avars, (unsigned long int)orig->szvars * sizeof(struct AVar) /*12ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L13:
      ;
      void *return_value_lglnew$10;
      return_value_lglnew$10=lglnew(lgl, (unsigned long int)orig->szvars * sizeof(signed char) /*1ul*/ );
      lgl->vals = (signed char *)return_value_lglnew$10;
      memcpy((void *)lgl->vals, (const void *)orig->vals, (unsigned long int)orig->szvars * sizeof(signed char) /*1ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L14:
      ;
      void *return_value_lglnew$11;
      return_value_lglnew$11=lglnew(lgl, (unsigned long int)(2 * orig->szvars) * sizeof(signed long int) /*8ul*/ );
      lgl->jwh = (signed long int *)return_value_lglnew$11;
      memcpy((void *)lgl->jwh, (const void *)orig->jwh, (unsigned long int)(2 * orig->szvars) * sizeof(signed long int) /*8ul*/ );
    }
    while((_Bool)0);
    do
    {

    __CPROVER_DUMP_L15:
      ;
      void *return_value_lglnew$12;
      return_value_lglnew$12=lglnew(lgl, (unsigned long int)orig->szdrail * sizeof(struct TD) /*12ul*/ );
      lgl->drail = (struct TD *)return_value_lglnew$12;
      memcpy((void *)lgl->drail, (const void *)orig->drail, (unsigned long int)orig->szdrail * sizeof(struct TD) /*12ul*/ );
    }
    while((_Bool)0);
    lglqclone(lgl, orig);
    do
    {
      void *return_value_lglnew$13;
      return_value_lglnew$13=lglnew(lgl, (unsigned long int)(((1 << 4) - 1) + 1) * sizeof(struct Stk) /*24ul*/ );
      lgl->red = (struct Stk *)return_value_lglnew$13;
    }
    while((_Bool)0);
    glue = 0;
    for( ; !(glue >= 16); glue = glue + 1)
      do
      {
        unsigned long int lglclone$$1$$16$$1$$COUNT = (unsigned long int)((orig->red + (signed long int)glue)->top - (orig->red + (signed long int)glue)->start);
        unsigned long int lglclone$$1$$16$$1$$SIZE = (unsigned long int)((orig->red + (signed long int)glue)->end - (orig->red + (signed long int)glue)->start);
        unsigned long int lglclone$$1$$16$$1$$BYTES = lglclone$$1$$16$$1$$SIZE * sizeof(signed int) /*4ul*/ ;
        do
        {
          void *return_value_lglnew$14;
          return_value_lglnew$14=lglnew(lgl, lglclone$$1$$16$$1$$SIZE * sizeof(signed int) /*4ul*/ );
          (lgl->red + (signed long int)glue)->start = (signed int *)return_value_lglnew$14;
        }
        while((_Bool)0);
        memcpy((void *)(lgl->red + (signed long int)glue)->start, (const void *)(orig->red + (signed long int)glue)->start, lglclone$$1$$16$$1$$BYTES);
        (lgl->red + (signed long int)glue)->top = (lgl->red + (signed long int)glue)->start + (signed long int)lglclone$$1$$16$$1$$COUNT;
        (lgl->red + (signed long int)glue)->end = (lgl->red + (signed long int)glue)->start + (signed long int)lglclone$$1$$16$$1$$SIZE;
      }
      while((_Bool)0);
    do
    {
      void *return_value_lglnew$15;
      return_value_lglnew$15=lglnew(lgl, (unsigned long int)1 * sizeof(struct Wchs) /*152ul*/ );
      lgl->wchs = (struct Wchs *)return_value_lglnew$15;
    }
    while((_Bool)0);
    memcpy((void *)lgl->wchs, (const void *)orig->wchs, sizeof(struct Wchs) /*152ul*/ );
    do
    {
      unsigned long int lglclone$$1$$18$$COUNT = (unsigned long int)(orig->wchs->stk.top - orig->wchs->stk.start);
      unsigned long int lglclone$$1$$18$$SIZE = (unsigned long int)(orig->wchs->stk.end - orig->wchs->stk.start);
      unsigned long int lglclone$$1$$18$$BYTES = lglclone$$1$$18$$SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew$16;
        return_value_lglnew$16=lglnew(lgl, lglclone$$1$$18$$SIZE * sizeof(signed int) /*4ul*/ );
        lgl->wchs->stk.start = (signed int *)return_value_lglnew$16;
      }
      while((_Bool)0);
      memcpy((void *)lgl->wchs->stk.start, (const void *)orig->wchs->stk.start, lglclone$$1$$18$$BYTES);
      lgl->wchs->stk.top = lgl->wchs->stk.start + (signed long int)lglclone$$1$$18$$COUNT;
      lgl->wchs->stk.end = lgl->wchs->stk.start + (signed long int)lglclone$$1$$18$$SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone$$1$$19$$COUNT = (unsigned long int)(orig->control.top - orig->control.start);
      unsigned long int lglclone$$1$$19$$SIZE = (unsigned long int)(orig->control.end - orig->control.start);
      unsigned long int lglclone$$1$$19$$BYTES = lglclone$$1$$19$$SIZE * sizeof(struct Ctr) /*4ul*/ ;
      do
      {
        void *return_value_lglnew$17;
        return_value_lglnew$17=lglnew(lgl, lglclone$$1$$19$$SIZE * sizeof(struct Ctr) /*4ul*/ );
        lgl->control.start = (struct Ctr *)return_value_lglnew$17;
      }
      while((_Bool)0);
      memcpy((void *)lgl->control.start, (const void *)orig->control.start, lglclone$$1$$19$$BYTES);
      lgl->control.top = lgl->control.start + (signed long int)lglclone$$1$$19$$COUNT;
      lgl->control.end = lgl->control.start + (signed long int)lglclone$$1$$19$$SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int COUNT = (unsigned long int)(orig->clause.top - orig->clause.start);
      unsigned long int SIZE = (unsigned long int)(orig->clause.end - orig->clause.start);
      unsigned long int lglclone$$1$$20$$BYTES = SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew$18;
        return_value_lglnew$18=lglnew(lgl, SIZE * sizeof(signed int) /*4ul*/ );
        lgl->clause.start = (signed int *)return_value_lglnew$18;
      }
      while((_Bool)0);
      memcpy((void *)lgl->clause.start, (const void *)orig->clause.start, lglclone$$1$$20$$BYTES);
      lgl->clause.top = lgl->clause.start + (signed long int)COUNT;
      lgl->clause.end = lgl->clause.start + (signed long int)SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone$$1$$21$$COUNT = (unsigned long int)(orig->eclause.top - orig->eclause.start);
      unsigned long int lglclone$$1$$21$$SIZE = (unsigned long int)(orig->eclause.end - orig->eclause.start);
      unsigned long int lglclone$$1$$21$$BYTES = lglclone$$1$$21$$SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew$19;
        return_value_lglnew$19=lglnew(lgl, lglclone$$1$$21$$SIZE * sizeof(signed int) /*4ul*/ );
        lgl->eclause.start = (signed int *)return_value_lglnew$19;
      }
      while((_Bool)0);
      memcpy((void *)lgl->eclause.start, (const void *)orig->eclause.start, lglclone$$1$$21$$BYTES);
      lgl->eclause.top = lgl->eclause.start + (signed long int)lglclone$$1$$21$$COUNT;
      lgl->eclause.end = lgl->eclause.start + (signed long int)lglclone$$1$$21$$SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone$$1$$22$$COUNT = (unsigned long int)(orig->extend.top - orig->extend.start);
      unsigned long int lglclone$$1$$22$$SIZE = (unsigned long int)(orig->extend.end - orig->extend.start);
      unsigned long int lglclone$$1$$22$$BYTES = lglclone$$1$$22$$SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew$20;
        return_value_lglnew$20=lglnew(lgl, lglclone$$1$$22$$SIZE * sizeof(signed int) /*4ul*/ );
        lgl->extend.start = (signed int *)return_value_lglnew$20;
      }
      while((_Bool)0);
      memcpy((void *)lgl->extend.start, (const void *)orig->extend.start, lglclone$$1$$22$$BYTES);
      lgl->extend.top = lgl->extend.start + (signed long int)lglclone$$1$$22$$COUNT;
      lgl->extend.end = lgl->extend.start + (signed long int)lglclone$$1$$22$$SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone$$1$$23$$COUNT = (unsigned long int)(orig->irr.top - orig->irr.start);
      unsigned long int lglclone$$1$$23$$SIZE = (unsigned long int)(orig->irr.end - orig->irr.start);
      unsigned long int lglclone$$1$$23$$BYTES = lglclone$$1$$23$$SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew$21;
        return_value_lglnew$21=lglnew(lgl, lglclone$$1$$23$$SIZE * sizeof(signed int) /*4ul*/ );
        lgl->irr.start = (signed int *)return_value_lglnew$21;
      }
      while((_Bool)0);
      memcpy((void *)lgl->irr.start, (const void *)orig->irr.start, lglclone$$1$$23$$BYTES);
      lgl->irr.top = lgl->irr.start + (signed long int)lglclone$$1$$23$$COUNT;
      lgl->irr.end = lgl->irr.start + (signed long int)lglclone$$1$$23$$SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone$$1$$24$$COUNT = (unsigned long int)(orig->trail.top - orig->trail.start);
      unsigned long int lglclone$$1$$24$$SIZE = (unsigned long int)(orig->trail.end - orig->trail.start);
      unsigned long int lglclone$$1$$24$$BYTES = lglclone$$1$$24$$SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew$22;
        return_value_lglnew$22=lglnew(lgl, lglclone$$1$$24$$SIZE * sizeof(signed int) /*4ul*/ );
        lgl->trail.start = (signed int *)return_value_lglnew$22;
      }
      while((_Bool)0);
      memcpy((void *)lgl->trail.start, (const void *)orig->trail.start, lglclone$$1$$24$$BYTES);
      lgl->trail.top = lgl->trail.start + (signed long int)lglclone$$1$$24$$COUNT;
      lgl->trail.end = lgl->trail.start + (signed long int)lglclone$$1$$24$$SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone$$1$$25$$COUNT = (unsigned long int)(orig->frames.top - orig->frames.start);
      unsigned long int lglclone$$1$$25$$SIZE = (unsigned long int)(orig->frames.end - orig->frames.start);
      unsigned long int lglclone$$1$$25$$BYTES = lglclone$$1$$25$$SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew$23;
        return_value_lglnew$23=lglnew(lgl, lglclone$$1$$25$$SIZE * sizeof(signed int) /*4ul*/ );
        lgl->frames.start = (signed int *)return_value_lglnew$23;
      }
      while((_Bool)0);
      memcpy((void *)lgl->frames.start, (const void *)orig->frames.start, lglclone$$1$$25$$BYTES);
      lgl->frames.top = lgl->frames.start + (signed long int)lglclone$$1$$25$$COUNT;
      lgl->frames.end = lgl->frames.start + (signed long int)lglclone$$1$$25$$SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone$$1$$26$$COUNT = (unsigned long int)(orig->eassume.top - orig->eassume.start);
      unsigned long int lglclone$$1$$26$$SIZE = (unsigned long int)(orig->eassume.end - orig->eassume.start);
      unsigned long int lglclone$$1$$26$$BYTES = lglclone$$1$$26$$SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew$24;
        return_value_lglnew$24=lglnew(lgl, lglclone$$1$$26$$SIZE * sizeof(signed int) /*4ul*/ );
        lgl->eassume.start = (signed int *)return_value_lglnew$24;
      }
      while((_Bool)0);
      memcpy((void *)lgl->eassume.start, (const void *)orig->eassume.start, lglclone$$1$$26$$BYTES);
      lgl->eassume.top = lgl->eassume.start + (signed long int)lglclone$$1$$26$$COUNT;
      lgl->eassume.end = lgl->eassume.start + (signed long int)lglclone$$1$$26$$SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone$$1$$27$$COUNT = (unsigned long int)(orig->assume.top - orig->assume.start);
      unsigned long int lglclone$$1$$27$$SIZE = (unsigned long int)(orig->assume.end - orig->assume.start);
      unsigned long int lglclone$$1$$27$$BYTES = lglclone$$1$$27$$SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew$25;
        return_value_lglnew$25=lglnew(lgl, lglclone$$1$$27$$SIZE * sizeof(signed int) /*4ul*/ );
        lgl->assume.start = (signed int *)return_value_lglnew$25;
      }
      while((_Bool)0);
      memcpy((void *)lgl->assume.start, (const void *)orig->assume.start, lglclone$$1$$27$$BYTES);
      lgl->assume.top = lgl->assume.start + (signed long int)lglclone$$1$$27$$COUNT;
      lgl->assume.end = lgl->assume.start + (signed long int)lglclone$$1$$27$$SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone$$1$$28$$COUNT = (unsigned long int)(orig->fassume.top - orig->fassume.start);
      unsigned long int lglclone$$1$$28$$SIZE = (unsigned long int)(orig->fassume.end - orig->fassume.start);
      unsigned long int BYTES = lglclone$$1$$28$$SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew$26;
        return_value_lglnew$26=lglnew(lgl, lglclone$$1$$28$$SIZE * sizeof(signed int) /*4ul*/ );
        lgl->fassume.start = (signed int *)return_value_lglnew$26;
      }
      while((_Bool)0);
      memcpy((void *)lgl->fassume.start, (const void *)orig->fassume.start, BYTES);
      lgl->fassume.top = lgl->fassume.start + (signed long int)lglclone$$1$$28$$COUNT;
      lgl->fassume.end = lgl->fassume.start + (signed long int)lglclone$$1$$28$$SIZE;
    }
    while((_Bool)0);
    do
    {
      unsigned long int lglclone$$1$$29$$COUNT = (unsigned long int)(orig->cassume.top - orig->cassume.start);
      unsigned long int lglclone$$1$$29$$SIZE = (unsigned long int)(orig->cassume.end - orig->cassume.start);
      unsigned long int lglclone$$1$$29$$BYTES = lglclone$$1$$29$$SIZE * sizeof(signed int) /*4ul*/ ;
      do
      {
        void *return_value_lglnew$27;
        return_value_lglnew$27=lglnew(lgl, lglclone$$1$$29$$SIZE * sizeof(signed int) /*4ul*/ );
        lgl->cassume.start = (signed int *)return_value_lglnew$27;
      }
      while((_Bool)0);
      memcpy((void *)lgl->cassume.start, (const void *)orig->cassume.start, lglclone$$1$$29$$BYTES);
      lgl->cassume.top = lgl->cassume.start + (signed long int)lglclone$$1$$29$$COUNT;
      lgl->cassume.end = lgl->cassume.start + (signed long int)lglclone$$1$$29$$SIZE;
    }
    while((_Bool)0);
    lgl->stats->bytes.max = orig->stats->bytes.max;
    return lgl;
  }
}

// lglclsr
// file lglib.c line 13663
static void lglclsr(struct LGL *lgl)
{
  signed int lit;
  signed int return_value_lglterminate$1;
  signed int return_value_lglcgrlimhit$2;
  signed int return_value_lglcgrlimhit$3;
  while(lgl->mt == 0)
  {
    return_value_lglterminate$1=lglterminate(lgl);
    if(!(return_value_lglterminate$1 == 0))
      break;

    lit=lglwrknext(lgl);
    if(lit == 0)
      break;

    return_value_lglcgrlimhit$2=lglcgrlimhit(lgl);
    if(!(return_value_lglcgrlimhit$2 == 0))
      break;

    lglcgrlit(lgl, lit);
    if(lgl->mt == 0)
    {
      return_value_lglcgrlimhit$3=lglcgrlimhit(lgl);
      if(return_value_lglcgrlimhit$3 == 0)
        lglcgrlit(lgl, -lit);

    }

  }
  if(!(lgl->$anon0.cgr->simplified.all == 0))
    lglprt(lgl, 2, "[closure-%d] simplified %d gates", lgl->stats->cgr.count, lgl->$anon0.cgr->simplified.all);

  if(!(lgl->$anon0.cgr->simplified.and == 0))
    lglprt(lgl, 2, "[closure-%d] simplified %d and gates", lgl->stats->cgr.count, lgl->$anon0.cgr->simplified.and);

  if(!(lgl->$anon0.cgr->simplified.xor == 0))
    lglprt(lgl, 2, "[closure-%d] simplified %d xor gates", lgl->stats->cgr.count, lgl->$anon0.cgr->simplified.xor);

  if(!(lgl->$anon0.cgr->simplified.ite == 0))
    lglprt(lgl, 2, "[closure-%d] simplified %d ite gates", lgl->stats->cgr.count, lgl->$anon0.cgr->simplified.ite);

  if(!(lgl->$anon0.cgr->matched.all == 0))
    lglprt(lgl, 2, "[closure-%d] matched %d gates", lgl->stats->cgr.count, lgl->$anon0.cgr->matched.all);

  double return_value_lglpcnt$4;
  if(!(lgl->$anon0.cgr->matched.and == 0))
  {
    return_value_lglpcnt$4=lglpcnt((double)lgl->$anon0.cgr->matched.and, (double)lgl->$anon0.cgr->matched.all);
    lglprt(lgl, 2, "[closure-%d] matched %d and gates %.0f%%", lgl->stats->cgr.count, lgl->$anon0.cgr->matched.and, return_value_lglpcnt$4);
  }

  double return_value_lglpcnt$5;
  if(!(lgl->$anon0.cgr->matched.xor == 0))
  {
    return_value_lglpcnt$5=lglpcnt((double)lgl->$anon0.cgr->matched.xor, (double)lgl->$anon0.cgr->matched.all);
    lglprt(lgl, 2, "[closure-%d] matched %d xor gates %.0f%%", lgl->stats->cgr.count, lgl->$anon0.cgr->matched.xor, return_value_lglpcnt$5);
  }

  double return_value_lglpcnt$6;
  if(!(lgl->$anon0.cgr->matched.ite == 0))
  {
    return_value_lglpcnt$6=lglpcnt((double)lgl->$anon0.cgr->matched.ite, (double)lgl->$anon0.cgr->matched.all);
    lglprt(lgl, 2, "[closure-%d] matched %d ite gates %.0f%%", lgl->stats->cgr.count, lgl->$anon0.cgr->matched.ite, return_value_lglpcnt$6);
  }

}

// lglcmpagsl
// file lglib.c line 5128
static signed int lglcmpagsl(struct ASL *a, struct ASL *b)
{
  signed int res = a->act - b->act;
  if(!(res == 0))
    return res;

  else
  {
    res = (b->lidx & (1 << 4) - 1) - (a->lidx & (1 << 4) - 1);
    if(!(res == 0))
      return res;

    else
    {
      res = b->size - a->size;
      if(!(res == 0))
        return res;

      else
        return a->lidx - b->lidx;
    }
  }
}

// lglcmpasgl
// file lglib.c line 5136
static signed int lglcmpasgl(struct ASL *a, struct ASL *b)
{
  signed int res = a->act - b->act;
  if(!(res == 0))
    return res;

  else
  {
    res = b->size - a->size;
    if(!(res == 0))
      return res;

    else
    {
      res = (b->lidx & (1 << 4) - 1) - (a->lidx & (1 << 4) - 1);
      if(!(res == 0))
        return res;

      else
        return a->lidx - b->lidx;
    }
  }
}

// lglcmpdfl
// file lglib.c line 15489
static signed int lglcmpdfl(const struct DFL *a, const struct DFL *b)
{
  return a->discovered - b->discovered;
}

// lglcmpfdat
// file lglib.c line 7440
static signed int lglcmpfdat(struct ForceData *fdat, signed int l, signed int k)
{
  struct ForceData *d;
  struct ForceData *e;
  l=abs(l);
  k=abs(k);
  d = fdat + (signed long int)l;
  e = fdat + (signed long int)k;
  if(d->sum < e->sum)
    return -1;

  else
    if(d->sum > e->sum)
      return 1;

    else
      if(!(d->pos >= e->pos))
        return -1;

      else
        if(!(e->pos >= d->pos))
          return 1;

        else
          return l - k;
}

// lglcmpgauss
// file lglib.c line 16499
static signed int lglcmpgauss(struct LGL *lgl, signed int a, signed int b)
{
  signed int res;
  signed int return_value_lglgaussoccs$1;
  return_value_lglgaussoccs$1=lglgaussoccs(lgl, a);
  signed int return_value_lglgaussoccs$2;
  return_value_lglgaussoccs$2=lglgaussoccs(lgl, b);
  res = return_value_lglgaussoccs$1 - return_value_lglgaussoccs$2;
  if(res == 0)
    res = a - b;

  return res;
}

// lglcmpgoccs
// file lglib.c line 13081
static signed int lglcmpgoccs(struct LGL *lgl, signed int a, signed int b)
{
  struct Gat *g;
  g=lglgidx2gat(lgl, a);
  struct Gat *h;
  h=lglgidx2gat(lgl, b);
  signed int res = (signed int)g->tag - (signed int)h->tag;
  if(!(res == 0))
    return res;

  else
  {
    res = (signed int)g->size - (signed int)h->size;
    if(!(res == 0))
      return res;

    else
    {
      res = g->minrhs - h->minrhs;
      if(!(res == 0))
        return res;

      else
        return a - b;
    }
  }
}

// lglcmphase
// file lglib.c line 6484
static signed int lglcmphase(struct LGL *lgl, signed int a, signed int b)
{
  signed char return_value_lgliphase$1;
  return_value_lgliphase$1=lgliphase(lgl, b);
  signed char return_value_lgliphase$2;
  return_value_lgliphase$2=lgliphase(lgl, a);
  return (signed int)return_value_lgliphase$1 - (signed int)return_value_lgliphase$2;
}

// lglcmpitecands
// file lglib.c line 12808
static signed int lglcmpitecands(const struct ITEC *c, const struct ITEC *d)
{
  signed int a = c->other;
  signed int b = d->other;
  signed int res;
  signed int return_value_abs$1;
  return_value_abs$1=abs(a);
  signed int return_value_abs$2;
  return_value_abs$2=abs(b);
  res = return_value_abs$1 - return_value_abs$2;
  if(!(res == 0))
    return res;

  else
  {
    res = a - b;
    if(!(res == 0))
      return res;

    else
      return c->other2 - d->other2;
  }
}

// lglcmpocc
// file lglib.c line 12570
static signed int lglcmpocc(struct LGL *lgl, signed int a, signed int b)
{
  signed int return_value_lglocc$1;
  return_value_lglocc$1=lglocc(lgl, a);
  signed int return_value_lglocc$2;
  return_value_lglocc$2=lglocc(lgl, b);
  return return_value_lglocc$1 - return_value_lglocc$2;
}

// lglcmprepr
// file lglib.c line 8187
static signed int lglcmprepr(struct LGL *lgl, signed int a, signed int b)
{
  signed int f;
  f=lglifrozen(lgl, a);
  signed int g;
  g=lglifrozen(lgl, b);
  signed int res = g - f;
  if(!(res == 0))
    return res;

  else
  {
    signed int return_value_abs$1;
    return_value_abs$1=abs(a);
    signed int return_value_abs$2;
    return_value_abs$2=abs(b);
    res = return_value_abs$1 - return_value_abs$2;
    if(!(res == 0))
      return res;

    else
      return a - b;
  }
}

// lglcnf
// file lglib.c line 10734
static signed long int lglcnf(signed int pos, signed int size)
{
  signed long int return_value_lglpos2cnf$1;
  return_value_lglpos2cnf$1=lglpos2cnf(pos);
  signed long int return_value_lglsize2cnf$2;
  return_value_lglsize2cnf$2=lglsize2cnf(size);
  return return_value_lglpos2cnf$1 | return_value_lglsize2cnf$2;
}

// lglcnf2pos
// file lglib.c line 10731
static signed int lglcnf2pos(signed long int cnf)
{
  return (signed int)(cnf & 0xfffffll);
}

// lglcnf2size
// file lglib.c line 10732
static signed int lglcnf2size(signed long int cnf)
{
  return (signed int)(cnf >> 32);
}

// lglcntctk
// file lglib.c line 1544
static signed int lglcntctk(struct Ctk *ctk)
{
  return (signed int)(ctk->top - ctk->start);
}

// lglcntstk
// file lglib.c line 1388
static unsigned long int lglcntstk(struct Stk *s)
{
  return (unsigned long int)(s->top - s->start);
}

// lglcntwtk
// file lglib.c line 14993
static signed int lglcntwtk(struct Wtk *wtk)
{
  return (signed int)(wtk->top - wtk->start);
}

// lglcompact
// file lglib.c line 7609
static void lglcompact(struct LGL *lgl)
{
  signed int glue;
  lglfitstk(lgl, &lgl->assume);
  lglfitstk(lgl, &lgl->clause);
  lglfitstk(lgl, &lgl->eassume);
  lglfitstk(lgl, &lgl->extend);
  lglfitstk(lgl, &lgl->fassume);
  lglfitstk(lgl, &lgl->cassume);
  lglfitstk(lgl, &lgl->frames);
  lglfitstk(lgl, &lgl->trail);
  lgldefrag(lgl);
  lglfitstk(lgl, &lgl->wchs->stk);
  lglfitstk(lgl, &lgl->irr);
  glue = 0;
  for( ; !(glue >= 15); glue = glue + 1)
    lglfitlir(lgl, lgl->red + (signed long int)glue);
  lglrelstk(lgl, &lgl->$anon1.lcaseen);
  lglrelstk(lgl, &lgl->poisoned);
  lglrelstk(lgl, &lgl->seen);
  lglrelstk(lgl, &lgl->esched);
}

// lglcompactify
// file lglib.c line 17573
static signed int lglcompactify(struct LGL *lgl, signed int res)
{
  if(lgl->opts->compact.val == 0)
    return 0;

  else
    if(res == 0)
      return 1;

    else
      if(res == 20)
        return 1;

      else
        return (signed int)(lgl->opts->compact.val >= 2);
}

// lglcompletefork
// file lglib.c line 18926
static void lglcompletefork(struct LGL *dst, struct LGL *src)
{
  signed int eidx;
  signed int erepr;
  signed int val;
  struct Ext *dext;
  struct Ext *rext;
  eidx = 1;
  signed int return_value_abs$1;
  for( ; src->maxext >= eidx; eidx = eidx + 1)
  {
    erepr=lglerepr(src, eidx);
    if(eidx >= dst->szext)
      lgladjext(dst, eidx);

    if(!(dst->maxext >= eidx))
    {
      dst->maxext = eidx;
      lglmelter(dst);
    }

    rext=lglelit2ext(src, erepr);
    dext=lglelit2ext(dst, eidx);
    if(!(erepr == eidx))
    {
      dext->repr = erepr;
      dext->equiv = (unsigned int)1;
      dext->imported = (unsigned int)1;
    }

    else
    {
      return_value_abs$1=abs(rext->repr);
      if(return_value_abs$1 >= 2)
        goto __CPROVER_DUMP_L7;

      else
      {
        val = rext->repr;
        dext->repr = val;
        dext->imported = (unsigned int)1;
      }
    }

  __CPROVER_DUMP_L7:
    ;
  }
}

// lglcomputechanged
// file lglib.c line 17371
static void lglcomputechanged(struct LGL *lgl)
{
  struct Ext *ext;
  signed int eidx;
  lgl->changed = 0;
  eidx = 1;
  for( ; lgl->maxext >= eidx; eidx = eidx + 1)
  {
    ext=lglelit2ext(lgl, eidx);
    if(!(ext->oldval == 0))
    {
      if(!(ext->oldval == ext->val))
        lgl->changed = lgl->changed + 1;

    }

    ext->oldval = (signed int)ext->val;
  }

__CPROVER_DUMP_L3:
  ;
}

// lglcomputecog
// file lglib.c line 18522
static void lglcomputecog(struct LGL *lgl)
{
  signed int eidx;
  signed int minval;
  signed int maxval;
  signed int minvar;
  signed int maxvar;
  signed int count;
  signed long int tmp;
  signed long int avgval;
  signed long int avgvar;
  struct Ext *ext;
  maxvar = 0;
  minvar = maxvar;
  count = minvar;
  avgvar = (signed long int)0;
  avgval = avgvar;
  minval = 0x7fffffff;
  maxval = -1;
  eidx = 1;
  for( ; lgl->maxext >= eidx; eidx = eidx + 1)
  {
    ext=lglelit2ext(lgl, eidx);
    if(!(ext->cog.count == 0))
    {
      tmp = (signed long int)10 * ext->cog.sum;
      tmp = tmp / (signed long int)ext->cog.count;
      tmp = tmp + (signed long int)5;
      tmp = tmp / (signed long int)10;
      if(!(tmp >= (signed long int)minval))
      {
        minval = (signed int)tmp;
        minvar = eidx;
      }

      if(!((signed long int)maxval >= tmp))
      {
        maxval = (signed int)tmp;
        maxvar = eidx;
      }

      avgval = avgval + tmp;
      avgvar = avgvar + (signed long int)eidx;
      count = count + 1;
    }

  }
  if(!(count == 0))
  {
    avgval = avgval * (signed long int)10;
    avgval = avgval / (signed long int)count;
    avgval = avgval + (signed long int)5;
    avgval = avgval / (signed long int)10;
    avgvar = avgvar * (signed long int)10;
    avgvar = avgvar / (signed long int)count;
    avgvar = avgvar + (signed long int)5;
    avgvar = avgvar / (signed long int)10;
  }

  lgl->stats->features.cog.val.min = minval;
  lgl->stats->features.cog.val.avg = (signed int)avgval;
  lgl->stats->features.cog.val.max = maxval;
  lgl->stats->features.cog.var.min = minvar;
  lgl->stats->features.cog.var.avg = (signed int)avgvar;
  lgl->stats->features.cog.var.max = maxvar;
}

// lglcon
// file lglib.c line 6572
static void lglcon(struct LGL *lgl)
{
  signed int glue = -1;
  for( ; !(glue >= 15); glue = glue + 1)
    lglconnaux(lgl, glue);
  lglfullyconnected(lgl);
}

// lglconnaux
// file lglib.c line 6490
static void lglconnaux(struct LGL *lgl, signed int glue)
{
  signed int lit;
  signed int satisfied;
  signed int lidx;
  signed int size;
  signed int red;
  signed int act;
  const signed int *p;
  const signed int *c;
  const signed int *lglconnaux$$1$$start;
  const signed int *top;
  signed int *q;
  signed int *d;
  struct Stk *stk;
  signed char val;
  if(glue >= 0)
  {
    red = REDCS;
    stk = lgl->red + (signed long int)glue;
  }

  else
  {
    red = 0;
    stk = &lgl->irr;
  }
  q = stk->start;
  lglconnaux$$1$$start = q;
  c = lglconnaux$$1$$start;
  top = stk->top;
  _Bool tmp_if_expr$1;
  signed int *tmp_post$2;
  const signed int *tmp_post$3;
  const signed int *tmp_post$5;
  signed int *tmp_post$6;
  signed int return_value_lglcmphase$12;
  signed int return_value_lglmtstk$13;
  signed int return_value_lglcmphase$15;
  signed int *tmp_post$16;
  while(!(c >= top))
  {
    act = *c;
    if(act == 0x7fffffff)
    {
      p = c + (signed long int)1;
      do
      {
        if(!(p >= top))
          tmp_if_expr$1 = *p == 0x7fffffff ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(!tmp_if_expr$1)
          break;

        p = p + 1l;
      }
      while((_Bool)1);
      c = p;
    }

    else
    {
      signed int return_value_lglisact$4;
      return_value_lglisact$4=lglisact(act);
      if(!(return_value_lglisact$4 == 0))
      {
        tmp_post$2 = q;
        q = q + 1l;
        tmp_post$3 = c;
        c = c + 1l;
        *tmp_post$2 = *tmp_post$3;
      }

      else
        act = -1;
      p = c;
      d = q;
      satisfied = 0;
      do
      {
        tmp_post$5 = p;
        p = p + 1l;
        lit = *tmp_post$5;
        if(lit == 0)
          break;

        if(satisfied == 0)
        {
          val=lglval(lgl, lit);
          signed int return_value_lgliselim$7;
          return_value_lgliselim$7=lgliselim(lgl, lit);
          if(!(return_value_lgliselim$7 == 0))
            satisfied = 1;

          else
            if((signed int)val >= 1)
              satisfied = 1;

            else
              if(val == 0)
              {
                tmp_post$6 = q;
                q = q + 1l;
                *tmp_post$6 = lit;
              }

        }

      }
      while((_Bool)1);
      if(p == c + 1l || !(satisfied == 0))
        q = d - (signed long int)(act >= 0);

      else
      {
        size = (signed int)(q - d);
        if(size == 0)
        {
          q = d - (signed long int)(act >= 0);
          if(lgl->mt == 0)
          {

          __CPROVER_DUMP_L18:
            ;
            lgl->mt = 1;
          }

        }

        else
          if(size == 1)
          {
            q = d - (signed long int)(act >= 0);

          __CPROVER_DUMP_L21:
            ;
            lglunit(lgl, d[(signed long int)0]);
          }

          else
            if(size == 2)
            {
              q = d - (signed long int)(act >= 0);
              lglwchbin(lgl, d[(signed long int)0], d[(signed long int)1], red);
              lglwchbin(lgl, d[(signed long int)1], d[(signed long int)0], red);
            }

            else
              if(size == 3)
              {
                q = d - (signed long int)(act >= 0);
                lglwchtrn(lgl, d[(signed long int)0], d[(signed long int)1], d[(signed long int)2], red);
                lglwchtrn(lgl, d[(signed long int)1], d[(signed long int)0], d[(signed long int)2], red);
                lglwchtrn(lgl, d[(signed long int)2], d[(signed long int)0], d[(signed long int)1], red);
              }

              else
              {
                if(!(lgl->opts->sortlits.val == 0))
                  do
                  {
                    signed int *AA = d;
                    signed int NN = size;
                    do
                    {
                      signed int L = 0;
                      signed int R = NN - 1;
                      signed int M;
                      signed int LL;
                      signed int RR;
                      signed int I;
                      if(!(R + -L >= 11))
                        break;

                      do
                      {
                        M = (L + R) / 2;
                        do
                        {
                          signed int TMP = AA[(signed long int)M];
                          AA[(signed long int)M] = AA[(signed long int)(R - 1)];
                          AA[(signed long int)(R - 1)] = TMP;
                        }
                        while((_Bool)0);
                        do
                        {
                          signed int return_value_lglcmphase$8;
                          return_value_lglcmphase$8=lglcmphase(lgl, *(&AA[(signed long int)L]), *(&AA[(signed long int)(R - 1)]));
                          if(return_value_lglcmphase$8 >= 1)
                            do
                            {
                              signed int lglconnaux$$1$$2$$8$$1$$1$$1$$1$$2$$1$$TMP = AA[(signed long int)L];
                              AA[(signed long int)L] = AA[(signed long int)(R - 1)];
                              AA[(signed long int)(R - 1)] = lglconnaux$$1$$2$$8$$1$$1$$1$$1$$2$$1$$TMP;
                            }
                            while((_Bool)0);

                        }
                        while((_Bool)0);
                        do
                        {
                          signed int return_value_lglcmphase$9;
                          return_value_lglcmphase$9=lglcmphase(lgl, *(&AA[(signed long int)L]), *(&AA[(signed long int)R]));
                          if(return_value_lglcmphase$9 >= 1)
                            do
                            {
                              signed int lglconnaux$$1$$2$$8$$1$$1$$1$$1$$3$$1$$TMP = AA[(signed long int)L];
                              AA[(signed long int)L] = AA[(signed long int)R];
                              AA[(signed long int)R] = lglconnaux$$1$$2$$8$$1$$1$$1$$1$$3$$1$$TMP;
                            }
                            while((_Bool)0);

                        }
                        while((_Bool)0);
                        do
                        {
                          signed int return_value_lglcmphase$10;
                          return_value_lglcmphase$10=lglcmphase(lgl, *(&AA[(signed long int)(R - 1)]), *(&AA[(signed long int)R]));
                          if(return_value_lglcmphase$10 >= 1)
                            do
                            {
                              signed int lglconnaux$$1$$2$$8$$1$$1$$1$$1$$4$$1$$TMP = AA[(signed long int)(R - 1)];
                              AA[(signed long int)(R - 1)] = AA[(signed long int)R];
                              AA[(signed long int)R] = lglconnaux$$1$$2$$8$$1$$1$$1$$1$$4$$1$$TMP;
                            }
                            while((_Bool)0);

                        }
                        while((_Bool)0);
                        do
                        {
                          signed int PIVOT;
                          signed int J = R - 1;
                          I = (L + 1) - 1;
                          PIVOT = AA[(signed long int)J];
                          do
                          {

                          __CPROVER_DUMP_L39:
                            ;
                            I = I + 1;
                            signed int return_value_lglcmphase$11;
                            return_value_lglcmphase$11=lglcmphase(lgl, *(&AA[(signed long int)I]), *(&PIVOT));
                            if(!(return_value_lglcmphase$11 >= 0))
                              goto __CPROVER_DUMP_L39;

                            do
                            {
                              J = J - 1;
                              return_value_lglcmphase$12=lglcmphase(lgl, *(&PIVOT), *(&AA[(signed long int)J]));
                              if(return_value_lglcmphase$12 >= 0)
                                break;

                              if(J == 1 + L)
                                break;

                            }
                            while((_Bool)1);
                            if(I >= J)
                              break;

                            do
                            {
                              signed int lglconnaux$$1$$2$$8$$1$$1$$1$$1$$5$$1$$1$$1$$TMP = AA[(signed long int)I];
                              AA[(signed long int)I] = AA[(signed long int)J];
                              AA[(signed long int)J] = lglconnaux$$1$$2$$8$$1$$1$$1$$1$$5$$1$$1$$1$$TMP;
                            }
                            while((_Bool)0);
                          }
                          while((_Bool)1);
                          do
                          {
                            signed int lglconnaux$$1$$2$$8$$1$$1$$1$$1$$5$$2$$TMP = AA[(signed long int)I];
                            AA[(signed long int)I] = AA[(signed long int)(R - 1)];
                            AA[(signed long int)(R - 1)] = lglconnaux$$1$$2$$8$$1$$1$$1$$1$$5$$2$$TMP;
                          }
                          while((_Bool)0);
                        }
                        while((_Bool)0);
                        if(!(I + -L >= R + -I))
                        {
                          LL = I + 1;
                          RR = R;
                          R = I - 1;
                        }

                        else
                        {
                          LL = L;
                          RR = I - 1;
                          L = I + 1;
                        }
                        if(R + -L >= 11)
                        {
                          lglpushstk(lgl, &lgl->$anon1.sortstk, LL);
                          lglpushstk(lgl, &lgl->$anon1.sortstk, RR);
                        }

                        else
                          if(RR + -LL >= 11)
                          {
                            L = LL;
                            R = RR;
                          }

                          else
                          {
                            return_value_lglmtstk$13=lglmtstk(&lgl->$anon1.sortstk);
                            if(return_value_lglmtstk$13 == 0)
                            {
                              R=lglpopstk(&lgl->$anon1.sortstk);
                              L=lglpopstk(&lgl->$anon1.sortstk);
                            }

                            else
                              break;
                          }
                      }
                      while((_Bool)1);
                    }
                    while((_Bool)0);
                    do
                    {
                      signed int lglconnaux$$1$$2$$8$$1$$2$$PIVOT;
                      signed int lglconnaux$$1$$2$$8$$1$$2$$L = 0;
                      signed int lglconnaux$$1$$2$$8$$1$$2$$R = NN - 1;
                      signed int lglconnaux$$1$$2$$8$$1$$2$$I;
                      signed int lglconnaux$$1$$2$$8$$1$$2$$J;
                      lglconnaux$$1$$2$$8$$1$$2$$I = lglconnaux$$1$$2$$8$$1$$2$$R;
                      for( ; !(lglconnaux$$1$$2$$8$$1$$2$$L >= lglconnaux$$1$$2$$8$$1$$2$$I); lglconnaux$$1$$2$$8$$1$$2$$I = lglconnaux$$1$$2$$8$$1$$2$$I - 1)
                        do
                        {
                          signed int return_value_lglcmphase$14;
                          return_value_lglcmphase$14=lglcmphase(lgl, *(&AA[(signed long int)(lglconnaux$$1$$2$$8$$1$$2$$I - 1)]), *(&AA[(signed long int)lglconnaux$$1$$2$$8$$1$$2$$I]));
                          if(return_value_lglcmphase$14 >= 1)
                            do
                            {
                              signed int lglconnaux$$1$$2$$8$$1$$2$$1$$1$$1$$TMP = AA[(signed long int)(lglconnaux$$1$$2$$8$$1$$2$$I - 1)];
                              AA[(signed long int)(lglconnaux$$1$$2$$8$$1$$2$$I - 1)] = AA[(signed long int)lglconnaux$$1$$2$$8$$1$$2$$I];
                              AA[(signed long int)lglconnaux$$1$$2$$8$$1$$2$$I] = lglconnaux$$1$$2$$8$$1$$2$$1$$1$$1$$TMP;
                            }
                            while((_Bool)0);

                        }
                        while((_Bool)0);
                      lglconnaux$$1$$2$$8$$1$$2$$I = lglconnaux$$1$$2$$8$$1$$2$$L + 2;
                      for( ; lglconnaux$$1$$2$$8$$1$$2$$R >= lglconnaux$$1$$2$$8$$1$$2$$I; lglconnaux$$1$$2$$8$$1$$2$$I = lglconnaux$$1$$2$$8$$1$$2$$I + 1)
                      {
                        lglconnaux$$1$$2$$8$$1$$2$$J = lglconnaux$$1$$2$$8$$1$$2$$I;
                        lglconnaux$$1$$2$$8$$1$$2$$PIVOT = AA[(signed long int)lglconnaux$$1$$2$$8$$1$$2$$I];
                        do
                        {
                          return_value_lglcmphase$15=lglcmphase(lgl, *(&lglconnaux$$1$$2$$8$$1$$2$$PIVOT), *(&AA[(signed long int)(lglconnaux$$1$$2$$8$$1$$2$$J - 1)]));
                          if(return_value_lglcmphase$15 >= 0)
                            break;

                          AA[(signed long int)lglconnaux$$1$$2$$8$$1$$2$$J] = AA[(signed long int)(lglconnaux$$1$$2$$8$$1$$2$$J - 1)];
                          lglconnaux$$1$$2$$8$$1$$2$$J = lglconnaux$$1$$2$$8$$1$$2$$J - 1;
                        }
                        while((_Bool)1);
                        AA[(signed long int)lglconnaux$$1$$2$$8$$1$$2$$J] = lglconnaux$$1$$2$$8$$1$$2$$PIVOT;
                      }
                    }
                    while((_Bool)0);

                  __CPROVER_DUMP_L61:
                    ;
                  }
                  while((_Bool)0);

                tmp_post$16 = q;
                q = q + 1l;
                *tmp_post$16 = 0;
                lidx = (signed int)(d - lglconnaux$$1$$start);
                if(!(red == 0))
                {
                  lidx = lidx << 4;
                  lidx = lidx | glue;
                }

                lglwchlrg(lgl, d[(signed long int)0], d[(signed long int)1], red, lidx);
                lglwchlrg(lgl, d[(signed long int)1], d[(signed long int)0], red, lidx);
              }
      }
      c = p;
    }
  }
  stk->top = q;
}

// lglcount
// file lglib.c line 6578
static void lglcount(struct LGL *lgl)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int tag;
  signed int blit;
  signed int red;
  signed int other;
  signed int other2;
  signed int glue;
  signed int count;
  const signed int *p;
  const signed int *w;
  const signed int *c;
  const signed int *eow;
  struct HTS *hts;
  struct Stk *lir;
  lgl->stats->irr.clauses.cur = 0;
  lgl->stats->irr.lits.cur = 0;
  lgl->stats->red.bin = 0;
  lgl->stats->red.trn = 0;
  lgl->stats->red.lrg = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      hts=lglhts(lgl, lit);
      if(!(hts->offset == 0))
      {
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          red = blit & REDCS;
          tag = blit & MASKCS;
          if(tag == TRNCS || tag == LRGCS)
            p = p + 1l;

          if(!(tag == LRGCS))
          {
            other = blit >> RMSHFT;
            signed int return_value_abs$1;
            return_value_abs$1=abs(lit);
            signed int return_value_abs$2;
            return_value_abs$2=abs(other);
            if(!(return_value_abs$1 >= return_value_abs$2))
            {
              if(tag == TRNCS)
              {
                other2 = *p;
                signed int return_value_abs$3;
                return_value_abs$3=abs(lit);
                signed int return_value_abs$4;
                return_value_abs$4=abs(other2);
                if(return_value_abs$3 >= return_value_abs$4)
                  goto __CPROVER_DUMP_L12;

              }

              if(red == 0)
              {
                lgl->stats->irr.clauses.cur = lgl->stats->irr.clauses.cur + 1;
                if(tag == BINCS)
                  lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur + 2;

                else
                  lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur + 3;
              }

              else
                if(tag == BINCS)
                  lgl->stats->red.bin = lgl->stats->red.bin + 1;

                else
                  lgl->stats->red.trn = lgl->stats->red.trn + 1;
            }

          }


        __CPROVER_DUMP_L12:
          ;
        }
      }

    }
  }
  c = lgl->irr.start;
  for( ; !(c >= lgl->irr.top); c = p + (signed long int)1)
  {
    p = c;
    if(!(*p >= 0x7fffffff))
    {
      for( ; !(*p == 0); p = p + 1l)
        ;
      lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur + (signed int)(p - c);
      lgl->stats->irr.clauses.cur = lgl->stats->irr.clauses.cur + 1;
    }

  }

__CPROVER_DUMP_L20:
  ;
  glue = 0;
  for( ; !(glue >= 15); glue = glue + 1)
  {
    lir = lgl->red + (signed long int)glue;
    count = 0;
    c = lir->start;
    for( ; !(c >= lir->top); c = c + 1l)
      if(*c == 0)
        count = count + 1;

    if(!(count == 0))

      __CPROVER_DUMP_L25:
        ;

    lgl->stats->red.lrg = lgl->stats->red.lrg + count;
    lgl->stats->lir[(signed long int)glue].clauses = count;
  }
  if(!(lgl->stats->red.bin == 0))

    __CPROVER_DUMP_L28:
      ;

  if(!(lgl->stats->red.trn == 0))

    __CPROVER_DUMP_L30:
      ;

  if(!(lgl->stats->red.lrg == 0))

    __CPROVER_DUMP_L32:
      ;

}

// lglcpyopts
// file lglib.c line 18907
static void lglcpyopts(struct LGL *dst, const struct LGL *src)
{
  const struct Opt *s;
  struct Opt *d;
  s = &src->opts->beforefirst + (signed long int)1;
  d = &dst->opts->beforefirst + (signed long int)1;
  signed int tmp_statement_expression$1;
  signed int tmp_statement_expression$3;
  for( ; &src->opts->afterlast + -1l >= s; d = d + 1l)
  {
    unsigned long int lglcpyopts$$1$$1$$1$$1$$__s1_len;
    unsigned long int lglcpyopts$$1$$1$$1$$1$$__s2_len;
    signed int return_value___builtin_strcmp$2;
    return_value___builtin_strcmp$2=__builtin_strcmp(s->lng, "clim");
    tmp_statement_expression$1 = return_value___builtin_strcmp$2;
    if(!(tmp_statement_expression$1 == 0))
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp$4;
      return_value___builtin_strcmp$4=__builtin_strcmp(s->lng, "dlim");
      tmp_statement_expression$3 = return_value___builtin_strcmp$4;
      if(!(tmp_statement_expression$3 == 0))
      {
        if(!(d->val == s->val))
          lglsetopt(dst, s->lng, s->val);

      }

    }

    s = s + 1l;
  }
}

// lglcpystk
// file lglib.c line 16551
static void lglcpystk(struct LGL *lgl, struct Stk *dst, struct Stk *src)
{
  const signed int *p = src->start;
  for( ; !(p >= src->top); p = p + 1l)
    lglpushstk(lgl, dst, *p);
}

// lglctrav
// file lglib.c line 18746
void lglctrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int))
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglctrav");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  signed int return_value_lglbcp$1;
  if(lgl->mt == 0)
  {
    return_value_lglbcp$1=lglbcp(lgl);
    if(return_value_lglbcp$1 == 0)
      lgl->mt = 1;

  }

  if(lgl->mt == 0)
    lglgc(lgl);

  signed int return_value_lglexport$6;
  if(!(lgl->mt == 0))
    trav(state, 0);

  else
  {
    if(lgl->level >= 1)
      lglbacktrack(lgl, 0);

    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      sign = -1;
      for( ; !(sign >= 2); sign = sign + 2)
      {
        lit = sign * idx;
        hts=lglhts(lgl, lit);
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          tag = blit & MASKCS;
          red = blit & REDCS;
          if(tag == TRNCS || tag == LRGCS)
            p = p + 1l;

          if(red == 0)
          {
            if(tag == BINCS || tag == TRNCS)
            {
              other = blit >> RMSHFT;
              signed int return_value_abs$2;
              return_value_abs$2=abs(other);
              if(return_value_abs$2 >= idx)
              {
                if(tag == TRNCS)
                {
                  other2 = *p;
                  signed int return_value_abs$3;
                  return_value_abs$3=abs(other2);
                  if(!(return_value_abs$3 >= idx))
                    goto __CPROVER_DUMP_L16;

                }

                else
                  other2 = 0;
                signed int return_value_lglexport$4;
                return_value_lglexport$4=lglexport(lgl, lit);
                trav(state, return_value_lglexport$4);
                signed int return_value_lglexport$5;
                return_value_lglexport$5=lglexport(lgl, other);
                trav(state, return_value_lglexport$5);
                if(!(other2 == 0))
                {
                  return_value_lglexport$6=lglexport(lgl, other2);
                  trav(state, return_value_lglexport$6);
                }

                trav(state, 0);
              }

            }

          }


        __CPROVER_DUMP_L16:
          ;
        }
      }
    }
    c = lgl->irr.start;
    for( ; !(c >= lgl->irr.top); c = p + (signed long int)1)
    {
      p = c;
      if(!(*p >= 134217727))
      {
        other = *p;
        if(!(other == 0))
        {
          signed int return_value_lglexport$7;
          return_value_lglexport$7=lglexport(lgl, other);
          trav(state, return_value_lglexport$7);
          p = p + 1l;
        }

        trav(state, 0);
      }

    }
  }
}

// lglcutwidth
// file lglib.c line 6877
static signed int lglcutwidth(struct LGL *lgl)
{
  signed int lidx;
  signed int res;
  signed int l4;
  signed int r4;
  signed int b4;
  signed int l10;
  signed int r10;
  signed int b10;
  signed int m;
  signed int oldbias;
  signed int idx;
  signed int sign;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  const signed int *q;
  signed int *widths;
  signed int max;
  signed int cut;
  signed int min4;
  signed int min10;
  signed long int sum;
  signed long int avg;
  struct HTS *hts;
  double return_value_lglpcnt$3;
  double return_value_lglpcnt$4;
  if(!(lgl->nvars >= 3))
    return 0;

  else
  {
    lglstart(lgl, &lgl->times->ctw);
    oldbias = lgl->bias;
    signed int return_value_abs$1;
    return_value_abs$1=abs(lgl->opts->bias.val);
    if(!(return_value_abs$1 >= 2))
      lgl->bias = lgl->opts->bias.val;

    else
    {
      min10 = 0x7fffffff;
      min4 = min10;
      cut = 0;
      max = cut;
      sum = (signed long int)max;
      do
      {
        void *return_value_lglnew$2;
        return_value_lglnew$2=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
        widths = (signed int *)return_value_lglnew$2;
      }
      while((_Bool)0);
      l4 = 2 + ((lgl->nvars - 2) + 3) / 4;
      r4 = 2 + (3 * (lgl->nvars - 2) + 3) / 4;
      l10 = 2 + ((lgl->nvars - 2) + 9) / 10;
      r10 = 2 + (9 * (lgl->nvars - 2) + 9) / 10;
      b10 = 0;
      b4 = b10;
      idx = 2;
      for( ; !(idx >= lgl->nvars); idx = idx + 1)
      {
        sign = -1;
        for( ; !(sign >= 2); sign = sign + 2)
        {
          lit = idx * sign;
          hts=lglhts(lgl, lit);
          w=lglhts2wchs(lgl, hts);
          eow = w + (signed long int)hts->count;
          p = w;
          for( ; !(p >= eow); p = p + 1l)
          {
            blit = *p;
            red = blit & REDCS;
            tag = blit & MASKCS;
            other=abs(blit >> RMSHFT);
            if(tag == BINCS)
            {
              if(!(red == 0))
                goto __CPROVER_DUMP_L14;

              if(!(idx >= other))
              {
                widths[(signed long int)other] = widths[(signed long int)other] + 1;
                cut = cut + 1;
              }

            }

            else
              if(tag == TRNCS)
              {
                p = p + 1l;
                other2=abs(*p);
                if(!(red == 0))
                  goto __CPROVER_DUMP_L14;

                if(!(idx >= other))
                {
                  widths[(signed long int)other] = widths[(signed long int)other] + 1;
                  cut = cut + 1;
                }

                if(!(idx >= other2))
                {
                  widths[(signed long int)other2] = widths[(signed long int)other2] + 1;
                  cut = cut + 1;
                }

              }

              else
              {
                p = p + 1l;
                lidx = *p;
                if(red == 0)
                {
                  c=lglidx2lits(lgl, LRGCS, 0, lidx);
                  q = c;
                  do
                  {
                    other=abs(*q);
                    if(other == 0)
                      break;

                    if(!(other == idx))
                    {
                      if(!(idx >= other))
                      {
                        widths[(signed long int)other] = widths[(signed long int)other] + 1;
                        cut = cut + 1;
                      }

                    }

                    q = q + 1l;
                  }
                  while((_Bool)1);
                }

              }

          __CPROVER_DUMP_L14:
            ;
          }
        }
        cut = cut - widths[(signed long int)idx];
        if(!(max >= cut))
          max = cut;

        if(idx >= l4 && r4 >= idx && !(cut >= min4))
        {
          b4 = idx;
          min4 = cut;
        }

        if(idx >= l10 && r10 >= idx && !(cut >= min10))
        {
          b10 = idx;
          min10 = cut;
        }

        sum = sum + (signed long int)cut;
      }
      do
      {
        lgldel(lgl, (void *)widths, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
        widths = ((signed int *)NULL);
      }
      while((_Bool)0);
      avg = sum / (signed long long int)lgl->nvars;
      res = (signed int)avg;
      return_value_lglpcnt$3=lglpcnt((double)(b4 - 2), (double)(lgl->nvars - 2));
      return_value_lglpcnt$4=lglpcnt((double)(b10 - 2), (double)(lgl->nvars - 2));
      lglprt(lgl, 1, "[cut-width] %d, max %d, min4 %d at %.0f%%, min10 %d at %.0f%%", res, max, min4, return_value_lglpcnt$3, min10, return_value_lglpcnt$4);
      m = (lgl->nvars + 2) / 2;
      if(!(b10 >= m) && !(b4 >= m))
        lgl->bias = -1;

      if(!(m >= b10) && !(m >= b4))
        lgl->bias = 1;

    }

  DONE:
    ;
    (void)0;
    lglprt(lgl, 1, "[decision-order] bias %d, old %d", lgl->bias, oldbias);
    lglstop(lgl);
    return res;
  }
}

// lglcval
// file lglib.c line 2961
static signed int lglcval(struct LGL *lgl, signed int litorval)
{
  if(litorval == 1 || litorval == -1)
    return litorval;

  else
  {
    signed char return_value_lglval$1;
    return_value_lglval$1=lglval(lgl, litorval);
    return (signed int)return_value_lglval$1;
  }
}

// lgldassume
// file lglib.c line 7730
static void lgldassume(struct LGL *lgl, signed int lit)
{

__CPROVER_DUMP_L1:
  ;
  lgl->stats->decisions = lgl->stats->decisions + 1l;
  lgl->stats->height = lgl->stats->height + (signed long int)lgl->level;
  lgliassume(lgl, lit);
}

// lgldcpcln
// file lglib.c line 8043
static void lgldcpcln(struct LGL *lgl)
{
  signed int glue;
  signed int old;
  signed int rounds = 0;
  struct Stk *lir;
  do
  {
    rounds = rounds + 1;
    old = lgl->stats->fixed.current;
    lgldcpclnstk(lgl, 0, &lgl->irr);
    lgldcpclnstk(lgl, 0, &lgl->dis->irr.bin);
    lgldcpclnstk(lgl, 0, &lgl->dis->irr.trn);
    lgldcpclnstk(lgl, REDCS, &lgl->dis->red.bin);
    lgldcpclnstk(lgl, REDCS, &lgl->dis->red.trn);
    glue = 0;
    for( ; !(glue >= 15); glue = glue + 1)
    {
      lir = lgl->red + (signed long int)glue;
      lgldcpclnstk(lgl, REDCS, lir);
    }
  }
  while(!(old >= lgl->stats->fixed.current));

__CPROVER_DUMP_L4:
  ;
}

// lgldcpclnstk
// file lglib.c line 7904
static void lgldcpclnstk(struct LGL *lgl, signed int red, struct Stk *s)
{
  signed int oldsz;
  signed int newsz;
  signed int lit;
  signed int mark;
  signed int satisfied;
  signed int repr;
  signed int act;
  const signed int *p;
  const signed int *c;
  const signed int *eos = s->top;
  signed int *lgldcpclnstk$$1$$start;
  signed int *q;
  signed int *r;
  signed int *d;
  struct Stk *t;
  signed char val;
  lgldcpclnstk$$1$$start = s->start;
  q = lgldcpclnstk$$1$$start;
  c = q;
  _Bool tmp_if_expr$1;
  signed int *tmp_post$2;
  const signed int *tmp_post$3;
  signed int *tmp_post$6;
  signed int *tmp_post$7;
  struct Stk *tmp_if_expr$8;
  signed int *tmp_post$9;
  struct Stk *tmp_if_expr$10;
  signed int *tmp_post$11;
  for( ; !(c >= eos); c = p + (signed long int)1)
  {
    act = *c;
    if(act == 0x7fffffff)
    {
      p = c + (signed long int)1;
      do
      {
        if(!(p >= eos))
          tmp_if_expr$1 = *p == 0x7fffffff ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(!tmp_if_expr$1)
          break;

        p = p + 1l;
      }
      while((_Bool)1);
      p = p - 1l;
    }

    else
    {
      signed int return_value_lglisact$4;
      return_value_lglisact$4=lglisact(act);
      if(!(return_value_lglisact$4 == 0))
      {
        tmp_post$2 = q;
        q = q + 1l;
        tmp_post$3 = c;
        c = c + 1l;
        *tmp_post$2 = *tmp_post$3;
      }

      else
        act = -1;
      d = q;
      satisfied = 0;
      p = c;
      do
      {
        lit = *p;
        if(lit == 0)
          break;

        if(satisfied == 0)
        {
          repr=lglirepr(lgl, lit);
          signed int return_value_lglcval$5;
          return_value_lglcval$5=lglcval(lgl, repr);
          val = (signed char)return_value_lglcval$5;
          if((signed int)val >= 1)
            satisfied = 1;

          else
            if((signed int)val >= 0)
            {
              mark=lglmarked(lgl, repr);
              if(!(mark >= 0))
                satisfied = 1;

              else
                if(!(mark >= 1))
                {
                  lglmark(lgl, repr);
                  tmp_post$6 = q;
                  q = q + 1l;
                  *tmp_post$6 = repr;
                }

            }

        }

        p = p + 1l;
      }
      while((_Bool)1);
      oldsz = (signed int)(p - c);
      r = d;
      for( ; !(r >= q); r = r + 1l)
        lglunmark(lgl, *r);
      if(oldsz == 0 || !(satisfied == 0))
        q = d - (signed long int)(act >= 0);

      else
      {
        newsz = (signed int)(q - d);
        if(newsz >= 4)
        {
          tmp_post$7 = q;
          q = q + 1l;
          *tmp_post$7 = 0;
        }

        else
          if(newsz == 0)
          {

          __CPROVER_DUMP_L20:
            ;
            lgl->mt = 1;
            q = d - (signed long int)(act >= 0);
          }

          else
            if(newsz == 1)
            {

            __CPROVER_DUMP_L22:
              ;
              lglunit(lgl, d[(signed long int)0]);
              q = d - (signed long int)(act >= 0);
            }

            else
              if(newsz == 2)
              {
                if(!(red == 0))
                  tmp_if_expr$8 = &lgl->dis->red.bin;

                else
                  tmp_if_expr$8 = &lgl->dis->irr.bin;
                t = tmp_if_expr$8;
                if(!(s == t))
                {
                  lglpushstk(lgl, t, d[(signed long int)0]);
                  lglpushstk(lgl, t, d[(signed long int)1]);
                  lglpushstk(lgl, t, 0);
                  q = d - (signed long int)(act >= 0);
                }

                else
                {
                  tmp_post$9 = q;
                  q = q + 1l;
                  *tmp_post$9 = 0;
                }
              }

              else
              {
                if(!(red == 0))
                  tmp_if_expr$10 = &lgl->dis->red.trn;

                else
                  tmp_if_expr$10 = &lgl->dis->irr.trn;
                t = tmp_if_expr$10;
                if(!(s == t))
                {
                  lglpushstk(lgl, t, d[(signed long int)0]);
                  lglpushstk(lgl, t, d[(signed long int)1]);
                  lglpushstk(lgl, t, d[(signed long int)2]);
                  lglpushstk(lgl, t, 0);
                  q = d - (signed long int)(act >= 0);
                }

                else
                {
                  tmp_post$11 = q;
                  q = q + 1l;
                  *tmp_post$11 = 0;
                }
              }
      }
    }
  }
  s->top = q;
}

// lgldcpcon
// file lglib.c line 8023
static void lgldcpcon(struct LGL *lgl)
{
  struct Stk *lir;
  signed int glue;
  lgldcpconnaux(lgl, 0, 0, &lgl->dis->irr.bin);
  lgldcpconnaux(lgl, REDCS, 0, &lgl->dis->red.bin);
  lgldcpconnaux(lgl, 0, 0, &lgl->dis->irr.trn);
  lgldcpconnaux(lgl, REDCS, 0, &lgl->dis->red.trn);
  lglrelstk(lgl, &lgl->dis->irr.bin);
  lglrelstk(lgl, &lgl->dis->irr.trn);
  lglrelstk(lgl, &lgl->dis->red.bin);
  lglrelstk(lgl, &lgl->dis->red.trn);
  do
  {
    lgldel(lgl, (void *)lgl->dis, (unsigned long int)1 * sizeof(struct Dis) /*96ul*/ );
    lgl->dis = ((struct Dis *)NULL);
  }
  while((_Bool)0);
  lgldcpconnaux(lgl, 0, 0, &lgl->irr);
  glue = 0;
  for( ; !(glue >= 15); glue = glue + 1)
  {
    lir = lgl->red + (signed long int)glue;
    lgldcpconnaux(lgl, REDCS, glue, lir);
  }
  lglfullyconnected(lgl);
}

// lgldcpconnaux
// file lglib.c line 7982
static void lgldcpconnaux(struct LGL *lgl, signed int red, signed int glue, struct Stk *s)
{
  signed int *lgldcpconnaux$$1$$start = s->start;
  signed int *q;
  signed int *d;
  signed int lit;
  signed int size;
  signed int lidx;
  signed int act;
  const signed int *p;
  const signed int *c;
  const signed int *eos = s->top;
  q = lgldcpconnaux$$1$$start;
  c = q;
  signed int *tmp_post$1;
  const signed int *tmp_post$2;
  signed int *tmp_post$4;
  signed int *tmp_post$5;
  for( ; !(c >= eos); c = p + (signed long int)1)
  {
    act = *c;
    signed int return_value_lglisact$3;
    return_value_lglisact$3=lglisact(act);
    if(!(return_value_lglisact$3 == 0))
    {
      tmp_post$1 = q;
      q = q + 1l;
      tmp_post$2 = c;
      c = c + 1l;
      *tmp_post$1 = *tmp_post$2;
    }

    else
      act = -1;
    d = q;
    p = c;
    do
    {
      lit = *p;
      if(lit == 0)
        break;

      tmp_post$4 = q;
      q = q + 1l;
      *tmp_post$4 = lit;
      p = p + 1l;
    }
    while((_Bool)1);
    size = (signed int)(q - d);
    if(size == 2)
    {
      q = d - (signed long int)(act >= 0);
      lglwchbin(lgl, d[(signed long int)0], d[(signed long int)1], red);
      lglwchbin(lgl, d[(signed long int)1], d[(signed long int)0], red);
    }

    else
      if(size == 3)
      {
        q = d - (signed long int)(act >= 0);
        lglwchtrn(lgl, d[(signed long int)0], d[(signed long int)1], d[(signed long int)2], red);
        lglwchtrn(lgl, d[(signed long int)1], d[(signed long int)0], d[(signed long int)2], red);
        lglwchtrn(lgl, d[(signed long int)2], d[(signed long int)0], d[(signed long int)1], red);
      }

      else
      {
        tmp_post$5 = q;
        q = q + 1l;
        *tmp_post$5 = 0;
        lidx = (signed int)(d - lgldcpconnaux$$1$$start);
        if(!(red == 0))
        {
          lidx = lidx << 4;
          lidx = lidx | glue;
        }

        lglwchlrg(lgl, d[(signed long int)0], d[(signed long int)1], red, lidx);
        lglwchlrg(lgl, d[(signed long int)1], d[(signed long int)0], red, lidx);
      }
  }
  s->top = q;
}

// lgldcpdis
// file lglib.c line 7852
static void lgldcpdis(struct LGL *lgl)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int tag;
  signed int blit;
  signed int red;
  signed int other;
  signed int other2;
  signed int i;
  const signed int *w;
  const signed int *p;
  const signed int *eow;
  signed char val;
  struct HTS *hts;
  struct Stk *s;
  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Dis) /*96ul*/ );
    lgl->dis = (struct Dis *)return_value_lglnew$1;
  }
  while((_Bool)0);
  idx = 2;
  signed int return_value_lglisfree$3;
  struct Stk *tmp_if_expr$4;
  signed int return_value_lglisfree$6;
  struct Stk *tmp_if_expr$7;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      hts=lglhts(lgl, lit);
      if(!(hts->offset == 0))
      {
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        hts->offset = 0;
        hts->count = hts->offset;
        val=lglval(lgl, lit);
        if(!((signed int)val >= 1))
        {
          p = w;
          for( ; !(p >= eow); p = p + 1l)
          {
            blit = *p;
            tag = blit & MASKCS;
            if(tag == TRNCS || tag == LRGCS)
              p = p + 1l;

            if(!(tag == LRGCS))
            {
              other = blit >> RMSHFT;
              signed int return_value_abs$2;
              return_value_abs$2=abs(other);
              if(return_value_abs$2 >= idx)
              {
                val=lglval(lgl, other);
                if(!((signed int)val >= 1))
                {
                  red = blit & REDCS;
                  if(!(red == 0))
                  {
                    return_value_lglisfree$3=lglisfree(lgl, other);
                    if(!(return_value_lglisfree$3 == 0))
                      goto __CPROVER_DUMP_L7;

                  }

                  else
                  {

                  __CPROVER_DUMP_L7:
                    ;
                    if(tag == BINCS)
                    {
                      if(!(red == 0))
                        tmp_if_expr$4 = &lgl->dis->red.bin;

                      else
                        tmp_if_expr$4 = &lgl->dis->irr.bin;
                      s = tmp_if_expr$4;
                    }

                    else
                    {
                      other2 = *p;
                      signed int return_value_abs$5;
                      return_value_abs$5=abs(other2);
                      if(!(return_value_abs$5 >= idx))
                        goto __CPROVER_DUMP_L17;

                      val=lglval(lgl, other2);
                      if((signed int)val >= 1)
                        goto __CPROVER_DUMP_L17;

                      if(!(red == 0))
                      {
                        return_value_lglisfree$6=lglisfree(lgl, other2);
                        if(return_value_lglisfree$6 == 0)
                          goto __CPROVER_DUMP_L17;

                      }

                      if(!(red == 0))
                        tmp_if_expr$7 = &lgl->dis->red.trn;

                      else
                        tmp_if_expr$7 = &lgl->dis->irr.trn;
                      s = tmp_if_expr$7;
                      lglpushstk(lgl, s, other2);
                    }
                    lglpushstk(lgl, s, other);
                    lglpushstk(lgl, s, lit);
                    lglpushstk(lgl, s, 0);
                  }
                }

              }

            }


          __CPROVER_DUMP_L17:
            ;
          }
        }

      }

    }
  }
  lglrststk(&lgl->wchs->stk, 2);
  lgl->wchs->stk.top[(signed long int)-1] = 0x7fffffff;
  i = 0;
  for( ; !(i >= 31); i = i + 1)
    lgl->wchs->start[(signed long int)i] = 0x7fffffff;
  lgl->wchs->free = 0;
}

// lgldec
// file lglib.c line 1253
static void lgldec(struct LGL *lgl, unsigned long int bytes)
{
  lgl->stats->bytes.current = lgl->stats->bytes.current - bytes;
}

// lgldec64
// file lglib.c line 16230
static unsigned long int lgldec64(unsigned long int i)
{
  unsigned long int res = i - (unsigned long int)1;
  signed int return_value_lglpar64$1;
  do
  {
    return_value_lglpar64$1=lglpar64(res);
    if(return_value_lglpar64$1 == 0)
      break;

    res = res - 1ul;
  }
  while((_Bool)1);
  return res;
}

// lgldecide
// file lglib.c line 7832
static signed int lgldecide(struct LGL *lgl)
{
  signed int lit;
  lglchkbcpclean(lgl, "decide");
  _Bool tmp_if_expr$1;
  if(lgl->unassigned == 0)
    return 0;

  else
  {
    lit=lgladecide(lgl);
    if(!(lit == 0))
    {

    __CPROVER_DUMP_L2:
      ;
      lgl->alevel = lgl->level + 1;
    }

    else
    {
      if(!(lgl->opts->randec.val == 0))
        tmp_if_expr$1 = lgl->limits->randec <= lgl->stats->decisions ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        lit=lglrandec(lgl);

      else
        lit=lglnextdecision(lgl);

    __CPROVER_DUMP_L7:
      ;
      lit=lgldecidephase(lgl, lit);
    }

  __CPROVER_DUMP_L3:
    ;
    if(!(lit == 0))
      lgldassume(lgl, lit);

    return 1;
  }
}

// lgldecidephase
// file lglib.c line 7758
static signed int lgldecidephase(struct LGL *lgl, signed int lit)
{
  signed int res;
  res=abs(lit);
  signed int flipped;
  struct AVar *av;
  av=lglavar(lgl, lit);
  _Bool tmp_if_expr$2;
  signed int return_value_lgldefphase$1;
  unsigned long int return_value_lglcntstk$4;
  _Bool tmp_if_expr$3;
  if(!(av->fase == 0))
    return (signed int)av->fase * res;

  else
  {
    if(!(lgl->phaseneg == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_lgldefphase$1=lgldefphase(lgl, res);
      tmp_if_expr$2 = return_value_lgldefphase$1 <= 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      res = -res;

    if(lgl->flipping == 0)
    {
      if(lgl->phaseneg == 0)
      {
        if(!(lgl->opts->flipping.val == 0))
        {
          if(lgl->level >= lgl->alevel)
          {
            return_value_lglcntstk$4=lglcntstk(&lgl->assume);
            if((unsigned long int)lgl->assumed == return_value_lglcntstk$4)
            {
              if(lgl->opts->fliptop.val == 0)
                tmp_if_expr$3 = (_Bool)1;

              else
                tmp_if_expr$3 = lgl->level == lgl->alevel ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$3)
              {
                if(lgl->notflipped >= lgl->limits->flipint)
                {

                __CPROVER_DUMP_L7:
                  ;
                  lgl->stats->fliphases = lgl->stats->fliphases + 1l;
                  lglupdflipint(lgl);
                  lgl->flipping = lgl->opts->flipdur.val;
                  lgl->notflipped = 0;
                }

                else
                  lgl->notflipped = lgl->notflipped + 1;
              }

            }

          }

        }

      }

    }

    if(!(lgl->flipping == 0))
    {
      flipped = -res;

    __CPROVER_DUMP_L10:
      ;
      lgl->stats->flipped = lgl->stats->flipped + 1l;
      res = flipped;
    }

    return res;
  }
}

// lgldecirr
// file lglib.c line 3481
static void lgldecirr(struct LGL *lgl, signed int size)
{
  lgl->stats->irr.clauses.cur = lgl->stats->irr.clauses.cur - 1;
  lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur - size;
  lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;
}

// lgldecision
// file lglib.c line 4799
static signed int lgldecision(struct LGL *lgl, signed int lit)
{
  signed int *rsn;
  rsn=lglrsn(lgl, lit);
  signed int tag = rsn[(signed long int)0] & MASKCS;
  return (signed int)(tag == DECISION);
}

// lgldeclscnt
// file lglib.c line 4071
static void lgldeclscnt(struct LGL *lgl, signed int size, signed int red, signed int glue)
{
  if(red == 0)
    lgldecirr(lgl, size);

  else
    if(size == 2)
      lgl->stats->red.bin = lgl->stats->red.bin - 1;

    else
      if(size == 3)
        lgl->stats->red.trn = lgl->stats->red.trn - 1;

      else
      {
        lgl->stats->red.lrg = lgl->stats->red.lrg - 1;
        lgl->stats->lir[(signed long int)glue].clauses = lgl->stats->lir[(signed long int)glue].clauses - 1;
      }
}

// lgldecocc
// file lglib.c line 5650
static void lgldecocc(struct LGL *lgl, signed int lit)
{
  signed int idx;
  signed int sign;
  signed int change;
  struct EVar *ev;
  _Bool tmp_if_expr$1;
  if(!(lgl->cgrclosing == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = lgl->probing != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = lgl->gaussing != 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$2)
  {
    idx=abs(lit);
    sign = (signed int)(lit < 0);
    ev=lglevar(lgl, lit);
    ev->occ[(signed long int)sign] = ev->occ[(signed long int)sign] - 1;
    signed int return_value_lglisfree$3;
    return_value_lglisfree$3=lglisfree(lgl, lit);
    if(!(return_value_lglisfree$3 == 0))
    {
      change=lglecalc(lgl, ev);

    __CPROVER_DUMP_L7:
      ;
      if(!(ev->pos >= 0))
        lglesched(lgl, idx);

      else
        if(!(change >= 0))
          lgleup(lgl, idx);

        else
          if(change >= 1)
            lgledown(lgl, idx);

    }

  }

}

// lgldecomp
// file lglib.c line 12274
static signed int lgldecomp(struct LGL *lgl)
{
  signed int res = 1;
  signed int oldnvars = lgl->nvars;
  signed int success;
  lglstart(lgl, &lgl->times->dcp);
  lgl->stats->decomps = lgl->stats->decomps + 1;
  lgl->decomposing = (char)1;
  lgl->simp = lgl->simp + 1;
  if(lgl->level >= 1)
    lglbacktrack(lgl, 0);

  res = 0;
  lglgc(lgl);
  signed int return_value_lglsyncunits$1;
  return_value_lglsyncunits$1=lglsyncunits(lgl);
  signed int return_value_lglbcp$2;
  signed int return_value_lgltarjan$3;
  signed int return_value_lglsynceqs$4;
  signed int return_value_lglbcp$5;
  if(!(return_value_lglsyncunits$1 == 0))
  {
    return_value_lglbcp$2=lglbcp(lgl);
    if(!(return_value_lglbcp$2 == 0))
    {
      lglgc(lgl);
      if(lgl->mt == 0)
      {
        return_value_lgltarjan$3=lgltarjan(lgl);
        if(!(return_value_lgltarjan$3 == 0))
        {
          return_value_lglsynceqs$4=lglsynceqs(lgl);
          if(!(return_value_lglsynceqs$4 == 0))
          {
            lglchkred(lgl);
            lgldcpdis(lgl);
            lgldcpcln(lgl);
            lgldcpcon(lgl);
            lglcompact(lgl);
            lglmap(lgl);
            if(lgl->mt == 0)
            {
              return_value_lglbcp$5=lglbcp(lgl);
              if(return_value_lglbcp$5 == 0)
              {
                if(lgl->mt == 0)
                  lgl->mt = 1;

              }

              else
              {
                lglcount(lgl);
                lglgc(lgl);
                if(lgl->mt == 0)
                {
                  if(lgl->mt == 0)
                  {
                    lglpicosatchkall(lgl);
                    lglpicosatrestart(lgl);
                  }

                  res = 1;
                }

              }
            }

          }

        }

      }

    }

  }


DONE:
  ;
  if(!(lgl->repr == ((signed int *)NULL)))
    do
    {
      lgldel(lgl, (void *)lgl->repr, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
      lgl->repr = ((signed int *)NULL);
    }
    while((_Bool)0);

  lgl->decomposing = (char)0;

__CPROVER_DUMP_L8:
  ;
  lgl->simp = lgl->simp - 1;
  success = (signed int)(lgl->nvars < oldnvars);
  _Bool tmp_if_expr$6;
  if(success == 0)
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = lgl->probing != 0 ? (_Bool)1 : (_Bool)0;
  lglrep(lgl, 1 + (signed int)tmp_if_expr$6, (char)100);
  lglstop(lgl);
  return res;
}

// lgldecomposing
// file lglib.c line 16953
static signed int lgldecomposing(struct LGL *lgl)
{
  return lgl->opts->decompose.val;
}

// lgldefphase
// file lglib.c line 7738
static signed int lgldefphase(struct LGL *lgl, signed int idx)
{
  struct AVar *av;
  signed int bias;
  av=lglavar(lgl, idx);
  if(av->phase == 0)
  {
    bias = lgl->opts->phase.val;
    if(bias == 0)
      bias = (signed int)av->bias;

    if(bias == 0)
      bias=lglsetjwhbias(lgl, idx);

    av->phase = bias;
  }

  return (signed int)av->phase;
}

// lgldefrag
// file lglib.c line 6362
static void lgldefrag(struct LGL *lgl)
{
  signed int *wchs;
  signed int nwchs;
  signed int i;
  signed int idx;
  signed int bit;
  signed int ldsize;
  signed int size;
  signed int offset;
  signed int *lgldefrag$$1$$start;
  signed int *q;
  signed int *end;
  const signed int *p;
  const signed int *eow;
  const signed int *w;
  struct HTS *hts;
  struct Qln *line;
  signed int *tmp_post$4;
  signed int *tmp_post$5;
  struct Qnd *return_value_lglqnd$3;
  signed int *tmp_post$6;
  if(!(lgl->qscheduling == 0))
  {
    lglstart(lgl, &lgl->times->dfg);
    lgl->stats->defrags = lgl->stats->defrags + 1;
    unsigned long int return_value_lglcntstk$1;
    return_value_lglcntstk$1=lglcntstk(&lgl->wchs->stk);
    nwchs = (signed int)return_value_lglcntstk$1;
    do
    {
      void *return_value_lglnew$2;
      return_value_lglnew$2=lglnew(lgl, (unsigned long int)nwchs * sizeof(signed int) /*4ul*/ );
      wchs = (signed int *)return_value_lglnew$2;
    }
    while((_Bool)0);
    memcpy((void *)wchs, (const void *)lgl->wchs->stk.start, (unsigned long int)nwchs * sizeof(signed int) /*4ul*/ );
    i = 0;
    for( ; !(i >= 31); i = i + 1)
      lgl->wchs->start[(signed long int)i] = 0x7fffffff;
    lgl->wchs->free = 0;
    lgldefrag$$1$$start = lgl->wchs->stk.start;
    offset = 1;
    line = lgl->queue.bottom;
    for( ; !(line == ((struct Qln *)NULL)); line = line->up)
    {
      idx = line->last;
      for( ; !(idx == 0); idx = return_value_lglqnd$3->prev)
      {
        bit = 0;
        for( ; !(bit >= 2); bit = bit + 1)
        {
          hts = (lgl->dvars + (signed long int)idx)->hts + (signed long int)bit;
          if(!(hts->offset == 0))
          {
            ldsize=lglceilld(hts->count);
            size = 1 << ldsize;
            w = wchs + (signed long int)hts->offset;
            hts->offset = offset;
            eow = w + (signed long int)hts->count;
            q = lgldefrag$$1$$start + (signed long int)offset;
            p = w;
            for( ; !(p >= eow); p = p + 1l)
            {
              tmp_post$4 = q;
              q = q + 1l;
              *tmp_post$4 = *p;
            }
            offset = offset + size;
            end = lgldefrag$$1$$start + (signed long int)offset;
            for( ; !(q >= end); *tmp_post$5 = 0)
            {
              tmp_post$5 = q;
              q = q + 1l;
            }
          }

        }
        return_value_lglqnd$3=lglqnd(lgl, idx);
      }
    }
    do
    {
      lgldel(lgl, (void *)wchs, (unsigned long int)nwchs * sizeof(signed int) /*4ul*/ );
      wchs = ((signed int *)NULL);
    }
    while((_Bool)0);
    q = lgldefrag$$1$$start + (signed long int)offset;
    tmp_post$6 = q;
    q = q + 1l;
    *tmp_post$6 = 0x7fffffff;
    lgl->wchs->stk.top = q;
    lglfitstk(lgl, &lgl->wchs->stk);
    lgl->limits->dfg.pshwchs = lgl->stats->pshwchs + (signed long int)lgl->opts->defragint.val;
    lgl->limits->dfg.prgss = lgl->stats->prgss;
    lglrep(lgl, 2, (char)70);
    lglstop(lgl);
  }

}

// lgldefragmenting
// file lglib.c line 16988
static signed int lgldefragmenting(struct LGL *lgl)
{
  signed int relfree;
  if(!(lgl->stats->pshwchs >= lgl->limits->dfg.pshwchs))
    return 0;

  else
    if(lgl->nvars == 0)
      return 0;

    else
    {
      relfree = (100 * lgl->wchs->free + 99) / lgl->nvars;
      return (signed int)(relfree >= lgl->opts->defragfree.val);
    }
}

// lgldel
// file lglib.c line 1271
static void lgldel(struct LGL *lgl, void *ptr, unsigned long int bytes)
{
  if(!(ptr == NULL))
  {
    lgldec(lgl, bytes);

  __CPROVER_DUMP_L2:
    ;
    if(!(lgl->mem->dealloc == ((void (*)(void *, void *, unsigned long int))NULL)))
      lgl->mem->dealloc(lgl->mem->state, ptr, bytes);

    else
      free(ptr);
  }

}

// lgldelstr
// file lglib.c line 1306
static void lgldelstr(struct LGL *lgl, char *str)
{
  do
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    lgldel(lgl, (void *)str, (return_value_strlen$1 + (unsigned long int)1) * sizeof(char) /*1ul*/ );
    str = ((char *)NULL);
  }
  while((_Bool)0);
}

// lgldense
// file lglib.c line 9121
static void lgldense(struct LGL *lgl, signed int occstoo)
{
  signed int lit;
  signed int lidx;
  signed int count;
  signed int idx;
  signed int other;
  signed int other2;
  signed int blit;
  signed int sign;
  signed int tag;
  signed int red;
  const signed int *lgldense$$1$$start;
  const signed int *top;
  const signed int *c;
  const signed int *p;
  const signed int *eow;
  signed int *q;
  signed int *w;
  struct EVar *ev;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  lgl->stats->dense = lgl->stats->dense + 1l;
  count = 0;
  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(struct EVar) /*16ul*/ );
    lgl->evars = (struct EVar *)return_value_lglnew$1;
  }
  while((_Bool)0);
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    ev = lgl->evars + (signed long int)idx;
    ev->pos = -1;
  }
  idx = 2;
  signed int *tmp_post$2;
  signed int *tmp_post$3;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      hts=lglhts(lgl, lit);
      if(!(hts->count == 0))
      {
        w=lglhts2wchs(lgl, hts);
        q = w;
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          tag = blit & MASKCS;
          if(tag == TRNCS || tag == LRGCS)
            p = p + 1l;

          red = blit & REDCS;
          if(!(tag == LRGCS) || red == 0)
          {
            tmp_post$2 = q;
            q = q + 1l;
            *tmp_post$2 = blit;
            if(tag == TRNCS || tag == LRGCS)
            {
              tmp_post$3 = q;
              q = q + 1l;
              *tmp_post$3 = *p;
            }

            if(red == 0)
            {
              if(tag == BINCS || tag == TRNCS)
              {
                other = blit >> RMSHFT;
                signed int return_value_abs$4;
                return_value_abs$4=abs(other);
                if(return_value_abs$4 >= idx)
                {
                  if(tag == TRNCS)
                  {
                    other2 = *p;
                    signed int return_value_abs$5;
                    return_value_abs$5=abs(other2);
                    if(!(return_value_abs$5 >= idx))
                      goto __CPROVER_DUMP_L12;

                    lglincocc(lgl, other2);
                    count = count + 1;
                  }

                  lglincocc(lgl, lit);
                  count = count + 1;
                  lglincocc(lgl, other);
                  count = count + 1;
                }

              }

            }

          }


        __CPROVER_DUMP_L12:
          ;
        }
        lglshrinkhts(lgl, hts, (signed int)(q - w));
      }

    }
  }
  if(!(count == 0))

    __CPROVER_DUMP_L17:
      ;

  if(!(occstoo == 0))
  {
    count = 0;
    lgldense$$1$$start = lgl->irr.start;
    top = lgl->irr.top;
    c = lgldense$$1$$start;
    for( ; !(c >= top); c = p + (signed long int)1)
    {
      p = c;
      if(!(*c >= 134217727))
      {
        lidx = (signed int)(c - lgldense$$1$$start);
        blit = lidx << RMSHFT | OCCS;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          hts=lglhts(lgl, lit);
          lglpushwch(lgl, hts, blit);
          lglincocc(lgl, lit);
          count = count + 1;
          p = p + 1l;
        }
        while((_Bool)1);
      }

    }
  }

  if(!(count == 0))

    __CPROVER_DUMP_L23:
      ;

  count = 0;
  if(lgl->cgrclosing == 0)
  {
    if(lgl->probing == 0)
    {
      if(lgl->gaussing == 0)
      {
        if(lgl->cceing == 0)
        {
          idx = 2;
          for( ; !(idx >= lgl->nvars); idx = idx + 1)
          {
            ev=lglevar(lgl, idx);
            if(!(ev->pos >= 0))
            {
              signed int return_value_lglifrozen$6;
              return_value_lglifrozen$6=lglifrozen(lgl, idx);
              if(return_value_lglifrozen$6 == 0)
              {
                if(!(lgl->donotsched == 0))
                {
                  struct AVar *av;
                  av=lglavar(lgl, idx);
                  if(!(lgl->eliminating == 0))
                  {
                    if(!(av->donotelm == 0u))
                      goto __CPROVER_DUMP_L30;

                  }

                  if(!(lgl->blocking == 0))
                  {
                    if(!(av->donotblk == 0u))
                      goto __CPROVER_DUMP_L30;

                  }

                  if(!(lgl->cceing == 0))
                  {
                    if(!(av->donotcce == 0u))
                      goto __CPROVER_DUMP_L30;

                  }

                }

                lglesched(lgl, idx);
                count = count + 1;
              }

            }


          __CPROVER_DUMP_L30:
            ;
          }
          if(!(count == 0))

            __CPROVER_DUMP_L32:
              ;

        }

      }

    }

  }


__CPROVER_DUMP_L33:
  ;
  lgl->dense = (char)(1 + occstoo);
  lglfullyconnected(lgl);
  struct EVar *return_value_lglevar$7;
  if(lgl->opts->verbose.val >= 1)
  {
    const char *str;
    signed int inst;
    signed int vl;
    count = 0;
    if(!(lgl->eliminating == 0))
    {
      str = "elim";
      inst = lgl->stats->elm.count;
      vl = 1;
    }

    else
      if(!(lgl->blocking == 0))
      {
        str = "block";
        inst = lgl->stats->blk.count;
        vl = 1;
      }

      else
      {
        str = "dense";
        inst = (signed int)lgl->stats->dense;
        vl = 2;
      }
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      return_value_lglevar$7=lglevar(lgl, idx);
      if(return_value_lglevar$7->pos >= 0)
        count = count + 1;

    }
    double return_value_lglpcnt$8;
    return_value_lglpcnt$8=lglpcnt((double)count, (double)(lgl->nvars - 2));
    lglprt(lgl, vl, "[%s-%d] scheduled %d variables %.0f%%", str, inst, count, return_value_lglpcnt$8);
  }

}

// lgldeprioritize
// file lglib.c line 5862
static void lgldeprioritize(struct LGL *lgl)
{
  signed int old_prior;
  signed int new_prior;
  signed int first;
  signed int last;
  struct Qln *p;
  struct Qln *down;
  struct Qln *up;
  signed long int new_prior64;
  lgl->stats->queue.deprior.count = lgl->stats->queue.deprior.count + 1;
  p = lgl->queue.bottom;
  for( ; !(p == ((struct Qln *)NULL)); p = p->up)
  {
    old_prior = p->prior;
    lgl->stats->queue.deprior.sum = lgl->stats->queue.deprior.sum + 1l;
    if(!(old_prior == 0))
    {
      new_prior64 = (signed long int)old_prior;
      new_prior64 = new_prior64 * (signed long int)lgl->opts->queuefactor.val;
      new_prior64 = new_prior64 + (signed long int)999;
      new_prior64 = new_prior64 / (signed long int)1000;
      new_prior = (signed int)new_prior64;
      if(!(new_prior == old_prior))
      {

      __CPROVER_DUMP_L2:
        ;
        p->prior = new_prior;
      }

    }

  }
  p = lgl->queue.bottom;
  for( ; !(p == ((struct Qln *)NULL)); p = up)
  {
    up = p->up;
    down = p->down;
    if(!(down == ((struct Qln *)NULL)))
    {
      if(down->prior >= p->prior)
      {

      __CPROVER_DUMP_L6:
        ;
        down->up = up;
        if(!(up == ((struct Qln *)NULL)))
          up->down = down;

        else
          lgl->queue.top = down;
        first = down->first;
        down->first = p->first;
        if(!(p->unassigned == 0))
          down->unassigned = p->unassigned;

        if(lgl->queue.unassigned == p)
          lgl->queue.unassigned = down;

        last = p->last;
        p->last = 0;
        p->first = p->last;
        struct Qnd *return_value_lglqnd$1;
        return_value_lglqnd$1=lglqnd(lgl, first);
        return_value_lglqnd$1->prev = last;
        struct Qnd *return_value_lglqnd$2;
        return_value_lglqnd$2=lglqnd(lgl, last);
        return_value_lglqnd$2->next = first;
        p->repr = down;
        p->down = ((struct Qln *)NULL);
        p->up = lgl->queue.merged;
        lgl->queue.merged = p;
        lgl->queue.nmerged = lgl->queue.nmerged + 1;
        lgl->stats->queue.merged = lgl->stats->queue.merged + 1l;
        if(lgl->queue.nmerged >= lgl->opts->queuemergelim.val)
          lglflushqmerged(lgl);

      }

    }

  }
  lglchkqueue(lgl);
  if(lgl->opts->log.val >= 5)
    lglqdump(lgl);

}

// lglderef
// file lglib.h line 192
signed int lglderef(struct LGL *lgl, signed int elit)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglderef");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "deref %d", elit);
    break;
  }
  lgl->stats->calls.deref = lgl->stats->calls.deref + 1l;
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglderef");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not deref zero literal");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }

__CPROVER_DUMP_L8:
  ;
  do
  {
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglderef");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

    while((96 & (signed int)lgl->state) == 0)
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglderef");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "!(%s)", (const void *)"SATISFIED | EXTENDED");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
  }
  while((_Bool)0);
  if((EXTENDED & (signed int)lgl->state) == 0)
    lglextend(lgl);

  res=lglederef(lgl, elit);

__CPROVER_DUMP_L15:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglderef(lgl->clone, elit);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglderef");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d", (const void *)"lglderef", elit, CLONERES, (const void *)"lglderef", elit, res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lgldie
// file lglib.c line 1160
static void lgldie(struct LGL *lgl, const char *msg, ...)
{
  void **ap;
  fprintf(lgl->out, "*** internal error in '%s': ", (const void *)"lglib.c");
  ap = (void **)&msg;
  vfprintf(lgl->out, msg, ap);
  ap = ((void **)NULL);
  fputc(10, lgl->out);
  fflush(lgl->out);
  exit(0);
}

// lgldis
// file lglib.c line 6408
static void lgldis(struct LGL *lgl)
{
  signed int blit;
  signed int nblit;
  signed int tag;
  signed int red;
  signed int *p;
  signed int *q;
  signed int *eow;
  signed int *w;
  signed int idx;
  signed int sign;
  signed int lit;
  signed int other;
  signed int other2;
  struct Stk bins;
  struct Stk trns;
  signed char val;
  signed char val2;
  struct HTS *hts;
  do
    memset((void *)&bins, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  do
    memset((void *)&trns, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  idx = 2;
  _Bool tmp_if_expr$2;
  signed int return_value_lgliselim$1;
  signed int *tmp_post$5;
  signed int *tmp_post$6;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = idx * sign;
      hts=lglhts(lgl, lit);
      if(!(hts->offset == 0))
      {
        val=lglval(lgl, lit);
        if(!(val == 0))
          tmp_if_expr$2 = (_Bool)1;

        else
        {
          return_value_lgliselim$1=lgliselim(lgl, lit);
          tmp_if_expr$2 = return_value_lgliselim$1 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$2)
          lglshrinkhts(lgl, hts, 0);

        else
        {
          w=lglhts2wchs(lgl, hts);
          eow = w + (signed long int)hts->count;
          p = w;
          for( ; !(p >= eow); p = p + 1l)
          {
            blit = *p;
            tag = blit & MASKCS;
            red = blit & REDCS;
            if(!(tag == OCCS))
            {
              if(tag == TRNCS || tag == LRGCS)
                p = p + 1l;

              if(!(tag == LRGCS))
              {
                other = blit >> RMSHFT;
                val=lglval(lgl, other);
                if(!((signed int)val >= 1))
                {
                  signed int return_value_lgliselim$3;
                  return_value_lgliselim$3=lgliselim(lgl, other);
                  if(return_value_lgliselim$3 == 0)
                  {
                    if(tag == BINCS)
                      lglpushstk(lgl, &bins, blit);

                    else
                    {
                      other2 = *p;
                      val2=lglval(lgl, other2);
                      if(!((signed int)val2 >= 1))
                      {
                        signed int return_value_lgliselim$4;
                        return_value_lgliselim$4=lgliselim(lgl, other2);
                        if(return_value_lgliselim$4 == 0)
                        {
                          if(!((signed int)val >= 0))
                          {
                            nblit = red | other2 << RMSHFT | BINCS;
                            lglpushstk(lgl, &bins, nblit);
                          }

                          else
                            if(!((signed int)val2 >= 0))
                            {
                              nblit = red | other << RMSHFT | BINCS;
                              lglpushstk(lgl, &bins, nblit);
                            }

                            else
                            {
                              lglpushstk(lgl, &trns, blit);
                              lglpushstk(lgl, &trns, other2);
                            }
                        }

                      }

                    }
                  }

                }

              }

            }

          }
          q = w;
          p = bins.start;
          for( ; !(p == bins.top); p = p + 1l)
          {
            tmp_post$5 = q;
            q = q + 1l;
            *tmp_post$5 = *p;
          }
          p = trns.start;
          for( ; !(p == trns.top); p = p + 1l)
          {
            tmp_post$6 = q;
            q = q + 1l;
            *tmp_post$6 = *p;
          }
          lglshrinkhts(lgl, hts, (signed int)(q - w));
          lglclnstk(&bins);
          lglclnstk(&trns);
        }
      }

    }
  }
  lglrelstk(lgl, &bins);
  lglrelstk(lgl, &trns);
}

// lgldstpull
// file lglib.c line 14382
static signed int lgldstpull(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  if(!(av->mark == 0))
    return 0;

  else
  {
    signed int return_value_lglevel$1;
    return_value_lglevel$1=lglevel(lgl, lit);
    if(return_value_lglevel$1 == 0)
      return 0;

    else
    {
      av->mark = 1;
      signed int return_value_lgldecision$2;
      return_value_lgldecision$2=lgldecision(lgl, lit);
      if(!(return_value_lgldecision$2 == 0))
        lglpushstk(lgl, &lgl->clause, lit);

      else
        lglpushstk(lgl, &lgl->seen, -lit);

    __CPROVER_DUMP_L3:
      ;

    __CPROVER_DUMP_L5:
      ;
      return 1;
    }
  }
}

// lgldvar
// file lglib.c line 2313
static struct DVar * lgldvar(struct LGL *lgl, signed int lit)
{
  signed int return_value_abs$1;
  return_value_abs$1=abs(lit);
  return lgl->dvars + (signed long int)return_value_abs$1;
}

// lgldynstr
// file lglib.c line 5725
static void lgldynstr(struct LGL *lgl, signed int del, signed int lit, signed int r0, signed int r1)
{
  signed int *p;
  signed int *c;
  signed int lidx;
  signed int other;
  signed int red;
  signed int tag;
  signed int glue;
  signed int other2;
  signed int other3;
  signed int blit;
  tag = r0 & MASKCS;

__CPROVER_DUMP_L1:
  ;
  red = r0 & REDCS;
  if(!(red == 0))
    lgl->stats->otfs.str.dyn.red = lgl->stats->otfs.str.dyn.red + 1;

  else
    lgl->stats->otfs.str.dyn.irr = lgl->stats->otfs.str.dyn.irr + 1;
  lgl->stats->prgss = lgl->stats->prgss + 1l;
  if(red == 0)
    lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;

  if(tag == BINCS)
  {
    other = del == lit ? r0 >> RMSHFT : lit;
    lglrmbcls(lgl, del, other, red);
    lglunflict(lgl, other);
  }

  else
  {
    if(tag == TRNCS)
    {
      if(lit == del)
      {
        other = r0 >> RMSHFT;
        other2 = r1;
      }

      else
        if(del == r1)
        {
          other = lit;
          other2 = r0 >> RMSHFT;
        }

        else
        {
          other = lit;
          other2 = r1;
        }
      lglrmtcls(lgl, del, other, other2, red);
      if(red == 0)
        lglincirr(lgl, 2);

      else
        lgl->stats->red.bin = lgl->stats->red.bin + 1;
      lglwchbin(lgl, other, other2, red);
      lglwchbin(lgl, other2, other, red);
      signed int return_value_lglevel$1;
      return_value_lglevel$1=lglevel(lgl, other);
      signed int return_value_lglevel$2;
      return_value_lglevel$2=lglevel(lgl, other2);
      if(!(return_value_lglevel$1 >= return_value_lglevel$2))
        do
        {
          signed int TMP = other;
          other = other2;
          other2 = TMP;
        }
        while((_Bool)0);

      blit = other2 << RMSHFT | BINCS | red;
      lglbonflict(lgl, other, blit);
      goto __CPROVER_DUMP_L31;
    }

    lidx = r1;
    glue = red != 0 ? lidx & (1 << 4) - 1 : 0;
    c=lglidx2lits(lgl, LRGCS, red, lidx);
    p = c;
    for( ; !(*p == del); p = p + 1l)
      ;
    if(!(glue >= 15))
    {
      lglrmlwch(lgl, c[(signed long int)0], red, lidx);
      lglrmlwch(lgl, c[(signed long int)1], red, lidx);
    }

    do
    {
      p = p + 1l;
      other = *p;
      if(other == 0)
        break;

      p[(signed long int)-1] = other;
    }
    while((_Bool)1);
    p[(signed long int)-1] = 0;
    *p = 0x7fffffff;
    if(red == 0)
      lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur - 1;

    lglorderclsaux(lgl, c + (signed long int)0);
    lglorderclsaux(lgl, c + (signed long int)1);
    if(p - c == 4l)
    {
      other = c[(signed long int)0];
      other2 = c[(signed long int)1];
      other3 = c[(signed long int)2];
      if(!(red == 0) && !(glue >= 15))
      {

      __CPROVER_DUMP_L19:
        ;
        c[(signed long int)-1] = 0x7fffffff;
      }

      c[(signed long int)3] = 0x7fffffff;
      c[(signed long int)2] = c[(signed long int)3];
      c[(signed long int)1] = c[(signed long int)2];
      c[(signed long int)0] = c[(signed long int)1];
      signed int return_value_lglevel$3;
      return_value_lglevel$3=lglevel(lgl, other2);
      signed int return_value_lglevel$4;
      return_value_lglevel$4=lglevel(lgl, other3);
      if(!(return_value_lglevel$3 >= return_value_lglevel$4))
        do
        {
          signed int lgldynstr$$1$$6$$2$$TMP = other2;
          other2 = other3;
          other3 = lgldynstr$$1$$6$$2$$TMP;
        }
        while((_Bool)0);

      signed int return_value_lglevel$5;
      return_value_lglevel$5=lglevel(lgl, other);
      signed int return_value_lglevel$6;
      return_value_lglevel$6=lglevel(lgl, other2);
      if(!(return_value_lglevel$5 >= return_value_lglevel$6))
        do
        {
          signed int lgldynstr$$1$$6$$3$$TMP = other;
          other = other2;
          other2 = lgldynstr$$1$$6$$3$$TMP;
        }
        while((_Bool)0);

      lglwchtrn(lgl, other, other2, other3, red);
      lglwchtrn(lgl, other2, other, other3, red);
      lglwchtrn(lgl, other3, other, other2, red);
      if(!(red == 0))
      {
        lgl->stats->red.lrg = lgl->stats->red.lrg - 1;
        lgl->stats->lir[(signed long int)glue].clauses = lgl->stats->lir[(signed long int)glue].clauses - 1;
        lgl->stats->red.trn = lgl->stats->red.trn + 1;
      }

      lgltonflict(lgl, other, other2 << RMSHFT | red | TRNCS, other3);
    }

    else
    {
      if(!(glue >= 15))
      {

      __CPROVER_DUMP_L27:
        ;
        lglwchlrg(lgl, c[(signed long int)0], c[(signed long int)1], red, lidx);

      __CPROVER_DUMP_L28:
        ;
        lglwchlrg(lgl, c[(signed long int)1], c[(signed long int)0], red, lidx);
      }

      lglonflict(lgl, 0, c[(signed long int)0], red, lidx);
    }
  }

__CPROVER_DUMP_L31:
  ;
}

// lgldynsub
// file lglib.c line 5707
static void lgldynsub(struct LGL *lgl, signed int lit, signed int r0, signed int r1)
{
  signed int red;
  signed int tag = r0 & MASKCS;

__CPROVER_DUMP_L1:
  ;
  red = r0 & REDCS;
  if(!(red == 0))
    lgl->stats->otfs.sub.dyn.red = lgl->stats->otfs.sub.dyn.red + 1;

  else
    lgl->stats->otfs.sub.dyn.irr = lgl->stats->otfs.sub.dyn.irr + 1;
  if(tag == BINCS)
    lglrmbcls(lgl, lit, r0 >> RMSHFT, red);

  else
    if(tag == TRNCS)
      lglrmtcls(lgl, lit, r0 >> RMSHFT, r1, red);

    else
      lglrmlcls(lgl, r1, red);
}

// lgleadd
// file lglib.c line 3850
static void lgleadd(struct LGL *lgl, signed int elit)
{
  signed int ilit;
  lglreset(lgl);
  if(!(elit == 0))
    ilit=lglimport(lgl, elit);

  else
    ilit = 0;

__CPROVER_DUMP_L1:
  ;

__CPROVER_DUMP_L3:
  ;
  lglfadd(lgl, elit);
  lgliadd(lgl, ilit);
}

// lgleassign
// file lglib.c line 17364
static void lgleassign(struct LGL *lgl, signed int lit)
{
  struct Ext *ext;
  ext=lglelit2ext(lgl, lit);

__CPROVER_DUMP_L1:
  ;
  ext->val=lglsgn(lit);
}

// lgleassume
// file lglib.c line 3916
static void lgleassume(struct LGL *lgl, signed int elit)
{
  signed int ilit;
  signed int val;
  unsigned int bit;
  struct AVar *av;
  struct Ext *ext;
  lglreset(lgl);
  ilit=lglimport(lgl, elit);

__CPROVER_DUMP_L1:
  ;
  bit = 1u << (signed int)(elit < 0);
  ext=lglelit2ext(lgl, elit);
  if((bit & (unsigned int)ext->assumed) == 0u)
  {
    ext->assumed = (unsigned int)ext->assumed | bit;
    lglpushstk(lgl, &lgl->eassume, elit);
  }

  val=lglcval(lgl, ilit);
  if(val == 0)
  {
    av=lglavar(lgl, ilit);
    bit = 1u << (signed int)(ilit < 0);
    if(!((bit & (unsigned int)av->assumed) == 0u))

      __CPROVER_DUMP_L3:
        ;

    else
    {
      av->assumed = (unsigned int)av->assumed | bit;
      if(!(((3u ^ bit) & (unsigned int)av->assumed) == 0u))

        __CPROVER_DUMP_L5:
          ;

      lglpushstk(lgl, &lgl->assume, ilit);
    }
  }

  else
    if(val >= 1)

      __CPROVER_DUMP_L9:
        ;

    else
    {

    __CPROVER_DUMP_L10:
      ;
      if(!(ilit == -1))
      {
        av=lglavar(lgl, ilit);
        bit = 1u << (signed int)(ilit < 0);
        if((bit & (unsigned int)av->assumed) == 0u)
        {
          av->assumed = (unsigned int)av->assumed | bit;
          lglpushstk(lgl, &lgl->assume, ilit);
        }

      }

      if(lgl->failed == 0)
        lgl->failed = ilit;

    }
}

// lglecalc
// file lglib.c line 3362
static signed int lglecalc(struct LGL *lgl, struct EVar *ev)
{
  signed int oldscore = ev->score;
  ev->score = ev->occ[(signed long int)0] + ev->occ[(signed long int)1];
  return ev->score - oldscore;
}

// lglecassume
// file lglib.c line 3959
static void lglecassume(struct LGL *lgl, signed int elit)
{

__CPROVER_DUMP_L1:
  ;
}

// lglecls
// file lglib.c line 9371
static signed int lglecls(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int lidx;
  signed int count;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  signed int d[4l];
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  count = 0;
  hts=lglhts(lgl, lit);
  signed int tmp_if_expr$1;
  if(hts->count == 0)
    return 0;

  else
  {
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      blit = *p;
      tag = blit & MASKCS;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      if(!(tag == LRGCS))
      {
        red = blit & REDCS;
        if(red == 0)
        {
          if(tag == BINCS || tag == TRNCS)
          {
            d[(signed long int)0] = lit;
            other = blit >> RMSHFT;
            d[(signed long int)1] = other;
            if(tag == TRNCS)
            {
              d[(signed long int)2] = *p;
              d[(signed long int)3] = 0;
            }

            else
              d[(signed long int)2] = 0;
            c = d;
          }

          else
          {
            if(tag == OCCS)
              tmp_if_expr$1 = blit >> RMSHFT;

            else
              tmp_if_expr$1 = *p;
            lidx = tmp_if_expr$1;
            c=lglidx2lits(lgl, OCCS, 0, lidx);
          }
          lgladdecl(lgl, c);
          count = count + 1;
        }

      }

    }
    return count;
  }
}

// lglecmp
// file lglib.c line 3194
static signed int lglecmp(struct LGL *lgl, signed int l, signed int k)
{
  struct EVar *return_value_lglevar$1;
  return_value_lglevar$1=lglevar(lgl, k);
  struct EVar *return_value_lglevar$2;
  return_value_lglevar$2=lglevar(lgl, l);
  return return_value_lglevar$1->score - return_value_lglevar$2->score;
}

// lglederef
// file lglib.c line 8448
static signed int lglederef(struct LGL *lgl, signed int elit)
{
  signed int ilit;
  signed int res;
  struct Ext *ext;
  signed int return_value_abs$1;
  return_value_abs$1=abs(elit);
  signed int tmp_if_expr$3;
  signed int return_value_lglcval$2;
  if(!(lgl->maxext >= return_value_abs$1))
    return -1;

  else
  {
    ext=lglelit2ext(lgl, elit);
    res = (signed int)ext->val;
    if(res == 0)
    {
      ilit = ext->repr;
      if(!(ilit == 0))
      {
        return_value_lglcval$2=lglcval(lgl, ilit);
        tmp_if_expr$3 = return_value_lglcval$2;
      }

      else
        tmp_if_expr$3 = -1;
      res = tmp_if_expr$3;
    }

    if(!(elit >= 0))
      res = -res;

    return res;
  }
}

// lgledown
// file lglib.c line 3250
static void lgledown(struct LGL *lgl, signed int lit)
{
  signed int parent = lit;
  signed int child;
  signed int right;
  signed int ppos;
  signed int cpos;
  signed int *p;
  signed int *pposptr;
  signed int *cposptr;
  signed int size;
  struct Stk *s = &lgl->esched;
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(s);
  size = (signed int)return_value_lglcntstk$1;
  p = s->start;
  pposptr=lglepos(lgl, parent);
  ppos = *pposptr;
  do
  {
    cpos = 2 * ppos + 1;
    if(cpos >= size)
      break;

    child = p[(signed long int)cpos];
    if(!(1 + cpos >= size))
    {
      right = p[(signed long int)(cpos + 1)];
      signed int return_value_lglecmp$2;
      return_value_lglecmp$2=lglecmp(lgl, child, right);
      if(!(return_value_lglecmp$2 >= 0))
      {
        cpos = cpos + 1;
        child = right;
      }

    }

    signed int return_value_lglecmp$3;
    return_value_lglecmp$3=lglecmp(lgl, child, lit);
    if(!(return_value_lglecmp$3 >= 1))
      break;

    cposptr=lglepos(lgl, child);
    p[(signed long int)ppos] = child;
    *cposptr = ppos;

  __CPROVER_DUMP_L4:
    ;
    ppos = cpos;
  }
  while((_Bool)1);
  if(!(*pposptr == ppos))
  {
    *pposptr = ppos;
    p[(signed long int)ppos] = lit;
  }


__CPROVER_DUMP_L7:
  ;
}

// lglefixed
// file lglib.c line 17958
static signed int lglefixed(struct LGL *lgl, signed int elit)
{
  signed int res;
  signed int ilit;
  signed int return_value_abs$1;
  return_value_abs$1=abs(elit);
  signed int return_value_abs$3;
  signed char return_value_lglifixed$2;
  if(!(lgl->maxext >= return_value_abs$1))
    return 0;

  else
  {
    ilit=lglimport(lgl, elit);
    if(ilit == 0)
      res = 0;

    else
    {
      return_value_abs$3=abs(ilit);
      if(return_value_abs$3 == 1)
        res = ilit;

      else
      {
        return_value_lglifixed$2=lglifixed(lgl, ilit);
        res = (signed int)return_value_lglifixed$2;
      }
    }
    return res;
  }
}

// lglelim
// file lglib.c line 12128
static signed int lglelim(struct LGL *lgl)
{
  signed int res = 1;
  signed int idx;
  signed int elmd;
  signed int oldnvars;
  signed int success;
  signed int all;
  signed int rem;
  signed int oldrem = (signed int)lgl->elmrem;
  signed int oldall = (signed int)lgl->elmall;
  signed long int oldprgss;
  lglstart(lgl, &lgl->times->elm);
  lgl->stats->elm.count = lgl->stats->elm.count + 1;
  lgl->simp = (char)1;
  lgl->eliminating = lgl->simp;
  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Elm) /*256ul*/ );
    lgl->$anon0.elm = (struct Elm *)return_value_lglnew$1;
  }
  while((_Bool)0);
  if(lgl->level >= 1)
    lglbacktrack(lgl, 0);

  oldnvars=lglrem(lgl);
  lglgc(lgl);
  lglfreezer(lgl);
  all = (signed int)(!(oldrem != 0) || !(oldall != 0));
  signed int return_value_lgleschedrem$2;
  if(!(all == 0))
    lglprt(lgl, 1, "[elim-%d] scheduling all variables this time", lgl->stats->elm.count);

  else
  {
    return_value_lgleschedrem$2=lgleschedrem(lgl, 1);
    if(return_value_lgleschedrem$2 == 0)
    {
      all = 1;
      oldrem = 0;
    }

  }
  if(all == 0)
    lgl->donotsched = (char)1;

  lgldense(lgl, 1);
  if(all == 0)
    lgl->donotsched = (char)0;

  lglsetelmlim(lgl);
  oldprgss = lgl->stats->prgss;
  signed int return_value_lglsmallirr$3;
  signed int return_value_lglterminate$4;
  signed int return_value_lglmtstk$5;
  while(!(res == 0))
  {
    return_value_lglsmallirr$3=lglsmallirr(lgl);
    if(return_value_lglsmallirr$3 == 0)
      break;

    return_value_lglterminate$4=lglterminate(lgl);
    if(!(return_value_lglterminate$4 == 0))
      break;

    return_value_lglmtstk$5=lglmtstk(&lgl->esched);
    if(!(return_value_lglmtstk$5 == 0))
      break;

    if(lgl->stats->elm.steps >= lgl->limits->elm.steps)
      break;

    idx=lglpopesched(lgl);
    struct AVar *return_value_lglavar$6;
    return_value_lglavar$6=lglavar(lgl, idx);
    return_value_lglavar$6->donotelm = (unsigned int)1;
    lglelimlit(lgl, idx);
    res=lglflush(lgl);
  }
  unsigned long int return_value_lglcntstk$7;
  return_value_lglcntstk$7=lglcntstk(&lgl->esched);
  rem = (signed int)return_value_lglcntstk$7;
  double return_value_lglpcnt$8;
  if(rem == 0)
    lglprt(lgl, 1, "[elim-%d] fully completed variable elimination", lgl->stats->elm.count);

  else
    if(oldrem == 0)
    {
      return_value_lglpcnt$8=lglpcnt((double)rem, (double)(lgl->nvars - 2));
      lglprt(lgl, 1, "[elim-%d] incomplete variable elimination %d not tried %.0f%%", lgl->stats->elm.count, rem, return_value_lglpcnt$8);
    }

    else
      rem=lgleschedrem(lgl, 0);
  lglsetdonotesched(lgl, (signed int)!(rem != 0));
  lglrelstk(lgl, &lgl->esched);
  lglrelecls(lgl);
  lglsparse(lgl);
  lglgc(lgl);
  lgl->elmrem = (char)(rem > 0);
  lgl->elmall = (char)(all != 0 && rem != 0);
  lglprt(lgl, 1, "[elim-%d] transition to [ all %d rem %d ] state", lgl->stats->elm.count, lgl->elmall, lgl->elmrem);
  signed int return_value_lglrem$9;
  return_value_lglrem$9=lglrem(lgl);
  elmd = oldnvars - return_value_lglrem$9;
  success = (signed int)(oldprgss < lgl->stats->prgss);
  lgl->stats->irrprgss = lgl->stats->irrprgss + (signed long int)elmd;
  lglupdelmint(lgl, success);
  double return_value_lglpcnt$10;
  return_value_lglpcnt$10=lglpcnt((double)elmd, (double)oldnvars);
  lglprt(lgl, 1, "[elim-%d] eliminated %d = %.0f%% variables out of %d", lgl->stats->elm.count, elmd, return_value_lglpcnt$10, oldnvars);
  do
  {
    lgldel(lgl, (void *)lgl->$anon0.elm, (unsigned long int)1 * sizeof(struct Elm) /*256ul*/ );
    lgl->$anon0.elm = ((struct Elm *)NULL);
  }
  while((_Bool)0);
  lglrep(lgl, 1 + (signed int)!(success != 0), (char)101);
  lgl->simp = (char)0;
  lgl->eliminating = lgl->simp;
  lglstop(lgl);
  return (signed int)!(lgl->mt != 0);
}

// lgleliminated
// file lglib.c line 10121
static void lgleliminated(struct LGL *lgl, signed int pivot)
{
  struct AVar *av;
  signed int elit;
  struct Ext *e;
  av=lglavar(lgl, pivot);
  av->type = (unsigned int)ELIMVAR;
  lgl->stats->elm.elmd = lgl->stats->elm.elmd + 1;
  lglflushclauses(lgl, pivot);
  lglflushclauses(lgl, -pivot);

__CPROVER_DUMP_L1:
  ;
  elit=lglexport(lgl, pivot);
  e=lglelit2ext(lgl, elit);
  e->eliminated = (unsigned int)1;
}

// lgleliminating
// file lglib.c line 16970
static signed int lgleliminating(struct LGL *lgl)
{
  if(lgl->opts->elim.val == 0)
    return 0;

  else
  {
    signed int return_value_lglsmallirr$1;
    return_value_lglsmallirr$1=lglsmallirr(lgl);
    if(return_value_lglsmallirr$1 == 0)
      return 0;

    else
      if(!(lgl->nvars >= 3))
        return 0;

      else
        if(!(lgl->mt == 0))
          return 0;

        else
          if(!(lgl->elmrem == 0))
            return 1;

          else
            return (signed int)(lgl->stats->irrprgss > lgl->limits->elm.irrprgss);
  }
}

// lglelimlit
// file lglib.c line 11059
static void lglelimlit(struct LGL *lgl, signed int idx)
{
  signed int return_value_lglisfree$1;
  return_value_lglisfree$1=lglisfree(lgl, idx);
  signed int return_value_lgltrysmallve$3;
  if(!(return_value_lglisfree$1 == 0))
  {
    signed int return_value_lglchkoccs4elm$2;
    return_value_lglchkoccs4elm$2=lglchkoccs4elm(lgl, idx);
    if(!(return_value_lglchkoccs4elm$2 == 0))
    {

    __CPROVER_DUMP_L1:
      ;
      if(!(lgl->opts->smallve.val == 0))
      {
        return_value_lgltrysmallve$3=lgltrysmallve(lgl, idx);
        if(return_value_lgltrysmallve$3 == 0)
          goto __CPROVER_DUMP_L2;

      }

      else
      {

      __CPROVER_DUMP_L2:
        ;
        lglinitecls(lgl, idx);
        lglelimlitaux(lgl, idx);
        if(!(lgl->$anon0.elm->pivot == 0))
          lglrstecls(lgl);

      }
    }

  }

}

// lglelimlitaux
// file lglib.c line 10453
static void lglelimlitaux(struct LGL *lgl, signed int idx)
{
  lglelmsub(lgl);
  signed int return_value_lglelmstr$1;
  return_value_lglelmstr$1=lglelmstr(lgl);
  if(return_value_lglelmstr$1 == 0)
  {
    lglelmfre(lgl);
    lgltrylargeve(lgl);
  }

}

// lglelit2ext
// file lglib.c line 2461
static struct Ext * lglelit2ext(struct LGL *lgl, signed int elit)
{
  signed int idx;
  idx=abs(elit);
  return lgl->ext + (signed long int)idx;
}

// lglelitblockingoreliminated
// file lglib.c line 12199
static signed int lglelitblockingoreliminated(struct LGL *lgl, signed int elit)
{
  struct Ext *ext;
  ext=lglelit2ext(lgl, elit);
  _Bool tmp_if_expr$1;
  if(!(ext->blocking == 0u))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ext->eliminated != 0u ? (_Bool)1 : (_Bool)0;
  return (signed int)tmp_if_expr$1;
}

// lglelmfre
// file lglib.c line 10111
static void lglelmfre(struct LGL *lgl)
{
  signed int *sop;
  signed int *eop;
  signed int *son;
  signed int *eon;
  sop = lgl->$anon0.elm->lits.start + (signed long int)1;
  son = lgl->$anon0.elm->lits.start + (signed long int)lgl->$anon0.elm->neglidx;
  eop = son;
  eon = lgl->$anon0.elm->lits.top;
  lglelmfrelit(lgl, 1, sop, eop, son, eon);
  lglelmfrelit(lgl, -1, son, eon, sop, eop);
}

// lglelmfrelit
// file lglib.c line 10024
static void lglelmfrelit(struct LGL *lgl, signed int mpivot, signed int *sop, signed int *eop, signed int *son, signed int *eon)
{
  signed int ipivot = mpivot * lgl->$anon0.elm->pivot;
  signed int clidx;
  signed int ilit;
  signed int tmp;
  signed int cover;
  signed int maxcover;
  signed int *c;
  signed int *d;
  signed int *p;
  signed int *q;
  signed int lit;
  signed int nontrivial;
  signed int idx;
  signed int sgn;
  signed int clen;
  signed int reslen;

__CPROVER_DUMP_L1:
  ;
  clidx = 0;
  signed int return_value_lglulit$1;
  return_value_lglulit$1=lglulit(-mpivot);
  cover=lglpeek(&lgl->$anon0.elm->noccs, return_value_lglulit$1);
  c = sop;
  for( ; !(c >= eop); c = p + (signed long int)1)
  {
    if(!(lgl->eliminating == 0))
      lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;

    if(*c == 0x7fffffff)
    {
      p = c + (signed long int)1;
      for( ; !(*p == 0); p = p + 1l)
        ;
    }

    else
    {
      maxcover = 0;
      p = c;
      do
      {
        lit = *p;
        if(lit == 0)
          break;

        if(!(lit == mpivot))
        {
          signed int return_value_lglulit$2;
          return_value_lglulit$2=lglulit(-lit);
          signed int return_value_lglpeek$3;
          return_value_lglpeek$3=lglpeek(&lgl->$anon0.elm->noccs, return_value_lglulit$2);
          maxcover = maxcover + return_value_lglpeek$3;
        }

        p = p + 1l;
      }
      while((_Bool)1);
      if(!(maxcover >= cover + -1))
        clidx = clidx + 1;

      else
      {
        p = c;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          if(!(lit == mpivot))
          {
            idx=abs(lit);
            sgn=lglsgn(lit);
            lglpoke(&lgl->$anon0.elm->mark, idx, sgn);
          }

          p = p + 1l;
        }
        while((_Bool)1);
        nontrivial = 0;
        clen = (signed int)(p - c);
        d = son;
        for( ; nontrivial == 0 && !(d >= eon); d = q + (signed long int)1)
        {
          lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
          if(*d == 0x7fffffff)
          {
            q = d + (signed long int)1;
            for( ; !(*q == 0); q = q + 1l)
              ;
          }

          else
          {
            lgl->stats->elm.resolutions = lgl->stats->elm.resolutions + 1l;

          __CPROVER_DUMP_L18:
            ;

          __CPROVER_DUMP_L19:
            ;
            reslen = clen - 1;
            q = d;
            do
            {
              lit = *q;
              if(lit == 0)
                break;

              if(!(lit == -mpivot))
              {
                idx=abs(lit);
                sgn=lglsgn(lit);
                tmp=lglpeek(&lgl->$anon0.elm->mark, idx);
                if(tmp == -sgn)
                  break;

                if(!(tmp == sgn))
                  reslen = reslen + 1;

              }

              q = q + 1l;
            }
            while((_Bool)1);
            if(!(lit == 0))
              do
              {
                q = q + 1l;
                if(*q == 0)
                  break;

              }
              while((_Bool)1);

            else
            {

            __CPROVER_DUMP_L25:
              ;
              nontrivial = 0x7fffffff;
            }
          }

        __CPROVER_DUMP_L24:
          ;
        }
        p = c;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          if(!(lit == mpivot))
          {
            idx=abs(lit);
            lglpoke(&lgl->$anon0.elm->mark, idx, 0);
          }

          p = p + 1l;
        }
        while((_Bool)1);
        if(!(lgl->opts->block.val == 0))
        {
          if(lgl->opts->elmblk.val == 0)
            goto __CPROVER_DUMP_L35;

          if(!(nontrivial == 0))
            goto __CPROVER_DUMP_L35;

          lgl->stats->elm.blkd = lgl->stats->elm.blkd + 1;

        __CPROVER_DUMP_L31:
          ;
          lglepush(lgl, 0);
          lglepush(lgl, ipivot);
          p = c;
          do
          {
            lit = *p;
            if(lit == 0)
              break;

            if(!(lit == mpivot))
            {
              ilit=lglm2i(lgl, lit);
              lglepush(lgl, ilit);
            }

            p = p + 1l;
          }
          while((_Bool)1);
          lglelrmcls(lgl, ipivot, c, clidx);
          lglblockinglit(lgl, ipivot);
        }

        else
        {

        __CPROVER_DUMP_L35:
          ;
          clidx = clidx + 1;
          if(lgl->stats->elm.steps >= lgl->limits->elm.steps)
          {

          __CPROVER_DUMP_L36:
            ;
            goto __CPROVER_DUMP_L39;
          }

        }
      }
    }
  }

__CPROVER_DUMP_L39:
  ;
}

// lglelmstr
// file lglib.c line 9658
static signed int lglelmstr(struct LGL *lgl)
{
  signed int clidx;
  signed int count;
  signed int strengthened;
  signed int pivot;
  signed int *c;
  signed int *p;
  signed int mlit;
  signed int ilit;
  signed int res;
  signed int found;
  signed int size;
  strengthened = 0;
  clidx = strengthened;
  count = clidx;
  pivot = lgl->$anon0.elm->pivot;
  res = 0;

__CPROVER_DUMP_L1:
  ;
  c = lgl->$anon0.elm->lits.start + (signed long int)1;
  _Bool tmp_if_expr$1;
  signed int tmp_post$2;
  do
  {
    if(!(c >= lgl->$anon0.elm->lits.top))
      tmp_if_expr$1 = lgl->limits->elm.steps > lgl->stats->elm.steps ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
    tmp_post$2 = count;
    count = count + 1;
    if(tmp_post$2 == lgl->$anon0.elm->negcls)
    {
      clidx = 0;
      pivot = -pivot;
    }


  __CPROVER_DUMP_L5:
    ;
    if(*c == 0x7fffffff)
      for( ; !(*c == 0); c = c + 1l)
        ;

    else
    {
      signed int return_value_lglbacksub$3;
      return_value_lglbacksub$3=lglbacksub(lgl, c, 1);
      if(!(return_value_lglbacksub$3 == 0))
      {
        strengthened = strengthened + 1;
        lgl->stats->elm.str = lgl->stats->elm.str + 1;

      __CPROVER_DUMP_L10:
        ;

      __CPROVER_DUMP_L11:
        ;
        found = 0;
        size = 0;
        p = c;
        do
        {
          mlit = *p;
          if(mlit == 0)
            break;

          ilit=lglm2i(lgl, *p);
          if(ilit == pivot)
            found = found + 1;

          else
          {
            lglpushstk(lgl, &lgl->clause, ilit);
            size = size + 1;
          }
          p = p + 1l;
        }
        while((_Bool)1);
        lglpushstk(lgl, &lgl->clause, 0);

      __CPROVER_DUMP_L16:
        ;
        lglelrmcls(lgl, pivot, c, clidx);
        lgladdcls(lgl, 0, 0, 1);
        lglclnstk(&lgl->clause);
        if(size == 1)
        {
          res = 1;
          break;
        }

      }

      else
        clidx = clidx + 1;
      for( ; !(*c == 0); c = c + 1l)
        ;
    }
    c = c + 1l;
  }
  while((_Bool)1);

__CPROVER_DUMP_L22:
  ;
  return res;
}

// lglelmsub
// file lglib.c line 9635
static void lglelmsub(struct LGL *lgl)
{
  signed int clidx;
  signed int count;
  signed int subsumed;
  signed int pivot;
  signed int *c;
  subsumed = 0;
  clidx = subsumed;
  count = clidx;
  pivot = lgl->$anon0.elm->pivot;
  c = lgl->$anon0.elm->lits.start + (signed long int)1;
  _Bool tmp_if_expr$1;
  signed int tmp_post$2;
  do
  {
    if(!(c >= lgl->$anon0.elm->lits.top))
      tmp_if_expr$1 = lgl->limits->elm.steps > lgl->stats->elm.steps ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
    tmp_post$2 = count;
    count = count + 1;
    if(tmp_post$2 == lgl->$anon0.elm->negcls)
    {
      clidx = 0;
      pivot = -pivot;
    }

    signed int return_value_lglbacksub$3;
    return_value_lglbacksub$3=lglbacksub(lgl, c, 0);
    if(!(return_value_lglbacksub$3 == 0))
    {
      subsumed = subsumed + 1;
      lgl->stats->elm.sub = lgl->stats->elm.sub + 1;

    __CPROVER_DUMP_L5:
      ;

    __CPROVER_DUMP_L6:
      ;
      lglelrmcls(lgl, pivot, c, clidx);
    }

    else
      clidx = clidx + 1;
    for( ; !(*c == 0); c = c + 1l)
      ;
    c = c + 1l;
  }
  while((_Bool)1);

__CPROVER_DUMP_L10:
  ;
}

// lglelrmcls
// file lglib.c line 9481
static void lglelrmcls(struct LGL *lgl, signed int lit, signed int *c, signed int clidx)
{
  signed int lidx;
  signed int i;
  signed int other;
  signed int ulit;
  signed int *lglelrmcls$$1$$lits;
  signed int *csigs;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other2;
  signed int *p;
  signed int *eow;
  signed int *w;
  signed int count;
  struct HTS *hts;
  lglelrmcls$$1$$lits = lgl->$anon0.elm->lits.start;
  csigs = lgl->$anon0.elm->csigs.start;
  lidx = (signed int)(c - lglelrmcls$$1$$lits);

__CPROVER_DUMP_L1:
  ;
  i = lidx;
  do
  {
    other = lglelrmcls$$1$$lits[(signed long int)i];
    if(other == 0)
      break;

    lglelrmcls$$1$$lits[(signed long int)i] = 0x7fffffff;
    csigs[(signed long int)i] = 0;
    ulit=lglulit(other);
    lgl->$anon0.elm->noccs.start[(signed long int)ulit] = lgl->$anon0.elm->noccs.start[(signed long int)ulit] - 1;
    i = i + 1;
  }
  while((_Bool)1);
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  count = 0;
  tag = count;
  blit = tag;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(!(tag == LRGCS))
    {
      red = blit & REDCS;
      if(red == 0)
      {
        if(count == clidx)
          break;

        count = count + 1;
      }

    }

  }
  signed int tmp_if_expr$1;
  if(tag == BINCS)
  {
    other = blit >> RMSHFT;
    lglrmbcls(lgl, lit, other, 0);
  }

  else
    if(tag == TRNCS)
    {
      other = blit >> RMSHFT;
      other2 = *p;
      lglrmtcls(lgl, lit, other, other2, 0);
    }

    else
    {
      if(tag == OCCS)
        tmp_if_expr$1 = blit >> RMSHFT;

      else
        tmp_if_expr$1 = *p;
      lidx = tmp_if_expr$1;
      lglrmlcls(lgl, lidx, 0);
    }
}

// lglemerge
// file lglib.c line 8068
static void lglemerge(struct LGL *lgl, signed int ilit0, signed int ilit1)
{
  signed int elit0;
  signed int return_value_abs$1;
  return_value_abs$1=abs(ilit0);
  signed int return_value_lglsgn$2;
  return_value_lglsgn$2=lglsgn(ilit0);
  elit0 = lgl->i2e[(signed long int)return_value_abs$1] * return_value_lglsgn$2;
  signed int elit1;
  signed int return_value_abs$3;
  return_value_abs$3=abs(ilit1);
  signed int return_value_lglsgn$4;
  return_value_lglsgn$4=lglsgn(ilit1);
  elit1 = lgl->i2e[(signed long int)return_value_abs$3] * return_value_lglsgn$4;
  signed int repr0;
  repr0=lglerepr(lgl, elit0);
  signed int repr1;
  repr1=lglerepr(lgl, elit1);
  struct Ext *ext0;
  ext0=lglelit2ext(lgl, repr0);
  if(!(repr0 >= 0))
    repr1 = repr1 * -1;

  ext0->equiv = (unsigned int)1;
  ext0->repr = repr1;

__CPROVER_DUMP_L2:
  ;
  lglepush(lgl, 0);
  lglepush(lgl, -ilit0);
  lglepush(lgl, ilit1);
  lglepush(lgl, 0);
  lglepush(lgl, ilit0);
  lglepush(lgl, -ilit1);
}

// lglenlargegates
// file lglib.c line 12334
static void lglenlargegates(struct LGL *lgl)
{
  signed int oldsize = lgl->$anon0.cgr->szgates;
  signed int newsize = oldsize != 0 ? 2 * oldsize : 1;
  do
  {
    void *return_value_lglrsz$1;
    return_value_lglrsz$1=lglrsz(lgl, (void *)lgl->$anon0.cgr->gates, (unsigned long int)oldsize * sizeof(struct Gat) /*32ul*/ , (unsigned long int)newsize * sizeof(struct Gat) /*32ul*/ );
    lgl->$anon0.cgr->gates = (struct Gat *)return_value_lglrsz$1;
  }
  while((_Bool)0);
  lgl->$anon0.cgr->szgates = newsize;
}

// lglenlctk
// file lglib.c line 1551
static void lglenlctk(struct LGL *lgl, struct Ctk *ctk)
{
  signed int oldsize;
  oldsize=lglsizectk(ctk);
  signed int newsize = oldsize != 0 ? 2 * oldsize : 1;
  signed int count;
  count=lglcntctk(ctk);
  do
  {
    void *return_value_lglrsz$1;
    return_value_lglrsz$1=lglrsz(lgl, (void *)ctk->start, (unsigned long int)oldsize * sizeof(struct Ctr) /*4ul*/ , (unsigned long int)newsize * sizeof(struct Ctr) /*4ul*/ );
    ctk->start = (struct Ctr *)return_value_lglrsz$1;
  }
  while((_Bool)0);
  ctk->top = ctk->start + (signed long int)count;
  ctk->end = ctk->start + (signed long int)newsize;
}

// lglenlstk
// file lglib.c line 1401
static void lglenlstk(struct LGL *lgl, struct Stk *s)
{
  unsigned long int old_size;
  old_size=lglszstk(s);
  unsigned long int new_size = old_size != 0ul ? (unsigned long int)2 * old_size : (unsigned long int)1;
  unsigned long int count;
  count=lglcntstk(s);
  do
  {
    void *return_value_lglrsz$1;
    return_value_lglrsz$1=lglrsz(lgl, (void *)s->start, old_size * sizeof(signed int) /*4ul*/ , new_size * sizeof(signed int) /*4ul*/ );
    s->start = (signed int *)return_value_lglrsz$1;
  }
  while((_Bool)0);
  s->top = s->start + (signed long int)count;
  s->end = s->start + (signed long int)new_size;
}

// lglenlvars
// file lglib.c line 2292
static void lglenlvars(struct LGL *lgl)
{
  unsigned long int old_size;
  unsigned long int new_size;
  old_size = (unsigned long int)lgl->szvars;
  new_size = old_size != 0ul ? (unsigned long int)2 * old_size : (unsigned long int)4;

__CPROVER_DUMP_L1:
  ;
  lglrszvars(lgl, (signed int)new_size);
}

// lglenlwchs
// file lglib.c line 3041
static signed long int lglenlwchs(struct LGL *lgl, struct HTS *hts)
{
  signed int oldhcount = hts->count;
  signed int oldoffset = hts->offset;
  signed int newoffset;
  signed int oldwcount;
  signed int newwcount;
  signed int oldwsize;
  signed int newwsize;
  signed int i;
  signed int j;
  signed int newhcount = oldhcount != 0 ? 2 * oldhcount : 1;
  signed int *oldwstart;
  signed int *newwstart;
  signed int *lglenlwchs$$1$$start;
  signed int ldnewhcount;
  ldnewhcount=lglfloorld(newhcount);
  signed long int res = (signed long int)0;
  newhcount = 1 << ldnewhcount;

__CPROVER_DUMP_L1:
  ;
  lgl->stats->enlwchs = lgl->stats->enlwchs + 1l;
  newoffset = lgl->wchs->start[(signed long int)ldnewhcount];
  lglenlwchs$$1$$start = lgl->wchs->stk.start;
  if(!(newoffset == 0x7fffffff))
  {
    lgl->wchs->start[(signed long int)ldnewhcount] = lglenlwchs$$1$$start[(signed long int)newoffset];
    lglenlwchs$$1$$start[(signed long int)newoffset] = 0;
    lgl->wchs->free = lgl->wchs->free - 1;
  }

  else
  {
    unsigned long int return_value_lglcntstk$1;
    return_value_lglcntstk$1=lglcntstk(&lgl->wchs->stk);
    oldwcount = (signed int)return_value_lglcntstk$1;
    newwcount = oldwcount + newhcount;
    unsigned long int return_value_lglszstk$2;
    return_value_lglszstk$2=lglszstk(&lgl->wchs->stk);
    oldwsize = (signed int)return_value_lglszstk$2;
    newwsize = oldwsize;
    for( ; !(newwsize >= newwcount); newwsize = newwsize * 2)
      ;
    if(!(oldwsize >= newwsize))
    {
      oldwstart = lgl->wchs->stk.start;
      newwstart = oldwstart;
      do
      {
        void *return_value_lglrsz$3;
        return_value_lglrsz$3=lglrsz(lgl, (void *)newwstart, (unsigned long int)oldwsize * sizeof(signed int) /*4ul*/ , (unsigned long int)newwsize * sizeof(signed int) /*4ul*/ );
        newwstart = (signed int *)return_value_lglrsz$3;
      }
      while((_Bool)0);

    __CPROVER_DUMP_L7:
      ;
      res = newwstart - oldwstart;
      if(!(res == 0l))
      {

      __CPROVER_DUMP_L8:
        ;
        lgl->wchs->stk.start = newwstart;
        lglenlwchs$$1$$start = lgl->wchs->stk.start;
      }

      lgl->wchs->stk.end = lglenlwchs$$1$$start + (signed long int)newwsize;
    }

    lgl->wchs->stk.top = lglenlwchs$$1$$start + (signed long int)newwcount;
    lgl->wchs->stk.top[(signed long int)-1] = 0x7fffffff;
    newoffset = oldwcount - 1;
  }

__CPROVER_DUMP_L2:
  ;

__CPROVER_DUMP_L11:
  ;
  j = newoffset;
  i = oldoffset;
  signed int tmp_post$4;
  for( ; !(i >= oldhcount + oldoffset); i = i + 1)
  {
    tmp_post$4 = j;
    j = j + 1;
    lglenlwchs$$1$$start[(signed long int)tmp_post$4] = lglenlwchs$$1$$start[(signed long int)i];
    lglenlwchs$$1$$start[(signed long int)i] = 0;
  }
  signed int tmp_post$5;
  for( ; !(j >= newhcount + newoffset); lglenlwchs$$1$$start[(signed long int)tmp_post$5] = 0)
  {
    tmp_post$5 = j;
    j = j + 1;
  }
  hts->offset = newoffset;
  if(oldhcount >= 1)
    lglfreewch(lgl, oldoffset, oldhcount);

  return res;
}

// lglenlwtk
// file lglib.c line 15000
static void lglenlwtk(struct LGL *lgl, struct Wtk *wtk)
{
  signed int oldsize;
  oldsize=lglsizewtk(wtk);
  signed int newsize = oldsize != 0 ? 2 * oldsize : 1;
  signed int count;
  count=lglcntwtk(wtk);
  do
  {
    void *return_value_lglrsz$1;
    return_value_lglrsz$1=lglrsz(lgl, (void *)wtk->start, (unsigned long int)oldsize * sizeof(struct Work) /*8ul*/ , (unsigned long int)newsize * sizeof(struct Work) /*8ul*/ );
    wtk->start = (struct Work *)return_value_lglrsz$1;
  }
  while((_Bool)0);
  wtk->top = wtk->start + (signed long int)count;
  wtk->end = wtk->start + (signed long int)newsize;
}

// lglepos
// file lglib.c line 3186
static signed int * lglepos(struct LGL *lgl, signed int lit)
{
  struct EVar *ev;
  signed int *res;
  ev=lglevar(lgl, lit);
  res = &ev->pos;
  return res;
}

// lglepush
// file lglib.c line 8062
static void lglepush(struct LGL *lgl, signed int ilit)
{
  signed int elit;
  signed int tmp_if_expr$2;
  signed int return_value_lglexport$1;
  if(!(ilit == 0))
  {
    return_value_lglexport$1=lglexport(lgl, ilit);
    tmp_if_expr$2 = return_value_lglexport$1;
  }

  else
    tmp_if_expr$2 = 0;
  elit = tmp_if_expr$2;
  lglpushstk(lgl, &lgl->extend, elit);

__CPROVER_DUMP_L3:
  ;
}

// lglepusheliminated
// file lglib.c line 10141
static void lglepusheliminated(struct LGL *lgl, signed int idx)
{
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  const signed int *l;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  struct HTS *hts;
  signed int return_value_lglocc$1;
  return_value_lglocc$1=lglocc(lgl, idx);
  signed int return_value_lglocc$2;
  return_value_lglocc$2=lglocc(lgl, -idx);
  lit = return_value_lglocc$1 < return_value_lglocc$2 ? idx : -idx;

__CPROVER_DUMP_L1:
  ;
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(!(tag == LRGCS))
    {
      red = blit & REDCS;
      if(red == 0)
      {
        lglepush(lgl, 0);
        lglepush(lgl, lit);
        if(tag == BINCS || tag == TRNCS)
        {
          lglepush(lgl, blit >> RMSHFT);
          if(tag == TRNCS)
            lglepush(lgl, *p);

        }

        else
        {
          c=lglidx2lits(lgl, OCCS, 0, blit >> RMSHFT);
          l = c;
          do
          {
            other = *l;
            if(other == 0)
              break;

            if(!(other == lit))
              lglepush(lgl, other);

            l = l + 1l;
          }
          while((_Bool)1);
        }
      }

    }

  }
  lglepush(lgl, 0);
  lglepush(lgl, -lit);
  lgleliminated(lgl, idx);
}

// lglerepr
// file lglib.c line 2467
static signed int lglerepr(struct LGL *lgl, signed int elit)
{
  signed int res;
  signed int lglerepr$$1$$next;
  signed int tmp;
  struct Ext *ext;
  res = elit;
  do
  {
    ext=lglelit2ext(lgl, res);
    if(ext->equiv == 0u)
      break;

    lglerepr$$1$$next = ext->repr;
    if(!(res >= 0))
      lglerepr$$1$$next = -lglerepr$$1$$next;

    res = lglerepr$$1$$next;
  }
  while((_Bool)1);
  tmp = elit;
  do
  {
    ext=lglelit2ext(lgl, tmp);
    if(ext->equiv == 0u)
      break;

    lglerepr$$1$$next = ext->repr;
    ext->repr = tmp < 0 ? -res : res;
    if(!(tmp >= 0))
      lglerepr$$1$$next = -lglerepr$$1$$next;

    tmp = lglerepr$$1$$next;
  }
  while((_Bool)1);
  return res;
}

// lglesched
// file lglib.c line 3294
static void lglesched(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  signed int *p;
  struct Stk *s;
  if(lgl->cgrclosing == 0)
  {
    signed int return_value_lglifrozen$1;
    return_value_lglifrozen$1=lglifrozen(lgl, lit);
    if(return_value_lglifrozen$1 == 0)
    {
      signed int return_value_lglisfree$2;
      return_value_lglisfree$2=lglisfree(lgl, lit);
      if(!(return_value_lglisfree$2 == 0))
      {
        if(!(lgl->donotsched == 0))
        {
          av=lglavar(lgl, lit);
          if(!(lgl->eliminating == 0))
          {
            if(!(av->donotelm == 0u))
              goto __CPROVER_DUMP_L9;

          }

          if(!(lgl->blocking == 0))
          {
            if(!(av->donotblk == 0u))
              goto __CPROVER_DUMP_L9;

          }

          if(lgl->cceing == 0)
            goto __CPROVER_DUMP_L6;

          if(av->donotcce == 0u)
            goto __CPROVER_DUMP_L6;

        }

        else
        {

        __CPROVER_DUMP_L6:
          ;
          p=lglepos(lgl, lit);
          s = &lgl->esched;
          if(!(*p >= 0))
          {
            unsigned long int return_value_lglcntstk$3;
            return_value_lglcntstk$3=lglcntstk(s);
            *p = (signed int)return_value_lglcntstk$3;
            lglpushstk(lgl, s, lit);
            lgleup(lgl, lit);
            lgledown(lgl, lit);
          }

        }
      }

    }

  }


__CPROVER_DUMP_L8:
  ;

__CPROVER_DUMP_L9:
  ;
}

// lgleschedrem
// file lglib.c line 11318
static signed int lgleschedrem(struct LGL *lgl, signed int this_time)
{
  signed int idx;
  signed int res = 0;
  signed int count;
  const char *str;
  struct AVar *av;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglifrozen$1;
    return_value_lglifrozen$1=lglifrozen(lgl, idx);
    if(return_value_lglifrozen$1 == 0)
    {
      signed int return_value_lglisfree$2;
      return_value_lglisfree$2=lglisfree(lgl, idx);
      if(!(return_value_lglisfree$2 == 0))
      {
        av=lglavar(lgl, idx);
        if(!(lgl->eliminating == 0))
        {
          if(av->donotelm == 0u)
            goto __CPROVER_DUMP_L3;

        }

        else
        {

        __CPROVER_DUMP_L3:
          ;
          if(!(lgl->blocking == 0))
          {
            if(av->donotblk == 0u)
              goto __CPROVER_DUMP_L4;

          }

          else
          {

          __CPROVER_DUMP_L4:
            ;
            if(!(lgl->cceing == 0))
            {
              if(av->donotcce == 0u)
                goto __CPROVER_DUMP_L5;

            }

            else
            {

            __CPROVER_DUMP_L5:
              ;
              res = res + 1;
            }
          }
        }
      }

    }

  }
  if(!(lgl->eliminating == 0))
  {
    count = lgl->stats->elm.count;
    str = "elim";
  }

  else
    if(!(lgl->blocking == 0))
    {
      count = lgl->stats->blk.count;
      str = "block";
    }

    else
    {
      count = lgl->stats->cce.count;
      str = "cce";
    }
  signed int return_value_lglrem$3;
  double return_value_lglpcnt$4;
  if(!(res == 0))
  {
    return_value_lglrem$3=lglrem(lgl);
    return_value_lglpcnt$4=lglpcnt((double)res, (double)return_value_lglrem$3);
    lglprt(lgl, 1, "[%s-%d] %d variables %.0f%% %s time", str, count, res, return_value_lglpcnt$4, this_time != 0 ? "will be scheduled this" : "remain to be tried next");
  }

  else
  {
    lglprt(lgl, 1, "[%s-%d] no untried remaining variables left", str, count);
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      av=lglavar(lgl, idx);
      if(!(lgl->eliminating == 0))
        av->donotelm = (unsigned int)0;

      if(!(lgl->blocking == 0))
        av->donotblk = (unsigned int)0;

      if(!(lgl->cceing == 0))
        av->donotcce = (unsigned int)0;

    }
  }
  return res;
}

// lglesetphase
// file lglib.c line 3891
static void lglesetphase(struct LGL *lgl, signed int elit, signed int phase)
{
  signed int ilit;
  ilit=lglimport(lgl, elit);
  signed int return_value_abs$1;
  return_value_abs$1=abs(ilit);
  if(return_value_abs$1 >= 2)
  {

  __CPROVER_DUMP_L1:
    ;
    lglisetphase(lgl, ilit, phase);
  }

  else

    __CPROVER_DUMP_L2:
      ;
}

// lgletrav
// file lglib.c line 18731
void lgletrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int, signed int))
{
  signed int elit;
  signed int erepr;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lgletrav");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  signed int return_value_lglbcp$1;
  if(lgl->mt == 0)
  {
    return_value_lglbcp$1=lglbcp(lgl);
    if(return_value_lglbcp$1 == 0)
      lgl->mt = 1;

  }

  if(lgl->mt == 0)
    lglgc(lgl);

  if(lgl->mt == 0)
  {
    if(lgl->level >= 1)
      lglbacktrack(lgl, 0);

    elit = 1;
    for( ; lgl->maxext >= elit; elit = elit + 1)
    {
      signed int return_value_lglefixed$2;
      return_value_lglefixed$2=lglefixed(lgl, elit);
      if(return_value_lglefixed$2 == 0)
      {
        erepr=lglerepr(lgl, elit);
        if(!(erepr == elit))
          trav(state, elit, erepr);

      }

    }
  }

}

// lgleunassignall
// file lglib.c line 3708
static void lgleunassignall(struct LGL *lgl)
{
  signed int eidx = 1;
  struct Ext *return_value_lglelit2ext$1;
  for( ; lgl->maxext >= eidx; eidx = eidx + 1)
  {
    return_value_lglelit2ext$1=lglelit2ext(lgl, eidx);
    return_value_lglelit2ext$1->val = 0;
  }
}

// lgleup
// file lglib.c line 3220
static void lgleup(struct LGL *lgl, signed int lit)
{
  signed int child = lit;
  signed int parent;
  signed int cpos;
  signed int ppos;
  signed int *p;
  signed int *cposptr;
  signed int *pposptr;
  struct Stk *s = &lgl->esched;
  p = s->start;
  cposptr=lglepos(lgl, child);
  cpos = *cposptr;
  while(cpos >= 1)
  {
    ppos = (cpos - 1) / 2;
    parent = p[(signed long int)ppos];
    signed int return_value_lglecmp$1;
    return_value_lglecmp$1=lglecmp(lgl, parent, lit);
    if(return_value_lglecmp$1 >= 0)
      break;

    pposptr=lglepos(lgl, parent);
    p[(signed long int)cpos] = parent;
    *pposptr = cpos;

  __CPROVER_DUMP_L2:
    ;
    cpos = ppos;
  }
  if(!(*cposptr == cpos))
  {
    *cposptr = cpos;
    p[(signed long int)cpos] = lit;
  }


__CPROVER_DUMP_L5:
  ;
}

// lglevar
// file lglib.c line 3180
static struct EVar * lglevar(struct LGL *lgl, signed int lit)
{
  signed int idx;
  idx=abs(lit);
  return lgl->evars + (signed long int)idx;
}

// lglevel
// file lglib.c line 2340
static signed int lglevel(struct LGL *lgl, signed int lit)
{
  struct TD *return_value_lgltd$1;
  return_value_lgltd$1=lgltd(lgl, lit);
  return (signed int)return_value_lgltd$1->level;
}

// lglevelused
// file lglib.c line 1579
static signed int lglevelused(struct LGL *lgl, signed int level)
{
  struct Ctk *ctk = &lgl->control;
  struct Ctr *ctr = ctk->start + (signed long int)level;
  return (signed int)ctr->used;
}

// lglexp
// file lglib.c line 1047
static signed int lglexp(signed long int a)
{
  signed int res = (signed int)(a >> 32);
  res = res - 0x10000000;
  return res;
}

// lglexport
// file lglib.c line 2573
static signed int lglexport(struct LGL *lgl, signed int ilit)
{
  signed int return_value_abs$1;
  return_value_abs$1=abs(ilit);
  signed int return_value_lglsgn$2;
  return_value_lglsgn$2=lglsgn(ilit);
  return lgl->i2e[(signed long int)return_value_abs$1] * return_value_lglsgn$2;
}

// lglextend
// file lglib.c line 17383
static void lglextend(struct LGL *lgl)
{
  signed int *p;
  signed int lit;
  signed int eidx;
  signed int ilit;
  signed int lglextend$$1$$next;
  signed int satisfied;
  signed int val;
  signed int *lglextend$$1$$start;
  signed int erepr;
  signed int equiv;
  struct Ext *ext;
  struct Ext *extrepr;
  lgleunassignall(lgl);
  equiv = 0;
  for( ; !(equiv >= 2); equiv = equiv + 1)
  {
    if(!(equiv == 0))

      __CPROVER_DUMP_L2:
        ;

    else

      __CPROVER_DUMP_L3:
        ;
    eidx = 1;
    for( ; lgl->maxext >= eidx; eidx = eidx + 1)
    {
      ext=lglelit2ext(lgl, eidx);
      if(!(ext->imported == 0u))
      {
        if(equiv == (signed int)ext->equiv)
        {
          if(!(ext->equiv == 0u))
          {
            erepr=lglerepr(lgl, eidx);

          __CPROVER_DUMP_L6:
            ;
            extrepr=lglelit2ext(lgl, erepr);
            val = (signed int)extrepr->val;
            if(val == 0)
            {
              ilit = extrepr->repr;
              if(!(ilit == 0))
              {

              __CPROVER_DUMP_L7:
                ;
                val=lglcval(lgl, ilit);
              }

              else

                __CPROVER_DUMP_L8:
                  ;
            }

            if(!(erepr >= 0))
              val = -val;

          }

          else
          {
            ilit = ext->repr;
            if(!(ilit == 0))
            {

            __CPROVER_DUMP_L12:
              ;
              val=lglcval(lgl, ilit);
            }

            else
            {

            __CPROVER_DUMP_L13:
              ;
              val = 0;
            }
          }
          lit = val > 0 ? eidx : -eidx;
          lgleassign(lgl, lit);
        }

      }

    }
  }
  lglextend$$1$$start = lgl->extend.start;
  p = lgl->extend.top;
  while(!(lglextend$$1$$start >= p))
  {
    satisfied = 0;
    lglextend$$1$$next = 0;
    do
    {
      lit = lglextend$$1$$next;
      p = p - 1l;
      lglextend$$1$$next = *p;
      if(!(lit == 0) && satisfied == 0)
      {
        val=lglederef(lgl, lit);
        if(val >= 1)
        {

        __CPROVER_DUMP_L20:
          ;
          satisfied = 1;
        }

      }

    }
    while(!(lglextend$$1$$next == 0));
    if(satisfied == 0)
      lgleassign(lgl, lit);

  }
  lglcomputechanged(lgl);

__CPROVER_DUMP_L24:
  ;
  do
    lgl->state = (enum State)EXTENDED;
  while((_Bool)0);
}

// lglf2rce
// file lglib.c line 2713
static void lglf2rce(struct LGL *lgl, signed int lit, signed int other, signed int red)
{
  lglassign(lgl, lit, other << RMSHFT | BINCS | red, 0);
}

// lglf3rce
// file lglib.c line 2720
static void lglf3rce(struct LGL *lgl, signed int lit, signed int other, signed int other2, signed int red)
{
  lglassign(lgl, lit, other << RMSHFT | TRNCS | red, other2);
}

// lglfadd
// file lglib.c line 3812
static void lglfadd(struct LGL *lgl, signed int elit)
{
  signed int eidx;
  signed int size;
  const signed int *p;
  signed long int sum;
  struct Ext *ext;
  signed int return_value_abs$2;
  if(!(elit == 0))
  {
    eidx=abs(elit);
    if(!(lgl->stats->features.vars >= eidx))
      lgl->stats->features.vars = eidx;

    lgl->stats->features.lits.total = lgl->stats->features.lits.total + 1;
    if(elit >= 1)
      lgl->stats->features.lits.pos = lgl->stats->features.lits.pos + 1;

    if(!(elit >= 0))
      lgl->stats->features.lits.neg = lgl->stats->features.lits.neg + 1;

    lglpushstk(lgl, &lgl->eclause, elit);
  }

  else
  {
    unsigned long int return_value_lglcntstk$1;
    return_value_lglcntstk$1=lglcntstk(&lgl->eclause);
    size = (signed int)return_value_lglcntstk$1;
    lgl->stats->features.clauses.total = lgl->stats->features.clauses.total + 1;
    if(size >= 1)
    {
      if(size == 1)
        lgl->stats->features.clauses.unit = lgl->stats->features.clauses.unit + 1;

      if(size == 2)
        lgl->stats->features.clauses.bin = lgl->stats->features.clauses.bin + 1;

      if(size == 3)
        lgl->stats->features.clauses.trn = lgl->stats->features.clauses.trn + 1;

      if(size >= 4)
        lgl->stats->features.clauses.lrg = lgl->stats->features.clauses.lrg + 1;

      sum = (signed long int)0;
      p = lgl->eclause.start;
      for( ; !(p >= lgl->eclause.top); p = p + 1l)
      {
        return_value_abs$2=abs(*p);
        sum = sum + (signed long int)return_value_abs$2;
      }
      sum = sum * (signed long int)10;
      sum = sum / (signed long int)size;
      sum = sum + (signed long int)5;
      sum = sum / (signed long int)10;
      p = lgl->eclause.start;
      for( ; !(p >= lgl->eclause.top); p = p + 1l)
      {
        ext=lglelit2ext(lgl, *p);
        ext->cog.sum = ext->cog.sum + sum;
        ext->cog.count = ext->cog.count + 1;
      }
      lglclnstk(&lgl->eclause);
    }

  }
}

// lglfailed
// file lglib.h line 195
signed int lglfailed(struct LGL *lgl, signed int elit)
{
  unsigned int bit;
  struct Ext *ext;
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfailed");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "failed %d", elit);
    break;
  }
  lgl->stats->calls.failed = lgl->stats->calls.failed + 1l;
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfailed");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not check zero failed literal");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }

__CPROVER_DUMP_L8:
  ;
  do
  {
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfailed");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

    while((384 & (signed int)lgl->state) == 0)
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfailed");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "!(%s)", (const void *)"UNSATISFIED | FAILED");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
  }
  while((_Bool)0);
  do
  {
    signed int return_value_abs$1;
    return_value_abs$1=abs(elit);
    if(lgl->maxext >= return_value_abs$1)
      break;

    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfailed");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not check unimported failed literal");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
  }
  while((_Bool)0);
  ext=lglelit2ext(lgl, elit);
  bit = 1u << (signed int)(elit < 0);
  while((bit & (unsigned int)ext->assumed) == 0u)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfailed");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not check unassumed failed literal");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  if((FAILED & (signed int)lgl->state) == 0)
  {
    lglstart(lgl, &lgl->times->all);
    lglanafailed(lgl);
    lglstop(lgl);
  }

  res = (signed int)(((unsigned int)ext->failed & bit) != (unsigned int)0);

__CPROVER_DUMP_L21:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglfailed(lgl->clone, elit);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfailed");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d", (const void *)"lglfailed", elit, CLONERES, (const void *)"lglfailed", elit, res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglfailedass
// file lglib.c line 14442
static signed int lglfailedass(struct LGL *lgl)
{
  _Bool tmp_if_expr$1;
  if(lgl->level == lgl->alevel)
    tmp_if_expr$1 = lgl->failed != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return (signed int)tmp_if_expr$1;
}

// lglfalsefun
// file lglib.c line 10513
static void lglfalsefun(unsigned long int *res)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    res[(signed long int)i] = (unsigned long int)0ll;
}

// lglfirstopt
// file lglib.c line 2142
void * lglfirstopt(struct LGL *lgl)
{
  return (void *)(&lgl->opts->beforefirst + (signed long int)1);
}

// lglfitlir
// file lglib.c line 5072
static void lglfitlir(struct LGL *lgl, struct Stk *lir)
{
  lglfitstk(lgl, lir);
}

// lglfitstk
// file lglib.c line 1427
static void lglfitstk(struct LGL *lgl, struct Stk *s)
{
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(s);
  lglshrstk(lgl, s, (signed int)return_value_lglcntstk$1);
}

// lglfixate
// file lglib.c line 3995
void lglfixate(struct LGL *lgl)
{
  const signed int *p;
  struct Stk eassume;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfixate");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "fixate");
    break;
  }
  if(lgl->mt == 0)
  {
    do
      memset((void *)&eassume, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    p = lgl->eassume.start;
    for( ; !(p >= lgl->eassume.top); p = p + 1l)
      lglpushstk(lgl, &eassume, *p);
    p = eassume.start;
    for( ; !(p >= eassume.top); p = p + 1l)
    {
      lgleadd(lgl, *p);
      lgleadd(lgl, 0);
    }
    lglrelstk(lgl, &eassume);
    lgluse(lgl);
    if(!(lgl->clone == ((struct LGL *)NULL)))
      lglfixate(lgl->clone);

  }

}

// lglfixed
// file lglib.c line 17969
signed int lglfixed(struct LGL *lgl, signed int elit)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfixed");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "fixed %d", elit);
    break;
  }
  lgl->stats->calls.fixed = lgl->stats->calls.fixed + 1l;
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfixed");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not deref zero literal");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  res=lglefixed(lgl, elit);

__CPROVER_DUMP_L9:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglfixed(lgl->clone, elit);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfixed");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d", (const void *)"lglfixed", elit, CLONERES, (const void *)"lglfixed", elit, res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglfixlrgwchs
// file lglib.c line 15880
static void lglfixlrgwchs(struct LGL *lgl)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int lidx;
  signed int fixed;
  const signed int *p;
  const signed int *eow;
  const signed int *c;
  signed int *q;
  signed int *w;
  struct HTS *hts;
  fixed = 0;
  idx = 2;
  signed int *tmp_post$1;
  signed int *tmp_post$2;
  signed int *tmp_post$3;
  signed int *tmp_post$4;
  signed int *tmp_post$5;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      hts=lglhts(lgl, lit);
      w=lglhts2wchs(lgl, hts);
      eow = w + (signed long int)hts->count;
      q = w;
      p = w;
      for( ; !(p >= eow); p = p + 1l)
      {
        blit = *p;
        tag = blit & MASKCS;
        if(tag == BINCS)
        {
          tmp_post$1 = q;
          q = q + 1l;
          *tmp_post$1 = blit;
        }

        else
        {
          p = p + 1l;
          lidx = *p;
          if(tag == TRNCS)
          {
            tmp_post$2 = q;
            q = q + 1l;
            *tmp_post$2 = blit;
            tmp_post$3 = q;
            q = q + 1l;
            *tmp_post$3 = lidx;
          }

          else
          {
            red = blit & REDCS;
            c=lglidx2lits(lgl, LRGCS, red, lidx);
            if(*c >= 134217727)
              fixed = fixed + 1;

            else
            {
              tmp_post$4 = q;
              q = q + 1l;
              *tmp_post$4 = blit;
              tmp_post$5 = q;
              q = q + 1l;
              *tmp_post$5 = lidx;
            }
          }
        }
      }
      lglshrinkhts(lgl, hts, (signed int)((signed long int)hts->count - (p - q)));
    }
  }
  if(!(fixed == 0))

    __CPROVER_DUMP_L11:
      ;

}

// lglfjadd
// file lglib.c line 18891
static void lglfjadd(struct LGL *lgl, signed int elit)
{
  signed int ilit;
  signed int tmp_if_expr$2;
  signed int return_value_lglimport$1;
  if(!(elit == 0))
  {
    return_value_lglimport$1=lglimport(lgl, elit);
    tmp_if_expr$2 = return_value_lglimport$1;
  }

  else
    tmp_if_expr$2 = 0;
  ilit = tmp_if_expr$2;
  lglpushstk(lgl, &lgl->clause, ilit);
  if(ilit == 0)
  {
    signed int return_value_lglsimpcls$3;
    return_value_lglsimpcls$3=lglsimpcls(lgl);
    if(return_value_lglsimpcls$3 == 0)
      lgladdcls(lgl, REDCS, 0, 1);

    lglclnstk(&lgl->clause);
  }

}

// lglfjradd
// file lglib.c line 18899
static void lglfjradd(struct LGL *lgl, signed int elit, signed int glue)
{
  signed int ilit;
  signed int tmp_if_expr$2;
  signed int return_value_lglimport$1;
  if(!(elit == 0))
  {
    return_value_lglimport$1=lglimport(lgl, elit);
    tmp_if_expr$2 = return_value_lglimport$1;
  }

  else
    tmp_if_expr$2 = 0;
  ilit = tmp_if_expr$2;
  lglpushstk(lgl, &lgl->clause, ilit);
  if(ilit == 0)
  {
    signed int return_value_lglsimpcls$3;
    return_value_lglsimpcls$3=lglsimpcls(lgl);
    if(return_value_lglsimpcls$3 == 0)
      lgladdcls(lgl, REDCS, glue, 1);

    lglclnstk(&lgl->clause);
  }

}

// lglfloorld
// file lglib.c line 971
static signed int lglfloorld(signed int n)
{
  if(!(n >= 256))
    return (signed int)lglfloorldtab[(signed long int)n];

  else
    if(!(n >= 65536))
      return 8 + (signed int)lglfloorldtab[(signed long int)(n >> 8)];

    else
      if(!(n >= 16777216))
        return 16 + (signed int)lglfloorldtab[(signed long int)(n >> 16)];

      else
        return 24 + (signed int)lglfloorldtab[(signed long int)(n >> 24)];
}

// lglflrce
// file lglib.c line 2729
static void lglflrce(struct LGL *lgl, signed int lit, signed int red, signed int lidx)
{
  lglassign(lgl, lit, red | LRGCS, lidx);
}

// lglflshrep
// file lglib.c line 5066
static void lglflshrep(struct LGL *lgl)
{
  if(!(lgl->stats->reported == 0))
  {
    if(!(lgl->stats->reported % 23 == 0))
      lglrephead(lgl);

    else
      lglprt(lgl, 1, "");
  }

}

// lglflt
// file lglib.c line 1061
static signed long int lglflt(signed int e, unsigned long int m)
{
  signed long int res;
  if(m == 0ul)
    return 0x0000000000000000ll;

  else
  {
    if(!(m >= 0x0000000100000000ull))
      while((0x0000000100000000ull & m) == 0ul)
      {
        m = m << 1;
        if(e >= -2147483647)
          e = e - 1;

        else
          break;
      }

    else
      while(m >= 8589934592ull)
      {
        m = m >> 1;
        if(e >= -2147483647)
          e = e + 1;

        else
          break;
      }
    if(!(e >= -268435456))
      return 0x0000000000000000ll;

    else
      if(e >= 1879048192)
        return 0x7fffffffffffffffll;

      else
      {
        e = e + 0x10000000;
        res = (signed long int)(m & ~0x0000000100000000ull);
        res = res | (signed long int)e << 32;
        return res;
      }
  }
}

// lglflt2str
// file lglib.c line 1094
static const char * lglflt2str(struct LGL *lgl, signed long int a)
{
  double d;
  double e;
  if(a == 0x0000000000000000ll)
    return "0";

  else
    if(a == 0x7fffffffffffffffll)
      return "inf";

    else
    {
      unsigned long int return_value_lglmnt$1;
      return_value_lglmnt$1=lglmnt(a);
      d = (double)return_value_lglmnt$1;
      d = d / (double)4294967296ll;
      signed int return_value_lglexp$2;
      return_value_lglexp$2=lglexp(a);
      e = (double)return_value_lglexp$2;
      e = e + (double)32;
      lgl->fltstr->current = lgl->fltstr->current + 1;
      if(lgl->fltstr->current == 6)
        lgl->fltstr->current = 0;

      sprintf(lgl->fltstr->str[(signed long int)lgl->fltstr->current], "%.6fd%+03.0f", d, e);
      return lgl->fltstr->str[(signed long int)lgl->fltstr->current];
    }
}

// lglflush
// file lglib.c line 9991
static signed int lglflush(struct LGL *lgl)
{
  signed int lit;
  signed int count;
  unsigned long int return_value_lglcntstk$4;
  signed int tmp_post$5;
  if(!(lgl->mt == 0))
    return 0;

  else
  {
    lglchkirrstats(lgl);
    unsigned long int return_value_lglcntstk$1;
    return_value_lglcntstk$1=lglcntstk(&lgl->trail);
    if((unsigned long int)lgl->flushed == return_value_lglcntstk$1)
      return 1;

    else
    {
      signed int return_value_lglbcp$2;
      return_value_lglbcp$2=lglbcp(lgl);
      if(return_value_lglbcp$2 == 0)
      {
        lgl->mt = 1;
        return 0;
      }

      else
      {
        signed int return_value_lglsyncunits$3;
        return_value_lglsyncunits$3=lglsyncunits(lgl);
        if(return_value_lglsyncunits$3 == 0)
          return 0;

        else
        {
          count = 0;
          do
          {
            return_value_lglcntstk$4=lglcntstk(&lgl->trail);
            if((unsigned long int)lgl->flushed >= return_value_lglcntstk$4)
              break;

            tmp_post$5 = lgl->flushed;
            lgl->flushed = lgl->flushed + 1;
            lit=lglpeek(&lgl->trail, tmp_post$5);
            lglflushclauses(lgl, lit);
            lglflushlits(lgl, -lit);
            count = count + 1;
          }
          while((_Bool)1);

        __CPROVER_DUMP_L6:
          ;
          return 1;
        }
      }
    }
  }
}

// lglflushcache
// file lglib.h line 198
void lglflushcache(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglflushcache");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "flush");
    break;
  }
  if(lgl->mt == 0)
  {
    lgl->limits->reduce.inner = lgl->opts->redlinit.val;
    lglboundredl(lgl);
    lglreduce(lgl, 1);
    lgl->limits->reduce.inner = lgl->opts->redlinit.val;
    lglboundredl(lgl);
    lgl->limits->reduce.outer = 2 * lgl->limits->reduce.inner;
    lglprt(lgl, 1, "[flush-cache] new limit %d", lgl->limits->reduce.inner);
    if(!(lgl->clone == ((struct LGL *)NULL)))
      lglflushcache(lgl->clone);

  }

}

// lglflushclauses
// file lglib.c line 9711
static signed int lglflushclauses(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int count;
  signed int glue;
  signed int res;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  signed int lidx;
  signed int glidx;
  signed int slidx;
  signed int *c;
  signed int *q;
  struct HTS *hts;
  lglchkirrstats(lgl);
  hts=lglhts(lgl, lit);
  if(hts->count == 0)
    return 0;

  else
  {
    res = 0;

  __CPROVER_DUMP_L2:
    ;
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    count = 0;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      if(!(lgl->blocking == 0))
        lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;

      if(!(lgl->eliminating == 0))
        lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;

      blit = *p;
      tag = blit & MASKCS;
      red = blit & REDCS;
      other = blit >> RMSHFT;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      if(tag == BINCS)
      {
        lglrmbwch(lgl, other, lit, red);

      __CPROVER_DUMP_L7:
        ;
        lgldeclscnt(lgl, 2, red, 0);
        if(red == 0)
        {
          lgldecocc(lgl, lit);
          lgldecocc(lgl, other);
          res = res + 1;
        }

        count = count + 1;
      }

      else
        if(tag == TRNCS)
        {
          other2 = *p;
          lglrmtwch(lgl, other2, lit, other, red);
          lglrmtwch(lgl, other, lit, other2, red);

        __CPROVER_DUMP_L10:
          ;
          lgldeclscnt(lgl, 3, red, 0);
          if(red == 0)
          {
            lgldecocc(lgl, lit);
            lgldecocc(lgl, other);
            lgldecocc(lgl, other2);
            res = res + 1;
          }

          count = count + 1;
        }

        else
        {
          if(tag == LRGCS)
          {
            lidx = *p;
            c=lglidx2lits(lgl, LRGCS, red, lidx);
            glue = red != 0 ? lidx & (1 << 4) - 1 : 0;
          }

          else
          {
            lidx = blit >> RMSHFT;
            c=lglidx2lits(lgl, OCCS, red, lidx);
            glue = 0;
          }
          other = c[(signed long int)0];
          if(!(other >= 134217727))
          {

          __CPROVER_DUMP_L15:
            ;
            if(tag == LRGCS)
            {
              if(other == lit)
                other = c[(signed long int)1];

              lglrmlwch(lgl, other, red, lidx);
            }

            else
            {
              glidx = lidx;
              if(!(red == 0))
                glidx = glidx << 4;

              if(!(c[1l] == lit))
                lglrmlwch(lgl, c[(signed long int)1], red, glidx);

              if(!(other == lit))
                lglrmlwch(lgl, other, red, glidx);

            }
            if(!(red == 0))
            {

            __CPROVER_DUMP_L21:
              ;
              c[(signed long int)-1] = 0x7fffffff;
            }

            else
              lgldecocc(lgl, lit);
            q = c;
            do
            {
              other = *q;
              if(other == 0)
                break;

              *q = 0x7fffffff;
              if(!(other == lit))
              {
                if(glue == 0 || red == 0)
                {
                  slidx = lidx;
                  if(tag == LRGCS && !(red == 0))
                    slidx = slidx >> 4;

                  lglrmlocc(lgl, other, red, slidx);
                  if(red == 0)
                    lgldecocc(lgl, other);

                }

              }

              q = q + 1l;
            }
            while((_Bool)1);
            *q = 0x7fffffff;
            lgldeclscnt(lgl, (signed int)(q - c), red, glue);
            if(red == 0)
              res = res + 1;

            count = count + 1;
          }

        }
    }
    lglshrinkhts(lgl, hts, 0);

  __CPROVER_DUMP_L31:
    ;
    lglchkirrstats(lgl);
    return res;
  }
}

// lglflushlits
// file lglib.c line 9813
static signed int lglflushlits(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int size;
  signed int satisfied;
  signed int d[3l];
  signed int glue;
  signed int *p;
  signed int *w;
  signed int *eow;
  signed int *c;
  signed int *l;
  signed int *k;
  signed int lidx;
  signed int slidx;
  signed int glidx;
  signed int count;
  signed int res;
  signed char val;
  signed char val2;
  signed long int delta;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  lglchkirrstats(lgl);
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  count = 0;
  res = count;
  p = w;
  signed int tmp_if_expr$2;
  _Bool tmp_if_expr$7;
  signed char return_value_lglval$6;
  signed int *tmp_post$8;
  signed int *tmp_post$9;
  signed int *tmp_post$10;
  for( ; !(p >= eow); p = p + 1l)
  {
    if(!(lgl->blocking == 0))
      lgl->stats->blk.steps = lgl->stats->blk.steps + 1l;

    if(!(lgl->eliminating == 0))
      lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;

    count = count + 1;
    blit = *p;
    tag = blit & MASKCS;
    red = blit & REDCS;
    if(tag == BINCS)
    {
      other = blit >> RMSHFT;
      lglrmbwch(lgl, other, lit, red);

    __CPROVER_DUMP_L5:
      ;
      lgldeclscnt(lgl, 2, red, 0);
      if(red == 0)
      {
        if(!(lgl->dense == 0))
        {
          lgldecocc(lgl, lit);
          lgldecocc(lgl, other);
        }

        res = res + 1;
      }

    }

    else
      if(tag == TRNCS)
      {
        other = blit >> RMSHFT;
        p = p + 1l;
        other2 = *p;
        lglrmtwch(lgl, other2, lit, other, red);
        lglrmtwch(lgl, other, lit, other2, red);

      __CPROVER_DUMP_L9:
        ;
        lgldeclscnt(lgl, 3, red, 0);
        if(red == 0)
        {
          if(!(lgl->dense == 0))
          {
            lgldecocc(lgl, lit);
            lgldecocc(lgl, other);
            lgldecocc(lgl, other2);
          }

          res = res + 1;
        }

        val=lglval(lgl, other);
        val2=lglval(lgl, other2);
        if(val == 0 && val2 == 0)
        {

        __CPROVER_DUMP_L12:
          ;
          delta=lglwchbin(lgl, other, other2, red);
          signed long int return_value_lglwchbin$1;
          return_value_lglwchbin$1=lglwchbin(lgl, other2, other, red);
          delta = delta + return_value_lglwchbin$1;
          if(!(delta == 0l))
            do
            {
              p = p + delta;
              w = w + delta;
              eow = eow + delta;
            }
            while((_Bool)0);

          if(!(red == 0))
            lgl->stats->red.bin = lgl->stats->red.bin + 1;

          else
          {
            lglincirr(lgl, 2);
            if(!(lgl->dense == 0))
            {
              lglincocc(lgl, other);
              lglincocc(lgl, other2);
            }

          }
        }

      }

      else
      {
        if(tag == LRGCS)
        {
          p = p + 1l;
          tmp_if_expr$2 = *p;
        }

        else
          tmp_if_expr$2 = blit >> RMSHFT;
        lidx = tmp_if_expr$2;
        c=lglidx2lits(lgl, tag, red, lidx);
        if(!(*c >= 134217727))
        {
          satisfied = 0;
          size = satisfied;
          l = c;
          do
          {
            other = *l;
            if(other == 0)
              break;

            if(!(other == lit))
            {
              val=lglval(lgl, other);
              if((signed int)val >= 0)
              {
                if((signed int)val >= 1)
                {
                  satisfied = 1;
                  break;
                }

                if(!(size >= 3))
                  d[(signed long int)size] = other;

                size = size + 1;
              }

            }

            l = l + 1l;
          }
          while((_Bool)1);
          if(satisfied == 0 && size == 2)
          {

          __CPROVER_DUMP_L26:
            ;
            delta=lglwchbin(lgl, d[(signed long int)0], d[(signed long int)1], red);
            signed long int return_value_lglwchbin$3;
            return_value_lglwchbin$3=lglwchbin(lgl, d[(signed long int)1], d[(signed long int)0], red);
            delta = delta + return_value_lglwchbin$3;
            if(!(delta == 0l))
              do
              {
                p = p + delta;
                w = w + delta;
                eow = eow + delta;
              }
              while((_Bool)0);

            if(!(red == 0))
              lgl->stats->red.bin = lgl->stats->red.bin + 1;

            else
            {
              lglincirr(lgl, 2);
              if(!(lgl->dense == 0))
              {
                lglincocc(lgl, d[(signed long int)0]);
                lglincocc(lgl, d[(signed long int)1]);
              }

            }
          }

          if(satisfied == 0 && size == 3)
          {

          __CPROVER_DUMP_L32:
            ;
            delta=lglwchtrn(lgl, d[(signed long int)0], d[(signed long int)1], d[(signed long int)2], red);
            signed long int return_value_lglwchtrn$4;
            return_value_lglwchtrn$4=lglwchtrn(lgl, d[(signed long int)1], d[(signed long int)0], d[(signed long int)2], red);
            delta = delta + return_value_lglwchtrn$4;
            signed long int return_value_lglwchtrn$5;
            return_value_lglwchtrn$5=lglwchtrn(lgl, d[(signed long int)2], d[(signed long int)0], d[(signed long int)1], red);
            delta = delta + return_value_lglwchtrn$5;
            if(!(delta == 0l))
              do
              {
                p = p + delta;
                w = w + delta;
                eow = eow + delta;
              }
              while((_Bool)0);

            if(!(red == 0))
              lgl->stats->red.trn = lgl->stats->red.trn + 1;

            else
            {
              lglincirr(lgl, 3);
              if(!(lgl->dense == 0))
              {
                lglincocc(lgl, d[(signed long int)0]);
                lglincocc(lgl, d[(signed long int)1]);
                lglincocc(lgl, d[(signed long int)2]);
              }

            }
          }

          if(!(lgl->dense == 0))
          {
            if(red == 0)
            {
              l = c;
              do
              {
                other = *l;
                if(other == 0)
                  break;

                if(!(satisfied == 0) || !(size >= 4))
                  tmp_if_expr$7 = (_Bool)1;

                else
                {
                  return_value_lglval$6=lglval(lgl, other);
                  tmp_if_expr$7 = (signed int)return_value_lglval$6 < 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$7)
                {
                  if(red == 0)
                    lgldecocc(lgl, other);

                  if(!(other == lit))
                  {
                    slidx = lidx;
                    if(tag == LRGCS && !(red == 0))
                      slidx = slidx >> 4;

                    lglrmlocc(lgl, other, red, slidx);
                  }

                }

                l = l + 1l;
              }
              while((_Bool)1);
            }

          }

          glidx = lidx;
          if(tag == OCCS && !(red == 0))
            glidx = glidx << 4;

          if(!(*c == lit))
            lglrmlwch(lgl, c[(signed long int)0], red, glidx);

          if(!(c[1l] == lit))
            lglrmlwch(lgl, c[(signed long int)1], red, glidx);

          if(!(satisfied == 0) || !(size >= 4))
          {
            if(!(red == 0))
            {

            __CPROVER_DUMP_L48:
              ;
              c[(signed long int)-1] = 0x7fffffff;
            }

            k = c;
            do
            {
              other = *k;
              if(other == 0)
                break;

              *k = 0x7fffffff;
              k = k + 1l;
            }
            while((_Bool)1);
            *k = 0x7fffffff;
            if(!(red == 0))
            {
              glue = tag == LRGCS ? lidx & (1 << 4) - 1 : 0;
              lgl->stats->lir[(signed long int)glue].clauses = lgl->stats->lir[(signed long int)glue].clauses - 1;
              lgl->stats->red.lrg = lgl->stats->red.lrg - 1;
            }

            else
              lgldecirr(lgl, (signed int)(k - c));
          }

          else
          {
            k = c;
            l = k;
            do
            {
              other = *l;
              if(other == 0)
                break;

              val=lglval(lgl, other);
              if((signed int)val >= 0)
              {
                tmp_post$8 = k;
                k = k + 1l;
                *tmp_post$8 = other;
              }

              l = l + 1l;
            }
            while((_Bool)1);
            if(red == 0 && !(k >= l))
              lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur - (signed int)(l - k);

            tmp_post$9 = k;
            k = k + 1l;
            *tmp_post$9 = 0;
            for( ; l >= k; *tmp_post$10 = 0x7fffffff)
            {
              tmp_post$10 = k;
              k = k + 1l;
            }
            delta=lglwchlrg(lgl, c[(signed long int)0], c[(signed long int)1], red, glidx);
            signed long int return_value_lglwchlrg$11;
            return_value_lglwchlrg$11=lglwchlrg(lgl, c[(signed long int)1], c[(signed long int)0], red, glidx);
            delta = delta + return_value_lglwchlrg$11;
            if(!(delta == 0l))
              do
              {
                p = p + delta;
                w = w + delta;
                eow = eow + delta;
              }
              while((_Bool)0);

          }
        }

      }
  }
  hts=lglhts(lgl, lit);
  lglshrinkhts(lgl, hts, 0);

__CPROVER_DUMP_L65:
  ;
  lglchkirrstats(lgl);
  return res;
}

// lglflushphases
// file lglib.c line 6830
static void lglflushphases(struct LGL *lgl)
{
  signed int idx;
  signed int flushed = 0;
  struct AVar *av;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree$1;
    return_value_lglisfree$1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree$1 == 0))
    {
      av=lglavar(lgl, idx);
      if(!(av->phase == 0))
      {
        av->phase = 0;
        flushed = flushed + 1;
      }

    }

  }
  lglprt(lgl, 1, "[flushphases] %d saved phases reset", flushed);
  lgl->allphaseset = (char)!(flushed != 0);
  lgl->flushphases = (char)0;
}

// lglflushqmerged
// file lglib.c line 5839
static void lglflushqmerged(struct LGL *lgl)
{
  struct Qln *p;
  struct Qln *up;
  signed int i;
  if(!(lgl->qscheduling == 0))
  {
    if(!(lgl->queue.merged == ((struct Qln *)NULL)))
    {
      lgl->stats->queue.gcs = lgl->stats->queue.gcs + 1l;

    __CPROVER_DUMP_L3:
      ;
      i = 2;
      for( ; !(i >= lgl->nvars); i = i + 1)
        lglqln(lgl, i);
      p = lgl->queue.merged;
      for( ; !(p == ((struct Qln *)NULL)); p = up)
      {
        up = p->up;
        lgl->stats->queue.col = lgl->stats->queue.col + 1l;
        lgl->queue.nmerged = lgl->queue.nmerged - 1;
        lgl->queue.nlines = lgl->queue.nlines - 1;
        do
        {
          lgldel(lgl, (void *)p, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
          p = ((struct Qln *)NULL);
        }
        while((_Bool)0);
      }
      lgl->queue.merged = ((struct Qln *)NULL);
    }

  }

}

// lglflushremovedoccs
// file lglib.c line 4392
static void lglflushremovedoccs(struct LGL *lgl, signed int lit)
{
  struct HTS *hts;
  hts=lglhts(lgl, lit);
  signed int *w;
  w=lglhts2wchs(lgl, hts);
  signed int *eow = w + (signed long int)hts->count;
  signed int blit;
  signed int tag;
  signed int red;
  signed int lidx;
  signed int *p;
  signed int *q;
  signed int *c;
  lglrminc(lgl, w, eow);
  q = w;
  p = q;
  signed int *tmp_post$1;
  signed int *tmp_post$2;
  signed int *tmp_post$3;
  signed int tmp_if_expr$4;
  signed int *tmp_post$5;
  signed int *tmp_post$6;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    red = blit & REDCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(tag == BINCS)
    {
      tmp_post$1 = q;
      q = q + 1l;
      *tmp_post$1 = blit;
    }

    else
      if(tag == TRNCS)
      {
        tmp_post$2 = q;
        q = q + 1l;
        *tmp_post$2 = blit;
        tmp_post$3 = q;
        q = q + 1l;
        *tmp_post$3 = *p;
      }

      else
      {
        if(red == 0)
        {
          if(tag == LRGCS)
            tmp_if_expr$4 = *p;

          else
            tmp_if_expr$4 = blit >> RMSHFT;
          lidx = tmp_if_expr$4;
          c=lglidx2lits(lgl, tag, red, lidx);
          if(*c == 0x7fffffff)
            goto __CPROVER_DUMP_L8;

        }

        tmp_post$5 = q;
        q = q + 1l;
        *tmp_post$5 = blit;
        if(tag == LRGCS)
        {
          tmp_post$6 = q;
          q = q + 1l;
          *tmp_post$6 = *p;
        }

      }

  __CPROVER_DUMP_L8:
    ;
  }
  lglshrinkhts(lgl, hts, (signed int)(q - w));
}

// lglflushtimers
// file lglib.h line 278
void lglflushtimers(struct LGL *lgl)
{
  double time;
  time=lglgetime(lgl);
  double delta;
  double entered;
  double *ptr;
  signed int nest = 0;
  for( ; !(nest >= lgl->timers->nest); nest = nest + 1)
  {
    entered = lgl->timers->phase[(signed long int)nest];
    lgl->timers->phase[(signed long int)nest] = time;
    delta = time - entered;
    if(delta < 0.000000)
      delta = (double)0;

    ptr = (signed long int)lgl->timers->idx[(signed long int)nest] + (double *)lgl->times;
    *ptr = *ptr + delta;
  }
}

// lglforce
// file lglib.c line 7455
static void lglforce(struct LGL *lgl, signed int *map)
{
  signed int idx;
  signed int lit;
  signed int sign;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int size;
  signed int C;
  signed int V;
  signed int o;
  signed int min;
  signed int max;
  signed int round = 1;
  signed int first = (signed int)!(lgl->stats->force.count != 0l);
  double cog;
  double span;
  double oldspan;
  double mincut;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  struct ForceData *fdat;
  struct HTS *hts;
  struct Stk order;
  signed int return_value_lglcmpfdat$9;
  signed int return_value_lglmtstk$10;
  signed int return_value_lglcmpfdat$12;
  signed int tmp_post$13;
  signed int tmp_post$14;
  signed int return_value_lglrem$15;
  signed int return_value_lglceilld$16;
  if(!(lgl->allowforce == 0))
  {
    if(!(lgl->opts->force.val == 0))
    {
      lglstart(lgl, &lgl->times->force);
      span = (double)0x7fffffff;
      do
      {

      RESTART:
        ;
        oldspan = span;
        lgl->stats->force.count = lgl->stats->force.count + 1l;
        do
        {
          void *return_value_lglnew$1;
          return_value_lglnew$1=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(struct ForceData) /*16ul*/ );
          fdat = (struct ForceData *)return_value_lglnew$1;
        }
        while((_Bool)0);
        do
          memset((void *)&order, 0, sizeof(struct Stk) /*24ul*/ );
        while((_Bool)0);
        V = 0;
        idx = 2;
        for( ; !(idx >= lgl->nvars); idx = idx + 1)
        {
          signed int return_value_lglisfree$2;
          return_value_lglisfree$2=lglisfree(lgl, idx);
          if(!(return_value_lglisfree$2 == 0))
          {
            (fdat + (signed long int)idx)->pos = map[(signed long int)idx];
            lglpushstk(lgl, &order, idx);
            V = V + 1;
          }

        }
        if(V >= 2)
        {
          C = 0;
          span = (double)0;
          idx = 2;
          for( ; !(idx >= lgl->nvars); idx = idx + 1)
          {
            sign = -1;
            for( ; !(sign >= 2); sign = sign + 2)
            {
              lit = sign * idx;
              hts=lglhts(lgl, lit);
              w=lglhts2wchs(lgl, hts);
              eow = w + (signed long int)hts->count;
              p = w;
              for( ; !(p >= eow); p = p + 1l)
              {
                blit = *p;
                tag = blit & MASKCS;
                if(tag == TRNCS || tag == LRGCS)
                  p = p + 1l;

                if(!(tag == LRGCS))
                {
                  red = blit & REDCS;
                  if(red == 0)
                  {
                    other=abs(blit >> RMSHFT);
                    if(other >= idx)
                    {
                      if(tag == BINCS)
                      {
                        cog = (double)((fdat + (signed long int)idx)->pos + (fdat + (signed long int)other)->pos);
                        cog = cog / (double)2;
                        lglincfdat(fdat, idx, cog);
                        lglincfdat(fdat, other, cog);
                        o = (fdat + (signed long int)idx)->pos;
                        min = o;
                        max = o;
                        o = (fdat + (signed long int)other)->pos;
                        min=lglmin(min, o);
                        max=lglmax(max, o);
                        span = span + (double)(max - min);
                        C = C + 1;
                      }

                      else
                        if(tag == TRNCS)
                        {
                          other2=abs(*p);
                          if(other2 >= idx)
                          {
                            cog = (double)((fdat + (signed long int)idx)->pos + (fdat + (signed long int)other)->pos + (fdat + (signed long int)other2)->pos);
                            cog = cog / (double)3;
                            lglincfdat(fdat, idx, cog);
                            lglincfdat(fdat, other, cog);
                            lglincfdat(fdat, other2, cog);
                            o = (fdat + (signed long int)idx)->pos;
                            min = o;
                            max = o;
                            o = (fdat + (signed long int)other)->pos;
                            min=lglmin(min, o);
                            max=lglmax(max, o);
                            o = (fdat + (signed long int)other2)->pos;
                            min=lglmin(min, o);
                            max=lglmax(max, o);
                            span = span + (double)(max - min);
                            C = C + 1;
                          }

                        }

                    }

                  }

                }

              }
            }
          }
          c = lgl->irr.start;
          for( ; !(c >= lgl->irr.top); c = p + (signed long int)1)
          {
            p = c;
            if(!(*p >= 134217727))
            {
              cog = (double)0;
              do
              {
                idx=abs(*p);
                if(idx == 0)
                  break;

                cog = cog + (double)(fdat + (signed long int)idx)->pos;
                p = p + 1l;
              }
              while((_Bool)1);
              size = (signed int)(p - c);
              cog = cog / (double)size;
              min = 0x7fffffff;
              max = -0x7fffffff - 1;
              p = c;
              do
              {
                idx=abs(*p);
                if(idx == 0)
                  break;

                o = (fdat + (signed long int)idx)->pos;
                min=lglmin(min, o);
                max=lglmax(max, o);
                lglincfdat(fdat, idx, cog);
                p = p + 1l;
              }
              while((_Bool)1);
              span = span + (double)(max - min);
              C = C + 1;
            }

          }
          idx = 2;
          for( ; !(idx >= lgl->nvars); idx = idx + 1)
          {
            signed int return_value_lglisfree$3;
            return_value_lglisfree$3=lglisfree(lgl, idx);
            if(!(return_value_lglisfree$3 == 0))
            {
              size = (fdat + (signed long int)idx)->count;
              if(!(size == 0))
                (fdat + (signed long int)idx)->sum = (fdat + (signed long int)idx)->sum / (double)size;

            }

          }
          mincut = span / (double)(V - 1);
          if(C >= 1)
            span = span / (double)C;

          else
            span = (double)0;
          if(lgl->stats->force.count >= 2l)
          {
            if((double)lgl->stats->force.mincut.min > mincut)
              lgl->stats->force.mincut.min = (signed int)mincut;

            if((double)lgl->stats->force.mincut.max < mincut)
              lgl->stats->force.mincut.max = (signed int)mincut;

          }

          else
          {
            lgl->stats->force.mincut.max = (signed int)mincut;
            lgl->stats->force.mincut.min = lgl->stats->force.mincut.max;
          }
          lglprt(lgl, 1, "[force-%lld] mincut %.1f, span %.1f, %d variables, %d clauses", (signed long long int)lgl->stats->force.count, mincut, span, V, C);
          do
          {
            signed int *AA = order.start;
            signed int NN;
            unsigned long int return_value_lglcntstk$4;
            return_value_lglcntstk$4=lglcntstk(&order);
            NN = (signed int)return_value_lglcntstk$4;
            do
            {
              signed int L = 0;
              signed int R = NN - 1;
              signed int M;
              signed int LL;
              signed int RR;
              signed int I;
              if(!(R + -L >= 11))
                break;

              do
              {
                M = (L + R) / 2;
                do
                {
                  signed int TMP = AA[(signed long int)M];
                  AA[(signed long int)M] = AA[(signed long int)(R - 1)];
                  AA[(signed long int)(R - 1)] = TMP;
                }
                while((_Bool)0);
                do
                {
                  signed int return_value_lglcmpfdat$5;
                  return_value_lglcmpfdat$5=lglcmpfdat(fdat, *(&AA[(signed long int)L]), *(&AA[(signed long int)(R - 1)]));
                  if(return_value_lglcmpfdat$5 >= 1)
                    do
                    {
                      signed int lglforce$$1$$8$$1$$1$$1$$2$$1$$TMP = AA[(signed long int)L];
                      AA[(signed long int)L] = AA[(signed long int)(R - 1)];
                      AA[(signed long int)(R - 1)] = lglforce$$1$$8$$1$$1$$1$$2$$1$$TMP;
                    }
                    while((_Bool)0);

                }
                while((_Bool)0);
                do
                {
                  signed int return_value_lglcmpfdat$6;
                  return_value_lglcmpfdat$6=lglcmpfdat(fdat, *(&AA[(signed long int)L]), *(&AA[(signed long int)R]));
                  if(return_value_lglcmpfdat$6 >= 1)
                    do
                    {
                      signed int lglforce$$1$$8$$1$$1$$1$$3$$1$$TMP = AA[(signed long int)L];
                      AA[(signed long int)L] = AA[(signed long int)R];
                      AA[(signed long int)R] = lglforce$$1$$8$$1$$1$$1$$3$$1$$TMP;
                    }
                    while((_Bool)0);

                }
                while((_Bool)0);
                do
                {
                  signed int return_value_lglcmpfdat$7;
                  return_value_lglcmpfdat$7=lglcmpfdat(fdat, *(&AA[(signed long int)(R - 1)]), *(&AA[(signed long int)R]));
                  if(return_value_lglcmpfdat$7 >= 1)
                    do
                    {
                      signed int lglforce$$1$$8$$1$$1$$1$$4$$1$$TMP = AA[(signed long int)(R - 1)];
                      AA[(signed long int)(R - 1)] = AA[(signed long int)R];
                      AA[(signed long int)R] = lglforce$$1$$8$$1$$1$$1$$4$$1$$TMP;
                    }
                    while((_Bool)0);

                }
                while((_Bool)0);
                do
                {
                  signed int PIVOT;
                  signed int J = R - 1;
                  I = (L + 1) - 1;
                  PIVOT = AA[(signed long int)J];
                  do
                  {

                  __CPROVER_DUMP_L49:
                    ;
                    I = I + 1;
                    signed int return_value_lglcmpfdat$8;
                    return_value_lglcmpfdat$8=lglcmpfdat(fdat, *(&AA[(signed long int)I]), *(&PIVOT));
                    if(!(return_value_lglcmpfdat$8 >= 0))
                      goto __CPROVER_DUMP_L49;

                    do
                    {
                      J = J - 1;
                      return_value_lglcmpfdat$9=lglcmpfdat(fdat, *(&PIVOT), *(&AA[(signed long int)J]));
                      if(return_value_lglcmpfdat$9 >= 0)
                        break;

                      if(J == 1 + L)
                        break;

                    }
                    while((_Bool)1);
                    if(I >= J)
                      break;

                    do
                    {
                      signed int lglforce$$1$$8$$1$$1$$1$$5$$1$$1$$1$$TMP = AA[(signed long int)I];
                      AA[(signed long int)I] = AA[(signed long int)J];
                      AA[(signed long int)J] = lglforce$$1$$8$$1$$1$$1$$5$$1$$1$$1$$TMP;
                    }
                    while((_Bool)0);
                  }
                  while((_Bool)1);
                  do
                  {
                    signed int lglforce$$1$$8$$1$$1$$1$$5$$2$$TMP = AA[(signed long int)I];
                    AA[(signed long int)I] = AA[(signed long int)(R - 1)];
                    AA[(signed long int)(R - 1)] = lglforce$$1$$8$$1$$1$$1$$5$$2$$TMP;
                  }
                  while((_Bool)0);
                }
                while((_Bool)0);
                if(!(I + -L >= R + -I))
                {
                  LL = I + 1;
                  RR = R;
                  R = I - 1;
                }

                else
                {
                  LL = L;
                  RR = I - 1;
                  L = I + 1;
                }
                if(R + -L >= 11)
                {
                  lglpushstk(lgl, &lgl->$anon1.sortstk, LL);
                  lglpushstk(lgl, &lgl->$anon1.sortstk, RR);
                }

                else
                  if(RR + -LL >= 11)
                  {
                    L = LL;
                    R = RR;
                  }

                  else
                  {
                    return_value_lglmtstk$10=lglmtstk(&lgl->$anon1.sortstk);
                    if(return_value_lglmtstk$10 == 0)
                    {
                      R=lglpopstk(&lgl->$anon1.sortstk);
                      L=lglpopstk(&lgl->$anon1.sortstk);
                    }

                    else
                      break;
                  }
              }
              while((_Bool)1);
            }
            while((_Bool)0);
            do
            {
              signed int lglforce$$1$$8$$2$$PIVOT;
              signed int lglforce$$1$$8$$2$$L = 0;
              signed int lglforce$$1$$8$$2$$R = NN - 1;
              signed int lglforce$$1$$8$$2$$I;
              signed int lglforce$$1$$8$$2$$J;
              lglforce$$1$$8$$2$$I = lglforce$$1$$8$$2$$R;
              for( ; !(lglforce$$1$$8$$2$$L >= lglforce$$1$$8$$2$$I); lglforce$$1$$8$$2$$I = lglforce$$1$$8$$2$$I - 1)
                do
                {
                  signed int return_value_lglcmpfdat$11;
                  return_value_lglcmpfdat$11=lglcmpfdat(fdat, *(&AA[(signed long int)(lglforce$$1$$8$$2$$I - 1)]), *(&AA[(signed long int)lglforce$$1$$8$$2$$I]));
                  if(return_value_lglcmpfdat$11 >= 1)
                    do
                    {
                      signed int lglforce$$1$$8$$2$$1$$1$$1$$TMP = AA[(signed long int)(lglforce$$1$$8$$2$$I - 1)];
                      AA[(signed long int)(lglforce$$1$$8$$2$$I - 1)] = AA[(signed long int)lglforce$$1$$8$$2$$I];
                      AA[(signed long int)lglforce$$1$$8$$2$$I] = lglforce$$1$$8$$2$$1$$1$$1$$TMP;
                    }
                    while((_Bool)0);

                }
                while((_Bool)0);
              lglforce$$1$$8$$2$$I = lglforce$$1$$8$$2$$L + 2;
              for( ; lglforce$$1$$8$$2$$R >= lglforce$$1$$8$$2$$I; lglforce$$1$$8$$2$$I = lglforce$$1$$8$$2$$I + 1)
              {
                lglforce$$1$$8$$2$$J = lglforce$$1$$8$$2$$I;
                lglforce$$1$$8$$2$$PIVOT = AA[(signed long int)lglforce$$1$$8$$2$$I];
                do
                {
                  return_value_lglcmpfdat$12=lglcmpfdat(fdat, *(&lglforce$$1$$8$$2$$PIVOT), *(&AA[(signed long int)(lglforce$$1$$8$$2$$J - 1)]));
                  if(return_value_lglcmpfdat$12 >= 0)
                    break;

                  AA[(signed long int)lglforce$$1$$8$$2$$J] = AA[(signed long int)(lglforce$$1$$8$$2$$J - 1)];
                  lglforce$$1$$8$$2$$J = lglforce$$1$$8$$2$$J - 1;
                }
                while((_Bool)1);
                AA[(signed long int)lglforce$$1$$8$$2$$J] = lglforce$$1$$8$$2$$PIVOT;
              }
            }
            while((_Bool)0);

          __CPROVER_DUMP_L71:
            ;
          }
          while((_Bool)0);
          o = 2;
          p = order.start;
          for( ; !(p >= order.top); p = p + 1l)
          {
            idx = *p;

          __CPROVER_DUMP_L73:
            ;
            tmp_post$13 = o;
            o = o + 1;
            map[(signed long int)idx] = tmp_post$13;
          }
        }

        do
        {

        DONE:
          ;
          lgldel(lgl, (void *)fdat, (unsigned long int)lgl->nvars * sizeof(struct ForceData) /*16ul*/ );
          fdat = ((struct ForceData *)NULL);
        }
        while((_Bool)0);
        lglrelstk(lgl, &order);
        if(first == 0)
          goto __CPROVER_DUMP_L75;

        tmp_post$14 = round;
        round = round + 1;
        if(!(tmp_post$14 >= lgl->opts->force.val))
          goto RESTART;

        return_value_lglrem$15=lglrem(lgl);
        return_value_lglceilld$16=lglceilld(return_value_lglrem$15);
        if(!(round >= return_value_lglceilld$16))
          goto RESTART;

      }
      while(oldspan + -span > oldspan / 100.0 && oldspan > span);

    __CPROVER_DUMP_L75:
      ;
      lglstop(lgl);
    }

  }

}

// lglfork
// file lglib.h line 72
struct LGL * lglfork(struct LGL *lgl, signed int complete)
{
  struct LGL *return_value_lglforkaux$1;
  return_value_lglforkaux$1=lglforkaux(lgl, 0, complete);
  return return_value_lglforkaux$1;
}

// lglforkaux
// file lglib.c line 18955
static struct LGL * lglforkaux(struct LGL *lgl, signed int brutefork, signed int complete)
{
  signed int nass;
  signed int elit;
  const signed int *p;
  struct LGL *res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglforkaux");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->forked == 0))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglforkaux");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not fork twice yet");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lglstart(lgl, &lgl->times->all);
  lglrep(lgl, 1, (char)102);
  signed int return_value_lglbcp$1;
  if(lgl->mt == 0)
  {
    return_value_lglbcp$1=lglbcp(lgl);
    if(return_value_lglbcp$1 == 0)
      lgl->mt = 1;

  }

  if(lgl->mt == 0)
    lglgc(lgl);

  res=lglminit(lgl->mem->state, lgl->mem->alloc, lgl->mem->realloc, lgl->mem->dealloc);
  lglcpyopts(res, lgl);
  lglctrav(lgl, (void *)res, (void (*)(void *, signed int))lgleadd);
  if(res->mt == 0)
    lglrtrav(lgl, (void *)res, (void (*)(void *, signed int, signed int))lglfjradd);

  if(!(complete == 0))
    lglcompletefork(res, lgl);

  unsigned long int return_value_lglcntstk$2;
  return_value_lglcntstk$2=lglcntstk(&lgl->assume);
  nass = (signed int)return_value_lglcntstk$2;
  res->bruteforked = (char)(nass != 0 && brutefork != 0);
  if(!(res->bruteforked == 0))

    __CPROVER_DUMP_L11:
      ;

  else

    __CPROVER_DUMP_L12:
      ;
  p = lgl->eassume.start;
  for( ; !(p >= lgl->eassume.top); p = p + 1l)
  {
    elit = *p;
    lglpushstk(res, &res->fassume, elit);
    if(res->bruteforked == 0)
      lglassume(res, elit);

    else
    {
      lglfjadd(res, elit);
      lglfjadd(res, 0);
    }
  }
  lgl->forked = (char)1;
  lglstop(lgl);
  return res;
}

// lglforkmerge
// file lglib.c line 18996
static void lglforkmerge(struct LGL *to, struct LGL *from)
{
  const signed int *p;
  struct Trv travstate;
  if(from->bruteforked == 0)
  {
    travstate.state = (void *)to;
    travstate.trav = (void (*)(void *, signed int))lgleadd;
    lglutrav(from, (void *)&travstate, lgltravallu);
    lgletrav(from, (void *)&travstate, lgltravalle);
  }

  p = from->fassume.start;
  for( ; !(p >= from->fassume.top); p = p + 1l)
    lgleassume(to, *p);
}

// lglfreewch
// file lglib.c line 3018
static void lglfreewch(struct LGL *lgl, signed int oldoffset, signed int oldhcount)
{
  signed int ldoldhcount;
  ldoldhcount=lglceilld(oldhcount);
  lgl->wchs->stk.start[(signed long int)oldoffset] = lgl->wchs->start[(signed long int)ldoldhcount];
  lgl->wchs->start[(signed long int)ldoldhcount] = oldoffset;
  lgl->wchs->free = lgl->wchs->free + 1;

__CPROVER_DUMP_L1:
  ;
}

// lglfreeze
// file lglib.h line 262
void lglfreeze(struct LGL *lgl, signed int elit)
{
  struct Ext *ext;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfreeze");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "freeze %d", elit);
    break;
  }
  lgl->stats->calls.freeze = lgl->stats->calls.freeze + 1l;
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfreeze");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not freeze zero literal");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }

__CPROVER_DUMP_L8:
  ;
  do
  {
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfreeze");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

    while((2039 & (signed int)lgl->state) == 0)
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfreeze");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "!(%s)", (const void *)"UNUSED|OPTSET|USED|RESET|SATISFIED|UNSATISFIED|FAILED|LOOKED| UNKNOWN|EXTENDED");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
  }
  while((_Bool)0);

__CPROVER_DUMP_L14:
  ;
  lglimport(lgl, elit);
  ext=lglelit2ext(lgl, elit);
  while(!(ext->melted == 0u))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfreeze");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "freezing melted literal %d", elit);
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  while(ext->frozen == 0x7fffffff)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglfreeze");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "literal %d frozen too often", elit);
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  ext->frozen = ext->frozen + 1;
  if(ext->frozen == 0)
    lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;

  lglmelter(lgl);
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglfreeze(lgl->clone, elit);

}

// lglfreezer
// file lglib.c line 8118
static void lglfreezer(struct LGL *lgl)
{
  signed int frozen;
  signed int melted;
  signed int tmpfrozen;
  signed int elit;
  signed int erepr;
  struct Ext *ext;
  struct Ext *rext;
  signed int *p;
  signed int eass;
  if(lgl->frozen == 0)
  {
    elit = 1;
    for( ; lgl->maxext >= elit; elit = elit + 1)
      (lgl->ext + (signed long int)elit)->tmpfrozen = (unsigned int)0;
    frozen = 0;
    tmpfrozen = frozen;
    signed int return_value_lglmtstk$1;
    return_value_lglmtstk$1=lglmtstk(&lgl->eassume);
    if(return_value_lglmtstk$1 == 0)
    {
      p = lgl->eassume.start;
      for( ; !(p >= lgl->eassume.top); p = p + 1l)
      {
        eass = *p;
        ext=lglelit2ext(lgl, eass);
        if(ext->frozen == 0)
        {
          if(ext->tmpfrozen == 0u)
          {
            ext->tmpfrozen = (unsigned int)1;
            tmpfrozen = tmpfrozen + 1;

          __CPROVER_DUMP_L5:
            ;
            erepr=lglerepr(lgl, eass);
            rext=lglelit2ext(lgl, erepr);
            if(!(ext == rext))
            {
              if(rext->frozen == 0)
              {
                if(rext->tmpfrozen == 0u)
                {

                __CPROVER_DUMP_L6:
                  ;
                  rext->tmpfrozen = (unsigned int)1;
                  tmpfrozen = tmpfrozen + 1;
                }

              }

            }

          }

        }

      }
    }

    elit = 1;
    for( ; lgl->maxext >= elit; elit = elit + 1)
    {
      ext=lglelit2ext(lgl, elit);
      if(!(ext->frozen == 0))
      {
        frozen = frozen + 1;
        erepr=lglerepr(lgl, elit);
        rext=lglelit2ext(lgl, erepr);
        if(!(ext == rext))
        {
          if(rext->frozen == 0)
          {
            if(rext->tmpfrozen == 0u)
            {

            __CPROVER_DUMP_L10:
              ;
              rext->tmpfrozen = (unsigned int)1;
              tmpfrozen = tmpfrozen + 1;
            }

          }

        }

      }

    }
    melted = 0;
    elit = 1;
    for( ; lgl->maxext >= elit; elit = elit + 1)
    {
      ext=lglelit2ext(lgl, elit);
      if(ext->frozen == 0)
      {
        if(ext->melted == 0u)
        {
          if(ext->tmpfrozen == 0u)
          {

          __CPROVER_DUMP_L14:
            ;
            ext->melted = (unsigned int)1;
            melted = melted + 1;
          }

        }

      }

    }

  __CPROVER_DUMP_L16:
    ;

  __CPROVER_DUMP_L17:
    ;

  __CPROVER_DUMP_L18:
    ;
    lgl->frozen = (char)1;
  }


__CPROVER_DUMP_L19:
  ;
}

// lglfullctk
// file lglib.c line 1540
static signed int lglfullctk(struct Ctk *ctk)
{
  return (signed int)(ctk->top == ctk->end);
}

// lglfullstk
// file lglib.c line 1386
static signed int lglfullstk(struct Stk *s)
{
  return (signed int)(s->top == s->end);
}

// lglfullwtk
// file lglib.c line 14989
static signed int lglfullwtk(struct Wtk *wtk)
{
  return (signed int)(wtk->top == wtk->end);
}

// lglfullyconnected
// file lglib.c line 6566
static void lglfullyconnected(struct LGL *lgl)
{
  if(!(lgl->notfullyconnected == 0))
  {

  __CPROVER_DUMP_L1:
    ;
    lgl->notfullyconnected = (char)0;
  }

}

// lglfuncpy
// file lglib.c line 10507
static void lglfuncpy(unsigned long int *dst, unsigned long int *src)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    dst[(signed long int)i] = src[(signed long int)i];
}

// lglgat2idx
// file lglib.c line 12373
static signed int lglgat2idx(struct LGL *lgl, struct Gat *g)
{
  return (signed int)(g - lgl->$anon0.cgr->gates);
}

// lglgateextract
// file lglib.c line 12951
static void lglgateextract(struct LGL *lgl)
{
  signed int idx;
  signed int count;

__CPROVER_DUMP_L1:
  ;
  lglrandidxtrav(lgl, lglcgextractidx);
  count = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
    count = count + (signed int)(lgl->avars + (signed long int)idx)->gate;
  if(!(lgl->$anon0.cgr->extracted.units == 0))
    lglprt(lgl, 2, "[extract-%d] extracted %d units", lgl->stats->cgr.count, lgl->$anon0.cgr->extracted.units);

  if(!(lgl->$anon0.cgr->extracted.eq == 0))
    lglprt(lgl, 2, "[extract-%d] extracted %d equivalences", lgl->stats->cgr.count, lgl->$anon0.cgr->extracted.eq);

  double return_value_lglpcnt$1;
  if(!(lgl->$anon0.cgr->extracted.all == 0))
  {
    return_value_lglpcnt$1=lglpcnt((double)count, (double)lgl->nvars);
    lglprt(lgl, 2, "[extract-%d] extracted %d gates for %d variables %.0f%%", lgl->stats->cgr.count, lgl->$anon0.cgr->extracted.all, count, return_value_lglpcnt$1);
  }

  double return_value_lglpcnt$2;
  if(!(lgl->$anon0.cgr->extracted.and == 0))
  {
    return_value_lglpcnt$2=lglpcnt((double)lgl->$anon0.cgr->extracted.and, (double)lgl->$anon0.cgr->extracted.all);
    lglprt(lgl, 2, "[extract-%d] %d and gates %.0f%% of all extracted gates", lgl->stats->cgr.count, lgl->$anon0.cgr->extracted.and, return_value_lglpcnt$2);
  }

  double return_value_lglpcnt$3;
  if(!(lgl->$anon0.cgr->extracted.xor == 0))
  {
    return_value_lglpcnt$3=lglpcnt((double)lgl->$anon0.cgr->extracted.xor, (double)lgl->$anon0.cgr->extracted.all);
    lglprt(lgl, 2, "[extract-%d] %d xor gates %.0f%% of all extracted gates", lgl->stats->cgr.count, lgl->$anon0.cgr->extracted.xor, return_value_lglpcnt$3);
  }

  double return_value_lglpcnt$4;
  if(!(lgl->$anon0.cgr->extracted.ite == 0))
  {
    return_value_lglpcnt$4=lglpcnt((double)lgl->$anon0.cgr->extracted.ite, (double)lgl->$anon0.cgr->extracted.all);
    lglprt(lgl, 2, "[extract-%d] %d ite gates %.0f%% of all extracted gates", lgl->stats->cgr.count, lgl->$anon0.cgr->extracted.ite, return_value_lglpcnt$4);
  }

}

// lglgauss
// file lglib.c line 16810
static signed int lglgauss(struct LGL *lgl)
{
  signed int oldunits;
  signed int oldequivs;
  signed int oldtrneqs;
  signed int units;
  signed int equivs;
  signed int trneqs;
  signed int success;
  signed int return_value_lglterminate$4;
  _Bool tmp_if_expr$3;
  signed int return_value_lglbcp$2;
  signed int return_value_lglterminate$6;
  if(!(lgl->mt == 0))
    return 0;

  else
    if(!(lgl->nvars >= 3))
      return 1;

    else
    {
      lglstart(lgl, &lgl->times->gauss);
      lgl->gaussing = (char)1;
      lgl->simp = lgl->gaussing;
      lgl->stats->gauss.count = lgl->stats->gauss.count + 1;
      lglsetgausslim(lgl);
      lglgaussinit(lgl);
      lglgaussextract(lgl);
      oldunits = lgl->stats->gauss.units;
      oldequivs = lgl->stats->gauss.equivs;
      oldtrneqs = lgl->stats->gauss.trneqs;
      signed int return_value_lglmtstk$5;
      return_value_lglmtstk$5=lglmtstk(&lgl->$anon0.gauss->xors);
      if(return_value_lglmtstk$5 == 0)
      {
        lglgaussconnect(lgl);
        lglgaussorder(lgl);
        lglsetgausslim(lgl);
        lglgausselim(lgl);
        if(lgl->mt == 0)
        {
          return_value_lglterminate$4=lglterminate(lgl);
          if(return_value_lglterminate$4 == 0)
          {
            if(lgl->opts->verbose.val >= 3)
              lglgdump(lgl);

            lglgaussdisconnect(lgl);
            signed int return_value_lglgaussexport$1;
            return_value_lglgaussexport$1=lglgaussexport(lgl);
            if(return_value_lglgaussexport$1 == 0)
              tmp_if_expr$3 = (_Bool)1;

            else
            {
              return_value_lglbcp$2=lglbcp(lgl);
              tmp_if_expr$3 = !(return_value_lglbcp$2 != 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$3)
              lgl->mt = 1;

            else
              if(!(lgl->stats->gauss.steps.extr >= lgl->limits->gauss.steps.extr))
              {
                if(!(lgl->stats->gauss.steps.elim >= lgl->limits->gauss.steps.elim))
                  lglprt(lgl, 1, "[gauss-%d] fully completed", lgl->stats->gauss.count);

              }

          }

        }

      }

      lglgaussreset(lgl);
      units = lgl->stats->gauss.units - oldunits;
      equivs = lgl->stats->gauss.equivs - oldequivs;
      trneqs = lgl->stats->gauss.trneqs - oldtrneqs;
      success = (signed int)(units != 0 || equivs != 0);
      if(lgl->mt == 0)
      {
        if(!(success == 0))
        {
          return_value_lglterminate$6=lglterminate(lgl);
          if(return_value_lglterminate$6 == 0)
            lgldecomp(lgl);

        }

      }

      if(!(trneqs == 0))
        success = 1;

      if(!(lgl->mt == 0))
        lglprt(lgl, 1, "[gauss-%d] proved unsatisfiability", lgl->stats->gauss.count);

      else
        lglprt(lgl, 1, "[gauss-%d] exported %d unary, %d binary and %d ternary equations", lgl->stats->gauss.count, units, equivs, trneqs);
      lglupdgausspen(lgl, success);
      lglrep(lgl, 1, (char)71);
      lgl->gaussing = (char)0;
      lgl->simp = lgl->gaussing;
      lglstop(lgl);
      return (signed int)!(lgl->mt != 0);
    }
}

// lglgaussaddeqn
// file lglib.c line 16557
static signed int lglgaussaddeqn(struct LGL *lgl, signed int eqn)
{
  const signed int *p;
  struct AVar *av;
  signed int var;
  p = lgl->$anon0.gauss->xors.start + (signed long int)eqn;
  do
  {
    var = *p;
    if(!(var >= 2))
      break;

    av=lglavar(lgl, var);
    if(av->mark == 0)
      lglpushstk(lgl, &lgl->clause, var);

    av->mark = (signed int)!(av->mark != 0);
    p = p + 1l;
  }
  while((_Bool)1);
  return var;
}

// lglgausschkeliminated
// file lglib.c line 16606
static void lglgausschkeliminated(struct LGL *lgl)
{
  ;
}

// lglgaussconeqn
// file lglib.c line 16413
static void lglgaussconeqn(struct LGL *lgl, signed int eqn)
{
  const signed int *xors = lgl->$anon0.gauss->xors.start;
  signed int i;
  signed int var;
  lgl->stats->gauss.steps.elim = lgl->stats->gauss.steps.elim + 1l;
  i = eqn;
  do
  {
    var = xors[(signed long int)i];
    if(!(var >= 2))
      break;

    lglpushstk(lgl, lgl->$anon0.gauss->occs + (signed long int)var, eqn);
    i = i + 1;
  }
  while((_Bool)1);
}

// lglgaussconnect
// file lglib.c line 16433
static void lglgaussconnect(struct LGL *lgl)
{
  signed int c;
  signed int i;
  signed int eox;
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(&lgl->$anon0.gauss->xors);
  eox = (signed int)return_value_lglcntstk$1;
  signed int connected;
  signed int var;
  signed int vars;
  const signed int *xors = lgl->$anon0.gauss->xors.start;
  struct Stk *occs;

__CPROVER_DUMP_L1:
  ;
  do
  {
    void *return_value_lglnew$2;
    return_value_lglnew$2=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(struct Stk) /*24ul*/ );
    lgl->$anon0.gauss->occs = (struct Stk *)return_value_lglnew$2;
  }
  while((_Bool)0);
  connected = 0;
  vars = connected;
  c = 0;
  for( ; !(c >= eox); c = i + 1)
  {
    lgl->stats->gauss.steps.elim = lgl->stats->gauss.steps.elim + 1l;
    i = c;
    do
    {
      var = xors[(signed long int)i];
      if(!(var >= 2))
        break;

      occs = lgl->$anon0.gauss->occs + (signed long int)var;
      signed int return_value_lglmtstk$3;
      return_value_lglmtstk$3=lglmtstk(occs);
      if(!(return_value_lglmtstk$3 == 0))
        vars = vars + 1;

      lglpushstk(lgl, lgl->$anon0.gauss->occs + (signed long int)var, c);
      connected = connected + 1;
      i = i + 1;
    }
    while((_Bool)1);
  }
  double return_value_lglavg$4;
  return_value_lglavg$4=lglavg((double)connected, (double)vars);
  lglprt(lgl, 1, "[gauss-%d] connected %d occurrences of %d variables (average %.1f)", lgl->stats->gauss.count, connected, vars, return_value_lglavg$4);
}

// lglgaussdisconnect
// file lglib.c line 16467
static void lglgaussdisconnect(struct LGL *lgl)
{
  signed int idx;

__CPROVER_DUMP_L1:
  ;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
    lglrelstk(lgl, lgl->$anon0.gauss->occs + (signed long int)idx);
  do
  {
    lgldel(lgl, (void *)lgl->$anon0.gauss->occs, (unsigned long int)lgl->nvars * sizeof(struct Stk) /*24ul*/ );
    lgl->$anon0.gauss->occs = ((struct Stk *)NULL);
  }
  while((_Bool)0);
}

// lglgaussdiseqn
// file lglib.c line 16421
static void lglgaussdiseqn(struct LGL *lgl, signed int eqn)
{
  signed int *xors = lgl->$anon0.gauss->xors.start;
  signed int i;
  signed int var;
  i = eqn;
  do
  {
    var = xors[(signed long int)i];
    if(!(var >= 2))
      break;

    xors[(signed long int)i] = 0x7fffffff >> RMSHFT;
    lgl->$anon0.gauss->garbage = lgl->$anon0.gauss->garbage + 1;
    lgl->stats->gauss.steps.elim = lgl->stats->gauss.steps.elim + 1l;
    lglrmstk(lgl->$anon0.gauss->occs + (signed long int)var, eqn);
    i = i + 1;
  }
  while((_Bool)1);
  xors[(signed long int)i] = 0x7fffffff >> RMSHFT;
  lgl->$anon0.gauss->garbage = lgl->$anon0.gauss->garbage + 1;
}

// lglgausselim
// file lglib.c line 16667
static void lglgausselim(struct LGL *lgl)
{
  signed int pivot;
  signed int changed = 1;
  unsigned long int return_value_lglcntstk$1;
  signed int tmp_post$3;
  while(lgl->mt == 0)
  {
    return_value_lglcntstk$1=lglcntstk(&lgl->$anon0.gauss->order);
    if((unsigned long int)lgl->$anon0.gauss->next >= return_value_lglcntstk$1)
      break;

    if(lgl->stats->gauss.steps.elim >= lgl->limits->gauss.steps.elim)
      break;

    signed int return_value_lglterminate$2;
    return_value_lglterminate$2=lglterminate(lgl);
    if(!(return_value_lglterminate$2 == 0))
      break;

    if(!(changed == 0))
      lglgaussort(lgl);

    tmp_post$3 = lgl->$anon0.gauss->next;
    lgl->$anon0.gauss->next = lgl->$anon0.gauss->next + 1;
    pivot=lglpeek(&lgl->$anon0.gauss->order, tmp_post$3);
    changed=lglgausselimvar(lgl, pivot);
  }
}

// lglgausselimvar
// file lglib.c line 16637
static signed int lglgausselimvar(struct LGL *lgl, signed int pivot)
{
  signed int subst;
  signed int changed;
  signed int occs;
  signed int eliminated;

__CPROVER_DUMP_L1:
  ;
  occs=lglgaussoccs(lgl, pivot);
  if(occs == 0)
  {

  __CPROVER_DUMP_L2:
    ;
    eliminated = 2;
    changed = 0;
  }

  else
    if(occs == 1)
    {

    __CPROVER_DUMP_L4:
      ;
      eliminated = 1;
      changed = 0;
    }

    else
    {
      lglgaussgc(lgl);
      subst=lglgausspickeqn(lgl, pivot);
      if(subst >= 0)
      {
        lglgaussubst(lgl, pivot, subst);
        eliminated = 1;
        changed = 1;
      }

      else
      {
        eliminated = 3;
        changed = 0;
      }
    }
  lgl->$anon0.gauss->eliminated[(signed long int)pivot] = (signed char)eliminated;
  lglgausschkeliminated(lgl);
  return changed;
}

// lglgaussexp2
// file lglib.c line 16692
static signed int lglgaussexp2(struct LGL *lgl, signed int a, signed int b)
{
  signed int return_value_lglhasbin$1;
  return_value_lglhasbin$1=lglhasbin(lgl, a, b);
  if(!(return_value_lglhasbin$1 == 0))
    return 0;

  else
  {
    lglpushstk(lgl, &lgl->clause, a);
    lglpushstk(lgl, &lgl->clause, b);
    lglpushstk(lgl, &lgl->clause, 0);

  __CPROVER_DUMP_L2:
    ;
    lgladdcls(lgl, REDCS, 0, 0);
    lglclnstk(&lgl->clause);
    return 1;
  }
}

// lglgaussexp3
// file lglib.c line 16708
static signed int lglgaussexp3(struct LGL *lgl, signed int a, signed int b, signed int c)
{
  signed int return_value_lglhastrn$1;
  return_value_lglhastrn$1=lglhastrn(lgl, a, b, c);
  if(!(return_value_lglhastrn$1 == 0))
    return 0;

  else
  {
    lglpushstk(lgl, &lgl->clause, a);
    lglpushstk(lgl, &lgl->clause, b);
    lglpushstk(lgl, &lgl->clause, c);
    lglpushstk(lgl, &lgl->clause, 0);

  __CPROVER_DUMP_L2:
    ;
    lgladdcls(lgl, REDCS, 0, 0);
    lglclnstk(&lgl->clause);
    return 1;
  }
}

// lglgaussexport
// file lglib.c line 16725
static signed int lglgaussexport(struct LGL *lgl)
{
  signed int var;
  signed int size;
  signed int val;
  signed int rhs;
  signed int unit;
  signed int a;
  signed int b;
  signed int c;
  signed int exported;
  const signed int *e;
  const signed int *p;
  const signed int *q;
  e = lgl->$anon0.gauss->xors.start;
  signed int tmp_if_expr$3;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$5;
  for( ; !(e >= lgl->$anon0.gauss->xors.top); e = p + (signed long int)1)
  {
    p = e;
    if(!(*p >= 134217727))
    {
      do
      {
        var = *p;
        if(!(var >= 2))
          break;

        p = p + 1l;
      }
      while((_Bool)1);
      rhs = *p;
      q = e;
      for( ; !(q >= p); q = q + 1l)
      {
        var = *q;
        signed char return_value_lglval$1;
        return_value_lglval$1=lglval(lgl, var);
        val = (signed int)return_value_lglval$1;
        if(val >= 0)
        {
          if(val >= 1)
            rhs = (signed int)!(rhs != 0);

          else
            lglpushstk(lgl, &lgl->clause, var);
        }

      }
      unsigned long int return_value_lglcntstk$2;
      return_value_lglcntstk$2=lglcntstk(&lgl->clause);
      size = (signed int)return_value_lglcntstk$2;
      if(!(rhs == 0) || !(size == 0))
      {
        if(size == 0 && !(rhs == 0))
        {

        __CPROVER_DUMP_L10:
          ;
          return 0;
        }

        if(size >= 1)
          tmp_if_expr$3 = lgl->clause.start[(signed long int)0];

        else
          tmp_if_expr$3 = 0;
        a = tmp_if_expr$3;
        if(size >= 2)
          tmp_if_expr$4 = lgl->clause.start[(signed long int)1];

        else
          tmp_if_expr$4 = 0;
        b = tmp_if_expr$4;
        if(size >= 3)
          tmp_if_expr$5 = lgl->clause.start[(signed long int)2];

        else
          tmp_if_expr$5 = 0;
        c = tmp_if_expr$5;
        lglclnstk(&lgl->clause);
        if(size == 1)
        {
          unit = a;
          if(rhs == 0)
            unit = -unit;


        __CPROVER_DUMP_L18:
          ;
          lgl->stats->gauss.units = lgl->stats->gauss.units + 1;
          lglunit(lgl, unit);
        }

        else
          if(size == 2)
          {
            if(!(rhs == 0))
              b = -b;

            exported=lglgaussexp2(lgl, -a, b);
            signed int return_value_lglgaussexp2$6;
            return_value_lglgaussexp2$6=lglgaussexp2(lgl, a, -b);
            exported = exported | return_value_lglgaussexp2$6;
            if(!(exported == 0))
            {

            __CPROVER_DUMP_L21:
              ;
              lgl->stats->gauss.equivs = lgl->stats->gauss.equivs + 1;
            }

          }

          else
            if(size == 3)
            {
              if(!(lgl->opts->gaussexptrn.val == 0))
              {
                if(rhs == 0)
                  c = -c;

                exported=lglgaussexp3(lgl, a, b, c);
                signed int return_value_lglgaussexp3$7;
                return_value_lglgaussexp3$7=lglgaussexp3(lgl, a, -b, -c);
                exported = exported | return_value_lglgaussexp3$7;
                signed int return_value_lglgaussexp3$8;
                return_value_lglgaussexp3$8=lglgaussexp3(lgl, -a, b, -c);
                exported = exported | return_value_lglgaussexp3$8;
                signed int return_value_lglgaussexp3$9;
                return_value_lglgaussexp3$9=lglgaussexp3(lgl, -a, -b, c);
                exported = exported | return_value_lglgaussexp3$9;
                if(!(exported == 0))
                {

                __CPROVER_DUMP_L25:
                  ;
                  lgl->stats->gauss.trneqs = lgl->stats->gauss.trneqs + 1;
                }

              }

            }

      }

    }

  }
  return 1;
}

// lglgaussextract
// file lglib.c line 16477
static void lglgaussextract(struct LGL *lgl)
{
  signed int extracted;
  signed int lglgaussextract$$1$$lits;
  if(!(lgl->level == 0))
    lglbacktrack(lgl, 0);

  lglgc(lgl);
  if(lgl->mt == 0)
  {
    lgldense(lgl, 1);
    extracted=lglgaussextractsmall(lgl);
    signed int return_value_lglgaussextractlarge$1;
    return_value_lglgaussextractlarge$1=lglgaussextractlarge(lgl);
    extracted = extracted + return_value_lglgaussextractlarge$1;
    unsigned long int return_value_lglcntstk$2;
    return_value_lglcntstk$2=lglcntstk(&lgl->$anon0.gauss->xors);
    lglgaussextract$$1$$lits = (signed int)(return_value_lglcntstk$2 - (unsigned long int)extracted);
    double return_value_lglavg$3;
    return_value_lglavg$3=lglavg((double)lglgaussextract$$1$$lits, (double)extracted);
    lglprt(lgl, 1, "[gauss-%d] extracted %d xors of average arity %.1f", lgl->stats->gauss.count, extracted, return_value_lglavg$3);
    lglsparse(lgl);
    lglgc(lgl);
    if(lgl->mt == 0)
      lglfitstk(lgl, &lgl->$anon0.gauss->xors);

  }

}

// lglgaussextractlarge
// file lglib.c line 16401
static signed int lglgaussextractlarge(struct LGL *lgl)
{
  const signed int *p;
  const signed int *c;
  signed int res = 0;
  c = lgl->irr.start;
  for( ; !(c >= lgl->irr.top); c = p + (signed long int)1)
  {
    if(lgl->stats->gauss.steps.extr >= lgl->limits->gauss.steps.extr)
      break;

    p = c;
    if(!(*p >= 134217727))
    {
      signed int return_value_lglgaussextractxor$1;
      return_value_lglgaussextractxor$1=lglgaussextractxor(lgl, c);
      res = res + return_value_lglgaussextractxor$1;
      for( ; !(*p == 0); p = p + 1l)
        ;
    }

  }
  return res;
}

// lglgaussextractsmall
// file lglib.c line 16391
static signed int lglgaussextractsmall(struct LGL *lgl)
{
  signed long int before = lgl->stats->gauss.extracted;
  signed long int after;
  signed long int delta;
  signed int res;
  lglrandlitrav(lgl, lglgaussextractsmallit);
  after = lgl->stats->gauss.extracted;
  delta = after - before;
  res = (signed int)(delta > (signed long int)0x7fffffff ? (signed long int)0x7fffffff : delta);
  return res;
}

// lglgaussextractsmallit
// file lglib.c line 16357
static signed int lglgaussextractsmallit(struct LGL *lgl, signed int lit)
{
  signed int allxors = lgl->opts->gaussextrall.val;
  signed int cls[4l];
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  const signed int *w;
  const signed int *eow;
  const signed int *p;
  struct HTS *hts;
  signed int return_value_abs$2;
  signed int return_value_abs$3;
  if(lgl->stats->gauss.steps.extr >= lgl->limits->gauss.steps.extr)
    return 0;

  else
  {
    signed char return_value_lglval$1;
    return_value_lglval$1=lglval(lgl, lit);
    if((signed int)return_value_lglval$1 >= 1)
      return 1;

    else
    {
      hts=lglhts(lgl, lit);
      w=lglhts2wchs(lgl, hts);
      eow = w + (signed long int)hts->count;
      p = w;
      for( ; !(p >= eow); p = p + 1l)
      {
        blit = *p;
        tag = blit & MASKCS;
        if(tag == TRNCS || tag == LRGCS)
          p = p + 1l;

        if(!(tag == OCCS) && !(tag == LRGCS))
        {
          other = blit >> RMSHFT;
          if(allxors == 0)
          {
            return_value_abs$2=abs(other);
            if(!(return_value_abs$2 >= lit))
              goto __CPROVER_DUMP_L9;

          }

          cls[(signed long int)0] = lit;
          cls[(signed long int)1] = other;
          if(tag == TRNCS)
          {
            other2 = *p;
            if(allxors == 0)
            {
              return_value_abs$3=abs(other2);
              if(!(return_value_abs$3 >= lit))
                goto __CPROVER_DUMP_L9;

            }

            cls[(signed long int)2] = other2;
            cls[(signed long int)3] = 0;
          }

          else
            cls[(signed long int)2] = 0;
          lglgaussextractxor(lgl, cls);
        }


      __CPROVER_DUMP_L9:
        ;
      }
      return 1;
    }
  }
}

// lglgaussextractxor
// file lglib.c line 16350
static signed int lglgaussextractxor(struct LGL *lgl, const signed int *c)
{
  signed int old;
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(&lgl->$anon0.gauss->xors);
  old = (signed int)return_value_lglcntstk$1;
  signed int res;
  res=lglgaussextractxoraux(lgl, c);
  if(res == 0)
    lglrststk(&lgl->$anon0.gauss->xors, old);

  return res;
}

// lglgaussextractxoraux
// file lglib.c line 16308
static signed int lglgaussextractxoraux(struct LGL *lgl, const signed int *c)
{
  signed int lit;
  signed int val;
  signed int size;
  signed int maxsize;
  signed int negs;
  signed int lglgaussextractxoraux$$1$$start;
  signed int max;
  signed int *d;
  signed int *q;
  signed int allxors = lgl->opts->gaussextrall.val;
  unsigned long int signs;
  const signed int *p;
  maxsize = lgl->opts->gaussmaxor.val;
  size = 0;
  negs = size;
  max = negs;
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(&lgl->$anon0.gauss->xors);
  lglgaussextractxoraux$$1$$start = (signed int)return_value_lglcntstk$1;
  p = c;
  _Bool tmp_if_expr$5;
  signed int return_value_abs$3;
  signed int return_value_abs$4;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    signed char return_value_lglval$2;
    return_value_lglval$2=lglval(lgl, lit);
    val = (signed int)return_value_lglval$2;
    if(val >= 1)
      return 0;

    if(val >= 0)
    {
      if(!(lit >= 0))
      {
        if(allxors == 0 && !(negs == 0))
          return 0;

        negs = (signed int)!(negs != 0);
      }

      if(max == 0)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_abs$3=abs(max);
        return_value_abs$4=abs(lit);
        tmp_if_expr$5 = return_value_abs$3 < return_value_abs$4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        max = lit;

      lglpushstk(lgl, &lgl->$anon0.gauss->xors, lit);
      size = size + 1;
      if(!(maxsize >= size))
        return 0;

    }

    p = p + 1l;
  }
  while((_Bool)1);
  _Bool tmp_if_expr$6;
  if(!(size >= 2))
    return 0;

  else
    if(allxors == 0 && max >= 1 && !(negs == 0))
      return 0;

    else
    {
      lglpushstk(lgl, &lgl->$anon0.gauss->xors, 0);
      d = lgl->$anon0.gauss->xors.start + (signed long int)lglgaussextractxoraux$$1$$start;
      signs=lgldec64(1ull << size);
      do
      {
        signed int return_value_lglgaussubcls$7;
        return_value_lglgaussubcls$7=lglgaussubcls(lgl, signs, d);
        if(return_value_lglgaussubcls$7 == 0)
          break;

        signs=lgldec64(signs);
        if(!(signs == 0ul))
          tmp_if_expr$6 = lgl->stats->gauss.steps.extr < lgl->limits->gauss.steps.extr ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$6 = (_Bool)0;
      }
      while(tmp_if_expr$6);
      if(!(signs == 0ul))
        return 0;

      else
      {
        q = d;
        do
        {
          lit = *q;
          if(lit == 0)
            break;

          *q=abs(lit);
          q = q + 1l;
        }
        while((_Bool)1);
        *q = (signed int)!(negs != 0);

      __CPROVER_DUMP_L21:
        ;
        lgl->stats->gauss.arity.sum = lgl->stats->gauss.arity.sum + (signed long int)size;
        if(!(lgl->stats->gauss.arity.max >= size))
          lgl->stats->gauss.arity.max = size;

        lgl->stats->gauss.extracted = lgl->stats->gauss.extracted + 1l;
        return 1;
      }
    }
}

// lglgaussgc
// file lglib.c line 16619
static void lglgaussgc(struct LGL *lgl)
{
  signed int count;
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(&lgl->$anon0.gauss->xors);
  count = (signed int)return_value_lglcntstk$1;
  signed int *q;
  const signed int *p;
  signed int *tmp_post$2;
  if(lgl->$anon0.gauss->garbage >= count / 2 + 10000)
  {
    lgl->stats->gauss.gcs = lgl->stats->gauss.gcs + 1;
    lglprt(lgl, 2, "[gauss-%d] collecting %d garbage out of %d", lgl->stats->gauss.count, lgl->$anon0.gauss->garbage, count);
    lglgaussdisconnect(lgl);
    q = lgl->$anon0.gauss->xors.start;
    p = q;
    for( ; !(p >= lgl->$anon0.gauss->xors.top); p = p + 1l)
      if(!(*p == 134217727))
      {
        tmp_post$2 = q;
        q = q + 1l;
        *tmp_post$2 = *p;
      }

    lgl->$anon0.gauss->xors.top = q;
    lglfitstk(lgl, &lgl->$anon0.gauss->xors);
    lglgaussconnect(lgl);
    lgl->$anon0.gauss->garbage = 0;
  }

}

// lglgaussing
// file lglib.c line 17010
static signed int lglgaussing(struct LGL *lgl)
{
  signed int return_value_lglsmallirr$1;
  return_value_lglsmallirr$1=lglsmallirr(lgl);
  if(return_value_lglsmallirr$1 == 0)
    return 0;

  else
    return lgl->opts->gauss.val;
}

// lglgaussinit
// file lglib.c line 16678
static void lglgaussinit(struct LGL *lgl)
{
  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Gauss) /*72ul*/ );
    lgl->$anon0.gauss = (struct Gauss *)return_value_lglnew$1;
  }
  while((_Bool)0);
}

// lglgaussoccs
// file lglib.c line 16495
static signed int lglgaussoccs(struct LGL *lgl, signed int a)
{
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(lgl->$anon0.gauss->occs + (signed long int)a);
  return (signed int)return_value_lglcntstk$1;
}

// lglgaussorder
// file lglib.c line 16462
static void lglgaussorder(struct LGL *lgl)
{
  lglrandidxtrav(lgl, lglgaussorderidx);
  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(signed char) /*1ul*/ );
    lgl->$anon0.gauss->eliminated = (signed char *)return_value_lglnew$1;
  }
  while((_Bool)0);
}

// lglgaussorderidx
// file lglib.c line 16455
static signed int lglgaussorderidx(struct LGL *lgl, signed int var)
{
  signed int return_value_lglmtstk$1;
  return_value_lglmtstk$1=lglmtstk(lgl->$anon0.gauss->occs + (signed long int)var);
  if(return_value_lglmtstk$1 == 0)
    lglpushstk(lgl, &lgl->$anon0.gauss->order, var);

  return 1;
}

// lglgaussort
// file lglib.c line 16507
static void lglgaussort(struct LGL *lgl)
{
  signed int max;
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(&lgl->$anon0.gauss->order);
  max = (signed int)return_value_lglcntstk$1;
  signed int rest;
  signed int *lglgaussort$$1$$start;
  rest = max - lgl->$anon0.gauss->next;
  lglgaussort$$1$$start = lgl->$anon0.gauss->order.start + (signed long int)lgl->$anon0.gauss->next;
  lgl->stats->gauss.steps.elim = lgl->stats->gauss.steps.elim + (signed long int)rest;
  signed int return_value_lglcmpgauss$6;
  signed int return_value_lglmtstk$7;
  signed int return_value_lglcmpgauss$9;
  do
  {
    signed int *AA = lglgaussort$$1$$start;
    signed int NN = rest;
    do
    {
      signed int lglgaussort$$1$$1$$1$$L = 0;
      signed int lglgaussort$$1$$1$$1$$R = NN - 1;
      signed int M;
      signed int LL;
      signed int RR;
      signed int lglgaussort$$1$$1$$1$$I;
      if(!(lglgaussort$$1$$1$$1$$R + -lglgaussort$$1$$1$$1$$L >= 11))
        break;

      do
      {
        M = (lglgaussort$$1$$1$$1$$L + lglgaussort$$1$$1$$1$$R) / 2;
        do
        {
          signed int lglgaussort$$1$$1$$1$$1$$1$$1$$TMP = AA[(signed long int)M];
          AA[(signed long int)M] = AA[(signed long int)(lglgaussort$$1$$1$$1$$R - 1)];
          AA[(signed long int)(lglgaussort$$1$$1$$1$$R - 1)] = lglgaussort$$1$$1$$1$$1$$1$$1$$TMP;
        }
        while((_Bool)0);
        do
        {
          signed int return_value_lglcmpgauss$2;
          return_value_lglcmpgauss$2=lglcmpgauss(lgl, *(&AA[(signed long int)lglgaussort$$1$$1$$1$$L]), *(&AA[(signed long int)(lglgaussort$$1$$1$$1$$R - 1)]));
          if(return_value_lglcmpgauss$2 >= 1)
            do
            {
              signed int lglgaussort$$1$$1$$1$$1$$1$$2$$1$$TMP = AA[(signed long int)lglgaussort$$1$$1$$1$$L];
              AA[(signed long int)lglgaussort$$1$$1$$1$$L] = AA[(signed long int)(lglgaussort$$1$$1$$1$$R - 1)];
              AA[(signed long int)(lglgaussort$$1$$1$$1$$R - 1)] = lglgaussort$$1$$1$$1$$1$$1$$2$$1$$TMP;
            }
            while((_Bool)0);

        }
        while((_Bool)0);
        do
        {
          signed int return_value_lglcmpgauss$3;
          return_value_lglcmpgauss$3=lglcmpgauss(lgl, *(&AA[(signed long int)lglgaussort$$1$$1$$1$$L]), *(&AA[(signed long int)lglgaussort$$1$$1$$1$$R]));
          if(return_value_lglcmpgauss$3 >= 1)
            do
            {
              signed int lglgaussort$$1$$1$$1$$1$$1$$3$$1$$TMP = AA[(signed long int)lglgaussort$$1$$1$$1$$L];
              AA[(signed long int)lglgaussort$$1$$1$$1$$L] = AA[(signed long int)lglgaussort$$1$$1$$1$$R];
              AA[(signed long int)lglgaussort$$1$$1$$1$$R] = lglgaussort$$1$$1$$1$$1$$1$$3$$1$$TMP;
            }
            while((_Bool)0);

        }
        while((_Bool)0);
        do
        {
          signed int return_value_lglcmpgauss$4;
          return_value_lglcmpgauss$4=lglcmpgauss(lgl, *(&AA[(signed long int)(lglgaussort$$1$$1$$1$$R - 1)]), *(&AA[(signed long int)lglgaussort$$1$$1$$1$$R]));
          if(return_value_lglcmpgauss$4 >= 1)
            do
            {
              signed int lglgaussort$$1$$1$$1$$1$$1$$4$$1$$TMP = AA[(signed long int)(lglgaussort$$1$$1$$1$$R - 1)];
              AA[(signed long int)(lglgaussort$$1$$1$$1$$R - 1)] = AA[(signed long int)lglgaussort$$1$$1$$1$$R];
              AA[(signed long int)lglgaussort$$1$$1$$1$$R] = lglgaussort$$1$$1$$1$$1$$1$$4$$1$$TMP;
            }
            while((_Bool)0);

        }
        while((_Bool)0);
        do
        {
          signed int lglgaussort$$1$$1$$1$$1$$1$$5$$PIVOT;
          signed int lglgaussort$$1$$1$$1$$1$$1$$5$$J = lglgaussort$$1$$1$$1$$R - 1;
          lglgaussort$$1$$1$$1$$I = (lglgaussort$$1$$1$$1$$L + 1) - 1;
          lglgaussort$$1$$1$$1$$1$$1$$5$$PIVOT = AA[(signed long int)lglgaussort$$1$$1$$1$$1$$1$$5$$J];
          do
          {

          __CPROVER_DUMP_L15:
            ;
            lglgaussort$$1$$1$$1$$I = lglgaussort$$1$$1$$1$$I + 1;
            signed int return_value_lglcmpgauss$5;
            return_value_lglcmpgauss$5=lglcmpgauss(lgl, *(&AA[(signed long int)lglgaussort$$1$$1$$1$$I]), *(&lglgaussort$$1$$1$$1$$1$$1$$5$$PIVOT));
            if(!(return_value_lglcmpgauss$5 >= 0))
              goto __CPROVER_DUMP_L15;

            do
            {
              lglgaussort$$1$$1$$1$$1$$1$$5$$J = lglgaussort$$1$$1$$1$$1$$1$$5$$J - 1;
              return_value_lglcmpgauss$6=lglcmpgauss(lgl, *(&lglgaussort$$1$$1$$1$$1$$1$$5$$PIVOT), *(&AA[(signed long int)lglgaussort$$1$$1$$1$$1$$1$$5$$J]));
              if(return_value_lglcmpgauss$6 >= 0)
                break;

              if(lglgaussort$$1$$1$$1$$1$$1$$5$$J == 1 + lglgaussort$$1$$1$$1$$L)
                break;

            }
            while((_Bool)1);
            if(lglgaussort$$1$$1$$1$$I >= lglgaussort$$1$$1$$1$$1$$1$$5$$J)
              break;

            do
            {
              signed int lglgaussort$$1$$1$$1$$1$$1$$5$$1$$1$$1$$TMP = AA[(signed long int)lglgaussort$$1$$1$$1$$I];
              AA[(signed long int)lglgaussort$$1$$1$$1$$I] = AA[(signed long int)lglgaussort$$1$$1$$1$$1$$1$$5$$J];
              AA[(signed long int)lglgaussort$$1$$1$$1$$1$$1$$5$$J] = lglgaussort$$1$$1$$1$$1$$1$$5$$1$$1$$1$$TMP;
            }
            while((_Bool)0);
          }
          while((_Bool)1);
          do
          {
            signed int TMP = AA[(signed long int)lglgaussort$$1$$1$$1$$I];
            AA[(signed long int)lglgaussort$$1$$1$$1$$I] = AA[(signed long int)(lglgaussort$$1$$1$$1$$R - 1)];
            AA[(signed long int)(lglgaussort$$1$$1$$1$$R - 1)] = TMP;
          }
          while((_Bool)0);
        }
        while((_Bool)0);
        if(!(lglgaussort$$1$$1$$1$$I + -lglgaussort$$1$$1$$1$$L >= lglgaussort$$1$$1$$1$$R + -lglgaussort$$1$$1$$1$$I))
        {
          LL = lglgaussort$$1$$1$$1$$I + 1;
          RR = lglgaussort$$1$$1$$1$$R;
          lglgaussort$$1$$1$$1$$R = lglgaussort$$1$$1$$1$$I - 1;
        }

        else
        {
          LL = lglgaussort$$1$$1$$1$$L;
          RR = lglgaussort$$1$$1$$1$$I - 1;
          lglgaussort$$1$$1$$1$$L = lglgaussort$$1$$1$$1$$I + 1;
        }
        if(lglgaussort$$1$$1$$1$$R + -lglgaussort$$1$$1$$1$$L >= 11)
        {
          lglpushstk(lgl, &lgl->$anon1.sortstk, LL);
          lglpushstk(lgl, &lgl->$anon1.sortstk, RR);
        }

        else
          if(RR + -LL >= 11)
          {
            lglgaussort$$1$$1$$1$$L = LL;
            lglgaussort$$1$$1$$1$$R = RR;
          }

          else
          {
            return_value_lglmtstk$7=lglmtstk(&lgl->$anon1.sortstk);
            if(return_value_lglmtstk$7 == 0)
            {
              lglgaussort$$1$$1$$1$$R=lglpopstk(&lgl->$anon1.sortstk);
              lglgaussort$$1$$1$$1$$L=lglpopstk(&lgl->$anon1.sortstk);
            }

            else
              break;
          }
      }
      while((_Bool)1);
    }
    while((_Bool)0);
    do
    {
      signed int PIVOT;
      signed int L = 0;
      signed int R = NN - 1;
      signed int I;
      signed int J;
      I = R;
      for( ; !(L >= I); I = I - 1)
        do
        {
          signed int return_value_lglcmpgauss$8;
          return_value_lglcmpgauss$8=lglcmpgauss(lgl, *(&AA[(signed long int)(I - 1)]), *(&AA[(signed long int)I]));
          if(return_value_lglcmpgauss$8 >= 1)
            do
            {
              signed int lglgaussort$$1$$1$$2$$1$$1$$1$$TMP = AA[(signed long int)(I - 1)];
              AA[(signed long int)(I - 1)] = AA[(signed long int)I];
              AA[(signed long int)I] = lglgaussort$$1$$1$$2$$1$$1$$1$$TMP;
            }
            while((_Bool)0);

        }
        while((_Bool)0);
      I = L + 2;
      for( ; R >= I; I = I + 1)
      {
        J = I;
        PIVOT = AA[(signed long int)I];
        do
        {
          return_value_lglcmpgauss$9=lglcmpgauss(lgl, *(&PIVOT), *(&AA[(signed long int)(J - 1)]));
          if(return_value_lglcmpgauss$9 >= 0)
            break;

          AA[(signed long int)J] = AA[(signed long int)(J - 1)];
          J = J - 1;
        }
        while((_Bool)1);
        AA[(signed long int)J] = PIVOT;
      }
    }
    while((_Bool)0);

  __CPROVER_DUMP_L37:
    ;
  }
  while((_Bool)0);
  lglprt(lgl, 3, "[gauss-%d] sorted %d remaining variables", lgl->stats->gauss.count, rest);
}

// lglgausspickeqn
// file lglib.c line 16519
static signed int lglgausspickeqn(struct LGL *lgl, signed int pivot)
{
  signed int res;
  signed int cand;
  signed int weight;
  signed int size;
  signed int tmp;
  signed int other;
  signed int found;
  const signed int *p;
  const signed int *e;
  const signed int *q;
  struct Stk *occs;
  res = -1;
  weight = 0x7fffffff;
  size = 0x7fffffff;
  occs = lgl->$anon0.gauss->occs + (signed long int)pivot;
  p = occs->start;
  for( ; !(p >= occs->top); p = p + 1l)
  {
    cand = *p;
    e = lgl->$anon0.gauss->xors.start + (signed long int)cand;
    tmp = 0;
    found = tmp;
    lgl->stats->gauss.steps.elim = lgl->stats->gauss.steps.elim + 1l;
    q = e;
    do
    {
      other = *q;
      if(!(other >= 2))
        break;

      if(!(lgl->$anon0.gauss->eliminated[(signed long int)other] == 0))
        break;

      if(other == pivot)
        found = found + 1;

      else
      {
        signed int return_value_lglgaussoccs$1;
        return_value_lglgaussoccs$1=lglgaussoccs(lgl, other);
        tmp = tmp + (return_value_lglgaussoccs$1 - 1);
      }
      q = q + 1l;
    }
    while((_Bool)1);
    if(!(other >= 2))
    {
      if(!(q - e >= (signed long int)size) || !(res >= 0))
      {
        if(!(q - e == (signed long int)size) || !(res >= 0) || !(tmp >= weight))
        {
          weight = tmp;
          size = (signed int)(q - e);
          res = cand;
        }

      }

    }

  }
  if(res >= 0)

    __CPROVER_DUMP_L8:
      ;

  else

    __CPROVER_DUMP_L9:
      ;
  return res;
}

// lglgaussreset
// file lglib.c line 16683
static void lglgaussreset(struct LGL *lgl)
{
  if(!(lgl->$anon0.gauss->occs == ((struct Stk *)NULL)))
    lglgaussdisconnect(lgl);

  if(!(lgl->$anon0.gauss->eliminated == ((signed char *)NULL)))
    do
    {
      lgldel(lgl, (void *)lgl->$anon0.gauss->eliminated, (unsigned long int)lgl->nvars * sizeof(signed char) /*1ul*/ );
      lgl->$anon0.gauss->eliminated = ((signed char *)NULL);
    }
    while((_Bool)0);

  lglrelstk(lgl, &lgl->$anon0.gauss->xors);
  lglrelstk(lgl, &lgl->$anon0.gauss->order);
  do
  {
    lgldel(lgl, (void *)lgl->$anon0.gauss, (unsigned long int)1 * sizeof(struct Gauss) /*72ul*/ );
    lgl->$anon0.gauss = ((struct Gauss *)NULL);
  }
  while((_Bool)0);
}

// lglgaussubcls
// file lglib.c line 16301
static signed int lglgaussubcls(struct LGL *lgl, unsigned long int signs, const signed int *c)
{
  signed int res;
  res=lglgaussubclsaux(lgl, signs, c);
  signed int lit;
  const signed int *p = c;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    lglunmark(lgl, lit);
    p = p + 1l;
  }
  while((_Bool)1);
  return res;
}

// lglgaussubclsaux
// file lglib.c line 16251
static signed int lglgaussubclsaux(struct LGL *lgl, unsigned long int signs, const signed int *c)
{
  signed int lit;
  signed int i;
  signed int min;
  signed int minocc;
  signed int tmpocc;
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  signed int red;
  signed int lidx;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *d;
  const signed int *q;
  struct HTS *hts;
  minocc = 0x7fffffff;
  i = 0;
  min = i;
  lgl->stats->gauss.steps.extr = lgl->stats->gauss.steps.extr + 1l;
  p = c;
  signed int tmp_post$2;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    signed int return_value_lglmarked$1;
    return_value_lglmarked$1=lglmarked(lgl, lit);
    if(!(return_value_lglmarked$1 == 0))
      return 0;

    tmp_post$2 = i;
    i = i + 1;
    if(!((1ull << tmp_post$2 & signs) == 0ul))
      lit = -lit;

    lglsignedmark(lgl, lit);
    signed int return_value_lglocc$3;
    return_value_lglocc$3=lglocc(lgl, lit);
    struct HTS *return_value_lglhts$4;
    return_value_lglhts$4=lglhts(lgl, lit);
    tmpocc = return_value_lglocc$3 + return_value_lglhts$4->count;
    if(!(tmpocc >= minocc))
    {
      minocc = tmpocc;
      min = lit;
    }

    p = p + 1l;
  }
  while((_Bool)1);
  hts=lglhts(lgl, min);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  p = w;
  signed int return_value_lglsignedmarked$8;
  for( ; !(p >= eow); p = p + 1l)
  {
    lgl->stats->gauss.steps.extr = lgl->stats->gauss.steps.extr + 1l;
    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(!(tag == LRGCS))
    {
      if(tag == BINCS)
      {
        other = blit >> RMSHFT;
        signed int return_value_lglsignedmarked$5;
        return_value_lglsignedmarked$5=lglsignedmarked(lgl, other);
        if(!(return_value_lglsignedmarked$5 == 0))
          return 1;

      }

      else
        if(tag == TRNCS)
        {
          other = blit >> RMSHFT;
          signed int return_value_lglsignedmarked$6;
          return_value_lglsignedmarked$6=lglsignedmarked(lgl, other);
          if(return_value_lglsignedmarked$6 == 0)
            goto __CPROVER_DUMP_L15;

          other2 = *p;
          signed int return_value_lglsignedmarked$7;
          return_value_lglsignedmarked$7=lglsignedmarked(lgl, other2);
          if(!(return_value_lglsignedmarked$7 == 0))
            return 1;

        }

        else
        {
          red = blit & REDCS;
          lidx = blit >> RMSHFT;
          d=lglidx2lits(lgl, OCCS, red, lidx);
          q = d;
          do
          {
            other = *q;
            if(other == 0)
              break;

            return_value_lglsignedmarked$8=lglsignedmarked(lgl, other);
            if(return_value_lglsignedmarked$8 == 0)
              break;

            q = q + 1l;
          }
          while((_Bool)1);
          if(other == 0)
            return 1;

        }
    }


  __CPROVER_DUMP_L15:
    ;
  }
  return 0;
}

// lglgaussubst
// file lglib.c line 16569
static void lglgaussubst(struct LGL *lgl, signed int pivot, signed int subst)
{
  struct Stk *occs = lgl->$anon0.gauss->occs + (signed long int)pivot;
  signed int eqn;
  signed int rhs;
  signed int res;
  const signed int *p;
  signed int *q;
  unsigned long int return_value_lglcntstk$1;
  signed int return_value_lglmarked$5;
  signed int *tmp_post$4;
  do
  {
    return_value_lglcntstk$1=lglcntstk(occs);
    if(!(return_value_lglcntstk$1 >= 2ul))
      break;

    signed int return_value_lglterminate$2;
    return_value_lglterminate$2=lglterminate(lgl);
    if(!(return_value_lglterminate$2 == 0))
      goto __CPROVER_DUMP_L15;

    eqn = occs->start[(signed long int)0];
    if(eqn == subst)
      eqn = occs->start[(signed long int)1];


  __CPROVER_DUMP_L3:
    ;
    rhs=lglgaussaddeqn(lgl, eqn);

  __CPROVER_DUMP_L4:
    ;
    signed int return_value_lglgaussaddeqn$3;
    return_value_lglgaussaddeqn$3=lglgaussaddeqn(lgl, subst);
    if(!(return_value_lglgaussaddeqn$3 == 0))
      rhs = (signed int)!(rhs != 0);

    lglgaussdiseqn(lgl, eqn);
    q = lgl->clause.start;
    p = q;
    for( ; !(p >= lgl->clause.top); p = p + 1l)
    {
      return_value_lglmarked$5=lglmarked(lgl, *p);
      if(!(return_value_lglmarked$5 == 0))
      {
        tmp_post$4 = q;
        q = q + 1l;
        *tmp_post$4 = *p;
      }

    }
    lgl->clause.top = q;
    signed int return_value_lglmtstk$7;
    return_value_lglmtstk$7=lglmtstk(&lgl->clause);
    if(return_value_lglmtstk$7 == 0)
    {
      unsigned long int return_value_lglcntstk$6;
      return_value_lglcntstk$6=lglcntstk(&lgl->$anon0.gauss->xors);
      res = (signed int)return_value_lglcntstk$6;
      lglcpystk(lgl, &lgl->$anon0.gauss->xors, &lgl->clause);
      lglpushstk(lgl, &lgl->$anon0.gauss->xors, rhs);

    __CPROVER_DUMP_L9:
      ;
      lglgaussconeqn(lgl, res);
    }

    else
      if(rhs == 0)

        __CPROVER_DUMP_L11:
          ;

      else
      {

      __CPROVER_DUMP_L12:
        ;
        lgl->mt = 1;
      }
    lglpopnunmarkstk(lgl, &lgl->clause);
  }
  while((_Bool)1);

__CPROVER_DUMP_L15:
  ;
}

// lglgc
// file lglib.c line 7634
static void lglgc(struct LGL *lgl)
{
  unsigned long int return_value_lglcntstk$2;
  if(lgl->mt == 0)
  {
    lglchkred(lgl);
    signed int return_value_lglgcnotnecessary$1;
    return_value_lglgcnotnecessary$1=lglgcnotnecessary(lgl);
    if(return_value_lglgcnotnecessary$1 == 0)
    {
      lglstart(lgl, &lgl->times->gc);
      lglchkbcpclean(lgl, "gc");
      lglrep(lgl, 2, (char)103);
      lgl->stats->gcs = lgl->stats->gcs + 1;
      if(lgl->level >= 1)
        lglbacktrack(lgl, 0);

      do
      {
        lgldis(lgl);
        lglcon(lgl);
        if(!(lgl->mt == 0))
          break;

        if(lgl->next2 == lgl->next)
        {
          return_value_lglcntstk$2=lglcntstk(&lgl->trail);
          if((unsigned long int)lgl->next == return_value_lglcntstk$2)
            break;

        }

        signed int return_value_lglbcp$3;
        return_value_lglbcp$3=lglbcp(lgl);
        if(return_value_lglbcp$3 == 0)
        {

        __CPROVER_DUMP_L3:
          ;
          lgl->mt = 1;
          break;
        }

      }
      while((_Bool)1);
      lglcount(lgl);
      lglmap(lgl);
      lglcompact(lgl);
      lgl->limits->gc.fixed = (signed long int)lgl->stats->fixed.sum;
      lglchkred(lgl);
      lglrep(lgl, 2, (char)99);
      lglstop(lgl);
    }

  }

}

// lglgcd
// file lglib.c line 3319
static unsigned int lglgcd(unsigned int a, unsigned int b)
{
  unsigned int tmp;
  if(!(a >= b))
    do
    {
      unsigned int TMP = a;
      a = b;
      b = TMP;
    }
    while((_Bool)0);

  for( ; !(b == 0u); a = tmp)
  {
    tmp = b;
    b = a % b;
  }
  return a;
}

// lglgcnotnecessary
// file lglib.c line 7603
static signed int lglgcnotnecessary(struct LGL *lgl)
{
  if(!(lgl->forcegc == 0))
    return 0;

  else
    if(!(lgl->notfullyconnected == 0))
      return 0;

    else
      return (signed int)((signed long int)lgl->stats->fixed.sum <= lgl->limits->gc.fixed);
}

// lglgdump
// file lglib.c line 16237
static void lglgdump(struct LGL *lgl)
{
  ;
}

// lglgetconfs
// file lglib.h line 282
signed long int lglgetconfs(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglgetconfs");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  return lgl->stats->confs;
}

// lglgetdecs
// file lglib.h line 283
signed long int lglgetdecs(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglgetdecs");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  return lgl->stats->decisions;
}

// lglgetdom
// file lglib.c line 2591
static signed int lglgetdom(struct LGL *lgl, signed int lit)
{
  signed int res;
  signed int return_value_lglulit$1;
  return_value_lglulit$1=lglulit(lit);
  res = lgl->doms[(signed long int)return_value_lglulit$1];
  return res;
}

// lglgetenv
// file lglib.c line 1606
static void lglgetenv(struct LGL *lgl, struct Opt *opt, const char *lname)
{
  const char *q;
  const char *valstr;
  char uname[40l];
  char *p;
  signed int newval;
  signed int oldval;
  uname[(signed long int)0] = (char)76;
  uname[(signed long int)1] = (char)71;
  uname[(signed long int)2] = (char)76;
  p = uname + (signed long int)3;
  q = lname;
  char *tmp_post$1;
  signed int tmp_statement_expression$2;
  signed int tmp_if_expr$4;
  const signed int **return_value___ctype_toupper_loc$3;
  const signed int **return_value___ctype_toupper_loc$5;
  for( ; !(*q == 0); q = q + 1l)
  {
    tmp_post$1 = p;
    p = p + 1l;
    signed int __res;
    return_value___ctype_toupper_loc$5=__ctype_toupper_loc();
    __res = (*return_value___ctype_toupper_loc$5)[(signed long int)(signed int)*q];
    tmp_statement_expression$2 = __res;
    *tmp_post$1 = (char)tmp_statement_expression$2;
  }
  *p = (char)0;
  valstr=getenv(uname);
  if(!(valstr == ((const char *)NULL)))
  {
    oldval = opt->val;
    newval=atoi$link1(valstr);
    if(!(newval >= opt->min))
      newval = opt->min;

    if(!(opt->max >= newval))
      newval = opt->max;

    if(!(newval == oldval))
    {
      opt->val = newval;
      while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      {
        lgltrapi(lgl, "option %s %d", lname, newval);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        fprintf(stderr, "liblgl.a: %s:%d: %s: Coverage target `%s' reached.", (const void *)"lglgetenv", 1628, (const void *)"lglib.c", (const void *)"lgl->clone");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputc(10, stderr);
        fflush(stderr);
        abort();
        break;
      }
      if(!(lgl->clone == ((struct LGL *)NULL)))
        lglsetopt(lgl->clone, lname, newval);

    }

  }

}

// lglgetime
// file lglib.c line 4956
static double lglgetime(struct LGL *lgl)
{
  _Bool tmp_if_expr$2;
  if(!(lgl->cbs == ((struct Cbs *)NULL)))
    tmp_if_expr$2 = lgl->cbs->getime != ((double (*)(void))NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  double return_value;
  double return_value_lglprocesstime$1;
  if(tmp_if_expr$2)
  {
    return_value=lgl->cbs->getime();
    return return_value;
  }

  else
  {
    return_value_lglprocesstime$1=lglprocesstime();
    return return_value_lglprocesstime$1;
  }
}

// lglgetopt
// file lglib.c line 2263
signed int lglgetopt(struct LGL *lgl, const char *opt)
{
  struct Opt *o;
  o=lgligetopt(lgl, opt);
  signed int tmp_if_expr$1;
  if(!(o == ((struct Opt *)NULL)))
    tmp_if_expr$1 = o->val;

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// lglgetoptminmax
// file lglib.c line 2268
signed int lglgetoptminmax(struct LGL *lgl, const char *opt, signed int *min_ptr, signed int *max_ptr)
{
  struct Opt *o;
  o=lgligetopt(lgl, opt);
  if(o == ((struct Opt *)NULL))
    return 0;

  else
  {
    if(!(min_ptr == ((signed int *)NULL)))
      *min_ptr = o->min;

    if(!(max_ptr == ((signed int *)NULL)))
      *max_ptr = o->max;

    return o->val;
  }
}

// lglgetout
// file lglib.c line 2244
struct _IO_FILE * lglgetout(struct LGL *lgl)
{
  return lgl->out;
}

// lglgetprefix
// file lglib.c line 2251
const char * lglgetprefix(struct LGL *lgl)
{
  return lgl->prefix;
}

// lglgetprops
// file lglib.h line 284
signed long int lglgetprops(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglgetprops");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  return lgl->stats->props.search + lgl->stats->props.simp;
}

// lglgidx2gat
// file lglib.c line 12368
static struct Gat * lglgidx2gat(struct LGL *lgl, signed int gidx)
{
  return lgl->$anon0.cgr->gates + (signed long int)gidx;
}

// lglgluestats
// file lglib.c line 18095
static void lglgluestats(struct LGL *lgl)
{
  signed long int added;
  signed long int reduced;
  signed long int forcing;
  signed long int resolved;
  signed long int conflicts;
  signed long int wadded;
  signed long int wreduced;
  signed long int wforcing;
  signed long int wresolved;
  signed long int wconflicts;
  signed long int avgadded;
  signed long int avgreduced;
  signed long int avgforcing;
  signed long int avgresolved;
  signed long int avgconflicts;
  double madded;
  double mreduced;
  double mforcing;
  double mresolved;
  double mconflicts;
  double vadded;
  double vreduced;
  double vforcing;
  double vresolved;
  double vconflicts;
  double sadded;
  double sreduced;
  double sforcing;
  double sresolved;
  double sconflicts;
  struct Stats *s = lgl->stats;
  signed int glue;
  lglprs(lgl, "");
  lglprs(lgl, "scaledglue%7s %3s %9s %3s %9s %3s %9s %3s %9s", (const void *)"added", (const void *)"", (const void *)"reduced", (const void *)"", (const void *)"forcing", (const void *)"", (const void *)"resolved", (const void *)"", (const void *)"conflicts");
  conflicts = (signed long int)0;
  resolved = conflicts;
  forcing = resolved;
  reduced = forcing;
  added = reduced;
  wconflicts = (signed long int)0;
  wresolved = wconflicts;
  wforcing = wresolved;
  wreduced = wforcing;
  wadded = wreduced;
  glue = 0;
  for( ; !(glue >= 16); glue = glue + 1)
  {
    added = added + s->lir[(signed long int)glue].added;
    reduced = reduced + s->lir[(signed long int)glue].reduced;
    forcing = forcing + s->lir[(signed long int)glue].forcing;
    resolved = resolved + s->lir[(signed long int)glue].resolved;
    conflicts = conflicts + s->lir[(signed long int)glue].conflicts;
    wadded = wadded + (signed long int)glue * s->lir[(signed long int)glue].added;
    wreduced = wreduced + (signed long int)glue * s->lir[(signed long int)glue].reduced;
    wforcing = wforcing + (signed long int)glue * s->lir[(signed long int)glue].forcing;
    wresolved = wresolved + (signed long int)glue * s->lir[(signed long int)glue].resolved;
    wconflicts = wconflicts + (signed long int)glue * s->lir[(signed long int)glue].conflicts;
  }
  avgadded = added != 0l ? (((signed long int)10 * wadded) / added + (signed long int)5) / (signed long int)10 : (signed long int)0;
  avgreduced = reduced != 0l ? (((signed long int)10 * wreduced) / reduced + (signed long int)5) / (signed long int)10 : (signed long int)0;
  avgforcing = forcing != 0l ? (((signed long int)10 * wforcing) / forcing + (signed long int)5) / (signed long int)10 : (signed long int)0;
  avgresolved = resolved != 0l ? (((signed long int)10 * wresolved) / resolved + (signed long int)5) / (signed long int)10 : (signed long int)0;
  avgconflicts = conflicts != 0l ? (((signed long int)10 * wconflicts) / conflicts + (signed long int)5) / (signed long int)10 : (signed long int)0;
  lglprs(lgl, "");
  lglprs(lgl, "all %9lld %3.0f %9lld %3.0f %9lld %3.0f %9lld %3.0f %9lld %3.0f", (signed long long int)added, 100.0, (signed long long int)reduced, 100.0, (signed long long int)forcing, 100.0, (signed long long int)resolved, 100.0, (signed long long int)conflicts, 100.0);
  lglprs(lgl, "");
  glue = 0;
  for( ; !(glue >= 16); glue = glue + 1)
  {
    double return_value_lglpcnt$1;
    return_value_lglpcnt$1=lglpcnt((double)s->lir[(signed long int)glue].added, (double)added);
    double return_value_lglpcnt$2;
    return_value_lglpcnt$2=lglpcnt((double)s->lir[(signed long int)glue].reduced, (double)reduced);
    double return_value_lglpcnt$3;
    return_value_lglpcnt$3=lglpcnt((double)s->lir[(signed long int)glue].forcing, (double)forcing);
    double return_value_lglpcnt$4;
    return_value_lglpcnt$4=lglpcnt((double)s->lir[(signed long int)glue].resolved, (double)resolved);
    double return_value_lglpcnt$5;
    return_value_lglpcnt$5=lglpcnt((double)s->lir[(signed long int)glue].conflicts, (double)conflicts);
    lglprs(lgl, "%2d  %9lld %3.0f%c%9lld %3.0f%c%9lld %3.0f%c%9lld %3.0f%c%9lld %3.0f%c", glue, (signed long long int)s->lir[(signed long int)glue].added, return_value_lglpcnt$1, (signed long int)glue == avgadded ? 60 : 32, (signed long long int)s->lir[(signed long int)glue].reduced, return_value_lglpcnt$2, (signed long int)glue == avgreduced ? 60 : 32, (signed long long int)s->lir[(signed long int)glue].forcing, return_value_lglpcnt$3, (signed long int)glue == avgforcing ? 60 : 32, (signed long long int)s->lir[(signed long int)glue].resolved, return_value_lglpcnt$4, (signed long int)glue == avgresolved ? 60 : 32, (signed long long int)s->lir[(signed long int)glue].conflicts, return_value_lglpcnt$5, (signed long int)glue == avgconflicts ? 60 : 32);
  }
  lglprs(lgl, "");
  madded=lglavg((double)wadded, (double)added);
  mreduced=lglavg((double)wreduced, (double)reduced);
  mforcing=lglavg((double)wforcing, (double)forcing);
  mresolved=lglavg((double)wresolved, (double)resolved);
  mconflicts=lglavg((double)wconflicts, (double)conflicts);
  lglprs(lgl, "avg  %14.1f%14.1f%14.1f%14.1f%14.1f", madded, mreduced, mforcing, mresolved, mconflicts);
  vconflicts = (double)0;
  vresolved = vconflicts;
  vforcing = vresolved;
  vreduced = vforcing;
  vadded = vreduced;
  glue = 0;
  for( ; !(glue >= 16); glue = glue + 1)
  {
    double return_value_lglsqr$6;
    return_value_lglsqr$6=lglsqr((double)glue - madded);
    vadded = vadded + (double)s->lir[(signed long int)glue].added * return_value_lglsqr$6;
    double return_value_lglsqr$7;
    return_value_lglsqr$7=lglsqr((double)glue - mreduced);
    vreduced = vreduced + (double)s->lir[(signed long int)glue].reduced * return_value_lglsqr$7;
    double return_value_lglsqr$8;
    return_value_lglsqr$8=lglsqr((double)glue - mforcing);
    vforcing = vforcing + (double)s->lir[(signed long int)glue].forcing * return_value_lglsqr$8;
    double return_value_lglsqr$9;
    return_value_lglsqr$9=lglsqr((double)glue - mresolved);
    vresolved = vresolved + (double)s->lir[(signed long int)glue].resolved * return_value_lglsqr$9;
    double return_value_lglsqr$10;
    return_value_lglsqr$10=lglsqr((double)glue - mconflicts);
    vconflicts = vconflicts + (double)s->lir[(signed long int)glue].conflicts * return_value_lglsqr$10;
  }
  double return_value_lglavg$11;
  return_value_lglavg$11=lglavg(vadded, (double)added);
  sadded=sqrt(return_value_lglavg$11);
  double return_value_lglavg$12;
  return_value_lglavg$12=lglavg(vreduced, (double)reduced);
  sreduced=sqrt(return_value_lglavg$12);
  double return_value_lglavg$13;
  return_value_lglavg$13=lglavg(vforcing, (double)forcing);
  sforcing=sqrt(return_value_lglavg$13);
  double return_value_lglavg$14;
  return_value_lglavg$14=lglavg(vresolved, (double)resolved);
  sresolved=sqrt(return_value_lglavg$14);
  double return_value_lglavg$15;
  return_value_lglavg$15=lglavg(vconflicts, (double)conflicts);
  sconflicts=sqrt(return_value_lglavg$15);
  lglprs(lgl, "std  %14.1f%14.1f%14.1f%14.1f%14.1f", sadded, sreduced, sforcing, sresolved, sconflicts);
}

// lglgoccsmatchcand
// file lglib.c line 13092
static signed int lglgoccsmatchcand(struct LGL *lgl, signed int a, signed int b)
{
  struct Gat *g;
  g=lglgidx2gat(lgl, a);
  struct Gat *h;
  h=lglgidx2gat(lgl, b);
  _Bool tmp_if_expr$1;
  if(g->tag == h->tag)
    tmp_if_expr$1 = g->size == h->size ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = g->minrhs == h->minrhs ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  return (signed int)tmp_if_expr$2;
}

// lglhasbin
// file lglib.c line 8465
static signed int lglhasbin(struct LGL *lgl, signed int a, signed int b)
{
  const signed int *w;
  const signed int *eow;
  const signed int *p;
  signed int blit;
  signed int tag;
  signed int other;
  struct HTS *ha;
  struct HTS *hb;
  ha=lglhts(lgl, a);
  hb=lglhts(lgl, b);
  if(!(hb->count >= ha->count))
  {
    do
    {
      signed int TMP = a;
      a = b;
      b = TMP;
    }
    while((_Bool)0);
    do
    {
      struct HTS *lglhasbin$$1$$1$$2$$TMP = ha;
      ha = hb;
      hb = lglhasbin$$1$$1$$2$$TMP;
    }
    while((_Bool)0);
  }

  w=lglhts2wchs(lgl, ha);
  eow = w + (signed long int)ha->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(!(tag == OCCS))
    {
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      else
      {
        other = blit >> RMSHFT;
        if(other == b)
          return 1;

      }
    }

  }
  return 0;
}

// lglhasbingate
// file lglib.c line 12431
static signed int lglhasbingate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int rhs0, signed int rhs1)
{
  const signed int *p;
  struct Stk *s;
  struct Gat *g;
  lhs=lglcgreprnotconst(lgl, lhs);
  rhs0=lglcgreprnotconst(lgl, rhs0);
  rhs1=lglcgreprnotconst(lgl, rhs1);
  signed int return_value_abs$1;
  return_value_abs$1=abs(lhs);
  s = lgl->$anon0.cgr->goccs + (signed long int)return_value_abs$1;
  p = s->start;
  for( ; !(p >= s->top); p = p + 1l)
  {
    g=lglgidx2gat(lgl, *p);
    if((signed int)g->tag == (signed int)tag)
    {
      if((signed int)g->size == 2)
      {
        if(g->lhs == lhs)
        {
          signed int return_value_lglcgeq$2;
          return_value_lglcgeq$2=lglcgeq(lgl, g->$anon0.lits[(signed long int)0], rhs0);
          if(!(return_value_lglcgeq$2 == 0))
          {
            signed int return_value_lglcgeq$3;
            return_value_lglcgeq$3=lglcgeq(lgl, g->$anon0.lits[(signed long int)1], rhs1);
            if(!(return_value_lglcgeq$3 == 0))
              return 1;

          }

        }

      }

    }

  }
  return 0;
}

// lglhasbins
// file lglib.c line 7787
static signed int lglhasbins(struct LGL *lgl, signed int lit)
{
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  signed int val;
  signed int val2;
  signed int implied;
  const signed int *p;
  const signed int *w;
  const signed int *eos;
  const signed int *q;
  struct HTS *hts;
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  eos = w + (signed long int)hts->count;
  p = w;
  const signed int *tmp_post$4;
  for( ; !(p >= eos); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(tag == BINCS)
    {
      other = blit >> RMSHFT;
      signed char return_value_lglval$1;
      return_value_lglval$1=lglval(lgl, other);
      val = (signed int)return_value_lglval$1;
      if(val == 0)
        return 1;

    }

    else
      if(tag == TRNCS)
      {
        other = blit >> RMSHFT;
        p = p + 1l;
        other2 = *p;
        signed char return_value_lglval$2;
        return_value_lglval$2=lglval(lgl, other);
        val = (signed int)return_value_lglval$2;
        signed char return_value_lglval$3;
        return_value_lglval$3=lglval(lgl, other2);
        val2 = (signed int)return_value_lglval$3;
        if(val >= 1 || val2 >= 1)
          goto __CPROVER_DUMP_L14;

        if(val == 0 && !(val2 >= 0))
          return 1;

        if(val2 == 0 && !(val >= 0))
          return 1;

      }

      else
      {
        p = p + 1l;
        q=lglidx2lits(lgl, LRGCS, blit & REDCS, *p);
        implied = 0;
        do
        {
          tmp_post$4 = q;
          q = q + 1l;
          other = *tmp_post$4;
          if(other == 0)
            break;

          if(!(other == lit))
          {
            signed char return_value_lglval$5;
            return_value_lglval$5=lglval(lgl, other);
            val = (signed int)return_value_lglval$5;
            if(val >= 1)
              break;

            if(val >= 0)
            {
              if(!(implied == 0))
                break;

              implied = other;
            }

          }

        }
        while((_Bool)1);
        if(other == 0)
        {
          if(!(implied == 0))
            return 1;

        }

      }

  __CPROVER_DUMP_L14:
    ;
  }
  return 0;
}

// lglhasitegate
// file lglib.c line 12383
static signed int lglhasitegate(struct LGL *lgl, signed int lhs, signed int cond, signed int pos, signed int neg)
{
  const signed int *p;
  signed int repr;
  struct Stk *s;
  repr=lglcgrepr(lgl, lhs);
  signed int return_value_abs$1;
  return_value_abs$1=abs(repr);
  if(return_value_abs$1 == 1)
    repr = lhs;

  signed int return_value_abs$2;
  return_value_abs$2=abs(repr);
  s = lgl->$anon0.cgr->goccs + (signed long int)return_value_abs$2;
  struct Gat *g;
  p = s->start;
  for( ; !(p >= s->top); p = p + 1l)
  {
    g=lglgidx2gat(lgl, *p);
    if((signed int)g->tag == ITETAG)
    {
      if(g->lhs == lhs)
      {
        signed int return_value_lglcgeq$3;
        return_value_lglcgeq$3=lglcgeq(lgl, g->$anon0.$anon1.cond, cond);
        if(!(return_value_lglcgeq$3 == 0))
        {
          signed int return_value_lglcgeq$4;
          return_value_lglcgeq$4=lglcgeq(lgl, g->$anon0.$anon1.pos, pos);
          if(!(return_value_lglcgeq$4 == 0))
          {
            signed int return_value_lglcgeq$5;
            return_value_lglcgeq$5=lglcgeq(lgl, g->$anon0.$anon1.neg, neg);
            if(!(return_value_lglcgeq$5 == 0))
              return 1;

          }

        }

      }

    }

  }
  return 0;
}

// lglhasopt
// file lglib.h line 121
signed int lglhasopt(struct LGL *lgl, const char *opt)
{
  struct Opt *o;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglhasopt");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  o = &lgl->opts->beforefirst + (signed long int)1;
  signed int tmp_statement_expression$1;
  for( ; &lgl->opts->afterlast + -1l >= o; o = o + 1l)
  {
    if(opt[1l] == 0)
    {
      if(o->shrt == *opt)
        return 1;

    }

    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$2;
    return_value___builtin_strcmp$2=__builtin_strcmp(o->lng, opt);
    tmp_statement_expression$1 = return_value___builtin_strcmp$2;
    if(tmp_statement_expression$1 == 0)
      return 1;

  }
  return 0;
}

// lglhastrn
// file lglib.c line 10204
static signed int lglhastrn(struct LGL *lgl, signed int a, signed int b, signed int c)
{
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  const signed int *w;
  const signed int *eow;
  const signed int *p;
  struct HTS *ha;
  struct HTS *hb;
  struct HTS *hc;
  ha=lglhts(lgl, a);
  hb=lglhts(lgl, b);
  if(!(hb->count >= ha->count))
  {
    do
    {
      signed int lglhastrn$$1$$1$$1$$TMP = a;
      a = b;
      b = lglhastrn$$1$$1$$1$$TMP;
    }
    while((_Bool)0);
    do
    {
      struct HTS *lglhastrn$$1$$1$$2$$TMP = ha;
      ha = hb;
      hb = lglhastrn$$1$$1$$2$$TMP;
    }
    while((_Bool)0);
  }

  hc=lglhts(lgl, c);
  if(!(hc->count >= ha->count))
  {
    do
    {
      signed int TMP = a;
      a = c;
      c = TMP;
    }
    while((_Bool)0);
    do
    {
      struct HTS *lglhastrn$$1$$2$$2$$TMP = ha;
      ha = hc;
      hc = lglhastrn$$1$$2$$2$$TMP;
    }
    while((_Bool)0);
  }

  w=lglhts2wchs(lgl, ha);
  eow = w + (signed long int)ha->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(!(tag == OCCS))
    {
      if(tag == BINCS)
      {
        other = blit >> RMSHFT;
        if(other == b || other == c)
          return 1;

      }

      else
      {
        if(tag == TRNCS || tag == LRGCS)
          p = p + 1l;

        if(!(tag == LRGCS))
        {
          other = blit >> RMSHFT;
          if(other == b || other == c)
          {
            other2 = *p;
            if(other2 == b || other2 == c)
              return 1;

          }

        }

      }
    }

  }
  if(!(hc->count >= hb->count))
  {
    do
    {
      signed int lglhastrn$$1$$4$$1$$TMP = b;
      b = c;
      c = lglhastrn$$1$$4$$1$$TMP;
    }
    while((_Bool)0);
    do
    {
      struct HTS *lglhastrn$$1$$4$$2$$TMP = hb;
      hb = hc;
      hc = lglhastrn$$1$$4$$2$$TMP;
    }
    while((_Bool)0);
  }

  w=lglhts2wchs(lgl, hb);
  eow = w + (signed long int)hb->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(!(tag == OCCS))
    {
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      else
      {
        other = blit >> RMSHFT;
        if(other == c)
          return 1;

      }
    }

  }
  return 0;
}

// lglhbred
// file lglib.c line 4355
static signed int lglhbred(struct LGL *lgl, signed int subsumed, signed int red)
{
  signed int res = subsumed != 0 ? red : REDCS;

__CPROVER_DUMP_L1:
  ;
  return res;
}

// lglheight
// file lglib.c line 5018
static double lglheight(struct LGL *lgl)
{
  double return_value_lglavg$1;
  return_value_lglavg$1=lglavg((double)lgl->stats->height, (double)lgl->stats->decisions);
  return return_value_lglavg$1;
}

// lglhts
// file lglib.c line 2599
static struct HTS * lglhts(struct LGL *lgl, signed int lit)
{
  struct DVar *return_value_lgldvar$1;
  return_value_lgldvar$1=lgldvar(lgl, lit);
  return return_value_lgldvar$1->hts + (signed long int)(lit < 0);
}

// lglhts2wchs
// file lglib.c line 2603
static signed int * lglhts2wchs(struct LGL *lgl, struct HTS *hts)
{
  signed int *res = lgl->wchs->stk.start + (signed long int)hts->offset;
  return res;
}

// lgli2m
// file lglib.c line 9273
static signed int lgli2m(struct LGL *lgl, signed int ilit)
{
  struct AVar *av;
  av=lglavar(lgl, ilit);
  signed int res = av->mark;
  if(res == 0)
  {
    unsigned long int return_value_lglcntstk$1;
    return_value_lglcntstk$1=lglcntstk(&lgl->seen);
    res = (signed int)(return_value_lglcntstk$1 + (unsigned long int)1);
    av->mark = res;
    signed int return_value_abs$2;
    return_value_abs$2=abs(ilit);
    lglpushstk(lgl, &lgl->seen, return_value_abs$2);
    lglpushstk(lgl, &lgl->$anon0.elm->lsigs, 0);
    lglpushstk(lgl, &lgl->$anon0.elm->lsigs, 0);
    lglpushstk(lgl, &lgl->$anon0.elm->noccs, 0);
    lglpushstk(lgl, &lgl->$anon0.elm->noccs, 0);
    lglpushstk(lgl, &lgl->$anon0.elm->mark, 0);
    lglpushstk(lgl, &lgl->$anon0.elm->mark, 0);
    lglpushstk(lgl, &lgl->$anon0.elm->occs, 0);
    lglpushstk(lgl, &lgl->$anon0.elm->occs, 0);
    signed int return_value_abs$3;
    return_value_abs$3=abs(ilit);
    lglpushstk(lgl, &lgl->$anon0.elm->m2i, return_value_abs$3);
  }


__CPROVER_DUMP_L1:
  ;
  if(!(ilit >= 0))
    res = -res;

  return res;
}

// lgliadd
// file lglib.c line 3685
static void lgliadd(struct LGL *lgl, signed int ilit)
{
  signed int size;
  lglpushstk(lgl, &lgl->clause, ilit);
  if(!(ilit == 0))

    __CPROVER_DUMP_L1:
      ;

  else
  {

  __CPROVER_DUMP_L2:
    ;

  __CPROVER_DUMP_L3:
    ;
    signed int return_value_lglsimpcls$2;
    return_value_lglsimpcls$2=lglsimpcls(lgl);
    if(return_value_lglsimpcls$2 == 0)
    {
      lgladdcls(lgl, 0, 0, 1);
      lgl->stats->irr.clauses.add = lgl->stats->irr.clauses.add + 1l;
      unsigned long int return_value_lglcntstk$1;
      return_value_lglcntstk$1=lglcntstk(&lgl->clause);
      size = (signed int)(return_value_lglcntstk$1 - (unsigned long int)1);
      lgl->stats->irr.clauses.add = lgl->stats->irr.clauses.add + (signed long int)size;
    }

    lglclnstk(&lgl->clause);
  }
}

// lgliassume
// file lglib.c line 7678
static void lgliassume(struct LGL *lgl, signed int lit)
{
  lgl->level = lgl->level + 1;
  lglpushcontrol(lgl, lit);

__CPROVER_DUMP_L1:
  ;
  lglassign(lgl, lit, DECISION, 0);
}

// lglidx2lits
// file lglib.c line 2537
static signed int * lglidx2lits(struct LGL *lgl, signed int tag, signed int red, signed int lidx)
{
  signed int *res;
  signed int glue = 0;
  struct Stk *s;
  while(tag == OCCS && !(red == 0))
  {
    fprintf(stderr, "liblgl.a: %s:%d: %s: Coverage target `%s' reached.", (const void *)"lglidx2lits", 2543, (const void *)"lglib.c", (const void *)"red && tag == OCCS");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputc(10, stderr);
    fflush(stderr);
    abort();
    break;
  }
  if(red == 0)
    s = &lgl->irr;

  else
    if(tag == OCCS)
      s = &lgl->red[(signed long int)0];

    else
    {
      glue = lidx & (1 << 4) - 1;
      lidx = lidx >> 4;
      s = &lgl->red[(signed long int)glue];
    }
  res = s->start + (signed long int)lidx;
  return res;
}

// lglifixed
// file lglib.c line 2794
static signed char lglifixed(struct LGL *lgl, signed int lit)
{
  signed int res;
  signed char return_value_lglval$1;
  return_value_lglval$1=lglval(lgl, lit);
  res = (signed int)return_value_lglval$1;
  if(res == 0)
    return (signed char)0;

  else
  {
    signed int return_value_lglevel$2;
    return_value_lglevel$2=lglevel(lgl, lit);
    if(return_value_lglevel$2 >= 1)
      return (signed char)0;

    else
      return (signed char)res;
  }
}

// lglifrozen
// file lglib.c line 3288
static signed int lglifrozen(struct LGL *lgl, signed int ilit)
{
  signed int elit;
  elit=lglexport(lgl, ilit);
  struct Ext *ext;
  ext=lglelit2ext(lgl, elit);
  _Bool tmp_if_expr$1;
  if(!(ext->frozen == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ext->tmpfrozen != 0u ? (_Bool)1 : (_Bool)0;
  return (signed int)tmp_if_expr$1;
}

// lglift
// file lglib.c line 14342
static signed int lglift(struct LGL *lgl)
{
  signed int oldrem;
  oldrem=lglrem(lgl);
  signed int removed;
  lglstart(lgl, &lgl->times->lft);
  lgl->lifting = (char)1;
  lgl->stats->lift.count = lgl->stats->lift.count + 1;
  lgl->simp = (char)1;
  if(lgl->level >= 1)
    lglbacktrack(lgl, 0);

  signed int return_value_lglbcp$1;
  return_value_lglbcp$1=lglbcp(lgl);
  signed int return_value_lgliftaux$2;
  signed int return_value_lglsynceqs$3;
  signed int return_value_lglbcp$4;
  if(!(return_value_lglbcp$1 == 0))
  {
    lglgc(lgl);
    if(lgl->mt == 0)
    {
      return_value_lgliftaux$2=lgliftaux(lgl);
      if(!(return_value_lgliftaux$2 == 0))
      {
        return_value_lglsynceqs$3=lglsynceqs(lgl);
        if(!(return_value_lglsynceqs$3 == 0))
        {
          lglchkred(lgl);
          lgldcpdis(lgl);
          lgldcpcln(lgl);
          lgldcpcon(lgl);
          lglcompact(lgl);
          lglmap(lgl);
          if(lgl->mt == 0)
          {
            return_value_lglbcp$4=lglbcp(lgl);
            if(!(return_value_lglbcp$4 == 0))
            {
              lglcount(lgl);
              lglgc(lgl);
              if(lgl->mt == 0)
              {
                if(lgl->mt == 0)
                {
                  lglpicosatchkall(lgl);
                  lglpicosatrestart(lgl);
                }

              }

            }

          }

        }

      }

    }

  }


DONE:
  ;
  signed int return_value_lglrem$5;
  return_value_lglrem$5=lglrem(lgl);
  removed = oldrem - return_value_lglrem$5;
  lglupdlftpen(lgl, removed);
  lgl->simp = (char)0;
  lgl->lifting = lgl->simp;
  lglprtlftrem(lgl);
  lglprt(lgl, 1 + (signed int)!(removed != 0), "[lift-%d] removed %d variables", lgl->stats->lift.count, removed);
  lglrep(lgl, 1 + (signed int)!(removed != 0), (char)94);
  lglstop(lgl);
  return (signed int)!(lgl->mt != 0);
}

// lgliftaux
// file lglib.c line 13973
static signed int lgliftaux(struct LGL *lgl)
{
  signed int lit1;
  signed int lit2;
  signed int repr1;
  signed int repr2;
  signed int orepr1;
  signed int orepr2;
  signed int tobeprobed;
  signed int notobeprobed;
  signed int i;
  signed int idx;
  signed int lit;
  signed int *reprs[3l];
  signed int first;
  signed int outer;
  signed int inner;
  signed int changed;
  signed int branch;
  struct Stk probes;
  struct Stk represented[2l];
  struct Stk saved;
  struct Stk tmp;
  signed int ok;
  signed int oldouter;
  signed int dom;
  signed int repr;
  signed int other;
  unsigned int pos;
  unsigned int delta;
  unsigned int mod;
  signed char val;
  signed char val1;
  signed char val2;
  signed long int global;
  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
    lgl->repr = (signed int *)return_value_lglnew$1;
  }
  while((_Bool)0);
  do
    memset((void *)&probes, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  do
    memset((void *)&saved, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  do
    memset((void *)&tmp, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  do
    memset((void *)&represented[(signed long int)0], 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  do
    memset((void *)&represented[(signed long int)1], 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
  do
  {
    void *return_value_lglnew$2;
    return_value_lglnew$2=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
    reprs[(signed long int)0] = (signed int *)return_value_lglnew$2;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew$3;
    return_value_lglnew$3=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
    reprs[(signed long int)1] = (signed int *)return_value_lglnew$3;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew$4;
    return_value_lglnew$4=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
    reprs[(signed long int)2] = (signed int *)return_value_lglnew$4;
  }
  while((_Bool)0);
  signed long int return_value_lglobalftlim$5;
  return_value_lglobalftlim$5=lglobalftlim(lgl);
  global = lgl->stats->visits.simp + return_value_lglobalftlim$5;
  notobeprobed = 0;
  tobeprobed = notobeprobed;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree$6;
    return_value_lglisfree$6=lglisfree(lgl, idx);
    if(!(return_value_lglisfree$6 == 0))
    {
      struct AVar *return_value_lglavar$7;
      return_value_lglavar$7=lglavar(lgl, idx);
      if(!(return_value_lglavar$7->donotlft == 0u))
        notobeprobed = notobeprobed + 1;

      else
        tobeprobed = tobeprobed + 1;
    }

  }
  double return_value_lglpcnt$10;
  if(tobeprobed == 0)
  {
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      signed int return_value_lglisfree$8;
      return_value_lglisfree$8=lglisfree(lgl, idx);
      if(!(return_value_lglisfree$8 == 0))
      {
        struct AVar *return_value_lglavar$9;
        return_value_lglavar$9=lglavar(lgl, idx);
        return_value_lglavar$9->donotlft = (unsigned int)0;
        tobeprobed = tobeprobed + 1;
      }

    }
    lglprt(lgl, 1, "[lift-%d] using all %d probes", lgl->stats->lift.count, tobeprobed);
  }

  else
  {
    return_value_lglpcnt$10=lglpcnt((double)tobeprobed, (double)(notobeprobed + tobeprobed));
    lglprt(lgl, 1, "[lift-%d] using %d probes %.0f%%", lgl->stats->lift.count, tobeprobed, return_value_lglpcnt$10);
  }
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree$11;
    return_value_lglisfree$11=lglisfree(lgl, idx);
    if(!(return_value_lglisfree$11 == 0))
    {
      struct AVar *return_value_lglavar$12;
      return_value_lglavar$12=lglavar(lgl, idx);
      if(return_value_lglavar$12->donotlft == 0u)
      {

      __CPROVER_DUMP_L21:
        ;
        lglpushstk(lgl, &probes, idx);
      }

    }

  }
  unsigned long int return_value_lglcntstk$13;
  return_value_lglcntstk$13=lglcntstk(&probes);
  mod = (unsigned int)return_value_lglcntstk$13;
  unsigned int return_value_lglrand$14;
  unsigned int return_value_lglrand$15;
  unsigned int return_value_lglgcd$16;
  unsigned long int return_value_lglcntstk$23;
  unsigned long int return_value_lglcntstk$24;
  signed int return_value_lglpeek$25;
  signed int return_value_lglmtstk$26;
  _Bool tmp_if_expr$31;
  signed char return_value_lglval$30;
  unsigned long int return_value_lglcntstk$32;
  unsigned long int return_value_lglcntstk$33;
  signed int return_value_lglpeek$34;
  signed int return_value_lglmtstk$35;
  unsigned long int return_value_lglcntstk$38;
  if(!(mod == 0u))
  {

  __CPROVER_DUMP_L24:
    ;
    return_value_lglrand$14=lglrand(lgl);
    pos = return_value_lglrand$14 % mod;
    return_value_lglrand$15=lglrand(lgl);
    delta = return_value_lglrand$15 % mod;
    if(delta == 0u)
      delta = delta + 1u;

    do
    {
      return_value_lglgcd$16=lglgcd(delta, mod);
      if(!(return_value_lglgcd$16 >= 2u))
        break;

      delta = delta + 1u;
      if(delta == mod)
        delta = (unsigned int)1;

    }
    while((_Bool)1);

  __CPROVER_DUMP_L27:
    ;
    first = 0;
    changed = first;
    while(lgl->mt == 0)
    {
      if(lgl->stats->visits.simp >= global)
        break;

      signed int return_value_lglterminate$17;
      return_value_lglterminate$17=lglterminate(lgl);
      if(!(return_value_lglterminate$17 == 0))
        break;

      signed int return_value_lglsyncunits$18;
      return_value_lglsyncunits$18=lglsyncunits(lgl);
      if(return_value_lglsyncunits$18 == 0)
        break;

      outer = probes.start[(signed long int)pos];
      struct AVar *return_value_lglavar$19;
      return_value_lglavar$19=lglavar(lgl, outer);
      return_value_lglavar$19->donotlft = (unsigned int)1;
      if(outer == first)
      {
        if(!(changed == 0))
          changed = 0;

        else
          break;
      }

      if(first == 0)
        first = outer;

      pos = pos + delta;
      if(pos >= mod)
        pos = pos - mod;

      signed char return_value_lglval$20;
      return_value_lglval$20=lglval(lgl, outer);
      if(return_value_lglval$20 == 0)
      {
        lgl->stats->lift.probed0 = lgl->stats->lift.probed0 + 1l;

      __CPROVER_DUMP_L35:
        ;
        unsigned long int return_value_lglcntstk$21;
        return_value_lglcntstk$21=lglcntstk(&lgl->trail);
        oldouter = (signed int)return_value_lglcntstk$21;
        lgliassume(lgl, outer);
        ok=lglbcp(lgl);
        if(ok == 0)
        {

        FIRST_OUTER_BRANCH_FAILED:
          ;
          dom=lglprbana(lgl, outer);

        __CPROVER_DUMP_L37:
          ;
          lgl->stats->lift.units = lgl->stats->lift.units + 1;
          lglbacktrack(lgl, 0);
          lglunit(lgl, -dom);
          signed int return_value_lglbcp$22;
          return_value_lglbcp$22=lglbcp(lgl);
          if(!(return_value_lglbcp$22 == 0))
            continue;


        __CPROVER_DUMP_L38:
          ;
          lgl->mt = 1;
          break;
        }

        inner=lglinnerprobe(lgl, oldouter, &probes, &tmp);
        if(inner == 0)
        {
          do

            FIRST_OUTER_BRANCH_WIHOUT_INNER_PROBE:
              ;
          while((_Bool)0);
          i = oldouter;
          do
          {
            return_value_lglcntstk$23=lglcntstk(&lgl->trail);
            if((unsigned long int)i >= return_value_lglcntstk$23)
              break;

            lit=lglpeek(&lgl->trail, i);
            idx=abs(lit);
            reprs[(signed long int)0][(signed long int)idx]=lglsgn(lit);
            lglpushstk(lgl, &represented[(signed long int)0], idx);
            i = i + 1;
          }
          while((_Bool)1);
        }

        else
        {

        __CPROVER_DUMP_L43:
          ;
          lgl->stats->lift.probed1 = lgl->stats->lift.probed1 + 1l;
          lgliassume(lgl, inner);
          ok=lglbcp(lgl);
          if(ok == 0)
          {

          __CPROVER_DUMP_L44:
            ;
            lglbacktrack(lgl, 1);
            lgladdliftbincls(lgl, -inner, -outer);
            ok=lglbcp(lgl);
            if(!(ok == 0))
              goto FIRST_OUTER_BRANCH_WIHOUT_INNER_PROBE;


          __CPROVER_DUMP_L45:
            ;
            goto FIRST_OUTER_BRANCH_FAILED;
          }

          lglclnstk(&saved);
          i = oldouter;
          do
          {
            return_value_lglcntstk$24=lglcntstk(&lgl->trail);
            if((unsigned long int)i >= return_value_lglcntstk$24)
              break;

            return_value_lglpeek$25=lglpeek(&lgl->trail, i);
            lglpushstk(lgl, &saved, return_value_lglpeek$25);
            i = i + 1;
          }
          while((_Bool)1);

        __CPROVER_DUMP_L49:
          ;
          lglbacktrack(lgl, 1);

        __CPROVER_DUMP_L50:
          ;
          lgl->stats->lift.probed1 = lgl->stats->lift.probed1 + 1l;
          lgliassume(lgl, -inner);
          ok=lglbcp(lgl);
          if(ok == 0)
          {

          __CPROVER_DUMP_L51:
            ;
            lglbacktrack(lgl, 1);
            lgladdliftbincls(lgl, inner, -outer);
            ok=lglbcp(lgl);
            if(!(ok == 0))
              goto FIRST_OUTER_BRANCH_WIHOUT_INNER_PROBE;


          __CPROVER_DUMP_L52:
            ;
            goto FIRST_OUTER_BRANCH_FAILED;
          }

          do
          {
            return_value_lglmtstk$26=lglmtstk(&saved);
            if(!(return_value_lglmtstk$26 == 0))
              break;

            lit=lglpopstk(&saved);
            idx=abs(lit);
            signed int return_value_lglsgn$27;
            return_value_lglsgn$27=lglsgn(lit);
            val1 = (signed char)return_value_lglsgn$27;
            val2=lglval(lgl, idx);
            if(val1 == val2)
            {
              reprs[(signed long int)0][(signed long int)idx] = (signed int)val1;
              lglpushstk(lgl, &represented[(signed long int)0], idx);
            }

            else
              if((signed int)val1 == -((signed int)val2) && !(lit == inner))
              {
                repr=lglptrjmp(reprs[(signed long int)0], lgl->nvars - 1, inner);
                other=lglptrjmp(reprs[(signed long int)0], lgl->nvars - 1, lit);
                signed int return_value_lglcmprepr$28;
                return_value_lglcmprepr$28=lglcmprepr(lgl, other, repr);
                if(!(return_value_lglcmprepr$28 >= 0))
                  do
                  {
                    signed int lgliftaux$$1$$15$$11$$2$$1$$TMP = repr;
                    repr = other;
                    other = lgliftaux$$1$$15$$11$$2$$1$$TMP;
                  }
                  while((_Bool)0);

                if(!(other >= 0))
                {
                  other = -other;
                  repr = -repr;
                }

                reprs[(signed long int)0][(signed long int)other] = repr;
                lglpushstk(lgl, &represented[(signed long int)0], other);
              }

          }
          while((_Bool)1);
          lglbacktrack(lgl, 1);
        }

      END_OF_FIRST_OUTER_BRANCH:
        ;
        (void)0;
        lglbacktrack(lgl, 0);
        lgl->stats->lift.probed0 = lgl->stats->lift.probed0 + 1l;

      __CPROVER_DUMP_L61:
        ;
        lgliassume(lgl, -outer);
        ok=lglbcp(lgl);
        if(ok == 0)
        {

        SECOND_OUTER_BRANCH_FAILED:
          ;
          dom=lglprbana(lgl, -outer);

        __CPROVER_DUMP_L63:
          ;
          lgl->stats->lift.units = lgl->stats->lift.units + 1;
          lglbacktrack(lgl, 0);
          lglunit(lgl, -dom);
          signed int return_value_lglbcp$29;
          return_value_lglbcp$29=lglbcp(lgl);
          if(!(return_value_lglbcp$29 == 0))
            goto CONTINUE;

          lgl->mt = 1;
          goto CONTINUE;
        }

        if(inner == 0)
          tmp_if_expr$31 = (_Bool)1;

        else
        {
          return_value_lglval$30=lglval(lgl, inner);
          tmp_if_expr$31 = return_value_lglval$30 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$31)
          inner=lglinnerprobe(lgl, oldouter, &probes, &tmp);

        if(inner == 0)
        {
          do

            SECOND_OUTER_BRANCH_WIHOUT_INNER_PROBE:
              ;
          while((_Bool)0);
          i = oldouter;
          do
          {
            return_value_lglcntstk$32=lglcntstk(&lgl->trail);
            if((unsigned long int)i >= return_value_lglcntstk$32)
              break;

            lit=lglpeek(&lgl->trail, i);
            idx=abs(lit);
            reprs[(signed long int)1][(signed long int)idx]=lglsgn(lit);
            lglpushstk(lgl, &represented[(signed long int)1], idx);
            i = i + 1;
          }
          while((_Bool)1);
        }

        else
        {

        __CPROVER_DUMP_L71:
          ;
          lgl->stats->lift.probed1 = lgl->stats->lift.probed1 + 1l;
          lgliassume(lgl, inner);
          ok=lglbcp(lgl);
          if(ok == 0)
          {

          __CPROVER_DUMP_L72:
            ;
            lglbacktrack(lgl, 1);
            lgladdliftbincls(lgl, -inner, outer);
            ok=lglbcp(lgl);
            if(!(ok == 0))
              goto SECOND_OUTER_BRANCH_WIHOUT_INNER_PROBE;


          __CPROVER_DUMP_L73:
            ;
            goto SECOND_OUTER_BRANCH_FAILED;
          }

          lglclnstk(&saved);
          i = oldouter;
          do
          {
            return_value_lglcntstk$33=lglcntstk(&lgl->trail);
            if((unsigned long int)i >= return_value_lglcntstk$33)
              break;

            return_value_lglpeek$34=lglpeek(&lgl->trail, i);
            lglpushstk(lgl, &saved, return_value_lglpeek$34);
            i = i + 1;
          }
          while((_Bool)1);

        __CPROVER_DUMP_L77:
          ;
          lglbacktrack(lgl, 1);

        __CPROVER_DUMP_L78:
          ;
          lgl->stats->lift.probed1 = lgl->stats->lift.probed1 + 1l;
          lgliassume(lgl, -inner);
          ok=lglbcp(lgl);
          if(ok == 0)
          {

          __CPROVER_DUMP_L79:
            ;
            lglbacktrack(lgl, 1);
            lgladdliftbincls(lgl, inner, outer);
            ok=lglbcp(lgl);
            if(!(ok == 0))
              goto SECOND_OUTER_BRANCH_WIHOUT_INNER_PROBE;


          __CPROVER_DUMP_L80:
            ;
            goto SECOND_OUTER_BRANCH_FAILED;
          }

          do
          {
            return_value_lglmtstk$35=lglmtstk(&saved);
            if(!(return_value_lglmtstk$35 == 0))
              break;

            lit=lglpopstk(&saved);
            idx=abs(lit);
            signed int return_value_lglsgn$36;
            return_value_lglsgn$36=lglsgn(lit);
            val1 = (signed char)return_value_lglsgn$36;
            val2=lglval(lgl, idx);
            if(val1 == val2)
            {
              reprs[(signed long int)1][(signed long int)idx] = (signed int)val1;
              lglpushstk(lgl, &represented[(signed long int)1], idx);
            }

            else
              if((signed int)val1 == -((signed int)val2) && !(lit == inner))
              {
                repr=lglptrjmp(reprs[(signed long int)1], lgl->nvars - 1, inner);
                other=lglptrjmp(reprs[(signed long int)1], lgl->nvars - 1, lit);
                signed int return_value_lglcmprepr$37;
                return_value_lglcmprepr$37=lglcmprepr(lgl, other, repr);
                if(!(return_value_lglcmprepr$37 >= 0))
                  do
                  {
                    signed int TMP = repr;
                    repr = other;
                    other = TMP;
                  }
                  while((_Bool)0);

                if(!(other >= 0))
                {
                  other = -other;
                  repr = -repr;
                }

                reprs[(signed long int)1][(signed long int)other] = repr;
                lglpushstk(lgl, &represented[(signed long int)1], other);
              }

          }
          while((_Bool)1);
          lglbacktrack(lgl, 1);
        }

      END_OF_SECOND_BRANCH:
        ;
        (void)0;
        lglbacktrack(lgl, 0);
        branch = 0;
        for( ; !(branch >= 2); branch = branch + 1)
        {
          i = 0;
          do
          {
            return_value_lglcntstk$38=lglcntstk(&represented[(signed long int)branch]);
            if((unsigned long int)i >= return_value_lglcntstk$38)
              break;

            lit1=lglpeek(&represented[(signed long int)branch], i);
            lit2 = reprs[(signed long int)branch][(signed long int)lit1];
            signed int return_value_abs$40;
            return_value_abs$40=abs(lit2);
            if(return_value_abs$40 == 1)
            {
              val=lglval(lgl, lit1);
              if(!(val == 0))
                goto __CPROVER_DUMP_L97;

              repr1=lglptrjmp(reprs[(signed long int)!(branch != 0)], lgl->nvars - 1, lit1);
              if(!(repr1 == lit2))
                goto __CPROVER_DUMP_L97;


            __CPROVER_DUMP_L91:
              ;
              lglunit(lgl, lit2 * lit1);
              lgl->stats->lift.units = lgl->stats->lift.units + 1;
            }

            else
            {
              repr1=lglptrjmp(reprs[(signed long int)2], lgl->nvars - 1, lit1);
              repr2=lglptrjmp(reprs[(signed long int)2], lgl->nvars - 1, lit2);
              if(repr1 == repr2)
                goto __CPROVER_DUMP_L97;

              orepr1=lglptrjmp(reprs[(signed long int)!(branch != 0)], lgl->nvars - 1, lit1);
              orepr2=lglptrjmp(reprs[(signed long int)!(branch != 0)], lgl->nvars - 1, lit2);
              if(!(orepr1 == orepr2))
                goto __CPROVER_DUMP_L97;

              signed int return_value_lglcmprepr$39;
              return_value_lglcmprepr$39=lglcmprepr(lgl, repr2, repr1);
              if(!(return_value_lglcmprepr$39 >= 0))
                do
                {
                  signed int lgliftaux$$1$$15$$22$$1$$1$$1$$2$$1$$TMP = repr1;
                  repr1 = repr2;
                  repr2 = lgliftaux$$1$$15$$22$$1$$1$$1$$2$$1$$TMP;
                }
                while((_Bool)0);

              if(!(repr2 >= 0))
              {
                repr2 = -repr2;
                repr1 = -repr1;
              }


            __CPROVER_DUMP_L95:
              ;
              reprs[(signed long int)2][(signed long int)repr2] = repr1;
            }

          __CPROVER_DUMP_L97:
            ;
            i = i + 1;
          }
          while((_Bool)1);
        }
        signed int return_value_lglbcp$41;
        return_value_lglbcp$41=lglbcp(lgl);
        if(return_value_lglbcp$41 == 0)
          lgl->mt = 1;


      CONTINUE:
        ;
        (void)0;
        lglcleanrepr(lgl, &represented[(signed long int)0], reprs[(signed long int)0]);
        lglcleanrepr(lgl, &represented[(signed long int)1], reprs[(signed long int)1]);
      }

    }
    if(lgl->mt == 0)
    {
      idx = 2;
      for( ; !(idx >= lgl->nvars); idx = idx + 1)
        lglptrjmp(reprs[(signed long int)2], lgl->nvars - 1, idx);
      idx = 2;
      for( ; !(idx >= lgl->nvars); idx = idx + 1)
      {
        repr=lglptrjmp(reprs[(signed long int)2], lgl->nvars - 1, idx);
        val=lglval(lgl, idx);
        if(!(val == 0))
        {
          if(repr == -((signed int)val))
          {

          __CPROVER_DUMP_L106:
            ;
            lgl->mt = 1;
            goto DONE;
          }

          if(!(repr >= 0))
          {
            repr = -repr;
            val = (signed char)-((signed int)val);
          }

          if(!(repr == 1))
            reprs[(signed long int)2][(signed long int)repr] = (signed int)val;

        }

      }
      idx = 2;
      for( ; !(idx >= lgl->nvars); idx = idx + 1)
      {
        repr=lglptrjmp(reprs[(signed long int)2], lgl->nvars - 1, idx);
        if(!(repr == idx))
        {
          signed int return_value_abs$42;
          return_value_abs$42=abs(repr);
          if(!(return_value_abs$42 == 1))
          {
            lgl->stats->lift.eqs = lgl->stats->lift.eqs + 1;

          __CPROVER_DUMP_L113:
            ;
            lglimerge(lgl, idx, repr);
          }

        }

      }
    }

  }


DONE:
  ;
  (void)0;
  do
  {
    lgldel(lgl, (void *)reprs[(signed long int)0], (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
    reprs[(signed long int)0] = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)reprs[(signed long int)1], (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
    reprs[(signed long int)1] = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)reprs[(signed long int)2], (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
    reprs[(signed long int)2] = ((signed int *)NULL);
  }
  while((_Bool)0);
  lglrelstk(lgl, &probes);
  lglrelstk(lgl, &represented[(signed long int)0]);
  lglrelstk(lgl, &represented[(signed long int)1]);
  lglrelstk(lgl, &saved);
  lglrelstk(lgl, &tmp);
  if(!(lgl->mt == 0))
    do
    {
      lgldel(lgl, (void *)lgl->repr, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
      lgl->repr = ((signed int *)NULL);
    }
    while((_Bool)0);

  return (signed int)!(lgl->mt != 0);
}

// lglifting
// file lglib.c line 16959
static signed int lglifting(struct LGL *lgl)
{
  return lgl->opts->lift.val;
}

// lgligetopt
// file lglib.c line 2253
static struct Opt * lgligetopt(struct LGL *lgl, const char *opt)
{
  struct Opt *o;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lgligetopt");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  o = &lgl->opts->beforefirst + (signed long int)1;
  signed int tmp_statement_expression$1;
  for( ; &lgl->opts->afterlast + -1l >= o; o = o + 1l)
  {
    if(opt[1l] == 0)
    {
      if(o->shrt == *opt)
        return o;

    }

    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$2;
    return_value___builtin_strcmp$2=__builtin_strcmp(o->lng, opt);
    tmp_statement_expression$1 = return_value___builtin_strcmp$2;
    if(tmp_statement_expression$1 == 0)
      return o;

  }
  return ((struct Opt *)NULL);
}

// lglilit
// file lglib.c line 6651
static signed int lglilit(signed int ulit)
{
  signed int res = ulit / 2;
  if(!((1 & ulit) == 0))
    res = -res;

  return res;
}

// lglimerge
// file lglib.c line 8096
static void lglimerge(struct LGL *lgl, signed int lit, signed int repr)
{
  signed int idx;
  idx=abs(lit);
  struct AVar *av;
  av=lglavar(lgl, idx);
  if(!(lit >= 0))
    repr = -repr;

  av->type = (unsigned int)EQUIVAR;
  lgl->repr[(signed long int)idx] = repr;
  lgl->stats->prgss = lgl->stats->prgss + 1l;
  lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;
  lgl->stats->equiv.sum = lgl->stats->equiv.sum + 1;
  lgl->stats->equiv.current = lgl->stats->equiv.current + 1;
  lglemerge(lgl, idx, repr);
}

// lglimhit
// file lglib.c line 17218
static signed int lglimhit(struct LGL *lgl, struct Lim *lim)
{
  if(lim == ((struct Lim *)NULL))
    return 0;

  else
    if(lim->decs >= lgl->stats->decisions)
    {
      lglprt(lgl, 1, "[limits] decision limit %lld hit at %lld decisions", (signed long long int)lim->decs, (signed long long int)lgl->stats->decisions);
      return 1;
    }

    else
      if(lim->confs >= 0l)
      {
        if(!(lgl->stats->confs >= lim->confs))
          goto __CPROVER_DUMP_L3;

        lglprt(lgl, 1, "[limits] conflict limit %lld hit at %lld conflicts", (signed long long int)lim->confs, (signed long long int)lgl->stats->confs);
        return 1;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        return 0;
      }
}

// lglimport
// file lglib.c line 2510
static signed int lglimport(struct LGL *lgl, signed int elit)
{
  signed int res;
  signed int repr;
  signed int eidx;
  eidx=abs(elit);
  struct Ext *ext;
  if(eidx >= lgl->szext)
    lgladjext(lgl, eidx);

  if(!(lgl->maxext >= eidx))
  {
    lgl->maxext = eidx;
    lglmelter(lgl);
  }

  repr=lglerepr(lgl, elit);
  ext=lglelit2ext(lgl, repr);
  res = ext->repr;
  if(ext->imported == 0u)
  {
    res=lglnewvar(lgl);
    ext->repr = res;
    ext->imported = (unsigned int)1;
    lgl->i2e[(signed long int)res] = eidx;
  }


__CPROVER_DUMP_L3:
  ;
  if(!(repr >= 0))
    res = -res;


__CPROVER_DUMP_L5:
  ;
  return res;
}

// lglinc
// file lglib.c line 1245
static void lglinc(struct LGL *lgl, unsigned long int bytes)
{
  lgl->stats->bytes.current = lgl->stats->bytes.current + bytes;
  if(!(lgl->stats->bytes.max >= lgl->stats->bytes.current))
    lgl->stats->bytes.max = lgl->stats->bytes.current;


__CPROVER_DUMP_L1:
  ;
}

// lglincextractlimhit
// file lglib.c line 12580
static signed int lglincextractlimhit(struct LGL *lgl)
{
  lgl->stats->cgr.esteps = lgl->stats->cgr.esteps + 1l;
  signed int return_value_lglcgextractlimhit$1;
  return_value_lglcgextractlimhit$1=lglcgextractlimhit(lgl);
  return return_value_lglcgextractlimhit$1;
}

// lglincfdat
// file lglib.c line 7434
static void lglincfdat(struct ForceData *fdat, signed int lit, double cog)
{
  signed int idx;
  idx=abs(lit);
  (fdat + (signed long int)idx)->count = (fdat + (signed long int)idx)->count + 1;
  (fdat + (signed long int)idx)->sum = (fdat + (signed long int)idx)->sum + cog;
}

// lglincirr
// file lglib.c line 3468
static void lglincirr(struct LGL *lgl, signed int size)
{
  if(size >= 2)
  {
    lgl->stats->irr.clauses.cur = lgl->stats->irr.clauses.cur + 1;
    if(!(lgl->stats->irr.clauses.max >= lgl->stats->irr.clauses.cur))
      lgl->stats->irr.clauses.max = lgl->stats->irr.clauses.cur;

    lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur + size;
    if(!(lgl->stats->irr.lits.max >= lgl->stats->irr.lits.cur))
      lgl->stats->irr.lits.max = lgl->stats->irr.lits.cur;

    lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;
  }

}

// lglincjwh
// file lglib.c line 6658
static void lglincjwh(struct LGL *lgl, signed int lit, signed long int inc)
{
  signed int ulit;
  ulit=lglulit(lit);
  signed long int old = lgl->jwh[(signed long int)ulit];
  signed long int new;
  new=lgladdflt(old, inc);
  lgl->jwh[(signed long int)ulit] = new;
}

// lglinclause
// file lglib.c line 12709
static void lglinclause(struct LGL *lgl, signed int parity)
{
  signed int *p;
  signed int return_value_lglparity$1;
  do
  {
    p = lgl->clause.start;
    for( ; !(p >= lgl->clause.top); p = p + 1l)
    {
      *p = -(*p);
      if(!(*p >= 0))
        break;

    }
    return_value_lglparity$1=lglparity(lgl);
  }
  while(!(return_value_lglparity$1 == parity));
}

// lglincocc
// file lglib.c line 3372
static void lglincocc(struct LGL *lgl, signed int lit)
{
  signed int idx;
  signed int sign;
  signed int change;
  struct EVar *ev;
  _Bool tmp_if_expr$1;
  if(!(lgl->cgrclosing == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = lgl->probing != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = lgl->gaussing != 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$2)
  {
    idx=abs(lit);
    sign = (signed int)(lit < 0);
    ev=lglevar(lgl, lit);
    ev->occ[(signed long int)sign] = ev->occ[(signed long int)sign] + 1;
    change=lglecalc(lgl, ev);

  __CPROVER_DUMP_L6:
    ;
    if(!(ev->pos >= 0))
      lglesched(lgl, idx);

    else
      if(change >= 1)
        lgledown(lgl, idx);

      else
        if(!(change >= 0))
          lgleup(lgl, idx);

  }

}

// lglinconsistent
// file lglib.c line 17950
signed int lglinconsistent(struct LGL *lgl)
{
  signed int res;
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "inconsistent");
    break;
  }
  res = (signed int)(lgl->mt != 0);

__CPROVER_DUMP_L3:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglinconsistent(lgl->clone);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglinconsistent");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone) = %d differs from %s (lgl) = %d", (const void *)"lglinconsistent", CLONERES, (const void *)"lglinconsistent", res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglincrestartaux
// file lglib.c line 6267
static void lglincrestartaux(struct LGL *lgl, signed int skip)
{
  signed int delta = lgl->opts->restartint.val;
  signed int count;
  if(lgl->opts->restart.val == 2)
  {
    lgl->limits->restart.luby = lgl->limits->restart.luby + 1;
    count = lgl->limits->restart.luby;
    signed long int return_value_lgluby$1;
    return_value_lgluby$1=lgluby(lgl, count);
    delta = delta * (signed int)return_value_lgluby$1;
  }

  else
  {
    lgl->limits->restart.inout = lgl->limits->restart.inout + 1;
    count = lgl->limits->restart.inout;
    signed long int return_value_lglinout$2;
    return_value_lglinout$2=lglinout(lgl, count, lgl->opts->rstinoutinc.val);
    delta = delta * (signed int)return_value_lglinout$2;
  }
  lgl->limits->restart.confs = lgl->stats->confs + (signed long int)delta;
  if(!(lgl->limits->restart.wasmaxdelta == 0))
    lglrep(lgl, 1 + skip, (char)(skip != 0 ? 78 : 82));

  else
    lglrep(lgl, 2, (char)(skip != 0 ? 110 : 114));
  if(!(lgl->limits->restart.maxdelta >= delta))
  {
    lgl->limits->restart.wasmaxdelta = 1;
    lgl->limits->restart.maxdelta = delta;
  }

  else
    lgl->limits->restart.wasmaxdelta = 0;
}

// lglincrestartl
// file lglib.c line 6287
static void lglincrestartl(struct LGL *lgl, signed int skip)
{
  switch(lgl->opts->restart.val)
  {
    case 1:
    {
      lglincrestartlfixed(lgl);
      break;
    }
    case 2:

    case 3:
      lglincrestartaux(lgl, skip);
    default:
      ;
  }
}

// lglincrestartlfixed
// file lglib.c line 6261
static void lglincrestartlfixed(struct LGL *lgl)
{
  signed int delta = lgl->opts->restartint.val;
  lgl->limits->restart.confs = lgl->stats->confs + (signed long int)delta;
  lglrep(lgl, 1, (char)82);
}

// lglincvar
// file lglib.c line 17902
signed int lglincvar(struct LGL *lgl)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglincvar");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "incvar");
    break;
  }
  res = lgl->maxext + 1;
  lglimport(lgl, res);

__CPROVER_DUMP_L6:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglincvar(lgl->clone);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglincvar");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone) = %d differs from %s (lgl) = %d", (const void *)"lglincvar", CLONERES, (const void *)"lglincvar", res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglinit
// file lglib.h line 23
struct LGL * lglinit(void)
{
  struct LGL *return_value_lglminit$1;
  return_value_lglminit$1=lglminit(NULL, ((void * (*)(void *, unsigned long int))NULL), ((void * (*)(void *, void *, unsigned long int, unsigned long int))NULL), ((void (*)(void *, void *, unsigned long int))NULL));
  return return_value_lglminit$1;
}

// lglinitcbs
// file lglib.c line 1312
static void lglinitcbs(struct LGL *lgl)
{
  if(lgl->cbs == ((struct Cbs *)NULL))
    do
    {
      void *return_value_lglnew$1;
      return_value_lglnew$1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Cbs) /*152ul*/ );
      lgl->cbs = (struct Cbs *)return_value_lglnew$1;
    }
    while((_Bool)0);

}

// lglinitecls
// file lglib.c line 9435
static void lglinitecls(struct LGL *lgl, signed int idx)
{
  lgl->$anon0.elm->pivot = idx;
  lglpushstk(lgl, &lgl->$anon0.elm->mark, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->mark, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->occs, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->occs, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->noccs, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->noccs, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->lsigs, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->lsigs, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->m2i, 0);
  lgli2m(lgl, idx);
  lglpushstk(lgl, &lgl->$anon0.elm->lits, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->next, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->csigs, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->sizes, 0);
  lgl->$anon0.elm->necls = 0;
  lglecls(lgl, idx);
  lgl->$anon0.elm->negcls = lgl->$anon0.elm->necls;
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(&lgl->$anon0.elm->lits);
  lgl->$anon0.elm->neglidx = (signed int)return_value_lglcntstk$1;
  lglecls(lgl, -idx);

__CPROVER_DUMP_L1:
  ;
}

// lglinitsmallve
// file lglib.c line 10633
static signed int lglinitsmallve(struct LGL *lgl, signed int lit, unsigned long int *res)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int lidx;
  signed int mlit;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  const signed int *q;
  unsigned long int cls[64l];
  unsigned long int tmp[64l];
  struct HTS *hts;
  signed char val;

__CPROVER_DUMP_L1:
  ;
  lgls2m(lgl, lit);
  hts=lglhts(lgl, lit);
  lgltruefun(res);
  if(!(hts->count == 0))
  {
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
      blit = *p;
      tag = blit & MASKCS;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      if(!(tag == LRGCS))
      {
        red = blit & REDCS;
        if(red == 0)
        {
          lglfalsefun(cls);
          if(tag == BINCS || tag == TRNCS)
          {
            other = blit >> RMSHFT;
            val=lglval(lgl, other);
            if(val == 0)
            {
              mlit=lgls2m(lgl, other);
              if(mlit == 0)
                return 0;

              lgls2fun(mlit, tmp);
              lglorfun(cls, tmp);
            }

            if(tag == TRNCS)
            {
              other2 = *p;
              val=lglval(lgl, other2);
              if(val == 0)
              {
                mlit=lgls2m(lgl, other2);
                if(mlit == 0)
                  return 0;

                lgls2fun(mlit, tmp);
                lglorfun(cls, tmp);
              }

            }

          }

          else
          {
            lidx = blit >> RMSHFT;
            c=lglidx2lits(lgl, OCCS, 0, lidx);
            q = c;
            do
            {
              other = *q;
              if(other == 0)
                break;

              if(!(other == lit))
              {
                val=lglval(lgl, other);
                if(val == 0)
                {
                  mlit=lgls2m(lgl, other);
                  if(mlit == 0)
                    return 0;

                  lgls2fun(mlit, tmp);
                  lglorfun(cls, tmp);
                }

              }

              q = q + 1l;
            }
            while((_Bool)1);
          }
          lglandfun(res, cls);
          lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
          lgl->stats->elm.copies = lgl->stats->elm.copies + 1l;
        }

      }

    }
  }


DONE:
  ;
  return 1;
}

// lglinitsolve
// file lglib.c line 17331
static void lglinitsolve(struct LGL *lgl)
{
  if(!((signed int)lgl->state == READY))
    lglsetup(lgl);

  lglredvars(lgl);
  lglfitstk(lgl, &lgl->irr);
  lglrep(lgl, 1, (char)42);
}

// lglinnerprobe
// file lglib.c line 13860
static signed int lglinnerprobe(struct LGL *lgl, signed int old, struct Stk *outer, struct Stk *tmp)
{
  signed int i;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int other;
  signed int other2;
  signed int res;
  const signed int *w;
  const signed int *eow;
  const signed int *p;
  struct HTS *hts;
  i = old;
  unsigned long int return_value_lglcntstk$1;
  do
  {
    return_value_lglcntstk$1=lglcntstk(&lgl->trail);
    if((unsigned long int)i >= return_value_lglcntstk$1)
      break;

    lit=lglpeek(&lgl->trail, i);
    hts=lglhts(lgl, -lit);
    w=lglhts2wchs(lgl, hts);
    eow = w + (signed long int)hts->count;
    p = w;
    for( ; !(p >= eow); p = p + 1l)
    {
      blit = *p;
      tag = blit & MASKCS;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      if(!(tag == BINCS) && !(tag == LRGCS))
      {
        other = blit >> RMSHFT;
        signed char return_value_lglval$2;
        return_value_lglval$2=lglval(lgl, other);
        if(!((signed int)return_value_lglval$2 >= 1))
        {
          other2 = *p;
          signed char return_value_lglval$3;
          return_value_lglval$3=lglval(lgl, other2);
          if(!((signed int)return_value_lglval$3 >= 1))
          {
            other=abs(other);
            signed int return_value_lglmarked$4;
            return_value_lglmarked$4=lglmarked(lgl, other);
            if(return_value_lglmarked$4 == 0)
            {
              lglmark(lgl, other);
              lglpushstk(lgl, tmp, other);
            }


          __CPROVER_DUMP_L5:
            ;
            other2=abs(other2);
            signed int return_value_lglmarked$5;
            return_value_lglmarked$5=lglmarked(lgl, other2);
            if(return_value_lglmarked$5 == 0)
            {
              lglmark(lgl, other2);
              lglpushstk(lgl, tmp, other2);
            }

          }

        }

      }


    __CPROVER_DUMP_L7:
      ;
    }
    i = i + 1;
  }
  while((_Bool)1);

__CPROVER_DUMP_L12:
  ;
  res=lglrandomprobe(lgl, tmp);
  lglpopnunmarkstk(lgl, tmp);
  if(res == 0)
    res=lglrandomprobe(lgl, outer);

  return res;
}

// lglinout
// file lglib.c line 5262
static signed long int lglinout(struct LGL *lgl, signed int c, signed int relincpcnt)
{
  signed long int i = (signed long int)1;
  signed long int o = (signed long int)1;
  lgl->stats->inout.count = lgl->stats->inout.count + 1;
  lgl->stats->inout.steps = lgl->stats->inout.steps + (signed long int)c;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = c;
    c = c - 1;
    if(!(tmp_post$1 >= 1))
      break;

    i = ((signed long int)(100 + relincpcnt) * i + (signed long int)99) / (signed long int)100;
    if(i >= o)
    {
      i = (signed long int)1;
      o = ((signed long int)(100 + relincpcnt) * o + (signed long int)99) / (signed long int)100;
    }

  }
  while((_Bool)1);
  return i;
}

// lglinprocessing
// file lglib.c line 17186
static signed int lglinprocessing(struct LGL *lgl)
{
  signed int res;
  signed int oldrem;
  signed int return_value_lglsimplimhit$1;
  return_value_lglsimplimhit$1=lglsimplimhit(lgl);
  if(return_value_lglsimplimhit$1 == 0)
    return (signed int)!(lgl->mt != 0);

  else
  {
    lgl->stats->simp.count = lgl->stats->simp.count + 1;
    lglstart(lgl, &lgl->times->inpr);
    oldrem=lglrem(lgl);
    res=lglisimp(lgl);
    signed int return_value_lglsimpcntrem$2;
    return_value_lglsimpcntrem$2=lglsimpcntrem(lgl, oldrem);
    lglupdprepint(lgl, return_value_lglsimpcntrem$2);
    lglstop(lgl);
    return res;
  }
}

// lgliphase
// file lglib.c line 6478
static signed char lgliphase(struct LGL *lgl, signed int lit)
{
  signed char res;
  struct AVar *return_value_lglavar$1;
  return_value_lglavar$1=lglavar(lgl, lit);
  res = (signed char)return_value_lglavar$1->phase;
  if(!(lit >= 0))
    res = (signed char)-((signed int)res);

  return res;
}

// lglirepr
// file lglib.c line 7181
static signed int lglirepr(struct LGL *lgl, signed int lit)
{
  signed int return_value_lglptrjmp$1;
  return_value_lglptrjmp$1=lglptrjmp(lgl->repr, lgl->nvars - 1, lit);
  return return_value_lglptrjmp$1;
}

// lglis
// file lglib.c line 6735
static signed int * lglis(struct LGL *lgl)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int tag;
  signed int blit;
  signed int other;
  signed int other2;
  signed int red;
  signed int *res;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  signed char val;
  signed char tmp;
  signed char tmp2;
  struct HTS *hts;
  struct Stk *s;
  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
    res = (signed int *)return_value_lglnew$1;
  }
  while((_Bool)0);
  res = res + (signed long int)lgl->nvars;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      val=lglval(lgl, lit);
      if(!((signed int)val >= 1))
      {
        hts=lglhts(lgl, lit);
        if(!(hts->offset == 0))
        {
          w=lglhts2wchs(lgl, hts);
          eow = w + (signed long int)hts->count;
          p = w;
          for( ; !(p >= eow); p = p + 1l)
          {
            blit = *p;
            tag = blit & MASKCS;
            if(tag == TRNCS || tag == LRGCS)
              p = p + 1l;

            if(!(tag == LRGCS))
            {
              red = blit & REDCS;
              if(red == 0)
              {
                other = blit >> RMSHFT;
                signed int return_value_abs$2;
                return_value_abs$2=abs(other);
                signed int return_value_abs$3;
                return_value_abs$3=abs(lit);
                if(return_value_abs$2 >= return_value_abs$3)
                {
                  tmp=lglval(lgl, other);
                  if(!((signed int)tmp >= 1))
                  {
                    if(tag == BINCS)
                    {
                      res[(signed long int)lit] = res[(signed long int)lit] + 1;
                      res[(signed long int)other] = res[(signed long int)other] + 1;
                    }

                    else
                    {
                      other2 = *p;
                      signed int return_value_abs$4;
                      return_value_abs$4=abs(other2);
                      signed int return_value_abs$5;
                      return_value_abs$5=abs(lit);
                      if(!(return_value_abs$4 >= return_value_abs$5))
                        goto __CPROVER_DUMP_L14;

                      tmp2=lglval(lgl, other2);
                      if((signed int)tmp2 >= 1)
                        goto __CPROVER_DUMP_L14;

                      if(val == 0)
                        res[(signed long int)lit] = res[(signed long int)lit] + 1;

                      if(tmp == 0)
                        res[(signed long int)other] = res[(signed long int)other] + 1;

                      if(tmp2 == 0)
                        res[(signed long int)other2] = res[(signed long int)other2] + 1;

                    }
                  }

                }

              }

            }


          __CPROVER_DUMP_L14:
            ;
          }
        }

      }

    }
  }
  s = &lgl->irr;
  c = s->start;
  signed char return_value_lglval$6;
  for( ; !(c >= s->top); c = p + (signed long int)1)
  {
    p = c;
    if(!(*p >= 134217727))
    {
      val = (signed char)-1;
      do
      {
        other = *p;
        if(other == 0)
          break;

        tmp=lglval(lgl, other);
        if(!((signed int)val >= (signed int)tmp))
          val = tmp;

        p = p + 1l;
      }
      while((_Bool)1);
      if(!((signed int)val >= 1))
      {
        p = c;
        do
        {
          other = *p;
          if(other == 0)
            break;

          return_value_lglval$6=lglval(lgl, other);
          if(return_value_lglval$6 == 0)
            res[(signed long int)other] = res[(signed long int)other] + 1;

          p = p + 1l;
        }
        while((_Bool)1);
      }

    }

  }
  return res;
}

// lglisact
// file lglib.c line 3390
static signed int lglisact(signed int act)
{
  return (signed int)(0x7fffffff >> RMSHFT <= act && act < 0x7fffffff - 1);
}

// lglisat
// file lglib.c line 17581
static signed int lglisat(struct LGL *lgl, struct Lim *lim, signed int simpits)
{
  signed int res;
  signed int count;
  lglreset(lgl);
  lglinitsolve(lgl);
  res=lglsolve(lgl, lim, 0);
  count = 0;
  for( ; res == 0 && !(count >= simpits); count = count + 1)
  {
    lglprt(lgl, 1, "next forced simplification iteration %d", count);
    res=lglsolve(lgl, lim, 1);
  }
  signed int return_value_lglcompactify$1;
  return_value_lglcompactify$1=lglcompactify(lgl, res);
  if(!(return_value_lglcompactify$1 == 0))
    lglcompact(lgl);

  if(res == 0)
  {

  __CPROVER_DUMP_L4:
    ;
    do
      lgl->state = (enum State)UNKNOWN;
    while((_Bool)0);
    lglrep(lgl, 1, (char)63);
  }

  if(res == 10)
  {

  __CPROVER_DUMP_L6:
    ;
    do
      lgl->state = (enum State)SATISFIED;
    while((_Bool)0);
    lglrep(lgl, 1, (char)49);
  }

  if(res == 20)
  {

  __CPROVER_DUMP_L8:
    ;
    do
      lgl->state = (enum State)UNSATISFIED;
    while((_Bool)0);
    lglrep(lgl, 1, (char)48);
  }

  lglflshrep(lgl);
  if(res == 10)
    lglextend(lgl);

  return res;
}

// lgliselim
// file lglib.c line 2568
static signed int lgliselim(struct LGL *lgl, signed int lit)
{
  enum Tag tag;
  struct AVar *return_value_lglavar$1;
  return_value_lglavar$1=lglavar(lgl, lit);
  tag = (enum Tag)return_value_lglavar$1->type;
  return (signed int)((signed int)tag == ELIMVAR);
}

// lglisetphase
// file lglib.c line 3883
static void lglisetphase(struct LGL *lgl, signed int lit, signed int phase)
{
  struct AVar *av;
  if(!(lit >= 0))
  {
    lit = -lit;
    phase = -phase;
  }

  av=lglavar(lgl, lit);
  av->fase = phase;

__CPROVER_DUMP_L2:
  ;
}

// lglisfalsefun
// file lglib.c line 10525
static signed int lglisfalsefun(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!(f[(signed long int)i] == 0ul))
      return 0;

  return 1;
}

// lglisfree
// file lglib.c line 2342
static signed int lglisfree(struct LGL *lgl, signed int lit)
{
  struct AVar *return_value_lglavar$1;
  return_value_lglavar$1=lglavar(lgl, lit);
  return (signed int)((signed int)return_value_lglavar$1->type == FREEVAR);
}

// lglisimp
// file lglib.c line 17019
static signed int lglisimp(struct LGL *lgl)
{
  signed int return_value_lglternres$1;
  signed int return_value_lglgauss$4;
  signed int return_value_lgldecomp$7;
  signed int return_value_lglprobe$10;
  signed int return_value_lglcgrclsr$13;
  signed int return_value_lglift$16;
  signed int return_value_lglcliff$19;
  signed int return_value_lglunhide$22;
  signed int return_value_lgltrd$25;
  signed int return_value_lglcce$30;
  signed int return_value_lglelim$33;
  if(lgl->opts->simplify.val == 0)
    return 1;

  else
  {
    signed int return_value_lglternresolving$2;
    return_value_lglternresolving$2=lglternresolving(lgl);
    if(!(return_value_lglternresolving$2 == 0))
    {
      return_value_lglternres$1=lglternres(lgl);
      if(!(return_value_lglternres$1 == 0))
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      signed int return_value_lglterminate$3;
      return_value_lglterminate$3=lglterminate(lgl);
      if(!(return_value_lglterminate$3 == 0))
        return 1;

      else
      {
        signed int return_value_lglgaussing$5;
        return_value_lglgaussing$5=lglgaussing(lgl);
        if(!(return_value_lglgaussing$5 == 0))
        {
          return_value_lglgauss$4=lglgauss(lgl);
          if(!(return_value_lglgauss$4 == 0))
            goto __CPROVER_DUMP_L4;

          return 0;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          signed int return_value_lglterminate$6;
          return_value_lglterminate$6=lglterminate(lgl);
          if(!(return_value_lglterminate$6 == 0))
            return 1;

          else
          {
            signed int return_value_lgldecomposing$8;
            return_value_lgldecomposing$8=lgldecomposing(lgl);
            if(!(return_value_lgldecomposing$8 == 0))
            {
              return_value_lgldecomp$7=lgldecomp(lgl);
              if(!(return_value_lgldecomp$7 == 0))
                goto __CPROVER_DUMP_L6;

              return 0;
            }

            else
            {

            __CPROVER_DUMP_L6:
              ;
              signed int return_value_lglterminate$9;
              return_value_lglterminate$9=lglterminate(lgl);
              if(!(return_value_lglterminate$9 == 0))
                return 1;

              else
              {
                signed int return_value_lglprobing$11;
                return_value_lglprobing$11=lglprobing(lgl);
                if(!(return_value_lglprobing$11 == 0))
                {
                  return_value_lglprobe$10=lglprobe(lgl);
                  if(!(return_value_lglprobe$10 == 0))
                    goto __CPROVER_DUMP_L8;

                  return 0;
                }

                else
                {

                __CPROVER_DUMP_L8:
                  ;
                  signed int return_value_lglterminate$12;
                  return_value_lglterminate$12=lglterminate(lgl);
                  if(!(return_value_lglterminate$12 == 0))
                    return 1;

                  else
                  {
                    signed int return_value_lglcgrclosing$14;
                    return_value_lglcgrclosing$14=lglcgrclosing(lgl);
                    if(!(return_value_lglcgrclosing$14 == 0))
                    {
                      return_value_lglcgrclsr$13=lglcgrclsr(lgl);
                      if(!(return_value_lglcgrclsr$13 == 0))
                        goto __CPROVER_DUMP_L10;

                      return 0;
                    }

                    else
                    {

                    __CPROVER_DUMP_L10:
                      ;
                      signed int return_value_lglterminate$15;
                      return_value_lglterminate$15=lglterminate(lgl);
                      if(!(return_value_lglterminate$15 == 0))
                        return 1;

                      else
                      {
                        signed int return_value_lglifting$17;
                        return_value_lglifting$17=lglifting(lgl);
                        if(!(return_value_lglifting$17 == 0))
                        {
                          return_value_lglift$16=lglift(lgl);
                          if(!(return_value_lglift$16 == 0))
                            goto __CPROVER_DUMP_L12;

                          return 0;
                        }

                        else
                        {

                        __CPROVER_DUMP_L12:
                          ;
                          signed int return_value_lglterminate$18;
                          return_value_lglterminate$18=lglterminate(lgl);
                          if(!(return_value_lglterminate$18 == 0))
                            return 1;

                          else
                          {
                            signed int return_value_lglcliffing$20;
                            return_value_lglcliffing$20=lglcliffing(lgl);
                            if(!(return_value_lglcliffing$20 == 0))
                            {
                              return_value_lglcliff$19=lglcliff(lgl);
                              if(!(return_value_lglcliff$19 == 0))
                                goto __CPROVER_DUMP_L14;

                              return 0;
                            }

                            else
                            {

                            __CPROVER_DUMP_L14:
                              ;
                              signed int return_value_lglterminate$21;
                              return_value_lglterminate$21=lglterminate(lgl);
                              if(!(return_value_lglterminate$21 == 0))
                                return 1;

                              else
                              {
                                if(!(lgl->opts->card.val == 0))
                                  lglcard(lgl);

                                signed int return_value_lglunhiding$23;
                                return_value_lglunhiding$23=lglunhiding(lgl);
                                if(!(return_value_lglunhiding$23 == 0))
                                {
                                  return_value_lglunhide$22=lglunhide(lgl);
                                  if(!(return_value_lglunhide$22 == 0))
                                    goto __CPROVER_DUMP_L17;

                                  return 0;
                                }

                                else
                                {

                                __CPROVER_DUMP_L17:
                                  ;
                                  signed int return_value_lglterminate$24;
                                  return_value_lglterminate$24=lglterminate(lgl);
                                  if(!(return_value_lglterminate$24 == 0))
                                    return 1;

                                  else
                                  {
                                    signed int return_value_lgltreducing$26;
                                    return_value_lgltreducing$26=lgltreducing(lgl);
                                    if(!(return_value_lgltreducing$26 == 0))
                                    {
                                      return_value_lgltrd$25=lgltrd(lgl);
                                      if(!(return_value_lgltrd$25 == 0))
                                        goto __CPROVER_DUMP_L19;

                                      return 0;
                                    }

                                    else
                                    {

                                    __CPROVER_DUMP_L19:
                                      ;
                                      signed int return_value_lglterminate$27;
                                      return_value_lglterminate$27=lglterminate(lgl);
                                      if(!(return_value_lglterminate$27 == 0))
                                        return 1;

                                      else
                                      {
                                        signed int return_value_lglblocking$28;
                                        return_value_lglblocking$28=lglblocking(lgl);
                                        if(!(return_value_lglblocking$28 == 0))
                                          lglblock(lgl);

                                        signed int return_value_lglterminate$29;
                                        return_value_lglterminate$29=lglterminate(lgl);
                                        if(!(return_value_lglterminate$29 == 0))
                                          return 1;

                                        else
                                        {
                                          signed int return_value_lglcceing$31;
                                          return_value_lglcceing$31=lglcceing(lgl);
                                          if(!(return_value_lglcceing$31 == 0))
                                          {
                                            return_value_lglcce$30=lglcce(lgl);
                                            if(!(return_value_lglcce$30 == 0))
                                              goto __CPROVER_DUMP_L23;

                                            return 0;
                                          }

                                          else
                                          {

                                          __CPROVER_DUMP_L23:
                                            ;
                                            signed int return_value_lglterminate$32;
                                            return_value_lglterminate$32=lglterminate(lgl);
                                            if(!(return_value_lglterminate$32 == 0))
                                              return 1;

                                            else
                                            {
                                              signed int return_value_lgleliminating$34;
                                              return_value_lgleliminating$34=lgleliminating(lgl);
                                              if(!(return_value_lgleliminating$34 == 0))
                                              {
                                                return_value_lglelim$33=lglelim(lgl);
                                                if(!(return_value_lglelim$33 == 0))
                                                  goto __CPROVER_DUMP_L25;

                                                return 0;
                                              }

                                              else
                                              {

                                              __CPROVER_DUMP_L25:
                                                ;
                                                signed int return_value_lglterminate$35;
                                                return_value_lglterminate$35=lglterminate(lgl);
                                                if(!(return_value_lglterminate$35 == 0))
                                                  return 1;

                                                else
                                                {
                                                  if(!(lgl->opts->card.val == 0))
                                                    lglcard(lgl);

                                                  signed int return_value_lgltopgc$36;
                                                  return_value_lgltopgc$36=lgltopgc(lgl);
                                                  if(return_value_lgltopgc$36 == 0)
                                                    return 0;

                                                  else
                                                  {
                                                    signed int return_value_lglterminate$37;
                                                    return_value_lglterminate$37=lglterminate(lgl);
                                                    if(!(return_value_lglterminate$37 == 0))
                                                      return 1;

                                                    else
                                                    {
                                                      if(lgl->allphaseset == 0)
                                                        lglphase(lgl);

                                                      signed int return_value_lglterminate$38;
                                                      return_value_lglterminate$38=lglterminate(lgl);
                                                      if(!(return_value_lglterminate$38 == 0))
                                                        return 1;

                                                      else
                                                      {
                                                        lgldefrag(lgl);
                                                        return 1;
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// lglislook
// file lglib.c line 8841
static signed int lglislook(struct LGL *lgl)
{
  signed long int best;
  signed long int pos;
  signed long int neg;
  signed long int score;
  signed int res;
  signed int idx;
  signed int elit;
  signed int *scores;
  struct Ext *ext;
  scores=lglis(lgl);
  res = 0;
  best = (signed long int)res;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree$1;
    return_value_lglisfree$1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree$1 == 0))
    {
      signed int return_value_lglexport$2;
      return_value_lglexport$2=lglexport(lgl, idx);
      struct Ext *return_value_lglelit2ext$3;
      return_value_lglelit2ext$3=lglelit2ext(lgl, return_value_lglexport$2);
      if(return_value_lglelit2ext$3->blocking == 0u)
      {
        pos = (signed long int)scores[(signed long int)idx];
        neg = (signed long int)scores[(signed long int)-idx];
        score = pos * neg + pos + neg;
        if(!(best >= score) || res == 0)
        {

        __CPROVER_DUMP_L3:
          ;
          res = pos > neg ? idx : -idx;
          best = score;
        }

      }

    }

  }
  scores = scores - (signed long int)lgl->nvars;
  do
  {
    lgldel(lgl, (void *)scores, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
    scores = ((signed int *)NULL);
  }
  while((_Bool)0);
  if(!(res == 0))
  {
    elit=lglexport(lgl, res);
    ext=lglelit2ext(lgl, elit);
    lglprt(lgl, 1, "[lislook] best look-ahead %ld score %d", res, (signed long long int)best);
    if(!(ext->melted == 0u))
      ext->melted = (unsigned int)0;

    else

      __CPROVER_DUMP_L8:
        ;
  }

  else

    __CPROVER_DUMP_L10:
      ;

__CPROVER_DUMP_L7:
  ;
  return res;
}

// lglispow2
// file lglib.c line 979
static signed int lglispow2(signed int n)
{
  return (signed int)!((n & n - 1) != 0);
}

// lglistruefun
// file lglib.c line 10532
static signed int lglistruefun(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!(f[(signed long int)i] == 18446744073709551615ul))
      return 0;

  return 1;
}

// lglitcanbemelted
// file lglib.c line 18027
signed int lglitcanbemelted(struct LGL *lgl, signed int elit)
{
  signed int res;
  struct Ext *ext;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglitcanbemelted");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "litcanbemelted %d", elit);
    break;
  }
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglitcanbemelted");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not check zero literal for being frozen");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  signed int return_value_abs$3;
  return_value_abs$3=abs(elit);
  signed int return_value_lglfixed$2;
  signed int return_value_lglerepr$1;
  if(!(lgl->maxext >= return_value_abs$3))
    res = 0;

  else
  {
    return_value_lglfixed$2=lglfixed(lgl, elit);
    if(!(return_value_lglfixed$2 == 0))
      res = 0;

    else
    {
      return_value_lglerepr$1=lglerepr(lgl, elit);
      if(!(return_value_lglerepr$1 == elit))
        res = 0;

      else
      {
        ext=lglelit2ext(lgl, elit);
        if(ext->frozen == 0)
          res = 0;

        else
          if(!(ext->melted == 0u))
            res = 0;

          else
            res = 1;
      }
    }
  }

__CPROVER_DUMP_L13:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglitcanbemelted(lgl->clone, elit);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglitcanbemelted");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d", (const void *)"lglitcanbemelted", elit, CLONERES, (const void *)"lglitcanbemelted", elit, res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglitgone
// file lglib.c line 18014
signed int lglitgone(struct LGL *lgl, signed int elit)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglitgone");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "litgone %d", elit);
    break;
  }
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglitgone");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not check zero literal for being gone");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  signed int return_value_abs$4;
  return_value_abs$4=abs(elit);
  signed int return_value_lglfixed$3;
  signed int return_value_lglerepr$2;
  struct Ext *return_value_lglelit2ext$1;
  if(!(lgl->maxext >= return_value_abs$4))
    res = 1;

  else
  {
    return_value_lglfixed$3=lglfixed(lgl, elit);
    if(!(return_value_lglfixed$3 == 0))
      res = 1;

    else
    {
      return_value_lglerepr$2=lglerepr(lgl, elit);
      if(!(return_value_lglerepr$2 == elit))
        res = 1;

      else
      {
        return_value_lglelit2ext$1=lglelit2ext(lgl, elit);
        res = (signed int)return_value_lglelit2ext$1->eliminated;
      }
    }
  }

__CPROVER_DUMP_L11:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglitgone(lgl->clone, elit);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglitgone");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d", (const void *)"lglitgone", elit, CLONERES, (const void *)"lglitgone", elit, res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lgljoin
// file lglib.h line 83
signed int lgljoin(struct LGL *to, struct LGL *from)
{
  signed int elit;
  signed int ok;
  signed int ilit;
  signed int val;
  signed int res;
  signed int expected;
  struct LGL *lgl = to;
  const signed int *p;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lgljoin");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(to->forked == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lgljoin");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "expected forked state");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lglreqinit(from);
  lglstart(to, &to->times->all);
  if(to->level >= 1)
    lglbacktrack(to, 0);

  _Bool tmp_if_expr$2;
  signed int return_value_lglfailed$1;
  _Bool tmp_if_expr$4;
  if(!((384 & (signed int)from->state) == 0))
  {
    expected = 20;
    signed int return_value_lglmtstk$3;
    return_value_lglmtstk$3=lglmtstk(&from->fassume);
    if(!(return_value_lglmtstk$3 == 0))
    {

    __CPROVER_DUMP_L8:
      ;
      to->mt = 1;
    }

    else
    {
      p = from->fassume.start;
      for( ; !(p >= from->fassume.top); p = p + 1l)
      {
        elit = *p;
        if(!(from->bruteforked == 0))
          tmp_if_expr$2 = (_Bool)1;

        else
        {
          return_value_lglfailed$1=lglfailed(from, elit);
          tmp_if_expr$2 = return_value_lglfailed$1 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$2)
          lglfjadd(to, -elit);

      }
      lglfjadd(to, 0);
      lglforkmerge(to, from);
    }
  }

  else
    if(!((96 & (signed int)from->state) == 0))
    {
      expected = 10;
      lglforkmerge(to, from);
      ok=lglbcp(to);
      if(!(ok == 0))
      {
        elit = 1;
        do
        {
          if(!(ok == 0))
            tmp_if_expr$4 = elit <= to->maxext ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(!tmp_if_expr$4)
            break;

          if(from->maxext >= elit)
          {
            struct Ext *return_value_lglelit2ext$5;
            return_value_lglelit2ext$5=lglelit2ext(from, elit);
            if(!(return_value_lglelit2ext$5->imported == 0u))
            {
              val=lglderef(from, elit);
              if(!(val == 0))
              {
                ilit=lglimport(to, elit);
                signed int return_value_abs$6;
                return_value_abs$6=abs(ilit);
                if(!(return_value_abs$6 == 1))
                {
                  signed char return_value_lglval$7;
                  return_value_lglval$7=lglval(to, ilit);
                  if(return_value_lglval$7 == 0)
                  {
                    lgldassume(to, val < 0 ? -ilit : ilit);
                    ok=lglbcp(to);
                  }

                }

              }

            }

          }

          elit = elit + 1;
        }
        while((_Bool)1);
      }

    }

    else
    {
      expected = 0;
      lglforkmerge(to, from);
    }
  lglrelease(from);
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$10;
  unsigned long int return_value_lglcntstk$9;
  if(!(to->mt == 0))
    res = 20;

  else
    if(!(expected == 0))
      res=lglisat(to, ((struct Lim *)NULL), 0);

    else
    {
      if(!(to->conf.lit == 0))
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = to->next2 < to->next ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
        tmp_if_expr$10 = (_Bool)1;

      else
      {
        return_value_lglcntstk$9=lglcntstk(&to->trail);
        tmp_if_expr$10 = (unsigned long int)to->next < return_value_lglcntstk$9 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$10)
      {
        if(to->level >= 1)
        {
          lglbacktrack(to, 0);
          res = 0;
        }

        else
        {
          if(to->conf.lit == 0)
            lglbcp(to);

          if(!(to->conf.lit == 0))
          {
            if(to->mt == 0)
            {

            __CPROVER_DUMP_L35:
              ;
              to->mt = 1;
            }

            res = 20;
          }

          else
            res = 0;
        }
      }

      else
        res = 0;
    }
  to->forked = (char)0;
  lglrep(to, 1, (char)106);
  lglstop(to);
  return res;
}

// lgljwh
// file lglib.c line 6665
static void lgljwh(struct LGL *lgl)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int tag;
  signed int blit;
  signed int other;
  signed int other2;
  signed int red;
  signed int size;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  signed char val;
  signed char tmp;
  signed char tmp2;
  struct HTS *hts;
  struct Stk *s;
  signed long int inc;
  do
    memset((void *)lgl->jwh, 0, (unsigned long int)(2 * lgl->nvars) * sizeof(signed long int) /*8ul*/ );
  while((_Bool)0);
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      val=lglval(lgl, lit);
      if(!((signed int)val >= 1))
      {
        hts=lglhts(lgl, lit);
        if(!(hts->offset == 0))
        {
          w=lglhts2wchs(lgl, hts);
          eow = w + (signed long int)hts->count;
          p = w;
          for( ; !(p >= eow); p = p + 1l)
          {
            blit = *p;
            tag = blit & MASKCS;
            if(tag == TRNCS || tag == LRGCS)
              p = p + 1l;

            if(!(tag == LRGCS))
            {
              red = blit & REDCS;
              if(red == 0)
              {
                other = blit >> RMSHFT;
                signed int return_value_abs$1;
                return_value_abs$1=abs(other);
                signed int return_value_abs$2;
                return_value_abs$2=abs(lit);
                if(return_value_abs$1 >= return_value_abs$2)
                {
                  tmp=lglval(lgl, other);
                  if(!((signed int)tmp >= 1))
                  {
                    if(tag == BINCS)
                    {
                      inc=lglflt(-2, (unsigned long int)1);
                      lglincjwh(lgl, lit, inc);
                      lglincjwh(lgl, other, inc);
                    }

                    else
                    {
                      other2 = *p;
                      signed int return_value_abs$3;
                      return_value_abs$3=abs(other2);
                      signed int return_value_abs$4;
                      return_value_abs$4=abs(lit);
                      if(!(return_value_abs$3 >= return_value_abs$4))
                        goto __CPROVER_DUMP_L11;

                      tmp2=lglval(lgl, other2);
                      if((signed int)tmp2 >= 1)
                        goto __CPROVER_DUMP_L11;

                      size = 3 + (signed int)val + (signed int)tmp + (signed int)tmp2;
                      inc=lglflt(-size, (unsigned long int)1);
                      lglincjwh(lgl, lit, inc);
                      lglincjwh(lgl, other, inc);
                      lglincjwh(lgl, other2, inc);
                    }
                  }

                }

              }

            }


          __CPROVER_DUMP_L11:
            ;
          }
        }

      }

    }
  }
  s = &lgl->irr;
  c = s->start;
  signed char return_value_lglval$5;
  for( ; !(c >= s->top); c = p + (signed long int)1)
  {
    p = c;
    if(!(*p >= 134217727))
    {
      val = (signed char)-1;
      size = 0;
      do
      {
        other = *p;
        if(other == 0)
          break;

        tmp=lglval(lgl, other);
        if(!((signed int)val >= (signed int)tmp))
          val = tmp;

        if(tmp == 0)
          size = size + 1;

        p = p + 1l;
      }
      while((_Bool)1);
      if(!((signed int)val >= 1))
      {
        inc=lglflt(-size, (unsigned long int)1);
        p = c;
        do
        {
          other = *p;
          if(other == 0)
            break;

          return_value_lglval$5=lglval(lgl, other);
          if(return_value_lglval$5 == 0)
            lglincjwh(lgl, other, inc);

          p = p + 1l;
        }
        while((_Bool)1);
      }

    }

  }
}

// lgljwhlook
// file lglib.c line 8804
static signed int lgljwhlook(struct LGL *lgl)
{
  signed long int best;
  signed long int pos;
  signed long int neg;
  signed long int score;
  signed int res;
  signed int idx;
  signed int elit;
  struct Ext *ext;
  lgljwh(lgl);
  best = 0x0000000000000000ll;
  res = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree$1;
    return_value_lglisfree$1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree$1 == 0))
    {
      signed int return_value_lglexport$2;
      return_value_lglexport$2=lglexport(lgl, idx);
      struct Ext *return_value_lglelit2ext$3;
      return_value_lglelit2ext$3=lglelit2ext(lgl, return_value_lglexport$2);
      if(return_value_lglelit2ext$3->blocking == 0u)
      {
        signed int return_value_lglulit$4;
        return_value_lglulit$4=lglulit(idx);
        pos = lgl->jwh[(signed long int)return_value_lglulit$4];
        signed int return_value_lglulit$5;
        return_value_lglulit$5=lglulit(-idx);
        neg = lgl->jwh[(signed long int)return_value_lglulit$5];
        score=lglmulflt(pos, neg);
        signed long int return_value_lgladdflt$6;
        return_value_lgladdflt$6=lgladdflt(pos, neg);
        score=lgladdflt(score, return_value_lgladdflt$6);
        if(!(best >= score) || res == 0)
        {

        __CPROVER_DUMP_L3:
          ;
          res = pos > neg ? idx : -idx;
          best = score;
        }

      }

    }

  }
  if(!(res == 0))
  {
    elit=lglexport(lgl, res);
    ext=lglelit2ext(lgl, elit);
    const char *return_value_lglflt2str$7;
    return_value_lglflt2str$7=lglflt2str(lgl, best);
    lglprt(lgl, 1, "[jwhlook] best look-ahead %d score %s", res, return_value_lglflt2str$7);
    if(!(ext->melted == 0u))
      ext->melted = (unsigned int)0;

    else

      __CPROVER_DUMP_L7:
        ;
  }

  else

    __CPROVER_DUMP_L9:
      ;

__CPROVER_DUMP_L6:
  ;
  return res;
}

// lglm2i
// file lglib.c line 9265
static signed int lglm2i(struct LGL *lgl, signed int mlit)
{
  signed int res;
  signed int midx;
  midx=abs(mlit);
  res=lglpeek(&lgl->$anon0.elm->m2i, midx);
  if(!(mlit >= 0))
    res = -res;

  return res;
}

// lglmap
// file lglib.c line 7574
static void lglmap(struct LGL *lgl)
{
  signed int size;
  signed int *map;
  signed int oldnvars;
  signed int mapsize;
  size=lglmapsize(lgl);
  oldnvars = lgl->nvars;
  mapsize=lglmax(oldnvars, 2);
  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)mapsize * sizeof(signed int) /*4ul*/ );
    map = (signed int *)return_value_lglnew$1;
  }
  while((_Bool)0);
  lglmapnonequiv(lgl, map, size);
  lglmapequiv(lgl, map);
  lglforce(lgl, map);
  lglmaptrail(lgl, map);
  lglflushqmerged(lgl);
  lglmapqueue(lgl, map);
  lglmapvars(lgl, map, size + 2);
  lglmaplits(lgl, map);
  if(!(lgl->cgrclosing == 0))
    lglmapstk(lgl, map, &lgl->$anon0.cgr->units);

  lglmapext(lgl, map);
  lglmapass(lgl, map);
  lglmaphts(lgl, map);
  do
  {
    lgldel(lgl, (void *)map, (unsigned long int)mapsize * sizeof(signed int) /*4ul*/ );
    map = ((signed int *)NULL);
  }
  while((_Bool)0);
  if(!(lgl->repr == ((signed int *)NULL)))
    do
    {
      lgldel(lgl, (void *)lgl->repr, (unsigned long int)oldnvars * sizeof(signed int) /*4ul*/ );
      lgl->repr = ((signed int *)NULL);
    }
    while((_Bool)0);

  lglpicosatrestart(lgl);
  lgl->unassigned = size;
}

// lglmapass
// file lglib.c line 7230
static void lglmapass(struct LGL *lgl, signed int *map)
{
  signed int *p;
  signed int *q;
  signed int iass;
  signed int mass;
  signed int flushed;
  unsigned int bit;
  struct AVar *av;
  signed int return_value_abs$1;
  return_value_abs$1=abs(lgl->failed);
  if(!(return_value_abs$1 == 1))
    lgl->failed=lglmaplit(map, lgl->failed);

  q = lgl->assume.start;
  p = q;
  signed int *tmp_post$2;
  for( ; !(p >= lgl->assume.top); p = p + 1l)
  {
    iass = *p;
    mass=lglmaplit(map, iass);
    if(!(mass == 1))
    {
      if(mass == -1)
      {
        if(!(lgl->failed == -1))
        {

        __CPROVER_DUMP_L3:
          ;
          lgl->failed = -1;
        }

      }

      else
      {

      __CPROVER_DUMP_L5:
        ;
        av=lglavar(lgl, mass);
        bit = 1u << (signed int)(mass < 0);
        if((bit & (unsigned int)av->assumed) == 0u)
        {

        __CPROVER_DUMP_L6:
          ;
          av->assumed = (unsigned int)av->assumed | bit;
        }

        tmp_post$2 = q;
        q = q + 1l;
        *tmp_post$2 = mass;
      }
    }

  }
  lgl->assume.top = q;
  flushed = 0;
  q = lgl->assume.start;
  p = q;
  signed int *tmp_post$4;
  for( ; !(p >= lgl->assume.top); p = p + 1l)
  {
    iass = *p;
    signed int return_value_lglsignedmarked$3;
    return_value_lglsignedmarked$3=lglsignedmarked(lgl, iass);
    if(!(return_value_lglsignedmarked$3 == 0))
      flushed = flushed + 1;

    else
    {
      lglsignedmark(lgl, iass);
      tmp_post$4 = q;
      q = q + 1l;
      *tmp_post$4 = iass;
    }
  }
  lgl->assume.top = q;
  p = lgl->assume.start;
  for( ; !(p >= lgl->assume.top); p = p + 1l)
  {
    iass = *p;
    lglsignedunmark(lgl, iass);
  }
  if(!(flushed == 0))

    __CPROVER_DUMP_L16:
      ;

}

// lglmapequiv
// file lglib.c line 7413
static void lglmapequiv(struct LGL *lgl, signed int *map)
{
  signed int idx;
  signed int repr;
  signed int dst;
  struct AVar *av;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
    if(map[(signed long int)idx] == 0)
    {
      av=lglavar(lgl, idx);
      if(!((signed int)av->type == ELIMVAR))
      {
        repr=lglirepr(lgl, idx);
        dst=lglmaplit(map, repr);

      __CPROVER_DUMP_L2:
        ;
        map[(signed long int)idx] = dst;
      }

    }

}

// lglmapext
// file lglib.c line 7186
static void lglmapext(struct LGL *lgl, signed int *map)
{
  signed int eidx;
  signed int ilit;
  signed int mlit;
  struct Ext *ext;
  eidx = 1;
  for( ; lgl->maxext >= eidx; eidx = eidx + 1)
    lglerepr(lgl, eidx);
  eidx = 1;
  for( ; lgl->maxext >= eidx; eidx = eidx + 1)
  {
    ext = lgl->ext + (signed long int)eidx;
    if(!(ext->imported == 0u))
    {
      if(!(ext->equiv == 0u))

        __CPROVER_DUMP_L4:
          ;

      else
      {
        ilit = ext->repr;
        mlit=lglmaplit(map, ilit);

      __CPROVER_DUMP_L6:
        ;
        ext->repr = mlit;
      }
    }

  }
}

// lglmapglue
// file lglib.c line 6973
static void lglmapglue(struct LGL *lgl, signed int *map, struct Stk *lits)
{
  signed int *p;
  signed int *eol = lits->top;
  p = lits->start;
  signed int return_value_lglisact$1;
  for( ; !(p >= eol); p = p + 1l)
  {
    return_value_lglisact$1=lglisact(*p);
    if(return_value_lglisact$1 == 0)
      *p=lglmaplit(map, *p);

  }
}

// lglmaphts
// file lglib.c line 7054
static void lglmaphts(struct LGL *lgl, signed int *map)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int *w;
  signed int *eow;
  signed int *p;
  signed int other;
  signed int other2;
  signed int blit;
  signed int tag;
  signed int red;
  signed int newblit;
  signed int newother;
  signed int newother2;
  struct HTS *hts;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      hts=lglhts(lgl, lit);
      if(!(hts->count == 0))
      {
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          tag = blit & MASKCS;
          red = blit & REDCS;
          other = blit >> RMSHFT;
          newother=lglmaplit(map, other);
          newblit = newother << RMSHFT | tag | red;
          *p = newblit;
          if(!(tag == BINCS))
          {
            p = p + 1l;
            other2 = *p;
            if(!(tag == LRGCS))
            {
              newother2=lglmaplit(map, other2);
              *p = newother2;
            }

          }

        }
      }

    }
  }
}

// lglmaplit
// file lglib.c line 6962
static signed int lglmaplit(signed int *map, signed int lit)
{
  signed int return_value_abs$1;
  return_value_abs$1=abs(lit);
  signed int return_value_lglsgn$2;
  return_value_lglsgn$2=lglsgn(lit);
  return map[(signed long int)return_value_abs$1] * return_value_lglsgn$2;
}

// lglmaplits
// file lglib.c line 6980
static void lglmaplits(struct LGL *lgl, signed int *map)
{
  signed int glue;
  lglmapstk(lgl, map, &lgl->irr);
  glue = 0;
  for( ; !(glue >= 15); glue = glue + 1)
    lglmapglue(lgl, map, &lgl->red[(signed long int)glue]);
}

// lglmapnonequiv
// file lglib.c line 7382
static void lglmapnonequiv(struct LGL *lgl, signed int *map, signed int size)
{
  signed int count = 0;
  signed int idx;
  struct AVar *av;
  signed char val;
  map[(signed long int)0] = 0;
  map[(signed long int)1] = 1;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    if(map[(signed long int)idx] == 0)
    {
      av=lglavar(lgl, idx);
      if((signed int)av->type == FREEVAR)
      {
        if(!(map[(signed long int)idx] == 0))
          goto __CPROVER_DUMP_L7;


      __CPROVER_DUMP_L2:
        ;
        map[(signed long int)idx] = count + 2;
        count = count + 1;
      }

      else
        if(!((signed int)av->type == EQUIVAR))
        {
          if((signed int)av->type == FIXEDVAR)
          {
            val = lgl->vals[(signed long int)idx];

          __CPROVER_DUMP_L5:
            ;
            map[(signed long int)idx] = (signed int)val;
          }

          else
            map[(signed long int)idx] = 0;
        }

    }


  __CPROVER_DUMP_L7:
    ;
  }
}

// lglmapqln
// file lglib.c line 7098
static void lglmapqln(struct LGL *lgl, struct Qln *line, signed int *map)
{
  signed int prev;
  signed int lglmapqln$$1$$next;
  signed int i;
  struct Qnd *n;
  struct Qnd *m;
  i = line->first;
  _Bool tmp_if_expr$2;
  signed int return_value_lglisfree$1;
  do
  {
    if(!(i == 0))
    {
      return_value_lglisfree$1=lglisfree(lgl, i);
      tmp_if_expr$2 = !(return_value_lglisfree$1 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    n=lglqnd(lgl, i);
    lglmapqln$$1$$next = n->next;
    do
      memset((void *)n, 0, sizeof(struct Qnd) /*16ul*/ );
    while((_Bool)0);
    i = lglmapqln$$1$$next;
  }
  while((_Bool)1);
  signed int return_value_lglisfree$4;
  signed int tmp_if_expr$7;
  signed int return_value_lglmaplit$5;
  signed int return_value_abs$6;
  signed int tmp_if_expr$10;
  signed int return_value_lglmaplit$8;
  signed int return_value_abs$9;
  if(!(i == 0))
  {
    signed int return_value_lglmaplit$3;
    return_value_lglmaplit$3=lglmaplit(map, i);
    line->first=abs(return_value_lglmaplit$3);
    prev = 0;
    for( ; !(i == 0); i = lglmapqln$$1$$next)
    {
      n=lglqnd(lgl, i);
      lglmapqln$$1$$next = n->next;
      while(!(lglmapqln$$1$$next == 0))
      {
        return_value_lglisfree$4=lglisfree(lgl, lglmapqln$$1$$next);
        if(!(return_value_lglisfree$4 == 0))
          break;

        m=lglqnd(lgl, lglmapqln$$1$$next);
        lglmapqln$$1$$next = m->next;
        do
          memset((void *)m, 0, sizeof(struct Qnd) /*16ul*/ );
        while((_Bool)0);
      }
      if(!(prev == 0))
      {
        return_value_lglmaplit$5=lglmaplit(map, prev);
        return_value_abs$6=abs(return_value_lglmaplit$5);
        tmp_if_expr$7 = return_value_abs$6;
      }

      else
        tmp_if_expr$7 = 0;
      n->prev = tmp_if_expr$7;
      if(!(lglmapqln$$1$$next == 0))
      {
        return_value_lglmaplit$8=lglmaplit(map, lglmapqln$$1$$next);
        return_value_abs$9=abs(return_value_lglmaplit$8);
        tmp_if_expr$10 = return_value_abs$9;
      }

      else
        tmp_if_expr$10 = 0;
      n->next = tmp_if_expr$10;
      prev = i;
    }
    signed int return_value_lglmaplit$11;
    return_value_lglmaplit$11=lglmaplit(map, prev);
    line->last=abs(return_value_lglmaplit$11);
  }

  else
  {
    line->last = 0;
    line->first = line->last;
  }
  line->unassigned = line->first;
}

// lglmapqueue
// file lglib.c line 7125
static void lglmapqueue(struct LGL *lgl, signed int *map)
{
  struct Qln *p;
  struct Qln *up;
  struct Qln *down = ((struct Qln *)NULL);
  p = lgl->queue.bottom;
  for( ; !(p == ((struct Qln *)NULL)); p = up)
  {
    up = p->up;
    lglmapqln(lgl, p, map);
    if(!(p->first == 0))
    {
      if(!(down == ((struct Qln *)NULL)))
        down->up = p;

      else
        lgl->queue.bottom = p;
      p->down = down;
      down = p;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      lgl->queue.nlines = lgl->queue.nlines - 1;
      lgl->stats->queue.del = lgl->stats->queue.del + 1l;
      p->up = lgl->queue.free;
      lgl->queue.free = p;
    }
  }
  if(!(down == ((struct Qln *)NULL)))
    down->up = ((struct Qln *)NULL);

  else
    lgl->queue.bottom = ((struct Qln *)NULL);
  lgl->queue.top = down;
  lgl->queue.unassigned = lgl->queue.top;
}

// lglmapsize
// file lglib.c line 7374
static signed int lglmapsize(struct LGL *lgl)
{
  signed int size = 0;
  signed int idx = 2;
  signed int return_value_lglisfree$1;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    return_value_lglisfree$1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree$1 == 0))
      size = size + 1;

  }

__CPROVER_DUMP_L4:
  ;
  return size;
}

// lglmapstk
// file lglib.c line 6966
static void lglmapstk(struct LGL *lgl, signed int *map, struct Stk *lits)
{
  signed int *p;
  signed int *eol = lits->top;
  p = lits->start;
  for( ; !(p >= eol); p = p + 1l)
    *p=lglmaplit(map, *p);
}

// lglmaptrail
// file lglib.c line 7084
static void lglmaptrail(struct LGL *lgl, signed int *map)
{
  signed int *p;
  signed int *q;
  signed int src;
  signed int dst;
  p = lgl->trail.start;
  signed int return_value_lglevel$1;
  for( ; !(p >= lgl->trail.top); p = p + 1l)
  {
    return_value_lglevel$1=lglevel(lgl, *p);
    if(return_value_lglevel$1 >= 1)
      break;

  }
  q = lgl->trail.start;
  signed int *tmp_post$2;
  for( ; !(p >= lgl->trail.top); p = p + 1l)
  {
    src = *p;
    dst=lglmaplit(map, src);
    tmp_post$2 = q;
    q = q + 1l;
    *tmp_post$2 = dst;
  }
  lgl->trail.top = q;
  unsigned long int return_value_lglcntstk$3;
  return_value_lglcntstk$3=lglcntstk(&lgl->trail);
  lgl->next = (signed int)return_value_lglcntstk$3;
  lgl->next2 = lgl->next;
  lgl->flushed = lgl->next2;
}

// lglmapvars
// file lglib.c line 6987
static void lglmapvars(struct LGL *lgl, signed int *map, signed int nvars)
{
  signed int i;
  signed int oldnvars = lgl->nvars;
  signed int sign;
  signed int udst;
  signed int idst;
  signed int usrc;
  signed int isrc;
  struct DVar *dvars;
  struct AVar *avars;
  struct Qnd *nodes;
  signed char *lglmapvars$$1$$vals;
  signed int *i2e;
  signed long int *jwh;
  if(!(nvars >= 3))
    nvars = 0;

  do
  {
    lgldel(lgl, (void *)lgl->doms, (unsigned long int)(2 * lgl->szvars) * sizeof(signed int) /*4ul*/ );
    lgl->doms = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)(2 * nvars) * sizeof(signed int) /*4ul*/ );
    lgl->doms = (signed int *)return_value_lglnew$1;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew$2;
    return_value_lglnew$2=lglnew(lgl, (unsigned long int)nvars * sizeof(signed char) /*1ul*/ );
    lglmapvars$$1$$vals = (signed char *)return_value_lglnew$2;
  }
  while((_Bool)0);
  i = 2;
  signed int return_value_lglisfree$3;
  for( ; !(i >= oldnvars); i = i + 1)
  {
    return_value_lglisfree$3=lglisfree(lgl, i);
    if(!(return_value_lglisfree$3 == 0))
      lglmapvars$$1$$vals[(signed long int)map[(signed long int)i]] = lgl->vals[(signed long int)i];

  }
  do
  {
    lgldel(lgl, (void *)lgl->vals, (unsigned long int)lgl->szvars * sizeof(signed char) /*1ul*/ );
    lgl->vals = ((signed char *)NULL);
  }
  while((_Bool)0);
  lgl->vals = lglmapvars$$1$$vals;
  do
  {
    void *return_value_lglnew$4;
    return_value_lglnew$4=lglnew(lgl, (unsigned long int)nvars * sizeof(signed int) /*4ul*/ );
    i2e = (signed int *)return_value_lglnew$4;
  }
  while((_Bool)0);
  i = 2;
  signed int return_value_lglisfree$5;
  for( ; !(i >= oldnvars); i = i + 1)
  {
    return_value_lglisfree$5=lglisfree(lgl, i);
    if(!(return_value_lglisfree$5 == 0))
      i2e[(signed long int)map[(signed long int)i]] = lgl->i2e[(signed long int)i];

  }
  do
  {
    lgldel(lgl, (void *)lgl->i2e, (unsigned long int)lgl->szvars * sizeof(signed int) /*4ul*/ );
    lgl->i2e = ((signed int *)NULL);
  }
  while((_Bool)0);
  lgl->i2e = i2e;
  do
  {
    void *return_value_lglnew$6;
    return_value_lglnew$6=lglnew(lgl, (unsigned long int)nvars * sizeof(struct DVar) /*16ul*/ );
    dvars = (struct DVar *)return_value_lglnew$6;
  }
  while((_Bool)0);
  i = 2;
  signed int return_value_lglisfree$7;
  for( ; !(i >= oldnvars); i = i + 1)
  {
    return_value_lglisfree$7=lglisfree(lgl, i);
    if(!(return_value_lglisfree$7 == 0))
      dvars[(signed long int)map[(signed long int)i]] = lgl->dvars[(signed long int)i];

  }
  do
  {
    lgldel(lgl, (void *)lgl->dvars, (unsigned long int)lgl->szvars * sizeof(struct DVar) /*16ul*/ );
    lgl->dvars = ((struct DVar *)NULL);
  }
  while((_Bool)0);
  lgl->dvars = dvars;
  do
  {
    void *return_value_lglnew$8;
    return_value_lglnew$8=lglnew(lgl, (unsigned long int)(2 * nvars) * sizeof(signed long int) /*8ul*/ );
    jwh = (signed long int *)return_value_lglnew$8;
  }
  while((_Bool)0);
  i = 2;
  signed int return_value_lglisfree$9;
  for( ; !(i >= oldnvars); i = i + 1)
  {
    return_value_lglisfree$9=lglisfree(lgl, i);
    if(!(return_value_lglisfree$9 == 0))
    {
      sign = -1;
      for( ; !(sign >= 2); sign = sign + 2)
      {
        isrc = sign * i;
        idst = sign * map[(signed long int)i];
        usrc=lglulit(isrc);
        udst=lglulit(idst);
        jwh[(signed long int)udst]=lgladdflt(jwh[(signed long int)udst], lgl->jwh[(signed long int)usrc]);
      }
    }

  }
  do
  {
    lgldel(lgl, (void *)lgl->jwh, (unsigned long int)(2 * lgl->szvars) * sizeof(signed long int) /*8ul*/ );
    lgl->jwh = ((signed long int *)NULL);
  }
  while((_Bool)0);
  lgl->jwh = jwh;
  do
  {
    void *return_value_lglnew$10;
    return_value_lglnew$10=lglnew(lgl, (unsigned long int)nvars * sizeof(struct Qnd) /*16ul*/ );
    nodes = (struct Qnd *)return_value_lglnew$10;
  }
  while((_Bool)0);
  i = 2;
  signed int return_value_lglisfree$11;
  for( ; !(i >= oldnvars); i = i + 1)
  {
    return_value_lglisfree$11=lglisfree(lgl, i);
    if(!(return_value_lglisfree$11 == 0))
      nodes[(signed long int)map[(signed long int)i]] = lgl->queue.nodes[(signed long int)i];

  }
  do
  {
    lgldel(lgl, (void *)lgl->queue.nodes, (unsigned long int)lgl->szvars * sizeof(struct Qnd) /*16ul*/ );
    lgl->queue.nodes = ((struct Qnd *)NULL);
  }
  while((_Bool)0);
  lgl->queue.nodes = nodes;
  do
  {
    void *return_value_lglnew$12;
    return_value_lglnew$12=lglnew(lgl, (unsigned long int)nvars * sizeof(struct AVar) /*12ul*/ );
    avars = (struct AVar *)return_value_lglnew$12;
  }
  while((_Bool)0);
  i = 2;
  signed int return_value_lglisfree$13;
  for( ; !(i >= oldnvars); i = i + 1)
  {
    return_value_lglisfree$13=lglisfree(lgl, i);
    if(!(return_value_lglisfree$13 == 0))
      avars[(signed long int)map[(signed long int)i]] = lgl->avars[(signed long int)i];

  }
  do
  {
    lgldel(lgl, (void *)lgl->avars, (unsigned long int)lgl->szvars * sizeof(struct AVar) /*12ul*/ );
    lgl->avars = ((struct AVar *)NULL);
  }
  while((_Bool)0);
  lgl->avars = avars;
  lgl->szvars = nvars;
  lgl->nvars = lgl->szvars;
  lgl->stats->fixed.current = 0;
}

// lglmark
// file lglib.c line 2939
static void lglmark(struct LGL *lgl, signed int lit)
{
  struct AVar *return_value_lglavar$1;
  return_value_lglavar$1=lglavar(lgl, lit);
  return_value_lglavar$1->mark=lglsgn(lit);
}

// lglmarked
// file lglib.c line 2843
static signed int lglmarked(struct LGL *lgl, signed int lit)
{
  signed int res;
  struct AVar *return_value_lglavar$1;
  return_value_lglavar$1=lglavar(lgl, lit);
  res = return_value_lglavar$1->mark;
  if(!(lit >= 0))
    res = -res;

  return res;
}

// lglmatchbingate
// file lglib.c line 13124
static signed int lglmatchbingate(struct LGL *lgl, struct Gat *g, struct Gat *h)
{
  signed int g0;
  g0=lglcgrepr(lgl, g->$anon0.lits[(signed long int)0]);
  signed int g1;
  g1=lglcgrepr(lgl, g->$anon0.lits[(signed long int)1]);
  signed int h0;
  h0=lglcgrepr(lgl, h->$anon0.lits[(signed long int)0]);
  signed int h1;
  h1=lglcgrepr(lgl, h->$anon0.lits[(signed long int)1]);
  signed int sign;
  lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
  if((signed int)g->tag == XORTAG)
  {
    sign = 1;
    if(!(g0 >= 0))
    {
      sign = -sign;
      g0 = -g0;
    }

    if(!(g1 >= 0))
    {
      sign = -sign;
      g1 = -g1;
    }

    if(!(h0 >= 0))
    {
      sign = -sign;
      h0 = -h0;
    }

    if(!(h1 >= 0))
    {
      sign = -sign;
      h1 = -h1;
    }

  }

  else
    sign = 1;
  if(g0 == h0 && g1 == h1)
    return sign;

  else
    if(g0 == h1 && g1 == h0)
      return sign;

    else
      return 0;
}

// lglmatchgate
// file lglib.c line 13295
static signed int lglmatchgate(struct LGL *lgl, signed int fixed, struct Gat *g, struct Gat *h)
{
  signed int l;
  l=lglcgrepr(lgl, g->lhs);
  signed int k;
  k=lglcgrepr(lgl, h->lhs);
  signed int repr;
  signed int other;
  signed int s;
  lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
  if((signed int)g->tag == ITETAG)
  {
    s=lglmatchitegate(lgl, g, h);
    if(s == 0)
      return 0;

  }

  else
    if((signed int)g->size == 2)
    {
      s=lglmatchbingate(lgl, g, h);
      if(s == 0)
        return 0;

    }

    else
      if((signed int)g->tag == ANDTAG)
      {
        s=lglmatchlrgand(lgl, g, h);
        if(s == 0)
          return 0;

      }

      else
        if((signed int)g->tag == XORTAG)
        {
          s=lglmatchlrgxor(lgl, g, h);
          if(s == 0)
            return 0;

        }

        else
          return 0;
  repr = s * l;
  other = k;
  if(repr == other)
    return 0;

  else
  {
    lgl->stats->cgr.matched.all = lgl->stats->cgr.matched.all + 1;
    lgl->$anon0.cgr->matched.all = lgl->$anon0.cgr->matched.all + 1;
    if((signed int)g->tag == ANDTAG)
    {
      lgl->$anon0.cgr->matched.and = lgl->$anon0.cgr->matched.and + 1;
      lgl->stats->cgr.matched.and = lgl->stats->cgr.matched.and + 1;
    }

    if((signed int)g->tag == XORTAG)
    {
      lgl->$anon0.cgr->matched.xor = lgl->$anon0.cgr->matched.xor + 1;
      lgl->stats->cgr.matched.xor = lgl->stats->cgr.matched.xor + 1;
    }

    if((signed int)g->tag == ITETAG)
    {
      lgl->$anon0.cgr->matched.ite = lgl->$anon0.cgr->matched.ite + 1;
      lgl->stats->cgr.matched.ite = lgl->stats->cgr.matched.ite + 1;
    }

    if(repr == -other)
    {

    __CPROVER_DUMP_L14:
      ;
      lgl->mt = 1;
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L15:
      ;
      lglcgmerge(lgl, other, repr);
      signed int return_value_abs$1;
      return_value_abs$1=abs(fixed);
      signed int return_value_abs$2;
      return_value_abs$2=abs(other);
      if(return_value_abs$1 == return_value_abs$2)
        return 1;

      else
      {
        signed int return_value_abs$3;
        return_value_abs$3=abs(fixed);
        signed int return_value_abs$4;
        return_value_abs$4=abs(repr);
        if(return_value_abs$3 == return_value_abs$4)
          return 1;

        else
          return 0;
      }
    }
  }
}

// lglmatchitegate
// file lglib.c line 13098
static signed int lglmatchitegate(struct LGL *lgl, struct Gat *g, struct Gat *h)
{
  signed int gc;
  gc=lglcgrepr(lgl, g->$anon0.$anon1.cond);
  signed int gp;
  gp=lglcgrepr(lgl, g->$anon0.$anon1.pos);
  signed int gn;
  gn=lglcgrepr(lgl, g->$anon0.$anon1.neg);
  signed int hc;
  hc=lglcgrepr(lgl, h->$anon0.$anon1.cond);
  signed int hp;
  hp=lglcgrepr(lgl, h->$anon0.$anon1.pos);
  signed int hn;
  hn=lglcgrepr(lgl, h->$anon0.$anon1.neg);
  lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
  if(gc == 1)
  {
    if(gp == hp && hc == 1)
      return 1;

    if(gp == hn && hc == -1)
      return 1;

  }

  else
    if(gc == -1)
    {
      if(gn == hp && hc == 1)
        return 1;

      if(gn == hn && hc == -1)
        return 1;

    }

    else
      if(gc == hc)
      {
        if(gn == hn && gp == hp)
          return 1;

        if(gn == -hn && gp == -hp)
          return -1;

      }

      else
        if(gc == -hc)
        {
          if(gn == hp && gp == hn)
            return 1;

          if(gn == -hp && gp == -hn)
            return -1;

        }

  return 0;
}

// lglmatchlrgand
// file lglib.c line 13216
static signed int lglmatchlrgand(struct LGL *lgl, struct Gat *g, struct Gat *h)
{
  signed int res;
  res=lglmatchlrgandaux(lgl, g, h);
  if(res >= 0)
    return res;

  else
  {
    res=lglmatchlrgandaux(lgl, h, g);
    signed int return_value_abs$1;
    return_value_abs$1=abs(res);
    return return_value_abs$1;
  }
}

// lglmatchlrgandaux
// file lglib.c line 13144
static signed int lglmatchlrgandaux(struct LGL *lgl, struct Gat *g, struct Gat *h)
{
  signed int *p;
  signed int other;
  signed int repr;
  signed int bit;
  signed int res;
  signed int jumped;
  signed int gfalse;
  signed int gtrue;
  signed int htrue;
  signed int hfalse;
  signed int found;
  struct AVar *u;
  jumped = 1;
  gtrue = 1;
  gfalse = 0;
  found = 0;
  p = g->$anon0.$anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
    signed int return_value_abs$1;
    return_value_abs$1=abs(other);
    signed int return_value_abs$2;
    return_value_abs$2=abs(g->$anon0.$anon0.origlhs);
    if(return_value_abs$1 == return_value_abs$2)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, -other);
      if(repr == -1)
      {
        gfalse = 1;
        break;
      }

      if(!(repr == 1))
      {
        gtrue = 0;
        if(!(repr == other))
          jumped = -1;

        u=lglavar(lgl, repr);
        bit = 1 << (signed int)(repr < 0);
        if(!(((3 ^ bit) & u->mark) == 0))
          gfalse = 1;

        if((u->mark & bit) == 0)
          u->mark = u->mark | bit;

      }

    }
    p = p + 1l;
  }
  while((_Bool)1);
  res = 1;
  htrue = 1;
  hfalse = 0;
  found = 0;
  p = h->$anon0.$anon0.cls;
  _Bool tmp_if_expr$3;
  do
  {
    if(!(res == 0))
    {
      other = *p;
      tmp_if_expr$3 = other != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    signed int return_value_abs$4;
    return_value_abs$4=abs(other);
    signed int return_value_abs$5;
    return_value_abs$5=abs(h->$anon0.$anon0.origlhs);
    if(return_value_abs$4 == return_value_abs$5)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, -other);
      if(repr == -1)
      {
        hfalse = 1;
        break;
      }

      if(!(repr == 1))
      {
        htrue = 0;
        if(!(repr == other))
          jumped = -1;

        u=lglavar(lgl, repr);
        bit = 1 << (signed int)(repr < 0);
        if((u->mark & bit) == 0)
          res = 0;

      }

    }
    p = p + 1l;
  }
  while((_Bool)1);
  found = 0;
  p = g->$anon0.$anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    signed int return_value_abs$6;
    return_value_abs$6=abs(other);
    signed int return_value_abs$7;
    return_value_abs$7=abs(g->$anon0.$anon0.origlhs);
    if(return_value_abs$6 == return_value_abs$7)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, other);
      signed int return_value_abs$8;
      return_value_abs$8=abs(repr);
      if(!(return_value_abs$8 == 1))
      {
        u=lglavar(lgl, repr);
        u->mark = 0;
      }

    }
    p = p + 1l;
  }
  while((_Bool)1);
  if(!(gfalse == 0))
  {
    lglcgmergelhsrhs(lgl, g->lhs, -1);
    res = 0;
  }

  else
    if(!(gtrue == 0) && !(res == 0))
    {
      lglcgmergelhsrhs(lgl, g->lhs, 1);
      res = 0;
    }

  if(!(hfalse == 0))
  {
    lglcgmergelhsrhs(lgl, h->lhs, -1);
    res = 0;
  }

  else
    if(!(htrue == 0))
    {
      lglcgmergelhsrhs(lgl, h->lhs, 1);
      res = 0;
    }

  return jumped * res;
}

// lglmatchlrgxor
// file lglib.c line 13223
static signed int lglmatchlrgxor(struct LGL *lgl, struct Gat *g, struct Gat *h)
{
  signed int *p;
  signed int other;
  signed int repr;
  signed int res;
  signed int gconst;
  signed int hconst;
  signed int hpar;
  signed int gpar;
  signed int sign;
  signed int found;
  struct AVar *u;
  gconst = 1;
  gpar = -1;
  sign = 1;
  found = 0;
  p = g->$anon0.$anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
    signed int return_value_abs$1;
    return_value_abs$1=abs(other);
    signed int return_value_abs$2;
    return_value_abs$2=abs(g->$anon0.$anon0.origlhs);
    if(return_value_abs$1 == return_value_abs$2)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, other);
      if(!(repr >= 0))
      {
        sign = -sign;
        gpar = -gpar;
      }

      signed int return_value_abs$3;
      return_value_abs$3=abs(repr);
      if(return_value_abs$3 == 1)
        goto __CPROVER_DUMP_L6;

      else
        gconst = 0;
      u=lglavar(lgl, repr);
      u->mark = (signed int)!(u->mark != 0);
    }

  __CPROVER_DUMP_L6:
    ;
    p = p + 1l;
  }
  while((_Bool)1);
  hconst = 1;
  hpar = -1;
  found = 0;
  p = h->$anon0.$anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    signed int return_value_abs$4;
    return_value_abs$4=abs(other);
    signed int return_value_abs$5;
    return_value_abs$5=abs(h->$anon0.$anon0.origlhs);
    if(return_value_abs$4 == return_value_abs$5)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, other);
      signed int return_value_abs$6;
      return_value_abs$6=abs(repr);
      if(!(return_value_abs$6 == 1))
        hconst = 0;

      if(!(repr >= 0))
      {
        sign = -sign;
        hpar = -hpar;
      }

      signed int return_value_abs$7;
      return_value_abs$7=abs(repr);
      if(return_value_abs$7 == 1)
        goto __CPROVER_DUMP_L14;

      else
        gconst = 0;
      u=lglavar(lgl, repr);
      u->mark = (signed int)!(u->mark != 0);
    }

  __CPROVER_DUMP_L14:
    ;
    p = p + 1l;
  }
  while((_Bool)1);
  res = 1;
  found = 0;
  p = g->$anon0.$anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    signed int return_value_abs$8;
    return_value_abs$8=abs(other);
    signed int return_value_abs$9;
    return_value_abs$9=abs(g->$anon0.$anon0.origlhs);
    if(return_value_abs$8 == return_value_abs$9)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, other);
      signed int return_value_abs$10;
      return_value_abs$10=abs(repr);
      if(!(return_value_abs$10 == 1))
      {
        u=lglavar(lgl, repr);
        if(!(u->mark == 0))
        {
          u->mark = 0;
          res = 0;
        }

      }

    }
    p = p + 1l;
  }
  while((_Bool)1);
  found = 0;
  p = h->$anon0.$anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    signed int return_value_abs$11;
    return_value_abs$11=abs(other);
    signed int return_value_abs$12;
    return_value_abs$12=abs(h->$anon0.$anon0.origlhs);
    if(return_value_abs$11 == return_value_abs$12)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, other);
      signed int return_value_abs$13;
      return_value_abs$13=abs(repr);
      if(!(return_value_abs$13 == 1))
      {
        u=lglavar(lgl, repr);
        if(!(u->mark == 0))
        {
          u->mark = 0;
          res = 0;
        }

      }

    }
    p = p + 1l;
  }
  while((_Bool)1);
  if(!(gconst == 0))
  {
    lglcgmergelhsrhs(lgl, g->lhs, gpar);
    res = 0;
  }

  if(!(hconst == 0))
  {
    lglcgmergelhsrhs(lgl, h->lhs, hpar);
    res = 0;
  }

  return sign * res;
}

// lglmax
// file lglib.c line 2309
static signed int lglmax(signed int a, signed int b)
{
  return a > b ? a : b;
}

// lglmaxmb
// file lglib.c line 4997
double lglmaxmb(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmaxmb");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  return (double)(lgl->stats->bytes.max + sizeof(struct LGL) /*816ul*/ ) / (double)(1 << 20);
}

// lglmaxoptnamelen
// file lglib.c line 2087
static signed int lglmaxoptnamelen(struct LGL *lgl)
{
  signed int res = 0;
  signed int len;
  struct Opt *o = &lgl->opts->beforefirst + (signed long int)1;
  unsigned long int return_value_strlen$1;
  for( ; &lgl->opts->afterlast + -1l >= o; o = o + 1l)
  {
    return_value_strlen$1=strlen(o->lng);
    len = (signed int)return_value_strlen$1;
    if(!(res >= len))
      res = len;

  }
  return res;
}

// lglmaxvar
// file lglib.c line 17893
signed int lglmaxvar(struct LGL *lgl)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmaxvar");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "maxvar");
    break;
  }
  res = lgl->maxext;

__CPROVER_DUMP_L6:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglmaxvar(lgl->clone);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmaxvar");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone) = %d differs from %s (lgl) = %d", (const void *)"lglmaxvar", CLONERES, (const void *)"lglmaxvar", res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglmb
// file lglib.h line 287
double lglmb(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmb");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  return (double)(lgl->stats->bytes.current + sizeof(struct LGL) /*816ul*/ ) / (double)(1 << 20);
}

// lglmelt
// file lglib.h line 263
void lglmelt(struct LGL *lgl, signed int elit)
{
  struct Ext *ext;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmelt");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "melt %d", elit);
    break;
  }
  lgl->stats->calls.melt = lgl->stats->calls.melt + 1l;
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmelt");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not melt zero literal");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }

__CPROVER_DUMP_L8:
  ;
  do
  {
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmelt");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

    while((2039 & (signed int)lgl->state) == 0)
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmelt");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "!(%s)", (const void *)"UNUSED|OPTSET|USED|RESET| SATISFIED|UNSATISFIED|FAILED|UNKNOWN|LOOKED| EXTENDED");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
  }
  while((_Bool)0);

__CPROVER_DUMP_L14:
  ;
  lglimport(lgl, elit);
  ext=lglelit2ext(lgl, elit);
  while(ext->frozen == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmelt");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can not melt fully unfrozen literal %d", elit);
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  ext->frozen = ext->frozen - 1;
  lglmelter(lgl);
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglmelt(lgl->clone, elit);

}

// lglmeltall
// file lglib.c line 18043
void lglmeltall(struct LGL *lgl)
{
  signed int idx;
  signed int melted;
  struct Ext *ext;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmeltall");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  melted = 0;
  idx = 1;
  for( ; lgl->maxext >= idx; idx = idx + 1)
  {
    ext=lglelit2ext(lgl, idx);
    ext->melted = (unsigned int)0;
    if(!(ext->frozen == 0))
    {
      lgl->stats->irrprgss = lgl->stats->irrprgss + 1l;
      ext->frozen = 0;
      melted = melted + 1;
    }

  }
  lglprt(lgl, 1, "[meltall] melted %d frozen literals", melted);
}

// lglmelter
// file lglib.c line 2504
static void lglmelter(struct LGL *lgl)
{
  if(!(lgl->frozen == 0))
    lgl->frozen = (char)0;


__CPROVER_DUMP_L1:
  ;
}

// lglmin
// file lglib.c line 2311
static signed int lglmin(signed int a, signed int b)
{
  return a < b ? a : b;
}

// lglmincls
// file lglib.c line 6003
static void lglmincls(struct LGL *lgl, signed int uip)
{
  signed int *p;
  signed int *q;
  signed int other;
  signed int minimized;
  signed int size;
  lglstart(lgl, &lgl->times->mcls);
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(&lgl->clause);
  size = (signed int)(return_value_lglcntstk$1 - (unsigned long int)1);
  lgl->stats->lits.nonmin = lgl->stats->lits.nonmin + (signed long int)size;
  q = lgl->clause.start;
  minimized = 0;
  p = q;
  _Bool tmp_if_expr$4;
  signed int return_value_lglminclslit$3;
  signed int *tmp_post$2;
  do
  {
    other = *p;
    if(other == 0)
      break;

    if(!(other == uip))
    {
      return_value_lglminclslit$3=lglminclslit(lgl, other);
      tmp_if_expr$4 = return_value_lglminclslit$3 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
    {

    __CPROVER_DUMP_L4:
      ;
      minimized = minimized + 1;
    }

    else
    {
      tmp_post$2 = q;
      q = q + 1l;
      *tmp_post$2 = other;
    }
    p = p + 1l;
  }
  while((_Bool)1);
  signed int *tmp_post$5 = q;
  q = q + 1l;
  *tmp_post$5 = 0;
  lglclnpoisoned(lgl);

__CPROVER_DUMP_L8:
  ;

__CPROVER_DUMP_L9:
  ;
  lgl->clause.top = q;
  lglstop(lgl);
}

// lglminclslit
// file lglib.c line 4873
static signed int lglminclslit(struct LGL *lgl, signed int start)
{
  signed int lit;
  signed int tag;
  signed int r0;
  signed int r1;
  signed int other;
  signed int *p;
  signed int *q;
  signed int *top;
  signed int old;
  signed int poisoned;
  signed int *rsn;
  signed int found;
  struct AVar *av;
  struct AVar *bv;
  struct Stk stk;
  lit = start;
  rsn=lglrsn(lgl, lit);
  r0 = rsn[(signed long int)0];
  tag = r0 & MASKCS;
  signed int return_value_lglpoison$3;
  signed int *tmp_post$4;
  signed int return_value_lglpoison$5;
  signed int *tmp_post$7;
  struct AVar *return_value_lglavar$8;
  if(tag == DECISION)
    return 0;

  else
  {
    unsigned long int return_value_lglcntstk$1;
    return_value_lglcntstk$1=lglcntstk(&lgl->seen);
    old = (signed int)return_value_lglcntstk$1;
    do
      memset((void *)&stk, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    do
    {
      r1 = rsn[(signed long int)1];
      if(tag == BINCS || tag == TRNCS)
      {
        other = r0 >> RMSHFT;
        signed int return_value_lglpoison$2;
        return_value_lglpoison$2=lglpoison(lgl, other, &stk);
        if(!(return_value_lglpoison$2 == 0))
          break;

        if(tag == TRNCS)
        {
          return_value_lglpoison$3=lglpoison(lgl, r1, &stk);
          if(!(return_value_lglpoison$3 == 0))
            break;

        }

      }

      else
      {
        p=lglidx2lits(lgl, LRGCS, r0 & REDCS, r1);
        found = 0;
        do
        {
          tmp_post$4 = p;
          p = p + 1l;
          other = *tmp_post$4;
          if(other == 0)
            break;

          if(other == -lit)
            found = found + 1;

          else
          {
            return_value_lglpoison$5=lglpoison(lgl, other, &stk);
            if(!(return_value_lglpoison$5 == 0))
              goto FAILED;

          }
        }
        while((_Bool)1);
      }
      signed int return_value_lglmtstk$6;
      return_value_lglmtstk$6=lglmtstk(&stk);
      if(!(return_value_lglmtstk$6 == 0))
      {
        lglrelstk(lgl, &stk);
        return 1;
      }

      lit=lglpopstk(&stk);
      rsn=lglrsn(lgl, lit);
      r0 = rsn[(signed long int)0];
      tag = r0 & MASKCS;
    }
    while((_Bool)1);

  FAILED:
    ;
    lglrelstk(lgl, &stk);
    p = lgl->seen.top;
    lgl->seen.top = lgl->seen.start + (signed long int)old;
    top = lgl->seen.top;
    while(!(top >= p))
    {
      p = p - 1l;
      lit = *p;
      av=lglavar(lgl, lit);
      av->mark = 0;
      poisoned = (signed int)av->poisoned;
      if(poisoned == 0)
      {
        rsn=lglrsn(lgl, lit);
        r0 = rsn[(signed long int)0];
        tag = r0 & MASKCS;
        r1 = rsn[(signed long int)1];
        if(tag == BINCS || tag == TRNCS)
        {
          other = r0 >> RMSHFT;
          bv=lglavar(lgl, other);
          if(!(bv->poisoned == 0u))
            poisoned = 1;

          else
            if(tag == TRNCS)
            {
              bv=lglavar(lgl, r1);
              if(!(bv->poisoned == 0u))
                poisoned = 1;

            }

        }

        else
        {
          q=lglidx2lits(lgl, LRGCS, r0 & REDCS, r1);
          for( ; poisoned == 0; poisoned = (signed int)return_value_lglavar$8->poisoned)
          {
            tmp_post$7 = q;
            q = q + 1l;
            other = *tmp_post$7;
            if(other == 0)
              break;

            return_value_lglavar$8=lglavar(lgl, other);
          }
        }
        if(!(poisoned == 0))
        {
          av->poisoned = (unsigned int)1;
          lglpushstk(lgl, &lgl->poisoned, lit);
        }

      }

    }
    return 0;
  }
}

// lglminit
// file lglib.c line 1700
struct LGL * lglminit(void *mem, void * (*alloc)(void *, unsigned long int), void * (*realloc)(void *, void *, unsigned long int, unsigned long int), void (*dealloc)(void *, void *, unsigned long int))
{
  const signed int K = 1000;
  const signed int M = K * K;
  const signed int I = 0x7fffffff;
  const char *apitracename;
  struct LGL *lgl;
  signed int i;
  lgl = ((struct LGL *)NULL);
  while(!((signed int)(dealloc == ((void (*)(void *, void *, unsigned long int))NULL)) + (signed int)(alloc == ((void * (*)(void *, unsigned long int))NULL)) + (signed int)(realloc == ((void * (*)(void *, void *, unsigned long int, unsigned long int))NULL)) == 0) && !((signed int)(dealloc == ((void (*)(void *, void *, unsigned long int))NULL)) + (signed int)(alloc == ((void * (*)(void *, unsigned long int))NULL)) + (signed int)(realloc == ((void * (*)(void *, void *, unsigned long int, unsigned long int))NULL)) == 3))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglminit");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "inconsistent set of external memory handlers");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lgl=lglnewlgl(mem, alloc, realloc, dealloc);
  lgl->tid = -1;
  lglpushcontrol(lgl, 0);
  lgl->out = stdout;
  lgl->prefix=lglstrdup(lgl, "c ");
  apitracename=getenv("LGLAPITRACE");
  if(!(apitracename == ((const char *)NULL)))
    lglopenapitrace(lgl, apitracename);

  do
  {
    struct Opt *lglminit$$1$$2$$opt = &lgl->opts->abstime;
    lglminit$$1$$2$$opt->shrt = (char)0;
    lglminit$$1$$2$$opt->lng = "abstime";
    lglminit$$1$$2$$opt->val = 0;
    lglminit$$1$$2$$opt->min = 0;
    lglminit$$1$$2$$opt->max = 1;
    lglminit$$1$$2$$opt->descrp = "print absolute time when reporting";
    lglgetenv(lgl, lglminit$$1$$2$$opt, "abstime");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$3$$opt = &lgl->opts->acts;
    lglminit$$1$$3$$opt->shrt = (char)0;
    lglminit$$1$$3$$opt->lng = "acts";
    lglminit$$1$$3$$opt->val = 2;
    lglminit$$1$$3$$opt->min = 0;
    lglminit$$1$$3$$opt->max = 2;
    lglminit$$1$$3$$opt->descrp = "activity based reduction: 0=disable,1=enable,2=dyn";
    lglgetenv(lgl, lglminit$$1$$3$$opt, "acts");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$4$$opt = &lgl->opts->actavgmax;
    lglminit$$1$$4$$opt->shrt = (char)0;
    lglminit$$1$$4$$opt->lng = "actavgmax";
    lglminit$$1$$4$$opt->val = 120;
    lglminit$$1$$4$$opt->min = 0;
    lglminit$$1$$4$$opt->max = 200;
    lglminit$$1$$4$$opt->descrp = "glue average max limit for dyn acts";
    lglgetenv(lgl, lglminit$$1$$4$$opt, "actavgmax");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$5$$opt = &lgl->opts->actstdmin;
    lglminit$$1$$5$$opt->shrt = (char)0;
    lglminit$$1$$5$$opt->lng = "actstdmin";
    lglminit$$1$$5$$opt->val = 20;
    lglminit$$1$$5$$opt->min = 0;
    lglminit$$1$$5$$opt->max = 200;
    lglminit$$1$$5$$opt->descrp = "glue standard deviation min limit for dyn acts";
    lglgetenv(lgl, lglminit$$1$$5$$opt, "actstdmin");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$6$$opt = &lgl->opts->actstdmax;
    lglminit$$1$$6$$opt->shrt = (char)0;
    lglminit$$1$$6$$opt->lng = "actstdmax";
    lglminit$$1$$6$$opt->val = 80;
    lglminit$$1$$6$$opt->min = 0;
    lglminit$$1$$6$$opt->max = 200;
    lglminit$$1$$6$$opt->descrp = "glue standard deviation max limit for dyn acts";
    lglgetenv(lgl, lglminit$$1$$6$$opt, "actstdmax");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$7$$opt = &lgl->opts->agile;
    lglminit$$1$$7$$opt->shrt = (char)0;
    lglminit$$1$$7$$opt->lng = "agile";
    lglminit$$1$$7$$opt->val = 23;
    lglminit$$1$$7$$opt->min = 0;
    lglminit$$1$$7$$opt->max = 100;
    lglminit$$1$$7$$opt->descrp = "agility limit for restarts";
    lglgetenv(lgl, lglminit$$1$$7$$opt, "agile");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$8$$opt = &lgl->opts->bias;
    lglminit$$1$$8$$opt->shrt = (char)0;
    lglminit$$1$$8$$opt->lng = "bias";
    lglminit$$1$$8$$opt->val = 2;
    lglminit$$1$$8$$opt->min = -1;
    lglminit$$1$$8$$opt->max = 2;
    lglminit$$1$$8$$opt->descrp = "decision order initial bias (0=nobias,2=cutwidth)";
    lglgetenv(lgl, lglminit$$1$$8$$opt, "bias");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$9$$opt = &lgl->opts->block;
    lglminit$$1$$9$$opt->shrt = (char)0;
    lglminit$$1$$9$$opt->lng = "block";
    lglminit$$1$$9$$opt->val = 1;
    lglminit$$1$$9$$opt->min = 0;
    lglminit$$1$$9$$opt->max = 1;
    lglminit$$1$$9$$opt->descrp = "blocked clause elimination (BCE)";
    lglgetenv(lgl, lglminit$$1$$9$$opt, "block");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$10$$opt = &lgl->opts->blkrtc;
    lglminit$$1$$10$$opt->shrt = (char)0;
    lglminit$$1$$10$$opt->lng = "blkrtc";
    lglminit$$1$$10$$opt->val = 0;
    lglminit$$1$$10$$opt->min = 0;
    lglminit$$1$$10$$opt->max = 1;
    lglminit$$1$$10$$opt->descrp = "run BCE until completion";
    lglgetenv(lgl, lglminit$$1$$10$$opt, "blkrtc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$11$$opt = &lgl->opts->blkclslim;
    lglminit$$1$$11$$opt->shrt = (char)0;
    lglminit$$1$$11$$opt->lng = "blkclslim";
    lglminit$$1$$11$$opt->val = 2000;
    lglminit$$1$$11$$opt->min = 3;
    lglminit$$1$$11$$opt->max = I;
    lglminit$$1$$11$$opt->descrp = "max blocked clause size";
    lglgetenv(lgl, lglminit$$1$$11$$opt, "blkclslim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$12$$opt = &lgl->opts->blkocclim;
    lglminit$$1$$12$$opt->shrt = (char)0;
    lglminit$$1$$12$$opt->lng = "blkocclim";
    lglminit$$1$$12$$opt->val = 2000;
    lglminit$$1$$12$$opt->min = 3;
    lglminit$$1$$12$$opt->max = I;
    lglminit$$1$$12$$opt->descrp = "max occurrences in blocked clause elimination";
    lglgetenv(lgl, lglminit$$1$$12$$opt, "blkocclim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$13$$opt = &lgl->opts->blkmaxeff;
    lglminit$$1$$13$$opt->shrt = (char)0;
    lglminit$$1$$13$$opt->lng = "blkmaxeff";
    lglminit$$1$$13$$opt->val = I;
    lglminit$$1$$13$$opt->min = -1;
    lglminit$$1$$13$$opt->max = I;
    lglminit$$1$$13$$opt->descrp = "max effort in BCE (-1=unlimited)";
    lglgetenv(lgl, lglminit$$1$$13$$opt, "blkmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$14$$opt = &lgl->opts->blkmineff;
    lglminit$$1$$14$$opt->shrt = (char)0;
    lglminit$$1$$14$$opt->lng = "blkmineff";
    lglminit$$1$$14$$opt->val = 10 * M;
    lglminit$$1$$14$$opt->min = 0;
    lglminit$$1$$14$$opt->max = I;
    lglminit$$1$$14$$opt->descrp = "min effort in BCE";
    lglgetenv(lgl, lglminit$$1$$14$$opt, "blkmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$15$$opt = &lgl->opts->blkreleff;
    lglminit$$1$$15$$opt->shrt = (char)0;
    lglminit$$1$$15$$opt->lng = "blkreleff";
    lglminit$$1$$15$$opt->val = 20;
    lglminit$$1$$15$$opt->min = 0;
    lglminit$$1$$15$$opt->max = K;
    lglminit$$1$$15$$opt->descrp = "rel effort in BCE";
    lglgetenv(lgl, lglminit$$1$$15$$opt, "blkreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$16$$opt = &lgl->opts->card;
    lglminit$$1$$16$$opt->shrt = (char)0;
    lglminit$$1$$16$$opt->lng = "card";
    lglminit$$1$$16$$opt->val = 0;
    lglminit$$1$$16$$opt->min = 0;
    lglminit$$1$$16$$opt->max = 1;
    lglminit$$1$$16$$opt->descrp = "extract cardinality constraints";
    lglgetenv(lgl, lglminit$$1$$16$$opt, "card");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$17$$opt = &lgl->opts->cce;
    lglminit$$1$$17$$opt->shrt = (char)0;
    lglminit$$1$$17$$opt->lng = "cce";
    lglminit$$1$$17$$opt->val = 3;
    lglminit$$1$$17$$opt->min = 0;
    lglminit$$1$$17$$opt->max = 3;
    lglminit$$1$$17$$opt->descrp = "covered clause elimination (1=ate,2=abce,3=cce)";
    lglgetenv(lgl, lglminit$$1$$17$$opt, "cce");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$18$$opt = &lgl->opts->ccemaxeff;
    lglminit$$1$$18$$opt->shrt = (char)0;
    lglminit$$1$$18$$opt->lng = "ccemaxeff";
    lglminit$$1$$18$$opt->val = 100 * M;
    lglminit$$1$$18$$opt->min = -1;
    lglminit$$1$$18$$opt->max = I;
    lglminit$$1$$18$$opt->descrp = "max effort in covered clause elimination";
    lglgetenv(lgl, lglminit$$1$$18$$opt, "ccemaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$19$$opt = &lgl->opts->ccemineff;
    lglminit$$1$$19$$opt->shrt = (char)0;
    lglminit$$1$$19$$opt->lng = "ccemineff";
    lglminit$$1$$19$$opt->val = 5 * M;
    lglminit$$1$$19$$opt->min = 0;
    lglminit$$1$$19$$opt->max = I;
    lglminit$$1$$19$$opt->descrp = "min effort in covered clause elimination";
    lglgetenv(lgl, lglminit$$1$$19$$opt, "ccemineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$20$$opt = &lgl->opts->ccereleff;
    lglminit$$1$$20$$opt->shrt = (char)0;
    lglminit$$1$$20$$opt->lng = "ccereleff";
    lglminit$$1$$20$$opt->val = 3;
    lglminit$$1$$20$$opt->min = 0;
    lglminit$$1$$20$$opt->max = K;
    lglminit$$1$$20$$opt->descrp = "rel effort in covered clause elimination";
    lglgetenv(lgl, lglminit$$1$$20$$opt, "ccereleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$21$$opt = &lgl->opts->check;
    lglminit$$1$$21$$opt->shrt = (char)99;
    lglminit$$1$$21$$opt->lng = "check";
    lglminit$$1$$21$$opt->val = 0;
    lglminit$$1$$21$$opt->min = 0;
    lglminit$$1$$21$$opt->max = 3;
    lglminit$$1$$21$$opt->descrp = "check level";
    lglgetenv(lgl, lglminit$$1$$21$$opt, "check");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$22$$opt = &lgl->opts->cgrclsr;
    lglminit$$1$$22$$opt->shrt = (char)0;
    lglminit$$1$$22$$opt->lng = "cgrclsr";
    lglminit$$1$$22$$opt->val = 1;
    lglminit$$1$$22$$opt->min = 0;
    lglminit$$1$$22$$opt->max = 1;
    lglminit$$1$$22$$opt->descrp = "gate extraction and congruence closure";
    lglgetenv(lgl, lglminit$$1$$22$$opt, "cgrclsr");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$23$$opt = &lgl->opts->cgrmaxority;
    lglminit$$1$$23$$opt->shrt = (char)0;
    lglminit$$1$$23$$opt->lng = "cgrmaxority";
    lglminit$$1$$23$$opt->val = 20;
    lglminit$$1$$23$$opt->min = 2;
    lglminit$$1$$23$$opt->max = 30;
    lglminit$$1$$23$$opt->descrp = "maximum xor arity to be extracted";
    lglgetenv(lgl, lglminit$$1$$23$$opt, "cgrmaxority");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$24$$opt = &lgl->opts->cgrmaxeff;
    lglminit$$1$$24$$opt->shrt = (char)0;
    lglminit$$1$$24$$opt->lng = "cgrmaxeff";
    lglminit$$1$$24$$opt->val = 8 * M;
    lglminit$$1$$24$$opt->min = -1;
    lglminit$$1$$24$$opt->max = I;
    lglminit$$1$$24$$opt->descrp = "max effort in congruence closure";
    lglgetenv(lgl, lglminit$$1$$24$$opt, "cgrmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$25$$opt = &lgl->opts->cgrmineff;
    lglminit$$1$$25$$opt->shrt = (char)0;
    lglminit$$1$$25$$opt->lng = "cgrmineff";
    lglminit$$1$$25$$opt->val = 200 * K;
    lglminit$$1$$25$$opt->min = 0;
    lglminit$$1$$25$$opt->max = I;
    lglminit$$1$$25$$opt->descrp = "min effort in congruence closure";
    lglgetenv(lgl, lglminit$$1$$25$$opt, "cgrmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$26$$opt = &lgl->opts->cgreleff;
    lglminit$$1$$26$$opt->shrt = (char)0;
    lglminit$$1$$26$$opt->lng = "cgreleff";
    lglminit$$1$$26$$opt->val = 1;
    lglminit$$1$$26$$opt->min = 0;
    lglminit$$1$$26$$opt->max = 10 * K;
    lglminit$$1$$26$$opt->descrp = "rel effort in congruence closure";
    lglgetenv(lgl, lglminit$$1$$26$$opt, "cgreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$27$$opt = &lgl->opts->cgrexteq;
    lglminit$$1$$27$$opt->shrt = (char)0;
    lglminit$$1$$27$$opt->lng = "cgrexteq";
    lglminit$$1$$27$$opt->val = 1;
    lglminit$$1$$27$$opt->min = 0;
    lglminit$$1$$27$$opt->max = 1;
    lglminit$$1$$27$$opt->descrp = "extract equivalences";
    lglgetenv(lgl, lglminit$$1$$27$$opt, "cgrexteq");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$28$$opt = &lgl->opts->cgrextand;
    lglminit$$1$$28$$opt->shrt = (char)0;
    lglminit$$1$$28$$opt->lng = "cgrextand";
    lglminit$$1$$28$$opt->val = 1;
    lglminit$$1$$28$$opt->min = 0;
    lglminit$$1$$28$$opt->max = 1;
    lglminit$$1$$28$$opt->descrp = "extract and gates";
    lglgetenv(lgl, lglminit$$1$$28$$opt, "cgrextand");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$29$$opt = &lgl->opts->cgrextxor;
    lglminit$$1$$29$$opt->shrt = (char)0;
    lglminit$$1$$29$$opt->lng = "cgrextxor";
    lglminit$$1$$29$$opt->val = 1;
    lglminit$$1$$29$$opt->min = 0;
    lglminit$$1$$29$$opt->max = 1;
    lglminit$$1$$29$$opt->descrp = "extract xor gates";
    lglgetenv(lgl, lglminit$$1$$29$$opt, "cgrextxor");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$30$$opt = &lgl->opts->cgrextite;
    lglminit$$1$$30$$opt->shrt = (char)0;
    lglminit$$1$$30$$opt->lng = "cgrextite";
    lglminit$$1$$30$$opt->val = 1;
    lglminit$$1$$30$$opt->min = 0;
    lglminit$$1$$30$$opt->max = 1;
    lglminit$$1$$30$$opt->descrp = "extract ite gates";
    lglgetenv(lgl, lglminit$$1$$30$$opt, "cgrextite");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$31$$opt = &lgl->opts->cgrextunits;
    lglminit$$1$$31$$opt->shrt = (char)0;
    lglminit$$1$$31$$opt->lng = "cgrextunits";
    lglminit$$1$$31$$opt->val = 1;
    lglminit$$1$$31$$opt->min = 0;
    lglminit$$1$$31$$opt->max = 1;
    lglminit$$1$$31$$opt->descrp = "extract units";
    lglgetenv(lgl, lglminit$$1$$31$$opt, "cgrextunits");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$32$$opt = &lgl->opts->cliff;
    lglminit$$1$$32$$opt->shrt = (char)0;
    lglminit$$1$$32$$opt->lng = "cliff";
    lglminit$$1$$32$$opt->val = 1;
    lglminit$$1$$32$$opt->min = 0;
    lglminit$$1$$32$$opt->max = 1;
    lglminit$$1$$32$$opt->descrp = "cliffing";
    lglgetenv(lgl, lglminit$$1$$32$$opt, "cliff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$33$$opt = &lgl->opts->cliffmaxeff;
    lglminit$$1$$33$$opt->shrt = (char)0;
    lglminit$$1$$33$$opt->lng = "cliffmaxeff";
    lglminit$$1$$33$$opt->val = 100 * M;
    lglminit$$1$$33$$opt->min = -1;
    lglminit$$1$$33$$opt->max = I;
    lglminit$$1$$33$$opt->descrp = "max effort in cliffing";
    lglgetenv(lgl, lglminit$$1$$33$$opt, "cliffmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$34$$opt = &lgl->opts->cliffmineff;
    lglminit$$1$$34$$opt->shrt = (char)0;
    lglminit$$1$$34$$opt->lng = "cliffmineff";
    lglminit$$1$$34$$opt->val = 10 * M;
    lglminit$$1$$34$$opt->min = 0;
    lglminit$$1$$34$$opt->max = I;
    lglminit$$1$$34$$opt->descrp = "min effort in cliffing";
    lglgetenv(lgl, lglminit$$1$$34$$opt, "cliffmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$35$$opt = &lgl->opts->cliffreleff;
    lglminit$$1$$35$$opt->shrt = (char)0;
    lglminit$$1$$35$$opt->lng = "cliffreleff";
    lglminit$$1$$35$$opt->val = 8;
    lglminit$$1$$35$$opt->min = 0;
    lglminit$$1$$35$$opt->max = 10 * K;
    lglminit$$1$$35$$opt->descrp = "rel effort in cliffing";
    lglgetenv(lgl, lglminit$$1$$35$$opt, "cliffreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$36$$opt = &lgl->opts->compact;
    lglminit$$1$$36$$opt->shrt = (char)0;
    lglminit$$1$$36$$opt->lng = "compact";
    lglminit$$1$$36$$opt->val = 0;
    lglminit$$1$$36$$opt->min = 0;
    lglminit$$1$$36$$opt->max = 2;
    lglminit$$1$$36$$opt->descrp = "compactify after 'lglsat' + 'lglsimp' (1=UNS,2=SAT)";
    lglgetenv(lgl, lglminit$$1$$36$$opt, "compact");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$37$$opt = &lgl->opts->decompose;
    lglminit$$1$$37$$opt->shrt = (char)0;
    lglminit$$1$$37$$opt->lng = "decompose";
    lglminit$$1$$37$$opt->val = 1;
    lglminit$$1$$37$$opt->min = 0;
    lglminit$$1$$37$$opt->max = 1;
    lglminit$$1$$37$$opt->descrp = "enable decompose";
    lglgetenv(lgl, lglminit$$1$$37$$opt, "decompose");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$38$$opt = &lgl->opts->defragfree;
    lglminit$$1$$38$$opt->shrt = (char)0;
    lglminit$$1$$38$$opt->lng = "defragfree";
    lglminit$$1$$38$$opt->val = 50;
    lglminit$$1$$38$$opt->min = 10;
    lglminit$$1$$38$$opt->max = K;
    lglminit$$1$$38$$opt->descrp = "defragmentation free watches limit";
    lglgetenv(lgl, lglminit$$1$$38$$opt, "defragfree");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$39$$opt = &lgl->opts->defragint;
    lglminit$$1$$39$$opt->shrt = (char)0;
    lglminit$$1$$39$$opt->lng = "defragint";
    lglminit$$1$$39$$opt->val = 10 * M;
    lglminit$$1$$39$$opt->min = 100;
    lglminit$$1$$39$$opt->max = I;
    lglminit$$1$$39$$opt->descrp = "defragmentation pushed watches interval";
    lglgetenv(lgl, lglminit$$1$$39$$opt, "defragint");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$40$$opt = &lgl->opts->elim;
    lglminit$$1$$40$$opt->shrt = (char)0;
    lglminit$$1$$40$$opt->lng = "elim";
    lglminit$$1$$40$$opt->val = 1;
    lglminit$$1$$40$$opt->min = 0;
    lglminit$$1$$40$$opt->max = 1;
    lglminit$$1$$40$$opt->descrp = "bounded variable eliminiation (BVE)";
    lglgetenv(lgl, lglminit$$1$$40$$opt, "elim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$41$$opt = &lgl->opts->elmrtc;
    lglminit$$1$$41$$opt->shrt = (char)0;
    lglminit$$1$$41$$opt->lng = "elmrtc";
    lglminit$$1$$41$$opt->val = 0;
    lglminit$$1$$41$$opt->min = 0;
    lglminit$$1$$41$$opt->max = 1;
    lglminit$$1$$41$$opt->descrp = "run BVE until completion";
    lglgetenv(lgl, lglminit$$1$$41$$opt, "elmrtc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$42$$opt = &lgl->opts->elmblk;
    lglminit$$1$$42$$opt->shrt = (char)0;
    lglminit$$1$$42$$opt->lng = "elmblk";
    lglminit$$1$$42$$opt->val = 1;
    lglminit$$1$$42$$opt->min = 0;
    lglminit$$1$$42$$opt->max = 1;
    lglminit$$1$$42$$opt->descrp = "enable BCE during BVE";
    lglgetenv(lgl, lglminit$$1$$42$$opt, "elmblk");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$43$$opt = &lgl->opts->elmclslim;
    lglminit$$1$$43$$opt->shrt = (char)0;
    lglminit$$1$$43$$opt->lng = "elmclslim";
    lglminit$$1$$43$$opt->val = 1000;
    lglminit$$1$$43$$opt->min = 3;
    lglminit$$1$$43$$opt->max = I;
    lglminit$$1$$43$$opt->descrp = "max antecendent size in elimination";
    lglgetenv(lgl, lglminit$$1$$43$$opt, "elmclslim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$44$$opt = &lgl->opts->elmocclim;
    lglminit$$1$$44$$opt->shrt = (char)0;
    lglminit$$1$$44$$opt->lng = "elmocclim";
    lglminit$$1$$44$$opt->val = 1000;
    lglminit$$1$$44$$opt->min = 3;
    lglminit$$1$$44$$opt->max = I;
    lglminit$$1$$44$$opt->descrp = "max occurences in elimination";
    lglgetenv(lgl, lglminit$$1$$44$$opt, "elmocclim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$45$$opt = &lgl->opts->elmaxeff;
    lglminit$$1$$45$$opt->shrt = (char)0;
    lglminit$$1$$45$$opt->lng = "elmaxeff";
    lglminit$$1$$45$$opt->val = 100 * M;
    lglminit$$1$$45$$opt->min = -1;
    lglminit$$1$$45$$opt->max = I;
    lglminit$$1$$45$$opt->descrp = "max effort in BVE (-1=unlimited)";
    lglgetenv(lgl, lglminit$$1$$45$$opt, "elmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$46$$opt = &lgl->opts->elmineff;
    lglminit$$1$$46$$opt->shrt = (char)0;
    lglminit$$1$$46$$opt->lng = "elmineff";
    lglminit$$1$$46$$opt->val = 5 * M;
    lglminit$$1$$46$$opt->min = 0;
    lglminit$$1$$46$$opt->max = I;
    lglminit$$1$$46$$opt->descrp = "min effort in BVE";
    lglgetenv(lgl, lglminit$$1$$46$$opt, "elmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$47$$opt = &lgl->opts->elmreleff;
    lglminit$$1$$47$$opt->shrt = (char)0;
    lglminit$$1$$47$$opt->lng = "elmreleff";
    lglminit$$1$$47$$opt->val = 10;
    lglminit$$1$$47$$opt->min = 0;
    lglminit$$1$$47$$opt->max = 10 * K;
    lglminit$$1$$47$$opt->descrp = "rel effort in BVE";
    lglgetenv(lgl, lglminit$$1$$47$$opt, "elmreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$48$$opt = &lgl->opts->sleeponabort;
    lglminit$$1$$48$$opt->shrt = (char)0;
    lglminit$$1$$48$$opt->lng = "sleeponabort";
    lglminit$$1$$48$$opt->val = 0;
    lglminit$$1$$48$$opt->min = 0;
    lglminit$$1$$48$$opt->max = I;
    lglminit$$1$$48$$opt->descrp = "sleep this seconds before abort/exit";
    lglgetenv(lgl, lglminit$$1$$48$$opt, "sleeponabort");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$49$$opt = &lgl->opts->exitonabort;
    lglminit$$1$$49$$opt->shrt = (char)0;
    lglminit$$1$$49$$opt->lng = "exitonabort";
    lglminit$$1$$49$$opt->val = 0;
    lglminit$$1$$49$$opt->min = 0;
    lglminit$$1$$49$$opt->max = 1;
    lglminit$$1$$49$$opt->descrp = "exit instead abort after internal error";
    lglgetenv(lgl, lglminit$$1$$49$$opt, "exitonabort");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$50$$opt = &lgl->opts->flipping;
    lglminit$$1$$50$$opt->shrt = (char)0;
    lglminit$$1$$50$$opt->lng = "flipping";
    lglminit$$1$$50$$opt->val = 1;
    lglminit$$1$$50$$opt->min = 0;
    lglminit$$1$$50$$opt->max = 1;
    lglminit$$1$$50$$opt->descrp = "enable point flipping";
    lglgetenv(lgl, lglminit$$1$$50$$opt, "flipping");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$51$$opt = &lgl->opts->flipint;
    lglminit$$1$$51$$opt->shrt = (char)0;
    lglminit$$1$$51$$opt->lng = "flipint";
    lglminit$$1$$51$$opt->val = 2;
    lglminit$$1$$51$$opt->min = 0;
    lglminit$$1$$51$$opt->max = I;
    lglminit$$1$$51$$opt->descrp = "flipping interval in number of top level decision";
    lglgetenv(lgl, lglminit$$1$$51$$opt, "flipint");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$52$$opt = &lgl->opts->flipdur;
    lglminit$$1$$52$$opt->shrt = (char)0;
    lglminit$$1$$52$$opt->lng = "flipdur";
    lglminit$$1$$52$$opt->val = 50;
    lglminit$$1$$52$$opt->min = 1;
    lglminit$$1$$52$$opt->max = I;
    lglminit$$1$$52$$opt->descrp = "flipping duration in number of conflicts";
    lglgetenv(lgl, lglminit$$1$$52$$opt, "flipdur");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$53$$opt = &lgl->opts->fliptop;
    lglminit$$1$$53$$opt->shrt = (char)0;
    lglminit$$1$$53$$opt->lng = "fliptop";
    lglminit$$1$$53$$opt->val = 1;
    lglminit$$1$$53$$opt->min = 0;
    lglminit$$1$$53$$opt->max = 1;
    lglminit$$1$$53$$opt->descrp = "flipping only at the top level";
    lglgetenv(lgl, lglminit$$1$$53$$opt, "fliptop");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$54$$opt = &lgl->opts->force;
    lglminit$$1$$54$$opt->shrt = (char)0;
    lglminit$$1$$54$$opt->lng = "force";
    lglminit$$1$$54$$opt->val = 0;
    lglminit$$1$$54$$opt->min = 0;
    lglminit$$1$$54$$opt->max = I;
    lglminit$$1$$54$$opt->descrp = "reorder variables with force algorithm";
    lglgetenv(lgl, lglminit$$1$$54$$opt, "force");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$55$$opt = &lgl->opts->gauss;
    lglminit$$1$$55$$opt->shrt = (char)0;
    lglminit$$1$$55$$opt->lng = "gauss";
    lglminit$$1$$55$$opt->val = 1;
    lglminit$$1$$55$$opt->min = 0;
    lglminit$$1$$55$$opt->max = 1;
    lglminit$$1$$55$$opt->descrp = "gaussion elimination";
    lglgetenv(lgl, lglminit$$1$$55$$opt, "gauss");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$56$$opt = &lgl->opts->gaussextrall;
    lglminit$$1$$56$$opt->shrt = (char)0;
    lglminit$$1$$56$$opt->lng = "gaussextrall";
    lglminit$$1$$56$$opt->val = 1;
    lglminit$$1$$56$$opt->min = 0;
    lglminit$$1$$56$$opt->max = 1;
    lglminit$$1$$56$$opt->descrp = "extract all xors (with duplicates)";
    lglgetenv(lgl, lglminit$$1$$56$$opt, "gaussextrall");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$57$$opt = &lgl->opts->gaussmaxor;
    lglminit$$1$$57$$opt->shrt = (char)0;
    lglminit$$1$$57$$opt->lng = "gaussmaxor";
    lglminit$$1$$57$$opt->val = 20;
    lglminit$$1$$57$$opt->min = 2;
    lglminit$$1$$57$$opt->max = 64;
    lglminit$$1$$57$$opt->descrp = "maximum xor size in gaussian elimination";
    lglgetenv(lgl, lglminit$$1$$57$$opt, "gaussmaxor");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$58$$opt = &lgl->opts->gaussexptrn;
    lglminit$$1$$58$$opt->shrt = (char)0;
    lglminit$$1$$58$$opt->lng = "gaussexptrn";
    lglminit$$1$$58$$opt->val = 1;
    lglminit$$1$$58$$opt->min = 0;
    lglminit$$1$$58$$opt->max = 1;
    lglminit$$1$$58$$opt->descrp = "export ternary clauses from gaussian elimination";
    lglgetenv(lgl, lglminit$$1$$58$$opt, "gaussexptrn");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$59$$opt = &lgl->opts->gaussmaxeff;
    lglminit$$1$$59$$opt->shrt = (char)0;
    lglminit$$1$$59$$opt->lng = "gaussmaxeff";
    lglminit$$1$$59$$opt->val = 50 * M;
    lglminit$$1$$59$$opt->min = -1;
    lglminit$$1$$59$$opt->max = I;
    lglminit$$1$$59$$opt->descrp = "max effort in gaussian elimination";
    lglgetenv(lgl, lglminit$$1$$59$$opt, "gaussmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$60$$opt = &lgl->opts->gaussmineff;
    lglminit$$1$$60$$opt->shrt = (char)0;
    lglminit$$1$$60$$opt->lng = "gaussmineff";
    lglminit$$1$$60$$opt->val = 2 * M;
    lglminit$$1$$60$$opt->min = 0;
    lglminit$$1$$60$$opt->max = I;
    lglminit$$1$$60$$opt->descrp = "min effort in gaussian elimination";
    lglgetenv(lgl, lglminit$$1$$60$$opt, "gaussmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$61$$opt = &lgl->opts->gaussreleff;
    lglminit$$1$$61$$opt->shrt = (char)0;
    lglminit$$1$$61$$opt->lng = "gaussreleff";
    lglminit$$1$$61$$opt->val = 2;
    lglminit$$1$$61$$opt->min = 0;
    lglminit$$1$$61$$opt->max = 10 * K;
    lglminit$$1$$61$$opt->descrp = "rel effort in gaussian elimination";
    lglgetenv(lgl, lglminit$$1$$61$$opt, "gaussreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$62$$opt = &lgl->opts->gluescale;
    lglminit$$1$$62$$opt->shrt = (char)0;
    lglminit$$1$$62$$opt->lng = "gluescale";
    lglminit$$1$$62$$opt->val = 2;
    lglminit$$1$$62$$opt->min = 1;
    lglminit$$1$$62$$opt->max = 3;
    lglminit$$1$$62$$opt->descrp = "glue scaling: 1=linear,2=sqrt,3=ld";
    lglgetenv(lgl, lglminit$$1$$62$$opt, "gluescale");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$63$$opt = &lgl->opts->gluekeep;
    lglminit$$1$$63$$opt->shrt = (char)0;
    lglminit$$1$$63$$opt->lng = "gluekeep";
    lglminit$$1$$63$$opt->val = 0;
    lglminit$$1$$63$$opt->min = 0;
    lglminit$$1$$63$$opt->max = I;
    lglminit$$1$$63$$opt->descrp = "keep clauses with this original glue";
    lglgetenv(lgl, lglminit$$1$$63$$opt, "gluekeep");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$64$$opt = &lgl->opts->inprocessing;
    lglminit$$1$$64$$opt->shrt = (char)0;
    lglminit$$1$$64$$opt->lng = "inprocessing";
    lglminit$$1$$64$$opt->val = 1;
    lglminit$$1$$64$$opt->min = 0;
    lglminit$$1$$64$$opt->max = 1;
    lglminit$$1$$64$$opt->descrp = "enable inprocessing";
    lglgetenv(lgl, lglminit$$1$$64$$opt, "inprocessing");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$65$$opt = &lgl->opts->cintinc;
    lglminit$$1$$65$$opt->shrt = (char)0;
    lglminit$$1$$65$$opt->lng = "cintinc";
    lglminit$$1$$65$$opt->val = 10 * K;
    lglminit$$1$$65$$opt->min = 10;
    lglminit$$1$$65$$opt->max = M;
    lglminit$$1$$65$$opt->descrp = "inprocessing conflict interval increment";
    lglgetenv(lgl, lglminit$$1$$65$$opt, "cintinc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$66$$opt = &lgl->opts->irrlim;
    lglminit$$1$$66$$opt->shrt = (char)0;
    lglminit$$1$$66$$opt->lng = "irrlim";
    lglminit$$1$$66$$opt->val = 20;
    lglminit$$1$$66$$opt->min = 1;
    lglminit$$1$$66$$opt->max = 200;
    lglminit$$1$$66$$opt->descrp = "general irredundant added literals limit";
    lglgetenv(lgl, lglminit$$1$$66$$opt, "irrlim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$67$$opt = &lgl->opts->lift;
    lglminit$$1$$67$$opt->shrt = (char)0;
    lglminit$$1$$67$$opt->lng = "lift";
    lglminit$$1$$67$$opt->val = 1;
    lglminit$$1$$67$$opt->min = 0;
    lglminit$$1$$67$$opt->max = 1;
    lglminit$$1$$67$$opt->descrp = "enable double lookahead lifting";
    lglgetenv(lgl, lglminit$$1$$67$$opt, "lift");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$68$$opt = &lgl->opts->lftmaxeff;
    lglminit$$1$$68$$opt->shrt = (char)0;
    lglminit$$1$$68$$opt->lng = "lftmaxeff";
    lglminit$$1$$68$$opt->val = 20 * M;
    lglminit$$1$$68$$opt->min = -1;
    lglminit$$1$$68$$opt->max = I;
    lglminit$$1$$68$$opt->descrp = "max effort in lifting";
    lglgetenv(lgl, lglminit$$1$$68$$opt, "lftmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$69$$opt = &lgl->opts->lftmineff;
    lglminit$$1$$69$$opt->shrt = (char)0;
    lglminit$$1$$69$$opt->lng = "lftmineff";
    lglminit$$1$$69$$opt->val = 500 * K;
    lglminit$$1$$69$$opt->min = 0;
    lglminit$$1$$69$$opt->max = I;
    lglminit$$1$$69$$opt->descrp = "min effort in lifting";
    lglgetenv(lgl, lglminit$$1$$69$$opt, "lftmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$70$$opt = &lgl->opts->lftreleff;
    lglminit$$1$$70$$opt->shrt = (char)0;
    lglminit$$1$$70$$opt->lng = "lftreleff";
    lglminit$$1$$70$$opt->val = 6;
    lglminit$$1$$70$$opt->min = 0;
    lglminit$$1$$70$$opt->max = 10 * K;
    lglminit$$1$$70$$opt->descrp = "rel effort in lifting";
    lglgetenv(lgl, lglminit$$1$$70$$opt, "lftreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$71$$opt = &lgl->opts->lhbr;
    lglminit$$1$$71$$opt->shrt = (char)0;
    lglminit$$1$$71$$opt->lng = "lhbr";
    lglminit$$1$$71$$opt->val = 1;
    lglminit$$1$$71$$opt->min = 0;
    lglminit$$1$$71$$opt->max = 1;
    lglminit$$1$$71$$opt->descrp = "enable lazy hyber binary reasoning";
    lglgetenv(lgl, lglminit$$1$$71$$opt, "lhbr");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$72$$opt = &lgl->opts->lkhd;
    lglminit$$1$$72$$opt->shrt = (char)0;
    lglminit$$1$$72$$opt->lng = "lkhd";
    lglminit$$1$$72$$opt->val = 1;
    lglminit$$1$$72$$opt->min = 0;
    lglminit$$1$$72$$opt->max = 1;
    lglminit$$1$$72$$opt->descrp = "0=LIS,1=JWH";
    lglgetenv(lgl, lglminit$$1$$72$$opt, "lkhd");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$73$$opt = &lgl->opts->clim;
    lglminit$$1$$73$$opt->shrt = (char)0;
    lglminit$$1$$73$$opt->lng = "clim";
    lglminit$$1$$73$$opt->val = -1;
    lglminit$$1$$73$$opt->min = -1;
    lglminit$$1$$73$$opt->max = I;
    lglminit$$1$$73$$opt->descrp = "conflict limit";
    lglgetenv(lgl, lglminit$$1$$73$$opt, "clim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$74$$opt = &lgl->opts->mocint;
    lglminit$$1$$74$$opt->shrt = (char)0;
    lglminit$$1$$74$$opt->lng = "mocint";
    lglminit$$1$$74$$opt->val = 1000;
    lglminit$$1$$74$$opt->min = 1;
    lglminit$$1$$74$$opt->max = I;
    lglminit$$1$$74$$opt->descrp = "multiple objectives conflict limit interval";
    lglgetenv(lgl, lglminit$$1$$74$$opt, "mocint");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$75$$opt = &lgl->opts->move;
    lglminit$$1$$75$$opt->shrt = (char)0;
    lglminit$$1$$75$$opt->lng = "move";
    lglminit$$1$$75$$opt->val = 2;
    lglminit$$1$$75$$opt->min = 0;
    lglminit$$1$$75$$opt->max = 2;
    lglminit$$1$$75$$opt->descrp = "move redundant clauses (1=only binary)";
    lglgetenv(lgl, lglminit$$1$$75$$opt, "move");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$76$$opt = &lgl->opts->log;
    lglminit$$1$$76$$opt->shrt = (char)108;
    lglminit$$1$$76$$opt->lng = "log";
    lglminit$$1$$76$$opt->val = -1;
    lglminit$$1$$76$$opt->min = -1;
    lglminit$$1$$76$$opt->max = 5;
    lglminit$$1$$76$$opt->descrp = "log level";
    lglgetenv(lgl, lglminit$$1$$76$$opt, "log");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$77$$opt = &lgl->opts->otfs;
    lglminit$$1$$77$$opt->shrt = (char)0;
    lglminit$$1$$77$$opt->lng = "otfs";
    lglminit$$1$$77$$opt->val = 1;
    lglminit$$1$$77$$opt->min = 0;
    lglminit$$1$$77$$opt->max = 1;
    lglminit$$1$$77$$opt->descrp = "enable on-the-fly subsumption";
    lglgetenv(lgl, lglminit$$1$$77$$opt, "otfs");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$78$$opt = &lgl->opts->phase;
    lglminit$$1$$78$$opt->shrt = (char)0;
    lglminit$$1$$78$$opt->lng = "phase";
    lglminit$$1$$78$$opt->val = 0;
    lglminit$$1$$78$$opt->min = -1;
    lglminit$$1$$78$$opt->max = 1;
    lglminit$$1$$78$$opt->descrp = "default phase (-1=neg,0=JeroslowWang,1=pos)";
    lglgetenv(lgl, lglminit$$1$$78$$opt, "phase");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$79$$opt = &lgl->opts->phaseneginit;
    lglminit$$1$$79$$opt->shrt = (char)0;
    lglminit$$1$$79$$opt->lng = "phaseneginit";
    lglminit$$1$$79$$opt->val = 0;
    lglminit$$1$$79$$opt->min = 0;
    lglminit$$1$$79$$opt->max = I;
    lglminit$$1$$79$$opt->descrp = "initial zero phase conflict interval";
    lglgetenv(lgl, lglminit$$1$$79$$opt, "phaseneginit");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$80$$opt = &lgl->opts->plain;
    lglminit$$1$$80$$opt->shrt = (char)0;
    lglminit$$1$$80$$opt->lng = "plain";
    lglminit$$1$$80$$opt->val = 0;
    lglminit$$1$$80$$opt->min = 0;
    lglminit$$1$$80$$opt->max = 1;
    lglminit$$1$$80$$opt->descrp = "plain mode disables all preprocessing";
    lglgetenv(lgl, lglminit$$1$$80$$opt, "plain");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$81$$opt = &lgl->opts->probe;
    lglminit$$1$$81$$opt->shrt = (char)0;
    lglminit$$1$$81$$opt->lng = "probe";
    lglminit$$1$$81$$opt->val = 1;
    lglminit$$1$$81$$opt->min = 0;
    lglminit$$1$$81$$opt->max = 1;
    lglminit$$1$$81$$opt->descrp = "enable probing";
    lglgetenv(lgl, lglminit$$1$$81$$opt, "probe");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$82$$opt = &lgl->opts->prbasic;
    lglminit$$1$$82$$opt->shrt = (char)0;
    lglminit$$1$$82$$opt->lng = "prbasic";
    lglminit$$1$$82$$opt->val = 1;
    lglminit$$1$$82$$opt->min = 0;
    lglminit$$1$$82$$opt->max = 2;
    lglminit$$1$$82$$opt->descrp = "enable basic probing procedure (1=roots only)";
    lglgetenv(lgl, lglminit$$1$$82$$opt, "prbasic");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$83$$opt = &lgl->opts->prbasicroundlim;
    lglminit$$1$$83$$opt->shrt = (char)0;
    lglminit$$1$$83$$opt->lng = "prbasicroundlim";
    lglminit$$1$$83$$opt->val = 9;
    lglminit$$1$$83$$opt->min = 1;
    lglminit$$1$$83$$opt->max = I;
    lglminit$$1$$83$$opt->descrp = "basic probing round limit";
    lglgetenv(lgl, lglminit$$1$$83$$opt, "prbasicroundlim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$84$$opt = &lgl->opts->prbasicmaxeff;
    lglminit$$1$$84$$opt->shrt = (char)0;
    lglminit$$1$$84$$opt->lng = "prbasicmaxeff";
    lglminit$$1$$84$$opt->val = 100 * M;
    lglminit$$1$$84$$opt->min = -1;
    lglminit$$1$$84$$opt->max = I;
    lglminit$$1$$84$$opt->descrp = "max effort in basic probing";
    lglgetenv(lgl, lglminit$$1$$84$$opt, "prbasicmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$85$$opt = &lgl->opts->prbasicmineff;
    lglminit$$1$$85$$opt->shrt = (char)0;
    lglminit$$1$$85$$opt->lng = "prbasicmineff";
    lglminit$$1$$85$$opt->val = M;
    lglminit$$1$$85$$opt->min = 0;
    lglminit$$1$$85$$opt->max = I;
    lglminit$$1$$85$$opt->descrp = "min effort in basic probing";
    lglgetenv(lgl, lglminit$$1$$85$$opt, "prbasicmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$86$$opt = &lgl->opts->prbasicreleff;
    lglminit$$1$$86$$opt->shrt = (char)0;
    lglminit$$1$$86$$opt->lng = "prbasicreleff";
    lglminit$$1$$86$$opt->val = 10;
    lglminit$$1$$86$$opt->min = 0;
    lglminit$$1$$86$$opt->max = 10 * K;
    lglminit$$1$$86$$opt->descrp = "rel effort in basic probing";
    lglgetenv(lgl, lglminit$$1$$86$$opt, "prbasicreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$87$$opt = &lgl->opts->queuemergelim;
    lglminit$$1$$87$$opt->shrt = (char)0;
    lglminit$$1$$87$$opt->lng = "queuemergelim";
    lglminit$$1$$87$$opt->val = 10000;
    lglminit$$1$$87$$opt->min = 1;
    lglminit$$1$$87$$opt->max = I;
    lglminit$$1$$87$$opt->descrp = "flush limit on garbage merged queue lines";
    lglgetenv(lgl, lglminit$$1$$87$$opt, "queuemergelim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$88$$opt = &lgl->opts->queuefactor;
    lglminit$$1$$88$$opt->shrt = (char)0;
    lglminit$$1$$88$$opt->lng = "queuefactor";
    lglminit$$1$$88$$opt->val = 833;
    lglminit$$1$$88$$opt->min = 1;
    lglminit$$1$$88$$opt->max = 999;
    lglminit$$1$$88$$opt->descrp = "queue unbump factor in per mille";
    lglgetenv(lgl, lglminit$$1$$88$$opt, "queuefactor");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$89$$opt = &lgl->opts->queueinc;
    lglminit$$1$$89$$opt->shrt = (char)0;
    lglminit$$1$$89$$opt->lng = "queueinc";
    lglminit$$1$$89$$opt->val = 20;
    lglminit$$1$$89$$opt->min = 1;
    lglminit$$1$$89$$opt->max = 1000;
    lglminit$$1$$89$$opt->descrp = "queue bump increment";
    lglgetenv(lgl, lglminit$$1$$89$$opt, "queueinc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$90$$opt = &lgl->opts->rmincpen;
    lglminit$$1$$90$$opt->shrt = (char)0;
    lglminit$$1$$90$$opt->lng = "rmincpen";
    lglminit$$1$$90$$opt->val = 4;
    lglminit$$1$$90$$opt->min = 0;
    lglminit$$1$$90$$opt->max = 32;
    lglminit$$1$$90$$opt->descrp = "logarithm of watcher removal penalty";
    lglgetenv(lgl, lglminit$$1$$90$$opt, "rmincpen");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$91$$opt = &lgl->opts->seed;
    lglminit$$1$$91$$opt->shrt = (char)0;
    lglminit$$1$$91$$opt->lng = "seed";
    lglminit$$1$$91$$opt->val = 0;
    lglminit$$1$$91$$opt->min = 0;
    lglminit$$1$$91$$opt->max = I;
    lglminit$$1$$91$$opt->descrp = "random number generator seed";
    lglgetenv(lgl, lglminit$$1$$91$$opt, "seed");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$92$$opt = &lgl->opts->smallirr;
    lglminit$$1$$92$$opt->shrt = (char)0;
    lglminit$$1$$92$$opt->lng = "smallirr";
    lglminit$$1$$92$$opt->val = 90;
    lglminit$$1$$92$$opt->min = 0;
    lglminit$$1$$92$$opt->max = 100;
    lglminit$$1$$92$$opt->descrp = "max percentage irr lits for BCE and VE";
    lglgetenv(lgl, lglminit$$1$$92$$opt, "smallirr");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$93$$opt = &lgl->opts->smallve;
    lglminit$$1$$93$$opt->shrt = (char)0;
    lglminit$$1$$93$$opt->lng = "smallve";
    lglminit$$1$$93$$opt->val = 1;
    lglminit$$1$$93$$opt->min = 0;
    lglminit$$1$$93$$opt->max = 1;
    lglminit$$1$$93$$opt->descrp = "enable small number variables elimination";
    lglgetenv(lgl, lglminit$$1$$93$$opt, "smallve");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$94$$opt = &lgl->opts->smallvevars;
    lglminit$$1$$94$$opt->shrt = (char)0;
    lglminit$$1$$94$$opt->lng = "smallvevars";
    lglminit$$1$$94$$opt->val = 12;
    lglminit$$1$$94$$opt->min = 4;
    lglminit$$1$$94$$opt->max = 12;
    lglminit$$1$$94$$opt->descrp = "variables small variable elimination";
    lglgetenv(lgl, lglminit$$1$$94$$opt, "smallvevars");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$95$$opt = &lgl->opts->randec;
    lglminit$$1$$95$$opt->shrt = (char)0;
    lglminit$$1$$95$$opt->lng = "randec";
    lglminit$$1$$95$$opt->val = 1;
    lglminit$$1$$95$$opt->min = 0;
    lglminit$$1$$95$$opt->max = 1;
    lglminit$$1$$95$$opt->descrp = "enable random decisions";
    lglgetenv(lgl, lglminit$$1$$95$$opt, "randec");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$96$$opt = &lgl->opts->randecint;
    lglminit$$1$$96$$opt->shrt = (char)0;
    lglminit$$1$$96$$opt->lng = "randecint";
    lglminit$$1$$96$$opt->val = 1000;
    lglminit$$1$$96$$opt->min = 2;
    lglminit$$1$$96$$opt->max = I / 2;
    lglminit$$1$$96$$opt->descrp = "random decision interval";
    lglgetenv(lgl, lglminit$$1$$96$$opt, "randecint");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$97$$opt = &lgl->opts->reduce;
    lglminit$$1$$97$$opt->shrt = (char)0;
    lglminit$$1$$97$$opt->lng = "reduce";
    lglminit$$1$$97$$opt->val = 1;
    lglminit$$1$$97$$opt->min = 0;
    lglminit$$1$$97$$opt->max = 4;
    lglminit$$1$$97$$opt->descrp = "clause reduction (1=noouter,2=luby,3=inout,4=arith)";
    lglgetenv(lgl, lglminit$$1$$97$$opt, "reduce");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$98$$opt = &lgl->opts->redfixed;
    lglminit$$1$$98$$opt->shrt = (char)0;
    lglminit$$1$$98$$opt->lng = "redfixed";
    lglminit$$1$$98$$opt->val = 0;
    lglminit$$1$$98$$opt->min = 0;
    lglminit$$1$$98$$opt->max = 1;
    lglminit$$1$$98$$opt->descrp = "keep a fixed size of learned clauses";
    lglgetenv(lgl, lglminit$$1$$98$$opt, "redfixed");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$99$$opt = &lgl->opts->redlbound;
    lglminit$$1$$99$$opt->shrt = (char)0;
    lglminit$$1$$99$$opt->lng = "redlbound";
    lglminit$$1$$99$$opt->val = 0;
    lglminit$$1$$99$$opt->min = 0;
    lglminit$$1$$99$$opt->max = 1;
    lglminit$$1$$99$$opt->descrp = "relative and absolute bounds on learned clauses";
    lglgetenv(lgl, lglminit$$1$$99$$opt, "redlbound");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$100$$opt = &lgl->opts->redlexpfac;
    lglminit$$1$$100$$opt->shrt = (char)0;
    lglminit$$1$$100$$opt->lng = "redlexpfac";
    lglminit$$1$$100$$opt->val = 10;
    lglminit$$1$$100$$opt->min = 0;
    lglminit$$1$$100$$opt->max = 1000;
    lglminit$$1$$100$$opt->descrp = "exponential reduce limit increment factor";
    lglgetenv(lgl, lglminit$$1$$100$$opt, "redlexpfac");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$101$$opt = &lgl->opts->redldoutfac;
    lglminit$$1$$101$$opt->shrt = (char)0;
    lglminit$$1$$101$$opt->lng = "redldoutfac";
    lglminit$$1$$101$$opt->val = 0;
    lglminit$$1$$101$$opt->min = 0;
    lglminit$$1$$101$$opt->max = 32;
    lglminit$$1$$101$$opt->descrp = "outer to inner factor";
    lglgetenv(lgl, lglminit$$1$$101$$opt, "redldoutfac");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$102$$opt = &lgl->opts->redloutinc;
    lglminit$$1$$102$$opt->shrt = (char)0;
    lglminit$$1$$102$$opt->lng = "redloutinc";
    lglminit$$1$$102$$opt->val = 10000;
    lglminit$$1$$102$$opt->min = 0;
    lglminit$$1$$102$$opt->max = 1000000;
    lglminit$$1$$102$$opt->descrp = "outer arithmetic reduce increment";
    lglgetenv(lgl, lglminit$$1$$102$$opt, "redloutinc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *opt = &lgl->opts->redlinit;
    opt->shrt = (char)0;
    opt->lng = "redlinit";
    opt->val = 1 * K;
    opt->min = 1;
    opt->max = 100 * M;
    opt->descrp = "initial reduce limit";
    lglgetenv(lgl, opt, "redlinit");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$104$$opt = &lgl->opts->redlinc;
    lglminit$$1$$104$$opt->shrt = (char)0;
    lglminit$$1$$104$$opt->lng = "redlinc";
    lglminit$$1$$104$$opt->val = 1000;
    lglminit$$1$$104$$opt->min = 1;
    lglminit$$1$$104$$opt->max = 10 * M;
    lglminit$$1$$104$$opt->descrp = "reduce limit increment";
    lglgetenv(lgl, lglminit$$1$$104$$opt, "redlinc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$105$$opt = &lgl->opts->redinoutinc;
    lglminit$$1$$105$$opt->shrt = (char)0;
    lglminit$$1$$105$$opt->lng = "redinoutinc";
    lglminit$$1$$105$$opt->val = 100;
    lglminit$$1$$105$$opt->min = 1;
    lglminit$$1$$105$$opt->max = 1000;
    lglminit$$1$$105$$opt->descrp = "reduce inner/outer relative increment";
    lglgetenv(lgl, lglminit$$1$$105$$opt, "redinoutinc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$106$$opt = &lgl->opts->redlmininc;
    lglminit$$1$$106$$opt->shrt = (char)0;
    lglminit$$1$$106$$opt->lng = "redlmininc";
    lglminit$$1$$106$$opt->val = 10;
    lglminit$$1$$106$$opt->min = 1;
    lglminit$$1$$106$$opt->max = 100 * K;
    lglminit$$1$$106$$opt->descrp = "rel min reduce limit increment";
    lglgetenv(lgl, lglminit$$1$$106$$opt, "redlmininc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$107$$opt = &lgl->opts->redlmaxinc;
    lglminit$$1$$107$$opt->shrt = (char)0;
    lglminit$$1$$107$$opt->lng = "redlmaxinc";
    lglminit$$1$$107$$opt->val = 200;
    lglminit$$1$$107$$opt->min = 1;
    lglminit$$1$$107$$opt->max = 100 * K;
    lglminit$$1$$107$$opt->descrp = "rel max reduce limit increment";
    lglgetenv(lgl, lglminit$$1$$107$$opt, "redlmaxinc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$108$$opt = &lgl->opts->redlminrel;
    lglminit$$1$$108$$opt->shrt = (char)0;
    lglminit$$1$$108$$opt->lng = "redlminrel";
    lglminit$$1$$108$$opt->val = 10;
    lglminit$$1$$108$$opt->min = 10;
    lglminit$$1$$108$$opt->max = 1000;
    lglminit$$1$$108$$opt->descrp = "minimum relative reduce limit";
    lglgetenv(lgl, lglminit$$1$$108$$opt, "redlminrel");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$109$$opt = &lgl->opts->redlmaxrel;
    lglminit$$1$$109$$opt->shrt = (char)0;
    lglminit$$1$$109$$opt->lng = "redlmaxrel";
    lglminit$$1$$109$$opt->val = 300;
    lglminit$$1$$109$$opt->min = 10;
    lglminit$$1$$109$$opt->max = 10000;
    lglminit$$1$$109$$opt->descrp = "maximum relative reduce limit";
    lglgetenv(lgl, lglminit$$1$$109$$opt, "redlmaxrel");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$110$$opt = &lgl->opts->redlminabs;
    lglminit$$1$$110$$opt->shrt = (char)0;
    lglminit$$1$$110$$opt->lng = "redlminabs";
    lglminit$$1$$110$$opt->val = 500;
    lglminit$$1$$110$$opt->min = 10;
    lglminit$$1$$110$$opt->max = 1000000;
    lglminit$$1$$110$$opt->descrp = "minimum absolute reduce limit";
    lglgetenv(lgl, lglminit$$1$$110$$opt, "redlminabs");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$111$$opt = &lgl->opts->redlmaxabs;
    lglminit$$1$$111$$opt->shrt = (char)0;
    lglminit$$1$$111$$opt->lng = "redlmaxabs";
    lglminit$$1$$111$$opt->val = 1000000;
    lglminit$$1$$111$$opt->min = 10;
    lglminit$$1$$111$$opt->max = I / 2;
    lglminit$$1$$111$$opt->descrp = "maximum absolute reduce limit";
    lglgetenv(lgl, lglminit$$1$$111$$opt, "redlmaxabs");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$112$$opt = &lgl->opts->restart;
    lglminit$$1$$112$$opt->shrt = (char)0;
    lglminit$$1$$112$$opt->lng = "restart";
    lglminit$$1$$112$$opt->val = 2;
    lglminit$$1$$112$$opt->min = 0;
    lglminit$$1$$112$$opt->max = 3;
    lglminit$$1$$112$$opt->descrp = "enable restarting (0=no,1=fixed,2=luby,3=inout)";
    lglgetenv(lgl, lglminit$$1$$112$$opt, "restart");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$113$$opt = &lgl->opts->restartint;
    lglminit$$1$$113$$opt->shrt = (char)0;
    lglminit$$1$$113$$opt->lng = "restartint";
    lglminit$$1$$113$$opt->val = 5;
    lglminit$$1$$113$$opt->min = 1;
    lglminit$$1$$113$$opt->max = I;
    lglminit$$1$$113$$opt->descrp = "restart interval";
    lglgetenv(lgl, lglminit$$1$$113$$opt, "restartint");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$114$$opt = &lgl->opts->rstinoutinc;
    lglminit$$1$$114$$opt->shrt = (char)0;
    lglminit$$1$$114$$opt->lng = "rstinoutinc";
    lglminit$$1$$114$$opt->val = 110;
    lglminit$$1$$114$$opt->min = 1;
    lglminit$$1$$114$$opt->max = 1000;
    lglminit$$1$$114$$opt->descrp = "restart inner/outer relative increment";
    lglgetenv(lgl, lglminit$$1$$114$$opt, "rstinoutinc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$115$$opt = &lgl->opts->simplify;
    lglminit$$1$$115$$opt->shrt = (char)0;
    lglminit$$1$$115$$opt->lng = "simplify";
    lglminit$$1$$115$$opt->val = 1;
    lglminit$$1$$115$$opt->min = 0;
    lglminit$$1$$115$$opt->max = 1;
    lglminit$$1$$115$$opt->descrp = "enable simplification";
    lglgetenv(lgl, lglminit$$1$$115$$opt, "simplify");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$116$$opt = &lgl->opts->simpdelay;
    lglminit$$1$$116$$opt->shrt = (char)0;
    lglminit$$1$$116$$opt->lng = "simpdelay";
    lglminit$$1$$116$$opt->val = 100;
    lglminit$$1$$116$$opt->min = 0;
    lglminit$$1$$116$$opt->max = 0x7fffffff;
    lglminit$$1$$116$$opt->descrp = "delay simplification";
    lglgetenv(lgl, lglminit$$1$$116$$opt, "simpdelay");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$117$$opt = &lgl->opts->simpen;
    lglminit$$1$$117$$opt->shrt = (char)0;
    lglminit$$1$$117$$opt->lng = "simpen";
    lglminit$$1$$117$$opt->val = 4;
    lglminit$$1$$117$$opt->min = 0;
    lglminit$$1$$117$$opt->max = 24;
    lglminit$$1$$117$$opt->descrp = "logarithmic initial simplification penalty";
    lglgetenv(lgl, lglminit$$1$$117$$opt, "simpen");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$118$$opt = &lgl->opts->sizepen;
    lglminit$$1$$118$$opt->shrt = (char)0;
    lglminit$$1$$118$$opt->lng = "sizepen";
    lglminit$$1$$118$$opt->val = 1 * M;
    lglminit$$1$$118$$opt->min = 1;
    lglminit$$1$$118$$opt->max = I;
    lglminit$$1$$118$$opt->descrp = "number of literals size penalty starting point";
    lglgetenv(lgl, lglminit$$1$$118$$opt, "sizepen");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$119$$opt = &lgl->opts->sizemaxpen;
    lglminit$$1$$119$$opt->shrt = (char)0;
    lglminit$$1$$119$$opt->lng = "sizemaxpen";
    lglminit$$1$$119$$opt->val = 3;
    lglminit$$1$$119$$opt->min = 0;
    lglminit$$1$$119$$opt->max = 20;
    lglminit$$1$$119$$opt->descrp = "maximum logarithmic size penalty";
    lglgetenv(lgl, lglminit$$1$$119$$opt, "sizemaxpen");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$120$$opt = &lgl->opts->sortlits;
    lglminit$$1$$120$$opt->shrt = (char)0;
    lglminit$$1$$120$$opt->lng = "sortlits";
    lglminit$$1$$120$$opt->val = 0;
    lglminit$$1$$120$$opt->min = 0;
    lglminit$$1$$120$$opt->max = 1;
    lglminit$$1$$120$$opt->descrp = "sort literals of clauses during garbage collection";
    lglgetenv(lgl, lglminit$$1$$120$$opt, "sortlits");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$121$$opt = &lgl->opts->syncint;
    lglminit$$1$$121$$opt->shrt = (char)0;
    lglminit$$1$$121$$opt->lng = "syncint";
    lglminit$$1$$121$$opt->val = 111111;
    lglminit$$1$$121$$opt->min = 0;
    lglminit$$1$$121$$opt->max = M;
    lglminit$$1$$121$$opt->descrp = "unit synchronization interval";
    lglgetenv(lgl, lglminit$$1$$121$$opt, "syncint");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$122$$opt = &lgl->opts->termint;
    lglminit$$1$$122$$opt->shrt = (char)0;
    lglminit$$1$$122$$opt->lng = "termint";
    lglminit$$1$$122$$opt->val = 122222;
    lglminit$$1$$122$$opt->min = 0;
    lglminit$$1$$122$$opt->max = M;
    lglminit$$1$$122$$opt->descrp = "termination check interval";
    lglgetenv(lgl, lglminit$$1$$122$$opt, "termint");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$123$$opt = &lgl->opts->ternres;
    lglminit$$1$$123$$opt->shrt = (char)0;
    lglminit$$1$$123$$opt->lng = "ternres";
    lglminit$$1$$123$$opt->val = 1;
    lglminit$$1$$123$$opt->min = 0;
    lglminit$$1$$123$$opt->max = 1;
    lglminit$$1$$123$$opt->descrp = "generate ternary resolvents";
    lglgetenv(lgl, lglminit$$1$$123$$opt, "ternres");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$124$$opt = &lgl->opts->ternresrtc;
    lglminit$$1$$124$$opt->shrt = (char)0;
    lglminit$$1$$124$$opt->lng = "ternresrtc";
    lglminit$$1$$124$$opt->val = 0;
    lglminit$$1$$124$$opt->min = 0;
    lglminit$$1$$124$$opt->max = 1;
    lglminit$$1$$124$$opt->descrp = "run ternary resolvents until completion";
    lglgetenv(lgl, lglminit$$1$$124$$opt, "ternresrtc");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$125$$opt = &lgl->opts->trnrmaxeff;
    lglminit$$1$$125$$opt->shrt = (char)0;
    lglminit$$1$$125$$opt->lng = "trnrmaxeff";
    lglminit$$1$$125$$opt->val = 40 * M;
    lglminit$$1$$125$$opt->min = -1;
    lglminit$$1$$125$$opt->max = I;
    lglminit$$1$$125$$opt->descrp = "max effort in ternary resolutions";
    lglgetenv(lgl, lglminit$$1$$125$$opt, "trnrmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$126$$opt = &lgl->opts->trnrmineff;
    lglminit$$1$$126$$opt->shrt = (char)0;
    lglminit$$1$$126$$opt->lng = "trnrmineff";
    lglminit$$1$$126$$opt->val = 4 * M;
    lglminit$$1$$126$$opt->min = 0;
    lglminit$$1$$126$$opt->max = I;
    lglminit$$1$$126$$opt->descrp = "min effort in ternary resolutions";
    lglgetenv(lgl, lglminit$$1$$126$$opt, "trnrmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$127$$opt = &lgl->opts->trnreleff;
    lglminit$$1$$127$$opt->shrt = (char)0;
    lglminit$$1$$127$$opt->lng = "trnreleff";
    lglminit$$1$$127$$opt->val = 10;
    lglminit$$1$$127$$opt->min = 0;
    lglminit$$1$$127$$opt->max = K;
    lglminit$$1$$127$$opt->descrp = "rel effort in ternary resolutions";
    lglgetenv(lgl, lglminit$$1$$127$$opt, "trnreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$128$$opt = &lgl->opts->transred;
    lglminit$$1$$128$$opt->shrt = (char)0;
    lglminit$$1$$128$$opt->lng = "transred";
    lglminit$$1$$128$$opt->val = 1;
    lglminit$$1$$128$$opt->min = 0;
    lglminit$$1$$128$$opt->max = 1;
    lglminit$$1$$128$$opt->descrp = "enable transitive reduction";
    lglgetenv(lgl, lglminit$$1$$128$$opt, "transred");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$129$$opt = &lgl->opts->trdmaxeff;
    lglminit$$1$$129$$opt->shrt = (char)0;
    lglminit$$1$$129$$opt->lng = "trdmaxeff";
    lglminit$$1$$129$$opt->val = 2 * M;
    lglminit$$1$$129$$opt->min = -1;
    lglminit$$1$$129$$opt->max = I;
    lglminit$$1$$129$$opt->descrp = "max effort in transitive reduction";
    lglgetenv(lgl, lglminit$$1$$129$$opt, "trdmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$130$$opt = &lgl->opts->trdmineff;
    lglminit$$1$$130$$opt->shrt = (char)0;
    lglminit$$1$$130$$opt->lng = "trdmineff";
    lglminit$$1$$130$$opt->val = 100 * K;
    lglminit$$1$$130$$opt->min = 0;
    lglminit$$1$$130$$opt->max = I;
    lglminit$$1$$130$$opt->descrp = "min effort in transitive reduction";
    lglgetenv(lgl, lglminit$$1$$130$$opt, "trdmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$131$$opt = &lgl->opts->trdreleff;
    lglminit$$1$$131$$opt->shrt = (char)0;
    lglminit$$1$$131$$opt->lng = "trdreleff";
    lglminit$$1$$131$$opt->val = 10;
    lglminit$$1$$131$$opt->min = 0;
    lglminit$$1$$131$$opt->max = 10 * K;
    lglminit$$1$$131$$opt->descrp = "rel effort in transitive reduction";
    lglgetenv(lgl, lglminit$$1$$131$$opt, "trdreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$132$$opt = &lgl->opts->unhide;
    lglminit$$1$$132$$opt->shrt = (char)0;
    lglminit$$1$$132$$opt->lng = "unhide";
    lglminit$$1$$132$$opt->val = 1;
    lglminit$$1$$132$$opt->min = 0;
    lglminit$$1$$132$$opt->max = 1;
    lglminit$$1$$132$$opt->descrp = "enable unhiding";
    lglgetenv(lgl, lglminit$$1$$132$$opt, "unhide");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$133$$opt = &lgl->opts->unhdextstamp;
    lglminit$$1$$133$$opt->shrt = (char)0;
    lglminit$$1$$133$$opt->lng = "unhdextstamp";
    lglminit$$1$$133$$opt->val = 1;
    lglminit$$1$$133$$opt->min = 0;
    lglminit$$1$$133$$opt->max = 1;
    lglminit$$1$$133$$opt->descrp = "used extended stamping features";
    lglgetenv(lgl, lglminit$$1$$133$$opt, "unhdextstamp");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$134$$opt = &lgl->opts->unhdhbr;
    lglminit$$1$$134$$opt->shrt = (char)0;
    lglminit$$1$$134$$opt->lng = "unhdhbr";
    lglminit$$1$$134$$opt->val = 0;
    lglminit$$1$$134$$opt->min = 0;
    lglminit$$1$$134$$opt->max = 1;
    lglminit$$1$$134$$opt->descrp = "enable unhiding hidden binary resolution";
    lglgetenv(lgl, lglminit$$1$$134$$opt, "unhdhbr");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$135$$opt = &lgl->opts->unhdmaxeff;
    lglminit$$1$$135$$opt->shrt = (char)0;
    lglminit$$1$$135$$opt->lng = "unhdmaxeff";
    lglminit$$1$$135$$opt->val = 20 * M;
    lglminit$$1$$135$$opt->min = -1;
    lglminit$$1$$135$$opt->max = I;
    lglminit$$1$$135$$opt->descrp = "max effort in unhiding";
    lglgetenv(lgl, lglminit$$1$$135$$opt, "unhdmaxeff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$136$$opt = &lgl->opts->unhdmineff;
    lglminit$$1$$136$$opt->shrt = (char)0;
    lglminit$$1$$136$$opt->lng = "unhdmineff";
    lglminit$$1$$136$$opt->val = 1 * M;
    lglminit$$1$$136$$opt->min = 0;
    lglminit$$1$$136$$opt->max = I;
    lglminit$$1$$136$$opt->descrp = "min effort in unhiding";
    lglgetenv(lgl, lglminit$$1$$136$$opt, "unhdmineff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$137$$opt = &lgl->opts->unhdreleff;
    lglminit$$1$$137$$opt->shrt = (char)0;
    lglminit$$1$$137$$opt->lng = "unhdreleff";
    lglminit$$1$$137$$opt->val = 4;
    lglminit$$1$$137$$opt->min = 0;
    lglminit$$1$$137$$opt->max = 10 * K;
    lglminit$$1$$137$$opt->descrp = "rel effort in unhiding";
    lglgetenv(lgl, lglminit$$1$$137$$opt, "unhdreleff");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$138$$opt = &lgl->opts->unhdlnpr;
    lglminit$$1$$138$$opt->shrt = (char)0;
    lglminit$$1$$138$$opt->lng = "unhdlnpr";
    lglminit$$1$$138$$opt->val = 3;
    lglminit$$1$$138$$opt->min = 0;
    lglminit$$1$$138$$opt->max = I;
    lglminit$$1$$138$$opt->descrp = "unhide no progress round limit";
    lglgetenv(lgl, lglminit$$1$$138$$opt, "unhdlnpr");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$139$$opt = &lgl->opts->unhdroundlim;
    lglminit$$1$$139$$opt->shrt = (char)0;
    lglminit$$1$$139$$opt->lng = "unhdroundlim";
    lglminit$$1$$139$$opt->val = 5;
    lglminit$$1$$139$$opt->min = 0;
    lglminit$$1$$139$$opt->max = 100;
    lglminit$$1$$139$$opt->descrp = "unhide round limit";
    lglgetenv(lgl, lglminit$$1$$139$$opt, "unhdroundlim");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$140$$opt = &lgl->opts->verbose;
    lglminit$$1$$140$$opt->shrt = (char)118;
    lglminit$$1$$140$$opt->lng = "verbose";
    lglminit$$1$$140$$opt->val = 0;
    lglminit$$1$$140$$opt->min = 0;
    lglminit$$1$$140$$opt->max = 3;
    lglminit$$1$$140$$opt->descrp = "verbosity level";
    lglgetenv(lgl, lglminit$$1$$140$$opt, "verbose");
  }
  while((_Bool)0);
  do
  {
    struct Opt *lglminit$$1$$141$$opt = &lgl->opts->witness;
    lglminit$$1$$141$$opt->shrt = (char)0;
    lglminit$$1$$141$$opt->lng = "witness";
    lglminit$$1$$141$$opt->val = 1;
    lglminit$$1$$141$$opt->min = 0;
    lglminit$$1$$141$$opt->max = 1;
    lglminit$$1$$141$$opt->descrp = "print witness";
    lglgetenv(lgl, lglminit$$1$$141$$opt, "witness");
  }
  while((_Bool)0);
  if(!(lgl->opts->plain.val == 0))
    lglsetplain(lgl, 1);

  signed int return_value_abs$1;
  return_value_abs$1=abs(lgl->opts->bias.val);
  if(!(return_value_abs$1 >= 2))
    lgl->bias = lgl->opts->bias.val;

  else
    lgl->bias = 1;
  do
  {
    void *return_value_lglnew$2;
    return_value_lglnew$2=lglnew(lgl, (unsigned long int)1 * sizeof(struct Times) /*240ul*/ );
    lgl->times = (struct Times *)return_value_lglnew$2;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew$3;
    return_value_lglnew$3=lglnew(lgl, (unsigned long int)1 * sizeof(struct Tmrs) /*128ul*/ );
    lgl->timers = (struct Tmrs *)return_value_lglnew$3;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew$4;
    return_value_lglnew$4=lglnew(lgl, (unsigned long int)1 * sizeof(struct Limits) /*352ul*/ );
    lgl->limits = (struct Limits *)return_value_lglnew$4;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew$5;
    return_value_lglnew$5=lglnew(lgl, (unsigned long int)1 * sizeof(struct FltStr) /*604ul*/ );
    lgl->fltstr = (struct FltStr *)return_value_lglnew$5;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew$6;
    return_value_lglnew$6=lglnew(lgl, (unsigned long int)(((1 << 4) - 1) + 1) * sizeof(struct Stk) /*24ul*/ );
    lgl->red = (struct Stk *)return_value_lglnew$6;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew$7;
    return_value_lglnew$7=lglnew(lgl, (unsigned long int)1 * sizeof(struct Wchs) /*152ul*/ );
    lgl->wchs = (struct Wchs *)return_value_lglnew$7;
  }
  while((_Bool)0);
  i = 0;
  for( ; !(i >= 31); i = i + 1)
    lgl->wchs->start[(signed long int)i] = 0x7fffffff;
  lglpushstk(lgl, &lgl->wchs->stk, 0x7fffffff);
  lglpushstk(lgl, &lgl->wchs->stk, 0x7fffffff);

__CPROVER_DUMP_L154:
  ;
  do
    lgl->state = (enum State)UNUSED;
  while((_Bool)0);
  return lgl;
}

// lglmnt
// file lglib.c line 1054
static unsigned long int lglmnt(signed long int a)
{
  unsigned long int res = (unsigned long int)a & 0x00000001ffffffffull;
  res = res | 0x0000000100000000ull;
  return res;
}

// lglmosat
// file lglib.c line 17745
signed int lglmosat(struct LGL *lgl, void *state, signed int (*f)(void *, signed int, signed int), signed int *targets)
{
  signed int cint;
  signed int clim;
  signed int target;
  signed int ntargets;
  signed int rtargets;
  signed int lglmosat$$1$$next;
  signed int round;
  signed int lglmosat$$1$$done;
  signed char *reported;
  signed char *r;
  signed long int confs;
  signed long int totalclim;
  const signed int *p;
  signed char val;
  struct Lim lim;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmosat");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  do
  {
    signed int return_value_lglmtstk$1;
    return_value_lglmtstk$1=lglmtstk(&lgl->clause);
    if(!(return_value_lglmtstk$1 == 0))
      break;

    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglmosat");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "clause terminating zero missing");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
  }
  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "mosat");
    break;
  }
  lglstart(lgl, &lgl->times->all);
  lgl->stats->calls.mosat = lgl->stats->calls.mosat + 1l;
  ntargets = 0;
  p = targets;
  for( ; !(*p == 0); p = p + 1l)
    ntargets = ntargets + 1;
  do
  {
    void *return_value_lglnew$2;
    return_value_lglnew$2=lglnew(lgl, (unsigned long int)ntargets * sizeof(signed char) /*1ul*/ );
    reported = (signed char *)return_value_lglnew$2;
  }
  while((_Bool)0);
  rtargets = ntargets;
  cint = lgl->opts->mocint.val;
  signed long long int tmp_if_expr$3;
  if(!(lgl->opts->clim.val >= 0))
    tmp_if_expr$3 = 0x7fffffffffffffffll;

  else
    tmp_if_expr$3 = lgl->stats->confs + (signed long int)lgl->opts->clim.val;
  totalclim = tmp_if_expr$3;
  round = 1;
  lglmosat$$1$$next = 0;
  lglmosat$$1$$done = lglmosat$$1$$next;
  lglprt(lgl, 1, "[mosat-%lld] given %d targets", (signed long long int)lgl->stats->calls.mosat, ntargets);
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$7;
  signed char return_value_lglval$6;
  while(lgl->mt == 0)
  {
    p = targets;
    r = reported;
    do
    {
      if(lglmosat$$1$$done == 0)
      {
        target = *p;
        tmp_if_expr$4 = target != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(!tmp_if_expr$4)
        break;

      if(*r == 0)
      {
        signed int return_value_lglfixed$5;
        return_value_lglfixed$5=lglfixed(lgl, target);
        val = (signed char)return_value_lglfixed$5;
        if((signed int)val >= 0)
        {
          if((signed int)lgl->state == SATISFIED)
          {
            return_value_lglval$6=lglval(lgl, target);
            tmp_if_expr$7 = (signed int)return_value_lglval$6 > 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$7 = (_Bool)0;
          if(tmp_if_expr$7)
            val = (signed char)1;

          else
            val = (signed char)0;
        }

        if(!(val == 0))
        {

        __CPROVER_DUMP_L21:
          ;
          signed int return_value;
          return_value=f(state, target, (signed int)val);
          lglmosat$$1$$done = (signed int)!(return_value != 0);
          rtargets = rtargets - 1;
          *r = val;
        }

      }

      p = p + 1l;
      r = r + 1l;
    }
    while((_Bool)1);
    round = round + 1;
    double return_value_lglpcnt$8;
    return_value_lglpcnt$8=lglpcnt((double)rtargets, (double)ntargets);
    lglprt(lgl, 1, "[mosat-%lld-%d] %d targets remain out of %d (%.0f%%)", (signed long long int)lgl->stats->calls.mosat, round, rtargets, ntargets, return_value_lglpcnt$8);
    if(rtargets == 0)
      break;

    if(!(totalclim >= lgl->stats->confs))
      break;

    do
    {
      target = targets[(signed long int)lglmosat$$1$$next];
      signed int return_value_lglfixed$9;
      return_value_lglfixed$9=lglfixed(lgl, target);
      if(return_value_lglfixed$9 == 0)
        break;

      lglmosat$$1$$next = lglmosat$$1$$next + 1;
      if(lglmosat$$1$$next == ntargets)
        lglmosat$$1$$next = 0;

    }
    while((_Bool)1);

  __CPROVER_DUMP_L26:
    ;
    lglassume(lgl, target);
    confs = lgl->stats->confs;
    clim=lglmin(cint, lgl->opts->clim.val);
    lim.confs = confs >= 0x7fffffffffffffffll - (signed long int)clim ? 0x7fffffffffffffffll : confs + (signed long int)clim;
    lim.decs = (signed long int)-1;
    lglprt(lgl, 1, "[limits] conflict limit %lld after %lld conflicts", (signed long long int)lim.confs, (signed long long int)confs);
    lglisat(lgl, &lim, 0);
    cint = cint + lgl->opts->mocint.val;
  }
  do
  {
    lgldel(lgl, (void *)reported, (unsigned long int)ntargets * sizeof(signed char) /*1ul*/ );
    reported = ((signed char *)NULL);
  }
  while((_Bool)0);
  lglprt(lgl, 1, "[mosat-%lld] solved %d targets out of %d, %d remain", (signed long long int)lgl->stats->calls.mosat, ntargets - rtargets, ntargets, rtargets);
  lglstop(lgl);
  return (signed int)!(rtargets != 0);
}

// lglmsgend
// file lglib.c line 1199
static void lglmsgend(struct LGL *lgl)
{
  fputc(10, lgl->out);
  fflush(lgl->out);
  if(!(lgl->cbs == ((struct Cbs *)NULL)))
  {
    if(!(lgl->cbs->msglock.unlock == ((void (*)(void *))NULL)))
      lgl->cbs->msglock.unlock(lgl->cbs->msglock.state);

  }

}

// lglmsgstart
// file lglib.c line 1190
static signed int lglmsgstart(struct LGL *lgl, signed int level)
{
  if(!(lgl->opts->verbose.val >= level))
    return 0;

  else
  {
    if(!(lgl->cbs == ((struct Cbs *)NULL)))
    {
      if(!(lgl->cbs->msglock.lock == ((void (*)(void *))NULL)))
        lgl->cbs->msglock.lock(lgl->cbs->msglock.state);

    }

    const char *return_value_lglprefix$1;
    return_value_lglprefix$1=lglprefix(lgl);
    fputs(return_value_lglprefix$1, lgl->out);
    if(lgl->tid >= 0)
      fprintf(lgl->out, "%d ", lgl->tid);

    return 1;
  }
}

// lglmtstk
// file lglib.c line 1387
static signed int lglmtstk(struct Stk *s)
{
  return (signed int)(s->top == s->start);
}

// lglmtwtk
// file lglib.c line 14987
static signed int lglmtwtk(struct Wtk *wtk)
{
  return (signed int)(wtk->top == wtk->start);
}

// lglmulflt
// file lglib.c line 1126
static signed long int lglmulflt(signed long int a, signed long int b)
{
  signed int e;
  signed int ea;
  signed int eb;
  unsigned long int m;
  unsigned long int ma;
  unsigned long int mb;
  lglchkflt(a);
  lglchkflt(b);
  if(a == 0x7fffffffffffffffll)
    return 0x7fffffffffffffffll;

  else
    if(b == 0x7fffffffffffffffll)
      return 0x7fffffffffffffffll;

    else
      if(a == 0x0000000000000000ll)
        return 0x0000000000000000ll;

      else
        if(b == 0x0000000000000000ll)
          return 0x0000000000000000ll;

        else
        {
          ea=lglexp(a);
          eb=lglexp(b);
          if(ea >= 1 && eb >= 1 && !(0x7fffffff + -ea >= eb))
            return 0x7fffffffffffffffll;

          else
          {
            e = ea + eb;
            if(e >= 1879048160)
              return 0x7fffffffffffffffll;

            else
            {
              e = e + 32;
              ma=lglmnt(a);
              mb=lglmnt(b);
              ma = ma >> 1;
              mb = mb >> 1;
              m = ma * mb;
              m = m >> 30;
              signed long int return_value_lglflt$1;
              return_value_lglflt$1=lglflt(e, m);
              return return_value_lglflt$1;
            }
          }
        }
}

// lglmvbcls
// file lglib.c line 11138
static void lglmvbcls(struct LGL *lgl, signed int a, signed int b)
{
  lglpushstk(lgl, &lgl->clause, a);
  lglpushstk(lgl, &lgl->clause, b);
  lglpushstk(lgl, &lgl->clause, 0);
  signed int return_value_lglsimpleprobeclausexists$1;
  return_value_lglsimpleprobeclausexists$1=lglsimpleprobeclausexists(lgl);
  if(return_value_lglsimpleprobeclausexists$1 == 0)
  {

  __CPROVER_DUMP_L1:
    ;
    lgladdcls(lgl, REDCS, 0, 1);
  }

  lglclnstk(&lgl->clause);
  lgl->stats->moved.bin = lgl->stats->moved.bin + 1l;
}

// lglmvtcls
// file lglib.c line 11157
static void lglmvtcls(struct LGL *lgl, signed int a, signed int b, signed int c)
{
  lglpushstk(lgl, &lgl->clause, a);
  lglpushstk(lgl, &lgl->clause, b);
  lglpushstk(lgl, &lgl->clause, c);
  lglpushstk(lgl, &lgl->clause, 0);
  signed int return_value_lglsimpleprobeclausexists$1;
  return_value_lglsimpleprobeclausexists$1=lglsimpleprobeclausexists(lgl);
  if(return_value_lglsimpleprobeclausexists$1 == 0)
  {

  __CPROVER_DUMP_L1:
    ;
    lgladdcls(lgl, REDCS, 0, 1);
  }

  lglclnstk(&lgl->clause);
  lgl->stats->moved.trn = lgl->stats->moved.trn + 1l;
}

// lglneedacts
// file lglib.c line 5144
static signed int lglneedacts(struct LGL *lgl, signed int *glueuselessptr, signed int *needmoreglueptr)
{
  signed long int clauses = (signed long int)0;
  signed long int weighted = (signed long int)0;
  signed long int tmp;
  signed long int avg;
  signed long int var = (signed long int)0;
  signed long int std;
  signed long int delta;
  signed int glue;
  signed int maxglue = 0;
  glue = 0;
  for( ; !(glue >= 16); glue = glue + 1)
  {
    tmp = (signed long int)lgl->stats->lir[(signed long int)glue].clauses;
    if(!(tmp == 0l))
      maxglue = glue;

    clauses = clauses + tmp;
    weighted = weighted + (signed long int)glue * tmp;
  }
  avg = clauses != 0l ? ((signed long int)10 * weighted) / clauses : (signed long int)0;
  lglprt(lgl, 2, "[needacts-%d] existing clauses glue average %.1f", lgl->stats->reduced, (double)avg / 10.0);
  glue = 1;
  for( ; !(glue >= 16); glue = glue + 1)
  {
    delta = (signed long int)(10 * glue) - avg;
    var = var + delta * delta * (signed long int)lgl->stats->lir[(signed long int)glue].clauses;
  }
  var = clauses != 0l ? var / clauses : (signed long int)0;
  signed int return_value_lglceilsqrt64$1;
  return_value_lglceilsqrt64$1=lglceilsqrt64((signed int)var);
  std = (signed long int)return_value_lglceilsqrt64$1;
  lglprt(lgl, 2, "[needacts-%d] existing clauses glue standard deviation %.1f", lgl->stats->reduced, (double)std / 10.0);
  *glueuselessptr = (signed int)(std < (signed long int)10);
  if(!(maxglue >= 4))
    *needmoreglueptr = 2;

  else
    if(!(maxglue >= 6))
      *needmoreglueptr = 1;

    else
      *needmoreglueptr = 1;
  if(!((signed long int)lgl->opts->actavgmax.val >= avg))
    return 1;

  else
    if((signed long int)lgl->opts->actstdmin.val >= std)
      return 1;

    else
      if(!((signed long int)lgl->opts->actstdmax.val >= std))
        return 1;

      else
        return 0;
}

// lglnegass
// file lglib.c line 17554
static void lglnegass(struct LGL *lgl)
{
  const signed int *p;
  struct Stk eassume;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglnegass");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "negass");
    break;
  }
  if(lgl->mt == 0)
  {
    do
      memset((void *)&eassume, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    p = lgl->eassume.start;
    for( ; !(p >= lgl->eassume.top); p = p + 1l)
      lglpushstk(lgl, &eassume, *p);
    p = eassume.start;
    for( ; !(p >= eassume.top); p = p + 1l)
      lgleadd(lgl, -(*p));
    lgleadd(lgl, 0);
    p = eassume.start;
    for( ; !(p >= eassume.top); p = p + 1l)
      lglassume(lgl, *p);
    lglrelstk(lgl, &eassume);
    lgluse(lgl);
    if(!(lgl->clone == ((struct LGL *)NULL)))
      lglnegass(lgl->clone);

  }

}

// lglnegcofactorfun
// file lglib.c line 10751
static void lglnegcofactorfun(unsigned long int *f, signed int v, unsigned long int *res)
{
  unsigned long int mask[64l];
  unsigned long int masked[64l];
  lglvar2fun(v, mask);
  lgland3negfun(masked, f, mask);
  lglfuncpy(res, masked);
  lglslfun(masked, 1 << v);
  lglorfun(res, masked);
}

// lglnegvar2fun
// file lglib.c line 10503
static void lglnegvar2fun(signed int v, unsigned long int *res)
{
  lglvar2funaux(v, res, 1);
}

// lglnew
// file lglib.c line 1258
static void * lglnew(struct LGL *lgl, unsigned long int bytes)
{
  void *res;
  if(bytes == 0ul)
    return NULL;

  else
  {
    if(!(lgl->mem->alloc == ((void * (*)(void *, unsigned long int))NULL)))
      res=lgl->mem->alloc(lgl->mem->state, bytes);

    else
      res=malloc(bytes);
    if(res == NULL)
      lgldie(lgl, "out of memory allocating %ld bytes", bytes);


  __CPROVER_DUMP_L4:
    ;
    lglinc(lgl, bytes);
    if(!(res == NULL))
      memset(res, 0, bytes);

    return res;
  }
}

// lglnewbingate
// file lglib.c line 12451
static signed int lglnewbingate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int rhs0, signed int rhs1)
{
  signed int gidx;
  struct Gat *g;
  lhs=lglcgreprnotconst(lgl, lhs);
  rhs0=lglcgreprnotconst(lgl, rhs0);
  rhs1=lglcgreprnotconst(lgl, rhs1);
  signed int return_value_abs$1;
  return_value_abs$1=abs(rhs0);
  signed int return_value_abs$2;
  return_value_abs$2=abs(rhs1);
  if(!(return_value_abs$2 >= return_value_abs$1))
    do
    {
      signed int TMP = rhs0;
      rhs0 = rhs1;
      rhs1 = TMP;
    }
    while((_Bool)0);

  if((signed int)tag == XORTAG && !(lhs >= 0))
  {
    lhs = -lhs;
    rhs0 = -rhs0;
  }

  if((signed int)tag == XORTAG && !(rhs0 >= 0))
  {
    rhs0 = -rhs0;
    rhs1 = -rhs1;
  }

  signed int return_value_lglhasbingate$3;
  return_value_lglhasbingate$3=lglhasbingate(lgl, tag, lhs, rhs0, rhs1);
  if(!(return_value_lglhasbingate$3 == 0))
    return 0;

  else
  {
    g=lglnewgate(lgl, tag, lhs, 2);
    gidx=lglgat2idx(lgl, g);
    g->$anon0.lits[(signed long int)0] = rhs0;
    g->$anon0.lits[(signed long int)1] = rhs1;
    lglpushgocc(lgl, rhs0, gidx);
    lglpushgocc(lgl, rhs1, gidx);
    if((signed int)tag == ANDTAG)
    {
      lgl->$anon0.cgr->extracted.and = lgl->$anon0.cgr->extracted.and + 1;
      lgl->stats->cgr.extracted.and = lgl->stats->cgr.extracted.and + 1l;
    }

    else
      if((signed int)tag == XORTAG)
      {
        lgl->$anon0.cgr->extracted.xor = lgl->$anon0.cgr->extracted.xor + 1;
        lgl->stats->cgr.extracted.xor = lgl->stats->cgr.extracted.xor + 1l;
      }


  __CPROVER_DUMP_L6:
    ;

  __CPROVER_DUMP_L8:
    ;
    return 1;
  }
}

// lglnewgate
// file lglib.c line 12349
static struct Gat * lglnewgate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int size)
{
  struct Gat *res;
  signed int gidx;
  if(lgl->$anon0.cgr->extracted.all >= lgl->$anon0.cgr->szgates)
    lglenlargegates(lgl);

  lgl->stats->cgr.extracted.all = lgl->stats->cgr.extracted.all + 1l;
  signed int tmp_post$1 = lgl->$anon0.cgr->extracted.all;
  lgl->$anon0.cgr->extracted.all = lgl->$anon0.cgr->extracted.all + 1;
  gidx = tmp_post$1;
  res = lgl->$anon0.cgr->gates + (signed long int)gidx;
  do
    memset((void *)&(*res), 0, sizeof(struct Gat) /*32ul*/ );
  while((_Bool)0);
  lhs=lglcgreprnotconst(lgl, lhs);
  res->lhs = lhs;
  lglpushgocc(lgl, lhs, gidx);
  struct AVar *return_value_lglavar$2;
  return_value_lglavar$2=lglavar(lgl, lhs);
  return_value_lglavar$2->gate = (unsigned int)1;
  res->tag = (unsigned int)tag;
  res->size = size;
  return res;
}

// lglnewirrlim
// file lglib.c line 6799
static signed long int lglnewirrlim(struct LGL *lgl)
{
  signed long int lglnewirrlim$$1$$add = lgl->stats->irr.clauses.add;
  signed long int res = lglnewirrlim$$1$$add;
  res = res * (100ll + (signed long int)lgl->opts->irrlim.val);
  res = res + (signed long int)99;
  res = res / (signed long int)100;
  if(lglnewirrlim$$1$$add >= res)
    res = lglnewirrlim$$1$$add + (signed long int)1;

  lglprt(lgl, 2, "[irrlim] %lld", (signed long long int)res);
  return res;
}

// lglnewitegate
// file lglib.c line 12406
static void lglnewitegate(struct LGL *lgl, signed int lhs, signed int cond, signed int pos, signed int neg)
{
  signed int gidx;
  struct Gat *g;
  lhs=lglcgreprnotconst(lgl, lhs);
  if(!(lhs >= 0))
  {
    lhs = -lhs;
    pos = -pos;
    neg = -neg;
  }

  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  signed int return_value_lglsgn$1;
  signed int return_value_lglsgn$2;
  if(neg >= 1 && !(pos >= 0))
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    if(!(cond >= 0))
    {
      return_value_lglsgn$1=lglsgn(pos);
      return_value_lglsgn$2=lglsgn(neg);
      tmp_if_expr$3 = return_value_lglsgn$1 == return_value_lglsgn$2 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
    tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$4)
  {
    do
    {
      signed int TMP = pos;
      pos = neg;
      neg = TMP;
    }
    while((_Bool)0);
    cond = -cond;
  }

  cond=lglcgreprnotconst(lgl, cond);
  pos=lglcgreprnotconst(lgl, pos);
  neg=lglcgreprnotconst(lgl, neg);
  signed int return_value_lglhasitegate$5;
  return_value_lglhasitegate$5=lglhasitegate(lgl, lhs, cond, pos, neg);
  if(return_value_lglhasitegate$5 == 0)
  {
    g=lglnewgate(lgl, (enum GTag)ITETAG, lhs, 2);
    gidx=lglgat2idx(lgl, g);
    g->$anon0.$anon1.cond = cond;
    g->$anon0.$anon1.pos = pos;
    g->$anon0.$anon1.neg = neg;
    lglpushgocc(lgl, cond, gidx);
    lglpushgocc(lgl, pos, gidx);
    lglpushgocc(lgl, neg, gidx);

  __CPROVER_DUMP_L9:
    ;
    lgl->stats->cgr.extracted.ite = lgl->stats->cgr.extracted.ite + 1l;
    lgl->$anon0.cgr->extracted.ite = lgl->$anon0.cgr->extracted.ite + 1;
  }

}

// lglnewlgl
// file lglib.c line 1669
static struct LGL * lglnewlgl(void *mem, void * (*alloc)(void *, unsigned long int), void * (*realloc)(void *, void *, unsigned long int, unsigned long int), void (*dealloc)(void *, void *, unsigned long int))
{
  struct LGL *lgl;
  void *tmp_if_expr$2;
  void *return_value;
  void *return_value_malloc$1;
  if(!(alloc == ((void * (*)(void *, unsigned long int))NULL)))
  {
    return_value=alloc(mem, sizeof(struct LGL) /*816ul*/ );
    tmp_if_expr$2 = return_value;
  }

  else
  {
    return_value_malloc$1=malloc(sizeof(struct LGL) /*816ul*/ );
    tmp_if_expr$2 = return_value_malloc$1;
  }
  lgl = (struct LGL *)tmp_if_expr$2;
  while(lgl == ((struct LGL *)NULL))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglnewlgl");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "out of memory allocating main solver object");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  do
    memset((void *)lgl, 0, sizeof(struct LGL) /*816ul*/ );
  while((_Bool)0);
  void *tmp_if_expr$4;
  void *return_value_1;
  void *return_value_malloc$3;
  if(!(alloc == ((void * (*)(void *, unsigned long int))NULL)))
  {
    return_value_1=alloc(mem, sizeof(struct Mem) /*32ul*/ );
    tmp_if_expr$4 = return_value_1;
  }

  else
  {
    return_value_malloc$3=malloc(sizeof(struct Mem) /*32ul*/ );
    tmp_if_expr$4 = return_value_malloc$3;
  }
  lgl->mem = (struct Mem *)tmp_if_expr$4;
  while(lgl->mem == ((struct Mem *)NULL))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglnewlgl");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "out of memory allocating memory manager object");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lgl->mem->state = mem;
  lgl->mem->alloc = alloc;
  lgl->mem->realloc = realloc;
  lgl->mem->dealloc = dealloc;
  void *tmp_if_expr$6;
  void *return_value_2;
  void *return_value_malloc$5;
  if(!(alloc == ((void * (*)(void *, unsigned long int))NULL)))
  {
    return_value_2=alloc(mem, sizeof(struct Opts) /*5680ul*/ );
    tmp_if_expr$6 = return_value_2;
  }

  else
  {
    return_value_malloc$5=malloc(sizeof(struct Opts) /*5680ul*/ );
    tmp_if_expr$6 = return_value_malloc$5;
  }
  lgl->opts = (struct Opts *)tmp_if_expr$6;
  while(lgl->opts == ((struct Opts *)NULL))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglnewlgl");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "out of memory allocating option manager object");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  do
    memset((void *)lgl->opts, 0, sizeof(struct Opts) /*5680ul*/ );
  while((_Bool)0);
  void *tmp_if_expr$8;
  void *return_value_3;
  void *return_value_malloc$7;
  if(!(alloc == ((void * (*)(void *, unsigned long int))NULL)))
  {
    return_value_3=alloc(mem, sizeof(struct Stats) /*2272ul*/ );
    tmp_if_expr$8 = return_value_3;
  }

  else
  {
    return_value_malloc$7=malloc(sizeof(struct Stats) /*2272ul*/ );
    tmp_if_expr$8 = return_value_malloc$7;
  }
  lgl->stats = (struct Stats *)tmp_if_expr$8;
  while(lgl->stats == ((struct Stats *)NULL))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglnewlgl");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "out of memory allocating statistic counters");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  do
    memset((void *)lgl->stats, 0, sizeof(struct Stats) /*2272ul*/ );
  while((_Bool)0);
  lglinc(lgl, sizeof(struct LGL) /*816ul*/ );
  lglinc(lgl, sizeof(struct Mem) /*32ul*/ );
  lglinc(lgl, sizeof(struct Opts) /*5680ul*/ );
  lglinc(lgl, sizeof(struct Stats) /*2272ul*/ );
  return lgl;
}

// lglnewlrgate
// file lglib.c line 12478
static void lglnewlrgate(struct LGL *lgl, enum GTag tag, signed int lhs, signed int *cls, signed int size)
{
  signed int gidx;
  signed int other;
  signed int lhsrepr;
  const signed int *p;
  struct Gat *g;
  lhsrepr=lglcgreprnotconst(lgl, lhs);
  g=lglnewgate(lgl, tag, lhsrepr, size);
  g->$anon0.$anon0.origlhs = lhs;
  gidx=lglgat2idx(lgl, g);
  g->$anon0.$anon0.cls = cls;
  p = cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    signed int return_value_abs$1;
    return_value_abs$1=abs(other);
    if(!(return_value_abs$1 == lhs))
    {
      other=lglcgreprnotconst(lgl, other);
      lglpushgocc(lgl, other, gidx);
    }

    p = p + 1l;
  }
  while((_Bool)1);
  if((signed int)tag == ANDTAG)
  {
    lgl->$anon0.cgr->extracted.and = lgl->$anon0.cgr->extracted.and + 1;
    lgl->stats->cgr.extracted.and = lgl->stats->cgr.extracted.and + 1l;
  }

  if((signed int)tag == XORTAG)
  {
    lgl->$anon0.cgr->extracted.xor = lgl->$anon0.cgr->extracted.xor + 1;
    lgl->stats->cgr.extracted.xor = lgl->stats->cgr.extracted.xor + 1l;
  }

}

// lglnewvar
// file lglib.c line 2435
static signed int lglnewvar(struct LGL *lgl)
{
  struct AVar *av;
  struct DVar *dv;
  signed int res;
  if(lgl->nvars == lgl->szvars)
    lglenlvars(lgl);

  signed int tmp_post$1;
  if(!(lgl->nvars == 0))
  {
    tmp_post$1 = lgl->nvars;
    lgl->nvars = lgl->nvars + 1;
    res = tmp_post$1;
  }

  else
  {
    res = 2;
    lgl->nvars = 3;
  }
  if(res >= 134217726)
    lgldie(lgl, "more than %d variables", ((0x7fffffff >> RMSHFT) - 2) - 1);


__CPROVER_DUMP_L4:
  ;
  dv = lgl->dvars + (signed long int)res;
  do
    memset((void *)dv, 0, sizeof(struct DVar) /*16ul*/ );
  while((_Bool)0);
  av = lgl->avars + (signed long int)res;
  do
    memset((void *)av, 0, sizeof(struct AVar) /*12ul*/ );
  while((_Bool)0);
  lglqsched(lgl, res);
  lgl->unassigned = lgl->unassigned + 1;
  lgl->allphaseset = (char)0;
  return res;
}

// lglnextdecision
// file lglib.c line 6295
static signed int lglnextdecision(struct LGL *lgl)
{
  signed int res = 0;
  struct Qln *line;
  _Bool tmp_if_expr$2;
  signed char return_value_lglval$1;
  if(lgl->unassigned == 0)
    return 0;

  else
  {
    lglstart(lgl, &lgl->times->dec);
    line = lgl->queue.unassigned;
    lglchkqueue(lgl);
    do
    {
      struct Qnd *n;
      res = line->unassigned;
      do
      {
        if(!(res == 0))
        {
          return_value_lglval$1=lglval(lgl, res);
          tmp_if_expr$2 = return_value_lglval$1 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        n=lglqnd(lgl, res);
        res = n->next;
      }
      while((_Bool)1);
      line->unassigned = res;
      if(!(line->unassigned == 0))
        break;

      lgl->queue.unassigned = line->down;
      line = lgl->queue.unassigned;
    }
    while((_Bool)1);

  __CPROVER_DUMP_L7:
    ;
    lglstop(lgl);
    return res;
  }
}

// lglnextopt
// file lglib.c line 2144
void * lglnextopt(struct LGL *lgl, void *current, const char **nameptr, signed int *valptr, signed int *minptr, signed int *maxptr)
{
  struct Opt *opt = (struct Opt *)current;
  struct Opt *res = opt + (signed long int)1;
  if(!(&lgl->opts->afterlast + -1l >= res))
    return NULL;

  else
  {
    if(!(nameptr == ((const char **)NULL)))
      *nameptr = opt->lng;

    if(!(valptr == ((signed int *)NULL)))
      *valptr = opt->val;

    if(!(minptr == ((signed int *)NULL)))
      *minptr = opt->min;

    if(!(maxptr == ((signed int *)NULL)))
      *maxptr = opt->max;

    return (void *)res;
  }
}

// lglnvars
// file lglib.c line 12317
signed int lglnvars(struct LGL *lgl)
{
  signed int return_value_lglrem$1;
  return_value_lglrem$1=lglrem(lgl);
  return return_value_lglrem$1;
}

// lglobalftlim
// file lglib.c line 13929
static signed long int lglobalftlim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->lftreleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->lftmineff.val))
    limit = (signed long int)lgl->opts->lftmineff.val;

  if(lgl->opts->lftmaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->lftmaxeff.val >= limit))
      limit = (signed long int)lgl->opts->lftmaxeff.val;

  }

  signed int return_value_lglszpen$1;
  return_value_lglszpen$1=lglszpen(lgl);
  pen = lgl->limits->lft.pen + return_value_lglszpen$1;
  limit = limit >> pen;
  irrlim = (signed long int)(lgl->stats->irr.lits.cur / 4);
  irrlim = irrlim >> lgl->limits->simp.pen;
  signed int return_value_lglszpen$2;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    lglprt(lgl, 1, "[lift-%d] limit %lld based on %d irredundant literals", lgl->stats->lift.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    return_value_lglszpen$2=lglszpen(lgl);
    lglprt(lgl, 1, "[lift-%d] limit %lld with penalty %d = %d + %d", lgl->stats->lift.count, (signed long long int)limit, pen, lgl->limits->lft.pen, return_value_lglszpen$2);
  }
  return limit;
}

// lglocc
// file lglib.c line 3368
static signed int lglocc(struct LGL *lgl, signed int lit)
{
  struct EVar *return_value_lglevar$1;
  return_value_lglevar$1=lglevar(lgl, lit);
  return return_value_lglevar$1->occ[(signed long int)(lit < 0)];
}

// lglonabort
// file lglib.c line 1316
void lglonabort(struct LGL *lgl, void *abortstate, void (*onabort)(void *))
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglonabort");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->abortstate = abortstate;
  lgl->cbs->onabort = onabort;
}

// lglonflict
// file lglib.c line 4035
static void lglonflict(struct LGL *lgl, signed int check, signed int lit, signed int red, signed int lidx)
{
  signed int glue;
  lgl->conf.lit = lit;
  lgl->conf.rsn[(signed long int)0] = red | LRGCS;
  lgl->conf.rsn[(signed long int)1] = lidx;
  if(!(red == 0))
  {
    glue = lidx & (1 << 4) - 1;
    lgl->stats->lir[(signed long int)glue].conflicts = lgl->stats->lir[(signed long int)glue].conflicts + 1l;
  }

}

// lglookahead
// file lglib.c line 17832
signed int lglookahead(struct LGL *lgl)
{
  signed int ilit;
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglookahead");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "lkhd");
    break;
  }
  do
  {
    signed int return_value_lglmtstk$1;
    return_value_lglmtstk$1=lglmtstk(&lgl->eassume);
    if(!(return_value_lglmtstk$1 == 0))
      break;

    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglookahead");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "imcompatible with 'lglassume'");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
  }
  while((_Bool)0);
  do
  {
    signed int return_value_lglmtstk$2;
    return_value_lglmtstk$2=lglmtstk(&lgl->clause);
    if(!(return_value_lglmtstk$2 == 0))
      break;

    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglookahead");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "clause terminating zero missing");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
  }
  while((_Bool)0);
  lglstart(lgl, &lgl->times->all);
  lglstart(lgl, &lgl->times->lkhd);
  lglreset(lgl);
  lgl->lkhd = (char)1;
  if(!(lgl->level == 0))
    lglbacktrack(lgl, 0);

  _Bool tmp_if_expr$8;
  signed int return_value_lglbcp$7;
  if(lgl->mt == 0)
  {
    return_value_lglbcp$7=lglbcp(lgl);
    tmp_if_expr$8 = return_value_lglbcp$7 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$8 = (_Bool)0;
  _Bool tmp_if_expr$4;
  signed int return_value_lglsmallirr$3;
  signed int tmp_if_expr$6;
  signed int return_value_lglexport$5;
  if(tmp_if_expr$8)
  {
    ilit = 0;
    if(lgl->opts->lkhd.val == 2)
    {
      return_value_lglsmallirr$3=lglsmallirr(lgl);
      tmp_if_expr$4 = !(return_value_lglsmallirr$3 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      ilit=lgljwhlook(lgl);

    else
    {
      if(!(lgl->opts->lkhd.val == 0))
      {
        if(lgl->opts->lkhd.val == 1)
          goto __CPROVER_DUMP_L17;

      }

      else
      {
        ilit=lglislook(lgl);
        goto __CPROVER_DUMP_L18;
      }

    __CPROVER_DUMP_L17:
      ;
      ilit=lgljwhlook(lgl);
    }

  __CPROVER_DUMP_L18:
    ;
    if(lgl->mt == 0 && !(ilit == 0))
    {
      return_value_lglexport$5=lglexport(lgl, ilit);
      tmp_if_expr$6 = return_value_lglexport$5;
    }

    else
      tmp_if_expr$6 = 0;
    res = tmp_if_expr$6;
  }

  else
  {
    lgl->mt = 1;
    res = 0;
  }
  lgl->lkhd = (char)0;
  lglstop(lgl);
  lglstop(lgl);

__CPROVER_DUMP_L23:
  ;
  do
    lgl->state = (enum State)LOOKED;
  while((_Bool)0);

__CPROVER_DUMP_L24:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglookahead(lgl->clone);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglookahead");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone) = %d differs from %s (lgl) = %d", (const void *)"lglookahead", CLONERES, (const void *)"lglookahead", res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lgloop
// file lglib.c line 17233
static signed int lgloop(struct LGL *lgl, struct Lim *lim)
{
  _Bool tmp_if_expr$10;
  signed int return_value_lglinprocessing$9;
  signed int return_value_lglana$7;
  do
  {
    signed int return_value_lglbcpsearch$8;
    return_value_lglbcpsearch$8=lglbcpsearch(lgl);
    if(!(return_value_lglbcpsearch$8 == 0))
    {
      return_value_lglinprocessing$9=lglinprocessing(lgl);
      tmp_if_expr$10 = return_value_lglinprocessing$9 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$10 = (_Bool)0;
    if(tmp_if_expr$10)
    {
      signed int return_value_lglterminate$1;
      return_value_lglterminate$1=lglterminate(lgl);
      if(!(return_value_lglterminate$1 == 0))
        return 0;

      signed int return_value_lglsyncunits$2;
      return_value_lglsyncunits$2=lglsyncunits(lgl);
      if(return_value_lglsyncunits$2 == 0)
        return 20;

      signed int return_value_lglfailedass$3;
      return_value_lglfailedass$3=lglfailedass(lgl);
      if(!(return_value_lglfailedass$3 == 0))
        return 20;

      lglregularly(lgl);
      signed int return_value_lglimhit$4;
      return_value_lglimhit$4=lglimhit(lgl, lim);
      if(!(return_value_lglimhit$4 == 0))
        return 0;

      signed int return_value_lglrestarting$5;
      return_value_lglrestarting$5=lglrestarting(lgl);
      if(!(return_value_lglrestarting$5 == 0))
      {
        lglrestart(lgl);
        continue;
      }

      signed int return_value_lgldecide$6;
      return_value_lgldecide$6=lgldecide(lgl);
      if(return_value_lgldecide$6 == 0)
        return 10;

    }

    else
    {
      return_value_lglana$7=lglana(lgl);
      if(return_value_lglana$7 == 0)
        return 20;

    }
  }
  while((_Bool)1);
}

// lglopenapitrace
// file lglib.c line 1485
static void lglopenapitrace(struct LGL *lgl, const char *name)
{
  struct _IO_FILE *file;
  char *cmd;
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(name);
  len = (signed int)return_value_strlen$1;
  _Bool tmp_if_expr$5;
  signed int tmp_statement_expression$3;
  if(len >= 3)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$4;
    return_value___builtin_strcmp$4=__builtin_strcmp((name + (signed long int)len) - (signed long int)3, ".gz");
    tmp_statement_expression$3 = return_value___builtin_strcmp$4;
    tmp_if_expr$5 = !(tmp_statement_expression$3 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$5 = (_Bool)0;
  if(tmp_if_expr$5)
  {
    len = len + 20;
    do
    {
      void *return_value_lglnew$2;
      return_value_lglnew$2=lglnew(lgl, (unsigned long int)len * sizeof(char) /*1ul*/ );
      cmd = (char *)return_value_lglnew$2;
    }
    while((_Bool)0);
    sprintf(cmd, "gzip -c > %s", name);
    file=popen(cmd, "w");
    do
    {
      lgldel(lgl, (void *)cmd, (unsigned long int)len * sizeof(char) /*1ul*/ );
      cmd = ((char *)NULL);
    }
    while((_Bool)0);
    if(!(file == ((struct _IO_FILE *)NULL)))
      lgl->closeapitrace = (char)2;

  }

  else
  {
    file=fopen(name, "w");
    if(!(file == ((struct _IO_FILE *)NULL)))
      lgl->closeapitrace = (char)1;

  }
  if(!(file == ((struct _IO_FILE *)NULL)))
    lgl->apitrace = file;

  else
    lglwrn(lgl, "can not write API trace to '%s'", name);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "init");
    break;
  }
}

// lglopts
// file lglib.c line 2111
void lglopts(struct LGL *lgl, const char *prefix, signed int ignsome)
{
  struct Opt *o;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglopts");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  o = &lgl->opts->beforefirst + (signed long int)1;
  signed int tmp_statement_expression$1;
  signed int tmp_statement_expression$3;
  signed int tmp_statement_expression$5;
  signed int tmp_statement_expression$7;
  for( ; &lgl->opts->afterlast + -1l >= o; o = o + 1l)
  {
    if(!(ignsome == 0))
    {
      unsigned long int __s1_len;
      unsigned long int lglopts$$1$$2$$1$$1$$1$$__s2_len;
      signed int return_value___builtin_strcmp$2;
      return_value___builtin_strcmp$2=__builtin_strcmp(o->lng, "check");
      tmp_statement_expression$1 = return_value___builtin_strcmp$2;
      if(tmp_statement_expression$1 == 0)
        goto __CPROVER_DUMP_L6;

      unsigned long int lglopts$$1$$2$$1$$1$$2$$__s1_len;
      unsigned long int lglopts$$1$$2$$1$$1$$2$$__s2_len;
      signed int return_value___builtin_strcmp$4;
      return_value___builtin_strcmp$4=__builtin_strcmp(o->lng, "log");
      tmp_statement_expression$3 = return_value___builtin_strcmp$4;
      if(tmp_statement_expression$3 == 0)
        goto __CPROVER_DUMP_L6;

      unsigned long int lglopts$$1$$2$$1$$1$$3$$__s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp$6;
      return_value___builtin_strcmp$6=__builtin_strcmp(o->lng, "verbose");
      tmp_statement_expression$5 = return_value___builtin_strcmp$6;
      if(tmp_statement_expression$5 == 0)
        goto __CPROVER_DUMP_L6;

      unsigned long int lglopts$$1$$2$$1$$1$$4$$__s1_len;
      unsigned long int lglopts$$1$$2$$1$$1$$4$$__s2_len;
      signed int return_value___builtin_strcmp$8;
      return_value___builtin_strcmp$8=__builtin_strcmp(o->lng, "witness");
      tmp_statement_expression$7 = return_value___builtin_strcmp$8;
      if(tmp_statement_expression$7 == 0)
        goto __CPROVER_DUMP_L6;

    }

    fprintf(lgl->out, "%s--%s=%d\n", prefix, o->lng, o->val);

  __CPROVER_DUMP_L6:
    ;
  }
}

// lglor3fun
// file lglib.c line 10551
static void lglor3fun(unsigned long int *a, unsigned long int *b, unsigned long int *c)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = b[(signed long int)i] | c[(signed long int)i];
}

// lglor3negfun
// file lglib.c line 10557
static void lglor3negfun(unsigned long int *a, unsigned long int *b, unsigned long int *c)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = b[(signed long int)i] | ~c[(signed long int)i];
}

// lglordercls
// file lglib.c line 3007
static void lglordercls(struct LGL *lgl)
{
  lglorderclsaux(lgl, lgl->clause.start);

__CPROVER_DUMP_L1:
  ;
  lglorderclsaux(lgl, lgl->clause.start + (signed long int)1);

__CPROVER_DUMP_L2:
  ;

__CPROVER_DUMP_L3:
  ;
}

// lglorderclsaux
// file lglib.c line 2995
static void lglorderclsaux(struct LGL *lgl, signed int *start)
{
  signed int *p;
  signed int max = 0;
  signed int level;
  signed int lit;
  p = start;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    signed char return_value_lglval$1;
    return_value_lglval$1=lglval(lgl, lit);
    if(!(return_value_lglval$1 == 0))
    {
      level=lglevel(lgl, lit);
      if(!(max >= level))
      {
        max = level;
        *p = start[(signed long int)0];
        start[(signed long int)0] = lit;
      }

    }

    p = p + 1l;
  }
  while((_Bool)1);
}

// lglorfun
// file lglib.c line 10539
static void lglorfun(unsigned long int *a, unsigned long int *b)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = a[(signed long int)i] | b[(signed long int)i];
}

// lglornegfun
// file lglib.c line 10545
static void lglornegfun(unsigned long int *a, unsigned long int *b)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    a[(signed long int)i] = a[(signed long int)i] | ~b[(signed long int)i];
}

// lglpar64
// file lglib.c line 16222
static signed int lglpar64(unsigned long int i)
{
  unsigned int x;
  signed int res = 0;
  x = (unsigned int)i;
  for( ; !(x == 0u); x = x & x - (unsigned int)1)
    res = (signed int)!(res != 0);
  return res;
}

// lglparity
// file lglib.c line 12701
static signed int lglparity(struct LGL *lgl)
{
  const signed int *p;
  signed int res = 0;
  p = lgl->clause.start;
  for( ; !(p >= lgl->clause.top); p = p + 1l)
    if(!(*p >= 0))
      res = (signed int)!(res != 0);

  return res;
}

// lglpcnt
// file lglib.c line 3357
static double lglpcnt(double n, double d)
{
  if(d <= 0.000000 || !IEEE_FLOAT_NOTEQUAL(n, 0.000000))
    return 0.0;

  else
    return (100.0 * n) / d;
}

// lglpeek
// file lglib.c line 1391
static signed int lglpeek(struct Stk *s, signed int pos)
{
  return s->start[(signed long int)pos];
}

// lglphase
// file lglib.c line 6846
static void lglphase(struct LGL *lgl)
{
  signed long int set = lgl->stats->phase.set;
  signed long int pos = lgl->stats->phase.pos;
  signed long int neg = lgl->stats->phase.neg;
  signed int idx;
  lglstart(lgl, &lgl->times->phs);
  if(!(lgl->flushphases == 0))
    lglflushphases(lgl);

  double return_value_lglpcnt$1;
  double return_value_lglpcnt$2;
  if(lgl->opts->phase.val == 0)
  {
    lglsetallphases(lgl);
    if(lgl->allphaseset == 0)
    {
      lgl->stats->phase.count = lgl->stats->phase.count + 1;
      lgljwh(lgl);
      idx = 2;
      for( ; !(idx >= lgl->nvars); idx = idx + 1)
        lglsetjwhbias(lgl, idx);
      set = lgl->stats->phase.set - set;
      pos = lgl->stats->phase.pos - pos;
      neg = lgl->stats->phase.neg - neg;
      return_value_lglpcnt$1=lglpcnt((double)pos, (double)set);
      return_value_lglpcnt$2=lglpcnt((double)neg, (double)set);
      lglprt(lgl, 1, "[phase-%d] phase bias: %lld positive %.0f%%, %lld negative %.0f%%", lgl->stats->phase.count, (signed long long int)pos, return_value_lglpcnt$1, (signed long long int)neg, return_value_lglpcnt$2);
    }

  }


DONE:
  ;
  lglstop(lgl);
}

// lglpicosatchkall
// file lglib.c line 7337
static void lglpicosatchkall(struct LGL *lgl)
{
  ;
}

// lglpicosatrestart
// file lglib.c line 7356
static void lglpicosatrestart(struct LGL *lgl)
{
  ;
}

// lglpoison
// file lglib.c line 4841
static signed int lglpoison(struct LGL *lgl, signed int lit, struct Stk *stk)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int level;
  signed int res;
  signed int return_value_lglevelused$1;
  if(!(av->mark == 0))
    res = 0;

  else
  {
    level=lglevel(lgl, lit);
    if(level == 0)
      res = 0;

    else
    {
      signed int return_value_lgldecision$2;
      return_value_lgldecision$2=lgldecision(lgl, lit);
      if(!(return_value_lgldecision$2 == 0))
        res = 1;

      else
      {
        return_value_lglevelused$1=lglevelused(lgl, level);
        if(return_value_lglevelused$1 == 0)
          res = 1;

        else
        {
          lgl->stats->poison.search = lgl->stats->poison.search + 1l;
          if(!(av->poisoned == 0u))
          {
            lgl->stats->poison.hits = lgl->stats->poison.hits + 1l;
            res = 1;
          }

          else
          {
            av->mark = 1;
            lglpushstk(lgl, &lgl->seen, lit);
            lglpushstk(lgl, stk, lit);
            res = 0;
          }
        }
      }
    }
  }
  if(!(res == 0))
  {
    if(av->poisoned == 0u)
    {
      av->poisoned = (unsigned int)1;
      lglpushstk(lgl, &lgl->poisoned, lit);
    }

  }

  return res;
}

// lglpoke
// file lglib.c line 1396
static void lglpoke(struct Stk *s, signed int pos, signed int val)
{
  s->start[(signed long int)pos] = val;
}

// lglpopcontrol
// file lglib.c line 1569
static void lglpopcontrol(struct LGL *lgl)
{
  lgl->control.top = lgl->control.top - 1l;
}

// lglpopesched
// file lglib.c line 5628
static signed int lglpopesched(struct LGL *lgl)
{
  struct Stk *s = &lgl->esched;
  signed int res;
  signed int last;
  signed int cnt;
  signed int *p;
  struct EVar *ev;
  res = *s->start;

__CPROVER_DUMP_L1:
  ;
  ev=lglevar(lgl, res);
  ev->pos = -1;
  last=lglpopstk(s);
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(s);
  cnt = (signed int)return_value_lglcntstk$1;
  if(cnt == 0)
    return res;

  else
  {
    p=lglepos(lgl, last);
    *p = 0;
    *s->start = last;
    lgledown(lgl, last);
    return res;
  }
}

// lglpopnunlcamarkstk
// file lglib.c line 4132
static void lglpopnunlcamarkstk(struct LGL *lgl, struct Stk *stk)
{
  signed int return_value_lglmtstk$1;
  signed int return_value_lglpopstk$2;
  struct AVar *return_value_lglavar$3;
  do
  {
    return_value_lglmtstk$1=lglmtstk(stk);
    if(!(return_value_lglmtstk$1 == 0))
      break;

    return_value_lglpopstk$2=lglpopstk(stk);
    return_value_lglavar$3=lglavar(lgl, return_value_lglpopstk$2);
    return_value_lglavar$3->lcamark = (unsigned int)0;
  }
  while((_Bool)1);
}

// lglpopnunmarkstk
// file lglib.c line 4127
static void lglpopnunmarkstk(struct LGL *lgl, struct Stk *stk)
{
  signed int return_value_lglmtstk$1;
  signed int return_value_lglpopstk$2;
  struct AVar *return_value_lglavar$3;
  do
  {
    return_value_lglmtstk$1=lglmtstk(stk);
    if(!(return_value_lglmtstk$1 == 0))
      break;

    return_value_lglpopstk$2=lglpopstk(stk);
    return_value_lglavar$3=lglavar(lgl, return_value_lglpopstk$2);
    return_value_lglavar$3->mark = 0;
  }
  while((_Bool)1);
}

// lglpopstk
// file lglib.c line 1447
static signed int lglpopstk(struct Stk *s)
{
  s->top = s->top - 1l;
  return *s->top;
}

// lglpos2cnf
// file lglib.c line 10729
static signed long int lglpos2cnf(signed int pos)
{
  return (signed long int)pos;
}

// lglposcofactorfun
// file lglib.c line 10760
static void lglposcofactorfun(unsigned long int *f, signed int v, unsigned long int *res)
{
  unsigned long int mask[64l];
  unsigned long int masked[64l];
  lglvar2fun(v, mask);
  lgland3fun(masked, f, mask);
  lglfuncpy(res, masked);
  lglsrfun(masked, 1 << v);
  lglorfun(res, masked);
}

// lglprbana
// file lglib.c line 8406
static signed int lglprbana(struct LGL *lgl, signed int probe)
{
  signed int open;
  signed int lit;
  signed int r0;
  signed int r1;
  signed int tag;
  signed int red;
  signed int other;
  signed int res;
  signed int *p;
  signed int *rsn;
  lit = lgl->conf.lit;
  r0 = lgl->conf.rsn[(signed long int)0];
  r1 = lgl->conf.rsn[(signed long int)1];
  open=lglprbpull(lgl, lit, probe);

__CPROVER_DUMP_L1:
  ;
  signed int return_value_lglprbpull$2;
  signed int *tmp_post$3;
  signed int return_value_lglprbpull$4;
  signed int return_value_lglmarked$5;
  do
  {
    tag = r0 & MASKCS;
    if(tag == BINCS || tag == TRNCS)
    {
      other = r0 >> RMSHFT;
      signed int return_value_lglprbpull$1;
      return_value_lglprbpull$1=lglprbpull(lgl, other, probe);
      if(!(return_value_lglprbpull$1 == 0))
        open = open + 1;

      if(tag == TRNCS)
      {
        return_value_lglprbpull$2=lglprbpull(lgl, r1, probe);
        if(!(return_value_lglprbpull$2 == 0))
          open = open + 1;

      }

    }

    else
    {
      red = r0 & REDCS;
      p=lglidx2lits(lgl, LRGCS, red, r1);
      do
      {
        tmp_post$3 = p;
        p = p + 1l;
        other = *tmp_post$3;
        if(other == 0)
          break;

        return_value_lglprbpull$4=lglprbpull(lgl, other, probe);
        open = open + return_value_lglprbpull$4;
      }
      while((_Bool)1);
    }

  __CPROVER_DUMP_L8:
    ;
    do
    {
      lit=lglpopstk(&lgl->trail);
      return_value_lglmarked$5=lglmarked(lgl, lit);
      if(!(return_value_lglmarked$5 == 0))
        break;

      lglunassign(lgl, lit);
    }
    while((_Bool)1);
    lglunassign(lgl, lit);
    open = open - 1;
    if(open == 0)
    {
      res = lit;
      break;
    }


  __CPROVER_DUMP_L11:
    ;
    rsn=lglrsn(lgl, lit);
    r0 = rsn[(signed long int)0];
    r1 = rsn[(signed long int)1];
  }
  while((_Bool)1);
  if(res == probe)

    __CPROVER_DUMP_L13:
      ;

  else

    __CPROVER_DUMP_L14:
      ;
  lglpopnunmarkstk(lgl, &lgl->seen);
  return res;
}

// lglprbpull
// file lglib.c line 8393
static signed int lglprbpull(struct LGL *lgl, signed int lit, signed int probe)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  if(!(av->mark == 0))
    return 0;

  else
  {
    signed int return_value_lglevel$1;
    return_value_lglevel$1=lglevel(lgl, lit);
    if(return_value_lglevel$1 == 0)
      return 0;

    else
    {
      av->mark = 1;
      lglpushstk(lgl, &lgl->seen, -lit);

    __CPROVER_DUMP_L3:
      ;
      return 1;
    }
  }
}

// lglprefix
// file lglib.c line 1186
static const char * lglprefix(struct LGL *lgl)
{
  _Bool tmp_if_expr$1;
  if(!(lgl == ((struct LGL *)NULL)))
    tmp_if_expr$1 = lgl->prefix != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  char *tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = lgl->prefix;

  else
    tmp_if_expr$2 = "c (LGL HAS NO PREFIX YET) ";
  return tmp_if_expr$2;
}

// lglpreprocessing
// file lglib.c line 17151
static signed int lglpreprocessing(struct LGL *lgl, signed int forced)
{
  signed int res = (signed int)!(lgl->mt != 0);
  signed int oldrem;
  signed int pcntremoved;
  _Bool tmp_if_expr$1;
  if(!(forced == 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(lgl->stats->simp.count != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    lgl->stats->simp.count = lgl->stats->simp.count + 1;
    oldrem=lglrem(lgl);
    res=lglisimp(lgl);
    pcntremoved=lglsimpcntrem(lgl, oldrem);
    lglupdprepint(lgl, forced != 0 ? 0x7fffffff : pcntremoved);
  }

  return res;
}

// lglprint
// file lglib.c line 18806
void lglprint(struct LGL *lgl, struct _IO_FILE *file)
{
  signed int count = 0;
  lglctrav(lgl, (void *)&count, lgltravcounter);
  signed int return_value_lglmaxvar$1;
  return_value_lglmaxvar$1=lglmaxvar(lgl);
  fprintf(file, "p cnf %d %d\n", return_value_lglmaxvar$1, count);
  lglctrav(lgl, (void *)file, lgltravprinter);
}

// lglprintfeatures
// file lglib.c line 18556
void lglprintfeatures(struct LGL *lgl)
{
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"vars", lgl->stats->features.vars);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"lits.total", lgl->stats->features.lits.total);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"lits.pos", lgl->stats->features.lits.pos);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"lits.neg", lgl->stats->features.lits.neg);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"clauses.total", lgl->stats->features.clauses.total);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"clauses.unit", lgl->stats->features.clauses.unit);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"clauses.bin", lgl->stats->features.clauses.bin);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"clauses.trn", lgl->stats->features.clauses.trn);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"clauses.lrg", lgl->stats->features.clauses.lrg);
  while((_Bool)0);
  lglcomputecog(lgl);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"cog.val.min", lgl->stats->features.cog.val.min);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"cog.val.avg", lgl->stats->features.cog.val.avg);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"cog.val.max", lgl->stats->features.cog.val.max);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"cog.var.min", lgl->stats->features.cog.var.min);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"cog.var.avg", lgl->stats->features.cog.var.avg);
  while((_Bool)0);
  do
    fprintf(lgl->out, "%sfeature %s %d\n", lgl->prefix, (const void *)"cog.var.max", lgl->stats->features.cog.var.max);
  while((_Bool)0);
}

// lglprobe
// file lglib.c line 9113
static signed int lglprobe(struct LGL *lgl)
{
  signed int res = 1;
  lglstart(lgl, &lgl->times->prb.all);
  res=lglbasicprobe(lgl);
  lglstop(lgl);
  return res;
}

// lglprobing
// file lglib.c line 16864
static signed int lglprobing(struct LGL *lgl)
{
  if(lgl->opts->probe.val == 0)
    return 0;

  else
    if(!(lgl->opts->prbasic.val == 0))
      return 1;

    else
    {
      signed int return_value_lglsmallirr$1;
      return_value_lglsmallirr$1=lglsmallirr(lgl);
      if(return_value_lglsmallirr$1 == 0)
        return 0;

      else
        return 0;
    }
}

// lglprocesstime
// file lglib.h line 290
double lglprocesstime(void)
{
  struct rusage u;
  double res;
  signed int return_value_getrusage$1;
  return_value_getrusage$1=getrusage(0, &u);
  if(!(return_value_getrusage$1 == 0))
    return (double)0;

  else
  {
    res = (double)u.ru_utime.tv_sec + 1e-6 * (double)u.ru_utime.tv_usec;
    res = res + (double)u.ru_stime.tv_sec + 1e-6 * (double)u.ru_stime.tv_usec;
    return res;
  }
}

// lglprop
// file lglib.c line 4420
static void lglprop(struct LGL *lgl, signed int lit)
{
  signed int *p;
  signed int *q;
  signed int *eos;
  signed int blit;
  signed int other;
  signed int other2;
  signed int other3;
  signed int red;
  signed int prev;
  signed int tag;
  signed int val;
  signed int val2;
  signed int lidx;
  signed int *c;
  signed int *l;
  signed int dom;
  signed int hbred;
  signed int subsumed;
  signed int glue;
  signed int flushoccs;
  signed long int delta;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  hts=lglhts(lgl, -lit);
  signed int *tmp_post$1;
  signed int *tmp_post$3;
  signed int return_value_lgliselim$4;
  signed int *tmp_post$5;
  signed int *tmp_post$6;
  signed int return_value_lgliselim$7;
  signed int return_value_lgliselim$9;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$15;
  signed int return_value_lgliselim$17;
  signed int return_value_lgliselim$19;
  _Bool tmp_if_expr$27;
  _Bool tmp_if_expr$28;
  _Bool tmp_if_expr$29;
  _Bool tmp_if_expr$23;
  signed int *tmp_post$24;
  signed int *tmp_post$30;
  signed int *tmp_post$31;
  signed int *tmp_post$32;
  signed int *tmp_post$33;
  if(!(hts->offset == 0))
  {
    flushoccs = 0;
    q=lglhts2wchs(lgl, hts);
    eos = q + (signed long int)hts->count;
    p = q;
    for( ; !(p >= eos); p = p + 1l)
    {
      blit = *p;
      tag = blit & MASKCS;
      red = blit & REDCS;
      if(tag == OCCS)
      {
        tmp_post$1 = q;
        q = q + 1l;
        *tmp_post$1 = blit;
      }

      else
      {
        other = blit >> RMSHFT;
        signed char return_value_lglval$2;
        return_value_lglval$2=lglval(lgl, other);
        val = (signed int)return_value_lglval$2;
        if(tag == BINCS)
        {
          tmp_post$3 = q;
          q = q + 1l;
          *tmp_post$3 = blit;
          if(val >= 1)
            goto __CPROVER_DUMP_L97;

          if(!(red == 0))
          {
            return_value_lgliselim$4=lgliselim(lgl, other);
            if(!(return_value_lgliselim$4 == 0))
              goto __CPROVER_DUMP_L97;

          }

          if(!(val >= 0))
          {
            lglbonflict(lgl, -lit, blit);
            p = p + 1l;
            break;
          }

          lglf2rce(lgl, other, -lit, red);
        }

        else
          if(tag == TRNCS)
          {
            tmp_post$5 = q;
            q = q + 1l;
            *tmp_post$5 = blit;
            p = p + 1l;
            other2 = *p;
            tmp_post$6 = q;
            q = q + 1l;
            *tmp_post$6 = other2;
            if(val >= 1)
              goto __CPROVER_DUMP_L97;

            if(!(red == 0))
            {
              return_value_lgliselim$7=lgliselim(lgl, other);
              if(!(return_value_lgliselim$7 == 0))
                goto __CPROVER_DUMP_L97;

            }

            signed char return_value_lglval$8;
            return_value_lglval$8=lglval(lgl, other2);
            val2 = (signed int)return_value_lglval$8;
            if(val2 >= 1)
              goto __CPROVER_DUMP_L97;

            if(val == 0 && val2 == 0)
              goto __CPROVER_DUMP_L97;

            if(!(red == 0))
            {
              return_value_lgliselim$9=lgliselim(lgl, other2);
              if(!(return_value_lgliselim$9 == 0))
                goto __CPROVER_DUMP_L97;

            }

            if(!(val >= 0) && !(val2 >= 0))
            {
              lgltonflict(lgl, -lit, blit, other2);
              p = p + 1l;
              break;
            }

            if(val == 0)
              do
              {
                signed int TMP = other;
                other = other2;
                other2 = TMP;
              }
              while((_Bool)0);

            if(!(lgl->level == 0))
              tmp_if_expr$13 = lgl->simp != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$13 = (_Bool)0;
            if(tmp_if_expr$13)
              tmp_if_expr$14 = lgl->opts->lhbr.val != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$14 = (_Bool)0;
            if(tmp_if_expr$14)
              tmp_if_expr$15 = !(lgl->cgrclosing != 0) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$15 = (_Bool)0;
            if(tmp_if_expr$15)
            {
              dom=lglgetdom(lgl, lit);
              signed int return_value_lglgetdom$10;
              return_value_lglgetdom$10=lglgetdom(lgl, -other);
              if(!(return_value_lglgetdom$10 == dom))
                goto NO_HBR_JUST_F3RCE;

              dom=lglca(lgl, lit, -other);
              if(dom == 0)
                goto NO_HBR_JUST_F3RCE;

              subsumed = (signed int)(dom == lit || dom == -other);
              hbred=lglhbred(lgl, subsumed, red);

            __CPROVER_DUMP_L23:
              ;
              if(!(subsumed == 0))
              {

              __CPROVER_DUMP_L24:
                ;
                lglrmtwch(lgl, other2, other, -lit, red);
                lglrmtwch(lgl, other, other2, -lit, red);
                lgl->stats->hbr.sub = lgl->stats->hbr.sub + 1;
                if(!(red == 0))
                  lgl->stats->red.trn = lgl->stats->red.trn - 1;

                else
                {
                  lgldecirr(lgl, 3);
                  if(!(lgl->dense == 0))
                  {
                    if(-dom == -lit)
                      lgldecocc(lgl, other);

                    else
                      lgldecocc(lgl, -lit);
                  }

                }
              }

              delta = (signed long int)0;
              if(dom == lit)
              {

              __CPROVER_DUMP_L28:
                ;
                blit = other2 << RMSHFT | BINCS | hbred;
                q[(signed long int)-2] = blit;
                q = q - 1l;
              }

              else
              {
                if(dom == -other)
                {

                __CPROVER_DUMP_L30:
                  ;
                  q = q - (signed long int)2;
                }

                else

                  __CPROVER_DUMP_L31:
                    ;
                signed long int return_value_lglwchbin$11;
                return_value_lglwchbin$11=lglwchbin(lgl, -dom, other2, hbred);
                delta = delta + return_value_lglwchbin$11;
              }
              signed long int return_value_lglwchbin$12;
              return_value_lglwchbin$12=lglwchbin(lgl, other2, -dom, hbred);
              delta = delta + return_value_lglwchbin$12;
              if(!(delta == 0l))
              {
                p = p + delta;
                q = q + delta;
                eos = eos + delta;
              }

              if(!(hbred == 0))
                lgl->stats->red.bin = lgl->stats->red.bin + 1;

              else
                lglincirr(lgl, 2);
              lglf2rce(lgl, other2, -dom, hbred);
              lgl->stats->hbr.trn = lgl->stats->hbr.trn + 1;
              lgl->stats->hbr.cnt = lgl->stats->hbr.cnt + 1;
              lgl->stats->prgss = lgl->stats->prgss + 1l;
            }

            else
            {

            NO_HBR_JUST_F3RCE:
              ;
              lglf3rce(lgl, other2, -lit, other, red);
            }
          }

          else
          {
            if(!(val >= 1))
            {
              lidx = p[(signed long int)1];
              c=lglidx2lits(lgl, LRGCS, red, lidx);
              other2 = c[(signed long int)0];
              if(other2 >= 134217727)
              {
                p = p + 1l;
                goto __CPROVER_DUMP_L97;
              }

              if(other2 == -lit)
              {
                c[(signed long int)0] = c[(signed long int)1];
                other2 = c[(signed long int)0];
                c[(signed long int)1] = -lit;
              }

              if(!(other2 == other))
              {
                other = other2;
                signed char return_value_lglval$16;
                return_value_lglval$16=lglval(lgl, other);
                val = (signed int)return_value_lglval$16;
                blit = red;
                blit = blit | LRGCS;
                blit = blit | other2 << RMSHFT;
                if(val >= 1)
                  goto COPYL;

              }

              if(!(red == 0))
              {
                return_value_lgliselim$17=lgliselim(lgl, other);
                if(!(return_value_lgliselim$17 == 0))
                  goto COPYL;

              }

              val2 = 0x7fffffff;
              prev = -lit;
              l = c + (signed long int)2;
              do
              {
                other2 = *l;
                if(other2 == 0)
                  break;

                *l = prev;
                signed char return_value_lglval$18;
                return_value_lglval$18=lglval(lgl, other2);
                val2 = (signed int)return_value_lglval$18;
                if(val2 >= 0)
                  break;

                if(!(red == 0))
                {
                  return_value_lgliselim$19=lgliselim(lgl, other2);
                  if(!(return_value_lgliselim$19 == 0))
                    break;

                }

                prev = other2;
                l = l + 1l;
              }
              while((_Bool)1);
              if(val2 >= 0 && !(other2 == 0))
              {
                c[(signed long int)1] = other2;
                delta=lglwchlrg(lgl, other2, other, red, lidx);
                if(!(delta == 0l))
                {
                  p = p + delta;
                  q = q + delta;
                  eos = eos + delta;
                }

                p = p + 1l;
                goto __CPROVER_DUMP_L97;
              }

              for( ; !(c + 2l >= l); prev = other3)
              {
                l = l - 1l;
                other3 = *l;
                *l = prev;
              }
              if(other2 == 0 || val2 >= 0)
              {
                if(!(val >= 0))
                {
                  lglonflict(lgl, 1, -lit, red, lidx);
                  break;
                }

                if(!(lgl->level == 0))
                  tmp_if_expr$27 = lgl->simp != 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$27 = (_Bool)0;
                if(tmp_if_expr$27)
                  tmp_if_expr$28 = lgl->opts->lhbr.val != 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$28 = (_Bool)0;
                if(tmp_if_expr$28)
                  tmp_if_expr$29 = !(lgl->cgrclosing != 0) ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$29 = (_Bool)0;
                if(tmp_if_expr$29)
                {
                  dom = 0;
                  l = c;
                  do
                  {
                    other2 = *l;
                    if(other2 == 0)
                      break;

                    if(!(other2 == other))
                    {
                      signed int return_value_lglevel$20;
                      return_value_lglevel$20=lglevel(lgl, other2);
                      if(!(return_value_lglevel$20 == 0))
                      {
                        if(dom == 0)
                          dom=lglgetdom(lgl, -other);

                        signed int return_value_lglgetdom$21;
                        return_value_lglgetdom$21=lglgetdom(lgl, -other2);
                        if(!(dom == return_value_lglgetdom$21))
                          goto NO_HBR_JUST_FLRCE;

                      }

                    }

                    l = l + 1l;
                  }
                  while((_Bool)1);

                __CPROVER_DUMP_L61:
                  ;
                  dom = 0;
                  l = c;
                  do
                  {
                    other2 = *l;
                    if(other2 == 0)
                      break;

                    if(!(other2 == other))
                    {
                      signed int return_value_lglevel$22;
                      return_value_lglevel$22=lglevel(lgl, other2);
                      if(!(return_value_lglevel$22 == 0))
                        dom=lglca(lgl, dom, -other2);

                    }

                    l = l + 1l;
                  }
                  while((_Bool)1);
                  if(dom == 0)
                    goto NO_HBR_JUST_FLRCE;


                __CPROVER_DUMP_L65:
                  ;
                  subsumed = 0;
                  l = c;
                  do
                  {
                    if(subsumed == 0)
                    {
                      other2 = *l;
                      tmp_if_expr$23 = other2 != 0 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$23 = (_Bool)0;
                    if(!tmp_if_expr$23)
                      break;

                    subsumed = (signed int)(dom == -other2);
                    l = l + 1l;
                  }
                  while((_Bool)1);
                  hbred=lglhbred(lgl, subsumed, red);

                __CPROVER_DUMP_L70:
                  ;
                  if(!(subsumed == 0))
                  {

                  __CPROVER_DUMP_L71:
                    ;
                    lglrmlwch(lgl, other, red, lidx);
                    lgl->stats->hbr.sub = lgl->stats->hbr.sub + 1;
                    if(!(red == 0))
                    {
                      glue = lidx & (1 << 4) - 1;
                      if(!(glue == 15))
                      {
                        lgl->stats->red.lrg = lgl->stats->red.lrg - 1;
                        lgl->stats->lir[(signed long int)glue].clauses = lgl->stats->lir[(signed long int)glue].clauses - 1;
                      }

                    }

                    if(red == 0)
                    {
                      if(!(lgl->dense == 0))
                      {
                        l = c;
                        do
                        {
                          other2 = *l;
                          if(other2 == 0)
                            break;

                          if(!(other2 == -lit))
                            lglrmlocc(lgl, other2, 0, lidx);

                          if(!(other2 == -dom))
                          {
                            if(!(other2 == other))
                              lgldecocc(lgl, other2);

                          }

                          l = l + 1l;
                        }
                        while((_Bool)1);
                        flushoccs = flushoccs + 1;
                      }

                    }

                    if(!(red == 0) && !(glue >= 15))
                    {

                    __CPROVER_DUMP_L78:
                      ;
                      c[(signed long int)-1] = 0x7fffffff;
                    }

                    l = c;
                    for( ; !(*l == 0); l = l + 1l)
                      *l = 0x7fffffff;
                    if(red == 0)
                      lgldecirr(lgl, (signed int)(l - c));

                    *l = 0x7fffffff;
                  }

                  delta = (signed long int)0;
                  if(dom == lit)
                  {

                  __CPROVER_DUMP_L84:
                    ;
                    blit = other << RMSHFT | BINCS | hbred;
                    tmp_post$24 = q;
                    q = q + 1l;
                    *tmp_post$24 = blit;
                    p = p + 1l;
                  }

                  else
                  {
                    if(!(subsumed == 0))
                    {

                    __CPROVER_DUMP_L86:
                      ;
                      p = p + 1l;
                    }

                    else

                      __CPROVER_DUMP_L87:
                        ;
                    signed long int return_value_lglwchbin$25;
                    return_value_lglwchbin$25=lglwchbin(lgl, -dom, other, hbred);
                    delta = delta + return_value_lglwchbin$25;
                  }
                  signed long int return_value_lglwchbin$26;
                  return_value_lglwchbin$26=lglwchbin(lgl, other, -dom, hbred);
                  delta = delta + return_value_lglwchbin$26;
                  if(!(delta == 0l))
                  {
                    p = p + delta;
                    q = q + delta;
                    eos = eos + delta;
                  }

                  if(!(hbred == 0))
                    lgl->stats->red.bin = lgl->stats->red.bin + 1;

                  else
                    lglincirr(lgl, 2);
                  lglf2rce(lgl, other, -dom, hbred);
                  lgl->stats->hbr.lrg = lgl->stats->hbr.lrg + 1;
                  lgl->stats->hbr.cnt = lgl->stats->hbr.cnt + 1;
                  lgl->stats->prgss = lgl->stats->prgss + 1l;
                  if(!(subsumed == 0))
                    goto __CPROVER_DUMP_L97;

                }

                else
                {

                NO_HBR_JUST_FLRCE:
                  ;
                  lglflrce(lgl, other, red, lidx);
                }
              }

            }


          COPYL:
            ;
            tmp_post$30 = q;
            q = q + 1l;
            *tmp_post$30 = blit;
            tmp_post$31 = q;
            q = q + 1l;
            p = p + 1l;
            *tmp_post$31 = *p;
          }
      }

    __CPROVER_DUMP_L97:
      ;
    }
    for( ; !(p >= eos); *tmp_post$32 = *tmp_post$33)
    {
      tmp_post$32 = q;
      q = q + 1l;
      tmp_post$33 = p;
      p = p + 1l;
    }
    lglshrinkhts(lgl, hts, (signed int)((signed long int)hts->count - (p - q)));
    if(!(flushoccs == 0))
      lglflushremovedoccs(lgl, -lit);

  }

}

// lglprop2
// file lglib.c line 4697
static void lglprop2(struct LGL *lgl, signed int lit)
{
  signed int other;
  signed int blit;
  signed int tag;
  signed int val;
  signed int red;
  signed int visits;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  visits = 0;
  hts=lglhts(lgl, -lit);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    visits = visits + 1;
    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(tag == BINCS)
    {
      red = blit & REDCS;
      other = blit >> RMSHFT;
      signed int return_value_lgliselim$1;
      return_value_lgliselim$1=lgliselim(lgl, other);
      if(return_value_lgliselim$1 == 0)
      {
        signed char return_value_lglval$2;
        return_value_lglval$2=lglval(lgl, other);
        val = (signed int)return_value_lglval$2;
        if(!(val >= 1))
        {
          if(!(val >= 0))
          {
            lglbonflict(lgl, -lit, blit);
            break;
          }

          lglf2rce(lgl, other, -lit, red);
        }

      }

    }

  }
  if(!(lgl->lkhd == 0))
    lgl->stats->visits.lkhd = lgl->stats->visits.lkhd + (signed long int)visits;

  else
    if(!(lgl->simp == 0))
      lgl->stats->visits.simp = lgl->stats->visits.simp + (signed long int)visits;

    else
      lgl->stats->visits.search = lgl->stats->visits.search + (signed long int)visits;
  if(!(lgl->basicprobing == 0))
    lgl->stats->prb.basic.steps = lgl->stats->prb.basic.steps + (signed long int)visits;

  if(!(lgl->cceing == 0))
    lgl->stats->cce.steps = lgl->stats->cce.steps + (signed long int)visits;

  if(!(lgl->cliffing == 0))
    lgl->stats->cliff.steps = lgl->stats->cliff.steps + (signed long int)visits;

}

// lglpropsearch
// file lglib.c line 4245
static void lglpropsearch(struct LGL *lgl, signed int lit)
{
  signed int *q;
  signed int *eos;
  signed int blit;
  signed int other;
  signed int other2;
  signed int other3;
  signed int red;
  signed int prev;
  signed int tag;
  signed int val;
  signed int val2;
  signed int lidx;
  signed int *c;
  signed int *l;
  const signed int *p;
  signed int visits;
  signed long int delta;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  hts=lglhts(lgl, -lit);
  signed int *tmp_post$1;
  signed int *tmp_post$2;
  signed int *tmp_post$7;
  const signed int *tmp_post$8;
  if(!(hts->offset == 0))
  {
    q=lglhts2wchs(lgl, hts);
    eos = q + (signed long int)hts->count;
    visits = 0;
    p = q;
    for( ; !(p >= eos); p = p + 1l)
    {
      visits = visits + 1;
      tmp_post$1 = q;
      q = q + 1l;
      blit = *p;
      *tmp_post$1 = blit;
      tag = blit & MASKCS;
      if(!(tag == BINCS))
      {
        tmp_post$2 = q;
        q = q + 1l;
        p = p + 1l;
        *tmp_post$2 = *p;
      }

      other = blit >> RMSHFT;
      signed char return_value_lglval$3;
      return_value_lglval$3=lglval(lgl, other);
      val = (signed int)return_value_lglval$3;
      if(!(val >= 1))
      {
        red = blit & REDCS;
        if(tag == BINCS)
        {
          if(!(val >= 0))
          {
            lglbonflict(lgl, -lit, blit);
            p = p + 1l;
            break;
          }

          lglf2rce(lgl, other, -lit, red);
        }

        else
          if(tag == TRNCS)
          {
            other2 = *p;
            signed char return_value_lglval$4;
            return_value_lglval$4=lglval(lgl, other2);
            val2 = (signed int)return_value_lglval$4;
            if(val2 >= 1)
              goto __CPROVER_DUMP_L25;

            if(val == 0 && val2 == 0)
              goto __CPROVER_DUMP_L25;

            if(!(val >= 0) && !(val2 >= 0))
            {
              lgltonflict(lgl, -lit, blit, other2);
              p = p + 1l;
              break;
            }

            if(val == 0)
              do
              {
                signed int TMP = other;
                other = other2;
                other2 = TMP;
              }
              while((_Bool)0);

            lglf3rce(lgl, other2, -lit, other, red);
          }

          else
          {
            lidx = *p;
            c=lglidx2lits(lgl, LRGCS, red, lidx);
            other2 = c[(signed long int)0];
            if(other2 == -lit)
            {
              c[(signed long int)0] = c[(signed long int)1];
              other2 = c[(signed long int)0];
              c[(signed long int)1] = -lit;
            }

            if(!(other2 == other))
            {
              other = other2;
              signed char return_value_lglval$5;
              return_value_lglval$5=lglval(lgl, other);
              val = (signed int)return_value_lglval$5;
              if(val >= 1)
              {
                q[(signed long int)-2] = LRGCS | other2 << RMSHFT | red;
                goto __CPROVER_DUMP_L25;
              }

            }

            val2 = 0x7fffffff;
            prev = -lit;
            l = c + (signed long int)2;
            do
            {
              other2 = *l;
              if(other2 == 0)
                break;

              *l = prev;
              signed char return_value_lglval$6;
              return_value_lglval$6=lglval(lgl, other2);
              val2 = (signed int)return_value_lglval$6;
              if(val2 >= 0)
                break;

              prev = other2;
              l = l + 1l;
            }
            while((_Bool)1);
            if(val2 >= 0 && !(other2 == 0))
            {
              c[(signed long int)1] = other2;
              delta=lglwchlrg(lgl, other2, other, red, lidx);
              if(!(delta == 0l))
              {
                p = p + delta;
                q = q + delta;
                eos = eos + delta;
              }

              q = q - (signed long int)2;
              goto __CPROVER_DUMP_L25;
            }

            for( ; !(c + 2l >= l); prev = other3)
            {
              l = l - 1l;
              other3 = *l;
              *l = prev;
            }
            if(!(val >= 0))
            {
              lglonflict(lgl, 1, -lit, red, lidx);
              p = p + 1l;
              break;
            }

            lglflrce(lgl, other, red, lidx);
          }
      }


    __CPROVER_DUMP_L25:
      ;
    }
    for( ; !(p >= eos); *tmp_post$7 = *tmp_post$8)
    {
      tmp_post$7 = q;
      q = q + 1l;
      tmp_post$8 = p;
      p = p + 1l;
    }
    lglshrinkhts(lgl, hts, (signed int)((signed long int)hts->count - (p - q)));
    lgl->stats->visits.search = lgl->stats->visits.search + (signed long int)visits;
  }

}

// lglpropunits
// file lglib.c line 13725
static signed int lglpropunits(struct LGL *lgl)
{
  signed int lit;
  signed char val;
  signed int return_value_lglmtstk$1;
  do
  {
    return_value_lglmtstk$1=lglmtstk(&lgl->$anon0.cgr->units);
    if(!(return_value_lglmtstk$1 == 0))
      break;

    lit=lglpopstk(&lgl->$anon0.cgr->units);
    signed int return_value_lglcval$2;
    return_value_lglcval$2=lglcval(lgl, lit);
    val = (signed char)return_value_lglcval$2;
    if(!((signed int)val >= 1))
    {
      if(!((signed int)val >= 0))
      {

      __CPROVER_DUMP_L3:
        ;
        lgl->mt = 1;
      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        lglunitnocheck(lgl, lit);
        signed int return_value_lglbcp$3;
        return_value_lglbcp$3=lglbcp(lgl);
        if(!(return_value_lglbcp$3 == 0))
          continue;


      __CPROVER_DUMP_L5:
        ;
        lgl->mt = 1;
      }
    }

  }
  while((_Bool)1);
  return (signed int)!(lgl->mt != 0);
}

// lglprs
// file lglib.c line 18084
static void lglprs(struct LGL *lgl, const char *fmt, ...)
{
  void **ap;
  lglprstart(lgl);
  ap = (void **)&fmt;
  vfprintf(lgl->out, fmt, ap);
  ap = ((void **)NULL);
  fputc(10, lgl->out);
}

// lglprstart
// file lglib.c line 18078
static void lglprstart(struct LGL *lgl)
{
  fputs(lgl->prefix, lgl->out);
  if(lgl->tid >= 0)
    fprintf(lgl->out, "%d ", lgl->tid);

}

// lglprt
// file lglib.c line 1206
static void lglprt(struct LGL *lgl, signed int level, const char *msg, ...)
{
  void **ap;
  if(lgl->opts->verbose.val >= level)
  {
    lglmsgstart(lgl, level);
    ap = (void **)&msg;
    vfprintf(lgl->out, msg, ap);
    ap = ((void **)NULL);
    lglmsgend(lgl);
  }

}

// lglprtcgrem
// file lglib.c line 12985
static void lglprtcgrem(struct LGL *lgl)
{
  signed int idx;
  signed int ret = 0;
  signed int rem = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree$1;
    return_value_lglisfree$1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree$1 == 0))
    {
      struct AVar *return_value_lglavar$2;
      return_value_lglavar$2=lglavar(lgl, idx);
      if(!(return_value_lglavar$2->donotcgrcls == 0u))
        ret = ret + 1;

      else
        rem = rem + 1;
    }

  }
  signed int return_value_lglrem$3;
  double return_value_lglpcnt$4;
  struct AVar *return_value_lglavar$5;
  if(!(rem == 0))
  {
    return_value_lglrem$3=lglrem(lgl);
    return_value_lglpcnt$4=lglpcnt((double)rem, (double)return_value_lglrem$3);
    lglprt(lgl, 1, "[cgrclsr-%d] %d variables remain %.0f%% (%d retained)", lgl->stats->cgr.count, rem, return_value_lglpcnt$4, ret);
  }

  else
  {
    lglprt(lgl, 1, "[cgrclsr-%d] fully completed congruence closure", lgl->stats->cgr.count);
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      return_value_lglavar$5=lglavar(lgl, idx);
      return_value_lglavar$5->donotcgrcls = (unsigned int)0;
    }
  }
}

// lglprternresrem
// file lglib.c line 14689
static void lglprternresrem(struct LGL *lgl)
{
  signed int idx;
  signed int ret = 0;
  signed int rem = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree$1;
    return_value_lglisfree$1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree$1 == 0))
    {
      struct AVar *return_value_lglavar$2;
      return_value_lglavar$2=lglavar(lgl, idx);
      if(!(return_value_lglavar$2->donoternres == 0u))
        ret = ret + 1;

      else
        rem = rem + 1;
    }

  }
  signed int return_value_lglrem$3;
  double return_value_lglpcnt$4;
  struct AVar *return_value_lglavar$5;
  if(!(rem == 0))
  {
    return_value_lglrem$3=lglrem(lgl);
    return_value_lglpcnt$4=lglpcnt((double)rem, (double)return_value_lglrem$3);
    lglprt(lgl, 1, "[ternres-%d] %d variables remain %.0f%% (%d retained)", lgl->stats->trnr.count, rem, return_value_lglpcnt$4, ret);
  }

  else
  {
    lglprt(lgl, 1, "[ternres-%d] fully completed ternary resolution", lgl->stats->trnr.count);
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      return_value_lglavar$5=lglavar(lgl, idx);
      return_value_lglavar$5->donoternres = (unsigned int)0;
    }
  }
}

// lglprtlftrem
// file lglib.c line 13956
static void lglprtlftrem(struct LGL *lgl)
{
  signed int idx;
  signed int ret = 0;
  signed int rem = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree$1;
    return_value_lglisfree$1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree$1 == 0))
    {
      struct AVar *return_value_lglavar$2;
      return_value_lglavar$2=lglavar(lgl, idx);
      if(!(return_value_lglavar$2->donotlft == 0u))
        ret = ret + 1;

      else
        rem = rem + 1;
    }

  }
  signed int return_value_lglrem$3;
  double return_value_lglpcnt$4;
  struct AVar *return_value_lglavar$5;
  if(!(rem == 0))
  {
    return_value_lglrem$3=lglrem(lgl);
    return_value_lglpcnt$4=lglpcnt((double)rem, (double)return_value_lglrem$3);
    lglprt(lgl, 1, "[lift-%d] %d variables remain %.0f%% (%d retained)", lgl->stats->lift.count, rem, return_value_lglpcnt$4, ret);
  }

  else
  {
    lglprt(lgl, 1, "[lift-%d] fully completed lifting", lgl->stats->lift.count);
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      return_value_lglavar$5=lglavar(lgl, idx);
      return_value_lglavar$5->donotlft = (unsigned int)0;
    }
  }
}

// lglptrjmp
// file lglib.c line 7151
static signed int lglptrjmp(signed int *repr, signed int max, signed int start)
{
  signed int lglptrjmp$$1$$next;
  signed int idx;
  signed int res;
  signed int sgn;
  signed int tmp;
  lglptrjmp$$1$$next = start;
  do
  {
    res = lglptrjmp$$1$$next;
    idx=abs(res);
    sgn=lglsgn(res);
    lglptrjmp$$1$$next = repr[(signed long int)idx];
    lglptrjmp$$1$$next = lglptrjmp$$1$$next * sgn;
  }
  while(!(lglptrjmp$$1$$next == 0));
  tmp = start;
  for( ; !(tmp == res); tmp = lglptrjmp$$1$$next)
  {
    idx=abs(tmp);
    sgn=lglsgn(tmp);
    lglptrjmp$$1$$next = repr[(signed long int)idx] * sgn;
    repr[(signed long int)idx] = sgn * res;
  }
  return res;
}

// lglpull
// file lglib.c line 4809
static signed int lglpull(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int level;
  signed int res;
  level=lglevel(lgl, lit);
  if(level == 0)
    return 0;

  else
    if(!(av->mark == 0))
      return 0;

    else
    {
      av->mark = 1;
      lglpushstk(lgl, &lgl->seen, lit);
      if(level == lgl->level)
      {

      __CPROVER_DUMP_L3:
        ;
        res = 1;
      }

      else
      {
        lglpushstk(lgl, &lgl->clause, lit);

      __CPROVER_DUMP_L5:
        ;
        signed int return_value_lglevelused$1;
        return_value_lglevelused$1=lglevelused(lgl, level);
        if(return_value_lglevelused$1 == 0)
        {
          lgluselevel(lgl, level);
          lglpushstk(lgl, &lgl->frames, level);
        }


      __CPROVER_DUMP_L6:
        ;
        res = 0;
      }
      return res;
    }
}

// lglpurelit
// file lglib.c line 11122
static signed int lglpurelit(struct LGL *lgl, signed int lit)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  lgl->stats->blk.pure = lgl->stats->blk.pure + 1;
  res=lglflushclauses(lgl, lit);
  lgl->stats->blk.clauses = lgl->stats->blk.clauses + res;
  if(!(lgl->blocking == 0))
    lgl->stats->blk.steps = lgl->stats->blk.steps + (signed long int)res;

  lglepusheliminated(lgl, lit);
  return res;
}

// lglpushcontrol
// file lglib.c line 1560
static void lglpushcontrol(struct LGL *lgl, signed int decision)
{
  struct Ctk *ctk = &lgl->control;
  struct Ctr *ctr;
  signed int return_value_lglfullctk$1;
  return_value_lglfullctk$1=lglfullctk(ctk);
  if(!(return_value_lglfullctk$1 == 0))
    lglenlctk(lgl, ctk);

  struct Ctr *tmp_post$2 = ctk->top;
  ctk->top = ctk->top + 1l;
  ctr = tmp_post$2;
  ctr->decision = decision;
  ctr->used = (unsigned int)0;
}

// lglpushgocc
// file lglib.c line 12323
static void lglpushgocc(struct LGL *lgl, signed int lit, signed int gidx)
{
  signed int idx;
  signed int repr;
  struct Stk *goccs;
  repr=lglcgrepr(lgl, lit);
  signed int return_value_abs$1;
  return_value_abs$1=abs(repr);
  if(return_value_abs$1 == 1)
    repr = lit;

  idx=abs(repr);
  goccs = lgl->$anon0.cgr->goccs + (signed long int)idx;
  lglpushstk(lgl, goccs, gidx);
}

// lglpushnmarkseen
// file lglib.c line 11116
static void lglpushnmarkseen(struct LGL *lgl, signed int lit)
{
  lglpushstk(lgl, &lgl->seen, lit);
  lglmark(lgl, lit);
}

// lglpushstk
// file lglib.c line 1431
static void lglpushstk(struct LGL *lgl, struct Stk *s, signed int elem)
{
  signed int return_value_lglfullstk$1;
  return_value_lglfullstk$1=lglfullstk(s);
  if(!(return_value_lglfullstk$1 == 0))
    lglenlstk(lgl, s);

  signed int *tmp_post$2 = s->top;
  s->top = s->top + 1l;
  *tmp_post$2 = elem;
}

// lglpushwch
// file lglib.c line 3115
static signed long int lglpushwch(struct LGL *lgl, struct HTS *hts, signed int wch)
{
  signed long int res = (signed long int)0;
  signed int *wchs;
  wchs=lglhts2wchs(lgl, hts);
  if(!(wchs[(signed long int)hts->count] == 0))
  {
    res=lglenlwchs(lgl, hts);
    wchs=lglhts2wchs(lgl, hts);
  }

  signed int tmp_post$1 = hts->count;
  hts->count = hts->count + 1;
  wchs[(signed long int)tmp_post$1] = wch;
  lgl->stats->pshwchs = lgl->stats->pshwchs + 1l;
  return res;
}

// lglpushwtk
// file lglib.c line 15009
static void lglpushwtk(struct LGL *lgl, struct Wtk *wtk, enum Wrag wrag, signed int lit, signed int other, signed int red)
{
  struct Work w;
  signed int return_value_lglfullwtk$1;
  return_value_lglfullwtk$1=lglfullwtk(wtk);
  if(!(return_value_lglfullwtk$1 == 0))
    lglenlwtk(lgl, wtk);

  w.wrag = (unsigned int)wrag;
  w.other = other;
  w.red = (unsigned int)(red != 0 ? 1 : 0);
  w.removed = (unsigned int)0;
  w.lit = lit;
  struct Work *tmp_post$2 = wtk->top;
  wtk->top = wtk->top + 1l;
  *tmp_post$2 = w;
}

// lglqclone
// file lglib.c line 1906
static void lglqclone(struct LGL *lgl, struct LGL *orig)
{
  struct LGL *to = lgl;
  struct LGL *from = orig;
  struct Qln *pl;
  struct Qln *fl;
  struct Qln *tl;
  struct Qnd *fn;
  struct Qnd *tn;
  signed int idx;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)from->szvars * sizeof(struct Qnd) /*16ul*/ );
    lgl->queue.nodes = (struct Qnd *)return_value_lglnew$1;
    memcpy((void *)lgl->queue.nodes, (const void *)orig->queue.nodes, (unsigned long int)from->szvars * sizeof(struct Qnd) /*16ul*/ );
  }
  while((_Bool)0);
  struct Qln *tmp_if_expr$4;
  if(!(lgl->qscheduling == 0))
  {
    pl = ((struct Qln *)NULL);
    fl = from->queue.bottom;
    for( ; !(fl == ((struct Qln *)NULL)); fl = fl->up)
    {
      do
      {
        void *return_value_lglnew$2;
        return_value_lglnew$2=lglnew(lgl, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
        tl = (struct Qln *)return_value_lglnew$2;
      }
      while((_Bool)0);
      tl->prior = fl->prior;
      tl->first = fl->first;
      tl->last = fl->last;
      tl->unassigned = fl->unassigned;
      fl->down = tl;
      if(!(pl == ((struct Qln *)NULL)))
        pl->up = tl;

      else
        to->queue.bottom = tl;
      tl->down = pl;
      tl->repr = tl;
      pl = tl;
    }
    to->queue.top = pl;
    pl = ((struct Qln *)NULL);
    fl = from->queue.merged;
    for( ; !(fl == ((struct Qln *)NULL)); fl = fl->up)
    {
      do
      {
        void *return_value_lglnew$3;
        return_value_lglnew$3=lglnew(lgl, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
        tl = (struct Qln *)return_value_lglnew$3;
      }
      while((_Bool)0);
      fl->down = tl;
      if(!(pl == ((struct Qln *)NULL)))
        pl->up = tl;

      else
        to->queue.merged = tl;
      pl = tl;
    }
    fl = from->queue.merged;
    for( ; !(fl == ((struct Qln *)NULL)); fl = fl->up)
    {
      tl = fl->down;
      while(fl->repr == ((struct Qln *)NULL))
      {
        fprintf(stderr, "liblgl.a: %s:%d: %s: Coverage target `%s' reached.", (const void *)"lglqclone", 1951, (const void *)"lglib.c", (const void *)"!fl->repr");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputc(10, stderr);
        fflush(stderr);
        abort();
        break;
      }
      while(tl == ((struct Qln *)NULL))
      {
        fprintf(stderr, "liblgl.a: %s:%d: %s: Coverage target `%s' reached.", (const void *)"lglqclone", 1958, (const void *)"lglib.c", (const void *)"!tl");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputc(10, stderr);
        fflush(stderr);
        abort();
        break;
      }
      if(!(fl->repr == ((struct Qln *)NULL)))
        tmp_if_expr$4 = fl->repr->down;

      else
        tmp_if_expr$4 = ((struct Qln *)NULL);
      tl->repr = tmp_if_expr$4;
    }
    idx = 2;
    for( ; !(idx >= from->nvars); idx = idx + 1)
    {
      fn=lglqnd(from, idx);
      tn=lglqnd(to, idx);
      tn->line = fn->line->down;
    }
    pl = ((struct Qln *)NULL);
    fl = from->queue.bottom;
    for( ; !(fl == ((struct Qln *)NULL)); fl = fl->up)
    {
      if(fl == from->queue.unassigned)
        to->queue.unassigned = fl->down;

      fl->down = pl;
      pl = fl;
    }
    fl = from->queue.merged;
    for( ; !(fl == ((struct Qln *)NULL)); fl = fl->up)
      fl->down = ((struct Qln *)NULL);
    to->queue.nmerged = from->queue.nmerged;
    to->queue.nlines = from->queue.nlines;
    fl = from->queue.free;
    for( ; !(fl == ((struct Qln *)NULL)); fl = fl->up)
    {
      do
      {
        void *return_value_lglnew$5;
        return_value_lglnew$5=lglnew(lgl, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
        tl = (struct Qln *)return_value_lglnew$5;
      }
      while((_Bool)0);
      tl->up = to->queue.free;
      to->queue.free = tl;
    }
  }

}

// lglqcmp
// file lglib.c line 2753
static signed int lglqcmp(struct LGL *lgl, signed int l, signed int k)
{
  struct Qln *ln;
  ln=lglqln(lgl, l);
  struct Qln *kn;
  kn=lglqln(lgl, k);
  return ln->prior - kn->prior;
}

// lglqdump
// file lglib.c line 2421
static void lglqdump(struct LGL *lgl)
{
  struct Qln *p;
  struct Qnd *n;
  signed int i;
  p = lgl->queue.top;
  for( ; !(p == ((struct Qln *)NULL)); p = p->down)
  {
    printf("c queue[%d]", p->prior);
    i = p->first;
    for( ; !(i == 0); i = n->next)
    {
      n=lglqnd(lgl, i);
      printf(" %d", i);
    }
    printf("\n");
  }
}

// lglqln
// file lglib.c line 2741
static struct Qln * lglqln(struct LGL *lgl, signed int lit)
{
  struct Qln *res;
  struct Qln *line;
  struct Qln *lglqln$$1$$next;
  struct Qnd *node;
  node=lglqnd(lgl, lit);
  res = node->line;
  do
  {
    line = res->repr;
    if(line == res)
      break;

    res = line;
  }
  while((_Bool)1);
  line = node->line;
  for( ; !(line == res); line = lglqln$$1$$next)
  {
    lglqln$$1$$next = line->repr;
    line->repr = res;
  }
  node->line = res;
  return res;
}

// lglqnd
// file lglib.c line 1900
static struct Qnd * lglqnd(struct LGL *lgl, signed int lit)
{
  signed int idx;
  idx=abs(lit);
  return lgl->queue.nodes + (signed long int)idx;
}

// lglqsched
// file lglib.c line 2372
static void lglqsched(struct LGL *lgl, signed int idx)
{
  struct Qnd *n;
  n=lglqnd(lgl, idx);
  struct Qnd *m;
  struct Qln *l;
  if(!(lgl->qscheduling == 0))
  {
    l = lgl->queue.bottom;
    if(l == ((struct Qln *)NULL))
    {
      l = lgl->queue.free;
      if(!(l == ((struct Qln *)NULL)))
      {
        lgl->queue.free = l->up;
        do
          memset((void *)l, 0, sizeof(struct Qln) /*40ul*/ );
        while((_Bool)0);
      }

      else
        do
        {
          void *return_value_lglnew$1;
          return_value_lglnew$1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
          l = (struct Qln *)return_value_lglnew$1;
        }
        while((_Bool)0);
      l->repr = l;
      lgl->queue.unassigned = l->repr;
      lgl->queue.top = lgl->queue.unassigned;
      lgl->queue.bottom = lgl->queue.top;
      lgl->queue.nlines = lgl->queue.nlines + 1;
      lgl->stats->queue.new = lgl->stats->queue.new + 1l;
    }

    else
      if(!(l->prior == 0))
      {
        l = lgl->queue.free;
        if(!(l == ((struct Qln *)NULL)))
        {
          lgl->queue.free = l->up;
          do
            memset((void *)l, 0, sizeof(struct Qln) /*40ul*/ );
          while((_Bool)0);
        }

        else
          do
          {
            void *return_value_lglnew$2;
            return_value_lglnew$2=lglnew(lgl, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
            l = (struct Qln *)return_value_lglnew$2;
          }
          while((_Bool)0);
        lgl->queue.bottom->down = l;
        l->up = lgl->queue.bottom;
        lgl->queue.bottom = l;
        l->repr = l;
        lgl->queue.nlines = lgl->queue.nlines + 1;
        lgl->stats->queue.new = lgl->stats->queue.new + 1l;
      }


  __CPROVER_DUMP_L5:
    ;

  __CPROVER_DUMP_L10:
    ;
    if(!(lgl->bias >= 0))
    {
      n->prev = l->last;
      if(!(n->prev == 0))
      {
        m=lglqnd(lgl, l->last);
        m->next = idx;
      }

      else
      {
        l->unassigned = idx;
        l->first = l->unassigned;
      }
      l->last = idx;
    }

    else
    {
      n->next = l->first;
      if(!(n->next == 0))
      {
        m=lglqnd(lgl, l->first);
        m->prev = idx;
      }

      else
        l->last = idx;
      l->unassigned = idx;
      l->first = l->unassigned;
    }
    n->line = l;
    if(lgl->opts->check.val >= 3)
      lglchkqueue(lgl);

  }

}

// lglqschedall
// file lglib.c line 17259
static void lglqschedall(struct LGL *lgl)
{
  signed int idx;
  lgl->qscheduling = (char)1;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
    lglqsched(lgl, idx);
  lglprt(lgl, 1, "[queue-schedule-all-variables]");
}

// lglrand
// file lglib.c line 1529
static unsigned int lglrand(struct LGL *lgl)
{
  unsigned int res;
  lgl->rng.z = (unsigned int)36969 * (lgl->rng.z & (unsigned int)65535) + (lgl->rng.z >> 16);
  lgl->rng.w = (unsigned int)18000 * (lgl->rng.w & (unsigned int)65535) + (lgl->rng.w >> 16);
  res = (lgl->rng.z << 16) + lgl->rng.w;

__CPROVER_DUMP_L1:
  ;
  return res;
}

// lglrandec
// file lglib.c line 7686
static signed int lglrandec(struct LGL *lgl)
{
  unsigned int size;
  unsigned int pos;
  unsigned int lglrandec$$1$$start;
  unsigned int delta;
  signed int lit;
  lgl->limits->randec = lgl->stats->decisions;
  lgl->limits->randec = lgl->limits->randec + (signed long int)(lgl->opts->randecint.val / 2);
  unsigned int return_value_lglrand$1;
  return_value_lglrand$1=lglrand(lgl);
  lgl->limits->randec = lgl->limits->randec + (signed long int)(return_value_lglrand$1 % (unsigned int)lgl->opts->randecint.val);
  size = (unsigned int)(lgl->nvars - 2);
  unsigned int return_value_lglgcd$4;
  signed char return_value_lglval$5;
  if(size == 0u)
    return 0;

  else
  {
    unsigned int return_value_lglrand$2;
    return_value_lglrand$2=lglrand(lgl);
    lglrandec$$1$$start = return_value_lglrand$2 % size;
    pos = lglrandec$$1$$start;
    lit = (signed int)((unsigned int)2 + pos);
    signed char return_value_lglval$6;
    return_value_lglval$6=lglval(lgl, lit);
    if(!(return_value_lglval$6 == 0))
    {
      unsigned int return_value_lglrand$3;
      return_value_lglrand$3=lglrand(lgl);
      delta = return_value_lglrand$3 % size;
      if(size == 1u)
        return 0;

      if(delta == 0u)
        delta = delta + 1u;

      do
      {
        return_value_lglgcd$4=lglgcd(delta, size);
        if(return_value_lglgcd$4 == 1u)
          break;

        delta = delta + 1u;
        if(delta == size)
          delta = (unsigned int)1;

      }
      while((_Bool)1);
      do
      {
        pos = pos + delta;
        if(pos >= size)
          pos = pos - size;

        if(pos == lglrandec$$1$$start)
          return 0;

        lit = (signed int)(pos + (unsigned int)2);
        return_value_lglval$5=lglval(lgl, lit);
      }
      while(!(return_value_lglval$5 == 0));
    }

    lgl->stats->randecs = lgl->stats->randecs + 1l;
    return lit;
  }
}

// lglrandidxtrav
// file lglib.c line 3327
static signed int lglrandidxtrav(struct LGL *lgl, signed int (*fun)(struct LGL *, signed int))
{
  signed int idx;
  signed int delta;
  signed int mod;
  signed int prev;
  signed int first;
  signed int res;
  mod=lglmax(lgl->nvars, 2);
  first = mod;
  unsigned int return_value_lglrand$1;
  return_value_lglrand$1=lglrand(lgl);
  idx = (signed int)(return_value_lglrand$1 % (unsigned int)mod);
  unsigned int return_value_lglrand$2;
  return_value_lglrand$2=lglrand(lgl);
  delta = (signed int)(return_value_lglrand$2 % (unsigned int)mod);
  if(delta == 0)
    delta = delta + 1;

  unsigned int return_value_lglgcd$3;
  do
  {
    return_value_lglgcd$3=lglgcd((unsigned int)delta, (unsigned int)mod);
    if(!(return_value_lglgcd$3 >= 2u))
      break;

    delta = delta + 1;
    if(delta == mod)
      delta = 1;

  }
  while((_Bool)1);
  res = 1;
  _Bool tmp_if_expr$4;
  signed int return_value;
  while(!(res == 0))
  {
    if(idx >= 2)
    {
      return_value=fun(lgl, idx);
      tmp_if_expr$4 = !(return_value != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      res = 0;

    else
    {
      prev = idx;
      idx = idx + delta;
      if(idx >= mod)
        idx = idx - mod;

      if(idx == first)
        break;

      if(first == mod)
        first = prev;

    }
  }
  return res;
}

// lglrandlitrav
// file lglib.c line 8594
static signed int lglrandlitrav(struct LGL *lgl, signed int (*fun)(struct LGL *, signed int))
{
  signed int delta;
  signed int mod;
  signed int prev;
  signed int first;
  signed int ulit;
  signed int count;
  unsigned int return_value_lglgcd$3;
  signed int return_value_lglilit$4;
  signed int return_value;
  if(!(lgl->nvars >= 2))
    return 0;

  else
  {
    mod = 2 * lgl->nvars;
    first = mod;
    unsigned int return_value_lglrand$1;
    return_value_lglrand$1=lglrand(lgl);
    ulit = (signed int)(return_value_lglrand$1 % (unsigned int)mod);
    unsigned int return_value_lglrand$2;
    return_value_lglrand$2=lglrand(lgl);
    delta = (signed int)(return_value_lglrand$2 % (unsigned int)mod);
    if(delta == 0)
      delta = delta + 1;

    do
    {
      return_value_lglgcd$3=lglgcd((unsigned int)delta, (unsigned int)mod);
      if(!(return_value_lglgcd$3 >= 2u))
        break;

      delta = delta + 1;
      if(delta == mod)
        delta = 1;

    }
    while((_Bool)1);
    count = mod;
    do
    {
      count = count - 1;
      if(ulit >= 4)
      {
        return_value_lglilit$4=lglilit(ulit);
        return_value=fun(lgl, return_value_lglilit$4);
        if(return_value == 0)
          return 0;

      }

      prev = ulit;
      ulit = ulit + delta;
      if(ulit >= mod)
        ulit = ulit - mod;

      if(ulit == first)
        break;

      if(first == mod)
        first = prev;

    }
    while((_Bool)1);
    return 1;
  }
}

// lglrandomprobe
// file lglib.c line 13848
static signed int lglrandomprobe(struct LGL *lgl, struct Stk *outer)
{
  unsigned int pos;
  unsigned int mod;
  signed int res;
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(outer);
  mod = (unsigned int)return_value_lglcntstk$1;
  if(mod == 0u)
    return 0;

  else
  {
    unsigned int return_value_lglrand$2;
    return_value_lglrand$2=lglrand(lgl);
    pos = return_value_lglrand$2 % mod;
    res=lglpeek(outer, (signed int)pos);
    signed char return_value_lglval$3;
    return_value_lglval$3=lglval(lgl, res);
    if(!(return_value_lglval$3 == 0))
      return 0;

    else
      return res;
  }
}

// lglreadopts
// file lglib.c line 2203
signed int lglreadopts(struct LGL *lgl, struct _IO_FILE *file)
{
  signed int res;
  signed int ch;
  signed int val;
  signed int nvalbuf;
  signed int noptbuf;
  char optbuf[40l];
  char valbuf[40l];
  const char *opt;
  res = 0;
  signed int tmp_post$2;
  signed int return_value_lglws$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int return_value_lglws$6;
  signed int tmp_post$7;
  signed int return_value_lglws$8;
  signed int tmp_post$9;
  signed int tmp_post$10;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    ch=_IO_getc(file);
    signed int return_value_lglws$1;
    return_value_lglws$1=lglws(ch);
    if(!(return_value_lglws$1 == 0))
      goto __CPROVER_DUMP_L1;

    if(ch == -1)
      break;

    noptbuf = 0;
    tmp_post$2 = noptbuf;
    noptbuf = noptbuf + 1;
    optbuf[(signed long int)tmp_post$2] = (char)ch;
    do
    {
      ch=_IO_getc(file);
      if(ch == -1)
        break;

      return_value_lglws$3=lglws(ch);
      if(!(return_value_lglws$3 == 0))
        break;

      if((unsigned long int)(1 + noptbuf) >= sizeof(char [40l]) /*40ul*/ )
      {
        ch = -1;
        break;
      }

      tmp_post$4 = noptbuf;
      noptbuf = noptbuf + 1;
      optbuf[(signed long int)tmp_post$4] = (char)ch;
    }
    while((_Bool)1);
    if(ch == -1)
      break;

    tmp_post$5 = noptbuf;
    noptbuf = noptbuf + 1;
    optbuf[(signed long int)tmp_post$5] = (char)0;
    do
    {
      ch=_IO_getc(file);
      return_value_lglws$6=lglws(ch);
      if(return_value_lglws$6 == 0)
        break;

    }
    while((_Bool)1);
    if(ch == -1)
      break;

    nvalbuf = 0;
    tmp_post$7 = nvalbuf;
    nvalbuf = nvalbuf + 1;
    valbuf[(signed long int)tmp_post$7] = (char)ch;
    do
    {
      ch=_IO_getc(file);
      if(ch == -1)
        break;

      return_value_lglws$8=lglws(ch);
      if(!(return_value_lglws$8 == 0))
        break;

      if((unsigned long int)(1 + nvalbuf) >= sizeof(char [40l]) /*40ul*/ )
      {
        ch = -1;
        break;
      }

      tmp_post$9 = nvalbuf;
      nvalbuf = nvalbuf + 1;
      valbuf[(signed long int)tmp_post$9] = (char)ch;
    }
    while((_Bool)1);
    tmp_post$10 = nvalbuf;
    nvalbuf = nvalbuf + 1;
    valbuf[(signed long int)tmp_post$10] = (char)0;
    opt = optbuf;
    val=atoi$link1(valbuf);
    lglprt(lgl, 1, "read option --%s=%d", opt, val);
    lglsetopt(lgl, opt, val);
    res = res + 1;
  }
  while((_Bool)1);
  return res;
}

// lglredstk
// file lglib.c line 1456
static void lglredstk(struct LGL *lgl, struct Stk *s, signed int minsize, signed int pow2smaller)
{
  unsigned long int oldsize;
  unsigned long int count;
  unsigned long int limit;
  unsigned long int newsize;
  oldsize=lglszstk(s);
  if(!((unsigned long int)minsize >= oldsize))
  {
    count=lglcntstk(s);
    limit = oldsize >> pow2smaller;
    if(limit >= count)
    {
      newsize = oldsize / (unsigned long int)2;
      if(newsize >= 1ul)
      {
        do
        {
          void *return_value_lglrsz$1;
          return_value_lglrsz$1=lglrsz(lgl, (void *)s->start, oldsize * sizeof(signed int) /*4ul*/ , newsize * sizeof(signed int) /*4ul*/ );
          s->start = (signed int *)return_value_lglrsz$1;
        }
        while((_Bool)0);
        s->top = s->start + (signed long int)count;
        s->end = s->start + (signed long int)newsize;
      }

      else
        lglrelstk(lgl, s);
    }

  }

}

// lglreduce
// file lglib.c line 5281
static void lglreduce(struct LGL *lgl, signed int forced)
{
  signed int *p;
  signed int *q;
  signed int *lglreduce$$1$$start;
  signed int *c;
  signed int **maps;
  signed int *sizes;
  signed int *map;
  signed int *eow;
  signed int *rsn;
  signed int nlocked;
  signed int collected;
  signed int sumcollected;
  signed int nunlocked;
  signed int moved;
  signed int act;
  signed int glue;
  signed int minredglue;
  signed int maxredglue;
  signed int target;
  signed int rem;
  signed int nkeep;
  signed int inc;
  signed int acts;
  signed int glueuseless;
  signed int needmoreclauses;
  signed int delta;
  struct ASL *asls;
  struct ASL *asl;
  signed int nasls;
  signed int szasls;
  signed int size;
  signed int idx;
  signed int tag;
  signed int red;
  signed int i;
  signed int blit;
  signed int r0;
  signed int lidx;
  signed int src;
  signed int dst;
  signed int lit;
  char type = (char)45;
  signed long int outer;
  struct HTS *hts;
  struct DVar *dv;
  struct Stk *lir;
  lglchkred(lgl);
  lglstart(lgl, &lgl->times->red);
  lgl->stats->reduced.count = lgl->stats->reduced.count + 1;

__CPROVER_DUMP_L1:
  ;
  acts=lglneedacts(lgl, &glueuseless, &needmoreclauses);
  delta = lgl->stats->red.lrg;
  delta = delta - lgl->lrgluereasons;
  if(!((3 * lgl->limits->reduce.inner) / 2 >= delta))
    target = delta - lgl->limits->reduce.inner / 2;

  else
    target = delta / 2;
  rem = target;

__CPROVER_DUMP_L4:
  ;
  maxredglue = ((1 << 4) - 1) - 1;
  for( ; maxredglue >= 0; maxredglue = maxredglue - 1)
    if(lgl->stats->lir[(signed long int)maxredglue].clauses >= 1)
      break;


__CPROVER_DUMP_L6:
  ;
  if(!(lgl->opts->acts.val >= 2))
    acts = lgl->opts->acts.val;

  if(!(acts == 0))
  {
    lgl->stats->acts = lgl->stats->acts + 1;
    lglprt(lgl, 2, "[needacts-%d] using primarily activities for reduction", lgl->stats->reduced);
    szasls = lgl->stats->red.lrg;
    minredglue = 1;
  }

  else
  {
    lglprt(lgl, 2, "[needacts-%d] using primarily glues for reduction", lgl->stats->reduced);
    asls = ((struct ASL *)NULL);
    if(maxredglue >= 1)
    {
      minredglue = maxredglue;
      for( ; minredglue >= 2; minredglue = minredglue - 1)
      {

      __CPROVER_DUMP_L10:
        ;
        if(lgl->stats->lir[(signed long int)minredglue].clauses >= rem)
          break;

        rem = rem - lgl->stats->lir[(signed long int)minredglue].clauses;
      }
    }

    else
      minredglue = 1;
    szasls = lgl->stats->lir[(signed long int)minredglue].clauses;
  }

__CPROVER_DUMP_L14:
  ;
  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)(maxredglue + 1) * sizeof(signed int *) /*8ul*/ );
    maps = (signed int **)return_value_lglnew$1;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglnew$2;
    return_value_lglnew$2=lglnew(lgl, (unsigned long int)(maxredglue + 1) * sizeof(signed int) /*4ul*/ );
    sizes = (signed int *)return_value_lglnew$2;
  }
  while((_Bool)0);
  glue = minredglue;
  for( ; maxredglue >= glue; glue = glue + 1)
  {
    lir = lgl->red + (signed long int)glue;
    unsigned long int return_value_lglcntstk$3;
    return_value_lglcntstk$3=lglcntstk(lir);
    size = (signed int)return_value_lglcntstk$3;
    size = (size + 5) / 6;
    sizes[(signed long int)glue] = size;
    lglfitstk(lgl, lir);
    do
    {
      void *return_value_lglnew$4;
      return_value_lglnew$4=lglnew(lgl, (unsigned long int)size * sizeof(signed int) /*4ul*/ );
      maps[(signed long int)glue] = (signed int *)return_value_lglnew$4;
    }
    while((_Bool)0);
    map = maps[(signed long int)glue];
    i = 0;
    for( ; !(i >= size); i = i + 1)
      map[(signed long int)i] = -2;
  }
  nlocked = 0;
  i = 0;
  unsigned long int return_value_lglcntstk$5;
  do
  {
    return_value_lglcntstk$5=lglcntstk(&lgl->trail);
    if((unsigned long int)i >= return_value_lglcntstk$5)
      break;

    lit=lglpeek(&lgl->trail, i);
    idx=abs(lit);
    rsn=lglrsn(lgl, idx);
    r0 = rsn[(signed long int)0];
    red = r0 & REDCS;
    if(!(red == 0))
    {
      tag = r0 & MASKCS;
      if(tag == LRGCS)
      {
        lidx = rsn[(signed long int)1];
        glue = lidx & (1 << 4) - 1;
        if(!(glue == 15))
        {
          if(glue >= minredglue)
          {
            if(maxredglue >= glue)
            {
              lidx = lidx >> 4;
              lidx = lidx / 6;
              maps[(signed long int)glue][(signed long int)lidx] = -1;
              nlocked = nlocked + 1;
            }

          }

        }

      }

    }

    i = i + 1;
  }
  while((_Bool)1);

__CPROVER_DUMP_L25:
  ;
  do
  {
    void *return_value_lglnew$6;
    return_value_lglnew$6=lglnew(lgl, (unsigned long int)szasls * sizeof(struct ASL) /*12ul*/ );
    asls = (struct ASL *)return_value_lglnew$6;
  }
  while((_Bool)0);
  nasls = 0;
  glue = minredglue;
  _Bool tmp_if_expr$7;
  signed int tmp_post$8;
  for( ; maxredglue >= glue; glue = glue + 1)
  {
    lir = lgl->red + (signed long int)glue;
    lglreduce$$1$$start = lir->start;
    c = lglreduce$$1$$start;
    for( ; !(c >= lir->top); c = p + (signed long int)1)
    {
      act = *c;
      if(act == 0x7fffffff)
      {
        p = c + (signed long int)1;
        do
        {
          if(!(p >= lir->top))
            tmp_if_expr$7 = *p == 0x7fffffff ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$7 = (_Bool)0;
          if(!tmp_if_expr$7)
            break;

          p = p + 1l;
        }
        while((_Bool)1);
        p = p - 1l;
      }

      else
      {
        c = c + 1l;
        p = c;
        for( ; !(*p == 0); p = p + 1l)
          ;
        tmp_post$8 = nasls;
        nasls = nasls + 1;
        asl = asls + (signed long int)tmp_post$8;
        asl->act = act;
        asl->size = (signed int)(p - c);
        asl->lidx = (signed int)(c - lglreduce$$1$$start << 4 | (signed long int)glue);
      }
    }
    if(acts == 0)
      break;

  }
  signed int return_value_lglcmpasgl$13;
  signed int return_value_lglmtstk$14;
  signed int return_value_lglcmpasgl$16;
  signed int return_value_lglcmpagsl$21;
  signed int return_value_lglmtstk$22;
  signed int return_value_lglcmpagsl$24;
  if(!(glueuseless == 0))
    do
    {
      struct ASL *lglreduce$$1$$15$$AA = asls;
      signed int lglreduce$$1$$15$$NN = nasls;
      do
      {
        signed int lglreduce$$1$$15$$1$$L = 0;
        signed int lglreduce$$1$$15$$1$$R = lglreduce$$1$$15$$NN - 1;
        signed int lglreduce$$1$$15$$1$$M;
        signed int LL;
        signed int RR;
        signed int I;
        if(!(lglreduce$$1$$15$$1$$R + -lglreduce$$1$$15$$1$$L >= 11))
          break;

        do
        {
          lglreduce$$1$$15$$1$$M = (lglreduce$$1$$15$$1$$L + lglreduce$$1$$15$$1$$R) / 2;
          do
          {
            struct ASL TMP = lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$1$$M];
            lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$1$$M] = lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$1$$R - 1)];
            lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$1$$R - 1)] = TMP;
          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpasgl$9;
            return_value_lglcmpasgl$9=lglcmpasgl(&lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$1$$L], &lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$1$$R - 1)]);
            if(return_value_lglcmpasgl$9 >= 1)
              do
              {
                struct ASL lglreduce$$1$$15$$1$$1$$1$$2$$1$$TMP = lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$1$$L];
                lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$1$$L] = lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$1$$R - 1)];
                lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$1$$R - 1)] = lglreduce$$1$$15$$1$$1$$1$$2$$1$$TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpasgl$10;
            return_value_lglcmpasgl$10=lglcmpasgl(&lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$1$$L], &lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$1$$R]);
            if(return_value_lglcmpasgl$10 >= 1)
              do
              {
                struct ASL lglreduce$$1$$15$$1$$1$$1$$3$$1$$TMP = lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$1$$L];
                lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$1$$L] = lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$1$$R];
                lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$1$$R] = lglreduce$$1$$15$$1$$1$$1$$3$$1$$TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpasgl$11;
            return_value_lglcmpasgl$11=lglcmpasgl(&lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$1$$R - 1)], &lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$1$$R]);
            if(return_value_lglcmpasgl$11 >= 1)
              do
              {
                struct ASL lglreduce$$1$$15$$1$$1$$1$$4$$1$$TMP = lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$1$$R - 1)];
                lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$1$$R - 1)] = lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$1$$R];
                lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$1$$R] = lglreduce$$1$$15$$1$$1$$1$$4$$1$$TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            struct ASL PIVOT;
            signed int J = lglreduce$$1$$15$$1$$R - 1;
            I = (lglreduce$$1$$15$$1$$L + 1) - 1;
            PIVOT = lglreduce$$1$$15$$AA[(signed long int)J];
            do
            {

            __CPROVER_DUMP_L54:
              ;
              I = I + 1;
              signed int return_value_lglcmpasgl$12;
              return_value_lglcmpasgl$12=lglcmpasgl(&lglreduce$$1$$15$$AA[(signed long int)I], &PIVOT);
              if(!(return_value_lglcmpasgl$12 >= 0))
                goto __CPROVER_DUMP_L54;

              do
              {
                J = J - 1;
                return_value_lglcmpasgl$13=lglcmpasgl(&PIVOT, &lglreduce$$1$$15$$AA[(signed long int)J]);
                if(return_value_lglcmpasgl$13 >= 0)
                  break;

                if(J == 1 + lglreduce$$1$$15$$1$$L)
                  break;

              }
              while((_Bool)1);
              if(I >= J)
                break;

              do
              {
                struct ASL lglreduce$$1$$15$$1$$1$$1$$5$$1$$1$$1$$TMP = lglreduce$$1$$15$$AA[(signed long int)I];
                lglreduce$$1$$15$$AA[(signed long int)I] = lglreduce$$1$$15$$AA[(signed long int)J];
                lglreduce$$1$$15$$AA[(signed long int)J] = lglreduce$$1$$15$$1$$1$$1$$5$$1$$1$$1$$TMP;
              }
              while((_Bool)0);
            }
            while((_Bool)1);
            do
            {
              struct ASL lglreduce$$1$$15$$1$$1$$1$$5$$2$$TMP = lglreduce$$1$$15$$AA[(signed long int)I];
              lglreduce$$1$$15$$AA[(signed long int)I] = lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$1$$R - 1)];
              lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$1$$R - 1)] = lglreduce$$1$$15$$1$$1$$1$$5$$2$$TMP;
            }
            while((_Bool)0);
          }
          while((_Bool)0);
          if(!(I + -lglreduce$$1$$15$$1$$L >= lglreduce$$1$$15$$1$$R + -I))
          {
            LL = I + 1;
            RR = lglreduce$$1$$15$$1$$R;
            lglreduce$$1$$15$$1$$R = I - 1;
          }

          else
          {
            LL = lglreduce$$1$$15$$1$$L;
            RR = I - 1;
            lglreduce$$1$$15$$1$$L = I + 1;
          }
          if(lglreduce$$1$$15$$1$$R + -lglreduce$$1$$15$$1$$L >= 11)
          {
            lglpushstk(lgl, &lgl->$anon1.sortstk, LL);
            lglpushstk(lgl, &lgl->$anon1.sortstk, RR);
          }

          else
            if(RR + -LL >= 11)
            {
              lglreduce$$1$$15$$1$$L = LL;
              lglreduce$$1$$15$$1$$R = RR;
            }

            else
            {
              return_value_lglmtstk$14=lglmtstk(&lgl->$anon1.sortstk);
              if(return_value_lglmtstk$14 == 0)
              {
                lglreduce$$1$$15$$1$$R=lglpopstk(&lgl->$anon1.sortstk);
                lglreduce$$1$$15$$1$$L=lglpopstk(&lgl->$anon1.sortstk);
              }

              else
                break;
            }
        }
        while((_Bool)1);
      }
      while((_Bool)0);
      do
      {
        struct ASL lglreduce$$1$$15$$2$$PIVOT;
        signed int L = 0;
        signed int R = lglreduce$$1$$15$$NN - 1;
        signed int lglreduce$$1$$15$$2$$I;
        signed int lglreduce$$1$$15$$2$$J;
        lglreduce$$1$$15$$2$$I = R;
        for( ; !(L >= lglreduce$$1$$15$$2$$I); lglreduce$$1$$15$$2$$I = lglreduce$$1$$15$$2$$I - 1)
          do
          {
            signed int return_value_lglcmpasgl$15;
            return_value_lglcmpasgl$15=lglcmpasgl(&lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$2$$I - 1)], &lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$2$$I]);
            if(return_value_lglcmpasgl$15 >= 1)
              do
              {
                struct ASL lglreduce$$1$$15$$2$$1$$1$$1$$TMP = lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$2$$I - 1)];
                lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$2$$I - 1)] = lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$2$$I];
                lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$2$$I] = lglreduce$$1$$15$$2$$1$$1$$1$$TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
        lglreduce$$1$$15$$2$$I = L + 2;
        for( ; R >= lglreduce$$1$$15$$2$$I; lglreduce$$1$$15$$2$$I = lglreduce$$1$$15$$2$$I + 1)
        {
          lglreduce$$1$$15$$2$$J = lglreduce$$1$$15$$2$$I;
          lglreduce$$1$$15$$2$$PIVOT = lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$2$$I];
          do
          {
            return_value_lglcmpasgl$16=lglcmpasgl(&lglreduce$$1$$15$$2$$PIVOT, &lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$2$$J - 1)]);
            if(return_value_lglcmpasgl$16 >= 0)
              break;

            lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$2$$J] = lglreduce$$1$$15$$AA[(signed long int)(lglreduce$$1$$15$$2$$J - 1)];
            lglreduce$$1$$15$$2$$J = lglreduce$$1$$15$$2$$J - 1;
          }
          while((_Bool)1);
          lglreduce$$1$$15$$AA[(signed long int)lglreduce$$1$$15$$2$$J] = lglreduce$$1$$15$$2$$PIVOT;
        }
      }
      while((_Bool)0);

    __CPROVER_DUMP_L76:
      ;
    }
    while((_Bool)0);

  else
    do
    {
      struct ASL *AA = asls;
      signed int NN = nasls;
      do
      {
        signed int lglreduce$$1$$16$$1$$L = 0;
        signed int lglreduce$$1$$16$$1$$R = NN - 1;
        signed int M;
        signed int lglreduce$$1$$16$$1$$LL;
        signed int lglreduce$$1$$16$$1$$RR;
        signed int lglreduce$$1$$16$$1$$I;
        if(!(lglreduce$$1$$16$$1$$R + -lglreduce$$1$$16$$1$$L >= 11))
          break;

        do
        {
          M = (lglreduce$$1$$16$$1$$L + lglreduce$$1$$16$$1$$R) / 2;
          do
          {
            struct ASL lglreduce$$1$$16$$1$$1$$1$$1$$TMP = AA[(signed long int)M];
            AA[(signed long int)M] = AA[(signed long int)(lglreduce$$1$$16$$1$$R - 1)];
            AA[(signed long int)(lglreduce$$1$$16$$1$$R - 1)] = lglreduce$$1$$16$$1$$1$$1$$1$$TMP;
          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpagsl$17;
            return_value_lglcmpagsl$17=lglcmpagsl(&AA[(signed long int)lglreduce$$1$$16$$1$$L], &AA[(signed long int)(lglreduce$$1$$16$$1$$R - 1)]);
            if(return_value_lglcmpagsl$17 >= 1)
              do
              {
                struct ASL lglreduce$$1$$16$$1$$1$$1$$2$$1$$TMP = AA[(signed long int)lglreduce$$1$$16$$1$$L];
                AA[(signed long int)lglreduce$$1$$16$$1$$L] = AA[(signed long int)(lglreduce$$1$$16$$1$$R - 1)];
                AA[(signed long int)(lglreduce$$1$$16$$1$$R - 1)] = lglreduce$$1$$16$$1$$1$$1$$2$$1$$TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpagsl$18;
            return_value_lglcmpagsl$18=lglcmpagsl(&AA[(signed long int)lglreduce$$1$$16$$1$$L], &AA[(signed long int)lglreduce$$1$$16$$1$$R]);
            if(return_value_lglcmpagsl$18 >= 1)
              do
              {
                struct ASL lglreduce$$1$$16$$1$$1$$1$$3$$1$$TMP = AA[(signed long int)lglreduce$$1$$16$$1$$L];
                AA[(signed long int)lglreduce$$1$$16$$1$$L] = AA[(signed long int)lglreduce$$1$$16$$1$$R];
                AA[(signed long int)lglreduce$$1$$16$$1$$R] = lglreduce$$1$$16$$1$$1$$1$$3$$1$$TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            signed int return_value_lglcmpagsl$19;
            return_value_lglcmpagsl$19=lglcmpagsl(&AA[(signed long int)(lglreduce$$1$$16$$1$$R - 1)], &AA[(signed long int)lglreduce$$1$$16$$1$$R]);
            if(return_value_lglcmpagsl$19 >= 1)
              do
              {
                struct ASL lglreduce$$1$$16$$1$$1$$1$$4$$1$$TMP = AA[(signed long int)(lglreduce$$1$$16$$1$$R - 1)];
                AA[(signed long int)(lglreduce$$1$$16$$1$$R - 1)] = AA[(signed long int)lglreduce$$1$$16$$1$$R];
                AA[(signed long int)lglreduce$$1$$16$$1$$R] = lglreduce$$1$$16$$1$$1$$1$$4$$1$$TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
          do
          {
            struct ASL lglreduce$$1$$16$$1$$1$$1$$5$$PIVOT;
            signed int lglreduce$$1$$16$$1$$1$$1$$5$$J = lglreduce$$1$$16$$1$$R - 1;
            lglreduce$$1$$16$$1$$I = (lglreduce$$1$$16$$1$$L + 1) - 1;
            lglreduce$$1$$16$$1$$1$$1$$5$$PIVOT = AA[(signed long int)lglreduce$$1$$16$$1$$1$$1$$5$$J];
            do
            {

            __CPROVER_DUMP_L91:
              ;
              lglreduce$$1$$16$$1$$I = lglreduce$$1$$16$$1$$I + 1;
              signed int return_value_lglcmpagsl$20;
              return_value_lglcmpagsl$20=lglcmpagsl(&AA[(signed long int)lglreduce$$1$$16$$1$$I], &lglreduce$$1$$16$$1$$1$$1$$5$$PIVOT);
              if(!(return_value_lglcmpagsl$20 >= 0))
                goto __CPROVER_DUMP_L91;

              do
              {
                lglreduce$$1$$16$$1$$1$$1$$5$$J = lglreduce$$1$$16$$1$$1$$1$$5$$J - 1;
                return_value_lglcmpagsl$21=lglcmpagsl(&lglreduce$$1$$16$$1$$1$$1$$5$$PIVOT, &AA[(signed long int)lglreduce$$1$$16$$1$$1$$1$$5$$J]);
                if(return_value_lglcmpagsl$21 >= 0)
                  break;

                if(lglreduce$$1$$16$$1$$1$$1$$5$$J == 1 + lglreduce$$1$$16$$1$$L)
                  break;

              }
              while((_Bool)1);
              if(lglreduce$$1$$16$$1$$I >= lglreduce$$1$$16$$1$$1$$1$$5$$J)
                break;

              do
              {
                struct ASL lglreduce$$1$$16$$1$$1$$1$$5$$1$$1$$1$$TMP = AA[(signed long int)lglreduce$$1$$16$$1$$I];
                AA[(signed long int)lglreduce$$1$$16$$1$$I] = AA[(signed long int)lglreduce$$1$$16$$1$$1$$1$$5$$J];
                AA[(signed long int)lglreduce$$1$$16$$1$$1$$1$$5$$J] = lglreduce$$1$$16$$1$$1$$1$$5$$1$$1$$1$$TMP;
              }
              while((_Bool)0);
            }
            while((_Bool)1);
            do
            {
              struct ASL lglreduce$$1$$16$$1$$1$$1$$5$$2$$TMP = AA[(signed long int)lglreduce$$1$$16$$1$$I];
              AA[(signed long int)lglreduce$$1$$16$$1$$I] = AA[(signed long int)(lglreduce$$1$$16$$1$$R - 1)];
              AA[(signed long int)(lglreduce$$1$$16$$1$$R - 1)] = lglreduce$$1$$16$$1$$1$$1$$5$$2$$TMP;
            }
            while((_Bool)0);
          }
          while((_Bool)0);
          if(!(lglreduce$$1$$16$$1$$I + -lglreduce$$1$$16$$1$$L >= lglreduce$$1$$16$$1$$R + -lglreduce$$1$$16$$1$$I))
          {
            lglreduce$$1$$16$$1$$LL = lglreduce$$1$$16$$1$$I + 1;
            lglreduce$$1$$16$$1$$RR = lglreduce$$1$$16$$1$$R;
            lglreduce$$1$$16$$1$$R = lglreduce$$1$$16$$1$$I - 1;
          }

          else
          {
            lglreduce$$1$$16$$1$$LL = lglreduce$$1$$16$$1$$L;
            lglreduce$$1$$16$$1$$RR = lglreduce$$1$$16$$1$$I - 1;
            lglreduce$$1$$16$$1$$L = lglreduce$$1$$16$$1$$I + 1;
          }
          if(lglreduce$$1$$16$$1$$R + -lglreduce$$1$$16$$1$$L >= 11)
          {
            lglpushstk(lgl, &lgl->$anon1.sortstk, lglreduce$$1$$16$$1$$LL);
            lglpushstk(lgl, &lgl->$anon1.sortstk, lglreduce$$1$$16$$1$$RR);
          }

          else
            if(lglreduce$$1$$16$$1$$RR + -lglreduce$$1$$16$$1$$LL >= 11)
            {
              lglreduce$$1$$16$$1$$L = lglreduce$$1$$16$$1$$LL;
              lglreduce$$1$$16$$1$$R = lglreduce$$1$$16$$1$$RR;
            }

            else
            {
              return_value_lglmtstk$22=lglmtstk(&lgl->$anon1.sortstk);
              if(return_value_lglmtstk$22 == 0)
              {
                lglreduce$$1$$16$$1$$R=lglpopstk(&lgl->$anon1.sortstk);
                lglreduce$$1$$16$$1$$L=lglpopstk(&lgl->$anon1.sortstk);
              }

              else
                break;
            }
        }
        while((_Bool)1);
      }
      while((_Bool)0);
      do
      {
        struct ASL lglreduce$$1$$16$$2$$PIVOT;
        signed int lglreduce$$1$$16$$2$$L = 0;
        signed int lglreduce$$1$$16$$2$$R = NN - 1;
        signed int lglreduce$$1$$16$$2$$I;
        signed int lglreduce$$1$$16$$2$$J;
        lglreduce$$1$$16$$2$$I = lglreduce$$1$$16$$2$$R;
        for( ; !(lglreduce$$1$$16$$2$$L >= lglreduce$$1$$16$$2$$I); lglreduce$$1$$16$$2$$I = lglreduce$$1$$16$$2$$I - 1)
          do
          {
            signed int return_value_lglcmpagsl$23;
            return_value_lglcmpagsl$23=lglcmpagsl(&AA[(signed long int)(lglreduce$$1$$16$$2$$I - 1)], &AA[(signed long int)lglreduce$$1$$16$$2$$I]);
            if(return_value_lglcmpagsl$23 >= 1)
              do
              {
                struct ASL lglreduce$$1$$16$$2$$1$$1$$1$$TMP = AA[(signed long int)(lglreduce$$1$$16$$2$$I - 1)];
                AA[(signed long int)(lglreduce$$1$$16$$2$$I - 1)] = AA[(signed long int)lglreduce$$1$$16$$2$$I];
                AA[(signed long int)lglreduce$$1$$16$$2$$I] = lglreduce$$1$$16$$2$$1$$1$$1$$TMP;
              }
              while((_Bool)0);

          }
          while((_Bool)0);
        lglreduce$$1$$16$$2$$I = lglreduce$$1$$16$$2$$L + 2;
        for( ; lglreduce$$1$$16$$2$$R >= lglreduce$$1$$16$$2$$I; lglreduce$$1$$16$$2$$I = lglreduce$$1$$16$$2$$I + 1)
        {
          lglreduce$$1$$16$$2$$J = lglreduce$$1$$16$$2$$I;
          lglreduce$$1$$16$$2$$PIVOT = AA[(signed long int)lglreduce$$1$$16$$2$$I];
          do
          {
            return_value_lglcmpagsl$24=lglcmpagsl(&lglreduce$$1$$16$$2$$PIVOT, &AA[(signed long int)(lglreduce$$1$$16$$2$$J - 1)]);
            if(return_value_lglcmpagsl$24 >= 0)
              break;

            AA[(signed long int)lglreduce$$1$$16$$2$$J] = AA[(signed long int)(lglreduce$$1$$16$$2$$J - 1)];
            lglreduce$$1$$16$$2$$J = lglreduce$$1$$16$$2$$J - 1;
          }
          while((_Bool)1);
          AA[(signed long int)lglreduce$$1$$16$$2$$J] = lglreduce$$1$$16$$2$$PIVOT;
        }
      }
      while((_Bool)0);

    __CPROVER_DUMP_L113:
      ;
    }
    while((_Bool)0);

__CPROVER_DUMP_L114:
  ;
  nkeep = 0;
  idx = rem;
  for( ; !(idx >= nasls); idx = idx + 1)
  {
    asl = asls + (signed long int)idx;
    lidx = asl->lidx;
    glue = lidx & (1 << 4) - 1;
    lidx = lidx >> 4;
    lidx = lidx / 6;
    maps[(signed long int)glue][(signed long int)lidx] = -1;
    nkeep = nkeep + 1;
  }
  do
  {
    lgldel(lgl, (void *)asls, (unsigned long int)szasls * sizeof(struct ASL) /*12ul*/ );
    asls = ((struct ASL *)NULL);
  }
  while((_Bool)0);

__CPROVER_DUMP_L117:
  ;
  sumcollected = 0;
  glue = minredglue;
  signed int *tmp_post$25;
  _Bool tmp_if_expr$26;
  signed int *tmp_post$27;
  signed int *tmp_post$28;
  signed int *tmp_post$29;
  signed int *tmp_post$30;
  for( ; maxredglue >= glue; glue = glue + 1)
  {
    lir = lgl->red + (signed long int)glue;
    map = maps[(signed long int)glue];
    lglreduce$$1$$start = lir->start;
    q = lglreduce$$1$$start;
    collected = 0;
    c = lglreduce$$1$$start;
    for( ; !(c >= lir->top); c = p + (signed long int)1)
    {
      tmp_post$25 = c;
      c = c + 1l;
      act = *tmp_post$25;
      if(act == 0x7fffffff)
      {
        p = c;
        do
        {
          if(!(p >= lir->top))
            tmp_if_expr$26 = *p == 0x7fffffff ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$26 = (_Bool)0;
          if(!tmp_if_expr$26)
            break;

          p = p + 1l;
        }
        while((_Bool)1);
        p = p - 1l;
      }

      else
      {
        p = c;

      __CPROVER_DUMP_L125:
        ;
        src = (signed int)((c - lglreduce$$1$$start) / (signed long int)6);
        if(map[(signed long int)src] == -2)
        {
          collected = collected + 1;

        __CPROVER_DUMP_L126:
          ;
          for( ; !(*p == 0); p = p + 1l)
            ;
        }

        else
        {
          dst = (signed int)((q - lglreduce$$1$$start) + (signed long int)1);
          map[(signed long int)src] = dst;
          if(p == q)
          {
            for( ; !(*p == 0); p = p + 1l)
              ;
            q = p + (signed long int)1;
          }

          else
          {
            tmp_post$27 = q;
            q = q + 1l;
            *tmp_post$27 = act;

          __CPROVER_DUMP_L133:
            ;
            for( ; !(*p == 0); *tmp_post$28 = *tmp_post$29)
            {
              tmp_post$28 = q;
              q = q + 1l;
              tmp_post$29 = p;
              p = p + 1l;
            }
            tmp_post$30 = q;
            q = q + 1l;
            *tmp_post$30 = 0;
          }
        }
      }
    }

  __CPROVER_DUMP_L137:
    ;
    sumcollected = sumcollected + collected;
    lgl->stats->lir[(signed long int)glue].clauses = lgl->stats->lir[(signed long int)glue].clauses - collected;
    lgl->stats->lir[(signed long int)glue].reduced = lgl->stats->lir[(signed long int)glue].reduced + (signed long int)collected;
    lir->top = q;
    lglfitlir(lgl, lir);
  }

__CPROVER_DUMP_L138:
  ;
  lgl->stats->red.lrg = lgl->stats->red.lrg - sumcollected;
  nunlocked = 0;
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed char return_value_lglval$31;
    return_value_lglval$31=lglval(lgl, idx);
    if(!(return_value_lglval$31 == 0))
    {
      rsn=lglrsn(lgl, idx);
      r0 = rsn[(signed long int)0];
      red = r0 & REDCS;
      if(!(red == 0))
      {
        tag = r0 & MASKCS;
        if(tag == LRGCS)
        {
          lidx = rsn[(signed long int)1];
          glue = lidx & (1 << 4) - 1;
          if(glue >= minredglue)
          {
            if(maxredglue >= glue)
            {
              src = lidx >> 4;
              dst = maps[(signed long int)glue][(signed long int)(src / 6)];
              dst = dst << 4;
              dst = dst | lidx & (1 << 4) - 1;
              rsn[(signed long int)1] = dst;
              nunlocked = nunlocked + 1;
            }

          }

        }

      }

    }

  }

__CPROVER_DUMP_L145:
  ;
  moved = 0;
  collected = moved;
  idx = 2;
  signed int *tmp_post$32;
  signed int *tmp_post$33;
  signed int *tmp_post$34;
  signed int *tmp_post$35;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    dv=lgldvar(lgl, idx);
    i = 0;
    for( ; !(i >= 2); i = i + 1)
    {
      hts = dv->hts + (signed long int)i;
      if(!(hts->offset == 0))
      {
        q=lglhts2wchs(lgl, hts);
        eow = q + (signed long int)hts->count;
        p = q;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          red = blit & REDCS;
          tag = blit & MASKCS;
          if(tag == LRGCS && !(red == 0))
          {
            p = p + 1l;
            lidx = *p;
            glue = lidx & (1 << 4) - 1;
            if(!(glue >= minredglue) || !(maxredglue >= glue))
              dst = lidx >> 4;

            else
            {
              src = lidx >> 4;
              dst = maps[(signed long int)glue][(signed long int)(src / 6)];
            }
            if(dst >= 0)
            {
              moved = moved + 1;
              tmp_post$32 = q;
              q = q + 1l;
              *tmp_post$32 = blit;
              tmp_post$33 = q;
              q = q + 1l;
              *tmp_post$33 = dst << 4 | lidx & (1 << 4) - 1;
            }

            else
              collected = collected + 1;
          }

          else
          {
            tmp_post$34 = q;
            q = q + 1l;
            *tmp_post$34 = blit;
            if(!(tag == BINCS))
            {
              tmp_post$35 = q;
              q = q + 1l;
              p = p + 1l;
              *tmp_post$35 = *p;
            }

          }
        }
        lglshrinkhts(lgl, hts, (signed int)((signed long int)hts->count - (p - q)));
      }

    }
  }

__CPROVER_DUMP_L158:
  ;
  glue = minredglue;
  for( ; maxredglue >= glue; glue = glue + 1)
    do
    {
      lgldel(lgl, (void *)maps[(signed long int)glue], (unsigned long int)sizes[(signed long int)glue] * sizeof(signed int) /*4ul*/ );
      maps[(signed long int)glue] = ((signed int *)NULL);
    }
    while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)sizes, (unsigned long int)(maxredglue + 1) * sizeof(signed int) /*4ul*/ );
    sizes = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)maps, (unsigned long int)(maxredglue + 1) * sizeof(signed int *) /*8ul*/ );
    maps = ((signed int **)NULL);
  }
  while((_Bool)0);
  _Bool tmp_if_expr$38;
  if(lgl->opts->redfixed.val == 0)
  {
    if(needmoreclauses == 0)
    {
      inc = lgl->opts->redlinc.val;
      lglprt(lgl, 2, "arithmetic increase of reduce limit");
      lgl->stats->reduced.arith = lgl->stats->reduced.arith + 1;
    }

    else
      if(needmoreclauses == 1)
      {
        inc = 2 * lgl->opts->redlinc.val;
        lglprt(lgl, 2, "double arithmetic increase of reduce limit");
        lgl->stats->reduced.arith2 = lgl->stats->reduced.arith2 + 1;
        lgl->stats->reduced.arith = lgl->stats->reduced.arith + 1;
      }

      else
      {
        inc = (lgl->opts->redlexpfac.val * lgl->limits->reduce.inner + 99) / 100;
        if(inc == 0)
          inc = inc + 1;

        lglprt(lgl, 2, "exponential increase of reduce limit");
        lgl->stats->reduced.geom = lgl->stats->reduced.geom + 1;
      }

  __CPROVER_DUMP_L166:
    ;
    lgl->limits->reduce.inner = lgl->limits->reduce.inner + inc;
    if(lgl->opts->reduce.val >= 2)
      tmp_if_expr$38 = lgl->limits->reduce.inner >= lgl->limits->reduce.outer ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$38 = (_Bool)0;
    if(tmp_if_expr$38)
    {
      type = (char)47;
      lgl->stats->reduced.reset = lgl->stats->reduced.reset + 1;
      lgl->limits->reduce.inner = lgl->opts->redlinit.val;
      lglboundredl(lgl);
      if(lgl->opts->reduce.val == 2)
      {
        outer = (signed long int)lgl->limits->reduce.inner;
        outer = outer << lgl->opts->redldoutfac.val;
        signed long int return_value_lgluby$36;
        return_value_lgluby$36=lgluby(lgl, lgl->stats->reduced.reset);
        outer = outer * return_value_lgluby$36;
      }

      else
        if(lgl->opts->reduce.val == 3)
        {
          outer = (signed long int)lgl->limits->reduce.inner;
          outer = outer << lgl->opts->redldoutfac.val;
          signed long int return_value_lglinout$37;
          return_value_lglinout$37=lglinout(lgl, lgl->stats->reduced.reset, lgl->opts->redinoutinc.val);
          outer = outer * return_value_lglinout$37;
        }

        else
        {
          outer = (signed long int)(lgl->limits->reduce.outer + lgl->opts->redloutinc.val);
          if(!(outer >= (signed long int)lgl->limits->reduce.inner))
            outer = (signed long int)lgl->limits->reduce.inner;

        }
      if(outer >= 2147483648l)
        outer = (signed long int)0x7fffffff;

      lgl->limits->reduce.outer = (signed int)outer;
    }

    else
      lglboundredl(lgl);
  }


NOINC:
  ;
  lglrep(lgl, 1, type);
  lglchkred(lgl);
  lglstop(lgl);
}

// lglreducing
// file lglib.c line 16979
static signed int lglreducing(struct LGL *lgl)
{
  signed int lrg;
  signed int lrglue;
  if(lgl->opts->reduce.val == 0)
    return 0;

  else
  {
    lrg = lgl->stats->red.lrg;
    lrglue = lgl->lrgluereasons;
    return (signed int)(lrg - lrglue >= lgl->limits->reduce.inner);
  }
}

// lglredvars
// file lglib.c line 2300
static void lglredvars(struct LGL *lgl)
{
  unsigned long int old_size;
  unsigned long int new_size;
  old_size = (unsigned long int)lgl->szvars;
  new_size = (unsigned long int)lgl->nvars;
  if(!(new_size == old_size))
  {

  __CPROVER_DUMP_L1:
    ;
    lglrszvars(lgl, (signed int)new_size);
  }

}

// lglregularly
// file lglib.c line 17087
static void lglregularly(struct LGL *lgl)
{
  signed int return_value_lglreducing$1;
  return_value_lglreducing$1=lglreducing(lgl);
  if(!(return_value_lglreducing$1 == 0))
    lglreduce(lgl, 0);

  signed int return_value_lgldefragmenting$2;
  return_value_lgldefragmenting$2=lgldefragmenting(lgl);
  if(!(return_value_lgldefragmenting$2 == 0))
    lgldefrag(lgl);

}

// lglrelctk
// file lglib.c line 1546
static void lglrelctk(struct LGL *lgl, struct Ctk *ctk)
{
  do
  {
    signed int return_value_lglsizectk$1;
    return_value_lglsizectk$1=lglsizectk(ctk);
    lgldel(lgl, (void *)ctk->start, (unsigned long int)return_value_lglsizectk$1 * sizeof(struct Ctr) /*4ul*/ );
    ctk->start = ((struct Ctr *)NULL);
  }
  while((_Bool)0);
  memset((void *)ctk, 0, sizeof(struct Ctk) /*24ul*/ );
}

// lglrelease
// file lglib.h line 24
void lglrelease(struct LGL *lgl)
{
  void (*dealloc)(void *, void *, unsigned long int);
  signed int i;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglrelease");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  if(!(lgl->clone == ((struct LGL *)NULL)))
  {
    lglrelease(lgl->clone);
    lgl->clone = ((struct LGL *)NULL);
  }

  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "release");
    break;
  }
  do
  {
    lgldel(lgl, (void *)lgl->avars, (unsigned long int)lgl->szvars * sizeof(struct AVar) /*12ul*/ );
    lgl->avars = ((struct AVar *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->drail, (unsigned long int)lgl->szdrail * sizeof(struct TD) /*12ul*/ );
    lgl->drail = ((struct TD *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->dvars, (unsigned long int)lgl->szvars * sizeof(struct DVar) /*16ul*/ );
    lgl->dvars = ((struct DVar *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->ext, (unsigned long int)lgl->szext * sizeof(struct Ext) /*32ul*/ );
    lgl->ext = ((struct Ext *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->i2e, (unsigned long int)lgl->szvars * sizeof(signed int) /*4ul*/ );
    lgl->i2e = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->doms, (unsigned long int)(2 * lgl->szvars) * sizeof(signed int) /*4ul*/ );
    lgl->doms = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->jwh, (unsigned long int)(2 * lgl->szvars) * sizeof(signed long int) /*8ul*/ );
    lgl->jwh = ((signed long int *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->queue.nodes, (unsigned long int)lgl->szvars * sizeof(struct Qnd) /*16ul*/ );
    lgl->queue.nodes = ((struct Qnd *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->vals, (unsigned long int)lgl->szvars * sizeof(signed char) /*1ul*/ );
    lgl->vals = ((signed char *)NULL);
  }
  while((_Bool)0);
  lglrelqueue(lgl);
  lglrelctk(lgl, &lgl->control);
  lglrelstk(lgl, &lgl->assume);
  lglrelstk(lgl, &lgl->clause);
  lglrelstk(lgl, &lgl->eclause);
  lglrelstk(lgl, &lgl->eassume);
  lglrelstk(lgl, &lgl->extend);
  lglrelstk(lgl, &lgl->fassume);
  lglrelstk(lgl, &lgl->cassume);
  lglrelstk(lgl, &lgl->frames);
  lglrelstk(lgl, &lgl->trail);
  lglrelstk(lgl, &lgl->wchs->stk);
  lglrelstk(lgl, &lgl->irr);
  i = 0;
  for( ; !(i >= 16); i = i + 1)
    lglrelstk(lgl, &lgl->red[(signed long int)i]);
  do
    lglrelstk(lgl, &lgl->seen);
  while((_Bool)0);
  do
    lglrelstk(lgl, &lgl->$anon1.lcaseen);
  while((_Bool)0);
  do
    lglrelstk(lgl, &lgl->poisoned);
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->limits, (unsigned long int)1 * sizeof(struct Limits) /*352ul*/ );
    lgl->limits = ((struct Limits *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->times, (unsigned long int)1 * sizeof(struct Times) /*240ul*/ );
    lgl->times = ((struct Times *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->timers, (unsigned long int)1 * sizeof(struct Tmrs) /*128ul*/ );
    lgl->timers = ((struct Tmrs *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->red, (unsigned long int)(((1 << 4) - 1) + 1) * sizeof(struct Stk) /*24ul*/ );
    lgl->red = ((struct Stk *)NULL);
  }
  while((_Bool)0);
  do
  {
    lgldel(lgl, (void *)lgl->wchs, (unsigned long int)1 * sizeof(struct Wchs) /*152ul*/ );
    lgl->wchs = ((struct Wchs *)NULL);
  }
  while((_Bool)0);
  if(!(lgl->fltstr == ((struct FltStr *)NULL)))
    do
    {
      lgldel(lgl, (void *)lgl->fltstr, (unsigned long int)1 * sizeof(struct FltStr) /*604ul*/ );
      lgl->fltstr = ((struct FltStr *)NULL);
    }
    while((_Bool)0);

  if(!(lgl->cbs == ((struct Cbs *)NULL)))
    do
    {
      lgldel(lgl, (void *)lgl->cbs, (unsigned long int)1 * sizeof(struct Cbs) /*152ul*/ );
      lgl->cbs = ((struct Cbs *)NULL);
    }
    while((_Bool)0);

  lgldelstr(lgl, lgl->prefix);
  lgldec(lgl, sizeof(struct Stats) /*2272ul*/ );
  lgldec(lgl, sizeof(struct Opts) /*5680ul*/ );
  lgldec(lgl, sizeof(struct Mem) /*32ul*/ );
  lgldec(lgl, sizeof(struct LGL) /*816ul*/ );
  if((signed int)lgl->closeapitrace == 1)
    fclose(lgl->apitrace);

  if((signed int)lgl->closeapitrace == 2)
    pclose(lgl->apitrace);

  dealloc = lgl->mem->dealloc;
  if(!(dealloc == ((void (*)(void *, void *, unsigned long int))NULL)))
  {
    void *memstate = lgl->mem->state;
    if(!(lgl->stats == ((struct Stats *)NULL)))
      dealloc(memstate, (void *)lgl->stats, sizeof(struct Stats) /*2272ul*/ );

    if(!(lgl->times == ((struct Times *)NULL)))
      dealloc(memstate, (void *)lgl->times, sizeof(struct Times) /*240ul*/ );

    if(!(lgl->opts == ((struct Opts *)NULL)))
      dealloc(memstate, (void *)lgl->opts, sizeof(struct Opts) /*5680ul*/ );

    dealloc(memstate, (void *)lgl->mem, sizeof(struct Mem) /*32ul*/ );
    dealloc(memstate, (void *)lgl, sizeof(struct LGL) /*816ul*/ );
  }

  else
  {
    free((void *)lgl->stats);
    free((void *)lgl->times);
    free((void *)lgl->opts);
    free((void *)lgl->mem);
    free((void *)lgl);
  }
}

// lglrelecls
// file lglib.c line 9422
static void lglrelecls(struct LGL *lgl)
{
  lglrelstk(lgl, &lgl->$anon0.elm->lits);
  lglrelstk(lgl, &lgl->$anon0.elm->next);
  lglrelstk(lgl, &lgl->$anon0.elm->csigs);
  lglrelstk(lgl, &lgl->$anon0.elm->lsigs);
  lglrelstk(lgl, &lgl->$anon0.elm->sizes);
  lglrelstk(lgl, &lgl->$anon0.elm->occs);
  lglrelstk(lgl, &lgl->$anon0.elm->noccs);
  lglrelstk(lgl, &lgl->$anon0.elm->mark);
  lglrelstk(lgl, &lgl->$anon0.elm->m2i);
  lglrelstk(lgl, &lgl->$anon0.elm->clv);
}

// lglrelqueue
// file lglib.c line 18614
static void lglrelqueue(struct LGL *lgl)
{
  struct Qln *p;
  struct Qln *up;
  p = lgl->queue.bottom;
  for( ; !(p == ((struct Qln *)NULL)); p = up)
  {
    up = p->up;
    do
    {
      lgldel(lgl, (void *)p, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
      p = ((struct Qln *)NULL);
    }
    while((_Bool)0);
  }
  p = lgl->queue.merged;
  for( ; !(p == ((struct Qln *)NULL)); p = up)
  {
    up = p->up;
    do
    {
      lgldel(lgl, (void *)p, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
      p = ((struct Qln *)NULL);
    }
    while((_Bool)0);
  }
  p = lgl->queue.free;
  for( ; !(p == ((struct Qln *)NULL)); p = up)
  {
    up = p->up;
    do
    {
      lgldel(lgl, (void *)p, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
      p = ((struct Qln *)NULL);
    }
    while((_Bool)0);
  }
  do
    memset((void *)&lgl->queue, 0, sizeof(struct Queue) /*56ul*/ );
  while((_Bool)0);
}

// lglrelstk
// file lglib.c line 1410
static void lglrelstk(struct LGL *lgl, struct Stk *s)
{
  do
  {
    unsigned long int return_value_lglszstk$1;
    return_value_lglszstk$1=lglszstk(s);
    lgldel(lgl, (void *)s->start, return_value_lglszstk$1 * sizeof(signed int) /*4ul*/ );
    s->start = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
    memset((void *)s, 0, sizeof(struct Stk) /*24ul*/ );
  while((_Bool)0);
}

// lglrelwtk
// file lglib.c line 14995
static void lglrelwtk(struct LGL *lgl, struct Wtk *wtk)
{
  do
  {
    signed int return_value_lglsizewtk$1;
    return_value_lglsizewtk$1=lglsizewtk(wtk);
    lgldel(lgl, (void *)wtk->start, (unsigned long int)return_value_lglsizewtk$1 * sizeof(struct Work) /*8ul*/ );
    wtk->start = ((struct Work *)NULL);
  }
  while((_Bool)0);
  memset((void *)wtk, 0, sizeof(struct Wtk) /*24ul*/ );
}

// lglrem
// file lglib.c line 3348
static signed int lglrem(struct LGL *lgl)
{
  signed int res = lgl->nvars;
  if(res == 0)
    return 0;

  else
  {
    res = res - (lgl->stats->fixed.current + 2);
    return res;
  }
}

// lglrep
// file lglib.c line 5046
static void lglrep(struct LGL *lgl, signed int level, char type)
{
  double tmp_if_expr$3;
  double return_value_lglgetime$1;
  double return_value_lglsec$2;
  if(lgl->opts->verbose.val >= level)
  {
    if(lgl->stats->reported % 23 == 0)
      lglrephead(lgl);

    if(!(lgl->opts->abstime.val == 0))
    {
      return_value_lglgetime$1=lglgetime(lgl);
      tmp_if_expr$3 = return_value_lglgetime$1;
    }

    else
    {
      return_value_lglsec$2=lglsec(lgl);
      tmp_if_expr$3 = return_value_lglsec$2;
    }
    signed int return_value_lglrem$4;
    return_value_lglrem$4=lglrem(lgl);
    double return_value_lglagility$5;
    return_value_lglagility$5=lglagility(lgl);
    signed long int return_value_lglavglue$6;
    return_value_lglavglue$6=lglavglue(lgl);
    double return_value_lglheight$7;
    return_value_lglheight$7=lglheight(lgl);
    double return_value_lglmb$8;
    return_value_lglmb$8=lglmb(lgl);
    lglprt(lgl, 1, "%c %6.1f %7d %8d %9lld %7d %6d %5d %3.0f %4.1f %5.1f %4.0f", type, tmp_if_expr$3, return_value_lglrem$4, lgl->stats->irr.clauses.cur, (signed long long int)lgl->stats->confs, lgl->stats->red.lrg, lgl->stats->red.bin, lgl->stats->red.trn, return_value_lglagility$5, (double)return_value_lglavglue$6 / 100.0, return_value_lglheight$7, return_value_lglmb$8);
    lgl->stats->reported = lgl->stats->reported + 1;
  }

}

// lglrephead
// file lglib.c line 5028
static void lglrephead(struct LGL *lgl)
{
  if(!(lgl->tid >= 1))
  {
    if(!(lgl->cbs == ((struct Cbs *)NULL)))
    {
      if(!(lgl->cbs->msglock.lock == ((void (*)(void *))NULL)))
        lgl->cbs->msglock.lock(lgl->cbs->msglock.state);

    }

    fprintf(lgl->out, "%s\n", lgl->prefix);
    fprintf(lgl->out, "%s%s seconds         irredundant          redundant clauses agility   height\n", lgl->prefix, !(lgl->tid != 0) ? "  " : "");
    fprintf(lgl->out, "%s%s         variables clauses conflicts large binary ternary    glue         MB\n", lgl->prefix, !(lgl->tid != 0) ? "  " : "");
    fprintf(lgl->out, "%s\n", lgl->prefix);
    fflush(lgl->out);
    if(!(lgl->cbs == ((struct Cbs *)NULL)))
    {
      if(!(lgl->cbs->msglock.unlock == ((void (*)(void *))NULL)))
        lgl->cbs->msglock.unlock(lgl->cbs->msglock.state);

    }

  }

}

// lglrepr
// file lglib.c line 17980
signed int lglrepr(struct LGL *lgl, signed int elit)
{
  signed int res;
  signed int eidx;
  eidx=abs(elit);

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglrepr");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "repr %d", elit);
    break;
  }
  lgl->stats->calls.repr = lgl->stats->calls.repr + 1l;
  if(!(lgl->maxext >= eidx))
    res = elit;

  else
  {
    res=lglerepr(lgl, elit);
    signed int return_value_abs$1;
    return_value_abs$1=abs(res);
    if(!(return_value_abs$1 >= 2))
      res = elit;

  }

__CPROVER_DUMP_L8:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglrepr(lgl->clone, elit);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglrepr");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d", (const void *)"lglrepr", elit, CLONERES, (const void *)"lglrepr", elit, res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglreqinit
// file lglib.c line 18994
static void lglreqinit(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglreqinit");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
}

// lglrescoreclauses
// file lglib.c line 3414
static void lglrescoreclauses(struct LGL *lgl)
{
  signed int glue;
  lgl->stats->rescored.clauses = lgl->stats->rescored.clauses + 1;
  glue = 0;
  for( ; !(glue >= 15); glue = glue + 1)
    lglrescoreglue(lgl, glue);
}

// lglrescoreglue
// file lglib.c line 3392
static void lglrescoreglue(struct LGL *lgl, signed int glue)
{
  signed int *c;
  signed int *p;
  signed int oldact;
  signed int newact;
  struct Stk *lir = lgl->red + (signed long int)glue;
  c = lir->start;
  _Bool tmp_if_expr$1;
  signed int *tmp_post$2;
  for( ; !(c >= lir->top); c = p + (signed long int)1)
  {
    oldact = *c;
    if(oldact == 0x7fffffff)
    {
      p = c + (signed long int)1;
      do
      {
        if(!(p >= lir->top))
          tmp_if_expr$1 = *p == 0x7fffffff ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(!tmp_if_expr$1)
          break;

        p = p + 1l;
      }
      while((_Bool)1);
      p = p - 1l;
    }

    else
    {
      newact = (0x7fffffff >> RMSHFT) + ((oldact - (0x7fffffff >> RMSHFT)) + 1) / 2;
      tmp_post$2 = c;
      c = c + 1l;
      *tmp_post$2 = newact;

    __CPROVER_DUMP_L7:
      ;
      p = c;
      for( ; !(*p == 0); p = p + 1l)
        ;
    }
  }
}

// lglreset
// file lglib.c line 3744
static void lglreset(struct LGL *lgl)
{
  signed int elit;
  signed int ilit;
  signed int erepr;
  struct Ext *ext;
  struct Ext *rext;
  unsigned int bit;
  struct AVar *av;
  signed int return_value_lglmtstk$1;
  signed int return_value_lglmtstk$3;
  if(!((signed int)lgl->state == RESET))
  {
    if((signed int)lgl->state >= 5)
    {
      if(lgl->level >= 1)
        lglbacktrack(lgl, 0);

      signed int return_value_lglmtstk$2;
      return_value_lglmtstk$2=lglmtstk(&lgl->eassume);
      if(return_value_lglmtstk$2 == 0)
      {

      __CPROVER_DUMP_L4:
        ;
        do
        {
          return_value_lglmtstk$1=lglmtstk(&lgl->eassume);
          if(!(return_value_lglmtstk$1 == 0))
            break;

          elit=lglpopstk(&lgl->eassume);
          ext=lglelit2ext(lgl, elit);
          ext->assumed = (unsigned int)0;
          if(!(ext->failed == 0u))
          {
            ext->failed = (unsigned int)0;
            erepr=lglerepr(lgl, elit);
            if(!(erepr == elit))
            {
              rext=lglelit2ext(lgl, erepr);
              rext->failed = (unsigned int)0;
            }

          }

        }
        while((_Bool)1);
      }

      lglchkeassumeclean(lgl);
      signed int return_value_lglmtstk$4;
      return_value_lglmtstk$4=lglmtstk(&lgl->assume);
      if(return_value_lglmtstk$4 == 0)
      {

      __CPROVER_DUMP_L9:
        ;
        do
        {
          return_value_lglmtstk$3=lglmtstk(&lgl->assume);
          if(!(return_value_lglmtstk$3 == 0))
            break;

          ilit=lglpopstk(&lgl->assume);
          av=lglavar(lgl, ilit);
          bit = 1u << (signed int)(ilit < 0);
          av->assumed = (unsigned int)av->assumed & ~bit;
          av->failed = (unsigned int)av->failed & ~bit;
        }
        while((_Bool)1);
      }

      signed int return_value_lglmtstk$5;
      return_value_lglmtstk$5=lglmtstk(&lgl->cassume);
      if(return_value_lglmtstk$5 == 0)
      {

      __CPROVER_DUMP_L13:
        ;
        lglclnstk(&lgl->cassume);
        lgl->ncassumed = 0;
        lgl->cassumed = lgl->ncassumed;
      }

      if(!(lgl->failed == 0))
      {

      __CPROVER_DUMP_L15:
        ;
        lgl->failed = 0;
      }

      if(!(lgl->assumed == 0))
      {

      __CPROVER_DUMP_L17:
        ;
        lgl->assumed = 0;
      }

      lglchkassumeclean(lgl);
      lgleunassignall(lgl);

    __CPROVER_DUMP_L19:
      ;
      do
        lgl->state = (enum State)RESET;
      while((_Bool)0);
    }

  }

}

// lglresetforked
// file lglib.c line 18920
void lglresetforked(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglresetforked");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(lgl->forked == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglresetforked");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "not forked");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lgl->bruteforked = (char)0;
  lgl->forked = lgl->bruteforked;
}

// lglresetphase
// file lglib.c line 3908
void lglresetphase(struct LGL *lgl, signed int elit)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglresetphase");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(elit == 0))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglresetphase");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "invalid literal argument");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "resetphase %d", elit);
    break;
  }
  lglesetphase(lgl, elit, 0);
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglresetphase(lgl->clone, elit);

}

// lglresetsmallve
// file lglib.c line 10708
static void lglresetsmallve(struct LGL *lgl)
{
  lglclnstk(&lgl->$anon0.elm->m2i);
  lglclnstk(&lgl->$anon0.elm->clv);
  lglpopnunmarkstk(lgl, &lgl->seen);
}

// lglrestart
// file lglib.c line 6334
static void lglrestart(struct LGL *lgl)
{
  signed int skip;
  signed int level;
  signed long int kept;
  lglstart(lgl, &lgl->times->rsts);
  skip=lglagile(lgl);
  if(!(skip == 0))
    lgl->stats->restarts.skipped = lgl->stats->restarts.skipped + 1;

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(!(lgl->opts->restart.val >= 2))
      level = 0;

    else
      level=lglreusetrail(lgl);
    if(!(level >= lgl->alevel))
      level = lgl->alevel;

    else
      if(!(lgl->alevel >= level))
      {
        kept = (signed long int)((100 * level) / lgl->level);
        lgl->stats->restarts.kept.sum = lgl->stats->restarts.kept.sum + kept;
        lgl->stats->restarts.kept.count = lgl->stats->restarts.kept.count + 1;
      }

    if(!(level >= lgl->level))
    {
      lglbacktrack(lgl, level);
      lgl->stats->restarts.count = lgl->stats->restarts.count + 1;
    }

    else
      lgl->stats->restarts.skipped = lgl->stats->restarts.skipped + 1;
  }

__CPROVER_DUMP_L1:
  ;
  lglincrestartl(lgl, skip);
  lglstop(lgl);
}

// lglrestarting
// file lglib.c line 16996
static signed int lglrestarting(struct LGL *lgl)
{
  signed int lglrestarting$$1$$assumptions;
  if(lgl->opts->restart.val == 0)
    return 0;

  else
    if(lgl->level == 0)
      return 0;

    else
    {
      unsigned long int return_value_lglcntstk$1;
      return_value_lglcntstk$1=lglcntstk(&lgl->assume);
      lglrestarting$$1$$assumptions = (signed int)return_value_lglcntstk$1;
      if(!(lglrestarting$$1$$assumptions == 0))
      {
        if(!(lgl->assumed >= lglrestarting$$1$$assumptions))
          return 0;

        if(!(lgl->alevel == lgl->level))
          goto __CPROVER_DUMP_L4;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L4:
        ;
        return (signed int)(lgl->stats->confs >= lgl->limits->restart.confs);
      }
    }
}

// lglreusetrail
// file lglib.c line 6315
static signed int lglreusetrail(struct LGL *lgl)
{
  signed int lglreusetrail$$1$$next = 0;
  signed int res = 0;
  signed int prev;
  signed int level;
  const struct Ctr *p;
  lglreusetrail$$1$$next=lglnextdecision(lgl);
  signed int return_value_lglqcmp$1;
  if(lglreusetrail$$1$$next == 0)
    return 0;

  else
  {
    p = lgl->control.start + (signed long int)1;
    for( ; !(p >= lgl->control.top); p = p + 1l)
    {
      prev = (signed int)p->decision;
      signed int return_value_lglassumption$2;
      return_value_lglassumption$2=lglassumption(lgl, prev);
      if(return_value_lglassumption$2 == 0)
      {
        return_value_lglqcmp$1=lglqcmp(lgl, prev, lglreusetrail$$1$$next);
        if(!(return_value_lglqcmp$1 >= 0))
          break;

      }

      level=lglevel(lgl, prev);
      res = level;
    }
    if(!(res == 0))
      lglprt(lgl, 2, "reuse trail level %d from current level %d", res, lgl->level);

    return res;
  }
}

// lglrgopts
// file lglib.c line 2125
void lglrgopts(struct LGL *lgl)
{
  struct Opt *o;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglrgopts");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  o = &lgl->opts->beforefirst + (signed long int)1;
  for( ; &lgl->opts->afterlast + -1l >= o; o = o + 1l)
    fprintf(lgl->out, "%s %d %d %d\n", o->lng, o->val, o->min, o->max);
}

// lglrmbcls
// file lglib.c line 5668
static void lglrmbcls(struct LGL *lgl, signed int a, signed int b, signed int red)
{
  lglrmbwch(lgl, a, b, red);
  lglrmbwch(lgl, b, a, red);

__CPROVER_DUMP_L1:
  ;
  lgldeclscnt(lgl, 2, red, 0);
  if(red == 0)
  {
    if(!(lgl->dense == 0))
    {
      lgldecocc(lgl, a);
      lgldecocc(lgl, b);
    }

  }

}

// lglrmbindup
// file lglib.c line 15958
static void lglrmbindup(struct LGL *lgl)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int round;
  signed int redrem;
  signed int irrem;
  signed int *w;
  signed int *eow;
  signed int *p;
  signed int *q;
  struct HTS *hts;
  irrem = 0;
  redrem = irrem;
  idx = 2;
  signed int *tmp_post$1;
  signed int *tmp_post$2;
  signed int *tmp_post$5;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      round = 0;
      for( ; !(round >= 2); round = round + 1)
      {
        hts=lglhts(lgl, lit);
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        q = w;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          tag = blit & MASKCS;
          if(!(tag == BINCS))
          {
            tmp_post$1 = q;
            q = q + 1l;
            *tmp_post$1 = blit;
          }

          if(tag == TRNCS || tag == LRGCS)
          {
            tmp_post$2 = q;
            q = q + 1l;
            p = p + 1l;
            *tmp_post$2 = *p;
          }

          if(tag == BINCS)
          {
            red = blit & REDCS;
            other = blit >> RMSHFT;
            signed int return_value_lglsignedmarked$6;
            return_value_lglsignedmarked$6=lglsignedmarked(lgl, other);
            if(!(return_value_lglsignedmarked$6 == 0))
            {
              if(red == 0 && !(round == 0))
                goto ONLYCOPY;

              if(!(red == 0))
                redrem = redrem + 1;

              else
                irrem = irrem + 1;
              signed int return_value_abs$3;
              return_value_abs$3=abs(lit);
              signed int return_value_abs$4;
              return_value_abs$4=abs(other);
              if(!(return_value_abs$4 >= return_value_abs$3))
              {

              __CPROVER_DUMP_L9:
                ;
                lgldeclscnt(lgl, 2, red, 0);
                if(red == 0)
                {
                  if(!(lgl->dense == 0))
                  {
                    lgldecocc(lgl, lit);
                    lgldecocc(lgl, other);
                  }

                }

                lgl->stats->bindup.removed = lgl->stats->bindup.removed + 1;
                if(!(red == 0))
                  lgl->stats->bindup.red = lgl->stats->bindup.red + 1;

              }

              else

                __CPROVER_DUMP_L12:
                  ;
            }

            else
            {
              if(red == 0 && round == 0 || !(red == 0) && !(round == 0))
                lglsignedmarknpushseen(lgl, other);


            ONLYCOPY:
              ;
              tmp_post$5 = q;
              q = q + 1l;
              *tmp_post$5 = blit;
            }
          }

        }
        lglshrinkhts(lgl, hts, (signed int)((signed long int)hts->count - (p - q)));
      }
      lglpopnunmarkstk(lgl, &lgl->seen);
    }
  }
}

// lglrmbwch
// file lglib.c line 5603
static void lglrmbwch(struct LGL *lgl, signed int lit, signed int other, signed int red)
{
  signed int *p;
  signed int blit;
  signed int blit1;
  signed int *w;
  signed int *eow;
  signed int tag;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  p = w;
  eow = w + (signed long int)hts->count;
  lglrminc(lgl, w, eow);
  blit1 = other << RMSHFT | red | BINCS;
  signed int *tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p + 1l;
    blit = *tmp_post$1;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    else
      if(!(tag == OCCS))
      {
        if(blit == blit1)
          break;

      }

  }
  while((_Bool)1);
  for( ; !(p >= eow); p = p + 1l)
    p[(signed long int)-1] = p[(signed long int)0];
  lglshrinkhts(lgl, hts, (signed int)((p - w) - (signed long int)1));
}

// lglrminc
// file lglib.c line 4086
static void lglrminc(struct LGL *lgl, const signed int *w, const signed int *eow)
{
  signed int inc = (signed int)(eow - w);
  inc = inc >> lgl->opts->rmincpen.val;
  inc = inc + 1;
  if(!(lgl->blocking == 0))
    lgl->stats->blk.steps = lgl->stats->blk.steps + (signed long int)inc;

  else
    if(!(lgl->eliminating == 0))
      lgl->stats->elm.steps = lgl->stats->elm.steps + (signed long int)inc;

}

// lglrmlcls
// file lglib.c line 5686
static void lglrmlcls(struct LGL *lgl, signed int lidx, signed int red)
{
  signed int *c;
  signed int *p;
  signed int glue;
  signed int lit;
  glue = red != 0 ? lidx & (1 << 4) - 1 : 0;
  c=lglidx2lits(lgl, LRGCS, red, lidx);
  if(red == 0 || !(glue >= 15))
  {
    lglrmlwch(lgl, c[(signed long int)0], red, lidx);
    lglrmlwch(lgl, c[(signed long int)1], red, lidx);
  }

  if(red == 0)
  {
    if(!(lgl->dense == 0))
    {
      p = c;
      do
      {
        lit = *p;
        if(lit == 0)
          break;

        lglrmlocc(lgl, lit, red, lidx);
        lgldecocc(lgl, lit);
        p = p + 1l;
      }
      while((_Bool)1);
    }

  }

  if(!(red == 0) && !(glue >= 15))
  {

  __CPROVER_DUMP_L4:
    ;
    c[(signed long int)-1] = 0x7fffffff;
  }

  p = c;
  for( ; !(*p == 0); p = p + 1l)
    *p = 0x7fffffff;
  *p = 0x7fffffff;
  if(!(glue == 15))
    lgldeclscnt(lgl, (signed int)(p - c), red, glue);

}

// lglrmlocc
// file lglib.c line 4363
static void lglrmlocc(struct LGL *lgl, signed int lit, signed int red, signed int lidx)
{
  signed int search;
  signed int blit;
  signed int tag;
  signed int *p;
  signed int *q;
  signed int *w;
  signed int *eow;
  struct HTS *hts;
  signed int *tmp_post$1;
  if((signed int)lgl->dense >= 2)
  {
    hts=lglhts(lgl, lit);
    search = lidx << RMSHFT | OCCS | red;
    w=lglhts2wchs(lgl, hts);
    p = w;
    eow = w + (signed long int)hts->count;
    lglrminc(lgl, w, eow);
    do
    {
      tmp_post$1 = p;
      p = p + 1l;
      blit = *tmp_post$1;
      tag = blit & MASKCS;
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

    }
    while(!(blit == search));
    q = p;
    for( ; !(q >= eow); q = q + 1l)
      q[(signed long int)-1] = q[(signed long int)0];
    lglshrinkhts(lgl, hts, (signed int)((q - w) - (signed long int)1));
  }

}

// lglrmlwch
// file lglib.c line 4210
static void lglrmlwch(struct LGL *lgl, signed int lit, signed int red, signed int lidx)
{
  signed int blit;
  signed int tag;
  signed int *p;
  signed int *q;
  signed int *w;
  signed int *eow;
  signed int ored;
  signed int olidx;
  struct HTS *hts;
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  p = w;
  eow = w + (signed long int)hts->count;
  lglrminc(lgl, w, eow);
  signed int *tmp_post$1;
  signed int *tmp_post$2;
  do
  {
    tmp_post$1 = p;
    p = p + 1l;
    blit = *tmp_post$1;
    tag = blit & MASKCS;
    if(!(tag == BINCS))
    {
      if(!(tag == OCCS))
      {
        tmp_post$2 = p;
        p = p + 1l;
        olidx = *tmp_post$2;
        if(!(tag == TRNCS))
        {
          ored = blit & REDCS;
          if(ored == red)
          {
            if(olidx == lidx)
              break;

          }

        }

      }

    }

  }
  while((_Bool)1);
  q = p;
  for( ; !(q >= eow); q = q + 1l)
    q[(signed long int)-2] = q[(signed long int)0];
  lglshrinkhts(lgl, hts, (signed int)((q - w) - (signed long int)2));
}

// lglrmstk
// file lglib.c line 1436
static void lglrmstk(struct Stk *s, signed int elem)
{
  signed int *p;
  signed int *q;
  p = s->start;
  for( ; !(p >= s->top); p = p + 1l)
    if(*p == elem)
      break;

  signed int *tmp_post$1 = p;
  p = p + 1l;
  q = tmp_post$1;
  signed int *tmp_post$2;
  signed int *tmp_post$3;
  for( ; !(p >= s->top); *tmp_post$2 = *tmp_post$3)
  {
    tmp_post$2 = q;
    q = q + 1l;
    tmp_post$3 = p;
    p = p + 1l;
  }
  s->top = q;
}

// lglrmtcls
// file lglib.c line 5676
static void lglrmtcls(struct LGL *lgl, signed int a, signed int b, signed int c, signed int red)
{
  lglrmtwch(lgl, a, b, c, red);
  lglrmtwch(lgl, b, a, c, red);
  lglrmtwch(lgl, c, a, b, red);

__CPROVER_DUMP_L1:
  ;
  lgldeclscnt(lgl, 3, red, 0);
  if(red == 0)
  {
    if(!(lgl->dense == 0))
    {
      lgldecocc(lgl, a);
      lgldecocc(lgl, b);
      lgldecocc(lgl, c);
    }

  }

}

// lglrmtwch
// file lglib.c line 4099
static void lglrmtwch(struct LGL *lgl, signed int lit, signed int other1, signed int other2, signed int red)
{
  signed int *p;
  signed int blit;
  signed int other;
  signed int blit1;
  signed int blit2;
  signed int *w;
  signed int *eow;
  signed int tag;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  p = w;
  eow = w + (signed long int)hts->count;
  lglrminc(lgl, w, eow);
  blit1 = other1 << RMSHFT | red | TRNCS;
  blit2 = other2 << RMSHFT | red | TRNCS;
  signed int *tmp_post$1;
  signed int *tmp_post$2;
  do
  {
    tmp_post$1 = p;
    p = p + 1l;
    blit = *tmp_post$1;
    tag = blit & MASKCS;
    if(!(tag == OCCS) && !(tag == BINCS))
    {
      tmp_post$2 = p;
      p = p + 1l;
      other = *tmp_post$2;
      if(!(tag == LRGCS))
      {
        if(blit == blit1 && other == other2)
          break;

        if(blit == blit2 && other == other1)
          break;

      }

    }

  }
  while((_Bool)1);
  for( ; !(p >= eow); p = p + 1l)
    p[(signed long int)-2] = p[(signed long int)0];
  lglshrinkhts(lgl, hts, (signed int)((p - w) - (signed long int)2));
}

// lglrmvbcls
// file lglib.c line 11792
static void lglrmvbcls(struct LGL *lgl, signed int a, signed int b)
{
  lglrmbcls(lgl, a, b, 0);
  if(!(lgl->opts->move.val == 0))
    lglmvbcls(lgl, a, b);

}

// lglrmvtcls
// file lglib.c line 11797
static void lglrmvtcls(struct LGL *lgl, signed int a, signed int b, signed int c)
{
  lglrmtcls(lgl, a, b, c, 0);
  if(lgl->opts->move.val >= 2)
    lglmvtcls(lgl, a, b, c);

}

// lglrsn
// file lglib.c line 2578
static signed int * lglrsn(struct LGL *lgl, signed int lit)
{
  struct TD *return_value_lgltd$1;
  return_value_lgltd$1=lgltd(lgl, lit);
  return return_value_lgltd$1->rsn;
}

// lglrstcontrol
// file lglib.c line 1574
static void lglrstcontrol(struct LGL *lgl, signed int count)
{
  signed int return_value_lglcntctk$1;
  do
  {
    return_value_lglcntctk$1=lglcntctk(&lgl->control);
    if(count >= return_value_lglcntctk$1)
      break;

    lglpopcontrol(lgl);
  }
  while((_Bool)1);
}

// lglrstecls
// file lglib.c line 9407
static void lglrstecls(struct LGL *lgl)
{
  lglclnstk(&lgl->$anon0.elm->lits);
  lglclnstk(&lgl->$anon0.elm->next);
  lglclnstk(&lgl->$anon0.elm->csigs);
  lglclnstk(&lgl->$anon0.elm->lsigs);
  lglclnstk(&lgl->$anon0.elm->sizes);
  lglclnstk(&lgl->$anon0.elm->occs);
  lglclnstk(&lgl->$anon0.elm->noccs);
  lglclnstk(&lgl->$anon0.elm->mark);
  lglclnstk(&lgl->$anon0.elm->m2i);
  lglpopnunmarkstk(lgl, &lgl->seen);
  lgl->$anon0.elm->pivot = 0;
}

// lglrststk
// file lglib.c line 1451
static void lglrststk(struct Stk *s, signed int newsz)
{
  s->top = s->start + (signed long int)newsz;
}

// lglrsz
// file lglib.c line 1279
static void * lglrsz(struct LGL *lgl, void *ptr, unsigned long int old, unsigned long int new)
{
  void *res;
  void *return_value_lglnew$1;
  if(ptr == NULL)
  {
    return_value_lglnew$1=lglnew(lgl, new);
    return return_value_lglnew$1;
  }

  else
    if(new == 0ul)
    {
      lgldel(lgl, ptr, old);
      return NULL;
    }

    else
      if(old == new)
        return ptr;

      else
      {
        lgldec(lgl, old);
        if(!(lgl->mem->realloc == ((void * (*)(void *, void *, unsigned long int, unsigned long int))NULL)))
          res=lgl->mem->realloc(lgl->mem->state, ptr, old, new);

        else
          res=realloc(ptr, new);
        if(res == NULL)
          lgldie(lgl, "out of memory reallocating %ld to %ld bytes", old, new);


      __CPROVER_DUMP_L6:
        ;
        lglinc(lgl, new);
        if(!(old >= new))
          memset(res + (signed long int)old, 0, new - old);

        return res;
      }
}

// lglrszvars
// file lglib.c line 2279
static void lglrszvars(struct LGL *lgl, signed int new_size)
{
  signed int old_size = lgl->szvars;
  do
  {
    void *return_value_lglrsz$1;
    return_value_lglrsz$1=lglrsz(lgl, (void *)lgl->vals, (unsigned long int)old_size * sizeof(signed char) /*1ul*/ , (unsigned long int)new_size * sizeof(signed char) /*1ul*/ );
    lgl->vals = (signed char *)return_value_lglrsz$1;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglrsz$2;
    return_value_lglrsz$2=lglrsz(lgl, (void *)lgl->i2e, (unsigned long int)old_size * sizeof(signed int) /*4ul*/ , (unsigned long int)new_size * sizeof(signed int) /*4ul*/ );
    lgl->i2e = (signed int *)return_value_lglrsz$2;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglrsz$3;
    return_value_lglrsz$3=lglrsz(lgl, (void *)lgl->doms, (unsigned long int)(2 * old_size) * sizeof(signed int) /*4ul*/ , (unsigned long int)(2 * new_size) * sizeof(signed int) /*4ul*/ );
    lgl->doms = (signed int *)return_value_lglrsz$3;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglrsz$4;
    return_value_lglrsz$4=lglrsz(lgl, (void *)lgl->dvars, (unsigned long int)old_size * sizeof(struct DVar) /*16ul*/ , (unsigned long int)new_size * sizeof(struct DVar) /*16ul*/ );
    lgl->dvars = (struct DVar *)return_value_lglrsz$4;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglrsz$5;
    return_value_lglrsz$5=lglrsz(lgl, (void *)lgl->avars, (unsigned long int)old_size * sizeof(struct AVar) /*12ul*/ , (unsigned long int)new_size * sizeof(struct AVar) /*12ul*/ );
    lgl->avars = (struct AVar *)return_value_lglrsz$5;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglrsz$6;
    return_value_lglrsz$6=lglrsz(lgl, (void *)lgl->jwh, (unsigned long int)(2 * old_size) * sizeof(signed long int) /*8ul*/ , (unsigned long int)(2 * new_size) * sizeof(signed long int) /*8ul*/ );
    lgl->jwh = (signed long int *)return_value_lglrsz$6;
  }
  while((_Bool)0);
  do
  {
    void *return_value_lglrsz$7;
    return_value_lglrsz$7=lglrsz(lgl, (void *)lgl->queue.nodes, (unsigned long int)old_size * sizeof(struct Qnd) /*16ul*/ , (unsigned long int)new_size * sizeof(struct Qnd) /*16ul*/ );
    lgl->queue.nodes = (struct Qnd *)return_value_lglrsz$7;
  }
  while((_Bool)0);
  lgl->szvars = new_size;
}

// lglrtrav
// file lglib.c line 18813
void lglrtrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int, signed int))
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int glue;
  const signed int *p;
  const signed int *c;
  const signed int *w;
  const signed int *eow;
  struct Stk *lir;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglrtrav");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  signed int return_value_lglexport$6;
  if(lgl->mt == 0)
  {
    lglgc(lgl);
    if(lgl->level >= 1)
      lglbacktrack(lgl, 0);

    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      signed char return_value_lglval$1;
      return_value_lglval$1=lglval(lgl, idx);
      if(return_value_lglval$1 == 0)
      {
        sign = -1;
        for( ; !(sign >= 2); sign = sign + 2)
        {
          lit = sign * idx;
          hts=lglhts(lgl, lit);
          w=lglhts2wchs(lgl, hts);
          eow = w + (signed long int)hts->count;
          p = w;
          for( ; !(p >= eow); p = p + 1l)
          {
            blit = *p;
            tag = blit & MASKCS;
            red = blit & REDCS;
            if(tag == TRNCS || tag == LRGCS)
              p = p + 1l;

            if(!(red == 0))
            {
              if(tag == BINCS || tag == TRNCS)
              {
                other = blit >> RMSHFT;
                signed int return_value_abs$2;
                return_value_abs$2=abs(other);
                if(return_value_abs$2 >= idx)
                {
                  if(tag == TRNCS)
                  {
                    other2 = *p;
                    signed int return_value_abs$3;
                    return_value_abs$3=abs(other2);
                    if(!(return_value_abs$3 >= idx))
                      goto __CPROVER_DUMP_L14;

                  }

                  else
                    other2 = 0;
                  signed int return_value_lglexport$4;
                  return_value_lglexport$4=lglexport(lgl, lit);
                  trav(state, return_value_lglexport$4, 0);
                  signed int return_value_lglexport$5;
                  return_value_lglexport$5=lglexport(lgl, other);
                  trav(state, return_value_lglexport$5, 0);
                  if(!(other2 == 0))
                  {
                    return_value_lglexport$6=lglexport(lgl, other2);
                    trav(state, return_value_lglexport$6, 0);
                  }

                  trav(state, 0, 0);
                }

              }

            }


          __CPROVER_DUMP_L14:
            ;
          }
        }
      }

    }
    glue = 0;
    for( ; !(glue >= 15); glue = glue + 1)
    {
      lir = lgl->red + (signed long int)glue;
      c = lir->start;
      for( ; !(c >= lir->top); c = p + (signed long int)1)
      {
        p = c;
        if(!(*p >= 134217727))
        {
          other = *p;
          if(!(other == 0))
          {
            signed int return_value_lglexport$7;
            return_value_lglexport$7=lglexport(lgl, other);
            trav(state, return_value_lglexport$7, 0);
            p = p + 1l;
          }

          trav(state, 0, 0);
        }

      }
    }
  }

}

// lgls2fun
// file lglib.c line 10626
static void lgls2fun(signed int mlit, unsigned long int *res)
{
  signed int midx;
  midx=abs(mlit);
  signed int sidx = midx - 2;
  if(!(mlit >= 0))
    lglnegvar2fun(sidx, res);

  else
    lglvar2fun(sidx, res);
}

// lgls2m
// file lglib.c line 10460
static signed int lgls2m(struct LGL *lgl, signed int ilit)
{
  struct AVar *av;
  av=lglavar(lgl, ilit);
  signed int res = av->mark;
  if(res == 0)
  {
    unsigned long int return_value_lglcntstk$1;
    return_value_lglcntstk$1=lglcntstk(&lgl->seen);
    res = (signed int)(return_value_lglcntstk$1 + (unsigned long int)1);
    if(!(1 + lgl->opts->smallvevars.val >= res))
      return 0;

    av->mark = res;
    signed int return_value_abs$2;
    return_value_abs$2=abs(ilit);
    lglpushstk(lgl, &lgl->seen, return_value_abs$2);
    signed int return_value_abs$3;
    return_value_abs$3=abs(ilit);
    lglpushstk(lgl, &lgl->$anon0.elm->m2i, return_value_abs$3);
  }


__CPROVER_DUMP_L2:
  ;
  if(!(ilit >= 0))
    res = -res;

  return res;
}

// lglsat
// file lglib.h line 189
signed int lglsat(struct LGL *lgl)
{
  signed int res;
  struct Lim lim;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsat");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "sat");
    break;
  }
  lglstart(lgl, &lgl->times->all);
  lgl->stats->calls.sat = lgl->stats->calls.sat + 1l;
  do
  {
    signed int return_value_lglmtstk$1;
    return_value_lglmtstk$1=lglmtstk(&lgl->clause);
    if(!(return_value_lglmtstk$1 == 0))
      break;

    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsat");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "clause terminating zero missing");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
  }
  while((_Bool)0);
  lglsetlim(lgl, &lim);
  res=lglisat(lgl, &lim, 0);
  lglstop(lgl);

__CPROVER_DUMP_L9:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglsat(lgl->clone);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsat");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone) = %d differs from %s (lgl) = %d", (const void *)"lglsat", CLONERES, (const void *)"lglsat", res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglschedbasicprobe
// file lglib.c line 8877
static signed int lglschedbasicprobe(struct LGL *lgl, struct Stk *probes, signed int round)
{
  signed int idx;
  signed int res;
  signed int i;
  signed int j;
  signed int donotbasicprobes;
  signed int keepscheduled;
  idx = 2;
  signed int return_value_lglhasbins$3;
  signed int return_value_lglhasbins$2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree$1;
    return_value_lglisfree$1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree$1 == 0))
    {
      if(!(lgl->opts->prbasic.val >= 2))
      {
        return_value_lglhasbins$3=lglhasbins(lgl, idx);
        if(return_value_lglhasbins$3 == 0)
          goto __CPROVER_DUMP_L2;

        return_value_lglhasbins$2=lglhasbins(lgl, -idx);
        if(return_value_lglhasbins$2 == 0)
          goto __CPROVER_DUMP_L2;

      }

      else
      {

      __CPROVER_DUMP_L2:
        ;
        lglpushstk(lgl, probes, idx);
      }
    }

  }
  unsigned long int return_value_lglcntstk$4;
  return_value_lglcntstk$4=lglcntstk(probes);
  res = (signed int)return_value_lglcntstk$4;
  keepscheduled = 0;
  donotbasicprobes = keepscheduled;
  i = 0;
  for( ; !(i >= res); i = i + 1)
  {
    idx=lglpeek(probes, i);
    if(!(idx == 0))
    {
      struct AVar *return_value_lglavar$5;
      return_value_lglavar$5=lglavar(lgl, idx);
      if(!(return_value_lglavar$5->donotbasicprobe == 0u))
        donotbasicprobes = donotbasicprobes + 1;

      else
        keepscheduled = keepscheduled + 1;
    }

  }
  if(keepscheduled == 0)
  {
    i = 0;
    for( ; !(i >= res); i = i + 1)
    {
      idx=lglpeek(probes, i);
      if(!(idx == 0))
      {
        struct AVar *return_value_lglavar$6;
        return_value_lglavar$6=lglavar(lgl, idx);
        return_value_lglavar$6->donotbasicprobe = (unsigned int)0;
        keepscheduled = keepscheduled + 1;
      }

    }
    donotbasicprobes = 0;
  }

  i = 0;
  for( ; !(i >= res); i = i + 1)
  {
    idx=lglpeek(probes, i);
    if(!(idx == 0))
    {
      struct AVar *return_value_lglavar$7;
      return_value_lglavar$7=lglavar(lgl, idx);
      if(!(return_value_lglavar$7->donotbasicprobe == 0u))
        donotbasicprobes = donotbasicprobes + 1;

      else
        keepscheduled = keepscheduled + 1;
    }

  }
  j = 0;
  i = 0;
  signed int tmp_post$8;
  for( ; !(i >= res); i = i + 1)
  {
    idx=lglpeek(probes, i);
    if(!(idx == 0))
    {
      struct AVar *return_value_lglavar$9;
      return_value_lglavar$9=lglavar(lgl, idx);
      if(return_value_lglavar$9->donotbasicprobe == 0u)
      {
        tmp_post$8 = j;
        j = j + 1;
        lglpoke(probes, tmp_post$8, idx);
      }

    }

  }
  res = j;
  lglrststk(probes, res);
  signed int return_value_lglrem$10;
  double return_value_lglpcnt$11;
  if(res == 0)
    lglprt(lgl, 2, "[basicprobe-%d-%d] no potential probes found", lgl->stats->prb.basic.count, round);

  else
    if(donotbasicprobes == 0)
      lglprt(lgl, 2, "[basicprobe-%d-%d] scheduled all %d potential probes", lgl->stats->prb.basic.count, round, res);

    else
    {
      return_value_lglrem$10=lglrem(lgl);
      return_value_lglpcnt$11=lglpcnt((double)res, (double)return_value_lglrem$10);
      lglprt(lgl, 2, "[basicprobe-%d-%d] scheduled %d probes %.0f%%", lgl->stats->prb.basic.count, round, res, return_value_lglpcnt$11);
    }
  return res;
}

// lglsearch
// file lglib.c line 17247
static signed int lglsearch(struct LGL *lgl, struct Lim *lim)
{
  signed int res;
  lgl->searching = (char)1;
  lglstart(lgl, &lgl->times->srch);
  res=lgloop(lgl, lim);
  lgl->searching = (char)0;
  lglstop(lgl);
  return res;
}

// lglsec
// file lglib.c line 4985
double lglsec(struct LGL *lgl)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsec");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglflushtimers(lgl);
  return lgl->times->all;
}

// lglsetallphases
// file lglib.c line 6823
static void lglsetallphases(struct LGL *lgl)
{
  signed int res = 1;
  signed int idx = 2;
  _Bool tmp_if_expr$1;
  signed int return_value_lglisfree$2;
  _Bool tmp_if_expr$4;
  struct AVar *return_value_lglavar$3;
  do
  {
    if(!(res == 0))
      tmp_if_expr$1 = idx < lgl->nvars ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    return_value_lglisfree$2=lglisfree(lgl, idx);
    if(return_value_lglisfree$2 == 0)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_lglavar$3=lglavar(lgl, idx);
      tmp_if_expr$4 = return_value_lglavar$3->phase != 0 ? (_Bool)1 : (_Bool)0;
    }
    res = (signed int)tmp_if_expr$4;
    idx = idx + 1;
  }
  while((_Bool)1);
  lgl->allphaseset = (char)res;
}

// lglsetbinminrhs
// file lglib.c line 13045
static void lglsetbinminrhs(struct LGL *lgl, struct Gat *g)
{
  signed int a;
  a=lglcgrepr(lgl, g->$anon0.lits[(signed long int)0]);
  signed int b;
  b=lglcgrepr(lgl, g->$anon0.lits[(signed long int)1]);
  signed int return_value_abs$5;
  return_value_abs$5=abs(a);
  _Bool tmp_if_expr$7;
  signed int return_value_abs$6;
  if(return_value_abs$5 == 1)
  {
    return_value_abs$6=abs(b);
    tmp_if_expr$7 = return_value_abs$6 == 1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  signed int return_value_abs$4;
  signed int return_value_abs$3;
  signed int return_value_abs$1;
  signed int return_value_abs$2;
  if(tmp_if_expr$7)
    g->minrhs = 0x7fffffff;

  else
  {
    return_value_abs$4=abs(a);
    if(return_value_abs$4 == 1)
      g->minrhs = b;

    else
    {
      return_value_abs$3=abs(b);
      if(return_value_abs$3 == 1)
        g->minrhs = a;

      else
      {
        return_value_abs$1=abs(a);
        return_value_abs$2=abs(b);
        g->minrhs = return_value_abs$1 < return_value_abs$2 ? a : b;
      }
    }
  }
}

// lglsetblklim
// file lglib.c line 11284
static void lglsetblklim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  signed int return_value_lglszpen$2;
  if(!(lgl->opts->blkrtc.val == 0))
  {
    lgl->limits->blk.steps = 0x7fffffffffffffffll;
    lglprt(lgl, 1, "[block-%d] no limit", lgl->stats->elm.count);
  }

  else
  {
    limit = ((signed long int)lgl->opts->blkreleff.val * lgl->stats->visits.search) / (signed long int)1000;
    if(!(limit >= (signed long int)lgl->opts->blkmineff.val))
      limit = (signed long int)lgl->opts->blkmineff.val;

    if(lgl->opts->blkmaxeff.val >= 0)
    {
      if(!((signed long int)lgl->opts->blkmaxeff.val >= limit))
        limit = (signed long int)lgl->opts->blkmaxeff.val;

    }

    signed int return_value_lglszpen$1;
    return_value_lglszpen$1=lglszpen(lgl);
    pen = lgl->limits->blk.pen + return_value_lglszpen$1;
    limit = limit >> pen;
    irrlim = (signed long int)lgl->stats->irr.lits.cur;
    irrlim = irrlim >> lgl->limits->simp.pen;
    if(!(limit >= irrlim))
    {
      limit = irrlim;
      lglprt(lgl, 1, "[block-%d] limit of %lld steps based on %d irredundant literals", lgl->stats->blk.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
    }

    else
    {
      return_value_lglszpen$2=lglszpen(lgl);
      lglprt(lgl, 1, "[block-%d] limit of %lld steps penalty %d = %d + %d", lgl->stats->blk.count, (signed long long int)limit, pen, lgl->limits->blk.pen, return_value_lglszpen$2);
    }
    lgl->limits->blk.steps = lgl->stats->blk.steps + limit;
  }
}

// lglsetccelim
// file lglib.c line 11450
static void lglsetccelim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->ccereleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->ccemineff.val))
    limit = (signed long int)lgl->opts->ccemineff.val;

  if(lgl->opts->ccemaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->ccemaxeff.val >= limit))
      limit = (signed long int)lgl->opts->ccemaxeff.val;

  }

  signed int return_value_lglszpen$1;
  return_value_lglszpen$1=lglszpen(lgl);
  pen = lgl->limits->cce.pen + return_value_lglszpen$1;
  limit = limit >> pen;
  irrlim = (signed long int)lgl->stats->irr.lits.cur;
  irrlim = irrlim >> lgl->limits->simp.pen;
  if(!(lgl->opts->block.val == 0))
  {
    if(lgl->blkrem == 0)
    {
      irrlim = irrlim * (signed long int)2;
      limit = limit * (signed long int)2;
    }

  }

  signed int return_value_lglszpen$2;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    lglprt(lgl, 1, "[cce-%d] limit of %lld steps based on %d irredundant literals", lgl->stats->cce.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    return_value_lglszpen$2=lglszpen(lgl);
    lglprt(lgl, 1, "[cce-%d] limit of %lld steps penalty %d = %d + %d", lgl->stats->cce.count, (signed long long int)limit, pen, lgl->limits->cce.pen, return_value_lglszpen$2);
  }
  lgl->limits->cce.steps = lgl->stats->cce.steps + limit;
}

// lglsetcgrclsrlim
// file lglib.c line 13759
static void lglsetcgrclsrlim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->cgreleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->cgrmineff.val))
    limit = (signed long int)lgl->opts->cgrmineff.val;

  if(lgl->opts->cgrmaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->cgrmaxeff.val >= limit))
      limit = (signed long int)lgl->opts->cgrmaxeff.val;

  }

  signed int return_value_lglszpen$1;
  return_value_lglszpen$1=lglszpen(lgl);
  pen = lgl->limits->cgr.pen + return_value_lglszpen$1;
  limit = limit >> pen;
  irrlim = (signed long int)(lgl->stats->irr.lits.cur / 2);
  irrlim = irrlim >> lgl->limits->simp.pen;
  signed int return_value_lglszpen$2;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    lglprt(lgl, 1, "[cgrclsr-%d] limit %lld based on %d irredundant literals", lgl->stats->cgr.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    return_value_lglszpen$2=lglszpen(lgl);
    lglprt(lgl, 1, "[cgrclsr-%d] limit %lld penalty %d = %d + %d", lgl->stats->cgr.count, (signed long long int)limit, pen, lgl->limits->cgr.pen, return_value_lglszpen$2);
  }
  lgl->limits->cgr.esteps = lgl->stats->cgr.esteps + limit;
  lgl->limits->cgr.csteps = lgl->stats->cgr.csteps + (signed long int)2 * limit;
}

// lglsetclifflim
// file lglib.c line 12037
static void lglsetclifflim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->cliffreleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->cliffmineff.val))
    limit = (signed long int)lgl->opts->cliffmineff.val;

  if(lgl->opts->cliffmaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->cliffmaxeff.val >= limit))
      limit = (signed long int)lgl->opts->cliffmaxeff.val;

  }

  signed int return_value_lglszpen$1;
  return_value_lglszpen$1=lglszpen(lgl);
  pen = lgl->limits->cliff.pen + return_value_lglszpen$1;
  limit = limit >> pen;
  irrlim = (signed long int)(2 * lgl->stats->irr.lits.cur);
  irrlim = irrlim >> lgl->limits->simp.pen;
  signed int return_value_lglszpen$2;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    lglprt(lgl, 1, "[cliff-%d] limit of %lld steps based on %d irredundant literals", lgl->stats->cliff.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    return_value_lglszpen$2=lglszpen(lgl);
    lglprt(lgl, 1, "[cliff-%d] limit of %lld steps penalty %d = %d + %d", lgl->stats->cliff.count, (signed long long int)limit, pen, lgl->limits->cliff.pen, return_value_lglszpen$2);
  }
  lgl->limits->cliff.steps = lgl->stats->cliff.steps + limit;
}

// lglsetconsumedunits
// file lglib.c line 1360
void lglsetconsumedunits(struct LGL *lgl, void (*fun)(void *, signed int), void *state)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetconsumedunits");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->units.consumed.fun = fun;
  lgl->cbs->units.consumed.state = state;
}

// lglsetconsumeunits
// file lglib.c line 1337
void lglsetconsumeunits(struct LGL *lgl, void (*fun)(void *, signed int **, signed int **), void *state)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetconsumeunits");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->units.consume.fun = fun;
  lgl->cbs->units.consume.state = state;
}

// lglsetdom
// file lglib.c line 2582
static void lglsetdom(struct LGL *lgl, signed int lit, signed int dom)
{
  signed int return_value_lglulit$1;
  return_value_lglulit$1=lglulit(lit);
  lgl->doms[(signed long int)return_value_lglulit$1] = dom;

__CPROVER_DUMP_L1:
  ;
}

// lglsetdonotesched
// file lglib.c line 11356
static void lglsetdonotesched(struct LGL *lgl, signed int completed)
{
  struct AVar *av;
  struct EVar *ev;
  signed int idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    av=lglavar(lgl, idx);
    ev=lglevar(lgl, idx);
    if(!(lgl->eliminating == 0))
    {
      if(!(completed == 0))
        av->donotelm = (unsigned int)0;

      else
        if(!(ev->pos >= 0))
          av->donotelm = (unsigned int)1;

    }

    if(!(lgl->blocking == 0))
    {
      if(!(completed == 0))
        av->donotblk = (unsigned int)0;

      else
        if(!(ev->pos >= 0))
          av->donotblk = (unsigned int)1;

    }

    if(!(lgl->cceing == 0))
    {
      if(!(completed == 0))
        av->donotcce = (unsigned int)0;

      else
        if(!(ev->pos >= 0))
          av->donotcce = (unsigned int)1;

    }

  }
}

// lglsetelmlim
// file lglib.c line 12095
static void lglsetelmlim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  signed int return_value_lglszpen$2;
  if(!(lgl->opts->elmrtc.val == 0))
  {
    lgl->limits->elm.steps = 0x7fffffffffffffffll;
    lglprt(lgl, 1, "[elim-%d] no limit", lgl->stats->elm.count);
  }

  else
  {
    limit = ((signed long int)lgl->opts->elmreleff.val * lgl->stats->visits.search) / (signed long int)1000;
    if(!(limit >= (signed long int)lgl->opts->elmineff.val))
      limit = (signed long int)lgl->opts->elmineff.val;

    if(lgl->opts->elmaxeff.val >= 0)
    {
      if(!((signed long int)lgl->opts->elmaxeff.val >= limit))
        limit = (signed long int)lgl->opts->elmaxeff.val;

    }

    signed int return_value_lglszpen$1;
    return_value_lglszpen$1=lglszpen(lgl);
    pen = lgl->limits->elm.pen + return_value_lglszpen$1;
    limit = limit >> pen;
    irrlim = (signed long int)lgl->stats->irr.lits.cur;
    irrlim = irrlim >> lgl->limits->simp.pen;
    if(!(limit >= irrlim))
    {
      limit = irrlim;
      lglprt(lgl, 1, "[elim-%d] limit of %lld steps based on %d irredundant literals", lgl->stats->elm.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
    }

    else
    {
      return_value_lglszpen$2=lglszpen(lgl);
      lglprt(lgl, 1, "[elim-%d] limit of %lld steps penalty %d = %d + %d", lgl->stats->elm.count, (signed long long int)limit, pen, lgl->limits->elm.pen, return_value_lglszpen$2);
    }
    lgl->limits->elm.steps = lgl->stats->elm.steps + limit;
  }
}

// lglseterm
// file lglib.h line 295
void lglseterm(struct LGL *lgl, signed int (*fun)(void *), void *state)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglseterm");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->term.fun = fun;
  lgl->cbs->term.state = state;
}

// lglseternreslim
// file lglib.c line 14656
static void lglseternreslim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  signed int return_value_lglszpen$2;
  if(!(lgl->opts->ternresrtc.val == 0))
  {
    limit = 0x7fffffffffffffffll;
    lglprt(lgl, 1, "[ternres-%d] no limit (run to completion)", lgl->stats->trnr.count);
  }

  else
  {
    limit = ((signed long int)lgl->opts->trnreleff.val * lgl->stats->visits.search) / (signed long int)1000;
    if(!(limit >= (signed long int)lgl->opts->trnrmineff.val))
      limit = (signed long int)lgl->opts->trnrmineff.val;

    if(lgl->opts->trnrmaxeff.val >= 0)
    {
      if(!((signed long int)lgl->opts->trnrmaxeff.val >= limit))
        limit = (signed long int)lgl->opts->trnrmaxeff.val;

    }

    signed int return_value_lglszpen$1;
    return_value_lglszpen$1=lglszpen(lgl);
    pen = lgl->limits->trnr.pen + return_value_lglszpen$1;
    limit = limit >> pen;
    irrlim = (signed long int)(4 * lgl->stats->irr.lits.cur);
    irrlim = irrlim >> lgl->limits->simp.pen;
    if(!(limit >= irrlim))
    {
      limit = irrlim;
      lglprt(lgl, 1, "[ternres-%d] limit %lld based on %d irredundant literals", lgl->stats->trnr.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
    }

    else
    {
      return_value_lglszpen$2=lglszpen(lgl);
      lglprt(lgl, 1, "[ternres-%d] limit %lld with penalty %d = %d + %d", lgl->stats->trnr.count, (signed long long int)limit, pen, lgl->limits->trnr.pen, return_value_lglszpen$2);
    }
  }
  lgl->limits->trnr.steps = lgl->stats->trnr.steps + limit;
}

// lglsetgausslim
// file lglib.c line 16781
static void lglsetgausslim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->gaussreleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->gaussmineff.val))
    limit = (signed long int)lgl->opts->gaussmineff.val;

  if(lgl->opts->gaussmaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->gaussmaxeff.val >= limit))
      limit = (signed long int)lgl->opts->gaussmaxeff.val;

  }

  signed int return_value_lglszpen$1;
  return_value_lglszpen$1=lglszpen(lgl);
  pen = lgl->limits->gauss.pen + return_value_lglszpen$1;
  limit = limit >> pen;
  irrlim = (signed long int)(lgl->stats->irr.lits.cur / 2);
  irrlim = irrlim >> lgl->limits->simp.pen;
  signed int return_value_lglszpen$2;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    lglprt(lgl, 1, "[gauss-%d] limit %lld based on %d irredundant literals", lgl->stats->gauss.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    return_value_lglszpen$2=lglszpen(lgl);
    lglprt(lgl, 1, "[gauss-%d] limit %lld penalty %d = %d + %d", lgl->stats->gauss.count, (signed long long int)limit, pen, lgl->limits->gauss.pen, return_value_lglszpen$2);
  }
  lgl->limits->gauss.steps.extr = lgl->stats->gauss.steps.extr + limit;
  lgl->limits->gauss.steps.elim = lgl->stats->gauss.steps.elim + limit;
}

// lglsetid
// file lglib.h line 134
void lglsetid(struct LGL *lgl, signed int tid, signed int tids)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetid");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(tid >= 0))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetid");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "negative id");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  while(tid >= tids)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetid");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "id exceed number of ids");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lgl->tid = tid;
  lgl->tids = tids;
}

// lglsetime
// file lglib.h line 306
void lglsetime(struct LGL *lgl, double (*time)(void))
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetime");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->getime = time;
}

// lglsetiteminrhs
// file lglib.c line 13069
static void lglsetiteminrhs(struct LGL *lgl, struct Gat *g)
{
  g->minrhs=lglcgrepr(lgl, g->$anon0.$anon1.cond);
}

// lglsetjwhbias
// file lglib.c line 6809
static signed int lglsetjwhbias(struct LGL *lgl, signed int idx)
{
  signed long int pos;
  signed int return_value_lglulit$1;
  return_value_lglulit$1=lglulit(idx);
  pos = lgl->jwh[(signed long int)return_value_lglulit$1];
  signed long int neg;
  signed int return_value_lglulit$2;
  return_value_lglulit$2=lglulit(-idx);
  neg = lgl->jwh[(signed long int)return_value_lglulit$2];
  struct AVar *av;
  av=lglavar(lgl, idx);
  signed int bias;
  if(!(av->phase == 0))
    return (signed int)av->phase;

  else
  {
    bias = pos > neg ? 1 : -1;
    if((signed int)av->bias == bias)
      return bias;

    else
    {
      av->bias = bias;
      lgl->stats->phase.set = lgl->stats->phase.set + 1l;
      if(!(neg >= pos))
        lgl->stats->phase.pos = lgl->stats->phase.pos + 1l;

      else
        lgl->stats->phase.neg = lgl->stats->phase.neg + 1l;
      return bias;
    }
  }
}

// lglsetlim
// file lglib.c line 17705
static void lglsetlim(struct LGL *lgl, struct Lim *lim)
{
  signed long int clim;
  signed long int confs;
  signed long int delay;
  signed long int delayed;
  lim->decs = (signed long int)-1;
  clim = (signed long int)lgl->opts->clim.val;
  if(!(clim >= 0l))
  {
    lim->confs = (signed long int)-1;
    lglprt(lgl, 1, "[limits] no conflict limit");
  }

  else
  {
    confs = lgl->stats->confs;
    lim->confs = confs >= 0x7fffffffffffffffll - clim ? 0x7fffffffffffffffll : confs + clim;
    lglprt(lgl, 1, "[limits] conflict limit %lld after %lld conflicts", (signed long long int)lim->confs, (signed long long int)confs);
  }
  delay = (signed long int)lgl->opts->simpdelay.val;
  if(delay >= 1l)
  {
    delayed = lgl->stats->confs + delay;
    if(!(lgl->limits->simp.confs >= delayed))
    {
      lgl->limits->simp.confs = delayed;
      lglprt(lgl, 1, "[limits] simplification delayed by %lld to %lld conflicts", (signed long long int)delay, (signed long long int)lgl->limits->simp.confs);
    }

    else
      lglprt(lgl, 1, "[limits] simplification conflict limit already exceeds delay");
  }

  else
    lglprt(lgl, 1, "[limits] simplification not delayed since 'simpdelay == 0'");
}

// lglsetlockeq
// file lglib.c line 1346
void lglsetlockeq(struct LGL *lgl, signed int * (*fun)(void *), void *state)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetlockeq");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->eqs.lock.fun = fun;
  lgl->cbs->eqs.lock.state = state;
}

// lglsetlrgminrhs
// file lglib.c line 13056
static void lglsetlrgminrhs(struct LGL *lgl, struct Gat *g)
{
  signed int *p;
  signed int other;
  g->minrhs = 0x7fffffff;
  p = g->$anon0.$anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    signed int return_value_abs$1;
    return_value_abs$1=abs(other);
    signed int return_value_abs$2;
    return_value_abs$2=abs(g->lhs);
    if(!(return_value_abs$1 == return_value_abs$2))
    {
      other=lglcgrepr(lgl, other);
      signed int return_value_abs$3;
      return_value_abs$3=abs(other);
      if(!(return_value_abs$3 == 1))
      {
        signed int return_value_abs$4;
        return_value_abs$4=abs(g->minrhs);
        signed int return_value_abs$5;
        return_value_abs$5=abs(other);
        if(!(return_value_abs$5 >= return_value_abs$4))
          g->minrhs = other;

      }

    }

    p = p + 1l;
  }
  while((_Bool)1);
}

// lglsetminrhs
// file lglib.c line 13074
static void lglsetminrhs(struct LGL *lgl, struct Gat *g)
{
  if((signed int)g->tag == ITETAG)
    lglsetiteminrhs(lgl, g);

  else
    if((signed int)g->size == 2)
      lglsetbinminrhs(lgl, g);

    else
      lglsetlrgminrhs(lgl, g);
  if(!((signed int)g->tag == ANDTAG))
  {
    if(!(g->minrhs >= 0))
      g->minrhs = -g->minrhs;

  }

}

// lglsetmsglock
// file lglib.h line 305
void lglsetmsglock(struct LGL *lgl, void (*lock)(void *), void (*unlock)(void *), void *state)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetmsglock");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->msglock.lock = lock;
  lgl->cbs->msglock.unlock = unlock;
  lgl->cbs->msglock.state = state;
}

// lglsetopt
// file lglib.h line 118
void lglsetopt(struct LGL *lgl, const char *opt, signed int val)
{
  signed int oldval;
  struct Opt *o = &lgl->opts->beforefirst + (signed long int)1;
  signed int tmp_statement_expression$1;
  for( ; &lgl->opts->afterlast + -1l >= o; o = o + 1l)
  {
    if(opt[1l] == 0)
    {
      if(o->shrt == *opt)
        break;

    }

    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$2;
    return_value___builtin_strcmp$2=__builtin_strcmp(o->lng, opt);
    tmp_statement_expression$1 = return_value___builtin_strcmp$2;
    if(tmp_statement_expression$1 == 0)
      break;

  }
  if(&lgl->opts->afterlast + -1l >= o)
  {
    if(!(val >= o->min))
      val = o->min;

    if(!(o->max >= val))
      val = o->max;

    oldval = o->val;
    o->val = val;
    if(o == &lgl->opts->flipping)
    {
      if(oldval == 0)
      {
        lgl->notflipped = 0;
        lgl->flipping = lgl->notflipped;
      }

    }

    if(o == &lgl->opts->plain)
    {
      if(oldval == 0 && val >= 1)
        lglsetplain(lgl, 1);

      if(val == 0 && !(oldval == 0))
        lglsetplain(lgl, 0);

    }

    if(o == &lgl->opts->phase)
    {
      if(!(val == oldval))
        lgl->flushphases = (char)1;

    }

    if((signed int)lgl->state == UNUSED)
    {

    __CPROVER_DUMP_L11:
      ;
      do
        lgl->state = (enum State)OPTSET;
      while((_Bool)0);
    }

    while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
    {
      lgltrapi(lgl, "option %s %d", opt, val);
      break;
    }
    if(!(lgl->clone == ((struct LGL *)NULL)))
      lglsetopt(lgl->clone, opt, val);

  }

}

// lglsetout
// file lglib.h line 112
void lglsetout(struct LGL *lgl, struct _IO_FILE *out)
{
  lgl->out = out;
}

// lglsetphase
// file lglib.c line 3899
void lglsetphase(struct LGL *lgl, signed int elit)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetphase");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(elit == 0)
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetphase");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "invalid literal argument");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "setphase %d", elit);
    break;
  }
  if(!(elit >= 0))
    lglesetphase(lgl, -elit, -1);

  else
    lglesetphase(lgl, elit, 1);
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglsetphase(lgl->clone, elit);

}

// lglsetphases
// file lglib.c line 17463
void lglsetphases(struct LGL *lgl)
{
  signed int elit;
  signed int phase;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetphases");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "setphases");
    break;
  }

__CPROVER_DUMP_L5:
  ;
  do
  {
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetphases");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

    while((96 & (signed int)lgl->state) == 0)
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetphases");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "!(%s)", (const void *)"SATISFIED | EXTENDED");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
  }
  while((_Bool)0);
  if((EXTENDED & (signed int)lgl->state) == 0)
    lglextend(lgl);

  elit = 1;
  for( ; lgl->maxext >= elit; elit = elit + 1)
  {
    phase=lglederef(lgl, elit);
    lglesetphase(lgl, elit, phase);
  }
  if(!(lgl->clone == ((struct LGL *)NULL)))
    lglsetphases(lgl->clone);

}

// lglsetplain
// file lglib.c line 1652
static void lglsetplain(struct LGL *lgl, signed int val)
{
  lgl->opts->block.val = (signed int)!(val != 0);
  lgl->opts->card.val = (signed int)!(val != 0);
  lgl->opts->cce.val = (signed int)!(val != 0);
  lgl->opts->cliff.val = (signed int)!(val != 0);
  lgl->opts->cgrclsr.val = (signed int)!(val != 0);
  lgl->opts->decompose.val = (signed int)!(val != 0);
  lgl->opts->elim.val = (signed int)!(val != 0);
  lgl->opts->gauss.val = (signed int)!(val != 0);
  lgl->opts->lift.val = (signed int)!(val != 0);
  lgl->opts->probe.val = (signed int)!(val != 0);
  lgl->opts->ternres.val = (signed int)!(val != 0);
  lgl->opts->transred.val = (signed int)!(val != 0);
  lgl->opts->unhide.val = (signed int)!(val != 0);
  lglprt(lgl, 1, "[plain] plain solving switched %s", val != 0 ? "on" : "off");
}

// lglsetprbasiclim
// file lglib.c line 8941
static void lglsetprbasiclim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->prbasicreleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->prbasicmineff.val))
    limit = (signed long int)lgl->opts->prbasicmineff.val;

  if(lgl->opts->prbasicmaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->prbasicmaxeff.val >= limit))
      limit = (signed long int)lgl->opts->prbasicmaxeff.val;

  }

  signed int return_value_lglszpen$1;
  return_value_lglszpen$1=lglszpen(lgl);
  pen = lgl->limits->prb.pen.basic + return_value_lglszpen$1;
  limit = limit >> pen;
  irrlim = (signed long int)(lgl->stats->irr.lits.cur / 2);
  irrlim = irrlim >> lgl->limits->simp.pen;
  signed int return_value_lglszpen$2;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    lglprt(lgl, 1, "[basicprobe-%d] limit %lld based on %d irredundant litearls", lgl->stats->prb.basic.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    return_value_lglszpen$2=lglszpen(lgl);
    lglprt(lgl, 1, "[basicprobe-%d] limit %lld penalty %d = %d + %d", lgl->stats->prb.basic.count, (signed long long int)limit, pen, lgl->limits->prb.pen.basic, return_value_lglszpen$2);
  }
  lgl->limits->prb.steps = lgl->stats->prb.basic.steps + limit;
}

// lglsetprefix
// file lglib.h line 113
void lglsetprefix(struct LGL *lgl, const char *prefix)
{
  lgldelstr(lgl, lgl->prefix);
  lgl->prefix=lglstrdup(lgl, prefix);
}

// lglsetproduceunit
// file lglib.c line 1330
void lglsetproduceunit(struct LGL *lgl, void (*fun)(void *, signed int), void *state)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetproduceunit");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->units.produce.fun = fun;
  lgl->cbs->units.produce.state = state;
}

// lglsetrdlim
// file lglib.c line 14886
static void lglsetrdlim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->trdreleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->trdmineff.val))
    limit = (signed long int)lgl->opts->trdmineff.val;

  if(lgl->opts->trdmaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->trdmaxeff.val >= limit))
      limit = (signed long int)lgl->opts->trdmaxeff.val;

  }

  signed int return_value_lglszpen$1;
  return_value_lglszpen$1=lglszpen(lgl);
  pen = lgl->limits->trd.pen + return_value_lglszpen$1;
  limit = limit >> pen;
  irrlim = (signed long int)lgl->stats->irr.lits.cur;
  irrlim = irrlim >> lgl->limits->simp.pen;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int return_value_lglszpen$4;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    tmp_post$2 = lgl->stats->trd.count;
    lgl->stats->trd.count = lgl->stats->trd.count + 1;
    lglprt(lgl, 1, "[transred-%d] limit %lld based on %d irredundant literals", tmp_post$2, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    tmp_post$3 = lgl->stats->trd.count;
    lgl->stats->trd.count = lgl->stats->trd.count + 1;
    return_value_lglszpen$4=lglszpen(lgl);
    lglprt(lgl, 1, "[transred-%d] limit %lld with penalty %d = %d + %d", tmp_post$3, (signed long long int)limit, pen, lgl->limits->trd.pen, return_value_lglszpen$4);
  }
  lgl->limits->trd.steps = lgl->stats->trd.steps + limit;
}

// lglsetunhdlim
// file lglib.c line 16124
static void lglsetunhdlim(struct LGL *lgl)
{
  signed long int limit;
  signed long int irrlim;
  signed int pen;
  limit = ((signed long int)lgl->opts->unhdreleff.val * lgl->stats->visits.search) / (signed long int)1000;
  if(!(limit >= (signed long int)lgl->opts->unhdmineff.val))
    limit = (signed long int)lgl->opts->unhdmineff.val;

  if(lgl->opts->unhdmaxeff.val >= 0)
  {
    if(!((signed long int)lgl->opts->unhdmaxeff.val >= limit))
      limit = (signed long int)lgl->opts->unhdmaxeff.val;

  }

  signed int return_value_lglszpen$1;
  return_value_lglszpen$1=lglszpen(lgl);
  pen = lgl->limits->unhd.pen + return_value_lglszpen$1;
  limit = limit >> pen;
  irrlim = (signed long int)lgl->stats->irr.lits.cur;
  irrlim = irrlim >> lgl->limits->simp.pen;
  signed int return_value_lglszpen$2;
  if(!(limit >= irrlim))
  {
    limit = irrlim;
    lglprt(lgl, 1, "[unhide-%d] limit %lld based on %d irredundant literals", lgl->stats->unhd.count, (signed long long int)limit, lgl->stats->irr.lits.cur);
  }

  else
  {
    return_value_lglszpen$2=lglszpen(lgl);
    lglprt(lgl, 1, "[unhide-%d] limit %lld with penalty %d = %d + %d", lgl->stats->unhd.count, (signed long long int)limit, pen, lgl->limits->unhd.pen, return_value_lglszpen$2);
  }
  lgl->limits->unhd.steps = lgl->stats->unhd.steps + limit;
}

// lglsetunlockeq
// file lglib.c line 1353
void lglsetunlockeq(struct LGL *lgl, void (*fun)(void *, signed int, signed int), void *state)
{

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsetunlockeq");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglinitcbs(lgl);
  lgl->cbs->eqs.unlock.fun = fun;
  lgl->cbs->eqs.unlock.state = state;
}

// lglsetup
// file lglib.c line 17294
static void lglsetup(struct LGL *lgl)
{
  unsigned int return_value_lglrand$1;
  if(!((signed int)lgl->state == RESET))
  {
    lgl->limits->dfg.pshwchs = lgl->stats->pshwchs + (signed long int)lgl->opts->defragint.val;
    lgl->limits->reduce.inner = lgl->opts->redlinit.val;
    lglboundredl(lgl);
    lgl->limits->reduce.outer = 2 * lgl->limits->reduce.inner;
    lgl->limits->blk.irrprgss = (signed long int)-1;
    lgl->limits->elm.irrprgss = (signed long int)-1;
    lgl->limits->simp.prgss = (signed long int)-1;
    lgl->limits->term.steps = (signed long int)-1;
    lgl->limits->flipint = lgl->opts->flipint.val;
    lgl->phaseneg = lgl->opts->phaseneginit.val;
    lglincrestartl(lgl, 0);
    lgl->rng.w = (unsigned int)lgl->opts->seed.val;
    lgl->rng.z = ~lgl->rng.w;
    lgl->rng.w = lgl->rng.w << 1;
    lgl->rng.z = lgl->rng.z << 1;
    lgl->rng.w = lgl->rng.w + (unsigned int)1;
    lgl->rng.z = lgl->rng.z + (unsigned int)1;
    lgl->rng.w = lgl->rng.w * 2019164533u;
    lgl->rng.z = lgl->rng.z * 1000632769u;
    lgl->limits->randec = lgl->limits->randec + (signed long int)(lgl->opts->randecint.val / 2);
    return_value_lglrand$1=lglrand(lgl);
    lgl->limits->randec = lgl->limits->randec + (signed long int)(return_value_lglrand$1 % (unsigned int)lgl->opts->randecint.val);
    lglchkenv(lgl);
  }

  do
  {

  DONE:
    ;
    (void)0;

  __CPROVER_DUMP_L2:
    ;
    lgl->state = (enum State)READY;
  }
  while((_Bool)0);
}

// lglsgn
// file lglib.c line 2459
static signed int lglsgn(signed int lit)
{
  return lit < 0 ? -1 : 1;
}

// lglshrinkhts
// file lglib.c line 3029
static void lglshrinkhts(struct LGL *lgl, struct HTS *hts, signed int newcount)
{
  signed int *p;
  signed int i;
  signed int oldcount = hts->count;
  if(!(newcount == oldcount))
  {
    p=lglhts2wchs(lgl, hts);
    i = newcount;
    for( ; !(i >= oldcount); i = i + 1)
      p[(signed long int)i] = 0;
    hts->count = newcount;
    if(newcount == 0)
    {
      lglfreewch(lgl, hts->offset, oldcount);
      hts->offset = 0;
    }

  }

}

// lglshrstk
// file lglib.c line 1415
static void lglshrstk(struct LGL *lgl, struct Stk *s, signed int new_size)
{
  unsigned long int old_size;
  unsigned long int count;
  count=lglcntstk(s);
  if(new_size >= 1)
  {
    old_size=lglszstk(s);
    do
    {
      void *return_value_lglrsz$1;
      return_value_lglrsz$1=lglrsz(lgl, (void *)s->start, old_size * sizeof(signed int) /*4ul*/ , (unsigned long int)new_size * sizeof(signed int) /*4ul*/ );
      s->start = (signed int *)return_value_lglrsz$1;
    }
    while((_Bool)0);
    s->top = s->start + (signed long int)count;
    s->end = s->start + (signed long int)new_size;
  }

  else
    lglrelstk(lgl, s);
}

// lglsig
// file lglib.c line 9301
static unsigned int lglsig(signed int lit)
{
  unsigned int ulit;
  signed int return_value_lglulit$1;
  return_value_lglulit$1=lglulit(lit);
  ulit = (unsigned int)return_value_lglulit$1;
  unsigned int res;
  ulit = ulit - (unsigned int)2;
  res = 1u << (ulit & (unsigned int)31);
  return res;
}

// lglsignedmark
// file lglib.c line 7205
static void lglsignedmark(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int bit = 1 << (signed int)(lit < 0);
  if((av->mark & bit) == 0)
    av->mark = av->mark | bit;

}

// lglsignedmark2
// file lglib.c line 11486
static void lglsignedmark2(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int bit = 1 << 2 + (signed int)(lit < 0);
  if((av->mark & bit) == 0)
    av->mark = av->mark | bit;

}

// lglsignedmarked
// file lglib.c line 7224
static signed int lglsignedmarked(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int bit = 1 << (signed int)(lit < 0);
  return av->mark & bit;
}

// lglsignedmarked2
// file lglib.c line 11500
static signed int lglsignedmarked2(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int bit = 1 << 2 + (signed int)(lit < 0);
  return av->mark & bit;
}

// lglsignedmarknpushseen
// file lglib.c line 7219
static void lglsignedmarknpushseen(struct LGL *lgl, signed int lit)
{
  lglsignedmark(lgl, lit);
  lglpushstk(lgl, &lgl->seen, lit);
}

// lglsignedunmark
// file lglib.c line 7212
static void lglsignedunmark(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int bit = 1 << (signed int)(lit < 0);
  if(!((av->mark & bit) == 0))
    av->mark = av->mark & ~bit;

}

// lglsignedunmark2
// file lglib.c line 11493
static void lglsignedunmark2(struct LGL *lgl, signed int lit)
{
  struct AVar *av;
  av=lglavar(lgl, lit);
  signed int bit = 1 << 2 + (signed int)(lit < 0);
  if(!((av->mark & bit) == 0))
    av->mark = av->mark & ~bit;

}

// lglsimp
// file lglib.c line 17875
signed int lglsimp(struct LGL *lgl, signed int iterations)
{
  struct Lim lim;
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsimp");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "simp %d", iterations);
    break;
  }
  while(!(iterations >= 0))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsimp");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "negative number of simplification iterations");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  do
  {
    signed int return_value_lglmtstk$1;
    return_value_lglmtstk$1=lglmtstk(&lgl->clause);
    if(!(return_value_lglmtstk$1 == 0))
      break;

    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsimp");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "clause terminating zero missing");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
  }
  while((_Bool)0);
  lglstart(lgl, &lgl->times->all);
  lgl->stats->calls.simp = lgl->stats->calls.simp + 1l;
  do
    memset((void *)&lim, 0, sizeof(struct Lim) /*16ul*/ );
  while((_Bool)0);
  lim.decs = lgl->stats->decisions;
  res=lglisat(lgl, &lim, iterations);
  lglstop(lgl);

__CPROVER_DUMP_L11:
  ;
  do
  {
    if(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
      lgltrapi(lgl, "return %d", res);

    do
    {
      signed int CLONERES;
      if(lgl->clone == ((struct LGL *)NULL))
        break;

      CLONERES=lglsimp(lgl->clone, iterations);
      while(!(CLONERES == res))
      {
        fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglsimp");
        if(!(lgl == ((struct LGL *)NULL)))
        {
          if(lgl->tid >= 0)
            fprintf(stderr, " (tid %d)", lgl->tid);

        }

        fputs(": ", stderr);
        fprintf(stderr, "%s (lgl->clone, %d) = %d differs from %s (lgl, %d) = %d", (const void *)"lglsimp", iterations, CLONERES, (const void *)"lglsimp", iterations, res);
        fputc(10, stderr);
        fflush(stderr);
        lglabort(lgl);
        exit(1);
        break;
      }
      while(!(lgl->clone == ((struct LGL *)NULL)))
      {
        lglchkclonesamestats(lgl);
        break;
      }
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  return res;
}

// lglsimpand
// file lglib.c line 13437
static signed int lglsimpand(struct LGL *lgl, struct Gat *g)
{
  signed int return_value_lglsimpbinand$1;
  signed int return_value_lglsimplrgand$2;
  if((signed int)g->size == 2)
  {
    return_value_lglsimpbinand$1=lglsimpbinand(lgl, g);
    return return_value_lglsimpbinand$1;
  }

  else
  {
    return_value_lglsimplrgand$2=lglsimplrgand(lgl, g);
    return return_value_lglsimplrgand$2;
  }
}

// lglsimpbinand
// file lglib.c line 13334
static signed int lglsimpbinand(struct LGL *lgl, struct Gat *g)
{
  signed int lhs;
  signed int a;
  signed int b;
  signed int res;
  signed int conflict;
  lhs=lglcgrepr(lgl, g->lhs);
  a=lglcgrepr(lgl, -g->$anon0.lits[(signed long int)0]);
  b=lglcgrepr(lgl, -g->$anon0.lits[(signed long int)1]);
  res = 0;
  conflict = res;
  signed int return_value_lglcgunit$1;
  signed int return_value_lglcgunit$2;
  if(a == 1 && b == 1)
  {
    if(lhs == 1)
      return 0;

    res = 1;

  __CPROVER_DUMP_L2:
    ;
    if(lhs == -1)
      conflict = 1;

    else
    {
      return_value_lglcgunit$1=lglcgunit(lgl, lhs);
      conflict = (signed int)!(return_value_lglcgunit$1 != 0);
    }
  }

  else
    if(a == -1 || a == -b || b == -1)
    {
      if(lhs == -1)
        return 0;

      res = 1;

    __CPROVER_DUMP_L7:
      ;
      if(lhs == 1)
        conflict = 1;

      else
      {
        return_value_lglcgunit$2=lglcgunit(lgl, -lhs);
        conflict = (signed int)!(return_value_lglcgunit$2 != 0);
      }
    }

    else
    {
      if(b == 1)
        do
        {
          signed int TMP = a;
          a = b;
          b = TMP;
        }
        while((_Bool)0);

      if(a == 1)
      {
        if(lhs == b)
          return 0;

        res = 1;

      __CPROVER_DUMP_L14:
        ;
        if(lhs == -b)
          conflict = 1;

        else
          lglcgmerge(lgl, lhs, b);
      }

    }
  if(!(res == 0))
  {
    lgl->$anon0.cgr->simplified.all = lgl->$anon0.cgr->simplified.all + 1;
    lgl->stats->cgr.simplified.all = lgl->stats->cgr.simplified.all + 1;
    lgl->$anon0.cgr->simplified.and = lgl->$anon0.cgr->simplified.and + 1;
    lgl->stats->cgr.simplified.and = lgl->stats->cgr.simplified.and + 1;
  }

  if(!(conflict == 0))
  {

  __CPROVER_DUMP_L18:
    ;
    lgl->mt = 1;
  }

  return res;
}

// lglsimpbinxor
// file lglib.c line 13443
static signed int lglsimpbinxor(struct LGL *lgl, struct Gat *g)
{
  signed int res;
  signed int conflict;
  signed int lhs;
  signed int rhs;
  signed int a;
  signed int b;
  signed int return_value_lglcgrepr$1;
  return_value_lglcgrepr$1=lglcgrepr(lgl, g->lhs);
  lhs = -return_value_lglcgrepr$1;
  a=lglcgrepr(lgl, g->$anon0.lits[(signed long int)0]);
  b=lglcgrepr(lgl, g->$anon0.lits[(signed long int)1]);
  res = 0;
  conflict = res;
  rhs = conflict;
  if(a == b)
    rhs = -1;

  else
    if(a == -b)
      rhs = 1;

    else
      if(a == 1)
        rhs = -b;

      else
        if(a == -1)
          rhs = b;

        else
          if(b == 1)
            rhs = -a;

          else
            if(b == -1)
              rhs = a;

            else
              if(lhs == 1)
              {
                lhs = a;
                rhs = -b;
              }

              else
                if(lhs == -1)
                {
                  lhs = a;
                  rhs = b;
                }

  if(!(rhs == 0) && !(rhs == lhs))
    res = 1;

  if(!(res == 0))
  {

  __CPROVER_DUMP_L10:
    ;
    lgl->$anon0.cgr->simplified.all = lgl->$anon0.cgr->simplified.all + 1;
    lgl->stats->cgr.simplified.all = lgl->stats->cgr.simplified.all + 1;
    lgl->$anon0.cgr->simplified.xor = lgl->$anon0.cgr->simplified.xor + 1;
    lgl->stats->cgr.simplified.xor = lgl->stats->cgr.simplified.xor + 1;
    conflict=lglcgmergelhsrhs(lgl, lhs, rhs);
  }

  if(!(conflict == 0))
  {

  __CPROVER_DUMP_L12:
    ;
    lgl->mt = 1;
  }

  return res;
}

// lglsimpcls
// file lglib.c line 2969
static signed int lglsimpcls(struct LGL *lgl)
{
  signed int *p;
  signed int *q = lgl->clause.start;
  signed int lit;
  signed int tmp;
  signed int mark;
  p = lgl->clause.start;
  signed int *tmp_post$1;
  do
  {
    lit = *p;
    if(lit == 0)
      break;

    tmp=lglcval(lgl, lit);
    if(tmp == 1)
    {

    __CPROVER_DUMP_L2:
      ;
      break;
    }

    if(tmp == -1)

      __CPROVER_DUMP_L4:
        ;

    else
    {
      mark=lglmarked(lgl, lit);
      if(mark >= 1)

        __CPROVER_DUMP_L6:
          ;

      else
      {
        if(!(mark >= 0))
        {

        __CPROVER_DUMP_L8:
          ;
          break;
        }

        tmp_post$1 = q;
        q = q + 1l;
        *tmp_post$1 = lit;
        lglmark(lgl, lit);
      }
    }
    p = p + 1l;
  }
  while((_Bool)1);
  *q = 0;
  lgl->clause.top = q + (signed long int)1;
  while(!(lgl->clause.start >= q))
  {
    q = q - 1l;
    lglunmark(lgl, *q);
  }
  if(!(lit == 0))

    __CPROVER_DUMP_L14:
      ;

  else

    __CPROVER_DUMP_L15:
      ;
  return lit;
}

// lglsimpcntrem
// file lglib.c line 17137
static signed int lglsimpcntrem(struct LGL *lgl, signed int oldrem)
{
  signed int rem;
  rem=lglrem(lgl);
  signed int removed = oldrem - rem;
  signed int pcnt;
  signed long int pcnt64;
  if(!(removed >= 1))
    pcnt = 0;

  else
  {
    pcnt64 = (signed long int)((100 * removed) / oldrem);
    pcnt = (signed int)pcnt64;
  }
  lglprt(lgl, 1, "[simplification-%d] removed %d variables %d%%", lgl->stats->simp.count, removed, pcnt);
  return pcnt;
}

// lglsimpgate
// file lglib.c line 13608
static signed int lglsimpgate(struct LGL *lgl, struct Gat *g)
{
  signed int return_value_lglsimpand$1;
  signed int return_value_lglsimpite$2;
  if((signed int)g->tag == ANDTAG)
  {
    return_value_lglsimpand$1=lglsimpand(lgl, g);
    return return_value_lglsimpand$1;
  }

  else
    if((signed int)g->tag == ITETAG)
    {
      return_value_lglsimpite$2=lglsimpite(lgl, g);
      return return_value_lglsimpite$2;
    }

    else
    {
      signed int return_value_lglsimpxor$3;
      return_value_lglsimpxor$3=lglsimpxor(lgl, g);
      return return_value_lglsimpxor$3;
    }
}

// lglsimpite
// file lglib.c line 13523
static signed int lglsimpite(struct LGL *lgl, struct Gat *g)
{
  signed int glhs = g->lhs;
  signed int lhs;
  lhs=lglcgrepr(lgl, glhs);
  signed int gc;
  gc=lglcgrepr(lgl, g->$anon0.$anon1.cond);
  signed int gp;
  gp=lglcgrepr(lgl, g->$anon0.$anon1.pos);
  signed int gn;
  gn=lglcgrepr(lgl, g->$anon0.$anon1.neg);
  signed int res;
  signed int conflict;
  signed int rhs;
  signed int gate;
  res = 0;
  conflict = res;
  rhs = conflict;
  gate = rhs;
  if(gc == 1 || gp == gn)
  {
    res = 1;
    rhs = gp;
  }

  else
    if(gc == -1)
    {
      res = 1;
      rhs = gn;
    }

    else
      if(gn == -1 && gp == 1)
      {
        res = 1;
        rhs = gc;
      }

      else
        if(gn == 1 && gp == -1)
        {
          res = 1;
          rhs = -gc;
        }

        else
          if(gc == gn || gn == -1)
          {
            if(gp == 1)
            {
              res = 1;
              rhs = gc;
            }

            else
              if(gp == -1)
              {
                res = 1;
                rhs = -1;
              }

              else
              {
                res=lglnewbingate(lgl, (enum GTag)ANDTAG, glhs, -gc, -gp);
                gate = 1;
              }
          }

          else
            if(gc == -gp || gp == -1)
            {
              if(gn == 1)
              {
                res = 1;
                rhs = -gc;
              }

              else
              {
                res=lglnewbingate(lgl, (enum GTag)ANDTAG, glhs, gc, -gn);
                gate = 1;
              }
            }

            else
              if(gc == gp || gp == 1)
              {
                if(gn == 1)
                {
                  res = 1;
                  rhs = 1;
                }

                else
                {
                  res=lglnewbingate(lgl, (enum GTag)ANDTAG, -glhs, gc, gn);
                  gate = 1;
                }
              }

              else
                if(gc == -gn || gn == 1)
                {
                  if(gp == 1)
                  {
                    res = 1;
                    rhs = 1;
                  }

                  else
                  {
                    res=lglnewbingate(lgl, (enum GTag)ANDTAG, -glhs, gp, -gc);
                    gate = 1;
                  }
                }

                else
                  if(gp == -gn)
                  {
                    res=lglnewbingate(lgl, (enum GTag)XORTAG, -glhs, gc, gn);
                    gate = 1;
                  }

  if(gate == 0 && lhs == rhs && !(res == 0))
    res = 0;

  if(!(res == 0) && (!(gate == 0) || !(lhs == rhs)))
  {

  __CPROVER_DUMP_L20:
    ;
    lgl->$anon0.cgr->simplified.all = lgl->$anon0.cgr->simplified.all + 1;
    lgl->stats->cgr.simplified.all = lgl->stats->cgr.simplified.all + 1;
    lgl->$anon0.cgr->simplified.ite = lgl->$anon0.cgr->simplified.ite + 1;
    lgl->stats->cgr.simplified.ite = lgl->stats->cgr.simplified.ite + 1;
    if(gate == 0)
    {
      if(!(lhs == rhs))
        conflict=lglcgmergelhsrhs(lgl, lhs, rhs);

      else
        res = 0;
    }

  }

  if(!(conflict == 0))
  {

  __CPROVER_DUMP_L23:
    ;
    lgl->mt = 1;
  }

  return res;
}

// lglsimpleprobebinexists
// file lglib.c line 8617
static signed int lglsimpleprobebinexists(struct LGL *lgl, signed int a, signed int b)
{
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  struct HTS *hts;
  hts=lglhts(lgl, a);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(tag == BINCS)
    {
      red = blit & REDCS;
      if(red == 0)
      {
        other = blit >> RMSHFT;
        if(other == b)
          return 1;

      }

    }

  }
  return 0;
}

// lglsimpleprobeclausexists
// file lglib.c line 8703
static signed int lglsimpleprobeclausexists(struct LGL *lgl)
{
  signed int len;
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(&lgl->clause);
  len = (signed int)(return_value_lglcntstk$1 - (unsigned long int)1);
  signed int a;
  signed int b;
  signed int c;
  signed int *p;
  signed int *s;
  signed int res;
  s = lgl->clause.start;
  p = s + (signed long int)1;
  struct HTS *return_value_lglhts$2;
  struct HTS *return_value_lglhts$3;
  for( ; !(p + 1l >= lgl->clause.top); p = p + 1l)
  {
    return_value_lglhts$2=lglhts(lgl, *s);
    return_value_lglhts$3=lglhts(lgl, *p);
    if(!(return_value_lglhts$3->count >= return_value_lglhts$2->count))
      do
      {
        signed int TMP = *s;
        *s = *p;
        *p = TMP;
      }
      while((_Bool)0);

  }
  a = lgl->clause.start[(signed long int)0];
  if(len == 2)
  {
    b = lgl->clause.start[(signed long int)1];
    res=lglsimpleprobebinexists(lgl, a, b);
  }

  else
    if(len == 3)
    {
      b = lgl->clause.start[(signed long int)1];
      c = lgl->clause.start[(signed long int)2];
      res=lglsimpleprobetrnexists(lgl, a, b, c);
    }

    else
      if(len >= 4)
        res=lglsimpleprobelrgexists(lgl, a);

      else
        res = 0;
  if(!(res == 0))

    __CPROVER_DUMP_L9:
      ;

  return res;
}

// lglsimpleprobelrgexists
// file lglib.c line 8663
static signed int lglsimpleprobelrgexists(struct LGL *lgl, signed int a)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int lidx;
  signed int res;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *c;
  const signed int *q;
  struct HTS *hts;
  p = lgl->clause.start;
  for( ; !(p + 1l >= lgl->clause.top); p = p + 1l)
  {
    other = *p;
    lglsignedmark(lgl, other);
  }
  hts=lglhts(lgl, a);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  res = 0;
  p = w;
  _Bool tmp_if_expr$3;
  signed int return_value_lglsignedmarked$2;
  signed int return_value_lglsignedmarked$4;
  for( ; res == 0 && !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    red = blit & REDCS;
    if(!(tag == LRGCS) && red == 0)
    {
      other = blit >> RMSHFT;
      if(tag == BINCS)
        res=lglsignedmarked(lgl, other);

      else
        if(tag == TRNCS)
        {
          other2 = *p;
          signed int return_value_lglsignedmarked$1;
          return_value_lglsignedmarked$1=lglsignedmarked(lgl, other);
          if(!(return_value_lglsignedmarked$1 == 0))
          {
            return_value_lglsignedmarked$2=lglsignedmarked(lgl, other2);
            tmp_if_expr$3 = return_value_lglsignedmarked$2 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$3 = (_Bool)0;
          res = (signed int)tmp_if_expr$3;
        }

        else
        {
          lidx = other;
          c=lglidx2lits(lgl, OCCS, 0, lidx);
          q = c;
          do
          {
            other = *q;
            if(other == 0)
              break;

            return_value_lglsignedmarked$4=lglsignedmarked(lgl, other);
            if(return_value_lglsignedmarked$4 == 0)
              break;

            q = q + 1l;
          }
          while((_Bool)1);
          res = (signed int)!(other != 0);
        }
    }

  }
  p = lgl->clause.start;
  for( ; !(p + 1l >= lgl->clause.top); p = p + 1l)
    lglunmark(lgl, *p);
  return res;
}

// lglsimpleprobetrnexists
// file lglib.c line 8637
static signed int lglsimpleprobetrnexists(struct LGL *lgl, signed int a, signed int b, signed int c)
{
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  struct HTS *hts;
  hts=lglhts(lgl, a);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  p = w;
  for( ; !(p >= eow); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    red = blit & REDCS;
    if(red == 0)
    {
      other = blit >> RMSHFT;
      if(tag == BINCS)
      {
        if(other == b)
          return 1;

        if(other == c)
          return 1;

      }

      else
        if(tag == TRNCS)
        {
          other2 = *p;
          if(other == b && other2 == c)
            return 1;

          if(other == c && other2 == b)
            return 1;

        }

    }

  }
  return 0;
}

// lglsimplimhit
// file lglib.c line 17165
static signed int lglsimplimhit(struct LGL *lgl)
{
  if(lgl->opts->inprocessing.val == 0)
  {
    if(lgl->stats->simp.count == 0)
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(lgl->stats->confs >= lgl->limits->simp.confs))
      return 0;

    else
    {
      lgl->stats->simp.climhit = lgl->stats->simp.climhit + 1;
      lglprt(lgl, 1, "[simplification-%d] limit hit at %lld conflicts", lgl->stats->simp.count + 1, (signed long long int)lgl->stats->confs);
      if(!(lgl->limits->simp.pen == 0))
        lglprt(lgl, 1, "[simplification-%d] simplification penalty of %d", lgl->stats->simp.count + 1, lgl->limits->simp.pen);

      else
        lglprt(lgl, 1, "[simplification-%d] no simplification penalty", lgl->stats->simp.count + 1);
      return 1;
    }
  }
}

// lglsimplrgand
// file lglib.c line 13375
static signed int lglsimplrgand(struct LGL *lgl, struct Gat *g)
{
  signed int *p;
  signed int lhs;
  signed int other;
  signed int repr;
  signed int conflict;
  signed int res;
  signed int foundfalse;
  signed int rhs;
  signed int bit;
  signed int found;
  struct AVar *u;
  lhs=lglcgrepr(lgl, g->lhs);
  foundfalse = 0;
  rhs = foundfalse;
  found = 0;
  p = g->$anon0.$anon0.cls;
  _Bool tmp_if_expr$1;
  do
  {
    if(foundfalse == 0)
    {
      other = *p;
      tmp_if_expr$1 = other != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    if(other == g->$anon0.$anon0.origlhs)
      found = found + 1;

    else
    {
      lgl->stats->cgr.csteps = lgl->stats->cgr.csteps + 1l;
      repr=lglcgrepr(lgl, -other);
      if(!(repr == 1))
      {
        if(repr == -1)
        {
          foundfalse = 1;
          break;
        }

        if(!(rhs == 0))
          rhs = 0x7fffffff;

        else
          rhs = repr;
        u=lglavar(lgl, repr);
        bit = 1 << (signed int)(repr < 0);
        if((u->mark & bit) == 0)
        {
          if(!(((3 ^ bit) & u->mark) == 0))
          {
            foundfalse = 1;
            break;
          }

          u->mark = u->mark | bit;
        }

      }

    }
    p = p + 1l;
  }
  while((_Bool)1);
  p = g->$anon0.$anon0.cls;
  do
  {
    other = *p;
    if(other == 0)
      break;

    if(!(other == g->$anon0.$anon0.origlhs))
    {
      repr=lglcgrepr(lgl, other);
      signed int return_value_abs$2;
      return_value_abs$2=abs(repr);
      if(!(return_value_abs$2 == 1))
      {
        struct AVar *return_value_lglavar$3;
        return_value_lglavar$3=lglavar(lgl, repr);
        return_value_lglavar$3->mark = 0;
      }

    }

    p = p + 1l;
  }
  while((_Bool)1);
  res = 0;
  conflict = res;
  signed int return_value_lglcgunit$4;
  signed int return_value_lglcgunit$5;
  if(!(foundfalse == 0))
  {
    if(!(lhs == -1))
    {
      res = 1;

    __CPROVER_DUMP_L14:
      ;
      if(lhs == 1)
        conflict = 1;

      else
      {
        return_value_lglcgunit$4=lglcgunit(lgl, -lhs);
        conflict = (signed int)!(return_value_lglcgunit$4 != 0);
      }
    }

  }

  else
    if(rhs == 0)
    {
      if(!(lhs == 1))
      {
        res = 1;

      __CPROVER_DUMP_L19:
        ;
        if(lhs == -1)
          conflict = 1;

        else
        {
          return_value_lglcgunit$5=lglcgunit(lgl, lhs);
          conflict = (signed int)!(return_value_lglcgunit$5 != 0);
        }
      }

    }

    else
      if(!(rhs == 0x7fffffff))
      {
        if(!(lhs == rhs))
        {
          res = 1;

        __CPROVER_DUMP_L24:
          ;
          if(lhs == -rhs)
            conflict = 1;

          else
            lglcgmerge(lgl, lhs, rhs);
        }

      }

  if(!(res == 0))
  {
    lgl->$anon0.cgr->simplified.all = lgl->$anon0.cgr->simplified.all + 1;
    lgl->stats->cgr.simplified.all = lgl->stats->cgr.simplified.all + 1;
    lgl->$anon0.cgr->simplified.and = lgl->$anon0.cgr->simplified.and + 1;
    lgl->stats->cgr.simplified.and = lgl->stats->cgr.simplified.and + 1;
  }

  if(!(conflict == 0))
  {

  __CPROVER_DUMP_L28:
    ;
    lgl->mt = 1;
  }

  return res;
}

// lglsimplrgxor
// file lglib.c line 13479
static signed int lglsimplrgxor(struct LGL *lgl, struct Gat *g)
{
  signed int conflict;
  signed int lhs;
  signed int rhs;
  signed int other;
  signed int repr;
  signed int *p;
  signed int found;
  signed int return_value_lglcgrepr$1;
  return_value_lglcgrepr$1=lglcgrepr(lgl, g->lhs);
  lhs = -return_value_lglcgrepr$1;
  rhs = -1;
  found = 0;
  p = g->$anon0.$anon0.cls;
  signed int return_value_abs$2;
  do
  {
    other = *p;
    if(other == 0)
      break;

    if(other == g->$anon0.$anon0.origlhs)
      found = found + 1;

    else
    {
      repr=lglcgrepr(lgl, other);
      if(repr == -1)
        goto __CPROVER_DUMP_L13;

      else
        if(repr == 1)
          rhs = -rhs;

        else
          if(repr == rhs)
            rhs = -1;

          else
            if(repr == lhs)
              lhs = -1;

            else
              if(repr == -lhs)
                lhs = 1;

              else
                if(lhs == -1)
                  lhs = repr;

                else
                  if(lhs == 1)
                    lhs = -repr;

                  else
                  {
                    return_value_abs$2=abs(rhs);
                    if(!(return_value_abs$2 == 1))
                      return 0;

                    else
                      if(rhs == -1)
                        rhs = repr;

                      else
                        rhs = -repr;
                  }
    }

  __CPROVER_DUMP_L13:
    ;
    p = p + 1l;
  }
  while((_Bool)1);
  if(lhs == rhs)
    return 0;

  else
  {

  __CPROVER_DUMP_L15:
    ;
    lgl->$anon0.cgr->simplified.all = lgl->$anon0.cgr->simplified.all + 1;
    lgl->stats->cgr.simplified.all = lgl->stats->cgr.simplified.all + 1;
    lgl->$anon0.cgr->simplified.xor = lgl->$anon0.cgr->simplified.xor + 1;
    lgl->stats->cgr.simplified.xor = lgl->stats->cgr.simplified.xor + 1;
    conflict=lglcgmergelhsrhs(lgl, lhs, rhs);
    if(!(conflict == 0))
    {

    __CPROVER_DUMP_L16:
      ;
      lgl->mt = 1;
    }

    return 1;
  }
}

// lglsimpxor
// file lglib.c line 13517
static signed int lglsimpxor(struct LGL *lgl, struct Gat *g)
{
  signed int return_value_lglsimpbinxor$1;
  signed int return_value_lglsimplrgxor$2;
  if((signed int)g->size == 2)
  {
    return_value_lglsimpbinxor$1=lglsimpbinxor(lgl, g);
    return return_value_lglsimpbinxor$1;
  }

  else
  {
    return_value_lglsimplrgxor$2=lglsimplrgxor(lgl, g);
    return return_value_lglsimplrgxor$2;
  }
}

// lglsize2cnf
// file lglib.c line 10730
static signed long int lglsize2cnf(signed int s)
{
  return (signed long int)s << 32;
}

// lglsizectk
// file lglib.c line 1542
static signed int lglsizectk(struct Ctk *ctk)
{
  return (signed int)(ctk->end - ctk->start);
}

// lglsizes
// file lglib.c line 18590
void lglsizes(struct LGL *lgl)
{
  lglprt(lgl, 0, "sizeof (int) == %ld", (signed long int)sizeof(signed int) /*4ul*/ );
  lglprt(lgl, 0, "sizeof (unsigned) == %ld", (signed long int)sizeof(unsigned int) /*4ul*/ );
  lglprt(lgl, 0, "sizeof (void*) == %ld", (signed long int)sizeof(void *) /*8ul*/ );
  lglprt(lgl, 0, "sizeof (Stk) == %ld", (signed long int)sizeof(struct Stk) /*24ul*/ );
  lglprt(lgl, 0, "sizeof (Fun) == %ld", (signed long int)sizeof(unsigned long int [64l]) /*512ul*/ );
  lglprt(lgl, 0, "sizeof (AVar) == %ld", (signed long int)sizeof(struct AVar) /*12ul*/ );
  lglprt(lgl, 0, "sizeof (DVar) == %ld", (signed long int)sizeof(struct DVar) /*16ul*/ );
  lglprt(lgl, 0, "sizeof (EVar) == %ld", (signed long int)sizeof(struct EVar) /*16ul*/ );
  lglprt(lgl, 0, "sizeof (Gat) == %ld", (signed long int)sizeof(struct Gat) /*32ul*/ );
  lglprt(lgl, 0, "sizeof (Stats.lir) == %ld", (signed long int)sizeof(struct anonymous$30 [16l]) /*896ul*/ );
  lglprt(lgl, 0, "sizeof (Stats) == %ld", (signed long int)sizeof(struct Stats) /*2272ul*/ );
  lglprt(lgl, 0, "sizeof (LGL) == %ld", (signed long int)sizeof(struct LGL) /*816ul*/ );
  lglprt(lgl, 0, "MAXVAR == %ld", (signed long int)((0x7fffffff >> RMSHFT) - 2));
  lglprt(lgl, 0, "MAXREDLIDX == %ld", (signed long int)((1 << 31 - 4) - 2));
  lglprt(lgl, 0, "MAXIRRLIDX == %ld", (signed long int)((1 << 31 - RMSHFT) - 2));
}

// lglsizewtk
// file lglib.c line 14991
static signed int lglsizewtk(struct Wtk *wtk)
{
  return (signed int)(wtk->end - wtk->start);
}

// lglslfun
// file lglib.c line 10607
static void lglslfun(unsigned long int *a, signed int shift)
{
  unsigned long int rest;
  unsigned long int tmp;
  signed int i;
  signed int j;
  signed int q;
  signed int b;
  signed int l;
  b = shift & 63;
  q = shift >> 6;
  j = (1 << 12 - 6) - 1;
  i = j - q;
  l = 64 - b;
  unsigned long int tmp_if_expr$1;
  for( ; j >= 0; j = j - 1)
  {
    if(i >= 0)
    {
      tmp = a[(signed long int)i] << b;
      if(i >= 1 && !(b == 0))
        tmp_if_expr$1 = a[(signed long int)(i - 1)] >> l;

      else
        tmp_if_expr$1 = (unsigned long int)0ll;
      rest = tmp_if_expr$1;
      a[(signed long int)j] = rest | tmp;
    }

    else
      a[(signed long int)j] = (unsigned long int)0ll;
    i = i - 1;
  }
}

// lglsmalladdlit2cnf
// file lglib.c line 10842
static signed long int lglsmalladdlit2cnf(struct LGL *lgl, signed long int cnf, signed int lit)
{
  signed int p;
  signed int m;
  signed int q;
  signed int n;
  signed int i;
  signed int cls;
  signed long int res;
  p=lglcnf2pos(cnf);
  m=lglcnf2size(cnf);
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(&lgl->$anon0.elm->clv);
  q = (signed int)return_value_lglcntstk$1;
  i = 0;
  for( ; !(i >= m); i = i + 1)
  {
    cls=lglpeek(&lgl->$anon0.elm->clv, p + i);
    cls = cls | lit;
    lglpushstk(lgl, &lgl->$anon0.elm->clv, cls);
  }
  unsigned long int return_value_lglcntstk$2;
  return_value_lglcntstk$2=lglcntstk(&lgl->$anon0.elm->clv);
  n = (signed int)(return_value_lglcntstk$2 - (unsigned long int)q);
  res=lglcnf(q, n);
  return res;
}

// lglsmallcnfunits
// file lglib.c line 10957
static signed int lglsmallcnfunits(struct LGL *lgl, signed long int cnf)
{
  signed int p;
  signed int m;
  signed int i;
  signed int res;
  signed int cls;
  signed int ilit;
  p=lglcnf2pos(cnf);
  m=lglcnf2size(cnf);
  res = 0;
  i = 0;
  for( ; !(i >= m); i = i + 1)
  {
    cls=lglpeek(&lgl->$anon0.elm->clv, p + i);
    ilit=lglsmallisunitcls(lgl, cls);
    if(!(ilit == 0))
    {
      lglunit(lgl, ilit);
      res = res + 1;
    }

  }
  return res;
}

// lglsmallevalcls
// file lglib.c line 10714
static void lglsmallevalcls(unsigned int cls, unsigned long int *res)
{
  unsigned long int tmp[64l];
  signed int v;
  lglfalsefun(res);
  v = 0;
  for( ; !(v >= 12); v = v + 1)
    if(!((cls & (unsigned int)(1 << 2 * v + 1)) == 0u))
    {
      lglvar2fun(v, tmp);
      lglornegfun(res, tmp);
    }

    else
      if(!((cls & (unsigned int)(1 << 2 * v)) == 0u))
      {
        lglvar2fun(v, tmp);
        lglorfun(res, tmp);
      }

}

// lglsmallevalcnf
// file lglib.c line 10738
static void lglsmallevalcnf(struct LGL *lgl, signed long int cnf, unsigned long int *res)
{
  unsigned long int tmp[64l];
  signed int i;
  signed int n;
  signed int p;
  signed int cls;
  p=lglcnf2pos(cnf);
  n=lglcnf2size(cnf);
  lgltruefun(res);
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    cls=lglpeek(&lgl->$anon0.elm->clv, p + i);
    lglsmallevalcls((unsigned int)cls, tmp);
    lglandfun(res, tmp);
  }
}

// lglsmallfundeps0
// file lglib.c line 10769
static signed int lglsmallfundeps0(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!((0xaaaaaaaaaaaaaaaaull & f[(signed long int)i]) >> 1 == (0x5555555555555555ull & f[(signed long int)i])))
      return 1;

  return 0;
}

// lglsmallfundeps1
// file lglib.c line 10777
static signed int lglsmallfundeps1(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!((0xccccccccccccccccull & f[(signed long int)i]) >> 2 == (0x3333333333333333ull & f[(signed long int)i])))
      return 1;

  return 0;
}

// lglsmallfundeps2
// file lglib.c line 10785
static signed int lglsmallfundeps2(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!((0xf0f0f0f0f0f0f0f0ull & f[(signed long int)i]) >> 4 == (0x0f0f0f0f0f0f0f0full & f[(signed long int)i])))
      return 1;

  return 0;
}

// lglsmallfundeps3
// file lglib.c line 10793
static signed int lglsmallfundeps3(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!((0xff00ff00ff00ff00ull & f[(signed long int)i]) >> 8 == (0x00ff00ff00ff00ffull & f[(signed long int)i])))
      return 1;

  return 0;
}

// lglsmallfundeps4
// file lglib.c line 10801
static signed int lglsmallfundeps4(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!((0xffff0000ffff0000ull & f[(signed long int)i]) >> 16 == (0x0000ffff0000ffffull & f[(signed long int)i])))
      return 1;

  return 0;
}

// lglsmallfundeps5
// file lglib.c line 10809
static signed int lglsmallfundeps5(unsigned long int *f)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    if(!((0xffffffff00000000ull & f[(signed long int)i]) >> 32 == (0x00000000ffffffffull & f[(signed long int)i])))
      return 1;

  return 0;
}

// lglsmallfundepsgen
// file lglib.c line 10817
static signed int lglsmallfundepsgen(unsigned long int *f, signed int min)
{
  const signed int c = 1 << min - 6;
  signed int i;
  signed int j;
  i = 0;
  for( ; !(i >= 64); i = i + (1 << min - 5))
  {
    j = 0;
    for( ; !(j >= c); j = j + 1)
      if(!(f[(signed long int)(i + j)] == f[(signed long int)(c + i + j)]))
        return 1;

  }
  return 0;
}

// lglsmallipos
// file lglib.c line 10874
static signed long int lglsmallipos(struct LGL *lgl, unsigned long int *U, unsigned long int *L, signed int min)
{
  unsigned long int U0[64l];
  unsigned long int U1[64l];
  unsigned long int L0[64l];
  unsigned long int L1[64l];
  unsigned long int Unew[64l];
  unsigned long int ftmp[64l];
  signed long int c0;
  signed long int c1;
  signed long int cstar;
  signed long int ctmp;
  signed long int res;
  signed int x;
  signed int y;
  signed int z;
  signed int return_value_lglistruefun$1;
  return_value_lglistruefun$1=lglistruefun(U);
  signed int return_value_lglcnf2pos$4;
  signed int return_value_lglcnf2pos$5;
  if(!(return_value_lglistruefun$1 == 0))
    return 0ll;

  else
  {
    signed int return_value_lglisfalsefun$2;
    return_value_lglisfalsefun$2=lglisfalsefun(L);
    if(!(return_value_lglisfalsefun$2 == 0))
      return 1ll << 32;

    else
    {
      lgl->stats->elm.ipos = lgl->stats->elm.ipos + 1l;
      y=lglsmalltopvar(U, min);
      z=lglsmalltopvar(L, min);
      lgl->stats->elm.steps = lgl->stats->elm.steps + (signed long int)12;
      x = y < z ? y : z;
      lglnegcofactorfun(U, x, U0);
      lglposcofactorfun(U, x, U1);
      lglnegcofactorfun(L, x, L0);
      lglposcofactorfun(L, x, L1);
      lglor3negfun(ftmp, U0, L1);
      c0=lglsmallipos(lgl, ftmp, L0, min + 1);
      lglor3negfun(ftmp, U1, L0);
      c1=lglsmallipos(lgl, ftmp, L1, min + 1);
      lglsmallevalcnf(lgl, c0, ftmp);
      lglor3negfun(Unew, U0, ftmp);
      lglsmallevalcnf(lgl, c1, ftmp);
      lglandornegfun(Unew, U1, ftmp);
      lglor3fun(ftmp, L0, L1);
      cstar=lglsmallipos(lgl, Unew, ftmp, min + 1);
      ctmp=lglsmalladdlit2cnf(lgl, c1, 1 << 2 * x + 1);
      signed int return_value_lglcnf2pos$3;
      return_value_lglcnf2pos$3=lglcnf2pos(ctmp);
      res = (signed long int)return_value_lglcnf2pos$3;
      ctmp=lglsmalladdlit2cnf(lgl, c0, 1 << 2 * x);
      if(res == 0ll)
      {
        return_value_lglcnf2pos$4=lglcnf2pos(ctmp);
        res = (signed long int)return_value_lglcnf2pos$4;
      }

      ctmp=lglsmalladdlit2cnf(lgl, cstar, 0);
      if(res == 0ll)
      {
        return_value_lglcnf2pos$5=lglcnf2pos(ctmp);
        res = (signed long int)return_value_lglcnf2pos$5;
      }

      unsigned long int return_value_lglcntstk$6;
      return_value_lglcntstk$6=lglcntstk(&lgl->$anon0.elm->clv);
      signed long int return_value_lglsize2cnf$7;
      return_value_lglsize2cnf$7=lglsize2cnf((signed int)(return_value_lglcntstk$6 - (unsigned long int)res));
      res = res | return_value_lglsize2cnf$7;
      return res;
    }
  }
}

// lglsmallirr
// file lglib.c line 9103
static signed int lglsmallirr(struct LGL *lgl)
{
  signed int maxirrlidx;
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(&lgl->irr);
  maxirrlidx = (signed int)return_value_lglcntstk$1;
  signed int limit;
  signed long int tmp = (signed long int)((1 << 31 - 4) - 2);
  tmp = tmp * (signed long int)lgl->opts->smallirr.val;
  tmp = tmp / (signed long int)100;
  limit = (signed int)(tmp < (signed long int)0x7fffffff ? tmp : (signed long int)0x7fffffff);
  if(maxirrlidx >= limit)
    return 0;

  else
    return 1;
}

// lglsmallisunitcls
// file lglib.c line 10943
static signed int lglsmallisunitcls(struct LGL *lgl, signed int cls)
{
  signed int fidx;
  signed int fsign;
  signed int flit;
  signed int mlit;
  signed int ilit = 0;
  fidx = 0;
  for( ; !(fidx >= 12); fidx = fidx + 1)
  {
    fsign = 0;
    for( ; !(fsign >= 2); fsign = fsign + 1)
    {
      flit = 1 << 2 * fidx + fsign;
      if(!((flit & cls) == 0))
      {
        if(!(ilit == 0))
          return 0;

        mlit = (fidx + 2) * (fsign != 0 ? -1 : 1);
        ilit=lglm2i(lgl, mlit);
      }

    }
  }
  return ilit;
}

// lglsmalltopvar
// file lglib.c line 10827
static signed int lglsmalltopvar(unsigned long int *f, signed int min)
{
  signed int i;
  signed int return_value_lglsmallfundeps0$1;
  signed int return_value_lglsmallfundeps1$2;
  signed int return_value_lglsmallfundeps2$3;
  signed int return_value_lglsmallfundeps3$4;
  signed int return_value_lglsmallfundeps4$5;
  signed int return_value_lglsmallfundepsgen$7;
  switch(min)
  {
    case 0:
    {
      return_value_lglsmallfundeps0$1=lglsmallfundeps0(f);
      if(!(return_value_lglsmallfundeps0$1 == 0))
        return 0;

    }
    case 1:
    {
      return_value_lglsmallfundeps1$2=lglsmallfundeps1(f);
      if(!(return_value_lglsmallfundeps1$2 == 0))
        return 1;

    }
    case 2:
    {
      return_value_lglsmallfundeps2$3=lglsmallfundeps2(f);
      if(!(return_value_lglsmallfundeps2$3 == 0))
        return 2;

    }
    case 3:
    {
      return_value_lglsmallfundeps3$4=lglsmallfundeps3(f);
      if(!(return_value_lglsmallfundeps3$4 == 0))
        return 3;

    }
    case 4:
    {
      return_value_lglsmallfundeps4$5=lglsmallfundeps4(f);
      if(!(return_value_lglsmallfundeps4$5 == 0))
        return 4;

    }
    case 5:
    {
      signed int return_value_lglsmallfundeps5$6;
      return_value_lglsmallfundeps5$6=lglsmallfundeps5(f);
      if(!(return_value_lglsmallfundeps5$6 == 0))
        return 5;

    }
    default:
    {
      i=lglmax(6, min);
      for( ; !(i >= 11); i = i + 1)
      {
        return_value_lglsmallfundepsgen$7=lglsmallfundepsgen(f, i);
        if(!(return_value_lglsmallfundepsgen$7 == 0))
          return i;

      }
      return i;
    }
  }
}

// lglsmallve
// file lglib.c line 10911
static void lglsmallve(struct LGL *lgl, signed long int cnf)
{
  signed int *soc;
  signed int return_value_lglcnf2pos$1;
  return_value_lglcnf2pos$1=lglcnf2pos(cnf);
  soc = lgl->$anon0.elm->clv.start + (signed long int)return_value_lglcnf2pos$1;
  signed int *eoc;
  signed int return_value_lglcnf2size$2;
  return_value_lglcnf2size$2=lglcnf2size(cnf);
  eoc = soc + (signed long int)return_value_lglcnf2size$2;
  signed int *p;
  signed int cls;
  signed int v;
  signed int lit;
  signed int trivial;
  signed char val;
  p = soc;
  signed int return_value_lglm2i$3;
  for( ; lgl->mt == 0 && !(p >= eoc); p = p + 1l)
  {
    cls = *p;
    trivial = 0;
    v = 0;
    for( ; !(v >= 12); v = v + 1)
    {
      if(!((1 << 2 * v + 1 & cls) == 0))
      {
        return_value_lglm2i$3=lglm2i(lgl, v + 2);
        lit = -return_value_lglm2i$3;
      }

      else
        if(!((1 << 2 * v & cls) == 0))
          lit=lglm2i(lgl, v + 2);

        else
          goto __CPROVER_DUMP_L8;
      val=lglval(lgl, lit);
      if((signed int)val >= 0)
      {
        if((signed int)val >= 1)
          trivial = 1;

        lglpushstk(lgl, &lgl->clause, lit);
      }


    __CPROVER_DUMP_L8:
      ;
    }
    if(trivial == 0)
    {
      lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
      lgl->stats->elm.resolutions = lgl->stats->elm.resolutions + 1l;
      lglpushstk(lgl, &lgl->clause, 0);

    __CPROVER_DUMP_L10:
      ;
      lgladdcls(lgl, 0, 0, 1);
    }

    lglclnstk(&lgl->clause);
  }
}

// lglsolve
// file lglib.c line 17284
static signed int lglsolve(struct LGL *lgl, struct Lim *lim, signed int forcesimp)
{
  signed int res;
  lgl->limits->simp.pen = lgl->opts->simpen.val;
  lglstart(lgl, &lgl->times->prep);
  res=lgltopsimp(lgl, forcesimp);
  lglstop(lgl);
  if(!(res == 0))
    return res;

  else
  {
    signed int return_value_lglsearch$1;
    return_value_lglsearch$1=lglsearch(lgl, lim);
    return return_value_lglsearch$1;
  }
}

// lglsparse
// file lglib.c line 9229
static void lglsparse(struct LGL *lgl)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int count;
  signed int blit;
  signed int tag;
  signed int *w;
  signed int *p;
  signed int *eow;
  signed int *q;
  struct HTS *hts;
  lgl->stats->sparse = lgl->stats->sparse + 1l;
  count = 0;
  idx = 2;
  signed int *tmp_post$1;
  signed int *tmp_post$2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      lit = sign * idx;
      hts=lglhts(lgl, lit);
      if(!(hts->count == 0))
      {
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        q = w;
        p = q;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          tag = blit & MASKCS;
          if(tag == OCCS)
            count = count + 1;

          else
          {
            tmp_post$1 = q;
            q = q + 1l;
            *tmp_post$1 = blit;
            if(!(tag == BINCS))
            {
              tmp_post$2 = q;
              q = q + 1l;
              p = p + 1l;
              *tmp_post$2 = *p;
            }

          }
        }
        lglshrinkhts(lgl, hts, (signed int)(q - w));
      }

    }
  }
  do
  {
    lgldel(lgl, (void *)lgl->evars, (unsigned long int)lgl->nvars * sizeof(struct EVar) /*16ul*/ );
    lgl->evars = ((struct EVar *)NULL);
  }
  while((_Bool)0);
  lglrelstk(lgl, &lgl->esched);

__CPROVER_DUMP_L10:
  ;
  lgl->dense = (char)0;
  lgl->notfullyconnected = (char)1;

__CPROVER_DUMP_L11:
  ;
}

// lglsqr
// file lglib.c line 18093
static double lglsqr(double a)
{
  return a * a;
}

// lglsrfun
// file lglib.c line 10587
static void lglsrfun(unsigned long int *a, signed int shift)
{
  unsigned long int rest;
  unsigned long int tmp;
  signed int i;
  signed int j;
  signed int q;
  signed int b;
  signed int l;
  b = shift & 63;
  q = shift >> 6;
  j = 0;
  i = q;
  l = 64 - b;
  unsigned long int tmp_if_expr$1;
  for( ; !(j >= 64); j = j + 1)
  {
    if(!(i >= 64))
    {
      tmp = a[(signed long int)i] >> b;
      if(!(b == 0) && !(1 + i >= 64))
        tmp_if_expr$1 = a[(signed long int)(i + 1)] << l;

      else
        tmp_if_expr$1 = 0ull;
      rest = tmp_if_expr$1;
      a[(signed long int)j] = rest | tmp;
    }

    else
      a[(signed long int)j] = 0ull;
    i = i + 1;
  }
}

// lglstamp
// file lglib.c line 15021
static signed int lglstamp(struct LGL *lgl, signed int root, struct DFPR *dfpr, struct DFOPF *dfopf, struct Wtk *work, struct Stk *units, struct Stk *sccs, struct Stk *trds, signed int *visitedptr, signed int stamp, signed int irronly)
{
  signed int uroot;
  signed int lit;
  signed int ulit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int failed;
  signed int uother;
  signed int unotother;
  signed int observed;
  signed int discovered;
  signed int pos;
  signed int undiscovered;
  unsigned int lglstamp$$1$$start;
  unsigned int end;
  unsigned int mod;
  unsigned int i;
  unsigned int j;
  unsigned int sccsize;
  const signed int *p;
  const signed int *w;
  const signed int *eos;
  signed int startstamp;
  const struct Work *r;
  signed int removed;
  struct HTS *hts;
  enum Wrag wrag;
  signed char return_value_lglval$1;
  return_value_lglval$1=lglval(lgl, root);
  signed int return_value_lglmtwtk$2;
  unsigned int tmp_post$9;
  signed int return_value_lglcntwtk$10;
  signed int return_value_lglulit$11;
  signed int return_value_lglulit$12;
  if(!(return_value_lglval$1 == 0))
    return stamp;

  else
  {
    uroot=lglulit(root);
    if(!((dfpr + (signed long int)uroot)->discovered == 0))
      return stamp;

    else
    {

    __CPROVER_DUMP_L2:
      ;
      startstamp = 0;
      lglpushwtk(lgl, work, (enum Wrag)PREFIX, root, 0, 0);
      do
      {
        return_value_lglmtwtk$2=lglmtwtk(work);
        if(!(return_value_lglmtwtk$2 == 0))
          break;

        lgl->stats->unhd.steps = lgl->stats->unhd.steps + 1l;
        do
        {
          work->top = work->top - 1l;
          wrag = (enum Wrag)work->top->wrag;
          lit = (signed int)work->top->lit;
          other = (signed int)work->top->other;
          red = work->top->red != 0u ? REDCS : 0;
          removed = (signed int)work->top->removed;
        }
        while((_Bool)0);
        if(removed == 0)
        {
          if((signed int)wrag == PREFIX)
          {
            ulit=lglulit(lit);
            if(!((dfpr + (signed long int)ulit)->discovered == 0))
            {
              (dfopf + (signed long int)ulit)->observed = stamp;

            __CPROVER_DUMP_L5:
              ;
              continue;
            }

            stamp = stamp + 1;
            (dfpr + (signed long int)ulit)->discovered = stamp;
            (dfopf + (signed long int)ulit)->observed = stamp;

          __CPROVER_DUMP_L7:
            ;
            *visitedptr = *visitedptr + 1;
            if(startstamp == 0)
            {
              startstamp = stamp;

            __CPROVER_DUMP_L8:
              ;
              (dfpr + (signed long int)ulit)->root = lit;
            }


          __CPROVER_DUMP_L9:
            ;

          __CPROVER_DUMP_L10:
            ;

          __CPROVER_DUMP_L11:
            ;
            lglpushwtk(lgl, work, (enum Wrag)POSTFIX, lit, 0, 0);
            (dfopf + (signed long int)ulit)->pushed=lglcntwtk(work);
            (dfopf + (signed long int)ulit)->flag = 1;
            lglpushstk(lgl, sccs, lit);
            hts=lglhts(lgl, -lit);
            w=lglhts2wchs(lgl, hts);
            eos = w + (signed long int)hts->count;
            undiscovered = 0;
            for( ; !(undiscovered >= 2); undiscovered = undiscovered + 1)
            {
              signed int return_value_lglcntwtk$3;
              return_value_lglcntwtk$3=lglcntwtk(work);
              lglstamp$$1$$start = (unsigned int)return_value_lglcntwtk$3;
              p = w;
              for( ; !(p >= eos); p = p + 1l)
              {
                blit = *p;
                tag = blit & MASKCS;
                if(!(tag == OCCS))
                {
                  if(tag == TRNCS || tag == LRGCS)
                    p = p + 1l;

                  else
                  {
                    red = blit & REDCS;
                    if(red == 0 || irronly == 0)
                    {
                      other = blit >> RMSHFT;
                      signed char return_value_lglval$4;
                      return_value_lglval$4=lglval(lgl, other);
                      if(return_value_lglval$4 == 0)
                      {
                        uother=lglulit(other);
                        if(undiscovered == (signed int)((dfpr + (signed long int)uother)->discovered == 0))
                        {
                          do
                          {
                            signed int return_value_lglsignedmarked$5;
                            return_value_lglsignedmarked$5=lglsignedmarked(lgl, other);
                            if(!(return_value_lglsignedmarked$5 >= 1))
                              break;

                            fprintf(stderr, "liblgl.a: %s:%d: %s: Coverage target `%s' reached.", (const void *)"lglstamp", 15099, (const void *)"lglib.c", (const void *)"lglsignedmarked (lgl, other) > 0");
                            if(!(lgl == ((struct LGL *)NULL)))
                            {
                              if(lgl->tid >= 0)
                                fprintf(stderr, " (tid %d)", lgl->tid);

                            }

                            fputc(10, stderr);
                            fflush(stderr);
                            abort();
                          }
                          while((_Bool)0);
                          signed int return_value_lglsignedmarked$6;
                          return_value_lglsignedmarked$6=lglsignedmarked(lgl, other);
                          if(return_value_lglsignedmarked$6 >= 1)

                            __CPROVER_DUMP_L18:
                              ;

                          else
                          {
                            lglsignedmark(lgl, other);
                            lglpushwtk(lgl, work, (enum Wrag)BEFORE, lit, other, red);
                          }
                        }

                      }

                    }

                  }
                }

              }
              signed int return_value_lglcntwtk$7;
              return_value_lglcntwtk$7=lglcntwtk(work);
              end = (unsigned int)return_value_lglcntwtk$7;
              r = work->start + (signed long int)lglstamp$$1$$start;
              for( ; !(r >= work->top); r = r + 1l)
                lglunmark(lgl, (signed int)r->other);
              mod = end - lglstamp$$1$$start;
              if(mod >= 2u)
              {
                i = lglstamp$$1$$start;
                for( ; !(i >= end + 4294967295u); i = i + 1u)
                {
                  unsigned int return_value_lglrand$8;
                  return_value_lglrand$8=lglrand(lgl);
                  tmp_post$9 = mod;
                  mod = mod - 1u;
                  j = return_value_lglrand$8 % tmp_post$9;
                  if(!(j == 0u))
                  {
                    j = i + j;
                    do
                    {
                      struct Work TMP = work->start[(signed long int)i];
                      work->start[(signed long int)i] = work->start[(signed long int)j];
                      work->start[(signed long int)j] = TMP;
                    }
                    while((_Bool)0);
                  }

                }
              }

            }
          }

          else
            if((signed int)wrag == BEFORE)
            {

            __CPROVER_DUMP_L32:
              ;
              lglpushwtk(lgl, work, (enum Wrag)AFTER, lit, other, red);
              ulit=lglulit(lit);
              uother=lglulit(other);
              unotother=lglulit(-other);
              if(!(lgl->opts->unhdextstamp.val == 0))
              {
                if(!(red == 0) || !(irronly == 0))
                {
                  if(!((dfpr + (signed long int)ulit)->discovered >= (dfopf + (signed long int)uother)->observed))
                  {

                  __CPROVER_DUMP_L33:
                    ;
                    lgl->stats->unhd.stamp.trds = lgl->stats->unhd.stamp.trds + 1;
                    lgl->stats->prgss = lgl->stats->prgss + 1l;
                    if(!(red == 0))
                      lgl->stats->unhd.tauts.red = lgl->stats->unhd.tauts.red + 1;

                    lglrmbcls(lgl, -lit, other, red);
                    pos = (dfopf + (signed long int)unotother)->pushed;
                    if(pos >= 0)
                      do
                      {
                        return_value_lglcntwtk$10=lglcntwtk(work);
                        if(pos >= return_value_lglcntwtk$10)
                          break;

                        if(!((signed int)(work->start + (signed long int)pos)->lit == -other))
                          break;

                        if((signed int)(work->start + (signed long int)pos)->other == -lit)
                        {

                        __CPROVER_DUMP_L36:
                          ;
                          (work->start + (signed long int)pos)->removed = (unsigned int)1;
                        }

                        pos = pos + 1;
                      }
                      while((_Bool)1);

                    work->top = work->top - 1l;
                    continue;
                  }

                }

              }

              observed = (dfopf + (signed long int)unotother)->observed;
              if(!(lgl->opts->unhdextstamp.val == 0))
              {
                if(observed >= startstamp)
                {

                __CPROVER_DUMP_L41:
                  ;
                  failed = lit;
                  do
                  {
                    return_value_lglulit$11=lglulit(failed);
                    if(observed >= (dfpr + (signed long int)return_value_lglulit$11)->discovered)
                      break;

                    return_value_lglulit$12=lglulit(failed);
                    failed = (dfpr + (signed long int)return_value_lglulit$12)->parent;
                  }
                  while((_Bool)1);

                __CPROVER_DUMP_L44:
                  ;
                  lglpushstk(lgl, units, -failed);
                  lgl->stats->unhd.stamp.failed = lgl->stats->unhd.stamp.failed + 1;
                  if(!((dfpr + (signed long int)unotother)->discovered == 0))
                  {
                    if((dfpr + (signed long int)unotother)->finished == 0)
                    {

                    __CPROVER_DUMP_L45:
                      ;
                      work->top = work->top - 1l;
                      continue;
                    }

                  }

                }

              }

              if((dfpr + (signed long int)uother)->discovered == 0)
              {
                (dfpr + (signed long int)uother)->parent = lit;

              __CPROVER_DUMP_L47:
                ;
                (dfpr + (signed long int)uother)->root = root;

              __CPROVER_DUMP_L48:
                ;
                lglpushwtk(lgl, work, (enum Wrag)PREFIX, other, 0, 0);
              }

            }

            else
              if((signed int)wrag == AFTER)
              {

              __CPROVER_DUMP_L51:
                ;
                uother=lglulit(other);
                ulit=lglulit(lit);
                if(!(lgl->opts->unhdextstamp.val == 0))
                {
                  if((dfpr + (signed long int)uother)->finished == 0)
                  {
                    if(!((dfpr + (signed long int)uother)->discovered >= (dfpr + (signed long int)ulit)->discovered))
                    {

                    __CPROVER_DUMP_L52:
                      ;
                      (dfpr + (signed long int)ulit)->discovered = (dfpr + (signed long int)uother)->discovered;

                    __CPROVER_DUMP_L53:
                      ;
                      if(!((dfopf + (signed long int)ulit)->flag == 0))
                      {

                      __CPROVER_DUMP_L54:
                        ;
                        (dfopf + (signed long int)ulit)->flag = 0;
                      }

                    }

                  }

                }

                (dfopf + (signed long int)uother)->observed = stamp;
              }

              else
              {

              __CPROVER_DUMP_L57:
                ;
                ulit=lglulit(lit);
                if(!((dfopf + (signed long int)ulit)->flag == 0))
                {
                  stamp = stamp + 1;
                  sccsize = (unsigned int)0;
                  discovered = (dfpr + (signed long int)ulit)->discovered;
                  do
                  {
                    other=lglpopstk(sccs);
                    uother=lglulit(other);
                    (dfopf + (signed long int)uother)->pushed = -1;
                    (dfopf + (signed long int)uother)->flag = 0;
                    (dfpr + (signed long int)uother)->discovered = discovered;
                    (dfpr + (signed long int)uother)->finished = stamp;

                  __CPROVER_DUMP_L59:
                    ;
                    sccsize = sccsize + 1u;
                  }
                  while(!(other == lit));
                  if(sccsize >= 2u)
                  {

                  __CPROVER_DUMP_L60:
                    ;
                    lgl->stats->unhd.stamp.sumsccsizes = lgl->stats->unhd.stamp.sumsccsizes + (signed long int)sccsize;
                    lgl->stats->unhd.stamp.sccs = lgl->stats->unhd.stamp.sccs + 1;
                  }

                }

              }
        }


      __CPROVER_DUMP_L56:
        ;
      }
      while((_Bool)1);
      return stamp;
    }
  }
}

// lglstampall
// file lglib.c line 16012
static struct DFPR * lglstampall(struct LGL *lgl, signed int irronly)
{
  signed int roots;
  signed int searches;
  signed int noimpls;
  signed int unassigned;
  signed int visited;
  unsigned int pos;
  unsigned int delta;
  unsigned int mod;
  unsigned int ulit;
  unsigned int first;
  unsigned int last;
  unsigned int count;
  signed int root;
  signed int stamp;
  signed int rootsonly;
  signed int lit;
  struct Stk units;
  struct Stk sccs;
  struct Stk trds;
  struct DFOPF *dfopf;
  struct DFOPF *q;
  struct DFPR *dfpr;
  struct Wtk lglstampall$$1$$work;
  signed char val;
  unsigned int return_value_lglgcd$5;
  signed int return_value_lglulit$9;
  signed int return_value_lglunhdisroot$10;
  signed int return_value_lglunhdhasbins$11;
  signed int return_value_lglmtstk$12;
  _Bool tmp_if_expr$20;
  if(!(lgl->nvars >= 3))
    return ((struct DFPR *)NULL);

  else
  {
    lglrmbindup(lgl);
    do
    {
      void *return_value_lglnew$1;
      return_value_lglnew$1=lglnew(lgl, (unsigned long int)(2 * lgl->nvars) * sizeof(struct DFPR) /*16ul*/ );
      dfpr = (struct DFPR *)return_value_lglnew$1;
    }
    while((_Bool)0);
    do
    {
      void *return_value_lglnew$2;
      return_value_lglnew$2=lglnew(lgl, (unsigned long int)(2 * lgl->nvars) * sizeof(struct DFOPF) /*12ul*/ );
      dfopf = (struct DFOPF *)return_value_lglnew$2;
    }
    while((_Bool)0);
    do
      memset((void *)&lglstampall$$1$$work, 0, sizeof(struct Wtk) /*24ul*/ );
    while((_Bool)0);
    do
      memset((void *)&sccs, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    do
      memset((void *)&trds, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    do
      memset((void *)&units, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    q = dfopf;
    for( ; !(q >= dfopf + (signed long int)(2 * lgl->nvars)); q = q + 1l)
      q->pushed = -1;
    visited = 0;
    stamp = visited;
    unassigned = stamp;
    noimpls = unassigned;
    roots = noimpls;
    searches = roots;
    rootsonly = 1;
    for( ; rootsonly >= 0; rootsonly = rootsonly - 1)
    {
      count = (unsigned int)0;
      mod = (unsigned int)(2 * (lgl->nvars - 2));
      first = mod;
      unsigned int return_value_lglrand$3;
      return_value_lglrand$3=lglrand(lgl);
      pos = return_value_lglrand$3 % mod;
      unsigned int return_value_lglrand$4;
      return_value_lglrand$4=lglrand(lgl);
      delta = return_value_lglrand$4 % mod;
      if(delta == 0u)
        delta = delta + 1u;

      do
      {
        return_value_lglgcd$5=lglgcd(delta, mod);
        if(!(return_value_lglgcd$5 >= 2u))
          break;

        delta = delta + 1u;
        if(delta == mod)
          delta = (unsigned int)1;

      }
      while((_Bool)1);

    __CPROVER_DUMP_L13:
      ;
      do
      {
        signed int return_value_lglterminate$6;
        return_value_lglterminate$6=lglterminate(lgl);
        if(!(return_value_lglterminate$6 == 0))
        {
          searches = 0;
          goto DONE;
        }

        signed int return_value_lglsyncunits$7;
        return_value_lglsyncunits$7=lglsyncunits(lgl);
        if(return_value_lglsyncunits$7 == 0)
          goto DONE;

        ulit = pos + (unsigned int)4;
        root=lglilit((signed int)ulit);
        lgl->stats->unhd.steps = lgl->stats->unhd.steps + 1l;
        count = count + 1u;
        signed char return_value_lglval$8;
        return_value_lglval$8=lglval(lgl, root);
        if(return_value_lglval$8 == 0)
        {
          if(!(rootsonly == 0))
            unassigned = unassigned + 1;

          return_value_lglulit$9=lglulit(root);
          if((dfpr + (signed long int)return_value_lglulit$9)->discovered == 0)
          {
            if(!(rootsonly == 0))
            {
              return_value_lglunhdisroot$10=lglunhdisroot(lgl, root, dfpr, irronly);
              if(return_value_lglunhdisroot$10 == 0)
                goto CONTINUE;

            }

            return_value_lglunhdhasbins$11=lglunhdhasbins(lgl, dfpr, -root, irronly);
            if(return_value_lglunhdhasbins$11 == 0)
            {
              if(!(rootsonly == 0))
                noimpls = noimpls + 1;

            }

            else
            {
              if(!(rootsonly == 0))
                roots = roots + 1;

              searches = searches + 1;
              stamp=lglstamp(lgl, root, dfpr, dfopf, &lglstampall$$1$$work, &units, &sccs, &trds, &visited, stamp, irronly);
              do
              {
                return_value_lglmtstk$12=lglmtstk(&units);
                if(!(return_value_lglmtstk$12 == 0))
                  break;

                lit=lglpopstk(&units);
                val=lglval(lgl, lit);
                if(!((signed int)val >= 1))
                {
                  if(!((signed int)val >= 0))
                  {

                  __CPROVER_DUMP_L23:
                    ;
                    lgl->mt = 1;
                    goto DONE;
                  }

                  lglunit(lgl, lit);
                  signed int return_value_lglbcp$13;
                  return_value_lglbcp$13=lglbcp(lgl);
                  if(return_value_lglbcp$13 == 0)
                  {

                  __CPROVER_DUMP_L25:
                    ;
                    lgl->mt = 1;
                    goto DONE;
                  }

                }

              }
              while((_Bool)1);
            }
          }

        }


      CONTINUE:
        ;
        last = pos;
        pos = pos + delta;
        if(pos >= mod)
          pos = pos - mod;

        if(pos == first)
          break;

        if(mod == 1u)
          break;

        if(first == mod)
          first = last;

      }
      while((_Bool)1);
    }
    double return_value_lglpcnt$14;
    return_value_lglpcnt$14=lglpcnt((double)lgl->unassigned, (double)(lgl->nvars - 2));
    lglprt(lgl, 2, "[unhd-%d-%d] %d unassigned variables out of %d (%.0f%%)", lgl->stats->unhd.count, lgl->stats->unhd.rounds, lgl->unassigned, lgl->nvars - 2, return_value_lglpcnt$14);
    double return_value_lglpcnt$15;
    return_value_lglpcnt$15=lglpcnt((double)roots, (double)unassigned);
    lglprt(lgl, 2, "[unhd-%d-%d] %d root literals out of %d (%.0f%%)", lgl->stats->unhd.count, lgl->stats->unhd.rounds, roots, unassigned, return_value_lglpcnt$15);
    double return_value_lglpcnt$16;
    return_value_lglpcnt$16=lglpcnt((double)(searches - roots), (double)unassigned);
    lglprt(lgl, 2, "[unhd-%d-%d] %d additional non-root searches out of %d (%.0f%%)", lgl->stats->unhd.count, lgl->stats->unhd.rounds, searches - roots, unassigned, return_value_lglpcnt$16);
    double return_value_lglpcnt$17;
    return_value_lglpcnt$17=lglpcnt((double)noimpls, (double)unassigned);
    lglprt(lgl, 2, "[unhd-%d-%d] %d literals not in F2 out of %d (%.0f%%)", lgl->stats->unhd.count, lgl->stats->unhd.rounds, noimpls, unassigned, return_value_lglpcnt$17);
    double return_value_lglpcnt$18;
    return_value_lglpcnt$18=lglpcnt((double)visited, (double)unassigned);
    lglprt(lgl, 2, "[unhd-%d-%d] %d visited literals out of %d (%.0f%%)", lgl->stats->unhd.count, lgl->stats->unhd.rounds, visited, unassigned, return_value_lglpcnt$18);
    double return_value_lglavg$19;
    return_value_lglavg$19=lglavg((double)visited, (double)searches);
    lglprt(lgl, 2, "[unhd-%d-%d] %.2f average number visited literals per search", lgl->stats->unhd.count, lgl->stats->unhd.rounds, return_value_lglavg$19);

  DONE:
    ;
    if(searches == 0)
      tmp_if_expr$20 = (_Bool)1;

    else
      tmp_if_expr$20 = lgl->mt != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$20)
    {
      do
      {
        lgldel(lgl, (void *)dfpr, (unsigned long int)(2 * lgl->nvars) * sizeof(struct DFPR) /*16ul*/ );
        dfpr = ((struct DFPR *)NULL);
      }
      while((_Bool)0);
      dfpr = ((struct DFPR *)NULL);
    }

    lglrelwtk(lgl, &lglstampall$$1$$work);
    lglrelstk(lgl, &units);
    lglrelstk(lgl, &sccs);
    lglrelstk(lgl, &trds);
    do
    {
      lgldel(lgl, (void *)dfopf, (unsigned long int)(2 * lgl->nvars) * sizeof(struct DFOPF) /*12ul*/ );
      dfopf = ((struct DFOPF *)NULL);
    }
    while((_Bool)0);
    return dfpr;
  }
}

// lglstart
// file lglib.c line 4961
static void lglstart(struct LGL *lgl, double *timestatsptr)
{
  signed int nest = lgl->timers->nest;
  lgl->timers->idx[(signed long int)nest] = (signed int)(timestatsptr - (double *)lgl->times);
  lgl->timers->phase[(signed long int)nest]=lglgetime(lgl);
  lgl->timers->nest = lgl->timers->nest + 1;
}

// lglstats
// file lglib.h line 280
void lglstats(struct LGL *lgl)
{
  struct Times *ts = lgl->times;
  struct Stats *s = lgl->stats;
  double t = ts->all;
  double simp;
  double search;
  signed long long int p = s->props.search + s->props.simp + s->props.lkhd;
  signed int remaining;
  signed int removed;
  signed int sum;
  signed long long int v;
  signed long long int min;
  signed long int steps;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglstats");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  lglprs(lgl, "blkd: %d bces, %d removed, %lld resolutions, %lld steps", s->blk.count, s->blk.clauses, (signed long long int)s->blk.res, (signed long long int)s->blk.steps);
  double return_value_lglpcnt$1;
  return_value_lglpcnt$1=lglpcnt((double)s->blk.lits, (double)(2 * lgl->maxext));
  lglprs(lgl, "blkd: %d blocking literals %.0f%%, %d pure", s->blk.lits, return_value_lglpcnt$1, s->blk.pure);
  double return_value_lglpcnt$2;
  return_value_lglpcnt$2=lglpcnt((double)s->cce.ate, (double)s->cce.eliminated);
  double return_value_lglpcnt$3;
  return_value_lglpcnt$3=lglpcnt((double)s->cce.abce, (double)s->cce.eliminated);
  lglprs(lgl, "cces: %d cces, %d eliminated, %d ate %.0f%%, %d abce %.0f%%", s->cce.count, s->cce.eliminated, s->cce.ate, return_value_lglpcnt$2, s->cce.abce, return_value_lglpcnt$3);
  lglprs(lgl, "cces: %lld probed, %d lifted, %d failed", (signed long long int)s->cce.probed, s->cce.lifted, s->cce.failed);
  lglprs(lgl, "clff: %d cliffs, %d lifted, %d failed", s->cliff.count, s->cliff.lifted, s->cliff.failed);
  lglprs(lgl, "clff: %lld decisions, %lld steps", (signed long long int)s->cliff.decisions, (signed long long int)s->cliff.steps);
  lglprs(lgl, "clls: %lld sat, %lld simp, %lld freeze, %lld melt", (signed long long int)s->calls.sat, (signed long long int)s->calls.simp, (signed long long int)s->calls.freeze, (signed long long int)s->calls.melt);
  lglprs(lgl, "clls: %lld add, %lld assume,, %lld deref, %lld failed", (signed long long int)s->calls.add, (signed long long int)s->calls.assume, (signed long long int)s->calls.deref, (signed long long int)s->calls.failed);
  lglprs(lgl, "clls: %lld cassume, %lld mosat", (signed long long int)s->calls.cassume, (signed long long int)s->calls.mosat);
  lglprs(lgl, "coll: %d gcs, %d rescored clauses", s->gcs, s->rescored.clauses);
  lglprs(lgl, "cgrs: %d count, %lld esteps, %lld csteps", s->cgr.count, (signed long long int)s->cgr.esteps, (signed long long int)s->cgr.csteps);
  lglprs(lgl, "cgrs: %d eqs, %d units", s->cgr.eq, s->cgr.units);
  double return_value_lglpcnt$4;
  return_value_lglpcnt$4=lglpcnt((double)s->cgr.matched.and, (double)s->cgr.matched.all);
  double return_value_lglpcnt$5;
  return_value_lglpcnt$5=lglpcnt((double)s->cgr.matched.xor, (double)s->cgr.matched.all);
  double return_value_lglpcnt$6;
  return_value_lglpcnt$6=lglpcnt((double)s->cgr.matched.ite, (double)s->cgr.matched.all);
  lglprs(lgl, "cgrs: %d matched (%d ands %.0f%%, %d xors %.0f%%, %d ites %.0f%%)", s->cgr.matched.all, s->cgr.matched.and, return_value_lglpcnt$4, s->cgr.matched.xor, return_value_lglpcnt$5, s->cgr.matched.ite, return_value_lglpcnt$6);
  double return_value_lglpcnt$7;
  return_value_lglpcnt$7=lglpcnt((double)s->cgr.simplified.and, (double)s->cgr.simplified.all);
  double return_value_lglpcnt$8;
  return_value_lglpcnt$8=lglpcnt((double)s->cgr.simplified.xor, (double)s->cgr.simplified.all);
  double return_value_lglpcnt$9;
  return_value_lglpcnt$9=lglpcnt((double)s->cgr.simplified.ite, (double)s->cgr.simplified.all);
  lglprs(lgl, "cgrs: %d simplified (%d ands %.0f%%, %d xors %.0f%%, %d ites %.0f%%)", s->cgr.simplified.all, s->cgr.simplified.and, return_value_lglpcnt$7, s->cgr.simplified.xor, return_value_lglpcnt$8, s->cgr.simplified.ite, return_value_lglpcnt$9);
  double return_value_lglpcnt$10;
  return_value_lglpcnt$10=lglpcnt((double)s->cgr.extracted.and, (double)s->cgr.extracted.all);
  double return_value_lglpcnt$11;
  return_value_lglpcnt$11=lglpcnt((double)s->cgr.extracted.xor, (double)s->cgr.extracted.all);
  double return_value_lglpcnt$12;
  return_value_lglpcnt$12=lglpcnt((double)s->cgr.extracted.ite, (double)s->cgr.extracted.all);
  lglprs(lgl, "cgrs: %lld extracted (%lld ands %.0f%%, %lld xors %.0f%%, %lld ites %.0f%%)", (signed long long int)s->cgr.extracted.all, (signed long long int)s->cgr.extracted.and, return_value_lglpcnt$10, (signed long long int)s->cgr.extracted.xor, return_value_lglpcnt$11, (signed long long int)s->cgr.extracted.ite, return_value_lglpcnt$12);
  double return_value_lglpcnt$13;
  return_value_lglpcnt$13=lglpcnt((double)s->equiv.sum, (double)lgl->maxext);
  lglprs(lgl, "dcps: %d decompositions, %d equivalent %.0f%%", s->decomps, s->equiv.sum, return_value_lglpcnt$13);
  double return_value_lglpcnt$14;
  return_value_lglpcnt$14=lglpcnt((double)s->randecs, (double)s->decisions);
  lglprs(lgl, "decs: %lld decision, %lld random %.3f%%", (signed long long int)s->decisions, (signed long long int)s->randecs, return_value_lglpcnt$14);
  double return_value_lglpcnt$15;
  return_value_lglpcnt$15=lglpcnt((double)s->flipped, (double)s->decisions);
  lglprs(lgl, "decs: %lld flipped %.3f%% (in %lld phases)", (signed long long int)s->flipped, return_value_lglpcnt$15, (signed long long int)s->fliphases);
  double return_value_lglpcnt$16;
  return_value_lglpcnt$16=lglpcnt((double)s->elm.elmd, (double)lgl->maxext);
  lglprs(lgl, "elms: %d elims, %d eliminated %.0f%%", s->elm.count, s->elm.elmd, return_value_lglpcnt$16);
  double return_value_lglpcnt$17;
  return_value_lglpcnt$17=lglpcnt((double)s->elm.small.elm, (double)s->elm.elmd);
  double return_value_lglpcnt$18;
  return_value_lglpcnt$18=lglpcnt((double)s->elm.large, (double)s->elm.elmd);
  lglprs(lgl, "elms: %d small %.0f%%, %d large %.0f%%", s->elm.small.elm, return_value_lglpcnt$17, s->elm.large, return_value_lglpcnt$18);
  double return_value_lglpcnt$19;
  return_value_lglpcnt$19=lglpcnt((double)(s->elm.small.tried - s->elm.small.failed), (double)s->elm.small.tried);
  double return_value_lglpcnt$20;
  return_value_lglpcnt$20=lglpcnt((double)s->elm.small.failed, (double)s->elm.small.tried);
  lglprs(lgl, "elms: %d tried small, %d succeeded %.0f%%, %d failed %.0f%%", s->elm.small.tried, s->elm.small.tried - s->elm.small.failed, return_value_lglpcnt$19, s->elm.small.failed, return_value_lglpcnt$20);
  lglprs(lgl, "elms: %d subsumed, %d strengthened, %d blocked", s->elm.sub, s->elm.str, s->elm.blkd);
  lglprs(lgl, "elms: %lld copies, %lld resolutions, %lld ipos", (signed long long int)s->elm.copies, (signed long long int)s->elm.resolutions, (signed long long int)s->elm.ipos);
  lglprs(lgl, "elms: %lld subchks, %lld strchks", (signed long long int)s->elm.subchks, (signed long long int)s->elm.strchks);
  lglprs(lgl, "frcs: %lld computed, %.1f - %.1f average min-cut range", (signed long long int)s->force.count, s->force.mincut.min, s->force.mincut.max);
  double return_value_lglavg$21;
  return_value_lglavg$21=lglavg((double)s->gauss.arity.sum, (double)s->gauss.extracted);
  lglprs(lgl, "gaus: %lld extractions, %lld extracted, %.1f size, %d max", s->gauss.count, s->gauss.extracted, return_value_lglavg$21, s->gauss.arity.max);
  lglprs(lgl, "gaus: exported %d units, %d binary and %d ternary equations", s->gauss.units, s->gauss.equivs, s->gauss.trneqs);
  steps = s->gauss.steps.extr + s->gauss.steps.extr;
  double return_value_lglpcnt$22;
  return_value_lglpcnt$22=lglpcnt((double)s->gauss.steps.extr, (double)steps);
  double return_value_lglpcnt$23;
  return_value_lglpcnt$23=lglpcnt((double)s->gauss.steps.elim, (double)steps);
  lglprs(lgl, "gaus: %d gc, %lld steps, %lld extr %.0f%%, %lld elim %.0f%%", s->gauss.gcs, steps, s->gauss.steps.extr, return_value_lglpcnt$22, s->gauss.steps.elim, return_value_lglpcnt$23);
  double return_value_lglavg$24;
  return_value_lglavg$24=lglavg((double)s->clauses.glue, (double)s->clauses.learned);
  double return_value_lglavg$25;
  return_value_lglavg$25=lglavg((double)s->clauses.scglue, (double)s->clauses.learned);
  lglprs(lgl, "glue: %.1f avg, %.1f scaled avg", return_value_lglavg$24, return_value_lglavg$25);
  double return_value_lglpcnt$26;
  return_value_lglpcnt$26=lglpcnt((double)s->clauses.maxglue, (double)s->clauses.learned);
  lglprs(lgl, "glue: %lld maxredglue=%d (%.0f%%)", (signed long long int)s->clauses.maxglue, (1 << 4) - 1, return_value_lglpcnt$26);
  sum = (signed int)(s->lift.probed0 + s->lift.probed1);
  double return_value_lglpcnt$27;
  return_value_lglpcnt$27=lglpcnt((double)s->lift.probed0, (double)sum);
  double return_value_lglpcnt$28;
  return_value_lglpcnt$28=lglpcnt((double)s->lift.probed1, (double)sum);
  lglprs(lgl, "lift: %d phases, %d probed (%lld level1 %.0f%%, %lld level2 %.0f%%)", s->lift.count, sum, (signed long long int)s->lift.probed0, return_value_lglpcnt$27, (signed long long int)s->lift.probed1, return_value_lglpcnt$28);
  lglprs(lgl, "lift: %d units, %d equivalences, %d implications", s->lift.units, s->lift.eqs, s->lift.impls);
  double return_value_lglpcnt$29;
  return_value_lglpcnt$29=lglpcnt((double)s->hbr.trn, (double)s->hbr.cnt);
  double return_value_lglpcnt$30;
  return_value_lglpcnt$30=lglpcnt((double)s->hbr.lrg, (double)s->hbr.cnt);
  double return_value_lglpcnt$31;
  return_value_lglpcnt$31=lglpcnt((double)s->hbr.sub, (double)s->hbr.cnt);
  lglprs(lgl, "hbrs: %d hbrs = %d trn %.0f%% + %d lrg %.0f%%, %d sub %.0f%%", s->hbr.cnt, s->hbr.trn, return_value_lglpcnt$29, s->hbr.lrg, return_value_lglpcnt$30, s->hbr.sub, return_value_lglpcnt$31);
  double return_value_lglpcnt$32;
  return_value_lglpcnt$32=lglpcnt((double)s->uips, (double)s->clauses.learned);
  double return_value_lglavg$33;
  return_value_lglavg$33=lglavg((double)s->lits.learned, (double)s->clauses.learned);
  double return_value_lglavg$34;
  return_value_lglavg$34=lglavg((double)s->clauses.glue, (double)s->clauses.learned);
  lglprs(lgl, "lrnd: %lld clauses, %lld uips %.0f%%, %.1f length, %.1f glue", (signed long long int)s->clauses.learned, (signed long long int)s->uips, return_value_lglpcnt$32, return_value_lglavg$33, return_value_lglavg$34);
  lglprs(lgl, "ints: %lld luby (%lld steps), %lld inout (%lld steps)", (signed long long int)s->luby.count, (signed long long int)s->luby.steps, (signed long long int)s->inout.count, (signed long long int)s->inout.steps);
  min = s->lits.nonmin - s->lits.learned;
  sum = (signed int)(s->moved.bin + s->moved.trn);
  double return_value_lglpcnt$35;
  return_value_lglpcnt$35=lglpcnt((double)min, (double)s->lits.nonmin);
  lglprs(lgl, "mins: %lld learned lits, %.0f%% minimized", (signed long long int)s->lits.learned, return_value_lglpcnt$35);
  double return_value_lglpcnt$36;
  return_value_lglpcnt$36=lglpcnt((double)s->moved.bin, (double)sum);
  double return_value_lglpcnt$37;
  return_value_lglpcnt$37=lglpcnt((double)s->moved.trn, (double)sum);
  lglprs(lgl, "move: moved %lld, %lld binary %.0f%%, %lld ternary %.0f%%", sum, (signed long long int)s->moved.bin, return_value_lglpcnt$36, (signed long long int)s->moved.trn, return_value_lglpcnt$37);
  sum = s->otfs.str.dyn.red + s->otfs.str.dyn.irr;
  double return_value_lglpcnt$38;
  return_value_lglpcnt$38=lglpcnt((double)s->otfs.driving, (double)sum);
  double return_value_lglpcnt$39;
  return_value_lglpcnt$39=lglpcnt((double)s->otfs.restarting, (double)sum);
  lglprs(lgl, "otfs: str %d dyn (%d red, %d irr) %d drv %.0f%%, %d rst %.0f%%", sum, s->otfs.str.dyn.red, s->otfs.str.dyn.irr, s->otfs.driving, return_value_lglpcnt$38, s->otfs.restarting, return_value_lglpcnt$39);
  lglprs(lgl, "otfs: sub %d dyn (%d red, %d irr)", s->otfs.sub.dyn.red + s->otfs.sub.dyn.irr, s->otfs.sub.dyn.red, s->otfs.sub.dyn.irr);
  double return_value_lglpcnt$40;
  return_value_lglpcnt$40=lglpcnt((double)s->phase.pos, (double)s->phase.set);
  double return_value_lglpcnt$41;
  return_value_lglpcnt$41=lglpcnt((double)s->phase.neg, (double)s->phase.set);
  lglprs(lgl, "phas: %lld computed, %lld set, %lld pos (%.0f%%), %lld neg (%.0f%%)", (signed long long int)s->phase.count, (signed long long int)s->phase.set, (signed long long int)s->phase.pos, return_value_lglpcnt$40, (signed long long int)s->phase.neg, return_value_lglpcnt$41);
  lglprs(lgl, "prbs: %d basic, %lld probed, %d failed, %d lifted", s->prb.basic.count, (signed long long int)s->prb.basic.probed, s->prb.basic.failed, s->prb.basic.lifted);
  double return_value_lglavg$42;
  return_value_lglavg$42=lglavg((double)s->props.search, (double)s->decisions);
  lglprs(lgl, "prps: %lld props, %.0f props/dec", (signed long long int)p, return_value_lglavg$42);
  double return_value_lglpcnt$43;
  return_value_lglpcnt$43=lglpcnt((double)s->props.search, (double)p);
  double return_value_lglpcnt$44;
  return_value_lglpcnt$44=lglpcnt((double)s->props.simp, (double)p);
  double return_value_lglpcnt$45;
  return_value_lglpcnt$45=lglpcnt((double)s->props.lkhd, (double)p);
  lglprs(lgl, "prps: %.0f%% srch, %.0f%% simp, %.0f%% lkhd", return_value_lglpcnt$43, return_value_lglpcnt$44, return_value_lglpcnt$45);
  double return_value_lglpcnt$46;
  return_value_lglpcnt$46=lglpcnt((double)s->poison.hits, (double)s->poison.search);
  lglprs(lgl, "psns: %lld searches, %lld hits, %.0f%% hit rate", (signed long long int)s->poison.search, (signed long long int)s->poison.hits, return_value_lglpcnt$46);
  lglprs(lgl, "queu: %lld new, %lld del, %d maximum priority", (signed long long int)s->queue.new, (signed long long int)s->queue.del, s->queue.max);
  lglprs(lgl, "queu: %lld merged, %lld collected, %lld gcs", (signed long long int)s->queue.merged, (signed long long int)s->queue.col, (signed long long int)s->queue.gcs);
  double return_value_lglavg$47;
  return_value_lglavg$47=lglavg((double)s->queue.deprior.sum, (double)s->queue.deprior.count);
  lglprs(lgl, "queu: %lld deprioritized, %.1f lines on average", (signed long long int)s->queue.deprior.count, return_value_lglavg$47);
  double return_value_lglpcnt$48;
  return_value_lglpcnt$48=lglpcnt((double)s->acts, (double)s->reduced.count);
  double return_value_lglpcnt$49;
  return_value_lglpcnt$49=lglpcnt((double)s->reduced.geom, (double)s->reduced.count);
  lglprs(lgl, "reds: %d count, %d reset, %d acts %.0f%%, %d exp %.0f%%", s->reduced.count, s->reduced.reset, s->acts, return_value_lglpcnt$48, s->reduced.geom, return_value_lglpcnt$49);
  double return_value_lglpcnt$50;
  return_value_lglpcnt$50=lglpcnt((double)s->reduced.arith, (double)s->reduced.count);
  double return_value_lglpcnt$51;
  return_value_lglpcnt$51=lglpcnt((double)s->reduced.arith2, (double)s->reduced.arith);
  lglprs(lgl, "reds: %d arithmetic %.0f%%, %d double %.0f%%", s->reduced.arith, return_value_lglpcnt$50, s->reduced.arith2, return_value_lglpcnt$51);
  double return_value_lglpcnt$52;
  return_value_lglpcnt$52=lglpcnt((double)s->bindup.red, (double)s->bindup.removed);
  lglprs(lgl, "rmbd: %d removed, %d red %.0f%%", s->bindup.removed, s->bindup.red, return_value_lglpcnt$52);
  sum = s->restarts.count + s->restarts.skipped;
  double return_value_lglpcnt$53;
  return_value_lglpcnt$53=lglpcnt((double)s->restarts.count, (double)sum);
  double return_value_lglpcnt$54;
  return_value_lglpcnt$54=lglpcnt((double)s->restarts.skipped, (double)sum);
  lglprs(lgl, "rsts: %d restarts %.0f%%, %d skipped %.0f%%", s->restarts.count, return_value_lglpcnt$53, s->restarts.skipped, return_value_lglpcnt$54);
  double return_value_lglpcnt$55;
  return_value_lglpcnt$55=lglpcnt((double)s->restarts.kept.count, (double)s->restarts.count);
  double return_value_lglavg$56;
  return_value_lglavg$56=lglavg((double)s->restarts.kept.sum, (double)s->restarts.kept.count);
  lglprs(lgl, "rsts: %d kept %.1f%% average %.1f%%", s->restarts.kept.count, return_value_lglpcnt$55, return_value_lglavg$56);
  double return_value_lglpcnt$57;
  return_value_lglpcnt$57=lglpcnt((double)s->simp.ilimhit, (double)s->simp.count);
  double return_value_lglpcnt$58;
  return_value_lglpcnt$58=lglpcnt((double)s->simp.plimhit, (double)s->simp.count);
  double return_value_lglpcnt$59;
  return_value_lglpcnt$59=lglpcnt((double)s->simp.climhit, (double)s->simp.count);
  lglprs(lgl, "simp: %d count (%d ilim %.0f%%, %d plim %.0f%%, %d clim %0.f%%)", s->simp.count, s->simp.ilimhit, return_value_lglpcnt$57, s->simp.plimhit, return_value_lglpcnt$58, s->simp.climhit, return_value_lglpcnt$59);
  lglprs(lgl, "trnr: %d count, %d bin, %d trn, %lld steps", s->trnr.count, s->trnr.bin, s->trnr.trn, (signed long long int)s->trnr.steps);
  double return_value_lglpcnt$60;
  return_value_lglpcnt$60=lglpcnt((double)s->fixed.sum, (double)lgl->maxext);
  lglprs(lgl, "tops: %d fixed %.0f%%, %d iterations", s->fixed.sum, return_value_lglpcnt$60, s->iterations);
  lglprs(lgl, "trds: %d transitive reductions, %d removed, %d failed", s->trd.count, s->trd.red, s->trd.failed);
  lglprs(lgl, "trds: %lld nodes, %lld edges, %lld steps", (signed long long int)s->trd.lits, (signed long long int)s->trd.bins, (signed long long int)s->trd.steps);
  lglprs(lgl, "unhd: %d count, %d rounds, %lld steps", s->unhd.count, s->unhd.rounds, (signed long long int)s->unhd.steps);
  double return_value_lglavg$61;
  return_value_lglavg$61=lglavg((double)s->unhd.stamp.sumsccsizes, (double)s->unhd.stamp.sccs);
  lglprs(lgl, "unhd: %d non-trivial sccs of average size %.1f", s->unhd.stamp.sccs, return_value_lglavg$61);
  sum=lglunhdunits(lgl);
  lglprs(lgl, "unhd: %d units, %d bin, %d trn, %d lrg", sum, s->unhd.units.bin, s->unhd.units.trn, s->unhd.units.lrg);
  sum=lglunhdfailed(lgl);
  lglprs(lgl, "unhd: %d failed, %d stamp, %d lits, %d bin, %d trn, %d lrg", sum, s->unhd.stamp.failed, s->unhd.failed.lits, s->unhd.failed.bin, s->unhd.failed.trn, s->unhd.units.lrg);
  sum=lglunhdtauts(lgl);
  double return_value_lglpcnt$62;
  return_value_lglpcnt$62=lglpcnt((double)s->unhd.tauts.bin, (double)sum);
  double return_value_lglpcnt$63;
  return_value_lglpcnt$63=lglpcnt((double)s->unhd.tauts.trn, (double)sum);
  double return_value_lglpcnt$64;
  return_value_lglpcnt$64=lglpcnt((double)s->unhd.tauts.lrg, (double)sum);
  lglprs(lgl, "unhd: %d tauts, %d bin %.0f%%, %d trn %.0f%%, %d lrg %.0f%%", sum, s->unhd.tauts.bin, return_value_lglpcnt$62, s->unhd.tauts.trn, return_value_lglpcnt$63, s->unhd.tauts.lrg, return_value_lglpcnt$64);
  double return_value_lglpcnt$65;
  return_value_lglpcnt$65=lglpcnt((double)s->unhd.stamp.trds, (double)sum);
  double return_value_lglpcnt$66;
  return_value_lglpcnt$66=lglpcnt((double)s->unhd.tauts.red, (double)sum);
  lglprs(lgl, "unhd: %d tauts, %d stamp %.0f%%, %d red %.0f%%", sum, s->unhd.stamp.trds, return_value_lglpcnt$65, s->unhd.tauts.red, return_value_lglpcnt$66);
  sum=lglunhdhbrs(lgl);
  double return_value_lglpcnt$67;
  return_value_lglpcnt$67=lglpcnt((double)s->unhd.hbrs.trn, (double)sum);
  double return_value_lglpcnt$68;
  return_value_lglpcnt$68=lglpcnt((double)s->unhd.hbrs.lrg, (double)sum);
  double return_value_lglpcnt$69;
  return_value_lglpcnt$69=lglpcnt((double)s->unhd.hbrs.red, (double)sum);
  lglprs(lgl, "unhd: %d hbrs, %d trn %.0f%%, %d lrg %.0f%%, %d red %.0f%%", sum, s->unhd.hbrs.trn, return_value_lglpcnt$67, s->unhd.hbrs.lrg, return_value_lglpcnt$68, s->unhd.hbrs.red, return_value_lglpcnt$69);
  sum=lglunhdstrd(lgl);
  double return_value_lglpcnt$70;
  return_value_lglpcnt$70=lglpcnt((double)s->unhd.units.bin, (double)sum);
  double return_value_lglpcnt$71;
  return_value_lglpcnt$71=lglpcnt((double)s->unhd.str.trn, (double)sum);
  double return_value_lglpcnt$72;
  return_value_lglpcnt$72=lglpcnt((double)s->unhd.str.lrg, (double)sum);
  double return_value_lglpcnt$73;
  return_value_lglpcnt$73=lglpcnt((double)s->unhd.str.red, (double)sum);
  lglprs(lgl, "unhd: %d strd, %d bin %.0f%%, %d trn %.0f%%, %d lrg %.0f%%, %d red %.0f%%", sum, s->unhd.units.bin, return_value_lglpcnt$70, s->unhd.str.trn, return_value_lglpcnt$71, s->unhd.str.lrg, return_value_lglpcnt$72, s->unhd.str.red, return_value_lglpcnt$73);
  removed = s->fixed.sum + s->elm.elmd + s->equiv.sum;
  remaining = lgl->maxext - removed;
  double return_value_lglpcnt$74;
  return_value_lglpcnt$74=lglpcnt((double)remaining, (double)lgl->maxext);
  double return_value_lglpcnt$75;
  return_value_lglpcnt$75=lglpcnt((double)removed, (double)lgl->maxext);
  lglprs(lgl, "vars: %d remaining %.0f%% and %d removed %.0f%% out of %d", remaining, return_value_lglpcnt$74, removed, return_value_lglpcnt$75, lgl->maxext);
  double return_value_lglpcnt$76;
  return_value_lglpcnt$76=lglpcnt((double)s->fixed.sum, (double)lgl->maxext);
  double return_value_lglpcnt$77;
  return_value_lglpcnt$77=lglpcnt((double)s->elm.elmd, (double)lgl->maxext);
  double return_value_lglpcnt$78;
  return_value_lglpcnt$78=lglpcnt((double)s->equiv.sum, (double)lgl->maxext);
  lglprs(lgl, "vars: %d fixed %.0f%%, %d eliminated %.0f%%, %d equivalent %.0f%%", s->fixed.sum, return_value_lglpcnt$76, s->elm.elmd, return_value_lglpcnt$77, s->equiv.sum, return_value_lglpcnt$78);
  v = s->visits.search + s->visits.simp + s->visits.lkhd;
  double return_value_lglpcnt$79;
  return_value_lglpcnt$79=lglpcnt((double)s->visits.search, (double)v);
  double return_value_lglpcnt$80;
  return_value_lglpcnt$80=lglpcnt((double)s->visits.simp, (double)v);
  double return_value_lglpcnt$81;
  return_value_lglpcnt$81=lglpcnt((double)s->visits.lkhd, (double)v);
  lglprs(lgl, "vsts: %lld visits, %.0f%% srch, %.0f%% simp, %.0f%% lkhd", (signed long long int)v, return_value_lglpcnt$79, return_value_lglpcnt$80, return_value_lglpcnt$81);
  double return_value_lglavg$82;
  return_value_lglavg$82=lglavg((double)s->visits.search, (double)s->props.search);
  double return_value_lglavg$83;
  return_value_lglavg$83=lglavg((double)s->visits.search, (double)s->confs);
  lglprs(lgl, "vsts: %.1f search visits per propagation %.1f per conflict", return_value_lglavg$82, return_value_lglavg$83);
  lglprs(lgl, "wchs: %lld pushed, %lld enlarged, %d defrags", (signed long long int)s->pshwchs, (signed long long int)s->enlwchs, s->defrags);
  lglgluestats(lgl);
  lglprs(lgl, "");
  double return_value_lglavg$84;
  return_value_lglavg$84=lglavg((double)s->confs, t);
  lglprs(lgl, "%lld decisions, %lld conflicts, %.1f conflicts/sec", (signed long long int)s->decisions, (signed long long int)s->confs, return_value_lglavg$84);
  double return_value_lglavg$85;
  return_value_lglavg$85=lglavg((double)p / 1e6, t);
  lglprs(lgl, "%lld propagations, %.1f megaprops/sec", (signed long long int)p, return_value_lglavg$85);
  double return_value_lglmaxmb$86;
  return_value_lglmaxmb$86=lglmaxmb(lgl);
  lglprs(lgl, "%.1f seconds, %.1f MB", t, return_value_lglmaxmb$86);
  lglprs(lgl, "");
  double return_value_lglpcnt$87;
  return_value_lglpcnt$87=lglpcnt(ts->ana, t);
  lglprs(lgl, "%8.3f %3.0f%% analysis", ts->ana, return_value_lglpcnt$87);
  double return_value_lglpcnt$88;
  return_value_lglpcnt$88=lglpcnt(ts->blk, t);
  lglprs(lgl, "%8.3f %3.0f%% block", ts->blk, return_value_lglpcnt$88);
  double return_value_lglpcnt$89;
  return_value_lglpcnt$89=lglpcnt(ts->bump, t);
  lglprs(lgl, "%8.3f %3.0f%% bump", ts->bump, return_value_lglpcnt$89);
  double return_value_lglpcnt$90;
  return_value_lglpcnt$90=lglpcnt(ts->card, t);
  lglprs(lgl, "%8.3f %3.0f%% card", ts->card, return_value_lglpcnt$90);
  double return_value_lglpcnt$91;
  return_value_lglpcnt$91=lglpcnt(ts->cce, t);
  lglprs(lgl, "%8.3f %3.0f%% cce", ts->cce, return_value_lglpcnt$91);
  double return_value_lglpcnt$92;
  return_value_lglpcnt$92=lglpcnt(ts->cliff, t);
  lglprs(lgl, "%8.3f %3.0f%% cliff", ts->cliff, return_value_lglpcnt$92);
  double return_value_lglpcnt$93;
  return_value_lglpcnt$93=lglpcnt(ts->ctw, t);
  lglprs(lgl, "%8.3f %3.0f%% cutwidth", ts->ctw, return_value_lglpcnt$93);
  double return_value_lglpcnt$94;
  return_value_lglpcnt$94=lglpcnt(ts->dec, t);
  lglprs(lgl, "%8.3f %3.0f%% decide", ts->dec, return_value_lglpcnt$94);
  double return_value_lglpcnt$95;
  return_value_lglpcnt$95=lglpcnt(ts->force, t);
  lglprs(lgl, "%8.3f %3.0f%% force", ts->force, return_value_lglpcnt$95);
  double return_value_lglpcnt$96;
  return_value_lglpcnt$96=lglpcnt(ts->gc, t);
  lglprs(lgl, "%8.3f %3.0f%% gc", ts->gc, return_value_lglpcnt$96);
  double return_value_lglpcnt$97;
  return_value_lglpcnt$97=lglpcnt(ts->cgr, t);
  lglprs(lgl, "%8.3f %3.0f%% cgrclsr", ts->cgr, return_value_lglpcnt$97);
  double return_value_lglpcnt$98;
  return_value_lglpcnt$98=lglpcnt(ts->dcp, t);
  lglprs(lgl, "%8.3f %3.0f%% decomp", ts->dcp, return_value_lglpcnt$98);
  double return_value_lglpcnt$99;
  return_value_lglpcnt$99=lglpcnt(ts->dfg, t);
  lglprs(lgl, "%8.3f %3.0f%% defrag", ts->dfg, return_value_lglpcnt$99);
  double return_value_lglpcnt$100;
  return_value_lglpcnt$100=lglpcnt(ts->elm, t);
  lglprs(lgl, "%8.3f %3.0f%% elim", ts->elm, return_value_lglpcnt$100);
  double return_value_lglpcnt$101;
  return_value_lglpcnt$101=lglpcnt(ts->gauss, t);
  lglprs(lgl, "%8.3f %3.0f%% gauss", ts->gauss, return_value_lglpcnt$101);
  double return_value_lglpcnt$102;
  return_value_lglpcnt$102=lglpcnt(ts->lft, t);
  lglprs(lgl, "%8.3f %3.0f%% lift", ts->lft, return_value_lglpcnt$102);
  double return_value_lglpcnt$103;
  return_value_lglpcnt$103=lglpcnt(ts->mcls, t);
  lglprs(lgl, "%8.3f %3.0f%% mincls", ts->mcls, return_value_lglpcnt$103);
  double return_value_lglpcnt$104;
  return_value_lglpcnt$104=lglpcnt(ts->phs, t);
  lglprs(lgl, "%8.3f %3.0f%% phase", ts->phs, return_value_lglpcnt$104);
  double return_value_lglpcnt$105;
  return_value_lglpcnt$105=lglpcnt(ts->prb.all, t);
  lglprs(lgl, "%8.3f %3.0f%% probe", ts->prb.all, return_value_lglpcnt$105);
  double return_value_lglpcnt$106;
  return_value_lglpcnt$106=lglpcnt(ts->red, t);
  lglprs(lgl, "%8.3f %3.0f%% reduce", ts->red, return_value_lglpcnt$106);
  double return_value_lglpcnt$107;
  return_value_lglpcnt$107=lglpcnt(ts->rsts, t);
  lglprs(lgl, "%8.3f %3.0f%% restart", ts->rsts, return_value_lglpcnt$107);
  double return_value_lglpcnt$108;
  return_value_lglpcnt$108=lglpcnt(ts->trn, t);
  lglprs(lgl, "%8.3f %3.0f%% ternres", ts->trn, return_value_lglpcnt$108);
  double return_value_lglpcnt$109;
  return_value_lglpcnt$109=lglpcnt(ts->trd, t);
  lglprs(lgl, "%8.3f %3.0f%% transred", ts->trd, return_value_lglpcnt$109);
  double return_value_lglpcnt$110;
  return_value_lglpcnt$110=lglpcnt(ts->unhd, t);
  lglprs(lgl, "%8.3f %3.0f%% unhide", ts->unhd, return_value_lglpcnt$110);
  lglprs(lgl, "==================================");
  simp = ts->prep + ts->inpr;
  double return_value_lglpcnt$111;
  return_value_lglpcnt$111=lglpcnt(ts->prep, t);
  double return_value_lglpcnt$112;
  return_value_lglpcnt$112=lglpcnt(ts->prep, simp);
  lglprs(lgl, "%8.3f %3.0f%% preprocessing   %3.0f%%", ts->prep, return_value_lglpcnt$111, return_value_lglpcnt$112);
  double return_value_lglpcnt$113;
  return_value_lglpcnt$113=lglpcnt(ts->inpr, t);
  double return_value_lglpcnt$114;
  return_value_lglpcnt$114=lglpcnt(ts->inpr, simp);
  lglprs(lgl, "%8.3f %3.0f%% inprocessing    %3.0f%%", ts->inpr, return_value_lglpcnt$113, return_value_lglpcnt$114);
  lglprs(lgl, "==================================");
  double return_value_lglpcnt$115;
  return_value_lglpcnt$115=lglpcnt(simp, t);
  lglprs(lgl, "%8.3f %3.0f%% simplifying", simp, return_value_lglpcnt$115);
  double return_value_lglpcnt$116;
  return_value_lglpcnt$116=lglpcnt(ts->lkhd, t);
  lglprs(lgl, "%8.3f %3.0f%% lookahead", ts->lkhd, return_value_lglpcnt$116);
  search = ts->srch - ts->inpr;
  double return_value_lglpcnt$117;
  return_value_lglpcnt$117=lglpcnt(search, t);
  lglprs(lgl, "%8.3f %3.0f%% search", search, return_value_lglpcnt$117);
  lglprs(lgl, "==================================");
  lglprs(lgl, "%8.3f %3.0f%% all", t, 100.0);
  fflush(lgl->out);
}

// lglsteps
// file lglib.c line 8309
static signed long int lglsteps(struct LGL *lgl)
{
  signed long int steps = lgl->stats->props.simp;
  steps = steps + lgl->stats->props.search;
  steps = steps + lgl->stats->props.lkhd;
  steps = steps + lgl->stats->trd.steps;
  steps = steps + lgl->stats->unhd.steps;
  steps = steps + lgl->stats->elm.steps;
  return steps;
}

// lglstop
// file lglib.c line 4991
static void lglstop(struct LGL *lgl)
{
  lglflushtimers(lgl);
  lgl->timers->nest = lgl->timers->nest - 1;
}

// lglstrdup
// file lglib.c line 1300
static char * lglstrdup(struct LGL *lgl, const char *str)
{
  char *res;
  do
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    void *return_value_lglnew$2;
    return_value_lglnew$2=lglnew(lgl, (return_value_strlen$1 + (unsigned long int)1) * sizeof(char) /*1ul*/ );
    res = (char *)return_value_lglnew$2;
  }
  while((_Bool)0);
  char *return_value_strcpy$3;
  return_value_strcpy$3=strcpy(res, str);
  return return_value_strcpy$3;
}

// lglsynceqs
// file lglib.c line 12204
static signed int lglsynceqs(struct LGL *lgl)
{
  signed int *ereprs;
  signed int emax = lgl->maxext;
  signed int elit1;
  signed int erepr1;
  signed int elit2;
  signed int erepr2;
  signed int ilit1;
  signed int irepr1;
  signed int ilit2;
  signed int irepr2;
  signed int consumed = 0;
  signed int produced = 0;
  if(lgl->nvars == 0)
    return 1;

  else
    if(lgl->cbs == ((struct Cbs *)NULL))
      return 1;

    else
      if(lgl->cbs->eqs.lock.fun == ((signed int * (*)(void *))NULL))
        return 1;

      else
      {
        ereprs=lgl->cbs->eqs.lock.fun(lgl->cbs->eqs.lock.state);
        consumed = 0;
        produced = consumed;
        elit1 = 1;
        if(emax >= elit1)
        {
          signed int return_value_lglelitblockingoreliminated$1;
          return_value_lglelitblockingoreliminated$1=lglelitblockingoreliminated(lgl, elit1);
          if(return_value_lglelitblockingoreliminated$1 == 0)
          {
            elit2=lglptrjmp(ereprs, emax, elit1);
            if(!(elit2 == elit1))
            {
              signed int return_value_lglelitblockingoreliminated$2;
              return_value_lglelitblockingoreliminated$2=lglelitblockingoreliminated(lgl, elit2);
              if(return_value_lglelitblockingoreliminated$2 == 0)
              {
                erepr1=lglerepr(lgl, elit1);
                signed int return_value_lglelitblockingoreliminated$3;
                return_value_lglelitblockingoreliminated$3=lglelitblockingoreliminated(lgl, erepr1);
                if(return_value_lglelitblockingoreliminated$3 == 0)
                {
                  erepr2=lglerepr(lgl, elit2);
                  signed int return_value_lglelitblockingoreliminated$4;
                  return_value_lglelitblockingoreliminated$4=lglelitblockingoreliminated(lgl, erepr2);
                  if(return_value_lglelitblockingoreliminated$4 == 0)
                  {
                    if(!(erepr1 == erepr2))
                    {
                      if(erepr1 == -erepr2)
                      {

                      INCONSISTENT:
                        ;
                        lgl->mt = 1;
                      }

                      ilit1=lglimport(lgl, elit1);
                      ilit2=lglimport(lgl, elit2);
                      if(!(ilit1 == ilit2))
                      {
                        signed int return_value_abs$5;
                        return_value_abs$5=abs(ilit1);
                        if(return_value_abs$5 >= 2)
                        {
                          signed int return_value_abs$6;
                          return_value_abs$6=abs(ilit2);
                          if(return_value_abs$6 >= 2)
                          {
                            irepr1=lglirepr(lgl, ilit1);
                            irepr2=lglirepr(lgl, ilit2);
                            if(!(irepr1 == irepr2))
                            {
                              signed int return_value_abs$7;
                              return_value_abs$7=abs(irepr1);
                              if(return_value_abs$7 >= 2)
                              {
                                signed int return_value_abs$8;
                                return_value_abs$8=abs(irepr2);
                                if(return_value_abs$8 >= 2)
                                {
                                  signed int return_value_lglisfree$9;
                                  return_value_lglisfree$9=lglisfree(lgl, irepr1);
                                  if(!(return_value_lglisfree$9 == 0))
                                  {
                                    signed int return_value_lglisfree$10;
                                    return_value_lglisfree$10=lglisfree(lgl, irepr2);
                                    if(!(return_value_lglisfree$10 == 0))
                                    {
                                      consumed = consumed + 1;
                                      lglimerge(lgl, irepr1, irepr2);
                                    }

                                  }

                                }

                              }

                            }

                          }

                        }

                      }

                    }

                  }

                }

              }

            }

          }

          elit1 = elit1 + 1;
        }

        elit1 = 1;
        if(emax >= elit1)
        {
          elit2=lglerepr(lgl, elit1);
          if(!(elit1 == elit2))
          {
            erepr1=lglptrjmp(ereprs, emax, elit1);
            erepr2=lglptrjmp(ereprs, emax, elit2);
            if(!(erepr1 == erepr2))
            {
              produced = produced + 1;
              signed int return_value_abs$11;
              return_value_abs$11=abs(erepr1);
              ereprs[(signed long int)return_value_abs$11] = erepr1 < 0 ? -erepr2 : erepr2;
            }

          }

          elit1 = elit1 + 1;
        }


      DONE:
        ;
        if(!(lgl->cbs->eqs.unlock.fun == ((void (*)(void *, signed int, signed int))NULL)))
          lgl->cbs->eqs.unlock.fun(lgl->cbs->eqs.unlock.state, consumed, produced);

        return (signed int)!(lgl->mt != 0);
      }
}

// lglsyncunits
// file lglib.c line 8333
static signed int lglsyncunits(struct LGL *lgl)
{
  signed int *units;
  signed int *eou;
  signed int *p;
  signed int elit;
  signed int erepr;
  signed int ilit;
  signed int res;
  signed int count = 0;
  void (*produce)(void *, signed int);
  signed long int steps;
  struct Ext *ext;
  signed char val;
  signed int return_value_lglevel$1;
  signed int return_value_lglisfree$2;
  if(!(lgl->mt == 0))
    return 0;

  else
    if(lgl->cbs == ((struct Cbs *)NULL))
      return 1;

    else
      if(lgl->cbs->units.consume.fun == ((void (*)(void *, signed int **, signed int **))NULL))
        return 1;

      else
      {
        steps=lglsteps(lgl);
        if(!(steps >= lgl->limits->sync.steps))
          return 1;

        else
        {
          lgl->limits->sync.steps = steps + (signed long int)lgl->opts->syncint.val;
          lgl->cbs->units.consume.fun(lgl->cbs->units.consume.state, &units, &eou);
          if(units == eou)
            return 1;

          else
          {
            produce = lgl->cbs->units.produce.fun;
            lgl->cbs->units.produce.fun = ((void (*)(void *, signed int))NULL);
            p = units;
            if(lgl->mt == 0 && !(p >= eou))
            {
              elit = *p;
              erepr=lglerepr(lgl, elit);
              ext=lglelit2ext(lgl, erepr);
              ilit = ext->repr;
              if(!(ilit == 0))
              {
                if(!(erepr >= 0))
                  ilit = -ilit;

                if(!(ilit == 1))
                {
                  if(ilit == -1)
                    val = (signed char)-1;

                  else
                  {
                    val=lglval(lgl, ilit);
                    if(!(val == 0))
                    {
                      return_value_lglevel$1=lglevel(lgl, ilit);
                      if(!(return_value_lglevel$1 == 0))
                        val = (signed char)0;

                    }

                  }
                  if(!((signed int)val == 1))
                  {
                    if((signed int)val == -1)
                    {
                      if(lgl->level >= 1)
                        lglbacktrack(lgl, 0);

                      lgl->mt = 1;
                    }

                    else
                    {
                      return_value_lglisfree$2=lglisfree(lgl, ilit);
                      if(!(return_value_lglisfree$2 == 0))
                      {
                        if(lgl->level >= 1)
                          lglbacktrack(lgl, 0);

                        lglunit(lgl, ilit);
                        count = count + 1;
                      }

                    }
                  }

                }

              }

              p = p + 1l;
            }

            lgl->cbs->units.produce.fun = produce;
            if(!(lgl->cbs->units.consumed.fun == ((void (*)(void *, signed int))NULL)))
              lgl->cbs->units.consumed.fun(lgl->cbs->units.consumed.state, count);

            if(!(lgl->mt == 0))
              return 0;

            else
              if(count == 0)
                return 1;

              else
              {
                res=lglbcp(lgl);
                if(res == 0)
                {
                  if(lgl->mt == 0)
                    lgl->mt = 1;

                }

                return res;
              }
          }
        }
      }
}

// lglszpen
// file lglib.c line 8728
static signed int lglszpen(struct LGL *lgl)
{
  signed int res;
  res=lglceilld(lgl->stats->irr.lits.cur / lgl->opts->sizepen.val);
  if(!(res >= 0))
    res = 0;

  if(!(lgl->opts->sizemaxpen.val >= res))
    res = lgl->opts->sizemaxpen.val;

  return res;
}

// lglszstk
// file lglib.c line 1389
static unsigned long int lglszstk(struct Stk *s)
{
  return (unsigned long int)(s->end - s->start);
}

// lgltarjan
// file lglib.c line 8194
static signed int lgltarjan(struct LGL *lgl)
{
  signed int *dfsimap;
  signed int *mindfsimap;
  signed int idx;
  signed int oidx;
  signed int sign;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int other;
  signed int dfsi;
  signed int mindfsi;
  signed int ulit;
  signed int uother;
  signed int tmp;
  signed int repr;
  signed int res;
  signed int sgn;
  signed int frozen;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  struct Stk stk;
  struct Stk component;
  struct AVar *av;
  struct HTS *hts;
  signed int return_value_lglmtstk$4;
  signed int return_value_lglifrozen$6;
  if(lgl->nvars == 0)
    return 1;

  else
  {
    lglfreezer(lgl);
    dfsi = 0;
    do
    {
      void *return_value_lglnew$1;
      return_value_lglnew$1=lglnew(lgl, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
      dfsimap = (signed int *)return_value_lglnew$1;
    }
    while((_Bool)0);
    do
    {
      void *return_value_lglnew$2;
      return_value_lglnew$2=lglnew(lgl, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
      mindfsimap = (signed int *)return_value_lglnew$2;
    }
    while((_Bool)0);
    do
    {
      void *return_value_lglnew$3;
      return_value_lglnew$3=lglnew(lgl, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
      lgl->repr = (signed int *)return_value_lglnew$3;
    }
    while((_Bool)0);
    do
      memset((void *)&stk, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    do
      memset((void *)&component, 0, sizeof(struct Stk) /*24ul*/ );
    while((_Bool)0);
    res = 1;
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      sign = -1;
      for( ; !(sign >= 2); sign = sign + 2)
      {
        lit = sign * idx;
        ulit=lglulit(lit);
        tmp = dfsimap[(signed long int)ulit];
        if(tmp == 0)
        {
          lglpushstk(lgl, &stk, lit);
          do
          {
            return_value_lglmtstk$4=lglmtstk(&stk);
            if(!(return_value_lglmtstk$4 == 0))
              break;

            lit=lglpopstk(&stk);
            if(!(lit == 0))
            {
              ulit=lglulit(lit);
              if(!(dfsimap[(signed long int)ulit] == 0))
                continue;

              dfsi = dfsi + 1;
              mindfsimap[(signed long int)ulit] = dfsi;
              dfsimap[(signed long int)ulit] = mindfsimap[(signed long int)ulit];
              lglpushstk(lgl, &component, lit);
              lglpushstk(lgl, &stk, lit);
              lglpushstk(lgl, &stk, 0);
              hts=lglhts(lgl, -lit);
              if(hts->offset == 0)
                continue;

              w=lglhts2wchs(lgl, hts);
              eow = w + (signed long int)hts->count;
              p = w;
              for( ; !(p >= eow); p = p + 1l)
              {
                blit = *p;
                tag = blit & MASKCS;
                if(!(tag == BINCS))
                  p = p + 1l;

                else
                {
                  other = blit >> RMSHFT;
                  uother=lglulit(other);
                  tmp = dfsimap[(signed long int)uother];
                  if(tmp == 0)
                    lglpushstk(lgl, &stk, other);

                }
              }
            }

            else
            {
              lit=lglpopstk(&stk);
              ulit=lglulit(lit);
              mindfsi = dfsimap[(signed long int)ulit];
              hts=lglhts(lgl, -lit);
              w=lglhts2wchs(lgl, hts);
              eow = w + (signed long int)hts->count;
              p = w;
              for( ; !(p >= eow); p = p + 1l)
              {
                blit = *p;
                tag = blit & MASKCS;
                if(!(tag == BINCS))
                  p = p + 1l;

                else
                {
                  other = blit >> RMSHFT;
                  uother=lglulit(other);
                  tmp = mindfsimap[(signed long int)uother];
                  if(!(tmp >= mindfsi))
                    mindfsi = tmp;

                }
              }
              if(mindfsi == dfsimap[(signed long int)ulit])
              {
                repr = lit;
                frozen=lglifrozen(lgl, repr);
                p = component.top - (signed long int)1;
                do
                {
                  other = *p;
                  if(other == lit)
                    break;

                  signed int return_value_lglcmprepr$5;
                  return_value_lglcmprepr$5=lglcmprepr(lgl, other, repr);
                  if(!(return_value_lglcmprepr$5 >= 0))
                    repr = other;

                  if(frozen == 0)
                  {
                    return_value_lglifrozen$6=lglifrozen(lgl, other);
                    if(!(return_value_lglifrozen$6 == 0))
                      frozen = 1;

                  }

                  p = p - 1l;
                }
                while((_Bool)1);
                do
                {
                  other=lglpopstk(&component);
                  if(other == lit)
                    break;

                  signed int return_value_lglulit$7;
                  return_value_lglulit$7=lglulit(other);
                  mindfsimap[(signed long int)return_value_lglulit$7] = 0x7fffffff;
                  if(!(other == repr))
                  {
                    if(other == -repr)
                    {

                    __CPROVER_DUMP_L24:
                      ;
                      lgl->mt = 1;
                      res = 0;
                      goto DONE;
                    }

                    sgn=lglsgn(other);
                    oidx=abs(other);
                    tmp = lgl->repr[(signed long int)oidx];
                    if(!(tmp == repr * sgn))
                    {

                    __CPROVER_DUMP_L26:
                      ;
                      if(!(tmp == 0))
                      {

                      __CPROVER_DUMP_L27:
                        ;
                        lgl->mt = 1;
                        res = 0;
                        goto DONE;
                      }

                      else
                      {
                        av=lglavar(lgl, oidx);
                        if((signed int)av->type == FREEVAR)
                          lglimerge(lgl, other, repr);

                      }
                    }

                  }

                }
                while((_Bool)1);
                signed int return_value_lglulit$8;
                return_value_lglulit$8=lglulit(lit);
                mindfsimap[(signed long int)return_value_lglulit$8] = 0x7fffffff;
                if(!(frozen == 0))

                  __CPROVER_DUMP_L32:
                    ;

              }

              else
                mindfsimap[(signed long int)ulit] = mindfsi;
            }
          }
          while((_Bool)1);
        }

      }
    }

  DONE:
    ;
    lglrelstk(lgl, &stk);
    lglrelstk(lgl, &component);
    do
    {
      lgldel(lgl, (void *)mindfsimap, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
      mindfsimap = ((signed int *)NULL);
    }
    while((_Bool)0);
    do
    {
      lgldel(lgl, (void *)dfsimap, (unsigned long int)(2 * lgl->nvars) * sizeof(signed int) /*4ul*/ );
      dfsimap = ((signed int *)NULL);
    }
    while((_Bool)0);
    if(res == 0)
      do
      {
        lgldel(lgl, (void *)lgl->repr, (unsigned long int)lgl->nvars * sizeof(signed int) /*4ul*/ );
        lgl->repr = ((signed int *)NULL);
      }
      while((_Bool)0);

    return res;
  }
}

// lgltd
// file lglib.c line 2334
static struct TD * lgltd(struct LGL *lgl, signed int lit)
{
  signed int pos;
  pos=lgltrail(lgl, lit);
  return lgl->drail + (signed long int)pos;
}

// lglterminate
// file lglib.c line 8319
static signed int lglterminate(struct LGL *lgl)
{
  signed long int steps;
  signed int res;
  if(lgl->cbs == ((struct Cbs *)NULL))
    return 0;

  else
    if(lgl->cbs->term.fun == ((signed int (*)(void *))NULL))
      return 0;

    else
      if(!(lgl->cbs->term.done == 0))
        return 1;

      else
      {
        steps=lglsteps(lgl);
        if(!(steps >= lgl->limits->term.steps))
          return 0;

        else
        {
          res=lgl->cbs->term.fun(lgl->cbs->term.state);
          if(!(res == 0))
            lgl->cbs->term.done = res;

          else
            lgl->limits->term.steps = steps + (signed long int)lgl->opts->termint.val;
          return res;
        }
      }
}

// lglternres
// file lglib.c line 14734
static signed int lglternres(struct LGL *lgl)
{
  signed int before;
  signed int after;
  signed int delta;
  signed int before2;
  signed int after2;
  signed int delta2;
  signed int before3;
  signed int after3;
  signed int delta3;
  signed int success;
  signed int lit;
  if(!(lgl->nvars >= 3))
    return 1;

  else
  {
    lglstart(lgl, &lgl->times->trn);

  __CPROVER_DUMP_L2:
    ;
    lgl->ternresing = (char)1;
    lgl->simp = lgl->ternresing;
    lgl->stats->trnr.count = lgl->stats->trnr.count + 1;
    if(lgl->level >= 1)
      lglbacktrack(lgl, 0);

    lglseternreslim(lgl);
    lglternresinit(lgl);
    before2 = lgl->stats->trnr.bin;
    before3 = lgl->stats->trnr.trn;
    while(!(lgl->stats->trnr.steps >= lgl->limits->trnr.steps))
    {
      signed int return_value_lglterminate$1;
      return_value_lglterminate$1=lglterminate(lgl);
      if(!(return_value_lglterminate$1 == 0))
        break;

      signed int return_value_lglsyncunits$2;
      return_value_lglsyncunits$2=lglsyncunits(lgl);
      if(return_value_lglsyncunits$2 == 0)
        break;

      lit=lglwrknext(lgl);
      if(lit == 0)
      {
        lglprt(lgl, 2, "[ternres-%d] saturated", lgl->stats->trnr.count);
        break;
      }

      lgl->stats->trnr.steps = lgl->stats->trnr.steps + 1l;
      signed int return_value_lglisfree$3;
      return_value_lglisfree$3=lglisfree(lgl, lit);
      if(!(return_value_lglisfree$3 == 0))
      {
        struct AVar *return_value_lglavar$4;
        return_value_lglavar$4=lglavar(lgl, lit);
        return_value_lglavar$4->donoternres = (unsigned int)1;
        lglternresidx(lgl, lit);
      }

    }
    after2 = lgl->stats->trnr.bin;
    after3 = lgl->stats->trnr.trn;
    after = after2 + after3;
    before = before2 + before3;
    delta2 = after2 - before2;
    delta3 = after3 - before3;
    delta = after - before;
    success = (signed int)(before < after);
    lglprt(lgl, 1, "[ternres-%d] %d ternary resolvents (%d bin, %d trn)", lgl->stats->trnr.count, delta, delta2, delta3);
    lglupdternrespen(lgl, success);
    lgl->ternresing = (char)0;
    lgl->simp = lgl->ternresing;
    lglprternresrem(lgl);
    lglrep(lgl, 1 + (signed int)!(success != 0), (char)84);
    lglwrkreset(lgl);
    lglstop(lgl);
    return (signed int)!(lgl->mt != 0);
  }
}

// lglternresidx
// file lglib.c line 14651
static void lglternresidx(struct LGL *lgl, signed int idx)
{
  lglternreslit(lgl, idx);
  lglternreslit(lgl, -idx);
}

// lglternresinit
// file lglib.c line 14706
static void lglternresinit(struct LGL *lgl)
{
  signed int idx;
  signed int schedulable = 0;
  signed int donoternres = 0;
  lglwrkinit(lgl, 1, 1);
  idx = 2;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    signed int return_value_lglisfree$1;
    return_value_lglisfree$1=lglisfree(lgl, idx);
    if(!(return_value_lglisfree$1 == 0))
    {
      struct AVar *return_value_lglavar$2;
      return_value_lglavar$2=lglavar(lgl, idx);
      if(!(return_value_lglavar$2->donoternres == 0u))
        donoternres = donoternres + 1;

      else
        schedulable = schedulable + 1;
    }

  }
  if(schedulable == 0)
  {
    donoternres = 0;
    idx = 2;
    for( ; !(idx >= lgl->nvars); idx = idx + 1)
    {
      signed int return_value_lglisfree$3;
      return_value_lglisfree$3=lglisfree(lgl, idx);
      if(!(return_value_lglisfree$3 == 0))
      {
        struct AVar *return_value_lglavar$4;
        return_value_lglavar$4=lglavar(lgl, idx);
        return_value_lglavar$4->donoternres = (unsigned int)0;
        schedulable = schedulable + 1;
      }

    }
  }

  double return_value_lglpcnt$5;
  if(donoternres == 0)
    lglprt(lgl, 1, "[ternres-%d] all %d free variables schedulable", lgl->stats->trnr.count, schedulable);

  else
  {
    return_value_lglpcnt$5=lglpcnt((double)schedulable, (double)(lgl->nvars - 2));
    lglprt(lgl, 1, "[ternres-%d] %d schedulable variables %.0f%%", lgl->stats->trnr.count, schedulable, return_value_lglpcnt$5);
  }
  lgl->donotsched = (char)1;
  lglrandidxtrav(lgl, lglwrktouch);
  lgl->donotsched = (char)0;
}

// lglternreslit
// file lglib.c line 14550
static void lglternreslit(struct LGL *lgl, signed int lit)
{
  signed int *pw;
  signed int *peow;
  signed int *nw;
  signed int *neow;
  signed int *p;
  signed int *n;
  signed int pblit;
  signed int ptag;
  signed int pother;
  signed int pother2;
  signed int pdelta;
  signed int nblit;
  signed int ntag;
  signed int nother;
  signed int nother2;
  signed int ndelta;
  struct HTS *phts;
  struct HTS *nhts;
  signed int a;
  signed int b;
  signed int c;
  phts=lglhts(lgl, lit);
  pw=lglhts2wchs(lgl, phts);
  peow = pw + (signed long int)phts->count;
  nhts=lglhts(lgl, -lit);
  nw=lglhts2wchs(lgl, nhts);
  neow = nw + (signed long int)nhts->count;
  n = nw;
  for( ; !(n >= neow); n = n + 1l)
  {
    lgl->stats->trnr.steps = lgl->stats->trnr.steps + 1l;
    if(lgl->stats->trnr.steps >= lgl->limits->trnr.steps)
      goto __CPROVER_DUMP_L28;

    nblit = *n;
    ntag = nblit & MASKCS;
    if(!(ntag == OCCS) && !(ntag == BINCS))
    {
      if(ntag == TRNCS)
        break;

      n = n + 1l;
    }

  }
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$4;
  if(!(n >= neow))
  {
    p = pw;
    do
    {
      if(!(p >= peow))
        tmp_if_expr$1 = lgl->stats->trnr.steps < lgl->limits->trnr.steps ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      lgl->stats->trnr.steps = lgl->stats->trnr.steps + 1l;
      pblit = *p;
      ptag = pblit & MASKCS;
      if(!(ptag == OCCS) && !(ptag == BINCS))
      {
        if(ptag == TRNCS || ptag == LRGCS)
          p = p + 1l;

        if(!(ptag == LRGCS))
        {
          pother = pblit >> RMSHFT;
          signed char return_value_lglval$2;
          return_value_lglval$2=lglval(lgl, pother);
          if(return_value_lglval$2 == 0)
          {
            pother2 = *p;
            signed char return_value_lglval$3;
            return_value_lglval$3=lglval(lgl, pother2);
            if(return_value_lglval$3 == 0)
            {
              n = nw;
              do
              {
                if(!(n >= neow))
                  tmp_if_expr$4 = lgl->stats->trnr.steps < lgl->limits->trnr.steps ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$4 = (_Bool)0;
                if(!tmp_if_expr$4)
                  break;

                lgl->stats->trnr.steps = lgl->stats->trnr.steps + 1l;
                nblit = *n;
                ntag = nblit & MASKCS;
                if(!(ntag == OCCS) && !(ntag == BINCS))
                {
                  if(ntag == TRNCS || ntag == LRGCS)
                    n = n + 1l;

                  if(!(ntag == LRGCS))
                  {
                    nother = nblit >> RMSHFT;
                    signed char return_value_lglval$5;
                    return_value_lglval$5=lglval(lgl, nother);
                    if(return_value_lglval$5 == 0)
                    {
                      nother2 = *n;
                      signed char return_value_lglval$6;
                      return_value_lglval$6=lglval(lgl, nother2);
                      if(return_value_lglval$6 == 0)
                      {
                        if(nother == pother && nother2 == pother2 || nother == pother2 && nother2 == pother)
                        {
                          a = nother;
                          b = nother2;
                          signed int return_value_lglhasbin$7;
                          return_value_lglhasbin$7=lglhasbin(lgl, a, b);
                          if(!(return_value_lglhasbin$7 == 0))
                            goto __CPROVER_DUMP_L24;

                          lgl->stats->trnr.bin = lgl->stats->trnr.bin + 1;

                        __CPROVER_DUMP_L17:
                          ;
                          lglwchbin(lgl, a, b, REDCS);
                          lglwchbin(lgl, b, a, REDCS);
                          lgl->stats->red.bin = lgl->stats->red.bin + 1;
                          lglwrktouch(lgl, a);
                          lglwrktouch(lgl, b);
                        }

                        else
                        {
                          a = nother;
                          b = nother2;
                          if(nother == pother || nother2 == pother)
                            c = pother2;

                          else
                            if(nother == pother2 || nother2 == pother2)
                              c = pother;

                            else
                              goto __CPROVER_DUMP_L24;
                          if(a == -c || b == -c)
                            goto __CPROVER_DUMP_L24;

                          signed int return_value_lglhastrn$8;
                          return_value_lglhastrn$8=lglhastrn(lgl, a, b, c);
                          if(!(return_value_lglhastrn$8 == 0))
                            goto __CPROVER_DUMP_L24;

                          lgl->stats->trnr.trn = lgl->stats->trnr.trn + 1;

                        __CPROVER_DUMP_L22:
                          ;
                          lglwchtrn(lgl, a, b, c, REDCS);
                          lglwchtrn(lgl, b, a, c, REDCS);
                          lglwchtrn(lgl, c, a, b, REDCS);
                          lgl->stats->red.trn = lgl->stats->red.trn + 1;
                          lglwrktouch(lgl, a);
                          lglwrktouch(lgl, b);
                          lglwrktouch(lgl, c);
                        }
                        pdelta = (signed int)(p - pw);
                        phts=lglhts(lgl, lit);
                        pw=lglhts2wchs(lgl, phts);
                        peow = pw + (signed long int)phts->count;
                        p = pw + (signed long int)pdelta;
                        ndelta = (signed int)(n - nw);
                        nhts=lglhts(lgl, -lit);
                        nw=lglhts2wchs(lgl, nhts);
                        neow = nw + (signed long int)nhts->count;
                        n = nw + (signed long int)ndelta;
                      }

                    }

                  }

                }


              __CPROVER_DUMP_L24:
                ;
                n = n + 1l;
              }
              while((_Bool)1);
            }

          }

        }

      }

      p = p + 1l;
    }
    while((_Bool)1);
  }


__CPROVER_DUMP_L28:
  ;
}

// lglternresolving
// file lglib.c line 17008
static signed int lglternresolving(struct LGL *lgl)
{
  return lgl->opts->ternres.val;
}

// lgltonflict
// file lglib.c line 4021
static void lgltonflict(struct LGL *lgl, signed int lit, signed int blit, signed int other2)
{
  lgl->conf.lit = lit;
  lgl->conf.rsn[(signed long int)0] = blit;
  lgl->conf.rsn[(signed long int)1] = other2;

__CPROVER_DUMP_L1:
  ;
}

// lgltopgc
// file lglib.c line 7668
static signed int lgltopgc(struct LGL *lgl)
{
  if(!(lgl->mt == 0))
    return 0;

  else
  {
    lgl->allowforce = (char)1;
    lgl->forcegc = lgl->allowforce;
    lglgc(lgl);
    lgl->allowforce = (char)0;
    lgl->forcegc = lgl->allowforce;
    return (signed int)!(lgl->mt != 0);
  }
}

// lgltopsimp
// file lglib.c line 17267
static signed int lgltopsimp(struct LGL *lgl, signed int forcesimp)
{
  _Bool tmp_if_expr$4;
  signed int return_value_lglfailedass$3;
  _Bool tmp_if_expr$8;
  signed int return_value_lglsimplimhit$7;
  signed int return_value_lglpreprocessing$6;
  if(!(lgl->mt == 0))
    return 20;

  else
  {
    signed int return_value_lglfailedass$1;
    return_value_lglfailedass$1=lglfailedass(lgl);
    if(!(return_value_lglfailedass$1 == 0))
      return 20;

    else
    {
      signed int return_value_lglbcptop$2;
      return_value_lglbcptop$2=lglbcptop(lgl);
      if(return_value_lglbcptop$2 == 0)
        return 20;

      else
      {
        if(!(lgl->mt == 0))
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_lglfailedass$3=lglfailedass(lgl);
          tmp_if_expr$4 = return_value_lglfailedass$3 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
          return 20;

        else
        {
          signed int return_value_lglterminate$5;
          return_value_lglterminate$5=lglterminate(lgl);
          if(!(return_value_lglterminate$5 == 0))
            return 0;

          else
          {
            if(!(forcesimp == 0))
              tmp_if_expr$8 = (_Bool)1;

            else
            {
              return_value_lglsimplimhit$7=lglsimplimhit(lgl);
              tmp_if_expr$8 = return_value_lglsimplimhit$7 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$8)
            {
              return_value_lglpreprocessing$6=lglpreprocessing(lgl, forcesimp);
              if(!(return_value_lglpreprocessing$6 == 0))
                goto __CPROVER_DUMP_L10;

              return 20;
            }

            else
            {

            __CPROVER_DUMP_L10:
              ;
              signed int return_value_lglfailedass$9;
              return_value_lglfailedass$9=lglfailedass(lgl);
              if(!(return_value_lglfailedass$9 == 0))
                return 20;

              else
              {
                if(lgl->qscheduling == 0)
                {
                  if(lgl->stats->confs == 0l)
                    lglcutwidth(lgl);

                  lglqschedall(lgl);
                }

                lglrep(lgl, 1, (char)115);
                return 0;
              }
            }
          }
        }
      }
    }
  }
}

// lgltopstk
// file lglib.c line 1449
static signed int lgltopstk(struct Stk *s)
{
  return s->top[(signed long int)-1];
}

// lgltrail
// file lglib.c line 2332
static signed int lgltrail(struct LGL *lgl, signed int lit)
{
  struct AVar *return_value_lglavar$1;
  return_value_lglavar$1=lglavar(lgl, lit);
  return return_value_lglavar$1->trail;
}

// lgltrapi
// file lglib.c line 1476
static void lgltrapi(struct LGL *lgl, const char *msg, ...)
{
  void **ap = (void **)&msg;
  vfprintf(lgl->apitrace, msg, ap);
  ap = ((void **)NULL);
  fputc(10, lgl->apitrace);
}

// lgltravall
// file lglib.c line 18882
void lgltravall(struct LGL *lgl, void *state, void (*trav)(void *, signed int))
{
  struct Trv travstate;
  travstate.state = state;
  travstate.trav = trav;
  lglutrav(lgl, (void *)&travstate, lgltravallu);
  lgletrav(lgl, (void *)&travstate, lgltravalle);
  lglctrav(lgl, state, trav);
}

// lgltravalle
// file lglib.c line 18872
static void lgltravalle(void *voidptr, signed int lit, signed int repr)
{
  struct Trv *state = (struct Trv *)voidptr;
  state->trav(state->state, -lit);
  state->trav(state->state, repr);
  state->trav(state->state, 0);
  state->trav(state->state, lit);
  state->trav(state->state, -repr);
  state->trav(state->state, 0);
}

// lgltravallu
// file lglib.c line 18866
static void lgltravallu(void *voidptr, signed int unit)
{
  struct Trv *state = (struct Trv *)voidptr;
  state->trav(state->state, unit);
  state->trav(state->state, 0);
}

// lgltravcounter
// file lglib.c line 18795
static void lgltravcounter(void *voidptr, signed int lit)
{
  signed int *cntptr = (signed int *)voidptr;
  if(lit == 0)
    *cntptr = *cntptr + 1;

}

// lgltravprinter
// file lglib.c line 18800
static void lgltravprinter(void *voidptr, signed int lit)
{
  struct _IO_FILE *out = (struct _IO_FILE *)voidptr;
  if(!(lit == 0))
    fprintf(out, "%d ", lit);

  else
    fprintf(out, "0\n");
}

// lgltrd
// file lglib.c line 14908
static signed int lgltrd(struct LGL *lgl)
{
  unsigned int pos;
  unsigned int delta;
  unsigned int mod;
  unsigned int ulit;
  unsigned int first;
  unsigned int last;
  signed long int oldprgss = lgl->stats->prgss;
  signed int lit;
  signed int count;
  signed int success;
  unsigned int return_value_lglgcd$3;
  if(!(lgl->nvars >= 3))
    return 1;

  else
  {
    lgl->stats->trd.count = lgl->stats->trd.count + 1;
    lglstart(lgl, &lgl->times->trd);
    lgl->simp = (char)1;
    if(lgl->level >= 1)
      lglbacktrack(lgl, 0);

    lglsetrdlim(lgl);
    mod = (unsigned int)(2 * (lgl->nvars - 2));
    unsigned int return_value_lglrand$1;
    return_value_lglrand$1=lglrand(lgl);
    pos = return_value_lglrand$1 % mod;
    unsigned int return_value_lglrand$2;
    return_value_lglrand$2=lglrand(lgl);
    delta = return_value_lglrand$2 % mod;
    if(delta == 0u)
      delta = delta + 1u;

    do
    {
      return_value_lglgcd$3=lglgcd(delta, mod);
      if(!(return_value_lglgcd$3 >= 2u))
        break;

      delta = delta + 1u;
      if(delta == mod)
        delta = (unsigned int)1;

    }
    while((_Bool)1);

  __CPROVER_DUMP_L5:
    ;
    first = mod;
    count = 0;
    while(!(lgl->stats->trd.steps >= lgl->limits->trd.steps))
    {
      signed int return_value_lglterminate$4;
      return_value_lglterminate$4=lglterminate(lgl);
      if(!(return_value_lglterminate$4 == 0))
        break;

      signed int return_value_lglsyncunits$5;
      return_value_lglsyncunits$5=lglsyncunits(lgl);
      if(return_value_lglsyncunits$5 == 0)
        break;

      ulit = pos + (unsigned int)4;
      lit=lglilit((signed int)ulit);
      lgltrdlit(lgl, lit);
      count = count + 1;
      if(!(lgl->mt == 0))
        break;

      last = pos;
      pos = pos + delta;
      if(pos >= mod)
        pos = pos - mod;

      if(pos == first)
        break;

      if(mod == 1u)
        break;

      if(first == mod)
        first = last;

    }
    success = (signed int)(oldprgss < lgl->stats->prgss);
    if(!(success == 0))
    {
      if(!(lgl->limits->trd.pen == 0))
        lgl->limits->trd.pen = lgl->limits->trd.pen - 1;

    }

    if(success == 0)
    {
      if(!(lgl->limits->trd.pen >= 4))
        lgl->limits->trd.pen = lgl->limits->trd.pen + 1;

    }

    lgl->simp = (char)0;
    lglrep(lgl, 1 + (signed int)!(success != 0), (char)116);
    lglstop(lgl);
    return (signed int)!(lgl->mt != 0);
  }
}

// lgltrdbin
// file lglib.c line 14784
static signed int lgltrdbin(struct LGL *lgl, signed int start, signed int target, signed int irr)
{
  signed int lit;
  signed int lgltrdbin$$1$$next;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int *p;
  signed int *w;
  signed int *eow;
  signed int res;
  signed int ign;
  signed int val;
  struct HTS *hts;

__CPROVER_DUMP_L1:
  ;
  lgl->stats->trd.bins = lgl->stats->trd.bins + 1l;
  lglpushnmarkseen(lgl, -start);
  lgltrdbin$$1$$next = 0;
  res = 0;
  ign = 1;
  unsigned long int return_value_lglcntstk$1;
  signed int tmp_post$2;
  do
  {
    return_value_lglcntstk$1=lglcntstk(&lgl->seen);
    if((unsigned long int)lgltrdbin$$1$$next >= return_value_lglcntstk$1)
      break;

    tmp_post$2 = lgltrdbin$$1$$next;
    lgltrdbin$$1$$next = lgltrdbin$$1$$next + 1;
    lit=lglpeek(&lgl->seen, tmp_post$2);
    lgl->stats->trd.steps = lgl->stats->trd.steps + 1l;

  __CPROVER_DUMP_L3:
    ;
    signed char return_value_lglval$3;
    return_value_lglval$3=lglval(lgl, lit);
    val = (signed int)return_value_lglval$3;
    if(val == 0)
    {
      hts=lglhts(lgl, -lit);
      if(!(hts->count == 0))
      {
        w=lglhts2wchs(lgl, hts);
        eow = w + (signed long int)hts->count;
        p = w;
        for( ; !(p >= eow); p = p + 1l)
        {
          blit = *p;
          tag = blit & MASKCS;
          if(tag == TRNCS || tag == LRGCS)
            p = p + 1l;

          if(tag == BINCS)
          {
            red = blit & REDCS;
            if(red == 0 || irr == 0)
            {
              other = blit >> RMSHFT;
              if(!(other == start))
              {
                if(other == target)
                {
                  if(lit == -start && !(ign == 0))
                  {
                    ign = 0;
                    goto __CPROVER_DUMP_L14;
                  }


                __CPROVER_DUMP_L8:
                  ;
                  res = 1;
                  goto DONE;
                }

                val=lglmarked(lgl, other);
                if(!(val >= 1))
                {
                  if(!(val >= 0))
                  {
                    lgl->stats->trd.failed = lgl->stats->trd.failed + 1;

                  __CPROVER_DUMP_L10:
                    ;
                    lglunit(lgl, start);
                    val=lglbcp(lgl);
                    if(val == 0)
                    {
                      if(lgl->mt == 0)
                        lgl->mt = 1;

                    }

                    res = -1;
                    goto DONE;
                  }

                  lglpushnmarkseen(lgl, other);
                }

              }

            }

          }


        __CPROVER_DUMP_L13:
          ;

        __CPROVER_DUMP_L14:
          ;
        }
      }

    }

  }
  while((_Bool)1);

DONE:
  ;
  lglpopnunmarkstk(lgl, &lgl->seen);
  return res;
}

// lgltrdlit
// file lglib.c line 14845
static void lgltrdlit(struct LGL *lgl, signed int start)
{
  signed int target;
  signed int *w;
  signed int *p;
  signed int *eow;
  signed int blit;
  signed int tag;
  signed int red;
  signed int val;
  struct HTS *hts;
  signed char return_value_lglval$1;
  return_value_lglval$1=lglval(lgl, start);
  val = (signed int)return_value_lglval$1;
  _Bool tmp_if_expr$2;
  if(val == 0)
  {

  __CPROVER_DUMP_L1:
    ;
    hts=lglhts(lgl, start);
    if(!(hts->count == 0))
    {
      lgl->stats->trd.lits = lgl->stats->trd.lits + 1l;
      w=lglhts2wchs(lgl, hts);
      eow = w + (signed long int)hts->count;
      p = w;
      do
      {
        if(!(p >= eow))
          tmp_if_expr$2 = lgl->stats->trd.steps < lgl->limits->trd.steps ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        blit = *p;
        tag = blit & MASKCS;
        if(tag == TRNCS || tag == LRGCS)
          p = p + 1l;

        if(tag == BINCS)
        {
          target = blit >> RMSHFT;
          signed int return_value_abs$3;
          return_value_abs$3=abs(start);
          signed int return_value_abs$4;
          return_value_abs$4=abs(target);
          if(return_value_abs$4 >= return_value_abs$3)
          {
            red = blit & REDCS;
            val=lgltrdbin(lgl, start, target, red ^ REDCS);
            if(!(val == 0))
            {
              if(!(val >= 0))
                break;


            __CPROVER_DUMP_L8:
              ;
              lgl->stats->trd.red = lgl->stats->trd.red + 1;
              lgl->stats->prgss = lgl->stats->prgss + 1l;
              lglrmbwch(lgl, start, target, red);
              lglrmbwch(lgl, target, start, red);
              if(!(red == 0))
                lgl->stats->red.bin = lgl->stats->red.bin - 1;

              else
                lgldecirr(lgl, 2);
              break;
            }

          }

        }

        p = p + 1l;
      }
      while((_Bool)1);
    }

  }

}

// lgltreducing
// file lglib.c line 16949
static signed int lgltreducing(struct LGL *lgl)
{
  return lgl->opts->transred.val;
}

// lgltruefun
// file lglib.c line 10519
static void lgltruefun(unsigned long int *res)
{
  signed int i = 0;
  for( ; !(i >= 64); i = i + 1)
    res[(signed long int)i] = (unsigned long int)~0ll;
}

// lgltrylargeve
// file lglib.c line 10247
static signed int lgltrylargeve(struct LGL *lgl)
{
  const signed int *c;
  const signed int *d;
  const signed int *sop;
  const signed int *eop;
  const signed int *son;
  const signed int *eon;
  const signed int *p;
  const signed int *q;
  const signed int *lgltrylargeve$$1$$start;
  const signed int *end;
  signed int lit;
  signed int idx;
  signed int sgn;
  signed int tmp;
  signed int ip;
  signed int mp;
  signed int ilit;
  signed int npocc;
  signed int nnocc;
  signed int limit;
  signed int count;
  signed int i;
  signed int clen;
  signed int dlen;
  signed int reslen;
  signed int maxreslen;
  signed char val;
  ip = lgl->$anon0.elm->pivot;
  sop = lgl->$anon0.elm->lits.start + (signed long int)1;
  son = lgl->$anon0.elm->lits.start + (signed long int)lgl->$anon0.elm->neglidx;
  eop = son;
  eon = lgl->$anon0.elm->lits.top;
  signed int return_value_lglulit$1;
  return_value_lglulit$1=lglulit(1);
  npocc=lglpeek(&lgl->$anon0.elm->noccs, return_value_lglulit$1);
  signed int return_value_lglulit$2;
  return_value_lglulit$2=lglulit(-1);
  nnocc=lglpeek(&lgl->$anon0.elm->noccs, return_value_lglulit$2);
  limit = npocc + nnocc;
  count = 0;
  i = 0;
  for( ; !(i >= 2); i = i + 1)
  {
    lgltrylargeve$$1$$start = i != 0 ? son : sop;
    end = i != 0 ? eon : eop;
    c = lgltrylargeve$$1$$start;
    for( ; !(c >= end); c = c + 1l)
    {
      lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
      if(*c == 0x7fffffff)
        for( ; !(*c == 0); c = c + 1l)
          ;

      else
      {
        do
        {
          lit = *c;
          if(lit == 0)
            break;

          lglm2i(lgl, lit);
          c = c + 1l;
        }
        while((_Bool)1);
        count = count + 1;
      }
    }
  }

__CPROVER_DUMP_L9:
  ;
  maxreslen = 0;
  c = sop;
  for( ; limit >= 0 && !(c >= eop); c = p + (signed long int)1)
  {
    lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
    if(*c == 0x7fffffff)
    {
      p = c + (signed long int)1;
      for( ; !(*p == 0); p = p + 1l)
        ;
    }

    else
    {
      clen = 0;
      p = c;
      do
      {
        lit = *p;
        if(lit == 0)
          break;

        if(!(lit == 1))
        {
          idx=abs(lit);
          sgn=lglsgn(lit);
          lglpoke(&lgl->$anon0.elm->mark, idx, sgn);
          ilit=lglm2i(lgl, lit);
          lglpushstk(lgl, &lgl->$anon1.resolvent, ilit);
          clen = clen + 1;
        }

        p = p + 1l;
      }
      while((_Bool)1);
      d = son;
      for( ; limit >= 0 && !(d >= eon); d = q + (signed long int)1)
      {
        lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
        if(*d == 0x7fffffff)
        {
          q = d + (signed long int)1;
          for( ; !(*q == 0); q = q + 1l)
            ;
        }

        else
        {
          lgl->stats->elm.resolutions = lgl->stats->elm.resolutions + 1l;

        __CPROVER_DUMP_L21:
          ;

        __CPROVER_DUMP_L22:
          ;
          dlen = 0;
          reslen = clen;
          q = d;
          do
          {
            lit = *q;
            if(lit == 0)
              break;

            if(!(lit == -1))
            {
              dlen = dlen + 1;
              idx=abs(lit);
              sgn=lglsgn(lit);
              tmp=lglpeek(&lgl->$anon0.elm->mark, idx);
              if(tmp == -sgn)
                break;

              if(!(tmp == sgn))
              {
                ilit=lglm2i(lgl, lit);
                lglpushstk(lgl, &lgl->$anon1.resolvent, ilit);
                reslen = reslen + 1;
              }

            }

            q = q + 1l;
          }
          while((_Bool)1);
          if(lit == 0 && reslen == 1)
          {

          __CPROVER_DUMP_L26:
            ;
            lit=lglpeek(&lgl->$anon1.resolvent, 0);
            struct EVar *return_value_lglevar$3;
            return_value_lglevar$3=lglevar(lgl, lit);
            limit = limit + return_value_lglevar$3->occ[(signed long int)(lit < 0)];
          }

          else
            if(!(lit == 0))
              do
              {
                q = q + 1l;
                if(*q == 0)
                  break;

              }
              while((_Bool)1);

            else
            {
              limit = limit - 1;

            __CPROVER_DUMP_L31:
              ;
              if(!(maxreslen >= reslen))
                maxreslen = reslen;

            }

        __CPROVER_DUMP_L29:
          ;
          lglrststk(&lgl->$anon1.resolvent, clen);
        }
      }
      lglclnstk(&lgl->$anon1.resolvent);
      p = c;
      do
      {
        lit = *p;
        if(lit == 0)
          break;

        if(!(lit == 1))
        {
          idx=abs(lit);
          lglpoke(&lgl->$anon0.elm->mark, idx, 0);
        }

        p = p + 1l;
      }
      while((_Bool)1);
      if(lgl->stats->elm.steps >= lgl->limits->elm.steps)
      {

      __CPROVER_DUMP_L38:
        ;
        return 0;
      }

    }
  }
  if(!(limit >= 0))
  {

  __CPROVER_DUMP_L41:
    ;
    return 0;
  }

  else
  {
    if(!(limit == 0))

      __CPROVER_DUMP_L43:
        ;

    else

      __CPROVER_DUMP_L44:
        ;

  __CPROVER_DUMP_L45:
    ;
    lglflushclauses(lgl, ip);
    lglflushclauses(lgl, -ip);
    if(!(npocc >= nnocc))
    {
      lgltrylargeve$$1$$start = sop;
      end = eop;
      mp = 1;
    }

    else
    {
      lgltrylargeve$$1$$start = son;
      end = eon;
      ip = -ip;
      mp = -1;
    }

  __CPROVER_DUMP_L47:
    ;
    c = lgltrylargeve$$1$$start;
    for( ; !(c >= end); c = p + (signed long int)1)
    {
      lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
      if(*c == 0x7fffffff)
      {
        p = c + (signed long int)1;
        for( ; !(*p == 0); p = p + 1l)
          ;
      }

      else
      {
        lglepush(lgl, 0);
        lglepush(lgl, ip);
        p = c;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          if(!(lit == mp))
          {
            ilit=lglm2i(lgl, lit);
            lglepush(lgl, ilit);
          }

          p = p + 1l;
        }
        while((_Bool)1);
      }
    }
    lglepush(lgl, 0);
    lglepush(lgl, -ip);
    c = sop;
    for( ; !(c >= eop); c = p + (signed long int)1)
    {
      lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
      if(*c == 0x7fffffff)
      {
        p = c + (signed long int)1;
        for( ; !(*p == 0); p = p + 1l)
          ;
      }

      else
      {
        clen = 0;
        p = c;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          if(!(lit == 1))
          {
            idx=abs(lit);
            sgn=lglsgn(lit);
            lglpoke(&lgl->$anon0.elm->mark, idx, sgn);
            ilit=lglm2i(lgl, lit);
            lglpushstk(lgl, &lgl->$anon1.resolvent, ilit);
            clen = clen + 1;
          }

          p = p + 1l;
        }
        while((_Bool)1);
        d = son;
        for( ; limit >= 0 && !(d >= eon); d = q + (signed long int)1)
        {
          lgl->stats->elm.steps = lgl->stats->elm.steps + 1l;
          if(*d == 0x7fffffff)
          {
            q = d + (signed long int)1;
            for( ; !(*q == 0); q = q + 1l)
              ;
          }

          else
          {
            lgl->stats->elm.resolutions = lgl->stats->elm.resolutions + 1l;
            dlen = 0;
            reslen = clen;
            q = d;
            do
            {
              lit = *q;
              if(lit == 0)
                break;

              if(!(lit == -1))
              {
                dlen = dlen + 1;
                idx=abs(lit);
                sgn=lglsgn(lit);
                tmp=lglpeek(&lgl->$anon0.elm->mark, idx);
                if(!(tmp == sgn))
                {
                  if(tmp == -sgn)
                    break;

                  ilit=lglm2i(lgl, lit);
                  val=lglval(lgl, ilit);
                  if((signed int)val >= 0)
                  {
                    if((signed int)val >= 1)
                      break;

                    lglpushstk(lgl, &lgl->clause, ilit);
                    ilit=lglm2i(lgl, lit);
                    lglpushstk(lgl, &lgl->$anon1.resolvent, ilit);
                    reslen = reslen + 1;
                  }

                }

              }

              q = q + 1l;
            }
            while((_Bool)1);
            if(!(lit == 0) || !(reslen == 1))
            {
              if(lit == 0)
                goto RESOLVE;

              do
              {
                q = q + 1l;
                if(*q == 0)
                  break;

              }
              while((_Bool)1);
            }

            else
            {
              do

                RESOLVE:
                  ;
              while((_Bool)0);

            __CPROVER_DUMP_L73:
              ;
              p = c;
              do
              {
                lit = *p;
                if(lit == 0)
                  break;

                if(!(lit == 1))
                {
                  ilit=lglm2i(lgl, lit);
                  val=lglval(lgl, ilit);
                  if((signed int)val >= 0)
                  {
                    if((signed int)val >= 1)
                      break;

                    lglpushstk(lgl, &lgl->clause, ilit);
                  }

                }

                p = p + 1l;
              }
              while((_Bool)1);
              if(lit == 0)
              {
                lglpushstk(lgl, &lgl->clause, 0);

              __CPROVER_DUMP_L77:
                ;
                lgladdcls(lgl, 0, 0, 1);
              }

            }
            lglclnstk(&lgl->clause);
            lglrststk(&lgl->$anon1.resolvent, clen);
          }
        }
        lglclnstk(&lgl->$anon1.resolvent);
        p = c;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          if(!(lit == 1))
          {
            idx=abs(lit);
            lglpoke(&lgl->$anon0.elm->mark, idx, 0);
          }

          p = p + 1l;
        }
        while((_Bool)1);
      }
    }
    lgleliminated(lgl, lgl->$anon0.elm->pivot);
    lgl->stats->elm.large = lgl->stats->elm.large + 1;
    return 1;
  }
}

// lgltrysmallve
// file lglib.c line 10973
static signed int lgltrysmallve(struct LGL *lgl, signed int idx)
{
  signed int res = 0;
  signed int new;
  signed int old;
  signed int units;
  unsigned long int pos[64l];
  unsigned long int neg[64l];
  unsigned long int fun[64l];
  struct EVar *ev;
  signed long int cnf;
  lglpushstk(lgl, &lgl->$anon0.elm->m2i, 0);
  lglpushstk(lgl, &lgl->$anon0.elm->clv, 0);
  signed int return_value_lglinitsmallve$1;
  return_value_lglinitsmallve$1=lglinitsmallve(lgl, idx, pos);
  _Bool tmp_if_expr$3;
  signed int return_value_lglinitsmallve$2;
  if(!(return_value_lglinitsmallve$1 == 0))
  {
    return_value_lglinitsmallve$2=lglinitsmallve(lgl, -idx, neg);
    tmp_if_expr$3 = return_value_lglinitsmallve$2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
  {
    lglor3fun(fun, pos, neg);
    cnf=lglsmallipos(lgl, fun, fun, 0);
    new=lglcnf2size(cnf);
    units=lglsmallcnfunits(lgl, cnf);
    new = new - units;
    ev=lglevar(lgl, idx);
    old = ev->occ[(signed long int)0] + ev->occ[(signed long int)1];

  __CPROVER_DUMP_L3:
    ;
    lgl->stats->elm.small.tried = lgl->stats->elm.small.tried + 1;
    if(old >= new)
    {

    __CPROVER_DUMP_L4:
      ;
      lglepusheliminated(lgl, idx);
      lglflushclauses(lgl, idx);
      lglflushclauses(lgl, -idx);
      lglsmallve(lgl, cnf);
      lgl->stats->elm.small.elm = lgl->stats->elm.small.elm + 1;
      res = 1;
    }

    else
    {

    __CPROVER_DUMP_L5:
      ;
      if(units >= 1)
        res = 1;

      else
        lgl->stats->elm.small.failed = lgl->stats->elm.small.failed + 1;
    }
  }

  else

    __CPROVER_DUMP_L8:
      ;
  lglresetsmallve(lgl);
  return res;
}

// lgluby
// file lglib.c line 5256
static signed long int lgluby(struct LGL *lgl, signed int i)
{
  lgl->stats->luby.count = lgl->stats->luby.count + 1;
  signed long int return_value_lglubyrec$1;
  return_value_lglubyrec$1=lglubyrec(lgl, i);
  return return_value_lglubyrec$1;
}

// lglubyrec
// file lglib.c line 5237
static signed long int lglubyrec(struct LGL *lgl, signed int i)
{
  signed long int res = (signed long int)0;
  signed long int s = (signed long int)0;
  signed int k = 1;
  for( ; res == 0l && !(k >= 32); k = k + 1)
  {
    if(i == (1 << k) + -1)
      res = (signed long int)(1 << k - 1);

    s = s + 1l;
  }
  k = 1;
  for( ; res == 0l; s = s + 1l)
  {
    if(i >= 1 << k + -1 && !(i >= (1 << k) + -1))
      res=lglubyrec(lgl, (i - (1 << k - 1)) + 1);

    k = k + 1;
  }
  lgl->stats->luby.steps = lgl->stats->luby.steps + s;
  return res;
}

// lglulit
// file lglib.c line 2580
static signed int lglulit(signed int lit)
{
  signed int return_value_abs$1;
  return_value_abs$1=abs(lit);
  return 2 * return_value_abs$1 + (signed int)(lit < 0);
}

// lglunassign
// file lglib.c line 2759
static void lglunassign(struct LGL *lgl, signed int lit)
{
  signed int idx;
  idx=abs(lit);
  signed int r0;
  signed int r1;
  signed int tag;
  signed int lidx;
  signed int glue;
  struct TD *td;
  struct Qln *n;

__CPROVER_DUMP_L1:
  ;
  lgl->vals[(signed long int)idx] = (signed char)0;
  lgl->unassigned = lgl->unassigned + 1;
  _Bool tmp_if_expr$1;
  if(!(lgl->qscheduling == 0))
  {
    n=lglqln(lgl, idx);
    n->unassigned = n->first;
    if(lgl->queue.unassigned == ((struct Qln *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = lgl->queue.unassigned->prior < n->prior ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      lgl->queue.unassigned = n;

  }

  td=lgltd(lgl, idx);
  r0 = td->rsn[(signed long int)0];
  if(!((REDCS & r0) == 0))
  {
    tag = r0 & MASKCS;
    if(tag == LRGCS)
    {
      r1 = td->rsn[(signed long int)1];
      glue = r1 & (1 << 4) - 1;
      if(!(td->lrglue == 0u))
        lgl->lrgluereasons = lgl->lrgluereasons - 1;

      if(glue >= 15)
      {
        lidx = r1 >> 4;

      __CPROVER_DUMP_L9:
        ;
        lglrststk(&lgl->red[(signed long int)glue], lidx);
        lglredstk(lgl, &lgl->red[(signed long int)glue], 1 << 20, 3);
      }

    }

  }

}

// lglunclone
// file lglib.c line 17616
signed int lglunclone(struct LGL *lgl, struct LGL *from)
{
  signed int res;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglunclone");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  _Bool tmp_if_expr$1;
  if(!(lgl->mt == 0))
    return 20;

  else
  {
    while(from == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglunclone");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized 'from' solver");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
    if(!(from->mt == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = ((signed int)from->state & UNSATISFIED) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      lglnegass(lgl);
      res=lglisat(lgl, ((struct Lim *)NULL), 0);
    }

    else
      if(!((96 & (signed int)from->state) == 0))
      {
        lglclass(lgl, from);
        res = 10;
      }

      else
      {
        lglreset(lgl);

      __CPROVER_DUMP_L11:
        ;
        do
          lgl->state = (enum State)UNKNOWN;
        while((_Bool)0);
        res = 0;
      }
    return res;
  }
}

// lglunflict
// file lglib.c line 5719
static void lglunflict(struct LGL *lgl, signed int lit)
{
  lgl->conf.lit = lit;
  lgl->conf.rsn[(signed long int)0] = lit << RMSHFT | UNITCS;

__CPROVER_DUMP_L1:
  ;
}

// lglunhdfailed
// file lglib.c line 15928
static signed int lglunhdfailed(struct LGL *lgl)
{
  signed int res = lgl->stats->unhd.stamp.failed;
  res = res + lgl->stats->unhd.failed.lits;
  res = res + lgl->stats->unhd.failed.bin;
  res = res + lgl->stats->unhd.failed.trn;
  res = res + lgl->stats->unhd.failed.lrg;
  return res;
}

// lglunhdhasbins
// file lglib.c line 14955
static signed int lglunhdhasbins(struct LGL *lgl, const struct DFPR *dfpr, signed int lit, signed int irronly)
{
  signed int blit;
  signed int tag;
  signed int other;
  signed int val;
  signed int red;
  signed int ulit;
  const signed int *p;
  const signed int *w;
  const signed int *eos;
  struct HTS *hts;
  hts=lglhts(lgl, lit);
  w=lglhts2wchs(lgl, hts);
  eos = w + (signed long int)hts->count;
  p = w;
  for( ; !(p >= eos); p = p + 1l)
  {
    blit = *p;
    tag = blit & MASKCS;
    if(!(tag == OCCS))
    {
      if(tag == TRNCS || tag == LRGCS)
        p = p + 1l;

      else
      {
        red = blit & REDCS;
        if(red == 0 || irronly == 0)
        {
          other = blit >> RMSHFT;
          signed char return_value_lglval$1;
          return_value_lglval$1=lglval(lgl, other);
          val = (signed int)return_value_lglval$1;
          if(!(val >= 1))
          {
            ulit=lglulit(other);
            if((dfpr + (signed long int)ulit)->discovered == 0)
              return 1;

          }

        }

      }
    }

  }
  return 0;
}

// lglunhdhbrs
// file lglib.c line 15937
static signed int lglunhdhbrs(struct LGL *lgl)
{
  signed int res = lgl->stats->unhd.hbrs.trn;
  res = res + lgl->stats->unhd.hbrs.lrg;
  return res;
}

// lglunhdisroot
// file lglib.c line 14981
static signed int lglunhdisroot(struct LGL *lgl, signed int lit, struct DFPR *dfpr, signed int irronly)
{
  signed int res;
  signed int return_value_lglunhdhasbins$1;
  return_value_lglunhdhasbins$1=lglunhdhasbins(lgl, dfpr, lit, irronly);
  res = (signed int)!(return_value_lglunhdhasbins$1 != 0);
  return res;
}

// lglunhdstrd
// file lglib.c line 15951
static signed int lglunhdstrd(struct LGL *lgl)
{
  signed int res = lgl->stats->unhd.units.bin;
  res = res + lgl->stats->unhd.str.trn;
  res = res + lgl->stats->unhd.str.lrg;
  return res;
}

// lglunhdtauts
// file lglib.c line 15943
static signed int lglunhdtauts(struct LGL *lgl)
{
  signed int res = lgl->stats->unhd.stamp.trds;
  res = res + lgl->stats->unhd.tauts.bin;
  res = res + lgl->stats->unhd.tauts.trn;
  res = res + lgl->stats->unhd.tauts.lrg;
  return res;
}

// lglunhdunits
// file lglib.c line 15921
static signed int lglunhdunits(struct LGL *lgl)
{
  signed int res = lgl->stats->unhd.units.bin;
  res = res + lgl->stats->unhd.units.trn;
  res = res + lgl->stats->unhd.units.lrg;
  return res;
}

// lglunhide
// file lglib.c line 16151
static signed int lglunhide(struct LGL *lgl)
{
  signed long int oldprgss = lgl->stats->prgss;
  signed long int roundprgss = (signed long int)0;
  signed int irronly;
  signed int round;
  signed int maxrounds;
  signed int noprgssrounds;
  signed int success;
  signed int oldunits;
  signed int oldfailed;
  signed int oldtauts;
  signed int oldhbrs;
  signed int oldstrd;
  struct DFPR *dfpr = ((struct DFPR *)NULL);
  _Bool tmp_if_expr$1;
  signed int tmp_post$2;
  _Bool tmp_if_expr$3;
  if(!(lgl->nvars >= 3))
    return 1;

  else
  {
    lgl->stats->unhd.count = lgl->stats->unhd.count + 1;
    lgl->unhiding = (char)1;
    lgl->simp = (char)1;
    lglstart(lgl, &lgl->times->unhd);
    if(lgl->stats->red.bin == 0)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (lgl->stats->unhd.count & 1) != 0 ? (_Bool)1 : (_Bool)0;
    irronly = (signed int)tmp_if_expr$1;
    if(lgl->level >= 1)
      lglbacktrack(lgl, 0);

    maxrounds = lgl->opts->unhdroundlim.val;
    lglsetunhdlim(lgl);
    oldunits=lglunhdunits(lgl);
    oldfailed=lglunhdfailed(lgl);
    oldtauts=lglunhdtauts(lgl);
    oldhbrs=lglunhdhbrs(lgl);
    oldstrd=lglunhdstrd(lgl);
    round = 0;
    noprgssrounds = round;
    while(lgl->mt == 0)
    {
      if(round >= maxrounds)
        break;

      if(round >= 1)
      {
        if(roundprgss == lgl->stats->prgss)
        {
          tmp_post$2 = noprgssrounds;
          noprgssrounds = noprgssrounds + 1;
          if(tmp_post$2 == lgl->opts->unhdlnpr.val)
          {

          __CPROVER_DUMP_L6:
            ;
            break;
          }

        }

      }

      round = round + 1;
      roundprgss = lgl->stats->prgss;
      lgl->stats->unhd.rounds = lgl->stats->unhd.rounds + 1;
      lglgc(lgl);
      if(lgl->nvars == 0)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = lgl->mt != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        break;

      dfpr=lglstampall(lgl, irronly);
      if(dfpr == ((struct DFPR *)NULL))
        break;

      signed int return_value_lglunhidefailed$4;
      return_value_lglunhidefailed$4=lglunhidefailed(lgl, dfpr);
      if(return_value_lglunhidefailed$4 == 0)
        break;

      signed int return_value_lglunhidebintrn$5;
      return_value_lglunhidebintrn$5=lglunhidebintrn(lgl, dfpr, irronly);
      if(return_value_lglunhidebintrn$5 == 0)
        break;

      signed int return_value_lglunhidelrg$6;
      return_value_lglunhidelrg$6=lglunhidelrg(lgl, dfpr, irronly);
      if(return_value_lglunhidelrg$6 == 0)
        break;

      if(lgl->stats->unhd.steps >= lgl->limits->unhd.steps)
        break;

      irronly = (signed int)(!(lgl->stats->red.bin != 0) ? (_Bool)1 : (!(irronly != 0) ? (_Bool)1 : (_Bool)0));
      do
      {
        lgldel(lgl, (void *)dfpr, (unsigned long int)(2 * lgl->nvars) * sizeof(struct DFPR) /*16ul*/ );
        dfpr = ((struct DFPR *)NULL);
      }
      while((_Bool)0);
    }
    if(!(dfpr == ((struct DFPR *)NULL)))
      do
      {
        lgldel(lgl, (void *)dfpr, (unsigned long int)(2 * lgl->nvars) * sizeof(struct DFPR) /*16ul*/ );
        dfpr = ((struct DFPR *)NULL);
      }
      while((_Bool)0);

    signed int return_value_lglunhdunits$7;
    return_value_lglunhdunits$7=lglunhdunits(lgl);
    signed int return_value_lglunhdfailed$8;
    return_value_lglunhdfailed$8=lglunhdfailed(lgl);
    signed int return_value_lglunhdtauts$9;
    return_value_lglunhdtauts$9=lglunhdtauts(lgl);
    signed int return_value_lglunhdhbrs$10;
    return_value_lglunhdhbrs$10=lglunhdhbrs(lgl);
    signed int return_value_lglunhdstrd$11;
    return_value_lglunhdstrd$11=lglunhdstrd(lgl);
    lglprt(lgl, 1, "[unhide-%d-%d] %d units, %d failed, %d tauts, %d hbrs, %d literals", lgl->stats->unhd.count, lgl->stats->unhd.rounds, return_value_lglunhdunits$7 - oldunits, return_value_lglunhdfailed$8 - oldfailed, return_value_lglunhdtauts$9 - oldtauts, return_value_lglunhdhbrs$10 - oldhbrs, return_value_lglunhdstrd$11 - oldstrd);
    success = (signed int)(oldprgss < lgl->stats->prgss);
    lglupdunhdpen(lgl, success);
    lgl->simp = (char)0;
    lgl->unhiding = (char)0;
    lglrep(lgl, 1 + (signed int)!(success != 0), (char)117);
    lglstop(lgl);
    return (signed int)!(lgl->mt != 0);
  }
}

// lglunhidebintrn
// file lglib.c line 15283
static signed int lglunhidebintrn(struct LGL *lgl, const struct DFPR *dfpr, signed int irronly)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int blit;
  signed int tag;
  signed int red;
  signed int other;
  signed int other2;
  signed int unit;
  signed int root;
  signed int lca;
  signed int nbinred;
  signed int ntrnred;
  signed int nbinunits;
  signed int ntrnunits;
  signed int ntrnstr;
  signed int ntrnhbrs;
  const signed int *p;
  const signed int *eow;
  signed int ulit;
  signed int uother;
  signed int *w;
  signed int *q;
  signed long int delta;
  struct HTS *hts;
  ntrnhbrs = 0;
  ntrnstr = ntrnhbrs;
  ntrnunits = ntrnstr;
  nbinunits = ntrnunits;
  ntrnred = nbinunits;
  nbinred = ntrnred;
  idx = 2;
  signed int *tmp_post$4;
  signed int *tmp_post$5;
  signed int *tmp_post$7;
  const signed int *tmp_post$8;
  _Bool tmp_if_expr$12;
  signed char return_value_lglval$11;
  _Bool tmp_if_expr$14;
  signed int return_value_lglunhroot$13;
  _Bool tmp_if_expr$43;
  signed int return_value_lglunhimplies2incl$42;
  _Bool tmp_if_expr$36;
  signed char return_value_lglval$35;
  _Bool tmp_if_expr$38;
  signed int return_value_lglunhroot$37;
  _Bool tmp_if_expr$40;
  signed int return_value_lglunhroot$39;
  _Bool tmp_if_expr$34;
  signed int return_value_lglunhimplies2incl$31;
  _Bool tmp_if_expr$33;
  signed int return_value_lglunhimplies2incl$32;
  signed int return_value_lglunhimplies2incl$30;
  signed int return_value_lglunhimplies2incl$29;
  signed char return_value_lglval$28;
  signed int return_value_lglunhroot$19;
  signed int return_value_lglunhimplies2incl$18;
  signed int return_value_lglunhimplies2incl$17;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      signed int return_value_lglterminate$1;
      return_value_lglterminate$1=lglterminate(lgl);
      if(!(return_value_lglterminate$1 == 0))
        return 0;

      signed int return_value_lglsyncunits$2;
      return_value_lglsyncunits$2=lglsyncunits(lgl);
      if(return_value_lglsyncunits$2 == 0)
        return 0;

      lgl->stats->unhd.steps = lgl->stats->unhd.steps + 1l;
      lit = sign * idx;
      signed char return_value_lglval$3;
      return_value_lglval$3=lglval(lgl, lit);
      if(return_value_lglval$3 == 0)
      {
        ulit=lglulit(lit);
        if(!((dfpr + (signed long int)ulit)->discovered == 0))
        {
          hts=lglhts(lgl, lit);
          w=lglhts2wchs(lgl, hts);
          eow = w + (signed long int)hts->count;
          q = w;
          p = w;
          for( ; !(p >= eow); p = p + 1l)
          {
            blit = *p;
            tmp_post$4 = q;
            q = q + 1l;
            *tmp_post$4 = blit;
            tag = blit & MASKCS;
            if(tag == TRNCS || tag == LRGCS)
            {
              tmp_post$5 = q;
              q = q + 1l;
              p = p + 1l;
              *tmp_post$5 = *p;
            }

            if(!(tag == LRGCS))
            {
              red = blit & REDCS;
              other = blit >> RMSHFT;
              signed char return_value_lglval$6;
              return_value_lglval$6=lglval(lgl, other);
              if(return_value_lglval$6 == 0)
              {
                uother=lglulit(other);
                if(tag == BINCS)
                {
                  signed int return_value_lglunhimplies2$15;
                  return_value_lglunhimplies2$15=lglunhimplies2(dfpr, other, lit);
                  if(!(return_value_lglunhimplies2$15 == 0))
                  {

                  __CPROVER_DUMP_L9:
                    ;
                    lgl->stats->unhd.units.bin = lgl->stats->unhd.units.bin + 1;
                    nbinunits = nbinunits + 1;
                    unit = lit;

                  UNIT:
                    ;
                    lglunit(lgl, unit);
                    p = p + 1l;
                    for( ; !(p >= eow); *tmp_post$7 = *tmp_post$8)
                    {
                      tmp_post$7 = q;
                      q = q + 1l;
                      tmp_post$8 = p;
                      p = p + 1l;
                    }
                    lglshrinkhts(lgl, hts, (signed int)((signed long int)hts->count - (p - q)));
                    signed int return_value_lglbcp$9;
                    return_value_lglbcp$9=lglbcp(lgl);
                    if(!(return_value_lglbcp$9 == 0))
                      goto NEXTIDX;


                  __CPROVER_DUMP_L13:
                    ;
                    lgl->mt = 1;
                    return 0;
                  }

                  else
                  {
                    root=lglunhroot(dfpr, -lit);
                    if(!(root == 0))
                    {
                      return_value_lglval$11=lglval(lgl, root);
                      tmp_if_expr$12 = !(return_value_lglval$11 != 0) ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$12 = (_Bool)0;
                    if(tmp_if_expr$12)
                    {
                      return_value_lglunhroot$13=lglunhroot(dfpr, -other);
                      tmp_if_expr$14 = root == return_value_lglunhroot$13 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$14 = (_Bool)0;
                    if(tmp_if_expr$14)
                    {

                    __CPROVER_DUMP_L19:
                      ;
                      lgl->stats->unhd.failed.bin = lgl->stats->unhd.failed.bin + 1;
                      lca=lglunhlca(lgl, dfpr, -lit, -other);
                      unit = -lca;
                      goto UNIT;
                    }

                    else
                      if(red == 0 && irronly == 0)
                        goto __CPROVER_DUMP_L74;

                      else
                      {
                        if((dfpr + (signed long int)uother)->parent == -lit)
                          goto __CPROVER_DUMP_L74;

                        if((dfpr + (signed long int)ulit)->parent == -other)
                          goto __CPROVER_DUMP_L74;

                        signed int return_value_lglunhimplies2$10;
                        return_value_lglunhimplies2$10=lglunhimplies2(dfpr, -lit, other);
                        if(return_value_lglunhimplies2$10 == 0)
                          goto __CPROVER_DUMP_L74;


                      __CPROVER_DUMP_L22:
                        ;
                        lgl->stats->unhd.tauts.bin = lgl->stats->unhd.tauts.bin + 1;
                        lgl->stats->prgss = lgl->stats->prgss + 1l;
                        if(!(red == 0))
                          lgl->stats->unhd.tauts.red = lgl->stats->unhd.tauts.red + 1;

                        nbinred = nbinred + 1;
                        lglrmbwch(lgl, other, lit, red);

                      __CPROVER_DUMP_L24:
                        ;
                        lgldeclscnt(lgl, 2, red, 0);
                        q = q - 1l;
                      }
                  }
                }

                else
                {
                  other2 = *p;
                  signed char return_value_lglval$16;
                  return_value_lglval$16=lglval(lgl, other2);
                  if(!(return_value_lglval$16 == 0))
                    goto __CPROVER_DUMP_L74;

                  signed int return_value_lglunhimplies2incl$41;
                  return_value_lglunhimplies2incl$41=lglunhimplies2incl(dfpr, other, lit);
                  if(!(return_value_lglunhimplies2incl$41 == 0))
                  {
                    return_value_lglunhimplies2incl$42=lglunhimplies2incl(dfpr, other2, lit);
                    tmp_if_expr$43 = return_value_lglunhimplies2incl$42 != 0 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr$43 = (_Bool)0;
                  if(tmp_if_expr$43)
                  {

                  __CPROVER_DUMP_L29:
                    ;
                    lgl->stats->unhd.str.trn = lgl->stats->unhd.str.trn + 2;
                    if(!(red == 0))
                      lgl->stats->unhd.str.red = lgl->stats->unhd.str.red + 2;

                    lgl->stats->unhd.units.trn = lgl->stats->unhd.units.trn + 1;
                    ntrnunits = ntrnunits + 1;
                    unit = lit;
                    goto UNIT;
                  }

                  else
                  {
                    root=lglunhroot(dfpr, -lit);
                    if(!(root == 0))
                    {
                      return_value_lglval$35=lglval(lgl, root);
                      tmp_if_expr$36 = !(return_value_lglval$35 != 0) ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$36 = (_Bool)0;
                    if(tmp_if_expr$36)
                    {
                      return_value_lglunhroot$37=lglunhroot(dfpr, -other);
                      tmp_if_expr$38 = root == return_value_lglunhroot$37 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$38 = (_Bool)0;
                    if(tmp_if_expr$38)
                    {
                      return_value_lglunhroot$39=lglunhroot(dfpr, -other2);
                      tmp_if_expr$40 = root == return_value_lglunhroot$39 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$40 = (_Bool)0;
                    if(tmp_if_expr$40)
                    {

                    __CPROVER_DUMP_L38:
                      ;
                      lgl->stats->unhd.failed.trn = lgl->stats->unhd.failed.trn + 1;
                      lca=lglunhlca(lgl, dfpr, -lit, -other);
                      lca=lglunhlca(lgl, dfpr, lca, -other2);
                      unit = -lca;
                      goto UNIT;
                    }

                    else
                    {
                      if(!(red == 0) || !(irronly == 0))
                      {
                        return_value_lglunhimplies2incl$31=lglunhimplies2incl(dfpr, -lit, other);
                        if(!(return_value_lglunhimplies2incl$31 == 0))
                          tmp_if_expr$33 = (_Bool)1;

                        else
                        {
                          return_value_lglunhimplies2incl$32=lglunhimplies2incl(dfpr, -lit, other2);
                          tmp_if_expr$33 = return_value_lglunhimplies2incl$32 != 0 ? (_Bool)1 : (_Bool)0;
                        }
                        tmp_if_expr$34 = tmp_if_expr$33 ? (_Bool)1 : (_Bool)0;
                      }

                      else
                        tmp_if_expr$34 = (_Bool)0;
                      if(tmp_if_expr$34)
                      {

                      __CPROVER_DUMP_L44:
                        ;
                        lgl->stats->unhd.tauts.trn = lgl->stats->unhd.tauts.trn + 1;
                        lgl->stats->prgss = lgl->stats->prgss + 1l;
                        if(!(red == 0))
                          lgl->stats->unhd.tauts.red = lgl->stats->unhd.tauts.red + 1;

                        ntrnred = ntrnred + 1;
                        lglrmtwch(lgl, other, lit, other2, red);
                        lglrmtwch(lgl, other2, lit, other, red);

                      __CPROVER_DUMP_L46:
                        ;
                        lgldeclscnt(lgl, 3, red, 0);
                        q = q - (signed long int)2;
                      }

                      else
                      {
                        return_value_lglunhimplies2incl$30=lglunhimplies2incl(dfpr, other2, lit);
                        if(!(return_value_lglunhimplies2incl$30 == 0))
                        {
                          do

                            TRNSTR:
                              ;
                          while((_Bool)0);
                          lgl->stats->unhd.str.trn = lgl->stats->unhd.str.trn + 1;
                          lgl->stats->prgss = lgl->stats->prgss + 1l;
                          if(!(red == 0))
                            lgl->stats->unhd.str.red = lgl->stats->unhd.str.red + 1;

                          ntrnstr = ntrnstr + 1;
                          lglrmtwch(lgl, other, lit, other2, red);
                          lglrmtwch(lgl, other2, lit, other, red);

                        __CPROVER_DUMP_L50:
                          ;
                          lgldeclscnt(lgl, 3, red, 0);
                          if(red == 0)
                            lglincirr(lgl, 2);

                          else
                            lgl->stats->red.bin = lgl->stats->red.bin + 1;
                          delta=lglwchbin(lgl, other, lit, red);
                          if(!(delta == 0l))
                          {
                            p = p + delta;
                            q = q + delta;
                            eow = eow + delta;
                            w = w + delta;
                          }

                          q = q - 1l;
                          q[(signed long int)-1] = red | BINCS | other << RMSHFT;
                          goto __CPROVER_DUMP_L74;
                        }

                        else
                        {
                          return_value_lglunhimplies2incl$29=lglunhimplies2incl(dfpr, other, lit);
                          if(!(return_value_lglunhimplies2incl$29 == 0))
                          {
                            do
                            {
                              signed int TMP = other;
                              other = other2;
                              other2 = TMP;
                            }
                            while((_Bool)0);
                            goto TRNSTR;
                          }

                          else
                            if(!(lgl->opts->unhdhbr.val == 0))
                            {
                              root=lglunhroot(dfpr, -lit);
                              if(!(root == 0))
                              {
                                return_value_lglval$28=lglval(lgl, root);
                                if(return_value_lglval$28 == 0)
                                {
                                  signed int return_value_lglunhroot$20;
                                  return_value_lglunhroot$20=lglunhroot(dfpr, -other2);
                                  if(root == return_value_lglunhroot$20)
                                    lca=lglunhlca(lgl, dfpr, -lit, -other2);

                                  else
                                  {
                                    return_value_lglunhroot$19=lglunhroot(dfpr, -other);
                                    if(root == return_value_lglunhroot$19)
                                    {
                                      lca=lglunhlca(lgl, dfpr, -lit, -other);
                                      do
                                      {
                                        signed int lglunhidebintrn$$1$$1$$1$$1$$1$$1$$1$$2$$6$$2$$1$$TMP = other;
                                        other = other2;
                                        other2 = lglunhidebintrn$$1$$1$$1$$1$$1$$1$$1$$2$$6$$2$$1$$TMP;
                                      }
                                      while((_Bool)0);
                                    }

                                    else
                                    {
                                      return_value_lglunhimplies2incl$18=lglunhimplies2incl(dfpr, root, -other2);
                                      if(!(return_value_lglunhimplies2incl$18 == 0))
                                        lca = root;

                                      else
                                      {
                                        return_value_lglunhimplies2incl$17=lglunhimplies2incl(dfpr, root, -other);
                                        if(!(return_value_lglunhimplies2incl$17 == 0))
                                        {
                                          lca = root;
                                          do
                                          {
                                            signed int lglunhidebintrn$$1$$1$$1$$1$$1$$1$$1$$2$$6$$3$$1$$TMP = other;
                                            other = other2;
                                            other2 = lglunhidebintrn$$1$$1$$1$$1$$1$$1$$1$$2$$6$$3$$1$$TMP;
                                          }
                                          while((_Bool)0);
                                        }

                                        else
                                          goto __CPROVER_DUMP_L74;
                                      }
                                    }
                                  }
                                  signed int return_value_abs$21;
                                  return_value_abs$21=abs(lca);
                                  signed int return_value_abs$22;
                                  return_value_abs$22=abs(lit);
                                  if(return_value_abs$21 == return_value_abs$22)
                                    goto __CPROVER_DUMP_L74;

                                  signed int return_value_abs$23;
                                  return_value_abs$23=abs(lca);
                                  signed int return_value_abs$24;
                                  return_value_abs$24=abs(other);
                                  if(return_value_abs$23 == return_value_abs$24)
                                    goto __CPROVER_DUMP_L74;

                                  signed int return_value_abs$25;
                                  return_value_abs$25=abs(lca);
                                  signed int return_value_abs$26;
                                  return_value_abs$26=abs(other2);
                                  if(return_value_abs$25 == return_value_abs$26)
                                    goto __CPROVER_DUMP_L74;

                                  signed int return_value_lglunhimplies2incl$27;
                                  return_value_lglunhimplies2incl$27=lglunhimplies2incl(dfpr, lca, other);
                                  if(!(return_value_lglunhimplies2incl$27 == 0))
                                    goto __CPROVER_DUMP_L74;


                                __CPROVER_DUMP_L67:
                                  ;
                                  lgl->stats->unhd.hbrs.trn = lgl->stats->unhd.hbrs.trn + 1;
                                  if(!(red == 0))
                                    lgl->stats->unhd.hbrs.red = lgl->stats->unhd.hbrs.red + 1;

                                  lgl->stats->prgss = lgl->stats->prgss + 1l;
                                  ntrnhbrs = ntrnhbrs + 1;

                                __CPROVER_DUMP_L69:
                                  ;
                                  lgl->stats->red.bin = lgl->stats->red.bin + 1;
                                  delta=lglwchbin(lgl, -lca, other, REDCS);
                                  if(!(delta == 0l))
                                  {
                                    p = p + delta;
                                    q = q + delta;
                                    eow = eow + delta;
                                    w = w + delta;
                                  }

                                  delta=lglwchbin(lgl, other, -lca, REDCS);
                                  if(!(delta == 0l))
                                  {
                                    p = p + delta;
                                    q = q + delta;
                                    eow = eow + delta;
                                    w = w + delta;
                                  }

                                }

                              }

                            }

                        }
                      }
                    }
                  }
                }
              }

            }


          __CPROVER_DUMP_L74:
            ;
          }
          lglshrinkhts(lgl, hts, (signed int)((signed long int)hts->count - (p - q)));
        }

      }

    }

  NEXTIDX:
    ;
  }
  if(!(nbinred == 0))

    __CPROVER_DUMP_L79:
      ;

  if(!(nbinunits == 0))

    __CPROVER_DUMP_L81:
      ;

  if(!(ntrnred == 0))

    __CPROVER_DUMP_L83:
      ;

  if(!(ntrnstr == 0))

    __CPROVER_DUMP_L85:
      ;

  if(!(ntrnunits == 0))

    __CPROVER_DUMP_L87:
      ;

  if(!(ntrnstr == 0))

    __CPROVER_DUMP_L89:
      ;

  return 1;
}

// lglunhidefailed
// file lglib.c line 15247
static signed int lglunhidefailed(struct LGL *lgl, const struct DFPR *dfpr)
{
  signed int idx;
  signed int sign;
  signed int lit;
  signed int unit;
  signed int nfailed = 0;
  idx = 2;
  signed int return_value_lglunhimplincl$5;
  for( ; !(idx >= lgl->nvars); idx = idx + 1)
  {
    sign = -1;
    for( ; !(sign >= 2); sign = sign + 2)
    {
      signed int return_value_lglterminate$1;
      return_value_lglterminate$1=lglterminate(lgl);
      if(!(return_value_lglterminate$1 == 0))
        return 0;

      signed int return_value_lglsyncunits$2;
      return_value_lglsyncunits$2=lglsyncunits(lgl);
      if(return_value_lglsyncunits$2 == 0)
        return 0;

      lgl->stats->unhd.steps = lgl->stats->unhd.steps + 1l;
      lit = sign * idx;
      signed char return_value_lglval$3;
      return_value_lglval$3=lglval(lgl, lit);
      if(return_value_lglval$3 == 0)
      {
        signed int return_value_lglulit$4;
        return_value_lglulit$4=lglulit(lit);
        if(!((dfpr + (signed long int)return_value_lglulit$4)->discovered == 0))
        {
          signed int return_value_lglunhimplincl$6;
          return_value_lglunhimplincl$6=lglunhimplincl(dfpr, lit, -lit);
          if(!(return_value_lglunhimplincl$6 == 0))
            unit = -lit;

          else
          {
            return_value_lglunhimplincl$5=lglunhimplincl(dfpr, -lit, lit);
            if(!(return_value_lglunhimplincl$5 == 0))
              unit = lit;

            else
              goto __CPROVER_DUMP_L13;
          }

        __CPROVER_DUMP_L7:
          ;

        __CPROVER_DUMP_L9:
          ;

        __CPROVER_DUMP_L11:
          ;
          lglunit(lgl, unit);
          lgl->stats->unhd.failed.lits = lgl->stats->unhd.failed.lits + 1;
          nfailed = nfailed + 1;
          signed int return_value_lglbcp$7;
          return_value_lglbcp$7=lglbcp(lgl);
          if(return_value_lglbcp$7 == 0)
          {

          __CPROVER_DUMP_L12:
            ;
            lgl->mt = 1;
            return 0;
          }

        }

      }


    __CPROVER_DUMP_L13:
      ;
    }
  }

__CPROVER_DUMP_L15:
  ;
  return 1;
}

// lglunhideglue
// file lglib.c line 15493
static signed int lglunhideglue(struct LGL *lgl, const struct DFPR *dfpr, signed int glue, signed int irronly)
{
  struct DFL *dfl;
  struct DFL *eodfl;
  struct DFL *d;
  struct DFL *e;
  signed int szdfl;
  signed int posdfl;
  signed int negdfl;
  signed int ndfl;
  signed int res;
  signed int oldsize;
  signed int newsize;
  signed int hastobesatisfied;
  signed int satisfied;
  signed int tautological;
  signed int watched;
  signed int lit;
  signed int ulit;
  signed int val;
  signed int sign;
  signed int nonfalse;
  signed int root;
  signed int lca;
  signed int unit;
  signed int ntaut = 0;
  signed int nstr = 0;
  signed int nunits = 0;
  signed int nhbrs = 0;
  signed int lidx;
  signed int *p;
  signed int *q;
  signed int *c;
  signed int *eoc;
  signed int red;
  signed int lca1;
  signed int lca2;
  signed int root1;
  signed int root2;
  struct Stk *lglunhideglue$$1$$lits;
  if(!(glue >= 0))
  {
    lglunhideglue$$1$$lits = &lgl->irr;
    red = 0;
  }

  else
  {
    lglunhideglue$$1$$lits = lgl->red + (signed long int)glue;
    red = REDCS;
  }
  res = 1;
  dfl = ((struct DFL *)NULL);
  szdfl = 0;
  c = lglunhideglue$$1$$lits->start;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$4;
  signed int return_value_lglsyncunits$3;
  signed int *tmp_post$6;
  signed int *tmp_post$7;
  signed char return_value_lglval$10;
  _Bool tmp_if_expr$12;
  signed int return_value_lglunhroot$11;
  signed int return_value_lglcmpdfl$18;
  signed int return_value_lglmtstk$19;
  signed int return_value_lglcmpdfl$21;
  _Bool tmp_if_expr$22;
  _Bool tmp_if_expr$23;
  signed int return_value_lglcmpdfl$29;
  signed int return_value_lglmtstk$30;
  signed int return_value_lglcmpdfl$32;
  _Bool tmp_if_expr$33;
  signed int *tmp_post$34;
  signed int *tmp_post$35;
  signed int return_value_lglcmpdfl$41;
  signed int return_value_lglmtstk$42;
  signed int return_value_lglcmpdfl$44;
  _Bool tmp_if_expr$45;
  signed int *tmp_post$46;
  signed int *tmp_post$47;
  signed int return_value_lglunhimplies2incl$50;
  signed int tmp_if_expr$52;
  signed int return_value_lglunhlca$51;
  signed int tmp_if_expr$54;
  signed int return_value_lglunhlca$53;
  signed int return_value_lglunhimplies2incl$55;
  signed int *tmp_post$56;
  do
  {
    if(lgl->mt == 0)
      tmp_if_expr$1 = c < lglunhideglue$$1$$lits->top ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    signed int return_value_lglterminate$2;
    return_value_lglterminate$2=lglterminate(lgl);
    if(!(return_value_lglterminate$2 == 0))
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_lglsyncunits$3=lglsyncunits(lgl);
      tmp_if_expr$4 = !(return_value_lglsyncunits$3 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      res = 0;
      break;
    }

    eoc = c;
    lit = *eoc;
    if(!(lit >= 134217727))
    {
      lgl->stats->unhd.steps = lgl->stats->unhd.steps + 1l;
      lidx = (signed int)(c - lglunhideglue$$1$$lits->start);
      if(!(red == 0))
      {
        lidx = lidx << 4;
        lidx = lidx | glue;
      }

      watched = 1;
      for( ; !(*eoc == 0); eoc = eoc + 1l)
        ;
      oldsize = (signed int)(eoc - c);
      ndfl = 0;
      tautological = ndfl;
      satisfied = tautological;
      hastobesatisfied = satisfied;
      unit = hastobesatisfied;
      q = c;
      negdfl = 0;
      posdfl = negdfl;
      nonfalse = posdfl;
      p = c;
      for( ; !(p >= eoc); p = p + 1l)
      {
        lit = *p;
        signed char return_value_lglval$5;
        return_value_lglval$5=lglval(lgl, lit);
        val = (signed int)return_value_lglval$5;
        if(val >= 1)
        {
          satisfied = 1;
          q = c + (signed long int)2;
          break;
        }

        if(!(val >= 0))
        {
          if(!(p >= c + 2l))
          {
            tmp_post$6 = q;
            q = q + 1l;
            *tmp_post$6 = lit;
            hastobesatisfied = 1;
          }

        }

        else
        {
          tmp_post$7 = q;
          q = q + 1l;
          *tmp_post$7 = lit;
          nonfalse = nonfalse + 1;
          signed int return_value_lglulit$8;
          return_value_lglulit$8=lglulit(lit);
          if(!((dfpr + (signed long int)return_value_lglulit$8)->discovered == 0))
            posdfl = posdfl + 1;

          signed int return_value_lglulit$9;
          return_value_lglulit$9=lglulit(-lit);
          if(!((dfpr + (signed long int)return_value_lglulit$9)->discovered == 0))
            negdfl = negdfl + 1;

        }
      }
      eoc = q;
      *eoc = 0;
      ndfl = posdfl + negdfl;
      if(satisfied == 0 && ndfl >= 2)
      {
        if(nonfalse == negdfl)
        {
          root=lglunhroot(dfpr, -(*c));
          return_value_lglval$10=lglval(lgl, root);
          if(!(return_value_lglval$10 == 0))
            goto HTE;

          p = c + (signed long int)1;
          do
          {
            if(!(p >= eoc))
            {
              return_value_lglunhroot$11=lglunhroot(dfpr, -(*p));
              tmp_if_expr$12 = return_value_lglunhroot$11 == root ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$12 = (_Bool)0;
            if(!tmp_if_expr$12)
              break;

            p = p + 1l;
          }
          while((_Bool)1);
          if(!(p >= eoc))
            goto HTE;


        __CPROVER_DUMP_L25:
          ;

        __CPROVER_DUMP_L26:
          ;
          lca = -(*c);
          p = c + (signed long int)1;
          for( ; !(p >= eoc); p = p + 1l)
            lca=lglunhlca(lgl, dfpr, -(*p), lca);

        __CPROVER_DUMP_L28:
          ;
          lgl->stats->unhd.failed.lrg = lgl->stats->unhd.failed.lrg + 1;
          unit = -lca;
        }

        else
        {

        HTE:
          ;
          if(!(irronly == 0) || glue >= 0)
          {
            if(negdfl >= 2 && posdfl >= 2)
            {
              if(!(szdfl >= ndfl))
              {
                do
                {
                  void *return_value_lglrsz$13;
                  return_value_lglrsz$13=lglrsz(lgl, (void *)dfl, (unsigned long int)szdfl * sizeof(struct DFL) /*12ul*/ , (unsigned long int)ndfl * sizeof(struct DFL) /*12ul*/ );
                  dfl = (struct DFL *)return_value_lglrsz$13;
                }
                while((_Bool)0);
                szdfl = ndfl;
              }

              ndfl = 0;
              p = c;
              for( ; !(p >= eoc); p = p + 1l)
              {
                sign = -1;
                for( ; !(sign >= 2); sign = sign + 2)
                {
                  lit = *p;
                  ulit=lglulit(sign * lit);
                  if(!((dfpr + (signed long int)ulit)->discovered == 0))
                  {
                    (dfl + (signed long int)ndfl)->discovered = (dfpr + (signed long int)ulit)->discovered;
                    (dfl + (signed long int)ndfl)->finished = (dfpr + (signed long int)ulit)->finished;
                    (dfl + (signed long int)ndfl)->$anon0.sign = sign;
                    ndfl = ndfl + 1;
                  }

                }
              }
              lgl->stats->unhd.steps = lgl->stats->unhd.steps + (signed long int)6;
              do
              {
                struct DFL *AA = dfl;
                signed int NN = ndfl;
                do
                {
                  signed int L = 0;
                  signed int R = NN - 1;
                  signed int M;
                  signed int LL;
                  signed int RR;
                  signed int I;
                  if(!(R + -L >= 11))
                    break;

                  do
                  {
                    M = (L + R) / 2;
                    do
                    {
                      struct DFL TMP = AA[(signed long int)M];
                      AA[(signed long int)M] = AA[(signed long int)(R - 1)];
                      AA[(signed long int)(R - 1)] = TMP;
                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpdfl$14;
                      return_value_lglcmpdfl$14=lglcmpdfl(&AA[(signed long int)L], &AA[(signed long int)(R - 1)]);
                      if(return_value_lglcmpdfl$14 >= 1)
                        do
                        {
                          struct DFL lglunhideglue$$1$$3$$1$$11$$1$$1$$1$$2$$1$$TMP = AA[(signed long int)L];
                          AA[(signed long int)L] = AA[(signed long int)(R - 1)];
                          AA[(signed long int)(R - 1)] = lglunhideglue$$1$$3$$1$$11$$1$$1$$1$$2$$1$$TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpdfl$15;
                      return_value_lglcmpdfl$15=lglcmpdfl(&AA[(signed long int)L], &AA[(signed long int)R]);
                      if(return_value_lglcmpdfl$15 >= 1)
                        do
                        {
                          struct DFL lglunhideglue$$1$$3$$1$$11$$1$$1$$1$$3$$1$$TMP = AA[(signed long int)L];
                          AA[(signed long int)L] = AA[(signed long int)R];
                          AA[(signed long int)R] = lglunhideglue$$1$$3$$1$$11$$1$$1$$1$$3$$1$$TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpdfl$16;
                      return_value_lglcmpdfl$16=lglcmpdfl(&AA[(signed long int)(R - 1)], &AA[(signed long int)R]);
                      if(return_value_lglcmpdfl$16 >= 1)
                        do
                        {
                          struct DFL lglunhideglue$$1$$3$$1$$11$$1$$1$$1$$4$$1$$TMP = AA[(signed long int)(R - 1)];
                          AA[(signed long int)(R - 1)] = AA[(signed long int)R];
                          AA[(signed long int)R] = lglunhideglue$$1$$3$$1$$11$$1$$1$$1$$4$$1$$TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      struct DFL PIVOT;
                      signed int J = R - 1;
                      I = (L + 1) - 1;
                      PIVOT = AA[(signed long int)J];
                      do
                      {

                      __CPROVER_DUMP_L51:
                        ;
                        I = I + 1;
                        signed int return_value_lglcmpdfl$17;
                        return_value_lglcmpdfl$17=lglcmpdfl(&AA[(signed long int)I], &PIVOT);
                        if(!(return_value_lglcmpdfl$17 >= 0))
                          goto __CPROVER_DUMP_L51;

                        do
                        {
                          J = J - 1;
                          return_value_lglcmpdfl$18=lglcmpdfl(&PIVOT, &AA[(signed long int)J]);
                          if(return_value_lglcmpdfl$18 >= 0)
                            break;

                          if(J == 1 + L)
                            break;

                        }
                        while((_Bool)1);
                        if(I >= J)
                          break;

                        do
                        {
                          struct DFL lglunhideglue$$1$$3$$1$$11$$1$$1$$1$$5$$1$$1$$1$$TMP = AA[(signed long int)I];
                          AA[(signed long int)I] = AA[(signed long int)J];
                          AA[(signed long int)J] = lglunhideglue$$1$$3$$1$$11$$1$$1$$1$$5$$1$$1$$1$$TMP;
                        }
                        while((_Bool)0);
                      }
                      while((_Bool)1);
                      do
                      {
                        struct DFL lglunhideglue$$1$$3$$1$$11$$1$$1$$1$$5$$2$$TMP = AA[(signed long int)I];
                        AA[(signed long int)I] = AA[(signed long int)(R - 1)];
                        AA[(signed long int)(R - 1)] = lglunhideglue$$1$$3$$1$$11$$1$$1$$1$$5$$2$$TMP;
                      }
                      while((_Bool)0);
                    }
                    while((_Bool)0);
                    if(!(I + -L >= R + -I))
                    {
                      LL = I + 1;
                      RR = R;
                      R = I - 1;
                    }

                    else
                    {
                      LL = L;
                      RR = I - 1;
                      L = I + 1;
                    }
                    if(R + -L >= 11)
                    {
                      lglpushstk(lgl, &lgl->$anon1.sortstk, LL);
                      lglpushstk(lgl, &lgl->$anon1.sortstk, RR);
                    }

                    else
                      if(RR + -LL >= 11)
                      {
                        L = LL;
                        R = RR;
                      }

                      else
                      {
                        return_value_lglmtstk$19=lglmtstk(&lgl->$anon1.sortstk);
                        if(return_value_lglmtstk$19 == 0)
                        {
                          R=lglpopstk(&lgl->$anon1.sortstk);
                          L=lglpopstk(&lgl->$anon1.sortstk);
                        }

                        else
                          break;
                      }
                  }
                  while((_Bool)1);
                }
                while((_Bool)0);
                do
                {
                  struct DFL lglunhideglue$$1$$3$$1$$11$$2$$PIVOT;
                  signed int lglunhideglue$$1$$3$$1$$11$$2$$L = 0;
                  signed int lglunhideglue$$1$$3$$1$$11$$2$$R = NN - 1;
                  signed int lglunhideglue$$1$$3$$1$$11$$2$$I;
                  signed int lglunhideglue$$1$$3$$1$$11$$2$$J;
                  lglunhideglue$$1$$3$$1$$11$$2$$I = lglunhideglue$$1$$3$$1$$11$$2$$R;
                  for( ; !(lglunhideglue$$1$$3$$1$$11$$2$$L >= lglunhideglue$$1$$3$$1$$11$$2$$I); lglunhideglue$$1$$3$$1$$11$$2$$I = lglunhideglue$$1$$3$$1$$11$$2$$I - 1)
                    do
                    {
                      signed int return_value_lglcmpdfl$20;
                      return_value_lglcmpdfl$20=lglcmpdfl(&AA[(signed long int)(lglunhideglue$$1$$3$$1$$11$$2$$I - 1)], &AA[(signed long int)lglunhideglue$$1$$3$$1$$11$$2$$I]);
                      if(return_value_lglcmpdfl$20 >= 1)
                        do
                        {
                          struct DFL lglunhideglue$$1$$3$$1$$11$$2$$1$$1$$1$$TMP = AA[(signed long int)(lglunhideglue$$1$$3$$1$$11$$2$$I - 1)];
                          AA[(signed long int)(lglunhideglue$$1$$3$$1$$11$$2$$I - 1)] = AA[(signed long int)lglunhideglue$$1$$3$$1$$11$$2$$I];
                          AA[(signed long int)lglunhideglue$$1$$3$$1$$11$$2$$I] = lglunhideglue$$1$$3$$1$$11$$2$$1$$1$$1$$TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                  lglunhideglue$$1$$3$$1$$11$$2$$I = lglunhideglue$$1$$3$$1$$11$$2$$L + 2;
                  for( ; lglunhideglue$$1$$3$$1$$11$$2$$R >= lglunhideglue$$1$$3$$1$$11$$2$$I; lglunhideglue$$1$$3$$1$$11$$2$$I = lglunhideglue$$1$$3$$1$$11$$2$$I + 1)
                  {
                    lglunhideglue$$1$$3$$1$$11$$2$$J = lglunhideglue$$1$$3$$1$$11$$2$$I;
                    lglunhideglue$$1$$3$$1$$11$$2$$PIVOT = AA[(signed long int)lglunhideglue$$1$$3$$1$$11$$2$$I];
                    do
                    {
                      return_value_lglcmpdfl$21=lglcmpdfl(&lglunhideglue$$1$$3$$1$$11$$2$$PIVOT, &AA[(signed long int)(lglunhideglue$$1$$3$$1$$11$$2$$J - 1)]);
                      if(return_value_lglcmpdfl$21 >= 0)
                        break;

                      AA[(signed long int)lglunhideglue$$1$$3$$1$$11$$2$$J] = AA[(signed long int)(lglunhideglue$$1$$3$$1$$11$$2$$J - 1)];
                      lglunhideglue$$1$$3$$1$$11$$2$$J = lglunhideglue$$1$$3$$1$$11$$2$$J - 1;
                    }
                    while((_Bool)1);
                    AA[(signed long int)lglunhideglue$$1$$3$$1$$11$$2$$J] = lglunhideglue$$1$$3$$1$$11$$2$$PIVOT;
                  }
                }
                while((_Bool)0);

              __CPROVER_DUMP_L73:
                ;
              }
              while((_Bool)0);
              eodfl = dfl + (signed long int)ndfl;
              d = dfl;
              for( ; !(d >= eodfl + -1l); d = d + 1l)
                if(!(d->$anon0.sign >= 0))
                  break;

              while(!(d >= eodfl + -1l))
              {
                e = d + (signed long int)1;
                do
                {
                  if(!(e >= eodfl))
                    tmp_if_expr$22 = e->finished < d->finished ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$22 = (_Bool)0;
                  if(!tmp_if_expr$22)
                    break;

                  if(e->$anon0.sign >= 0)
                  {

                  __CPROVER_DUMP_L79:
                    ;
                    ntaut = ntaut + 1;
                    lgl->stats->unhd.tauts.lrg = lgl->stats->unhd.tauts.lrg + 1;
                    if(!(red == 0))
                      lgl->stats->unhd.tauts.red = lgl->stats->unhd.tauts.red + 1;

                    lgl->stats->prgss = lgl->stats->prgss + 1l;
                    tautological = 1;
                    goto NEXT;
                  }

                  e = e + 1l;
                }
                while((_Bool)1);
                d = e;
                do
                {
                  if(!(d >= eodfl))
                    tmp_if_expr$23 = d->$anon0.sign > 0 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$23 = (_Bool)0;
                  if(!tmp_if_expr$23)
                    break;

                  d = d + 1l;
                }
                while((_Bool)1);
              }
            }

          }


        STRNEG:
          ;
          if(negdfl >= 2)
          {
            if(!(szdfl >= negdfl))
            {
              do
              {
                void *return_value_lglrsz$24;
                return_value_lglrsz$24=lglrsz(lgl, (void *)dfl, (unsigned long int)szdfl * sizeof(struct DFL) /*12ul*/ , (unsigned long int)negdfl * sizeof(struct DFL) /*12ul*/ );
                dfl = (struct DFL *)return_value_lglrsz$24;
              }
              while((_Bool)0);
              szdfl = negdfl;
            }

            lgl->stats->unhd.steps = lgl->stats->unhd.steps + 1l;
            ndfl = 0;
            p = c;
            for( ; !(p >= eoc); p = p + 1l)
            {
              lit = *p;
              ulit=lglulit(-lit);
              if(!((dfpr + (signed long int)ulit)->discovered == 0))
              {
                (dfl + (signed long int)ndfl)->discovered = (dfpr + (signed long int)ulit)->discovered;
                (dfl + (signed long int)ndfl)->finished = (dfpr + (signed long int)ulit)->finished;
                (dfl + (signed long int)ndfl)->$anon0.lit = lit;
                ndfl = ndfl + 1;
              }

            }
            if(ndfl >= 2)
            {
              lgl->stats->unhd.steps = lgl->stats->unhd.steps + (signed long int)3;
              do
              {
                struct DFL *lglunhideglue$$1$$3$$1$$16$$AA = dfl;
                signed int lglunhideglue$$1$$3$$1$$16$$NN = ndfl;
                do
                {
                  signed int lglunhideglue$$1$$3$$1$$16$$1$$L = 0;
                  signed int lglunhideglue$$1$$3$$1$$16$$1$$R = lglunhideglue$$1$$3$$1$$16$$NN - 1;
                  signed int lglunhideglue$$1$$3$$1$$16$$1$$M;
                  signed int lglunhideglue$$1$$3$$1$$16$$1$$LL;
                  signed int lglunhideglue$$1$$3$$1$$16$$1$$RR;
                  signed int lglunhideglue$$1$$3$$1$$16$$1$$I;
                  if(!(lglunhideglue$$1$$3$$1$$16$$1$$R + -lglunhideglue$$1$$3$$1$$16$$1$$L >= 11))
                    break;

                  do
                  {
                    lglunhideglue$$1$$3$$1$$16$$1$$M = (lglunhideglue$$1$$3$$1$$16$$1$$L + lglunhideglue$$1$$3$$1$$16$$1$$R) / 2;
                    do
                    {
                      struct DFL lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$1$$TMP = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$M];
                      lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$M] = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$1$$R - 1)];
                      lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$1$$R - 1)] = lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$1$$TMP;
                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpdfl$25;
                      return_value_lglcmpdfl$25=lglcmpdfl(&lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$L], &lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$1$$R - 1)]);
                      if(return_value_lglcmpdfl$25 >= 1)
                        do
                        {
                          struct DFL lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$2$$1$$TMP = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$L];
                          lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$L] = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$1$$R - 1)];
                          lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$1$$R - 1)] = lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$2$$1$$TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpdfl$26;
                      return_value_lglcmpdfl$26=lglcmpdfl(&lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$L], &lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$R]);
                      if(return_value_lglcmpdfl$26 >= 1)
                        do
                        {
                          struct DFL lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$3$$1$$TMP = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$L];
                          lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$L] = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$R];
                          lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$R] = lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$3$$1$$TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      signed int return_value_lglcmpdfl$27;
                      return_value_lglcmpdfl$27=lglcmpdfl(&lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$1$$R - 1)], &lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$R]);
                      if(return_value_lglcmpdfl$27 >= 1)
                        do
                        {
                          struct DFL lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$4$$1$$TMP = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$1$$R - 1)];
                          lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$1$$R - 1)] = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$R];
                          lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$R] = lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$4$$1$$TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                    do
                    {
                      struct DFL lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$PIVOT;
                      signed int lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$J = lglunhideglue$$1$$3$$1$$16$$1$$R - 1;
                      lglunhideglue$$1$$3$$1$$16$$1$$I = (lglunhideglue$$1$$3$$1$$16$$1$$L + 1) - 1;
                      lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$PIVOT = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$J];
                      do
                      {

                      __CPROVER_DUMP_L107:
                        ;
                        lglunhideglue$$1$$3$$1$$16$$1$$I = lglunhideglue$$1$$3$$1$$16$$1$$I + 1;
                        signed int return_value_lglcmpdfl$28;
                        return_value_lglcmpdfl$28=lglcmpdfl(&lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$I], &lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$PIVOT);
                        if(!(return_value_lglcmpdfl$28 >= 0))
                          goto __CPROVER_DUMP_L107;

                        do
                        {
                          lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$J = lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$J - 1;
                          return_value_lglcmpdfl$29=lglcmpdfl(&lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$PIVOT, &lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$J]);
                          if(return_value_lglcmpdfl$29 >= 0)
                            break;

                          if(lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$J == 1 + lglunhideglue$$1$$3$$1$$16$$1$$L)
                            break;

                        }
                        while((_Bool)1);
                        if(lglunhideglue$$1$$3$$1$$16$$1$$I >= lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$J)
                          break;

                        do
                        {
                          struct DFL lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$1$$1$$1$$TMP = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$I];
                          lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$I] = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$J];
                          lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$J] = lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$1$$1$$1$$TMP;
                        }
                        while((_Bool)0);
                      }
                      while((_Bool)1);
                      do
                      {
                        struct DFL lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$2$$TMP = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$I];
                        lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$1$$I] = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$1$$R - 1)];
                        lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$1$$R - 1)] = lglunhideglue$$1$$3$$1$$16$$1$$1$$1$$5$$2$$TMP;
                      }
                      while((_Bool)0);
                    }
                    while((_Bool)0);
                    if(!(lglunhideglue$$1$$3$$1$$16$$1$$I + -lglunhideglue$$1$$3$$1$$16$$1$$L >= lglunhideglue$$1$$3$$1$$16$$1$$R + -lglunhideglue$$1$$3$$1$$16$$1$$I))
                    {
                      lglunhideglue$$1$$3$$1$$16$$1$$LL = lglunhideglue$$1$$3$$1$$16$$1$$I + 1;
                      lglunhideglue$$1$$3$$1$$16$$1$$RR = lglunhideglue$$1$$3$$1$$16$$1$$R;
                      lglunhideglue$$1$$3$$1$$16$$1$$R = lglunhideglue$$1$$3$$1$$16$$1$$I - 1;
                    }

                    else
                    {
                      lglunhideglue$$1$$3$$1$$16$$1$$LL = lglunhideglue$$1$$3$$1$$16$$1$$L;
                      lglunhideglue$$1$$3$$1$$16$$1$$RR = lglunhideglue$$1$$3$$1$$16$$1$$I - 1;
                      lglunhideglue$$1$$3$$1$$16$$1$$L = lglunhideglue$$1$$3$$1$$16$$1$$I + 1;
                    }
                    if(lglunhideglue$$1$$3$$1$$16$$1$$R + -lglunhideglue$$1$$3$$1$$16$$1$$L >= 11)
                    {
                      lglpushstk(lgl, &lgl->$anon1.sortstk, lglunhideglue$$1$$3$$1$$16$$1$$LL);
                      lglpushstk(lgl, &lgl->$anon1.sortstk, lglunhideglue$$1$$3$$1$$16$$1$$RR);
                    }

                    else
                      if(lglunhideglue$$1$$3$$1$$16$$1$$RR + -lglunhideglue$$1$$3$$1$$16$$1$$LL >= 11)
                      {
                        lglunhideglue$$1$$3$$1$$16$$1$$L = lglunhideglue$$1$$3$$1$$16$$1$$LL;
                        lglunhideglue$$1$$3$$1$$16$$1$$R = lglunhideglue$$1$$3$$1$$16$$1$$RR;
                      }

                      else
                      {
                        return_value_lglmtstk$30=lglmtstk(&lgl->$anon1.sortstk);
                        if(return_value_lglmtstk$30 == 0)
                        {
                          lglunhideglue$$1$$3$$1$$16$$1$$R=lglpopstk(&lgl->$anon1.sortstk);
                          lglunhideglue$$1$$3$$1$$16$$1$$L=lglpopstk(&lgl->$anon1.sortstk);
                        }

                        else
                          break;
                      }
                  }
                  while((_Bool)1);
                }
                while((_Bool)0);
                do
                {
                  struct DFL lglunhideglue$$1$$3$$1$$16$$2$$PIVOT;
                  signed int lglunhideglue$$1$$3$$1$$16$$2$$L = 0;
                  signed int lglunhideglue$$1$$3$$1$$16$$2$$R = lglunhideglue$$1$$3$$1$$16$$NN - 1;
                  signed int lglunhideglue$$1$$3$$1$$16$$2$$I;
                  signed int lglunhideglue$$1$$3$$1$$16$$2$$J;
                  lglunhideglue$$1$$3$$1$$16$$2$$I = lglunhideglue$$1$$3$$1$$16$$2$$R;
                  for( ; !(lglunhideglue$$1$$3$$1$$16$$2$$L >= lglunhideglue$$1$$3$$1$$16$$2$$I); lglunhideglue$$1$$3$$1$$16$$2$$I = lglunhideglue$$1$$3$$1$$16$$2$$I - 1)
                    do
                    {
                      signed int return_value_lglcmpdfl$31;
                      return_value_lglcmpdfl$31=lglcmpdfl(&lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$2$$I - 1)], &lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$2$$I]);
                      if(return_value_lglcmpdfl$31 >= 1)
                        do
                        {
                          struct DFL lglunhideglue$$1$$3$$1$$16$$2$$1$$1$$1$$TMP = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$2$$I - 1)];
                          lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$2$$I - 1)] = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$2$$I];
                          lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$2$$I] = lglunhideglue$$1$$3$$1$$16$$2$$1$$1$$1$$TMP;
                        }
                        while((_Bool)0);

                    }
                    while((_Bool)0);
                  lglunhideglue$$1$$3$$1$$16$$2$$I = lglunhideglue$$1$$3$$1$$16$$2$$L + 2;
                  for( ; lglunhideglue$$1$$3$$1$$16$$2$$R >= lglunhideglue$$1$$3$$1$$16$$2$$I; lglunhideglue$$1$$3$$1$$16$$2$$I = lglunhideglue$$1$$3$$1$$16$$2$$I + 1)
                  {
                    lglunhideglue$$1$$3$$1$$16$$2$$J = lglunhideglue$$1$$3$$1$$16$$2$$I;
                    lglunhideglue$$1$$3$$1$$16$$2$$PIVOT = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$2$$I];
                    do
                    {
                      return_value_lglcmpdfl$32=lglcmpdfl(&lglunhideglue$$1$$3$$1$$16$$2$$PIVOT, &lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$2$$J - 1)]);
                      if(return_value_lglcmpdfl$32 >= 0)
                        break;

                      lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$2$$J] = lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$16$$2$$J - 1)];
                      lglunhideglue$$1$$3$$1$$16$$2$$J = lglunhideglue$$1$$3$$1$$16$$2$$J - 1;
                    }
                    while((_Bool)1);
                    lglunhideglue$$1$$3$$1$$16$$AA[(signed long int)lglunhideglue$$1$$3$$1$$16$$2$$J] = lglunhideglue$$1$$3$$1$$16$$2$$PIVOT;
                  }
                }
                while((_Bool)0);

              __CPROVER_DUMP_L129:
                ;
              }
              while((_Bool)0);
              eodfl = dfl + (signed long int)ndfl;
              d = dfl;
              for( ; !(d >= eodfl + -1l); d = e)
              {
                e = d + (signed long int)1;
                do
                {
                  if(!(e >= eodfl))
                    tmp_if_expr$33 = d->finished >= e->finished ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$33 = (_Bool)0;
                  if(!tmp_if_expr$33)
                    break;

                  lit = e->$anon0.lit;

                __CPROVER_DUMP_L134:
                  ;
                  e->$anon0.lit = 0;
                  nstr = nstr + 1;
                  lgl->stats->unhd.str.lrg = lgl->stats->unhd.str.lrg + 1;
                  if(!(red == 0))
                    lgl->stats->unhd.str.red = lgl->stats->unhd.str.red + 1;

                  lgl->stats->prgss = lgl->stats->prgss + 1l;
                  if(!(watched == 0))
                  {
                    if(!(lit == *c))
                    {
                      if(!(lit == c[1l]))
                        goto __CPROVER_DUMP_L137;

                    }

                    lglrmlwch(lgl, c[(signed long int)0], red, lidx);
                    lglrmlwch(lgl, c[(signed long int)1], red, lidx);
                    watched = 0;
                  }


                __CPROVER_DUMP_L137:
                  ;
                  e = e + 1l;
                }
                while((_Bool)1);
              }
              q = c;
              if(!(watched == 0))
                q = q + (signed long int)2;

              p = q;
              for( ; !(p >= eoc); p = p + 1l)
              {
                lit = *p;
                ulit=lglulit(-lit);
                if((dfpr + (signed long int)ulit)->discovered == 0)
                {
                  tmp_post$34 = q;
                  q = q + 1l;
                  *tmp_post$34 = lit;
                }

              }
              d = dfl;
              for( ; !(d >= eodfl); d = d + 1l)
              {
                lit = d->$anon0.lit;
                if(!(lit == 0))
                {
                  if(!(watched == 0))
                  {
                    if(lit == *c)
                      goto __CPROVER_DUMP_L147;

                  }

                  if(!(watched == 0))
                  {
                    if(lit == c[1l])
                      goto __CPROVER_DUMP_L147;

                  }

                  tmp_post$35 = q;
                  q = q + 1l;
                  *tmp_post$35 = lit;
                }


              __CPROVER_DUMP_L147:
                ;
              }
              eoc = q;
              *eoc = 0;
            }

          }


        STRPOS:
          ;
          if(posdfl >= 2)
          {
            if(!(szdfl >= posdfl))
            {
              do
              {
                void *return_value_lglrsz$36;
                return_value_lglrsz$36=lglrsz(lgl, (void *)dfl, (unsigned long int)szdfl * sizeof(struct DFL) /*12ul*/ , (unsigned long int)posdfl * sizeof(struct DFL) /*12ul*/ );
                dfl = (struct DFL *)return_value_lglrsz$36;
              }
              while((_Bool)0);
              szdfl = posdfl;
            }

            ndfl = 0;
            p = c;
            for( ; !(p >= eoc); p = p + 1l)
            {
              lit = *p;
              ulit=lglulit(lit);
              if(!((dfpr + (signed long int)ulit)->discovered == 0))
              {
                (dfl + (signed long int)ndfl)->discovered = -(dfpr + (signed long int)ulit)->discovered;
                (dfl + (signed long int)ndfl)->finished = -(dfpr + (signed long int)ulit)->finished;
                (dfl + (signed long int)ndfl)->$anon0.lit = lit;
                ndfl = ndfl + 1;
              }

            }
            if(!(ndfl >= 2))
              goto NEXT;

            lgl->stats->unhd.steps = lgl->stats->unhd.steps + (signed long int)3;
            do
            {
              struct DFL *lglunhideglue$$1$$3$$1$$22$$AA = dfl;
              signed int lglunhideglue$$1$$3$$1$$22$$NN = ndfl;
              do
              {
                signed int lglunhideglue$$1$$3$$1$$22$$1$$L = 0;
                signed int lglunhideglue$$1$$3$$1$$22$$1$$R = lglunhideglue$$1$$3$$1$$22$$NN - 1;
                signed int lglunhideglue$$1$$3$$1$$22$$1$$M;
                signed int lglunhideglue$$1$$3$$1$$22$$1$$LL;
                signed int lglunhideglue$$1$$3$$1$$22$$1$$RR;
                signed int lglunhideglue$$1$$3$$1$$22$$1$$I;
                if(!(lglunhideglue$$1$$3$$1$$22$$1$$R + -lglunhideglue$$1$$3$$1$$22$$1$$L >= 11))
                  break;

                do
                {
                  lglunhideglue$$1$$3$$1$$22$$1$$M = (lglunhideglue$$1$$3$$1$$22$$1$$L + lglunhideglue$$1$$3$$1$$22$$1$$R) / 2;
                  do
                  {
                    struct DFL lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$1$$TMP = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$M];
                    lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$M] = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$1$$R - 1)];
                    lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$1$$R - 1)] = lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$1$$TMP;
                  }
                  while((_Bool)0);
                  do
                  {
                    signed int return_value_lglcmpdfl$37;
                    return_value_lglcmpdfl$37=lglcmpdfl(&lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$L], &lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$1$$R - 1)]);
                    if(return_value_lglcmpdfl$37 >= 1)
                      do
                      {
                        struct DFL lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$2$$1$$TMP = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$L];
                        lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$L] = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$1$$R - 1)];
                        lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$1$$R - 1)] = lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$2$$1$$TMP;
                      }
                      while((_Bool)0);

                  }
                  while((_Bool)0);
                  do
                  {
                    signed int return_value_lglcmpdfl$38;
                    return_value_lglcmpdfl$38=lglcmpdfl(&lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$L], &lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$R]);
                    if(return_value_lglcmpdfl$38 >= 1)
                      do
                      {
                        struct DFL lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$3$$1$$TMP = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$L];
                        lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$L] = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$R];
                        lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$R] = lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$3$$1$$TMP;
                      }
                      while((_Bool)0);

                  }
                  while((_Bool)0);
                  do
                  {
                    signed int return_value_lglcmpdfl$39;
                    return_value_lglcmpdfl$39=lglcmpdfl(&lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$1$$R - 1)], &lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$R]);
                    if(return_value_lglcmpdfl$39 >= 1)
                      do
                      {
                        struct DFL lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$4$$1$$TMP = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$1$$R - 1)];
                        lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$1$$R - 1)] = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$R];
                        lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$R] = lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$4$$1$$TMP;
                      }
                      while((_Bool)0);

                  }
                  while((_Bool)0);
                  do
                  {
                    struct DFL lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$PIVOT;
                    signed int lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$J = lglunhideglue$$1$$3$$1$$22$$1$$R - 1;
                    lglunhideglue$$1$$3$$1$$22$$1$$I = (lglunhideglue$$1$$3$$1$$22$$1$$L + 1) - 1;
                    lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$PIVOT = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$J];
                    do
                    {

                    __CPROVER_DUMP_L169:
                      ;
                      lglunhideglue$$1$$3$$1$$22$$1$$I = lglunhideglue$$1$$3$$1$$22$$1$$I + 1;
                      signed int return_value_lglcmpdfl$40;
                      return_value_lglcmpdfl$40=lglcmpdfl(&lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$I], &lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$PIVOT);
                      if(!(return_value_lglcmpdfl$40 >= 0))
                        goto __CPROVER_DUMP_L169;

                      do
                      {
                        lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$J = lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$J - 1;
                        return_value_lglcmpdfl$41=lglcmpdfl(&lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$PIVOT, &lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$J]);
                        if(return_value_lglcmpdfl$41 >= 0)
                          break;

                        if(lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$J == 1 + lglunhideglue$$1$$3$$1$$22$$1$$L)
                          break;

                      }
                      while((_Bool)1);
                      if(lglunhideglue$$1$$3$$1$$22$$1$$I >= lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$J)
                        break;

                      do
                      {
                        struct DFL lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$1$$1$$1$$TMP = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$I];
                        lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$I] = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$J];
                        lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$J] = lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$1$$1$$1$$TMP;
                      }
                      while((_Bool)0);
                    }
                    while((_Bool)1);
                    do
                    {
                      struct DFL lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$2$$TMP = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$I];
                      lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$1$$I] = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$1$$R - 1)];
                      lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$1$$R - 1)] = lglunhideglue$$1$$3$$1$$22$$1$$1$$1$$5$$2$$TMP;
                    }
                    while((_Bool)0);
                  }
                  while((_Bool)0);
                  if(!(lglunhideglue$$1$$3$$1$$22$$1$$I + -lglunhideglue$$1$$3$$1$$22$$1$$L >= lglunhideglue$$1$$3$$1$$22$$1$$R + -lglunhideglue$$1$$3$$1$$22$$1$$I))
                  {
                    lglunhideglue$$1$$3$$1$$22$$1$$LL = lglunhideglue$$1$$3$$1$$22$$1$$I + 1;
                    lglunhideglue$$1$$3$$1$$22$$1$$RR = lglunhideglue$$1$$3$$1$$22$$1$$R;
                    lglunhideglue$$1$$3$$1$$22$$1$$R = lglunhideglue$$1$$3$$1$$22$$1$$I - 1;
                  }

                  else
                  {
                    lglunhideglue$$1$$3$$1$$22$$1$$LL = lglunhideglue$$1$$3$$1$$22$$1$$L;
                    lglunhideglue$$1$$3$$1$$22$$1$$RR = lglunhideglue$$1$$3$$1$$22$$1$$I - 1;
                    lglunhideglue$$1$$3$$1$$22$$1$$L = lglunhideglue$$1$$3$$1$$22$$1$$I + 1;
                  }
                  if(lglunhideglue$$1$$3$$1$$22$$1$$R + -lglunhideglue$$1$$3$$1$$22$$1$$L >= 11)
                  {
                    lglpushstk(lgl, &lgl->$anon1.sortstk, lglunhideglue$$1$$3$$1$$22$$1$$LL);
                    lglpushstk(lgl, &lgl->$anon1.sortstk, lglunhideglue$$1$$3$$1$$22$$1$$RR);
                  }

                  else
                    if(lglunhideglue$$1$$3$$1$$22$$1$$RR + -lglunhideglue$$1$$3$$1$$22$$1$$LL >= 11)
                    {
                      lglunhideglue$$1$$3$$1$$22$$1$$L = lglunhideglue$$1$$3$$1$$22$$1$$LL;
                      lglunhideglue$$1$$3$$1$$22$$1$$R = lglunhideglue$$1$$3$$1$$22$$1$$RR;
                    }

                    else
                    {
                      return_value_lglmtstk$42=lglmtstk(&lgl->$anon1.sortstk);
                      if(return_value_lglmtstk$42 == 0)
                      {
                        lglunhideglue$$1$$3$$1$$22$$1$$R=lglpopstk(&lgl->$anon1.sortstk);
                        lglunhideglue$$1$$3$$1$$22$$1$$L=lglpopstk(&lgl->$anon1.sortstk);
                      }

                      else
                        break;
                    }
                }
                while((_Bool)1);
              }
              while((_Bool)0);
              do
              {
                struct DFL lglunhideglue$$1$$3$$1$$22$$2$$PIVOT;
                signed int lglunhideglue$$1$$3$$1$$22$$2$$L = 0;
                signed int lglunhideglue$$1$$3$$1$$22$$2$$R = lglunhideglue$$1$$3$$1$$22$$NN - 1;
                signed int lglunhideglue$$1$$3$$1$$22$$2$$I;
                signed int lglunhideglue$$1$$3$$1$$22$$2$$J;
                lglunhideglue$$1$$3$$1$$22$$2$$I = lglunhideglue$$1$$3$$1$$22$$2$$R;
                for( ; !(lglunhideglue$$1$$3$$1$$22$$2$$L >= lglunhideglue$$1$$3$$1$$22$$2$$I); lglunhideglue$$1$$3$$1$$22$$2$$I = lglunhideglue$$1$$3$$1$$22$$2$$I - 1)
                  do
                  {
                    signed int return_value_lglcmpdfl$43;
                    return_value_lglcmpdfl$43=lglcmpdfl(&lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$2$$I - 1)], &lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$2$$I]);
                    if(return_value_lglcmpdfl$43 >= 1)
                      do
                      {
                        struct DFL lglunhideglue$$1$$3$$1$$22$$2$$1$$1$$1$$TMP = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$2$$I - 1)];
                        lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$2$$I - 1)] = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$2$$I];
                        lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$2$$I] = lglunhideglue$$1$$3$$1$$22$$2$$1$$1$$1$$TMP;
                      }
                      while((_Bool)0);

                  }
                  while((_Bool)0);
                lglunhideglue$$1$$3$$1$$22$$2$$I = lglunhideglue$$1$$3$$1$$22$$2$$L + 2;
                for( ; lglunhideglue$$1$$3$$1$$22$$2$$R >= lglunhideglue$$1$$3$$1$$22$$2$$I; lglunhideglue$$1$$3$$1$$22$$2$$I = lglunhideglue$$1$$3$$1$$22$$2$$I + 1)
                {
                  lglunhideglue$$1$$3$$1$$22$$2$$J = lglunhideglue$$1$$3$$1$$22$$2$$I;
                  lglunhideglue$$1$$3$$1$$22$$2$$PIVOT = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$2$$I];
                  do
                  {
                    return_value_lglcmpdfl$44=lglcmpdfl(&lglunhideglue$$1$$3$$1$$22$$2$$PIVOT, &lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$2$$J - 1)]);
                    if(return_value_lglcmpdfl$44 >= 0)
                      break;

                    lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$2$$J] = lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)(lglunhideglue$$1$$3$$1$$22$$2$$J - 1)];
                    lglunhideglue$$1$$3$$1$$22$$2$$J = lglunhideglue$$1$$3$$1$$22$$2$$J - 1;
                  }
                  while((_Bool)1);
                  lglunhideglue$$1$$3$$1$$22$$AA[(signed long int)lglunhideglue$$1$$3$$1$$22$$2$$J] = lglunhideglue$$1$$3$$1$$22$$2$$PIVOT;
                }
              }
              while((_Bool)0);

            __CPROVER_DUMP_L191:
              ;
            }
            while((_Bool)0);
            eodfl = dfl + (signed long int)ndfl;
            d = dfl;
            for( ; !(d >= eodfl + -1l); d = e)
            {
              e = d + (signed long int)1;
              do
              {
                if(!(e >= eodfl))
                  tmp_if_expr$45 = d->finished >= e->finished ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$45 = (_Bool)0;
                if(!tmp_if_expr$45)
                  break;

                lit = e->$anon0.lit;

              __CPROVER_DUMP_L196:
                ;
                e->$anon0.lit = 0;
                nstr = nstr + 1;
                lgl->stats->unhd.str.lrg = lgl->stats->unhd.str.lrg + 1;
                if(!(red == 0))
                  lgl->stats->unhd.str.red = lgl->stats->unhd.str.red + 1;

                lgl->stats->prgss = lgl->stats->prgss + 1l;
                if(!(watched == 0))
                {
                  if(!(lit == *c))
                  {
                    if(!(lit == c[1l]))
                      goto __CPROVER_DUMP_L199;

                  }

                  lglrmlwch(lgl, c[(signed long int)0], red, lidx);
                  lglrmlwch(lgl, c[(signed long int)1], red, lidx);
                  watched = 0;
                }


              __CPROVER_DUMP_L199:
                ;
                e = e + 1l;
              }
              while((_Bool)1);
            }
            q = c;
            if(!(watched == 0))
              q = q + (signed long int)2;

            p = q;
            for( ; !(p >= eoc); p = p + 1l)
            {
              lit = *p;
              ulit=lglulit(lit);
              if((dfpr + (signed long int)ulit)->discovered == 0)
              {
                tmp_post$46 = q;
                q = q + 1l;
                *tmp_post$46 = lit;
              }

            }
            d = dfl;
            for( ; !(d >= eodfl); d = d + 1l)
            {
              lit = d->$anon0.lit;
              if(!(lit == 0))
              {
                if(!(watched == 0))
                {
                  if(lit == *c)
                    goto __CPROVER_DUMP_L209;

                }

                if(!(watched == 0))
                {
                  if(lit == c[1l])
                    goto __CPROVER_DUMP_L209;

                }

                tmp_post$47 = q;
                q = q + 1l;
                *tmp_post$47 = lit;
              }


            __CPROVER_DUMP_L209:
              ;
            }
            eoc = q;
            *eoc = 0;
          }


        HBR:
          ;
          if(!(lgl->opts->unhdhbr.val == 0))
          {
            if(eoc - c >= 3l)
            {
              lca2 = 0;
              lca1 = lca2;
              root2 = lca1;
              root1 = root2;
              p = c;
              do
              {
                lit = *p;
                if(lit == 0)
                  break;

                root=lglunhroot(dfpr, -lit);
                if(root == 0)
                  root = -lit;

                if(root1 == 0)
                  root1 = root;

                else
                  if(!(root1 == root))
                  {
                    if(root2 == 0)
                      root2 = root;

                    else
                      if(!(root2 == root))
                      {
                        signed int return_value_lglunhimplies2incl$48;
                        return_value_lglunhimplies2incl$48=lglunhimplies2incl(dfpr, root1, -lit);
                        if(!(return_value_lglunhimplies2incl$48 == 0))
                          lca1 = root1;

                        else
                        {
                          signed int return_value_lglunhimplies2incl$49;
                          return_value_lglunhimplies2incl$49=lglunhimplies2incl(dfpr, root2, -lit);
                          if(!(return_value_lglunhimplies2incl$49 == 0))
                            lca2 = root2;

                          else
                            goto NEXT;
                        }
                      }

                  }

                p = p + 1l;
              }
              while((_Bool)1);
              if(!(root2 == 0))
              {
                if(!(root1 == -root2))
                {
                  return_value_lglunhimplies2incl$50=lglunhimplies2incl(dfpr, root1, -root2);
                  if(return_value_lglunhimplies2incl$50 == 0)
                  {

                  __CPROVER_DUMP_L220:
                    ;
                    if(lca1 == 0 && lca2 == 0)
                    {
                      p = c;
                      do
                      {
                        lit = *p;
                        if(lit == 0)
                          break;

                        root=lglunhroot(dfpr, -lit);
                        if(!(root == 0))
                        {
                          if(root == root1)
                          {
                            if(!(lca1 == 0))
                            {
                              return_value_lglunhlca$51=lglunhlca(lgl, dfpr, lca1, -lit);
                              tmp_if_expr$52 = return_value_lglunhlca$51;
                            }

                            else
                              tmp_if_expr$52 = -lit;
                            lca1 = tmp_if_expr$52;
                          }

                          if(root == root2)
                          {
                            if(!(lca2 == 0))
                            {
                              return_value_lglunhlca$53=lglunhlca(lgl, dfpr, lca2, -lit);
                              tmp_if_expr$54 = return_value_lglunhlca$53;
                            }

                            else
                              tmp_if_expr$54 = -lit;
                            lca2 = tmp_if_expr$54;
                          }

                        }

                        else
                          if(!(lca1 == 0))
                            lca2 = -lit;

                          else
                            lca1 = -lit;
                        p = p + 1l;
                      }
                      while((_Bool)1);
                    }

                    else
                    {
                      if(lca1 == 0)
                        lca1 = root1;

                      if(lca2 == 0)
                        lca2 = root2;

                    }
                    if(!(lca1 == -lca2))
                    {
                      return_value_lglunhimplies2incl$55=lglunhimplies2incl(dfpr, lca1, -lca2);
                      if(return_value_lglunhimplies2incl$55 == 0)
                      {

                      __CPROVER_DUMP_L235:
                        ;
                        lgl->stats->unhd.hbrs.lrg = lgl->stats->unhd.hbrs.lrg + 1;
                        if(!(red == 0))
                          lgl->stats->unhd.hbrs.red = lgl->stats->unhd.hbrs.red + 1;

                        lglwchbin(lgl, -lca1, -lca2, REDCS);
                        lglwchbin(lgl, -lca2, -lca1, REDCS);
                        lgl->stats->red.bin = lgl->stats->red.bin + 1;
                      }

                    }

                  }

                }

              }

            }

          }

        }
      }


    NEXT:
      ;
      newsize = (signed int)(eoc - c);
      if(!(satisfied == 0) || !(tautological == 0) || !(newsize >= 4))
      {
        lgldeclscnt(lgl, oldsize, red, glue);
        if(!(watched == 0))
        {
          lglrmlwch(lgl, c[(signed long int)0], red, lidx);
          lglrmlwch(lgl, c[(signed long int)1], red, lidx);
        }

      }

      else
        if(red == 0)
          lgl->stats->irr.lits.cur = lgl->stats->irr.lits.cur - (signed int)((c + (signed long int)oldsize) - eoc);

      p = c + (signed long int)oldsize;
      for( ; !(eoc >= p); p = p - 1l)
        *p = 0x7fffffff;
      if(!(satisfied == 0) || !(tautological == 0))
      {
        for( ; p >= c; *tmp_post$56 = 0x7fffffff)
        {
          tmp_post$56 = p;
          p = p - 1l;
        }
        if(!(red == 0))
        {

        __CPROVER_DUMP_L245:
          ;
          c[(signed long int)-1] = 0x7fffffff;
        }

        eoc = c + (signed long int)oldsize;
      }

      else
      {
        if(!(red == 0) && !(newsize >= 4))
        {

        __CPROVER_DUMP_L248:
          ;
          c[(signed long int)-1] = 0x7fffffff;
        }

        if(watched == 0 && newsize >= 4)
        {
          lglwchlrg(lgl, c[(signed long int)0], c[(signed long int)1], red, lidx);
          lglwchlrg(lgl, c[(signed long int)1], c[(signed long int)0], red, lidx);
        }

        else
          if(newsize == 3)
          {

          __CPROVER_DUMP_L251:
            ;
            lglwchtrn(lgl, c[(signed long int)0], c[(signed long int)1], c[(signed long int)2], red);
            lglwchtrn(lgl, c[(signed long int)1], c[(signed long int)0], c[(signed long int)2], red);
            lglwchtrn(lgl, c[(signed long int)2], c[(signed long int)0], c[(signed long int)1], red);
            if(red == 0)
              lglincirr(lgl, 3);

            else
              lgl->stats->red.trn = lgl->stats->red.trn + 1;
            *eoc = 0x7fffffff;
            c[(signed long int)2] = *eoc;
            c[(signed long int)1] = c[(signed long int)2];
            c[(signed long int)0] = c[(signed long int)1];
          }

          else
            if(newsize == 2)
            {

            __CPROVER_DUMP_L255:
              ;
              lglwchbin(lgl, c[(signed long int)0], c[(signed long int)1], red);
              lglwchbin(lgl, c[(signed long int)1], c[(signed long int)0], red);
              if(red == 0)
                lglincirr(lgl, 2);

              else
                lgl->stats->red.bin = lgl->stats->red.bin + 1;
              *eoc = 0x7fffffff;
              c[(signed long int)1] = *eoc;
              c[(signed long int)0] = c[(signed long int)1];
            }

            else
              if(newsize == 1)
              {

              __CPROVER_DUMP_L259:
                ;
                unit = c[(signed long int)0];
                *eoc = 0x7fffffff;
                c[(signed long int)0] = *eoc;
                lgl->stats->unhd.units.lrg = lgl->stats->unhd.units.lrg + 1;
                nunits = nunits + 1;
              }

        if(!(unit == 0))
        {
          lglunit(lgl, unit);
          signed int return_value_lglbcp$57;
          return_value_lglbcp$57=lglbcp(lgl);
          if(return_value_lglbcp$57 == 0)
          {
            lgl->mt = 1;

          __CPROVER_DUMP_L261:
            ;
            res = 0;
          }

        }

      }
    }

    c = eoc + (signed long int)1;
  }
  while((_Bool)1);
  if(!(nunits == 0))

    __CPROVER_DUMP_L264:
      ;

  if(!(ntaut == 0))

    __CPROVER_DUMP_L266:
      ;

  if(!(nstr == 0))

    __CPROVER_DUMP_L268:
      ;

  if(!(nhbrs == 0))

    __CPROVER_DUMP_L270:
      ;

  if(!(dfl == ((struct DFL *)NULL)))
    do
    {
      lgldel(lgl, (void *)dfl, (unsigned long int)szdfl * sizeof(struct DFL) /*12ul*/ );
      dfl = ((struct DFL *)NULL);
    }
    while((_Bool)0);

  return res;
}

// lglunhidelrg
// file lglib.c line 15913
static signed int lglunhidelrg(struct LGL *lgl, const struct DFPR *dfpr, signed int irronly)
{
  signed int glue;
  signed int res = 1;
  glue = -1;
  for( ; !(res == 0) && !(glue >= 15); glue = glue + 1)
    res=lglunhideglue(lgl, dfpr, glue, irronly);
  lglfixlrgwchs(lgl);
  return res;
}

// lglunhiding
// file lglib.c line 16951
static signed int lglunhiding(struct LGL *lgl)
{
  return lgl->opts->unhide.val;
}

// lglunhimpl
// file lglib.c line 10176
static signed int lglunhimpl(const struct DFPR *dfpr, signed int a, signed int b)
{
  signed int u;
  u=lglulit(a);
  signed int v;
  v=lglulit(b);
  signed int c;
  signed int d;
  signed int f;
  signed int g;
  c = (dfpr + (signed long int)u)->discovered;
  if(c == 0)
    return 0;

  else
  {
    d = (dfpr + (signed long int)v)->discovered;
    if(d == 0)
      return 0;

    else
    {
      f = (dfpr + (signed long int)u)->finished;
      g = (dfpr + (signed long int)v)->finished;
      return (signed int)(c < d && g < f);
    }
  }
}

// lglunhimplies2
// file lglib.c line 10186
static signed int lglunhimplies2(const struct DFPR *dfpr, signed int a, signed int b)
{
  signed int return_value_lglunhimpl$1;
  return_value_lglunhimpl$1=lglunhimpl(dfpr, a, b);
  _Bool tmp_if_expr$3;
  signed int return_value_lglunhimpl$2;
  if(!(return_value_lglunhimpl$1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_lglunhimpl$2=lglunhimpl(dfpr, -b, -a);
    tmp_if_expr$3 = return_value_lglunhimpl$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr$3;
}

// lglunhimplies2incl
// file lglib.c line 10200
static signed int lglunhimplies2incl(const struct DFPR *dfpr, signed int a, signed int b)
{
  signed int return_value_lglunhimplincl$1;
  return_value_lglunhimplincl$1=lglunhimplincl(dfpr, a, b);
  _Bool tmp_if_expr$3;
  signed int return_value_lglunhimplincl$2;
  if(!(return_value_lglunhimplincl$1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_lglunhimplincl$2=lglunhimplincl(dfpr, -b, -a);
    tmp_if_expr$3 = return_value_lglunhimplincl$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr$3;
}

// lglunhimplincl
// file lglib.c line 10190
static signed int lglunhimplincl(const struct DFPR *dfpr, signed int a, signed int b)
{
  signed int u;
  u=lglulit(a);
  signed int v;
  v=lglulit(b);
  signed int c;
  signed int d;
  signed int f;
  signed int g;
  c = (dfpr + (signed long int)u)->discovered;
  if(c == 0)
    return 0;

  else
  {
    d = (dfpr + (signed long int)v)->discovered;
    if(d == 0)
      return 0;

    else
    {
      f = (dfpr + (signed long int)u)->finished;
      g = (dfpr + (signed long int)v)->finished;
      return (signed int)(c <= d && g <= f);
    }
  }
}

// lglunhlca
// file lglib.c line 15222
static signed int lglunhlca(struct LGL *lgl, const struct DFPR *dfpr, signed int a, signed int b)
{
  const struct DFPR *c;
  const struct DFPR *d;
  signed int u;
  signed int v;
  signed int p;
  if(a == b)
    return a;

  else
  {
    u=lglulit(a);
    v=lglulit(b);
    c = dfpr + (signed long int)u;
    d = dfpr + (signed long int)v;
    if(d->discovered >= c->discovered)
      p = a;

    else
    {
      p = b;
      do
      {
        const struct DFPR *TMP = c;
        c = d;
        d = TMP;
      }
      while((_Bool)0);
    }
    for( ; !(c->finished >= d->finished); c = dfpr + (signed long int)u)
    {
      p = c->parent;
      if(p == 0)
        break;

      u=lglulit(p);
    }

  __CPROVER_DUMP_L5:
    ;
    return p;
  }
}

// lglunhroot
// file lglib.c line 15279
static signed int lglunhroot(const struct DFPR *dfpr, signed int lit)
{
  signed int return_value_lglulit$1;
  return_value_lglulit$1=lglulit(lit);
  return (dfpr + (signed long int)return_value_lglulit$1)->root;
}

// lglunit
// file lglib.c line 2932
static void lglunit(struct LGL *lgl, signed int lit)
{
  lglunitnocheck(lgl, lit);
}

// lglunitnocheck
// file lglib.c line 2926
static void lglunitnocheck(struct LGL *lgl, signed int lit)
{

__CPROVER_DUMP_L1:
  ;
  lglassign(lgl, lit, lit << RMSHFT | UNITCS, 0);
}

// lglunmark
// file lglib.c line 2943
static void lglunmark(struct LGL *lgl, signed int lit)
{
  struct AVar *return_value_lglavar$1;
  return_value_lglavar$1=lglavar(lgl, lit);
  return_value_lglavar$1->mark = 0;
}

// lglunuselevel
// file lglib.c line 1595
static void lglunuselevel(struct LGL *lgl, signed int level)
{
  struct Ctk *ctk = &lgl->control;
  struct Ctr *ctr = ctk->start + (signed long int)level;
  ctr->used = (unsigned int)0;
}

// lglupdblkint
// file lglib.c line 11312
static void lglupdblkint(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->blk.pen == 0))
      lgl->limits->blk.pen = lgl->limits->blk.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->blk.pen >= 4))
      lgl->limits->blk.pen = lgl->limits->blk.pen + 1;

  }

  lgl->limits->blk.irrprgss = lgl->stats->irrprgss;
}

// lglupdcceint
// file lglib.c line 11473
static void lglupdcceint(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->cce.pen == 0))
      lgl->limits->cce.pen = lgl->limits->cce.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->cce.pen >= 4))
      lgl->limits->cce.pen = lgl->limits->cce.pen + 1;

  }

}

// lglupdcgrpen
// file lglib.c line 13754
static void lglupdcgrpen(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->cgr.pen == 0))
      lgl->limits->cgr.pen = lgl->limits->cgr.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->cgr.pen >= 4))
      lgl->limits->cgr.pen = lgl->limits->cgr.pen + 1;

  }

}

// lglupdcliffint
// file lglib.c line 12059
static void lglupdcliffint(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->cliff.pen == 0))
      lgl->limits->cliff.pen = lgl->limits->cliff.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->cliff.pen >= 4))
      lgl->limits->cliff.pen = lgl->limits->cliff.pen + 1;

  }

  lgl->limits->cliff.irrprgss = lgl->stats->irrprgss;
}

// lglupdelmint
// file lglib.c line 12122
static void lglupdelmint(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->elm.pen == 0))
      lgl->limits->elm.pen = lgl->limits->elm.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->elm.pen >= 4))
      lgl->limits->elm.pen = lgl->limits->elm.pen + 1;

  }

  lgl->limits->elm.irrprgss = lgl->stats->irrprgss;
}

// lglupdflipint
// file lglib.c line 7752
static void lglupdflipint(struct LGL *lgl)
{
  signed long int limit = (signed long int)lgl->opts->flipint.val;
  if(limit >= 2147483648l)
    limit = (signed long int)0x7fffffff;

  lgl->limits->flipint = (signed int)limit;
}

// lglupdgausspen
// file lglib.c line 16803
static void lglupdgausspen(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->gauss.pen == 0))
      lgl->limits->gauss.pen = lgl->limits->gauss.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->gauss.pen >= 4))
      lgl->limits->gauss.pen = lgl->limits->gauss.pen + 1;

  }

}

// lglupdlftpen
// file lglib.c line 13951
static void lglupdlftpen(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->lft.pen == 0))
      lgl->limits->lft.pen = lgl->limits->lft.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->lft.pen >= 4))
      lgl->limits->lft.pen = lgl->limits->lft.pen + 1;

  }

}

// lglupdprbasicpen
// file lglib.c line 8934
static void lglupdprbasicpen(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->prb.pen.basic == 0))
      lgl->limits->prb.pen.basic = lgl->limits->prb.pen.basic - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->prb.pen.basic >= 4))
      lgl->limits->prb.pen.basic = lgl->limits->prb.pen.basic + 1;

  }

}

// lglupdprepint
// file lglib.c line 17092
static void lglupdprepint(struct LGL *lgl, signed int red)
{
  signed int div;
  signed int return_value_abs$1;
  return_value_abs$1=abs(red);
  div = return_value_abs$1 / 2 + 1;
  signed long int inc;
  if(red >= 101)
    lglprt(lgl, 1, "[simplification-%d] no increase of limit increments", lgl->stats->simp.count);

  else
  {
    if(div == 1)
      lglprt(lgl, 1, "[simplification-%d] no reduction of limit increments", lgl->stats->simp.count, div);

    else
      lglprt(lgl, 1, "[simplification-%d] limit increments divided by %d", lgl->stats->simp.count, div);
    if(!(lgl->opts->simplify.val == 0))
    {
      inc = (signed long int)(lgl->opts->cintinc.val / div);
      lgl->limits->simp.cinc = lgl->limits->simp.cinc + inc;
      lglprt(lgl, 1, "[simplification-%d] arithmetic increase of conflict limit interval by %lld", lgl->stats->simp.count, (signed long long int)inc);
    }

    else
      lglprt(lgl, 1, "[simplification-%d] limit does not change", lgl->stats->simp.count);
  }
  lgl->limits->simp.confs = lgl->stats->confs + lgl->limits->simp.cinc;
  lgl->limits->simp.irr=lglnewirrlim(lgl);
  lglprt(lgl, 1, "[simplification-%d] new irredundant limit %lld", lgl->stats->simp.count, (signed long long int)lgl->limits->simp.irr);
  lglprt(lgl, 1, "[simplification-%d] new conflict limit %lld", lgl->stats->simp.count, (signed long long int)lgl->limits->simp.confs);
  lgl->limits->simp.prgss = lgl->stats->prgss;
  if(lgl->limits->simp.pen >= 1)
  {
    lgl->limits->simp.pen = lgl->limits->simp.pen - 1;
    lglprt(lgl, 1, "[simplification-%d] simplification penalty reduced to %d", lgl->stats->simp.count, lgl->limits->simp.pen);
  }

}

// lglupdternrespen
// file lglib.c line 14684
static void lglupdternrespen(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->trnr.pen == 0))
      lgl->limits->trnr.pen = lgl->limits->trnr.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->trnr.pen >= 4))
      lgl->limits->trnr.pen = lgl->limits->trnr.pen + 1;

  }

}

// lglupdunhdpen
// file lglib.c line 16146
static void lglupdunhdpen(struct LGL *lgl, signed int success)
{
  if(!(success == 0))
  {
    if(!(lgl->limits->unhd.pen == 0))
      lgl->limits->unhd.pen = lgl->limits->unhd.pen - 1;

  }

  if(success == 0)
  {
    if(!(lgl->limits->unhd.pen >= 4))
      lgl->limits->unhd.pen = lgl->limits->unhd.pen + 1;

  }

}

// lglusage
// file lglib.c line 2096
void lglusage(struct LGL *lgl)
{
  char fmt[20l];
  signed int len;
  struct Opt *o;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglusage");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  len=lglmaxoptnamelen(lgl);
  sprintf(fmt, "--%%-%ds", len);
  o = &lgl->opts->beforefirst + (signed long int)1;
  for( ; &lgl->opts->afterlast + -1l >= o; o = o + 1l)
  {
    if(!(o->shrt == 0))
      fprintf(lgl->out, "-%c|", o->shrt);

    else
      fprintf(lgl->out, "   ");
    fprintf(lgl->out, fmt, o->lng);
    fprintf(lgl->out, " %s [%d]\n", o->descrp, o->val);
  }
}

// lgluse
// file lglib.c line 3806
static void lgluse(struct LGL *lgl)
{
  if(!((signed int)lgl->state >= USED))
  {

  __CPROVER_DUMP_L1:
    ;
    do
      lgl->state = (enum State)USED;
    while((_Bool)0);
  }

}

// lgluselevel
// file lglib.c line 1587
static void lgluselevel(struct LGL *lgl, signed int level)
{
  struct Ctk *ctk = &lgl->control;
  struct Ctr *ctr = ctk->start + (signed long int)level;
  ctr->used = (unsigned int)1;
}

// lglutrav
// file lglib.c line 18718
void lglutrav(struct LGL *lgl, void *state, void (*trav)(void *, signed int))
{
  signed int elit;
  signed int val;

__CPROVER_DUMP_L1:
  ;
  do
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglutrav");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

  while((_Bool)0);
  signed int return_value_lglbcp$1;
  if(lgl->mt == 0)
  {
    return_value_lglbcp$1=lglbcp(lgl);
    if(return_value_lglbcp$1 == 0)
      lgl->mt = 1;

  }

  if(lgl->mt == 0)
    lglgc(lgl);

  if(lgl->mt == 0)
  {
    if(lgl->level >= 1)
      lglbacktrack(lgl, 0);

    elit = 1;
    for( ; lgl->maxext >= elit; elit = elit + 1)
    {
      val=lglefixed(lgl, elit);
      if(!(val == 0))
        trav(state, val < 0 ? -elit : elit);

    }
  }

}

// lglval
// file lglib.c line 2323
static signed char lglval(struct LGL *lgl, signed int lit)
{
  signed int idx;
  idx=abs(lit);
  signed char res = lgl->vals[(signed long int)idx];
  if(!(lit >= 0))
    res = (signed char)-((signed int)res);

  return res;
}

// lglvar2fun
// file lglib.c line 10499
static void lglvar2fun(signed int v, unsigned long int *res)
{
  lglvar2funaux(v, res, 0);
}

// lglvar2funaux
// file lglib.c line 10477
static void lglvar2funaux(signed int v, unsigned long int *res, signed int negate)
{
  unsigned long int tmp;
  signed int i;
  signed int j;
  signed int p;
  if(!(v >= 6))
  {
    tmp = lglbasevar2funtab[(signed long int)v];
    if(!(negate == 0))
      tmp = ~tmp;

    i = 0;
    for( ; !(i >= 64); i = i + 1)
      res[(signed long int)i] = tmp;
  }

  else
  {
    tmp = negate != 0 ? ~0ull : 0ull;
    p = 1 << v - 6;
    j = 0;
    i = 0;
    for( ; !(i >= 64); i = i + 1)
    {
      res[(signed long int)i] = tmp;
      j = j + 1;
      if(j >= p)
      {
        tmp = ~tmp;
        j = 0;
      }

    }
  }
}

// lglversion
// file lglbnr.c line 52
const char * lglversion(void)
{
  return "ala b02aa1a04343558c4252b5f4a723be021964f652";
}

// lglvmtf
// file lglib.c line 5915
static void lglvmtf(struct LGL *lgl, signed int lit)
{
  signed int oldprior;
  signed int newprior;
  signed int inc;
  struct Qln *src;
  struct Qln *dst;
  struct Qln *l;
  struct Qnd *node;
  lit=abs(lit);
  src=lglqln(lgl, lit);
  oldprior = src->prior;
  inc = lgl->opts->queueinc.val;
  newprior = oldprior + inc;
  if(!(lgl->stats->queue.max >= newprior))
  {
    lgl->stats->queue.max = newprior;
    lglprt(lgl, 2, "[queue] maximum priority %d", newprior);
  }

  dst = src->up;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(dst == ((struct Qln *)NULL)))
      tmp_if_expr$1 = dst->prior < newprior ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    dst = dst->up;
  }
  while((_Bool)1);
  _Bool tmp_if_expr$3;
  if(dst == ((struct Qln *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = newprior < dst->prior ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
  {
    l = lgl->queue.free;
    if(!(l == ((struct Qln *)NULL)))
    {
      lgl->queue.free = l->up;
      do
        memset((void *)l, 0, sizeof(struct Qln) /*40ul*/ );
      while((_Bool)0);
    }

    else
      do
      {
        void *return_value_lglnew$2;
        return_value_lglnew$2=lglnew(lgl, (unsigned long int)1 * sizeof(struct Qln) /*40ul*/ );
        l = (struct Qln *)return_value_lglnew$2;
      }
      while((_Bool)0);

  __CPROVER_DUMP_L10:
    ;
    lgl->stats->queue.new = lgl->stats->queue.new + 1l;
    lgl->queue.nlines = lgl->queue.nlines + 1;
    l->prior = newprior;
    l->repr = l;
    if(!(dst == ((struct Qln *)NULL)))
    {
      if(!(dst->down == ((struct Qln *)NULL)))
        dst->down->up = l;

      else
        lgl->queue.bottom = l;
      l->down = dst->down;
      l->up = dst;
      dst->down = l;
    }

    else
    {
      lgl->queue.top->up = l;
      l->down = lgl->queue.top;
      lgl->queue.top = l;
    }
    dst = l;
  }


__CPROVER_DUMP_L15:
  ;
  node=lglqnd(lgl, lit);
  struct Qnd *return_value_lglqnd$4;
  if(!(node->prev == 0))
  {
    return_value_lglqnd$4=lglqnd(lgl, node->prev);
    return_value_lglqnd$4->next = node->next;
  }

  else
    src->first = node->next;
  struct Qnd *return_value_lglqnd$5;
  if(!(node->next == 0))
  {
    return_value_lglqnd$5=lglqnd(lgl, node->next);
    return_value_lglqnd$5->prev = node->prev;
  }

  else
    src->last = node->prev;
  if(src->unassigned == lit)
    src->unassigned = node->next;


__CPROVER_DUMP_L20:
  ;
  struct Qnd *return_value_lglqnd$6;
  if(!(dst->last == 0))
  {
    return_value_lglqnd$6=lglqnd(lgl, dst->last);
    return_value_lglqnd$6->next = lit;
  }

  else
    dst->first = lit;
  node->prev = dst->last;
  node->next = 0;
  node->line = dst;
  dst->last = lit;
  signed char return_value_lglval$8;
  return_value_lglval$8=lglval(lgl, lit);
  _Bool tmp_if_expr$7;
  if(return_value_lglval$8 == 0)
  {
    if(lgl->queue.unassigned == ((struct Qln *)NULL))
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = lgl->queue.unassigned->prior < newprior ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
      lgl->queue.unassigned = dst;

  }

  if(dst->unassigned == 0)
    dst->unassigned = lit;

  if(src->first == 0)
  {

  __CPROVER_DUMP_L27:
    ;
    if(!(src->down == ((struct Qln *)NULL)))
      src->down->up = src->up;

    else
      lgl->queue.bottom = src->up;
    if(!(src->up == ((struct Qln *)NULL)))
      src->up->down = src->down;

    else
      lgl->queue.top = src->down;
    if(lgl->queue.unassigned == src)
      lgl->queue.unassigned = src->down;

    lgl->queue.nlines = lgl->queue.nlines - 1;
    lgl->stats->queue.del = lgl->stats->queue.del + 1l;
    src->up = lgl->queue.free;
    lgl->queue.free = src;
  }

  if(lgl->opts->check.val >= 3)
    lglchkqueue(lgl);

}

// lglwchbin
// file lglib.c line 3132
static signed long int lglwchbin(struct LGL *lgl, signed int lit, signed int other, signed int red)
{
  struct HTS *hts;
  hts=lglhts(lgl, lit);
  signed int cs = other << RMSHFT | BINCS | red;
  signed long int res;
  res=lglpushwch(lgl, hts, cs);

__CPROVER_DUMP_L1:
  ;
  return res;
}

// lglwchlrg
// file lglib.c line 3153
static signed long int lglwchlrg(struct LGL *lgl, signed int lit, signed int other, signed int red, signed int lidx)
{
  struct HTS *hts;
  hts=lglhts(lgl, lit);
  signed int blit = other << RMSHFT | LRGCS | red;
  signed long int res = (signed long int)0;
  signed long int return_value_lglpushwch$1;
  return_value_lglpushwch$1=lglpushwch(lgl, hts, blit);
  res = res + return_value_lglpushwch$1;
  signed long int return_value_lglpushwch$2;
  return_value_lglpushwch$2=lglpushwch(lgl, hts, lidx);
  res = res + return_value_lglpushwch$2;
  return res;
}

// lglwchtrn
// file lglib.c line 3142
static signed long int lglwchtrn(struct LGL *lgl, signed int a, signed int b, signed int c, signed int red)
{
  struct HTS *hts;
  hts=lglhts(lgl, a);
  signed int cs = b << RMSHFT | TRNCS | red;
  signed long int res;
  res=lglpushwch(lgl, hts, cs);
  signed long int return_value_lglpushwch$1;
  return_value_lglpushwch$1=lglpushwch(lgl, hts, c);
  res = res + return_value_lglpushwch$1;

__CPROVER_DUMP_L1:
  ;
  return res;
}

// lglwrkcompact
// file lglib.c line 8514
static void lglwrkcompact(struct LGL *lgl)
{
  signed int i;
  signed int j = 0;
  signed int lit;
  signed int tail;
  unsigned long int return_value_lglcntstk$1;
  return_value_lglcntstk$1=lglcntstk(&lgl->wrk->queue);
  tail = (signed int)return_value_lglcntstk$1;
  i = lgl->wrk->head;
  signed int tmp_post$2;
  for( ; !(i >= tail); i = i + 1)
  {
    lit = lgl->wrk->queue.start[(signed long int)i];
    if(!(lit == 0))
    {
      signed int return_value_lglisfree$3;
      return_value_lglisfree$3=lglisfree(lgl, lit);
      if(return_value_lglisfree$3 == 0)
      {
        lgl->wrk->pos[(signed long int)lit] = -1;
        lgl->wrk->count = lgl->wrk->count - 1;
      }

      else
      {
        lgl->wrk->queue.start[(signed long int)j] = lit;
        tmp_post$2 = j;
        j = j + 1;
        lgl->wrk->pos[(signed long int)lit] = tmp_post$2;
      }
    }

  }
  lglrststk(&lgl->wrk->queue, j);
  lgl->wrk->head = 0;
}

// lglwrkdeq
// file lglib.c line 8557
static signed int lglwrkdeq(struct LGL *lgl)
{
  signed int res;
  signed int pos;
  unsigned long int return_value_lglcntstk$1;
  do
  {
    pos = lgl->wrk->head;
    return_value_lglcntstk$1=lglcntstk(&lgl->wrk->queue);
    if((unsigned long int)pos >= return_value_lglcntstk$1)
      break;

    lgl->wrk->head = lgl->wrk->head + 1;
    res = lgl->wrk->queue.start[(signed long int)pos];
    if(!(res == 0))
    {
      lgl->wrk->queue.start[(signed long int)pos] = 0;
      lgl->wrk->count = lgl->wrk->count - 1;
      lgl->wrk->pos[(signed long int)res] = -1;
      signed int return_value_lglisfree$2;
      return_value_lglisfree$2=lglisfree(lgl, res);
      if(!(return_value_lglisfree$2 == 0))
        return res;

    }

  }
  while((_Bool)1);
  return 0;
}

// lglwrkinit
// file lglib.c line 8488
static void lglwrkinit(struct LGL *lgl, signed int posonly, signed int fifo)
{
  signed int size;
  signed int lit;
  do
  {
    void *return_value_lglnew$1;
    return_value_lglnew$1=lglnew(lgl, (unsigned long int)1 * sizeof(struct Wrk) /*56ul*/ );
    lgl->wrk = (struct Wrk *)return_value_lglnew$1;
  }
  while((_Bool)0);
  lgl->wrk->fifo = fifo;
  lgl->wrk->size = lgl->nvars;
  size = lgl->wrk->size;
  if(!(posonly == 0))
  {
    do
    {
      void *return_value_lglnew$2;
      return_value_lglnew$2=lglnew(lgl, (unsigned long int)size * sizeof(signed int) /*4ul*/ );
      lgl->wrk->pos = (signed int *)return_value_lglnew$2;
    }
    while((_Bool)0);
    lgl->wrk->posonly = 1;
  }

  else
  {
    do
    {
      void *return_value_lglnew$3;
      return_value_lglnew$3=lglnew(lgl, (unsigned long int)(2 * size) * sizeof(signed int) /*4ul*/ );
      lgl->wrk->pos = (signed int *)return_value_lglnew$3;
    }
    while((_Bool)0);
    lgl->wrk->pos = lgl->wrk->pos + (signed long int)size;
    lit = -size + 1;
    for( ; !(lit >= -1); lit = lit + 1)
      lgl->wrk->pos[(signed long int)lit] = -1;
  }
  lit = 2;
  for( ; !(lit >= size); lit = lit + 1)
    lgl->wrk->pos[(signed long int)lit] = -1;
}

// lglwrknext
// file lglib.c line 8590
static signed int lglwrknext(struct LGL *lgl)
{
  signed int tmp_if_expr$3;
  signed int return_value_lglwrkdeq$1;
  signed int return_value_lglwrkpop$2;
  if(!(lgl->wrk->fifo == 0))
  {
    return_value_lglwrkdeq$1=lglwrkdeq(lgl);
    tmp_if_expr$3 = return_value_lglwrkdeq$1;
  }

  else
  {
    return_value_lglwrkpop$2=lglwrkpop(lgl);
    tmp_if_expr$3 = return_value_lglwrkpop$2;
  }
  return tmp_if_expr$3;
}

// lglwrkpop
// file lglib.c line 8573
static signed int lglwrkpop(struct LGL *lgl)
{
  signed int res;
  unsigned long int return_value_lglcntstk$1;
  do
  {
    return_value_lglcntstk$1=lglcntstk(&lgl->wrk->queue);
    if((unsigned long int)lgl->wrk->head >= return_value_lglcntstk$1)
      break;

    res=lglpopstk(&lgl->wrk->queue);
    if(!(res == 0))
    {
      lgl->wrk->pos[(signed long int)res] = -1;
      signed int return_value_lglisfree$2;
      return_value_lglisfree$2=lglisfree(lgl, res);
      if(!(return_value_lglisfree$2 == 0))
        return res;

    }

  }
  while((_Bool)1);
  return 0;
}

// lglwrkreset
// file lglib.c line 8504
static void lglwrkreset(struct LGL *lgl)
{
  lglrelstk(lgl, &lgl->wrk->queue);
  if(!(lgl->wrk->posonly == 0))
    do
    {
      lgldel(lgl, (void *)lgl->wrk->pos, (unsigned long int)lgl->wrk->size * sizeof(signed int) /*4ul*/ );
      lgl->wrk->pos = ((signed int *)NULL);
    }
    while((_Bool)0);

  else
  {
    lgl->wrk->pos = lgl->wrk->pos - (signed long int)lgl->wrk->size;
    do
    {
      lgldel(lgl, (void *)lgl->wrk->pos, (unsigned long int)(2 * lgl->wrk->size) * sizeof(signed int) /*4ul*/ );
      lgl->wrk->pos = ((signed int *)NULL);
    }
    while((_Bool)0);
  }
  do
  {
    lgldel(lgl, (void *)lgl->wrk, (unsigned long int)1 * sizeof(struct Wrk) /*56ul*/ );
    lgl->wrk = ((struct Wrk *)NULL);
  }
  while((_Bool)0);
}

// lglwrktouch
// file lglib.c line 8535
static signed int lglwrktouch(struct LGL *lgl, signed int lit)
{
  signed int tail;
  signed int pos;
  signed int return_value_lglisfree$1;
  return_value_lglisfree$1=lglisfree(lgl, lit);
  struct AVar *return_value_lglavar$2;
  struct AVar *return_value_lglavar$3;
  if(return_value_lglisfree$1 == 0)
    return 1;

  else
  {
    if(!(lgl->donotsched == 0))
    {
      if(!(lgl->cgrclosing == 0))
      {
        return_value_lglavar$2=lglavar(lgl, lit);
        if(!(return_value_lglavar$2->donotcgrcls == 0u))
          return 1;

      }

      if(!(lgl->ternresing == 0))
      {
        return_value_lglavar$3=lglavar(lgl, lit);
        if(!(return_value_lglavar$3->donoternres == 0u))
          return 1;

      }

    }

    if(!(lgl->wrk->posonly == 0))
      lit=abs(lit);

    unsigned long int return_value_lglcntstk$4;
    return_value_lglcntstk$4=lglcntstk(&lgl->wrk->queue);
    tail = (signed int)return_value_lglcntstk$4;

  __CPROVER_DUMP_L6:
    ;
    pos = lgl->wrk->pos[(signed long int)lit];
    if(pos >= 0)
      lgl->wrk->queue.start[(signed long int)pos] = 0;

    lgl->wrk->count = lgl->wrk->count + 1;
    lgl->wrk->pos[(signed long int)lit] = tail;
    lglpushstk(lgl, &lgl->wrk->queue, lit);
    if(!(lgl->wrk->count >= tail / 2))
      lglwrkcompact(lgl);

    return 1;
  }
}

// lglwrn
// file lglib.c line 1150
static void lglwrn(struct LGL *lgl, const char *msg, ...)
{
  void **ap;
  fprintf(lgl->out, "*** warning in '%s': ", (const void *)"lglib.c");
  ap = (void **)&msg;
  vfprintf(lgl->out, msg, ap);
  ap = ((void **)NULL);
  fputc(10, lgl->out);
  fflush(lgl->out);
}

// lglws
// file lglib.c line 2199
static signed int lglws(signed int ch)
{
  return (signed int)(ch == 32 || ch == 9 || ch == 10 || ch == 13);
}

// lglwtrapi
// file lglib.c line 1506
void lglwtrapi(struct LGL *lgl, struct _IO_FILE *apitrace)
{

__CPROVER_DUMP_L1:
  ;
  do
  {
    if(lgl == ((struct LGL *)NULL))
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglwtrapi");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "uninitialized manager");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
    }

    while((UNUSED & (signed int)lgl->state) == 0)
    {
      fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglwtrapi");
      if(!(lgl == ((struct LGL *)NULL)))
      {
        if(lgl->tid >= 0)
          fprintf(stderr, " (tid %d)", lgl->tid);

      }

      fputs(": ", stderr);
      fprintf(stderr, "!(%s)", (const void *)"UNUSED");
      fputc(10, stderr);
      fflush(stderr);
      lglabort(lgl);
      exit(1);
      break;
    }
  }
  while((_Bool)0);
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    fprintf(stderr, "*** API usage error of '%s' in '%s'", (const void *)"lglib.c", (const void *)"lglwtrapi");
    if(!(lgl == ((struct LGL *)NULL)))
    {
      if(lgl->tid >= 0)
        fprintf(stderr, " (tid %d)", lgl->tid);

    }

    fputs(": ", stderr);
    fprintf(stderr, "can only write one API trace");
    fputc(10, stderr);
    fflush(stderr);
    lglabort(lgl);
    exit(1);
    break;
  }
  lgl->apitrace = apitrace;
  while(!(lgl->apitrace == ((struct _IO_FILE *)NULL)))
  {
    lgltrapi(lgl, "init");
    break;
  }
}

// lglxorhascls
// file lglib.c line 12718
static signed int lglxorhascls(struct LGL *lgl)
{
  signed int lit;
  signed int res;
  signed int minlit = 0;
  signed int minoccs = 0x7fffffff;
  signed int litoccs;
  signed int blit;
  signed int tag;
  signed int lidx;
  const signed int *p;
  const signed int *w;
  const signed int *eow;
  const signed int *l;
  const signed int *c;
  struct HTS *hts;
  p = lgl->clause.start;
  for( ; !(p >= lgl->clause.top); p = p + 1l)
  {
    lit = *p;
    litoccs=lglocc(lgl, lit);
    if(!(litoccs >= minoccs))
    {
      minlit = lit;
      minoccs = litoccs;
    }

    lglsignedmark(lgl, lit);
  }
  res = 0;
  hts=lglhts(lgl, minlit);
  w=lglhts2wchs(lgl, hts);
  eow = w + (signed long int)hts->count;
  p = w;
  signed int return_value_lglsignedmarked$3;
  for( ; res == 0 && !(p >= eow); p = p + 1l)
  {
    blit = *p;
    signed int return_value_lglincextractlimhit$1;
    return_value_lglincextractlimhit$1=lglincextractlimhit(lgl);
    if(!(return_value_lglincextractlimhit$1 == 0))
      break;

    tag = blit & MASKCS;
    if(tag == TRNCS || tag == LRGCS)
      p = p + 1l;

    if(tag == OCCS)
    {
      lidx = blit >> RMSHFT;
      signed int return_value_lglincextractlimhit$2;
      return_value_lglincextractlimhit$2=lglincextractlimhit(lgl);
      if(!(return_value_lglincextractlimhit$2 == 0))
        break;

      c=lglidx2lits(lgl, OCCS, blit & REDCS, lidx);
      l = c;
      do
      {
        lit = *l;
        if(lit == 0)
          break;

        return_value_lglsignedmarked$3=lglsignedmarked(lgl, lit);
        if(return_value_lglsignedmarked$3 == 0)
          break;

        l = l + 1l;
      }
      while((_Bool)1);
      if(lit == 0)
        res = 1;

    }

  }
  p = lgl->clause.start;
  for( ; !(p >= lgl->clause.top); p = p + 1l)
    lglunmark(lgl, *p);
  return res;
}

// main
// file ilingeling.c line 758
signed int main(signed int argc, char **argv)
{
  const char *statsfilename = ((const char *)NULL);
  const char *histfilename = ((const char *)NULL);
  signed int i;
  signed int closeinputfile;
  signed int res = 0;
  struct Worker *winner;
  struct Worker *w;
  startime=currentime();
  i = 1;
  signed int tmp_statement_expression$20;
  signed int tmp_statement_expression$18;
  signed int tmp_statement_expression$16;
  signed int tmp_statement_expression$14;
  signed int tmp_statement_expression$12;
  signed int tmp_statement_expression$10;
  signed int tmp_statement_expression$8;
  signed int tmp_statement_expression$6;
  signed int tmp_statement_expression$4;
  signed int tmp_statement_expression$2;
  signed int return_value_isnum$1;
  for( ; !(i >= argc); i = i + 1)
  {
    unsigned long int main$$1$$1$$1$$1$$__s1_len;
    unsigned long int main$$1$$1$$1$$1$$__s2_len;
    signed int return_value___builtin_strcmp$21;
    return_value___builtin_strcmp$21=__builtin_strcmp(argv[(signed long int)i], "-h");
    tmp_statement_expression$20 = return_value___builtin_strcmp$21;
    if(tmp_statement_expression$20 == 0)
    {
      printf("usage: ilingeling [<option> ...][<inccnf>][<nworkers>]\n\nwhere <option> is one of the following:\n\n  -h  print this command line option summary\n\n  -v  increase verbose level\n  -q  do not print 'c job ...' lines (requires verbosity < 2)\n  -b  progress bar (implies '-q')\n\n  -s  <stats> output statistics to separate file\n  -t  <hist> output job run time histogram to separate file\n\n  --no-fork         disabling forking after %d conflicts\n  --no-brute-fork   do not brute-fork after additional %d conflicts\n\n  -a  add previous assumptions as don't care\n\n  <inccnf>    'p inccnf' + '<lit*> 0' clauses + 'a <lit>* 0' assumptions\n  <nworkers>  number of workers defaults to 1\n", 20000, 100000);
      exit(0);
    }

    else
    {
      unsigned long int main$$1$$1$$1$$3$$__s1_len;
      unsigned long int main$$1$$1$$1$$3$$__s2_len;
      signed int return_value___builtin_strcmp$19;
      return_value___builtin_strcmp$19=__builtin_strcmp(argv[(signed long int)i], "-v");
      tmp_statement_expression$18 = return_value___builtin_strcmp$19;
      if(tmp_statement_expression$18 == 0)
        verbose = verbose + 1;

      else
      {
        unsigned long int main$$1$$1$$1$$4$$__s1_len;
        unsigned long int main$$1$$1$$1$$4$$__s2_len;
        signed int return_value___builtin_strcmp$17;
        return_value___builtin_strcmp$17=__builtin_strcmp(argv[(signed long int)i], "-b");
        tmp_statement_expression$16 = return_value___builtin_strcmp$17;
        if(tmp_statement_expression$16 == 0)
          bar = 1;

        else
        {
          unsigned long int main$$1$$1$$1$$5$$__s1_len;
          unsigned long int main$$1$$1$$1$$5$$__s2_len;
          signed int return_value___builtin_strcmp$15;
          return_value___builtin_strcmp$15=__builtin_strcmp(argv[(signed long int)i], "-n");
          tmp_statement_expression$14 = return_value___builtin_strcmp$15;
          if(tmp_statement_expression$14 == 0)
            nowitness = 1;

          else
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp$13;
            return_value___builtin_strcmp$13=__builtin_strcmp(argv[(signed long int)i], "-a");
            tmp_statement_expression$12 = return_value___builtin_strcmp$13;
            if(tmp_statement_expression$12 == 0)
              addassumptions = 1;

            else
            {
              unsigned long int main$$1$$1$$1$$7$$__s1_len;
              unsigned long int main$$1$$1$$1$$7$$__s2_len;
              signed int return_value___builtin_strcmp$11;
              return_value___builtin_strcmp$11=__builtin_strcmp(argv[(signed long int)i], "-p");
              tmp_statement_expression$10 = return_value___builtin_strcmp$11;
              if(tmp_statement_expression$10 == 0)
                plain = 1;

              else
              {
                unsigned long int main$$1$$1$$1$$8$$__s1_len;
                unsigned long int main$$1$$1$$1$$8$$__s2_len;
                signed int return_value___builtin_strcmp$9;
                return_value___builtin_strcmp$9=__builtin_strcmp(argv[(signed long int)i], "-s");
                tmp_statement_expression$8 = return_value___builtin_strcmp$9;
                if(tmp_statement_expression$8 == 0)
                {
                  if(!(statsfilename == ((const char *)NULL)))
                    die("two '-s' options");

                  i = i + 1;
                  if(i == argc)
                    die("argument to '-s' missing");

                  statsfilename = argv[(signed long int)i];
                }

                else
                {
                  unsigned long int main$$1$$1$$1$$10$$__s1_len;
                  unsigned long int main$$1$$1$$1$$10$$__s2_len;
                  signed int return_value___builtin_strcmp$7;
                  return_value___builtin_strcmp$7=__builtin_strcmp(argv[(signed long int)i], "-t");
                  tmp_statement_expression$6 = return_value___builtin_strcmp$7;
                  if(tmp_statement_expression$6 == 0)
                  {
                    if(!(histfilename == ((const char *)NULL)))
                      die("two '-t' options");

                    i = i + 1;
                    if(i == argc)
                      die("argument to '-t' missing");

                    histfilename = argv[(signed long int)i];
                  }

                  else
                  {
                    unsigned long int main$$1$$1$$1$$12$$__s1_len;
                    unsigned long int main$$1$$1$$1$$12$$__s2_len;
                    signed int return_value___builtin_strcmp$5;
                    return_value___builtin_strcmp$5=__builtin_strcmp(argv[(signed long int)i], "--no-fork");
                    tmp_statement_expression$4 = return_value___builtin_strcmp$5;
                    if(tmp_statement_expression$4 == 0)
                      dofork = 0;

                    else
                    {
                      unsigned long int main$$1$$1$$1$$13$$__s1_len;
                      unsigned long int main$$1$$1$$1$$13$$__s2_len;
                      signed int return_value___builtin_strcmp$3;
                      return_value___builtin_strcmp$3=__builtin_strcmp(argv[(signed long int)i], "--no-brute-fork");
                      tmp_statement_expression$2 = return_value___builtin_strcmp$3;
                      if(tmp_statement_expression$2 == 0)
                        dofork = dofork != 0 ? 1 : 0;

                      else
                        if((signed int)*argv[(signed long int)i] == 45)
                          die("invalid option '%s'", argv[(signed long int)i]);

                        else
                        {
                          return_value_isnum$1=isnum(argv[(signed long int)i]);
                          if(!(return_value_isnum$1 == 0))
                          {
                            if(!(nworkers == 0))
                              die("number of workers specified twice: '%d' and '%s'", nworkers, argv[(signed long int)i]);

                            nworkers=atoi(argv[(signed long int)i]);
                            if(!(nworkers >= 1))
                              die("invalid number of workers argument: '%s'", argv[(signed long int)i]);

                          }

                          else
                            if(!(inputname == ((char *)NULL)))
                              die("two files given: '%s' and '%s'", inputname, argv[(signed long int)i]);

                            else
                              inputname = argv[(signed long int)i];
                        }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  signed int return_value_isatty$22;
  if(!(bar == 0))
  {
    return_value_isatty$22=isatty(1);
    if(return_value_isatty$22 == 0)
      die("progress bar requested but <stdout> not connected to terminal");

  }

  if(verbose >= 2 && !(bar == 0))
    die("verbosity %d > 1 with '-b'", verbose);

  if(!(statsfilename == ((const char *)NULL)))
  {
    statsfile=fopen(statsfilename, "w");
    if(statsfile == ((struct _IO_FILE *)NULL))
      die("can not write to stats file '%s'", statsfilename);

  }

  if(!(histfilename == ((const char *)NULL)))
  {
    histfile=fopen(histfilename, "w");
    if(histfile == ((struct _IO_FILE *)NULL))
      die("can not write to job run time histogram file '%s'", histfilename);

  }

  if(statsfile == ((struct _IO_FILE *)NULL) && !(verbose == 0))
    statsfile = stdout;

  if(!(verbose == 0))
  {
    lglbnr("iLingeling Incremental Parallel Lingeling", "c ", stdout);
    printf("c\n");
    fflush(stdout);
  }

  if(nworkers == 0)
    nworkers = 1;

  msg(((struct Worker *)NULL), 1, "using %d workers", nworkers);
  if(!(inputname == ((char *)NULL)))
  {
    inputfile=fopen(inputname, "r");
    if(inputfile == ((struct _IO_FILE *)NULL))
      die("can not read '%s'", inputname);

    closeinputfile = 1;
  }

  else
  {
    inputname = "<stdin>";
    inputfile = stdin;
    closeinputfile = 0;
  }
  init();
  setsighandlers();
  msg(((struct Worker *)NULL), 1, "parsing %s", inputname);
  parse();
  if(!(closeinputfile == 0))
    fclose(inputfile);

  msg(((struct Worker *)NULL), 1, "%d variables out of %d used in assumptions which is %.0f%%", nused, nvars, nvars != 0 ? 100.0 * ((double)nused / (double)nvars) : 0.0);
  freeze();
  start();
  stop();
  winner = ((struct Worker *)NULL);
  w = workers;
  for( ; !(w >= workers + (signed long int)nworkers); w = w + 1l)
    if(!(w->res == 0))
    {
      winner = w;
      if(w->res == 10)
        break;

    }

  signed int return_value_lglderef$24;
  if(!(winner == ((struct Worker *)NULL)))
  {
    res = winner->res;
    if(res == 10)
    {
      if(nowitness == 0)
      {
        do
        {
          unsigned long int BYTES = (unsigned long int)nvars * sizeof(signed char) /*1ul*/ ;
          void *return_value_malloc$23;
          return_value_malloc$23=malloc(BYTES);
          vals = (signed char *)return_value_malloc$23;
          if(vals == ((signed char *)NULL))
          {
            die("out of memory");
            exit(1);
          }

          memset((void *)vals, 0, BYTES);
          do
          {
            allocated = allocated + BYTES;
            if(!(maxallocated >= allocated))
              maxallocated = allocated;

          }
          while((_Bool)0);
        }
        while((_Bool)0);
        i = 1;
        for( ; !(i >= nvars); i = i + 1)
        {
          return_value_lglderef$24=lglderef(winner->lgl, i);
          vals[(signed long int)i] = (signed char)return_value_lglderef$24;
        }
      }

    }

  }

  resetsighandlers();
  if(!(statsfile == ((struct _IO_FILE *)NULL)))
    stats();

  if(!(statsfilename == ((const char *)NULL)))
    fclose(statsfile);

  if(!(histfile == ((struct _IO_FILE *)NULL)))
    hist();

  if(!(histfile == ((struct _IO_FILE *)NULL)))
    fclose(histfile);

  if(res == 10)
    printf("s SATISFIABLE\n");

  else
    if(res == 20)
      printf("s UNSATISFIABLE\n");

    else
      printf("s UNKNOWN\n");
  fflush(stdout);
  if(!(vals == ((signed char *)NULL)))
  {
    i = 1;
    for( ; !(i >= nvars); i = i + 1)
    {
      fputs("v ", stdout);
      if(!((signed int)vals[(signed long int)i] >= 0))
        fputc(45, stdout);

      printf("%d\n", i);
    }
    fputs("v 0\n", stdout);
    fflush(stdout);
  }

  reset();
  return res;
}

// msg
// file ilingeling.c line 133
static void msg(struct Worker *w, signed int level, const char *fmt, ...)
{
  void **ap;
  if(verbose >= level)
  {
    msglock(NULL);
    if(!(w == ((struct Worker *)NULL)))
      printf("c %d ", (signed int)(w - workers));

    else
      printf("c - ");
    ap = (void **)&fmt;
    vprintf(fmt, ap);
    ap = ((void **)NULL);
    fputc(10, stdout);
    fflush(stdout);
    msgunlock(NULL);
  }

}

// msglock
// file ilingeling.c line 123
static void msglock(void *voidptr)
{
  (void)voidptr;
  pthread_mutex_lock(&msgmutex);
}

// msgunlock
// file ilingeling.c line 128
static void msgunlock(void *voidptr)
{
  (void)voidptr;
  pthread_mutex_unlock(&msgmutex);
}

// next
// file ilingeling.c line 464
static signed int next(void)
{
  signed int res;
  res=_IO_getc(inputfile);
  if(res == 10)
    lineno = lineno + 1;

  return res;
}

// parse
// file ilingeling.c line 476
static void parse(void)
{
  signed int ch;
  signed int lit;
  signed int sign;
  signed int *assumption;
  signed int i;
  do
  {

  HEADER:
    ;
    ch=next();
    if(ch == -1)
      perr("unexpected end-of-file in header");

    if(!(ch == 99))
      break;

    do
    {
      ch=next();
      if(ch == 10)
        break;

      if(ch == -1)
        perr("unexpected end-of-file in comment");

    }
    while((_Bool)1);
  }
  while((_Bool)1);
  _Bool tmp_if_expr$2;
  signed int return_value_next$1;
  if(!(ch == 112))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_next$1=next();
    tmp_if_expr$2 = return_value_next$1 != 32 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$4;
  signed int return_value_next$3;
  if(tmp_if_expr$2)
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    return_value_next$3=next();
    tmp_if_expr$4 = return_value_next$3 != 105 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$6;
  signed int return_value_next$5;
  if(tmp_if_expr$4)
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    return_value_next$5=next();
    tmp_if_expr$6 = return_value_next$5 != 110 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$8;
  signed int return_value_next$7;
  if(tmp_if_expr$6)
    tmp_if_expr$8 = (_Bool)1;

  else
  {
    return_value_next$7=next();
    tmp_if_expr$8 = return_value_next$7 != 99 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$10;
  signed int return_value_next$9;
  if(tmp_if_expr$8)
    tmp_if_expr$10 = (_Bool)1;

  else
  {
    return_value_next$9=next();
    tmp_if_expr$10 = return_value_next$9 != 99 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$12;
  signed int return_value_next$11;
  if(tmp_if_expr$10)
    tmp_if_expr$12 = (_Bool)1;

  else
  {
    return_value_next$11=next();
    tmp_if_expr$12 = return_value_next$11 != 110 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$14;
  signed int return_value_next$13;
  if(tmp_if_expr$12)
    tmp_if_expr$14 = (_Bool)1;

  else
  {
    return_value_next$13=next();
    tmp_if_expr$14 = return_value_next$13 != 102 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$14)
    perr("invalid header (expected 'p inccnf')");

  ch=next();

CLAUSES:
  ;
  const unsigned short int **return_value___ctype_b_loc$16;
  const unsigned short int **return_value___ctype_b_loc$17;
  const unsigned short int **return_value___ctype_b_loc$20;
  const unsigned short int **return_value___ctype_b_loc$21;
  signed int tmp_post$23;
  signed int tmp_post$26;
  _Bool tmp_if_expr$28;
  const unsigned short int **return_value___ctype_b_loc$27;
  while((_Bool)1)
  {
    if(ch == 9 || ch == 10 || ch == 13 || ch == 32)
    {
      ch=next();
      goto CLAUSES;
    }

    if(ch == -1 && !(nlits == 0))
      perr("unexpected end-of-file in clause");

    if(ch == 97 && !(nlits == 0))
      perr("unexpected 'a' in clause");

    if(!(ch == 97))
    {
      if(ch == -1)
        goto DONE;

      if(!(ch == 97))
      {
        if(ch == 45)
        {
          sign = -1;
          ch=next();
          const unsigned short int **return_value___ctype_b_loc$15;
          return_value___ctype_b_loc$15=__ctype_b_loc();
          if((2048 & (signed int)(*return_value___ctype_b_loc$15)[(signed long int)ch]) == 0)
            perr("expected digit after '-'");

        }

        else
          sign = 1;
        return_value___ctype_b_loc$16=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$16)[(signed long int)ch]) == 0)
          perr("expected literal");

        lit = ch - 48;
        do
        {
          return_value___ctype_b_loc$17=__ctype_b_loc();
          ch=next();
          if((2048 & (signed int)(*return_value___ctype_b_loc$17)[(signed long int)ch]) == 0)
            break;

          lit = (10 * lit + ch) - 48;
        }
        while((_Bool)1);
        if(!(nvars >= lit))
        {
          if(lit >= szvars)
          {
            signed int oldszvars = szvars;
            szvars = szvars != 0 ? 2 * szvars : 1;
            for( ; lit >= szvars; szvars = szvars * 2)
              ;
            do
            {
              unsigned long int OBYTES = (unsigned long int)oldszvars * sizeof(signed int) /*4ul*/ ;
              unsigned long int NBYTES = (unsigned long int)szvars * sizeof(signed int) /*4ul*/ ;
              do
                allocated = allocated - OBYTES;
              while((_Bool)0);
              void *return_value_realloc$18;
              return_value_realloc$18=realloc((void *)used, NBYTES);
              used = (signed int *)return_value_realloc$18;
              if(used == ((signed int *)NULL))
                die("out of memory");

              do
              {
                allocated = allocated + NBYTES;
                if(!(maxallocated >= allocated))
                  maxallocated = allocated;

              }
              while((_Bool)0);
            }
            while((_Bool)0);
            i = oldszvars;
            for( ; !(i >= szvars); i = i + 1)
              used[(signed long int)i] = -1;
          }

          nvars = lit;
        }

        lit = lit * sign;
        if(!(lit == 0))
          nlits = nlits + 1;

        else
        {
          nlits = 0;
          nclauses = nclauses + 1;
        }
        add(lit);
        goto CLAUSES;
      }

    }


  ASSUMPTIONS:
    ;
    (void)0;
    ch=next();
    if(!(ch == 32))
      perr("expected space after 'a'");

    do
    {

    LITS:
      ;
      ch=next();
      if(ch == 9 || ch == 10 || ch == 13 || ch == 32)
        goto LITS;

      if(ch == -1 && !(nlits == 0))
        perr("unexpected end-of-file in assumptions");

      if(ch == 45)
      {
        sign = -1;
        ch=next();
        const unsigned short int **return_value___ctype_b_loc$19;
        return_value___ctype_b_loc$19=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$19)[(signed long int)ch]) == 0)
          perr("expected digit after '-'");

      }

      else
        sign = 1;
      return_value___ctype_b_loc$20=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$20)[(signed long int)ch]) == 0)
        perr("expected literal");

      lit = ch - 48;
      do
      {
        return_value___ctype_b_loc$21=__ctype_b_loc();
        ch=next();
        if((2048 & (signed int)(*return_value___ctype_b_loc$21)[(signed long int)ch]) == 0)
          break;

        lit = (10 * lit + ch) - 48;
      }
      while((_Bool)1);
      if(!(nvars >= lit))
        perr("assumption %d exceeds maximum variables %d", lit, nvars);

      if(!(used[(signed long int)lit] >= 0))
        nused = nused + 1;

      used[(signed long int)lit] = nassumptions;
      lit = lit * sign;
      if(!(ch == 9) && !(ch == 10) && !(ch == 13) && !(ch == 32))
        perr("expected white space after '%l'", lit);

      if(lit == 0)
        break;

      do
      {
        if(nlits >= szlits)
          do
          {
            unsigned long int oldbytes;
            unsigned long int newbytes;
            oldbytes = (unsigned long int)szlits * sizeof(signed int) /*4ul*/ ;
            do
              allocated = allocated - oldbytes;
            while((_Bool)0);
            szlits = szlits != 0 ? 2 * szlits : 1;
            newbytes = (unsigned long int)szlits * sizeof(signed int) /*4ul*/ ;
            void *return_value_realloc$22;
            return_value_realloc$22=realloc((void *)lits, newbytes);
            lits = (signed int *)return_value_realloc$22;
            if(lits == ((signed int *)NULL))
              die("out of memory");

            do
            {
              allocated = allocated + newbytes;
              if(!(maxallocated >= allocated))
                maxallocated = allocated;

            }
            while((_Bool)0);
          }
          while((_Bool)0);

        tmp_post$23 = nlits;
        nlits = nlits + 1;
        lits[(signed long int)tmp_post$23] = lit;
      }
      while((_Bool)0);
    }
    while((_Bool)1);
    do
    {
      unsigned long int BYTES = (unsigned long int)(nlits + 1) * sizeof(signed int) /*4ul*/ ;
      void *return_value_malloc$24;
      return_value_malloc$24=malloc(BYTES);
      assumption = (signed int *)return_value_malloc$24;
      if(assumption == ((signed int *)NULL))
      {
        die("out of memory");
        exit(1);
      }

      memset((void *)assumption, 0, BYTES);
      do
      {
        allocated = allocated + BYTES;
        if(!(maxallocated >= allocated))
          maxallocated = allocated;

      }
      while((_Bool)0);
    }
    while((_Bool)0);
    i = 0;
    for( ; !(i >= nlits); i = i + 1)
      assumption[(signed long int)i] = lits[(signed long int)i];
    do
    {
      if(nassumptions >= szassumptions)
        do
        {
          unsigned long int parse$$1$$9$$1$$oldbytes;
          unsigned long int parse$$1$$9$$1$$newbytes;
          parse$$1$$9$$1$$oldbytes = (unsigned long int)szassumptions * sizeof(signed int *) /*8ul*/ ;
          do
            allocated = allocated - parse$$1$$9$$1$$oldbytes;
          while((_Bool)0);
          szassumptions = szassumptions != 0 ? 2 * szassumptions : 1;
          parse$$1$$9$$1$$newbytes = (unsigned long int)szassumptions * sizeof(signed int *) /*8ul*/ ;
          void *return_value_realloc$25;
          return_value_realloc$25=realloc((void *)assumptions, parse$$1$$9$$1$$newbytes);
          assumptions = (signed int **)return_value_realloc$25;
          if(assumptions == ((signed int **)NULL))
            die("out of memory");

          do
          {
            allocated = allocated + parse$$1$$9$$1$$newbytes;
            if(!(maxallocated >= allocated))
              maxallocated = allocated;

          }
          while((_Bool)0);
        }
        while((_Bool)0);

      tmp_post$26 = nassumptions;
      nassumptions = nassumptions + 1;
      assumptions[(signed long int)tmp_post$26] = assumption;
    }
    while((_Bool)0);
    nlits = 0;
    do
    {

    NEXT:
      ;
      ch=next();
    }
    while(ch == 9 || ch == 10 || ch == 13 || ch == 32);
    if(ch == -1)
      goto DONE;

    if(ch == 45)
      tmp_if_expr$28 = (_Bool)1;

    else
    {
      return_value___ctype_b_loc$27=__ctype_b_loc();
      tmp_if_expr$28 = ((signed int)(*return_value___ctype_b_loc$27)[(signed long int)(signed int)ch] & (signed int)(unsigned short int)2048) != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$28)
      break;

  }
  if(!(ch == 97))
    perr("expected literal, 'a' or end-of-file");

  goto ASSUMPTIONS;

DONE:
  ;
  msg(((struct Worker *)NULL), 1, "maximum variable %d in %d clauses", nvars, nclauses);
  msg(((struct Worker *)NULL), 1, "parsed %d assumptions", nassumptions);
  nvars = nvars + 1;
  do
  {
    unsigned long int parse$$1$$10$$BYTES = (unsigned long int)nassumptions * sizeof(double) /*8ul*/ ;
    void *return_value_malloc$29;
    return_value_malloc$29=malloc(parse$$1$$10$$BYTES);
    times = (double *)return_value_malloc$29;
    if(times == ((double *)NULL))
    {
      die("out of memory");
      exit(1);
    }

    memset((void *)times, 0, parse$$1$$10$$BYTES);
    do
    {
      allocated = allocated + parse$$1$$10$$BYTES;
      if(!(maxallocated >= allocated))
        maxallocated = allocated;

    }
    while((_Bool)0);
  }
  while((_Bool)0);
  i = 0;
  for( ; !(i >= nassumptions); i = i + 1)
    times[(signed long int)i] = (double)-1;
}

// perr
// file ilingeling.c line 454
static void perr(const char *fmt, ...)
{
  void **ap;
  fprintf(stderr, "%s:%d: ", inputname, lineno);
  ap = (void **)&fmt;
  vfprintf(stderr, fmt, ap);
  fputc(10, stderr);
  fflush(stderr);
  exit(1);
}

// progress
// file ilingeling.c line 196
static void progress(signed int pmille, signed int total, signed int max, double avg, signed int nl)
{
  signed int ch;
  signed int i;
  signed int lim;
  signed int eta;
  char fmt[10l];
  double rem;
  msglock(NULL);
  signed int return_value_isatty$1;
  return_value_isatty$1=isatty(1);
  if(!(return_value_isatty$1 == 0))
    fputc(13, stdout);

  lim = 10;
  i = 1;
  for( ; !(i >= 11) && !(lim >= max); i = i + 1)
    lim = lim * 10;
  sprintf(fmt, "c %%0%dd", i);
  printf(fmt, total);
  printf(" / %d |", max);
  i = 0;
  for( ; !(i >= pmille / 50); i = i + 1)
    fputc(61, stdout);
  if(total == max)
    ch = 61;

  else
    switch(pmille % 4)
    {
      case 1:
      {
        ch = 92;
        break;
      }
      case 2:
      {
        ch = 124;
        break;
      }
      case 3:
      {
        ch = 47;
        break;
      }
      default:
        ch = 45;
    }
  signed int tmp_post$2 = i;
  i = i + 1;
  if(!(tmp_post$2 >= 20))
    fputc(ch, stdout);

  signed int tmp_post$3;
  do
  {
    tmp_post$3 = i;
    i = i + 1;
    if(tmp_post$3 >= 20)
      break;

    fputc(45, stdout);
  }
  while((_Bool)1);
  printf("| %3d%%", pmille / 10);
  printf(" %.4f sec/cube", avg);
  if(total >= max)
    eta = 0;

  else
  {
    rem = (double)(max - total) * avg;
    if(rem >= 3.600000e+5)
      eta = 0x7fffffff;

    else
      eta = (signed int)rem;
  }
  if(!(eta >= 0x7fffffff))
  {
    if(eta >= 3601)
    {
      printf("%02d:", eta / 3600);
      eta = eta % 3600;
    }

    else
      printf("   ");
    printf("%02d:%02d ETS", eta / 60, eta % 60);
  }

  else
    printf("   --:-- ETS");
  _Bool tmp_if_expr$5;
  signed int return_value_isatty$4;
  if(!(nl == 0))
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_isatty$4=isatty(1);
    tmp_if_expr$5 = !(return_value_isatty$4 != 0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
    fputc(10, stdout);

  fflush(stdout);
  msgunlock(NULL);
}

// reset
// file ilingeling.c line 436
static void reset(void)
{
  signed int i;
  signed int *p;
  signed int *a;
  if(!(vals == ((signed char *)NULL)))
    do
    {
      unsigned long int reset$$1$$1$$BYTES = (unsigned long int)nvars * sizeof(signed char) /*1ul*/ ;
      do
        allocated = allocated - reset$$1$$1$$BYTES;
      while((_Bool)0);
      free((void *)vals);
      vals = ((signed char *)NULL);
    }
    while((_Bool)0);

  i = 0;
  for( ; !(i >= nworkers); i = i + 1)
    lglrelease((workers + (signed long int)i)->lgl);
  do
  {
    unsigned long int reset$$1$$3$$BYTES = (unsigned long int)nworkers * sizeof(struct Worker) /*104ul*/ ;
    do
      allocated = allocated - reset$$1$$3$$BYTES;
    while((_Bool)0);
    free((void *)workers);
    workers = ((struct Worker *)NULL);
  }
  while((_Bool)0);
  i = 0;
  for( ; !(i >= nassumptions); i = i + 1)
  {
    a = assumptions[(signed long int)i];
    p = a;
    for( ; !(*p == 0); p = p + 1l)
      ;
    do
    {
      unsigned long int reset$$1$$4$$1$$2$$BYTES = (unsigned long int)((p - a) + (signed long int)1) * sizeof(signed int) /*4ul*/ ;
      do
        allocated = allocated - reset$$1$$4$$1$$2$$BYTES;
      while((_Bool)0);
      free((void *)a);
      a = ((signed int *)NULL);
    }
    while((_Bool)0);
  }
  do
  {
    unsigned long int reset$$1$$5$$BYTES = (unsigned long int)szassumptions * sizeof(signed int *) /*8ul*/ ;
    do
      allocated = allocated - reset$$1$$5$$BYTES;
    while((_Bool)0);
    free((void *)assumptions);
    assumptions = ((signed int **)NULL);
  }
  while((_Bool)0);
  do
  {
    unsigned long int reset$$1$$6$$BYTES = (unsigned long int)nassumptions * sizeof(double) /*8ul*/ ;
    do
      allocated = allocated - reset$$1$$6$$BYTES;
    while((_Bool)0);
    free((void *)times);
    times = ((double *)NULL);
  }
  while((_Bool)0);
  do
  {
    unsigned long int reset$$1$$7$$BYTES = (unsigned long int)szlits * sizeof(signed int) /*4ul*/ ;
    do
      allocated = allocated - reset$$1$$7$$BYTES;
    while((_Bool)0);
    free((void *)lits);
    lits = ((signed int *)NULL);
  }
  while((_Bool)0);
  do
  {
    unsigned long int BYTES = (unsigned long int)szvars * sizeof(signed int) /*4ul*/ ;
    do
      allocated = allocated - BYTES;
    while((_Bool)0);
    free((void *)used);
    used = ((signed int *)NULL);
  }
  while((_Bool)0);
  if(!(allocated == 0ul))
    warn("internal memory leak of %lld bytes", (signed long long int)allocated);

}

// resetsighandlers
// file ilingeling.c line 724
static void resetsighandlers(void)
{
  signal(2, sig_int_handler);
  signal(11, sig_segv_handler);
  signal(6, sig_abrt_handler);
  signal(15, sig_term_handler);
}

// sat
// file ilingeling.c line 263
static signed int sat(struct Worker *w)
{
  signed int res;
  char name[100l];
  struct LGL *forked;
  if(dofork >= 1)
    lglsetopt(w->lgl, "clim", 20000);

  res=lglsat(w->lgl);
  signed int return_value_justreturn$18;
  signed int tmp_post$1;
  signed int return_value_justreturn$17;
  signed int tmp_post$9;
  if(res == 0)
  {
    return_value_justreturn$18=justreturn(w);
    if(return_value_justreturn$18 == 0)
    {
      msg(w, 1, "forking after %d conflicts", 20000);
      forked=lglfork(w->lgl, 0);
      initlgl(forked, w, 0);
      if(dofork >= 2)
        lglsetopt(forked, "clim", 100000);

      tmp_post$1 = w->forked.count;
      w->forked.count = w->forked.count + 1;
      sprintf(name, "c F%d ", tmp_post$1);
      lglsetprefix(forked, name);
      signed int return_value_pthread_mutex_lock$2;
      return_value_pthread_mutex_lock$2=pthread_mutex_lock(&w->forked.lock);
      if(!(return_value_pthread_mutex_lock$2 == 0))
        warn("worker %d failed to lock 'forked' mutex", (signed int)(w - workers));

      w->forked.lgl = forked;
      signed int return_value_pthread_mutex_unlock$3;
      return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&w->forked.lock);
      if(!(return_value_pthread_mutex_unlock$3 == 0))
        warn("worker %d failed to unlock 'forked' mutex", (signed int)(w - workers));

      lglsat(forked);
      signed int return_value_pthread_mutex_lock$4;
      return_value_pthread_mutex_lock$4=pthread_mutex_lock(&w->forked.lock);
      if(!(return_value_pthread_mutex_lock$4 == 0))
        warn("worker %d failed to lock 'forked' mutex", (signed int)(w - workers));

      w->forked.lgl = ((struct LGL *)NULL);
      signed long int return_value_lglgetdecs$5;
      return_value_lglgetdecs$5=lglgetdecs(forked);
      w->forked.decs = w->forked.decs + return_value_lglgetdecs$5;
      signed long int return_value_lglgetconfs$6;
      return_value_lglgetconfs$6=lglgetconfs(forked);
      w->forked.confs = w->forked.confs + return_value_lglgetconfs$6;
      signed long int return_value_lglgetprops$7;
      return_value_lglgetprops$7=lglgetprops(forked);
      w->forked.props = w->forked.props + return_value_lglgetprops$7;
      signed int return_value_pthread_mutex_unlock$8;
      return_value_pthread_mutex_unlock$8=pthread_mutex_unlock(&w->forked.lock);
      if(!(return_value_pthread_mutex_unlock$8 == 0))
        warn("worker %d failed to unlock 'forked' mutex", (signed int)(w - workers));

      if(!(statsfile == ((struct _IO_FILE *)NULL)))
      {
        lglsetout(forked, statsfile);
        lglstats(forked);
        lglsetout(forked, stdout);
      }

      msg(w, 1, "joining forked solver");
      res=lgljoin(w->lgl, forked);
      if(res == 0)
      {
        return_value_justreturn$17=justreturn(w);
        if(return_value_justreturn$17 == 0)
        {
          msg(w, 1, "brute forking after %d conflicts", 100000);
          forked=lglbrutefork(w->lgl, 0);
          lglsetid(forked, (signed int)(w - workers), nworkers);
          initlgl(forked, w, 0);
          tmp_post$9 = w->forked.bcount;
          w->forked.bcount = w->forked.bcount + 1;
          sprintf(name, "c B%d ", tmp_post$9);
          lglsetprefix(forked, name);
          signed int return_value_pthread_mutex_lock$10;
          return_value_pthread_mutex_lock$10=pthread_mutex_lock(&w->forked.lock);
          if(!(return_value_pthread_mutex_lock$10 == 0))
            warn("worker %d failed to lock '(brute) forked' mutex", (signed int)(w - workers));

          w->forked.lgl = forked;
          signed int return_value_pthread_mutex_unlock$11;
          return_value_pthread_mutex_unlock$11=pthread_mutex_unlock(&w->forked.lock);
          if(!(return_value_pthread_mutex_unlock$11 == 0))
            warn("worker %d failed to unlock '(brute) forked' mutex", (signed int)(w - workers));

          lglsat(forked);
          signed int return_value_pthread_mutex_lock$12;
          return_value_pthread_mutex_lock$12=pthread_mutex_lock(&w->forked.lock);
          if(!(return_value_pthread_mutex_lock$12 == 0))
            warn("worker %d failed to lock '(brute) forked' mutex", (signed int)(w - workers));

          w->forked.lgl = ((struct LGL *)NULL);
          signed long int return_value_lglgetdecs$13;
          return_value_lglgetdecs$13=lglgetdecs(forked);
          w->forked.decs = w->forked.decs + return_value_lglgetdecs$13;
          signed long int return_value_lglgetconfs$14;
          return_value_lglgetconfs$14=lglgetconfs(forked);
          w->forked.confs = w->forked.confs + return_value_lglgetconfs$14;
          signed long int return_value_lglgetprops$15;
          return_value_lglgetprops$15=lglgetprops(forked);
          w->forked.props = w->forked.props + return_value_lglgetprops$15;
          signed int return_value_pthread_mutex_unlock$16;
          return_value_pthread_mutex_unlock$16=pthread_mutex_unlock(&w->forked.lock);
          if(!(return_value_pthread_mutex_unlock$16 == 0))
            warn("worker %d failed to unlock '(brute) forked' mutex", (signed int)(w - workers));

          if(!(statsfile == ((struct _IO_FILE *)NULL)))
          {
            lglsetout(forked, statsfile);
            lglstats(forked);
            lglsetout(forked, stdout);
          }

          msg(w, 1, "joining brute forked solver");
          res=lgljoin(w->lgl, forked);
        }

      }

    }

  }

  return res;
}

// setsighandlers
// file ilingeling.c line 751
static void setsighandlers(void)
{
  sig_int_handler=signal(2, catchsig);
  sig_segv_handler=signal(11, catchsig);
  sig_abrt_handler=signal(6, catchsig);
  sig_term_handler=signal(15, catchsig);
}

// start
// file ilingeling.c line 587
static void start(void)
{
  struct Worker *w = workers;
  for( ; !(w >= workers + (signed long int)nworkers); w = w + 1l)
  {
    signed int return_value_pthread_create$1;
    return_value_pthread_create$1=pthread_create(&w->thread, ((const union pthread_attr_t *)NULL), work, (void *)w);
    if(!(return_value_pthread_create$1 == 0))
      die("failed to create worker thread %d", (signed int)(w - workers));

  }
}

// stats
// file ilingeling.c line 627
static void stats(void)
{
  signed long int decs = (signed long int)0;
  signed long int confs = (signed long int)0;
  signed long int props = (signed long int)0;
  double mb = (double)maxallocated / (double)(1 << 20);
  double wct;
  wct=getime();
  double prt;
  prt=lglprocesstime();
  struct _IO_FILE *file = statsfile != ((struct _IO_FILE *)NULL) ? statsfile : stdout;
  double sum;
  double t;
  double min;
  double max;
  double avg;
  double std;
  signed int i;
  signed int n;
  i = 0;
  for( ; !(i >= nworkers); i = i + 1)
    lglflushtimers((workers + (signed long int)i)->lgl);
  i = 0;
  for( ; !(i >= nworkers); i = i + 1)
  {
    lglflushtimers((workers + (signed long int)i)->lgl);
    fprintf(file, "c\n");
    fprintf(file, "c ---------[worker %d stats]------------------\n", i);
    fprintf(file, "c\n");
    lglsetout((workers + (signed long int)i)->lgl, file);
    lglstats((workers + (signed long int)i)->lgl);
    lglsetout((workers + (signed long int)i)->lgl, stdout);
    double return_value_lglmb$1;
    return_value_lglmb$1=lglmb((workers + (signed long int)i)->lgl);
    mb = mb + return_value_lglmb$1;
    signed long int return_value_lglgetdecs$2;
    return_value_lglgetdecs$2=lglgetdecs((workers + (signed long int)i)->lgl);
    decs = decs + return_value_lglgetdecs$2;
    signed long int return_value_lglgetconfs$3;
    return_value_lglgetconfs$3=lglgetconfs((workers + (signed long int)i)->lgl);
    confs = confs + return_value_lglgetconfs$3;
    signed long int return_value_lglgetprops$4;
    return_value_lglgetprops$4=lglgetprops((workers + (signed long int)i)->lgl);
    props = props + return_value_lglgetprops$4;
    signed int return_value_pthread_mutex_lock$5;
    return_value_pthread_mutex_lock$5=pthread_mutex_lock(&(workers + (signed long int)i)->forked.lock);
    if(!(return_value_pthread_mutex_lock$5 == 0))
      warn("worker failed to lock 'forked' mutex");

    if(!((workers + (signed long int)i)->forked.lgl == ((struct LGL *)NULL)))
    {
      fprintf(file, "c ---------[forked worker %d dstats]----------\n", i);
      fprintf(file, "c\n");
      lglsetout((workers + (signed long int)i)->forked.lgl, file);
      lglstats((workers + (signed long int)i)->forked.lgl);
      lglsetout((workers + (signed long int)i)->forked.lgl, stdout);
      double return_value_lglmb$6;
      return_value_lglmb$6=lglmb((workers + (signed long int)i)->forked.lgl);
      mb = mb + return_value_lglmb$6;
      signed long int return_value_lglgetdecs$7;
      return_value_lglgetdecs$7=lglgetdecs((workers + (signed long int)i)->forked.lgl);
      decs = decs + return_value_lglgetdecs$7;
      signed long int return_value_lglgetconfs$8;
      return_value_lglgetconfs$8=lglgetconfs((workers + (signed long int)i)->forked.lgl);
      confs = confs + return_value_lglgetconfs$8;
      signed long int return_value_lglgetprops$9;
      return_value_lglgetprops$9=lglgetprops((workers + (signed long int)i)->forked.lgl);
      props = props + return_value_lglgetprops$9;
    }

    decs = decs + (workers + (signed long int)i)->forked.decs;
    confs = confs + (workers + (signed long int)i)->forked.confs;
    props = props + (workers + (signed long int)i)->forked.props;
    signed int return_value_pthread_mutex_unlock$10;
    return_value_pthread_mutex_unlock$10=pthread_mutex_unlock(&(workers + (signed long int)i)->forked.lock);
    if(!(return_value_pthread_mutex_unlock$10 == 0))
      warn("worker failed to lock 'forked' mutex");

  }
  fprintf(file, "c\n");
  fprintf(file, "c ---------[global-stats]-------------------------\n");
  fprintf(file, "c\n");
  statsps(file, "scheduled jobs", (signed long long int)queue, wct);
  fprintf(file, "c %d failed assumptions %.0f%% out of %d\n", redassumptions, sumassumptions != 0 ? (100.0 * (double)redassumptions) / (double)sumassumptions : (double)0, sumassumptions);
  fprintf(file, "c\n");
  statsps(file, "conflicts", confs, wct);
  statsps(file, "decisions", decs, wct);
  statsps(file, "propagations", props, wct);
  fprintf(file, "c wall clock time %.1f seconds\n", wct);
  fprintf(file, "c process time %.1f seconds\n", prt);
  fprintf(file, "c utilization %.0f%%\n", wct > (double)0 ? 100.0 * ((prt / wct) / (double)nworkers) : 0.0);
  fflush(file);
  n = 0;
  sum = (double)0;
  min = (double)-1;
  max = min;
  i = 0;
  signed int tmp_post$11;
  for( ; !(i >= nassumptions); i = i + 1)
  {
    t = times[(signed long int)i];
    if(!(t < 0.000000))
    {
      sum = sum + t;
      tmp_post$11 = n;
      n = n + 1;
      times[(signed long int)tmp_post$11] = t;
      if(min < 0.000000 || t < min)
        min = t;

      if(max < 0.000000 || t > max)
        max = t;

    }

  }
  if(!(n == 0))
  {
    fprintf(file, "c\n");
    avg = sum / (double)n;
    fprintf(file, "c %d finished jobs in average time %.3f\n", n, avg);
    fprintf(file, "c time: sum %.3f, min %.3f, max %.3f\n", sum, min, max);
    std = (double)0;
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      t = times[(signed long int)i] - avg;
      std = std + t * t;
    }
    std=sqrt(std);
    qsort((void *)times, (unsigned long int)n, sizeof(double *) /*8ul*/ , cmpdblptr);
    fprintf(file, "c time: median %.3f, std dve %.3f\n", times[(signed long int)(n / 2)], std);
  }

  fflush(file);
}

// statsps
// file ilingeling.c line 608
static void statsps(struct _IO_FILE *file, const char *name, signed long long int stats, double time)
{
  const char *scale;
  if(stats >= 10000001l)
  {
    scale = " million";
    stats = stats / (signed long long int)1000000;
  }

  else
    if(stats >= 10001l)
    {
      scale = " thousand";
      stats = stats / (signed long long int)1000;
    }

    else
      scale = "";
  fprintf(file, "c %lld%s %s, %.1f%s per second\n", stats, scale, name, time > (double)0 ? (double)stats / time : 0.0, scale);
}

// stop
// file ilingeling.c line 595
static void stop(void)
{
  struct Worker *w;
  double avg;
  w = workers;
  signed int return_value_pthread_join$1;
  for( ; !(w >= workers + (signed long int)nworkers); w = w + 1l)
  {
    return_value_pthread_join$1=pthread_join(w->thread, ((void **)NULL));
    if(!(return_value_pthread_join$1 == 0))
      die("failed to join worker %d", (signed int)(w - workers));

  }
  if(!(bar == 0))
  {
    avg = finished != 0 ? sumtimes / (double)finished : 0.0;
    progress((1000 * finished) / nassumptions, finished, nassumptions, avg, 1);
  }

  msg(((struct Worker *)NULL), 1, "joined all %d workers", nworkers);
}

// term
// file ilingeling.c line 183
static signed int term(void *voidptr)
{
  struct Worker *w = (struct Worker *)voidptr;
  signed int res;
  msg(w, 3, "checking early termination");
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&donemutex);
  if(!(return_value_pthread_mutex_lock$1 == 0))
    warn("failed to lock 'done' mutex in termination check");

  res = done;
  signed int return_value_pthread_mutex_unlock$2;
  return_value_pthread_mutex_unlock$2=pthread_mutex_unlock(&donemutex);
  if(!(return_value_pthread_mutex_unlock$2 == 0))
    warn("failed to unlock 'done' mutex in termination check");

  msg(w, 3, "early termination check %s", res != 0 ? "succeeded" : "failed");
  return res;
}

// tolower
// file /usr/include/ctype.h line 215
static inline signed int tolower(signed int __c)
{
  signed int tmp_if_expr$2;
  const signed int **return_value___ctype_tolower_loc$1;
  if(__c >= -128 && !(__c >= 256))
  {
    return_value___ctype_tolower_loc$1=__ctype_tolower_loc();
    tmp_if_expr$2 = (*return_value___ctype_tolower_loc$1)[(signed long int)__c];
  }

  else
    tmp_if_expr$2 = __c;
  return tmp_if_expr$2;
}

// toupper
// file /usr/include/ctype.h line 221
static inline signed int toupper(signed int __c)
{
  signed int tmp_if_expr$2;
  const signed int **return_value___ctype_toupper_loc$1;
  if(__c >= -128 && !(__c >= 256))
  {
    return_value___ctype_toupper_loc$1=__ctype_toupper_loc();
    tmp_if_expr$2 = (*return_value___ctype_toupper_loc$1)[(signed long int)__c];
  }

  else
    tmp_if_expr$2 = __c;
  return tmp_if_expr$2;
}

// vprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 36
static inline signed int vprintf(const char * restrict __fmt, void **__arg)
{
  signed int return_value_vfprintf$1;
  return_value_vfprintf$1=vfprintf(stdout, __fmt, __arg);
  return return_value_vfprintf$1;
}

// warn
// file ilingeling.c line 157
static void warn(const char *fmt, ...)
{
  void **ap;
  fputs("*** [ilingeling] warning: ", stderr);
  ap = (void **)&fmt;
  vfprintf(stderr, fmt, ap);
  ap = ((void **)NULL);
  fputc(10, stderr);
  fflush(stderr);
}

// work
// file ilingeling.c line 350
static void * work(void *voidptr)
{
  signed int i;
  signed int last;
  signed int pm;
  signed int lm;
  signed int count;
  signed int lit;
  signed int idx;
  signed int *a;
  signed int *p;
  signed int size;
  signed int red;
  signed int fin;
  double work$$1$$start;
  double end;
  double delta;
  double avg;
  struct Worker *w = (struct Worker *)voidptr;
  msg(w, 1, "running");
  signed int return_value_lglfailed$5;
  do
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&queuemutex);
    if(!(return_value_pthread_mutex_lock$1 == 0))
      die("worker %d failed to lock 'queue' mutex", (signed int)(w - workers));

    last = queue;
    if(!(last >= nassumptions))
      queue = queue + 1;

    signed int return_value_pthread_mutex_unlock$2;
    return_value_pthread_mutex_unlock$2=pthread_mutex_unlock(&queuemutex);
    if(!(return_value_pthread_mutex_unlock$2 == 0))
      die("worker %d failed to unlock 'queue' mutex", (signed int)(w - workers));

    if(last == nassumptions)
    {

    DONE:
      ;
      if(bar == 0)
        msg(w, 1, "done");

      return NULL;
    }

    msg(w, 2, "got job %d", last);
    count = 0;
    i = w->last + 1;
    for( ; last >= i; i = i + 1)
    {
      a = assumptions[(signed long int)i];
      if(!(addassumptions == 0) && !(i >= last))
      {
        p = a;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          lgladd(w->lgl, -lit);
          p = p + 1l;
        }
        while((_Bool)1);
        lgladd(w->lgl, 0);
      }

      p = a;
      do
      {
        lit = *p;
        if(lit == 0)
          break;

        idx=abs(lit);
        if(used[(signed long int)idx] == i)
        {
          lglmelt(w->lgl, idx);
          count = count + 1;
        }

        p = p + 1l;
      }
      while((_Bool)1);
    }
    msg(w, 2, "melted %d variables", count);
    w->last = last;
    a = assumptions[(signed long int)w->last];
    p = a;
    do
    {
      lit = *p;
      if(lit == 0)
        break;

      lglassume(w->lgl, lit);
      p = p + 1l;
    }
    while((_Bool)1);
    work$$1$$start=getime();
    w->res=sat(w);
    end=getime();
    delta = end - work$$1$$start;
    delta = delta <= (double)0 ? (double)0 : delta;
    times[(signed long int)last] = delta;
    if(!(bar == 0))
    {
      pthread_mutex_lock(&finishedmutex);
      finished = finished + 1;
      fin = finished;
      sumtimes = sumtimes + delta;
      avg = sumtimes / (double)fin;
      pthread_mutex_unlock(&finishedmutex);
      pm = (1000 * (fin - 1)) / nassumptions;
      lm = (1000 * fin) / nassumptions;
      if(!(pm >= lm))
        progress(lm, fin, nassumptions, avg, 0);

    }

    if(w->res == 10)
    {
      if(bar == 0)
        msg(w, 1, "job %d SATISFIABLE", last);

      signed int return_value_pthread_mutex_lock$3;
      return_value_pthread_mutex_lock$3=pthread_mutex_lock(&donemutex);
      if(!(return_value_pthread_mutex_lock$3 == 0))
        warn("worker %d failed to lock 'done' mutex", (signed int)(w - workers));

      done = 1;
      signed int return_value_pthread_mutex_unlock$4;
      return_value_pthread_mutex_unlock$4=pthread_mutex_unlock(&donemutex);
      if(!(return_value_pthread_mutex_unlock$4 == 0))
        warn("worker %d failed to unlock 'done' mutex", (signed int)(w - workers));

      goto DONE;
    }

    else
      if(w->res == 20)
      {
        red = 0;
        p = a;
        do
        {
          lit = *p;
          if(lit == 0)
            break;

          return_value_lglfailed$5=lglfailed(w->lgl, lit);
          if(!(return_value_lglfailed$5 == 0))
            red = red + 1;

          p = p + 1l;
        }
        while((_Bool)1);
        size = (signed int)(p - a);
        sumassumptions = sumassumptions + size;
        redassumptions = redassumptions + red;
        if(bar == 0)
          msg(w, 1, "job %d UNSATISFIABLE (%d failed / %d) in %.3f seconds", last, red, size, delta);

        lglflushcache(w->lgl);
      }

      else
      {
        if(bar == 0)
          msg(w, 1, "job %d UNKNOWN", last);

        goto DONE;
      }
  }
  while((_Bool)1);
}

