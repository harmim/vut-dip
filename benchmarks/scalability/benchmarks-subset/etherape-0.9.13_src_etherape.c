// #anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2
// file common.h line 80
enum anonymous$13 { APEMODE_DEFAULT=-1, LINK6=0, IP=1, TCP=2 };

// #anon_enum$EITHERBOUND=-1$INBOUND=0$OUTBOUND=1
// file pkt_info.h line 31
enum anonymous$7 { EITHERBOUND=-1, INBOUND=0, OUTBOUND=1 };

// #anon_enum$ETHERNET_II=0$ETHERNET_802_2=1$ETHERNET_802_3=2$ETHERNET_SNAP=3
// file prot_types.h line 29
enum anonymous$11 { ETHERNET_II=0, ETHERNET_802_2=1, ETHERNET_802_3=2, ETHERNET_SNAP=3 };

// #anon_enum$ETHERTYPE_UNK=0$ETHERTYPE_VINES=2989$ETHERTYPE_TRAIN=6532$ETHERTYPE_3C_NBP_DGRAM=15367$ETHERTYPE_IP=2048$ETHERTYPE_X25L3=2053$ETHERTYPE_ARP=2054$ETHERTYPE_DEC=24576$ETHERTYPE_DNA_DL=24577$ETHERTYPE_DNA_RC=24578$ETHERTYPE_DNA_RT=24579$ETHERTYPE_LAT=24580$ETHERTYPE_DEC_DIAG=24581$ETHERTYPE_DEC_CUST=24582$ETHERTYPE_DEC_SCA=24583$ETHERTYPE_ETHBRIDGE=25944$ETHERTYPE_DEC_LB=32824$ETHERTYPE_REVARP=32821$ETHERTYPE_ATALK=32923$ETHERTYPE_AARP=33011$ETHERTYPE_IPX=33079$ETHERTYPE_VLAN=33024$ETHERTYPE_SNMP=33100$ETHERTYPE_WCP=33023$ETHERTYPE_IPv6=34525$ETHERTYPE_PPP=34827$ETHERTYPE_MPLS=34887$ETHERTYPE_MPLS_MULTI=34888$ETHERTYPE_PPPOED=34915$ETHERTYPE_PPPOES=34916$ETHERTYPE_LOOP=36864
// file prot_types.h line 38
enum anonymous$8 { ETHERTYPE_UNK=0, ETHERTYPE_VINES=2989, ETHERTYPE_TRAIN=6532, ETHERTYPE_3C_NBP_DGRAM=15367, ETHERTYPE_IP=2048, ETHERTYPE_X25L3=2053, ETHERTYPE_ARP=2054, ETHERTYPE_DEC=24576, ETHERTYPE_DNA_DL=24577, ETHERTYPE_DNA_RC=24578, ETHERTYPE_DNA_RT=24579, ETHERTYPE_LAT=24580, ETHERTYPE_DEC_DIAG=24581, ETHERTYPE_DEC_CUST=24582, ETHERTYPE_DEC_SCA=24583, ETHERTYPE_ETHBRIDGE=25944, ETHERTYPE_DEC_LB=32824, ETHERTYPE_REVARP=32821, ETHERTYPE_ATALK=32923, ETHERTYPE_AARP=33011, ETHERTYPE_IPX=33079, ETHERTYPE_VLAN=33024, ETHERTYPE_SNMP=33100, ETHERTYPE_WCP=33023, ETHERTYPE_IPv6=34525, ETHERTYPE_PPP=34827, ETHERTYPE_MPLS=34887, ETHERTYPE_MPLS_MULTI=34888, ETHERTYPE_PPPOED=34915, ETHERTYPE_PPPOES=34916, ETHERTYPE_LOOP=36864 };

// #anon_enum$GDK_ACTION_DEFAULT=1$GDK_ACTION_COPY=2$GDK_ACTION_MOVE=4$GDK_ACTION_LINK=8$GDK_ACTION_PRIVATE=16$GDK_ACTION_ASK=32
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 40
enum anonymous$53 { GDK_ACTION_DEFAULT=1, GDK_ACTION_COPY=2, GDK_ACTION_MOVE=4, GDK_ACTION_LINK=8, GDK_ACTION_PRIVATE=16, GDK_ACTION_ASK=32 };

// #anon_enum$GDK_AXIS_IGNORE=0$GDK_AXIS_X=1$GDK_AXIS_Y=2$GDK_AXIS_PRESSURE=3$GDK_AXIS_XTILT=4$GDK_AXIS_YTILT=5$GDK_AXIS_WHEEL=6$GDK_AXIS_LAST=7
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 73
enum anonymous$58 { GDK_AXIS_IGNORE=0, GDK_AXIS_X=1, GDK_AXIS_Y=2, GDK_AXIS_PRESSURE=3, GDK_AXIS_XTILT=4, GDK_AXIS_YTILT=5, GDK_AXIS_WHEEL=6, GDK_AXIS_LAST=7 };

// #anon_enum$GDK_CROSSING_NORMAL=0$GDK_CROSSING_GRAB=1$GDK_CROSSING_UNGRAB=2$GDK_CROSSING_GTK_GRAB=3$GDK_CROSSING_GTK_UNGRAB=4$GDK_CROSSING_STATE_CHANGED=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 225
enum anonymous$45 { GDK_CROSSING_NORMAL=0, GDK_CROSSING_GRAB=1, GDK_CROSSING_UNGRAB=2, GDK_CROSSING_GTK_GRAB=3, GDK_CROSSING_GTK_UNGRAB=4, GDK_CROSSING_STATE_CHANGED=5 };

// #anon_enum$GDK_DRAG_PROTO_MOTIF=0$GDK_DRAG_PROTO_XDND=1$GDK_DRAG_PROTO_ROOTWIN=2$GDK_DRAG_PROTO_NONE=3$GDK_DRAG_PROTO_WIN32_DROPFILES=4$GDK_DRAG_PROTO_OLE2=5$GDK_DRAG_PROTO_LOCAL=6
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 50
enum anonymous$52 { GDK_DRAG_PROTO_MOTIF=0, GDK_DRAG_PROTO_XDND=1, GDK_DRAG_PROTO_ROOTWIN=2, GDK_DRAG_PROTO_NONE=3, GDK_DRAG_PROTO_WIN32_DROPFILES=4, GDK_DRAG_PROTO_OLE2=5, GDK_DRAG_PROTO_LOCAL=6 };

// #anon_enum$GDK_FONT_FONT=0$GDK_FONT_FONTSET=1
// file /usr/include/gtk-2.0/gdk/gdkfont.h line 43
enum anonymous$31 { GDK_FONT_FONT=0, GDK_FONT_FONTSET=1 };

// #anon_enum$GDK_INPUT_READ=1$GDK_INPUT_WRITE=2$GDK_INPUT_EXCEPTION=4
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 155
enum anonymous$4 { GDK_INPUT_READ=1, GDK_INPUT_WRITE=2, GDK_INPUT_EXCEPTION=4 };

// #anon_enum$GDK_LSB_FIRST=0$GDK_MSB_FIRST=1
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 118
enum anonymous$23 { GDK_LSB_FIRST=0, GDK_MSB_FIRST=1 };

// #anon_enum$GDK_MODE_DISABLED=0$GDK_MODE_SCREEN=1$GDK_MODE_WINDOW=2
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 66
enum anonymous$50 { GDK_MODE_DISABLED=0, GDK_MODE_SCREEN=1, GDK_MODE_WINDOW=2 };

// #anon_enum$GDK_NOTHING=-1$GDK_DELETE=0$GDK_DESTROY=1$GDK_EXPOSE=2$GDK_MOTION_NOTIFY=3$GDK_BUTTON_PRESS=4$GDK_2BUTTON_PRESS=5$GDK_3BUTTON_PRESS=6$GDK_BUTTON_RELEASE=7$GDK_KEY_PRESS=8$GDK_KEY_RELEASE=9$GDK_ENTER_NOTIFY=10$GDK_LEAVE_NOTIFY=11$GDK_FOCUS_CHANGE=12$GDK_CONFIGURE=13$GDK_MAP=14$GDK_UNMAP=15$GDK_PROPERTY_NOTIFY=16$GDK_SELECTION_CLEAR=17$GDK_SELECTION_REQUEST=18$GDK_SELECTION_NOTIFY=19$GDK_PROXIMITY_IN=20$GDK_PROXIMITY_OUT=21$GDK_DRAG_ENTER=22$GDK_DRAG_LEAVE=23$GDK_DRAG_MOTION=24$GDK_DRAG_STATUS=25$GDK_DROP_START=26$GDK_DROP_FINISHED=27$GDK_CLIENT_EVENT=28$GDK_VISIBILITY_NOTIFY=29$GDK_NO_EXPOSE=30$GDK_SCROLL=31$GDK_WINDOW_STATE=32$GDK_SETTING=33$GDK_OWNER_CHANGE=34$GDK_GRAB_BROKEN=35$GDK_DAMAGE=36$GDK_EVENT_LAST=37
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 115
enum anonymous$44 { GDK_NOTHING=-1, GDK_DELETE=0, GDK_DESTROY=1, GDK_EXPOSE=2, GDK_MOTION_NOTIFY=3, GDK_BUTTON_PRESS=4, GDK_2BUTTON_PRESS=5, GDK_3BUTTON_PRESS=6, GDK_BUTTON_RELEASE=7, GDK_KEY_PRESS=8, GDK_KEY_RELEASE=9, GDK_ENTER_NOTIFY=10, GDK_LEAVE_NOTIFY=11, GDK_FOCUS_CHANGE=12, GDK_CONFIGURE=13, GDK_MAP=14, GDK_UNMAP=15, GDK_PROPERTY_NOTIFY=16, GDK_SELECTION_CLEAR=17, GDK_SELECTION_REQUEST=18, GDK_SELECTION_NOTIFY=19, GDK_PROXIMITY_IN=20, GDK_PROXIMITY_OUT=21, GDK_DRAG_ENTER=22, GDK_DRAG_LEAVE=23, GDK_DRAG_MOTION=24, GDK_DRAG_STATUS=25, GDK_DROP_START=26, GDK_DROP_FINISHED=27, GDK_CLIENT_EVENT=28, GDK_VISIBILITY_NOTIFY=29, GDK_NO_EXPOSE=30, GDK_SCROLL=31, GDK_WINDOW_STATE=32, GDK_SETTING=33, GDK_OWNER_CHANGE=34, GDK_GRAB_BROKEN=35, GDK_DAMAGE=36, GDK_EVENT_LAST=37 };

// #anon_enum$GDK_NOTIFY_ANCESTOR=0$GDK_NOTIFY_VIRTUAL=1$GDK_NOTIFY_INFERIOR=2$GDK_NOTIFY_NONLINEAR=3$GDK_NOTIFY_NONLINEAR_VIRTUAL=4$GDK_NOTIFY_UNKNOWN=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 210
enum anonymous$46 { GDK_NOTIFY_ANCESTOR=0, GDK_NOTIFY_VIRTUAL=1, GDK_NOTIFY_INFERIOR=2, GDK_NOTIFY_NONLINEAR=3, GDK_NOTIFY_NONLINEAR_VIRTUAL=4, GDK_NOTIFY_UNKNOWN=5 };

// #anon_enum$GDK_OWNER_CHANGE_NEW_OWNER=0$GDK_OWNER_CHANGE_DESTROY=1$GDK_OWNER_CHANGE_CLOSE=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 259
enum anonymous$48 { GDK_OWNER_CHANGE_NEW_OWNER=0, GDK_OWNER_CHANGE_DESTROY=1, GDK_OWNER_CHANGE_CLOSE=2 };

// #anon_enum$GDK_RGB_DITHER_NONE=0$GDK_RGB_DITHER_NORMAL=1$GDK_RGB_DITHER_MAX=2
// file /usr/include/gtk-2.0/gdk/gdkrgb.h line 40
enum anonymous$63 { GDK_RGB_DITHER_NONE=0, GDK_RGB_DITHER_NORMAL=1, GDK_RGB_DITHER_MAX=2 };

// #anon_enum$GDK_SCROLL_UP=0$GDK_SCROLL_DOWN=1$GDK_SCROLL_LEFT=2$GDK_SCROLL_RIGHT=3
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 194
enum anonymous$56 { GDK_SCROLL_UP=0, GDK_SCROLL_DOWN=1, GDK_SCROLL_LEFT=2, GDK_SCROLL_RIGHT=3 };

// #anon_enum$GDK_SETTING_ACTION_NEW=0$GDK_SETTING_ACTION_CHANGED=1$GDK_SETTING_ACTION_DELETED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 252
enum anonymous$55 { GDK_SETTING_ACTION_NEW=0, GDK_SETTING_ACTION_CHANGED=1, GDK_SETTING_ACTION_DELETED=2 };

// #anon_enum$GDK_SHIFT_MASK=1$GDK_LOCK_MASK=2$GDK_CONTROL_MASK=4$GDK_MOD1_MASK=8$GDK_MOD2_MASK=16$GDK_MOD3_MASK=32$GDK_MOD4_MASK=64$GDK_MOD5_MASK=128$GDK_BUTTON1_MASK=256$GDK_BUTTON2_MASK=512$GDK_BUTTON3_MASK=1024$GDK_BUTTON4_MASK=2048$GDK_BUTTON5_MASK=4096$GDK_SUPER_MASK=67108864$GDK_HYPER_MASK=134217728$GDK_META_MASK=268435456$GDK_RELEASE_MASK=1073741824$GDK_MODIFIER_MASK=1543512063
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 126
enum anonymous$57 { GDK_SHIFT_MASK=1, GDK_LOCK_MASK=2, GDK_CONTROL_MASK=4, GDK_MOD1_MASK=8, GDK_MOD2_MASK=16, GDK_MOD3_MASK=32, GDK_MOD4_MASK=64, GDK_MOD5_MASK=128, GDK_BUTTON1_MASK=256, GDK_BUTTON2_MASK=512, GDK_BUTTON3_MASK=1024, GDK_BUTTON4_MASK=2048, GDK_BUTTON5_MASK=4096, GDK_SUPER_MASK=67108864, GDK_HYPER_MASK=134217728, GDK_META_MASK=268435456, GDK_RELEASE_MASK=1073741824, GDK_MODIFIER_MASK=1543512063 };

// #anon_enum$GDK_SOURCE_MOUSE=0$GDK_SOURCE_PEN=1$GDK_SOURCE_ERASER=2$GDK_SOURCE_CURSOR=3
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 58
enum anonymous$49 { GDK_SOURCE_MOUSE=0, GDK_SOURCE_PEN=1, GDK_SOURCE_ERASER=2, GDK_SOURCE_CURSOR=3 };

// #anon_enum$GDK_VISIBILITY_UNOBSCURED=0$GDK_VISIBILITY_PARTIAL=1$GDK_VISIBILITY_FULLY_OBSCURED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 187
enum anonymous$47 { GDK_VISIBILITY_UNOBSCURED=0, GDK_VISIBILITY_PARTIAL=1, GDK_VISIBILITY_FULLY_OBSCURED=2 };

// #anon_enum$GDK_VISUAL_STATIC_GRAY=0$GDK_VISUAL_GRAYSCALE=1$GDK_VISUAL_STATIC_COLOR=2$GDK_VISUAL_PSEUDO_COLOR=3$GDK_VISUAL_TRUE_COLOR=4$GDK_VISUAL_DIRECT_COLOR=5
// file /usr/include/gtk-2.0/gdk/gdkvisual.h line 55
enum anonymous$24 { GDK_VISUAL_STATIC_GRAY=0, GDK_VISUAL_GRAYSCALE=1, GDK_VISUAL_STATIC_COLOR=2, GDK_VISUAL_PSEUDO_COLOR=3, GDK_VISUAL_TRUE_COLOR=4, GDK_VISUAL_DIRECT_COLOR=5 };

// #anon_enum$GDK_WINDOW_STATE_WITHDRAWN=1$GDK_WINDOW_STATE_ICONIFIED=2$GDK_WINDOW_STATE_MAXIMIZED=4$GDK_WINDOW_STATE_STICKY=8$GDK_WINDOW_STATE_FULLSCREEN=16$GDK_WINDOW_STATE_ABOVE=32$GDK_WINDOW_STATE_BELOW=64
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 241
enum anonymous$54 { GDK_WINDOW_STATE_WITHDRAWN=1, GDK_WINDOW_STATE_ICONIFIED=2, GDK_WINDOW_STATE_MAXIMIZED=4, GDK_WINDOW_STATE_STICKY=8, GDK_WINDOW_STATE_FULLSCREEN=16, GDK_WINDOW_STATE_ABOVE=32, GDK_WINDOW_STATE_BELOW=64 };

// #anon_enum$GNOME_INTERACT_NONE=0$GNOME_INTERACT_ERRORS=1$GNOME_INTERACT_ANY=2
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-client.h line 50
enum anonymous$77 { GNOME_INTERACT_NONE=0, GNOME_INTERACT_ERRORS=1, GNOME_INTERACT_ANY=2 };

// #anon_enum$GNOME_RESTART_IF_RUNNING=0$GNOME_RESTART_ANYWAY=1$GNOME_RESTART_IMMEDIATELY=2$GNOME_RESTART_NEVER=3
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-client.h line 71
enum anonymous$78 { GNOME_RESTART_IF_RUNNING=0, GNOME_RESTART_ANYWAY=1, GNOME_RESTART_IMMEDIATELY=2, GNOME_RESTART_NEVER=3 };

// #anon_enum$GNOME_SAVE_GLOBAL=0$GNOME_SAVE_LOCAL=1$GNOME_SAVE_BOTH=2
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-client.h line 63
enum anonymous$76 { GNOME_SAVE_GLOBAL=0, GNOME_SAVE_LOCAL=1, GNOME_SAVE_BOTH=2 };

// #anon_enum$GTK_BUTTONS_NONE=0$GTK_BUTTONS_OK=1$GTK_BUTTONS_CLOSE=2$GTK_BUTTONS_CANCEL=3$GTK_BUTTONS_YES_NO=4$GTK_BUTTONS_OK_CANCEL=5
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 89
enum anonymous$70 { GTK_BUTTONS_NONE=0, GTK_BUTTONS_OK=1, GTK_BUTTONS_CLOSE=2, GTK_BUTTONS_CANCEL=3, GTK_BUTTONS_YES_NO=4, GTK_BUTTONS_OK_CANCEL=5 };

// #anon_enum$GTK_DIALOG_MODAL=1$GTK_DIALOG_DESTROY_WITH_PARENT=2$GTK_DIALOG_NO_SEPARATOR=4
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 41
enum anonymous$67 { GTK_DIALOG_MODAL=1, GTK_DIALOG_DESTROY_WITH_PARENT=2, GTK_DIALOG_NO_SEPARATOR=4 };

// #anon_enum$GTK_FILE_CHOOSER_ACTION_OPEN=0$GTK_FILE_CHOOSER_ACTION_SAVE=1$GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2$GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER=3
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 56
enum anonymous$66 { GTK_FILE_CHOOSER_ACTION_OPEN=0, GTK_FILE_CHOOSER_ACTION_SAVE=1, GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2, GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER=3 };

// #anon_enum$GTK_MESSAGE_INFO=0$GTK_MESSAGE_WARNING=1$GTK_MESSAGE_QUESTION=2$GTK_MESSAGE_ERROR=3$GTK_MESSAGE_OTHER=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 221
enum anonymous$69 { GTK_MESSAGE_INFO=0, GTK_MESSAGE_WARNING=1, GTK_MESSAGE_QUESTION=2, GTK_MESSAGE_ERROR=3, GTK_MESSAGE_OTHER=4 };

// #anon_enum$GTK_ORIENTATION_HORIZONTAL=0$GTK_ORIENTATION_VERTICAL=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 262
enum anonymous$75 { GTK_ORIENTATION_HORIZONTAL=0, GTK_ORIENTATION_VERTICAL=1 };

// #anon_enum$GTK_RC_FG=1$GTK_RC_BG=2$GTK_RC_TEXT=4$GTK_RC_BASE=8
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 52
enum anonymous$32 { GTK_RC_FG=1, GTK_RC_BG=2, GTK_RC_TEXT=4, GTK_RC_BASE=8 };

// #anon_enum$GTK_SORT_ASCENDING=0$GTK_SORT_DESCENDING=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 476
enum anonymous$33 { GTK_SORT_ASCENDING=0, GTK_SORT_DESCENDING=1 };

// #anon_enum$GTK_STATE_NORMAL=0$GTK_STATE_ACTIVE=1$GTK_STATE_PRELIGHT=2$GTK_STATE_SELECTED=3$GTK_STATE_INSENSITIVE=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 399
enum anonymous$0 { GTK_STATE_NORMAL=0, GTK_STATE_ACTIVE=1, GTK_STATE_PRELIGHT=2, GTK_STATE_SELECTED=3, GTK_STATE_INSENSITIVE=4 };

// #anon_enum$GTK_TREE_VIEW_COLUMN_GROW_ONLY=0$GTK_TREE_VIEW_COLUMN_AUTOSIZE=1$GTK_TREE_VIEW_COLUMN_FIXED=2
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 45
enum anonymous$73 { GTK_TREE_VIEW_COLUMN_GROW_ONLY=0, GTK_TREE_VIEW_COLUMN_AUTOSIZE=1, GTK_TREE_VIEW_COLUMN_FIXED=2 };

// #anon_enum$GTK_UPDATE_ALWAYS=0$GTK_UPDATE_IF_VALID=1
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 53
enum anonymous$72 { GTK_UPDATE_ALWAYS=0, GTK_UPDATE_IF_VALID=1 };

// #anon_enum$GTK_UPDATE_CONTINUOUS=0$GTK_UPDATE_DISCONTINUOUS=1$GTK_UPDATE_DELAYED=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 434
enum anonymous$74 { GTK_UPDATE_CONTINUOUS=0, GTK_UPDATE_DISCONTINUOUS=1, GTK_UPDATE_DELAYED=2 };

// #anon_enum$G_CONNECT_AFTER=1$G_CONNECT_SWAPPED=2
// file /usr/include/glib-2.0/gobject/gsignal.h line 155
enum anonymous$65 { G_CONNECT_AFTER=1, G_CONNECT_SWAPPED=2 };

// #anon_enum$G_KEY_FILE_NONE=0$G_KEY_FILE_KEEP_COMMENTS=1$G_KEY_FILE_KEEP_TRANSLATIONS=2
// file /usr/include/glib-2.0/glib/gkeyfile.h line 50
enum anonymous$71 { G_KEY_FILE_NONE=0, G_KEY_FILE_KEEP_COMMENTS=1, G_KEY_FILE_KEEP_TRANSLATIONS=2 };

// #anon_enum$G_LOG_FLAG_RECURSION=1$G_LOG_FLAG_FATAL=2$G_LOG_LEVEL_ERROR=4$G_LOG_LEVEL_CRITICAL=8$G_LOG_LEVEL_WARNING=16$G_LOG_LEVEL_MESSAGE=32$G_LOG_LEVEL_INFO=64$G_LOG_LEVEL_DEBUG=128$G_LOG_LEVEL_MASK=-4
// file /usr/include/glib-2.0/glib/gmessages.h line 51
enum anonymous$30 { G_LOG_FLAG_RECURSION=1, G_LOG_FLAG_FATAL=2, G_LOG_LEVEL_ERROR=4, G_LOG_LEVEL_CRITICAL=8, G_LOG_LEVEL_WARNING=16, G_LOG_LEVEL_MESSAGE=32, G_LOG_LEVEL_INFO=64, G_LOG_LEVEL_DEBUG=128, G_LOG_LEVEL_MASK=-4 };

// #anon_enum$G_PARAM_READABLE=1$G_PARAM_WRITABLE=2$G_PARAM_READWRITE=3$G_PARAM_CONSTRUCT=4$G_PARAM_CONSTRUCT_ONLY=8$G_PARAM_LAX_VALIDATION=16$G_PARAM_STATIC_NAME=32$G_PARAM_PRIVATE=32$G_PARAM_STATIC_NICK=64$G_PARAM_STATIC_BLURB=128$G_PARAM_EXPLICIT_NOTIFY=1073741824$G_PARAM_DEPRECATED=-2147483648
// file /usr/include/glib-2.0/gobject/gparam.h line 150
enum anonymous$79 { G_PARAM_READABLE=1, G_PARAM_WRITABLE=2, G_PARAM_READWRITE=3, G_PARAM_CONSTRUCT=4, G_PARAM_CONSTRUCT_ONLY=8, G_PARAM_LAX_VALIDATION=16, G_PARAM_STATIC_NAME=32, G_PARAM_PRIVATE=32, G_PARAM_STATIC_NICK=64, G_PARAM_STATIC_BLURB=128, G_PARAM_EXPLICIT_NOTIFY=1073741824, G_PARAM_DEPRECATED=-2147483648 };

// #anon_enum$INST_TOTAL=0$INST_INBOUND=1$INST_OUTBOUND=2$INST_PACKETS=3$ACCU_TOTAL=4$ACCU_INBOUND=5$ACCU_OUTBOUND=6$ACCU_PACKETS=7$ACCU_AVG_SIZE=8
// file common.h line 64
enum anonymous$60 { INST_TOTAL=0, INST_INBOUND=1, INST_OUTBOUND=2, INST_PACKETS=3, ACCU_TOTAL=4, ACCU_INBOUND=5, ACCU_OUTBOUND=6, ACCU_PACKETS=7, ACCU_AVG_SIZE=8 };

// #anon_enum$IPX_PACKET_TYPE_IPX=0$IPX_PACKET_TYPE_RIP=1$IPX_PACKET_TYPE_ECHO=2$IPX_PACKET_TYPE_ERROR=3$IPX_PACKET_TYPE_PEP=4$IPX_PACKET_TYPE_SPX=5$IPX_PACKET_TYPE_NCP=17$IPX_PACKET_TYPE_WANBCAST=20
// file prot_types.h line 105
enum anonymous$22 { IPX_PACKET_TYPE_IPX=0, IPX_PACKET_TYPE_RIP=1, IPX_PACKET_TYPE_ECHO=2, IPX_PACKET_TYPE_ERROR=3, IPX_PACKET_TYPE_PEP=4, IPX_PACKET_TYPE_SPX=5, IPX_PACKET_TYPE_NCP=17, IPX_PACKET_TYPE_WANBCAST=20 };

// #anon_enum$IPX_SOCKET_PING_CISCO=2$IPX_SOCKET_NCP=1105$IPX_SOCKET_SAP=1106$IPX_SOCKET_IPXRIP=1107$IPX_SOCKET_NETBIOS=1109$IPX_SOCKET_DIAGNOSTIC=1110$IPX_SOCKET_SERIALIZATION=1111$IPX_SOCKET_NWLINK_SMB_SERVER=1360$IPX_SOCKET_NWLINK_SMB_NAMEQUERY=1361$IPX_SOCKET_NWLINK_SMB_REDIR=1362$IPX_SOCKET_NWLINK_SMB_MAILSLOT=1363$IPX_SOCKET_NWLINK_SMB_MESSENGER=1364$IPX_SOCKET_NWLINK_SMB_BROWSE=1365$IPX_SOCKET_ATTACHMATE_GW=1373$IPX_SOCKET_IPX_MESSAGE=16385$IPX_SOCKET_ADSM=34082$IPX_SOCKET_EIGRP=34238$IPX_SOCKET_WIDE_AREA_ROUTER=36865$IPX_SOCKET_SNMP_AGENT=36879$IPX_SOCKET_SNMP_SINK=36880$IPX_SOCKET_PING_NOVELL=36998$IPX_SOCKET_TCP_TUNNEL=37009$IPX_SOCKET_UDP_TUNNEL=37010
// file prot_types.h line 118
enum anonymous$17 { IPX_SOCKET_PING_CISCO=2, IPX_SOCKET_NCP=1105, IPX_SOCKET_SAP=1106, IPX_SOCKET_IPXRIP=1107, IPX_SOCKET_NETBIOS=1109, IPX_SOCKET_DIAGNOSTIC=1110, IPX_SOCKET_SERIALIZATION=1111, IPX_SOCKET_NWLINK_SMB_SERVER=1360, IPX_SOCKET_NWLINK_SMB_NAMEQUERY=1361, IPX_SOCKET_NWLINK_SMB_REDIR=1362, IPX_SOCKET_NWLINK_SMB_MAILSLOT=1363, IPX_SOCKET_NWLINK_SMB_MESSENGER=1364, IPX_SOCKET_NWLINK_SMB_BROWSE=1365, IPX_SOCKET_ATTACHMATE_GW=1373, IPX_SOCKET_IPX_MESSAGE=16385, IPX_SOCKET_ADSM=34082, IPX_SOCKET_EIGRP=34238, IPX_SOCKET_WIDE_AREA_ROUTER=36865, IPX_SOCKET_SNMP_AGENT=36879, IPX_SOCKET_SNMP_SINK=36880, IPX_SOCKET_PING_NOVELL=36998, IPX_SOCKET_TCP_TUNNEL=37009, IPX_SOCKET_UDP_TUNNEL=37010 };

// #anon_enum$IP_PROTO_IP=0$IP_PROTO_HOPOPTS=0$IP_PROTO_ICMP=1$IP_PROTO_IGMP=2$IP_PROTO_GGP=3$IP_PROTO_IPIP=4$IP_PROTO_IPV4=4$IP_PROTO_TCP=6$IP_PROTO_EGP=8$IP_PROTO_PUP=12$IP_PROTO_UDP=17$IP_PROTO_IDP=22$IP_PROTO_TP=29$IP_PROTO_IPV6=41$IP_PROTO_ROUTING=43$IP_PROTO_FRAGMENT=44$IP_PROTO_RSVP=46$IP_PROTO_GRE=47$IP_PROTO_ESP=50$IP_PROTO_AH=51$IP_PROTO_ICMPV6=58$IP_PROTO_NONE=59$IP_PROTO_DSTOPTS=60$IP_PROTO_EON=80$IP_PROTO_VINES=83$IP_PROTO_EIGRP=88$IP_PROTO_OSPF=89$IP_PROTO_ENCAP=98$IP_PROTO_PIM=103$IP_PROTO_IPCOMP=108$IP_PROTO_VRRP=112
// file prot_types.h line 148
enum anonymous$18 { IP_PROTO_IP=0, IP_PROTO_HOPOPTS=0, IP_PROTO_ICMP=1, IP_PROTO_IGMP=2, IP_PROTO_GGP=3, IP_PROTO_IPIP=4, IP_PROTO_IPV4=4, IP_PROTO_TCP=6, IP_PROTO_EGP=8, IP_PROTO_PUP=12, IP_PROTO_UDP=17, IP_PROTO_IDP=22, IP_PROTO_TP=29, IP_PROTO_IPV6=41, IP_PROTO_ROUTING=43, IP_PROTO_FRAGMENT=44, IP_PROTO_RSVP=46, IP_PROTO_GRE=47, IP_PROTO_ESP=50, IP_PROTO_AH=51, IP_PROTO_ICMPV6=58, IP_PROTO_NONE=59, IP_PROTO_DSTOPTS=60, IP_PROTO_EON=80, IP_PROTO_VINES=83, IP_PROTO_EIGRP=88, IP_PROTO_OSPF=89, IP_PROTO_ENCAP=98, IP_PROTO_PIM=103, IP_PROTO_IPCOMP=108, IP_PROTO_VRRP=112 };

// #anon_enum$LINEAR=0$LOG=1$SQRT=2
// file common.h line 54
enum anonymous$59 { LINEAR=0, LOG=1, SQRT=2 };

// #anon_enum$SAP_NULL=0$SAP_LLC_SLMGMT=2$SAP_SNA_PATHCTRL=4$SAP_IP=6$SAP_SNA1=8$SAP_SNA2=12$SAP_PROWAY_NM_INIT=14$SAP_TI=24$SAP_BPDU=66$SAP_RS511=78$SAP_X25=126$SAP_XNS=128$SAP_NESTAR=134$SAP_PROWAY_ASLM=142$SAP_SNAP=170$SAP_ARP=152$SAP_VINES1=186$SAP_VINES2=188$SAP_NETWARE=224$SAP_NETBIOS=240$SAP_IBMNM=244$SAP_RPL1=248$SAP_UB=250$SAP_RPL2=252$SAP_OSINL=254$SAP_GLOBAL=255
// file prot_types.h line 74
enum anonymous$14 { SAP_NULL=0, SAP_LLC_SLMGMT=2, SAP_SNA_PATHCTRL=4, SAP_IP=6, SAP_SNA1=8, SAP_SNA2=12, SAP_PROWAY_NM_INIT=14, SAP_TI=24, SAP_BPDU=66, SAP_RS511=78, SAP_X25=126, SAP_XNS=128, SAP_NESTAR=134, SAP_PROWAY_ASLM=142, SAP_SNAP=170, SAP_ARP=152, SAP_VINES1=186, SAP_VINES2=188, SAP_NETWARE=224, SAP_NETBIOS=240, SAP_IBMNM=244, SAP_RPL1=248, SAP_UB=250, SAP_RPL2=252, SAP_OSINL=254, SAP_GLOBAL=255 };

// tag-#anon#ST[*{S8}$S8$'name'||SYM#tag-#anon#ST[F64'average'||F64'aver_accu'||F64'accumulated'||F64'avg_size'||U64'accu_packets'||SYM#tag-timeval#'last_time'|]#'stats'||*{SYM#tag-_GList#}$SYM#tag-_GList#$'node_names'|]
// file protocols.h line 28
struct anonymous$26;

// tag-#anon#ST[*{S8}$S8$'prot'||*{S32(*{SYM#tag-#anon#ST[*{cU8}$cU8$'p'||U16'offset'||U16'packet_size'||EN#anon_enum$EITHERBOUND=-1$INBOUND=0$OUTBOUND=1#{S32}$S32$'dir'||S32'link_type'||SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'node_id'||SYM#tag-#anon#ST[U8'level'||U56'$pad0'||*{cSYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#}$cSYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#$'tokens'||*{SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#}$SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#$'protos'|]#'decoder'|]#}$SYM#tag-#anon#ST[*{cU8}$cU8$'p'||U16'offset'||U16'packet_size'||EN#anon_enum$EITHERBOUND=-1$INBOUND=0$OUTBOUND=1#{S32}$S32$'dir'||S32'link_type'||SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'node_id'||SYM#tag-#anon#ST[U8'level'||U56'$pad0'||*{cSYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#}$cSYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#$'tokens'||*{SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#}$SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#$'protos'|]#'decoder'|]#$)->S32}$S32(*{SYM#tag-#anon#ST[*{cU8}$cU8$'p'||U16'offset'||U16'packet_size'||EN#anon_enum$EITHERBOUND=-1$INBOUND=0$OUTBOUND=1#{S32}$S32$'dir'||S32'link_type'||SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'node_id'||SYM#tag-#anon#ST[U8'level'||U56'$pad0'||*{cSYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#}$cSYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#$'tokens'||*{SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#}$SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#$'protos'|]#'decoder'|]#}$SYM#tag-#anon#ST[*{cU8}$cU8$'p'||U16'offset'||U16'packet_size'||EN#anon_enum$EITHERBOUND=-1$INBOUND=0$OUTBOUND=1#{S32}$S32$'dir'||S32'link_type'||SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'node_id'||SYM#tag-#anon#ST[U8'level'||U56'$pad0'||*{cSYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#}$cSYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#$'tokens'||*{SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#}$SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#$'protos'|]#'decoder'|]#$)->S32$'function'|]
// file names.c line 58
struct anonymous$12;

// tag-#anon#ST[*{S8}$S8$'prot_name'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'window'|]
// file info_windows.c line 51
struct anonymous$29;

// tag-#anon#ST[*{SYM#tag-#anon#ST[U32'size'||U32'$pad0'||SYM#tag-timeval#'timestamp'||*{SYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#}$SYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#$'prot_desc'||U32'ref_count'||U32'$pad1'|]#}$SYM#tag-#anon#ST[U32'size'||U32'$pad0'||SYM#tag-timeval#'timestamp'||*{SYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#}$SYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#$'prot_desc'||U32'ref_count'||U32'$pad1'|]#$'info'||EN#anon_enum$EITHERBOUND=-1$INBOUND=0$OUTBOUND=1#{S32}$S32$'direction'||U32'$pad0'|]
// file pkt_info.h line 63
struct anonymous$62;

// tag-#anon#ST[*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'canvas'||F32'angle'||U32'node_i'||U32'n_nodes'||U32'$pad0'||F64'xmin'||F64'ymin'||F64'xmax'||F64'ymax'||F64'x_rad_max'||F64'y_rad_max'||F64'x_inner_rad_max'||F64'y_inner_rad_max'|]
// file diagram.c line 91
struct anonymous;

// tag-#anon#ST[*{cS8}$cS8$'protocol'||S32'must_resolve'||U32'$pad0'|]
// file node.c line 30
struct anonymous$39;

// tag-#anon#ST[*{cU8}$cU8$'original_packet'||U32'original_len'||U32'$pad0'||*{cU8}$cU8$'cur_packet'||U32'cur_len'||U32'$pad1'||*{SYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#}$SYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#$'pr'||U32'cur_level'||SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'dst_node_id'||SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'src_node_id'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'global_src_address'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'global_dst_address'||U16'global_src_port'||U16'global_dst_port'|]
// file decode_proto.c line 72
struct anonymous$3;

// tag-#anon#ST[*{cU8}$cU8$'p'||U16'offset'||U16'packet_size'||EN#anon_enum$EITHERBOUND=-1$INBOUND=0$OUTBOUND=1#{S32}$S32$'dir'||S32'link_type'||SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'node_id'||SYM#tag-#anon#ST[U8'level'||U56'$pad0'||*{cSYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#}$cSYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#$'tokens'||*{SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#}$SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#$'protos'|]#'decoder'|]
// file names.c line 38
struct anonymous$9;

// tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]
// file pkt_info.h line 38
struct anonymous$2;

// tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]
// file protocols.h line 43
struct anonymous$25;

// tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]
// file node_id.h line 37
struct anonymous$5;

// tag-#anon#ST[F64'average'||F64'aver_accu'||F64'accumulated'||F64'avg_size'||U64'accu_packets'||SYM#tag-timeval#'last_time'|]
// file basic_stats.h line 33
struct anonymous$34;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$41;

// tag-#anon#ST[S32'number'||U32'$pad0'||*{S8}$S8$'name'|]
// file names_netbios.c line 43
struct anonymous$15;

// tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'canvas_node_id'||U32'$pad0'||*{SYM#tag-_GnomeCanvasItem#}$SYM#tag-_GnomeCanvasItem#$'node_item'||*{SYM#tag-_GnomeCanvasItem#}$SYM#tag-_GnomeCanvasItem#$'text_item'||*{SYM#tag-_GnomeCanvasGroup#}$SYM#tag-_GnomeCanvasGroup#$'group_item'||SYM#tag-_GdkColor#'color'||S32'is_new'||S32'shown'||S32'centered'|]
// file diagram.c line 50
struct anonymous$82;

// tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'node_id'||U32'$pad0'||*{SYM#tag-_GString#}$SYM#tag-_GString#$'name'||*{SYM#tag-_GString#}$SYM#tag-_GString#$'numeric_name'||ARR6{*{S8}$S8$}$*{S8}$S8$$'main_prot'||SYM#tag-#anon#ST[SYM#tag-_GQueue#'pkt_list'||SYM#tag-#anon#ST[F64'average'||F64'aver_accu'||F64'accumulated'||F64'avg_size'||U64'accu_packets'||SYM#tag-timeval#'last_time'|]#'stats'||SYM#tag-#anon#ST[F64'average'||F64'aver_accu'||F64'accumulated'||F64'avg_size'||U64'accu_packets'||SYM#tag-timeval#'last_time'|]#'stats_in'||SYM#tag-#anon#ST[F64'average'||F64'aver_accu'||F64'accumulated'||F64'avg_size'||U64'accu_packets'||SYM#tag-timeval#'last_time'|]#'stats_out'||SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#'stats_protos'|]#'node_stats'|]
// file node.h line 25
struct anonymous$19;

// tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'node_id'||U32'$pad0'||*{SYM#tag-_GString#}$SYM#tag-_GString#$'numeric_name'||*{SYM#tag-_GString#}$SYM#tag-_GString#$'res_name'||F64'accumulated'|]
// file node_id.h line 52
struct anonymous$36;

// tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'src'||SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'dst'|]
// file links.h line 26
struct anonymous$16;

// tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'src'||SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'dst'|]#'canvas_link_id'||*{SYM#tag-_GnomeCanvasItem#}$SYM#tag-_GnomeCanvasItem#$'src_item'||*{SYM#tag-_GnomeCanvasItem#}$SYM#tag-_GnomeCanvasItem#$'dst_item'||SYM#tag-_GdkColor#'color'||U32'$pad0'|]
// file diagram.c line 75
struct anonymous$80;

// tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'src'||SYM#tag-#anon#ST[EN#anon_enum$APEMODE_DEFAULT=-1$LINK6=0$IP=1$TCP=2#{S32}$S32$'node_type'||SYM#tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]#'addr'||U16'$pad0'|]#'dst'|]#'link_id'||ARR6{*{S8}$S8$}$*{S8}$S8$$'main_prot'||SYM#tag-#anon#ST[SYM#tag-_GQueue#'pkt_list'||SYM#tag-#anon#ST[F64'average'||F64'aver_accu'||F64'accumulated'||F64'avg_size'||U64'accu_packets'||SYM#tag-timeval#'last_time'|]#'stats'||SYM#tag-#anon#ST[F64'average'||F64'aver_accu'||F64'accumulated'||F64'avg_size'||U64'accu_packets'||SYM#tag-timeval#'last_time'|]#'stats_in'||SYM#tag-#anon#ST[F64'average'||F64'aver_accu'||F64'accumulated'||F64'avg_size'||U64'accu_packets'||SYM#tag-timeval#'last_time'|]#'stats_out'||SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#'stats_protos'|]#'link_stats'|]
// file links.h line 37
struct anonymous$28;

// tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]
// file node_id.h line 28
struct anonymous$1;

// tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'src_address'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'dst_address'||U16'src_port'||U16'dst_port'||U32'$pad0'||*{S8}$S8$'data'|]
// file conversations.h line 21
struct anonymous$61;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]
// file common.h line 89
struct anonymous$20;

// tag-#anon#ST[SYM#tag-_GQueue#'pkt_list'||SYM#tag-#anon#ST[F64'average'||F64'aver_accu'||F64'accumulated'||F64'avg_size'||U64'accu_packets'||SYM#tag-timeval#'last_time'|]#'stats'||SYM#tag-#anon#ST[F64'average'||F64'aver_accu'||F64'accumulated'||F64'avg_size'||U64'accu_packets'||SYM#tag-timeval#'last_time'|]#'stats_in'||SYM#tag-#anon#ST[F64'average'||F64'aver_accu'||F64'accumulated'||F64'avg_size'||U64'accu_packets'||SYM#tag-timeval#'last_time'|]#'stats_out'||SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#'stats_protos'|]
// file traffic_stats.h line 26
struct anonymous$27;

// tag-#anon#ST[SYM#tag-_GdkColor#'color'||S32'preferred'|]
// file datastructs.h line 29
struct anonymous$64;

// tag-#anon#ST[U16'port'||U48'$pad0'||*{S8}$S8$'name'||S32'preferred'||U32'$pad1'|]
// file datastructs.h line 58
struct anonymous$21;

// tag-#anon#ST[U32'size'||U32'$pad0'||SYM#tag-timeval#'timestamp'||*{SYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#}$SYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#$'prot_desc'||U32'ref_count'||U32'$pad1'|]
// file pkt_info.h line 50
struct anonymous$6;

// tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]
// file common.h line 93
struct anonymous$38;

// tag-#anon#ST[U8'level'||U56'$pad0'||*{cSYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#}$cSYM#tag-#anon#ST[ARR6{*{S8}$S8$}$*{S8}$S8$$'protonames'|]#$'tokens'||*{SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#}$SYM#tag-#anon#ST[ARR6{*{SYM#tag-_GList#}$SYM#tag-_GList#$}$*{SYM#tag-_GList#}$SYM#tag-_GList#$$'protostack'|]#$'protos'|]
// file names.c line 47
struct anonymous$10;

// tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]
// file common.h line 96
union anonymous$37;

// tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 445
union anonymous$51;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$43;

// tag-#anon#UN[ARR6{U8}$U8$'eth'||SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'ip'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]#'$anon0'|]#'host'||U16'port'|]#'tcp4'|]
// file node_id.h line 24
union anonymous$81;

// tag-#anon#UN[S32'v_int'||U32'v_uint'||S64'v_long'||U64'v_ulong'||S64'v_int64'||U64'v_uint64'||F32'v_float'||F64'v_double'||*{V}$V$'v_pointer'|]
// file /usr/include/glib-2.0/gobject/gvalue.h line 112
union anonymous$68;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$42;

// tag-#anon#UN[SYM#tag-#anon#ST[U32'type'||SYM#tag-#anon#UN[ARR16{U8}$U8$'addr8'||ARR4{U32}$U32$'addr32'||U32'addr32_v4'||ARR4{U8}$U8$'addr_v4'||ARR16{U8}$U8$'addr_v6'|]#'$anon0'|]#'$anon0'||ARR20{U8}$U8$'all8'|]
// file common.h line 91
union anonymous$35;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$40;

// tag-IPCACHE_STATE
// file ip-cache.h line 26
enum IPCACHE_STATE { IPCACHE_STATE_FINISHED=0, IPCACHE_STATE_FAILED=1, IPCACHE_STATE_PTRREQ=2 };

// tag-NTTraverse
// file node_windows.c line 312
struct NTTraverse;

// tag-_ArtUta
// file /usr/include/libart-2.0/libart_lgpl/art_uta.h line 36
struct _ArtUta;

// tag-_EATreePos
// file pref_dialog.c line 480
struct _EATreePos;

// tag-_GArray
// file /usr/include/glib-2.0/glib/garray.h line 37
struct _GArray;

// tag-_GClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 74
struct _GClosure;

// tag-_GClosureNotifyData
// file /usr/include/glib-2.0/gobject/gclosure.h line 75
struct _GClosureNotifyData;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GError
// file /usr/include/glib-2.0/glib/gerror.h line 42
struct _GError;

// tag-_GHashTable
// file /usr/include/glib-2.0/glib/ghash.h line 37
struct _GHashTable;

// tag-_GKeyFile
// file /usr/include/glib-2.0/glib/gkeyfile.h line 48
struct _GKeyFile;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GObjectClass
// file /usr/include/glib-2.0/gobject/gobject.h line 188
struct _GObjectClass;

// tag-_GObjectConstructParam
// file /usr/include/glib-2.0/gobject/gobject.h line 191
struct _GObjectConstructParam;

// tag-_GOptionGroup
// file /usr/include/glib-2.0/glib/goption.h line 51
struct _GOptionGroup;

// tag-_GParamSpec
// file /usr/include/glib-2.0/gobject/gparam.h line 193
struct _GParamSpec;

// tag-_GQueue
// file /usr/include/glib-2.0/glib/gqueue.h line 36
struct _GQueue;

// tag-_GSList
// file /usr/include/glib-2.0/glib/gslist.h line 37
struct _GSList;

// tag-_GString
// file /usr/include/glib-2.0/glib/gstring.h line 39
struct _GString;

// tag-_GTree
// file /usr/include/glib-2.0/glib/gtree.h line 36
struct _GTree;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_GValue
// file /usr/include/glib-2.0/gobject/gtype.h line 386
struct _GValue;

// tag-_GdkAtom
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 80
struct _GdkAtom;

// tag-_GdkColor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 102
struct _GdkColor;

// tag-_GdkColormap
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 103
struct _GdkColormap;

// tag-_GdkDevice
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 47
struct _GdkDevice;

// tag-_GdkDeviceAxis
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 46
struct _GdkDeviceAxis;

// tag-_GdkDeviceKey
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 45
struct _GdkDeviceKey;

// tag-_GdkDragContext
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 38
struct _GdkDragContext;

// tag-_GdkDrawable
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 111
struct _GdkDrawable;

// tag-_GdkEvent
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 68
union _GdkEvent;

// tag-_GdkEventAny
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 47
struct _GdkEventAny;

// tag-_GdkEventButton
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 52
struct _GdkEventButton;

// tag-_GdkEventClient
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 62
struct _GdkEventClient;

// tag-_GdkEventConfigure
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 57
struct _GdkEventConfigure;

// tag-_GdkEventCrossing
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 56
struct _GdkEventCrossing;

// tag-_GdkEventDND
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 63
struct _GdkEventDND;

// tag-_GdkEventExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 48
struct _GdkEventExpose;

// tag-_GdkEventFocus
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 55
struct _GdkEventFocus;

// tag-_GdkEventGrabBroken
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 66
struct _GdkEventGrabBroken;

// tag-_GdkEventKey
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 54
struct _GdkEventKey;

// tag-_GdkEventMotion
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 51
struct _GdkEventMotion;

// tag-_GdkEventNoExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 49
struct _GdkEventNoExpose;

// tag-_GdkEventOwnerChange
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 60
struct _GdkEventOwnerChange;

// tag-_GdkEventProperty
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 58
struct _GdkEventProperty;

// tag-_GdkEventProximity
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 61
struct _GdkEventProximity;

// tag-_GdkEventScroll
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 53
struct _GdkEventScroll;

// tag-_GdkEventSelection
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 59
struct _GdkEventSelection;

// tag-_GdkEventSetting
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 65
struct _GdkEventSetting;

// tag-_GdkEventVisibility
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 50
struct _GdkEventVisibility;

// tag-_GdkEventWindowState
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 64
struct _GdkEventWindowState;

// tag-_GdkFont
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 105
struct _GdkFont;

// tag-_GdkGC
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 106
struct _GdkGC;

// tag-_GdkRectangle
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 69
struct _GdkRectangle;

// tag-_GdkRegion
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 108
struct _GdkRegion;

// tag-_GdkScreen
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 116
struct _GdkScreen;

// tag-_GdkVisual
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 109
struct _GdkVisual;

// tag-_GladeXML
// file /usr/include/libglade-2.0/glade/glade-xml.h line 37
struct _GladeXML;

// tag-_GladeXMLPrivate
// file /usr/include/libglade-2.0/glade/glade-xml.h line 39
struct _GladeXMLPrivate;

// tag-_GnomeCanvas
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 70
struct _GnomeCanvas;

// tag-_GnomeCanvasGroup
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 74
struct _GnomeCanvasGroup;

// tag-_GnomeCanvasItem
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 72
struct _GnomeCanvasItem;

// tag-_GnomeCanvasPoints
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas-util.h line 45
struct _GnomeCanvasPoints;

// tag-_GnomeClient
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-client.h line 46
struct _GnomeClient;

// tag-_GnomeModuleInfo
// file /usr/include/libgnome-2.0/libgnome/gnome-program.h line 144
struct _GnomeModuleInfo;

// tag-_GnomeModuleRequirement
// file /usr/include/libgnome-2.0/libgnome/gnome-program.h line 145
struct _GnomeModuleRequirement;

// tag-_GnomeProgram
// file /usr/include/libgnome-2.0/libgnome/gnome-program.h line 52
struct _GnomeProgram;

// tag-_GnomeProgramClass
// file /usr/include/libgnome-2.0/libgnome/gnome-program.h line 54
struct _GnomeProgramClass;

// tag-_GnomeProgramPrivate
// file /usr/include/libgnome-2.0/libgnome/gnome-program.h line 53
struct _GnomeProgramPrivate;

// tag-_GtkAboutDialog
// file /usr/include/gtk-2.0/gtk/gtkaboutdialog.h line 43
struct _GtkAboutDialog;

// tag-_GtkAdjustment
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 48
struct _GtkAdjustment;

// tag-_GtkBin
// file /usr/include/gtk-2.0/gtk/gtkbin.h line 48
struct _GtkBin;

// tag-_GtkBox
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 49
struct _GtkBox;

// tag-_GtkButton
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 48
struct _GtkButton;

// tag-_GtkCellEditable
// file /usr/include/gtk-2.0/gtk/gtkcelleditable.h line 37
struct _GtkCellEditable;

// tag-_GtkCellRenderer
// file /usr/include/gtk-2.0/gtk/gtkcellrenderer.h line 55
struct _GtkCellRenderer;

// tag-_GtkCheckMenuItem
// file /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h line 48
struct _GtkCheckMenuItem;

// tag-_GtkColorButton
// file /usr/include/gtk-2.0/gtk/gtkcolorbutton.h line 58
struct _GtkColorButton;

// tag-_GtkColorButtonPrivate
// file /usr/include/gtk-2.0/gtk/gtkcolorbutton.h line 60
struct _GtkColorButtonPrivate;

// tag-_GtkColorSelection
// file /usr/include/gtk-2.0/gtk/gtkcolorsel.h line 48
struct _GtkColorSelection;

// tag-_GtkColorSelectionDialog
// file /usr/include/gtk-2.0/gtk/gtkcolorseldialog.h line 48
struct _GtkColorSelectionDialog;

// tag-_GtkComboBox
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 40
struct _GtkComboBox;

// tag-_GtkComboBoxEntry
// file /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h line 41
struct _GtkComboBoxEntry;

// tag-_GtkComboBoxEntryPrivate
// file /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h line 43
struct _GtkComboBoxEntryPrivate;

// tag-_GtkComboBoxPrivate
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 42
struct _GtkComboBoxPrivate;

// tag-_GtkContainer
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 51
struct _GtkContainer;

// tag-_GtkDialog
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 94
struct _GtkDialog;

// tag-_GtkEntry
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 63
struct _GtkEntry;

// tag-_GtkFileChooser
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 37
struct _GtkFileChooser;

// tag-_GtkFontButton
// file /usr/include/gtk-2.0/gtk/gtkfontbutton.h line 49
struct _GtkFontButton;

// tag-_GtkFontButtonPrivate
// file /usr/include/gtk-2.0/gtk/gtkfontbutton.h line 51
struct _GtkFontButtonPrivate;

// tag-_GtkHBox
// file /usr/include/gtk-2.0/gtk/gtkhbox.h line 48
struct _GtkHBox;

// tag-_GtkIMContext
// file /usr/include/gtk-2.0/gtk/gtkimcontext.h line 42
struct _GtkIMContext;

// tag-_GtkItem
// file /usr/include/gtk-2.0/gtk/gtkitem.h line 48
struct _GtkItem;

// tag-_GtkLabel
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 49
struct _GtkLabel;

// tag-_GtkLabelSelectionInfo
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 52
struct _GtkLabelSelectionInfo;

// tag-_GtkLayout
// file /usr/include/gtk-2.0/gtk/gtklayout.h line 53
struct _GtkLayout;

// tag-_GtkListStore
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 42
struct _GtkListStore;

// tag-_GtkMenuItem
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 48
struct _GtkMenuItem;

// tag-_GtkMenuShell
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 48
struct _GtkMenuShell;

// tag-_GtkMisc
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 48
struct _GtkMisc;

// tag-_GtkObject
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 49
struct _GtkObject;

// tag-_GtkRadioMenuItem
// file /usr/include/gtk-2.0/gtk/gtkradiomenuitem.h line 48
struct _GtkRadioMenuItem;

// tag-_GtkRange
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 53
struct _GtkRange;

// tag-_GtkRangeLayout
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 50
struct _GtkRangeLayout;

// tag-_GtkRangeStepTimer
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 51
struct _GtkRangeStepTimer;

// tag-_GtkRcStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 57
struct _GtkRcStyle;

// tag-_GtkRecentManager
// file /usr/include/gtk-2.0/gtk/gtkrecentmanager.h line 45
struct _GtkRecentManager;

// tag-_GtkRecentManagerPrivate
// file /usr/include/gtk-2.0/gtk/gtkrecentmanager.h line 47
struct _GtkRecentManagerPrivate;

// tag-_GtkRequisition
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 478
struct _GtkRequisition;

// tag-_GtkSpinButton
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 71
struct _GtkSpinButton;

// tag-_GtkStatusbar
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 47
struct _GtkStatusbar;

// tag-_GtkStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 54
struct _GtkStyle;

// tag-_GtkToggleButton
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 48
struct _GtkToggleButton;

// tag-_GtkTreeIter
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 43
struct _GtkTreeIter;

// tag-_GtkTreeModel
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 46
struct _GtkTreeModel;

// tag-_GtkTreeModelSort
// file /usr/include/gtk-2.0/gtk/gtktreemodelsort.h line 40
struct _GtkTreeModelSort;

// tag-_GtkTreePath
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 44
struct _GtkTreePath;

// tag-_GtkTreeSortable
// file /usr/include/gtk-2.0/gtk/gtktreesortable.h line 45
struct _GtkTreeSortable;

// tag-_GtkTreeView
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 55
struct _GtkTreeView;

// tag-_GtkTreeViewColumn
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 52
struct _GtkTreeViewColumn;

// tag-_GtkTreeViewPrivate
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 57
struct _GtkTreeViewPrivate;

// tag-_GtkVBox
// file /usr/include/gtk-2.0/gtk/gtkvbox.h line 48
struct _GtkVBox;

// tag-_GtkWidget
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 69
struct _GtkWidget;

// tag-_GtkWindow
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 485
struct _GtkWindow;

// tag-_GtkWindowGeometryInfo
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 50
struct _GtkWindowGeometryInfo;

// tag-_GtkWindowGroup
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 51
struct _GtkWindowGroup;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_PangoAttrList
// file /usr/include/pango-1.0/pango/pango-attributes.h line 111
struct _PangoAttrList;

// tag-_PangoFontDescription
// file /usr/include/pango-1.0/pango/pango-font.h line 40
struct _PangoFontDescription;

// tag-_PangoLayout
// file /usr/include/pango-1.0/pango/pango-layout.h line 32
struct _PangoLayout;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_cairo_font_options
// file /usr/include/cairo/cairo.h line 1366
struct _cairo_font_options;

// tag-_ether
// file resolv.c line 103
struct _ether;

// tag-appdata_struct
// file appdata.h line 30
struct appdata_struct;

// tag-bpf_insn
// file /usr/include/pcap/bpf.h line 108
struct bpf_insn;

// tag-bpf_program
// file /usr/include/pcap/bpf.h line 106
struct bpf_program;

// tag-hashether
// file resolv.c line 92
struct hashether;

// tag-hashmanuf
// file resolv.c line 84
struct hashmanuf;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-ipcache_item
// file ip-cache.h line 33
struct ipcache_item;

// tag-ipresolve_link
// file thread_resolve.c line 62
struct ipresolve_link;

// tag-linktype_data_tag
// file decode_proto.c line 149
struct linktype_data_tag;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pcap
// file /usr/include/pcap/pcap.h line 79
struct pcap;

// tag-pcap_addr
// file /usr/include/pcap/pcap.h line 82
struct pcap_addr;

// tag-pcap_if
// file /usr/include/pcap/pcap.h line 81
struct pcap_if;

// tag-pcap_pkthdr
// file /usr/include/pcap/pcap.h line 160
struct pcap_pkthdr;

// tag-pcap_stat
// file /usr/include/pcap/pcap.h line 169
struct pcap_stat;

// tag-poptContext_s
// file /usr/include/popt.h line 200
struct poptContext_s;

// tag-poptOption
// file /usr/include/popt.h line 125
struct poptOption;

// tag-pref_struct
// file preferences.h line 29
struct pref_struct;

// tag-protocol_list_item_t_tag
// file info_windows.c line 58
struct protocol_list_item_t_tag;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rpc_program
// file decode_proto.c line 55
enum rpc_program { PORTMAP_PROGRAM=100000, NFS_PROGRAM=100003, YPSERV_PROGRAM=100004, MOUNT_PROGRAM=100005, YPBIND_PROGRAM=100007, YPPASSWD_PROGRAM=100009, REXEC_PROGRAM=100017, STAT_PROGRAM=100024, BOOTPARAMS_PROGRAM=100026, NLM_PROGRAM=100021, YPXFR_PROGRAM=100069, KERBPROG_PROGRAM=100078 };

// tag-rpc_type
// file decode_proto.c line 49
enum rpc_type { RPC_CALL=0, RPC_REPLY=1 };

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-status_t
// file capture.h line 23
enum status_t { STOP=0, PLAY=1, PAUSE=2, CAP_EOF=3 };

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// _IO_getc
// file /usr/include/libio.h line 434
extern signed int _IO_getc(struct _IO_FILE *);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// active_conversations
// file conversations.h line 39
signed long int active_conversations(void);
// active_names
// file node_id.h line 69
signed long int active_names(void);
// add_conversation
// file conversations.h line 31
void add_conversation(struct anonymous$20 *src_address, struct anonymous$20 *dst_address, unsigned short int src_port, unsigned short int dst_port, const char *data);
// add_manuf_name
// file resolv.c line 338
static void add_manuf_name(unsigned char *addr, char *name);
// add_name
// file names.c line 631
static void add_name(const char *numeric_name, const char *resolved_name, const struct anonymous$5 *node_id, const struct anonymous$9 *nt);
// add_node_packet
// file decode_proto.c line 328
static void add_node_packet(const unsigned char *raw_packet, unsigned int raw_size, struct anonymous$6 *packet, const struct anonymous$5 *node_id, enum anonymous$7 direction);
// add_offset
// file decode_proto.c line 247
static void add_offset(struct anonymous$3 *dp, unsigned int offset);
// add_ordered_node
// file diagram.c line 865
static signed int add_ordered_node(struct anonymous$5 *node_id, struct anonymous$82 *node, struct _GTree *ordered_nodes);
// addref_canvas_obj
// file diagram.c line 209
static void addref_canvas_obj(struct _GObject *obj);
// address_to_str
// file util.c line 366
const char * address_to_str(const struct anonymous$20 *ad);
// appdata_free
// file appdata.c line 76
void appdata_free(struct appdata_struct *p);
// appdata_init
// file appdata.h line 66
void appdata_init(struct appdata_struct *p);
// appdata_init_glade
// file appdata.h line 67
signed int appdata_init_glade(char *new_glade_file);
// append_etype_prot
// file decode_proto.c line 1652
static void append_etype_prot(struct anonymous$3 *dp, enum anonymous$8 etype);
// asin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 56
extern double asin(double);
// ask_reposition
// file diagram.h line 33
void ask_reposition(signed int r_font);
// basic_stats_add
// file basic_stats.h line 44
void basic_stats_add(struct anonymous$34 *tf_stat, double val);
// basic_stats_avg
// file basic_stats.h line 46
void basic_stats_avg(struct anonymous$34 *tf_stat, double avg_msecs);
// basic_stats_dump
// file basic_stats.h line 47
char * basic_stats_dump(const struct anonymous$34 *tf_stat);
// basic_stats_reset
// file basic_stats.h line 43
void basic_stats_reset(struct anonymous$34 *tf_stat);
// basic_stats_sub
// file basic_stats.h line 45
void basic_stats_sub(struct anonymous$34 *tf_stat, double val);
// basic_stats_xml
// file basic_stats.h line 48
char * basic_stats_xml(const struct anonymous$34 *tf_stat);
// bind_textdomain_codeset
// file /usr/include/libintl.h line 91
extern char * bind_textdomain_codeset(const char *, const char *);
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// canvas_link_compare
// file diagram.c line 1434
static signed int canvas_link_compare(const struct anonymous$16 *a, const struct anonymous$16 *b, void *dummy);
// canvas_link_delete
// file diagram.c line 1443
static void canvas_link_delete(struct anonymous$80 *canvas_link);
// canvas_link_update
// file diagram.c line 1141
static signed int canvas_link_update(struct anonymous$16 *link_id, struct anonymous$80 *canvas_link, struct _GList **delete_list);
// canvas_node_compare
// file diagram.c line 1426
static signed int canvas_node_compare(const struct anonymous$5 *a, const struct anonymous$5 *b, void *dummy);
// canvas_node_delete
// file diagram.c line 282
static void canvas_node_delete(struct anonymous$82 *canvas_node);
// canvas_node_update
// file diagram.c line 693
static signed int canvas_node_update(struct anonymous$5 *node_id, struct anonymous$82 *canvas_node, struct _GList **delete_list);
// cap_t_o_destroy
// file capture.c line 471
static void cap_t_o_destroy(void *data);
// cbox_add_select
// file pref_dialog.c line 830
static void cbox_add_select(struct _GtkComboBoxEntry *cbox, const char *str);
// change_refresh_period
// file pref_dialog.c line 866
void change_refresh_period(unsigned int newperiod);
// check_new_link
// file diagram.c line 1086
static signed int check_new_link(struct anonymous$16 *link_id, struct anonymous$28 *link, struct _GtkWidget *canvas);
// check_new_node
// file diagram.c line 613
static signed int check_new_node(struct anonymous$19 *node, struct _GtkWidget *canvas);
// check_new_protocol
// file diagram.c line 520
static void check_new_protocol(struct _GtkWidget *prot_table, const struct anonymous$25 *pstk);
// check_ordered_node
// file diagram.c line 875
static signed int check_ordered_node(double *traffic, struct anonymous$82 *node, unsigned int *count);
// choose_port
// file decode_proto.c line 1634
static unsigned short int choose_port(unsigned short int a, unsigned short int b);
// cleanup
// file main.c line 407
void cleanup(signed int signum);
// cleanup_capture
// file capture.h line 37
void cleanup_capture(void);
// clock
// file /usr/include/time.h line 189
extern signed long int clock(void);
// close_mutex
// file thread_resolve.c line 87
static void close_mutex(void);
// color_list_to_pref
// file pref_dialog.c line 786
static void color_list_to_pref(void);
// config_file_name
// file preferences.c line 84
static char * config_file_name(void);
// confirm_changes
// file pref_dialog.c line 52
static void confirm_changes(void);
// copy_config
// file preferences.c line 358
void copy_config(struct pref_struct *tgt, struct pref_struct *src);
// cos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern double cos(double);
// create_add_text_column
// file ui_utils.h line 56
void create_add_text_column(struct _GtkTreeView *gv, const char *title, signed int colno, signed int r_just);
// create_prot_info_window
// file info_windows.c line 98
static void create_prot_info_window(struct anonymous$26 *protocol);
// create_protocols_table
// file info_windows.c line 356
static struct _GtkListStore * create_protocols_table(struct _GtkWidget *window);
// dcgettext
// file /usr/include/libintl.h line 51
extern char * dcgettext(const char *, const char *, signed int);
// decode_next
// file names.c line 153
static void decode_next(struct anonymous$9 *nt);
// decode_proto_add
// file decode_proto.c line 233
static void decode_proto_add(struct anonymous$3 *dp, const char *fmt, ...);
// decode_proto_start
// file decode_proto.c line 218
static void decode_proto_start(struct anonymous$3 *dp, const unsigned char *pkt, unsigned int caplen);
// decode_wlan_mgmt
// file decode_proto.c line 646
static void decode_wlan_mgmt(struct anonymous$3 *dp, unsigned char subtype);
// delete_conversation_link
// file conversations.h line 35
void delete_conversation_link(struct anonymous$20 *src_address, struct anonymous$20 *dst_address);
// delete_conversations
// file conversations.h line 37
void delete_conversations(void);
// delete_gui_protocols
// file diagram.h line 32
void delete_gui_protocols(void);
// destroying_idle
// file diagram.h line 30
void destroying_idle(void *data);
// destroying_timeout
// file diagram.c line 261
void destroying_timeout(void *data);
// diagram_update_links
// file diagram.c line 367
static void diagram_update_links(struct _GtkWidget *canvas);
// diagram_update_nodes
// file diagram.c line 321
static void diagram_update_nodes(struct _GtkWidget *canvas);
// display_node
// file diagram.c line 811
static signed int display_node(struct anonymous$19 *node);
// dns_close
// file dns.c line 35
void dns_close(void);
// dns_lookup
// file dns.c line 41
const char * dns_lookup(struct anonymous$20 *address);
// dns_open
// file dns.c line 29
signed int dns_open(void);
// draw_oneside_link
// file diagram.c line 1221
static void draw_oneside_link(double xs, double ys, double xd, double yd, const struct anonymous$34 *link_stats, unsigned int scaledColor, struct _GnomeCanvasItem *item);
// dump_stats
// file diagram.h line 34
void dump_stats(unsigned int diff_msecs);
// dump_xml
// file export.c line 87
void dump_xml(char *ofile);
// duplicate_config
// file preferences.c line 324
struct pref_struct * duplicate_config(struct pref_struct *src);
// end_ethent
// file resolv.c line 278
static void end_ethent(void);
// eth_name_common
// file names.c line 269
static signed int eth_name_common(enum anonymous$13 ethmode, struct anonymous$9 *nt);
// eth_name_lookup
// file resolv.c line 426
static const char * eth_name_lookup(const unsigned char *addr, signed int only_ethers);
// ether_to_str
// file util.h line 51
const char * ether_to_str(const unsigned char *ad);
// ether_to_str_punct
// file util.c line 262
static const char * ether_to_str_punct(const unsigned char *ad, char punct);
// ethereal_nbns_name
// file names_netbios.h line 40
signed int ethereal_nbns_name(const char *pd, signed int offset, signed int pd_len, char *outname, unsigned long int outname_size, signed int *name_type_ret);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exp
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 100
extern double exp(double);
// fatal_error_dialog
// file menus.c line 619
void fatal_error_dialog(const char *message);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fgetline
// file resolv.c line 129
static signed int fgetline(char **buf, signed int *size, struct _IO_FILE *fp);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fill_node_id
// file names.c line 195
static void fill_node_id(struct anonymous$5 *node_id, enum anonymous$13 apemode, const struct anonymous$9 *nt, signed int disp, signed int portdisp, signed int type);
// finalize_callback
// file diagram.c line 203
static void finalize_callback(void *data, struct _GObject *obj);
// find_conversation
// file conversations.h line 33
const char * find_conversation(struct anonymous$20 *src_address, struct anonymous$20 *dst_address, unsigned short int src_port, unsigned short int dst_port);
// find_conversation_ptr
// file conversations.c line 45
static struct _GList * find_conversation_ptr(struct anonymous$20 *src_address, struct anonymous$20 *dst_address, unsigned short int src_port, unsigned short int dst_port);
// floor
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 184
extern double floor(double);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// force_next_packet
// file capture.h line 38
void force_next_packet(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_config
// file preferences.c line 342
void free_config(struct pref_struct *t);
// free_static_data
// file main.c line 295
static void free_static_data(void);
// freehash
// file datastructs.c line 57
static void freehash(void *data);
// g_ascii_strcasecmp
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 183
extern signed int g_ascii_strcasecmp(const char *, const char *);
// g_ascii_strup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 193
extern char * g_ascii_strup(const char *, signed long int);
// g_assertion_message_expr
// file /usr/include/glib-2.0/glib/gtestutils.h line 302
extern void g_assertion_message_expr(const char *, const char *, signed int, const char *, const char *);
// g_file_set_contents
// file /usr/include/glib-2.0/glib/gfileutils.h line 90
extern signed int g_file_set_contents(const char *, const char *, signed long int, struct _GError **);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_get_home_dir
// file /usr/include/glib-2.0/glib/gutils.h line 90
extern const char * g_get_home_dir(void);
// g_get_user_config_dir
// file /usr/include/glib-2.0/glib/gutils.h line 109
extern const char * g_get_user_config_dir(void);
// g_getenv
// file /usr/include/glib-2.0/glib/genviron.h line 37
extern const char * g_getenv(const char *);
// g_hash_table_destroy
// file /usr/include/glib-2.0/glib/ghash.h line 65
extern void g_hash_table_destroy(struct _GHashTable *);
// g_hash_table_insert
// file /usr/include/glib-2.0/glib/ghash.h line 67
extern signed int g_hash_table_insert(struct _GHashTable *, void *, void *);
// g_hash_table_lookup
// file /usr/include/glib-2.0/glib/ghash.h line 88
extern void * g_hash_table_lookup(struct _GHashTable *, const void *);
// g_hash_table_new_full
// file /usr/include/glib-2.0/glib/ghash.h line 60
extern struct _GHashTable * g_hash_table_new_full(unsigned int (*)(const void *), signed int (*)(const void *, const void *), void (*)(void *), void (*)(void *));
// g_idle_add_full
// file /usr/include/glib-2.0/glib/gmain.h line 587
extern unsigned int g_idle_add_full(signed int, signed int (*)(void *), void *, void (*)(void *));
// g_key_file_free
// file /usr/include/glib-2.0/glib/gkeyfile.h line 64
extern void g_key_file_free(struct _GKeyFile *);
// g_key_file_get_boolean
// file /usr/include/glib-2.0/glib/gkeyfile.h line 151
extern signed int g_key_file_get_boolean(struct _GKeyFile *, const char *, const char *, struct _GError **);
// g_key_file_get_double
// file /usr/include/glib-2.0/glib/gkeyfile.h line 191
extern double g_key_file_get_double(struct _GKeyFile *, const char *, const char *, struct _GError **);
// g_key_file_get_integer
// file /usr/include/glib-2.0/glib/gkeyfile.h line 161
extern signed int g_key_file_get_integer(struct _GKeyFile *, const char *, const char *, struct _GError **);
// g_key_file_get_string
// file /usr/include/glib-2.0/glib/gkeyfile.h line 129
extern char * g_key_file_get_string(struct _GKeyFile *, const char *, const char *, struct _GError **);
// g_key_file_load_from_file
// file /usr/include/glib-2.0/glib/gkeyfile.h line 69
extern signed int g_key_file_load_from_file(struct _GKeyFile *, const char *, enum anonymous$71, struct _GError **);
// g_key_file_new
// file /usr/include/glib-2.0/glib/gkeyfile.h line 58
extern struct _GKeyFile * g_key_file_new(void);
// g_key_file_set_boolean
// file /usr/include/glib-2.0/glib/gkeyfile.h line 156
extern void g_key_file_set_boolean(struct _GKeyFile *, const char *, const char *, signed int);
// g_key_file_set_double
// file /usr/include/glib-2.0/glib/gkeyfile.h line 196
extern void g_key_file_set_double(struct _GKeyFile *, const char *, const char *, double);
// g_key_file_set_integer
// file /usr/include/glib-2.0/glib/gkeyfile.h line 166
extern void g_key_file_set_integer(struct _GKeyFile *, const char *, const char *, signed int);
// g_key_file_set_string
// file /usr/include/glib-2.0/glib/gkeyfile.h line 134
extern void g_key_file_set_string(struct _GKeyFile *, const char *, const char *, const char *);
// g_key_file_to_data
// file /usr/include/glib-2.0/glib/gkeyfile.h line 93
extern char * g_key_file_to_data(struct _GKeyFile *, unsigned long int *, struct _GError **);
// g_list_delete_link
// file /usr/include/glib-2.0/glib/glist.h line 94
extern struct _GList * g_list_delete_link(struct _GList *, struct _GList *);
// g_list_find_custom
// file /usr/include/glib-2.0/glib/glist.h line 116
extern struct _GList * g_list_find_custom(struct _GList *, const void *, signed int (*)(const void *, const void *));
// g_list_first
// file /usr/include/glib-2.0/glib/glist.h line 128
extern struct _GList * g_list_first(struct _GList *);
// g_list_foreach
// file /usr/include/glib-2.0/glib/glist.h line 132
extern void g_list_foreach(struct _GList *, void (*)(void *, void *), void *);
// g_list_free
// file /usr/include/glib-2.0/glib/glist.h line 51
extern void g_list_free(struct _GList *);
// g_list_free_1
// file /usr/include/glib-2.0/glib/glist.h line 53
extern void g_list_free_1(struct _GList *);
// g_list_length
// file /usr/include/glib-2.0/glib/glist.h line 130
extern unsigned int g_list_length(struct _GList *);
// g_list_prepend
// file /usr/include/glib-2.0/glib/glist.h line 62
extern struct _GList * g_list_prepend(struct _GList *, void *);
// g_list_remove
// file /usr/include/glib-2.0/glib/glist.h line 85
extern struct _GList * g_list_remove(struct _GList *, const void *);
// g_list_remove_link
// file /usr/include/glib-2.0/glib/glist.h line 91
extern struct _GList * g_list_remove_link(struct _GList *, struct _GList *);
// g_list_reverse
// file /usr/include/glib-2.0/glib/glist.h line 97
extern struct _GList * g_list_reverse(struct _GList *);
// g_list_sort
// file /usr/include/glib-2.0/glib/glist.h line 136
extern struct _GList * g_list_sort(struct _GList *, signed int (*)(const void *, const void *));
// g_log
// file /usr/include/glib-2.0/glib/gmessages.h line 101
extern void g_log(const char *, enum anonymous$30, const char *, ...);
// g_log_default_handler
// file /usr/include/glib-2.0/glib/gmessages.h line 93
extern void g_log_default_handler(const char *, enum anonymous$30, const char *, void *);
// g_log_set_handler
// file /usr/include/glib-2.0/glib/gmessages.h line 79
extern unsigned int g_log_set_handler(const char *, enum anonymous$30, void (*)(const char *, enum anonymous$30, const char *, void *), void *);
// g_malloc
// file /usr/include/glib-2.0/glib/gmem.h line 78
extern void * g_malloc(unsigned long int);
// g_malloc0
// file /usr/include/glib-2.0/glib/gmem.h line 80
extern void * g_malloc0(unsigned long int);
// g_memdup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 256
extern void * g_memdup(const void *, unsigned int);
// g_object_get
// file /usr/include/glib-2.0/gobject/gobject.h line 436
extern void g_object_get(void *, const char *, ...);
// g_object_get_data
// file /usr/include/glib-2.0/gobject/gobject.h line 551
extern void * g_object_get_data(struct _GObject *, const char *);
// g_object_ref_sink
// file /usr/include/glib-2.0/gobject/gobject.h line 476
extern void * g_object_ref_sink(void *);
// g_object_set
// file /usr/include/glib-2.0/gobject/gobject.h line 432
extern void g_object_set(void *, const char *, ...);
// g_object_set_data
// file /usr/include/glib-2.0/gobject/gobject.h line 554
extern void g_object_set_data(struct _GObject *, const char *, void *);
// g_object_unref
// file /usr/include/glib-2.0/gobject/gobject.h line 480
extern void g_object_unref(void *);
// g_object_weak_ref
// file /usr/include/glib-2.0/gobject/gobject.h line 482
extern void g_object_weak_ref(struct _GObject *, void (*)(void *, struct _GObject *), void *);
// g_queue_init
// file /usr/include/glib-2.0/glib/gqueue.h line 80
extern void g_queue_init(struct _GQueue *);
// g_queue_is_empty
// file /usr/include/glib-2.0/glib/gqueue.h line 84
extern signed int g_queue_is_empty(struct _GQueue *);
// g_queue_peek_tail
// file /usr/include/glib-2.0/glib/gqueue.h line 127
extern void * g_queue_peek_tail(struct _GQueue *);
// g_queue_pop_head
// file /usr/include/glib-2.0/glib/gqueue.h line 118
extern void * g_queue_pop_head(struct _GQueue *);
// g_queue_pop_tail
// file /usr/include/glib-2.0/glib/gqueue.h line 120
extern void * g_queue_pop_tail(struct _GQueue *);
// g_queue_push_head
// file /usr/include/glib-2.0/glib/gqueue.h line 108
extern void g_queue_push_head(struct _GQueue *, void *);
// g_realloc
// file /usr/include/glib-2.0/glib/gmem.h line 82
extern void * g_realloc(void *, unsigned long int);
// g_return_if_fail_warning
// file /usr/include/glib-2.0/glib/gmessages.h line 124
extern void g_return_if_fail_warning(const char *, const char *, const char *);
// g_signal_connect_data
// file /usr/include/glib-2.0/gobject/gsignal.h line 388
extern unsigned long int g_signal_connect_data(void *, const char *, void (*)(void), void *, void (*)(void *, struct _GClosure *), enum anonymous$65);
// g_signal_emit_by_name
// file /usr/include/glib-2.0/gobject/gsignal.h line 327
extern void g_signal_emit_by_name(void *, const char *, ...);
// g_source_remove
// file /usr/include/glib-2.0/glib/gmain.h line 545
extern signed int g_source_remove(unsigned int);
// g_str_equal
// file /usr/include/glib-2.0/glib/ghash.h line 154
extern signed int g_str_equal(const void *, const void *);
// g_str_hash
// file /usr/include/glib-2.0/glib/ghash.h line 157
extern unsigned int g_str_hash(const void *);
// g_strdelimit
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 103
extern char * g_strdelimit(char *, const char *, char);
// g_strdup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 216
extern char * g_strdup(const char *);
// g_strdup_printf
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 218
extern char * g_strdup_printf(const char *, ...);
// g_strdup_vprintf
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 221
extern char * g_strdup_vprintf(const char *, void **);
// g_strdupv
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 283
extern char ** g_strdupv(char **);
// g_strfreev
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 281
extern void g_strfreev(char **);
// g_string_append
// file /usr/include/glib-2.0/glib/gstring.h line 80
extern struct _GString * g_string_append(struct _GString *, const char *);
// g_string_append_printf
// file /usr/include/glib-2.0/glib/gstring.h line 149
extern void g_string_append_printf(struct _GString *, const char *, ...);
// g_string_assign
// file /usr/include/glib-2.0/glib/gstring.h line 66
extern struct _GString * g_string_assign(struct _GString *, const char *);
// g_string_free
// file /usr/include/glib-2.0/glib/gstring.h line 56
extern char * g_string_free(struct _GString *, signed int);
// g_string_new
// file /usr/include/glib-2.0/glib/gstring.h line 49
extern struct _GString * g_string_new(const char *);
// g_string_printf
// file /usr/include/glib-2.0/glib/gstring.h line 140
extern void g_string_printf(struct _GString *, const char *, ...);
// g_strjoin
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 233
extern char * g_strjoin(const char *, ...);
// g_strjoinv
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 278
extern char * g_strjoinv(const char *, char **);
// g_strsplit
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 270
extern char ** g_strsplit(const char *, const char *, signed int);
// g_strsplit_set
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 274
extern char ** g_strsplit_set(const char *, const char *, signed int);
// g_timeout_add
// file /usr/include/glib-2.0/glib/gmain.h line 560
extern unsigned int g_timeout_add(unsigned int, signed int (*)(void *), void *);
// g_timeout_add_full
// file /usr/include/glib-2.0/glib/gmain.h line 554
extern unsigned int g_timeout_add_full(signed int, unsigned int, signed int (*)(void *), void *, void (*)(void *));
// g_tree_destroy
// file /usr/include/glib-2.0/glib/gtree.h line 59
extern void g_tree_destroy(struct _GTree *);
// g_tree_foreach
// file /usr/include/glib-2.0/glib/gtree.h line 83
extern void g_tree_foreach(struct _GTree *, signed int (*)(void *, void *, void *), void *);
// g_tree_insert
// file /usr/include/glib-2.0/glib/gtree.h line 61
extern void g_tree_insert(struct _GTree *, void *, void *);
// g_tree_lookup
// file /usr/include/glib-2.0/glib/gtree.h line 75
extern void * g_tree_lookup(struct _GTree *, const void *);
// g_tree_new
// file /usr/include/glib-2.0/glib/gtree.h line 45
extern struct _GTree * g_tree_new(signed int (*)(const void *, const void *));
// g_tree_new_full
// file /usr/include/glib-2.0/glib/gtree.h line 50
extern struct _GTree * g_tree_new_full(signed int (*)(const void *, const void *, void *), void *, void (*)(void *), void (*)(void *));
// g_tree_nnodes
// file /usr/include/glib-2.0/glib/gtree.h line 100
extern signed int g_tree_nnodes(struct _GTree *);
// g_tree_remove
// file /usr/include/glib-2.0/glib/gtree.h line 69
extern signed int g_tree_remove(struct _GTree *, const void *);
// g_tree_replace
// file /usr/include/glib-2.0/glib/gtree.h line 65
extern void g_tree_replace(struct _GTree *, void *, void *);
// g_type_check_instance_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2168
extern struct _GTypeInstance * g_type_check_instance_cast(struct _GTypeInstance *, unsigned long int);
// g_utf8_strup
// file /usr/include/glib-2.0/glib/gunicode.h line 795
extern char * g_utf8_strup(const char *, signed long int);
// gdk_color_get_type
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 143
unsigned long int gdk_color_get_type(void);
// gdk_color_parse
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 136
signed int gdk_color_parse(const char *, struct _GdkColor *);
// gdk_color_to_string
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 141
char * gdk_color_to_string(const struct _GdkColor *);
// gdk_colormap_alloc_color
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 121
signed int gdk_colormap_alloc_color(struct _GdkColormap *, struct _GdkColor *, signed int, signed int);
// gdk_colormap_get_system
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 100
struct _GdkColormap * gdk_colormap_get_system(void);
// gdk_input_add
// file /usr/include/gtk-2.0/gdk/gdk.h line 105
signed int gdk_input_add(signed int, enum anonymous$4, void (*)(void *, signed int, enum anonymous$4), void *);
// gdk_input_callback
// file capture.c line 486
static void gdk_input_callback(void *dummy, signed int source, enum anonymous$4 condition);
// gdk_input_remove
// file /usr/include/gtk-2.0/gdk/gdk.h line 109
void gdk_input_remove(signed int);
// gdk_window_raise
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 377
void gdk_window_raise(struct _GdkDrawable *);
// generate_xml
// file export.c line 59
char * generate_xml(void);
// get_arp_name
// file names.c line 313
static signed int get_arp_name(struct anonymous$9 *nt);
// get_capture_status
// file capture.h line 31
enum status_t get_capture_status(void);
// get_color_store
// file pref_dialog.c line 491
static signed int get_color_store(struct _EATreePos *ep);
// get_default_filter
// file capture.h line 40
char * get_default_filter(enum anonymous$13 mode);
// get_dns_name
// file names_netbios.c line 102
static signed int get_dns_name(const char *pd, signed int offset, signed int pd_len, char *name, signed int maxname);
// get_eth_802_3
// file decode_proto.c line 485
static void get_eth_802_3(struct anonymous$3 *dp, enum anonymous$11 ethhdr_type);
// get_eth_II
// file decode_proto.c line 561
static void get_eth_II(struct anonymous$3 *dp, enum anonymous$8 etype);
// get_eth_type
// file decode_proto.c line 392
static void get_eth_type(struct anonymous$3 *dp);
// get_ethbyaddr
// file resolv.c line 311
static const struct _ether * get_ethbyaddr(const unsigned char *addr);
// get_ethent
// file resolv.c line 288
static struct _ether * get_ethent(signed int six_bytes);
// get_ether_name
// file resolv.c line 500
extern const char * get_ether_name(const unsigned char *addr, signed int only_ethers);
// get_fddi_type
// file decode_proto.c line 501
static void get_fddi_type(struct anonymous$3 *dp);
// get_ftp
// file decode_proto.c line 1569
static void get_ftp(struct anonymous$3 *dp);
// get_home_dir
// file util.h line 38
const char * get_home_dir(void);
// get_ieee802_5_type
// file decode_proto.c line 531
static void get_ieee802_5_type(struct anonymous$3 *dp);
// get_ip
// file decode_proto.c line 952
static void get_ip(struct anonymous$3 *dp);
// get_ip_name
// file names.c line 356
static signed int get_ip_name(struct anonymous$9 *nt);
// get_ipv6_name
// file names.c line 378
static signed int get_ipv6_name(struct anonymous$9 *nt);
// get_ipx
// file decode_proto.c line 1122
static void get_ipx(struct anonymous$3 *dp);
// get_ipx_name
// file names.c line 399
static signed int get_ipx_name(struct anonymous$9 *nt);
// get_ipxsap_name
// file names.c line 470
static signed int get_ipxsap_name(struct anonymous$9 *nt);
// get_link6_name
// file names.c line 292
static signed int get_link6_name(struct anonymous$9 *nt);
// get_link_size
// file diagram.c line 1283
static double get_link_size(const struct anonymous$34 *link_stats);
// get_linux_sll
// file decode_proto.c line 806
static void get_linux_sll(struct anonymous$3 *dp);
// get_linux_sll_name
// file names.c line 257
static signed int get_linux_sll_name(struct anonymous$9 *nt);
// get_live_packet
// file capture.c line 491
static unsigned int get_live_packet(void);
// get_llc
// file decode_proto.c line 824
static void get_llc(struct anonymous$3 *dp);
// get_llc_name
// file names.c line 298
static signed int get_llc_name(struct anonymous$9 *nt);
// get_loop
// file decode_proto.c line 381
static void get_loop(struct anonymous$3 *dp);
// get_nbdgm_name
// file names.c line 571
static signed int get_nbdgm_name(struct anonymous$9 *nt);
// get_nbss_name
// file names.c line 505
static signed int get_nbss_name(struct anonymous$9 *nt);
// get_netbios
// file decode_proto.c line 1511
static void get_netbios(struct anonymous$3 *dp);
// get_netbios_dgm
// file decode_proto.c line 1551
static void get_netbios_dgm(struct anonymous$3 *dp);
// get_netbios_host_type
// file names_netbios.h line 46
char * get_netbios_host_type(signed int type);
// get_netbios_ssn
// file decode_proto.c line 1534
static void get_netbios_ssn(struct anonymous$3 *dp);
// get_node_size
// file diagram.c line 1264
static double get_node_size(double average);
// get_null_name
// file names.c line 247
static signed int get_null_name(struct anonymous$9 *nt);
// get_offline_packet
// file capture.c line 398
static unsigned int get_offline_packet(void);
// get_packet_names
// file names.c line 123
void get_packet_names(struct anonymous$25 *pstk, const unsigned char *packet, unsigned short int size, const struct anonymous$2 *prot_stack, enum anonymous$7 direction, signed int link_type);
// get_packet_prot
// file decode_proto.c line 358
static void get_packet_prot(struct anonymous$3 *dp);
// get_ppi
// file decode_proto.c line 599
static void get_ppi(struct anonymous$3 *dp);
// get_radiotap
// file decode_proto.c line 573
static void get_radiotap(struct anonymous$3 *dp);
// get_rpc
// file decode_proto.c line 1404
static signed int get_rpc(struct anonymous$3 *dp, signed int is_udp);
// get_tcp
// file decode_proto.c line 1230
static void get_tcp(struct anonymous$3 *dp);
// get_tcp_name
// file names.c line 405
static signed int get_tcp_name(struct anonymous$9 *nt);
// get_udp
// file decode_proto.c line 1327
static void get_udp(struct anonymous$3 *dp);
// get_udp_name
// file names.c line 462
static signed int get_udp_name(struct anonymous$9 *nt);
// get_wlan
// file decode_proto.c line 680
static void get_wlan(struct anonymous$3 *dp);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyaddr_r
// file /usr/include/netdb.h line 172
extern signed int gethostbyaddr_r(const void *, unsigned int, signed int, struct hostent *, char *, unsigned long int, struct hostent ** restrict , signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// gfunc_remove_canvas_link
// file diagram.c line 315
static void gfunc_remove_canvas_link(void *data, void *user_data);
// gfunc_remove_canvas_node
// file diagram.c line 308
static void gfunc_remove_canvas_node(void *data, void *user_data);
// gfunc_remove_link
// file links.c line 169
static void gfunc_remove_link(void *data, void *user_data);
// gfunc_remove_node
// file node.c line 558
static void gfunc_remove_node(void *data, void *user_data);
// glade_init
// file /usr/include/libglade-2.0/glade/glade-init.h line 31
void glade_init(void);
// glade_require
// file /usr/include/libglade-2.0/glade/glade-init.h line 34
void glade_require(const char *);
// glade_xml_get_widget
// file /usr/include/libglade-2.0/glade/glade-xml.h line 112
struct _GtkWidget * glade_xml_get_widget(struct _GladeXML *, const char *);
// glade_xml_new
// file /usr/include/libglade-2.0/glade/glade-xml.h line 59
struct _GladeXML * glade_xml_new(const char *, const char *, const char *);
// glade_xml_signal_autoconnect
// file /usr/include/libglade-2.0/glade/glade-xml.h line 85
void glade_xml_signal_autoconnect(struct _GladeXML *);
// gnome_canvas_ellipse_get_type
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas-rect-ellipse.h line 154
unsigned long int gnome_canvas_ellipse_get_type(void);
// gnome_canvas_get_scroll_region
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 539
void gnome_canvas_get_scroll_region(struct _GnomeCanvas *, double *, double *, double *, double *);
// gnome_canvas_get_type
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 513
unsigned long int gnome_canvas_get_type(void);
// gnome_canvas_group_get_type
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 388
unsigned long int gnome_canvas_group_get_type(void);
// gnome_canvas_item_get_type
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 231
unsigned long int gnome_canvas_item_get_type(void);
// gnome_canvas_item_hide
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 286
void gnome_canvas_item_hide(struct _GnomeCanvasItem *);
// gnome_canvas_item_lower_to_bottom
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 276
void gnome_canvas_item_lower_to_bottom(struct _GnomeCanvasItem *);
// gnome_canvas_item_new
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 237
struct _GnomeCanvasItem * gnome_canvas_item_new(struct _GnomeCanvasGroup *, unsigned long int, const char *, ...);
// gnome_canvas_item_raise_to_top
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 273
void gnome_canvas_item_raise_to_top(struct _GnomeCanvasItem *);
// gnome_canvas_item_request_update
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 343
void gnome_canvas_item_request_update(struct _GnomeCanvasItem *);
// gnome_canvas_item_set
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 247
void gnome_canvas_item_set(struct _GnomeCanvasItem *, const char *, ...);
// gnome_canvas_item_show
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 281
void gnome_canvas_item_show(struct _GnomeCanvasItem *);
// gnome_canvas_item_w2i
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 304
void gnome_canvas_item_w2i(struct _GnomeCanvasItem *, double *, double *);
// gnome_canvas_points_free
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas-util.h line 66
void gnome_canvas_points_free(struct _GnomeCanvasPoints *);
// gnome_canvas_points_new
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas-util.h line 59
struct _GnomeCanvasPoints * gnome_canvas_points_new(signed int);
// gnome_canvas_polygon_get_type
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas-polygon.h line 85
unsigned long int gnome_canvas_polygon_get_type(void);
// gnome_canvas_root
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 532
struct _GnomeCanvasGroup * gnome_canvas_root(struct _GnomeCanvas *);
// gnome_canvas_set_scroll_region
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas.h line 535
void gnome_canvas_set_scroll_region(struct _GnomeCanvas *, double, double, double, double);
// gnome_canvas_text_get_type
// file /usr/include/libgnomecanvas-2.0/libgnomecanvas/gnome-canvas-text.h line 165
unsigned long int gnome_canvas_text_get_type(void);
// gnome_client_set_clone_command
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-client.h line 335
void gnome_client_set_clone_command(struct _GnomeClient *, signed int, char **);
// gnome_client_set_restart_command
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-client.h line 292
void gnome_client_set_restart_command(struct _GnomeClient *, signed int, char **);
// gnome_master_client
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-client.h line 208
struct _GnomeClient * gnome_master_client(void);
// gnome_program_init
// file /usr/include/libgnome-2.0/libgnome/gnome-program.h line 230
struct _GnomeProgram * gnome_program_init(const char *, const char *, const struct _GnomeModuleInfo *, signed int, char **, const char *, ...);
// gtk_about_dialog_get_type
// file /usr/include/gtk-2.0/gtk/gtkaboutdialog.h line 73
unsigned long int gtk_about_dialog_get_type(void);
// gtk_about_dialog_set_version
// file /usr/include/gtk-2.0/gtk/gtkaboutdialog.h line 88
void gtk_about_dialog_set_version(struct _GtkAboutDialog *, const char *);
// gtk_adjustment_set_value
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 93
void gtk_adjustment_set_value(struct _GtkAdjustment *, double);
// gtk_bin_get_child
// file /usr/include/gtk-2.0/gtk/gtkbin.h line 66
struct _GtkWidget * gtk_bin_get_child(struct _GtkBin *);
// gtk_bin_get_type
// file /usr/include/gtk-2.0/gtk/gtkbin.h line 64
unsigned long int gtk_bin_get_type(void);
// gtk_cell_renderer_text_new
// file /usr/include/gtk-2.0/gtk/gtkcellrenderertext.h line 97
struct _GtkCellRenderer * gtk_cell_renderer_text_new(void);
// gtk_check_menu_item_get_active
// file /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h line 84
signed int gtk_check_menu_item_get_active(struct _GtkCheckMenuItem *);
// gtk_check_menu_item_get_type
// file /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h line 77
unsigned long int gtk_check_menu_item_get_type(void);
// gtk_check_menu_item_set_active
// file /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h line 82
void gtk_check_menu_item_set_active(struct _GtkCheckMenuItem *, signed int);
// gtk_color_button_get_color
// file /usr/include/gtk-2.0/gtk/gtkcolorbutton.h line 90
void gtk_color_button_get_color(struct _GtkColorButton *, struct _GdkColor *);
// gtk_color_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkcolorbutton.h line 83
unsigned long int gtk_color_button_get_type(void);
// gtk_color_button_set_color
// file /usr/include/gtk-2.0/gtk/gtkcolorbutton.h line 86
void gtk_color_button_set_color(struct _GtkColorButton *, const struct _GdkColor *);
// gtk_color_selection_dialog_get_type
// file /usr/include/gtk-2.0/gtk/gtkcolorseldialog.h line 75
unsigned long int gtk_color_selection_dialog_get_type(void);
// gtk_color_selection_get_current_color
// file /usr/include/gtk-2.0/gtk/gtkcolorsel.h line 96
void gtk_color_selection_get_current_color(struct _GtkColorSelection *, struct _GdkColor *);
// gtk_color_selection_get_type
// file /usr/include/gtk-2.0/gtk/gtkcolorsel.h line 82
unsigned long int gtk_color_selection_get_type(void);
// gtk_color_selection_set_current_color
// file /usr/include/gtk-2.0/gtk/gtkcolorsel.h line 92
void gtk_color_selection_set_current_color(struct _GtkColorSelection *, const struct _GdkColor *);
// gtk_color_selection_set_previous_color
// file /usr/include/gtk-2.0/gtk/gtkcolorsel.h line 99
void gtk_color_selection_set_previous_color(struct _GtkColorSelection *, const struct _GdkColor *);
// gtk_combo_box_entry_get_type
// file /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h line 65
unsigned long int gtk_combo_box_entry_get_type(void);
// gtk_combo_box_get_active
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 100
signed int gtk_combo_box_get_active(struct _GtkComboBox *);
// gtk_combo_box_get_active_text
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 141
char * gtk_combo_box_get_active_text(struct _GtkComboBox *);
// gtk_combo_box_get_model
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 111
struct _GtkTreeModel * gtk_combo_box_get_model(struct _GtkComboBox *);
// gtk_combo_box_get_type
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 70
unsigned long int gtk_combo_box_get_type(void);
// gtk_combo_box_set_active
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 101
void gtk_combo_box_set_active(struct _GtkComboBox *, signed int);
// gtk_combo_box_set_model
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 109
void gtk_combo_box_set_model(struct _GtkComboBox *, struct _GtkTreeModel *);
// gtk_container_add
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 111
void gtk_container_add(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_foreach
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 122
void gtk_container_foreach(struct _GtkContainer *, void (*)(struct _GtkWidget *, void *), void *);
// gtk_container_get_children
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 132
struct _GList * gtk_container_get_children(struct _GtkContainer *);
// gtk_container_get_type
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 107
unsigned long int gtk_container_get_type(void);
// gtk_container_remove
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 113
void gtk_container_remove(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_resize_children
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 163
void gtk_container_resize_children(struct _GtkContainer *);
// gtk_dialog_get_type
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 127
unsigned long int gtk_dialog_get_type(void);
// gtk_dialog_run
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 175
signed int gtk_dialog_run(struct _GtkDialog *);
// gtk_entry_get_type
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 166
unsigned long int gtk_entry_get_type(void);
// gtk_entry_set_text
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 213
void gtk_entry_set_text(struct _GtkEntry *, const char *);
// gtk_events_pending
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 137
signed int gtk_events_pending(void);
// gtk_exit
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 131
void gtk_exit(signed int);
// gtk_file_chooser_dialog_new
// file /usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h line 57
struct _GtkWidget * gtk_file_chooser_dialog_new(const char *, struct _GtkWindow *, enum anonymous$66, const char *, ...);
// gtk_file_chooser_get_filename
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 163
char * gtk_file_chooser_get_filename(struct _GtkFileChooser *);
// gtk_file_chooser_get_type
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 88
unsigned long int gtk_file_chooser_get_type(void);
// gtk_file_chooser_get_uri
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 180
char * gtk_file_chooser_get_uri(struct _GtkFileChooser *);
// gtk_file_chooser_set_do_overwrite_confirmation
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 133
void gtk_file_chooser_set_do_overwrite_confirmation(struct _GtkFileChooser *, signed int);
// gtk_file_chooser_set_filename
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 164
signed int gtk_file_chooser_set_filename(struct _GtkFileChooser *, const char *);
// gtk_font_button_get_font_name
// file /usr/include/gtk-2.0/gtk/gtkfontbutton.h line 87
const char * gtk_font_button_get_font_name(struct _GtkFontButton *);
// gtk_font_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkfontbutton.h line 74
unsigned long int gtk_font_button_get_type(void);
// gtk_font_button_set_font_name
// file /usr/include/gtk-2.0/gtk/gtkfontbutton.h line 88
signed int gtk_font_button_set_font_name(struct _GtkFontButton *, const char *);
// gtk_label_get_label
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 120
const char * gtk_label_get_label(struct _GtkLabel *);
// gtk_label_get_selection_bounds
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 167
signed int gtk_label_get_selection_bounds(struct _GtkLabel *, signed int *, signed int *);
// gtk_label_get_type
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 109
unsigned long int gtk_label_get_type(void);
// gtk_label_new
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 110
struct _GtkWidget * gtk_label_new(const char *);
// gtk_label_select_region
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 164
void gtk_label_select_region(struct _GtkLabel *, signed int, signed int);
// gtk_label_set_text
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 112
void gtk_label_set_text(struct _GtkLabel *, const char *);
// gtk_list_store_append
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 126
void gtk_list_store_append(struct _GtkListStore *, struct _GtkTreeIter *);
// gtk_list_store_clear
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 128
void gtk_list_store_clear(struct _GtkListStore *);
// gtk_list_store_get_type
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 77
unsigned long int gtk_list_store_get_type(void);
// gtk_list_store_insert_before
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 108
void gtk_list_store_insert_before(struct _GtkListStore *, struct _GtkTreeIter *, struct _GtkTreeIter *);
// gtk_list_store_insert_with_values
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 114
void gtk_list_store_insert_with_values(struct _GtkListStore *, struct _GtkTreeIter *, signed int, ...);
// gtk_list_store_new
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 78
struct _GtkListStore * gtk_list_store_new(signed int, ...);
// gtk_list_store_prepend
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 124
void gtk_list_store_prepend(struct _GtkListStore *, struct _GtkTreeIter *);
// gtk_list_store_remove
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 103
signed int gtk_list_store_remove(struct _GtkListStore *, struct _GtkTreeIter *);
// gtk_list_store_set
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 92
void gtk_list_store_set(struct _GtkListStore *, struct _GtkTreeIter *, ...);
// gtk_main
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 145
void gtk_main(void);
// gtk_main_iteration
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 148
signed int gtk_main_iteration(void);
// gtk_main_quit
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 147
void gtk_main_quit(void);
// gtk_menu_item_activate
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 108
void gtk_menu_item_activate(struct _GtkMenuItem *);
// gtk_menu_item_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 99
unsigned long int gtk_menu_item_get_type(void);
// gtk_menu_shell_append
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 101
void gtk_menu_shell_append(struct _GtkMenuShell *, struct _GtkWidget *);
// gtk_menu_shell_get_type
// file /usr/include/gtk-2.0/gtk/gtkmenushell.h line 100
unsigned long int gtk_menu_shell_get_type(void);
// gtk_message_dialog_new
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 101
struct _GtkWidget * gtk_message_dialog_new(struct _GtkWindow *, enum anonymous$67, enum anonymous$69, enum anonymous$70, const char *, ...);
// gtk_misc_get_type
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 68
unsigned long int gtk_misc_get_type(void);
// gtk_misc_set_alignment
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 69
void gtk_misc_set_alignment(struct _GtkMisc *, float, float);
// gtk_object_destroy
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 151
void gtk_object_destroy(struct _GtkObject *);
// gtk_object_get_type
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 146
unsigned long int gtk_object_get_type(void);
// gtk_radio_menu_item_get_group
// file /usr/include/gtk-2.0/gtk/gtkradiomenuitem.h line 84
struct _GSList * gtk_radio_menu_item_get_group(struct _GtkRadioMenuItem *);
// gtk_radio_menu_item_get_type
// file /usr/include/gtk-2.0/gtk/gtkradiomenuitem.h line 72
unsigned long int gtk_radio_menu_item_get_type(void);
// gtk_radio_menu_item_new_with_label
// file /usr/include/gtk-2.0/gtk/gtkradiomenuitem.h line 75
struct _GtkWidget * gtk_radio_menu_item_new_with_label(struct _GSList *, const char *);
// gtk_range_get_type
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 136
unsigned long int gtk_range_get_type(void);
// gtk_recent_manager_add_item
// file /usr/include/gtk-2.0/gtk/gtkrecentmanager.h line 149
signed int gtk_recent_manager_add_item(struct _GtkRecentManager *, const char *);
// gtk_recent_manager_get_default
// file /usr/include/gtk-2.0/gtk/gtkrecentmanager.h line 141
struct _GtkRecentManager * gtk_recent_manager_get_default(void);
// gtk_show_uri
// file /usr/include/gtk-2.0/gtk/gtkshow.h line 32
signed int gtk_show_uri(struct _GdkScreen *, const char *, unsigned int, struct _GError **);
// gtk_spin_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 123
unsigned long int gtk_spin_button_get_type(void);
// gtk_spin_button_set_value
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 165
void gtk_spin_button_set_value(struct _GtkSpinButton *, double);
// gtk_statusbar_get_type
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 89
unsigned long int gtk_statusbar_get_type(void);
// gtk_statusbar_pop
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 100
void gtk_statusbar_pop(struct _GtkStatusbar *, unsigned int);
// gtk_statusbar_push
// file /usr/include/gtk-2.0/gtk/gtkstatusbar.h line 97
unsigned int gtk_statusbar_push(struct _GtkStatusbar *, unsigned int, const char *);
// gtk_style_new
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 441
struct _GtkStyle * gtk_style_new(void);
// gtk_style_set_background
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 456
void gtk_style_set_background(struct _GtkStyle *, struct _GdkDrawable *, enum anonymous$0);
// gtk_toggle_button_get_active
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 84
signed int gtk_toggle_button_get_active(struct _GtkToggleButton *);
// gtk_toggle_button_get_type
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 74
unsigned long int gtk_toggle_button_get_type(void);
// gtk_toggle_button_set_active
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 82
void gtk_toggle_button_set_active(struct _GtkToggleButton *, signed int);
// gtk_tree_model_get
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 234
void gtk_tree_model_get(struct _GtkTreeModel *, struct _GtkTreeIter *, ...);
// gtk_tree_model_get_iter
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 198
signed int gtk_tree_model_get_iter(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreePath *);
// gtk_tree_model_get_iter_first
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 206
signed int gtk_tree_model_get_iter_first(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_get_path
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 208
struct _GtkTreePath * gtk_tree_model_get_path(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_get_type
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 190
unsigned long int gtk_tree_model_get_type(void);
// gtk_tree_model_iter_n_children
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 221
signed int gtk_tree_model_iter_n_children(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_iter_next
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 214
signed int gtk_tree_model_iter_next(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_sort_convert_path_to_child_path
// file /usr/include/gtk-2.0/gtk/gtktreemodelsort.h line 93
struct _GtkTreePath * gtk_tree_model_sort_convert_path_to_child_path(struct _GtkTreeModelSort *, struct _GtkTreePath *);
// gtk_tree_model_sort_get_model
// file /usr/include/gtk-2.0/gtk/gtktreemodelsort.h line 87
struct _GtkTreeModel * gtk_tree_model_sort_get_model(struct _GtkTreeModelSort *);
// gtk_tree_model_sort_get_type
// file /usr/include/gtk-2.0/gtk/gtktreemodelsort.h line 84
unsigned long int gtk_tree_model_sort_get_type(void);
// gtk_tree_model_sort_new_with_model
// file /usr/include/gtk-2.0/gtk/gtktreemodelsort.h line 85
struct _GtkTreeModel * gtk_tree_model_sort_new_with_model(struct _GtkTreeModel *);
// gtk_tree_path_free
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 139
void gtk_tree_path_free(struct _GtkTreePath *);
// gtk_tree_sortable_get_sort_column_id
// file /usr/include/gtk-2.0/gtk/gtktreesortable.h line 84
signed int gtk_tree_sortable_get_sort_column_id(struct _GtkTreeSortable *, signed int *, enum anonymous$33 *);
// gtk_tree_sortable_get_type
// file /usr/include/gtk-2.0/gtk/gtktreesortable.h line 81
unsigned long int gtk_tree_sortable_get_type(void);
// gtk_tree_sortable_set_sort_column_id
// file /usr/include/gtk-2.0/gtk/gtktreesortable.h line 87
void gtk_tree_sortable_set_sort_column_id(struct _GtkTreeSortable *, signed int, enum anonymous$33);
// gtk_tree_sortable_set_sort_func
// file /usr/include/gtk-2.0/gtk/gtktreesortable.h line 90
void gtk_tree_sortable_set_sort_func(struct _GtkTreeSortable *, signed int, signed int (*)(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, void *), void *, void (*)(void *));
// gtk_tree_view_append_column
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 167
signed int gtk_tree_view_append_column(struct _GtkTreeView *, struct _GtkTreeViewColumn *);
// gtk_tree_view_column_new_with_attributes
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 128
struct _GtkTreeViewColumn * gtk_tree_view_column_new_with_attributes(const char *, struct _GtkCellRenderer *, ...);
// gtk_tree_view_column_set_sort_column_id
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 207
void gtk_tree_view_column_set_sort_column_id(struct _GtkTreeViewColumn *, signed int);
// gtk_tree_view_get_cursor
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 239
void gtk_tree_view_get_cursor(struct _GtkTreeView *, struct _GtkTreePath **, struct _GtkTreeViewColumn **);
// gtk_tree_view_get_model
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 145
struct _GtkTreeModel * gtk_tree_view_get_model(struct _GtkTreeView *);
// gtk_tree_view_get_type
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 140
unsigned long int gtk_tree_view_get_type(void);
// gtk_tree_view_set_cursor
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 230
void gtk_tree_view_set_cursor(struct _GtkTreeView *, struct _GtkTreePath *, struct _GtkTreeViewColumn *, signed int);
// gtk_tree_view_set_model
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 146
void gtk_tree_view_set_model(struct _GtkTreeView *, struct _GtkTreeModel *);
// gtk_widget_destroy
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 837
void gtk_widget_destroy(struct _GtkWidget *);
// gtk_widget_get_name
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 958
const char * gtk_widget_get_name(struct _GtkWidget *);
// gtk_widget_get_type
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 833
unsigned long int gtk_widget_get_type(void);
// gtk_widget_hide
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 853
void gtk_widget_hide(struct _GtkWidget *);
// gtk_widget_queue_resize
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 880
void gtk_widget_queue_resize(struct _GtkWidget *);
// gtk_widget_set_sensitive
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 964
void gtk_widget_set_sensitive(struct _GtkWidget *, signed int);
// gtk_widget_set_style
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1138
void gtk_widget_set_style(struct _GtkWidget *, struct _GtkStyle *);
// gtk_widget_show
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 851
void gtk_widget_show(struct _GtkWidget *);
// gtk_window_fullscreen
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 339
void gtk_window_fullscreen(struct _GtkWindow *);
// gtk_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 178
unsigned long int gtk_window_get_type(void);
// gtk_window_set_title
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 180
void gtk_window_set_title(struct _GtkWindow *, const char *);
// gtk_window_unfullscreen
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 340
void gtk_window_unfullscreen(struct _GtkWindow *);
// gui_eof_capture
// file menus.c line 517
void gui_eof_capture(void);
// gui_pause_capture
// file menus.c line 480
void gui_pause_capture(void);
// gui_start_capture
// file menus.c line 371
void gui_start_capture(void);
// gui_stop_capture
// file menus.c line 552
signed int gui_stop_capture(void);
// has_linklevel
// file decode_proto.h line 27
signed int has_linklevel(void);
// header_xml
// file export.c line 35
static char * header_xml(void);
// hide_pref_dialog
// file pref_dialog.c line 70
static void hide_pref_dialog(void);
// hide_widget
// file ui_utils.c line 101
void hide_widget(struct _GtkWidget *window, const char *lblname);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// init_capture
// file capture.h line 33
char * init_capture(void);
// init_config
// file preferences.c line 98
void init_config(struct pref_struct *p);
// init_diagram
// file diagram.h line 28
void init_diagram(struct _GladeXML *xml);
// init_menus
// file menus.c line 42
void init_menus(void);
// init_reposition
// file diagram.c line 923
static void init_reposition(struct anonymous *data, struct _GtkWidget *canvas, unsigned int total_nodes);
// initialize_ethers
// file resolv.c line 395
static void initialize_ethers(void);
// initialize_pref_controls
// file pref_dialog.c line 85
void initialize_pref_controls(void);
// install_handlers
// file main.c line 381
static void install_handlers(void);
// install_handlers::$tmp::return_value_signal$1$object
// 
void return_value_signal$1$object(signed int);
// install_handlers::$tmp::return_value_signal$2$object
// 
void return_value_signal$2$object(signed int);
// install_handlers::$tmp::return_value_signal$3$object
// 
void return_value_signal$3$object(signed int);
// interface_list_create
// file util.c line 72
struct _GList * interface_list_create(struct _GString *err_str);
// interface_list_free
// file util.c line 128
void interface_list_free(struct _GList *if_list);
// interface_list_free_cb
// file util.c line 122
static void interface_list_free_cb(void *data, void *user_data);
// ipcache_active_entries
// file ip-cache.h line 62
signed long int ipcache_active_entries(void);
// ipcache_alloc_item
// file ip-cache.c line 480
static struct ipcache_item * ipcache_alloc_item(struct anonymous$20 *ip);
// ipcache_calc_expire_tick
// file ip-cache.c line 160
static void ipcache_calc_expire_tick(struct ipcache_item *rp, unsigned long int delay, signed int is_request);
// ipcache_clear
// file ip-cache.h line 63
void ipcache_clear(void);
// ipcache_findid
// file ip-cache.c line 429
struct ipcache_item * ipcache_findid(unsigned short int id);
// ipcache_findip
// file ip-cache.c line 454
static struct ipcache_item * ipcache_findip(struct anonymous$20 *ip);
// ipcache_getidbash
// file ip-cache.c line 205
static unsigned short int ipcache_getidbash(unsigned short int id);
// ipcache_getipbash
// file ip-cache.c line 211
static unsigned short int ipcache_getipbash(struct anonymous$20 *ip);
// ipcache_getnameip
// file ip-cache.h line 58
const char * ipcache_getnameip(struct anonymous$20 *ip, signed int *is_expired);
// ipcache_init
// file ip-cache.h line 54
void ipcache_init(void);
// ipcache_is_expired_tick
// file ip-cache.c line 174
static signed int ipcache_is_expired_tick(unsigned long int tick);
// ipcache_link_activelist
// file ip-cache.c line 265
static void ipcache_link_activelist(struct ipcache_item *rp);
// ipcache_linkresolveid
// file ip-cache.c line 302
static void ipcache_linkresolveid(struct ipcache_item *addrp);
// ipcache_linkresolveip
// file ip-cache.c line 359
static void ipcache_linkresolveip(struct ipcache_item *addrp);
// ipcache_prepare_request
// file ip-cache.h line 57
struct ipcache_item * ipcache_prepare_request(struct anonymous$20 *ip);
// ipcache_purge_activelist
// file ip-cache.c line 249
static void ipcache_purge_activelist(void);
// ipcache_request_failed
// file ip-cache.h line 59
void ipcache_request_failed(struct ipcache_item *rp);
// ipcache_request_succeeded
// file ip-cache.h line 60
void ipcache_request_succeeded(struct ipcache_item *rp, signed long int ttl, char *ipname);
// ipcache_tick
// file ip-cache.h line 55
unsigned int ipcache_tick(void);
// ipcache_unlink_activelist
// file ip-cache.c line 224
static void ipcache_unlink_activelist(struct ipcache_item *rp);
// ipcache_unlinkresolve
// file ip-cache.c line 417
static void ipcache_unlinkresolve(struct ipcache_item *rp);
// ipcache_unlinkresolveid
// file ip-cache.c line 339
static void ipcache_unlinkresolveid(struct ipcache_item *rp);
// ipcache_unlinkresolveip
// file ip-cache.c line 396
static void ipcache_unlinkresolveip(struct ipcache_item *rp);
// ipv4_to_str
// file util.c line 200
const char * ipv4_to_str(const unsigned char *ad);
// ipv6_to_str
// file util.c line 313
const char * ipv6_to_str(const unsigned char *ad);
// labs
// file /usr/include/stdlib.h line 775
extern signed long int labs(signed long int);
// libgnomeui_module_info_get
// file /usr/include/libgnomeui-2.0/libgnomeui/gnome-ui-init.h line 38
const struct _GnomeModuleInfo * libgnomeui_module_info_get(void);
// limit_nodes
// file diagram.c line 840
static void limit_nodes(void);
// link_create
// file links.c line 83
struct anonymous$28 * link_create(const struct anonymous$16 *link_id);
// link_delete
// file links.c line 105
void link_delete(struct anonymous$28 *link);
// link_dump
// file links.c line 127
char * link_dump(const struct anonymous$28 *link);
// link_dump_tvs
// file links.c line 361
static signed int link_dump_tvs(void *key, void *value, void *data);
// link_id_compare
// file links.h line 32
signed int link_id_compare(const struct anonymous$16 *a, const struct anonymous$16 *b);
// link_id_node_names
// file links.h line 34
char * link_id_node_names(const struct anonymous$16 *link_id);
// link_info_window_compare
// file info_windows.c line 938
static signed int link_info_window_compare(const void *a, const void *b);
// link_info_window_create
// file info_windows.h line 28
void link_info_window_create(const struct anonymous$16 *link_id);
// link_item_event
// file diagram.c line 1333
static signed int link_item_event(struct _GnomeCanvasItem *item, union _GdkEvent *event, struct anonymous$80 *canvas_link);
// links_catalog_add_packet
// file links.h line 60
void links_catalog_add_packet(const struct anonymous$16 *link_id, struct anonymous$6 *packet, enum anonymous$7 direction);
// links_catalog_close
// file links.h line 51
void links_catalog_close(void);
// links_catalog_compare
// file links.c line 227
static signed int links_catalog_compare(const void *a, const void *b, void *dummy);
// links_catalog_dump
// file links.c line 376
char * links_catalog_dump(void);
// links_catalog_find
// file links.h line 54
struct anonymous$28 * links_catalog_find(const struct anonymous$16 *key);
// links_catalog_find_create
// file links.c line 289
struct anonymous$28 * links_catalog_find_create(const struct anonymous$16 *key);
// links_catalog_foreach
// file links.h line 57
void links_catalog_foreach(signed int (*func)(void *, void *, void *), void *data);
// links_catalog_foreach::func$object
// 
signed int func$object(void *, void *, void *);
// links_catalog_insert
// file links.c line 251
void links_catalog_insert(struct anonymous$28 *new_link);
// links_catalog_open
// file links.h line 50
void links_catalog_open(void);
// links_catalog_remove
// file links.c line 270
void links_catalog_remove(const struct anonymous$16 *key);
// links_catalog_size
// file links.h line 56
signed int links_catalog_size(void);
// links_catalog_update_all
// file links.h line 58
void links_catalog_update_all(void);
// load_config
// file preferences.c line 173
void load_config(void);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// log_handler
// file main.c line 326
static void log_handler(char *log_domain, enum anonymous$30 mask, const char *message, void *user_data);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// manuf_name_lookup
// file resolv.c line 374
static const struct hashmanuf * manuf_name_lookup(const unsigned char *addr);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// missing_data_msg
// file names.c line 104
static void missing_data_msg(const struct anonymous$9 *nt, const char *pr);
// new_nodes_add
// file node.h line 45
void new_nodes_add(struct anonymous$19 *node);
// new_nodes_clear
// file node.h line 44
void new_nodes_clear(void);
// new_nodes_pop
// file node.h line 47
struct anonymous$19 * new_nodes_pop(void);
// new_nodes_remove
// file node.c line 427
void new_nodes_remove(struct anonymous$19 *node);
// node_count
// file node.h line 40
signed int node_count(void);
// node_create
// file node.c line 83
struct anonymous$19 * node_create(const struct anonymous$5 *node_id);
// node_delete
// file node.c line 119
void node_delete(struct anonymous$19 *node);
// node_dump
// file node.h line 38
char * node_dump(const struct anonymous$19 *node);
// node_dump_tvs
// file node.c line 588
static signed int node_dump_tvs(void *key, void *value, void *data);
// node_id_clear
// file node_id.h line 42
void node_id_clear(struct anonymous$5 *a);
// node_id_compare
// file node_id.h line 43
signed int node_id_compare(const struct anonymous$5 *na, const struct anonymous$5 *nb);
// node_id_dump
// file node_id.c line 122
char * node_id_dump(const struct anonymous$5 *id);
// node_id_str
// file node_id.c line 93
char * node_id_str(const struct anonymous$5 *id);
// node_id_xml
// file node_id.c line 151
char * node_id_xml(const struct anonymous$5 *id);
// node_info_window_compare
// file info_windows.c line 664
static signed int node_info_window_compare(const void *a, const void *b);
// node_item_event
// file diagram.c line 1371
static signed int node_item_event(struct _GnomeCanvasItem *item, union _GdkEvent *event, struct anonymous$82 *canvas_node);
// node_name_assign
// file node_id.h line 63
void node_name_assign(struct anonymous$36 *name, const char *nm, const char *num_nm, double sz);
// node_name_create
// file node_id.h line 61
struct anonymous$36 * node_name_create(const struct anonymous$5 *node_id);
// node_name_delete
// file node_id.h line 62
void node_name_delete(struct anonymous$36 *name);
// node_name_dump
// file node_id.h line 67
char * node_name_dump(const struct anonymous$36 *name);
// node_name_freq_compare
// file node_id.c line 323
signed int node_name_freq_compare(const void *a, const void *b);
// node_name_id_compare
// file node_id.h line 65
signed int node_name_id_compare(const struct anonymous$36 *a, const struct anonymous$36 *b);
// node_name_update
// file node.c line 286
static void node_name_update(struct anonymous$19 *node);
// node_name_xml
// file node_id.h line 68
char * node_name_xml(const struct anonymous$36 *name);
// node_protocols_window_create
// file info_windows.h line 27
void node_protocols_window_create(const struct anonymous$5 *node_id);
// node_update
// file node.c line 231
signed int node_update(struct anonymous$5 *node_id, struct anonymous$19 *node, void *delete_list_ptr);
// node_xml
// file node.c line 200
char * node_xml(const struct anonymous$19 *node);
// node_xml_tvs
// file node.c line 612
static signed int node_xml_tvs(void *key, void *value, void *data);
// nodes_catalog_close
// file node.h line 51
void nodes_catalog_close(void);
// nodes_catalog_compare
// file node.c line 481
static signed int nodes_catalog_compare(const void *a, const void *b, void *dummy);
// nodes_catalog_dump
// file node.c line 603
char * nodes_catalog_dump(void);
// nodes_catalog_find
// file node.h line 52
struct anonymous$19 * nodes_catalog_find(const struct anonymous$5 *key);
// nodes_catalog_foreach
// file node.c line 548
void nodes_catalog_foreach(signed int (*func)(void *, void *, void *), void *data);
// nodes_catalog_foreach::func$object
// 
signed int func$object(void *, void *, void *);
// nodes_catalog_new
// file node.h line 53
struct anonymous$19 * nodes_catalog_new(const struct anonymous$5 *node_id);
// nodes_catalog_open
// file node.h line 50
void nodes_catalog_open(void);
// nodes_catalog_remove
// file node.c line 521
void nodes_catalog_remove(const struct anonymous$5 *key);
// nodes_catalog_size
// file node.h line 55
signed int nodes_catalog_size(void);
// nodes_catalog_update_all
// file node.h line 57
void nodes_catalog_update_all(void);
// nodes_catalog_xml
// file node.h line 62
char * nodes_catalog_xml(void);
// nodes_table_clear
// file node_windows.c line 250
static void nodes_table_clear(struct _GtkWidget *window);
// nodes_table_compare
// file node_windows.c line 102
static signed int nodes_table_compare(struct _GtkTreeModel *gls, struct _GtkTreeIter *a, struct _GtkTreeIter *b, void *data);
// nodes_table_create
// file node_windows.c line 190
static struct _GtkListStore * nodes_table_create(struct _GtkWidget *window);
// nodes_table_iterate
// file node_windows.c line 319
static signed int nodes_table_iterate(void *key, void *value, void *data);
// nodes_table_update
// file node_windows.c line 371
static void nodes_table_update(struct _GtkWidget *window);
// nodes_table_update_row
// file node_windows.c line 284
static void nodes_table_update_row(struct _GtkListStore *gs, struct _GtkTreeIter *it, const struct anonymous$19 *node);
// nodes_wnd_hide
// file node_windows.c line 72
void nodes_wnd_hide(void);
// nodes_wnd_show
// file node_windows.c line 50
void nodes_wnd_show(void);
// nodes_wnd_update
// file node_windows.h line 28
void nodes_wnd_update(void);
// old_config_file_name
// file preferences.c line 88
static char * old_config_file_name(void);
// old_sighup_handler$object
// 
void old_sighup_handler$object(signed int);
// on_about1_activate
// file menus.c line 338
void on_about1_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_averaging_spin_adjustment_changed
// file pref_dialog.c line 293
void on_averaging_spin_adjustment_changed(struct _GtkAdjustment *adj);
// on_cancel_pref_button_clicked
// file pref_dialog.c line 415
void on_cancel_pref_button_clicked(struct _GtkButton *button, void *user_data);
// on_canvas1_size_allocate
// file callbacks.c line 31
void on_canvas1_size_allocate(struct _GtkWidget *widget, struct _GdkRectangle *allocation, void *user_data);
// on_center_node_changed
// file pref_dialog.c line 457
static void on_center_node_changed(struct _GtkComboBoxEntry *cbox, void *user_data);
// on_color_add_button_clicked
// file pref_dialog.c line 527
void on_color_add_button_clicked(struct _GtkButton *button, void *user_data);
// on_color_change_button_clicked
// file pref_dialog.c line 536
void on_color_change_button_clicked(struct _GtkButton *button, void *user_data);
// on_color_remove_button_clicked
// file pref_dialog.c line 572
void on_color_remove_button_clicked(struct _GtkButton *button, void *user_data);
// on_colordiag_ok_clicked
// file pref_dialog.c line 608
void on_colordiag_ok_clicked(struct _GtkButton *button, void *user_data);
// on_delete_protocol_window
// file info_windows.c line 591
signed int on_delete_protocol_window(struct _GtkWidget *wdg, union _GdkEvent *evt, void *ud);
// on_diagram_only_toggle_toggled
// file pref_dialog.c line 388
void on_diagram_only_toggle_toggled(struct _GtkToggleButton *togglebutton, void *user_data);
// on_export_activate
// file menus.c line 136
void on_export_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_filter_entry_changed
// file pref_dialog.c line 440
static void on_filter_entry_changed(struct _GtkComboBoxEntry *cbox, void *user_data);
// on_full_screen_activate
// file menus.c line 289
void on_full_screen_activate(struct _GtkCheckMenuItem *menuitem, void *user_data);
// on_group_unk_check_toggled
// file pref_dialog.c line 396
void on_group_unk_check_toggled(struct _GtkToggleButton *togglebutton, void *user_data);
// on_gui_link_to_spin_adjustment_changed
// file pref_dialog.c line 329
void on_gui_link_to_spin_adjustment_changed(struct _GtkAdjustment *adj);
// on_gui_node_to_spin_adjustment_changed
// file pref_dialog.c line 311
void on_gui_node_to_spin_adjustment_changed(struct _GtkAdjustment *adj);
// on_help_activate
// file menus.c line 355
void on_help_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_interface_radio_activate
// file menus.c line 170
void on_interface_radio_activate(char *gui_device);
// on_legend_check_activate
// file menus.c line 311
void on_legend_check_activate(struct _GtkCheckMenuItem *menuitem, void *user_data);
// on_link_to_spin_adjustment_changed
// file pref_dialog.c line 323
void on_link_to_spin_adjustment_changed(struct _GtkAdjustment *adj);
// on_link_width_slider_adjustment_changed
// file pref_dialog.c line 282
void on_link_width_slider_adjustment_changed(struct _GtkAdjustment *adj);
// on_mode_radio_activate
// file menus.c line 199
void on_mode_radio_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_name_motion_notify_event
// file callbacks.c line 59
signed int on_name_motion_notify_event(struct _GtkWidget *widget, struct _GdkEventMotion *event, void *user_data);
// on_next_menuitem_activate
// file menus.c line 271
void on_next_menuitem_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_node_info_delete_event
// file info_windows.c line 701
signed int on_node_info_delete_event(struct _GtkWidget *node_info, union _GdkEvent *evt, void *user_data);
// on_node_popup_motion_notify_event
// file callbacks.c line 49
signed int on_node_popup_motion_notify_event(struct _GtkWidget *widget, struct _GdkEventMotion *event, void *user_data);
// on_node_radius_slider_adjustment_changed
// file pref_dialog.c line 271
void on_node_radius_slider_adjustment_changed(struct _GtkAdjustment *adj);
// on_node_to_spin_adjustment_changed
// file pref_dialog.c line 305
void on_node_to_spin_adjustment_changed(struct _GtkAdjustment *adj);
// on_nodes_check_toggled
// file node_windows.c line 406
void on_nodes_check_toggled(struct _GtkCheckMenuItem *checkmenuitem, void *data);
// on_nodes_table_row_activated
// file node_windows.c line 423
void on_nodes_table_row_activated(struct _GtkTreeView *gv, struct _GtkTreePath *sorted_path, struct _GtkTreeViewColumn *column, void *data);
// on_nodes_toolbar_button_clicked
// file node_windows.c line 414
void on_nodes_toolbar_button_clicked(void);
// on_nodes_wnd_delete_event
// file node_windows.c line 400
signed int on_nodes_wnd_delete_event(struct _GtkWidget *wdg, union _GdkEvent *evt, void *ud);
// on_numeric_toggle_toggled
// file pref_dialog.c line 468
void on_numeric_toggle_toggled(struct _GtkToggleButton *togglebutton, void *user_data);
// on_ok_pref_button_clicked
// file pref_dialog.c line 406
void on_ok_pref_button_clicked(struct _GtkButton *button, void *user_data);
// on_open_activate
// file menus.c line 100
void on_open_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_pause_menuitem_activate
// file menus.c line 264
void on_pause_menuitem_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_preferences1_activate
// file pref_dialog.c line 251
void on_preferences1_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_prot_info_delete_event
// file info_windows.c line 155
signed int on_prot_info_delete_event(struct _GtkWidget *prot_info, union _GdkEvent *evt, void *user_data);
// on_prot_list_select_row
// file info_windows.c line 626
signed int on_prot_list_select_row(struct _GtkTreeView *gv, signed int arg1, void *user_data);
// on_proto_link_to_spin_adjustment_changed
// file pref_dialog.c line 335
void on_proto_link_to_spin_adjustment_changed(struct _GtkAdjustment *adj);
// on_proto_node_to_spin_adjustment_changed
// file pref_dialog.c line 317
void on_proto_node_to_spin_adjustment_changed(struct _GtkAdjustment *adj);
// on_proto_to_spin_adjustment_changed
// file pref_dialog.c line 341
void on_proto_to_spin_adjustment_changed(struct _GtkAdjustment *adj);
// on_protocol_edit_button_clicked
// file pref_dialog.c line 672
void on_protocol_edit_button_clicked(struct _GtkButton *button, void *user_data);
// on_protocol_edit_dialog_show
// file pref_dialog.c line 680
void on_protocol_edit_dialog_show(struct _GtkWidget *wdg, void *user_data);
// on_protocol_edit_ok_clicked
// file pref_dialog.c line 710
void on_protocol_edit_ok_clicked(struct _GtkButton *button, void *user_data);
// on_protocols_check_activate
// file info_windows.c line 598
void on_protocols_check_activate(struct _GtkCheckMenuItem *menuitem, void *user_data);
// on_refresh_spin_adjustment_changed
// file pref_dialog.c line 299
void on_refresh_spin_adjustment_changed(struct _GtkAdjustment *adj, struct _GtkWidget *canvas);
// on_save_pref_button_clicked
// file pref_dialog.c line 431
void on_save_pref_button_clicked(struct _GtkButton *button, void *user_data);
// on_size_mode_changed
// file pref_dialog.c line 346
static void on_size_mode_changed(struct _GtkComboBox *combo, void *data);
// on_size_variable_changed
// file pref_dialog.c line 353
static void on_size_variable_changed(struct _GtkComboBox *combo, void *data);
// on_stack_level_changed
// file pref_dialog.c line 360
static void on_stack_level_changed(struct _GtkComboBox *combo, void *data);
// on_start_menuitem_activate
// file menus.c line 257
void on_start_menuitem_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_status_bar_check_activate
// file menus.c line 323
void on_status_bar_check_activate(struct _GtkCheckMenuItem *menuitem, void *user_data);
// on_stop_menuitem_activate
// file menus.c line 278
void on_stop_menuitem_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_text_color_changed
// file pref_dialog.c line 378
static void on_text_color_changed(struct _GtkColorButton *wdg, void *data);
// on_text_font_changed
// file pref_dialog.c line 366
static void on_text_font_changed(struct _GtkFontButton *wdg, void *data);
// on_toolbar_check_activate
// file menus.c line 299
void on_toolbar_check_activate(struct _GtkCheckMenuItem *menuitem, void *user_data);
// open_mutex
// file thread_resolve.c line 77
static signed int open_mutex(void);
// packet_acquired
// file decode_proto.h line 29
void packet_acquired(unsigned char *raw_packet, unsigned int raw_size, unsigned int pkt_size);
// packet_list_item_count
// file pkt_info.h line 72
signed long int packet_list_item_count(void);
// packet_list_item_create
// file basic_stats.c line 148
struct anonymous$62 * packet_list_item_create(struct anonymous$6 *i, enum anonymous$7 d);
// packet_list_item_delete
// file basic_stats.c line 167
void packet_list_item_delete(struct anonymous$62 *pli);
// packet_protos_delete
// file basic_stats.c line 106
void packet_protos_delete(struct anonymous$2 *pt);
// packet_protos_dump
// file basic_stats.c line 115
char * packet_protos_dump(const struct anonymous$2 *pt);
// packet_protos_init
// file pkt_info.h line 44
struct anonymous$2 * packet_protos_init(void);
// parse_ether_line
// file resolv.c line 197
static signed int parse_ether_line(char *line, struct _ether *eth, signed int six_bytes);
// pause_capture
// file capture.h line 35
signed int pause_capture(void);
// pcap_close
// file /usr/include/pcap/pcap.h line 371
void pcap_close(struct pcap *);
// pcap_compile
// file /usr/include/pcap/pcap.h line 389
signed int pcap_compile(struct pcap *, struct bpf_program *, const char *, signed int, unsigned int);
// pcap_datalink
// file /usr/include/pcap/pcap.h line 396
signed int pcap_datalink(struct pcap *);
// pcap_fileno
// file /usr/include/pcap/pcap.h line 411
signed int pcap_fileno(struct pcap *);
// pcap_findalldevs
// file /usr/include/pcap/pcap.h line 422
signed int pcap_findalldevs(struct pcap_if **, char *);
// pcap_freealldevs
// file /usr/include/pcap/pcap.h line 423
void pcap_freealldevs(struct pcap_if *);
// pcap_geterr
// file /usr/include/pcap/pcap.h line 387
char * pcap_geterr(struct pcap *);
// pcap_lookupdev
// file /usr/include/pcap/pcap.h line 274
char * pcap_lookupdev(char *);
// pcap_lookupnet
// file /usr/include/pcap/pcap.h line 275
signed int pcap_lookupnet(const char *, unsigned int *, unsigned int *, char *);
// pcap_next_ex
// file /usr/include/pcap/pcap.h line 376
signed int pcap_next_ex(struct pcap *, struct pcap_pkthdr **, const unsigned char **);
// pcap_open_live
// file /usr/include/pcap/pcap.h line 349
struct pcap * pcap_open_live(const char *, signed int, signed int, signed int, char *);
// pcap_open_offline
// file /usr/include/pcap/pcap.h line 353
struct pcap * pcap_open_offline(const char *, char *);
// pcap_setfilter
// file /usr/include/pcap/pcap.h line 379
signed int pcap_setfilter(struct pcap *, struct bpf_program *);
// pcap_stats
// file /usr/include/pcap/pcap.h line 378
signed int pcap_stats(struct pcap *, struct pcap_stat *);
// poptGetContext
// file /usr/include/popt.h line 261
struct poptContext_s * poptGetContext(const char *, signed int, const char **, struct poptOption *, unsigned int);
// poptGetNextOpt
// file /usr/include/popt.h line 307
signed int poptGetNextOpt(struct poptContext_s *);
// port_service_free
// file datastructs.c line 542
static void port_service_free(struct anonymous$21 *p);
// port_service_new
// file datastructs.c line 530
static struct anonymous$21 * port_service_new(unsigned short int port, const char *name);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// pref_to_color_list
// file pref_dialog.c line 747
static void pref_to_color_list(void);
// process_netbios_name
// file names_netbios.c line 200
static signed int process_netbios_name(const char *name_ptr, char *outname, unsigned long int outname_size);
// prot_freq_compare
// file protocols.c line 211
static signed int prot_freq_compare(const void *a, const void *b);
// prot_info_compare
// file info_windows.c line 90
static signed int prot_info_compare(const void *a, const void *b);
// protocol_compare
// file protocols.c line 476
static signed int protocol_compare(const void *a, const void *b);
// protocol_stack_add_pkt
// file protocols.c line 70
void protocol_stack_add_pkt(struct anonymous$25 *pstk, const struct anonymous$6 *packet);
// protocol_stack_avg
// file protocols.c line 135
void protocol_stack_avg(struct anonymous$25 *pstk, double avgtime);
// protocol_stack_dump
// file protocols.c line 245
char * protocol_stack_dump(const struct anonymous$25 *pstk);
// protocol_stack_find
// file protocols.h line 61
const struct anonymous$26 * protocol_stack_find(const struct anonymous$25 *pstk, unsigned long int level, const char *protoname);
// protocol_stack_open
// file protocols.c line 42
void protocol_stack_open(struct anonymous$25 *pstk);
// protocol_stack_purge_expired
// file protocols.c line 157
void protocol_stack_purge_expired(struct anonymous$25 *pstk, double expire_time);
// protocol_stack_reset
// file protocols.c line 50
void protocol_stack_reset(struct anonymous$25 *pstk);
// protocol_stack_sort_most_used
// file protocols.c line 231
char * protocol_stack_sort_most_used(struct anonymous$25 *pstk, unsigned long int level);
// protocol_stack_sub_pkt
// file protocols.c line 102
void protocol_stack_sub_pkt(struct anonymous$25 *pstk, const struct anonymous$6 *packet);
// protocol_stack_xml
// file protocols.c line 292
char * protocol_stack_xml(const struct anonymous$25 *pstk);
// protocol_summary_add_packet
// file protocols.c line 514
void protocol_summary_add_packet(struct anonymous$6 *packet);
// protocol_summary_close
// file protocols.h line 71
void protocol_summary_close(void);
// protocol_summary_find
// file protocols.h line 76
const struct anonymous$26 * protocol_summary_find(unsigned long int level, const char *protoname);
// protocol_summary_foreach
// file protocols.c line 550
void protocol_summary_foreach(unsigned long int level, void (*func)(void *, void *), void *data);
// protocol_summary_foreach::func$object
// 
//void func$object(void *, void *);
// protocol_summary_open
// file protocols.h line 70
void protocol_summary_open(void);
// protocol_summary_size
// file protocols.h line 74
signed long int protocol_summary_size(void);
// protocol_summary_stack
// file protocols.h line 77
const struct anonymous$25 * protocol_summary_stack(void);
// protocol_summary_update_all
// file protocols.h line 73
void protocol_summary_update_all(void);
// protocol_t_create
// file protocols.c line 344
struct anonymous$26 * protocol_t_create(const char *protocol_name);
// protocol_t_delete
// file protocols.c line 357
void protocol_t_delete(struct anonymous$26 *prot);
// protocol_t_dump
// file protocols.c line 376
char * protocol_t_dump(const struct anonymous$26 *prot);
// protocol_t_xml
// file protocols.c line 424
char * protocol_t_xml(const struct anonymous$26 *prot, unsigned int level);
// protocols_table_clear
// file info_windows.c line 415
static void protocols_table_clear(struct _GtkListStore *gs);
// protocols_table_compare
// file info_windows.c line 275
static signed int protocols_table_compare(struct _GtkTreeModel *gs, struct _GtkTreeIter *a, struct _GtkTreeIter *b, void *userdata);
// protohash_clear
// file datastructs.h line 37
void protohash_clear(void);
// protohash_color
// file datastructs.h line 40
struct _GdkColor protohash_color(const char *protoname);
// protohash_compact
// file datastructs.h line 53
char ** protohash_compact(char **colors);
// protohash_init
// file datastructs.c line 63
static signed int protohash_init(void);
// protohash_is_preferred
// file datastructs.c line 160
signed int protohash_is_preferred(const char *protoname);
// protohash_read_prefvect
// file datastructs.h line 46
signed int protohash_read_prefvect(char **colors);
// protohash_reset_cycle
// file datastructs.h line 49
void protohash_reset_cycle(void);
// protohash_set
// file datastructs.c line 95
static signed int protohash_set(char *protoname, struct _GdkColor protocolor);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$42 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$42 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$42 *, const union anonymous$43 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$42 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$42 *, union anonymous$40 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$40 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$40 *, const union anonymous$43 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$40 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$40 *);
// purge_expired_legend_protocol
// file diagram.c line 486
static void purge_expired_legend_protocol(struct _GtkWidget *widget, void *data);
// putenv
// file /usr/include/stdlib.h line 578
extern signed int putenv(char *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read_boolean_config
// file preferences.c line 54
static void read_boolean_config(signed int *item, struct _GKeyFile *gkey, const char *key);
// read_double_config
// file preferences.c line 74
static void read_double_config(double *item, struct _GKeyFile *gkey, const char *key);
// read_int_config
// file preferences.c line 64
static void read_int_config(signed int *item, struct _GKeyFile *gkey, const char *key);
// read_string_config
// file preferences.c line 42
static void read_string_config(char **item, struct _GKeyFile *gkey, const char *key);
// register_glade_widget
// file ui_utils.h line 45
void register_glade_widget(struct _GladeXML *xm, struct _GObject *tgt, const char *widgetName);
// register_treeview
// file ui_utils.h line 60
void register_treeview(struct _GtkWidget *window, struct _GtkTreeView *gv);
// remove_spaces
// file datastructs.h line 56
char * remove_spaces(char *str);
// reposition_canvas_nodes
// file diagram.c line 956
static signed int reposition_canvas_nodes(struct anonymous$5 *node_id, struct anonymous$82 *canvas_node, struct anonymous *data);
// retrieve_treeview
// file ui_utils.h line 61
struct _GtkTreeView * retrieve_treeview(struct _GtkWidget *window);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// safe_strncat
// file util.c line 185
char * safe_strncat(char *dst, const char *src, unsigned long int maxlen);
// safe_strncpy
// file util.h line 46
char * safe_strncpy(char *dst, const char *src, unsigned long int maxlen);
// save_config
// file preferences.c line 249
void save_config(void);
// save_session
// file main.c line 343
static signed int save_session(struct _GnomeClient *client, signed int phase, enum anonymous$76 save_style, signed int is_shutdown, enum anonymous$77 interact_style, signed int is_fast, void *client_data);
// sendrequest_inverse
// file thread_resolve.c line 220
static void sendrequest_inverse(struct anonymous$20 *ip);
// services_clear
// file datastructs.h line 67
void services_clear(void);
// services_fill_preferred
// file datastructs.c line 370
static void services_fill_preferred(void);
// services_init
// file datastructs.h line 66
void services_init(void);
// services_name_cmp
// file datastructs.c line 341
static signed int services_name_cmp(const void *a, const void *b, void *unused);
// services_port_cmp
// file datastructs.c line 326
static signed int services_port_cmp(const void *a, const void *b, void *unused);
// services_port_find
// file datastructs.h line 71
const struct anonymous$21 * services_port_find(const char *name);
// services_port_trv
// file datastructs.c line 352
static signed int services_port_trv(void *key, void *value, void *data);
// services_pref_trv
// file datastructs.c line 364
static signed int services_pref_trv(void *key, void *value, void *data);
// services_tcp_find
// file datastructs.h line 69
const struct anonymous$21 * services_tcp_find(unsigned short int port);
// services_tree_free
// file datastructs.c line 346
static void services_tree_free(void *p);
// services_udp_find
// file datastructs.h line 70
const struct anonymous$21 * services_udp_find(unsigned short int port);
// session_die
// file main.c line 335
static void session_die(struct _GnomeClient *client, void *client_data);
// set_active_interface
// file menus.c line 632
static void set_active_interface(void);
// set_debug_level
// file main.c line 303
static void set_debug_level(void);
// set_default_config
// file preferences.c line 130
void set_default_config(struct pref_struct *p);
// set_ethent
// file resolv.c line 269
static void set_ethent(char *path);
// set_filter
// file capture.h line 39
signed int set_filter(char *filter_string, char *device);
// set_node_name
// file node.c line 324
static void set_node_name(struct anonymous$19 *node, const struct anonymous$39 *sequence);
// set_statusbar_msg
// file diagram.h line 31
void set_statusbar_msg(char *str);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// setup_link_type
// file decode_proto.h line 28
signed int setup_link_type(unsigned int linktype);
// show_widget
// file ui_utils.h line 51
void show_widget(struct _GtkWidget *window, const char *lblname);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// signal_export
// file main.c line 415
static void signal_export(signed int signum);
// sin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
extern double sin(double);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_capture
// file capture.h line 34
signed int start_capture(void);
// start_threads
// file thread_resolve.c line 167
static void start_threads();
// stats_info_create
// file info_windows.c line 771
static struct _GtkWidget * stats_info_create(const char *idkey, void *key);
// stats_info_update
// file info_windows.c line 831
static void stats_info_update(struct _GtkWidget *window, const struct anonymous$27 *stats);
// stop_capture
// file capture.h line 36
signed int stop_capture(void);
// stop_threads
// file thread_resolve.c line 203
static void stop_threads();
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strlongip
// file ip-cache.h line 66
char * strlongip(struct anonymous$20 *ip);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtdiff
// file ip-cache.c line 93
char * strtdiff(char *d, unsigned long int lend, signed long int signeddiff);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// substract_times
// file basic_stats.c line 41
struct timeval substract_times(struct timeval a, struct timeval b);
// substract_times_ms
// file basic_stats.h line 31
double substract_times_ms(struct timeval *a, struct timeval *b);
// textdomain
// file /usr/include/libintl.h line 82
extern char * textdomain(const char *);
// thread_close
// file thread_resolve.h line 24
void thread_close(void);
// thread_lookup
// file thread_resolve.h line 27
const char * thread_lookup(struct anonymous$20 *ip);
// thread_open
// file thread_resolve.h line 21
signed int thread_open(void);
// thread_pool_routine
// file thread_resolve.c line 95
static void * thread_pool_routine(void *dt);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timeout_changed
// file diagram.h line 35
void timeout_changed(void);
// timeval_to_str
// file ui_utils.h line 39
char * timeval_to_str(struct timeval last_heard);
// toggle_protocols_window
// file info_windows.c line 582
void toggle_protocols_window(void);
// traffic_compare
// file diagram.c line 899
static signed int traffic_compare(const void *a, const void *b);
// traffic_stats_add_packet
// file traffic_stats.h line 38
void traffic_stats_add_packet(struct anonymous$27 *pkt_stat, struct anonymous$6 *new_pkt, enum anonymous$7 dir);
// traffic_stats_dump
// file traffic_stats.h line 43
char * traffic_stats_dump(const struct anonymous$27 *pkt_stat);
// traffic_stats_init
// file traffic_stats.h line 36
void traffic_stats_init(struct anonymous$27 *pkt_stat);
// traffic_stats_purge_expired_packets
// file traffic_stats.c line 98
void traffic_stats_purge_expired_packets(struct anonymous$27 *pkt_stat, double pkt_expire_time, double proto_expire_time);
// traffic_stats_reset
// file traffic_stats.h line 37
void traffic_stats_reset(struct anonymous$27 *pkt_stat);
// traffic_stats_update
// file traffic_stats.h line 42
signed int traffic_stats_update(struct anonymous$27 *pkt_stat, double avg_time, double proto_expire_time);
// traffic_stats_xml
// file traffic_stats.h line 44
char * traffic_stats_xml(const struct anonymous$27 *pkt_stat);
// traffic_to_str
// file ui_utils.h line 42
char * traffic_to_str(double traffic, signed int is_speed);
// type_to_str
// file util.c line 382
const char * type_to_str(const struct anonymous$20 *ad);
// update_diagram
// file diagram.h line 27
unsigned int update_diagram(struct _GtkWidget *canvas);
// update_gtklabel
// file ui_utils.h line 48
void update_gtklabel(struct _GtkWidget *window, const char *lblname, const char *value);
// update_info_windows
// file info_windows.h line 26
unsigned int update_info_windows(void);
// update_legend
// file diagram.c line 500
static void update_legend(void);
// update_link
// file links.c line 175
static signed int update_link(struct anonymous$16 *link_id, struct anonymous$28 *link, void *delete_list_ptr);
// update_link_info_window
// file info_windows.c line 972
static void update_link_info_window(struct _GtkWidget *window);
// update_node_protocols_window
// file info_windows.c line 908
static void update_node_protocols_window(struct _GtkWidget *window);
// update_prot_info_window
// file info_windows.c line 186
static void update_prot_info_window(struct anonymous$29 *prot_info_window);
// update_prot_info_windows
// file info_windows.c line 230
static void update_prot_info_windows(void);
// update_protocols_row
// file info_windows.c line 435
static void update_protocols_row(struct _GtkListStore *gs, struct _GtkTreeIter *it, const struct protocol_list_item_t_tag *row_proto);
// update_protocols_table
// file info_windows.c line 469
static void update_protocols_table(struct _GtkWidget *window, const struct anonymous$25 *pstk);
// update_protocols_window
// file info_windows.c line 559
static void update_protocols_window(void);
// update_stats_info_windows
// file info_windows.c line 716
static void update_stats_info_windows(void);
// xmltag
// file util.c line 404
char * xmltag(const char *name, const char *fmt, ...);

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct anonymous$34
{
  // average
  double average;
  // aver_accu
  double aver_accu;
  // accumulated
  double accumulated;
  // avg_size
  double avg_size;
  // accu_packets
  unsigned long int accu_packets;
  // last_time
  struct timeval last_time;
};

struct anonymous$26
{
  // name
  char *name;
  // stats
  struct anonymous$34 stats;
  // node_names
  struct _GList *node_names;
};

struct anonymous$12
{
  // prot
  char *prot;
  // function
  signed int (*function)(struct anonymous$9 *);
};

struct anonymous$29
{
  // prot_name
  char *prot_name;
  // window
  struct _GtkWidget *window;
};

struct anonymous$62
{
  // info
  struct anonymous$6 *info;
  // direction
  enum anonymous$7 direction;
};

struct anonymous
{
  // canvas
  struct _GtkWidget *canvas;
  // angle
  float angle;
  // node_i
  unsigned int node_i;
  // n_nodes
  unsigned int n_nodes;
  // xmin
  double xmin;
  // ymin
  double ymin;
  // xmax
  double xmax;
  // ymax
  double ymax;
  // x_rad_max
  double x_rad_max;
  // y_rad_max
  double y_rad_max;
  // x_inner_rad_max
  double x_inner_rad_max;
  // y_inner_rad_max
  double y_inner_rad_max;
};

struct anonymous$39
{
  // protocol
  const char *protocol;
  // must_resolve
  signed int must_resolve;
};

union anonymous$37
{
  // addr8
  unsigned char addr8[16l];
  // addr32
  unsigned int addr32[4l];
  // addr32_v4
  unsigned int addr32_v4;
  // addr_v4
  unsigned char addr_v4[4l];
  // addr_v6
  unsigned char addr_v6[16l];
} __attribute__ ((__packed__));

struct anonymous$38
{
  // type
  unsigned int type;
  // $anon0
  union anonymous$37 $anon0;
} __attribute__ ((__packed__));

union anonymous$35
{
  // $anon0
  struct anonymous$38 $anon0;
  // all8
  unsigned char all8[20l];
} __attribute__ ((__packed__));

struct anonymous$20
{
  // $anon0
  union anonymous$35 $anon0;
} __attribute__ ((__packed__));

struct anonymous$1
{
  // host
  struct anonymous$20 host;
  // port
  unsigned short int port;
} __attribute__ ((__packed__));

union anonymous$81
{
  // eth
  unsigned char eth[6l];
  // ip
  struct anonymous$20 ip;
  // tcp4
  struct anonymous$1 tcp4;
} __attribute__ ((__packed__));

struct anonymous$5
{
  // node_type
  enum anonymous$13 node_type;
  // addr
  union anonymous$81 addr;
};

struct anonymous$3
{
  // original_packet
  const unsigned char *original_packet;
  // original_len
  unsigned int original_len;
  // cur_packet
  const unsigned char *cur_packet;
  // cur_len
  unsigned int cur_len;
  // pr
  struct anonymous$2 *pr;
  // cur_level
  unsigned int cur_level;
  // dst_node_id
  struct anonymous$5 dst_node_id;
  // src_node_id
  struct anonymous$5 src_node_id;
  // global_src_address
  struct anonymous$20 global_src_address;
  // global_dst_address
  struct anonymous$20 global_dst_address;
  // global_src_port
  unsigned short int global_src_port;
  // global_dst_port
  unsigned short int global_dst_port;
};

struct anonymous$10
{
  // level
  unsigned char level;
  // tokens
  const struct anonymous$2 *tokens;
  // protos
  struct anonymous$25 *protos;
};

struct anonymous$9
{
  // p
  const unsigned char *p;
  // offset
  unsigned short int offset;
  // packet_size
  unsigned short int packet_size;
  // dir
  enum anonymous$7 dir;
  // link_type
  signed int link_type;
  // node_id
  struct anonymous$5 node_id;
  // decoder
  struct anonymous$10 decoder;
};

struct anonymous$2
{
  // protonames
  char *protonames[6l];
};

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

struct anonymous$25
{
  // protostack
  struct _GList *protostack[6l];
};

struct anonymous$41
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$15
{
  // number
  signed int number;
  // name
  char *name;
};

struct _GdkColor
{
  // pixel
  unsigned int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
};

struct anonymous$82
{
  // canvas_node_id
  struct anonymous$5 canvas_node_id;
  // node_item
  struct _GnomeCanvasItem *node_item;
  // text_item
  struct _GnomeCanvasItem *text_item;
  // group_item
  struct _GnomeCanvasGroup *group_item;
  // color
  struct _GdkColor color;
  // is_new
  signed int is_new;
  // shown
  signed int shown;
  // centered
  signed int centered;
};

struct _GQueue
{
  // head
  struct _GList *head;
  // tail
  struct _GList *tail;
  // length
  unsigned int length;
};

struct anonymous$27
{
  // pkt_list
  struct _GQueue pkt_list;
  // stats
  struct anonymous$34 stats;
  // stats_in
  struct anonymous$34 stats_in;
  // stats_out
  struct anonymous$34 stats_out;
  // stats_protos
  struct anonymous$25 stats_protos;
};

struct anonymous$19
{
  // node_id
  struct anonymous$5 node_id;
  // name
  struct _GString *name;
  // numeric_name
  struct _GString *numeric_name;
  // main_prot
  char *main_prot[6l];
  // node_stats
  struct anonymous$27 node_stats;
};

struct anonymous$36
{
  // node_id
  struct anonymous$5 node_id;
  // numeric_name
  struct _GString *numeric_name;
  // res_name
  struct _GString *res_name;
  // accumulated
  double accumulated;
};

struct anonymous$16
{
  // src
  struct anonymous$5 src;
  // dst
  struct anonymous$5 dst;
};

struct anonymous$80
{
  // canvas_link_id
  struct anonymous$16 canvas_link_id;
  // src_item
  struct _GnomeCanvasItem *src_item;
  // dst_item
  struct _GnomeCanvasItem *dst_item;
  // color
  struct _GdkColor color;
};

struct anonymous$28
{
  // link_id
  struct anonymous$16 link_id;
  // main_prot
  char *main_prot[6l];
  // link_stats
  struct anonymous$27 link_stats;
};

struct anonymous$61
{
  // src_address
  struct anonymous$20 src_address;
  // dst_address
  struct anonymous$20 dst_address;
  // src_port
  unsigned short int src_port;
  // dst_port
  unsigned short int dst_port;
  // data
  char *data;
};

struct anonymous$64
{
  // color
  struct _GdkColor color;
  // preferred
  signed int preferred;
};

struct anonymous$21
{
  // port
  unsigned short int port;
  // name
  char *name;
  // preferred
  signed int preferred;
};

struct anonymous$6
{
  // size
  unsigned int size;
  // timestamp
  struct timeval timestamp;
  // prot_desc
  struct anonymous$2 *prot_desc;
  // ref_count
  unsigned int ref_count;
};

union anonymous$51
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

union anonymous$43
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$68
{
  // v_int
  signed int v_int;
  // v_uint
  unsigned int v_uint;
  // v_long
  signed long int v_long;
  // v_ulong
  unsigned long int v_ulong;
  // v_int64
  signed long int v_int64;
  // v_uint64
  unsigned long int v_uint64;
  // v_float
  float v_float;
  // v_double
  double v_double;
  // v_pointer
  void *v_pointer;
};

union anonymous$42
{
  // __data
  struct anonymous$41 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$40
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _GtkTreeIter
{
  // stamp
  signed int stamp;
  // user_data
  void *user_data;
  // user_data2
  void *user_data2;
  // user_data3
  void *user_data3;
};

struct NTTraverse
{
  // gs
  struct _GtkListStore *gs;
  // it
  struct _GtkTreeIter it;
  // res
  signed int res;
};

struct _ArtUta
{
  // x0
  signed int x0;
  // y0
  signed int y0;
  // width
  signed int width;
  // height
  signed int height;
  // utiles
  unsigned int *utiles;
};

struct _EATreePos
{
  // gv
  struct _GtkTreeView *gv;
  // gs
  struct _GtkListStore *gs;
};

struct _GArray
{
  // data
  char *data;
  // len
  unsigned int len;
};

struct _GClosure
{
  // ref_count
  volatile unsigned int ref_count : 15;
  // meta_marshal_nouse
  volatile unsigned int meta_marshal_nouse : 1;
  // n_guards
  volatile unsigned int n_guards : 1;
  // n_fnotifiers
  volatile unsigned int n_fnotifiers : 2;
  // n_inotifiers
  volatile unsigned int n_inotifiers : 8;
  // in_inotify
  volatile unsigned int in_inotify : 1;
  // floating
  volatile unsigned int floating : 1;
  // derivative_flag
  volatile unsigned int derivative_flag : 1;
  // in_marshal
  volatile unsigned int in_marshal : 1;
  // is_invalid
  volatile unsigned int is_invalid : 1;
  // marshal
  void (*marshal)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
  // data
  void *data;
  // notifiers
  struct _GClosureNotifyData *notifiers;
};

struct _GClosureNotifyData
{
  // data
  void *data;
  // notify
  void (*notify)(void *, struct _GClosure *);
};

struct _GError
{
  // domain
  unsigned int domain;
  // code
  signed int code;
  // message
  char *message;
};

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _GObjectClass
{
  // g_type_class
  struct _GTypeClass g_type_class;
  // construct_properties
  struct _GSList *construct_properties;
  // constructor
  struct _GObject * (*constructor)(unsigned long int, unsigned int, struct _GObjectConstructParam *);
  // set_property
  void (*set_property)(struct _GObject *, unsigned int, const struct _GValue *, struct _GParamSpec *);
  // get_property
  void (*get_property)(struct _GObject *, unsigned int, struct _GValue *, struct _GParamSpec *);
  // dispose
  void (*dispose)(struct _GObject *);
  // finalize
  void (*finalize)(struct _GObject *);
  // dispatch_properties_changed
  void (*dispatch_properties_changed)(struct _GObject *, unsigned int, struct _GParamSpec **);
  // notify
  void (*notify)(struct _GObject *, struct _GParamSpec *);
  // constructed
  void (*constructed)(struct _GObject *);
  // flags
  unsigned long int flags;
  // pdummy
  void *pdummy[6l];
};

struct _GObjectConstructParam
{
  // pspec
  struct _GParamSpec *pspec;
  // value
  struct _GValue *value;
};

struct _GParamSpec
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // name
  const char *name;
  // flags
  enum anonymous$79 flags;
  // value_type
  unsigned long int value_type;
  // owner_type
  unsigned long int owner_type;
  // _nick
  char *_nick;
  // _blurb
  char *_blurb;
  // qdata
  struct _GData *qdata;
  // ref_count
  unsigned int ref_count;
  // param_id
  unsigned int param_id;
};

struct _GSList
{
  // data
  void *data;
  // next
  struct _GSList *next;
};

struct _GString
{
  // str
  char *str;
  // len
  unsigned long int len;
  // allocated_len
  unsigned long int allocated_len;
};

struct _GValue
{
  // g_type
  unsigned long int g_type;
  // data
  union anonymous$68 data[2l];
};

struct _GdkColormap
{
  // parent_instance
  struct _GObject parent_instance;
  // size
  signed int size;
  // colors
  struct _GdkColor *colors;
  // visual
  struct _GdkVisual *visual;
  // windowing_data
  void *windowing_data;
};

struct _GdkDevice
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // source
  enum anonymous$49 source;
  // mode
  enum anonymous$50 mode;
  // has_cursor
  signed int has_cursor;
  // num_axes
  signed int num_axes;
  // axes
  struct _GdkDeviceAxis *axes;
  // num_keys
  signed int num_keys;
  // keys
  struct _GdkDeviceKey *keys;
};

struct _GdkDeviceAxis
{
  // use
  enum anonymous$58 use;
  // min
  double min;
  // max
  double max;
};

struct _GdkDeviceKey
{
  // keyval
  unsigned int keyval;
  // modifiers
  enum anonymous$57 modifiers;
};

struct _GdkDragContext
{
  // parent_instance
  struct _GObject parent_instance;
  // protocol
  enum anonymous$52 protocol;
  // is_source
  signed int is_source;
  // source_window
  struct _GdkDrawable *source_window;
  // dest_window
  struct _GdkDrawable *dest_window;
  // targets
  struct _GList *targets;
  // actions
  enum anonymous$53 actions;
  // suggested_action
  enum anonymous$53 suggested_action;
  // action
  enum anonymous$53 action;
  // start_time
  unsigned int start_time;
  // windowing_data
  void *windowing_data;
};

struct _GdkDrawable
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GdkEventAny
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkRectangle
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventExpose
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // area
  struct _GdkRectangle area;
  // region
  struct _GdkRegion *region;
  // count
  signed int count;
};

struct _GdkEventNoExpose
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkEventVisibility
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // state
  enum anonymous$47 state;
};

struct _GdkEventMotion
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // is_hint
  signed short int is_hint;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventButton
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventScroll
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // state
  unsigned int state;
  // direction
  enum anonymous$56 direction;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventKey
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // state
  unsigned int state;
  // keyval
  unsigned int keyval;
  // length
  signed int length;
  // string
  char *string;
  // hardware_keycode
  unsigned short int hardware_keycode;
  // group
  unsigned char group;
  // is_modifier
  unsigned int is_modifier : 1;
};

struct _GdkEventCrossing
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // subwindow
  struct _GdkDrawable *subwindow;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // mode
  enum anonymous$45 mode;
  // detail
  enum anonymous$46 detail;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct _GdkEventFocus
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // in
  signed short int in;
};

struct _GdkEventConfigure
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventProperty
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // atom
  struct _GdkAtom *atom;
  // time
  unsigned int time;
  // state
  unsigned int state;
};

struct _GdkEventSelection
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // property
  struct _GdkAtom *property;
  // time
  unsigned int time;
  // requestor
  unsigned int requestor;
};

struct _GdkEventOwnerChange
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // owner
  unsigned int owner;
  // reason
  enum anonymous$48 reason;
  // selection
  struct _GdkAtom *selection;
  // time
  unsigned int time;
  // selection_time
  unsigned int selection_time;
};

struct _GdkEventProximity
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // device
  struct _GdkDevice *device;
};

struct _GdkEventClient
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // message_type
  struct _GdkAtom *message_type;
  // data_format
  unsigned short int data_format;
  // data
  union anonymous$51 data;
};

struct _GdkEventDND
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // context
  struct _GdkDragContext *context;
  // time
  unsigned int time;
  // x_root
  signed short int x_root;
  // y_root
  signed short int y_root;
};

struct _GdkEventWindowState
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // changed_mask
  enum anonymous$54 changed_mask;
  // new_window_state
  enum anonymous$54 new_window_state;
};

struct _GdkEventSetting
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // action
  enum anonymous$55 action;
  // name
  char *name;
};

struct _GdkEventGrabBroken
{
  // type
  enum anonymous$44 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // keyboard
  signed int keyboard;
  // implicit
  signed int implicit;
  // grab_window
  struct _GdkDrawable *grab_window;
};

union _GdkEvent
{
  // type
  enum anonymous$44 type;
  // any
  struct _GdkEventAny any;
  // expose
  struct _GdkEventExpose expose;
  // no_expose
  struct _GdkEventNoExpose no_expose;
  // visibility
  struct _GdkEventVisibility visibility;
  // motion
  struct _GdkEventMotion motion;
  // button
  struct _GdkEventButton button;
  // scroll
  struct _GdkEventScroll scroll;
  // key
  struct _GdkEventKey key;
  // crossing
  struct _GdkEventCrossing crossing;
  // focus_change
  struct _GdkEventFocus focus_change;
  // configure
  struct _GdkEventConfigure configure;
  // property
  struct _GdkEventProperty property;
  // selection
  struct _GdkEventSelection selection;
  // owner_change
  struct _GdkEventOwnerChange owner_change;
  // proximity
  struct _GdkEventProximity proximity;
  // client
  struct _GdkEventClient client;
  // dnd
  struct _GdkEventDND dnd;
  // window_state
  struct _GdkEventWindowState window_state;
  // setting
  struct _GdkEventSetting setting;
  // grab_broken
  struct _GdkEventGrabBroken grab_broken;
};

struct _GdkFont
{
  // type
  enum anonymous$31 type;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct _GdkGC
{
  // parent_instance
  struct _GObject parent_instance;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // colormap
  struct _GdkColormap *colormap;
};

struct _GdkScreen
{
  // parent_instance
  struct _GObject parent_instance;
  // closed
  unsigned int closed : 1;
  // normal_gcs
  struct _GdkGC *normal_gcs[32l];
  // exposure_gcs
  struct _GdkGC *exposure_gcs[32l];
  // subwindow_gcs
  struct _GdkGC *subwindow_gcs[32l];
  // font_options
  struct _cairo_font_options *font_options;
  // resolution
  double resolution;
};

struct _GdkVisual
{
  // parent_instance
  struct _GObject parent_instance;
  // type
  enum anonymous$24 type;
  // depth
  signed int depth;
  // byte_order
  enum anonymous$23 byte_order;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
  // red_mask
  unsigned int red_mask;
  // red_shift
  signed int red_shift;
  // red_prec
  signed int red_prec;
  // green_mask
  unsigned int green_mask;
  // green_shift
  signed int green_shift;
  // green_prec
  signed int green_prec;
  // blue_mask
  unsigned int blue_mask;
  // blue_shift
  signed int blue_shift;
  // blue_prec
  signed int blue_prec;
};

struct _GladeXML
{
  // parent
  struct _GObject parent;
  // filename
  char *filename;
  // priv
  struct _GladeXMLPrivate *priv;
};

struct _GtkObject
{
  // parent_instance
  struct _GObject parent_instance;
  // flags
  unsigned int flags;
};

struct _GtkRequisition
{
  // width
  signed int width;
  // height
  signed int height;
};

struct _GtkWidget
{
  // object
  struct _GtkObject object;
  // private_flags
  unsigned short int private_flags;
  // state
  unsigned char state;
  // saved_state
  unsigned char saved_state;
  // name
  char *name;
  // style
  struct _GtkStyle *style;
  // requisition
  struct _GtkRequisition requisition;
  // allocation
  struct _GdkRectangle allocation;
  // window
  struct _GdkDrawable *window;
  // parent
  struct _GtkWidget *parent;
};

struct _GtkContainer
{
  // widget
  struct _GtkWidget widget;
  // focus_child
  struct _GtkWidget *focus_child;
  // border_width
  unsigned int border_width : 16;
  // need_resize
  unsigned int need_resize : 1;
  // resize_mode
  unsigned int resize_mode : 2;
  // reallocate_redraws
  unsigned int reallocate_redraws : 1;
  // has_focus_chain
  unsigned int has_focus_chain : 1;
};

struct _GtkLayout
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // hadjustment
  struct _GtkAdjustment *hadjustment;
  // vadjustment
  struct _GtkAdjustment *vadjustment;
  // bin_window
  struct _GdkDrawable *bin_window;
  // visibility
  enum anonymous$47 visibility;
  // scroll_x
  signed int scroll_x;
  // scroll_y
  signed int scroll_y;
  // freeze_count
  unsigned int freeze_count;
};

struct _GnomeCanvas
{
  // layout
  struct _GtkLayout layout;
  // root
  struct _GnomeCanvasItem *root;
  // redraw_area
  struct _ArtUta *redraw_area;
  // current_item
  struct _GnomeCanvasItem *current_item;
  // new_current_item
  struct _GnomeCanvasItem *new_current_item;
  // grabbed_item
  struct _GnomeCanvasItem *grabbed_item;
  // focused_item
  struct _GnomeCanvasItem *focused_item;
  // pixmap_gc
  struct _GdkGC *pixmap_gc;
  // pick_event
  union _GdkEvent pick_event;
  // scroll_x1
  double scroll_x1;
  // scroll_y1
  double scroll_y1;
  // scroll_x2
  double scroll_x2;
  // scroll_y2
  double scroll_y2;
  // pixels_per_unit
  double pixels_per_unit;
  // idle_id
  unsigned int idle_id;
  // root_destroy_id
  unsigned int root_destroy_id;
  // redraw_x1
  signed int redraw_x1;
  // redraw_y1
  signed int redraw_y1;
  // redraw_x2
  signed int redraw_x2;
  // redraw_y2
  signed int redraw_y2;
  // draw_xofs
  signed int draw_xofs;
  // draw_yofs
  signed int draw_yofs;
  // zoom_xofs
  signed int zoom_xofs;
  // zoom_yofs
  signed int zoom_yofs;
  // state
  signed int state;
  // grabbed_event_mask
  unsigned int grabbed_event_mask;
  // close_enough
  signed int close_enough;
  // center_scroll_region
  unsigned int center_scroll_region : 1;
  // need_update
  unsigned int need_update : 1;
  // need_redraw
  unsigned int need_redraw : 1;
  // need_repick
  unsigned int need_repick : 1;
  // left_grabbed_item
  unsigned int left_grabbed_item : 1;
  // in_repick
  unsigned int in_repick : 1;
  // aa
  unsigned int aa : 1;
  // dither
  enum anonymous$63 dither;
};

struct _GnomeCanvasItem
{
  // object
  struct _GtkObject object;
  // canvas
  struct _GnomeCanvas *canvas;
  // parent
  struct _GnomeCanvasItem *parent;
  // xform
  double *xform;
  // x1
  double x1;
  // y1
  double y1;
  // x2
  double x2;
  // y2
  double y2;
};

struct _GnomeCanvasGroup
{
  // item
  struct _GnomeCanvasItem item;
  // item_list
  struct _GList *item_list;
  // item_list_end
  struct _GList *item_list_end;
};

struct _GnomeCanvasPoints
{
  // coords
  double *coords;
  // num_points
  signed int num_points;
  // ref_count
  signed int ref_count;
};

struct _GnomeClient
{
  // object
  struct _GtkObject object;
  // smc_conn
  void *smc_conn;
  // client_id
  char *client_id;
  // previous_id
  char *previous_id;
  // config_prefix
  char *config_prefix;
  // global_config_prefix
  char *global_config_prefix;
  // static_args
  struct _GList *static_args;
  // clone_command
  char **clone_command;
  // current_directory
  char *current_directory;
  // discard_command
  char **discard_command;
  // environment
  struct _GHashTable *environment;
  // process_id
  signed int process_id;
  // program
  char *program;
  // resign_command
  char **resign_command;
  // restart_command
  char **restart_command;
  // restart_style
  enum anonymous$78 restart_style;
  // shutdown_command
  char **shutdown_command;
  // user_id
  char *user_id;
  // interaction_keys
  struct _GSList *interaction_keys;
  // input_id
  signed int input_id;
  // save_style
  unsigned int save_style : 2;
  // interact_style
  unsigned int interact_style : 2;
  // state
  unsigned int state : 3;
  // shutdown
  unsigned int shutdown : 1;
  // fast
  unsigned int fast : 1;
  // save_phase_2_requested
  unsigned int save_phase_2_requested : 1;
  // save_successfull
  unsigned int save_successfull : 1;
  // save_yourself_emitted
  unsigned int save_yourself_emitted : 1;
  // reserved
  void *reserved;
};

struct _GnomeModuleInfo
{
  // name
  const char *name;
  // version
  const char *version;
  // description
  const char *description;
  // requirements
  struct _GnomeModuleRequirement *requirements;
  // instance_init
  void (*instance_init)(struct _GnomeProgram *, struct _GnomeModuleInfo *);
  // pre_args_parse
  void (*pre_args_parse)(struct _GnomeProgram *, struct _GnomeModuleInfo *);
  // post_args_parse
  void (*post_args_parse)(struct _GnomeProgram *, struct _GnomeModuleInfo *);
  // options
  struct poptOption *options;
  // init_pass
  void (*init_pass)(const struct _GnomeModuleInfo *);
  // class_init
  void (*class_init)(struct _GnomeProgramClass *, const struct _GnomeModuleInfo *);
  // opt_prefix
  const char *opt_prefix;
  // get_goption_group_func
  struct _GOptionGroup * (*get_goption_group_func)(void);
};

struct _GnomeModuleRequirement
{
  // required_version
  const char *required_version;
  // module_info
  const struct _GnomeModuleInfo *module_info;
};

struct _GnomeProgram
{
  // object
  struct _GObject object;
  // _priv
  struct _GnomeProgramPrivate *_priv;
};

struct _GnomeProgramClass
{
  // object_class
  struct _GObjectClass object_class;
  // padding1
  void *padding1;
  // padding2
  void *padding2;
};

struct _GtkBin
{
  // container
  struct _GtkContainer container;
  // child
  struct _GtkWidget *child;
};

struct _GtkWindow
{
  // bin
  struct _GtkBin bin;
  // title
  char *title;
  // wmclass_name
  char *wmclass_name;
  // wmclass_class
  char *wmclass_class;
  // wm_role
  char *wm_role;
  // focus_widget
  struct _GtkWidget *focus_widget;
  // default_widget
  struct _GtkWidget *default_widget;
  // transient_parent
  struct _GtkWindow *transient_parent;
  // geometry_info
  struct _GtkWindowGeometryInfo *geometry_info;
  // frame
  struct _GdkDrawable *frame;
  // group
  struct _GtkWindowGroup *group;
  // configure_request_count
  unsigned short int configure_request_count;
  // allow_shrink
  unsigned int allow_shrink : 1;
  // allow_grow
  unsigned int allow_grow : 1;
  // configure_notify_received
  unsigned int configure_notify_received : 1;
  // need_default_position
  unsigned int need_default_position : 1;
  // need_default_size
  unsigned int need_default_size : 1;
  // position
  unsigned int position : 3;
  // type
  unsigned int type : 4;
  // has_user_ref_count
  unsigned int has_user_ref_count : 1;
  // has_focus
  unsigned int has_focus : 1;
  // modal
  unsigned int modal : 1;
  // destroy_with_parent
  unsigned int destroy_with_parent : 1;
  // has_frame
  unsigned int has_frame : 1;
  // iconify_initially
  unsigned int iconify_initially : 1;
  // stick_initially
  unsigned int stick_initially : 1;
  // maximize_initially
  unsigned int maximize_initially : 1;
  // decorated
  unsigned int decorated : 1;
  // type_hint
  unsigned int type_hint : 3;
  // gravity
  unsigned int gravity : 5;
  // is_active
  unsigned int is_active : 1;
  // has_toplevel_focus
  unsigned int has_toplevel_focus : 1;
  // frame_left
  unsigned int frame_left;
  // frame_top
  unsigned int frame_top;
  // frame_right
  unsigned int frame_right;
  // frame_bottom
  unsigned int frame_bottom;
  // keys_changed_handler
  unsigned int keys_changed_handler;
  // mnemonic_modifier
  enum anonymous$57 mnemonic_modifier;
  // screen
  struct _GdkScreen *screen;
};

struct _GtkDialog
{
  // window
  struct _GtkWindow window;
  // vbox
  struct _GtkWidget *vbox;
  // action_area
  struct _GtkWidget *action_area;
  // separator
  struct _GtkWidget *separator;
};

struct _GtkAboutDialog
{
  // parent_instance
  struct _GtkDialog parent_instance;
  // private_data
  void *private_data;
};

struct _GtkAdjustment
{
  // parent_instance
  struct _GtkObject parent_instance;
  // lower
  double lower;
  // upper
  double upper;
  // value
  double value;
  // step_increment
  double step_increment;
  // page_increment
  double page_increment;
  // page_size
  double page_size;
};

struct _GtkBox
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // spacing
  signed short int spacing;
  // homogeneous
  unsigned int homogeneous : 1;
};

struct _GtkButton
{
  // bin
  struct _GtkBin bin;
  // event_window
  struct _GdkDrawable *event_window;
  // label_text
  char *label_text;
  // activate_timeout
  unsigned int activate_timeout;
  // constructed
  unsigned int constructed : 1;
  // in_button
  unsigned int in_button : 1;
  // button_down
  unsigned int button_down : 1;
  // relief
  unsigned int relief : 2;
  // use_underline
  unsigned int use_underline : 1;
  // use_stock
  unsigned int use_stock : 1;
  // depressed
  unsigned int depressed : 1;
  // depress_on_activate
  unsigned int depress_on_activate : 1;
  // focus_on_click
  unsigned int focus_on_click : 1;
};

struct _GtkCellRenderer
{
  // parent
  struct _GtkObject parent;
  // xalign
  float xalign;
  // yalign
  float yalign;
  // width
  signed int width;
  // height
  signed int height;
  // xpad
  unsigned short int xpad;
  // ypad
  unsigned short int ypad;
  // mode
  unsigned int mode : 2;
  // visible
  unsigned int visible : 1;
  // is_expander
  unsigned int is_expander : 1;
  // is_expanded
  unsigned int is_expanded : 1;
  // cell_background_set
  unsigned int cell_background_set : 1;
  // sensitive
  unsigned int sensitive : 1;
  // editing
  unsigned int editing : 1;
};

struct _GtkItem
{
  // bin
  struct _GtkBin bin;
};

struct _GtkMenuItem
{
  // item
  struct _GtkItem item;
  // submenu
  struct _GtkWidget *submenu;
  // event_window
  struct _GdkDrawable *event_window;
  // toggle_size
  unsigned short int toggle_size;
  // accelerator_width
  unsigned short int accelerator_width;
  // accel_path
  char *accel_path;
  // show_submenu_indicator
  unsigned int show_submenu_indicator : 1;
  // submenu_placement
  unsigned int submenu_placement : 1;
  // submenu_direction
  unsigned int submenu_direction : 1;
  // right_justify
  unsigned int right_justify : 1;
  // timer_from_keypress
  unsigned int timer_from_keypress : 1;
  // from_menubar
  unsigned int from_menubar : 1;
  // timer
  unsigned int timer;
};

struct _GtkCheckMenuItem
{
  // menu_item
  struct _GtkMenuItem menu_item;
  // active
  unsigned int active : 1;
  // always_show_toggle
  unsigned int always_show_toggle : 1;
  // inconsistent
  unsigned int inconsistent : 1;
  // draw_as_radio
  unsigned int draw_as_radio : 1;
};

struct _GtkColorButton
{
  // button
  struct _GtkButton button;
  // priv
  struct _GtkColorButtonPrivate *priv;
};

struct _GtkVBox
{
  // box
  struct _GtkBox box;
};

struct _GtkColorSelection
{
  // parent_instance
  struct _GtkVBox parent_instance;
  // private_data
  void *private_data;
};

struct _GtkColorSelectionDialog
{
  // parent_instance
  struct _GtkDialog parent_instance;
  // colorsel
  struct _GtkWidget *colorsel;
  // ok_button
  struct _GtkWidget *ok_button;
  // cancel_button
  struct _GtkWidget *cancel_button;
  // help_button
  struct _GtkWidget *help_button;
};

struct _GtkComboBox
{
  // parent_instance
  struct _GtkBin parent_instance;
  // priv
  struct _GtkComboBoxPrivate *priv;
};

struct _GtkComboBoxEntry
{
  // parent_instance
  struct _GtkComboBox parent_instance;
  // priv
  struct _GtkComboBoxEntryPrivate *priv;
};

struct _GtkEntry
{
  // widget
  struct _GtkWidget widget;
  // text
  char *text;
  // editable
  unsigned int editable : 1;
  // visible
  unsigned int visible : 1;
  // overwrite_mode
  unsigned int overwrite_mode : 1;
  // in_drag
  unsigned int in_drag : 1;
  // text_length
  unsigned short int text_length;
  // text_max_length
  unsigned short int text_max_length;
  // text_area
  struct _GdkDrawable *text_area;
  // im_context
  struct _GtkIMContext *im_context;
  // popup_menu
  struct _GtkWidget *popup_menu;
  // current_pos
  signed int current_pos;
  // selection_bound
  signed int selection_bound;
  // cached_layout
  struct _PangoLayout *cached_layout;
  // cache_includes_preedit
  unsigned int cache_includes_preedit : 1;
  // need_im_reset
  unsigned int need_im_reset : 1;
  // has_frame
  unsigned int has_frame : 1;
  // activates_default
  unsigned int activates_default : 1;
  // cursor_visible
  unsigned int cursor_visible : 1;
  // in_click
  unsigned int in_click : 1;
  // is_cell_renderer
  unsigned int is_cell_renderer : 1;
  // editing_canceled
  unsigned int editing_canceled : 1;
  // mouse_cursor_obscured
  unsigned int mouse_cursor_obscured : 1;
  // select_words
  unsigned int select_words : 1;
  // select_lines
  unsigned int select_lines : 1;
  // resolved_dir
  unsigned int resolved_dir : 4;
  // truncate_multiline
  unsigned int truncate_multiline : 1;
  // button
  unsigned int button;
  // blink_timeout
  unsigned int blink_timeout;
  // recompute_idle
  unsigned int recompute_idle;
  // scroll_offset
  signed int scroll_offset;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
  // x_text_size
  unsigned short int x_text_size;
  // x_n_bytes
  unsigned short int x_n_bytes;
  // preedit_length
  unsigned short int preedit_length;
  // preedit_cursor
  unsigned short int preedit_cursor;
  // dnd_position
  signed int dnd_position;
  // drag_start_x
  signed int drag_start_x;
  // drag_start_y
  signed int drag_start_y;
  // invisible_char
  unsigned int invisible_char;
  // width_chars
  signed int width_chars;
};

struct _GtkFontButton
{
  // button
  struct _GtkButton button;
  // priv
  struct _GtkFontButtonPrivate *priv;
};

struct _GtkHBox
{
  // box
  struct _GtkBox box;
};

struct _GtkIMContext
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GtkMisc
{
  // widget
  struct _GtkWidget widget;
  // xalign
  float xalign;
  // yalign
  float yalign;
  // xpad
  unsigned short int xpad;
  // ypad
  unsigned short int ypad;
};

struct _GtkLabel
{
  // misc
  struct _GtkMisc misc;
  // label
  char *label;
  // jtype
  unsigned int jtype : 2;
  // wrap
  unsigned int wrap : 1;
  // use_underline
  unsigned int use_underline : 1;
  // use_markup
  unsigned int use_markup : 1;
  // ellipsize
  unsigned int ellipsize : 3;
  // single_line_mode
  unsigned int single_line_mode : 1;
  // have_transform
  unsigned int have_transform : 1;
  // in_click
  unsigned int in_click : 1;
  // wrap_mode
  unsigned int wrap_mode : 3;
  // pattern_set
  unsigned int pattern_set : 1;
  // track_links
  unsigned int track_links : 1;
  // mnemonic_keyval
  unsigned int mnemonic_keyval;
  // text
  char *text;
  // attrs
  struct _PangoAttrList *attrs;
  // effective_attrs
  struct _PangoAttrList *effective_attrs;
  // layout
  struct _PangoLayout *layout;
  // mnemonic_widget
  struct _GtkWidget *mnemonic_widget;
  // mnemonic_window
  struct _GtkWindow *mnemonic_window;
  // select_info
  struct _GtkLabelSelectionInfo *select_info;
};

struct _GtkListStore
{
  // parent
  struct _GObject parent;
  // stamp
  signed int stamp;
  // seq
  void *seq;
  // _gtk_reserved1
  void *_gtk_reserved1;
  // sort_list
  struct _GList *sort_list;
  // n_columns
  signed int n_columns;
  // sort_column_id
  signed int sort_column_id;
  // order
  enum anonymous$33 order;
  // column_headers
  unsigned long int *column_headers;
  // length
  signed int length;
  // default_sort_func
  signed int (*default_sort_func)(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, void *);
  // default_sort_data
  void *default_sort_data;
  // default_sort_destroy
  void (*default_sort_destroy)(void *);
  // columns_dirty
  unsigned int columns_dirty : 1;
};

struct _GtkMenuShell
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // active_menu_item
  struct _GtkWidget *active_menu_item;
  // parent_menu_shell
  struct _GtkWidget *parent_menu_shell;
  // button
  unsigned int button;
  // activate_time
  unsigned int activate_time;
  // active
  unsigned int active : 1;
  // have_grab
  unsigned int have_grab : 1;
  // have_xgrab
  unsigned int have_xgrab : 1;
  // ignore_leave
  unsigned int ignore_leave : 1;
  // menu_flag
  unsigned int menu_flag : 1;
  // ignore_enter
  unsigned int ignore_enter : 1;
  // keyboard_mode
  unsigned int keyboard_mode : 1;
};

struct _GtkRadioMenuItem
{
  // check_menu_item
  struct _GtkCheckMenuItem check_menu_item;
  // group
  struct _GSList *group;
};

struct _GtkRange
{
  // widget
  struct _GtkWidget widget;
  // adjustment
  struct _GtkAdjustment *adjustment;
  // update_policy
  enum anonymous$74 update_policy;
  // inverted
  unsigned int inverted : 1;
  // flippable
  unsigned int flippable : 1;
  // has_stepper_a
  unsigned int has_stepper_a : 1;
  // has_stepper_b
  unsigned int has_stepper_b : 1;
  // has_stepper_c
  unsigned int has_stepper_c : 1;
  // has_stepper_d
  unsigned int has_stepper_d : 1;
  // need_recalc
  unsigned int need_recalc : 1;
  // slider_size_fixed
  unsigned int slider_size_fixed : 1;
  // min_slider_size
  signed int min_slider_size;
  // orientation
  enum anonymous$75 orientation;
  // range_rect
  struct _GdkRectangle range_rect;
  // slider_start
  signed int slider_start;
  // slider_end
  signed int slider_end;
  // round_digits
  signed int round_digits;
  // trough_click_forward
  unsigned int trough_click_forward : 1;
  // update_pending
  unsigned int update_pending : 1;
  // layout
  struct _GtkRangeLayout *layout;
  // timer
  struct _GtkRangeStepTimer *timer;
  // slide_initial_slider_position
  signed int slide_initial_slider_position;
  // slide_initial_coordinate
  signed int slide_initial_coordinate;
  // update_timeout_id
  unsigned int update_timeout_id;
  // event_window
  struct _GdkDrawable *event_window;
};

struct _GtkRcStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // bg_pixmap_name
  char *bg_pixmap_name[5l];
  // font_desc
  struct _PangoFontDescription *font_desc;
  // color_flags
  enum anonymous$32 color_flags[5l];
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // rc_properties
  struct _GArray *rc_properties;
  // rc_style_lists
  struct _GSList *rc_style_lists;
  // icon_factories
  struct _GSList *icon_factories;
  // engine_specified
  unsigned int engine_specified : 1;
};

struct _GtkRecentManager
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GtkRecentManagerPrivate *priv;
};

struct _GtkSpinButton
{
  // entry
  struct _GtkEntry entry;
  // adjustment
  struct _GtkAdjustment *adjustment;
  // panel
  struct _GdkDrawable *panel;
  // timer
  unsigned int timer;
  // climb_rate
  double climb_rate;
  // timer_step
  double timer_step;
  // update_policy
  enum anonymous$72 update_policy;
  // in_child
  unsigned int in_child : 2;
  // click_child
  unsigned int click_child : 2;
  // button
  unsigned int button : 2;
  // need_timer
  unsigned int need_timer : 1;
  // timer_calls
  unsigned int timer_calls : 3;
  // digits
  unsigned int digits : 10;
  // numeric
  unsigned int numeric : 1;
  // wrap
  unsigned int wrap : 1;
  // snap_to_ticks
  unsigned int snap_to_ticks : 1;
};

struct _GtkStatusbar
{
  // parent_widget
  struct _GtkHBox parent_widget;
  // frame
  struct _GtkWidget *frame;
  // label
  struct _GtkWidget *label;
  // messages
  struct _GSList *messages;
  // keys
  struct _GSList *keys;
  // seq_context_id
  unsigned int seq_context_id;
  // seq_message_id
  unsigned int seq_message_id;
  // grip_window
  struct _GdkDrawable *grip_window;
  // has_resize_grip
  unsigned int has_resize_grip : 1;
};

struct _GtkStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // light
  struct _GdkColor light[5l];
  // dark
  struct _GdkColor dark[5l];
  // mid
  struct _GdkColor mid[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // text_aa
  struct _GdkColor text_aa[5l];
  // black
  struct _GdkColor black;
  // white
  struct _GdkColor white;
  // font_desc
  struct _PangoFontDescription *font_desc;
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // fg_gc
  struct _GdkGC *fg_gc[5l];
  // bg_gc
  struct _GdkGC *bg_gc[5l];
  // light_gc
  struct _GdkGC *light_gc[5l];
  // dark_gc
  struct _GdkGC *dark_gc[5l];
  // mid_gc
  struct _GdkGC *mid_gc[5l];
  // text_gc
  struct _GdkGC *text_gc[5l];
  // base_gc
  struct _GdkGC *base_gc[5l];
  // text_aa_gc
  struct _GdkGC *text_aa_gc[5l];
  // black_gc
  struct _GdkGC *black_gc;
  // white_gc
  struct _GdkGC *white_gc;
  // bg_pixmap
  struct _GdkDrawable *bg_pixmap[5l];
  // attach_count
  signed int attach_count;
  // depth
  signed int depth;
  // colormap
  struct _GdkColormap *colormap;
  // private_font
  struct _GdkFont *private_font;
  // private_font_desc
  struct _PangoFontDescription *private_font_desc;
  // rc_style
  struct _GtkRcStyle *rc_style;
  // styles
  struct _GSList *styles;
  // property_cache
  struct _GArray *property_cache;
  // icon_factories
  struct _GSList *icon_factories;
};

struct _GtkToggleButton
{
  // button
  struct _GtkButton button;
  // active
  unsigned int active : 1;
  // draw_indicator
  unsigned int draw_indicator : 1;
  // inconsistent
  unsigned int inconsistent : 1;
};

struct _GtkTreeModelSort
{
  // parent
  struct _GObject parent;
  // root
  void *root;
  // stamp
  signed int stamp;
  // child_flags
  unsigned int child_flags;
  // child_model
  struct _GtkTreeModel *child_model;
  // zero_ref_count
  signed int zero_ref_count;
  // sort_list
  struct _GList *sort_list;
  // sort_column_id
  signed int sort_column_id;
  // order
  enum anonymous$33 order;
  // default_sort_func
  signed int (*default_sort_func)(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, void *);
  // default_sort_data
  void *default_sort_data;
  // default_sort_destroy
  void (*default_sort_destroy)(void *);
  // changed_id
  unsigned int changed_id;
  // inserted_id
  unsigned int inserted_id;
  // has_child_toggled_id
  unsigned int has_child_toggled_id;
  // deleted_id
  unsigned int deleted_id;
  // reordered_id
  unsigned int reordered_id;
};

struct _GtkTreeView
{
  // parent
  struct _GtkContainer parent;
  // priv
  struct _GtkTreeViewPrivate *priv;
};

struct _GtkTreeViewColumn
{
  // parent
  struct _GtkObject parent;
  // tree_view
  struct _GtkWidget *tree_view;
  // button
  struct _GtkWidget *button;
  // child
  struct _GtkWidget *child;
  // arrow
  struct _GtkWidget *arrow;
  // alignment
  struct _GtkWidget *alignment;
  // window
  struct _GdkDrawable *window;
  // editable_widget
  struct _GtkCellEditable *editable_widget;
  // xalign
  float xalign;
  // property_changed_signal
  unsigned int property_changed_signal;
  // spacing
  signed int spacing;
  // column_type
  enum anonymous$73 column_type;
  // requested_width
  signed int requested_width;
  // button_request
  signed int button_request;
  // resized_width
  signed int resized_width;
  // width
  signed int width;
  // fixed_width
  signed int fixed_width;
  // min_width
  signed int min_width;
  // max_width
  signed int max_width;
  // drag_x
  signed int drag_x;
  // drag_y
  signed int drag_y;
  // title
  char *title;
  // cell_list
  struct _GList *cell_list;
  // sort_clicked_signal
  unsigned int sort_clicked_signal;
  // sort_column_changed_signal
  unsigned int sort_column_changed_signal;
  // sort_column_id
  signed int sort_column_id;
  // sort_order
  enum anonymous$33 sort_order;
  // visible
  unsigned int visible : 1;
  // resizable
  unsigned int resizable : 1;
  // clickable
  unsigned int clickable : 1;
  // dirty
  unsigned int dirty : 1;
  // show_sort_indicator
  unsigned int show_sort_indicator : 1;
  // maybe_reordered
  unsigned int maybe_reordered : 1;
  // reorderable
  unsigned int reorderable : 1;
  // use_resized_width
  unsigned int use_resized_width : 1;
  // expand
  unsigned int expand : 1;
};

struct _GtkWindowGroup
{
  // parent_instance
  struct _GObject parent_instance;
  // grabs
  struct _GSList *grabs;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _ether
{
  // addr
  unsigned char addr[6l];
  // name
  char name[64l];
};

struct appdata_struct
{
  // xml
  struct _GladeXML *xml;
  // app1
  struct _GtkWidget *app1;
  // statusbar
  struct _GtkStatusbar *statusbar;
  // now
  struct timeval now;
  // glade_file
  char *glade_file;
  // input_file
  char *input_file;
  // export_file
  char *export_file;
  // export_file_final
  char *export_file_final;
  // export_file_signal
  char *export_file_signal;
  // mode
  enum anonymous$13 mode;
  // node_limit
  signed int node_limit;
  // interface
  char *interface;
  // debug_mask
  enum anonymous$30 debug_mask;
  // min_delay
  unsigned long int min_delay;
  // max_delay
  unsigned long int max_delay;
  // n_packets
  unsigned long int n_packets;
  // total_mem_packets
  signed long int total_mem_packets;
  // request_dump
  signed int request_dump;
};

struct bpf_insn
{
  // code
  unsigned short int code;
  // jt
  unsigned char jt;
  // jf
  unsigned char jf;
  // k
  unsigned int k;
};

struct bpf_program
{
  // bf_len
  unsigned int bf_len;
  // bf_insns
  struct bpf_insn *bf_insns;
};

struct hashether
{
  // addr
  unsigned char addr[6l];
  // name
  char name[64l];
  // is_name_from_file
  signed int is_name_from_file;
  // next
  struct hashether *next;
};

struct hashmanuf
{
  // addr
  unsigned char addr[3l];
  // name
  char name[9l];
  // next
  struct hashmanuf *next;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct ipcache_item
{
  // nextid
  struct ipcache_item *nextid;
  // previousid
  struct ipcache_item *previousid;
  // nextip
  struct ipcache_item *nextip;
  // previousip
  struct ipcache_item *previousip;
  // next_active
  struct ipcache_item *next_active;
  // previous_active
  struct ipcache_item *previous_active;
  // expire_tick
  unsigned long int expire_tick;
  // last_expire_tick
  unsigned long int last_expire_tick;
  // fq_hostname
  char *fq_hostname;
  // ip
  struct anonymous$20 ip;
  // id
  unsigned short int id;
  // state
  enum IPCACHE_STATE state;
};

struct ipresolve_link
{
  // itemToResolve
  struct ipcache_item *itemToResolve;
  // next
  struct ipresolve_link *next;
};

struct linktype_data_tag
{
  // lt_desc
  const char *lt_desc;
  // dlt_linktype
  unsigned int dlt_linktype;
  // l2_idtype
  enum anonymous$13 l2_idtype;
  // fun
  void (*fun)(struct anonymous$3 *);
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pcap_addr
{
  // next
  struct pcap_addr *next;
  // addr
  struct sockaddr *addr;
  // netmask
  struct sockaddr *netmask;
  // broadaddr
  struct sockaddr *broadaddr;
  // dstaddr
  struct sockaddr *dstaddr;
};

struct pcap_if
{
  // next
  struct pcap_if *next;
  // name
  char *name;
  // description
  char *description;
  // addresses
  struct pcap_addr *addresses;
  // flags
  unsigned int flags;
};

struct pcap_pkthdr
{
  // ts
  struct timeval ts;
  // caplen
  unsigned int caplen;
  // len
  unsigned int len;
};

struct pcap_stat
{
  // ps_recv
  unsigned int ps_recv;
  // ps_drop
  unsigned int ps_drop;
  // ps_ifdrop
  unsigned int ps_ifdrop;
};

struct poptOption
{
  // longName
  const char *longName;
  // shortName
  char shortName;
  // argInfo
  unsigned int argInfo;
  // arg
  void *arg;
  // val
  signed int val;
  // descrip
  const char *descrip;
  // argDescrip
  const char *argDescrip;
};

struct pref_struct
{
  // name_res
  signed int name_res;
  // diagram_only
  signed int diagram_only;
  // group_unk
  signed int group_unk;
  // stationary
  signed int stationary;
  // node_radius_multiplier
  double node_radius_multiplier;
  // link_node_ratio
  double link_node_ratio;
  // size_mode
  enum anonymous$59 size_mode;
  // node_size_variable
  enum anonymous$60 node_size_variable;
  // filter
  char *filter;
  // text_color
  char *text_color;
  // fontname
  char *fontname;
  // center_node
  char *center_node;
  // stack_level
  unsigned int stack_level;
  // proto_timeout_time
  double proto_timeout_time;
  // gui_node_timeout_time
  double gui_node_timeout_time;
  // node_timeout_time
  double node_timeout_time;
  // proto_node_timeout_time
  double proto_node_timeout_time;
  // colors
  char **colors;
  // gui_link_timeout_time
  double gui_link_timeout_time;
  // link_timeout_time
  double link_timeout_time;
  // proto_link_timeout_time
  double proto_link_timeout_time;
  // refresh_period
  unsigned int refresh_period;
  // averaging_time
  double averaging_time;
};

struct protocol_list_item_t_tag
{
  // name
  char *name;
  // port
  unsigned int port;
  // color
  struct _GdkColor color;
  // rowstats
  struct anonymous$34 rowstats;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// active_list
// file ip-cache.c line 72
static struct ipcache_item *active_list = (struct ipcache_item *)(void *)0;
// all_links
// file links.c line 30
static struct _GTree *all_links = (struct _GTree *)(void *)0;
// all_nodes
// file node.c line 70
static struct _GTree *all_nodes = (struct _GTree *)(void *)0;
// already_updating
// file diagram.h line 24
signed int already_updating;
// appdata
// file appdata.h line 61
struct appdata_struct appdata;
// aseed
// file ip-cache.c line 77
signed long int aseed;
// black_color
// file diagram.c line 129
static struct _GdkColor black_color;
// canvas_links
// file diagram.c line 122
static struct _GTree *canvas_links;
// canvas_nodes
// file diagram.c line 118
static struct _GTree *canvas_nodes;
// canvas_obj_count
// file diagram.c line 135
static signed long int canvas_obj_count = (signed long int)0;
// capture_source
// file capture.c line 51
static signed int capture_source;
// capture_status
// file capture.c line 56
static enum status_t capture_status = (enum status_t)0;
// colors_changed
// file pref_dialog.c line 46
static signed int colors_changed = 0;
// conversations
// file conversations.c line 33
static struct _GList *conversations = (struct _GList *)(void *)0;
// current_cycle
// file datastructs.c line 52
static struct _GList *current_cycle = (struct _GList *)(void *)0;
// current_tick
// file ip-cache.c line 139
static unsigned long int current_tick = (unsigned long int)0;
// cycle_color_list
// file datastructs.c line 51
static struct _GList *cycle_color_list = (struct _GList *)(void *)0;
// diag_pref
// file pref_dialog.c line 47
static struct _GtkWidget *diag_pref = (struct _GtkWidget *)(void *)0;
// diagram_timeout
// file diagram.c line 132
static signed int diagram_timeout;
// displayed_nodes
// file diagram.c line 128
static unsigned int displayed_nodes;
// eth_p
// file resolv.c line 266
static struct _IO_FILE *eth_p = (struct _IO_FILE *)(void *)0;
// eth_resolution_initialized
// file resolv.c line 113
static signed int eth_resolution_initialized = 0;
// eth_table
// file resolv.c line 111
static struct hashether *eth_table[1024l];
// ethernet_sequence
// file node.c line 37
static struct anonymous$39 ethernet_sequence[17l] = { { .protocol="ETH_II", .must_resolve=(signed int)!(0 != 0) }, 
    { .protocol="802.2", .must_resolve=(signed int)!(0 != 0) }, 
    { .protocol="803.3", .must_resolve=(signed int)!(0 != 0) }, 
    { .protocol="FDDI", .must_resolve=(signed int)!(0 != 0) }, 
    { .protocol="IEEE802", .must_resolve=(signed int)!(0 != 0) }, 
    { .protocol="NETBIOS-DGM", .must_resolve=0 }, 
    { .protocol="NETBIOS-SSN", .must_resolve=0 }, 
    { .protocol="IP", .must_resolve=0 }, { .protocol="IPV6", .must_resolve=0 }, { .protocol="IPX-SAP", .must_resolve=0 }, 
    { .protocol="ARP", .must_resolve=0 }, { .protocol="ETH_II", .must_resolve=0 }, 
    { .protocol="802.2", .must_resolve=0 }, { .protocol="802.3", .must_resolve=0 }, { .protocol="FDDI", .must_resolve=0 }, { .protocol="IEEE802", .must_resolve=0 }, 
    { .protocol=(const char *)(void *)0, .must_resolve=0 } };
// g_ascii_table
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 53
extern const unsigned short int * const g_ascii_table;
// g_ethers_path
// file resolv.c line 119
static char *g_ethers_path = "/etc/ethers";
// g_manuf_path
// file resolv.c line 121
static char *g_manuf_path = "/etc/manuf";
// g_pethers_path
// file resolv.c line 120
static char *g_pethers_path = (char *)(void *)0;
// idbash
// file ip-cache.c line 68
struct ipcache_item *idbash[8192l];
// idseed
// file ip-cache.c line 76
signed long int idseed = (signed long int)0xdeadbeef;
// in_start_capture
// file menus.c line 37
static signed int in_start_capture = 0;
// ip_sequence
// file node.c line 57
static struct anonymous$39 ip_sequence[5l] = { { .protocol="NETBIOS-DGM", .must_resolve=0 }, 
    { .protocol="NETBIOS-SSN", .must_resolve=0 }, 
    { .protocol="IP", .must_resolve=0 }, { .protocol="IPV6", .must_resolve=0 }, { .protocol=(const char *)(void *)0, .must_resolve=0 } };
// ipbash
// file ip-cache.c line 69
struct ipcache_item *ipbash[8192l];
// is_idle
// file diagram.c line 127
static signed int is_idle = 0;
// known_protocols
// file diagram.c line 124
static unsigned int known_protocols = (unsigned int)0;
// linktypes
// file decode_proto.c line 163
static struct linktype_data_tag linktypes[11l];
// linktypes
// file decode_proto.c line 163
static struct linktype_data_tag linktypes[11l] = { { .lt_desc="Ethernet", .dlt_linktype=(unsigned int)1, .l2_idtype=(enum anonymous$13)LINK6,
    .fun=get_eth_type }, 
    { .lt_desc="RAW", .dlt_linktype=(unsigned int)12, .l2_idtype=(enum anonymous$13)IP,
    .fun=get_ip }, 
    { .lt_desc="LINUX_SLL", .dlt_linktype=(unsigned int)113, .l2_idtype=(enum anonymous$13)IP,
    .fun=get_linux_sll }, 
    { .lt_desc="BSD Loopback", .dlt_linktype=(unsigned int)0, .l2_idtype=(enum anonymous$13)IP,
    .fun=get_loop }, 
    { .lt_desc="OpenBSD Loopback", .dlt_linktype=(unsigned int)108, .l2_idtype=(enum anonymous$13)IP,
    .fun=get_loop }, 
    { .lt_desc="FDDI", .dlt_linktype=(unsigned int)10, .l2_idtype=(enum anonymous$13)LINK6,
    .fun=get_fddi_type }, 
    { .lt_desc="IEEE802.5", .dlt_linktype=(unsigned int)6, .l2_idtype=(enum anonymous$13)LINK6,
    .fun=get_ieee802_5_type }, 
    { .lt_desc="WLAN", .dlt_linktype=(unsigned int)105, .l2_idtype=(enum anonymous$13)LINK6,
    .fun=get_wlan }, 
    { .lt_desc="WLAN+RTAP", .dlt_linktype=(unsigned int)127, .l2_idtype=(enum anonymous$13)LINK6,
    .fun=get_radiotap }, 
    { .lt_desc="PPI", .dlt_linktype=(unsigned int)192, .l2_idtype=(enum anonymous$13)LINK6,
    .fun=get_ppi }, 
    { .lt_desc=(const char *)(void *)0, .dlt_linktype=(unsigned int)0, .l2_idtype=(enum anonymous$13)0,
    .fun=(void (*)(struct anonymous$3 *))(void *)0 } };
// lkentry
// file decode_proto.c line 161
const struct linktype_data_tag *lkentry = (const struct linktype_data_tag *)(void *)0;
// manuf_table
// file resolv.c line 110
static struct hashmanuf *manuf_table[256l];
// max_active
// file ip-cache.c line 74
static signed long int max_active = (signed long int)1024;
// ms_to_next
// file capture.c line 53
static unsigned long int ms_to_next;
// n_conversations
// file conversations.c line 34
static signed long int n_conversations = (signed long int)0;
// name_type_vals
// file names_netbios.c line 50
static const struct anonymous$15 name_type_vals[30l] = { { .number=0x00, .name="Workstation/Redirector" }, 
    { .number=0x01, .name="Browser" }, { .number=0x02, .name="Workstation/Redirector" }, 
    { .number=0x03, .name="Messenger service/Main name" }, 
    { .number=0x05, .name="Forwarded name" }, 
    { .number=0x06, .name="RAS Server service" }, 
    { .number=0x1b, .name="PDC Domain name" }, 
    { .number=0x1c, .name="BDC Domain name" }, 
    { .number=0x1d, .name="Master Browser backup" }, 
    { .number=0x1e, .name="Browser Election Service" }, 
    { .number=0x1f, .name="Net DDE Service" }, 
    { .number=0x20, .name="Server service" }, 
    { .number=0x21, .name="RAS client service" }, 
    { .number=0x22, .name="Exchange Interchange (MSMail Connector)" }, 
    { .number=0x23, .name="Exchange Store" }, 
    { .number=0x24, .name="Exchange Directory" }, 
    { .number=0x2b, .name="Lotus Notes Server service" }, 
    { .number=0x30, .name="Modem sharing server service" }, 
    { .number=0x31, .name="Modem sharing client service" }, 
    { .number=0x43, .name="SMS Clients Remote Control" }, 
    { .number=0x44, .name="SMS Administrators Remote Control Tool" }, 
    { .number=0x45, .name="SMS Clients Remote Chat" }, 
    { .number=0x46, .name="SMS Clients Remote Transfer" }, 
    { .number=0x4c, .name="DEC Pathworks TCP/IP Service on Windows NT" }, 
    { .number=0x52, .name="DEC Pathworks TCP/IP Service on Windows NT" }, 
    { .number=0x6a, .name="Microsoft Exchange IMC" }, 
    { .number=0x87, .name="Microsoft Exchange MTA" }, 
    { .number=0xbe, .name="Network Monitor Agent" }, 
    { .number=0xbf, .name="Network Monitor Analyzer" }, 
    { .number=0x00, .name=(char *)(void *)0 } };
// need_font_refresh
// file diagram.c line 131
static signed int need_font_refresh = (signed int)!(0 != 0);
// need_reposition
// file diagram.c line 130
static signed int need_reposition = (signed int)!(0 != 0);
// new_nodes
// file node.c line 412
static struct _GList *new_nodes = (struct _GList *)(void *)0;
// node_name_count
// file node_id.c line 192
static signed long int node_name_count = (signed long int)0;
// nodes_check
// file node_windows.c line 44
static struct _GtkCheckMenuItem *nodes_check = (struct _GtkCheckMenuItem *)(void *)0;
// nodes_num
// file node.c line 71
static signed int nodes_num = 0;
// nodes_wnd
// file node_windows.c line 43
static struct _GtkWidget *nodes_wnd = (struct _GtkWidget *)(void *)0;
// num_active
// file ip-cache.c line 73
static signed long int num_active = (signed long int)0;
// old_sighup_handler
// file main.c line 47
static void (*old_sighup_handler)(signed int);
// packet_list_item_n
// file basic_stats.c line 30
static signed long int packet_list_item_n = (signed long int)0;
// pcap_fd
// file capture.c line 50
static signed int pcap_fd;
// pch_struct
// file capture.c line 49
static struct pcap *pch_struct;
// poptHelpOptions
// file /usr/include/popt.h line 183
extern struct poptOption poptHelpOptions[];
// pref
// file preferences.h line 89
struct pref_struct pref;
// pref_group
// file preferences.c line 34
static const char *pref_group = "Diagram";
// prot_functions_table
// file names.c line 80
static struct anonymous$12 prot_functions_table[19l];
// prot_functions_table
// file names.c line 80
static struct anonymous$12 prot_functions_table[19l] = { { .prot="ETH_II", .function=get_link6_name }, 
    { .prot="802.2", .function=get_link6_name }, 
    { .prot="802.3", .function=get_link6_name }, 
    { .prot="ISL", .function=get_link6_name }, 
    { .prot="NULL", .function=get_null_name }, 
    { .prot="LINUX-SLL", .function=get_linux_sll_name }, 
    { .prot="FDDI", .function=get_link6_name }, 
    { .prot="Token Ring", .function=get_link6_name }, 
    { .prot="LLC", .function=get_llc_name }, 
    { .prot="ARP", .function=get_arp_name }, 
    { .prot="IP", .function=get_ip_name }, { .prot="IPV6", .function=get_ipv6_name }, 
    { .prot="IPX", .function=get_ipx_name }, 
    { .prot="TCP", .function=get_tcp_name }, 
    { .prot="UDP", .function=get_udp_name }, 
    { .prot="IPX-SAP", .function=get_ipxsap_name }, 
    { .prot="NETBIOS-SSN", .function=get_nbss_name }, 
    { .prot="NETBIOS-DGM", .function=get_nbdgm_name }, 
    { .prot=(char *)(void *)0, .function=(signed int (*)(struct anonymous$9 *))(void *)0 } };
// prot_info_windows
// file info_windows.c line 71
static struct _GList *prot_info_windows = (struct _GList *)(void *)0;
// protohash
// file datastructs.c line 50
static struct _GHashTable *protohash = (struct _GHashTable *)(void *)0;
// protosummary_stats
// file protocols.c line 489
static struct anonymous$27 *protosummary_stats = (struct anonymous$27 *)(void *)0;
// quiet
// file main.c line 46
static signed int quiet = 0;
// request_stop_thread
// file thread_resolve.c line 70
static signed int request_stop_thread = 0;
// resolveListHead
// file thread_resolve.c line 67
static struct ipresolve_link *resolveListHead = (struct ipresolve_link *)(void *)0;
// resolveListTail
// file thread_resolve.c line 68
static struct ipresolve_link *resolveListTail = (struct ipresolve_link *)(void *)0;
// resolvecond
// file thread_resolve.c line 75
static union anonymous$42 resolvecond;
// resolvemtx
// file thread_resolve.c line 74
static union anonymous$40 resolvemtx;
// resolver_threads
// file thread_resolve.c line 58
static unsigned long int resolver_threads[6l];
// resolver_threads_num
// file thread_resolve.c line 59
static signed int resolver_threads_num = 0;
// service_names
// file datastructs.c line 38
static struct _GTree *service_names = (struct _GTree *)(void *)0;
// stats_info_windows
// file info_windows.c line 68
static struct _GList *stats_info_windows = (struct _GList *)(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stop_requested
// file diagram.h line 25
signed int stop_requested;
// tcp_sequence
// file node.c line 65
static struct anonymous$39 tcp_sequence[2l] = { { .protocol="TCP", .must_resolve=0 }, { .protocol=(const char *)(void *)0, .must_resolve=0 } };
// tcp_services
// file datastructs.c line 39
static struct _GTree *tcp_services = (struct _GTree *)(void *)0;
// tmp_pref
// file pref_dialog.c line 48
static struct pref_struct *tmp_pref = (struct pref_struct *)(void *)0;
// udp_services
// file datastructs.c line 40
static struct _GTree *udp_services = (struct _GTree *)(void *)0;

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32$1;
  return_value___builtin_bswap32$1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32$1;
}

// active_conversations
// file conversations.h line 39
signed long int active_conversations(void)
{
  return n_conversations;
}

// active_names
// file node_id.h line 69
signed long int active_names(void)
{
  return node_name_count;
}

// add_conversation
// file conversations.h line 31
void add_conversation(struct anonymous$20 *src_address, struct anonymous$20 *dst_address, unsigned short int src_port, unsigned short int dst_port, const char *data)
{
  struct anonymous$61 *conv = (struct anonymous$61 *)(void *)0;
  const char *old_data = (const char *)(void *)0;
  signed int tmp_statement_expression$5;
  const char *return_value_address_to_str$1;
  const char *return_value_address_to_str$2;
  const char *return_value_address_to_str$3;
  const char *return_value_address_to_str$4;
  signed int tmp_statement_expression$10;
  if(dst_address == ((struct anonymous$20 *)NULL) || src_address == ((struct anonymous$20 *)NULL))
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, "NULL ptr in add_conversation");

  else
  {
    old_data=find_conversation(src_address, dst_address, src_port, dst_port);
    if(!(old_data == ((const char *)NULL)))
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp$6;
      return_value___builtin_strcmp$6=__builtin_strcmp(old_data, data);
      tmp_statement_expression$5 = return_value___builtin_strcmp$6;
      if(tmp_statement_expression$5 == 0)
      {
        return_value_address_to_str$1=address_to_str(src_address);
        return_value_address_to_str$2=address_to_str(dst_address);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, "Conflicting conversations %s:%d-%s:%d in add_conversation", return_value_address_to_str$1, src_port, return_value_address_to_str$2, dst_port);
      }

      else
      {
        return_value_address_to_str$3=address_to_str(src_address);
        return_value_address_to_str$4=address_to_str(dst_address);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Conversation %s:%d-%s:%d %s already exists in add_conversation", return_value_address_to_str$3, src_port, return_value_address_to_str$4, dst_port, data);
      }
      goto __CPROVER_DUMP_L10;
    }

    const char *return_value_address_to_str$7;
    return_value_address_to_str$7=address_to_str(src_address);
    const char *return_value_address_to_str$8;
    return_value_address_to_str$8=address_to_str(dst_address);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Adding new conversation %s:%d-%s:%d %s", return_value_address_to_str$7, src_port, return_value_address_to_str$8, dst_port, data);
    void *return_value_g_malloc$9;
    return_value_g_malloc$9=g_malloc(sizeof(struct anonymous$61) /*56ul*/ );
    conv = (struct anonymous$61 *)return_value_g_malloc$9;
    do
    {
      signed int _g_boolean_var_;
      if(!(conv == ((struct anonymous$61 *)NULL)))
        _g_boolean_var_ = 1;

      else
        _g_boolean_var_ = 0;
      tmp_statement_expression$10 = _g_boolean_var_;
      if((signed long int)tmp_statement_expression$10 == 0l)
        g_assertion_message_expr((char *)0, "conversations.c", 113, (const char *)"add_conversation", "conv");

    }
    while((_Bool)0);
    memmove((void *)&conv->src_address, (const void *)src_address, sizeof(struct anonymous$20) /*20ul*/ );
    memmove((void *)&conv->dst_address, (const void *)dst_address, sizeof(struct anonymous$20) /*20ul*/ );
    conv->src_port = src_port;
    conv->dst_port = dst_port;
    conv->data=g_strdup(data);
    conversations=g_list_prepend(conversations, (void *)conv);
    n_conversations = n_conversations + 1l;
  }

__CPROVER_DUMP_L10:
  ;
}

// add_manuf_name
// file resolv.c line 338
static void add_manuf_name(unsigned char *addr, char *name)
{
  struct hashmanuf *tp;
  struct hashmanuf **table = manuf_table;
  tp = table[(signed long int)((signed int)addr[(signed long int)2] & 256 - 1)];
  signed int tmp_statement_expression$3;
  if(tp == ((struct hashmanuf *)NULL))
  {
    void *return_value_g_malloc$1;
    return_value_g_malloc$1=g_malloc(sizeof(struct hashmanuf) /*24ul*/ );
    table[(signed long int)((signed int)addr[(signed long int)2] & 256 - 1)] = (struct hashmanuf *)return_value_g_malloc$1;
    tp = table[(signed long int)((signed int)addr[(signed long int)2] & 256 - 1)];
  }

  else
    for( ; (_Bool)1; tp = tp->next)
      if(tp->next == ((struct hashmanuf *)NULL))
      {
        void *return_value_g_malloc$2;
        return_value_g_malloc$2=g_malloc(sizeof(struct hashmanuf) /*24ul*/ );
        tp->next = (struct hashmanuf *)return_value_g_malloc$2;
        do
        {
          signed int _g_boolean_var_;
          if(!(tp->next == ((struct hashmanuf *)NULL)))
            _g_boolean_var_ = 1;

          else
            _g_boolean_var_ = 0;
          tmp_statement_expression$3 = _g_boolean_var_;
          if((signed long int)tmp_statement_expression$3 == 0l)
            g_assertion_message_expr((char *)0, "resolv.c", 358, (const char *)"add_manuf_name", "tp->next");

        }
        while((_Bool)0);
        tp = tp->next;
        break;
      }

  signed int tmp_statement_expression$4;
  do
  {
    signed int add_manuf_name$$1$$3$$1$$_g_boolean_var_;
    if(!(tp == ((struct hashmanuf *)NULL)))
      add_manuf_name$$1$$3$$1$$_g_boolean_var_ = 1;

    else
      add_manuf_name$$1$$3$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$4 = add_manuf_name$$1$$3$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$4 == 0l)
      g_assertion_message_expr((char *)0, "resolv.c", 366, (const char *)"add_manuf_name", "tp");

  }
  while((_Bool)0);
  memcpy((void *)tp->addr, (const void *)addr, sizeof(unsigned char [3l]) /*3ul*/ );
  safe_strncpy(tp->name, name, (unsigned long int)9);
  tp->next = (struct hashmanuf *)(void *)0;
}

// add_name
// file names.c line 631
static void add_name(const char *numeric_name, const char *resolved_name, const struct anonymous$5 *node_id, const struct anonymous$9 *nt)
{
  struct anonymous$26 *protocol = (struct anonymous$26 *)(void *)0;
  struct _GList *name_item = (struct _GList *)(void *)0;
  struct anonymous$36 *name = (struct anonymous$36 *)(void *)0;
  struct anonymous$36 key;
  const struct anonymous$26 *return_value_protocol_stack_find$1;
  return_value_protocol_stack_find$1=protocol_stack_find(nt->decoder.protos, (unsigned long int)nt->decoder.level, nt->decoder.tokens->protonames[(signed long int)nt->decoder.level]);
  protocol = (struct anonymous$26 *)return_value_protocol_stack_find$1;
  key.node_id = *node_id;
  name_item=g_list_find_custom(protocol->node_names, (const void *)&key, (signed int (*)(const void *, const void *))node_name_id_compare);
  if(!(name_item == ((struct _GList *)NULL)))
    name = (struct anonymous$36 *)name_item->data;

  else
  {
    name=node_name_create(node_id);
    protocol->node_names=g_list_prepend(protocol->node_names, (void *)name);
  }
  if(pref.name_res == 0)
    node_name_assign(name, (const char *)(void *)0, numeric_name, (double)nt->packet_size);

  else
    node_name_assign(name, resolved_name, numeric_name, (double)nt->packet_size);
}

// add_node_packet
// file decode_proto.c line 328
static void add_node_packet(const unsigned char *raw_packet, unsigned int raw_size, struct anonymous$6 *packet, const struct anonymous$5 *node_id, enum anonymous$7 direction)
{
  struct anonymous$19 *node;
  node=nodes_catalog_find(node_id);
  signed int tmp_statement_expression$1;
  if(node == ((struct anonymous$19 *)NULL))
  {
    node=nodes_catalog_new(node_id);
    do
    {
      signed int _g_boolean_var_;
      if(!(node == ((struct anonymous$19 *)NULL)))
        _g_boolean_var_ = 1;

      else
        _g_boolean_var_ = 0;
      tmp_statement_expression$1 = _g_boolean_var_;
      if((signed long int)tmp_statement_expression$1 == 0l)
        g_assertion_message_expr((char *)0, "decode_proto.c", 341, (const char *)"add_node_packet", "node");

    }
    while((_Bool)0);
  }

  traffic_stats_add_packet(&node->node_stats, packet, direction);
  if(node->node_stats.pkt_list.length == 1u)
    new_nodes_add(node);

  get_packet_names(&node->node_stats.stats_protos, raw_packet, (unsigned short int)raw_size, packet->prot_desc, direction, (signed int)lkentry->dlt_linktype);
}

// add_offset
// file decode_proto.c line 247
static void add_offset(struct anonymous$3 *dp, unsigned int offset)
{
  if(!(dp->cur_len >= offset))
    dp->cur_len = (unsigned int)0;

  else
  {
    dp->cur_packet = dp->cur_packet + (signed long int)offset;
    dp->cur_len = dp->cur_len - offset;
  }
}

// add_ordered_node
// file diagram.c line 865
static signed int add_ordered_node(struct anonymous$5 *node_id, struct anonymous$82 *node, struct _GTree *ordered_nodes)
{
  g_tree_insert(ordered_nodes, (void *)node, (void *)node);
  signed int return_value_g_tree_nnodes$1;
  return_value_g_tree_nnodes$1=g_tree_nnodes(ordered_nodes);
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Adding ordered node. Number of nodes: %d", return_value_g_tree_nnodes$1);
  return 0;
}

// addref_canvas_obj
// file diagram.c line 209
static void addref_canvas_obj(struct _GObject *obj)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(obj == ((struct _GObject *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "diagram.c", 211, (const char *)"addref_canvas_obj", "obj");

  }
  while((_Bool)0);
  g_object_ref_sink((void *)obj);
  if(!((G_LOG_LEVEL_INFO & (signed int)appdata.debug_mask) == 0))
  {
    g_object_weak_ref(obj, finalize_callback, (void *)0);
    canvas_obj_count = canvas_obj_count + 1l;
  }

}

// address_to_str
// file util.c line 366
const char * address_to_str(const struct anonymous$20 *ad)
{
  const char *return_value_ipv4_to_str$1;
  const char *return_value_ipv6_to_str$2;
  if(ad == ((const struct anonymous$20 *)NULL))
    return "<null addr>";

  else
    switch(ad->$anon0.$anon0.type)
    {
      case (unsigned int)2:
      {
        return_value_ipv4_to_str$1=ipv4_to_str(ad->$anon0.$anon0.$anon0.addr_v4);
        return return_value_ipv4_to_str$1;
      }
      case (unsigned int)10:
      {
        return_value_ipv6_to_str$2=ipv6_to_str(ad->$anon0.$anon0.$anon0.addr_v6);
        return return_value_ipv6_to_str$2;
      }
      default:
        return "<invalid address family>";
    }
}

// appdata_free
// file appdata.c line 76
void appdata_free(struct appdata_struct *p)
{
  g_free((void *)p->glade_file);
  p->glade_file = (char *)(void *)0;
  g_free((void *)p->input_file);
  p->input_file = (char *)(void *)0;
  g_free((void *)p->export_file);
  p->export_file = (char *)(void *)0;
  g_free((void *)p->export_file_final);
  p->export_file_final = (char *)(void *)0;
  g_free((void *)p->export_file_signal);
  p->export_file_signal = (char *)(void *)0;
  g_free((void *)p->interface);
  p->interface = (char *)(void *)0;
}

// appdata_init
// file appdata.h line 66
void appdata_init(struct appdata_struct *p)
{
  gettimeofday(&p->now, (struct timezone *)(void *)0);
  p->xml = (struct _GladeXML *)(void *)0;
  p->app1 = (struct _GtkWidget *)(void *)0;
  p->statusbar = (struct _GtkStatusbar *)(void *)0;
  p->glade_file = (char *)(void *)0;
  p->input_file = (char *)(void *)0;
  p->export_file = (char *)(void *)0;
  p->export_file_final = (char *)(void *)0;
  p->export_file_signal = (char *)(void *)0;
  p->interface = (char *)(void *)0;
  p->mode = (enum anonymous$13)IP;
  p->node_limit = -1;
  p->debug_mask = (enum anonymous$30)(G_LOG_LEVEL_MASK & ~(G_LOG_LEVEL_DEBUG | G_LOG_LEVEL_INFO));
  p->min_delay = (unsigned long int)0;
  p->max_delay = (unsigned long int)0x7fffffffffffffffL * 2UL + 1UL;
  p->n_packets = (unsigned long int)0;
  p->total_mem_packets = (signed long int)0;
  p->request_dump = 0;
}

// appdata_init_glade
// file appdata.h line 67
signed int appdata_init_glade(char *new_glade_file)
{
  if(!(new_glade_file == ((char *)NULL)))
    appdata.glade_file=g_strdup(new_glade_file);

  else
    appdata.glade_file=g_strdup("/usr/share/etherape/glade/etherape.glade");
  appdata.xml=glade_xml_new(appdata.glade_file, (const char *)(void *)0, (const char *)(void *)0);
  if(appdata.xml == ((struct _GladeXML *)NULL))
  {
    char *return_value_dcgettext$1;
    return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Could not load glade interface file '%s'!", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_ERROR, return_value_dcgettext$1, appdata.glade_file);

  __CPROVER_DUMP_L4:
    ;
    goto __CPROVER_DUMP_L4;
    return 0;
  }

  else
  {
    glade_xml_signal_autoconnect(appdata.xml);
    appdata.app1=glade_xml_get_widget(appdata.xml, "app1");
    struct _GtkWidget *return_value_glade_xml_get_widget$2;
    return_value_glade_xml_get_widget$2=glade_xml_get_widget(appdata.xml, "statusbar1");
    unsigned long int return_value_gtk_statusbar_get_type$3;
    return_value_gtk_statusbar_get_type$3=gtk_statusbar_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$2, return_value_gtk_statusbar_get_type$3);
    appdata.statusbar = (struct _GtkStatusbar *)return_value_g_type_check_instance_cast$4;
    return (signed int)!(0 != 0);
  }
}

// append_etype_prot
// file decode_proto.c line 1652
static void append_etype_prot(struct anonymous$3 *dp, enum anonymous$8 etype)
{
  switch((signed int)etype)
  {
    case ETHERTYPE_IP:
    {
      decode_proto_add(dp, "IP");
      break;
    }
    case ETHERTYPE_ARP:
    {
      decode_proto_add(dp, "ARP");
      break;
    }
    case ETHERTYPE_IPv6:
    {
      decode_proto_add(dp, "IPV6");
      break;
    }
    case ETHERTYPE_X25L3:
    {
      decode_proto_add(dp, "X25L3");
      break;
    }
    case ETHERTYPE_REVARP:
    {
      decode_proto_add(dp, "REVARP");
      break;
    }
    case ETHERTYPE_ATALK:
    {
      decode_proto_add(dp, "ATALK");
      break;
    }
    case ETHERTYPE_AARP:
    {
      decode_proto_add(dp, "AARP");
      break;
    }
    case ETHERTYPE_IPX:
      break;
    case ETHERTYPE_VINES:
    {
      decode_proto_add(dp, "VINES");
      break;
    }
    case ETHERTYPE_TRAIN:
    {
      decode_proto_add(dp, "TRAIN");
      break;
    }
    case ETHERTYPE_LOOP:
    {
      decode_proto_add(dp, "LOOP");
      break;
    }
    case ETHERTYPE_PPPOED:
    {
      decode_proto_add(dp, "PPPOED");
      break;
    }
    case ETHERTYPE_PPPOES:
    {
      decode_proto_add(dp, "PPPOES");
      break;
    }
    case ETHERTYPE_VLAN:
    {
      decode_proto_add(dp, "VLAN");
      break;
    }
    case ETHERTYPE_SNMP:
    {
      decode_proto_add(dp, "SNMP");
      break;
    }
    case ETHERTYPE_DNA_DL:
    {
      decode_proto_add(dp, "DNA-DL");
      break;
    }
    case ETHERTYPE_DNA_RC:
    {
      decode_proto_add(dp, "DNA-RC");
      break;
    }
    case ETHERTYPE_DNA_RT:
    {
      decode_proto_add(dp, "DNA-RT");
      break;
    }
    case ETHERTYPE_DEC:
    {
      decode_proto_add(dp, "DEC");
      break;
    }
    case ETHERTYPE_DEC_DIAG:
    {
      decode_proto_add(dp, "DEC-DIAG");
      break;
    }
    case ETHERTYPE_DEC_CUST:
    {
      decode_proto_add(dp, "DEC-CUST");
      break;
    }
    case ETHERTYPE_DEC_SCA:
    {
      decode_proto_add(dp, "DEC-SCA");
      break;
    }
    case ETHERTYPE_DEC_LB:
    {
      decode_proto_add(dp, "DEC-LB");
      break;
    }
    case ETHERTYPE_MPLS:
    {
      decode_proto_add(dp, "MPLS");
      break;
    }
    case ETHERTYPE_MPLS_MULTI:
    {
      decode_proto_add(dp, "MPLS-MULTI");
      break;
    }
    case ETHERTYPE_LAT:
    {
      decode_proto_add(dp, "LAT");
      break;
    }
    case ETHERTYPE_PPP:
    {
      decode_proto_add(dp, "PPP");
      break;
    }
    case ETHERTYPE_WCP:
    {
      decode_proto_add(dp, "WCP");
      break;
    }
    case ETHERTYPE_3C_NBP_DGRAM:
    {
      decode_proto_add(dp, "3C-NBP-DGRAM");
      break;
    }
    case ETHERTYPE_ETHBRIDGE:
    {
      decode_proto_add(dp, "ETHBRIDGE");
      break;
    }
    case ETHERTYPE_UNK:
      decode_proto_add(dp, "ETH_UNKNOWN");
  }
}

// ask_reposition
// file diagram.h line 33
void ask_reposition(signed int r_font)
{
  need_reposition = (signed int)!(0 != 0);
  need_font_refresh = r_font;
}

// basic_stats_add
// file basic_stats.h line 44
void basic_stats_add(struct anonymous$34 *tf_stat, double val)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(tf_stat == ((struct anonymous$34 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "basic_stats.c", 212, (const char *)"basic_stats_add", "tf_stat");

  }
  while((_Bool)0);
  tf_stat->accumulated = tf_stat->accumulated + val;
  tf_stat->aver_accu = tf_stat->aver_accu + val;
  tf_stat->accu_packets = tf_stat->accu_packets + 1ul;
  tf_stat->avg_size = tf_stat->accumulated / (double)tf_stat->accu_packets;
  tf_stat->last_time = appdata.now;
}

// basic_stats_avg
// file basic_stats.h line 46
void basic_stats_avg(struct anonymous$34 *tf_stat, double avg_msecs)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(tf_stat == ((struct anonymous$34 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "basic_stats.c", 233, (const char *)"basic_stats_avg", "tf_stat");

  }
  while((_Bool)0);
  if(IEEE_FLOAT_NOTEQUAL(avg_msecs, 0.000000))
    tf_stat->average = ((double)8000 * tf_stat->aver_accu) / avg_msecs;

}

// basic_stats_dump
// file basic_stats.h line 47
char * basic_stats_dump(const struct anonymous$34 *tf_stat)
{
  char *msg;
  char *msg_time;
  char *return_value_g_strdup$1;
  if(tf_stat == ((const struct anonymous$34 *)NULL))
  {
    return_value_g_strdup$1=g_strdup("basic_stats_t NULL");
    return return_value_g_strdup$1;
  }

  else
  {
    msg_time=timeval_to_str(tf_stat->last_time);
    msg=g_strdup_printf("avg: %f, avg_acc: %f, total: %f, avg_size: %f, packets: %lu, last heard: %s", tf_stat->average, tf_stat->aver_accu, tf_stat->accumulated, tf_stat->avg_size, tf_stat->accu_packets, msg_time);
    g_free((void *)msg_time);
    return msg;
  }
}

// basic_stats_reset
// file basic_stats.h line 43
void basic_stats_reset(struct anonymous$34 *tf_stat)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(tf_stat == ((struct anonymous$34 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "basic_stats.c", 201, (const char *)"basic_stats_reset", "tf_stat");

  }
  while((_Bool)0);
  tf_stat->average = (double)0;
  tf_stat->aver_accu = (double)0;
  tf_stat->accumulated = (double)0;
  tf_stat->avg_size = (double)0;
  tf_stat->accu_packets = (unsigned long int)0;
  tf_stat->last_time = appdata.now;
}

// basic_stats_sub
// file basic_stats.h line 45
void basic_stats_sub(struct anonymous$34 *tf_stat, double val)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(tf_stat == ((struct anonymous$34 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "basic_stats.c", 223, (const char *)"basic_stats_sub", "tf_stat");

  }
  while((_Bool)0);
  tf_stat->aver_accu = tf_stat->aver_accu - val;
  if(!IEEE_FLOAT_NOTEQUAL(tf_stat->aver_accu, 0.000000))
    tf_stat->average = (double)0;

}

// basic_stats_xml
// file basic_stats.h line 48
char * basic_stats_xml(const struct anonymous$34 *tf_stat)
{
  char *msg;
  double diffms;
  char *return_value_xmltag$1;
  if(tf_stat == ((const struct anonymous$34 *)NULL))
  {
    return_value_xmltag$1=xmltag("stats", "");
    return return_value_xmltag$1;
  }

  else
  {
    diffms=substract_times_ms(&appdata.now, &tf_stat->last_time);
    msg=xmltag("stats", "\n<avg>%.0f</avg>\n<total>%.0f</total>\n<avg_size>%.0f</avg_size>\n<packets>%lu</packets>\n<last_heard>%f</last_heard>\n", tf_stat->average, tf_stat->accumulated, tf_stat->avg_size, tf_stat->accu_packets, diffms / 1000.0);
    return msg;
  }
}

// canvas_link_compare
// file diagram.c line 1434
static signed int canvas_link_compare(const struct anonymous$16 *a, const struct anonymous$16 *b, void *dummy)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(a == ((const struct anonymous$16 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "diagram.c", 1437, (const char *)"canvas_link_compare", "a != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int canvas_link_compare$$1$$2$$1$$_g_boolean_var_;
    if(!(b == ((const struct anonymous$16 *)NULL)))
      canvas_link_compare$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      canvas_link_compare$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = canvas_link_compare$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "diagram.c", 1438, (const char *)"canvas_link_compare", "b != NULL");

  }
  while((_Bool)0);
  signed int return_value_link_id_compare$3;
  return_value_link_id_compare$3=link_id_compare(a, b);
  return return_value_link_id_compare$3;
}

// canvas_link_delete
// file diagram.c line 1443
static void canvas_link_delete(struct anonymous$80 *canvas_link)
{
  if(!(canvas_link->src_item == ((struct _GnomeCanvasItem *)NULL)))
  {
    unsigned long int return_value_gtk_object_get_type$1;
    return_value_gtk_object_get_type$1=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)canvas_link->src_item, return_value_gtk_object_get_type$1);
    gtk_object_destroy((struct _GtkObject *)return_value_g_type_check_instance_cast$2);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)canvas_link->src_item, (unsigned long int)(20 << 2));
    g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$3);
    canvas_link->src_item = (struct _GnomeCanvasItem *)(void *)0;
  }

  if(!(canvas_link->dst_item == ((struct _GnomeCanvasItem *)NULL)))
  {
    unsigned long int return_value_gtk_object_get_type$4;
    return_value_gtk_object_get_type$4=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)canvas_link->dst_item, return_value_gtk_object_get_type$4);
    gtk_object_destroy((struct _GtkObject *)return_value_g_type_check_instance_cast$5);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)canvas_link->dst_item, (unsigned long int)(20 << 2));
    g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$6);
    canvas_link->dst_item = (struct _GnomeCanvasItem *)(void *)0;
  }

  g_free((void *)canvas_link);
}

// canvas_link_update
// file diagram.c line 1141
static signed int canvas_link_update(struct anonymous$16 *link_id, struct anonymous$80 *canvas_link, struct _GList **delete_list)
{
  const struct anonymous$28 *link;
  const struct anonymous$82 *canvas_dst;
  const struct anonymous$82 *canvas_src;
  unsigned int scaledColor;
  double xs;
  double ys;
  double xd;
  double yd;
  double scale;
  link=links_catalog_find(link_id);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  if(link == ((const struct anonymous$28 *)NULL))
  {
    *delete_list=g_list_prepend(*delete_list, (void *)link_id);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Queing canvas link to remove.");
    return 0;
  }

  else
  {
    void *return_value_g_tree_lookup$1;
    return_value_g_tree_lookup$1=g_tree_lookup(canvas_nodes, (const void *)&link_id->dst);
    canvas_dst = (const struct anonymous$82 *)return_value_g_tree_lookup$1;
    if(canvas_dst == ((const struct anonymous$82 *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = !(canvas_dst->shown != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      gnome_canvas_item_hide(canvas_link->src_item);
      gnome_canvas_item_hide(canvas_link->dst_item);
      return 0;
    }

    else
    {
      void *return_value_g_tree_lookup$3;
      return_value_g_tree_lookup$3=g_tree_lookup(canvas_nodes, (const void *)&link_id->src);
      canvas_src = (const struct anonymous$82 *)return_value_g_tree_lookup$3;
      if(canvas_src == ((const struct anonymous$82 *)NULL))
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = !(canvas_src->shown != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        gnome_canvas_item_hide(canvas_link->src_item);
        gnome_canvas_item_hide(canvas_link->dst_item);
        return 0;
      }

      else
      {
        if(!(link->main_prot[(signed long int)pref.stack_level] == ((char *)NULL)))
        {
          double diffms;
          canvas_link->color=protohash_color(link->main_prot[(signed long int)pref.stack_level]);
          diffms=substract_times_ms(&appdata.now, &link->link_stats.stats.last_time);
          scale=pow(0.10, diffms / pref.gui_link_timeout_time);
          scaledColor = (unsigned int)(((signed int)(scale * (double)canvas_link->color.red) & 0xFF00) << 16 | ((signed int)(scale * (double)canvas_link->color.green) & 0xFF00) << 8 | (signed int)(scale * (double)canvas_link->color.blue) & 0xFF00 | 0xFF);
        }

        else
        {
          unsigned int black = (unsigned int)0x000000ff;
          scaledColor = black;
        }
        struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
        return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)canvas_src->group_item, (unsigned long int)(20 << 2));
        g_object_get((void *)(struct _GObject *)return_value_g_type_check_instance_cast$5, "x", &xs, (const void *)"y", &ys, (void *)0);
        struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
        return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)canvas_dst->group_item, (unsigned long int)(20 << 2));
        g_object_get((void *)(struct _GObject *)return_value_g_type_check_instance_cast$6, "x", &xd, (const void *)"y", &yd, (void *)0);
        draw_oneside_link(xs, ys, xd, yd, &link->link_stats.stats_out, scaledColor, canvas_link->src_item);
        draw_oneside_link(xd, yd, xs, ys, &link->link_stats.stats_in, scaledColor, canvas_link->dst_item);
        return 0;
      }
    }
  }
}

// canvas_node_compare
// file diagram.c line 1426
static signed int canvas_node_compare(const struct anonymous$5 *a, const struct anonymous$5 *b, void *dummy)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(a == ((const struct anonymous$5 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "diagram.c", 1429, (const char *)"canvas_node_compare", "a != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int canvas_node_compare$$1$$2$$1$$_g_boolean_var_;
    if(!(b == ((const struct anonymous$5 *)NULL)))
      canvas_node_compare$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      canvas_node_compare$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = canvas_node_compare$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "diagram.c", 1430, (const char *)"canvas_node_compare", "b != NULL");

  }
  while((_Bool)0);
  signed int return_value_node_id_compare$3;
  return_value_node_id_compare$3=node_id_compare(a, b);
  return return_value_node_id_compare$3;
}

// canvas_node_delete
// file diagram.c line 282
static void canvas_node_delete(struct anonymous$82 *canvas_node)
{
  if(!(canvas_node->node_item == ((struct _GnomeCanvasItem *)NULL)))
  {
    unsigned long int return_value_gtk_object_get_type$1;
    return_value_gtk_object_get_type$1=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)canvas_node->node_item, return_value_gtk_object_get_type$1);
    gtk_object_destroy((struct _GtkObject *)return_value_g_type_check_instance_cast$2);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)canvas_node->node_item, (unsigned long int)(20 << 2));
    g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$3);
    canvas_node->node_item = (struct _GnomeCanvasItem *)(void *)0;
  }

  if(!(canvas_node->text_item == ((struct _GnomeCanvasItem *)NULL)))
  {
    unsigned long int return_value_gtk_object_get_type$4;
    return_value_gtk_object_get_type$4=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)canvas_node->text_item, return_value_gtk_object_get_type$4);
    gtk_object_destroy((struct _GtkObject *)return_value_g_type_check_instance_cast$5);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)canvas_node->text_item, (unsigned long int)(20 << 2));
    g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$6);
    canvas_node->text_item = (struct _GnomeCanvasItem *)(void *)0;
  }

  if(!(canvas_node->group_item == ((struct _GnomeCanvasGroup *)NULL)))
  {
    unsigned long int return_value_gtk_object_get_type$7;
    return_value_gtk_object_get_type$7=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)canvas_node->group_item, return_value_gtk_object_get_type$7);
    gtk_object_destroy((struct _GtkObject *)return_value_g_type_check_instance_cast$8);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)canvas_node->group_item, (unsigned long int)(20 << 2));
    g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$9);
    canvas_node->group_item = (struct _GnomeCanvasGroup *)(void *)0;
  }

  g_free((void *)canvas_node);
}

// canvas_node_update
// file diagram.c line 693
static signed int canvas_node_update(struct anonymous$5 *node_id, struct anonymous$82 *canvas_node, struct _GList **delete_list)
{
  struct anonymous$19 *node;
  double node_size;
  signed long int end;
  double cpu_time_used;
  char *nametmp = (char *)(void *)0;
  node=nodes_catalog_find(node_id);
  _Bool tmp_if_expr$2;
  signed int return_value_display_node$1;
  if(node == ((struct anonymous$19 *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_display_node$1=display_node(node);
    tmp_if_expr$2 = !(return_value_display_node$1 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int tmp_statement_expression$5;
  signed int return_value_gtk_events_pending$7;
  if(tmp_if_expr$2)
  {
    *delete_list=g_list_prepend(*delete_list, (void *)node_id);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Queing canvas node to remove.");
    need_reposition = (signed int)!(0 != 0);
    return 0;
  }

  else
  {
    switch((signed int)pref.node_size_variable)
    {
      case INST_TOTAL:
      {
        node_size=get_node_size(node->node_stats.stats.average);
        break;
      }
      case INST_INBOUND:
      {
        node_size=get_node_size(node->node_stats.stats_in.average);
        break;
      }
      case INST_OUTBOUND:
      {
        node_size=get_node_size(node->node_stats.stats_out.average);
        break;
      }
      case INST_PACKETS:
      {
        node_size=get_node_size((double)node->node_stats.pkt_list.length);
        break;
      }
      case ACCU_TOTAL:
      {
        node_size=get_node_size(node->node_stats.stats.accumulated);
        break;
      }
      case ACCU_INBOUND:
      {
        node_size=get_node_size(node->node_stats.stats_in.accumulated);
        break;
      }
      case ACCU_OUTBOUND:
      {
        node_size=get_node_size(node->node_stats.stats_out.accumulated);
        break;
      }
      case ACCU_PACKETS:
      {
        node_size=get_node_size((double)node->node_stats.stats.accu_packets);
        break;
      }
      case ACCU_AVG_SIZE:
      {
        node_size=get_node_size(node->node_stats.stats.avg_size);
        break;
      }
      default:
      {
        node_size=get_node_size(node->node_stats.stats_out.average);
        char *return_value_dcgettext$3;
        return_value_dcgettext$3=dcgettext((const char *)(void *)0, "Unknown value or node_size_variable", 5);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$3);
      }
    }
    if(node_size > 5000.000000)
      node_size = (double)5000;

    if(!(node->main_prot[(signed long int)pref.stack_level] == ((char *)NULL)))
    {
      canvas_node->color=protohash_color(node->main_prot[(signed long int)pref.stack_level]);
      gnome_canvas_item_set(canvas_node->node_item, "x1", -node_size / (double)2, (const void *)"x2", node_size / (double)2, (const void *)"y1", -node_size / (double)2, (const void *)"y2", node_size / (double)2, (const void *)"fill_color_gdk", &canvas_node->color, (void *)0);
    }

    else
    {
      unsigned int black = (unsigned int)0x000000ff;
      gnome_canvas_item_set(canvas_node->node_item, "x1", -node_size / (double)2, (const void *)"x2", node_size / (double)2, (const void *)"y1", -node_size / (double)2, (const void *)"y2", node_size / (double)2, (const void *)"fill_color_rgba", black, (void *)0);
    }
    if(!(canvas_node->text_item == ((struct _GnomeCanvasItem *)NULL)))
    {
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)canvas_node->text_item, (unsigned long int)(20 << 2));
      g_object_get((void *)(struct _GObject *)return_value_g_type_check_instance_cast$4, "text", &nametmp, (void *)0);
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp$6;
      return_value___builtin_strcmp$6=__builtin_strcmp(nametmp, node->name->str);
      tmp_statement_expression$5 = return_value___builtin_strcmp$6;
      if(!(tmp_statement_expression$5 == 0))
      {
        gnome_canvas_item_set(canvas_node->text_item, "text", node->name->str, (void *)0);
        gnome_canvas_item_request_update(canvas_node->text_item);
      }

      g_free((void *)nametmp);
    }

    end=clock();
    static signed long int start = (signed long int)0;
    cpu_time_used = (double)(end - start) / (double)(signed long int)1000000;
    if(cpu_time_used > 0.05)
    {
      do
      {
        return_value_gtk_events_pending$7=gtk_events_pending();
        if(return_value_gtk_events_pending$7 == 0)
          break;

        gtk_main_iteration();
      }
      while((_Bool)1);
      start = end;
    }

    return 0;
  }
}

// cap_t_o_destroy
// file capture.c line 471
static void cap_t_o_destroy(void *data)
{
  unsigned int return_value_g_timeout_add_full$1;
  if((signed int)capture_status == PLAY)
  {
    return_value_g_timeout_add_full$1=g_timeout_add_full(0, (unsigned int)ms_to_next, (signed int (*)(void *))get_offline_packet, data, (void (*)(void *))cap_t_o_destroy);
    capture_source = (signed int)return_value_g_timeout_add_full$1;
  }

}

// cbox_add_select
// file pref_dialog.c line 830
static void cbox_add_select(struct _GtkComboBoxEntry *cbox, const char *str)
{
  struct _GtkTreeModel *model;
  struct _GtkTreeIter iter;
  struct _GtkTreeIter iter3;
  signed int res;
  char *modelstr;
  struct _GtkWidget *entry;
  if(str == ((const char *)NULL))
    str = "";

  unsigned long int return_value_gtk_bin_get_type$1;
  return_value_gtk_bin_get_type$1=gtk_bin_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)cbox, return_value_gtk_bin_get_type$1);
  entry=gtk_bin_get_child((struct _GtkBin *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gtk_entry_get_type$3;
  return_value_gtk_entry_get_type$3=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry, return_value_gtk_entry_get_type$3);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4, str);
  signed int tmp_statement_expression$7;
  if(!(*str == 0))
  {
    unsigned long int return_value_gtk_combo_box_get_type$5;
    return_value_gtk_combo_box_get_type$5=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)cbox, return_value_gtk_combo_box_get_type$5);
    model=gtk_combo_box_get_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$6);
    res=gtk_tree_model_get_iter_first(model, &iter);
    while(!(res == 0))
    {
      gtk_tree_model_get(model, &iter, 0, &modelstr, -1);
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp$8;
      return_value___builtin_strcmp$8=__builtin_strcmp(str, modelstr);
      tmp_statement_expression$7 = return_value___builtin_strcmp$8;
      if(tmp_statement_expression$7 == 0)
      {
        g_free((void *)modelstr);
        goto __CPROVER_DUMP_L6;
      }

      g_free((void *)modelstr);
      res=gtk_tree_model_iter_next(model, &iter);
    }
    unsigned long int return_value_gtk_list_store_get_type$9;
    return_value_gtk_list_store_get_type$9=gtk_list_store_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)model, return_value_gtk_list_store_get_type$9);
    gtk_list_store_insert_with_values((struct _GtkListStore *)return_value_g_type_check_instance_cast$10, &iter3, 0, 0, str, -1);
  }


__CPROVER_DUMP_L6:
  ;
}

// change_refresh_period
// file pref_dialog.c line 866
void change_refresh_period(unsigned int newperiod)
{
  pref.refresh_period = newperiod;
  timeout_changed();
}

// check_new_link
// file diagram.c line 1086
static signed int check_new_link(struct anonymous$16 *link_id, struct anonymous$28 *link, struct _GtkWidget *canvas)
{
  struct anonymous$80 *new_canvas_link;
  struct _GnomeCanvasGroup *group;
  struct _GnomeCanvasPoints *points;
  unsigned int i = (unsigned int)0;
  void *return_value_g_tree_lookup$11;
  return_value_g_tree_lookup$11=g_tree_lookup(canvas_links, (const void *)link_id);
  signed int tmp_statement_expression$4;
  if(return_value_g_tree_lookup$11 == NULL)
  {
    unsigned long int return_value_gnome_canvas_get_type$1;
    return_value_gnome_canvas_get_type$1=gnome_canvas_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)canvas, return_value_gnome_canvas_get_type$1);
    group=gnome_canvas_root((struct _GnomeCanvas *)return_value_g_type_check_instance_cast$2);
    void *return_value_g_malloc$3;
    return_value_g_malloc$3=g_malloc(sizeof(struct anonymous$80) /*88ul*/ );
    new_canvas_link = (struct anonymous$80 *)return_value_g_malloc$3;
    do
    {
      signed int _g_boolean_var_;
      if(!(new_canvas_link == ((struct anonymous$80 *)NULL)))
        _g_boolean_var_ = 1;

      else
        _g_boolean_var_ = 0;
      tmp_statement_expression$4 = _g_boolean_var_;
      if((signed long int)tmp_statement_expression$4 == 0l)
        g_assertion_message_expr((char *)0, "diagram.c", 1098, (const char *)"check_new_link", "new_canvas_link");

    }
    while((_Bool)0);
    new_canvas_link->canvas_link_id = *link_id;
    points=gnome_canvas_points_new(3);
    for( ; !(i >= 6u); i = i + 1u)
      points->coords[(signed long int)i] = 0.0;
    unsigned long int return_value_gnome_canvas_polygon_get_type$5;
    return_value_gnome_canvas_polygon_get_type$5=gnome_canvas_polygon_get_type();
    new_canvas_link->src_item=gnome_canvas_item_new(group, return_value_gnome_canvas_polygon_get_type$5, "points", points, (const void *)"fill_color", (const void *)"tan", (void *)0);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)new_canvas_link->src_item, (unsigned long int)(20 << 2));
    addref_canvas_obj((struct _GObject *)return_value_g_type_check_instance_cast$6);
    unsigned long int return_value_gnome_canvas_polygon_get_type$7;
    return_value_gnome_canvas_polygon_get_type$7=gnome_canvas_polygon_get_type();
    new_canvas_link->dst_item=gnome_canvas_item_new(group, return_value_gnome_canvas_polygon_get_type$7, "points", points, (const void *)"fill_color", (const void *)"tan", (void *)0);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)new_canvas_link->dst_item, (unsigned long int)(20 << 2));
    addref_canvas_obj((struct _GObject *)return_value_g_type_check_instance_cast$8);
    g_tree_insert(canvas_links, (void *)&new_canvas_link->canvas_link_id, (void *)new_canvas_link);
    gnome_canvas_item_lower_to_bottom(new_canvas_link->src_item);
    gnome_canvas_item_lower_to_bottom(new_canvas_link->dst_item);
    gnome_canvas_points_free(points);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)new_canvas_link->src_item, (unsigned long int)(20 << 2));
    g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$9, "event", (void (*)(void))link_item_event, (void *)new_canvas_link, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)new_canvas_link->dst_item, (unsigned long int)(20 << 2));
    g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$10, "event", (void (*)(void))link_item_event, (void *)new_canvas_link, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  }

  return 0;
}

// check_new_node
// file diagram.c line 613
static signed int check_new_node(struct anonymous$19 *node, struct _GtkWidget *canvas)
{
  struct anonymous$82 *new_canvas_node;
  struct _GnomeCanvasGroup *group;
  void *return_value_g_tree_lookup$21;
  signed int tmp_statement_expression$2;
  _Bool tmp_if_expr$18;
  char *return_value_dcgettext$17;
  if(node == ((struct anonymous$19 *)NULL))
    return 0;

  else
  {
    signed int return_value_display_node$22;
    return_value_display_node$22=display_node(node);
    if(!(return_value_display_node$22 == 0))
    {
      return_value_g_tree_lookup$21=g_tree_lookup(canvas_nodes, (const void *)&node->node_id);
      if(return_value_g_tree_lookup$21 == NULL)
      {
        void *return_value_g_malloc$1;
        return_value_g_malloc$1=g_malloc(sizeof(struct anonymous$82) /*80ul*/ );
        new_canvas_node = (struct anonymous$82 *)return_value_g_malloc$1;
        do
        {
          signed int _g_boolean_var_;
          if(!(new_canvas_node == ((struct anonymous$82 *)NULL)))
            _g_boolean_var_ = 1;

          else
            _g_boolean_var_ = 0;
          tmp_statement_expression$2 = _g_boolean_var_;
          if((signed long int)tmp_statement_expression$2 == 0l)
            g_assertion_message_expr((char *)0, "diagram.c", 624, (const char *)"check_new_node", "new_canvas_node");

        }
        while((_Bool)0);
        new_canvas_node->canvas_node_id = node->node_id;
        unsigned long int return_value_gnome_canvas_get_type$3;
        return_value_gnome_canvas_get_type$3=gnome_canvas_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
        return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)canvas, return_value_gnome_canvas_get_type$3);
        group=gnome_canvas_root((struct _GnomeCanvas *)return_value_g_type_check_instance_cast$4);
        unsigned long int return_value_gnome_canvas_group_get_type$5;
        return_value_gnome_canvas_group_get_type$5=gnome_canvas_group_get_type();
        struct _GnomeCanvasItem *return_value_gnome_canvas_item_new$6;
        return_value_gnome_canvas_item_new$6=gnome_canvas_item_new(group, return_value_gnome_canvas_group_get_type$5, "x", 100.0, (const void *)"y", 100.0, (void *)0);
        unsigned long int return_value_gnome_canvas_group_get_type$7;
        return_value_gnome_canvas_group_get_type$7=gnome_canvas_group_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
        return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gnome_canvas_item_new$6, return_value_gnome_canvas_group_get_type$7);
        group = (struct _GnomeCanvasGroup *)return_value_g_type_check_instance_cast$8;
        struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
        return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)group, (unsigned long int)(20 << 2));
        addref_canvas_obj((struct _GObject *)return_value_g_type_check_instance_cast$9);
        new_canvas_node->group_item = group;
        unsigned long int return_value_gnome_canvas_ellipse_get_type$10;
        return_value_gnome_canvas_ellipse_get_type$10=gnome_canvas_ellipse_get_type();
        new_canvas_node->node_item=gnome_canvas_item_new(group, return_value_gnome_canvas_ellipse_get_type$10, "x1", 0.0, (const void *)"x2", 0.0, (const void *)"y1", 0.0, (const void *)"y2", 0.0, (const void *)"fill_color", (const void *)"white", (const void *)"outline_color", (const void *)"black", (const void *)"width_pixels", 0, (void *)0);
        struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
        return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)new_canvas_node->node_item, (unsigned long int)(20 << 2));
        addref_canvas_obj((struct _GObject *)return_value_g_type_check_instance_cast$11);
        unsigned long int return_value_gnome_canvas_text_get_type$12;
        return_value_gnome_canvas_text_get_type$12=gnome_canvas_text_get_type();
        new_canvas_node->text_item=gnome_canvas_item_new(group, return_value_gnome_canvas_text_get_type$12, "text", node->name->str, (const void *)"x", 0.0, (const void *)"y", 0.0, (const void *)"anchor", 0, (const void *)"font", pref.fontname, (const void *)"fill_color", pref.text_color, (void *)0);
        struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
        return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)new_canvas_node->text_item, (unsigned long int)(20 << 2));
        addref_canvas_obj((struct _GObject *)return_value_g_type_check_instance_cast$13);
        unsigned long int return_value_gnome_canvas_item_get_type$14;
        return_value_gnome_canvas_item_get_type$14=gnome_canvas_item_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
        return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)new_canvas_node->text_item, return_value_gnome_canvas_item_get_type$14);
        gnome_canvas_item_raise_to_top((struct _GnomeCanvasItem *)return_value_g_type_check_instance_cast$15);
        struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
        return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)new_canvas_node->group_item, (unsigned long int)(20 << 2));
        g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$16, "event", (void (*)(void))node_item_event, (void *)new_canvas_node, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
        if(new_canvas_node->node_item == ((struct _GnomeCanvasItem *)NULL))
          tmp_if_expr$18 = (_Bool)1;

        else
          tmp_if_expr$18 = !(new_canvas_node->text_item != ((struct _GnomeCanvasItem *)NULL)) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$18)
        {
          return_value_dcgettext$17=dcgettext((const char *)(void *)0, "Canvas node null", 5);
          g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, return_value_dcgettext$17);
        }

        gnome_canvas_item_hide(new_canvas_node->node_item);
        gnome_canvas_item_hide(new_canvas_node->text_item);
        new_canvas_node->is_new = (signed int)!(0 != 0);
        new_canvas_node->shown = (signed int)!(0 != 0);
        new_canvas_node->centered = 0;
        g_tree_insert(canvas_nodes, (void *)&new_canvas_node->canvas_node_id, (void *)new_canvas_node);
        char *return_value_dcgettext$19;
        return_value_dcgettext$19=dcgettext((const char *)(void *)0, "Creating canvas_node: %s. Number of nodes %d", 5);
        signed int return_value_g_tree_nnodes$20;
        return_value_g_tree_nnodes$20=g_tree_nnodes(canvas_nodes);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, return_value_dcgettext$19, node->name->str, return_value_g_tree_nnodes$20);
        need_reposition = (signed int)!(0 != 0);
      }

    }

    return 0;
  }
}

// check_new_protocol
// file diagram.c line 520
static void check_new_protocol(struct _GtkWidget *prot_table, const struct anonymous$25 *pstk)
{
  const struct _GList *protocol_item;
  const struct anonymous$26 *protocol;
  struct _GdkColor color;
  struct _GtkStyle *style;
  struct _GtkLabel *lab;
  struct _GtkWidget *newlab;
  struct _GList *childlist;
  signed int tmp_statement_expression$5;
  char *return_value_dcgettext$10;
  if(!(pstk == ((const struct anonymous$25 *)NULL)))
  {
    unsigned long int return_value_gtk_container_get_type$1;
    return_value_gtk_container_get_type$1=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)prot_table, return_value_gtk_container_get_type$1);
    childlist=gtk_container_get_children((struct _GtkContainer *)return_value_g_type_check_instance_cast$2);
    protocol_item = pstk->protostack[(signed long int)pref.stack_level];
    while(!(protocol_item == ((const struct _GList *)NULL)))
    {
      const struct _GList *cur;
      protocol = (const struct anonymous$26 *)protocol_item->data;
      protocol_item = protocol_item->next;
      cur = childlist;
      while(!(cur == ((const struct _GList *)NULL)))
      {
        unsigned long int return_value_gtk_label_get_type$3;
        return_value_gtk_label_get_type$3=gtk_label_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
        return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)cur->data, return_value_gtk_label_get_type$3);
        lab = (struct _GtkLabel *)return_value_g_type_check_instance_cast$4;
        if(!(lab == ((struct _GtkLabel *)NULL)))
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          const char *return_value_gtk_label_get_label$6;
          return_value_gtk_label_get_label$6=gtk_label_get_label(lab);
          signed int return_value___builtin_strcmp$7;
          return_value___builtin_strcmp$7=__builtin_strcmp(protocol->name, return_value_gtk_label_get_label$6);
          tmp_statement_expression$5 = return_value___builtin_strcmp$7;
          if(tmp_statement_expression$5 == 0)
            break;

        }

        cur = cur->next;
      }
      if(cur == ((const struct _GList *)NULL))
      {
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Protocol '%s' not found. Creating legend item", protocol->name);
        newlab=gtk_label_new(protocol->name);
        gtk_widget_show(newlab);
        unsigned long int return_value_gtk_misc_get_type$8;
        return_value_gtk_misc_get_type$8=gtk_misc_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
        return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)newlab, return_value_gtk_misc_get_type$8);
        gtk_misc_set_alignment((struct _GtkMisc *)return_value_g_type_check_instance_cast$9, (float)0, (float)0);
        color=protohash_color(protocol->name);
        struct _GdkColormap *return_value_gdk_colormap_get_system$11;
        return_value_gdk_colormap_get_system$11=gdk_colormap_get_system();
        signed int return_value_gdk_colormap_alloc_color$12;
        return_value_gdk_colormap_alloc_color$12=gdk_colormap_alloc_color(return_value_gdk_colormap_get_system$11, &color, 0, (signed int)!(0 != 0));
        if(return_value_gdk_colormap_alloc_color$12 == 0)
        {
          return_value_dcgettext$10=dcgettext((const char *)(void *)0, "Unable to allocate color for new protocol %s", 5);
          g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$10, protocol->name);
        }

        style=gtk_style_new();
        style->fg[(signed long int)GTK_STATE_NORMAL] = color;
        gtk_widget_set_style(newlab, style);
        g_object_unref((void *)style);
        unsigned long int return_value_gtk_container_get_type$13;
        return_value_gtk_container_get_type$13=gtk_container_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
        return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)prot_table, return_value_gtk_container_get_type$13);
        gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$14, newlab);
        known_protocols = known_protocols + 1u;
      }

    }
    g_list_free(childlist);
  }

}

// check_ordered_node
// file diagram.c line 875
static signed int check_ordered_node(double *traffic, struct anonymous$82 *node, unsigned int *count)
{
  if(!(*count == 0u))
  {
    if(node->shown == 0)
      need_reposition = (signed int)!(0 != 0);

    node->shown = (signed int)!(0 != 0);
    displayed_nodes = displayed_nodes + 1u;
    *count = *count - 1u;
  }

  else
  {
    if(!(node->shown == 0))
      need_reposition = (signed int)!(0 != 0);

    node->shown = 0;
  }
  return 0;
}

// choose_port
// file decode_proto.c line 1634
static unsigned short int choose_port(unsigned short int a, unsigned short int b)
{
  unsigned int ret;
  if((signed int)b >= 1024 && !((signed int)a >= 1024))
    ret = (unsigned int)a;

  else
    if((signed int)a >= 1024 && !((signed int)b >= 1024))
      ret = (unsigned int)b;

    else
      if((signed int)b >= (signed int)a)
        ret = (unsigned int)a;

      else
        ret = (unsigned int)b;
  return (unsigned short int)ret;
}

// cleanup
// file main.c line 407
void cleanup(signed int signum)
{
  cleanup_capture();
  free_static_data();
  gtk_exit(0);
}

// cleanup_capture
// file capture.h line 37
void cleanup_capture(void)
{
  stop_capture();
  dns_close();
}

// close_mutex
// file thread_resolve.c line 87
static void close_mutex(void)
{
  pthread_mutex_destroy(&resolvemtx);
  pthread_cond_destroy(&resolvecond);
}

// color_list_to_pref
// file pref_dialog.c line 786
static void color_list_to_pref(void)
{
  signed int i;
  signed int ncolors;
  struct _GtkTreeIter it;
  struct _EATreePos ep;
  signed int return_value_get_color_store$1;
  return_value_get_color_store$1=get_color_store(&ep);
  signed int tmp_statement_expression$5;
  if(!(return_value_get_color_store$1 == 0))
  {
    g_strfreev(pref.colors);
    pref.colors = (char **)(void *)0;
    unsigned long int return_value_gtk_tree_model_get_type$2;
    return_value_gtk_tree_model_get_type$2=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)ep.gs, return_value_gtk_tree_model_get_type$2);
    ncolors=gtk_tree_model_iter_n_children((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$3, (struct _GtkTreeIter *)(void *)0);
    void *return_value_g_malloc$4;
    return_value_g_malloc$4=g_malloc(sizeof(char *) /*8ul*/  * (unsigned long int)(ncolors + 1));
    pref.colors = (char **)return_value_g_malloc$4;
    do
    {
      signed int _g_boolean_var_;
      if(!(pref.colors == ((char **)NULL)))
        _g_boolean_var_ = 1;

      else
        _g_boolean_var_ = 0;
      tmp_statement_expression$5 = _g_boolean_var_;
      if((signed long int)tmp_statement_expression$5 == 0l)
        g_assertion_message_expr((char *)0, "pref_dialog.c", 801, (const char *)"color_list_to_pref", "pref.colors");

    }
    while((_Bool)0);
    unsigned long int return_value_gtk_tree_model_get_type$6;
    return_value_gtk_tree_model_get_type$6=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)ep.gs, return_value_gtk_tree_model_get_type$6);
    gtk_tree_model_get_iter_first((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$7, &it);
    i = 0;
    for( ; !(i >= ncolors); i = i + 1)
    {
      char *protocol;
      struct _GdkColor *gdk_color;
      unsigned long int return_value_gtk_tree_model_get_type$8;
      return_value_gtk_tree_model_get_type$8=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
      return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)ep.gs, return_value_gtk_tree_model_get_type$8);
      gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$9, &it, 1, &gdk_color, 2, &protocol, -1);
      pref.colors[(signed long int)i]=g_strdup_printf("#%02x%02x%02x;%s", (signed int)gdk_color->red >> 8, (signed int)gdk_color->green >> 8, (signed int)gdk_color->blue >> 8, protocol);
      g_free((void *)protocol);
      unsigned long int return_value_gtk_tree_model_get_type$10;
      return_value_gtk_tree_model_get_type$10=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
      return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)ep.gs, return_value_gtk_tree_model_get_type$10);
      gtk_tree_model_iter_next((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$11, &it);
    }
    pref.colors[(signed long int)ncolors] = (char *)(void *)0;
    pref.colors=protohash_compact(pref.colors);
    protohash_read_prefvect(pref.colors);
  }

}

// config_file_name
// file preferences.c line 84
static char * config_file_name(void)
{
  const char *return_value_g_get_user_config_dir$1;
  return_value_g_get_user_config_dir$1=g_get_user_config_dir();
  char *return_value_g_strdup_printf$2;
  return_value_g_strdup_printf$2=g_strdup_printf("%s/%s", return_value_g_get_user_config_dir$1, (const void *)"etherape");
  return return_value_g_strdup_printf$2;
}

// confirm_changes
// file pref_dialog.c line 52
static void confirm_changes(void)
{
  struct _GtkWidget *widget = (struct _GtkWidget *)(void *)0;
  widget=glade_xml_get_widget(appdata.xml, "filter_combo");
  unsigned long int return_value_gtk_combo_box_entry_get_type$1;
  return_value_gtk_combo_box_entry_get_type$1=gtk_combo_box_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_combo_box_entry_get_type$1);
  on_filter_entry_changed((struct _GtkComboBoxEntry *)return_value_g_type_check_instance_cast$2, (void *)0);
  widget=glade_xml_get_widget(appdata.xml, "center_combo");
  unsigned long int return_value_gtk_combo_box_entry_get_type$3;
  return_value_gtk_combo_box_entry_get_type$3=gtk_combo_box_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_combo_box_entry_get_type$3);
  on_center_node_changed((struct _GtkComboBoxEntry *)return_value_g_type_check_instance_cast$4, (void *)0);
  if(!(colors_changed == 0))
  {
    color_list_to_pref();
    delete_gui_protocols();
  }

}

// copy_config
// file preferences.c line 358
void copy_config(struct pref_struct *tgt, struct pref_struct *src)
{
  if(!(tgt == src))
  {
    free_config(tgt);
    tgt->name_res = src->name_res;
    tgt->diagram_only = src->diagram_only;
    tgt->group_unk = src->group_unk;
    tgt->stationary = src->stationary;
    tgt->node_radius_multiplier = src->node_radius_multiplier;
    tgt->link_node_ratio = src->link_node_ratio;
    tgt->size_mode = src->size_mode;
    tgt->node_size_variable = src->node_size_variable;
    tgt->filter=g_strdup(src->filter);
    tgt->text_color=g_strdup(src->text_color);
    tgt->fontname=g_strdup(src->fontname);
    tgt->center_node=g_strdup(src->center_node);
    tgt->stack_level = src->stack_level;
    tgt->colors=g_strdupv(src->colors);
    tgt->proto_timeout_time = src->proto_timeout_time;
    tgt->gui_node_timeout_time = src->gui_node_timeout_time;
    tgt->node_timeout_time = src->node_timeout_time;
    tgt->proto_node_timeout_time = src->proto_node_timeout_time;
    tgt->gui_link_timeout_time = src->gui_link_timeout_time;
    tgt->link_timeout_time = src->link_timeout_time;
    tgt->proto_link_timeout_time = src->proto_link_timeout_time;
    tgt->refresh_period = src->refresh_period;
    tgt->averaging_time = src->averaging_time;
  }

}

// create_add_text_column
// file ui_utils.h line 56
void create_add_text_column(struct _GtkTreeView *gv, const char *title, signed int colno, signed int r_just)
{
  struct _GtkTreeViewColumn *gc;
  struct _GtkCellRenderer *gr;
  gr=gtk_cell_renderer_text_new();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  if(!(r_just == 0))
  {
    return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)gr, (unsigned long int)(20 << 2));
    g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$1, "xalign", 1.0, (void *)0);
  }

  gc=gtk_tree_view_column_new_with_attributes(title, gr, (const void *)"text", colno, (void *)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)gc, (unsigned long int)(20 << 2));
  g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$2, "resizable", !(0 != 0), (const void *)"reorderable", !(0 != 0), (void *)0);
  gtk_tree_view_column_set_sort_column_id(gc, colno);
  gtk_tree_view_append_column(gv, gc);
}

// create_prot_info_window
// file info_windows.c line 98
static void create_prot_info_window(struct anonymous$26 *protocol)
{
  struct _GtkWidget *window;
  struct anonymous$29 *prot_info_window;
  struct _GladeXML *xml_info_window;
  struct _GtkWidget *widget;
  struct _GList *list_item;
  list_item=g_list_find_custom(prot_info_windows, (const void *)protocol->name, prot_info_compare);
  if(list_item == ((struct _GList *)NULL))
  {
    xml_info_window=glade_xml_new(appdata.glade_file, "prot_info", (const char *)(void *)0);
    if(xml_info_window == ((struct _GladeXML *)NULL))
    {
      char *return_value_dcgettext$1;
      return_value_dcgettext$1=dcgettext((const char *)(void *)0, "We could not load the interface! (%s)", 5);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_ERROR, return_value_dcgettext$1, appdata.glade_file);

    __CPROVER_DUMP_L2:
      ;
      goto __CPROVER_DUMP_L2;
    }

    glade_xml_signal_autoconnect(xml_info_window);
    window=glade_xml_get_widget(xml_info_window, "prot_info");
    gtk_widget_show(window);
    widget=glade_xml_get_widget(xml_info_window, "prot_info_name_label");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$2, "name_label", (void *)widget);
    widget=glade_xml_get_widget(xml_info_window, "prot_info_last_heard_label");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$3, "last_heard_label", (void *)widget);
    widget=glade_xml_get_widget(xml_info_window, "prot_info_average");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$4, "average", (void *)widget);
    widget=glade_xml_get_widget(xml_info_window, "prot_info_accumulated");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$5, "accumulated", (void *)widget);
    g_object_unref((void *)xml_info_window);
    void *return_value_g_malloc$6;
    return_value_g_malloc$6=g_malloc(sizeof(struct anonymous$29) /*16ul*/ );
    prot_info_window = (struct anonymous$29 *)return_value_g_malloc$6;
    prot_info_window->prot_name=g_strdup(protocol->name);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$7, "prot_name", (void *)prot_info_window->prot_name);
    prot_info_window->window = window;
    prot_info_windows=g_list_prepend(prot_info_windows, (void *)prot_info_window);
  }

  else
    prot_info_window = (struct anonymous$29 *)list_item->data;
  update_prot_info_window(prot_info_window);
}

// create_protocols_table
// file info_windows.c line 356
static struct _GtkListStore * create_protocols_table(struct _GtkWidget *window)
{
  struct _GtkTreeView *gv;
  struct _GtkListStore *gs;
  struct _GtkTreeViewColumn *gc;
  signed int i;
  gv=retrieve_treeview(window);
  unsigned long int return_value_gtk_tree_sortable_get_type$9;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  if(gv == ((struct _GtkTreeView *)NULL))
    return (struct _GtkListStore *)(void *)0;

  else
  {
    struct _GtkTreeModel *return_value_gtk_tree_view_get_model$1;
    return_value_gtk_tree_view_get_model$1=gtk_tree_view_get_model(gv);
    unsigned long int return_value_gtk_list_store_get_type$2;
    return_value_gtk_list_store_get_type$2=gtk_list_store_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_tree_view_get_model$1, return_value_gtk_list_store_get_type$2);
    gs = (struct _GtkListStore *)return_value_g_type_check_instance_cast$3;
    if(!(gs == ((struct _GtkListStore *)NULL)))
      return gs;

    else
    {
      unsigned long int return_value_gdk_color_get_type$4;
      return_value_gdk_color_get_type$4=gdk_color_get_type();
      gs=gtk_list_store_new(9, return_value_gdk_color_get_type$4, (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(17 << 2));
      unsigned long int return_value_gtk_tree_model_get_type$5;
      return_value_gtk_tree_model_get_type$5=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)gs, return_value_gtk_tree_model_get_type$5);
      gtk_tree_view_set_model(gv, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$6);
      struct _GtkCellRenderer *return_value_gtk_cell_renderer_text_new$7;
      return_value_gtk_cell_renderer_text_new$7=gtk_cell_renderer_text_new();
      gc=gtk_tree_view_column_new_with_attributes(" ", return_value_gtk_cell_renderer_text_new$7, (const void *)"background-gdk", 0, (void *)0);
      struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)gc, (unsigned long int)(20 << 2));
      g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$8, "resizable", !(0 != 0), (const void *)"reorderable", !(0 != 0), (void *)0);
      gtk_tree_view_append_column(gv, gc);
      create_add_text_column(gv, "Protocol", 1, 0);
      create_add_text_column(gv, "Port", 2, (signed int)!(0 != 0));
      create_add_text_column(gv, "Inst Traffic", 3, 0);
      create_add_text_column(gv, "Accum Traffic", 4, 0);
      create_add_text_column(gv, "Avg Size", 5, 0);
      create_add_text_column(gv, "Last Heard", 6, 0);
      create_add_text_column(gv, "Packets", 7, 0);
      i = 0;
      for( ; !(i >= 8); i = i + 1)
      {
        return_value_gtk_tree_sortable_get_type$9=gtk_tree_sortable_get_type();
        return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)gs, return_value_gtk_tree_sortable_get_type$9);
        gtk_tree_sortable_set_sort_func((struct _GtkTreeSortable *)return_value_g_type_check_instance_cast$10, i, protocols_table_compare, (void *)gs, (void (*)(void *))(void *)0);
      }
      unsigned long int return_value_gtk_tree_sortable_get_type$11;
      return_value_gtk_tree_sortable_get_type$11=gtk_tree_sortable_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
      return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)gs, return_value_gtk_tree_sortable_get_type$11);
      gtk_tree_sortable_set_sort_column_id((struct _GtkTreeSortable *)return_value_g_type_check_instance_cast$12, 1, (enum anonymous$33)GTK_SORT_ASCENDING);
      return gs;
    }
  }
}

// decode_next
// file names.c line 153
static void decode_next(struct anonymous$9 *nt)
{
  struct anonymous$12 *next_func = (struct anonymous$12 *)(void *)0;
  static struct _GTree *prot_functions = (struct _GTree *)(void *)0;
  if(prot_functions == ((struct _GTree *)NULL))
  {
    unsigned int i;
    prot_functions=g_tree_new((signed int (*)(const void *, const void *))strcmp);
    i = (unsigned int)0;
    for( ; !(prot_functions_table[(signed long int)i].prot == ((char *)NULL)); i = i + 1u)
      g_tree_insert(prot_functions, (void *)prot_functions_table[(signed long int)i].prot, (void *)&prot_functions_table[(signed long int)i]);
  }

  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(nt == ((struct anonymous$9 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "names.c", 169, (const char *)"decode_next", "nt");

  }
  while((_Bool)0);
  while(!((signed int)nt->decoder.level >= 6))
  {
    if(nt->decoder.tokens->protonames[(signed long int)nt->decoder.level] == ((char *)NULL))
      break;

    void *return_value_g_tree_lookup$2;
    return_value_g_tree_lookup$2=g_tree_lookup(prot_functions, (const void *)nt->decoder.tokens->protonames[(signed long int)nt->decoder.level]);
    next_func = (struct anonymous$12 *)return_value_g_tree_lookup$2;
    if(!(next_func == ((struct anonymous$12 *)NULL)))
    {
      if((signed int)nt->offset >= (signed int)nt->packet_size)
        goto __CPROVER_DUMP_L13;

      signed int return_value;
      return_value=next_func->function(nt);
      if(return_value == 0)
        break;

    }

    nt->decoder.level = nt->decoder.level + 1;
  }

__CPROVER_DUMP_L13:
  ;
}

// decode_proto_add
// file decode_proto.c line 233
static void decode_proto_add(struct anonymous$3 *dp, const char *fmt, ...)
{
  void **ap;
  if(!(dp->cur_level >= 6u))
  {
    ap = (void **)&fmt;
    dp->pr->protonames[(signed long int)dp->cur_level]=g_strdup_vprintf(fmt, ap);
    ap = ((void **)NULL);
    dp->cur_level = dp->cur_level + 1u;
  }

  else
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, "protocol \"%.10s\" too deeply nested, ignored", fmt != ((const char *)NULL) ? fmt : "");
}

// decode_proto_start
// file decode_proto.c line 218
static void decode_proto_start(struct anonymous$3 *dp, const unsigned char *pkt, unsigned int caplen)
{
  dp->original_packet = pkt;
  dp->original_len = caplen;
  dp->cur_packet = pkt;
  dp->cur_len = caplen;
  dp->pr=packet_protos_init();
  dp->cur_level = (unsigned int)1;
  node_id_clear(&dp->dst_node_id);
  node_id_clear(&dp->src_node_id);
  memset((void *)&dp->global_src_address, 0, sizeof(struct anonymous$20) /*20ul*/ );
  memset((void *)&dp->global_dst_address, 0, sizeof(struct anonymous$20) /*20ul*/ );
  dp->global_src_port = (unsigned short int)0;
  dp->global_dst_port = (unsigned short int)0;
}

// decode_wlan_mgmt
// file decode_proto.c line 646
static void decode_wlan_mgmt(struct anonymous$3 *dp, unsigned char subtype)
{
  switch((signed int)subtype)
  {
    case 0:

    case 1:

    case 2:

    case 3:
    {
      decode_proto_add(dp, "WLAN-ASSOC");
      break;
    }
    case 4:

    case 5:
    {
      decode_proto_add(dp, "WLAN-PROBE");
      break;
    }
    case 8:
    {
      decode_proto_add(dp, "WLAN-BEACON");
      break;
    }
    case 9:
    {
      decode_proto_add(dp, "WLAN-ATIM");
      break;
    }
    case 10:
    {
      decode_proto_add(dp, "WLAN-DEASSOC");
      break;
    }
    case 11:

    case 12:
    {
      decode_proto_add(dp, "WLAN-AUTH");
      break;
    }
    default:
      decode_proto_add(dp, "WLAN-MGMT-UNKN");
  }
}

// delete_conversation_link
// file conversations.h line 35
void delete_conversation_link(struct anonymous$20 *src_address, struct anonymous$20 *dst_address)
{
  struct _GList *item;
  if(dst_address == ((struct anonymous$20 *)NULL) || src_address == ((struct anonymous$20 *)NULL))
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, "NULL ptr in delete_conversation_link");

  else
    do
    {
      item=find_conversation_ptr(src_address, dst_address, (unsigned short int)0, (unsigned short int)0);
      if(item == ((struct _GList *)NULL))
        break;

      struct anonymous$61 *conv = (struct anonymous$61 *)(void *)0;
      conv = (struct anonymous$61 *)item->data;
      const char *return_value_address_to_str$1;
      return_value_address_to_str$1=address_to_str(&conv->src_address);
      const char *return_value_address_to_str$2;
      return_value_address_to_str$2=address_to_str(&conv->dst_address);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Removing conversation %s:%d-%s:%d %s", return_value_address_to_str$1, conv->src_port, return_value_address_to_str$2, conv->dst_port, conv->data);
      g_free((void *)conv->data);
      g_free((void *)conv);
      conversations=g_list_delete_link(conversations, item);
      n_conversations = n_conversations - 1l;
    }
    while((_Bool)1);
}

// delete_conversations
// file conversations.h line 37
void delete_conversations(void)
{
  struct _GList *item = conversations;
  struct anonymous$61 *conv = (struct anonymous$61 *)(void *)0;
  while(!(item == ((struct _GList *)NULL)))
  {
    conv = (struct anonymous$61 *)item->data;
    const char *return_value_address_to_str$1;
    return_value_address_to_str$1=address_to_str(&conv->src_address);
    const char *return_value_address_to_str$2;
    return_value_address_to_str$2=address_to_str(&conv->dst_address);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Removing conversation %s:%d-%s:%d %s", return_value_address_to_str$1, conv->src_port, return_value_address_to_str$2, conv->dst_port, conv->data);
    g_free((void *)conv->data);
    g_free((void *)conv);
    item = item->next;
    n_conversations = n_conversations - 1l;
  }
  g_list_free(conversations);
  conversations = (struct _GList *)(void *)0;
}

// delete_gui_protocols
// file diagram.h line 32
void delete_gui_protocols(void)
{
  struct _GList *item;
  struct _GtkContainer *prot_table;
  known_protocols = (unsigned int)0;
  protohash_reset_cycle();
  struct _GtkWidget *return_value_glade_xml_get_widget$1;
  return_value_glade_xml_get_widget$1=glade_xml_get_widget(appdata.xml, "prot_table");
  unsigned long int return_value_gtk_container_get_type$2;
  return_value_gtk_container_get_type$2=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$1, return_value_gtk_container_get_type$2);
  prot_table = (struct _GtkContainer *)return_value_g_type_check_instance_cast$3;
  unsigned long int return_value_gtk_container_get_type$4;
  return_value_gtk_container_get_type$4=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)prot_table, return_value_gtk_container_get_type$4);
  item=gtk_container_get_children((struct _GtkContainer *)return_value_g_type_check_instance_cast$5);
  for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    gtk_container_remove(prot_table, (struct _GtkWidget *)item->data);
  gtk_container_resize_children(prot_table);
  unsigned long int return_value_gtk_widget_get_type$6;
  return_value_gtk_widget_get_type$6=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)appdata.app1, return_value_gtk_widget_get_type$6);
  gtk_widget_queue_resize((struct _GtkWidget *)return_value_g_type_check_instance_cast$7);
}

// destroying_idle
// file diagram.h line 30
void destroying_idle(void *data)
{
  unsigned int return_value_g_timeout_add_full$1;
  return_value_g_timeout_add_full$1=g_timeout_add_full(0, pref.refresh_period, (signed int (*)(void *))update_diagram, data, (void (*)(void *))destroying_timeout);
  diagram_timeout = (signed int)return_value_g_timeout_add_full$1;
  is_idle = 0;
}

// destroying_timeout
// file diagram.c line 261
void destroying_timeout(void *data)
{
  unsigned int return_value_g_idle_add_full$1;
  return_value_g_idle_add_full$1=g_idle_add_full(0, (signed int (*)(void *))update_diagram, data, (void (*)(void *))destroying_idle);
  diagram_timeout = (signed int)return_value_g_idle_add_full$1;
  is_idle = (signed int)!(0 != 0);
}

// diagram_update_links
// file diagram.c line 367
static void diagram_update_links(struct _GtkWidget *canvas)
{
  struct _GList *delete_list = (struct _GList *)(void *)0;
  links_catalog_update_all();
  links_catalog_foreach((signed int (*)(void *, void *, void *))check_new_link, (void *)canvas);
  delete_list = (struct _GList *)(void *)0;
  g_tree_foreach(canvas_links, (signed int (*)(void *, void *, void *))canvas_link_update, (void *)&delete_list);
  g_list_foreach(delete_list, gfunc_remove_canvas_link, (void *)0);
  g_list_free(delete_list);
}

// diagram_update_nodes
// file diagram.c line 321
static void diagram_update_nodes(struct _GtkWidget *canvas)
{
  struct _GList *delete_list = (struct _GList *)(void *)0;
  struct anonymous$19 *new_node = (struct anonymous$19 *)(void *)0;
  nodes_catalog_update_all();
  do
  {
    new_node=new_nodes_pop();
    if(new_node == ((struct anonymous$19 *)NULL))
      break;

    check_new_node(new_node, canvas);
  }
  while((_Bool)1);
  g_tree_foreach(canvas_nodes, (signed int (*)(void *, void *, void *))canvas_node_update, (void *)&delete_list);
  g_list_foreach(delete_list, gfunc_remove_canvas_node, (void *)0);
  g_list_free(delete_list);
  limit_nodes();
  if(!(need_reposition == 0))
  {
    struct anonymous rdata;
    init_reposition(&rdata, canvas, displayed_nodes);
    g_tree_foreach(canvas_nodes, (signed int (*)(void *, void *, void *))reposition_canvas_nodes, (void *)&rdata);
    need_reposition = 0;
    need_font_refresh = 0;
  }

}

// display_node
// file diagram.c line 811
static signed int display_node(struct anonymous$19 *node)
{
  double diffms;
  if(node == ((struct anonymous$19 *)NULL))
    return 0;

  else
  {
    diffms=substract_times_ms(&appdata.now, &node->node_stats.stats.last_time);
    if(diffms >= pref.gui_node_timeout_time && IEEE_FLOAT_NOTEQUAL(pref.gui_node_timeout_time, 0.000000))
    {
      if(!(node->node_stats.pkt_list.length == 0u))
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(IEEE_FLOAT_EQUAL(pref.gui_node_timeout_time, 1.000000))
      {
        if(node->node_stats.pkt_list.length == 0u)
          g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, "Impossible situation in display node");

      }

      return (signed int)!(0 != 0);
    }
  }
}

// dns_close
// file dns.c line 35
void dns_close(void)
{
  thread_close();
}

// dns_lookup
// file dns.c line 41
const char * dns_lookup(struct anonymous$20 *address)
{
  const char *return_value_thread_lookup$1;
  return_value_thread_lookup$1=thread_lookup(address);
  return return_value_thread_lookup$1;
}

// dns_open
// file dns.c line 29
signed int dns_open(void)
{
  signed int return_value_thread_open$1;
  return_value_thread_open$1=thread_open();
  return return_value_thread_open$1;
}

// draw_oneside_link
// file diagram.c line 1221
static void draw_oneside_link(double xs, double ys, double xd, double yd, const struct anonymous$34 *link_stats, unsigned int scaledColor, struct _GnomeCanvasItem *item)
{
  struct _GnomeCanvasPoints *points;
  double versorx;
  double versory;
  double modulus;
  double link_size;
  double return_value_get_link_size$1;
  return_value_get_link_size$1=get_link_size(link_stats);
  link_size = return_value_get_link_size$1 / (double)2;
  if(link_size > 1250.000000)
    link_size = (double)(5000 / 4);

  versorx = -(yd - ys);
  versory = xd - xs;
  double return_value_pow$2;
  return_value_pow$2=pow(versorx, (double)2);
  double return_value_pow$3;
  return_value_pow$3=pow(versory, (double)2);
  modulus=sqrt(return_value_pow$2 + return_value_pow$3);
  if(IEEE_FLOAT_EQUAL(modulus, 0.000000))
  {
    link_size = (double)0;
    modulus = (double)1;
  }

  points=gnome_canvas_points_new(3);
  points->coords[(signed long int)0] = xd;
  points->coords[(signed long int)1] = yd;
  points->coords[(signed long int)2] = xs + (versorx * link_size) / modulus;
  points->coords[(signed long int)3] = ys + (versory * link_size) / modulus;
  points->coords[(signed long int)4] = xs - (versorx * link_size) / modulus;
  points->coords[(signed long int)5] = ys - (versory * link_size) / modulus;
  gnome_canvas_item_set(item, "points", points, (const void *)"fill_color_rgba", scaledColor, (void *)0);
  gnome_canvas_item_show(item);
  gnome_canvas_points_free(points);
}

// dump_stats
// file diagram.h line 34
void dump_stats(unsigned int diff_msecs)
{
  char *status_string;
  signed long int ipc;
  ipc=ipcache_active_entries();
  char *return_value_dcgettext$1;
  return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Nodes: %d (on canvas: %d, shown: %u), Links: %d, Conversations: %ld, names %ld, protocols %ld. Total Packets seen: %lu (in memory: %ld, on list %ld). IP cache entries %ld. Canvas objs: %ld. Refreshed: %u ms", 5);
  signed int return_value_node_count$2;
  return_value_node_count$2=node_count();
  signed int return_value_g_tree_nnodes$3;
  return_value_g_tree_nnodes$3=g_tree_nnodes(canvas_nodes);
  signed int return_value_links_catalog_size$4;
  return_value_links_catalog_size$4=links_catalog_size();
  signed long int return_value_active_conversations$5;
  return_value_active_conversations$5=active_conversations();
  signed long int return_value_active_names$6;
  return_value_active_names$6=active_names();
  signed long int return_value_protocol_summary_size$7;
  return_value_protocol_summary_size$7=protocol_summary_size();
  signed long int return_value_packet_list_item_count$8;
  return_value_packet_list_item_count$8=packet_list_item_count();
  status_string=g_strdup_printf(return_value_dcgettext$1, return_value_node_count$2, return_value_g_tree_nnodes$3, displayed_nodes, return_value_links_catalog_size$4, return_value_active_conversations$5, return_value_active_names$6, return_value_protocol_summary_size$7, appdata.n_packets, appdata.total_mem_packets, return_value_packet_list_item_count$8, ipc, canvas_obj_count, (unsigned int)diff_msecs);
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, "%s", status_string);
  g_free((void *)status_string);
}

// dump_xml
// file export.c line 87
void dump_xml(char *ofile)
{
  struct _IO_FILE *fout;
  char *xml;
  signed int tmp_statement_expression$1;
  if(!(ofile == ((char *)NULL)))
  {
    xml=generate_xml();
    do
    {
      signed int _g_boolean_var_;
      if(!(xml == ((char *)NULL)))
        _g_boolean_var_ = 1;

      else
        _g_boolean_var_ = 0;
      tmp_statement_expression$1 = _g_boolean_var_;
      if((signed long int)tmp_statement_expression$1 == 0l)
        g_assertion_message_expr((char *)0, "export.c", 96, (const char *)"dump_xml", "xml");

    }
    while((_Bool)0);
    fout=fopen(ofile, "wb");
    if(!(fout == ((struct _IO_FILE *)NULL)))
    {
      fprintf(fout, "%s", xml);
      fclose(fout);
    }

    g_free((void *)xml);
  }

}

// duplicate_config
// file preferences.c line 324
struct pref_struct * duplicate_config(struct pref_struct *src)
{
  struct pref_struct *t;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(sizeof(struct pref_struct) /*160ul*/ );
  t = (struct pref_struct *)return_value_g_malloc$1;
  signed int tmp_statement_expression$2;
  do
  {
    signed int _g_boolean_var_;
    if(!(t == ((struct pref_struct *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$2 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "preferences.c", 329, (const char *)"duplicate_config", "t");

  }
  while((_Bool)0);
  t->filter = (char *)(void *)0;
  t->text_color = (char *)(void *)0;
  t->fontname = (char *)(void *)0;
  t->colors = (char **)(void *)0;
  t->center_node = (char *)(void *)0;
  copy_config(t, src);
  return t;
}

// end_ethent
// file resolv.c line 278
static void end_ethent(void)
{
  if(!(eth_p == ((struct _IO_FILE *)NULL)))
  {
    fclose(eth_p);
    eth_p = (struct _IO_FILE *)(void *)0;
  }

}

// eth_name_common
// file names.c line 269
static signed int eth_name_common(enum anonymous$13 ethmode, struct anonymous$9 *nt)
{
  const char *numeric;
  const char *solved;
  if((signed int)nt->dir == INBOUND)
    fill_node_id(&nt->node_id, ethmode, nt, (signed int)ethmode, 0, 0);

  else
    fill_node_id(&nt->node_id, ethmode, nt, (signed int)ethmode + 6, 0, 0);
  numeric=ether_to_str(nt->node_id.addr.eth);
  if(!(pref.name_res == 0))
    solved=get_ether_name(nt->node_id.addr.eth, (signed int)!(0 != 0));

  else
    solved = (const char *)(void *)0;
  add_name(numeric, solved, &nt->node_id, nt);
  nt->offset = nt->offset + (unsigned short int)14;
  return (signed int)!(0 != 0);
}

// eth_name_lookup
// file resolv.c line 426
static const char * eth_name_lookup(const unsigned char *addr, signed int only_ethers)
{
  const struct hashmanuf *manufp;
  struct hashether *tp;
  struct hashether **table = eth_table;
  const struct _ether *eth;
  signed int i;
  signed int j = (signed int)addr[(signed long int)2] << 8 | (signed int)addr[(signed long int)3];
  i = (signed int)addr[(signed long int)4] << 8 | (signed int)addr[(signed long int)5];
  tp = table[(signed long int)((i ^ j) & 1024 - 1)];
  _Bool tmp_if_expr$2;
  signed int tmp_statement_expression$5;
  if(tp == ((struct hashether *)NULL))
  {
    void *return_value_g_malloc$1;
    return_value_g_malloc$1=g_malloc(sizeof(struct hashether) /*88ul*/ );
    table[(signed long int)((i ^ j) & 1024 - 1)] = (struct hashether *)return_value_g_malloc$1;
    tp = table[(signed long int)((i ^ j) & 1024 - 1)];
  }

  else
    while((_Bool)1)
    {
      signed int return_value_memcmp$3;
      return_value_memcmp$3=memcmp((const void *)tp->addr, (const void *)addr, sizeof(unsigned char [6l]) /*6ul*/ );
      if(return_value_memcmp$3 == 0)
      {
        if(only_ethers == 0)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = tp->is_name_from_file != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          return tp->name;

        else
          return (const char *)(void *)0;
      }

      if(tp->next == ((struct hashether *)NULL))
      {
        void *return_value_g_malloc$4;
        return_value_g_malloc$4=g_malloc(sizeof(struct hashether) /*88ul*/ );
        tp->next = (struct hashether *)return_value_g_malloc$4;
        do
        {
          signed int _g_boolean_var_;
          if(!(tp->next == ((struct hashether *)NULL)))
            _g_boolean_var_ = 1;

          else
            _g_boolean_var_ = 0;
          tmp_statement_expression$5 = _g_boolean_var_;
          if((signed long int)tmp_statement_expression$5 == 0l)
            g_assertion_message_expr((char *)0, "resolv.c", 459, (const char *)"eth_name_lookup", "tp->next");

        }
        while((_Bool)0);
        tp = tp->next;
        break;
      }

      tp = tp->next;
    }
  signed int tmp_statement_expression$6;
  do
  {
    signed int eth_name_lookup$$1$$3$$1$$_g_boolean_var_;
    if(!(tp == ((struct hashether *)NULL)))
      eth_name_lookup$$1$$3$$1$$_g_boolean_var_ = 1;

    else
      eth_name_lookup$$1$$3$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$6 = eth_name_lookup$$1$$3$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$6 == 0l)
      g_assertion_message_expr((char *)0, "resolv.c", 466, (const char *)"eth_name_lookup", "tp");

  }
  while((_Bool)0);
  memcpy((void *)tp->addr, (const void *)addr, sizeof(unsigned char [6l]) /*6ul*/ );
  tp->next = (struct hashether *)(void *)0;
  eth=get_ethbyaddr(addr);
  const char *return_value_ether_to_str$7;
  if(eth == ((const struct _ether *)NULL))
  {
    manufp=manuf_name_lookup(addr);
    if(manufp == ((const struct hashmanuf *)NULL))
    {
      return_value_ether_to_str$7=ether_to_str((unsigned char *)addr);
      snprintf(tp->name, (unsigned long int)64, "%s", return_value_ether_to_str$7);
    }

    else
      snprintf(tp->name, (unsigned long int)64, "%s_%02x:%02x:%02x", (const void *)manufp->name, addr[(signed long int)3], addr[(signed long int)4], addr[(signed long int)5]);
    tp->is_name_from_file = 0;
  }

  else
  {
    safe_strncpy(tp->name, eth->name, (unsigned long int)64);
    tp->is_name_from_file = (signed int)!(0 != 0);
  }
  _Bool tmp_if_expr$8;
  if(only_ethers == 0)
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = tp->is_name_from_file != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$8)
    return tp->name;

  else
    return (const char *)(void *)0;
}

// ether_to_str
// file util.h line 51
const char * ether_to_str(const unsigned char *ad)
{
  const char *return_value_ether_to_str_punct$1;
  return_value_ether_to_str_punct$1=ether_to_str_punct(ad, (char)58);
  return return_value_ether_to_str_punct$1;
}

// ether_to_str_punct
// file util.c line 262
static const char * ether_to_str_punct(const unsigned char *ad, char punct)
{
  char *p;
  signed int i;
  unsigned int octet;
  static char str[3l][18l];
  static char *cur;
  if(cur == str[0l])
    cur = &str[(signed long int)1][(signed long int)0];

  else
    if(cur == str[1l])
      cur = &str[(signed long int)2][(signed long int)0];

    else
      cur = &str[(signed long int)0][(signed long int)0];
  p = &cur[(signed long int)18];
  p = p - 1l;
  *p = (char)0;
  i = 5;
  do
  {
    octet = (unsigned int)ad[(signed long int)i];
    p = p - 1l;
    static const char hex_digits[16l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
    *p = hex_digits[(signed long int)(octet & (unsigned int)0xF)];
    octet = octet >> 4;
    p = p - 1l;
    *p = hex_digits[(signed long int)(octet & (unsigned int)0xF)];
    if(i == 0)
      break;

    if(!(punct == 0))
    {
      p = p - 1l;
      *p = punct;
    }

    i = i - 1;
  }
  while((_Bool)1);
  return p;
}

// ethereal_nbns_name
// file names_netbios.h line 40
signed int ethereal_nbns_name(const char *pd, signed int offset, signed int pd_len, char *outname, unsigned long int outname_size, signed int *name_type_ret)
{
  signed int name_len;
  char name[1025l];
  char nbname[128l];
  char buf[16l];
  char *pname;
  char *pnbname;
  char cname;
  char cnbname;
  char *name_ret;
  signed int name_type;
  name_len=get_dns_name(pd, offset, pd_len, name, (signed int)sizeof(char [1025l]) /*1025ul*/ );
  name_ret = outname;
  pname = &name[(signed long int)0];
  pnbname = &nbname[(signed long int)0];
  do
  {
    cname = *pname;
    if((signed int)cname == 0)
      break;

    if((signed int)cname == 46)
      break;

    if((signed int)cname >= 91 || !((signed int)cname >= 65))
    {
      safe_strncpy(nbname, "Illegal NetBIOS name (character not between A and Z in first-level encoding)", sizeof(char [128l]) /*128ul*/ );
      goto bad;
    }

    cname = cname - (char)65;
    cnbname = (char)((signed int)cname << 4);
    pname = pname + 1l;
    cname = *pname;
    if((signed int)cname == 0 || (signed int)cname == 46)
    {
      safe_strncpy(nbname, "Illegal NetBIOS name (odd number of bytes)", sizeof(char [128l]) /*128ul*/ );
      goto bad;
    }

    if((signed int)cname >= 91 || !((signed int)cname >= 65))
    {
      safe_strncpy(nbname, "Illegal NetBIOS name (character not between A and Z in first-level encoding)", sizeof(char [128l]) /*128ul*/ );
      goto bad;
    }

    cname = cname - (char)65;
    cnbname = cnbname | cname;
    pname = pname + 1l;
    if(!(pnbname >= nbname + 16l))
      *pnbname = cnbname;

    pnbname = pnbname + 1l;
  }
  while((_Bool)1);
  if(!(pnbname - nbname == 16l))
    snprintf(nbname, sizeof(char [128l]) /*128ul*/ , "Illegal NetBIOS name (%ld bytes long)", (signed long int)(pnbname - nbname));

  else
  {
    name_type=process_netbios_name(nbname, outname, outname_size);
    snprintf(buf, sizeof(char [16l]) /*16ul*/ , "<%02x>", name_type);
    safe_strncat(outname, buf, outname_size);
    if((signed int)cname == 46)
      safe_strncat(outname, pname, outname_size);

    if(!(name_type_ret == ((signed int *)NULL)))
      *name_type_ret = name_type;

    return name_len;
  }

bad:
  ;
  if(!(name_type_ret == ((signed int *)NULL)))
    *name_type_ret = -1;

  safe_strncpy(outname, nbname, outname_size);
  return name_len;
}

// fatal_error_dialog
// file menus.c line 619
void fatal_error_dialog(const char *message)
{
  struct _GtkWidget *error_messagebox;
  error_messagebox=gtk_message_dialog_new((struct _GtkWindow *)(void *)0, (enum anonymous$67)GTK_DIALOG_MODAL, (enum anonymous$69)GTK_MESSAGE_ERROR, (enum anonymous$70)GTK_BUTTONS_OK, "%s", message);
  unsigned long int return_value_gtk_dialog_get_type$1;
  return_value_gtk_dialog_get_type$1=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)error_messagebox, return_value_gtk_dialog_get_type$1);
  gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$2);
  gtk_widget_destroy(error_messagebox);
}

// fgetline
// file resolv.c line 129
static signed int fgetline(char **buf, signed int *size, struct _IO_FILE *fp)
{
  signed int len;
  signed int c;
  signed int tmp_post$4;
  if(fp == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    if(*buf == ((char *)NULL))
    {
      if(*size == 0)
        *size = 8192;

      void *return_value_g_malloc$1;
      return_value_g_malloc$1=g_malloc((unsigned long int)*size);
      *buf = (char *)return_value_g_malloc$1;
      if(*buf == ((char *)NULL))
        return -1;

    }

    signed int return_value_feof$2;
    return_value_feof$2=feof(fp);
    if(!(return_value_feof$2 == 0))
      return -1;

    else
    {
      len = 0;
      do
      {
        c=_IO_getc(fp);
        if(c == -1)
          break;

        if(c == 10)
          break;

        if(1 + len >= *size)
        {
          *size = *size + 8192;
          void *return_value_g_realloc$3;
          return_value_g_realloc$3=g_realloc((void *)*buf, (unsigned long int)*size);
          *buf = (char *)return_value_g_realloc$3;
          if(*buf == ((char *)NULL))
            return -1;

        }

        tmp_post$4 = len;
        len = len + 1;
        (*buf)[(signed long int)tmp_post$4] = (char)c;
      }
      while((_Bool)1);
      if(c == -1 && len == 0)
        return -1;

      else
      {
        (*buf)[(signed long int)len] = (char)0;
        return len;
      }
    }
  }
}

// fill_node_id
// file names.c line 195
static void fill_node_id(struct anonymous$5 *node_id, enum anonymous$13 apemode, const struct anonymous$9 *nt, signed int disp, signed int portdisp, signed int type)
{
  unsigned char *dt = (unsigned char *)(void *)0;
  unsigned long int sz = (unsigned long int)0;
  memset((void *)node_id, 0, sizeof(struct anonymous$5) /*28ul*/ );
  node_id->node_type = apemode;
  char *return_value_dcgettext$1;
  switch((signed int)apemode)
  {
    case LINK6:
    {
      dt = node_id->addr.eth;
      sz = sizeof(unsigned char [6l]) /*6ul*/ ;
      break;
    }
    case IP:
    {
      dt = node_id->addr.ip.$anon0.$anon0.$anon0.addr8;
      sz = (unsigned long int)(type == 2 ? 32 / 8 : (type == 10 ? 128 / 8 : 0));
      break;
    }
    case TCP:
    {
      dt = node_id->addr.tcp4.host.$anon0.$anon0.$anon0.addr8;
      sz = (unsigned long int)(type == 2 ? 32 / 8 : (type == 10 ? 128 / 8 : 0));
      break;
    }
    default:
    {
      return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Unsupported ape mode in fill_node_id", 5);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_ERROR, return_value_dcgettext$1);

    __CPROVER_DUMP_L5:
      ;
      goto __CPROVER_DUMP_L5;
    }
  }
  _Bool tmp_if_expr$2;
  if(!((unsigned long int)nt->packet_size >= sz + (unsigned long int)(disp + (signed int)nt->offset)))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)nt->packet_size < (signed int)nt->offset + portdisp + 2 ? (_Bool)1 : (_Bool)0;
  unsigned short int tmp_statement_expression$3;
  if(tmp_if_expr$2)
    missing_data_msg(nt, (const char *)(void *)0);

  else
    if((signed int)apemode == TCP)
    {
      node_id->addr.tcp4.host.$anon0.$anon0.type = (unsigned int)type;
      do
        memmove((void *)dt, (const void *)(nt->p + (signed long int)nt->offset + (signed long int)disp), sz);
      while((_Bool)0);
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)*((unsigned short int *)(nt->p + (signed long int)nt->offset + (signed long int)portdisp));
      asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression$3 = __v;
      node_id->addr.tcp4.port = tmp_statement_expression$3;
    }

    else
    {
      if((signed int)apemode == IP)
        node_id->addr.ip.$anon0.$anon0.type = (unsigned int)type;

      do
        memmove((void *)dt, (const void *)(nt->p + (signed long int)nt->offset + (signed long int)disp), sz);
      while((_Bool)0);
    }
}

// finalize_callback
// file diagram.c line 203
static void finalize_callback(void *data, struct _GObject *obj)
{
  canvas_obj_count = canvas_obj_count - 1l;
}

// find_conversation
// file conversations.h line 33
const char * find_conversation(struct anonymous$20 *src_address, struct anonymous$20 *dst_address, unsigned short int src_port, unsigned short int dst_port)
{
  struct _GList *item;
  if(dst_address == ((struct anonymous$20 *)NULL) || src_address == ((struct anonymous$20 *)NULL))
  {
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, "NULL ptr in find_conversation");
    return (const char *)(void *)0;
  }

  else
  {
    item=find_conversation_ptr(src_address, dst_address, src_port, dst_port);
    if(!(item == ((struct _GList *)NULL)))
    {
      struct anonymous$61 *conv = (struct anonymous$61 *)item->data;
      return conv->data;
    }

    else
      return (const char *)(void *)0;
  }
}

// find_conversation_ptr
// file conversations.c line 45
static struct _GList * find_conversation_ptr(struct anonymous$20 *src_address, struct anonymous$20 *dst_address, unsigned short int src_port, unsigned short int dst_port)
{
  struct _GList *item = conversations;
  struct anonymous$61 *conv = (struct anonymous$61 *)(void *)0;
  signed int tmp_statement_expression$1;
  do
  {
    signed int find_conversation_ptr$$1$$1$$1$$_g_boolean_var_;
    if(!(src_address == ((struct anonymous$20 *)NULL)))
      find_conversation_ptr$$1$$1$$1$$_g_boolean_var_ = 1;

    else
      find_conversation_ptr$$1$$1$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$1 = find_conversation_ptr$$1$$1$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "conversations.c", 51, (const char *)"find_conversation_ptr", "src_address");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int _g_boolean_var_;
    if(!(dst_address == ((struct anonymous$20 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$2 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "conversations.c", 52, (const char *)"find_conversation_ptr", "dst_address");

  }
  while((_Bool)0);
  _Bool tmp_if_expr$5;
  signed int return_value_memcmp$4;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$21;
  signed int return_value_memcmp$12;
  _Bool tmp_if_expr$14;
  signed int return_value_memcmp$13;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$19;
  while(!(item == ((struct _GList *)NULL)))
  {
    conv = (struct anonymous$61 *)item->data;
    signed int return_value_memcmp$3;
    return_value_memcmp$3=memcmp((const void *)src_address, (const void *)&conv->src_address, sizeof(struct anonymous$20) /*20ul*/ );
    if(return_value_memcmp$3 == 0)
    {
      return_value_memcmp$4=memcmp((const void *)dst_address, (const void *)&conv->dst_address, sizeof(struct anonymous$20) /*20ul*/ );
      tmp_if_expr$5 = return_value_memcmp$4 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
    {
      if(src_port == 0)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = !(conv->src_port != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = src_port == conv->src_port ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$8 = (_Bool)0;
    if(tmp_if_expr$8)
    {
      if(dst_port == 0)
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = !(conv->dst_port != 0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$9)
        tmp_if_expr$10 = (_Bool)1;

      else
        tmp_if_expr$10 = dst_port == conv->dst_port ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$11 = tmp_if_expr$10 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$11 = (_Bool)0;
    if(tmp_if_expr$11)
      tmp_if_expr$21 = (_Bool)1;

    else
    {
      return_value_memcmp$12=memcmp((const void *)src_address, (const void *)&conv->dst_address, sizeof(struct anonymous$20) /*20ul*/ );
      if(return_value_memcmp$12 == 0)
      {
        return_value_memcmp$13=memcmp((const void *)dst_address, (const void *)&conv->src_address, sizeof(struct anonymous$20) /*20ul*/ );
        tmp_if_expr$14 = return_value_memcmp$13 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$14 = (_Bool)0;
      if(tmp_if_expr$14)
      {
        if(src_port == 0)
          tmp_if_expr$15 = (_Bool)1;

        else
          tmp_if_expr$15 = !(conv->dst_port != 0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$15)
          tmp_if_expr$16 = (_Bool)1;

        else
          tmp_if_expr$16 = src_port == conv->dst_port ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$17 = tmp_if_expr$16 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$17 = (_Bool)0;
      if(tmp_if_expr$17)
      {
        if(dst_port == 0)
          tmp_if_expr$18 = (_Bool)1;

        else
          tmp_if_expr$18 = !(conv->src_port != 0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$18)
          tmp_if_expr$19 = (_Bool)1;

        else
          tmp_if_expr$19 = dst_port == conv->src_port ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$20 = tmp_if_expr$19 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$20 = (_Bool)0;
      tmp_if_expr$21 = tmp_if_expr$20 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$21)
      break;

    item = item->next;
  }
  return item;
}

// force_next_packet
// file capture.h line 38
void force_next_packet(void)
{
  if(ms_to_next >= 21ul)
  {
    ms_to_next = (unsigned long int)0;
    g_source_remove((unsigned int)capture_source);
  }

}

// free_config
// file preferences.c line 342
void free_config(struct pref_struct *t)
{
  g_free((void *)t->filter);
  t->filter = (char *)(void *)0;
  g_free((void *)t->text_color);
  t->text_color = (char *)(void *)0;
  g_free((void *)t->fontname);
  t->fontname = (char *)(void *)0;
  g_free((void *)t->center_node);
  t->center_node = (char *)(void *)0;
  g_strfreev(t->colors);
  t->colors = (char **)(void *)0;
}

// free_static_data
// file main.c line 295
static void free_static_data(void)
{
  protohash_clear();
  ipcache_clear();
  services_clear();
}

// freehash
// file datastructs.c line 57
static void freehash(void *data)
{
  g_free(data);
}

// gdk_input_callback
// file capture.c line 486
static void gdk_input_callback(void *dummy, signed int source, enum anonymous$4 condition)
{
  get_live_packet();
}

// generate_xml
// file export.c line 59
char * generate_xml(void)
{
  char *xmlh;
  char *xmln;
  char *xml;
  char *oldlocale;
  char *return_value_setlocale$1;
  return_value_setlocale$1=setlocale(6, (const char *)(void *)0);
  oldlocale=g_strdup(return_value_setlocale$1);
  setlocale(6, "C");
  xmlh=header_xml();
  xmln=nodes_catalog_xml();
  xml=g_strdup_printf("<?xml version=\"1.0\"?>\n<!-- traffic data in bytes. last_heard in seconds from dump time -->\n<etherape>\n%s%s</etherape>", xmlh, xmln);
  setlocale(6, oldlocale);
  g_free((void *)xmln);
  g_free((void *)xmlh);
  g_free((void *)oldlocale);
  return xml;
}

// get_arp_name
// file names.c line 313
static signed int get_arp_name(struct anonymous$9 *nt)
{
  unsigned short int protocol_type;
  unsigned char hardware_len;
  unsigned char protocol_len;
  unsigned short int tmp_statement_expression$1;
  if((signed int)nt->dir == INBOUND)
    return 0;

  else
    if(4 + (signed int)nt->offset >= (signed int)nt->packet_size)
    {
      missing_data_msg(nt, "ARP");
      return 0;
    }

    else
    {
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)*((unsigned short int *)(nt->p + (signed long int)nt->offset + (signed long int)2));
      asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression$1 = __v;
      protocol_type = tmp_statement_expression$1;
      if(!((signed int)protocol_type == 0x0800))
        return 0;

      else
        if(7 + (signed int)nt->offset >= (signed int)nt->packet_size)
        {
          missing_data_msg(nt, "ARP");
          return 0;
        }

        else
        {
          hardware_len = *((unsigned char *)(nt->p + (signed long int)nt->offset + (signed long int)4));
          protocol_len = *((unsigned char *)(nt->p + (signed long int)nt->offset + (signed long int)5));
          fill_node_id(&nt->node_id, (enum anonymous$13)IP, nt, 8 + (signed int)hardware_len, 0, 2);
          const char *return_value_ipv4_to_str$2;
          return_value_ipv4_to_str$2=ipv4_to_str(nt->node_id.addr.ip.$anon0.$anon0.$anon0.addr_v4);
          const char *return_value_dns_lookup$3;
          return_value_dns_lookup$3=dns_lookup(&nt->node_id.addr.ip);
          add_name(return_value_ipv4_to_str$2, return_value_dns_lookup$3, &nt->node_id, nt);
          return 0;
        }
    }
}

// get_capture_status
// file capture.h line 31
enum status_t get_capture_status(void)
{
  return capture_status;
}

// get_color_store
// file pref_dialog.c line 491
static signed int get_color_store(struct _EATreePos *ep)
{
  ep->gs = (struct _GtkListStore *)(void *)0;
  struct _GtkWidget *return_value_glade_xml_get_widget$1;
  return_value_glade_xml_get_widget$1=glade_xml_get_widget(appdata.xml, "color_list");
  unsigned long int return_value_gtk_tree_view_get_type$2;
  return_value_gtk_tree_view_get_type$2=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$1, return_value_gtk_tree_view_get_type$2);
  ep->gv = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$3;
  if(ep->gv == ((struct _GtkTreeView *)NULL))
    return 0;

  else
  {
    struct _GtkTreeModel *return_value_gtk_tree_view_get_model$4;
    return_value_gtk_tree_view_get_model$4=gtk_tree_view_get_model(ep->gv);
    unsigned long int return_value_gtk_list_store_get_type$5;
    return_value_gtk_list_store_get_type$5=gtk_list_store_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_tree_view_get_model$4, return_value_gtk_list_store_get_type$5);
    ep->gs = (struct _GtkListStore *)return_value_g_type_check_instance_cast$6;
    if(!(ep->gs == ((struct _GtkListStore *)NULL)))
      return (signed int)!(0 != 0);

    else
    {
      unsigned long int return_value_gdk_color_get_type$7;
      return_value_gdk_color_get_type$7=gdk_color_get_type();
      ep->gs=gtk_list_store_new(3, (unsigned long int)(16 << 2), return_value_gdk_color_get_type$7, (unsigned long int)(16 << 2));
      unsigned long int return_value_gtk_tree_model_get_type$8;
      return_value_gtk_tree_model_get_type$8=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
      return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)ep->gs, return_value_gtk_tree_model_get_type$8);
      gtk_tree_view_set_model(ep->gv, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$9);
      struct _GtkCellRenderer *return_value_gtk_cell_renderer_text_new$10;
      return_value_gtk_cell_renderer_text_new$10=gtk_cell_renderer_text_new();
      struct _GtkTreeViewColumn *return_value_gtk_tree_view_column_new_with_attributes$11;
      return_value_gtk_tree_view_column_new_with_attributes$11=gtk_tree_view_column_new_with_attributes("Color", return_value_gtk_cell_renderer_text_new$10, (const void *)"text", 0, (const void *)"background-gdk", 1, (void *)0);
      gtk_tree_view_append_column(ep->gv, return_value_gtk_tree_view_column_new_with_attributes$11);
      struct _GtkCellRenderer *return_value_gtk_cell_renderer_text_new$12;
      return_value_gtk_cell_renderer_text_new$12=gtk_cell_renderer_text_new();
      struct _GtkTreeViewColumn *return_value_gtk_tree_view_column_new_with_attributes$13;
      return_value_gtk_tree_view_column_new_with_attributes$13=gtk_tree_view_column_new_with_attributes("Protocol", return_value_gtk_cell_renderer_text_new$12, (const void *)"text", 2, (void *)0);
      gtk_tree_view_append_column(ep->gv, return_value_gtk_tree_view_column_new_with_attributes$13);
      return (signed int)!(0 != 0);
    }
  }
}

// get_default_filter
// file capture.h line 40
char * get_default_filter(enum anonymous$13 mode)
{
  char *return_value_g_strdup$1;
  char *return_value_g_strdup$2;
  char *return_value_g_strdup$3;
  switch((signed int)mode)
  {
    case IP:
    {
      return_value_g_strdup$1=g_strdup("ip or ip6");
      return return_value_g_strdup$1;
    }
    case TCP:
    {
      return_value_g_strdup$2=g_strdup("tcp");
      return return_value_g_strdup$2;
    }
    case LINK6:
    {
      return_value_g_strdup$3=g_strdup("");
      return return_value_g_strdup$3;
    }
    default:
    {
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_ERROR, "Invalid apemode %d", mode);

    __CPROVER_DUMP_L6:
      ;
      goto __CPROVER_DUMP_L6;
    }
  }
}

// get_dns_name
// file names_netbios.c line 102
static signed int get_dns_name(const char *pd, signed int offset, signed int pd_len, char *name, signed int maxname)
{
  const char *dp = pd + (signed long int)offset;
  const char *dptr = dp;
  char *np = name;
  signed int len = -1;
  unsigned int component_len;
  signed int dns_data_offset;
  const char *tmp_post$1;
  char *tmp_post$2;
  char *tmp_post$3;
  const char *tmp_post$4;
  if(!(offset >= pd_len))
  {
    dns_data_offset = offset;
    maxname = maxname - 1;
    while((_Bool)1)
    {
      if(1 + offset >= pd_len)
        goto overflow;

      tmp_post$1 = dp;
      dp = dp + 1l;
      component_len = (unsigned int)*tmp_post$1;
      offset = offset + 1;
      if(component_len == 0u)
        break;

      switch(component_len & (unsigned int)0xc0)
      {
        case (unsigned int)0x00:
        {
          if(!(np == name))
          {
            if(maxname >= 1)
            {
              tmp_post$2 = np;
              np = np + 1l;
              *tmp_post$2 = (char)46;
              maxname = maxname - 1;
            }

          }

          if(component_len + (unsigned int)offset >= (unsigned int)pd_len)
            goto overflow;

          for( ; component_len >= 1u; offset = offset + 1)
          {
            if(maxname >= 1)
            {
              tmp_post$3 = np;
              np = np + 1l;
              *tmp_post$3 = *dp;
              maxname = maxname - 1;
            }

            component_len = component_len - 1u;
            dp = dp + 1l;
          }
          break;
        }
        case (unsigned int)0x40:

        case (unsigned int)0x80:
          goto dns_name_terminated;
        case (unsigned int)0xc0:
        {
          if(1 + offset >= pd_len)
            goto overflow;

          tmp_post$4 = dp;
          dp = dp + 1l;
          offset = (signed int)((unsigned int)dns_data_offset + ((component_len & (unsigned int)~0xc0) << 8 | (unsigned int)*tmp_post$4));
          if(!(len >= 0))
            len = (signed int)(dp - dptr);

          dp = pd + (signed long int)offset;
        }
        default:
          ;
      }
    }

  dns_name_terminated:
    ;
    *np = (char)0;
    if(!(len >= 0))
      len = (signed int)(dp - dptr);

    if((signed int)*name == 0)
      safe_strncpy(name, "<Root>", (unsigned long int)maxname);

    return len;
  }

  else
  {

  overflow:
    ;
    safe_strncpy(name, "<Name goes past end of captured data in packet>", (unsigned long int)maxname);
    if(!(len >= 0))
      len = (signed int)(dp - dptr);

    return len;
  }
}

// get_eth_802_3
// file decode_proto.c line 485
static void get_eth_802_3(struct anonymous$3 *dp, enum anonymous$11 ethhdr_type)
{
  switch((signed int)ethhdr_type)
  {
    case ETHERNET_802_2:
    {
      get_llc(dp);
      break;
    }
    case ETHERNET_802_3:
      get_ipx(dp);
  }
}

// get_eth_II
// file decode_proto.c line 561
static void get_eth_II(struct anonymous$3 *dp, enum anonymous$8 etype)
{
  if((signed int)etype == ETHERTYPE_IP || (signed int)etype == ETHERTYPE_IPv6)
    get_ip(dp);

  else
    if((signed int)etype == ETHERTYPE_IPX)
      get_ipx(dp);

    else
      append_etype_prot(dp, etype);
}

// get_eth_type
// file decode_proto.c line 392
static void get_eth_type(struct anonymous$3 *dp)
{
  unsigned short int ethsize;
  unsigned int size_offset;
  enum anonymous$11 ethhdr_type = (enum anonymous$11)ETHERNET_II;
  unsigned short int tmp_statement_expression$1;
  unsigned short int tmp_statement_expression$2;
  unsigned short int tmp_statement_expression$3;
  _Bool tmp_if_expr$4;
  if(dp->cur_len >= 20u)
  {
    size_offset = (unsigned int)12;
    unsigned short int get_eth_type$$1$$1$$__v;
    unsigned short int get_eth_type$$1$$1$$__x = (unsigned short int)*((unsigned short int *)(dp->cur_packet + (signed long int)size_offset));
    asm("rorw $8, %w0" : "=r"(get_eth_type$$1$$1$$__v) : "0"(get_eth_type$$1$$1$$__x) : "cc");
    tmp_statement_expression$1 = get_eth_type$$1$$1$$__v;
    ethsize = tmp_statement_expression$1;
    if((signed int)ethsize == ETHERTYPE_VLAN)
    {
      decode_proto_add(dp, "802.1Q");
      if(!((G_LOG_LEVEL_DEBUG & (signed int)appdata.debug_mask) == 0))
      {
        unsigned short int vlanid;
        unsigned short int get_eth_type$$1$$2$$1$$1$$__v;
        unsigned short int get_eth_type$$1$$2$$1$$1$$__x = (unsigned short int)*((unsigned short int *)(dp->cur_packet + (signed long int)14));
        asm("rorw $8, %w0" : "=r"(get_eth_type$$1$$2$$1$$1$$__v) : "0"(get_eth_type$$1$$2$$1$$1$$__x) : "cc");
        tmp_statement_expression$2 = get_eth_type$$1$$2$$1$$1$$__v;
        vlanid = (unsigned short int)((signed int)tmp_statement_expression$2 & 0x0fff);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "VLAN id: %u", vlanid);
      }

      size_offset = (unsigned int)16;
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)*((unsigned short int *)(dp->cur_packet + (signed long int)size_offset));
      asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression$3 = __v;
      ethsize = tmp_statement_expression$3;
    }

    if(!((signed int)ethsize >= 1501))
    {
      if((signed int)dp->cur_packet[(signed long int)(2u + size_offset)] == 0xff)
        tmp_if_expr$4 = (signed int)dp->cur_packet[(signed long int)(size_offset + (unsigned int)3)] == 0xff ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        ethhdr_type = (enum anonymous$11)ETHERNET_802_3;

      else
        ethhdr_type = (enum anonymous$11)ETHERNET_802_2;
      if(!((signed int)*dp->cur_packet == 0x01))
        goto __CPROVER_DUMP_L14;

      if(!((signed int)dp->cur_packet[1l] == 0x00))
        goto __CPROVER_DUMP_L14;

      if(!((signed int)dp->cur_packet[2l] == 0x0C))
        goto __CPROVER_DUMP_L14;

      if(!((signed int)dp->cur_packet[3l] == 0x00))
        goto __CPROVER_DUMP_L14;

      if(!((signed int)dp->cur_packet[4l] == 0x00))
        goto __CPROVER_DUMP_L14;

      decode_proto_add(dp, "ISL");
    }

    else
    {

    __CPROVER_DUMP_L14:
      ;
      dp->dst_node_id.node_type = (enum anonymous$13)LINK6;
      do
        memmove((void *)dp->dst_node_id.addr.eth, (const void *)(dp->cur_packet + (signed long int)0), sizeof(unsigned char [6l]) /*6ul*/ );
      while((_Bool)0);
      dp->src_node_id.node_type = (enum anonymous$13)LINK6;
      do
        memmove((void *)dp->src_node_id.addr.eth, (const void *)(dp->cur_packet + (signed long int)6), sizeof(unsigned char [6l]) /*6ul*/ );
      while((_Bool)0);
      add_offset(dp, size_offset + (unsigned int)2);
      if((signed int)ethhdr_type == ETHERNET_802_3)
        decode_proto_add(dp, "802.3-RAW");

      else
        if((signed int)ethhdr_type == ETHERNET_802_2)
        {
          decode_proto_add(dp, "802.3");
          get_eth_802_3(dp, ethhdr_type);
        }

        else
        {
          decode_proto_add(dp, "ETH_II");
          get_eth_II(dp, (enum anonymous$8)ethsize);
        }
    }
  }

}

// get_ethbyaddr
// file resolv.c line 311
static const struct _ether * get_ethbyaddr(const unsigned char *addr)
{
  struct _ether *eth;
  set_ethent(g_ethers_path);
  signed int return_value_memcmp$1;
  do
  {
    eth=get_ethent(1);
    if(eth == ((struct _ether *)NULL))
      break;

    return_value_memcmp$1=memcmp((const void *)addr, (const void *)eth->addr, (unsigned long int)6);
    if(return_value_memcmp$1 == 0)
      break;

  }
  while((_Bool)1);
  signed int return_value_memcmp$2;
  if(eth == ((struct _ether *)NULL))
  {
    end_ethent();
    set_ethent(g_pethers_path);
    do
    {
      eth=get_ethent(1);
      if(eth == ((struct _ether *)NULL))
        break;

      return_value_memcmp$2=memcmp((const void *)addr, (const void *)eth->addr, (unsigned long int)6);
      if(return_value_memcmp$2 == 0)
        break;

    }
    while((_Bool)1);
    end_ethent();
  }

  return eth;
}

// get_ethent
// file resolv.c line 288
static struct _ether * get_ethent(signed int six_bytes)
{
  signed int return_value_fgetline$1;
  if(eth_p == ((struct _IO_FILE *)NULL))
    return (struct _ether *)(void *)0;

  else
  {
    do
    {
      static signed int size = 0;
      static char *buf = (char *)(void *)0;
      return_value_fgetline$1=fgetline(&buf, &size, eth_p);
      if(!(return_value_fgetline$1 >= 0))
        break;

      signed int return_value_parse_ether_line$2;
      static struct _ether eth;
      return_value_parse_ether_line$2=parse_ether_line(buf, &eth, six_bytes);
      if(return_value_parse_ether_line$2 == 0)
        return &eth;

    }
    while((_Bool)1);
    return (struct _ether *)(void *)0;
  }
}

// get_ether_name
// file resolv.c line 500
extern const char * get_ether_name(const unsigned char *addr, signed int only_ethers)
{
  if(eth_resolution_initialized == 0)
  {
    initialize_ethers();
    eth_resolution_initialized = 1;
  }

  const char *return_value_eth_name_lookup$1;
  return_value_eth_name_lookup$1=eth_name_lookup(addr, only_ethers);
  return return_value_eth_name_lookup$1;
}

// get_fddi_type
// file decode_proto.c line 501
static void get_fddi_type(struct anonymous$3 *dp)
{
  decode_proto_add(dp, "FDDI");
  if(dp->cur_len >= 14u)
  {
    decode_proto_add(dp, "LLC");
    dp->dst_node_id.node_type = (enum anonymous$13)LINK6;
    do
      memmove((void *)dp->dst_node_id.addr.eth, (const void *)(dp->cur_packet + (signed long int)1), sizeof(unsigned char [6l]) /*6ul*/ );
    while((_Bool)0);
    dp->src_node_id.node_type = (enum anonymous$13)LINK6;
    do
      memmove((void *)dp->src_node_id.addr.eth, (const void *)(dp->cur_packet + (signed long int)7), sizeof(unsigned char [6l]) /*6ul*/ );
    while((_Bool)0);
    if(dp->cur_len >= 21u)
    {
      if((signed int)dp->cur_packet[19l] == 0x08)
      {
        if((signed int)dp->cur_packet[20l] == 0x00)
        {
          add_offset(dp, (unsigned int)21);
          get_ip(dp);
        }

      }

    }

  }

}

// get_ftp
// file decode_proto.c line 1569
static void get_ftp(struct anonymous$3 *dp)
{
  char *mesg = (char *)(void *)0;
  char *str;
  unsigned int hi_byte;
  unsigned int low_byte;
  unsigned short int server_port;
  unsigned int size = dp->cur_len;
  unsigned int i = (unsigned int)0;
  decode_proto_add(dp, "FTP");
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  signed int tmp_statement_expression$4;
  _Bool tmp_if_expr$6;
  signed int return_value_sscanf$5;
  _Bool tmp_if_expr$8;
  signed int return_value_sscanf$7;
  if(dp->cur_len >= 3u)
  {
    if(!((signed int)(char)*dp->cur_packet == 50))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)(char)dp->cur_packet[(signed long int)1] != 50 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)(char)dp->cur_packet[(signed long int)2] != 55 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$2)
    {
      void *return_value_g_malloc$3;
      return_value_g_malloc$3=g_malloc((unsigned long int)(size + (unsigned int)1));
      mesg = (char *)return_value_g_malloc$3;
      do
      {
        signed int _g_boolean_var_;
        if(!(mesg == ((char *)NULL)))
          _g_boolean_var_ = 1;

        else
          _g_boolean_var_ = 0;
        tmp_statement_expression$4 = _g_boolean_var_;
        if((signed long int)tmp_statement_expression$4 == 0l)
          g_assertion_message_expr((char *)0, "decode_proto.c", 1589, (const char *)"get_ftp", "mesg");

      }
      while((_Bool)0);
      memcpy((void *)mesg, (const void *)dp->cur_packet, (unsigned long int)size);
      mesg[(signed long int)size] = (char)0;
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Found FTP passive command: %s", mesg);
      str=strtok(mesg, "(,)");
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "FTP Token: %s", str != ((char *)NULL) ? str : "NULL");
      i = (unsigned int)0;
      for( ; !(str == ((char *)NULL)) && !(i >= 4u); i = i + 1u)
      {
        str=strtok((char *)(void *)0, "(,)");
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "FTP Token: %s", str != ((char *)NULL) ? str : "NULL");
      }
      str=strtok((char *)(void *)0, "(,)");
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "FTP Token: %s", str != ((char *)NULL) ? str : "NULL");
      if(str == ((char *)NULL))
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        return_value_sscanf$5=sscanf(str, "%d", &hi_byte);
        tmp_if_expr$6 = !(return_value_sscanf$5 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$6)
        g_free((void *)mesg);

      else
      {
        str=strtok((char *)(void *)0, "(,)");
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "FTP Token: %s", str != ((char *)NULL) ? str : "NULL");
        if(str == ((char *)NULL))
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value_sscanf$7=sscanf(str, "%d", &low_byte);
          tmp_if_expr$8 = !(return_value_sscanf$7 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
          g_free((void *)mesg);

        else
        {
          server_port = (unsigned short int)(hi_byte * (unsigned int)256 + low_byte);
          g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "FTP Hi: %d. Low: %d. Passive port is %d", hi_byte, low_byte, server_port);
          add_conversation(&dp->global_src_address, &dp->global_dst_address, server_port, (unsigned short int)0, "FTP-PASSIVE");
          g_free((void *)mesg);
        }
      }
    }

  }

}

// get_home_dir
// file util.h line 38
const char * get_home_dir(void)
{
  char *env_value;
  struct passwd *pwd;
  static const char *home = (const char *)(void *)0;
  if(!(home == ((const char *)NULL)))
    return home;

  else
  {
    env_value=getenv("HOME");
    if(!(env_value == ((char *)NULL)))
      home = env_value;

    else
    {
      unsigned int return_value_getuid$1;
      return_value_getuid$1=getuid();
      pwd=getpwuid(return_value_getuid$1);
      if(!(pwd == ((struct passwd *)NULL)))
        home=g_strdup(pwd->pw_dir);

      else
        home = "/tmp";
    }
    return home;
  }
}

// get_ieee802_5_type
// file decode_proto.c line 531
static void get_ieee802_5_type(struct anonymous$3 *dp)
{
  decode_proto_add(dp, "Token Ring");
  if(dp->cur_len >= 15u)
  {
    dp->dst_node_id.node_type = (enum anonymous$13)LINK6;
    do
      memmove((void *)dp->dst_node_id.addr.eth, (const void *)(dp->cur_packet + (signed long int)2), sizeof(unsigned char [6l]) /*6ul*/ );
    while((_Bool)0);
    dp->src_node_id.node_type = (enum anonymous$13)LINK6;
    do
      memmove((void *)dp->src_node_id.addr.eth, (const void *)(dp->cur_packet + (signed long int)8), sizeof(unsigned char [6l]) /*6ul*/ );
    while((_Bool)0);
    if(dp->cur_len >= 22u)
    {
      decode_proto_add(dp, "LLC");
      if((signed int)dp->cur_packet[20l] == 0x08)
      {
        if((signed int)dp->cur_packet[21l] == 0x00)
        {
          add_offset(dp, (unsigned int)22);
          get_ip(dp);
        }

      }

    }

  }

}

// get_ip
// file decode_proto.c line 952
static void get_ip(struct anonymous$3 *dp)
{
  unsigned short int fragment_offset;
  enum anonymous$18 ip_type;
  signed int ip_version;
  signed int ip_hl;
  unsigned short int tmp_statement_expression$1;
  if(dp->cur_len >= 20u)
  {
    ip_version = (signed int)dp->cur_packet[(signed long int)0] >> 4 & 15;
    switch(ip_version)
    {
      case 4:
      {
        ip_hl = ((signed int)dp->cur_packet[(signed long int)0] & 15) << 2;
        if(!(ip_hl >= 20))
          goto __CPROVER_DUMP_L49;

        decode_proto_add(dp, "IP");
        ip_type = (enum anonymous$18)dp->cur_packet[(signed long int)9];
        unsigned short int __v;
        unsigned short int __x = (unsigned short int)*((unsigned short int *)(dp->cur_packet + (signed long int)6));
        asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
        tmp_statement_expression$1 = __v;
        fragment_offset = tmp_statement_expression$1;
        fragment_offset = fragment_offset & (unsigned short int)0x0fff;
        if(!((signed int)appdata.mode == LINK6))
        {
          dp->dst_node_id.node_type = (enum anonymous$13)IP;
          memset((void *)&dp->dst_node_id.addr.ip, 0, sizeof(struct anonymous$20) /*20ul*/ );
          dp->dst_node_id.addr.ip.$anon0.$anon0.type = (unsigned int)2;
          do
            memmove((void *)dp->dst_node_id.addr.ip.$anon0.$anon0.$anon0.addr_v4, (const void *)(dp->cur_packet + (signed long int)16), sizeof(unsigned char [4l]) /*4ul*/ );
          while((_Bool)0);
          dp->src_node_id.node_type = (enum anonymous$13)IP;
          memset((void *)&dp->src_node_id.addr.ip, 0, sizeof(struct anonymous$20) /*20ul*/ );
          dp->src_node_id.addr.ip.$anon0.$anon0.type = (unsigned int)2;
          do
            memmove((void *)dp->src_node_id.addr.ip.$anon0.$anon0.$anon0.addr_v4, (const void *)(dp->cur_packet + (signed long int)12), sizeof(unsigned char [4l]) /*4ul*/ );
          while((_Bool)0);
        }

        add_offset(dp, (unsigned int)ip_hl);
        break;
      }
      case 6:
      {
        if(!(dp->cur_len >= 40u))
          goto __CPROVER_DUMP_L49;

        decode_proto_add(dp, "IPV6");
        ip_type = (enum anonymous$18)dp->cur_packet[(signed long int)6];
        fragment_offset = (unsigned short int)0;
        if(!((signed int)appdata.mode == LINK6))
        {
          dp->dst_node_id.node_type = (enum anonymous$13)IP;
          dp->dst_node_id.addr.ip.$anon0.$anon0.type = (unsigned int)10;
          do
            memmove((void *)dp->dst_node_id.addr.ip.$anon0.$anon0.$anon0.addr_v6, (const void *)(dp->cur_packet + (signed long int)24), sizeof(unsigned char [16l]) /*16ul*/ );
          while((_Bool)0);
          dp->src_node_id.node_type = (enum anonymous$13)IP;
          dp->src_node_id.addr.ip.$anon0.$anon0.type = (unsigned int)10;
          do
            memmove((void *)dp->src_node_id.addr.ip.$anon0.$anon0.$anon0.addr_v6, (const void *)(dp->cur_packet + (signed long int)8), sizeof(unsigned char [16l]) /*16ul*/ );
          while((_Bool)0);
        }

        add_offset(dp, (unsigned int)40);
        break;
      }
      default:
        goto __CPROVER_DUMP_L49;
    }
    memmove((void *)&dp->global_src_address, (const void *)&dp->src_node_id.addr.ip, sizeof(struct anonymous$20) /*20ul*/ );
    memmove((void *)&dp->global_dst_address, (const void *)&dp->dst_node_id.addr.ip, sizeof(struct anonymous$20) /*20ul*/ );
    switch((signed int)ip_type)
    {
      case IP_PROTO_ICMP:
      {
        decode_proto_add(dp, "ICMP");
        break;
      }
      case IP_PROTO_TCP:
      {
        if(!(fragment_offset == 0))
          decode_proto_add(dp, "TCP_FRAGMENT");

        else
          get_tcp(dp);
        break;
      }
      case IP_PROTO_UDP:
      {
        if(!(fragment_offset == 0))
          decode_proto_add(dp, "UDP_FRAGMENT");

        else
          get_udp(dp);
        break;
      }
      case IP_PROTO_IGMP:
      {
        decode_proto_add(dp, "IGMP");
        break;
      }
      case IP_PROTO_GGP:
      {
        decode_proto_add(dp, "GGP");
        break;
      }
      case IP_PROTO_IPIP:
      {
        decode_proto_add(dp, "IPIP");
        break;
      }
      case IP_PROTO_EGP:
      {
        decode_proto_add(dp, "EGP");
        break;
      }
      case IP_PROTO_PUP:
      {
        decode_proto_add(dp, "PUP");
        break;
      }
      case IP_PROTO_IDP:
      {
        decode_proto_add(dp, "IDP");
        break;
      }
      case IP_PROTO_TP:
      {
        decode_proto_add(dp, "TP");
        break;
      }
      case IP_PROTO_IPV6:
      {
        decode_proto_add(dp, "IPV6");
        break;
      }
      case IP_PROTO_ROUTING:
      {
        decode_proto_add(dp, "ROUTING");
        break;
      }
      case IP_PROTO_FRAGMENT:
      {
        decode_proto_add(dp, "FRAGMENT");
        break;
      }
      case IP_PROTO_RSVP:
      {
        decode_proto_add(dp, "RSVP");
        break;
      }
      case IP_PROTO_GRE:
      {
        decode_proto_add(dp, "GRE");
        break;
      }
      case IP_PROTO_ESP:
      {
        decode_proto_add(dp, "ESP");
        break;
      }
      case IP_PROTO_AH:
      {
        decode_proto_add(dp, "AH");
        break;
      }
      case IP_PROTO_ICMPV6:
      {
        decode_proto_add(dp, "ICPMPV6");
        break;
      }
      case IP_PROTO_NONE:
      {
        decode_proto_add(dp, "NONE");
        break;
      }
      case IP_PROTO_DSTOPTS:
      {
        decode_proto_add(dp, "DSTOPTS");
        break;
      }
      case IP_PROTO_VINES:
      {
        decode_proto_add(dp, "VINES");
        break;
      }
      case IP_PROTO_EIGRP:
      {
        decode_proto_add(dp, "EIGRP");
        break;
      }
      case IP_PROTO_OSPF:
      {
        decode_proto_add(dp, "OSPF");
        break;
      }
      case IP_PROTO_ENCAP:
      {
        decode_proto_add(dp, "ENCAP");
        break;
      }
      case IP_PROTO_PIM:
      {
        decode_proto_add(dp, "PIM");
        break;
      }
      case IP_PROTO_IPCOMP:
      {
        decode_proto_add(dp, "IPCOMP");
        break;
      }
      case IP_PROTO_VRRP:
      {
        decode_proto_add(dp, "VRRP");
        break;
      }
      default:
        decode_proto_add(dp, "IP_UNKNOWN");
    }
  }


__CPROVER_DUMP_L49:
  ;
}

// get_ip_name
// file names.c line 356
static signed int get_ip_name(struct anonymous$9 *nt)
{
  if((signed int)nt->dir == INBOUND)
    fill_node_id(&nt->node_id, (enum anonymous$13)IP, nt, 16, 0, 2);

  else
    fill_node_id(&nt->node_id, (enum anonymous$13)IP, nt, 12, 0, 2);
  const char *return_value_ipv4_to_str$1;
  const char *return_value_ipv4_to_str$2;
  const char *return_value_dns_lookup$3;
  if(pref.name_res == 0)
  {
    return_value_ipv4_to_str$1=ipv4_to_str(nt->node_id.addr.ip.$anon0.$anon0.$anon0.addr_v4);
    add_name(return_value_ipv4_to_str$1, (const char *)(void *)0, &nt->node_id, nt);
  }

  else
  {
    return_value_ipv4_to_str$2=ipv4_to_str(nt->node_id.addr.ip.$anon0.$anon0.$anon0.addr_v4);
    return_value_dns_lookup$3=dns_lookup(&nt->node_id.addr.ip);
    add_name(return_value_ipv4_to_str$2, return_value_dns_lookup$3, &nt->node_id, nt);
  }
  signed int tmp_if_expr$4;
  if(!((signed int)nt->offset >= (signed int)nt->packet_size))
    tmp_if_expr$4 = ((signed int)nt->p[(signed long int)nt->offset] & 15) << 2;

  else
    tmp_if_expr$4 = 0;
  nt->offset = nt->offset + (unsigned short int)tmp_if_expr$4;
  return (signed int)!(0 != 0);
}

// get_ipv6_name
// file names.c line 378
static signed int get_ipv6_name(struct anonymous$9 *nt)
{
  if((signed int)nt->dir == INBOUND)
    fill_node_id(&nt->node_id, (enum anonymous$13)IP, nt, 24, 0, 10);

  else
    fill_node_id(&nt->node_id, (enum anonymous$13)IP, nt, 8, 0, 10);
  const char *return_value_ipv6_to_str$1;
  const char *return_value_ipv6_to_str$2;
  const char *return_value_dns_lookup$3;
  if(pref.name_res == 0)
  {
    return_value_ipv6_to_str$1=ipv6_to_str(nt->node_id.addr.ip.$anon0.$anon0.$anon0.addr_v6);
    add_name(return_value_ipv6_to_str$1, (const char *)(void *)0, &nt->node_id, nt);
  }

  else
  {
    return_value_ipv6_to_str$2=ipv6_to_str(nt->node_id.addr.ip.$anon0.$anon0.$anon0.addr_v6);
    return_value_dns_lookup$3=dns_lookup(&nt->node_id.addr.ip);
    add_name(return_value_ipv6_to_str$2, return_value_dns_lookup$3, &nt->node_id, nt);
  }
  nt->offset = nt->offset + (unsigned short int)40;
  return (signed int)!(0 != 0);
}

// get_ipx
// file decode_proto.c line 1122
static void get_ipx(struct anonymous$3 *dp)
{
  enum anonymous$17 ipx_dsocket;
  enum anonymous$17 ipx_ssocket;
  unsigned short int ipx_length;
  enum anonymous$22 ipx_type;
  _Bool tmp_if_expr$1;
  if(!(dp->cur_len >= 30u))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*((unsigned short int *)dp->cur_packet) != 0xffff ? (_Bool)1 : (_Bool)0;
  unsigned short int tmp_statement_expression$2;
  unsigned short int tmp_statement_expression$3;
  unsigned short int tmp_statement_expression$4;
  if(!tmp_if_expr$1)
  {
    decode_proto_add(dp, "IPX");
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)*((unsigned short int *)(dp->cur_packet + (signed long int)16));
    asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression$2 = __v;
    ipx_dsocket = (enum anonymous$17)tmp_statement_expression$2;
    unsigned short int get_ipx$$1$$2$$__v;
    unsigned short int get_ipx$$1$$2$$__x = (unsigned short int)*((unsigned short int *)(dp->cur_packet + (signed long int)28));
    asm("rorw $8, %w0" : "=r"(get_ipx$$1$$2$$__v) : "0"(get_ipx$$1$$2$$__x) : "cc");
    tmp_statement_expression$3 = get_ipx$$1$$2$$__v;
    ipx_ssocket = (enum anonymous$17)tmp_statement_expression$3;
    ipx_type = (enum anonymous$22)*((unsigned char *)(dp->cur_packet + (signed long int)5));
    unsigned short int get_ipx$$1$$3$$__v;
    unsigned short int get_ipx$$1$$3$$__x = (unsigned short int)*((unsigned short int *)(dp->cur_packet + (signed long int)2));
    asm("rorw $8, %w0" : "=r"(get_ipx$$1$$3$$__v) : "0"(get_ipx$$1$$3$$__x) : "cc");
    tmp_statement_expression$4 = get_ipx$$1$$3$$__v;
    ipx_length = tmp_statement_expression$4;
    switch((signed int)ipx_type)
    {
      case IPX_PACKET_TYPE_PEP:

      case IPX_PACKET_TYPE_IPX:
        break;
      case IPX_PACKET_TYPE_RIP:
      {
        decode_proto_add(dp, "IPX-RIP");
        break;
      }
      case IPX_PACKET_TYPE_ECHO:
      {
        decode_proto_add(dp, "IPX-ECHO");
        break;
      }
      case IPX_PACKET_TYPE_ERROR:
      {
        decode_proto_add(dp, "IPX-ERROR");
        break;
      }
      case IPX_PACKET_TYPE_SPX:
      {
        decode_proto_add(dp, "IPX-SPX");
        break;
      }
      case IPX_PACKET_TYPE_NCP:
      {
        decode_proto_add(dp, "IPX-NCP");
        break;
      }
      case IPX_PACKET_TYPE_WANBCAST:
        decode_proto_add(dp, "IPX-NetBIOS");
    }
    if((signed int)ipx_type == IPX_PACKET_TYPE_IPX || (signed int)ipx_type == IPX_PACKET_TYPE_PEP || (signed int)ipx_type == IPX_PACKET_TYPE_WANBCAST)
    {
      if((signed int)ipx_dsocket == IPX_SOCKET_SAP || (signed int)ipx_ssocket == IPX_SOCKET_SAP)
        decode_proto_add(dp, "IPX-SAP");

      else
        if((signed int)ipx_dsocket == IPX_SOCKET_ATTACHMATE_GW || (signed int)ipx_ssocket == IPX_SOCKET_ATTACHMATE_GW)
          decode_proto_add(dp, "ATTACHMATE-GW");

        else
          if((signed int)ipx_dsocket == IPX_SOCKET_PING_NOVELL || (signed int)ipx_ssocket == IPX_SOCKET_PING_NOVELL)
            decode_proto_add(dp, "PING-NOVELL");

          else
            if((signed int)ipx_dsocket == IPX_SOCKET_NCP || (signed int)ipx_ssocket == IPX_SOCKET_NCP)
              decode_proto_add(dp, "IPX-NCP");

            else
              if((signed int)ipx_dsocket == IPX_SOCKET_IPXRIP || (signed int)ipx_ssocket == IPX_SOCKET_IPXRIP)
                decode_proto_add(dp, "IPX-RIP");

              else
                if((signed int)ipx_dsocket == IPX_SOCKET_NETBIOS || (signed int)ipx_ssocket == IPX_SOCKET_NETBIOS)
                  decode_proto_add(dp, "IPX-NetBIOS");

                else
                  if((signed int)ipx_dsocket == IPX_SOCKET_DIAGNOSTIC || (signed int)ipx_ssocket == IPX_SOCKET_DIAGNOSTIC)
                    decode_proto_add(dp, "IPX-DIAG");

                  else
                    if((signed int)ipx_dsocket == IPX_SOCKET_SERIALIZATION || (signed int)ipx_ssocket == IPX_SOCKET_SERIALIZATION)
                      decode_proto_add(dp, "IPX-SERIAL.");

                    else
                      if((signed int)ipx_dsocket == IPX_SOCKET_ADSM || (signed int)ipx_ssocket == IPX_SOCKET_ADSM)
                        decode_proto_add(dp, "IPX-ADSM");

                      else
                        if((signed int)ipx_dsocket == IPX_SOCKET_EIGRP || (signed int)ipx_ssocket == IPX_SOCKET_EIGRP)
                          decode_proto_add(dp, "EIGRP");

                        else
                          if((signed int)ipx_dsocket == IPX_SOCKET_WIDE_AREA_ROUTER || (signed int)ipx_ssocket == IPX_SOCKET_WIDE_AREA_ROUTER)
                            decode_proto_add(dp, "IPX W.A. ROUTER");

                          else
                            if((signed int)ipx_dsocket == IPX_SOCKET_TCP_TUNNEL || (signed int)ipx_ssocket == IPX_SOCKET_TCP_TUNNEL)
                              decode_proto_add(dp, "IPX-TCP-TUNNEL");

                            else
                              if((signed int)ipx_dsocket == IPX_SOCKET_UDP_TUNNEL || (signed int)ipx_ssocket == IPX_SOCKET_UDP_TUNNEL)
                                decode_proto_add(dp, "IPX-UDP-TUNNEL");

                              else
                                if((signed int)ipx_dsocket == IPX_SOCKET_NWLINK_SMB_SERVER || (signed int)ipx_dsocket == IPX_SOCKET_NWLINK_SMB_NAMEQUERY || (signed int)ipx_dsocket == IPX_SOCKET_NWLINK_SMB_REDIR || (signed int)ipx_dsocket == IPX_SOCKET_NWLINK_SMB_MAILSLOT || (signed int)ipx_dsocket == IPX_SOCKET_NWLINK_SMB_MESSENGER || (signed int)ipx_dsocket == IPX_SOCKET_NWLINK_SMB_BROWSE || (signed int)ipx_ssocket == IPX_SOCKET_NWLINK_SMB_SERVER || (signed int)ipx_ssocket == IPX_SOCKET_NWLINK_SMB_NAMEQUERY || (signed int)ipx_ssocket == IPX_SOCKET_NWLINK_SMB_REDIR || (signed int)ipx_ssocket == IPX_SOCKET_NWLINK_SMB_MAILSLOT || (signed int)ipx_ssocket == IPX_SOCKET_NWLINK_SMB_MESSENGER || (signed int)ipx_ssocket == IPX_SOCKET_NWLINK_SMB_BROWSE)
                                  decode_proto_add(dp, "IPX-SMB");

                                else
                                  if((signed int)ipx_dsocket == IPX_SOCKET_SNMP_AGENT || (signed int)ipx_dsocket == IPX_SOCKET_SNMP_SINK || (signed int)ipx_ssocket == IPX_SOCKET_SNMP_AGENT || (signed int)ipx_ssocket == IPX_SOCKET_SNMP_SINK)
                                    decode_proto_add(dp, "SNMP");

                                  else
                                    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Unknown IPX ports %d, %d", ipx_dsocket, ipx_ssocket);
    }

  }

}

// get_ipx_name
// file names.c line 399
static signed int get_ipx_name(struct anonymous$9 *nt)
{
  nt->offset = nt->offset + (unsigned short int)30;
  return (signed int)!(0 != 0);
}

// get_ipxsap_name
// file names.c line 470
static signed int get_ipxsap_name(struct anonymous$9 *nt)
{
  unsigned short int sap_type;
  unsigned short int curpos;
  char *name;
  unsigned short int tmp_statement_expression$1;
  if(2 + (signed int)nt->offset >= (signed int)nt->packet_size)
    return 0;

  else
  {
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)*((unsigned short int *)(nt->p + (signed long int)nt->offset));
    asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression$1 = __v;
    sap_type = tmp_statement_expression$1;
    if(!((signed int)sap_type == 0x0002))
      return 0;

    else
    {
      curpos = (unsigned short int)((signed int)nt->offset + 4);
      for( ; !((signed int)curpos >= (signed int)nt->packet_size); curpos = curpos + 1)
        if(*((char *)(nt->p + (signed long int)curpos)) == 0)
          break;

      if((signed int)curpos >= (signed int)nt->packet_size)
      {
        missing_data_msg(nt, "IPXSAP");
        return 0;
      }

      else
      {
        name = (char *)(nt->p + (signed long int)nt->offset + (signed long int)4);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Sap name %s found", name);
        add_name(name, name, &nt->node_id, nt);
        return 0;
      }
    }
  }
}

// get_link6_name
// file names.c line 292
static signed int get_link6_name(struct anonymous$9 *nt)
{
  signed int return_value_eth_name_common$1;
  return_value_eth_name_common$1=eth_name_common((enum anonymous$13)LINK6, nt);
  return return_value_eth_name_common$1;
}

// get_link_size
// file diagram.c line 1283
static double get_link_size(const struct anonymous$34 *link_stats)
{
  double result = 0.0;
  double data;
  switch((signed int)pref.node_size_variable)
  {
    case INST_TOTAL:

    case INST_INBOUND:

    case INST_OUTBOUND:

    case INST_PACKETS:
    {
      data = link_stats->average;
      break;
    }
    case ACCU_TOTAL:

    case ACCU_INBOUND:

    case ACCU_OUTBOUND:
    {
      data = link_stats->accumulated;
      break;
    }
    case ACCU_PACKETS:
    {
      data = (double)link_stats->accu_packets;
      break;
    }
    case ACCU_AVG_SIZE:
    {
      data = link_stats->avg_size;
      break;
    }
    default:
    {
      data = link_stats->average;
      char *return_value_dcgettext$1;
      return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Unknown value for link_size_variable", 5);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$1);
    }
  }
  switch((signed int)pref.size_mode)
  {
    case LINEAR:
    {
      result = data + (double)1;
      break;
    }
    case LOG:
    {
      result=log(data + (double)1);
      break;
    }
    case SQRT:
      result=sqrt(data + (double)1);
  }
  return 1.0 + pref.node_radius_multiplier * pref.link_node_ratio * result;
}

// get_linux_sll
// file decode_proto.c line 806
static void get_linux_sll(struct anonymous$3 *dp)
{
  enum anonymous$8 etype;
  decode_proto_add(dp, "LINUX-SLL");
  unsigned short int tmp_statement_expression$1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)*((unsigned short int *)&dp->cur_packet[(signed long int)14]);
  asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression$1 = __v;
  etype = (enum anonymous$8)tmp_statement_expression$1;
  add_offset(dp, (unsigned int)16);
  if((signed int)etype == ETHERTYPE_IP || (signed int)etype == ETHERTYPE_IPv6)
    get_ip(dp);

  else
    if((signed int)etype == ETHERTYPE_IPX)
      get_ipx(dp);

    else
      append_etype_prot(dp, etype);
}

// get_linux_sll_name
// file names.c line 257
static signed int get_linux_sll_name(struct anonymous$9 *nt)
{
  nt->offset = nt->offset + (unsigned short int)16;
  return (signed int)!(0 != 0);
}

// get_live_packet
// file capture.c line 491
static unsigned int get_live_packet(void)
{
  struct pcap_pkthdr *pkt_header = (struct pcap_pkthdr *)(void *)0;
  const unsigned char *pkt_data = (const unsigned char *)(void *)0;
  if(!((signed int)capture_status == PLAY) && !((signed int)capture_status == PAUSE))
    return (unsigned int)0;

  else
  {
    signed int return_value_pcap_next_ex$1;
    return_value_pcap_next_ex$1=pcap_next_ex(pch_struct, &pkt_header, &pkt_data);
    if(return_value_pcap_next_ex$1 == 1)
    {
      appdata.now.tv_sec = pkt_header->ts.tv_sec;
      appdata.now.tv_usec = pkt_header->ts.tv_usec;
      if(!(pkt_data == ((const unsigned char *)NULL)))
        packet_acquired((unsigned char *)pkt_data, pkt_header->caplen, pkt_header->len);

    }

    return (unsigned int)0;
  }
}

// get_llc
// file decode_proto.c line 824
static void get_llc(struct anonymous$3 *dp)
{
  enum anonymous$14 dsap;
  enum anonymous$14 ssap;
  unsigned short int control;
  unsigned short int tmp_statement_expression$1;
  if(dp->cur_len >= 4u)
  {
    dsap = (enum anonymous$14)dp->cur_packet[(signed long int)0];
    ssap = (enum anonymous$14)dp->cur_packet[(signed long int)1];
    if((signed int)dsap == SAP_SNAP && (signed int)ssap == SAP_SNAP)
    {
      enum anonymous$8 eth2_type;
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)*((unsigned short int *)(dp->cur_packet + (signed long int)6));
      asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression$1 = __v;
      eth2_type = (enum anonymous$8)tmp_statement_expression$1;
      add_offset(dp, (unsigned int)8);
      get_eth_II(dp, eth2_type);
      goto __CPROVER_DUMP_L33;
    }

    decode_proto_add(dp, "LLC");
    control = (unsigned short int)dp->cur_packet[(signed long int)2];
    if((0x1 & (signed int)control) == 0x00 || (signed int)control == 3)
    {
      add_offset(dp, (unsigned int)3);
      switch((signed int)dsap)
      {
        case SAP_NULL:
        {
          decode_proto_add(dp, "LLC-NULL");
          break;
        }
        case SAP_LLC_SLMGMT:
        {
          decode_proto_add(dp, "LLC-SLMGMT");
          break;
        }
        case SAP_SNA_PATHCTRL:
        {
          decode_proto_add(dp, "PATHCTRL");
          break;
        }
        case SAP_IP:
        {
          get_ip(dp);
          break;
        }
        case SAP_SNA1:
        {
          decode_proto_add(dp, "SNA1");
          break;
        }
        case SAP_SNA2:
        {
          decode_proto_add(dp, "SNA2");
          break;
        }
        case SAP_PROWAY_NM_INIT:
        {
          decode_proto_add(dp, "PROWAY-NM-INIT");
          break;
        }
        case SAP_TI:
        {
          decode_proto_add(dp, "TI");
          break;
        }
        case SAP_BPDU:
        {
          decode_proto_add(dp, "BPDU");
          break;
        }
        case SAP_RS511:
        {
          decode_proto_add(dp, "RS511");
          break;
        }
        case SAP_X25:
        {
          decode_proto_add(dp, "X25");
          break;
        }
        case SAP_XNS:
        {
          decode_proto_add(dp, "XNS");
          break;
        }
        case SAP_NESTAR:
        {
          decode_proto_add(dp, "NESTAR");
          break;
        }
        case SAP_PROWAY_ASLM:
        {
          decode_proto_add(dp, "PROWAY-ASLM");
          break;
        }
        case SAP_ARP:
        {
          decode_proto_add(dp, "ARP");
          break;
        }
        case SAP_SNAP:
        {
          g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, "Reached SNAP while checking for DSAP in get_llc");
          decode_proto_add(dp, "LLC-SNAP");
          break;
        }
        case SAP_VINES1:
        {
          decode_proto_add(dp, "VINES1");
          break;
        }
        case SAP_VINES2:
        {
          decode_proto_add(dp, "VINES2");
          break;
        }
        case SAP_NETWARE:
        {
          get_ipx(dp);
          break;
        }
        case SAP_NETBIOS:
        {
          decode_proto_add(dp, "NETBIOS");
          get_netbios(dp);
          break;
        }
        case SAP_IBMNM:
        {
          decode_proto_add(dp, "IBMNM");
          break;
        }
        case SAP_RPL1:
        {
          decode_proto_add(dp, "RPL1");
          break;
        }
        case SAP_UB:
        {
          decode_proto_add(dp, "UB");
          break;
        }
        case SAP_RPL2:
        {
          decode_proto_add(dp, "RPL2");
          break;
        }
        case SAP_OSINL:
        {
          decode_proto_add(dp, "OSINL");
          break;
        }
        case SAP_GLOBAL:
          decode_proto_add(dp, "LLC-GLOBAL");
      }
    }

  }


__CPROVER_DUMP_L33:
  ;
}

// get_llc_name
// file names.c line 298
static signed int get_llc_name(struct anonymous$9 *nt)
{
  _Bool tmp_if_expr$1;
  if(nt->link_type == 10)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = nt->link_type == 6 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    nt->offset = nt->offset + (unsigned short int)8;

  else
    if(nt->link_type == 1)
      nt->offset = nt->offset + (unsigned short int)3;

    else
      return 0;
  return (signed int)!(0 != 0);
}

// get_loop
// file decode_proto.c line 381
static void get_loop(struct anonymous$3 *dp)
{
  if(lkentry->dlt_linktype == 108u)
    decode_proto_add(dp, "LOOP");

  else
    decode_proto_add(dp, "NULL");
  add_offset(dp, (unsigned int)4);
  get_ip(dp);
}

// get_nbdgm_name
// file names.c line 571
static signed int get_nbdgm_name(struct anonymous$9 *nt)
{
  unsigned char mesg_type;
  char *numeric_name = (char *)(void *)0;
  char name[1085l];
  signed int name_found = 0;
  signed int name_type;
  signed int len;
  unsigned int i = (unsigned int)0;
  _Bool tmp_if_expr$1;
  signed int tmp_statement_expression$3;
  if(!((signed int)nt->packet_size >= 1 + (signed int)nt->offset))
    return 0;

  else
  {
    mesg_type = *((unsigned char *)(nt->p + (signed long int)nt->offset));
    nt->offset = nt->offset + (unsigned short int)10;
    if((signed int)mesg_type == 0x10 || (signed int)mesg_type == 0x11 || (signed int)mesg_type == 0x12)
    {
      nt->offset = nt->offset + (unsigned short int)4;
      len=ethereal_nbns_name((const char *)nt->p, (signed int)nt->offset, (signed int)nt->packet_size, name, sizeof(char [1085l]) /*1085ul*/ , &name_type);
      if((signed int)nt->dir == INBOUND)
        ethereal_nbns_name((const char *)nt->p, (signed int)nt->offset + len, (signed int)nt->packet_size, name, sizeof(char [1085l]) /*1085ul*/ , &name_type);

      name_found = (signed int)!(0 != 0);
    }

    else
      if((signed int)mesg_type == 0x14 || (signed int)mesg_type == 0x15 || (signed int)mesg_type == 0x16)
      {
        if((signed int)nt->dir == INBOUND)
        {
          len=ethereal_nbns_name((const char *)nt->p, (signed int)nt->offset, (signed int)nt->packet_size, name, sizeof(char [1085l]) /*1085ul*/ , &name_type);
          name_found = (signed int)!(0 != 0);
        }

      }

    do
    {
      if(!(i >= 15u))
        tmp_if_expr$1 = (signed int)name[(signed long int)i] != 32 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      i = i + 1u;
    }
    while((_Bool)1);
    name[(signed long int)i] = (char)0;
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$4;
    return_value___builtin_strcmp$4=__builtin_strcmp(name, "Illegal");
    tmp_statement_expression$3 = return_value___builtin_strcmp$4;
    if(!(tmp_statement_expression$3 == 0))
    {
      if(!(name_found == 0))
      {
        char *return_value_get_netbios_host_type$2;
        return_value_get_netbios_host_type$2=get_netbios_host_type(name_type);
        numeric_name=g_strdup_printf("%s %s (%s)", (const void *)name, (name + (signed long int)16) - (signed long int)1, return_value_get_netbios_host_type$2);
        add_name(numeric_name, name, &nt->node_id, nt);
        g_free((void *)numeric_name);
      }

    }

    return 0;
  }
}

// get_nbss_name
// file names.c line 505
static signed int get_nbss_name(struct anonymous$9 *nt)
{
  unsigned char mesg_type;
  unsigned short int tmp_statement_expression$1;
  _Bool tmp_if_expr$3;
  signed int tmp_statement_expression$5;
  if(!((signed int)nt->packet_size >= 1 + (signed int)nt->offset))
    return 0;

  else
  {
    mesg_type = *((unsigned char *)(nt->p + (signed long int)nt->offset));
    nt->offset = nt->offset + (unsigned short int)2;
    if((signed int)mesg_type == 0x81)
    {
      unsigned int i = (unsigned int)0;
      unsigned short int length;
      char *numeric_name = (char *)(void *)0;
      char name[1085l];
      unsigned int name_len;
      signed int name_type;
      if(2 + (signed int)nt->offset >= (signed int)nt->packet_size)
      {
        missing_data_msg(nt, "NBSS");
        return 0;
      }

      unsigned short int __v;
      unsigned short int __x = (unsigned short int)*((unsigned short int *)(nt->p + (signed long int)nt->offset + (signed long int)2));
      asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression$1 = __v;
      length = tmp_statement_expression$1;
      nt->offset = nt->offset + (unsigned short int)2;
      if((signed int)nt->offset + (signed int)length >= (signed int)nt->packet_size)
      {
        missing_data_msg(nt, "NBSS");
        return 0;
      }

      signed int return_value_ethereal_nbns_name$2;
      return_value_ethereal_nbns_name$2=ethereal_nbns_name((const char *)nt->p, (signed int)nt->offset, (signed int)nt->packet_size, name, sizeof(char [1085l]) /*1085ul*/ , &name_type);
      name_len = (unsigned int)return_value_ethereal_nbns_name$2;
      if((signed int)nt->dir == OUTBOUND)
        ethereal_nbns_name((const char *)nt->p, (signed int)((unsigned int)nt->offset + name_len), (signed int)nt->packet_size, name, sizeof(char [1085l]) /*1085ul*/ , &name_type);

      do
      {
        if(!(i >= 15u))
          tmp_if_expr$3 = (signed int)name[(signed long int)i] != 32 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(!tmp_if_expr$3)
          break;

        i = i + 1u;
      }
      while((_Bool)1);
      name[(signed long int)i] = (char)0;
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp$6;
      return_value___builtin_strcmp$6=__builtin_strcmp(name, "Illegal");
      tmp_statement_expression$5 = return_value___builtin_strcmp$6;
      if(!(tmp_statement_expression$5 == 0))
      {
        char *return_value_get_netbios_host_type$4;
        return_value_get_netbios_host_type$4=get_netbios_host_type(name_type);
        numeric_name=g_strdup_printf("%s %s (%s)", (const void *)name, (name + (signed long int)16) - (signed long int)1, return_value_get_netbios_host_type$4);
        add_name(numeric_name, name, &nt->node_id, nt);
        g_free((void *)numeric_name);
      }

      nt->offset = nt->offset + length;
    }

    return (signed int)!(0 != 0);
  }
}

// get_netbios
// file decode_proto.c line 1511
static void get_netbios(struct anonymous$3 *dp)
{
  unsigned short int hdr_len;
  if(dp->cur_len >= 5u)
  {
    hdr_len = (unsigned short int)((signed int)(unsigned short int)((unsigned char *)dp->cur_packet)[(signed long int)1] << 8 | (signed int)(unsigned short int)((unsigned char *)dp->cur_packet)[(signed long int)0] << 0);
    if(!((unsigned int)hdr_len >= dp->cur_len))
      decode_proto_add(dp, "SMB");

  }

}

// get_netbios_dgm
// file decode_proto.c line 1551
static void get_netbios_dgm(struct anonymous$3 *dp)
{
  unsigned char mesg_type;
  decode_proto_add(dp, "NETBIOS-DGM");
  mesg_type = dp->cur_packet[(signed long int)0];
  if((signed int)mesg_type == 0x10 || (signed int)mesg_type == 0x11 || (signed int)mesg_type == 0x12)
    decode_proto_add(dp, "SMB");

}

// get_netbios_host_type
// file names_netbios.h line 46
char * get_netbios_host_type(signed int type)
{
  unsigned int i = (unsigned int)0;
  for( ; (_Bool)1; i = i + 1u)
  {
    if(name_type_vals[(signed long int)i].number == 0)
    {
      if(name_type_vals[(signed long int)i].name == ((char *)NULL))
        goto __CPROVER_DUMP_L4;

    }

    if(name_type_vals[(signed long int)i].number == type)
      return name_type_vals[(signed long int)i].name;

  }

__CPROVER_DUMP_L4:
  ;
  return "Unknown";
}

// get_netbios_ssn
// file decode_proto.c line 1534
static void get_netbios_ssn(struct anonymous$3 *dp)
{
  unsigned char mesg_type;
  decode_proto_add(dp, "NETBIOS-SSN");
  mesg_type = dp->cur_packet[(signed long int)0];
  if((signed int)mesg_type == 0)
    decode_proto_add(dp, "SMB");

}

// get_node_size
// file diagram.c line 1264
static double get_node_size(double average)
{
  double result = 0.0;
  switch((signed int)pref.size_mode)
  {
    case LINEAR:
    {
      result = average + (double)1;
      break;
    }
    case LOG:
    {
      result=log(average + (double)1);
      break;
    }
    case SQRT:
      result=sqrt(average + (double)1);
  }
  return 5.0 + pref.node_radius_multiplier * result;
}

// get_null_name
// file names.c line 247
static signed int get_null_name(struct anonymous$9 *nt)
{
  nt->offset = nt->offset + (unsigned short int)4;
  return (signed int)!(0 != 0);
}

// get_offline_packet
// file capture.c line 398
static unsigned int get_offline_packet(void)
{
  double diffms;
  signed int result;
  static struct timeval last_read_time = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
  static const unsigned char *pkt_data = (const unsigned char *)(void *)0;
  static struct pcap_pkthdr *pkt_header = (struct pcap_pkthdr *)(void *)0;
  if((signed int)capture_status == STOP)
  {
    pkt_header = (struct pcap_pkthdr *)(void *)0;
    pkt_data = (const unsigned char *)(void *)0;
    last_read_time.tv_sec = (signed long int)0;
    last_read_time.tv_usec = last_read_time.tv_sec;
    return (unsigned int)0;
  }

  else
  {
    if(!(pkt_data == ((const unsigned char *)NULL)))
    {
      gettimeofday(&appdata.now, (struct timezone *)(void *)0);
      packet_acquired((unsigned char *)pkt_data, pkt_header->caplen, pkt_header->len);
    }

    result=pcap_next_ex(pch_struct, &pkt_header, &pkt_data);
    if(!(result == 1))
    {
      if(result == -2)
        goto __CPROVER_DUMP_L9;

    }

    else
    {
      if(last_read_time.tv_sec == 0l && last_read_time.tv_usec == 0l)
      {
        last_read_time.tv_sec = pkt_header->ts.tv_sec;
        last_read_time.tv_usec = pkt_header->ts.tv_usec;
      }

      static struct timeval this_time;
      this_time.tv_sec = pkt_header->ts.tv_sec;
      this_time.tv_usec = pkt_header->ts.tv_usec;
      diffms=substract_times_ms(&this_time, &last_read_time);
      if(diffms < 0.000000)
        ms_to_next = (unsigned long int)0;

      else
        ms_to_next = (unsigned long int)diffms;
      if(!(ms_to_next >= appdata.min_delay))
        ms_to_next = appdata.min_delay;

      else
        if(!(appdata.max_delay >= ms_to_next))
          ms_to_next = appdata.max_delay;

      last_read_time = this_time;
      goto __CPROVER_DUMP_L12;

    __CPROVER_DUMP_L9:
      ;
      capture_status = (enum status_t)CAP_EOF;
      if(!(appdata.export_file_final == ((char *)NULL)))
        dump_xml(appdata.export_file_final);

      goto __CPROVER_DUMP_L12;
    }
    ms_to_next = (unsigned long int)0;

  __CPROVER_DUMP_L12:
    ;
    return (unsigned int)0;
  }
}

// get_packet_names
// file names.c line 123
void get_packet_names(struct anonymous$25 *pstk, const unsigned char *packet, unsigned short int size, const struct anonymous$2 *prot_stack, enum anonymous$7 direction, signed int link_type)
{
  struct anonymous$9 nt;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(pstk == ((struct anonymous$25 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "names.c", 132, (const char *)"get_packet_names", "pstk != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int get_packet_names$$1$$2$$1$$_g_boolean_var_;
    if(!(packet == ((const unsigned char *)NULL)))
      get_packet_names$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      get_packet_names$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = get_packet_names$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "names.c", 133, (const char *)"get_packet_names", "packet != NULL");

  }
  while((_Bool)0);
  nt.p = packet;
  nt.packet_size = size;
  nt.dir = direction;
  nt.offset = (unsigned short int)0;
  nt.link_type = link_type;
  nt.decoder.level = (unsigned char)1;
  nt.decoder.tokens = prot_stack;
  nt.decoder.protos = pstk;
  decode_next(&nt);
}

// get_packet_prot
// file decode_proto.c line 358
static void get_packet_prot(struct anonymous$3 *dp)
{
  unsigned int i;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    signed int _g_boolean_var_;
    if(!(lkentry == ((const struct linktype_data_tag *)NULL)))
      tmp_if_expr$2 = lkentry->fun != ((void (*)(struct anonymous$3 *))NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "decode_proto.c", 362, (const char *)"get_packet_prot", "lkentry && lkentry->fun");

  }
  while((_Bool)0);
  lkentry->fun(dp);
  i = (unsigned int)5;
  if(i >= 1u)
  {
    if(!(dp->pr->protonames[(signed long int)i] == ((char *)NULL)))
      dp->pr->protonames[(signed long int)0]=g_strdup(dp->pr->protonames[(signed long int)i]);

    else
      i = i - 1u;
  }

}

// get_ppi
// file decode_proto.c line 599
static void get_ppi(struct anonymous$3 *dp)
{
  unsigned short int pph_len;
  unsigned int pph_dlt;
  signed int i;
  if(!(dp->cur_len >= 64u))
  {
    char *return_value_dcgettext$1;
    return_value_dcgettext$1=dcgettext((const char *)(void *)0, "PPI:captured size too small, packet discarded", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$1);
    decode_proto_add(dp, "PPI");
    goto __CPROVER_DUMP_L8;
  }

  pph_len = *((unsigned short int *)(dp->cur_packet + (signed long int)2));
  pph_dlt = *((unsigned int *)(dp->cur_packet + (signed long int)4));
  add_offset(dp, (unsigned int)pph_len);
  _Bool tmp_if_expr$3;
  static const struct linktype_data_tag *pph_lkentry = (const struct linktype_data_tag *)(void *)0;
  if(pph_lkentry == ((const struct linktype_data_tag *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = pph_lkentry->dlt_linktype != pph_dlt ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
  {
    pph_lkentry = (const struct linktype_data_tag *)(void *)0;
    i = 0;
    for( ; !(linktypes[(signed long int)i].lt_desc == ((const char *)NULL)); i = i + 1)
      if(linktypes[(signed long int)i].dlt_linktype == pph_dlt)
      {
        pph_lkentry = linktypes + (signed long int)i;
        pph_lkentry->fun(dp);
      }

    char *return_value_dcgettext$2;
    return_value_dcgettext$2=dcgettext((const char *)(void *)0, "PPI:unsupported link type %u, packet discarded", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$2, pph_dlt);
    goto __CPROVER_DUMP_L8;
  }

  pph_lkentry->fun(dp);

__CPROVER_DUMP_L8:
  ;
}

// get_radiotap
// file decode_proto.c line 573
static void get_radiotap(struct anonymous$3 *dp)
{
  unsigned short int rtlen;
  if(!(dp->cur_len >= 32u))
  {
    char *return_value_dcgettext$1;
    return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Radiotap:captured size too small, packet discarded", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$1);
    decode_proto_add(dp, "RADIOTAP");
    goto __CPROVER_DUMP_L2;
  }

  rtlen = *((unsigned short int *)(dp->cur_packet + (signed long int)2));
  add_offset(dp, (unsigned int)rtlen);
  get_wlan(dp);

__CPROVER_DUMP_L2:
  ;
}

// get_rpc
// file decode_proto.c line 1404
static signed int get_rpc(struct anonymous$3 *dp, signed int is_udp)
{
  signed int rpcstart;
  unsigned int rpcver;
  enum rpc_type msg_type;
  enum rpc_program msg_program;
  const char *rpc_prot = (const char *)(void *)0;
  unsigned int return_value___bswap_32$2;
  signed int tmp_statement_expression$3;
  const char *return_value_find_conversation$4;
  if(!(dp->cur_len >= 24u))
    return 0;

  else
  {
    if(!(is_udp == 0))
      rpcstart = 0;

    else
      rpcstart = 4;
    unsigned int return_value___bswap_32$1;
    return_value___bswap_32$1=__bswap_32(*((unsigned int *)(dp->cur_packet + (signed long int)rpcstart + (signed long int)4)));
    msg_type = (enum rpc_type)return_value___bswap_32$1;
    switch((signed int)msg_type)
    {
      case RPC_REPLY:
      {
        rpc_prot=find_conversation(&dp->global_dst_address, &dp->global_dst_address, dp->global_dst_port, (unsigned short int)0);
        if(rpc_prot == ((const char *)NULL))
          return 0;

        decode_proto_add(dp, "ONC-RPC");
        decode_proto_add(dp, rpc_prot);
        return (signed int)!(0 != 0);
      }
      case RPC_CALL:
      {
        rpcver=__bswap_32(*((unsigned int *)(dp->cur_packet + (signed long int)rpcstart + (signed long int)8)));
        if(!(rpcver == 2u))
          return 0;

        return_value___bswap_32$2=__bswap_32(*((unsigned int *)(dp->cur_packet + (signed long int)rpcstart + (signed long int)12)));
        msg_program = (enum rpc_program)return_value___bswap_32$2;
        switch((signed int)msg_program)
        {
          case BOOTPARAMS_PROGRAM:
          {
            rpc_prot = "BOOTPARAMS";
            break;
          }
          case MOUNT_PROGRAM:
          {
            rpc_prot = "MOUNT";
            break;
          }
          case NLM_PROGRAM:
          {
            rpc_prot = "NLM";
            break;
          }
          case PORTMAP_PROGRAM:
          {
            rpc_prot = "PORTMAP";
            break;
          }
          case STAT_PROGRAM:
          {
            rpc_prot = "STAT";
            break;
          }
          case NFS_PROGRAM:
          {
            rpc_prot = "NFS";
            break;
          }
          case YPBIND_PROGRAM:
          {
            rpc_prot = "YPBIND";
            break;
          }
          case YPSERV_PROGRAM:
          {
            rpc_prot = "YPSERV";
            break;
          }
          case YPXFR_PROGRAM:
          {
            rpc_prot = "YPXFR";
            break;
          }
          case YPPASSWD_PROGRAM:
          {
            rpc_prot = "YPPASSWD";
            break;
          }
          case REXEC_PROGRAM:
          {
            rpc_prot = "REXEC";
            break;
          }
          case KERBPROG_PROGRAM:
          {
            rpc_prot = "KERBPROG";
            break;
          }
          default:
            if((signed int)msg_program >= 100000 && !((signed int)msg_program >= 102000))
              rpc_prot = "RPC-UNKNOWN";

            else
              return 0;
        }
        do
        {
          signed int _g_boolean_var_;
          if(!(rpc_prot == ((const char *)NULL)))
            _g_boolean_var_ = 1;

          else
            _g_boolean_var_ = 0;
          tmp_statement_expression$3 = _g_boolean_var_;
          if((signed long int)tmp_statement_expression$3 == 0l)
            g_assertion_message_expr((char *)0, "decode_proto.c", 1492, (const char *)"get_rpc", "rpc_prot");

        }
        while((_Bool)0);
        return_value_find_conversation$4=find_conversation(&dp->global_src_address, &dp->global_src_address, dp->global_src_port, (unsigned short int)0);
        if(return_value_find_conversation$4 == ((const char *)NULL))
          add_conversation(&dp->global_src_address, &dp->global_src_address, dp->global_src_port, (unsigned short int)0, rpc_prot);

        decode_proto_add(dp, "ONC-RPC");
        decode_proto_add(dp, rpc_prot);
        return (signed int)!(0 != 0);
      }
      default:
        return 0;
    }
    return 0;
  }
}

// get_tcp
// file decode_proto.c line 1230
static void get_tcp(struct anonymous$3 *dp)
{
  const struct anonymous$21 *src_service;
  const struct anonymous$21 *dst_service;
  const struct anonymous$21 *chosen_service;
  unsigned short int src_port;
  unsigned short int dst_port;
  unsigned short int chosen_port;
  unsigned char th_off_x2;
  unsigned char tcp_len;
  const char *str;
  signed int src_pref = 0;
  signed int dst_pref = 0;
  decode_proto_add(dp, "TCP");
  unsigned short int tmp_statement_expression$1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)*((unsigned short int *)dp->cur_packet);
  asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression$1 = __v;
  src_port = tmp_statement_expression$1;
  dp->global_src_port = src_port;
  unsigned short int tmp_statement_expression$2;
  unsigned short int get_tcp$$1$$2$$__v;
  unsigned short int get_tcp$$1$$2$$__x = (unsigned short int)*((unsigned short int *)(dp->cur_packet + (signed long int)2));
  asm("rorw $8, %w0" : "=r"(get_tcp$$1$$2$$__v) : "0"(get_tcp$$1$$2$$__x) : "cc");
  tmp_statement_expression$2 = get_tcp$$1$$2$$__v;
  dst_port = tmp_statement_expression$2;
  dp->global_dst_port = dst_port;
  signed int tmp_statement_expression$3;
  signed int tmp_statement_expression$4;
  if((signed int)appdata.mode == TCP)
  {
    do
    {
      signed int _g_boolean_var_;
      if((signed int)dp->dst_node_id.node_type == IP)
        _g_boolean_var_ = 1;

      else
        _g_boolean_var_ = 0;
      tmp_statement_expression$3 = _g_boolean_var_;
      if((signed long int)tmp_statement_expression$3 == 0l)
        g_assertion_message_expr((char *)0, "decode_proto.c", 1248, (const char *)"get_tcp", "dp->dst_node_id.node_type == IP");

    }
    while((_Bool)0);
    dp->dst_node_id.node_type = (enum anonymous$13)TCP;
    memmove((void *)&dp->dst_node_id.addr.tcp4.host, (const void *)&dp->global_dst_address, sizeof(struct anonymous$20) /*20ul*/ );
    dp->dst_node_id.addr.tcp4.port = dp->global_dst_port;
    do
    {
      signed int get_tcp$$1$$3$$2$$1$$_g_boolean_var_;
      if((signed int)dp->src_node_id.node_type == IP)
        get_tcp$$1$$3$$2$$1$$_g_boolean_var_ = 1;

      else
        get_tcp$$1$$3$$2$$1$$_g_boolean_var_ = 0;
      tmp_statement_expression$4 = get_tcp$$1$$3$$2$$1$$_g_boolean_var_;
      if((signed long int)tmp_statement_expression$4 == 0l)
        g_assertion_message_expr((char *)0, "decode_proto.c", 1253, (const char *)"get_tcp", "dp->src_node_id.node_type == IP");

    }
    while((_Bool)0);
    dp->src_node_id.node_type = (enum anonymous$13)TCP;
    memmove((void *)&dp->src_node_id.addr.tcp4.host, (const void *)&dp->global_src_address, sizeof(struct anonymous$20) /*20ul*/ );
    dp->src_node_id.addr.tcp4.port = dp->global_src_port;
  }

  th_off_x2 = *((unsigned char *)(dp->cur_packet + (signed long int)12));
  tcp_len = (unsigned char)((((signed int)th_off_x2 & 0xf0) >> 4) * 4);
  add_offset(dp, (unsigned int)tcp_len);
  str=find_conversation(&dp->global_src_address, &dp->global_dst_address, src_port, dst_port);
  if(!(str == ((const char *)NULL)))
    decode_proto_add(dp, str);

  else
  {
    signed int return_value_get_rpc$5;
    return_value_get_rpc$5=get_rpc(dp, 0);
    if(return_value_get_rpc$5 == 0)
    {
      if((signed int)dst_port == 139 || (signed int)src_port == 139)
      {
        get_netbios_ssn(dp);
        goto __CPROVER_DUMP_L30;
      }

      else
        if((signed int)dst_port == 21 || (signed int)src_port == 21)
        {
          get_ftp(dp);
          goto __CPROVER_DUMP_L30;
        }

      src_service=services_tcp_find(src_port);
      dst_service=services_tcp_find(dst_port);
      chosen_port=choose_port(src_port, dst_port);
      if(dst_service == ((const struct anonymous$21 *)NULL) && src_service == ((const struct anonymous$21 *)NULL))
      {
        if(!(pref.group_unk == 0))
          decode_proto_add(dp, "TCP-UNKNOwN");

        else
          if(chosen_port == src_port)
            decode_proto_add(dp, "TCP:%d-%d", chosen_port, dst_port);

          else
            decode_proto_add(dp, "TCP:%d-%d", chosen_port, src_port);
      }

      else
      {
        if(!(src_service == ((const struct anonymous$21 *)NULL)))
          src_pref = src_service->preferred;

        if(!(dst_service == ((const struct anonymous$21 *)NULL)))
          dst_pref = dst_service->preferred;

        if(dst_pref == 0 && !(src_pref == 0))
          chosen_service = src_service;

        else
          if(src_pref == 0 && !(dst_pref == 0))
            chosen_service = dst_service;

          else
            if(dst_service == ((const struct anonymous$21 *)NULL) || src_port == chosen_port && !(src_service == ((const struct anonymous$21 *)NULL)))
              chosen_service = src_service;

            else
              chosen_service = dst_service;
        decode_proto_add(dp, "%s", chosen_service->name);
      }
    }

  }

__CPROVER_DUMP_L30:
  ;
}

// get_tcp_name
// file names.c line 405
static signed int get_tcp_name(struct anonymous$9 *nt)
{
  unsigned char th_off_x2;
  unsigned char tcp_len;
  if((signed int)appdata.mode == TCP)
  {
    char *numeric_name;
    char *resolved_name;
    signed int type = (signed int)nt->node_id.addr.tcp4.host.$anon0.$anon0.type;
    signed int shift = type == 10 ? 2 : 0;
    if((signed int)nt->dir == OUTBOUND)
      fill_node_id(&nt->node_id, (enum anonymous$13)TCP, nt, -8 << shift, 0, type);

    else
      fill_node_id(&nt->node_id, (enum anonymous$13)TCP, nt, -4 << shift, 2, type);
    const char *return_value_address_to_str$1;
    return_value_address_to_str$1=address_to_str(&nt->node_id.addr.tcp4.host);
    numeric_name=g_strdup_printf("%s:%d", return_value_address_to_str$1, nt->node_id.addr.tcp4.port);
    if(!(pref.name_res == 0))
    {
      const char *dnsname;
      const struct anonymous$21 *port;
      dnsname=dns_lookup(&nt->node_id.addr.tcp4.host);
      port=services_tcp_find(nt->node_id.addr.tcp4.port);
      if(!(port == ((const struct anonymous$21 *)NULL)))
        resolved_name=g_strdup_printf("%s:%s", dnsname, port->name);

      else
        resolved_name=g_strdup_printf("%s:%d", dnsname, nt->node_id.addr.tcp4.port);
    }

    else
      resolved_name = (char *)(void *)0;
    add_name(numeric_name, resolved_name, &nt->node_id, nt);
    g_free((void *)numeric_name);
    g_free((void *)resolved_name);
  }

  if(14 + (signed int)nt->offset >= (signed int)nt->packet_size)
  {
    missing_data_msg(nt, "TCP");
    return 0;
  }

  else
  {
    th_off_x2 = *((unsigned char *)(nt->p + (signed long int)nt->offset + (signed long int)12));
    tcp_len = (unsigned char)((((signed int)th_off_x2 & 0xf0) >> 4) * 4);
    nt->offset = nt->offset + (unsigned short int)tcp_len;
    return (signed int)!(0 != 0);
  }
}

// get_udp
// file decode_proto.c line 1327
static void get_udp(struct anonymous$3 *dp)
{
  const struct anonymous$21 *src_service;
  const struct anonymous$21 *dst_service;
  const struct anonymous$21 *chosen_service;
  unsigned short int src_port;
  unsigned short int dst_port;
  unsigned short int chosen_port;
  signed int src_pref = 0;
  signed int dst_pref = 0;
  decode_proto_add(dp, "UDP");
  unsigned short int tmp_statement_expression$1;
  unsigned short int __v;
  unsigned short int __x = (unsigned short int)*((unsigned short int *)dp->cur_packet);
  asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
  tmp_statement_expression$1 = __v;
  src_port = tmp_statement_expression$1;
  dp->global_src_port = src_port;
  unsigned short int tmp_statement_expression$2;
  unsigned short int get_udp$$1$$2$$__v;
  unsigned short int get_udp$$1$$2$$__x = (unsigned short int)*((unsigned short int *)(dp->cur_packet + (signed long int)2));
  asm("rorw $8, %w0" : "=r"(get_udp$$1$$2$$__v) : "0"(get_udp$$1$$2$$__x) : "cc");
  tmp_statement_expression$2 = get_udp$$1$$2$$__v;
  dst_port = tmp_statement_expression$2;
  dp->global_dst_port = dst_port;
  signed int tmp_statement_expression$3;
  signed int tmp_statement_expression$4;
  if((signed int)appdata.mode == TCP)
  {
    do
    {
      signed int get_udp$$1$$3$$1$$1$$_g_boolean_var_;
      if((signed int)dp->dst_node_id.node_type == IP)
        get_udp$$1$$3$$1$$1$$_g_boolean_var_ = 1;

      else
        get_udp$$1$$3$$1$$1$$_g_boolean_var_ = 0;
      tmp_statement_expression$3 = get_udp$$1$$3$$1$$1$$_g_boolean_var_;
      if((signed long int)tmp_statement_expression$3 == 0l)
        g_assertion_message_expr((char *)0, "decode_proto.c", 1342, (const char *)"get_udp", "dp->dst_node_id.node_type == IP");

    }
    while((_Bool)0);
    dp->dst_node_id.node_type = (enum anonymous$13)TCP;
    memmove((void *)&dp->dst_node_id.addr.tcp4.host, (const void *)&dp->global_dst_address, sizeof(struct anonymous$20) /*20ul*/ );
    dp->dst_node_id.addr.tcp4.port = dp->global_dst_port;
    do
    {
      signed int _g_boolean_var_;
      if((signed int)dp->src_node_id.node_type == IP)
        _g_boolean_var_ = 1;

      else
        _g_boolean_var_ = 0;
      tmp_statement_expression$4 = _g_boolean_var_;
      if((signed long int)tmp_statement_expression$4 == 0l)
        g_assertion_message_expr((char *)0, "decode_proto.c", 1347, (const char *)"get_udp", "dp->src_node_id.node_type == IP");

    }
    while((_Bool)0);
    dp->src_node_id.node_type = (enum anonymous$13)TCP;
    memmove((void *)&dp->src_node_id.addr.tcp4.host, (const void *)&dp->global_src_address, sizeof(struct anonymous$20) /*20ul*/ );
    dp->src_node_id.addr.tcp4.port = dp->global_src_port;
  }

  add_offset(dp, (unsigned int)8);
  signed int return_value_get_rpc$5;
  return_value_get_rpc$5=get_rpc(dp, (signed int)!(0 != 0));
  if(return_value_get_rpc$5 == 0)
  {
    if((signed int)dst_port == 138 || (signed int)src_port == 138)
      get_netbios_dgm(dp);

    else
    {
      src_service=services_udp_find(src_port);
      dst_service=services_udp_find(dst_port);
      chosen_port=choose_port(src_port, dst_port);
      if(dst_service == ((const struct anonymous$21 *)NULL) && src_service == ((const struct anonymous$21 *)NULL))
      {
        if(!(pref.group_unk == 0))
          decode_proto_add(dp, "UDP-UNKNOWN");

        else
          if(chosen_port == src_port)
            decode_proto_add(dp, "UDP:%d-%d", chosen_port, dst_port);

          else
            decode_proto_add(dp, "UDP:%d-%d", chosen_port, src_port);
      }

      else
      {
        if(!(src_service == ((const struct anonymous$21 *)NULL)))
          src_pref = src_service->preferred;

        if(!(dst_service == ((const struct anonymous$21 *)NULL)))
          dst_pref = dst_service->preferred;

        if(dst_pref == 0 && !(src_pref == 0))
          chosen_service = src_service;

        else
          if(src_pref == 0 && !(dst_pref == 0))
            chosen_service = dst_service;

          else
            if(dst_service == ((const struct anonymous$21 *)NULL) || src_port == chosen_port && !(src_service == ((const struct anonymous$21 *)NULL)))
              chosen_service = src_service;

            else
              chosen_service = dst_service;
        decode_proto_add(dp, "%s", chosen_service->name);
      }
    }
  }

}

// get_udp_name
// file names.c line 462
static signed int get_udp_name(struct anonymous$9 *nt)
{
  nt->offset = nt->offset + (unsigned short int)8;
  return (signed int)!(0 != 0);
}

// get_wlan
// file decode_proto.c line 680
static void get_wlan(struct anonymous$3 *dp)
{
  unsigned char type;
  unsigned char subtype;
  unsigned char wep;
  unsigned char fromtods;
  unsigned char dstofs;
  unsigned char srcofs;
  decode_proto_add(dp, "IEE802.11");
  if(!(dp->cur_len >= 10u))
  {
    char *return_value_dcgettext$1;
    return_value_dcgettext$1=dcgettext((const char *)(void *)0, "wlan:captured size too small, packet discarded", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$1);
    goto __CPROVER_DUMP_L23;
  }

  type = (unsigned char)((signed int)dp->cur_packet[(signed long int)0] >> 2 & 0x03);
  subtype = (unsigned char)((signed int)dp->cur_packet[(signed long int)0] >> 4 & 0x0f);
  fromtods = (unsigned char)((signed int)dp->cur_packet[(signed long int)1] & 0x03);
  wep = (unsigned char)((signed int)dp->cur_packet[(signed long int)1] >> 6 & 0x01);
  if((signed int)fromtods >= 4)
  {
    char *return_value_dcgettext$2;
    return_value_dcgettext$2=dcgettext((const char *)(void *)0, "Invalid tofromds field in WLAN packet: 0x%x", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$2, fromtods);
    goto __CPROVER_DUMP_L23;
  }

  switch((signed int)fromtods)
  {
    case 0:
    {
      dstofs = (unsigned char)4;
      srcofs = (unsigned char)10;
      break;
    }
    case 1:
    {
      dstofs = (unsigned char)16;
      srcofs = (unsigned char)10;
      break;
    }
    case 2:
    {
      dstofs = (unsigned char)4;
      srcofs = (unsigned char)16;
      break;
    }
    case 3:
    {
      dstofs = (unsigned char)16;
      srcofs = (unsigned char)24;
    }
  }
  if(!(dp->cur_len >= 6u + (unsigned int)(signed int)dstofs))
  {
    char *return_value_dcgettext$3;
    return_value_dcgettext$3=dcgettext((const char *)(void *)0, "wlan:captured size too small, packet discarded", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$3);
    goto __CPROVER_DUMP_L23;
  }

  dp->dst_node_id.node_type = (enum anonymous$13)LINK6;
  do
    memmove((void *)dp->dst_node_id.addr.eth, (const void *)(dp->cur_packet + (signed long int)dstofs), sizeof(unsigned char [6l]) /*6ul*/ );
  while((_Bool)0);
  if((signed int)subtype == 12 || !((signed int)type == 1))
  {
    if(!(dp->cur_len >= 6u + (unsigned int)(signed int)srcofs))
    {
      char *return_value_dcgettext$4;
      return_value_dcgettext$4=dcgettext((const char *)(void *)0, "wlan:captured size too small, packet discarded", 5);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$4);
      goto __CPROVER_DUMP_L23;
    }

    dp->src_node_id.node_type = (enum anonymous$13)LINK6;
    do
      memmove((void *)dp->src_node_id.addr.eth, (const void *)(dp->cur_packet + (signed long int)srcofs), sizeof(unsigned char [6l]) /*6ul*/ );
    while((_Bool)0);
  }

  if(!((signed int)fromtods == 3))
    add_offset(dp, (unsigned int)24);

  else
    add_offset(dp, (unsigned int)30);
  char *return_value_dcgettext$5;
  switch((signed int)type)
  {
    case 2:
    {
      if(wep == 0)
      {
        if((signed int)subtype == 8)
          add_offset(dp, (unsigned int)2);

        get_llc(dp);
      }

      else
        decode_proto_add(dp, "WLAN-CRYPTED");
      break;
    }
    case 0:
    {
      decode_wlan_mgmt(dp, subtype);
      break;
    }
    case 1:
    {
      decode_proto_add(dp, "WLAN-CTRL");
      break;
    }
    default:
    {
      return_value_dcgettext$5=dcgettext((const char *)(void *)0, "wlan:unknown frame type 0x%x, decode aborted", 5);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$5, type);
      goto __CPROVER_DUMP_L23;
    }
  }

__CPROVER_DUMP_L23:
  ;
}

// gfunc_remove_canvas_link
// file diagram.c line 315
static void gfunc_remove_canvas_link(void *data, void *user_data)
{
  g_tree_remove(canvas_links, (const void *)(const struct anonymous$16 *)data);
}

// gfunc_remove_canvas_node
// file diagram.c line 308
static void gfunc_remove_canvas_node(void *data, void *user_data)
{
  g_tree_remove(canvas_nodes, (const void *)(const struct anonymous$5 *)data);
}

// gfunc_remove_link
// file links.c line 169
static void gfunc_remove_link(void *data, void *user_data)
{
  links_catalog_remove((const struct anonymous$16 *)data);
}

// gfunc_remove_node
// file node.c line 558
static void gfunc_remove_node(void *data, void *user_data)
{
  nodes_catalog_remove((const struct anonymous$5 *)data);
}

// gui_eof_capture
// file menus.c line 517
void gui_eof_capture(void)
{
  struct _GtkWidget *widget;
  struct _GString *status_string = (struct _GString *)(void *)0;
  enum status_t return_value_get_capture_status$1;
  return_value_get_capture_status$1=get_capture_status();
  if(!((signed int)return_value_get_capture_status$1 == STOP))
  {
    widget=glade_xml_get_widget(appdata.xml, "start_button");
    gtk_widget_set_sensitive(widget, (signed int)!(0 != 0));
    widget=glade_xml_get_widget(appdata.xml, "start_menuitem");
    gtk_widget_set_sensitive(widget, (signed int)!(0 != 0));
    widget=glade_xml_get_widget(appdata.xml, "pause_button");
    gtk_widget_set_sensitive(widget, 0);
    widget=glade_xml_get_widget(appdata.xml, "pause_menuitem");
    gtk_widget_set_sensitive(widget, 0);
    widget=glade_xml_get_widget(appdata.xml, "next_button");
    gtk_widget_set_sensitive(widget, 0);
    widget=glade_xml_get_widget(appdata.xml, "next_menuitem");
    gtk_widget_set_sensitive(widget, 0);
    status_string=g_string_new("");
    char *return_value_dcgettext$2;
    return_value_dcgettext$2=dcgettext((const char *)(void *)0, "Replay from file '%s' completed.", 5);
    g_string_printf(status_string, return_value_dcgettext$2, appdata.input_file);
    set_statusbar_msg(status_string->str);
    g_string_free(status_string, (signed int)!(0 != 0));
  }

}

// gui_pause_capture
// file menus.c line 480
void gui_pause_capture(void)
{
  struct _GtkWidget *widget;
  update_info_windows();
  signed int return_value_pause_capture$1;
  return_value_pause_capture$1=pause_capture();
  if(!(return_value_pause_capture$1 == 0))
  {
    widget=glade_xml_get_widget(appdata.xml, "stop_button");
    gtk_widget_set_sensitive(widget, (signed int)!(0 != 0));
    widget=glade_xml_get_widget(appdata.xml, "stop_menuitem");
    gtk_widget_set_sensitive(widget, (signed int)!(0 != 0));
    widget=glade_xml_get_widget(appdata.xml, "start_button");
    gtk_widget_set_sensitive(widget, (signed int)!(0 != 0));
    widget=glade_xml_get_widget(appdata.xml, "start_menuitem");
    gtk_widget_set_sensitive(widget, (signed int)!(0 != 0));
    widget=glade_xml_get_widget(appdata.xml, "pause_button");
    gtk_widget_set_sensitive(widget, 0);
    widget=glade_xml_get_widget(appdata.xml, "pause_menuitem");
    gtk_widget_set_sensitive(widget, 0);
    widget=glade_xml_get_widget(appdata.xml, "next_button");
    gtk_widget_set_sensitive(widget, 0);
    widget=glade_xml_get_widget(appdata.xml, "next_menuitem");
    gtk_widget_set_sensitive(widget, 0);
    char *return_value_dcgettext$2;
    return_value_dcgettext$2=dcgettext((const char *)(void *)0, "Paused", 5);
    set_statusbar_msg(return_value_dcgettext$2);
    char *return_value_dcgettext$3;
    return_value_dcgettext$3=dcgettext((const char *)(void *)0, "Diagram paused", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$3);
    dump_stats((unsigned int)0);
  }

}

// gui_start_capture
// file menus.c line 371
void gui_start_capture(void)
{
  struct _GtkWidget *widget;
  char *errorbuf = (char *)(void *)0;
  struct _GString *status_string = (struct _GString *)(void *)0;
  enum status_t return_value_get_capture_status$2;
  return_value_get_capture_status$2=get_capture_status();
  signed int return_value_gui_stop_capture$1;
  char *return_value_dcgettext$8;
  char *return_value_dcgettext$12;
  char *return_value_dcgettext$13;
  char *return_value_dcgettext$14;
  char *return_value_dcgettext$15;
  char *return_value_dcgettext$16;
  if((signed int)return_value_get_capture_status$2 == CAP_EOF)
  {
    return_value_gui_stop_capture$1=gui_stop_capture();
    if(!(return_value_gui_stop_capture$1 == 0))
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    enum status_t return_value_get_capture_status$3;
    return_value_get_capture_status$3=get_capture_status();
    if((signed int)return_value_get_capture_status$3 == STOP)
    {
      errorbuf=init_capture();
      if(errorbuf == ((char *)NULL))
        goto __CPROVER_DUMP_L2;

      fatal_error_dialog(errorbuf);
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      enum status_t return_value_get_capture_status$5;
      return_value_get_capture_status$5=get_capture_status();
      if((signed int)return_value_get_capture_status$5 == PLAY)
      {
        char *return_value_dcgettext$4;
        return_value_dcgettext$4=dcgettext((const char *)(void *)0, "Status already PLAY at gui_start_capture", 5);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$4);
        goto __CPROVER_DUMP_L20;
      }

      signed int return_value_start_capture$6;
      return_value_start_capture$6=start_capture();
      if(!(return_value_start_capture$6 == 0))
      {
        in_start_capture = (signed int)!(0 != 0);
        widget=glade_xml_get_widget(appdata.xml, "stop_button");
        gtk_widget_set_sensitive(widget, (signed int)!(0 != 0));
        widget=glade_xml_get_widget(appdata.xml, "stop_menuitem");
        gtk_widget_set_sensitive(widget, (signed int)!(0 != 0));
        widget=glade_xml_get_widget(appdata.xml, "start_button");
        gtk_widget_set_sensitive(widget, 0);
        widget=glade_xml_get_widget(appdata.xml, "start_menuitem");
        gtk_widget_set_sensitive(widget, 0);
        widget=glade_xml_get_widget(appdata.xml, "pause_button");
        gtk_widget_set_sensitive(widget, (signed int)!(0 != 0));
        widget=glade_xml_get_widget(appdata.xml, "pause_menuitem");
        gtk_widget_set_sensitive(widget, (signed int)!(0 != 0));
        widget=glade_xml_get_widget(appdata.xml, "next_button");
        gtk_widget_set_sensitive(widget, (signed int)(appdata.input_file != (char *)(void *)0));
        widget=glade_xml_get_widget(appdata.xml, "next_menuitem");
        gtk_widget_set_sensitive(widget, (signed int)(appdata.input_file != (char *)(void *)0));
        widget=glade_xml_get_widget(appdata.xml, "link_radio");
        signed int return_value_has_linklevel$7;
        return_value_has_linklevel$7=has_linklevel();
        if(return_value_has_linklevel$7 == 0)
          gtk_widget_set_sensitive(widget, 0);

        else
          gtk_widget_set_sensitive(widget, (signed int)!(0 != 0));
        switch((signed int)appdata.mode)
        {
          case LINK6:
          {
            widget=glade_xml_get_widget(appdata.xml, "link_radio");
            break;
          }
          case IP:
          {
            widget=glade_xml_get_widget(appdata.xml, "ip_radio");
            break;
          }
          case TCP:
          {
            widget=glade_xml_get_widget(appdata.xml, "tcp_radio");
            break;
          }
          default:
          {
            return_value_dcgettext$8=dcgettext((const char *)(void *)0, "Invalid mode: %d", 5);
            g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$8, appdata.mode);
            goto __CPROVER_DUMP_L20;
          }
        }
        unsigned long int return_value_gtk_check_menu_item_get_type$9;
        return_value_gtk_check_menu_item_get_type$9=gtk_check_menu_item_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
        return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_check_menu_item_get_type$9);
        gtk_check_menu_item_set_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$10, (signed int)!(0 != 0));
        set_active_interface();
        char *return_value_dcgettext$11;
        return_value_dcgettext$11=dcgettext((const char *)(void *)0, "Reading data from ", 5);
        status_string=g_string_new(return_value_dcgettext$11);
        if(!(appdata.input_file == ((char *)NULL)))
          g_string_append(status_string, appdata.input_file);

        else
          if(!(appdata.interface == ((char *)NULL)))
            g_string_append(status_string, appdata.interface);

          else
          {
            return_value_dcgettext$12=dcgettext((const char *)(void *)0, "default interface", 5);
            g_string_append(status_string, return_value_dcgettext$12);
          }
        switch((signed int)appdata.mode)
        {
          case LINK6:
          {
            return_value_dcgettext$13=dcgettext((const char *)(void *)0, " in Data Link mode", 5);
            g_string_append(status_string, return_value_dcgettext$13);
            break;
          }
          case IP:
          {
            return_value_dcgettext$14=dcgettext((const char *)(void *)0, " in IP mode", 5);
            g_string_append(status_string, return_value_dcgettext$14);
            break;
          }
          case TCP:
          {
            return_value_dcgettext$15=dcgettext((const char *)(void *)0, " in TCP mode", 5);
            g_string_append(status_string, return_value_dcgettext$15);
            break;
          }
          default:
          {
            return_value_dcgettext$16=dcgettext((const char *)(void *)0, "Invalid mode: %d", 5);
            g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, return_value_dcgettext$16, appdata.mode);
            goto __CPROVER_DUMP_L20;
          }
        }
        set_statusbar_msg(status_string->str);
        g_string_free(status_string, (signed int)!(0 != 0));
        in_start_capture = 0;
        char *return_value_dcgettext$17;
        return_value_dcgettext$17=dcgettext((const char *)(void *)0, "Diagram started", 5);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$17);
      }

    }
  }

__CPROVER_DUMP_L20:
  ;
}

// gui_stop_capture
// file menus.c line 552
signed int gui_stop_capture(void)
{
  struct _GtkWidget *widget;
  struct _GString *status_string = (struct _GString *)(void *)0;
  stop_requested = 0;
  enum status_t return_value_get_capture_status$1;
  return_value_get_capture_status$1=get_capture_status();
  char *return_value_dcgettext$4;
  if((signed int)return_value_get_capture_status$1 == STOP)
    return (signed int)!(0 != 0);

  else
    if(!(already_updating == 0))
    {
      stop_requested = (signed int)!(0 != 0);
      return 0;
    }

    else
    {
      signed int return_value_stop_capture$2;
      return_value_stop_capture$2=stop_capture();
      if(return_value_stop_capture$2 == 0)
        return 0;

      else
      {
        widget=glade_xml_get_widget(appdata.xml, "start_button");
        gtk_widget_set_sensitive(widget, (signed int)!(0 != 0));
        widget=glade_xml_get_widget(appdata.xml, "start_menuitem");
        gtk_widget_set_sensitive(widget, (signed int)!(0 != 0));
        widget=glade_xml_get_widget(appdata.xml, "stop_button");
        gtk_widget_set_sensitive(widget, 0);
        widget=glade_xml_get_widget(appdata.xml, "stop_menuitem");
        gtk_widget_set_sensitive(widget, 0);
        widget=glade_xml_get_widget(appdata.xml, "pause_button");
        gtk_widget_set_sensitive(widget, 0);
        widget=glade_xml_get_widget(appdata.xml, "pause_menuitem");
        gtk_widget_set_sensitive(widget, 0);
        widget=glade_xml_get_widget(appdata.xml, "next_button");
        gtk_widget_set_sensitive(widget, 0);
        widget=glade_xml_get_widget(appdata.xml, "next_menuitem");
        gtk_widget_set_sensitive(widget, 0);
        delete_gui_protocols();
        widget=glade_xml_get_widget(appdata.xml, "canvas1");
        update_diagram(widget);
        char *return_value_dcgettext$3;
        return_value_dcgettext$3=dcgettext((const char *)(void *)0, "Ready to capture from ", 5);
        status_string=g_string_new(return_value_dcgettext$3);
        if(!(appdata.input_file == ((char *)NULL)))
          g_string_append(status_string, appdata.input_file);

        else
          if(!(appdata.interface == ((char *)NULL)))
            g_string_append(status_string, appdata.interface);

          else
          {
            return_value_dcgettext$4=dcgettext((const char *)(void *)0, "default interface", 5);
            g_string_append(status_string, return_value_dcgettext$4);
          }
        set_statusbar_msg(status_string->str);
        g_string_free(status_string, (signed int)!(0 != 0));
        char *return_value_dcgettext$5;
        return_value_dcgettext$5=dcgettext((const char *)(void *)0, "Diagram stopped", 5);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$5);
        dump_stats((unsigned int)0);
        return (signed int)!(0 != 0);
      }
    }
}

// has_linklevel
// file decode_proto.h line 27
signed int has_linklevel(void)
{
  if(!(lkentry == ((const struct linktype_data_tag *)NULL)))
    return (signed int)((signed int)lkentry->l2_idtype == LINK6);

  else
    return 0;
}

// header_xml
// file export.c line 35
static char * header_xml(void)
{
  char *dvc = (char *)(void *)0;
  char *xml;
  signed long int timenow;
  struct tm *tmnow;
  char timebuf[256l];
  if(!(appdata.input_file == ((char *)NULL)))
    dvc=xmltag("capture_file", appdata.input_file);

  else
    if(!(appdata.interface == ((char *)NULL)))
      dvc=xmltag("capture_device", appdata.interface);

  timenow=time((signed long int *)(void *)0);
  tmnow=localtime(&timenow);
  strftime(timebuf, sizeof(char [256l]) /*256ul*/ , "%F %T %z", tmnow);
  xml=xmltag("header", "\n%s<timestamp>%s</timestamp>\n", dvc != ((char *)NULL) ? dvc : "", (const void *)timebuf);
  g_free((void *)dvc);
  return xml;
}

// hide_pref_dialog
// file pref_dialog.c line 70
static void hide_pref_dialog(void)
{
  free_config(tmp_pref);
  g_free((void *)tmp_pref);
  tmp_pref = (struct pref_struct *)(void *)0;
  colors_changed = 0;
  gtk_widget_hide(diag_pref);
}

// hide_widget
// file ui_utils.c line 101
void hide_widget(struct _GtkWidget *window, const char *lblname)
{
  struct _GtkWidget *widget;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$2;
  return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, lblname);
  widget = (struct _GtkWidget *)return_value_g_object_get_data$2;
  gtk_widget_hide(widget);
}

// init_capture
// file capture.h line 33
char * init_capture(void)
{
  char *device;
  char ebuf[256l];
  unsigned int linktype;
  static signed int data_initialized = 0;
  if(data_initialized == 0)
  {
    if(!(pref.name_res == 0))
    {
      signed int return_value_dns_open$1;
      return_value_dns_open$1=dns_open();
      if(!(return_value_dns_open$1 == 0))
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, "Name resolver not available");

    }

    capture_status = (enum status_t)STOP;
    data_initialized = (signed int)!(0 != 0);
  }

  device = appdata.interface;
  static char errorbuf[300l];
  if(appdata.input_file == ((char *)NULL) && device == ((char *)NULL))
  {
    ebuf[0l] = (char)0;
    char *return_value_pcap_lookupdev$2;
    return_value_pcap_lookupdev$2=pcap_lookupdev(ebuf);
    device=g_strdup(return_value_pcap_lookupdev$2);
    if(device == ((char *)NULL))
    {
      char *return_value_dcgettext$3;
      return_value_dcgettext$3=dcgettext((const char *)(void *)0, "No capture device found or insufficient privileges.\nOnly file replay will be available.\nEtherApe must be run with administrative privileges (e.g. root) to enable live capture.\nPcap error: %s", 5);
      snprintf(errorbuf, sizeof(char [300l]) /*300ul*/ , return_value_dcgettext$3, (const void *)ebuf);
      return errorbuf;
    }

    appdata.interface = device;
  }

  if(appdata.input_file == ((char *)NULL))
  {
    ebuf[0l] = (char)0;
    pch_struct=pcap_open_live(device, 200, (signed int)!(0 != 0), 250, ebuf);
    if(pch_struct == ((struct pcap *)NULL))
    {
      char *return_value_dcgettext$4;
      return_value_dcgettext$4=dcgettext((const char *)(void *)0, "Error opening %s : %s\n- perhaps you need to be root?", 5);
      snprintf(errorbuf, sizeof(char [300l]) /*300ul*/ , return_value_dcgettext$4, device, (const void *)ebuf);
      return errorbuf;
    }

    pcap_fd=pcap_fileno(pch_struct);
    char *return_value_dcgettext$5;
    return_value_dcgettext$5=dcgettext((const char *)(void *)0, "Live device %s opened for capture. pcap_fd: %d", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$5, device, pcap_fd);
  }

  else
  {
    if(!(device == ((char *)NULL)))
    {
      char *return_value_dcgettext$6;
      return_value_dcgettext$6=dcgettext((const char *)(void *)0, "Can't open both %s and device %s. Please choose one.", 5);
      snprintf(errorbuf, sizeof(char [300l]) /*300ul*/ , return_value_dcgettext$6, appdata.input_file, device);
      return errorbuf;
    }

    ebuf[0l] = (char)0;
    pch_struct=pcap_open_offline(appdata.input_file, ebuf);
    if(pch_struct == ((struct pcap *)NULL))
    {
      char *return_value_dcgettext$7;
      return_value_dcgettext$7=dcgettext((const char *)(void *)0, "Error opening %s : %s", 5);
      snprintf(errorbuf, sizeof(char [300l]) /*300ul*/ , return_value_dcgettext$7, appdata.input_file, (const void *)ebuf);
      return errorbuf;
    }

    char *return_value_dcgettext$8;
    return_value_dcgettext$8=dcgettext((const char *)(void *)0, "%s opened for offline capture", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$8, appdata.input_file);
  }
  signed int return_value_pcap_datalink$9;
  return_value_pcap_datalink$9=pcap_datalink(pch_struct);
  linktype = (unsigned int)return_value_pcap_datalink$9;
  signed int return_value_setup_link_type$13;
  return_value_setup_link_type$13=setup_link_type(linktype);
  signed int return_value_has_linklevel$15;
  if(return_value_setup_link_type$13 == 0)
  {
    if(!(appdata.input_file == ((char *)NULL)))
    {
      char *return_value_dcgettext$10;
      return_value_dcgettext$10=dcgettext((const char *)(void *)0, "File %s contains packets with unsupported link type %d, cannot replay", 5);
      snprintf(errorbuf, sizeof(char [300l]) /*300ul*/ , return_value_dcgettext$10, appdata.input_file, linktype);
    }

    else
      if(!(device == ((char *)NULL)))
      {
        char *return_value_dcgettext$11;
        return_value_dcgettext$11=dcgettext((const char *)(void *)0, "Device %s uses unsupported link type %d,cannot capture. Please choose another interface.", 5);
        snprintf(errorbuf, sizeof(char [300l]) /*300ul*/ , return_value_dcgettext$11, device, linktype);
      }

      else
      {
        char *return_value_dcgettext$12;
        return_value_dcgettext$12=dcgettext((const char *)(void *)0, "Unsupported link type %d", 5);
        snprintf(errorbuf, sizeof(char [300l]) /*300ul*/ , return_value_dcgettext$12, linktype);
      }
    return errorbuf;
  }

  else
  {
    if((signed int)appdata.mode == APEMODE_DEFAULT)
    {
      appdata.mode = (enum anonymous$13)IP;
      g_free((void *)pref.filter);
      pref.filter=get_default_filter(appdata.mode);
    }

    if((signed int)appdata.mode == LINK6)
    {
      return_value_has_linklevel$15=has_linklevel();
      if(return_value_has_linklevel$15 == 0)
      {
        char *return_value_dcgettext$14;
        return_value_dcgettext$14=dcgettext((const char *)(void *)0, "This device does not support link-layer mode. Please use IP or TCP modes.", 5);
        snprintf(errorbuf, sizeof(char [300l]) /*300ul*/ , return_value_dcgettext$14);
        return errorbuf;
      }

    }

    if(!(pref.filter == ((char *)NULL)))
      set_filter(pref.filter, device);

    return (char *)(void *)0;
  }
}

// init_config
// file preferences.c line 98
void init_config(struct pref_struct *p)
{
  p->name_res = (signed int)!(0 != 0);
  p->refresh_period = (unsigned int)800;
  p->text_color=g_strdup("yellow");
  p->diagram_only = 0;
  p->group_unk = (signed int)!(0 != 0);
  p->stationary = 0;
  p->node_radius_multiplier = 0.0005;
  p->link_node_ratio = (double)1;
  p->size_mode = (enum anonymous$59)LINEAR;
  p->node_size_variable = (enum anonymous$60)INST_OUTBOUND;
  p->stack_level = (unsigned int)0;
  p->proto_timeout_time = (double)0;
  p->gui_node_timeout_time = (double)0;
  p->node_timeout_time = (double)0;
  p->proto_node_timeout_time = (double)0;
  p->gui_link_timeout_time = (double)0;
  p->link_timeout_time = (double)0;
  p->proto_link_timeout_time = (double)0;
  p->refresh_period = (unsigned int)0;
  p->filter = (char *)(void *)0;
  p->text_color = (char *)(void *)0;
  p->fontname = (char *)(void *)0;
  p->colors = (char **)(void *)0;
  p->center_node = (char *)(void *)0;
  p->averaging_time = (double)3000;
}

// init_diagram
// file diagram.h line 28
void init_diagram(struct _GladeXML *xml)
{
  struct _GtkStyle *style;
  struct _GtkWidget *canvas;
  canvas_nodes=g_tree_new_full((signed int (*)(const void *, const void *, void *))canvas_node_compare, (void *)0, (void (*)(void *))(void *)0, (void (*)(void *))canvas_node_delete);
  canvas_links=g_tree_new_full((signed int (*)(const void *, const void *, void *))canvas_link_compare, (void *)0, (void (*)(void *))(void *)0, (void (*)(void *))canvas_link_delete);
  initialize_pref_controls();
  canvas=glade_xml_get_widget(appdata.xml, "canvas1");
  gdk_color_parse("black", &black_color);
  struct _GdkColormap *return_value_gdk_colormap_get_system$1;
  return_value_gdk_colormap_get_system$1=gdk_colormap_get_system();
  gdk_colormap_alloc_color(return_value_gdk_colormap_get_system$1, &black_color, (signed int)!(0 != 0), (signed int)!(0 != 0));
  style=gtk_style_new();
  style->bg[(signed long int)GTK_STATE_NORMAL] = black_color;
  style->base[(signed long int)GTK_STATE_NORMAL] = black_color;
  gtk_widget_set_style(canvas, style);
  gtk_style_set_background(canvas->style, canvas->window, (enum anonymous$0)GTK_STATE_NORMAL);
  delete_gui_protocols();
  already_updating = 0;
  stop_requested = 0;
}

// init_menus
// file menus.c line 42
void init_menus(void)
{
  struct _GtkWidget *widget = (struct _GtkWidget *)(void *)0;
  struct _GtkWidget *item = (struct _GtkWidget *)(void *)0;
  struct _GList *interfaces;
  struct _GSList *group = (struct _GSList *)(void *)0;
  struct _GString *info_string = (struct _GString *)(void *)0;
  struct _GString *err_str;
  err_str=g_string_new("");
  interfaces=interface_list_create(err_str);
  char *return_value_dcgettext$1;
  return_value_dcgettext$1=dcgettext((const char *)(void *)0, "get_interface result: '%s'", 5);
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$1, err_str->str);
  if(interfaces == ((struct _GList *)NULL))
  {
    char *return_value_dcgettext$2;
    return_value_dcgettext$2=dcgettext((const char *)(void *)0, "No suitables interfaces for capture have been found", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$2);
    if(!(err_str == ((struct _GString *)NULL)))
      g_string_free(err_str, (signed int)!(0 != 0));

    goto __CPROVER_DUMP_L7;
  }

  if(!(err_str == ((struct _GString *)NULL)))
    g_string_free(err_str, (signed int)!(0 != 0));

  widget=glade_xml_get_widget(appdata.xml, "interfaces_menu");
  char *return_value_dcgettext$3;
  return_value_dcgettext$3=dcgettext((const char *)(void *)0, "Available interfaces for capture:", 5);
  info_string=g_string_new(return_value_dcgettext$3);
  item=gtk_radio_menu_item_new_with_label(group, "apedummy");
  unsigned long int return_value_gtk_radio_menu_item_get_type$4;
  return_value_gtk_radio_menu_item_get_type$4=gtk_radio_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)item, return_value_gtk_radio_menu_item_get_type$4);
  group=gtk_radio_menu_item_get_group((struct _GtkRadioMenuItem *)return_value_g_type_check_instance_cast$5);
  unsigned long int return_value_gtk_menu_shell_get_type$6;
  return_value_gtk_menu_shell_get_type$6=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_menu_shell_get_type$6);
  gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast$7, item);
  while(!(interfaces == ((struct _GList *)NULL)))
  {
    item=gtk_radio_menu_item_new_with_label(group, (char *)interfaces->data);
    unsigned long int return_value_gtk_radio_menu_item_get_type$8;
    return_value_gtk_radio_menu_item_get_type$8=gtk_radio_menu_item_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)item, return_value_gtk_radio_menu_item_get_type$8);
    group=gtk_radio_menu_item_get_group((struct _GtkRadioMenuItem *)return_value_g_type_check_instance_cast$9);
    unsigned long int return_value_gtk_menu_shell_get_type$10;
    return_value_gtk_menu_shell_get_type$10=gtk_menu_shell_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
    return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_menu_shell_get_type$10);
    gtk_menu_shell_append((struct _GtkMenuShell *)return_value_g_type_check_instance_cast$11, item);
    gtk_widget_show(item);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)item, (unsigned long int)(20 << 2));
    char *return_value_g_strdup$13;
    return_value_g_strdup$13=g_strdup((const char *)interfaces->data);
    g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$12, "activate", (void (*)(void))on_interface_radio_activate, (void *)return_value_g_strdup$13, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)G_CONNECT_SWAPPED);
    g_string_append(info_string, " ");
    g_string_append(info_string, (char *)interfaces->data);
    interfaces = interfaces->next;
  }
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, "%s", info_string->str);
  if(!(info_string == ((struct _GString *)NULL)))
    g_string_free(info_string, (signed int)!(0 != 0));

  interface_list_free(interfaces);

__CPROVER_DUMP_L7:
  ;
}

// init_reposition
// file diagram.c line 923
static void init_reposition(struct anonymous *data, struct _GtkWidget *canvas, unsigned int total_nodes)
{
  double text_compensation = (double)50;
  data->canvas = canvas;
  data->angle = (float)0.0;
  data->node_i = (unsigned int)0;
  data->n_nodes = (unsigned int)0;
  data->n_nodes = total_nodes;
  data->node_i = total_nodes;
  unsigned long int return_value_gnome_canvas_get_type$1;
  return_value_gnome_canvas_get_type$1=gnome_canvas_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)canvas, return_value_gnome_canvas_get_type$1);
  gnome_canvas_get_scroll_region((struct _GnomeCanvas *)return_value_g_type_check_instance_cast$2, &data->xmin, &data->ymin, &data->xmax, &data->ymax);
  data->xmin = data->xmin + text_compensation;
  data->xmax = data->xmax - text_compensation;
  data->x_rad_max = (0.9 * (data->xmax - data->xmin)) / (double)2;
  data->y_rad_max = (0.9 * (data->ymax - data->ymin)) / (double)2;
  data->x_inner_rad_max = data->x_rad_max / (double)2;
  data->y_inner_rad_max = data->y_rad_max / (double)2;
}

// initialize_ethers
// file resolv.c line 395
static void initialize_ethers(void)
{
  struct _ether *eth;
  if(g_pethers_path == ((char *)NULL))
  {
    const char *return_value_get_home_dir$1;
    return_value_get_home_dir$1=get_home_dir();
    g_pethers_path=g_strdup_printf("%s/%s", return_value_get_home_dir$1, (const void *)".etherape/ethers");
  }

  set_ethent(g_manuf_path);
  do
  {
    eth=get_ethent(0);
    if(eth == ((struct _ether *)NULL))
      break;

    add_manuf_name(eth->addr, eth->name);
  }
  while((_Bool)1);
  end_ethent();
}

// initialize_pref_controls
// file pref_dialog.c line 85
void initialize_pref_controls(void)
{
  struct _GtkWidget *widget;
  struct _GtkSpinButton *spin;
  struct _GdkColor color;
  struct _GtkTreeModel *model;
  diag_pref=glade_xml_get_widget(appdata.xml, "diag_pref");
  widget=glade_xml_get_widget(appdata.xml, "node_radius_slider");
  unsigned long int return_value_gtk_range_get_type$1;
  return_value_gtk_range_get_type$1=gtk_range_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_range_get_type$1);
  double return_value_log$3;
  return_value_log$3=log(pref.node_radius_multiplier);
  double return_value_log$4;
  return_value_log$4=log((double)10);
  gtk_adjustment_set_value(((struct _GtkRange *)return_value_g_type_check_instance_cast$2)->adjustment, return_value_log$3 / return_value_log$4);
  unsigned long int return_value_gtk_range_get_type$5;
  return_value_gtk_range_get_type$5=gtk_range_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_range_get_type$5);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkRange *)return_value_g_type_check_instance_cast$6)->adjustment, (unsigned long int)(20 << 2));
  g_signal_emit_by_name((void *)(struct _GObject *)return_value_g_type_check_instance_cast$7, "changed");
  widget=glade_xml_get_widget(appdata.xml, "link_width_slider");
  unsigned long int return_value_gtk_range_get_type$8;
  return_value_gtk_range_get_type$8=gtk_range_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_range_get_type$8);
  gtk_adjustment_set_value(((struct _GtkRange *)return_value_g_type_check_instance_cast$9)->adjustment, pref.link_node_ratio);
  unsigned long int return_value_gtk_range_get_type$10;
  return_value_gtk_range_get_type$10=gtk_range_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_range_get_type$10);
  unsigned long int return_value_gtk_object_get_type$12;
  return_value_gtk_object_get_type$12=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkRange *)return_value_g_type_check_instance_cast$11)->adjustment, return_value_gtk_object_get_type$12);
  g_signal_emit_by_name((void *)(struct _GtkObject *)return_value_g_type_check_instance_cast$13, "changed");
  struct _GtkWidget *return_value_glade_xml_get_widget$14;
  return_value_glade_xml_get_widget$14=glade_xml_get_widget(appdata.xml, "averaging_spin");
  unsigned long int return_value_gtk_spin_button_get_type$15;
  return_value_gtk_spin_button_get_type$15=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$14, return_value_gtk_spin_button_get_type$15);
  spin = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$16;
  gtk_spin_button_set_value(spin, pref.averaging_time);
  struct _GtkWidget *return_value_glade_xml_get_widget$17;
  return_value_glade_xml_get_widget$17=glade_xml_get_widget(appdata.xml, "refresh_spin");
  unsigned long int return_value_gtk_spin_button_get_type$18;
  return_value_gtk_spin_button_get_type$18=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
  return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$17, return_value_gtk_spin_button_get_type$18);
  spin = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$19;
  gtk_spin_button_set_value(spin, (double)pref.refresh_period);
  struct _GtkWidget *return_value_glade_xml_get_widget$20;
  return_value_glade_xml_get_widget$20=glade_xml_get_widget(appdata.xml, "node_to_spin");
  unsigned long int return_value_gtk_spin_button_get_type$21;
  return_value_gtk_spin_button_get_type$21=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$20, return_value_gtk_spin_button_get_type$21);
  spin = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$22;
  gtk_spin_button_set_value(spin, pref.node_timeout_time / 1000.0);
  struct _GtkWidget *return_value_glade_xml_get_widget$23;
  return_value_glade_xml_get_widget$23=glade_xml_get_widget(appdata.xml, "gui_node_to_spin");
  unsigned long int return_value_gtk_spin_button_get_type$24;
  return_value_gtk_spin_button_get_type$24=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
  return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$23, return_value_gtk_spin_button_get_type$24);
  spin = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$25;
  gtk_spin_button_set_value(spin, pref.gui_node_timeout_time / 1000.0);
  struct _GtkWidget *return_value_glade_xml_get_widget$26;
  return_value_glade_xml_get_widget$26=glade_xml_get_widget(appdata.xml, "proto_node_to_spin");
  unsigned long int return_value_gtk_spin_button_get_type$27;
  return_value_gtk_spin_button_get_type$27=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
  return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$26, return_value_gtk_spin_button_get_type$27);
  spin = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$28;
  gtk_spin_button_set_value(spin, pref.proto_node_timeout_time / 1000.0);
  struct _GtkWidget *return_value_glade_xml_get_widget$29;
  return_value_glade_xml_get_widget$29=glade_xml_get_widget(appdata.xml, "link_to_spin");
  unsigned long int return_value_gtk_spin_button_get_type$30;
  return_value_gtk_spin_button_get_type$30=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$31;
  return_value_g_type_check_instance_cast$31=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$29, return_value_gtk_spin_button_get_type$30);
  spin = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$31;
  gtk_spin_button_set_value(spin, pref.link_timeout_time / 1000.0);
  struct _GtkWidget *return_value_glade_xml_get_widget$32;
  return_value_glade_xml_get_widget$32=glade_xml_get_widget(appdata.xml, "gui_link_to_spin");
  unsigned long int return_value_gtk_spin_button_get_type$33;
  return_value_gtk_spin_button_get_type$33=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
  return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$32, return_value_gtk_spin_button_get_type$33);
  spin = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$34;
  gtk_spin_button_set_value(spin, pref.gui_link_timeout_time / 1000.0);
  struct _GtkWidget *return_value_glade_xml_get_widget$35;
  return_value_glade_xml_get_widget$35=glade_xml_get_widget(appdata.xml, "proto_link_to_spin");
  unsigned long int return_value_gtk_spin_button_get_type$36;
  return_value_gtk_spin_button_get_type$36=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$37;
  return_value_g_type_check_instance_cast$37=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$35, return_value_gtk_spin_button_get_type$36);
  spin = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$37;
  gtk_spin_button_set_value(spin, pref.proto_link_timeout_time / 1000.0);
  struct _GtkWidget *return_value_glade_xml_get_widget$38;
  return_value_glade_xml_get_widget$38=glade_xml_get_widget(appdata.xml, "proto_to_spin");
  unsigned long int return_value_gtk_spin_button_get_type$39;
  return_value_gtk_spin_button_get_type$39=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$40;
  return_value_g_type_check_instance_cast$40=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$38, return_value_gtk_spin_button_get_type$39);
  spin = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$40;
  gtk_spin_button_set_value(spin, pref.proto_timeout_time / 1000.0);
  widget=glade_xml_get_widget(appdata.xml, "diagram_only_toggle");
  unsigned long int return_value_gtk_toggle_button_get_type$41;
  return_value_gtk_toggle_button_get_type$41=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$42;
  return_value_g_type_check_instance_cast$42=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_toggle_button_get_type$41);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$42, pref.diagram_only);
  widget=glade_xml_get_widget(appdata.xml, "group_unk_check");
  unsigned long int return_value_gtk_toggle_button_get_type$43;
  return_value_gtk_toggle_button_get_type$43=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$44;
  return_value_g_type_check_instance_cast$44=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_toggle_button_get_type$43);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$44, pref.group_unk);
  widget=glade_xml_get_widget(appdata.xml, "name_res_check");
  unsigned long int return_value_gtk_toggle_button_get_type$45;
  return_value_gtk_toggle_button_get_type$45=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$46;
  return_value_g_type_check_instance_cast$46=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_toggle_button_get_type$45);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$46, pref.name_res);
  widget=glade_xml_get_widget(appdata.xml, "stack_level");
  unsigned long int return_value_gtk_combo_box_get_type$47;
  return_value_gtk_combo_box_get_type$47=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$48;
  return_value_g_type_check_instance_cast$48=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_combo_box_get_type$47);
  gtk_combo_box_set_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$48, (signed int)pref.stack_level);
  widget=glade_xml_get_widget(appdata.xml, "size_variable");
  unsigned long int return_value_gtk_combo_box_get_type$49;
  return_value_gtk_combo_box_get_type$49=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$50;
  return_value_g_type_check_instance_cast$50=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_combo_box_get_type$49);
  gtk_combo_box_set_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$50, (signed int)pref.node_size_variable);
  widget=glade_xml_get_widget(appdata.xml, "size_mode");
  unsigned long int return_value_gtk_combo_box_get_type$51;
  return_value_gtk_combo_box_get_type$51=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$52;
  return_value_g_type_check_instance_cast$52=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_combo_box_get_type$51);
  gtk_combo_box_set_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$52, (signed int)pref.size_mode);
  widget=glade_xml_get_widget(appdata.xml, "text_font");
  unsigned long int return_value_gtk_font_button_get_type$53;
  return_value_gtk_font_button_get_type$53=gtk_font_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$54;
  return_value_g_type_check_instance_cast$54=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_font_button_get_type$53);
  gtk_font_button_set_font_name((struct _GtkFontButton *)return_value_g_type_check_instance_cast$54, pref.fontname);
  widget=glade_xml_get_widget(appdata.xml, "text_color");
  signed int return_value_gdk_color_parse$55;
  return_value_gdk_color_parse$55=gdk_color_parse(pref.text_color, &color);
  if(return_value_gdk_color_parse$55 == 0)
    gdk_color_parse("#ffff00", &color);

  unsigned long int return_value_gtk_color_button_get_type$56;
  return_value_gtk_color_button_get_type$56=gtk_color_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$57;
  return_value_g_type_check_instance_cast$57=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_color_button_get_type$56);
  gtk_color_button_set_color((struct _GtkColorButton *)return_value_g_type_check_instance_cast$57, &color);
  widget=glade_xml_get_widget(appdata.xml, "filter_combo");
  unsigned long int return_value_gtk_combo_box_get_type$58;
  return_value_gtk_combo_box_get_type$58=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$59;
  return_value_g_type_check_instance_cast$59=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_combo_box_get_type$58);
  model=gtk_combo_box_get_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$59);
  if(model == ((struct _GtkTreeModel *)NULL))
  {
    struct _GtkListStore *list_store;
    list_store=gtk_list_store_new(1, (unsigned long int)(16 << 2));
    unsigned long int return_value_gtk_combo_box_get_type$60;
    return_value_gtk_combo_box_get_type$60=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$61;
    return_value_g_type_check_instance_cast$61=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_combo_box_get_type$60);
    unsigned long int return_value_gtk_tree_model_get_type$62;
    return_value_gtk_tree_model_get_type$62=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$63;
    return_value_g_type_check_instance_cast$63=g_type_check_instance_cast((struct _GTypeInstance *)list_store, return_value_gtk_tree_model_get_type$62);
    gtk_combo_box_set_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$61, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$63);
  }

  widget=glade_xml_get_widget(appdata.xml, "center_combo");
  unsigned long int return_value_gtk_combo_box_get_type$64;
  return_value_gtk_combo_box_get_type$64=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$65;
  return_value_g_type_check_instance_cast$65=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_combo_box_get_type$64);
  model=gtk_combo_box_get_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$65);
  if(model == ((struct _GtkTreeModel *)NULL))
  {
    struct _GtkListStore *initialize_pref_controls$$1$$2$$list_store;
    initialize_pref_controls$$1$$2$$list_store=gtk_list_store_new(1, (unsigned long int)(16 << 2));
    unsigned long int return_value_gtk_combo_box_get_type$66;
    return_value_gtk_combo_box_get_type$66=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$67;
    return_value_g_type_check_instance_cast$67=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_combo_box_get_type$66);
    unsigned long int return_value_gtk_tree_model_get_type$68;
    return_value_gtk_tree_model_get_type$68=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$69;
    return_value_g_type_check_instance_cast$69=g_type_check_instance_cast((struct _GTypeInstance *)initialize_pref_controls$$1$$2$$list_store, return_value_gtk_tree_model_get_type$68);
    gtk_combo_box_set_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$67, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$69);
  }

  pref_to_color_list();
  widget=glade_xml_get_widget(appdata.xml, "diag_pref");
  struct _GTypeInstance *return_value_g_type_check_instance_cast$70;
  return_value_g_type_check_instance_cast$70=g_type_check_instance_cast((struct _GTypeInstance *)widget, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$70, "delete_event", (void (*)(void))on_cancel_pref_button_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "node_radius_slider");
  unsigned long int return_value_gtk_range_get_type$71;
  return_value_gtk_range_get_type$71=gtk_range_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$72;
  return_value_g_type_check_instance_cast$72=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_range_get_type$71);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$73;
  return_value_g_type_check_instance_cast$73=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkRange *)return_value_g_type_check_instance_cast$72)->adjustment, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$73, "value_changed", (void (*)(void))on_node_radius_slider_adjustment_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "link_width_slider");
  unsigned long int return_value_gtk_range_get_type$74;
  return_value_gtk_range_get_type$74=gtk_range_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$75;
  return_value_g_type_check_instance_cast$75=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_range_get_type$74);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$76;
  return_value_g_type_check_instance_cast$76=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkRange *)return_value_g_type_check_instance_cast$75)->adjustment, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$76, "value_changed", (void (*)(void))on_link_width_slider_adjustment_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "averaging_spin");
  unsigned long int return_value_gtk_spin_button_get_type$77;
  return_value_gtk_spin_button_get_type$77=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$78;
  return_value_g_type_check_instance_cast$78=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_spin_button_get_type$77);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$79;
  return_value_g_type_check_instance_cast$79=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$78)->adjustment, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$79, "value_changed", (void (*)(void))on_averaging_spin_adjustment_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "refresh_spin");
  unsigned long int return_value_gtk_spin_button_get_type$80;
  return_value_gtk_spin_button_get_type$80=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$81;
  return_value_g_type_check_instance_cast$81=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_spin_button_get_type$80);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$82;
  return_value_g_type_check_instance_cast$82=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$81)->adjustment, (unsigned long int)(20 << 2));
  struct _GtkWidget *return_value_glade_xml_get_widget$83;
  return_value_glade_xml_get_widget$83=glade_xml_get_widget(appdata.xml, "canvas1");
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$82, "value_changed", (void (*)(void))on_refresh_spin_adjustment_changed, (void *)return_value_glade_xml_get_widget$83, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "node_to_spin");
  unsigned long int return_value_gtk_spin_button_get_type$84;
  return_value_gtk_spin_button_get_type$84=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$85;
  return_value_g_type_check_instance_cast$85=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_spin_button_get_type$84);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$86;
  return_value_g_type_check_instance_cast$86=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$85)->adjustment, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$86, "value_changed", (void (*)(void))on_node_to_spin_adjustment_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "gui_node_to_spin");
  unsigned long int return_value_gtk_spin_button_get_type$87;
  return_value_gtk_spin_button_get_type$87=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$88;
  return_value_g_type_check_instance_cast$88=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_spin_button_get_type$87);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$89;
  return_value_g_type_check_instance_cast$89=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$88)->adjustment, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$89, "value_changed", (void (*)(void))on_gui_node_to_spin_adjustment_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "proto_node_to_spin");
  unsigned long int return_value_gtk_spin_button_get_type$90;
  return_value_gtk_spin_button_get_type$90=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$91;
  return_value_g_type_check_instance_cast$91=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_spin_button_get_type$90);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$92;
  return_value_g_type_check_instance_cast$92=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$91)->adjustment, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$92, "value_changed", (void (*)(void))on_proto_node_to_spin_adjustment_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "link_to_spin");
  unsigned long int return_value_gtk_spin_button_get_type$93;
  return_value_gtk_spin_button_get_type$93=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$94;
  return_value_g_type_check_instance_cast$94=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_spin_button_get_type$93);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$95;
  return_value_g_type_check_instance_cast$95=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$94)->adjustment, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$95, "value_changed", (void (*)(void))on_link_to_spin_adjustment_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "gui_link_to_spin");
  unsigned long int return_value_gtk_spin_button_get_type$96;
  return_value_gtk_spin_button_get_type$96=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$97;
  return_value_g_type_check_instance_cast$97=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_spin_button_get_type$96);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$98;
  return_value_g_type_check_instance_cast$98=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$97)->adjustment, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$98, "value_changed", (void (*)(void))on_gui_link_to_spin_adjustment_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "proto_link_to_spin");
  unsigned long int return_value_gtk_spin_button_get_type$99;
  return_value_gtk_spin_button_get_type$99=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$100;
  return_value_g_type_check_instance_cast$100=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_spin_button_get_type$99);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$101;
  return_value_g_type_check_instance_cast$101=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$100)->adjustment, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$101, "value_changed", (void (*)(void))on_proto_link_to_spin_adjustment_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "proto_to_spin");
  unsigned long int return_value_gtk_spin_button_get_type$102;
  return_value_gtk_spin_button_get_type$102=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$103;
  return_value_g_type_check_instance_cast$103=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_spin_button_get_type$102);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$104;
  return_value_g_type_check_instance_cast$104=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$103)->adjustment, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$104, "value_changed", (void (*)(void))on_proto_to_spin_adjustment_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "stack_level");
  struct _GTypeInstance *return_value_g_type_check_instance_cast$105;
  return_value_g_type_check_instance_cast$105=g_type_check_instance_cast((struct _GTypeInstance *)widget, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$105, "changed", (void (*)(void))on_stack_level_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "size_variable");
  struct _GTypeInstance *return_value_g_type_check_instance_cast$106;
  return_value_g_type_check_instance_cast$106=g_type_check_instance_cast((struct _GTypeInstance *)widget, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$106, "changed", (void (*)(void))on_size_variable_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "size_mode");
  struct _GTypeInstance *return_value_g_type_check_instance_cast$107;
  return_value_g_type_check_instance_cast$107=g_type_check_instance_cast((struct _GTypeInstance *)widget, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$107, "changed", (void (*)(void))on_size_mode_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "text_font");
  struct _GTypeInstance *return_value_g_type_check_instance_cast$108;
  return_value_g_type_check_instance_cast$108=g_type_check_instance_cast((struct _GTypeInstance *)widget, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$108, "font_set", (void (*)(void))on_text_font_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
  widget=glade_xml_get_widget(appdata.xml, "text_color");
  struct _GTypeInstance *return_value_g_type_check_instance_cast$109;
  return_value_g_type_check_instance_cast$109=g_type_check_instance_cast((struct _GTypeInstance *)widget, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$109, "color_set", (void (*)(void))on_text_color_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
}

// install_handlers
// file main.c line 381
static void install_handlers(void)
{
  void (*return_value_signal$1)(signed int);
  return_value_signal$1=signal(15, cleanup);
  if(return_value_signal$1 == (void (*)(signed int))1)
    signal(15, (void (*)(signed int))1);

  void (*return_value_signal$2)(signed int);
  return_value_signal$2=signal(2, cleanup);
  if(return_value_signal$2 == (void (*)(signed int))1)
    signal(2, (void (*)(signed int))1);

  old_sighup_handler=signal(1, cleanup);
  if(!(old_sighup_handler == ((void (*)(signed int))NULL)))
    signal(1, old_sighup_handler);

  void (*return_value_signal$3)(signed int);
  return_value_signal$3=signal(10, signal_export);
  if(return_value_signal$3 == (void (*)(signed int))1)
    signal(10, (void (*)(signed int))1);

}

// interface_list_create
// file util.c line 72
struct _GList * interface_list_create(struct _GString *err_str)
{
  struct _GList *il = (struct _GList *)(void *)0;
  struct pcap_if *pcap_devlist = (struct pcap_if *)(void *)0;
  struct pcap_if *curdev;
  char pcap_errstr[1024l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  g_string_assign(err_str, "");
  signed int return_value_pcap_findalldevs$1;
  return_value_pcap_findalldevs$1=pcap_findalldevs(&pcap_devlist, pcap_errstr);
  if(!(return_value_pcap_findalldevs$1 >= 0))
  {
    g_string_printf(err_str, "Getting interface list from pcap failed: %s", (const void *)pcap_errstr);
    return (struct _GList *)(void *)0;
  }

  else
  {
    curdev = pcap_devlist;
    for( ; !(curdev == ((struct pcap_if *)NULL)); curdev = curdev->next)
      if(!(curdev->flags == 1u))
      {
        char *return_value_g_strdup$2;
        return_value_g_strdup$2=g_strdup(curdev->name);
        il=g_list_prepend(il, (void *)return_value_g_strdup$2);
      }

    curdev = pcap_devlist;
    for( ; !(curdev == ((struct pcap_if *)NULL)); curdev = curdev->next)
      if(curdev->flags == 1u)
      {
        char *return_value_g_strdup$3;
        return_value_g_strdup$3=g_strdup(curdev->name);
        il=g_list_prepend(il, (void *)return_value_g_strdup$3);
      }

    il=g_list_reverse(il);
    pcap_freealldevs(pcap_devlist);
    return il;
  }
}

// interface_list_free
// file util.c line 128
void interface_list_free(struct _GList *if_list)
{
  if(!(if_list == ((struct _GList *)NULL)))
  {
    g_list_foreach(if_list, interface_list_free_cb, (void *)0);
    g_list_free(if_list);
  }

}

// interface_list_free_cb
// file util.c line 122
static void interface_list_free_cb(void *data, void *user_data)
{
  g_free(data);
}

// ipcache_active_entries
// file ip-cache.h line 62
signed long int ipcache_active_entries(void)
{
  return num_active;
}

// ipcache_alloc_item
// file ip-cache.c line 480
static struct ipcache_item * ipcache_alloc_item(struct anonymous$20 *ip)
{
  struct ipcache_item *rp;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(ip == ((struct anonymous$20 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 484, (const char *)"ipcache_alloc_item", "ip");

  }
  while((_Bool)0);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct ipcache_item) /*104ul*/ );
  rp = (struct ipcache_item *)return_value_malloc$2;
  if(rp == ((struct ipcache_item *)NULL))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    fprintf(stderr, "malloc() failed: %s\n", return_value_strerror$4);
    exit(-1);
  }

  memset((void *)rp, 0, sizeof(struct ipcache_item) /*104ul*/ );
  rp->state = (enum IPCACHE_STATE)IPCACHE_STATE_PTRREQ;
  memmove((void *)&rp->ip, (const void *)ip, sizeof(struct anonymous$20) /*20ul*/ );
  ipcache_linkresolveip(rp);
  struct ipcache_item *return_value_ipcache_findid$5;
  do
  {
    signed long int return_value_time$6;
    return_value_time$6=time((signed long int *)(void *)0);
    idseed = ((idseed + idseed | (signed long int)return_value_time$6) + idseed) - (signed long int)0x54bad4a ^ aseed;
    aseed = aseed ^ idseed;
    rp->id = (unsigned short int)idseed;
    return_value_ipcache_findid$5=ipcache_findid(rp->id);
  }
  while(!(return_value_ipcache_findid$5 == ((struct ipcache_item *)NULL)));
  ipcache_linkresolveid(rp);
  return rp;
}

// ipcache_calc_expire_tick
// file ip-cache.c line 160
static void ipcache_calc_expire_tick(struct ipcache_item *rp, unsigned long int delay, signed int is_request)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(rp == ((struct ipcache_item *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 162, (const char *)"ipcache_calc_expire_tick", "rp");

  }
  while((_Bool)0);
  if(delay >= 86401ul)
    delay = (unsigned long int)86400;

  signed int return_value_rand$2;
  signed int return_value_rand$3;
  if(!(is_request == 0))
  {
    return_value_rand$2=rand();
    rp->expire_tick = delay + current_tick + (unsigned long int)(return_value_rand$2 % 12);
  }

  else
  {
    return_value_rand$3=rand();
    rp->expire_tick = delay + current_tick + (unsigned long int)(return_value_rand$3 % 720);
  }
  rp->last_expire_tick = rp->expire_tick;
}

// ipcache_clear
// file ip-cache.h line 63
void ipcache_clear(void)
{
  while(num_active >= 1l && !(active_list == ((struct ipcache_item *)NULL)))
  {
    struct ipcache_item *rp = active_list->previous_active;
    ipcache_unlinkresolve(rp);
    free((void *)rp);
  }
}

// ipcache_findid
// file ip-cache.c line 429
struct ipcache_item * ipcache_findid(unsigned short int id)
{
  struct ipcache_item *rp;
  signed int bashnum;
  unsigned short int return_value_ipcache_getidbash$1;
  return_value_ipcache_getidbash$1=ipcache_getidbash(id);
  bashnum = (signed int)return_value_ipcache_getidbash$1;
  rp = idbash[(signed long int)bashnum];
  if(!(rp == ((struct ipcache_item *)NULL)))
  {
    for( ; !(rp->nextid == ((struct ipcache_item *)NULL)); rp = rp->nextid)
      if(!((signed int)id >= (signed int)rp->nextid->id))
        break;

    for( ; !(rp->previousid == ((struct ipcache_item *)NULL)); rp = rp->previousid)
      if(!((signed int)rp->previousid->id >= (signed int)id))
        break;

    if(id == rp->id)
    {
      idbash[(signed long int)bashnum] = rp;
      return rp;
    }

    return (struct ipcache_item *)(void *)0;
  }

  else
    return rp;
}

// ipcache_findip
// file ip-cache.c line 454
static struct ipcache_item * ipcache_findip(struct anonymous$20 *ip)
{
  struct ipcache_item *rp;
  unsigned short int bashnum;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(ip == ((struct anonymous$20 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 459, (const char *)"ipcache_findip", "ip");

  }
  while((_Bool)0);
  bashnum=ipcache_getipbash(ip);
  rp = ipbash[(signed long int)bashnum];
  signed int return_value_memcmp$2;
  signed int return_value_memcmp$3;
  if(!(rp == ((struct ipcache_item *)NULL)))
  {
    for( ; !(rp->nextip == ((struct ipcache_item *)NULL)); rp = rp->nextip)
    {
      return_value_memcmp$2=memcmp((const void *)ip, (const void *)&rp->nextip->ip, sizeof(struct anonymous$20) /*20ul*/ );
      if(!(return_value_memcmp$2 >= 0))
        break;

    }
    for( ; !(rp->previousip == ((struct ipcache_item *)NULL)); rp = rp->previousip)
    {
      return_value_memcmp$3=memcmp((const void *)ip, (const void *)&rp->previousip->ip, sizeof(struct anonymous$20) /*20ul*/ );
      if(return_value_memcmp$3 >= 1)
        break;

    }
    signed int return_value_memcmp$4;
    return_value_memcmp$4=memcmp((const void *)ip, (const void *)&rp->ip, sizeof(struct anonymous$20) /*20ul*/ );
    if(return_value_memcmp$4 == 0)
    {
      ipbash[(signed long int)bashnum] = rp;
      return rp;
    }

    else
      return (struct ipcache_item *)(void *)0;
  }

  return rp;
}

// ipcache_getidbash
// file ip-cache.c line 205
static unsigned short int ipcache_getidbash(unsigned short int id)
{
  return (unsigned short int)((signed int)id & 8191);
}

// ipcache_getipbash
// file ip-cache.c line 211
static unsigned short int ipcache_getipbash(struct anonymous$20 *ip)
{
  unsigned int bash;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(ip == ((struct anonymous$20 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 215, (const char *)"ipcache_getipbash", "ip");

  }
  while((_Bool)0);
  bash = ip->$anon0.$anon0.$anon0.addr32[(signed long int)0] ^ ip->$anon0.$anon0.$anon0.addr32[(signed long int)1] ^ ip->$anon0.$anon0.$anon0.addr32[(signed long int)2] ^ ip->$anon0.$anon0.$anon0.addr32[(signed long int)3];
  bash = bash >> 16 ^ bash;
  bash = bash >> 8 ^ bash;
  return (unsigned short int)(bash & (unsigned int)8191);
}

// ipcache_getnameip
// file ip-cache.h line 58
const char * ipcache_getnameip(struct anonymous$20 *ip, signed int *is_expired)
{
  struct ipcache_item *rp;
  struct anonymous$20 iptofind;
  char *return_value_strlongip$1;
  _Bool tmp_if_expr$3;
  if(ip == ((struct anonymous$20 *)NULL))
    return "";

  else
  {
    memmove((void *)&iptofind, (const void *)ip, sizeof(struct anonymous$20) /*20ul*/ );
    if(pref.name_res == 0)
    {
      return_value_strlongip$1=strlongip(ip);
      return return_value_strlongip$1;
    }

    else
    {
      rp=ipcache_findip(&iptofind);
      if(!(rp == ((struct ipcache_item *)NULL)))
      {
        signed int return_value_ipcache_is_expired_tick$2;
        return_value_ipcache_is_expired_tick$2=ipcache_is_expired_tick(rp->expire_tick);
        if(!(return_value_ipcache_is_expired_tick$2 == 0))
          *is_expired = 1;

        else
          *is_expired = 0;
        if((signed int)rp->state == IPCACHE_STATE_FINISHED)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = (signed int)rp->state == IPCACHE_STATE_FAILED ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$3)
        {
          ipcache_link_activelist(rp);
          if((signed int)rp->state == IPCACHE_STATE_FINISHED)
          {
            if(!(rp->fq_hostname == ((char *)NULL)))
              return rp->fq_hostname;

          }

        }

      }

      else
        *is_expired = 1;
      char *return_value_strlongip$4;
      return_value_strlongip$4=strlongip(ip);
      return return_value_strlongip$4;
    }
  }
}

// ipcache_init
// file ip-cache.h line 54
void ipcache_init(void)
{
  signed int i;
  signed long int return_value_time$1;
  return_value_time$1=time((signed long int *)(void *)0);
  signed long int return_value_time$2;
  return_value_time$2=time((signed long int *)(void *)0);
  signed int return_value_getpid$3;
  return_value_getpid$3=getpid();
  aseed = return_value_time$1 ^ return_value_time$2 << 3 ^ (signed long int)(unsigned short int)return_value_getpid$3;
  i = 0;
  for( ; !(i >= 8192); i = i + 1)
  {
    idbash[(signed long int)i] = (struct ipcache_item *)(void *)0;
    ipbash[(signed long int)i] = (struct ipcache_item *)(void *)0;
  }
}

// ipcache_is_expired_tick
// file ip-cache.c line 174
static signed int ipcache_is_expired_tick(unsigned long int tick)
{
  return (signed int)(tick < current_tick);
}

// ipcache_link_activelist
// file ip-cache.c line 265
static void ipcache_link_activelist(struct ipcache_item *rp)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(rp == ((struct ipcache_item *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 272, (const char *)"ipcache_link_activelist", "rp");

  }
  while((_Bool)0);
  if(!(active_list == rp))
  {
    if(active_list == ((struct ipcache_item *)NULL))
    {
      rp->previous_active = rp;
      rp->next_active = rp->previous_active;
      active_list = rp->next_active;
      num_active = (signed long int)1;
    }

    else
    {
      if(rp->next_active == ((struct ipcache_item *)NULL))
        ipcache_purge_activelist();

      else
        ipcache_unlink_activelist(rp);
      rp->next_active = active_list;
      rp->previous_active = active_list->previous_active;
      active_list->previous_active->next_active = rp;
      active_list->previous_active = rp;
      active_list = rp;
      num_active = num_active + 1l;
    }
  }

}

// ipcache_linkresolveid
// file ip-cache.c line 302
static void ipcache_linkresolveid(struct ipcache_item *addrp)
{
  struct ipcache_item *rp;
  unsigned short int bashnum;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(addrp == ((struct ipcache_item *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 307, (const char *)"ipcache_linkresolveid", "addrp");

  }
  while((_Bool)0);
  bashnum=ipcache_getidbash(addrp->id);
  rp = idbash[(signed long int)bashnum];
  if(!(rp == ((struct ipcache_item *)NULL)))
  {
    for( ; !(rp->nextid == ((struct ipcache_item *)NULL)); rp = rp->nextid)
      if((signed int)rp->nextid->id >= (signed int)addrp->id)
        break;

    for( ; !(rp->previousid == ((struct ipcache_item *)NULL)); rp = rp->previousid)
      if((signed int)addrp->id >= (signed int)rp->previousid->id)
        break;

    if(!((signed int)rp->id >= (signed int)addrp->id))
    {
      addrp->previousid = rp;
      addrp->nextid = rp->nextid;
      if(!(rp->nextid == ((struct ipcache_item *)NULL)))
        rp->nextid->previousid = addrp;

      rp->nextid = addrp;
    }

    else
    {
      addrp->previousid = rp->previousid;
      addrp->nextid = rp;
      if(!(rp->previousid == ((struct ipcache_item *)NULL)))
        rp->previousid->nextid = addrp;

      rp->previousid = addrp;
    }
  }

  else
  {
    addrp->previousid = (struct ipcache_item *)(void *)0;
    addrp->nextid = addrp->previousid;
  }
  idbash[(signed long int)bashnum] = addrp;
}

// ipcache_linkresolveip
// file ip-cache.c line 359
static void ipcache_linkresolveip(struct ipcache_item *addrp)
{
  struct ipcache_item *rp;
  unsigned short int bashnum;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(addrp == ((struct ipcache_item *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 364, (const char *)"ipcache_linkresolveip", "addrp");

  }
  while((_Bool)0);
  bashnum=ipcache_getipbash(&addrp->ip);
  rp = ipbash[(signed long int)bashnum];
  signed int return_value_memcmp$2;
  signed int return_value_memcmp$3;
  if(!(rp == ((struct ipcache_item *)NULL)))
  {
    for( ; !(rp->nextip == ((struct ipcache_item *)NULL)); rp = rp->nextip)
    {
      return_value_memcmp$2=memcmp((const void *)&addrp->ip, (const void *)&rp->nextip->ip, sizeof(struct anonymous$20) /*20ul*/ );
      if(!(return_value_memcmp$2 >= 1))
        break;

    }
    for( ; !(rp->previousip == ((struct ipcache_item *)NULL)); rp = rp->previousip)
    {
      return_value_memcmp$3=memcmp((const void *)&addrp->ip, (const void *)&rp->previousip->ip, sizeof(struct anonymous$20) /*20ul*/ );
      if(return_value_memcmp$3 >= 0)
        break;

    }
    signed int return_value_memcmp$4;
    return_value_memcmp$4=memcmp((const void *)&rp->ip, (const void *)&addrp->ip, sizeof(struct anonymous$20) /*20ul*/ );
    if(!(return_value_memcmp$4 >= 0))
    {
      addrp->previousip = rp;
      addrp->nextip = rp->nextip;
      if(!(rp->nextip == ((struct ipcache_item *)NULL)))
        rp->nextip->previousip = addrp;

      rp->nextip = addrp;
    }

    else
    {
      addrp->previousip = rp->previousip;
      addrp->nextip = rp;
      if(!(rp->previousip == ((struct ipcache_item *)NULL)))
        rp->previousip->nextip = addrp;

      rp->previousip = addrp;
    }
  }

  else
  {
    addrp->previousip = (struct ipcache_item *)(void *)0;
    addrp->nextip = addrp->previousip;
  }
  ipbash[(signed long int)bashnum] = addrp;
}

// ipcache_prepare_request
// file ip-cache.h line 57
struct ipcache_item * ipcache_prepare_request(struct anonymous$20 *ip)
{
  struct ipcache_item *rp = (struct ipcache_item *)(void *)0;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(ip == ((struct anonymous$20 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 519, (const char *)"ipcache_prepare_request", "ip");

  }
  while((_Bool)0);
  rp=ipcache_findip(ip);
  if(rp == ((struct ipcache_item *)NULL))
    rp=ipcache_alloc_item(ip);

  if((signed int)rp->state == IPCACHE_STATE_FINISHED || (signed int)rp->state == IPCACHE_STATE_FAILED)
  {
    ipcache_calc_expire_tick(rp, (unsigned long int)18, 1);
    goto __CPROVER_DUMP_L9;
  }

  ipcache_calc_expire_tick(rp, rp->last_expire_tick * (unsigned long int)2, 1);

__CPROVER_DUMP_L9:
  ;
  rp->state = (enum IPCACHE_STATE)IPCACHE_STATE_PTRREQ;
  return rp;
}

// ipcache_purge_activelist
// file ip-cache.c line 249
static void ipcache_purge_activelist(void)
{
  if(num_active >= 11l && !(max_active >= num_active))
    while(num_active >= max_active + -10l && num_active >= 1l && !(active_list == ((struct ipcache_item *)NULL)))
    {
      struct ipcache_item *rp = active_list->previous_active;
      ipcache_unlinkresolve(rp);
      free((void *)rp);
    }

}

// ipcache_request_failed
// file ip-cache.h line 59
void ipcache_request_failed(struct ipcache_item *rp)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(rp == ((struct ipcache_item *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 551, (const char *)"ipcache_request_failed", "rp");

  }
  while((_Bool)0);
  if(!((signed int)rp->state == IPCACHE_STATE_FINISHED))
  {
    rp->state = (enum IPCACHE_STATE)IPCACHE_STATE_FAILED;
    ipcache_calc_expire_tick(rp, (unsigned long int)8640, 0);
    ipcache_link_activelist(rp);
  }

}

// ipcache_request_succeeded
// file ip-cache.h line 60
void ipcache_request_succeeded(struct ipcache_item *rp, signed long int ttl, char *ipname)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(rp == ((struct ipcache_item *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 566, (const char *)"ipcache_request_succeeded", "rp");

  }
  while((_Bool)0);
  rp->state = (enum IPCACHE_STATE)IPCACHE_STATE_FINISHED;
  ipcache_calc_expire_tick(rp, (unsigned long int)(ttl / (signed long int)12), 0);
  if(!(ipname == ((char *)NULL)))
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(ipname);
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(return_value_strlen$2 + (unsigned long int)1);
    rp->fq_hostname = (char *)return_value_malloc$3;
    if(rp->fq_hostname == ((char *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      fprintf(stderr, "malloc() error: %s\n", return_value_strerror$5);
      exit(-1);
    }

    strcpy(rp->fq_hostname, ipname);
  }

  ipcache_link_activelist(rp);
}

// ipcache_tick
// file ip-cache.h line 55
unsigned int ipcache_tick(void)
{
  current_tick = current_tick + 1ul;
  return (unsigned int)1;
}

// ipcache_unlink_activelist
// file ip-cache.c line 224
static void ipcache_unlink_activelist(struct ipcache_item *rp)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(rp == ((struct ipcache_item *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 226, (const char *)"ipcache_unlink_activelist", "rp");

  }
  while((_Bool)0);
  if(!(rp->next_active == ((struct ipcache_item *)NULL)))
  {
    if(rp->next_active == rp)
    {
      active_list = (struct ipcache_item *)(void *)0;
      num_active = (signed long int)0;
    }

    else
    {
      rp->next_active->previous_active = rp->previous_active;
      rp->previous_active->next_active = rp->next_active;
      if(active_list == rp)
        active_list = rp->next_active;

      num_active = num_active - 1l;
    }
  }

}

// ipcache_unlinkresolve
// file ip-cache.c line 417
static void ipcache_unlinkresolve(struct ipcache_item *rp)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(rp == ((struct ipcache_item *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 419, (const char *)"ipcache_unlinkresolve", "rp");

  }
  while((_Bool)0);
  ipcache_unlink_activelist(rp);
  ipcache_unlinkresolveid(rp);
  ipcache_unlinkresolveip(rp);
  if(!(rp->fq_hostname == ((char *)NULL)))
    free((void *)rp->fq_hostname);

}

// ipcache_unlinkresolveid
// file ip-cache.c line 339
static void ipcache_unlinkresolveid(struct ipcache_item *rp)
{
  unsigned short int bashnum;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(rp == ((struct ipcache_item *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 343, (const char *)"ipcache_unlinkresolveid", "rp");

  }
  while((_Bool)0);
  bashnum=ipcache_getidbash(rp->id);
  if(idbash[(signed long int)bashnum] == rp)
  {
    if(!(rp->previousid == ((struct ipcache_item *)NULL)))
      idbash[(signed long int)bashnum] = rp->previousid;

    else
      idbash[(signed long int)bashnum] = rp->nextid;
  }

  if(!(rp->nextid == ((struct ipcache_item *)NULL)))
    rp->nextid->previousid = rp->previousid;

  if(!(rp->previousid == ((struct ipcache_item *)NULL)))
    rp->previousid->nextid = rp->nextid;

}

// ipcache_unlinkresolveip
// file ip-cache.c line 396
static void ipcache_unlinkresolveip(struct ipcache_item *rp)
{
  unsigned short int bashnum;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(rp == ((struct ipcache_item *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 400, (const char *)"ipcache_unlinkresolveip", "rp");

  }
  while((_Bool)0);
  bashnum=ipcache_getipbash(&rp->ip);
  if(ipbash[(signed long int)bashnum] == rp)
  {
    if(!(rp->previousip == ((struct ipcache_item *)NULL)))
      ipbash[(signed long int)bashnum] = rp->previousip;

    else
      ipbash[(signed long int)bashnum] = rp->nextip;
  }

  if(!(rp->nextip == ((struct ipcache_item *)NULL)))
    rp->nextip->previousip = rp->previousip;

  if(!(rp->previousip == ((struct ipcache_item *)NULL)))
    rp->previousip->nextip = rp->nextip;

}

// ipv4_to_str
// file util.c line 200
const char * ipv4_to_str(const unsigned char *ad)
{
  const char *return_value_inet_ntop$1;
  static char buf[46l];
  return_value_inet_ntop$1=inet_ntop(2, (const void *)ad, buf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
  if(return_value_inet_ntop$1 == ((const char *)NULL))
    return "<invalid IPv4 address>";

  else
    return buf;
}

// ipv6_to_str
// file util.c line 313
const char * ipv6_to_str(const unsigned char *ad)
{
  if(ad == ((const unsigned char *)NULL))
    return "<null addr>";

  else
  {
    const char *return_value_inet_ntop$1;
    static char buf[46l];
    return_value_inet_ntop$1=inet_ntop(10, (const void *)ad, buf, (unsigned int)sizeof(char [46l]) /*46ul*/ );
    if(return_value_inet_ntop$1 == ((const char *)NULL))
      return "<invalid IPv6 address>";

    else
      return buf;
  }
}

// limit_nodes
// file diagram.c line 840
static void limit_nodes(void)
{
  displayed_nodes = (unsigned int)0;
  if(!(appdata.node_limit >= 0))
  {
    signed int return_value_g_tree_nnodes$1;
    return_value_g_tree_nnodes$1=g_tree_nnodes(canvas_nodes);
    displayed_nodes = (unsigned int)return_value_g_tree_nnodes$1;
    goto __CPROVER_DUMP_L2;
  }

  static unsigned int limit;
  limit = (unsigned int)appdata.node_limit;
  static struct _GTree *ordered_nodes = (struct _GTree *)(void *)0;
  ordered_nodes=g_tree_new(traffic_compare);
  g_tree_foreach(canvas_nodes, (signed int (*)(void *, void *, void *))add_ordered_node, (void *)ordered_nodes);
  g_tree_foreach(ordered_nodes, (signed int (*)(void *, void *, void *))check_ordered_node, (void *)&limit);
  g_tree_destroy(ordered_nodes);
  ordered_nodes = (struct _GTree *)(void *)0;

__CPROVER_DUMP_L2:
  ;
}

// link_create
// file links.c line 83
struct anonymous$28 * link_create(const struct anonymous$16 *link_id)
{
  struct anonymous$28 *link;
  unsigned int i = (unsigned int)5;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(sizeof(struct anonymous$28) /*344ul*/ );
  link = (struct anonymous$28 *)return_value_g_malloc$1;
  signed int tmp_statement_expression$2;
  do
  {
    signed int _g_boolean_var_;
    if(!(link == ((struct anonymous$28 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$2 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "links.c", 89, (const char *)"link_create", "link");

  }
  while((_Bool)0);
  link->link_id = *link_id;
  for( ; !(i == 4294967295u); i = i - 1u)
    link->main_prot[(signed long int)i] = (char *)(void *)0;
  traffic_stats_init(&link->link_stats);
  return link;
}

// link_delete
// file links.c line 105
void link_delete(struct anonymous$28 *link)
{
  unsigned int i;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(link == ((struct anonymous$28 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "links.c", 109, (const char *)"link_delete", "link");

  }
  while((_Bool)0);
  delete_conversation_link(&link->link_id.src.addr.ip, &link->link_id.dst.addr.ip);
  i = (unsigned int)5;
  for( ; !(i == 4294967295u); i = i - 1u)
    if(!(link->main_prot[(signed long int)i] == ((char *)NULL)))
    {
      g_free((void *)link->main_prot[(signed long int)i]);
      link->main_prot[(signed long int)i] = (char *)(void *)0;
    }

  traffic_stats_reset(&link->link_stats);
  g_free((void *)link);
}

// link_dump
// file links.c line 127
char * link_dump(const struct anonymous$28 *link)
{
  char *msg;
  char *msg_idsrc;
  char *msg_iddst;
  char *msg_stats;
  char *msg_mprot;
  unsigned int i;
  char *return_value_g_strdup$1;
  char *tmp_if_expr$2;
  char *tmp_if_expr$3;
  if(link == ((const struct anonymous$28 *)NULL))
  {
    return_value_g_strdup$1=g_strdup("link_t NULL");
    return return_value_g_strdup$1;
  }

  else
  {
    msg_idsrc=node_id_dump(&link->link_id.src);
    msg_iddst=node_id_dump(&link->link_id.dst);
    msg_stats=traffic_stats_dump(&link->link_stats);
    if(!(link->main_prot[0l] == ((char *)NULL)))
      tmp_if_expr$2 = link->main_prot[(signed long int)0];

    else
      tmp_if_expr$2 = "-none-";
    msg_mprot=g_strdup_printf("top: [%s], stack:", tmp_if_expr$2);
    i = (unsigned int)1;
    for( ; !(i >= 6u); i = i + 1u)
    {
      char *tmp = msg_mprot;
      if(!(link->main_prot[(signed long int)i] == ((char *)NULL)))
        tmp_if_expr$3 = link->main_prot[(signed long int)i];

      else
        tmp_if_expr$3 = "-none-";
      msg_mprot=g_strdup_printf("%s %d:>%s<", msg_mprot, i, tmp_if_expr$3);
      g_free((void *)tmp);
    }
    msg=g_strdup_printf("src: %s, dst: %s, main_prot: [%s], stats [%s]", msg_idsrc, msg_iddst, msg_mprot, msg_stats);
    g_free((void *)msg_idsrc);
    g_free((void *)msg_iddst);
    g_free((void *)msg_stats);
    g_free((void *)msg_mprot);
    return msg;
  }
}

// link_dump_tvs
// file links.c line 361
static signed int link_dump_tvs(void *key, void *value, void *data)
{
  char *msg_link;
  char *tmp;
  char **msg = (char **)data;
  const struct anonymous$28 *link = (const struct anonymous$28 *)value;
  msg_link=link_dump(link);
  tmp = *msg;
  *msg=g_strdup_printf("%slink %p:\n%s\n", tmp, link, msg_link);
  g_free((void *)tmp);
  g_free((void *)msg_link);
  return 0;
}

// link_id_compare
// file links.h line 32
signed int link_id_compare(const struct anonymous$16 *a, const struct anonymous$16 *b)
{
  signed int i;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(a == ((const struct anonymous$16 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"link_id_compare", "a != NULL");
      return 1;
    }

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int link_id_compare$$1$$2$$1$$_g_boolean_var_;
    if(!(b == ((const struct anonymous$16 *)NULL)))
      link_id_compare$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      link_id_compare$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = link_id_compare$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
    {
      g_return_if_fail_warning((char *)0, (const char *)"link_id_compare", "b != NULL");
      return 1;
    }

  }
  while((_Bool)0);
  i=node_id_compare(&a->src, &b->src);
  if(!(i == 0))
    return i;

  else
  {
    signed int return_value_node_id_compare$3;
    return_value_node_id_compare$3=node_id_compare(&a->dst, &b->dst);
    return return_value_node_id_compare$3;
  }
}

// link_id_node_names
// file links.h line 34
char * link_id_node_names(const struct anonymous$16 *link_id)
{
  const struct anonymous$19 *src_node;
  const struct anonymous$19 *dst_node;
  src_node=nodes_catalog_find(&link_id->src);
  dst_node=nodes_catalog_find(&link_id->dst);
  _Bool tmp_if_expr$2;
  if(dst_node == ((const struct anonymous$19 *)NULL) || src_node == ((const struct anonymous$19 *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(src_node->name->str != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = !(dst_node->name->str != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  char *return_value_g_strdup$1;
  if(tmp_if_expr$3)
  {
    return_value_g_strdup$1=g_strdup("");
    return return_value_g_strdup$1;
  }

  else
  {
    char *return_value_g_strdup_printf$4;
    return_value_g_strdup_printf$4=g_strdup_printf("%s-%s", src_node->name->str, dst_node->name->str);
    return return_value_g_strdup_printf$4;
  }
}

// link_info_window_compare
// file info_windows.c line 938
static signed int link_info_window_compare(const void *a, const void *b)
{
  const struct anonymous$16 *id_a;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(a == NULL))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "info_windows.c", 941, (const char *)"link_info_window_compare", "a != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int link_info_window_compare$$1$$2$$1$$_g_boolean_var_;
    if(!(b == NULL))
      link_info_window_compare$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      link_info_window_compare$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = link_info_window_compare$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "info_windows.c", 942, (const char *)"link_info_window_compare", "b != NULL");

  }
  while((_Bool)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)a, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$4;
  return_value_g_object_get_data$4=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$3, "link_id");
  id_a = (const struct anonymous$16 *)return_value_g_object_get_data$4;
  if(id_a == ((const struct anonymous$16 *)NULL))
    return -1;

  else
  {
    signed int return_value_link_id_compare$5;
    return_value_link_id_compare$5=link_id_compare(id_a, (const struct anonymous$16 *)b);
    return return_value_link_id_compare$5;
  }
}

// link_info_window_create
// file info_windows.h line 28
void link_info_window_create(const struct anonymous$16 *link_id)
{
  struct _GtkWidget *window;
  struct _GList *list_item;
  list_item=g_list_find_custom(stats_info_windows, (const void *)link_id, link_info_window_compare);
  if(list_item == ((struct _GList *)NULL))
  {
    void *return_value_g_memdup$1;
    return_value_g_memdup$1=g_memdup((const void *)link_id, (unsigned int)sizeof(struct anonymous$16) /*56ul*/ );
    window=stats_info_create("link_id", return_value_g_memdup$1);
    if(window == ((struct _GtkWidget *)NULL))
      goto __CPROVER_DUMP_L4;

  }

  else
    window = (struct _GtkWidget *)list_item->data;
  update_link_info_window(window);

__CPROVER_DUMP_L4:
  ;
}

// link_item_event
// file diagram.c line 1333
static signed int link_item_event(struct _GnomeCanvasItem *item, union _GdkEvent *event, struct anonymous$80 *canvas_link)
{
  char *str;
  const struct anonymous$28 *link = (const struct anonymous$28 *)(void *)0;
  _Bool tmp_if_expr$3;
  char *return_value_dcgettext$1;
  char *return_value_dcgettext$2;
  switch((signed int)event->type)
  {
    case GDK_2BUTTON_PRESS:
    {
      if(!(canvas_link == ((struct anonymous$80 *)NULL)))
        link_info_window_create(&canvas_link->canvas_link_id);

      break;
    }
    case GDK_ENTER_NOTIFY:
    {
      if(!(canvas_link == ((struct anonymous$80 *)NULL)))
        link=links_catalog_find(&canvas_link->canvas_link_id);

      if(!(link == ((const struct anonymous$28 *)NULL)))
        tmp_if_expr$3 = link->main_prot[(signed long int)pref.stack_level] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
      {
        return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Link main protocol: %s", 5);
        str=g_strdup_printf(return_value_dcgettext$1, link->main_prot[(signed long int)pref.stack_level]);
      }

      else
      {
        return_value_dcgettext$2=dcgettext((const char *)(void *)0, "Link main protocol unknown", 5);
        str=g_strdup_printf(return_value_dcgettext$2);
      }
      gtk_statusbar_push(appdata.statusbar, (unsigned int)1, str);
      g_free((void *)str);
      break;
    }
    case GDK_LEAVE_NOTIFY:
    {
      gtk_statusbar_pop(appdata.statusbar, (unsigned int)1);
      break;
    }
    default:
      ;
  }
  return 0;
}

// links_catalog_add_packet
// file links.h line 60
void links_catalog_add_packet(const struct anonymous$16 *link_id, struct anonymous$6 *packet, enum anonymous$7 direction)
{
  struct anonymous$28 *link;
  link=links_catalog_find_create(link_id);
  traffic_stats_add_packet(&link->link_stats, packet, direction);
}

// links_catalog_close
// file links.h line 51
void links_catalog_close(void)
{
  if(!(all_links == ((struct _GTree *)NULL)))
  {
    g_tree_destroy(all_links);
    all_links = (struct _GTree *)(void *)0;
  }

}

// links_catalog_compare
// file links.c line 227
static signed int links_catalog_compare(const void *a, const void *b, void *dummy)
{
  signed int return_value_link_id_compare$1;
  return_value_link_id_compare$1=link_id_compare((const struct anonymous$16 *)a, (const struct anonymous$16 *)b);
  return return_value_link_id_compare$1;
}

// links_catalog_dump
// file links.c line 376
char * links_catalog_dump(void)
{
  char *msg;
  msg=g_strdup("");
  links_catalog_foreach(link_dump_tvs, (void *)&msg);
  return msg;
}

// links_catalog_find
// file links.h line 54
struct anonymous$28 * links_catalog_find(const struct anonymous$16 *key)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(key == ((const struct anonymous$16 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "links.c", 281, (const char *)"links_catalog_find", "key");

  }
  while((_Bool)0);
  if(all_links == ((struct _GTree *)NULL))
    return (struct anonymous$28 *)(void *)0;

  else
  {
    void *return_value_g_tree_lookup$2;
    return_value_g_tree_lookup$2=g_tree_lookup(all_links, (const void *)key);
    return (struct anonymous$28 *)return_value_g_tree_lookup$2;
  }
}

// links_catalog_find_create
// file links.c line 289
struct anonymous$28 * links_catalog_find_create(const struct anonymous$16 *key)
{
  struct anonymous$28 *link;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(all_links == ((struct _GTree *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "links.c", 292, (const char *)"links_catalog_find_create", "all_links");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int links_catalog_find_create$$1$$2$$1$$_g_boolean_var_;
    if(!(key == ((const struct anonymous$16 *)NULL)))
      links_catalog_find_create$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      links_catalog_find_create$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = links_catalog_find_create$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "links.c", 293, (const char *)"links_catalog_find_create", "key");

  }
  while((_Bool)0);
  link=links_catalog_find(key);
  if(link == ((struct anonymous$28 *)NULL))
  {
    link=link_create(key);
    links_catalog_insert(link);
  }

  return link;
}

// links_catalog_foreach
// file links.h line 57
void links_catalog_foreach(signed int (*func)(void *, void *, void *), void *data)
{
  if(!(all_links == ((struct _GTree *)NULL)))
    g_tree_foreach(all_links, func, data);

}

// links_catalog_insert
// file links.c line 251
void links_catalog_insert(struct anonymous$28 *new_link)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(all_links == ((struct _GTree *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "links.c", 253, (const char *)"links_catalog_insert", "all_links");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int links_catalog_insert$$1$$2$$1$$_g_boolean_var_;
    if(!(new_link == ((struct anonymous$28 *)NULL)))
      links_catalog_insert$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      links_catalog_insert$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = links_catalog_insert$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "links.c", 254, (const char *)"links_catalog_insert", "new_link");

  }
  while((_Bool)0);
  g_tree_insert(all_links, (void *)&new_link->link_id, (void *)new_link);
  if(!((G_LOG_LEVEL_DEBUG & (signed int)appdata.debug_mask) == 0))
  {
    char *str;
    str=link_id_node_names(&new_link->link_id);
    char *return_value_dcgettext$3;
    return_value_dcgettext$3=dcgettext((const char *)(void *)0, "New link: %s. Number of links %d", 5);
    signed int return_value_links_catalog_size$4;
    return_value_links_catalog_size$4=links_catalog_size();
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$3, str, return_value_links_catalog_size$4);
    g_free((void *)str);
  }

}

// links_catalog_open
// file links.h line 50
void links_catalog_open(void)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(all_links == ((struct _GTree *)NULL))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "links.c", 235, (const char *)"links_catalog_open", "!all_links");

  }
  while((_Bool)0);
  all_links=g_tree_new_full(links_catalog_compare, (void *)0, (void (*)(void *))(void *)0, (void (*)(void *))link_delete);
}

// links_catalog_remove
// file links.c line 270
void links_catalog_remove(const struct anonymous$16 *key)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(all_links == ((struct _GTree *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "links.c", 272, (const char *)"links_catalog_remove", "all_links");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int links_catalog_remove$$1$$2$$1$$_g_boolean_var_;
    if(!(key == ((const struct anonymous$16 *)NULL)))
      links_catalog_remove$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      links_catalog_remove$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = links_catalog_remove$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "links.c", 273, (const char *)"links_catalog_remove", "key");

  }
  while((_Bool)0);
  g_tree_remove(all_links, (const void *)key);
}

// links_catalog_size
// file links.h line 56
signed int links_catalog_size(void)
{
  if(all_links == ((struct _GTree *)NULL))
    return 0;

  else
  {
    signed int return_value_g_tree_nnodes$1;
    return_value_g_tree_nnodes$1=g_tree_nnodes(all_links);
    return return_value_g_tree_nnodes$1;
  }
}

// links_catalog_update_all
// file links.h line 58
void links_catalog_update_all(void)
{
  struct _GList *delete_list = (struct _GList *)(void *)0;
  if(!(all_links == ((struct _GTree *)NULL)))
  {
    links_catalog_foreach((signed int (*)(void *, void *, void *))update_link, (void *)&delete_list);
    g_list_foreach(delete_list, gfunc_remove_link, (void *)0);
    g_list_free(delete_list);
    char *return_value_dcgettext$1;
    return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Updated links. Active links %d", 5);
    signed int return_value_links_catalog_size$2;
    return_value_links_catalog_size$2=links_catalog_size();
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, return_value_dcgettext$1, return_value_links_catalog_size$2);
  }

}

// load_config
// file preferences.c line 173
void load_config(void)
{
  char *pref_file;
  char *tmpstr = (char *)(void *)0;
  char **colorarray;
  struct _GKeyFile *gkey;
  set_default_config(&pref);
  gkey=g_key_file_new();
  pref_file=config_file_name();
  signed int return_value_g_key_file_load_from_file$2;
  return_value_g_key_file_load_from_file$2=g_key_file_load_from_file(gkey, pref_file, (enum anonymous$71)G_KEY_FILE_NONE, (struct _GError **)(void *)0);
  if(return_value_g_key_file_load_from_file$2 == 0)
  {
    g_free((void *)pref_file);
    pref_file=old_config_file_name();
    signed int return_value_g_key_file_load_from_file$1;
    return_value_g_key_file_load_from_file$1=g_key_file_load_from_file(gkey, pref_file, (enum anonymous$71)G_KEY_FILE_NONE, (struct _GError **)(void *)0);
    if(return_value_g_key_file_load_from_file$1 == 0)
    {
      g_free((void *)pref_file);
      goto __CPROVER_DUMP_L5;
    }

  }

  g_free((void *)pref_file);
  read_string_config(&pref.filter, gkey, "filter");
  read_string_config(&pref.fontname, gkey, "fontname");
  read_string_config(&pref.text_color, gkey, "text_color");
  read_string_config(&pref.center_node, gkey, "center_node");
  read_boolean_config(&pref.diagram_only, gkey, "diagram_only");
  read_boolean_config(&pref.group_unk, gkey, "group_unk");
  read_boolean_config(&pref.stationary, gkey, "stationary");
  read_boolean_config(&pref.name_res, gkey, "name_res");
  read_int_config((signed int *)&pref.refresh_period, gkey, "refresh_period");
  read_int_config((signed int *)&pref.size_mode, gkey, "size_mode");
  read_int_config((signed int *)&pref.node_size_variable, gkey, "node_size_variable");
  read_int_config((signed int *)&pref.stack_level, gkey, "stack_level");
  read_double_config(&pref.node_timeout_time, gkey, "node_timeout_time");
  read_double_config(&pref.gui_node_timeout_time, gkey, "gui_node_timeout_time");
  read_double_config(&pref.proto_node_timeout_time, gkey, "proto_node_timeout_time");
  read_double_config(&pref.link_timeout_time, gkey, "link_timeout_time");
  read_double_config(&pref.gui_link_timeout_time, gkey, "gui_link_timeout_time");
  read_double_config(&pref.proto_link_timeout_time, gkey, "proto_link_timeout_time");
  read_double_config(&pref.proto_timeout_time, gkey, "proto_timeout_time");
  read_double_config(&pref.averaging_time, gkey, "averaging_time");
  read_double_config(&pref.node_radius_multiplier, gkey, "node_radius_multiplier");
  read_double_config(&pref.link_node_ratio, gkey, "link_node_ratio");
  read_string_config(&tmpstr, gkey, "colors");
  if(!(tmpstr == ((char *)NULL)))
  {
    colorarray=g_strsplit(tmpstr, " ", 0);
    if(!(colorarray == ((char **)NULL)))
    {
      g_strfreev(pref.colors);
      pref.colors=protohash_compact(colorarray);
      protohash_read_prefvect(pref.colors);
    }

    g_free((void *)tmpstr);
  }

  g_key_file_free(gkey);

__CPROVER_DUMP_L5:
  ;
}

// log_handler
// file main.c line 326
static void log_handler(char *log_domain, enum anonymous$30 mask, const char *message, void *user_data)
{
  if(!(((signed int)appdata.debug_mask & (signed int)mask) == 0))
    g_log_default_handler("EtherApe", mask, message, user_data);

}

// main
// file main.c line 74
signed int main(signed int argc, char **argv)
{
  struct _GtkWidget *widget;
  struct _GnomeClient *client;
  char *mode_string = (char *)(void *)0;
  char *cl_filter = (char *)(void *)0;
  char *cl_interface = (char *)(void *)0;
  char *cl_input_file = (char *)(void *)0;
  char *export_file_final = (char *)(void *)0;
  char *export_file_signal = (char *)(void *)0;
  signed int cl_numeric = 0;
  signed long int midelay = (signed long int)0;
  signed long int madelay = 0x7fffffffffffffffL;
  char *version;
  char *cl_glade_file = (char *)(void *)0;
  struct poptContext_s *poptcon;
  struct poptOption optionsTable[16l] = { { .longName="diagram-only", .shortName=(char)100, .argInfo=0U,
    .arg=(void *)&pref.diagram_only, .val=0,
    .descrip="don't display any node text identification", .argDescrip=(const char *)(void *)0 }, 
    { .longName="replay-file", .shortName=(char)114, .argInfo=1U,
    .arg=(void *)&cl_input_file, .val=0,
    .descrip="replay packets from file", .argDescrip="<file to replay>" }, 
    { .longName="filter", .shortName=(char)102, .argInfo=1U,
    .arg=(void *)&cl_filter, .val=0,
    .descrip="set capture filter", .argDescrip="<capture filter>" }, 
    { .longName="interface", .shortName=(char)105, .argInfo=1U,
    .arg=(void *)&cl_interface, .val=0,
    .descrip="set interface to listen to", .argDescrip="<interface name>" }, 
    { .longName="final-export", .shortName=(char)0, .argInfo=1U,
    .arg=(void *)&export_file_final, .val=0,
    .descrip="export to named file at end of replay", .argDescrip="<file to export to>" }, 
    { .longName="signal-export", .shortName=(char)0, .argInfo=1U,
    .arg=(void *)&export_file_signal, .val=0,
    .descrip="export to named file on receiving USR1", .argDescrip="<file to export to>" }, 
    { .longName="stationary", .shortName=(char)115, .argInfo=0U,
    .arg=(void *)&pref.stationary, .val=0,
    .descrip="don't move nodes around (deprecated)", .argDescrip=(const char *)(void *)0 }, 
    { .longName="node-limit", .shortName=(char)108, .argInfo=2U,
    .arg=(void *)&appdata.node_limit, .val=0,
    .descrip="limits nodes displayed", .argDescrip="<number of nodes>" }, 
    { .longName="mode", .shortName=(char)109, .argInfo=1U,
    .arg=(void *)&mode_string, .val=0,
    .descrip="mode of operation", .argDescrip="<link|ip|tcp>" }, 
    { .longName="numeric", .shortName=(char)110, .argInfo=0U,
    .arg=(void *)&cl_numeric, .val=0,
    .descrip="don't convert addresses to names", .argDescrip=(const char *)(void *)0 }, 
    { .longName="quiet", .shortName=(char)113, .argInfo=0U,
    .arg=(void *)&quiet, .val=0, .descrip="Disable informational messages",
    .argDescrip=(const char *)(void *)0 }, 
    { .longName="min-delay", .shortName=(char)0, .argInfo=3U,
    .arg=(void *)&midelay, .val=0, .descrip="minimum packet delay in ms for reading capture files [cli only]",
    .argDescrip="<delay>" }, 
    { .longName="max-delay", .shortName=(char)0, .argInfo=3U,
    .arg=(void *)&madelay, .val=0, .descrip="maximum packet delay in ms for reading capture files [cli only]",
    .argDescrip="<delay>" }, 
    { .longName="glade-file", .shortName=(char)0, .argInfo=1U,
    .arg=(void *)&cl_glade_file, .val=0,
    .descrip="uses the named libglade file for widgets", .argDescrip="<glade file>" }, 
    { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=4U,
    .arg=(void *)poptHelpOptions, .val=0,
    .descrip="Help options:", .argDescrip=(const char *)(void *)0 }, 
    { .longName=(const char *)(void *)0, .shortName=(char)0, .argInfo=(unsigned int)0,
    .arg=(void *)0, .val=0,
    .descrip=(const char *)(void *)0, .argDescrip=(const char *)(void *)0 } };
  bindtextdomain("etherape", "/usr/share/locale");
  bind_textdomain_codeset("etherape", "UTF-8");
  textdomain("etherape");
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("GNOME_DESKTOP_ICON");
  if(return_value_getenv$1 == ((char *)NULL))
    putenv("GNOME_DESKTOP_ICON=/usr/share/pixmaps/etherape.png");

  version=g_strdup("0.9.13");
  const struct _GnomeModuleInfo *return_value_libgnomeui_module_info_get$2;
  return_value_libgnomeui_module_info_get$2=libgnomeui_module_info_get();
  gnome_program_init("EtherApe", version, return_value_libgnomeui_module_info_get$2, argc, argv, "popt-table", (const void *)optionsTable, (void *)0);
  g_free((void *)version);
  appdata_init(&appdata);
  init_config(&pref);
  set_debug_level();
  load_config();
  cl_numeric = (signed int)!(pref.name_res != 0);
  poptcon=poptGetContext("Etherape", argc, (const char **)argv, optionsTable, (unsigned int)0);
  signed int return_value_poptGetNextOpt$3;
  do
  {
    return_value_poptGetNextOpt$3=poptGetNextOpt(poptcon);
    if(!(return_value_poptGetNextOpt$3 >= 1))
      break;

  }
  while((_Bool)1);
  if(!(cl_interface == ((char *)NULL)))
  {
    if(!(appdata.interface == ((char *)NULL)))
      g_free((void *)appdata.interface);

    appdata.interface=g_strdup(cl_interface);
  }

  if(!(export_file_final == ((char *)NULL)))
  {
    if(!(appdata.export_file_final == ((char *)NULL)))
      g_free((void *)appdata.export_file_final);

    appdata.export_file_final=g_strdup(export_file_final);
  }

  if(!(export_file_signal == ((char *)NULL)))
  {
    if(!(appdata.export_file_signal == ((char *)NULL)))
      g_free((void *)appdata.export_file_signal);

    appdata.export_file_signal=g_strdup(export_file_signal);
  }

  pref.name_res = (signed int)!(cl_numeric != 0);
  if(!(cl_input_file == ((char *)NULL)))
  {
    if(!(appdata.input_file == ((char *)NULL)))
      g_free((void *)appdata.input_file);

    appdata.input_file=g_strdup(cl_input_file);
  }

  char *return_value_strstr$6;
  char *return_value_strstr$5;
  char *return_value_dcgettext$4;
  if(!(mode_string == ((char *)NULL)))
  {
    char *return_value_strstr$7;
    return_value_strstr$7=strstr(mode_string, "link");
    if(!(return_value_strstr$7 == ((char *)NULL)))
      appdata.mode = (enum anonymous$13)LINK6;

    else
    {
      return_value_strstr$6=strstr(mode_string, "ip");
      if(!(return_value_strstr$6 == ((char *)NULL)))
        appdata.mode = (enum anonymous$13)IP;

      else
      {
        return_value_strstr$5=strstr(mode_string, "tcp");
        if(!(return_value_strstr$5 == ((char *)NULL)))
          appdata.mode = (enum anonymous$13)TCP;

        else
        {
          return_value_dcgettext$4=dcgettext((const char *)(void *)0, "Unrecognized mode. Do etherape --help for a list of modes", 5);
          g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$4);
        }
      }
    }
    g_free((void *)pref.filter);
    pref.filter=get_default_filter(appdata.mode);
  }

  if(!(cl_filter == ((char *)NULL)))
  {
    if(!(pref.filter == ((char *)NULL)))
      g_free((void *)pref.filter);

    pref.filter=g_strdup(cl_filter);
  }

  if(midelay >= 0l)
  {
    appdata.min_delay = (unsigned long int)midelay;
    if(!(appdata.min_delay == 0ul))
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_MESSAGE, "Minimum delay set to %lu ms", appdata.min_delay);

  }

  else
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_MESSAGE, "Invalid minimum delay %ld, ignored", midelay);
  if(madelay >= 0l)
  {
    if(!((unsigned long int)madelay >= appdata.min_delay))
    {
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_MESSAGE, "Maximum delay must be less of minimum delay");
      appdata.max_delay = appdata.min_delay;
    }

    else
      appdata.max_delay = (unsigned long int)madelay;
    if(!(appdata.max_delay == 9223372036854775807ul))
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_MESSAGE, "Maximum delay set to %lu ms", appdata.max_delay);

  }

  else
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_MESSAGE, "Invalid maximum delay %ld, ignored", madelay);
  glade_init();
  glade_require("gnome");
  glade_require("canvas");
  signed int return_value_appdata_init_glade$8;
  return_value_appdata_init_glade$8=appdata_init_glade(cl_glade_file);
  if(return_value_appdata_init_glade$8 == 0)
    return 1;

  else
  {
    services_init();
    init_diagram(appdata.xml);
    client=gnome_master_client();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)client, (unsigned long int)(20 << 2));
    g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$9, "save_yourself", (void (*)(void))save_session, (void *)argv[(signed long int)0], (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)client, (unsigned long int)(20 << 2));
    g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$10, "die", (void (*)(void))session_die, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$65)0);
    gtk_widget_show(appdata.app1);
    install_handlers();
    widget=glade_xml_get_widget(appdata.xml, "canvas1");
    destroying_idle((void *)widget);
    g_timeout_add((unsigned int)500, (signed int (*)(void *))update_info_windows, (void *)0);
    g_timeout_add((unsigned int)10000, (signed int (*)(void *))ipcache_tick, (void *)0);
    init_menus();
    gui_start_capture();
    gtk_main();
    free_static_data();
    return 0;
  }
}

// manuf_name_lookup
// file resolv.c line 374
static const struct hashmanuf * manuf_name_lookup(const unsigned char *addr)
{
  struct hashmanuf *tp;
  struct hashmanuf **table = manuf_table;
  tp = table[(signed long int)((signed int)addr[(signed long int)2] & 256 - 1)];
  while(!(tp == ((struct hashmanuf *)NULL)))
  {
    signed int return_value_memcmp$1;
    return_value_memcmp$1=memcmp((const void *)tp->addr, (const void *)addr, sizeof(unsigned char [3l]) /*3ul*/ );
    if(return_value_memcmp$1 == 0)
      return tp;

    tp = tp->next;
  }
  return (const struct hashmanuf *)(void *)0;
}

// missing_data_msg
// file names.c line 104
static void missing_data_msg(const struct anonymous$9 *nt, const char *pr)
{
  char *return_value_dcgettext$1;
  char *return_value_dcgettext$2;
  if(!(pr == ((const char *)NULL)))
  {
    return_value_dcgettext$1=dcgettext((const char *)(void *)0, "not enough captured data, terminating protocol decode for '%s' (level %d)", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$1, pr, nt->decoder.level);
  }

  else
  {
    return_value_dcgettext$2=dcgettext((const char *)(void *)0, "not enough captured data, terminating protocol decode at level %d", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$2, nt->decoder.level);
  }
}

// new_nodes_add
// file node.h line 45
void new_nodes_add(struct anonymous$19 *node)
{
  new_nodes=g_list_prepend(new_nodes, (void *)node);
}

// new_nodes_clear
// file node.h line 44
void new_nodes_clear(void)
{
  g_list_free(new_nodes);
  new_nodes = (struct _GList *)(void *)0;
}

// new_nodes_pop
// file node.h line 47
struct anonymous$19 * new_nodes_pop(void)
{
  struct anonymous$19 *node = (struct anonymous$19 *)(void *)0;
  struct _GList *old_item = (struct _GList *)(void *)0;
  struct anonymous$19 *return_value_nodes_catalog_find$1;
  if(new_nodes == ((struct _GList *)NULL))
    return (struct anonymous$19 *)(void *)0;

  else
  {
    node = (struct anonymous$19 *)new_nodes->data;
    old_item = new_nodes;
    for( ; !(node == ((struct anonymous$19 *)NULL)); old_item = new_nodes)
    {
      return_value_nodes_catalog_find$1=nodes_catalog_find(&node->node_id);
      if(!(return_value_nodes_catalog_find$1 == ((struct anonymous$19 *)NULL)))
        break;

      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Already deleted node in list of new nodes, in new_nodes_pop");
      new_nodes=g_list_remove_link(new_nodes, new_nodes);
      g_list_free_1(old_item);
      if(!(new_nodes == ((struct _GList *)NULL)))
        node = (struct anonymous$19 *)new_nodes->data;

      else
        node = (struct anonymous$19 *)(void *)0;
    }
    if(new_nodes == ((struct _GList *)NULL))
      return (struct anonymous$19 *)(void *)0;

    else
    {
      new_nodes=g_list_remove_link(new_nodes, new_nodes);
      g_list_free_1(old_item);
      return node;
    }
  }
}

// new_nodes_remove
// file node.c line 427
void new_nodes_remove(struct anonymous$19 *node)
{
  new_nodes=g_list_remove(new_nodes, (const void *)node);
}

// node_count
// file node.h line 40
signed int node_count(void)
{
  return nodes_num;
}

// node_create
// file node.c line 83
struct anonymous$19 * node_create(const struct anonymous$5 *node_id)
{
  struct anonymous$19 *node;
  char *name;
  unsigned int i;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(node_id == ((const struct anonymous$5 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "node.c", 89, (const char *)"node_create", "node_id");

  }
  while((_Bool)0);
  void *return_value_g_malloc$2;
  return_value_g_malloc$2=g_malloc(sizeof(struct anonymous$19) /*336ul*/ );
  node = (struct anonymous$19 *)return_value_g_malloc$2;
  signed int tmp_statement_expression$3;
  do
  {
    signed int node_create$$1$$2$$1$$_g_boolean_var_;
    if(!(node == ((struct anonymous$19 *)NULL)))
      node_create$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      node_create$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$3 = node_create$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$3 == 0l)
      g_assertion_message_expr((char *)0, "node.c", 92, (const char *)"node_create", "node");

  }
  while((_Bool)0);
  node->node_id = *node_id;
  name=node_id_str(node_id);
  node->name=g_string_new(name);
  node->numeric_name=g_string_new(name);
  g_free((void *)name);
  i = (unsigned int)0;
  for( ; !(i >= 6u); i = i + 1u)
    node->main_prot[(signed long int)i] = (char *)(void *)0;
  traffic_stats_init(&node->node_stats);
  nodes_num = nodes_num + 1;
  if(!((G_LOG_LEVEL_INFO & (signed int)appdata.debug_mask) == 0))
  {
    char *msg;
    msg=node_id_dump(&node->node_id);
    char *return_value_dcgettext$4;
    return_value_dcgettext$4=dcgettext((const char *)(void *)0, "New node: %s. Number of nodes %d", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$4, msg, nodes_num);
    g_free((void *)msg);
  }

  return node;
}

// node_delete
// file node.c line 119
void node_delete(struct anonymous$19 *node)
{
  unsigned int i;
  if(!(node == ((struct anonymous$19 *)NULL)))
  {
    if(!(node->name == ((struct _GString *)NULL)))
      g_string_free(node->name, (signed int)!(0 != 0));

    node->name = (struct _GString *)(void *)0;
    if(!(node->numeric_name == ((struct _GString *)NULL)))
      g_string_free(node->numeric_name, (signed int)!(0 != 0));

    node->numeric_name = (struct _GString *)(void *)0;
    i = (unsigned int)0;
    for( ; !(i >= 6u); i = i + 1u)
      if(!(node->main_prot[(signed long int)i] == ((char *)NULL)))
      {
        g_free((void *)node->main_prot[(signed long int)i]);
        node->main_prot[(signed long int)i] = (char *)(void *)0;
      }

    traffic_stats_reset(&node->node_stats);
    if(!((G_LOG_LEVEL_INFO & (signed int)appdata.debug_mask) == 0))
    {
      char *msg;
      msg=node_id_dump(&node->node_id);
      char *return_value_dcgettext$1;
      return_value_dcgettext$1=dcgettext((const char *)(void *)0, "delete node: %s. Number of nodes %d", 5);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$1, msg, nodes_num - 1);
      g_free((void *)msg);
    }

    g_free((void *)node);
    nodes_num = nodes_num - 1;
  }

}

// node_dump
// file node.h line 38
char * node_dump(const struct anonymous$19 *node)
{
  char *msg;
  char *msg_id;
  char *msg_stats;
  char *msg_mprot;
  unsigned int i;
  char *return_value_g_strdup$1;
  char *tmp_if_expr$2;
  char *tmp_if_expr$3;
  if(node == ((const struct anonymous$19 *)NULL))
  {
    return_value_g_strdup$1=g_strdup("node_t NULL");
    return return_value_g_strdup$1;
  }

  else
  {
    msg_id=node_id_dump(&node->node_id);
    msg_stats=traffic_stats_dump(&node->node_stats);
    if(!(node->main_prot[0l] == ((char *)NULL)))
      tmp_if_expr$2 = node->main_prot[(signed long int)0];

    else
      tmp_if_expr$2 = "-none-";
    msg_mprot=g_strdup_printf("top: [%s], stack:", tmp_if_expr$2);
    i = (unsigned int)1;
    for( ; !(i >= 6u); i = i + 1u)
    {
      char *tmp = msg_mprot;
      if(!(node->main_prot[(signed long int)i] == ((char *)NULL)))
        tmp_if_expr$3 = node->main_prot[(signed long int)i];

      else
        tmp_if_expr$3 = "-none-";
      msg_mprot=g_strdup_printf("%s %d:>%s<", msg_mprot, i, tmp_if_expr$3);
      g_free((void *)tmp);
    }
    msg=g_strdup_printf("id: %s, name: %s, numeric_name: %s, main_prot: [%s], stats [%s]", msg_id, node->name->str, node->numeric_name->str, msg_mprot, msg_stats);
    g_free((void *)msg_id);
    g_free((void *)msg_stats);
    g_free((void *)msg_mprot);
    return msg;
  }
}

// node_dump_tvs
// file node.c line 588
static signed int node_dump_tvs(void *key, void *value, void *data)
{
  char *msg_node;
  char *tmp;
  char **msg = (char **)data;
  const struct anonymous$19 *node = (const struct anonymous$19 *)value;
  msg_node=node_dump(node);
  tmp = *msg;
  *msg=g_strdup_printf("%snode %p:\n%s\n", tmp, node, msg_node);
  g_free((void *)tmp);
  g_free((void *)msg_node);
  return 0;
}

// node_id_clear
// file node_id.h line 42
void node_id_clear(struct anonymous$5 *a)
{
  memset((void *)&a->addr, 0, sizeof(union anonymous$81) /*22ul*/ );
  a->node_type = (enum anonymous$13)APEMODE_DEFAULT;
}

// node_id_compare
// file node_id.h line 43
signed int node_id_compare(const struct anonymous$5 *na, const struct anonymous$5 *nb)
{
  const unsigned char *ga;
  const unsigned char *gb;
  signed int i;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(na == ((const struct anonymous$5 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "node_id.c", 49, (const char *)"node_id_compare", "na != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int node_id_compare$$1$$2$$1$$_g_boolean_var_;
    if(!(nb == ((const struct anonymous$5 *)NULL)))
      node_id_compare$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      node_id_compare$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = node_id_compare$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "node_id.c", 50, (const char *)"node_id_compare", "nb != NULL");

  }
  while((_Bool)0);
  if(!((signed int)na->node_type >= (signed int)nb->node_type))
    return -1;

  else
    if(!((signed int)nb->node_type >= (signed int)na->node_type))
      return 1;

  char *return_value_dcgettext$3;
  switch((signed int)na->node_type)
  {
    case APEMODE_DEFAULT:
      return 0;
    case LINK6:
    {
      ga = na->addr.eth;
      gb = nb->addr.eth;
      i = (signed int)sizeof(unsigned char [6l]) /*6ul*/ ;
      break;
    }
    case IP:
    {
      ga = na->addr.ip.$anon0.all8;
      gb = nb->addr.ip.$anon0.all8;
      i = (signed int)sizeof(unsigned char [20l]) /*20ul*/ ;
      break;
    }
    case TCP:
    {
      ga = na->addr.tcp4.host.$anon0.all8;
      gb = nb->addr.tcp4.host.$anon0.all8;
      i = (signed int)(sizeof(unsigned char [20l]) /*20ul*/  + sizeof(unsigned short int) /*2ul*/ );
      break;
    }
    default:
    {
      return_value_dcgettext$3=dcgettext((const char *)(void *)0, "Unsupported ape mode in node_id_compare", 5);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_ERROR, return_value_dcgettext$3);

    __CPROVER_DUMP_L18:
      ;
      goto __CPROVER_DUMP_L18;
    }
  }
  ga = na->addr.eth;
  gb = nb->addr.eth;
  i = (signed int)sizeof(union anonymous$81) /*22ul*/ ;
  i=memcmp((const void *)ga, (const void *)gb, (unsigned long int)i);
  if(i >= 2)
    i = 1;

  else
    if(!(i >= -1))
      i = -1;

  return i;
}

// node_id_dump
// file node_id.c line 122
char * node_id_dump(const struct anonymous$5 *id)
{
  char *msg;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(id == ((const struct anonymous$5 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "node_id.c", 125, (const char *)"node_id_dump", "id");

  }
  while((_Bool)0);
  const char *return_value_ether_to_str$2;
  const char *return_value_type_to_str$3;
  const char *return_value_address_to_str$4;
  const char *return_value_address_to_str$5;
  switch((signed int)id->node_type)
  {
    case APEMODE_DEFAULT:
    {
      msg=g_strdup_printf("NONE: 00:00:00:00:00:00");
      break;
    }
    case LINK6:
    {
      return_value_ether_to_str$2=ether_to_str(id->addr.eth);
      msg=g_strdup_printf("LINK: %s", return_value_ether_to_str$2);
      break;
    }
    case IP:
    {
      return_value_type_to_str$3=type_to_str(&id->addr.ip);
      return_value_address_to_str$4=address_to_str(&id->addr.ip);
      msg=g_strdup_printf("%s: %s", return_value_type_to_str$3, return_value_address_to_str$4);
      break;
    }
    case TCP:
    {
      return_value_address_to_str$5=address_to_str(&id->addr.tcp4.host);
      msg=g_strdup_printf("TCP/UDP: %s:%u", return_value_address_to_str$5, id->addr.tcp4.port);
      break;
    }
    default:
      msg=g_strdup_printf("node_id_type %d unknown", (signed int)id->node_type);
  }
  return msg;
}

// node_id_str
// file node_id.c line 93
char * node_id_str(const struct anonymous$5 *id)
{
  char *msg;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(id == ((const struct anonymous$5 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "node_id.c", 96, (const char *)"node_id_str", "id");

  }
  while((_Bool)0);
  const char *return_value_ether_to_str$2;
  const char *return_value_address_to_str$3;
  const char *return_value_address_to_str$4;
  switch((signed int)id->node_type)
  {
    case APEMODE_DEFAULT:
    {
      msg=g_strdup("00:00:00:00:00:00");
      break;
    }
    case LINK6:
    {
      return_value_ether_to_str$2=ether_to_str(id->addr.eth);
      msg=g_strdup(return_value_ether_to_str$2);
      break;
    }
    case IP:
    {
      return_value_address_to_str$3=address_to_str(&id->addr.ip);
      msg=g_strdup(return_value_address_to_str$3);
      break;
    }
    case TCP:
    {
      return_value_address_to_str$4=address_to_str(&id->addr.tcp4.host);
      msg=g_strdup_printf("%s:%u", return_value_address_to_str$4, id->addr.tcp4.port);
      break;
    }
    default:
    {
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_ERROR, "node_id_type %d unknown", (signed int)id->node_type);

    __CPROVER_DUMP_L11:
      ;
      goto __CPROVER_DUMP_L11;
    }
  }
  return msg;
}

// node_id_xml
// file node_id.c line 151
char * node_id_xml(const struct anonymous$5 *id)
{
  char *msg;
  char *msgb;
  char *xml;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(id == ((const struct anonymous$5 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "node_id.c", 156, (const char *)"node_id_xml", "id");

  }
  while((_Bool)0);
  const char *return_value_ether_to_str$2;
  const char *return_value_type_to_str$3;
  const char *return_value_address_to_str$4;
  const char *return_value_type_to_str$5;
  const char *return_value_address_to_str$6;
  switch((signed int)id->node_type)
  {
    case APEMODE_DEFAULT:
    {
      msg=g_strdup_printf(" ");
      break;
    }
    case LINK6:
    {
      return_value_ether_to_str$2=ether_to_str(id->addr.eth);
      msg=xmltag("link", "%s", return_value_ether_to_str$2);
      break;
    }
    case IP:
    {
      return_value_type_to_str$3=type_to_str(&id->addr.ip);
      return_value_address_to_str$4=address_to_str(&id->addr.ip);
      msg=xmltag(return_value_type_to_str$3, "%s", return_value_address_to_str$4);
      break;
    }
    case TCP:
    {
      return_value_type_to_str$5=type_to_str(&id->addr.tcp4.host);
      return_value_address_to_str$6=address_to_str(&id->addr.tcp4.host);
      xml=xmltag(return_value_type_to_str$5, "%s", return_value_address_to_str$6);
      msgb=xmltag("port", "%u", id->addr.tcp4.port);
      msg=g_strdup_printf("%s %s", xml, msgb);
      g_free((void *)xml);
      g_free((void *)msgb);
      break;
    }
    default:
      msg=xmltag("unknown", "node_id_type %d unknown", (signed int)id->node_type);
  }
  xml=xmltag("id", "\n%s", msg);
  g_free((void *)msg);
  return xml;
}

// node_info_window_compare
// file info_windows.c line 664
static signed int node_info_window_compare(const void *a, const void *b)
{
  const struct anonymous$5 *id_a;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(a == NULL))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "info_windows.c", 667, (const char *)"node_info_window_compare", "a != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int node_info_window_compare$$1$$2$$1$$_g_boolean_var_;
    if(!(b == NULL))
      node_info_window_compare$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      node_info_window_compare$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = node_info_window_compare$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "info_windows.c", 668, (const char *)"node_info_window_compare", "b != NULL");

  }
  while((_Bool)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)a, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$4;
  return_value_g_object_get_data$4=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$3, "node_id");
  id_a = (const struct anonymous$5 *)return_value_g_object_get_data$4;
  if(id_a == ((const struct anonymous$5 *)NULL))
    return -1;

  else
  {
    signed int return_value_node_id_compare$5;
    return_value_node_id_compare$5=node_id_compare(id_a, (const struct anonymous$5 *)b);
    return return_value_node_id_compare$5;
  }
}

// node_item_event
// file diagram.c line 1371
static signed int node_item_event(struct _GnomeCanvasItem *item, union _GdkEvent *event, struct anonymous$82 *canvas_node)
{
  double item_x;
  double item_y;
  const struct anonymous$19 *node = (const struct anonymous$19 *)(void *)0;
  item_x = event->button.x;
  item_y = event->button.y;
  gnome_canvas_item_w2i(item->parent, &item_x, &item_y);
  if((signed int)event->type == GDK_2BUTTON_PRESS)
  {
    if(!(canvas_node == ((struct anonymous$82 *)NULL)))
      node=nodes_catalog_find(&canvas_node->canvas_node_id);

    if(!(node == ((const struct anonymous$19 *)NULL)))
    {
      node_protocols_window_create(&canvas_node->canvas_node_id);
      signed int return_value_nodes_catalog_size$1;
      return_value_nodes_catalog_size$1=nodes_catalog_size();
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, "Nodes: %d (shown %u)", return_value_nodes_catalog_size$1, displayed_nodes);
      if(!((G_LOG_LEVEL_DEBUG & (signed int)appdata.debug_mask) == 0))
      {
        char *msg;
        msg=node_dump(node);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "%s", msg);
        g_free((void *)msg);
      }

    }

  }

  return 0;
}

// node_name_assign
// file node_id.h line 63
void node_name_assign(struct anonymous$36 *name, const char *nm, const char *num_nm, double sz)
{
  if(!((G_LOG_LEVEL_DEBUG & (signed int)appdata.debug_mask) == 0))
  {
    char *msgid;
    msgid=node_id_dump(&name->node_id);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, " node_name_assign: id %s, name %s, num.name %s\n", msgid, nm != ((const char *)NULL) ? nm : "<none>", num_nm);
    g_free((void *)msgid);
  }

  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(name == ((struct anonymous$36 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "node_id.c", 251, (const char *)"node_name_assign", "name");

  }
  while((_Bool)0);
  if(name->numeric_name == ((struct _GString *)NULL))
    name->numeric_name=g_string_new(num_nm);

  else
    g_string_assign(name->numeric_name, num_nm);
  if(!(nm == ((const char *)NULL)))
  {
    if(name->res_name == ((struct _GString *)NULL))
      name->res_name=g_string_new(nm);

    else
      g_string_assign(name->res_name, nm);
  }

  name->accumulated = name->accumulated + sz;
}

// node_name_create
// file node_id.h line 61
struct anonymous$36 * node_name_create(const struct anonymous$5 *node_id)
{
  struct anonymous$36 *name;
  signed int tmp_statement_expression$1;
  do
  {
    signed int node_name_create$$1$$1$$1$$_g_boolean_var_;
    if(!(node_id == ((const struct anonymous$5 *)NULL)))
      node_name_create$$1$$1$$1$$_g_boolean_var_ = 1;

    else
      node_name_create$$1$$1$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$1 = node_name_create$$1$$1$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "node_id.c", 203, (const char *)"node_name_create", "node_id");

  }
  while((_Bool)0);
  void *return_value_g_malloc$2;
  return_value_g_malloc$2=g_malloc(sizeof(struct anonymous$36) /*56ul*/ );
  name = (struct anonymous$36 *)return_value_g_malloc$2;
  signed int tmp_statement_expression$3;
  do
  {
    signed int _g_boolean_var_;
    if(!(name == ((struct anonymous$36 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$3 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$3 == 0l)
      g_assertion_message_expr((char *)0, "node_id.c", 206, (const char *)"node_name_create", "name");

  }
  while((_Bool)0);
  name->node_id = *node_id;
  name->accumulated = (double)0;
  name->numeric_name = (struct _GString *)(void *)0;
  name->res_name = (struct _GString *)(void *)0;
  node_name_count = node_name_count + 1l;
  char *gg;
  gg=node_id_dump(node_id);
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "node name created (%p): >%s<, total %ld", name, gg, node_name_count);
  g_free((void *)gg);
  return name;
}

// node_name_delete
// file node_id.h line 62
void node_name_delete(struct anonymous$36 *name)
{
  if(!(name == ((struct anonymous$36 *)NULL)))
  {
    char *gg;
    gg=node_id_dump(&name->node_id);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "node name delete (%p): >%s<, total %ld", name, gg, node_name_count - (signed long int)1);
    g_free((void *)gg);
    if(!(name->res_name == ((struct _GString *)NULL)))
      g_string_free(name->res_name, (signed int)!(0 != 0));

    if(!(name->numeric_name == ((struct _GString *)NULL)))
      g_string_free(name->numeric_name, (signed int)!(0 != 0));

    g_free((void *)name);
    node_name_count = node_name_count - 1l;
  }

}

// node_name_dump
// file node_id.h line 67
char * node_name_dump(const struct anonymous$36 *name)
{
  char *msg;
  char *nid;
  char *return_value_g_strdup$1;
  char *tmp_if_expr$2;
  if(name == ((const struct anonymous$36 *)NULL))
  {
    return_value_g_strdup$1=g_strdup("name_t NULL");
    return return_value_g_strdup$1;
  }

  else
  {
    nid=node_id_dump(&name->node_id);
    if(!(name->res_name == ((struct _GString *)NULL)))
      tmp_if_expr$2 = name->res_name->str;

    else
      tmp_if_expr$2 = "<none>";
    msg=g_strdup_printf("node id: %s, name: %s, numeric_name: %s, solved: %d, accumulated %f", nid, tmp_if_expr$2, name->numeric_name->str, name->res_name != (struct _GString *)(void *)0, name->accumulated);
    g_free((void *)nid);
    return msg;
  }
}

// node_name_freq_compare
// file node_id.c line 323
signed int node_name_freq_compare(const void *a, const void *b)
{
  const struct anonymous$36 *name_a;
  const struct anonymous$36 *name_b;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(a == NULL))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "node_id.c", 327, (const char *)"node_name_freq_compare", "a != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int node_name_freq_compare$$1$$2$$1$$_g_boolean_var_;
    if(!(b == NULL))
      node_name_freq_compare$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      node_name_freq_compare$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = node_name_freq_compare$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "node_id.c", 328, (const char *)"node_name_freq_compare", "b != NULL");

  }
  while((_Bool)0);
  name_a = (const struct anonymous$36 *)a;
  name_b = (const struct anonymous$36 *)b;
  if(name_a->accumulated > name_b->accumulated)
    return -1;

  else
    if(name_a->accumulated < name_b->accumulated)
      return 1;

    else
      return 0;
}

// node_name_id_compare
// file node_id.h line 65
signed int node_name_id_compare(const struct anonymous$36 *a, const struct anonymous$36 *b)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(a == ((const struct anonymous$36 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "node_id.c", 316, (const char *)"node_name_id_compare", "a != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int node_name_id_compare$$1$$2$$1$$_g_boolean_var_;
    if(!(b == ((const struct anonymous$36 *)NULL)))
      node_name_id_compare$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      node_name_id_compare$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = node_name_id_compare$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "node_id.c", 317, (const char *)"node_name_id_compare", "b != NULL");

  }
  while((_Bool)0);
  signed int return_value_node_id_compare$3;
  return_value_node_id_compare$3=node_id_compare(&a->node_id, &b->node_id);
  return return_value_node_id_compare$3;
}

// node_name_update
// file node.c line 286
static void node_name_update(struct anonymous$19 *node)
{
  struct _GList *protocol_item;
  struct anonymous$26 *protocol;
  unsigned int i = (unsigned int)5;
  i = (unsigned int)0;
  for( ; !(i >= 6u); i = i + 1u)
  {
    protocol_item = node->node_stats.stats_protos.protostack[(signed long int)i];
    for( ; !(protocol_item == ((struct _GList *)NULL)); protocol_item = protocol_item->next)
    {
      protocol = (struct anonymous$26 *)protocol_item->data;
      protocol->node_names=g_list_sort(protocol->node_names, node_name_freq_compare);
    }
  }
  switch((signed int)appdata.mode)
  {
    case LINK6:
    {
      set_node_name(node, ethernet_sequence);
      break;
    }
    case IP:
    {
      set_node_name(node, ip_sequence);
      break;
    }
    case TCP:
      set_node_name(node, tcp_sequence);
  }
}

// node_name_xml
// file node_id.h line 68
char * node_name_xml(const struct anonymous$36 *name)
{
  char *msg;
  char *nid;
  char *nres;
  char *return_value_xmltag$1;
  if(name == ((const struct anonymous$36 *)NULL))
  {
    return_value_xmltag$1=xmltag("name", "");
    return return_value_xmltag$1;
  }

  else
  {
    nid=node_id_xml(&name->node_id);
    if(!(name->res_name == ((struct _GString *)NULL)))
      nres=xmltag("resolved_name", "%s", name->res_name->str);

    else
      nres=g_strdup("");
    msg=xmltag("name", "\n%s%s<numeric_name>%s</numeric_name>\n<accumulated>%.0f</accumulated>", nid, nres, name->numeric_name->str, name->accumulated);
    g_free((void *)nid);
    g_free((void *)nres);
    return msg;
  }
}

// node_protocols_window_create
// file info_windows.h line 27
void node_protocols_window_create(const struct anonymous$5 *node_id)
{
  struct _GtkWidget *window;
  struct _GList *list_item;
  list_item=g_list_find_custom(stats_info_windows, (const void *)node_id, node_info_window_compare);
  if(list_item == ((struct _GList *)NULL))
  {
    void *return_value_g_memdup$1;
    return_value_g_memdup$1=g_memdup((const void *)node_id, (unsigned int)sizeof(struct anonymous$5) /*28ul*/ );
    window=stats_info_create("node_id", return_value_g_memdup$1);
    if(window == ((struct _GtkWidget *)NULL))
      goto __CPROVER_DUMP_L4;

    update_gtklabel(window, "node_iproto_name_b", "");
    update_gtklabel(window, "node_iproto_numeric_name_b", "");
  }

  else
    window = (struct _GtkWidget *)list_item->data;
  update_node_protocols_window(window);

__CPROVER_DUMP_L4:
  ;
}

// node_update
// file node.c line 231
signed int node_update(struct anonymous$5 *node_id, struct anonymous$19 *node, void *delete_list_ptr)
{
  double diffms;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(delete_list_ptr == NULL))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "node.c", 235, (const char *)"node_update", "delete_list_ptr");

  }
  while((_Bool)0);
  signed int return_value_traffic_stats_update$3;
  return_value_traffic_stats_update$3=traffic_stats_update(&node->node_stats, pref.averaging_time, pref.proto_node_timeout_time);
  if(!(return_value_traffic_stats_update$3 == 0))
  {
    unsigned int i = (unsigned int)5;
    for( ; !(i == 4294967295u); i = i - 1u)
    {
      if(!(node->main_prot[(signed long int)i] == ((char *)NULL)))
        g_free((void *)node->main_prot[(signed long int)i]);

      node->main_prot[(signed long int)i]=protocol_stack_sort_most_used(&node->node_stats.stats_protos, (unsigned long int)i);
    }
    node_name_update(node);
  }

  else
    if(IEEE_FLOAT_NOTEQUAL(pref.node_timeout_time, 0.000000))
    {
      diffms=substract_times_ms(&appdata.now, &node->node_stats.stats.last_time);
      if(diffms >= pref.node_timeout_time)
      {
        struct _GList **delete_list = (struct _GList **)delete_list_ptr;
        if(!((G_LOG_LEVEL_DEBUG & (signed int)appdata.debug_mask) == 0))
        {
          char *msg;
          msg=node_id_dump(&node->node_id);
          char *return_value_dcgettext$2;
          return_value_dcgettext$2=dcgettext((const char *)(void *)0, "Queuing node '%s' for remove", 5);
          g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, return_value_dcgettext$2, msg);
          g_free((void *)msg);
        }

        new_nodes_remove(node);
        *delete_list=g_list_prepend(*delete_list, (void *)node_id);
      }

    }

  return 0;
}

// node_xml
// file node.c line 200
char * node_xml(const struct anonymous$19 *node)
{
  char *msg;
  char *msg_id;
  char *msg_stats;
  char *msg_resolved;
  char *msg_numeric;
  char *return_value_xmltag$1;
  if(node == ((const struct anonymous$19 *)NULL))
  {
    return_value_xmltag$1=xmltag("node", "");
    return return_value_xmltag$1;
  }

  else
  {
    msg_id=node_id_xml(&node->node_id);
    msg_stats=traffic_stats_xml(&node->node_stats);
    msg_resolved=xmltag("resolved_name", "%s", node->name->str);
    msg_numeric=xmltag("numeric_name", "%s", node->numeric_name->str);
    msg=xmltag("node", "\n<name>\n%s%s%s</name>\n%s", msg_id, msg_resolved, msg_numeric, msg_stats);
    g_free((void *)msg_id);
    g_free((void *)msg_stats);
    g_free((void *)msg_resolved);
    g_free((void *)msg_numeric);
    return msg;
  }
}

// node_xml_tvs
// file node.c line 612
static signed int node_xml_tvs(void *key, void *value, void *data)
{
  char *msg_node;
  char *tmp;
  char **msg = (char **)data;
  const struct anonymous$19 *node = (const struct anonymous$19 *)value;
  msg_node=node_xml(node);
  tmp = *msg;
  *msg=g_strdup_printf("%s%s", tmp, msg_node);
  g_free((void *)tmp);
  g_free((void *)msg_node);
  return 0;
}

// nodes_catalog_close
// file node.h line 51
void nodes_catalog_close(void)
{
  if(!(all_nodes == ((struct _GTree *)NULL)))
  {
    g_tree_destroy(all_nodes);
    all_nodes = (struct _GTree *)(void *)0;
  }

}

// nodes_catalog_compare
// file node.c line 481
static signed int nodes_catalog_compare(const void *a, const void *b, void *dummy)
{
  signed int return_value_node_id_compare$1;
  return_value_node_id_compare$1=node_id_compare((const struct anonymous$5 *)a, (const struct anonymous$5 *)b);
  return return_value_node_id_compare$1;
}

// nodes_catalog_dump
// file node.c line 603
char * nodes_catalog_dump(void)
{
  char *msg;
  msg=g_strdup("");
  nodes_catalog_foreach(node_dump_tvs, (void *)&msg);
  return msg;
}

// nodes_catalog_find
// file node.h line 52
struct anonymous$19 * nodes_catalog_find(const struct anonymous$5 *key)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(key == ((const struct anonymous$5 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "node.c", 531, (const char *)"nodes_catalog_find", "key");

  }
  while((_Bool)0);
  if(all_nodes == ((struct _GTree *)NULL))
    return (struct anonymous$19 *)(void *)0;

  else
  {
    void *return_value_g_tree_lookup$2;
    return_value_g_tree_lookup$2=g_tree_lookup(all_nodes, (const void *)key);
    return (struct anonymous$19 *)return_value_g_tree_lookup$2;
  }
}

// nodes_catalog_foreach
// file node.c line 548
void nodes_catalog_foreach(signed int (*func)(void *, void *, void *), void *data)
{
  if(!(all_nodes == ((struct _GTree *)NULL)))
    g_tree_foreach(all_nodes, func, data);

}

// nodes_catalog_new
// file node.h line 53
struct anonymous$19 * nodes_catalog_new(const struct anonymous$5 *node_id)
{
  struct anonymous$19 *new_node;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(all_nodes == ((struct _GTree *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "node.c", 509, (const char *)"nodes_catalog_new", "all_nodes");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int nodes_catalog_new$$1$$2$$1$$_g_boolean_var_;
    if(!(node_id == ((const struct anonymous$5 *)NULL)))
      nodes_catalog_new$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      nodes_catalog_new$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = nodes_catalog_new$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "node.c", 510, (const char *)"nodes_catalog_new", "node_id");

  }
  while((_Bool)0);
  new_node=node_create(node_id);
  if(new_node == ((struct anonymous$19 *)NULL))
    return (struct anonymous$19 *)(void *)0;

  else
  {
    g_tree_insert(all_nodes, (void *)&new_node->node_id, (void *)new_node);
    return new_node;
  }
}

// nodes_catalog_open
// file node.h line 50
void nodes_catalog_open(void)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(all_nodes == ((struct _GTree *)NULL))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "node.c", 489, (const char *)"nodes_catalog_open", "!all_nodes");

  }
  while((_Bool)0);
  all_nodes=g_tree_new_full(nodes_catalog_compare, (void *)0, (void (*)(void *))(void *)0, (void (*)(void *))node_delete);
}

// nodes_catalog_remove
// file node.c line 521
void nodes_catalog_remove(const struct anonymous$5 *key)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int nodes_catalog_remove$$1$$1$$1$$_g_boolean_var_;
    if(!(all_nodes == ((struct _GTree *)NULL)))
      nodes_catalog_remove$$1$$1$$1$$_g_boolean_var_ = 1;

    else
      nodes_catalog_remove$$1$$1$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$1 = nodes_catalog_remove$$1$$1$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "node.c", 523, (const char *)"nodes_catalog_remove", "all_nodes");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int _g_boolean_var_;
    if(!(key == ((const struct anonymous$5 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$2 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "node.c", 524, (const char *)"nodes_catalog_remove", "key");

  }
  while((_Bool)0);
  g_tree_remove(all_nodes, (const void *)key);
}

// nodes_catalog_size
// file node.h line 55
signed int nodes_catalog_size(void)
{
  if(all_nodes == ((struct _GTree *)NULL))
    return 0;

  else
  {
    signed int return_value_g_tree_nnodes$1;
    return_value_g_tree_nnodes$1=g_tree_nnodes(all_nodes);
    return return_value_g_tree_nnodes$1;
  }
}

// nodes_catalog_update_all
// file node.h line 57
void nodes_catalog_update_all(void)
{
  struct _GList *delete_list = (struct _GList *)(void *)0;
  if(!(all_nodes == ((struct _GTree *)NULL)))
  {
    nodes_catalog_foreach((signed int (*)(void *, void *, void *))node_update, (void *)&delete_list);
    g_list_foreach(delete_list, gfunc_remove_node, (void *)0);
    g_list_free(delete_list);
    char *return_value_dcgettext$1;
    return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Updated nodes. Active nodes %d", 5);
    signed int return_value_nodes_catalog_size$2;
    return_value_nodes_catalog_size$2=nodes_catalog_size();
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, return_value_dcgettext$1, return_value_nodes_catalog_size$2);
  }

}

// nodes_catalog_xml
// file node.h line 62
char * nodes_catalog_xml(void)
{
  char *msg;
  char *xml;
  msg=g_strdup("");
  nodes_catalog_foreach(node_xml_tvs, (void *)&msg);
  xml=xmltag("nodes", "\n%s", msg);
  g_free((void *)msg);
  return xml;
}

// nodes_table_clear
// file node_windows.c line 250
static void nodes_table_clear(struct _GtkWidget *window)
{
  struct _GtkTreeView *gv;
  struct _GtkTreeModel *sort_model;
  struct _GtkTreeModel *gls;
  struct _GtkTreeIter it;
  signed int res;
  gv=retrieve_treeview(window);
  if(!(gv == ((struct _GtkTreeView *)NULL)))
  {
    sort_model=gtk_tree_view_get_model(gv);
    if(!(sort_model == ((struct _GtkTreeModel *)NULL)))
    {
      unsigned long int return_value_gtk_tree_model_sort_get_type$1;
      return_value_gtk_tree_model_sort_get_type$1=gtk_tree_model_sort_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)sort_model, return_value_gtk_tree_model_sort_get_type$1);
      gls=gtk_tree_model_sort_get_model((struct _GtkTreeModelSort *)return_value_g_type_check_instance_cast$2);
      if(!(gls == ((struct _GtkTreeModel *)NULL)))
      {
        res=gtk_tree_model_get_iter_first(gls, &it);
        while(!(res == 0))
        {
          struct anonymous$5 *rowitem = (struct anonymous$5 *)(void *)0;
          gtk_tree_model_get(gls, &it, 7, &rowitem, -1);
          g_free((void *)rowitem);
          unsigned long int return_value_gtk_list_store_get_type$3;
          return_value_gtk_list_store_get_type$3=gtk_list_store_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
          return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)gls, return_value_gtk_list_store_get_type$3);
          res=gtk_list_store_remove((struct _GtkListStore *)return_value_g_type_check_instance_cast$4, &it);
        }
      }

    }

  }

}

// nodes_table_compare
// file node_windows.c line 102
static signed int nodes_table_compare(struct _GtkTreeModel *gls, struct _GtkTreeIter *a, struct _GtkTreeIter *b, void *data)
{
  signed int ret = 0;
  double t1;
  double t2;
  double diffms;
  const struct anonymous$5 *nodeid1;
  const struct anonymous$5 *nodeid2;
  const struct anonymous$19 *node1;
  const struct anonymous$19 *node2;
  gtk_tree_model_get(gls, a, 7, &nodeid1, -1);
  gtk_tree_model_get(gls, b, 7, &nodeid2, -1);
  signed int tmp_statement_expression$1;
  if(nodeid1 == ((const struct anonymous$5 *)NULL) || nodeid2 == ((const struct anonymous$5 *)NULL))
    return 0;

  else
  {
    node1=nodes_catalog_find(nodeid1);
    node2=nodes_catalog_find(nodeid2);
    if(node1 == ((const struct anonymous$19 *)NULL) && node2 == ((const struct anonymous$19 *)NULL))
      return 0;

    else
      if(node1 == ((const struct anonymous$19 *)NULL))
        return -1;

      else
        if(node2 == ((const struct anonymous$19 *)NULL))
          return 1;

    if(!((signed int)data == 0))
    {
      if((signed int)data == 1)
        goto __CPROVER_DUMP_L6;

      if((signed int)data == 2)
        goto __CPROVER_DUMP_L7;

      if((signed int)data == 3)
        goto __CPROVER_DUMP_L11;

      if((signed int)data == 4)
        goto __CPROVER_DUMP_L15;

      if((signed int)data == 5)
        goto __CPROVER_DUMP_L19;

      if((signed int)data == 6)
        goto __CPROVER_DUMP_L23;

    }

    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$2;
    return_value___builtin_strcmp$2=__builtin_strcmp(node1->name->str, node2->name->str);
    tmp_statement_expression$1 = return_value___builtin_strcmp$2;
    ret = tmp_statement_expression$1;
    goto __CPROVER_DUMP_L26;

  __CPROVER_DUMP_L6:
    ;
    ret=node_id_compare(&node1->node_id, &node2->node_id);
    goto __CPROVER_DUMP_L26;

  __CPROVER_DUMP_L7:
    ;
    t1 = node1->node_stats.stats.average;
    t2 = node2->node_stats.stats.average;
    if(IEEE_FLOAT_EQUAL(t1, t2))
      ret = 0;

    else
      if(t1 < t2)
        ret = -1;

      else
        ret = 1;
    goto __CPROVER_DUMP_L26;

  __CPROVER_DUMP_L11:
    ;
    t1 = node1->node_stats.stats.accumulated;
    t2 = node2->node_stats.stats.accumulated;
    if(IEEE_FLOAT_EQUAL(t1, t2))
      ret = 0;

    else
      if(t1 < t2)
        ret = -1;

      else
        ret = 1;
    goto __CPROVER_DUMP_L26;

  __CPROVER_DUMP_L15:
    ;
    t1 = node1->node_stats.stats.avg_size;
    t2 = node2->node_stats.stats.avg_size;
    if(IEEE_FLOAT_EQUAL(t1, t2))
      ret = 0;

    else
      if(t1 < t2)
        ret = -1;

      else
        ret = 1;
    goto __CPROVER_DUMP_L26;

  __CPROVER_DUMP_L19:
    ;
    diffms=substract_times_ms(&node1->node_stats.stats.last_time, &node2->node_stats.stats.last_time);
    if(IEEE_FLOAT_EQUAL(diffms, 0.000000))
      ret = 0;

    else
      if(diffms < 0.000000)
        ret = -1;

      else
        ret = 1;
    goto __CPROVER_DUMP_L26;

  __CPROVER_DUMP_L23:
    ;
    if(node1->node_stats.stats.accu_packets == node2->node_stats.stats.accu_packets)
      ret = 0;

    else
      if(!(node1->node_stats.stats.accu_packets >= node2->node_stats.stats.accu_packets))
        ret = -1;

      else
        ret = 1;

  __CPROVER_DUMP_L26:
    ;
    return ret;
  }
}

// nodes_table_create
// file node_windows.c line 190
static struct _GtkListStore * nodes_table_create(struct _GtkWidget *window)
{
  struct _GtkTreeView *gv;
  struct _GtkListStore *gls;
  struct _GtkTreeModel *sort_model;
  signed int i;
  gv=retrieve_treeview(window);
  if(gv == ((struct _GtkTreeView *)NULL))
  {
    struct _GtkWidget *return_value_glade_xml_get_widget$1;
    return_value_glade_xml_get_widget$1=glade_xml_get_widget(appdata.xml, "nodes_table");
    unsigned long int return_value_gtk_tree_view_get_type$2;
    return_value_gtk_tree_view_get_type$2=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$1, return_value_gtk_tree_view_get_type$2);
    gv = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$3;
    if(gv == ((struct _GtkTreeView *)NULL))
    {
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, "can't find nodes_table");
      return (struct _GtkListStore *)(void *)0;
    }

    register_treeview(window, gv);
  }

  sort_model=gtk_tree_view_get_model(gv);
  if(!(sort_model == ((struct _GtkTreeModel *)NULL)))
  {
    unsigned long int return_value_gtk_tree_model_sort_get_type$4;
    return_value_gtk_tree_model_sort_get_type$4=gtk_tree_model_sort_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)sort_model, return_value_gtk_tree_model_sort_get_type$4);
    struct _GtkTreeModel *return_value_gtk_tree_model_sort_get_model$6;
    return_value_gtk_tree_model_sort_get_model$6=gtk_tree_model_sort_get_model((struct _GtkTreeModelSort *)return_value_g_type_check_instance_cast$5);
    unsigned long int return_value_gtk_list_store_get_type$7;
    return_value_gtk_list_store_get_type$7=gtk_list_store_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_tree_model_sort_get_model$6, return_value_gtk_list_store_get_type$7);
    gls = (struct _GtkListStore *)return_value_g_type_check_instance_cast$8;
    if(!(gls == ((struct _GtkListStore *)NULL)))
      return gls;

  }

  gls=gtk_list_store_new(8, (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(17 << 2));
  unsigned long int return_value_gtk_tree_model_get_type$9;
  return_value_gtk_tree_model_get_type$9=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)gls, return_value_gtk_tree_model_get_type$9);
  sort_model=gtk_tree_model_sort_new_with_model((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$10);
  unsigned long int return_value_gtk_tree_model_get_type$11;
  return_value_gtk_tree_model_get_type$11=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)sort_model, return_value_gtk_tree_model_get_type$11);
  gtk_tree_view_set_model(gv, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$12);
  create_add_text_column(gv, "Name", 0, 0);
  create_add_text_column(gv, "Address", 1, (signed int)!(0 != 0));
  create_add_text_column(gv, "Inst Traffic", 2, 0);
  create_add_text_column(gv, "Accum Traffic", 3, 0);
  create_add_text_column(gv, "Avg Size", 4, 0);
  create_add_text_column(gv, "Last Heard", 5, 0);
  create_add_text_column(gv, "Packets", 6, 0);
  i = 0;
  unsigned long int return_value_gtk_tree_sortable_get_type$13;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  for( ; !(i >= 7); i = i + 1)
  {
    return_value_gtk_tree_sortable_get_type$13=gtk_tree_sortable_get_type();
    return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)sort_model, return_value_gtk_tree_sortable_get_type$13);
    gtk_tree_sortable_set_sort_func((struct _GtkTreeSortable *)return_value_g_type_check_instance_cast$14, i, nodes_table_compare, (void *)(signed long int)i, (void (*)(void *))(void *)0);
  }
  unsigned long int return_value_gtk_tree_sortable_get_type$15;
  return_value_gtk_tree_sortable_get_type$15=gtk_tree_sortable_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)sort_model, return_value_gtk_tree_sortable_get_type$15);
  gtk_tree_sortable_set_sort_column_id((struct _GtkTreeSortable *)return_value_g_type_check_instance_cast$16, 0, (enum anonymous$33)GTK_SORT_ASCENDING);
  return gls;
}

// nodes_table_iterate
// file node_windows.c line 319
static signed int nodes_table_iterate(void *key, void *value, void *data)
{
  const struct anonymous$19 *node = (const struct anonymous$19 *)value;
  struct NTTraverse *tt = (struct NTTraverse *)data;
  struct anonymous$5 *rowitem;
  signed int tmp_statement_expression$7;
  while(!(tt->res == 0))
  {
    unsigned long int return_value_gtk_tree_model_get_type$1;
    return_value_gtk_tree_model_get_type$1=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)tt->gs, return_value_gtk_tree_model_get_type$1);
    gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$2, &tt->it, 7, &rowitem, -1);
    signed int return_value_node_id_compare$3;
    return_value_node_id_compare$3=node_id_compare(&node->node_id, rowitem);
    if(!(return_value_node_id_compare$3 == 0))
    {
      if(return_value_node_id_compare$3 == -1)
        goto __CPROVER_DUMP_L3;

      if(return_value_node_id_compare$3 == 1)
        goto __CPROVER_DUMP_L9;

    }

    else
    {
      nodes_table_update_row(tt->gs, &tt->it, node);
      unsigned long int return_value_gtk_tree_model_get_type$4;
      return_value_gtk_tree_model_get_type$4=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)tt->gs, return_value_gtk_tree_model_get_type$4);
      tt->res=gtk_tree_model_iter_next((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$5, &tt->it);
      return 0;

    __CPROVER_DUMP_L3:
      ;
      gtk_list_store_insert_before(tt->gs, &tt->it, &tt->it);
      void *return_value_g_malloc$6;
      return_value_g_malloc$6=g_malloc(sizeof(struct anonymous$5) /*28ul*/ );
      rowitem = (struct anonymous$5 *)return_value_g_malloc$6;
      do
      {
        signed int _g_boolean_var_;
        if(!(rowitem == ((struct anonymous$5 *)NULL)))
          _g_boolean_var_ = 1;

        else
          _g_boolean_var_ = 0;
        tmp_statement_expression$7 = _g_boolean_var_;
        if((signed long int)tmp_statement_expression$7 == 0l)
          g_assertion_message_expr((char *)0, "node_windows.c", 344, (const char *)"nodes_table_iterate", "rowitem");

      }
      while((_Bool)0);
      *rowitem = node->node_id;
      gtk_list_store_set(tt->gs, &tt->it, 7, rowitem, -1);
      nodes_table_update_row(tt->gs, &tt->it, node);
      unsigned long int return_value_gtk_tree_model_get_type$8;
      return_value_gtk_tree_model_get_type$8=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
      return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)tt->gs, return_value_gtk_tree_model_get_type$8);
      tt->res=gtk_tree_model_iter_next((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$9, &tt->it);
      return 0;

    __CPROVER_DUMP_L9:
      ;
      g_free((void *)rowitem);
      tt->res=gtk_list_store_remove(tt->gs, &tt->it);
    }
  }
  gtk_list_store_prepend(tt->gs, &tt->it);
  void *return_value_g_malloc$10;
  return_value_g_malloc$10=g_malloc(sizeof(struct anonymous$5) /*28ul*/ );
  rowitem = (struct anonymous$5 *)return_value_g_malloc$10;
  signed int tmp_statement_expression$11;
  do
  {
    signed int nodes_table_iterate$$1$$2$$1$$_g_boolean_var_;
    if(!(rowitem == ((struct anonymous$5 *)NULL)))
      nodes_table_iterate$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      nodes_table_iterate$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$11 = nodes_table_iterate$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$11 == 0l)
      g_assertion_message_expr((char *)0, "node_windows.c", 364, (const char *)"nodes_table_iterate", "rowitem");

  }
  while((_Bool)0);
  *rowitem = node->node_id;
  gtk_list_store_set(tt->gs, &tt->it, 7, rowitem, -1);
  nodes_table_update_row(tt->gs, &tt->it, node);
  return 0;
}

// nodes_table_update
// file node_windows.c line 371
static void nodes_table_update(struct _GtkWidget *window)
{
  struct _GtkListStore *gs;
  struct NTTraverse tt;
  gs=nodes_table_create(window);
  if(!(gs == ((struct _GtkListStore *)NULL)))
  {
    tt.gs = gs;
    unsigned long int return_value_gtk_tree_model_get_type$1;
    return_value_gtk_tree_model_get_type$1=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)tt.gs, return_value_gtk_tree_model_get_type$1);
    tt.res=gtk_tree_model_get_iter_first((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$2, &tt.it);
    nodes_catalog_foreach(nodes_table_iterate, (void *)&tt);
    while(!(tt.res == 0))
    {
      struct anonymous$5 *rowitem;
      unsigned long int return_value_gtk_tree_model_get_type$3;
      return_value_gtk_tree_model_get_type$3=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)tt.gs, return_value_gtk_tree_model_get_type$3);
      gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$4, &tt.it, 7, &rowitem, -1);
      g_free((void *)rowitem);
      tt.res=gtk_list_store_remove(tt.gs, &tt.it);
    }
  }

}

// nodes_table_update_row
// file node_windows.c line 284
static void nodes_table_update_row(struct _GtkListStore *gs, struct _GtkTreeIter *it, const struct anonymous$19 *node)
{
  char *sa;
  char *sb;
  char *sc;
  char *sd;
  char *se;
  const struct anonymous$34 *stats = (const struct anonymous$34 *)&node->node_stats.stats;
  sa=traffic_to_str(stats->average, (signed int)!(0 != 0));
  sb=traffic_to_str(stats->accumulated, 0);
  sc=g_strdup_printf("%lu", stats->accu_packets);
  sd=timeval_to_str(stats->last_time);
  se=traffic_to_str(stats->avg_size, 0);
  gtk_list_store_set(gs, it, 0, node->name->str, 1, node->numeric_name->str, 2, sa, 3, sb, 4, se, 6, sc, 5, sd, -1);
  g_free((void *)sa);
  g_free((void *)sb);
  g_free((void *)sc);
  g_free((void *)sd);
  g_free((void *)se);
}

// nodes_wnd_hide
// file node_windows.c line 72
void nodes_wnd_hide(void)
{
  _Bool tmp_if_expr$3;
  unsigned long int return_value_gtk_object_get_type$1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  if(nodes_wnd == ((struct _GtkWidget *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_gtk_object_get_type$1=gtk_object_get_type();
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)nodes_wnd, return_value_gtk_object_get_type$1);
    tmp_if_expr$3 = !((((struct _GtkObject *)return_value_g_type_check_instance_cast$2)->flags & (unsigned int)256) != (unsigned int)0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_gtk_check_menu_item_get_active$4;
  if(!tmp_if_expr$3)
  {
    gtk_widget_hide(nodes_wnd);
    nodes_table_clear(nodes_wnd);
    if(!(nodes_check == ((struct _GtkCheckMenuItem *)NULL)))
    {
      return_value_gtk_check_menu_item_get_active$4=gtk_check_menu_item_get_active(nodes_check);
      if(!(return_value_gtk_check_menu_item_get_active$4 == 0))
        gtk_check_menu_item_set_active(nodes_check, 0);

    }

  }

}

// nodes_wnd_show
// file node_windows.c line 50
void nodes_wnd_show(void)
{
  nodes_wnd=glade_xml_get_widget(appdata.xml, "nodes_wnd");
  struct _GtkWidget *return_value_glade_xml_get_widget$1;
  return_value_glade_xml_get_widget$1=glade_xml_get_widget(appdata.xml, "nodes_check");
  unsigned long int return_value_gtk_check_menu_item_get_type$2;
  return_value_gtk_check_menu_item_get_type$2=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$1, return_value_gtk_check_menu_item_get_type$2);
  nodes_check = (struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$3;
  if(!((G_LOG_LEVEL_DEBUG & (signed int)appdata.debug_mask) == 0))
  {
    char *nodemsg;
    nodemsg=nodes_catalog_dump();
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_MESSAGE, "%s", nodemsg);
    g_free((void *)nodemsg);
  }

  _Bool tmp_if_expr$6;
  unsigned long int return_value_gtk_object_get_type$4;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  if(nodes_wnd == ((struct _GtkWidget *)NULL))
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    return_value_gtk_object_get_type$4=gtk_object_get_type();
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)nodes_wnd, return_value_gtk_object_get_type$4);
    tmp_if_expr$6 = (((struct _GtkObject *)return_value_g_type_check_instance_cast$5)->flags & (unsigned int)256) != (unsigned int)0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_gtk_check_menu_item_get_active$7;
  if(!tmp_if_expr$6)
  {
    gtk_widget_show(nodes_wnd);
    gdk_window_raise(nodes_wnd->window);
    if(!(nodes_check == ((struct _GtkCheckMenuItem *)NULL)))
    {
      return_value_gtk_check_menu_item_get_active$7=gtk_check_menu_item_get_active(nodes_check);
      if(return_value_gtk_check_menu_item_get_active$7 == 0)
        gtk_check_menu_item_set_active(nodes_check, (signed int)!(0 != 0));

    }

    nodes_wnd_update();
  }

}

// nodes_wnd_update
// file node_windows.h line 28
void nodes_wnd_update(void)
{
  _Bool tmp_if_expr$3;
  unsigned long int return_value_gtk_object_get_type$1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  if(nodes_wnd == ((struct _GtkWidget *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_gtk_object_get_type$1=gtk_object_get_type();
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)nodes_wnd, return_value_gtk_object_get_type$1);
    tmp_if_expr$3 = !((((struct _GtkObject *)return_value_g_type_check_instance_cast$2)->flags & (unsigned int)256) != (unsigned int)0) ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr$3)
    nodes_table_update(nodes_wnd);

}

// old_config_file_name
// file preferences.c line 88
static char * old_config_file_name(void)
{
  const char *return_value_g_get_home_dir$1;
  return_value_g_get_home_dir$1=g_get_home_dir();
  char *return_value_g_strdup_printf$2;
  return_value_g_strdup_printf$2=g_strdup_printf("%s/.gnome2/Etherape", return_value_g_get_home_dir$1);
  return return_value_g_strdup_printf$2;
}

// on_about1_activate
// file menus.c line 338
void on_about1_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  struct _GtkWidget *about;
  about=glade_xml_get_widget(appdata.xml, "about1");
  unsigned long int return_value_gtk_about_dialog_get_type$1;
  return_value_gtk_about_dialog_get_type$1=gtk_about_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)about, return_value_gtk_about_dialog_get_type$1);
  gtk_about_dialog_set_version((struct _GtkAboutDialog *)return_value_g_type_check_instance_cast$2, "0.9.13");
  gtk_widget_show(about);
}

// on_averaging_spin_adjustment_changed
// file pref_dialog.c line 293
void on_averaging_spin_adjustment_changed(struct _GtkAdjustment *adj)
{
  pref.averaging_time = adj->value;
}

// on_cancel_pref_button_clicked
// file pref_dialog.c line 415
void on_cancel_pref_button_clicked(struct _GtkButton *button, void *user_data)
{
  copy_config(&pref, tmp_pref);
  ask_reposition((signed int)!(0 != 0));
  if(!(colors_changed == 0))
  {
    protohash_read_prefvect(pref.colors);
    delete_gui_protocols();
  }

  hide_pref_dialog();
}

// on_canvas1_size_allocate
// file callbacks.c line 31
void on_canvas1_size_allocate(struct _GtkWidget *widget, struct _GdkRectangle *allocation, void *user_data)
{
  struct _GtkWidget *canvas;
  unsigned long int return_value_gnome_canvas_get_type$1;
  return_value_gnome_canvas_get_type$1=gnome_canvas_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gnome_canvas_get_type$1);
  gnome_canvas_set_scroll_region((struct _GnomeCanvas *)return_value_g_type_check_instance_cast$2, (double)(-widget->allocation.width / 2), (double)(-widget->allocation.height / 2), (double)(widget->allocation.width / 2), (double)(widget->allocation.height / 2));
  ask_reposition(0);
  canvas=glade_xml_get_widget(appdata.xml, "canvas1");
  update_diagram(canvas);
}

// on_center_node_changed
// file pref_dialog.c line 457
static void on_center_node_changed(struct _GtkComboBoxEntry *cbox, void *user_data)
{
  char *str;
  unsigned long int return_value_gtk_combo_box_get_type$1;
  return_value_gtk_combo_box_get_type$1=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)cbox, return_value_gtk_combo_box_get_type$1);
  str=gtk_combo_box_get_active_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$2);
  g_free((void *)pref.center_node);
  pref.center_node=g_strdup(str);
  g_free((void *)str);
  cbox_add_select(cbox, pref.center_node);
}

// on_color_add_button_clicked
// file pref_dialog.c line 527
void on_color_add_button_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GtkWidget *dlg;
  dlg=glade_xml_get_widget(appdata.xml, "colorselectiondialog");
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)dlg, (unsigned long int)(20 << 2));
  g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "isadd", (void *)(signed long int)!(0 != 0));
  gtk_widget_show(dlg);
}

// on_color_change_button_clicked
// file pref_dialog.c line 536
void on_color_change_button_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GtkTreePath *gpath;
  struct _GtkTreeViewColumn *gcol;
  struct _GtkTreeIter it;
  struct _GdkColor *gdk_color;
  struct _GtkColorSelectionDialog *dlg;
  struct _GtkColorSelection *csel;
  struct _EATreePos ep;
  signed int return_value_get_color_store$1;
  return_value_get_color_store$1=get_color_store(&ep);
  if(!(return_value_get_color_store$1 == 0))
  {
    gtk_tree_view_get_cursor(ep.gv, &gpath, &gcol);
    if(!(gpath == ((struct _GtkTreePath *)NULL)))
    {
      unsigned long int return_value_gtk_tree_model_get_type$2;
      return_value_gtk_tree_model_get_type$2=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
      return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)ep.gs, return_value_gtk_tree_model_get_type$2);
      signed int return_value_gtk_tree_model_get_iter$4;
      return_value_gtk_tree_model_get_iter$4=gtk_tree_model_get_iter((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$3, &it, gpath);
      if(!(return_value_gtk_tree_model_get_iter$4 == 0))
      {
        unsigned long int return_value_gtk_tree_model_get_type$5;
        return_value_gtk_tree_model_get_type$5=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
        return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)ep.gs, return_value_gtk_tree_model_get_type$5);
        gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$6, &it, 1, &gdk_color, -1);
        struct _GtkWidget *return_value_glade_xml_get_widget$7;
        return_value_glade_xml_get_widget$7=glade_xml_get_widget(appdata.xml, "colorselectiondialog");
        unsigned long int return_value_gtk_color_selection_dialog_get_type$8;
        return_value_gtk_color_selection_dialog_get_type$8=gtk_color_selection_dialog_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
        return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$7, return_value_gtk_color_selection_dialog_get_type$8);
        dlg = (struct _GtkColorSelectionDialog *)return_value_g_type_check_instance_cast$9;
        unsigned long int return_value_gtk_color_selection_get_type$10;
        return_value_gtk_color_selection_get_type$10=gtk_color_selection_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
        return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)dlg->colorsel, return_value_gtk_color_selection_get_type$10);
        csel = (struct _GtkColorSelection *)return_value_g_type_check_instance_cast$11;
        gtk_color_selection_set_current_color(csel, gdk_color);
        gtk_color_selection_set_previous_color(csel, gdk_color);
        struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
        return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)dlg, (unsigned long int)(20 << 2));
        g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$12, "isadd", (void *)(signed long int)0);
        unsigned long int return_value_gtk_widget_get_type$13;
        return_value_gtk_widget_get_type$13=gtk_widget_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
        return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)dlg, return_value_gtk_widget_get_type$13);
        gtk_widget_show((struct _GtkWidget *)return_value_g_type_check_instance_cast$14);
      }

    }

  }

}

// on_color_remove_button_clicked
// file pref_dialog.c line 572
void on_color_remove_button_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GtkTreePath *gpath = (struct _GtkTreePath *)(void *)0;
  struct _GtkTreeViewColumn *gcol = (struct _GtkTreeViewColumn *)(void *)0;
  struct _GtkTreeIter it;
  struct _EATreePos ep;
  signed int return_value_get_color_store$1;
  return_value_get_color_store$1=get_color_store(&ep);
  if(!(return_value_get_color_store$1 == 0))
  {
    gtk_tree_view_get_cursor(ep.gv, &gpath, &gcol);
    if(!(gpath == ((struct _GtkTreePath *)NULL)))
    {
      unsigned long int return_value_gtk_tree_model_get_type$2;
      return_value_gtk_tree_model_get_type$2=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
      return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)ep.gs, return_value_gtk_tree_model_get_type$2);
      signed int return_value_gtk_tree_model_get_iter$4;
      return_value_gtk_tree_model_get_iter$4=gtk_tree_model_get_iter((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$3, &it, gpath);
      if(!(return_value_gtk_tree_model_get_iter$4 == 0))
      {
        signed int return_value_gtk_list_store_remove$7;
        return_value_gtk_list_store_remove$7=gtk_list_store_remove(ep.gs, &it);
        if(!(return_value_gtk_list_store_remove$7 == 0))
        {
          unsigned long int return_value_gtk_tree_model_get_type$5;
          return_value_gtk_tree_model_get_type$5=gtk_tree_model_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
          return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)ep.gs, return_value_gtk_tree_model_get_type$5);
          gpath=gtk_tree_model_get_path((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$6, &it);
          gtk_tree_view_set_cursor(ep.gv, gpath, (struct _GtkTreeViewColumn *)(void *)0, 0);
          gtk_tree_path_free(gpath);
        }

        colors_changed = (signed int)!(0 != 0);
        color_list_to_pref();
      }

    }

  }

}

// on_colordiag_ok_clicked
// file pref_dialog.c line 608
void on_colordiag_ok_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GtkWidget *colorsel;
  struct _GtkWidget *colorseldiag;
  struct _GdkColor gdk_color;
  struct _GtkTreePath *gpath = (struct _GtkTreePath *)(void *)0;
  struct _GtkTreeViewColumn *gcol = (struct _GtkTreeViewColumn *)(void *)0;
  struct _GtkTreeIter it;
  signed int isadd;
  struct _EATreePos ep;
  signed int return_value_get_color_store$1;
  return_value_get_color_store$1=get_color_store(&ep);
  _Bool tmp_if_expr$10;
  unsigned long int return_value_gtk_tree_model_get_type$7;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  signed int return_value_gtk_tree_model_get_iter$9;
  if(!(return_value_get_color_store$1 == 0))
  {
    colorseldiag=glade_xml_get_widget(appdata.xml, "colorselectiondialog");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)colorseldiag, (unsigned long int)(20 << 2));
    void *return_value_g_object_get_data$3;
    return_value_g_object_get_data$3=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$2, "isadd");
    isadd = (signed int)(signed long int)return_value_g_object_get_data$3;
    gtk_tree_view_get_cursor(ep.gv, &gpath, &gcol);
    if(!(isadd == 0))
    {
      if(!(gpath == ((struct _GtkTreePath *)NULL)))
      {
        struct _GtkTreeIter itsibling;
        unsigned long int return_value_gtk_tree_model_get_type$4;
        return_value_gtk_tree_model_get_type$4=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
        return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)ep.gs, return_value_gtk_tree_model_get_type$4);
        signed int return_value_gtk_tree_model_get_iter$6;
        return_value_gtk_tree_model_get_iter$6=gtk_tree_model_get_iter((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$5, &itsibling, gpath);
        if(return_value_gtk_tree_model_get_iter$6 == 0)
          goto __CPROVER_DUMP_L12;

        gtk_list_store_insert_before(ep.gs, &it, &itsibling);
      }

      else
        gtk_list_store_append(ep.gs, &it);
    }

    else
    {
      if(gpath == ((struct _GtkTreePath *)NULL))
        tmp_if_expr$10 = (_Bool)1;

      else
      {
        return_value_gtk_tree_model_get_type$7=gtk_tree_model_get_type();
        return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)ep.gs, return_value_gtk_tree_model_get_type$7);
        return_value_gtk_tree_model_get_iter$9=gtk_tree_model_get_iter((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$8, &it, gpath);
        tmp_if_expr$10 = !(return_value_gtk_tree_model_get_iter$9 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$10)
        goto __CPROVER_DUMP_L12;

    }
    unsigned long int return_value_gtk_color_selection_dialog_get_type$11;
    return_value_gtk_color_selection_dialog_get_type$11=gtk_color_selection_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)colorseldiag, return_value_gtk_color_selection_dialog_get_type$11);
    colorsel = ((struct _GtkColorSelectionDialog *)return_value_g_type_check_instance_cast$12)->colorsel;
    unsigned long int return_value_gtk_color_selection_get_type$13;
    return_value_gtk_color_selection_get_type$13=gtk_color_selection_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
    return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)colorsel, return_value_gtk_color_selection_get_type$13);
    gtk_color_selection_get_current_color((struct _GtkColorSelection *)return_value_g_type_check_instance_cast$14, &gdk_color);
    gdk_color.red = (unsigned short int)(((signed int)gdk_color.red >> 8) << 8);
    gdk_color.green = (unsigned short int)(((signed int)gdk_color.green >> 8) << 8);
    gdk_color.blue = (unsigned short int)(((signed int)gdk_color.blue >> 8) << 8);
    if(!(isadd == 0))
      gtk_list_store_set(ep.gs, &it, 0, (const void *)"        ", 1, &gdk_color, 2, (const void *)"", -1);

    else
      gtk_list_store_set(ep.gs, &it, 0, (const void *)"        ", 1, &gdk_color, -1);
    gtk_widget_hide(colorseldiag);
    color_list_to_pref();
    colors_changed = (signed int)!(0 != 0);
  }


__CPROVER_DUMP_L12:
  ;
}

// on_delete_protocol_window
// file info_windows.c line 591
signed int on_delete_protocol_window(struct _GtkWidget *wdg, union _GdkEvent *evt, void *ud)
{
  toggle_protocols_window();
  return (signed int)!(0 != 0);
}

// on_diagram_only_toggle_toggled
// file pref_dialog.c line 388
void on_diagram_only_toggle_toggled(struct _GtkToggleButton *togglebutton, void *user_data)
{
  pref.diagram_only=gtk_toggle_button_get_active(togglebutton);
  ask_reposition(0);
}

// on_export_activate
// file menus.c line 136
void on_export_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  struct _GtkWidget *dialog;
  dialog=gtk_file_chooser_dialog_new("Export to XML File", (struct _GtkWindow *)(void *)0, (enum anonymous$66)GTK_FILE_CHOOSER_ACTION_SAVE, "gtk-cancel", -6, (const void *)"gtk-save", -3, (void *)0);
  unsigned long int return_value_gtk_file_chooser_get_type$1;
  return_value_gtk_file_chooser_get_type$1=gtk_file_chooser_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$1);
  gtk_file_chooser_set_do_overwrite_confirmation((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$2, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_file_chooser_get_type$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  if(!(appdata.export_file == ((char *)NULL)))
  {
    return_value_gtk_file_chooser_get_type$3=gtk_file_chooser_get_type();
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$3);
    gtk_file_chooser_set_filename((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$4, appdata.export_file);
  }

  unsigned long int return_value_gtk_dialog_get_type$10;
  return_value_gtk_dialog_get_type$10=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$10);
  signed int return_value_gtk_dialog_run$12;
  return_value_gtk_dialog_run$12=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$11);
  if(return_value_gtk_dialog_run$12 == -3)
  {
    struct _GtkRecentManager *manager;
    manager=gtk_recent_manager_get_default();
    unsigned long int return_value_gtk_file_chooser_get_type$5;
    return_value_gtk_file_chooser_get_type$5=gtk_file_chooser_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$5);
    char *return_value_gtk_file_chooser_get_uri$7;
    return_value_gtk_file_chooser_get_uri$7=gtk_file_chooser_get_uri((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$6);
    gtk_recent_manager_add_item(manager, return_value_gtk_file_chooser_get_uri$7);
    g_free((void *)appdata.export_file);
    unsigned long int return_value_gtk_file_chooser_get_type$8;
    return_value_gtk_file_chooser_get_type$8=gtk_file_chooser_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$8);
    appdata.export_file=gtk_file_chooser_get_filename((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$9);
    gtk_widget_destroy(dialog);
    dump_xml(appdata.export_file);
  }

  else
    gtk_widget_destroy(dialog);
}

// on_filter_entry_changed
// file pref_dialog.c line 440
static void on_filter_entry_changed(struct _GtkComboBoxEntry *cbox, void *user_data)
{
  char *str;
  unsigned long int return_value_gtk_combo_box_get_type$1;
  return_value_gtk_combo_box_get_type$1=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)cbox, return_value_gtk_combo_box_get_type$1);
  str=gtk_combo_box_get_active_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$2);
  if(!(pref.filter == ((char *)NULL)))
    g_free((void *)pref.filter);

  pref.filter=g_strdup(str);
  set_filter(pref.filter, (char *)(void *)0);
  g_free((void *)str);
  cbox_add_select(cbox, pref.filter);
}

// on_full_screen_activate
// file menus.c line 289
void on_full_screen_activate(struct _GtkCheckMenuItem *menuitem, void *user_data)
{
  if(!(menuitem->active == 0u))
    gtk_window_fullscreen((struct _GtkWindow *)appdata.app1);

  else
    gtk_window_unfullscreen((struct _GtkWindow *)appdata.app1);
}

// on_group_unk_check_toggled
// file pref_dialog.c line 396
void on_group_unk_check_toggled(struct _GtkToggleButton *togglebutton, void *user_data)
{
  pref.group_unk=gtk_toggle_button_get_active(togglebutton);
}

// on_gui_link_to_spin_adjustment_changed
// file pref_dialog.c line 329
void on_gui_link_to_spin_adjustment_changed(struct _GtkAdjustment *adj)
{
  pref.gui_link_timeout_time = adj->value * 1000.0;
}

// on_gui_node_to_spin_adjustment_changed
// file pref_dialog.c line 311
void on_gui_node_to_spin_adjustment_changed(struct _GtkAdjustment *adj)
{
  pref.gui_node_timeout_time = adj->value * 1000.0;
}

// on_help_activate
// file menus.c line 355
void on_help_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  struct _GError *err = (struct _GError *)(void *)0;
  signed int success = 0;
  success=gtk_show_uri((struct _GdkScreen *)(void *)0, "ghelp:etherape", (unsigned int)0L, &err);
}

// on_interface_radio_activate
// file menus.c line 170
void on_interface_radio_activate(char *gui_device)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(gui_device == ((char *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "menus.c", 172, (const char *)"on_interface_radio_activate", "gui_device != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  if(!(appdata.interface == ((char *)NULL)))
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$3;
    return_value___builtin_strcmp$3=__builtin_strcmp(gui_device, appdata.interface);
    tmp_statement_expression$2 = return_value___builtin_strcmp$3;
    if(tmp_statement_expression$2 == 0)
      goto __CPROVER_DUMP_L9;

  }

  if(in_start_capture == 0)
  {
    signed int return_value_gui_stop_capture$4;
    return_value_gui_stop_capture$4=gui_stop_capture();
    if(!(return_value_gui_stop_capture$4 == 0))
    {
      if(!(appdata.input_file == ((char *)NULL)))
        g_free((void *)appdata.input_file);

      appdata.input_file = (char *)(void *)0;
      if(!(appdata.interface == ((char *)NULL)))
        g_free((void *)appdata.interface);

      appdata.interface=g_strdup(gui_device);
      gui_start_capture();
      char *return_value_dcgettext$5;
      return_value_dcgettext$5=dcgettext((const char *)(void *)0, "Capture interface set to %s in GUI", 5);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$5, gui_device);
    }

  }


__CPROVER_DUMP_L9:
  ;
}

// on_legend_check_activate
// file menus.c line 311
void on_legend_check_activate(struct _GtkCheckMenuItem *menuitem, void *user_data)
{
  struct _GtkWidget *widget;
  widget=glade_xml_get_widget(appdata.xml, "handlebox_legend");
  if(!(menuitem->active == 0u))
    gtk_widget_show(widget);

  else
    gtk_widget_hide(widget);
}

// on_link_to_spin_adjustment_changed
// file pref_dialog.c line 323
void on_link_to_spin_adjustment_changed(struct _GtkAdjustment *adj)
{
  pref.link_timeout_time = adj->value * 1000.0;
}

// on_link_width_slider_adjustment_changed
// file pref_dialog.c line 282
void on_link_width_slider_adjustment_changed(struct _GtkAdjustment *adj)
{
  pref.link_node_ratio = adj->value;
  char *return_value_dcgettext$1;
  return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Adjustment value: %g. Link-node ratio %g", 5);
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, return_value_dcgettext$1, adj->value, pref.link_node_ratio);
}

// on_mode_radio_activate
// file menus.c line 199
void on_mode_radio_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  enum anonymous$13 new_mode = (enum anonymous$13)APEMODE_DEFAULT;
  const char *menuname = (const char *)(void *)0;
  char *filter;
  signed int tmp_statement_expression$3;
  signed int tmp_statement_expression$8;
  signed int tmp_statement_expression$6;
  signed int tmp_statement_expression$4;
  signed int tmp_statement_expression$14;
  if(in_start_capture == 0)
  {
    unsigned long int return_value_gtk_widget_get_type$1;
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_widget_get_type$1);
    menuname=gtk_widget_get_name((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
    do
    {
      signed int _g_boolean_var_;
      if(!(menuname == ((const char *)NULL)))
        _g_boolean_var_ = 1;

      else
        _g_boolean_var_ = 0;
      tmp_statement_expression$3 = _g_boolean_var_;
      if((signed long int)tmp_statement_expression$3 == 0l)
        g_assertion_message_expr((char *)0, "menus.c", 211, (const char *)"on_mode_radio_activate", "menuname");

    }
    while((_Bool)0);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Initial mode in on_mode_radio_activate %s", (char *)menuname);
    unsigned long int on_mode_radio_activate$$1$$2$$__s1_len;
    unsigned long int on_mode_radio_activate$$1$$2$$__s2_len;
    signed int return_value___builtin_strcmp$9;
    return_value___builtin_strcmp$9=__builtin_strcmp("link_radio", menuname);
    tmp_statement_expression$8 = return_value___builtin_strcmp$9;
    if(tmp_statement_expression$8 == 0)
      new_mode = (enum anonymous$13)LINK6;

    else
    {
      unsigned long int on_mode_radio_activate$$1$$3$$__s1_len;
      unsigned long int on_mode_radio_activate$$1$$3$$__s2_len;
      signed int return_value___builtin_strcmp$7;
      return_value___builtin_strcmp$7=__builtin_strcmp("ip_radio", menuname);
      tmp_statement_expression$6 = return_value___builtin_strcmp$7;
      if(tmp_statement_expression$6 == 0)
        new_mode = (enum anonymous$13)IP;

      else
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp$5;
        return_value___builtin_strcmp$5=__builtin_strcmp("tcp_radio", menuname);
        tmp_statement_expression$4 = return_value___builtin_strcmp$5;
        if(tmp_statement_expression$4 == 0)
          new_mode = (enum anonymous$13)TCP;

        else
        {
          g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, "Unsopported mode in on_mode_radio_activate");
          exit(1);
        }
      }
    }
    if(!(new_mode == appdata.mode))
    {
      unsigned long int return_value_gtk_check_menu_item_get_type$10;
      return_value_gtk_check_menu_item_get_type$10=gtk_check_menu_item_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
      return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$10);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Mode menuitem active: %d", ((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$11)->active);
      signed int return_value_has_linklevel$12;
      return_value_has_linklevel$12=has_linklevel();
      if(return_value_has_linklevel$12 == 0)
      {
        if(!((signed int)new_mode == LINK6))
          goto __CPROVER_DUMP_L12;

      }

      else
      {

      __CPROVER_DUMP_L12:
        ;
        signed int return_value_gui_stop_capture$13;
        return_value_gui_stop_capture$13=gui_stop_capture();
        if(!(return_value_gui_stop_capture$13 == 0))
        {
          filter=get_default_filter(appdata.mode);
          unsigned long int on_mode_radio_activate$$1$$6$$__s1_len;
          unsigned long int on_mode_radio_activate$$1$$6$$__s2_len;
          signed int return_value___builtin_strcmp$15;
          return_value___builtin_strcmp$15=__builtin_strcmp(pref.filter, filter);
          tmp_statement_expression$14 = return_value___builtin_strcmp$15;
          if(tmp_statement_expression$14 == 0)
          {
            g_free((void *)pref.filter);
            pref.filter=get_default_filter(new_mode);
          }

          appdata.mode = new_mode;
          char *return_value_dcgettext$16;
          return_value_dcgettext$16=dcgettext((const char *)(void *)0, "Mode set to %s in GUI", 5);
          g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$16, (char *)menuitem);
          gui_start_capture();
        }

      }
    }

  }

}

// on_name_motion_notify_event
// file callbacks.c line 59
signed int on_name_motion_notify_event(struct _GtkWidget *widget, struct _GdkEventMotion *event, void *user_data)
{
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_MESSAGE, "Motion in name label");
  return 0;
}

// on_next_menuitem_activate
// file menus.c line 271
void on_next_menuitem_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "on_next_menuitem_activate called");
  force_next_packet();
}

// on_node_info_delete_event
// file info_windows.c line 701
signed int on_node_info_delete_event(struct _GtkWidget *node_info, union _GdkEvent *evt, void *user_data)
{
  stats_info_windows=g_list_remove(stats_info_windows, (const void *)node_info);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)node_info, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$2;
  return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "node_id");
  g_free(return_value_g_object_get_data$2);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)node_info, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$4;
  return_value_g_object_get_data$4=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$3, "link_id");
  g_free(return_value_g_object_get_data$4);
  gtk_widget_destroy(node_info);
  return 0;
}

// on_node_popup_motion_notify_event
// file callbacks.c line 49
signed int on_node_popup_motion_notify_event(struct _GtkWidget *widget, struct _GdkEventMotion *event, void *user_data)
{
  gtk_widget_destroy(widget);
  return 0;
}

// on_node_radius_slider_adjustment_changed
// file pref_dialog.c line 271
void on_node_radius_slider_adjustment_changed(struct _GtkAdjustment *adj)
{
  double return_value_log$1;
  return_value_log$1=log((double)10);
  pref.node_radius_multiplier=exp((double)adj->value * return_value_log$1);
  char *return_value_dcgettext$2;
  return_value_dcgettext$2=dcgettext((const char *)(void *)0, "Adjustment value: %g. Radius multiplier %g", 5);
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, return_value_dcgettext$2, adj->value, pref.node_radius_multiplier);
}

// on_node_to_spin_adjustment_changed
// file pref_dialog.c line 305
void on_node_to_spin_adjustment_changed(struct _GtkAdjustment *adj)
{
  pref.node_timeout_time = adj->value * 1000.0;
}

// on_nodes_check_toggled
// file node_windows.c line 406
void on_nodes_check_toggled(struct _GtkCheckMenuItem *checkmenuitem, void *data)
{
  signed int return_value_gtk_check_menu_item_get_active$1;
  return_value_gtk_check_menu_item_get_active$1=gtk_check_menu_item_get_active(checkmenuitem);
  if(!(return_value_gtk_check_menu_item_get_active$1 == 0))
    nodes_wnd_show();

  else
    nodes_wnd_hide();
}

// on_nodes_table_row_activated
// file node_windows.c line 423
void on_nodes_table_row_activated(struct _GtkTreeView *gv, struct _GtkTreePath *sorted_path, struct _GtkTreeViewColumn *column, void *data)
{
  struct _GtkTreeModel *sort_model;
  struct _GtkTreeModel *gls;
  struct _GtkTreePath *path;
  struct _GtkTreeIter it;
  sort_model=gtk_tree_view_get_model(gv);
  if(!(sort_model == ((struct _GtkTreeModel *)NULL)))
  {
    unsigned long int return_value_gtk_tree_model_sort_get_type$1;
    return_value_gtk_tree_model_sort_get_type$1=gtk_tree_model_sort_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)sort_model, return_value_gtk_tree_model_sort_get_type$1);
    gls=gtk_tree_model_sort_get_model((struct _GtkTreeModelSort *)return_value_g_type_check_instance_cast$2);
    if(!(gls == ((struct _GtkTreeModel *)NULL)))
    {
      unsigned long int return_value_gtk_tree_model_sort_get_type$3;
      return_value_gtk_tree_model_sort_get_type$3=gtk_tree_model_sort_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)sort_model, return_value_gtk_tree_model_sort_get_type$3);
      path=gtk_tree_model_sort_convert_path_to_child_path((struct _GtkTreeModelSort *)return_value_g_type_check_instance_cast$4, sorted_path);
      if(!(path == ((struct _GtkTreePath *)NULL)))
      {
        signed int return_value_gtk_tree_model_get_iter$5;
        return_value_gtk_tree_model_get_iter$5=gtk_tree_model_get_iter(gls, &it, path);
        if(!(return_value_gtk_tree_model_get_iter$5 == 0))
        {
          struct anonymous$5 *rowitem;
          gtk_tree_model_get(gls, &it, 7, &rowitem, -1);
          node_protocols_window_create(rowitem);
        }

        gtk_tree_path_free(path);
      }

    }

  }

}

// on_nodes_toolbar_button_clicked
// file node_windows.c line 414
void on_nodes_toolbar_button_clicked(void)
{
  struct _GtkWidget *on_nodes_toolbar_button_clicked$$1$$nodes_check;
  on_nodes_toolbar_button_clicked$$1$$nodes_check=glade_xml_get_widget(appdata.xml, "nodes_check");
  if(!(on_nodes_toolbar_button_clicked$$1$$nodes_check == ((struct _GtkWidget *)NULL)))
  {
    unsigned long int return_value_gtk_menu_item_get_type$1;
    return_value_gtk_menu_item_get_type$1=gtk_menu_item_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)on_nodes_toolbar_button_clicked$$1$$nodes_check, return_value_gtk_menu_item_get_type$1);
    gtk_menu_item_activate((struct _GtkMenuItem *)return_value_g_type_check_instance_cast$2);
  }

}

// on_nodes_wnd_delete_event
// file node_windows.c line 400
signed int on_nodes_wnd_delete_event(struct _GtkWidget *wdg, union _GdkEvent *evt, void *ud)
{
  nodes_wnd_hide();
  return (signed int)!(0 != 0);
}

// on_numeric_toggle_toggled
// file pref_dialog.c line 468
void on_numeric_toggle_toggled(struct _GtkToggleButton *togglebutton, void *user_data)
{
  pref.name_res=gtk_toggle_button_get_active(togglebutton);
}

// on_ok_pref_button_clicked
// file pref_dialog.c line 406
void on_ok_pref_button_clicked(struct _GtkButton *button, void *user_data)
{
  confirm_changes();
  hide_pref_dialog();
}

// on_open_activate
// file menus.c line 100
void on_open_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  struct _GtkWidget *dialog;
  signed int return_value_gui_stop_capture$1;
  return_value_gui_stop_capture$1=gui_stop_capture();
  unsigned long int return_value_gtk_file_chooser_get_type$2;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  if(!(return_value_gui_stop_capture$1 == 0))
  {
    dialog=gtk_file_chooser_dialog_new("Open Capture File", (struct _GtkWindow *)(void *)0, (enum anonymous$66)GTK_FILE_CHOOSER_ACTION_OPEN, "gtk-cancel", -6, (const void *)"gtk-open", -3, (void *)0);
    if(!(appdata.input_file == ((char *)NULL)))
    {
      return_value_gtk_file_chooser_get_type$2=gtk_file_chooser_get_type();
      return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$2);
      gtk_file_chooser_set_filename((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$3, appdata.input_file);
    }

    unsigned long int return_value_gtk_dialog_get_type$9;
    return_value_gtk_dialog_get_type$9=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$9);
    signed int return_value_gtk_dialog_run$11;
    return_value_gtk_dialog_run$11=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$10);
    if(return_value_gtk_dialog_run$11 == -3)
    {
      struct _GtkRecentManager *manager;
      manager=gtk_recent_manager_get_default();
      unsigned long int return_value_gtk_file_chooser_get_type$4;
      return_value_gtk_file_chooser_get_type$4=gtk_file_chooser_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$4);
      char *return_value_gtk_file_chooser_get_uri$6;
      return_value_gtk_file_chooser_get_uri$6=gtk_file_chooser_get_uri((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$5);
      gtk_recent_manager_add_item(manager, return_value_gtk_file_chooser_get_uri$6);
      g_free((void *)appdata.input_file);
      unsigned long int return_value_gtk_file_chooser_get_type$7;
      return_value_gtk_file_chooser_get_type$7=gtk_file_chooser_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$7);
      appdata.input_file=gtk_file_chooser_get_filename((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$8);
      gtk_widget_destroy(dialog);
      g_free((void *)appdata.interface);
      appdata.interface = (char *)(void *)0;
      gui_start_capture();
    }

    else
      gtk_widget_destroy(dialog);
  }

}

// on_pause_menuitem_activate
// file menus.c line 264
void on_pause_menuitem_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "on_pause_menuitem_activate called");
  gui_pause_capture();
}

// on_preferences1_activate
// file pref_dialog.c line 251
void on_preferences1_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  struct _GtkComboBoxEntry *cbox;
  tmp_pref=duplicate_config(&pref);
  initialize_pref_controls();
  struct _GtkWidget *return_value_glade_xml_get_widget$1;
  return_value_glade_xml_get_widget$1=glade_xml_get_widget(appdata.xml, "filter_combo");
  unsigned long int return_value_gtk_combo_box_entry_get_type$2;
  return_value_gtk_combo_box_entry_get_type$2=gtk_combo_box_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$1, return_value_gtk_combo_box_entry_get_type$2);
  cbox = (struct _GtkComboBoxEntry *)return_value_g_type_check_instance_cast$3;
  cbox_add_select(cbox, pref.filter);
  struct _GtkWidget *return_value_glade_xml_get_widget$4;
  return_value_glade_xml_get_widget$4=glade_xml_get_widget(appdata.xml, "center_combo");
  unsigned long int return_value_gtk_combo_box_entry_get_type$5;
  return_value_gtk_combo_box_entry_get_type$5=gtk_combo_box_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$4, return_value_gtk_combo_box_entry_get_type$5);
  cbox = (struct _GtkComboBoxEntry *)return_value_g_type_check_instance_cast$6;
  cbox_add_select(cbox, pref.center_node);
  gtk_widget_show(diag_pref);
  gdk_window_raise(diag_pref->window);
}

// on_prot_info_delete_event
// file info_windows.c line 155
signed int on_prot_info_delete_event(struct _GtkWidget *prot_info, union _GdkEvent *evt, void *user_data)
{
  struct _GList *item = (struct _GList *)(void *)0;
  char *prot_name = (char *)(void *)0;
  struct anonymous$29 *prot_info_window = (struct anonymous$29 *)(void *)0;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)prot_info, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$2;
  return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "prot_name");
  prot_name = (char *)return_value_g_object_get_data$2;
  if(prot_name == ((char *)NULL))
  {
    char *return_value_dcgettext$3;
    return_value_dcgettext$3=dcgettext((const char *)(void *)0, "No prot_name in on_prot_info_delete_event", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, return_value_dcgettext$3);
    return (signed int)!(0 != 0);
  }

  item=g_list_find_custom(prot_info_windows, (const void *)prot_name, prot_info_compare);
  if(item == ((struct _GList *)NULL))
  {
    char *return_value_dcgettext$4;
    return_value_dcgettext$4=dcgettext((const char *)(void *)0, "No prot_info_window in on_prot_info_delete_event", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, return_value_dcgettext$4);
    return (signed int)!(0 != 0);
  }

  prot_info_window = (struct anonymous$29 *)item->data;
  g_free((void *)prot_info_window->prot_name);
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)prot_info_window->window, return_value_gtk_widget_get_type$5);
  gtk_widget_destroy((struct _GtkWidget *)return_value_g_type_check_instance_cast$6);
  prot_info_windows=g_list_remove_link(prot_info_windows, item);
  return 0;
}

// on_prot_list_select_row
// file info_windows.c line 626
signed int on_prot_list_select_row(struct _GtkTreeView *gv, signed int arg1, void *user_data)
{
  struct anonymous$26 *protocol = (struct anonymous$26 *)(void *)0;
  struct _GtkListStore *gs;
  struct _GtkTreePath *gpath = (struct _GtkTreePath *)(void *)0;
  struct _GtkTreeViewColumn *gcol = (struct _GtkTreeViewColumn *)(void *)0;
  struct _GtkTreeIter it;
  struct _GtkTreeModel *return_value_gtk_tree_view_get_model$1;
  return_value_gtk_tree_view_get_model$1=gtk_tree_view_get_model(gv);
  unsigned long int return_value_gtk_list_store_get_type$2;
  return_value_gtk_list_store_get_type$2=gtk_list_store_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_tree_view_get_model$1, return_value_gtk_list_store_get_type$2);
  gs = (struct _GtkListStore *)return_value_g_type_check_instance_cast$3;
  if(gs == ((struct _GtkListStore *)NULL))
    return 0;

  else
  {
    gtk_tree_view_get_cursor(gv, &gpath, &gcol);
    if(gpath == ((struct _GtkTreePath *)NULL))
      return 0;

    else
    {
      unsigned long int return_value_gtk_tree_model_get_type$4;
      return_value_gtk_tree_model_get_type$4=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)gs, return_value_gtk_tree_model_get_type$4);
      signed int return_value_gtk_tree_model_get_iter$6;
      return_value_gtk_tree_model_get_iter$6=gtk_tree_model_get_iter((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$5, &it, gpath);
      if(return_value_gtk_tree_model_get_iter$6 == 0)
        return 0;

      else
      {
        unsigned long int return_value_gtk_tree_model_get_type$7;
        return_value_gtk_tree_model_get_type$7=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
        return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)gs, return_value_gtk_tree_model_get_type$7);
        gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$8, &it, 8, &protocol, -1);
        create_prot_info_window(protocol);
        return (signed int)!(0 != 0);
      }
    }
  }
}

// on_proto_link_to_spin_adjustment_changed
// file pref_dialog.c line 335
void on_proto_link_to_spin_adjustment_changed(struct _GtkAdjustment *adj)
{
  pref.proto_link_timeout_time = adj->value * 1000.0;
}

// on_proto_node_to_spin_adjustment_changed
// file pref_dialog.c line 317
void on_proto_node_to_spin_adjustment_changed(struct _GtkAdjustment *adj)
{
  pref.proto_node_timeout_time = adj->value * 1000.0;
}

// on_proto_to_spin_adjustment_changed
// file pref_dialog.c line 341
void on_proto_to_spin_adjustment_changed(struct _GtkAdjustment *adj)
{
  pref.proto_timeout_time = adj->value * 1000.0;
}

// on_protocol_edit_button_clicked
// file pref_dialog.c line 672
void on_protocol_edit_button_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GtkWidget *protocol_edit_dialog = (struct _GtkWidget *)(void *)0;
  protocol_edit_dialog=glade_xml_get_widget(appdata.xml, "protocol_edit_dialog");
  gtk_widget_show(protocol_edit_dialog);
}

// on_protocol_edit_dialog_show
// file pref_dialog.c line 680
void on_protocol_edit_dialog_show(struct _GtkWidget *wdg, void *user_data)
{
  char *protocol_string;
  struct _GtkTreePath *gpath = (struct _GtkTreePath *)(void *)0;
  struct _GtkTreeViewColumn *gcol = (struct _GtkTreeViewColumn *)(void *)0;
  struct _GtkTreeIter it;
  struct _GtkComboBoxEntry *cbox;
  struct _EATreePos ep;
  signed int return_value_get_color_store$1;
  return_value_get_color_store$1=get_color_store(&ep);
  if(!(return_value_get_color_store$1 == 0))
  {
    gtk_tree_view_get_cursor(ep.gv, &gpath, &gcol);
    if(!(gpath == ((struct _GtkTreePath *)NULL)))
    {
      unsigned long int return_value_gtk_tree_model_get_type$2;
      return_value_gtk_tree_model_get_type$2=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
      return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)ep.gs, return_value_gtk_tree_model_get_type$2);
      signed int return_value_gtk_tree_model_get_iter$4;
      return_value_gtk_tree_model_get_iter$4=gtk_tree_model_get_iter((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$3, &it, gpath);
      if(!(return_value_gtk_tree_model_get_iter$4 == 0))
      {
        unsigned long int return_value_gtk_tree_model_get_type$5;
        return_value_gtk_tree_model_get_type$5=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
        return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)ep.gs, return_value_gtk_tree_model_get_type$5);
        gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$6, &it, 2, &protocol_string, -1);
        struct _GtkWidget *return_value_glade_xml_get_widget$7;
        return_value_glade_xml_get_widget$7=glade_xml_get_widget(appdata.xml, "protocol_entry");
        unsigned long int return_value_gtk_combo_box_entry_get_type$8;
        return_value_gtk_combo_box_entry_get_type$8=gtk_combo_box_entry_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
        return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$7, return_value_gtk_combo_box_entry_get_type$8);
        cbox = (struct _GtkComboBoxEntry *)return_value_g_type_check_instance_cast$9;
        cbox_add_select(cbox, protocol_string);
        g_free((void *)protocol_string);
      }

    }

  }

}

// on_protocol_edit_ok_clicked
// file pref_dialog.c line 710
void on_protocol_edit_ok_clicked(struct _GtkButton *button, void *user_data)
{
  char *proto_string;
  struct _GtkTreePath *gpath = (struct _GtkTreePath *)(void *)0;
  struct _GtkTreeViewColumn *gcol = (struct _GtkTreeViewColumn *)(void *)0;
  struct _GtkTreeIter it;
  struct _GtkComboBoxEntry *cbox;
  struct _EATreePos ep;
  signed int return_value_get_color_store$1;
  return_value_get_color_store$1=get_color_store(&ep);
  if(!(return_value_get_color_store$1 == 0))
  {
    gtk_tree_view_get_cursor(ep.gv, &gpath, &gcol);
    if(!(gpath == ((struct _GtkTreePath *)NULL)))
    {
      unsigned long int return_value_gtk_tree_model_get_type$2;
      return_value_gtk_tree_model_get_type$2=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
      return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)ep.gs, return_value_gtk_tree_model_get_type$2);
      signed int return_value_gtk_tree_model_get_iter$4;
      return_value_gtk_tree_model_get_iter$4=gtk_tree_model_get_iter((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$3, &it, gpath);
      if(!(return_value_gtk_tree_model_get_iter$4 == 0))
      {
        struct _GtkWidget *return_value_glade_xml_get_widget$5;
        return_value_glade_xml_get_widget$5=glade_xml_get_widget(appdata.xml, "protocol_entry");
        unsigned long int return_value_gtk_combo_box_entry_get_type$6;
        return_value_gtk_combo_box_entry_get_type$6=gtk_combo_box_entry_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
        return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$5, return_value_gtk_combo_box_entry_get_type$6);
        cbox = (struct _GtkComboBoxEntry *)return_value_g_type_check_instance_cast$7;
        unsigned long int return_value_gtk_combo_box_get_type$8;
        return_value_gtk_combo_box_get_type$8=gtk_combo_box_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
        return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)cbox, return_value_gtk_combo_box_get_type$8);
        proto_string=gtk_combo_box_get_active_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$9);
        proto_string=g_utf8_strup(proto_string, (signed long int)-1);
        proto_string=remove_spaces(proto_string);
        cbox_add_select(cbox, proto_string);
        gtk_list_store_set(ep.gs, &it, 2, proto_string, -1);
        g_free((void *)proto_string);
        struct _GtkWidget *return_value_glade_xml_get_widget$10;
        return_value_glade_xml_get_widget$10=glade_xml_get_widget(appdata.xml, "protocol_edit_dialog");
        gtk_widget_hide(return_value_glade_xml_get_widget$10);
        colors_changed = (signed int)!(0 != 0);
        color_list_to_pref();
      }

    }

  }

}

// on_protocols_check_activate
// file info_windows.c line 598
void on_protocols_check_activate(struct _GtkCheckMenuItem *menuitem, void *user_data)
{
  struct _GtkWidget *protocols_window;
  protocols_window=glade_xml_get_widget(appdata.xml, "protocols_window");
  if(!(protocols_window == ((struct _GtkWidget *)NULL)))
  {
    signed int return_value_gtk_check_menu_item_get_active$7;
    return_value_gtk_check_menu_item_get_active$7=gtk_check_menu_item_get_active(menuitem);
    if(!(return_value_gtk_check_menu_item_get_active$7 == 0))
    {
      gtk_widget_show(protocols_window);
      gdk_window_raise(protocols_window->window);
      update_protocols_window();
    }

    else
    {
      struct _GtkListStore *gs;
      struct _GtkTreeView *gv;
      struct _GtkWidget *return_value_glade_xml_get_widget$1;
      return_value_glade_xml_get_widget$1=glade_xml_get_widget(appdata.xml, "prot_clist");
      unsigned long int return_value_gtk_tree_view_get_type$2;
      return_value_gtk_tree_view_get_type$2=gtk_tree_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
      return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$1, return_value_gtk_tree_view_get_type$2);
      gv = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$3;
      if(!(gv == ((struct _GtkTreeView *)NULL)))
      {
        struct _GtkTreeModel *return_value_gtk_tree_view_get_model$4;
        return_value_gtk_tree_view_get_model$4=gtk_tree_view_get_model(gv);
        unsigned long int return_value_gtk_list_store_get_type$5;
        return_value_gtk_list_store_get_type$5=gtk_list_store_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
        return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_tree_view_get_model$4, return_value_gtk_list_store_get_type$5);
        gs = (struct _GtkListStore *)return_value_g_type_check_instance_cast$6;
        if(!(gs == ((struct _GtkListStore *)NULL)))
          protocols_table_clear(gs);

      }

      gtk_widget_hide(protocols_window);
    }
  }

}

// on_refresh_spin_adjustment_changed
// file pref_dialog.c line 299
void on_refresh_spin_adjustment_changed(struct _GtkAdjustment *adj, struct _GtkWidget *canvas)
{
  change_refresh_period((unsigned int)adj->value);
}

// on_save_pref_button_clicked
// file pref_dialog.c line 431
void on_save_pref_button_clicked(struct _GtkButton *button, void *user_data)
{
  confirm_changes();
  save_config();
  hide_pref_dialog();
}

// on_size_mode_changed
// file pref_dialog.c line 346
static void on_size_mode_changed(struct _GtkComboBox *combo, void *data)
{
  signed int return_value_gtk_combo_box_get_active$1;
  return_value_gtk_combo_box_get_active$1=gtk_combo_box_get_active(combo);
  pref.size_mode = (enum anonymous$59)return_value_gtk_combo_box_get_active$1;
}

// on_size_variable_changed
// file pref_dialog.c line 353
static void on_size_variable_changed(struct _GtkComboBox *combo, void *data)
{
  signed int return_value_gtk_combo_box_get_active$1;
  return_value_gtk_combo_box_get_active$1=gtk_combo_box_get_active(combo);
  pref.node_size_variable = (enum anonymous$60)return_value_gtk_combo_box_get_active$1;
}

// on_stack_level_changed
// file pref_dialog.c line 360
static void on_stack_level_changed(struct _GtkComboBox *combo, void *data)
{
  signed int return_value_gtk_combo_box_get_active$1;
  return_value_gtk_combo_box_get_active$1=gtk_combo_box_get_active(combo);
  pref.stack_level = (unsigned int)return_value_gtk_combo_box_get_active$1;
  delete_gui_protocols();
}

// on_start_menuitem_activate
// file menus.c line 257
void on_start_menuitem_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "on_start_menuitem_activate called");
  gui_start_capture();
}

// on_status_bar_check_activate
// file menus.c line 323
void on_status_bar_check_activate(struct _GtkCheckMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_widget_get_type$1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_widget_get_type$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  if(!(menuitem->active == 0u))
  {
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)appdata.statusbar, return_value_gtk_widget_get_type$1);
    gtk_widget_show((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  }

  else
  {
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)appdata.statusbar, return_value_gtk_widget_get_type$3);
    gtk_widget_hide((struct _GtkWidget *)return_value_g_type_check_instance_cast$4);
  }
}

// on_stop_menuitem_activate
// file menus.c line 278
void on_stop_menuitem_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "on_stop_menuitem_activate called");
  gui_stop_capture();
}

// on_text_color_changed
// file pref_dialog.c line 378
static void on_text_color_changed(struct _GtkColorButton *wdg, void *data)
{
  struct _GdkColor new_color;
  gtk_color_button_get_color(wdg, &new_color);
  g_free((void *)pref.text_color);
  pref.text_color=gdk_color_to_string(&new_color);
  ask_reposition((signed int)!(0 != 0));
}

// on_text_font_changed
// file pref_dialog.c line 366
static void on_text_font_changed(struct _GtkFontButton *wdg, void *data)
{
  const char *str;
  str=gtk_font_button_get_font_name(wdg);
  if(!(str == ((const char *)NULL)))
  {
    if(!(pref.fontname == ((char *)NULL)))
      g_free((void *)pref.fontname);

    pref.fontname=g_strdup(str);
    ask_reposition((signed int)!(0 != 0));
  }

}

// on_toolbar_check_activate
// file menus.c line 299
void on_toolbar_check_activate(struct _GtkCheckMenuItem *menuitem, void *user_data)
{
  struct _GtkWidget *widget;
  widget=glade_xml_get_widget(appdata.xml, "handlebox_toolbar");
  if(!(menuitem->active == 0u))
    gtk_widget_show(widget);

  else
    gtk_widget_hide(widget);
}

// open_mutex
// file thread_resolve.c line 77
static signed int open_mutex(void)
{
  signed int return_value_pthread_mutex_init$1;
  return_value_pthread_mutex_init$1=pthread_mutex_init(&resolvemtx, (const union anonymous$43 *)(void *)0);
  _Bool tmp_if_expr$3;
  signed int return_value_pthread_cond_init$2;
  if(return_value_pthread_mutex_init$1 == 0)
  {
    return_value_pthread_cond_init$2=pthread_cond_init(&resolvecond, (const union anonymous$43 *)(void *)0);
    tmp_if_expr$3 = !(return_value_pthread_cond_init$2 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
    return 0;

  else
    return 1;
}

// packet_acquired
// file decode_proto.h line 29
void packet_acquired(unsigned char *raw_packet, unsigned int raw_size, unsigned int pkt_size)
{
  struct anonymous$6 *packet;
  struct anonymous$16 link_id;
  struct anonymous$3 decp;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(raw_packet == ((unsigned char *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "decode_proto.c", 268, (const char *)"packet_acquired", "raw_packet != NULL");

  }
  while((_Bool)0);
  _Bool tmp_if_expr$3;
  if(lkentry == ((const struct linktype_data_tag *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = !(lkentry->fun != ((void (*)(struct anonymous$3 *))NULL)) ? (_Bool)1 : (_Bool)0;
  signed int tmp_statement_expression$5;
  if(tmp_if_expr$3)
  {
    char *return_value_dcgettext$2;
    return_value_dcgettext$2=dcgettext((const char *)(void *)0, "Data link entry not initialized", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_ERROR, return_value_dcgettext$2);

  __CPROVER_DUMP_L9:
    ;
    goto __CPROVER_DUMP_L9;
  }

  else
  {
    decode_proto_start(&decp, raw_packet, raw_size);
    void *return_value_g_malloc$4;
    return_value_g_malloc$4=g_malloc(sizeof(struct anonymous$6) /*40ul*/ );
    packet = (struct anonymous$6 *)return_value_g_malloc$4;
    do
    {
      signed int packet_acquired$$1$$3$$1$$_g_boolean_var_;
      if(!(packet == ((struct anonymous$6 *)NULL)))
        packet_acquired$$1$$3$$1$$_g_boolean_var_ = 1;

      else
        packet_acquired$$1$$3$$1$$_g_boolean_var_ = 0;
      tmp_statement_expression$5 = packet_acquired$$1$$3$$1$$_g_boolean_var_;
      if((signed long int)tmp_statement_expression$5 == 0l)
        g_assertion_message_expr((char *)0, "decode_proto.c", 279, (const char *)"packet_acquired", "packet");

    }
    while((_Bool)0);
    packet->size = pkt_size;
    packet->timestamp = appdata.now;
    packet->ref_count = (unsigned int)0;
    get_packet_prot(&decp);
    if(decp.pr == ((struct anonymous$2 *)NULL))
      g_free((void *)packet);

    else
    {
      packet->prot_desc = decp.pr;
      appdata.n_packets = appdata.n_packets + 1ul;
      appdata.total_mem_packets = appdata.total_mem_packets + 1l;
      add_node_packet(raw_packet, raw_size, packet, &decp.src_node_id, (enum anonymous$7)OUTBOUND);
      add_node_packet(raw_packet, raw_size, packet, &decp.dst_node_id, (enum anonymous$7)INBOUND);
      signed int return_value_node_id_compare$6;
      return_value_node_id_compare$6=node_id_compare(&decp.src_node_id, &decp.dst_node_id);
      if(!(return_value_node_id_compare$6 >= 1))
      {
        link_id.src = decp.src_node_id;
        link_id.dst = decp.dst_node_id;
        links_catalog_add_packet(&link_id, packet, (enum anonymous$7)OUTBOUND);
      }

      else
      {
        link_id.src = decp.dst_node_id;
        link_id.dst = decp.src_node_id;
        links_catalog_add_packet(&link_id, packet, (enum anonymous$7)INBOUND);
      }
      protocol_summary_add_packet(packet);
    }
  }
}

// packet_list_item_count
// file pkt_info.h line 72
signed long int packet_list_item_count(void)
{
  return packet_list_item_n;
}

// packet_list_item_create
// file basic_stats.c line 148
struct anonymous$62 * packet_list_item_create(struct anonymous$6 *i, enum anonymous$7 d)
{
  struct anonymous$62 *newit;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(i == ((struct anonymous$6 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "basic_stats.c", 152, (const char *)"packet_list_item_create", "i");

  }
  while((_Bool)0);
  void *return_value_g_malloc$2;
  return_value_g_malloc$2=g_malloc(sizeof(struct anonymous$62) /*16ul*/ );
  newit = (struct anonymous$62 *)return_value_g_malloc$2;
  signed int tmp_statement_expression$3;
  do
  {
    signed int packet_list_item_create$$1$$2$$1$$_g_boolean_var_;
    if(!(newit == ((struct anonymous$62 *)NULL)))
      packet_list_item_create$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      packet_list_item_create$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$3 = packet_list_item_create$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$3 == 0l)
      g_assertion_message_expr((char *)0, "basic_stats.c", 155, (const char *)"packet_list_item_create", "newit");

  }
  while((_Bool)0);
  i->ref_count = i->ref_count + 1u;
  newit->info = i;
  newit->direction = d;
  packet_list_item_n = packet_list_item_n + 1l;
  return newit;
}

// packet_list_item_delete
// file basic_stats.c line 167
void packet_list_item_delete(struct anonymous$62 *pli)
{
  if(!(pli == ((struct anonymous$62 *)NULL)))
  {
    if(!(pli->info == ((struct anonymous$6 *)NULL)))
    {
      pli->info->ref_count = pli->info->ref_count - 1u;
      if(!(pli->info->ref_count >= 1u))
      {
        packet_protos_delete(pli->info->prot_desc);
        g_free((void *)pli->info);
        pli->info = (struct anonymous$6 *)(void *)0;
        appdata.total_mem_packets = appdata.total_mem_packets - 1l;
      }

    }

    g_free((void *)pli);
    packet_list_item_n = packet_list_item_n - 1l;
  }

}

// packet_protos_delete
// file basic_stats.c line 106
void packet_protos_delete(struct anonymous$2 *pt)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= 6u); i = i + 1u)
    g_free((void *)pt->protonames[(signed long int)i]);
  g_free((void *)pt);
}

// packet_protos_dump
// file basic_stats.c line 115
char * packet_protos_dump(const struct anonymous$2 *pt)
{
  signed int i;
  struct _GString *msg;
  msg=g_string_new("");
  if(!(pt->protonames[0l] == ((char *)NULL)))
    msg=g_string_new(pt->protonames[(signed long int)0]);

  else
    msg=g_string_new("UNKNOWN");
  i = 1;
  for( ; !(i >= 6); i = i + 1)
    if(!(pt->protonames[(signed long int)i] == ((char *)NULL)))
      g_string_append_printf(msg, "/%s", pt->protonames[(signed long int)i]);

    else
      g_string_append(msg, "/UNKNOWN");
  char *return_value_g_string_free$1;
  return_value_g_string_free$1=g_string_free(msg, 0);
  return return_value_g_string_free$1;
}

// packet_protos_init
// file pkt_info.h line 44
struct anonymous$2 * packet_protos_init(void)
{
  unsigned int i;
  struct anonymous$2 *pt;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(sizeof(struct anonymous$2) /*48ul*/ );
  pt = (struct anonymous$2 *)return_value_g_malloc$1;
  signed int tmp_statement_expression$2;
  do
  {
    signed int _g_boolean_var_;
    if(!(pt == ((struct anonymous$2 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$2 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "basic_stats.c", 97, (const char *)"packet_protos_init", "pt");

  }
  while((_Bool)0);
  if(!(pt == ((struct anonymous$2 *)NULL)))
  {
    i = (unsigned int)0;
    for( ; !(i >= 6u); i = i + 1u)
      pt->protonames[(signed long int)i] = (char *)(void *)0;
  }

  return pt;
}

// parse_ether_line
// file resolv.c line 197
static signed int parse_ether_line(char *line, struct _ether *eth, signed int six_bytes)
{
  char *cp;
  unsigned int a0;
  unsigned int a1;
  unsigned int a2;
  unsigned int a3;
  unsigned int a4;
  unsigned int a5;
  char *return_value___builtin_strchr$1;
  return_value___builtin_strchr$1=__builtin_strchr(line, 35);
  cp = return_value___builtin_strchr$1;
  if(!(cp == ((char *)NULL)))
    *cp = (char)0;

  cp=strtok(line, " \t\n");
  if(cp == ((char *)NULL))
    return -1;

  else
  {
    if(!(six_bytes == 0))
    {
      signed int return_value_sscanf$4;
      return_value_sscanf$4=sscanf(cp, "%x:%x:%x:%x:%x:%x", &a0, &a1, &a2, &a3, &a4, &a5);
      if(!(return_value_sscanf$4 == 6))
      {
        signed int return_value_sscanf$3;
        return_value_sscanf$3=sscanf(cp, "%x-%x-%x-%x-%x-%x", &a0, &a1, &a2, &a3, &a4, &a5);
        if(!(return_value_sscanf$3 == 6))
        {
          signed int return_value_sscanf$2;
          return_value_sscanf$2=sscanf(cp, "%x.%x.%x.%x.%x.%x", &a0, &a1, &a2, &a3, &a4, &a5);
          if(!(return_value_sscanf$2 == 6))
            return -1;

        }

      }

    }

    else
    {
      signed int return_value_sscanf$7;
      return_value_sscanf$7=sscanf(cp, "%x:%x:%x", &a0, &a1, &a2);
      if(!(return_value_sscanf$7 == 3))
      {
        signed int return_value_sscanf$6;
        return_value_sscanf$6=sscanf(cp, "%x-%x-%x", &a0, &a1, &a2);
        if(!(return_value_sscanf$6 == 3))
        {
          signed int return_value_sscanf$5;
          return_value_sscanf$5=sscanf(cp, "%x.%x.%x", &a0, &a1, &a2);
          if(!(return_value_sscanf$5 == 3))
            return -1;

        }

      }

    }
    cp=strtok((char *)(void *)0, " \t\n");
    if(cp == ((char *)NULL))
      return -1;

    else
    {
      eth->addr[(signed long int)0] = (unsigned char)a0;
      eth->addr[(signed long int)1] = (unsigned char)a1;
      eth->addr[(signed long int)2] = (unsigned char)a2;
      if(!(six_bytes == 0))
      {
        eth->addr[(signed long int)3] = (unsigned char)a3;
        eth->addr[(signed long int)4] = (unsigned char)a4;
        eth->addr[(signed long int)5] = (unsigned char)a5;
      }

      else
      {
        eth->addr[(signed long int)3] = (unsigned char)0;
        eth->addr[(signed long int)4] = (unsigned char)0;
        eth->addr[(signed long int)5] = (unsigned char)0;
      }
      safe_strncpy(eth->name, cp, (unsigned long int)64);
      return 0;
    }
  }
}

// pause_capture
// file capture.h line 35
signed int pause_capture(void)
{
  if(!((signed int)capture_status == PLAY))
    return (signed int)!(0 != 0);

  else
  {
    if(appdata.interface == ((char *)NULL))
    {
      char *return_value_dcgettext$1;
      return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Pausing offline capture", 5);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, return_value_dcgettext$1);
      signed int return_value_g_source_remove$3;
      return_value_g_source_remove$3=g_source_remove((unsigned int)capture_source);
      if(return_value_g_source_remove$3 == 0)
      {
        char *return_value_dcgettext$2;
        return_value_dcgettext$2=dcgettext((const char *)(void *)0, "Error while trying to pause capture", 5);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$2);
        return 0;
      }

    }

    capture_status = (enum status_t)PAUSE;
    return (signed int)!(0 != 0);
  }
}

// port_service_free
// file datastructs.c line 542
static void port_service_free(struct anonymous$21 *p)
{
  if(!(p == ((struct anonymous$21 *)NULL)))
    g_free((void *)p->name);

  g_free((void *)p);
}

// port_service_new
// file datastructs.c line 530
static struct anonymous$21 * port_service_new(unsigned short int port, const char *name)
{
  struct anonymous$21 *p;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(sizeof(struct anonymous$21) /*24ul*/ );
  p = (struct anonymous$21 *)return_value_g_malloc$1;
  signed int tmp_statement_expression$2;
  do
  {
    signed int _g_boolean_var_;
    if(!(p == ((struct anonymous$21 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$2 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "datastructs.c", 534, (const char *)"port_service_new", "p");

  }
  while((_Bool)0);
  p->port = port;
  p->name=g_strdup(name);
  p->preferred = 0;
  return p;
}

// pref_to_color_list
// file pref_dialog.c line 747
static void pref_to_color_list(void)
{
  signed int i;
  struct _EATreePos ep;
  signed int return_value_get_color_store$1;
  return_value_get_color_store$1=get_color_store(&ep);
  if(!(return_value_get_color_store$1 == 0))
  {
    gtk_list_store_clear(ep.gs);
    i = 0;
    for( ; !(pref.colors[(signed long int)i] == ((char *)NULL)); i = i + 1)
    {
      struct _GdkColor gdk_color;
      char **colors_protocols = (char **)(void *)0;
      char *protocol = (char *)(void *)0;
      struct _GtkTreeIter it;
      colors_protocols=g_strsplit(pref.colors[(signed long int)i], ";", 0);
      gdk_color_parse(colors_protocols[(signed long int)0], &gdk_color);
      if(colors_protocols[1l] == ((char *)NULL))
        protocol = "";

      else
        protocol = colors_protocols[(signed long int)1];
      gtk_list_store_append(ep.gs, &it);
      gtk_list_store_set(ep.gs, &it, 0, (const void *)"        ", 1, &gdk_color, 2, protocol, -1);
      g_strfreev(colors_protocols);
    }
  }

}

// process_netbios_name
// file names_netbios.c line 200
static signed int process_netbios_name(const char *name_ptr, char *outname, unsigned long int outname_size)
{
  unsigned int i;
  signed int name_type = (signed int)*((name_ptr + (signed long int)16) - (signed long int)1);
  char name_char;
  char *name_ret = outname;
  i = (unsigned int)0;
  const char *tmp_post$1;
  char *tmp_post$2;
  char *tmp_post$3;
  char *tmp_post$4;
  char *tmp_post$5;
  char *tmp_post$6;
  for( ; !(i >= 15u) && !((unsigned long int)(name_ret - outname) >= outname_size + 18446744073709551615ul); i = i + 1u)
  {
    tmp_post$1 = name_ptr;
    name_ptr = name_ptr + 1l;
    name_char = *tmp_post$1;
    if((signed int)name_char >= 32 && !((signed int)name_char >= 127))
    {
      tmp_post$2 = name_ret;
      name_ret = name_ret + 1l;
      *tmp_post$2 = name_char;
    }

    else
    {
      tmp_post$3 = name_ret;
      name_ret = name_ret + 1l;
      *tmp_post$3 = (char)60;
      tmp_post$4 = name_ret;
      name_ret = name_ret + 1l;
      static const char hex_digits[16l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '0', 'a', 'b', 'c', 'd', 'e', 'f' };
      *tmp_post$4 = hex_digits[(signed long int)((signed int)name_char >> 4)];
      tmp_post$5 = name_ret;
      name_ret = name_ret + 1l;
      *tmp_post$5 = hex_digits[(signed long int)((signed int)name_char & 0x0F)];
      tmp_post$6 = name_ret;
      name_ret = name_ret + 1l;
      *tmp_post$6 = (char)62;
    }
  }
  *name_ret = (char)0;
  return name_type;
}

// prot_freq_compare
// file protocols.c line 211
static signed int prot_freq_compare(const void *a, const void *b)
{
  const struct anonymous$26 *prot_a;
  const struct anonymous$26 *prot_b;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(a == NULL))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 215, (const char *)"prot_freq_compare", "a != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int prot_freq_compare$$1$$2$$1$$_g_boolean_var_;
    if(!(b == NULL))
      prot_freq_compare$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      prot_freq_compare$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = prot_freq_compare$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 216, (const char *)"prot_freq_compare", "b != NULL");

  }
  while((_Bool)0);
  prot_a = (const struct anonymous$26 *)a;
  prot_b = (const struct anonymous$26 *)b;
  if(prot_a->stats.accumulated > prot_b->stats.accumulated)
    return -1;

  else
    if(prot_a->stats.accumulated < prot_b->stats.accumulated)
      return 1;

    else
      return 0;
}

// prot_info_compare
// file info_windows.c line 90
static signed int prot_info_compare(const void *a, const void *b)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(a == NULL))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "info_windows.c", 92, (const char *)"prot_info_compare", "a != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int prot_info_compare$$1$$2$$1$$_g_boolean_var_;
    if(!(b == NULL))
      prot_info_compare$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      prot_info_compare$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = prot_info_compare$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "info_windows.c", 93, (const char *)"prot_info_compare", "b != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$3;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp$4;
  return_value___builtin_strcmp$4=__builtin_strcmp(((struct anonymous$29 *)a)->prot_name, (char *)b);
  tmp_statement_expression$3 = return_value___builtin_strcmp$4;
  return tmp_statement_expression$3;
}

// protocol_compare
// file protocols.c line 476
static signed int protocol_compare(const void *a, const void *b)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(a == NULL))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 478, (const char *)"protocol_compare", "a != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int protocol_compare$$1$$2$$1$$_g_boolean_var_;
    if(!(b == NULL))
      protocol_compare$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      protocol_compare$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = protocol_compare$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 479, (const char *)"protocol_compare", "b != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$3;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp$4;
  return_value___builtin_strcmp$4=__builtin_strcmp(((const struct anonymous$26 *)a)->name, (const char *)b);
  tmp_statement_expression$3 = return_value___builtin_strcmp$4;
  return tmp_statement_expression$3;
}

// protocol_stack_add_pkt
// file protocols.c line 70
void protocol_stack_add_pkt(struct anonymous$25 *pstk, const struct anonymous$6 *packet)
{
  struct _GList *protocol_item;
  struct anonymous$26 *protocol_info;
  unsigned int i;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(packet == ((const struct anonymous$6 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 76, (const char *)"protocol_stack_add_pkt", "packet");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int protocol_stack_add_pkt$$1$$2$$1$$_g_boolean_var_;
    if(!(pstk == ((struct anonymous$25 *)NULL)))
      protocol_stack_add_pkt$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      protocol_stack_add_pkt$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = protocol_stack_add_pkt$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 77, (const char *)"protocol_stack_add_pkt", "pstk");

  }
  while((_Bool)0);
  i = (unsigned int)0;
  signed int tmp_statement_expression$3;
  signed int tmp_statement_expression$4;
  for( ; !(i >= 6u); i = i + 1u)
    if(!(packet->prot_desc->protonames[(signed long int)i] == ((char *)NULL)))
    {
      protocol_item=g_list_find_custom(pstk->protostack[(signed long int)i], (const void *)packet->prot_desc->protonames[(signed long int)i], protocol_compare);
      if(!(protocol_item == ((struct _GList *)NULL)))
        protocol_info = (struct anonymous$26 *)protocol_item->data;

      else
      {
        protocol_info=protocol_t_create(packet->prot_desc->protonames[(signed long int)i]);
        pstk->protostack[(signed long int)i]=g_list_prepend(pstk->protostack[(signed long int)i], (void *)protocol_info);
      }
      do
      {
        signed int protocol_stack_add_pkt$$1$$3$$1$$2$$1$$_g_boolean_var_;
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp$5;
        return_value___builtin_strcmp$5=__builtin_strcmp(protocol_info->name, packet->prot_desc->protonames[(signed long int)i]);
        tmp_statement_expression$4 = return_value___builtin_strcmp$5;
        if(tmp_statement_expression$4 == 0)
          protocol_stack_add_pkt$$1$$3$$1$$2$$1$$_g_boolean_var_ = 1;

        else
          protocol_stack_add_pkt$$1$$3$$1$$2$$1$$_g_boolean_var_ = 0;
        tmp_statement_expression$3 = protocol_stack_add_pkt$$1$$3$$1$$2$$1$$_g_boolean_var_;
        if((signed long int)tmp_statement_expression$3 == 0l)
          g_assertion_message_expr((char *)0, "protocols.c", 96, (const char *)"protocol_stack_add_pkt", "!strcmp(protocol_info->name, packet->prot_desc->protonames[i])");

      }
      while((_Bool)0);
      basic_stats_add(&protocol_info->stats, (double)packet->size);
    }

}

// protocol_stack_avg
// file protocols.c line 135
void protocol_stack_avg(struct anonymous$25 *pstk, double avgtime)
{
  struct _GList *item;
  struct anonymous$26 *protocol;
  unsigned int i;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(pstk == ((struct anonymous$25 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 141, (const char *)"protocol_stack_avg", "pstk");

  }
  while((_Bool)0);
  i = (unsigned int)0;
  for( ; !(i >= 6u); i = i + 1u)
  {
    item = pstk->protostack[(signed long int)i];
    for( ; !(item == ((struct _GList *)NULL)); item = item->next)
    {
      protocol = (struct anonymous$26 *)item->data;
      basic_stats_avg(&protocol->stats, avgtime);
    }
  }
}

// protocol_stack_dump
// file protocols.c line 245
char * protocol_stack_dump(const struct anonymous$25 *pstk)
{
  unsigned int i;
  char *msg;
  char *return_value_g_strdup$1;
  signed int tmp_statement_expression$2;
  if(pstk == ((const struct anonymous$25 *)NULL))
  {
    return_value_g_strdup$1=g_strdup("protostack_t NULL");
    return return_value_g_strdup$1;
  }

  else
  {
    msg=g_strdup("");
    i = (unsigned int)0;
    for( ; !(i >= 6u); i = i + 1u)
    {
      char *msg_level;
      char *tmp;
      if(pstk->protostack[(signed long int)i] == ((struct _GList *)NULL))
        msg_level=g_strdup("-none-");

      else
      {
        const struct _GList *cur_el = pstk->protostack[(signed long int)i];
        msg_level = (char *)(void *)0;
        while(!(cur_el == ((const struct _GList *)NULL)))
        {
          char *msg_proto;
          const struct anonymous$26 *p = (const struct anonymous$26 *)cur_el->data;
          do
          {
            signed int _g_boolean_var_;
            if(!(p == ((const struct anonymous$26 *)NULL)))
              _g_boolean_var_ = 1;

            else
              _g_boolean_var_ = 0;
            tmp_statement_expression$2 = _g_boolean_var_;
            if((signed long int)tmp_statement_expression$2 == 0l)
              g_assertion_message_expr((char *)0, "protocols.c", 268, (const char *)"protocol_stack_dump", "p");

          }
          while((_Bool)0);
          msg_proto=protocol_t_dump(p);
          if(msg_level == ((char *)NULL))
            msg_level = msg_proto;

          else
          {
            tmp = msg_level;
            msg_level=g_strdup_printf("%s,[%s]", tmp, msg_proto);
            g_free((void *)tmp);
            g_free((void *)msg_proto);
          }
          cur_el = cur_el->next;
        }
      }
      tmp = msg;
      msg=g_strdup_printf("%slevel %d: [%s]\n", tmp, i, msg_level);
      g_free((void *)tmp);
      g_free((void *)msg_level);
    }
    return msg;
  }
}

// protocol_stack_find
// file protocols.h line 61
const struct anonymous$26 * protocol_stack_find(const struct anonymous$25 *pstk, unsigned long int level, const char *protoname)
{
  struct _GList *item;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(pstk == ((const struct anonymous$25 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 197, (const char *)"protocol_stack_find", "pstk");

  }
  while((_Bool)0);
  if(protoname == ((const char *)NULL) || level >= 6ul)
    return (const struct anonymous$26 *)(void *)0;

  else
  {
    item=g_list_find_custom(pstk->protostack[(signed long int)level], (const void *)protoname, protocol_compare);
    if(!(item == ((struct _GList *)NULL)))
    {
      if(item->data == NULL)
        goto __CPROVER_DUMP_L7;

      return (const struct anonymous$26 *)item->data;
    }

    else
    {

    __CPROVER_DUMP_L7:
      ;
      return (const struct anonymous$26 *)(void *)0;
    }
  }
}

// protocol_stack_open
// file protocols.c line 42
void protocol_stack_open(struct anonymous$25 *pstk)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(pstk == ((struct anonymous$25 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 44, (const char *)"protocol_stack_open", "pstk");

  }
  while((_Bool)0);
  unsigned int i = (unsigned int)0;
  for( ; !(i >= 6u); i = i + 1u)
    pstk->protostack[(signed long int)i] = (struct _GList *)(void *)0;
}

// protocol_stack_purge_expired
// file protocols.c line 157
void protocol_stack_purge_expired(struct anonymous$25 *pstk, double expire_time)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(pstk == ((struct anonymous$25 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 159, (const char *)"protocol_stack_purge_expired", "pstk");

  }
  while((_Bool)0);
  if(expire_time > 0.000000)
  {
    struct _GList *item;
    struct _GList *next_item;
    struct anonymous$26 *protocol;
    double diffms;
    unsigned int i = (unsigned int)0;
    for( ; !(i >= 6u); i = i + 1u)
    {
      item = pstk->protostack[(signed long int)i];
      for( ; !(item == ((struct _GList *)NULL)); item = next_item)
      {
        protocol = (struct anonymous$26 *)item->data;
        next_item = item->next;
        if(protocol->stats.aver_accu <= 0.000000)
        {
          diffms=substract_times_ms(&appdata.now, &protocol->stats.last_time);
          if(diffms >= expire_time)
          {
            protocol_t_delete(protocol);
            pstk->protostack[(signed long int)i]=g_list_delete_link(pstk->protostack[(signed long int)i], item);
          }

        }

      }
    }
  }

}

// protocol_stack_reset
// file protocols.c line 50
void protocol_stack_reset(struct anonymous$25 *pstk)
{
  unsigned int i;
  struct anonymous$26 *protocol_info;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(pstk == ((struct anonymous$25 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 55, (const char *)"protocol_stack_reset", "pstk");

  }
  while((_Bool)0);
  i = (unsigned int)0;
  for( ; !(i >= 6u); i = i + 1u)
    while(!(pstk->protostack[(signed long int)i] == ((struct _GList *)NULL)))
    {
      protocol_info = (struct anonymous$26 *)pstk->protostack[(signed long int)i]->data;
      protocol_t_delete(protocol_info);
      pstk->protostack[(signed long int)i]=g_list_delete_link(pstk->protostack[(signed long int)i], pstk->protostack[(signed long int)i]);
    }
}

// protocol_stack_sort_most_used
// file protocols.c line 231
char * protocol_stack_sort_most_used(struct anonymous$25 *pstk, unsigned long int level)
{
  struct anonymous$26 *protocol;
  _Bool tmp_if_expr$1;
  if(pstk == ((struct anonymous$25 *)NULL) || level >= 6ul)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(pstk->protostack[(signed long int)level] != ((struct _GList *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return (char *)(void *)0;

  else
  {
    pstk->protostack[(signed long int)level]=g_list_sort(pstk->protostack[(signed long int)level], prot_freq_compare);
    protocol = (struct anonymous$26 *)pstk->protostack[(signed long int)level]->data;
    char *return_value_g_strdup$2;
    return_value_g_strdup$2=g_strdup(protocol->name);
    return return_value_g_strdup$2;
  }
}

// protocol_stack_sub_pkt
// file protocols.c line 102
void protocol_stack_sub_pkt(struct anonymous$25 *pstk, const struct anonymous$6 *packet)
{
  unsigned int i = (unsigned int)0;
  struct _GList *item = (struct _GList *)(void *)0;
  struct anonymous$26 *protocol = (struct anonymous$26 *)(void *)0;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(pstk == ((struct anonymous$25 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 108, (const char *)"protocol_stack_sub_pkt", "pstk");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  signed int tmp_statement_expression$3;
  if(!(packet == ((const struct anonymous$6 *)NULL)))
    for( ; !(i >= 6u); i = i + 1u)
    {
      if(packet->prot_desc->protonames[(signed long int)i] == ((char *)NULL))
        break;

      item=g_list_find_custom(pstk->protostack[(signed long int)i], (const void *)packet->prot_desc->protonames[(signed long int)i], protocol_compare);
      if(item == ((struct _GList *)NULL))
      {
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, "Protocol not found while subtracting packet in protocol_stack_sub_pkt");
        break;
      }

      protocol = (struct anonymous$26 *)item->data;
      do
      {
        signed int protocol_stack_sub_pkt$$1$$2$$2$$1$$_g_boolean_var_;
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp$4;
        return_value___builtin_strcmp$4=__builtin_strcmp(protocol->name, packet->prot_desc->protonames[(signed long int)i]);
        tmp_statement_expression$3 = return_value___builtin_strcmp$4;
        if(tmp_statement_expression$3 == 0)
          protocol_stack_sub_pkt$$1$$2$$2$$1$$_g_boolean_var_ = 1;

        else
          protocol_stack_sub_pkt$$1$$2$$2$$1$$_g_boolean_var_ = 0;
        tmp_statement_expression$2 = protocol_stack_sub_pkt$$1$$2$$2$$1$$_g_boolean_var_;
        if((signed long int)tmp_statement_expression$2 == 0l)
          g_assertion_message_expr((char *)0, "protocols.c", 127, (const char *)"protocol_stack_sub_pkt", "!strcmp(protocol->name, packet->prot_desc->protonames[i])");

      }
      while((_Bool)0);
      basic_stats_sub(&protocol->stats, (double)packet->size);
    }

}

// protocol_stack_xml
// file protocols.c line 292
char * protocol_stack_xml(const struct anonymous$25 *pstk)
{
  unsigned int i;
  char *msg;
  char *xml;
  char *return_value_xmltag$1;
  signed int tmp_statement_expression$2;
  if(pstk == ((const struct anonymous$25 *)NULL))
  {
    return_value_xmltag$1=xmltag("protocols", "");
    return return_value_xmltag$1;
  }

  else
  {
    msg=g_strdup("");
    i = (unsigned int)1;
    for( ; !(i >= 6u); i = i + 1u)
    {
      char *msg_level;
      char *tmp;
      if(!(pstk->protostack[(signed long int)i] == ((struct _GList *)NULL)))
      {
        const struct _GList *cur_el = pstk->protostack[(signed long int)i];
        msg_level = (char *)(void *)0;
        while(!(cur_el == ((const struct _GList *)NULL)))
        {
          char *msg_proto;
          const struct anonymous$26 *p = (const struct anonymous$26 *)cur_el->data;
          do
          {
            signed int _g_boolean_var_;
            if(!(p == ((const struct anonymous$26 *)NULL)))
              _g_boolean_var_ = 1;

            else
              _g_boolean_var_ = 0;
            tmp_statement_expression$2 = _g_boolean_var_;
            if((signed long int)tmp_statement_expression$2 == 0l)
              g_assertion_message_expr((char *)0, "protocols.c", 315, (const char *)"protocol_stack_xml", "p");

          }
          while((_Bool)0);
          msg_proto=protocol_t_xml(p, i);
          if(msg_level == ((char *)NULL))
            msg_level = msg_proto;

          else
          {
            tmp = msg_level;
            msg_level=g_strdup_printf("%s%s", tmp, msg_proto);
            g_free((void *)tmp);
            g_free((void *)msg_proto);
          }
          cur_el = cur_el->next;
        }
        tmp = msg;
        msg=g_strdup_printf("%s%s", tmp, msg_level);
        g_free((void *)tmp);
        g_free((void *)msg_level);
      }

    }
    xml=xmltag("protocols", "%s", msg);
    g_free((void *)msg);
    return xml;
  }
}

// protocol_summary_add_packet
// file protocols.c line 514
void protocol_summary_add_packet(struct anonymous$6 *packet)
{
  if(protosummary_stats == ((struct anonymous$27 *)NULL))
    protocol_summary_open();

  traffic_stats_add_packet(protosummary_stats, packet, (enum anonymous$7)EITHERBOUND);
}

// protocol_summary_close
// file protocols.h line 71
void protocol_summary_close(void)
{
  if(!(protosummary_stats == ((struct anonymous$27 *)NULL)))
  {
    traffic_stats_reset(protosummary_stats);
    g_free((void *)protosummary_stats);
    protosummary_stats = (struct anonymous$27 *)(void *)0;
  }

}

// protocol_summary_find
// file protocols.h line 76
const struct anonymous$26 * protocol_summary_find(unsigned long int level, const char *protoname)
{
  if(protosummary_stats == ((struct anonymous$27 *)NULL))
    return (const struct anonymous$26 *)(void *)0;

  else
  {
    const struct anonymous$26 *return_value_protocol_stack_find$1;
    return_value_protocol_stack_find$1=protocol_stack_find(&protosummary_stats->stats_protos, level, protoname);
    return return_value_protocol_stack_find$1;
  }
}

// protocol_summary_foreach
// file protocols.c line 550
void protocol_summary_foreach(unsigned long int level, void (*func)(void *, void *), void *data)
{
  if(!(protosummary_stats == ((struct anonymous$27 *)NULL)) && !(level >= 6ul))
    g_list_foreach(protosummary_stats->stats_protos.protostack[(signed long int)level], func, data);

}

// protocol_summary_open
// file protocols.h line 70
void protocol_summary_open(void)
{
  if(!(protosummary_stats == ((struct anonymous$27 *)NULL)))
    protocol_summary_close();

  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(sizeof(struct anonymous$27) /*240ul*/ );
  protosummary_stats = (struct anonymous$27 *)return_value_g_malloc$1;
  signed int tmp_statement_expression$2;
  do
  {
    signed int _g_boolean_var_;
    if(!(protosummary_stats == ((struct anonymous$27 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$2 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 498, (const char *)"protocol_summary_open", "protosummary_stats");

  }
  while((_Bool)0);
  traffic_stats_init(protosummary_stats);
}

// protocol_summary_size
// file protocols.h line 74
signed long int protocol_summary_size(void)
{
  signed long int totproto = (signed long int)0;
  signed int i;
  if(protosummary_stats == ((struct anonymous$27 *)NULL))
    return (signed long int)0;

  else
  {
    i = 0;
    for( ; !(i >= 6); i = i + 1)
      if(!(protosummary_stats->stats_protos.protostack[(signed long int)i] == ((struct _GList *)NULL)))
      {
        unsigned int return_value_g_list_length$1;
        return_value_g_list_length$1=g_list_length(protosummary_stats->stats_protos.protostack[(signed long int)i]);
        totproto = totproto + (signed long int)return_value_g_list_length$1;
      }

    return totproto;
  }
}

// protocol_summary_stack
// file protocols.h line 77
const struct anonymous$25 * protocol_summary_stack(void)
{
  if(protosummary_stats == ((struct anonymous$27 *)NULL))
    return (const struct anonymous$25 *)(void *)0;

  else
    return &protosummary_stats->stats_protos;
}

// protocol_summary_update_all
// file protocols.h line 73
void protocol_summary_update_all(void)
{
  if(!(protosummary_stats == ((struct anonymous$27 *)NULL)))
    traffic_stats_update(protosummary_stats, pref.averaging_time, pref.proto_timeout_time);

}

// protocol_t_create
// file protocols.c line 344
struct anonymous$26 * protocol_t_create(const char *protocol_name)
{
  struct anonymous$26 *pr = (struct anonymous$26 *)(void *)0;
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(sizeof(struct anonymous$26) /*72ul*/ );
  pr = (struct anonymous$26 *)return_value_g_malloc$1;
  signed int tmp_statement_expression$2;
  do
  {
    signed int _g_boolean_var_;
    if(!(pr == ((struct anonymous$26 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$2 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 349, (const char *)"protocol_t_create", "pr");

  }
  while((_Bool)0);
  pr->name=g_strdup(protocol_name);
  basic_stats_reset(&pr->stats);
  pr->node_names = (struct _GList *)(void *)0;
  return pr;
}

// protocol_t_delete
// file protocols.c line 357
void protocol_t_delete(struct anonymous$26 *prot)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(prot == ((struct anonymous$26 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "protocols.c", 359, (const char *)"protocol_t_delete", "prot");

  }
  while((_Bool)0);
  g_free((void *)prot->name);
  prot->name = (char *)(void *)0;
  while(!(prot->node_names == ((struct _GList *)NULL)))
  {
    struct _GList *name_item = prot->node_names;
    struct anonymous$36 *name = (struct anonymous$36 *)name_item->data;
    node_name_delete(name);
    prot->node_names=g_list_delete_link(prot->node_names, name_item);
  }
  g_free((void *)prot);
}

// protocol_t_dump
// file protocols.c line 376
char * protocol_t_dump(const struct anonymous$26 *prot)
{
  char *msg;
  char *msg_stats;
  char *msg_names;
  char *return_value_g_strdup$1;
  if(prot == ((const struct anonymous$26 *)NULL))
  {
    return_value_g_strdup$1=g_strdup("protocol_t NULL");
    return return_value_g_strdup$1;
  }

  else
  {
    msg_stats=basic_stats_dump(&prot->stats);
    if(prot->node_names == ((struct _GList *)NULL))
      msg_names=g_strdup("-- no names --");

    else
    {
      const struct _GList *cur_el;
      msg_names = (char *)(void *)0;
      cur_el = prot->node_names;
      while(!(cur_el == ((const struct _GList *)NULL)))
      {
        char *str_name;
        const struct anonymous$36 *cur_name = (const struct anonymous$36 *)cur_el->data;
        str_name=node_name_dump(cur_name);
        if(msg_names == ((char *)NULL))
          msg_names = str_name;

        else
        {
          char *tmp = msg_names;
          msg_names=g_strjoin(",", tmp, str_name, (void *)0);
          g_free((void *)tmp);
          g_free((void *)str_name);
        }
        cur_el = cur_el->next;
      }
    }
    msg=g_strdup_printf("protocol name: %s, stats [%s], node_names [%s]", prot->name, msg_stats, msg_names);
    g_free((void *)msg_stats);
    g_free((void *)msg_names);
    return msg;
  }
}

// protocol_t_xml
// file protocols.c line 424
char * protocol_t_xml(const struct anonymous$26 *prot, unsigned int level)
{
  char *msg;
  char *msg_stats;
  char *msg_names;
  char *return_value_xmltag$1;
  if(prot == ((const struct anonymous$26 *)NULL))
  {
    return_value_xmltag$1=xmltag("protocol", "");
    return return_value_xmltag$1;
  }

  else
  {
    msg_stats=basic_stats_xml(&prot->stats);
    if(prot->node_names == ((struct _GList *)NULL))
      msg_names=g_strdup("");

    else
    {
      const struct _GList *cur_el;
      msg_names = (char *)(void *)0;
      cur_el = prot->node_names;
      while(!(cur_el == ((const struct _GList *)NULL)))
      {
        char *str_name;
        const struct anonymous$36 *cur_name = (const struct anonymous$36 *)cur_el->data;
        str_name=node_name_xml(cur_name);
        if(msg_names == ((char *)NULL))
          msg_names = str_name;

        else
        {
          char *tmp = msg_names;
          msg_names=g_strjoin(",", tmp, str_name, (void *)0);
          g_free((void *)tmp);
          g_free((void *)str_name);
        }
        cur_el = cur_el->next;
      }
    }
    msg=xmltag("protocol", "\n<level>%u</level>\n<key>%s</key>\n%s%s", level, prot->name, msg_stats, msg_names);
    g_free((void *)msg_stats);
    g_free((void *)msg_names);
    return msg;
  }
}

// protocols_table_clear
// file info_windows.c line 415
static void protocols_table_clear(struct _GtkListStore *gs)
{
  signed int res;
  struct _GtkTreeIter it;
  unsigned long int return_value_gtk_tree_model_get_type$1;
  return_value_gtk_tree_model_get_type$1=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)gs, return_value_gtk_tree_model_get_type$1);
  res=gtk_tree_model_get_iter_first((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$2, &it);
  while(!(res == 0))
  {
    struct protocol_list_item_t_tag *row_proto = (struct protocol_list_item_t_tag *)(void *)0;
    unsigned long int return_value_gtk_tree_model_get_type$3;
    return_value_gtk_tree_model_get_type$3=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)gs, return_value_gtk_tree_model_get_type$3);
    gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$4, &it, 8, &row_proto, -1);
    if(!(row_proto == ((struct protocol_list_item_t_tag *)NULL)))
    {
      g_free((void *)row_proto->name);
      g_free((void *)row_proto);
      res=gtk_list_store_remove(gs, &it);
    }

  }
}

// protocols_table_compare
// file info_windows.c line 275
static signed int protocols_table_compare(struct _GtkTreeModel *gs, struct _GtkTreeIter *a, struct _GtkTreeIter *b, void *userdata)
{
  signed int ret = 0;
  double t1;
  double t2;
  double diffms;
  signed int idcol;
  enum anonymous$33 order;
  const struct protocol_list_item_t_tag *prot1;
  const struct protocol_list_item_t_tag *prot2;
  gtk_tree_model_get(gs, a, 8, &prot1, -1);
  gtk_tree_model_get(gs, b, 8, &prot2, -1);
  signed int tmp_statement_expression$3;
  if(prot1 == ((const struct protocol_list_item_t_tag *)NULL) || prot2 == ((const struct protocol_list_item_t_tag *)NULL))
    return 0;

  else
  {
    unsigned long int return_value_gtk_tree_sortable_get_type$1;
    return_value_gtk_tree_sortable_get_type$1=gtk_tree_sortable_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)gs, return_value_gtk_tree_sortable_get_type$1);
    gtk_tree_sortable_get_sort_column_id((struct _GtkTreeSortable *)return_value_g_type_check_instance_cast$2, &idcol, &order);
    switch(idcol)
    {
      case 0:

      case 2:

      case 1:
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp$4;
        return_value___builtin_strcmp$4=__builtin_strcmp(prot1->name, prot2->name);
        tmp_statement_expression$3 = return_value___builtin_strcmp$4;
        ret = tmp_statement_expression$3;
        break;
      }
      case 3:
      {
        t1 = prot1->rowstats.average;
        t2 = prot2->rowstats.average;
        if(IEEE_FLOAT_EQUAL(t1, t2))
          ret = 0;

        else
          if(t1 < t2)
            ret = -1;

          else
            ret = 1;
        break;
      }
      case 4:
      {
        t1 = prot1->rowstats.accumulated;
        t2 = prot2->rowstats.accumulated;
        if(IEEE_FLOAT_EQUAL(t1, t2))
          ret = 0;

        else
          if(t1 < t2)
            ret = -1;

          else
            ret = 1;
        break;
      }
      case 5:
      {
        t1 = prot1->rowstats.avg_size;
        t2 = prot2->rowstats.avg_size;
        if(IEEE_FLOAT_EQUAL(t1, t2))
          ret = 0;

        else
          if(t1 < t2)
            ret = -1;

          else
            ret = 1;
        break;
      }
      case 6:
      {
        diffms=substract_times_ms(&prot1->rowstats.last_time, &prot2->rowstats.last_time);
        if(IEEE_FLOAT_EQUAL(diffms, 0.000000))
          ret = 0;

        else
          if(diffms < 0.000000)
            ret = -1;

          else
            ret = 1;
        break;
      }
      case 7:
        if(prot1->rowstats.accu_packets == prot2->rowstats.accu_packets)
          ret = 0;

        else
          if(!(prot1->rowstats.accu_packets >= prot2->rowstats.accu_packets))
            ret = -1;

          else
            ret = 1;
    }
    return ret;
  }
}

// protohash_clear
// file datastructs.h line 37
void protohash_clear(void)
{
  if(!(protohash == ((struct _GHashTable *)NULL)))
  {
    g_hash_table_destroy(protohash);
    protohash = (struct _GHashTable *)(void *)0;
  }

  while(!(cycle_color_list == ((struct _GList *)NULL)))
  {
    g_free(cycle_color_list->data);
    cycle_color_list=g_list_delete_link(cycle_color_list, cycle_color_list);
  }
  current_cycle = (struct _GList *)(void *)0;
}

// protohash_color
// file datastructs.h line 40
struct _GdkColor protohash_color(const char *protoname)
{
  const struct anonymous$64 *item;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(protoname == ((const char *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "datastructs.c", 136, (const char *)"protohash_color", "protoname");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int protohash_color$$1$$2$$1$$_g_boolean_var_;
    if(!(protohash == ((struct _GHashTable *)NULL)))
      protohash_color$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      protohash_color$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = protohash_color$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "datastructs.c", 137, (const char *)"protohash_color", "protohash");

  }
  while((_Bool)0);
  void *return_value_g_hash_table_lookup$3;
  return_value_g_hash_table_lookup$3=g_hash_table_lookup(protohash, (const void *)protoname);
  item = (struct anonymous$64 *)return_value_g_hash_table_lookup$3;
  if(item == ((const struct anonymous$64 *)NULL))
  {
    item = (struct anonymous$64 *)current_cycle->data;
    char *return_value_g_strdup$4;
    return_value_g_strdup$4=g_strdup(protoname);
    void *return_value_g_memdup$5;
    return_value_g_memdup$5=g_memdup((const void *)item, (unsigned int)sizeof(struct anonymous$64) /*16ul*/ );
    g_hash_table_insert(protohash, (void *)return_value_g_strdup$4, return_value_g_memdup$5);
    current_cycle = current_cycle->next;
    if(current_cycle == ((struct _GList *)NULL))
      current_cycle = cycle_color_list;

  }

  return item->color;
}

// protohash_compact
// file datastructs.h line 53
char ** protohash_compact(char **colors)
{
  signed int i;
  char **compacted;
  struct _GList *work;
  struct _GList *el;
  work = (struct _GList *)(void *)0;
  i = 0;
  _Bool tmp_if_expr$2;
  struct _GList *tmp_if_expr$1;
  for( ; !(colors[(signed long int)i] == ((char *)NULL)); i = i + 1)
  {
    char **colors_protocols;
    colors_protocols=g_strsplit_set(colors[(signed long int)i], "; \t\n", 0);
    if(!(*colors_protocols == ((char *)NULL)))
    {
      colors_protocols[(signed long int)1]=remove_spaces(colors_protocols[(signed long int)1]);
      el=g_list_first(work);
      for( ; !(el == ((struct _GList *)NULL)); el = tmp_if_expr$1)
      {
        char **protohash_compact$$1$$1$$1$$1$$1$$col = (char **)el->data;
        if(protohash_compact$$1$$1$$1$$1$$1$$col == ((char **)NULL))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = !(protohash_compact$$1$$1$$1$$1$$1$$col[(signed long int)0] != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$2)
        {
          signed int return_value_g_ascii_strcasecmp$3;
          return_value_g_ascii_strcasecmp$3=g_ascii_strcasecmp(protohash_compact$$1$$1$$1$$1$$1$$col[(signed long int)0], colors_protocols[(signed long int)0]);
          if(return_value_g_ascii_strcasecmp$3 == 0)
          {
            char *old = protohash_compact$$1$$1$$1$$1$$1$$col[(signed long int)1];
            if(!(colors_protocols[1l] == ((char *)NULL)))
            {
              if(!(*colors_protocols[1l] == 0))
              {
                if(!(old == ((char *)NULL)))
                  protohash_compact$$1$$1$$1$$1$$1$$col[(signed long int)1]=g_strjoin(",", old, colors_protocols[(signed long int)1], (void *)0);

                else
                  protohash_compact$$1$$1$$1$$1$$1$$col[(signed long int)1]=g_strdup(colors_protocols[(signed long int)1]);
                g_free((void *)old);
              }

            }

            break;
          }

        }

        if(!(el == ((struct _GList *)NULL)))
          tmp_if_expr$1 = ((struct _GList *)el)->next;

        else
          tmp_if_expr$1 = (struct _GList *)(void *)0;
      }
      if(!(el == ((struct _GList *)NULL)))
        g_strfreev(colors_protocols);

      else
        work=g_list_prepend(work, (void *)colors_protocols);
    }

  }
  work=g_list_reverse(work);
  unsigned int return_value_g_list_length$4;
  return_value_g_list_length$4=g_list_length(work);
  void *return_value_malloc$5;
  return_value_malloc$5=malloc(sizeof(char *) /*8ul*/  * (unsigned long int)(return_value_g_list_length$4 + (unsigned int)1));
  compacted = (char **)return_value_malloc$5;
  i = 0;
  el=g_list_first(work);
  signed int tmp_post$7;
  struct _GList *tmp_if_expr$6;
  for( ; !(el == ((struct _GList *)NULL)); el = tmp_if_expr$6)
  {
    char **col = (char **)el->data;
    tmp_post$7 = i;
    i = i + 1;
    compacted[(signed long int)tmp_post$7]=g_strjoin(";", col[(signed long int)0], col[(signed long int)1], (void *)0);
    g_strfreev(col);
    if(!(el == ((struct _GList *)NULL)))
      tmp_if_expr$6 = ((struct _GList *)el)->next;

    else
      tmp_if_expr$6 = (struct _GList *)(void *)0;
  }
  compacted[(signed long int)i] = (char *)(void *)0;
  g_list_free(work);
  g_strfreev(colors);
  return compacted;
}

// protohash_init
// file datastructs.c line 63
static signed int protohash_init(void)
{
  if(!(protohash == ((struct _GHashTable *)NULL)))
    return (signed int)!(0 != 0);

  else
  {
    protohash=g_hash_table_new_full(g_str_hash, g_str_equal, freehash, freehash);
    return (signed int)(protohash != (struct _GHashTable *)(void *)0);
  }
}

// protohash_is_preferred
// file datastructs.c line 160
signed int protohash_is_preferred(const char *protoname)
{
  const struct anonymous$64 *item;
  signed int tmp_statement_expression$1;
  do
  {
    signed int protohash_is_preferred$$1$$1$$1$$_g_boolean_var_;
    if(!(protoname == ((const char *)NULL)))
      protohash_is_preferred$$1$$1$$1$$_g_boolean_var_ = 1;

    else
      protohash_is_preferred$$1$$1$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$1 = protohash_is_preferred$$1$$1$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "datastructs.c", 163, (const char *)"protohash_is_preferred", "protoname");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int _g_boolean_var_;
    if(!(protohash == ((struct _GHashTable *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$2 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "datastructs.c", 164, (const char *)"protohash_is_preferred", "protohash");

  }
  while((_Bool)0);
  void *return_value_g_hash_table_lookup$3;
  return_value_g_hash_table_lookup$3=g_hash_table_lookup(protohash, (const void *)protoname);
  item = (struct anonymous$64 *)return_value_g_hash_table_lookup$3;
  if(item == ((const struct anonymous$64 *)NULL))
    return 0;

  else
    return item->preferred;
}

// protohash_read_prefvect
// file datastructs.h line 46
signed int protohash_read_prefvect(char **colors)
{
  signed int i;
  struct _GdkColor gdk_color;
  protohash_clear();
  i = 0;
  _Bool tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  for( ; !(colors[(signed long int)i] == ((char *)NULL)); i = i + 1)
  {
    char **colors_protocols;
    char **protos;
    signed int j;
    colors_protocols=g_strsplit_set(colors[(signed long int)i], "; \t\n", 0);
    if(!(*colors_protocols == ((char *)NULL)))
    {
      gdk_color_parse(colors_protocols[(signed long int)0], &gdk_color);
      if(colors_protocols[1l] == ((char *)NULL))
        tmp_if_expr$2 = (_Bool)1;

      else
      {
        return_value_strlen$1=strlen(colors_protocols[(signed long int)1]);
        tmp_if_expr$2 = !(return_value_strlen$1 != 0ul) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$2)
        protohash_set(colors_protocols[(signed long int)1], gdk_color);

      else
      {
        protos=g_strsplit_set(colors_protocols[(signed long int)1], ", \t\n", 0);
        j = 0;
        for( ; !(protos[(signed long int)j] == ((char *)NULL)); j = j + 1)
          if(!(protos[(signed long int)j] == ((char *)NULL)))
          {
            if(!(*protos[(signed long int)j] == 0))
              protohash_set(protos[(signed long int)j], gdk_color);

          }

        g_strfreev(protos);
      }
      g_strfreev(colors_protocols);
    }

  }
  if(cycle_color_list == ((struct _GList *)NULL))
  {
    gdk_color_parse("#7f7f7f", &gdk_color);
    protohash_set((char *)(void *)0, gdk_color);
  }

  else
    cycle_color_list=g_list_reverse(cycle_color_list);
  services_fill_preferred();
  return (signed int)!(0 != 0);
}

// protohash_reset_cycle
// file datastructs.h line 49
void protohash_reset_cycle(void)
{
  current_cycle = cycle_color_list;
}

// protohash_set
// file datastructs.c line 95
static signed int protohash_set(char *protoname, struct _GdkColor protocolor)
{
  struct anonymous$64 item;
  signed int return_value_protohash_init$1;
  _Bool tmp_if_expr$5;
  if(protohash == ((struct _GHashTable *)NULL))
  {
    return_value_protohash_init$1=protohash_init();
    if(!(return_value_protohash_init$1 == 0))
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    item.color = protocolor;
    if(!(protoname == ((char *)NULL)))
    {
      if(!(*protoname == 0))
      {
        item.preferred = (signed int)!(0 != 0);
        char *return_value_g_strdup$2;
        return_value_g_strdup$2=g_strdup(protoname);
        void *return_value_g_memdup$3;
        return_value_g_memdup$3=g_memdup((const void *)&item, (unsigned int)sizeof(struct anonymous$64) /*16ul*/ );
        g_hash_table_insert(protohash, (void *)return_value_g_strdup$2, return_value_g_memdup$3);
      }

    }

    if(protoname == ((char *)NULL))
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = !(*protoname != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
    {
      item.preferred = 0;
      void *return_value_g_memdup$4;
      return_value_g_memdup$4=g_memdup((const void *)&item, (unsigned int)sizeof(struct anonymous$64) /*16ul*/ );
      cycle_color_list=g_list_prepend(cycle_color_list, return_value_g_memdup$4);
      current_cycle = cycle_color_list;
    }

    return (signed int)!(0 != 0);
  }
}

// purge_expired_legend_protocol
// file diagram.c line 486
static void purge_expired_legend_protocol(struct _GtkWidget *widget, void *data)
{
  struct _GtkLabel *lab;
  unsigned long int return_value_gtk_label_get_type$1;
  return_value_gtk_label_get_type$1=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_label_get_type$1);
  lab = (struct _GtkLabel *)return_value_g_type_check_instance_cast$2;
  const char *return_value_gtk_label_get_label$3;
  const struct anonymous$26 *return_value_protocol_summary_find$4;
  if(!(lab == ((struct _GtkLabel *)NULL)))
  {
    return_value_gtk_label_get_label$3=gtk_label_get_label(lab);
    return_value_protocol_summary_find$4=protocol_summary_find((unsigned long int)pref.stack_level, return_value_gtk_label_get_label$3);
    if(return_value_protocol_summary_find$4 == ((const struct anonymous$26 *)NULL))
    {
      gtk_widget_destroy(widget);
      known_protocols = known_protocols - 1u;
    }

  }

}

// read_boolean_config
// file preferences.c line 54
static void read_boolean_config(signed int *item, struct _GKeyFile *gkey, const char *key)
{
  signed int tmp;
  struct _GError *err = (struct _GError *)(void *)0;
  tmp=g_key_file_get_boolean(gkey, pref_group, key, &err);
  if(err == ((struct _GError *)NULL))
    *item = tmp;

}

// read_double_config
// file preferences.c line 74
static void read_double_config(double *item, struct _GKeyFile *gkey, const char *key)
{
  double tmp;
  struct _GError *err = (struct _GError *)(void *)0;
  tmp=g_key_file_get_double(gkey, pref_group, key, &err);
  if(err == ((struct _GError *)NULL))
    *item = tmp;

}

// read_int_config
// file preferences.c line 64
static void read_int_config(signed int *item, struct _GKeyFile *gkey, const char *key)
{
  signed int tmp;
  struct _GError *err = (struct _GError *)(void *)0;
  tmp=g_key_file_get_integer(gkey, pref_group, key, &err);
  if(err == ((struct _GError *)NULL))
    *item = tmp;

}

// read_string_config
// file preferences.c line 42
static void read_string_config(char **item, struct _GKeyFile *gkey, const char *key)
{
  char *tmp;
  tmp=g_key_file_get_string(gkey, pref_group, key, (struct _GError **)(void *)0);
  if(!(tmp == ((char *)NULL)))
  {
    g_free((void *)*item);
    *item = tmp;
  }

}

// register_glade_widget
// file ui_utils.h line 45
void register_glade_widget(struct _GladeXML *xm, struct _GObject *tgt, const char *widgetName)
{
  struct _GtkWidget *widget;
  widget=glade_xml_get_widget(xm, widgetName);
  g_object_set_data(tgt, widgetName, (void *)widget);
}

// register_treeview
// file ui_utils.h line 60
void register_treeview(struct _GtkWidget *window, struct _GtkTreeView *gv)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(window == ((struct _GtkWidget *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ui_utils.c", 165, (const char *)"register_treeview", "window");

  }
  while((_Bool)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
  g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$2, "EA_gv", (void *)gv);
}

// remove_spaces
// file datastructs.h line 56
char * remove_spaces(char *str)
{
  char *out = str;
  char *cur = str;
  char *tmp_post$1;
  if(!(str == ((char *)NULL)))
  {
    cur = str;
    for( ; !(*cur == 0); cur = cur + 1l)
      if((256 & (signed int)g_ascii_table[(signed long int)(unsigned char)*cur]) == 0)
      {
        tmp_post$1 = out;
        out = out + 1l;
        *tmp_post$1 = *cur;
      }

    *out = (char)0;
  }

  return str;
}

// reposition_canvas_nodes
// file diagram.c line 956
static signed int reposition_canvas_nodes(struct anonymous$5 *node_id, struct anonymous$82 *canvas_node, struct anonymous *data)
{
  double x = (double)0;
  double y = (double)0;
  double oddAngle;
  signed int tmp_statement_expression$3;
  _Bool tmp_if_expr$7;
  signed int tmp_statement_expression$5;
  _Bool tmp_if_expr$15;
  if(canvas_node->shown == 0)
  {
    gnome_canvas_item_hide(canvas_node->node_item);
    gnome_canvas_item_hide(canvas_node->text_item);
    return 0;
  }

  else
  {
    oddAngle = (double)data->angle;
    if(!(pref.stationary == 0))
    {
      if(!(canvas_node->is_new == 0))
      {
        double s_angle = (double)0;
        static unsigned int count = (unsigned int)0;
        if(count == 0u)
        {
          s_angle = 3.14159265358979323846 * (double)2.0f;
          count = count + 1u;
        }

        else
        {
          static unsigned int base = (unsigned int)1;
          if(!(2u * base >= count))
          {
            base = base * (unsigned int)2;
            count = (unsigned int)1;
          }

          s_angle = (3.14159265358979323846 * (double)count) / (double)base;
          count = count + (unsigned int)2;
        }
        double return_value_cos$1;
        return_value_cos$1=cos(s_angle);
        x = data->x_rad_max * return_value_cos$1;
        double return_value_sin$2;
        return_value_sin$2=sin(s_angle);
        y = data->y_rad_max * return_value_sin$2;
      }

    }

    else
    {
      if(!(canvas_node->is_new == 0))
      {
        if(!(*pref.center_node == 0))
        {
          struct anonymous$19 *node;
          node=nodes_catalog_find((const struct anonymous$5 *)&canvas_node->canvas_node_id);
          if(!(node == ((struct anonymous$19 *)NULL)))
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp$4;
            return_value___builtin_strcmp$4=__builtin_strcmp(node->name->str, pref.center_node);
            tmp_statement_expression$3 = return_value___builtin_strcmp$4;
            if(tmp_statement_expression$3 == 0)
              tmp_if_expr$7 = (_Bool)1;

            else
            {
              unsigned long int reposition_canvas_nodes$$1$$3$$1$$1$$2$$__s1_len;
              unsigned long int reposition_canvas_nodes$$1$$3$$1$$1$$2$$__s2_len;
              signed int return_value___builtin_strcmp$6;
              return_value___builtin_strcmp$6=__builtin_strcmp(node->numeric_name->str, pref.center_node);
              tmp_statement_expression$5 = return_value___builtin_strcmp$6;
              tmp_if_expr$7 = !(tmp_statement_expression$5 != 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$7)
              canvas_node->centered = (signed int)!(0 != 0);

          }

        }

      }

      if(!(canvas_node->centered == 0))
      {
        x = (data->xmax - data->xmin) / (double)2 + data->xmin;
        y = (data->ymax - data->ymin) / (double)2 + data->ymin;
        data->angle = data->angle - (float)(((double)2 * 3.14159265358979323846) / (double)data->n_nodes);
      }

      else
      {
        if(data->n_nodes % 2u == 0u)
          oddAngle = (double)((data->angle * (float)data->n_nodes) / (float)(data->n_nodes + (unsigned int)1));

        if(data->n_nodes >= 8u)
        {
          double return_value_cos$8;
          return_value_cos$8=cos(oddAngle);
          x = data->x_rad_max * return_value_cos$8;
          double return_value_sin$9;
          return_value_sin$9=sin(oddAngle);
          double return_value_asin$10;
          return_value_asin$10=asin(return_value_sin$9);
          y = (data->y_rad_max * return_value_asin$10) / (3.14159265358979323846 / (double)2);
        }

        else
        {
          double return_value_cos$11;
          return_value_cos$11=cos((double)data->angle);
          x = data->x_rad_max * return_value_cos$11;
          double return_value_sin$12;
          return_value_sin$12=sin((double)data->angle);
          y = data->y_rad_max * return_value_sin$12;
        }
      }
    }
    if(pref.stationary == 0)
      tmp_if_expr$15 = (_Bool)1;

    else
      tmp_if_expr$15 = canvas_node->is_new != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$15)
    {
      unsigned long int return_value_gnome_canvas_item_get_type$13;
      return_value_gnome_canvas_item_get_type$13=gnome_canvas_item_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
      return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)canvas_node->group_item, return_value_gnome_canvas_item_get_type$13);
      gnome_canvas_item_set((struct _GnomeCanvasItem *)return_value_g_type_check_instance_cast$14, "x", x, (const void *)"y", y, (void *)0);
      canvas_node->is_new = 0;
    }

    if(!(need_font_refresh == 0))
      gnome_canvas_item_set(canvas_node->text_item, "font", pref.fontname, (const void *)"fill_color", pref.text_color, (void *)0);

    if(!(pref.diagram_only == 0))
      gnome_canvas_item_hide(canvas_node->text_item);

    else
    {
      gnome_canvas_item_show(canvas_node->text_item);
      gnome_canvas_item_request_update(canvas_node->text_item);
    }
    gnome_canvas_item_show(canvas_node->node_item);
    gnome_canvas_item_request_update(canvas_node->node_item);
    data->node_i = data->node_i - 1u;
    if(!(data->node_i == 0u))
      data->angle = data->angle + (float)(((double)2 * 3.14159265358979323846) / (double)data->n_nodes);

    else
    {
      data->angle = (float)0.0;
      data->n_nodes = (unsigned int)0;
    }
    return 0;
  }
}

// retrieve_treeview
// file ui_utils.h line 61
struct _GtkTreeView * retrieve_treeview(struct _GtkWidget *window)
{
  if(window == ((struct _GtkWidget *)NULL))
    return (struct _GtkTreeView *)(void *)0;

  else
  {
    struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
    return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    void *return_value_g_object_get_data$2;
    return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "EA_gv");
    unsigned long int return_value_gtk_tree_view_get_type$3;
    return_value_gtk_tree_view_get_type$3=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_get_data$2, return_value_gtk_tree_view_get_type$3);
    return (struct _GtkTreeView *)return_value_g_type_check_instance_cast$4;
  }
}

// safe_strncat
// file util.c line 185
char * safe_strncat(char *dst, const char *src, unsigned long int maxlen)
{
  unsigned long int lendst;
  lendst=strlen(dst);
  if(lendst >= maxlen)
    return dst;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(dst);
    __builtin_strncat(dst, src, maxlen - return_value_strlen$1);
    dst[(signed long int)(maxlen - (unsigned long int)1)] = (char)0;
    return dst;
  }
}

// safe_strncpy
// file util.h line 46
char * safe_strncpy(char *dst, const char *src, unsigned long int maxlen)
{
  if(!(maxlen >= 1ul))
    return dst;

  else
  {
    __builtin_strncpy(dst, src, maxlen - (unsigned long int)1);
    dst[(signed long int)(maxlen - (unsigned long int)1)] = (char)0;
    return dst;
  }
}

// save_config
// file preferences.c line 249
void save_config(void)
{
  char *pref_file;
  char *cfgdata;
  char *tmpstr;
  signed int res;
  struct _GError *error = (struct _GError *)(void *)0;
  struct _GKeyFile *gkey;
  gkey=g_key_file_new();
  g_key_file_set_boolean(gkey, pref_group, "diagram_only", pref.diagram_only);
  g_key_file_set_boolean(gkey, pref_group, "group_unk", pref.group_unk);
  g_key_file_set_boolean(gkey, pref_group, "name_res", pref.name_res);
  g_key_file_set_double(gkey, pref_group, "node_timeout_time", pref.node_timeout_time);
  g_key_file_set_double(gkey, pref_group, "gui_node_timeout_time", pref.gui_node_timeout_time);
  g_key_file_set_double(gkey, pref_group, "proto_node_timeout_time", pref.proto_node_timeout_time);
  g_key_file_set_double(gkey, pref_group, "link_timeout_time", pref.link_timeout_time);
  g_key_file_set_double(gkey, pref_group, "gui_link_timeout_time", pref.gui_link_timeout_time);
  g_key_file_set_double(gkey, pref_group, "proto_link_timeout_time", pref.proto_link_timeout_time);
  g_key_file_set_double(gkey, pref_group, "proto_timeout_time", pref.proto_timeout_time);
  g_key_file_set_double(gkey, pref_group, "averaging_time", pref.averaging_time);
  g_key_file_set_double(gkey, pref_group, "node_radius_multiplier", pref.node_radius_multiplier);
  g_key_file_set_double(gkey, pref_group, "link_node_ratio", pref.link_node_ratio);
  g_key_file_set_integer(gkey, pref_group, "refresh_period", (signed int)pref.refresh_period);
  g_key_file_set_integer(gkey, pref_group, "size_mode", (signed int)pref.size_mode);
  g_key_file_set_integer(gkey, pref_group, "node_size_variable", (signed int)pref.node_size_variable);
  g_key_file_set_integer(gkey, pref_group, "stack_level", (signed int)pref.stack_level);
  g_key_file_set_string(gkey, pref_group, "filter", pref.filter);
  g_key_file_set_string(gkey, pref_group, "fontname", pref.fontname);
  g_key_file_set_string(gkey, pref_group, "text_color", pref.text_color);
  g_key_file_set_string(gkey, pref_group, "center_node", pref.center_node);
  tmpstr=g_strjoinv(" ", pref.colors);
  g_key_file_set_string(gkey, pref_group, "colors", tmpstr);
  g_free((void *)tmpstr);
  g_key_file_set_string(gkey, "General", "version", "0.9.13");
  cfgdata=g_key_file_to_data(gkey, (unsigned long int *)(void *)0, (struct _GError **)(void *)0);
  pref_file=config_file_name();
  res=g_file_set_contents(pref_file, cfgdata, (signed long int)-1, &error);
  g_free((void *)cfgdata);
  char *return_value_dcgettext$1;
  _Bool tmp_if_expr$3;
  char *tmp_if_expr$4;
  if(!(res == 0))
  {
    return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Preferences saved to %s", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$1, pref_file);
  }

  else
  {
    struct _GtkWidget *dialog;
    char *return_value_dcgettext$2;
    return_value_dcgettext$2=dcgettext((const char *)(void *)0, "Error saving preferences to '%s': %s", 5);
    if(!(error == ((struct _GError *)NULL)))
      tmp_if_expr$3 = error->message != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = error->message;

    else
      tmp_if_expr$4 = "";
    dialog=gtk_message_dialog_new((struct _GtkWindow *)(void *)0, (enum anonymous$67)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$69)GTK_MESSAGE_ERROR, (enum anonymous$70)GTK_BUTTONS_CLOSE, return_value_dcgettext$2, pref_file, tmp_if_expr$4);
    unsigned long int return_value_gtk_dialog_get_type$5;
    return_value_gtk_dialog_get_type$5=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$5);
    gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$6);
    gtk_widget_destroy(dialog);
  }
  g_free((void *)pref_file);
}

// save_session
// file main.c line 343
static signed int save_session(struct _GnomeClient *client, signed int phase, enum anonymous$76 save_style, signed int is_shutdown, enum anonymous$77 interact_style, signed int is_fast, void *client_data)
{
  char **argv;
  unsigned int argc;
  void *return_value_g_malloc0$1;
  return_value_g_malloc0$1=g_malloc0(sizeof(char *) /*8ul*/  * (unsigned long int)4);
  argv = (char **)return_value_g_malloc0$1;
  signed int tmp_statement_expression$2;
  do
  {
    signed int _g_boolean_var_;
    if(!(argv == ((char **)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$2 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "main.c", 352, (const char *)"save_session", "argv");

  }
  while((_Bool)0);
  argc = (unsigned int)1;
  argv[(signed long int)0] = (char *)client_data;
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_MESSAGE, "In save_session");
  gnome_client_set_clone_command(client, (signed int)argc, argv);
  gnome_client_set_restart_command(client, (signed int)argc, argv);
  return (signed int)!(0 != 0);
}

// sendrequest_inverse
// file thread_resolve.c line 220
static void sendrequest_inverse(struct anonymous$20 *ip)
{
  struct ipcache_item *rp = (struct ipcache_item *)(void *)0;
  if(!(ip == ((struct anonymous$20 *)NULL)))
  {
    rp=ipcache_prepare_request(ip);
    struct ipresolve_link *newitm;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct ipresolve_link) /*16ul*/ );
    newitm = (struct ipresolve_link *)return_value_malloc$1;
    newitm->itemToResolve = rp;
    newitm->next = (struct ipresolve_link *)(void *)0;
    if(resolveListHead == ((struct ipresolve_link *)NULL))
    {
      resolveListHead = newitm;
      resolveListTail = resolveListHead;
    }

    else
    {
      resolveListTail->next = newitm;
      resolveListTail = newitm;
    }
    pthread_cond_signal(&resolvecond);
    char *return_value_strlongip$2;
    return_value_strlongip$2=strlongip(&rp->ip);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "Resolver: queued request \"%s\".", return_value_strlongip$2);
  }

}

// services_clear
// file datastructs.h line 67
void services_clear(void)
{
  g_tree_destroy(service_names);
  g_tree_destroy(tcp_services);
  g_tree_destroy(udp_services);
}

// services_fill_preferred
// file datastructs.c line 370
static void services_fill_preferred(void)
{
  if(!(udp_services == ((struct _GTree *)NULL)))
    g_tree_foreach(udp_services, services_pref_trv, (void *)0);

  if(!(tcp_services == ((struct _GTree *)NULL)))
    g_tree_foreach(tcp_services, services_pref_trv, (void *)0);

}

// services_init
// file datastructs.h line 66
void services_init(void)
{
  struct _IO_FILE *services = (struct _IO_FILE *)(void *)0;
  char *line;
  char **t1 = (char **)(void *)0;
  char **t2 = (char **)(void *)0;
  char *str;
  struct anonymous$21 *port_service;
  unsigned int i;
  char filename[4096l];
  unsigned short int port_number;
  signed int tmp_statement_expression$4;
  char *return_value_fgets$5;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$10;
  signed int tmp_statement_expression$8;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$13;
  signed int return_value_sscanf$12;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$22;
  signed int return_value_g_ascii_strcasecmp$15;
  _Bool tmp_if_expr$17;
  signed int return_value_g_ascii_strcasecmp$16;
  _Bool tmp_if_expr$19;
  signed int return_value_g_ascii_strcasecmp$18;
  _Bool tmp_if_expr$21;
  signed int return_value_g_ascii_strcasecmp$20;
  char *return_value_dcgettext$23;
  char *return_value_dcgettext$24;
  signed int return_value_g_ascii_strcasecmp$28;
  char *return_value_dcgettext$25;
  signed int return_value_g_ascii_strcasecmp$26;
  if(tcp_services == ((struct _GTree *)NULL))
  {
    safe_strncpy(filename, "/etc/etherape/services", sizeof(char [4096l]) /*4096ul*/ );
    services=fopen(filename, "r");
    if(services == ((struct _IO_FILE *)NULL))
    {
      safe_strncpy(filename, "/etc/services", sizeof(char [4096l]) /*4096ul*/ );
      services=fopen(filename, "r");
      if(services == ((struct _IO_FILE *)NULL))
      {
        char *return_value_dcgettext$1;
        return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Failed to open %s. No TCP or UDP services will be recognized", 5);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, return_value_dcgettext$1, (const void *)filename);
        goto __CPROVER_DUMP_L46;
      }

    }

    char *return_value_dcgettext$2;
    return_value_dcgettext$2=dcgettext((const char *)(void *)0, "Reading TCP and UDP services from %s", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$2, (const void *)filename);
    service_names=g_tree_new_full(services_name_cmp, (void *)0, (void (*)(void *))(void *)0, services_tree_free);
    tcp_services=g_tree_new_full(services_port_cmp, (void *)0, (void (*)(void *))(void *)0, services_tree_free);
    udp_services=g_tree_new_full(services_port_cmp, (void *)0, (void (*)(void *))(void *)0, services_tree_free);
    void *return_value_g_malloc$3;
    return_value_g_malloc$3=g_malloc((unsigned long int)1024);
    line = (char *)return_value_g_malloc$3;
    do
    {
      signed int _g_boolean_var_;
      if(!(line == ((char *)NULL)))
        _g_boolean_var_ = 1;

      else
        _g_boolean_var_ = 0;
      tmp_statement_expression$4 = _g_boolean_var_;
      if((signed long int)tmp_statement_expression$4 == 0l)
        g_assertion_message_expr((char *)0, "datastructs.c", 414, (const char *)"services_init", "line");

    }
    while((_Bool)0);
    do
    {
      return_value_fgets$5=fgets(line, 1024, services);
      if(return_value_fgets$5 == ((char *)NULL))
        break;

      if(!((signed int)*line == 35))
      {
        if(!((signed int)*line == 32))
        {
          if(!((signed int)*line == 10))
          {
            if(!((signed int)*line == 9))
            {
              signed int error = 0;
              char *return_value_g_strdelimit$6;
              return_value_g_strdelimit$6=g_strdelimit(line, " \t\n", (char)32);
              if(return_value_g_strdelimit$6 == ((char *)NULL))
                error = (signed int)!(0 != 0);

              if(!(error == 0))
                tmp_if_expr$7 = (_Bool)1;

              else
              {
                t1=g_strsplit(line, " ", 0);
                tmp_if_expr$7 = !(t1 != ((char **)NULL)) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$7)
                error = (signed int)!(0 != 0);

              if(error == 0)
              {
                if(!(*t1 == ((char *)NULL)))
                {
                  char *told = t1[(signed long int)0];
                  t1[(signed long int)0]=g_ascii_strup(told, (signed long int)-1);
                  g_free((void *)told);
                }

              }

              i = (unsigned int)1;
              do
              {
                if(!(t1[(signed long int)i] == ((char *)NULL)))
                {
                  unsigned long int __s1_len;
                  unsigned long int __s2_len;
                  signed int return_value___builtin_strcmp$9;
                  return_value___builtin_strcmp$9=__builtin_strcmp("", t1[(signed long int)i]);
                  tmp_statement_expression$8 = return_value___builtin_strcmp$9;
                  tmp_if_expr$10 = !(tmp_statement_expression$8 != 0) ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$10 = (_Bool)0;
                if(!tmp_if_expr$10)
                  break;

                i = i + 1u;
              }
              while((_Bool)1);
              if(error == 0)
              {
                str = t1[(signed long int)i];
                if(!(str == ((char *)NULL)))
                {
                  t2=g_strsplit(str, "/", 0);
                  if(t2 == ((char **)NULL))
                    error = (signed int)!(0 != 0);

                }

              }

              if(t2 == ((char **)NULL) || !(error == 0))
                tmp_if_expr$11 = (_Bool)1;

              else
                tmp_if_expr$11 = !(t2[(signed long int)0] != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$11)
                error = (signed int)!(0 != 0);

              if(!(error == 0))
                tmp_if_expr$13 = (_Bool)1;

              else
              {
                return_value_sscanf$12=sscanf(t2[(signed long int)0], "%hd", &port_number);
                tmp_if_expr$13 = !(return_value_sscanf$12 != 0) ? (_Bool)1 : (_Bool)0;
              }
              if(!((signed int)port_number >= 1) || tmp_if_expr$13)
                error = (signed int)!(0 != 0);

              if(!(error == 0))
                tmp_if_expr$14 = (_Bool)1;

              else
                tmp_if_expr$14 = !(t2[(signed long int)1] != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$14)
                error = (signed int)!(0 != 0);

              if(!(error == 0))
                tmp_if_expr$22 = (_Bool)1;

              else
              {
                return_value_g_ascii_strcasecmp$15=g_ascii_strcasecmp("udp", t2[(signed long int)1]);
                if(!(return_value_g_ascii_strcasecmp$15 == 0))
                {
                  return_value_g_ascii_strcasecmp$16=g_ascii_strcasecmp("tcp", t2[(signed long int)1]);
                  tmp_if_expr$17 = return_value_g_ascii_strcasecmp$16 != 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$17 = (_Bool)0;
                if(tmp_if_expr$17)
                {
                  return_value_g_ascii_strcasecmp$18=g_ascii_strcasecmp("ddp", t2[(signed long int)1]);
                  tmp_if_expr$19 = return_value_g_ascii_strcasecmp$18 != 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$19 = (_Bool)0;
                if(tmp_if_expr$19)
                {
                  return_value_g_ascii_strcasecmp$20=g_ascii_strcasecmp("sctp", t2[(signed long int)1]);
                  tmp_if_expr$21 = return_value_g_ascii_strcasecmp$20 != 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$21 = (_Bool)0;
                tmp_if_expr$22 = tmp_if_expr$21 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$22)
                error = (signed int)!(0 != 0);

              if(!(error == 0))
              {
                return_value_dcgettext$23=dcgettext((const char *)(void *)0, "Unable to  parse line %s", 5);
                g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$23, line);
              }

              else
              {
                signed int return_value_g_ascii_strcasecmp$29;
                return_value_g_ascii_strcasecmp$29=g_ascii_strcasecmp("ddp", t2[(signed long int)1]);
                if(return_value_g_ascii_strcasecmp$29 == 0)
                {
                  return_value_dcgettext$24=dcgettext((const char *)(void *)0, "DDP protocols not supported in %s", 5);
                  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$24, line);
                }

                else
                {
                  return_value_g_ascii_strcasecmp$28=g_ascii_strcasecmp("sctp", t2[(signed long int)1]);
                  if(return_value_g_ascii_strcasecmp$28 == 0)
                  {
                    return_value_dcgettext$25=dcgettext((const char *)(void *)0, "SCTP protocols not supported in %s", 5);
                    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$25, line);
                  }

                  else
                  {
                    port_service=port_service_new(port_number, t1[(signed long int)0]);
                    signed int return_value_g_ascii_strcasecmp$27;
                    return_value_g_ascii_strcasecmp$27=g_ascii_strcasecmp("tcp", t2[(signed long int)1]);
                    if(return_value_g_ascii_strcasecmp$27 == 0)
                      g_tree_replace(tcp_services, (void *)&port_service->port, (void *)port_service);

                    else
                    {
                      return_value_g_ascii_strcasecmp$26=g_ascii_strcasecmp("udp", t2[(signed long int)1]);
                      if(return_value_g_ascii_strcasecmp$26 == 0)
                        g_tree_replace(udp_services, (void *)&port_service->port, (void *)port_service);

                    }
                  }
                }
              }
              g_strfreev(t2);
              t2 = (char **)(void *)0;
              g_strfreev(t1);
              t1 = (char **)(void *)0;
            }

          }

        }

      }

    }
    while((_Bool)1);
    fclose(services);
    g_free((void *)line);
    g_tree_foreach(udp_services, services_port_trv, (void *)service_names);
    g_tree_foreach(tcp_services, services_port_trv, (void *)service_names);
    services_fill_preferred();
  }


__CPROVER_DUMP_L46:
  ;
}

// services_name_cmp
// file datastructs.c line 341
static signed int services_name_cmp(const void *a, const void *b, void *unused)
{
  signed int return_value_g_ascii_strcasecmp$1;
  return_value_g_ascii_strcasecmp$1=g_ascii_strcasecmp((const char *)a, (const char *)b);
  return return_value_g_ascii_strcasecmp$1;
}

// services_port_cmp
// file datastructs.c line 326
static signed int services_port_cmp(const void *a, const void *b, void *unused)
{
  unsigned short int port_a;
  unsigned short int port_b;
  port_a = *((unsigned short int *)a);
  port_b = *((unsigned short int *)b);
  if(!((signed int)port_b >= (signed int)port_a))
    return 1;

  else
    if(!((signed int)port_a >= (signed int)port_b))
      return -1;

    else
      return 0;
}

// services_port_find
// file datastructs.h line 71
const struct anonymous$21 * services_port_find(const char *name)
{
  if(name == ((const char *)NULL) || service_names == ((struct _GTree *)NULL))
    return (const struct anonymous$21 *)(void *)0;

  else
  {
    void *return_value_g_tree_lookup$1;
    return_value_g_tree_lookup$1=g_tree_lookup(service_names, (const void *)name);
    return (const struct anonymous$21 *)return_value_g_tree_lookup$1;
  }
}

// services_port_trv
// file datastructs.c line 352
static signed int services_port_trv(void *key, void *value, void *data)
{
  const struct anonymous$21 *svc = (const struct anonymous$21 *)value;
  struct _GTree *tree = (struct _GTree *)data;
  struct anonymous$21 *new_el;
  new_el=port_service_new(svc->port, svc->name);
  g_tree_replace(tree, (void *)new_el->name, (void *)new_el);
  return 0;
}

// services_pref_trv
// file datastructs.c line 364
static signed int services_pref_trv(void *key, void *value, void *data)
{
  struct anonymous$21 *svc = (struct anonymous$21 *)value;
  svc->preferred=protohash_is_preferred(svc->name);
  return 0;
}

// services_tcp_find
// file datastructs.h line 69
const struct anonymous$21 * services_tcp_find(unsigned short int port)
{
  void *return_value_g_tree_lookup$1;
  if(!(tcp_services == ((struct _GTree *)NULL)))
  {
    return_value_g_tree_lookup$1=g_tree_lookup(tcp_services, (const void *)&port);
    return (struct anonymous$21 *)return_value_g_tree_lookup$1;
  }

  else
    return (const struct anonymous$21 *)(void *)0;
}

// services_tree_free
// file datastructs.c line 346
static void services_tree_free(void *p)
{
  port_service_free((struct anonymous$21 *)p);
}

// services_udp_find
// file datastructs.h line 70
const struct anonymous$21 * services_udp_find(unsigned short int port)
{
  void *return_value_g_tree_lookup$1;
  if(!(udp_services == ((struct _GTree *)NULL)))
  {
    return_value_g_tree_lookup$1=g_tree_lookup(udp_services, (const void *)&port);
    return (struct anonymous$21 *)return_value_g_tree_lookup$1;
  }

  else
    return (const struct anonymous$21 *)(void *)0;
}

// session_die
// file main.c line 335
static void session_die(struct _GnomeClient *client, void *client_data)
{
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_MESSAGE, "in die");
  gtk_main_quit();
}

// set_active_interface
// file menus.c line 632
static void set_active_interface(void)
{
  struct _GtkWidget *widget;
  struct _GList *menu_items = (struct _GList *)(void *)0;
  char *label;
  widget=glade_xml_get_widget(appdata.xml, "interfaces_menu");
  unsigned long int return_value_gtk_menu_shell_get_type$1;
  return_value_gtk_menu_shell_get_type$1=gtk_menu_shell_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_menu_shell_get_type$1);
  menu_items = ((struct _GtkMenuShell *)return_value_g_type_check_instance_cast$2)->children;
  signed int tmp_statement_expression$11;
  unsigned long int return_value_gtk_check_menu_item_get_type$9;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  while(!(menu_items == ((struct _GList *)NULL)))
  {
    widget = (struct _GtkWidget *)menu_items->data;
    if(!(appdata.input_file == ((char *)NULL)))
    {
      unsigned long int return_value_gtk_check_menu_item_get_type$3;
      return_value_gtk_check_menu_item_get_type$3=gtk_check_menu_item_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_check_menu_item_get_type$3);
      gtk_check_menu_item_set_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$4, (signed int)!(0 != 0));
      goto __CPROVER_DUMP_L5;
    }

    unsigned long int return_value_gtk_bin_get_type$5;
    return_value_gtk_bin_get_type$5=gtk_bin_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_bin_get_type$5);
    unsigned long int return_value_gtk_label_get_type$7;
    return_value_gtk_label_get_type$7=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkBin *)return_value_g_type_check_instance_cast$6)->child, return_value_gtk_label_get_type$7);
    label = ((struct _GtkLabel *)return_value_g_type_check_instance_cast$8)->label;
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$12;
    return_value___builtin_strcmp$12=__builtin_strcmp(label, appdata.interface);
    tmp_statement_expression$11 = return_value___builtin_strcmp$12;
    if(tmp_statement_expression$11 == 0)
    {
      return_value_gtk_check_menu_item_get_type$9=gtk_check_menu_item_get_type();
      return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_check_menu_item_get_type$9);
      gtk_check_menu_item_set_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$10, (signed int)!(0 != 0));
    }

    menu_items = menu_items->next;
  }

__CPROVER_DUMP_L5:
  ;
}

// set_debug_level
// file main.c line 303
static void set_debug_level(void)
{
  const char *env_debug;
  env_debug=g_getenv("APE_DEBUG");
  appdata.debug_mask = (enum anonymous$30)(G_LOG_LEVEL_MASK & ~(G_LOG_LEVEL_DEBUG | G_LOG_LEVEL_INFO));
  signed int return_value_g_ascii_strcasecmp$1;
  if(!(env_debug == ((const char *)NULL)))
  {
    signed int return_value_g_ascii_strcasecmp$2;
    return_value_g_ascii_strcasecmp$2=g_ascii_strcasecmp(env_debug, "INFO");
    if(return_value_g_ascii_strcasecmp$2 == 0)
      appdata.debug_mask = (enum anonymous$30)(G_LOG_LEVEL_MASK & ~G_LOG_LEVEL_DEBUG);

    else
    {
      return_value_g_ascii_strcasecmp$1=g_ascii_strcasecmp(env_debug, "DEBUG");
      if(return_value_g_ascii_strcasecmp$1 == 0)
        appdata.debug_mask = (enum anonymous$30)G_LOG_LEVEL_MASK;

    }
  }

  if(!(quiet == 0))
    appdata.debug_mask = (enum anonymous$30)0;

  g_log_set_handler((const char *)(void *)0, (enum anonymous$30)G_LOG_LEVEL_MASK, (void (*)(const char *, enum anonymous$30, const char *, void *))log_handler, (void *)0);
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "debug_mask %d", appdata.debug_mask);
}

// set_default_config
// file preferences.c line 130
void set_default_config(struct pref_struct *p)
{
  p->diagram_only = 0;
  p->group_unk = (signed int)!(0 != 0);
  p->stationary = 0;
  p->name_res = (signed int)!(0 != 0);
  p->node_timeout_time = 120000.0;
  p->gui_node_timeout_time = 60000.0;
  p->proto_node_timeout_time = 60000.0;
  p->link_timeout_time = 20000.0;
  p->gui_link_timeout_time = 20000.0;
  p->proto_link_timeout_time = 20000.0;
  p->proto_timeout_time = 600000.0;
  p->averaging_time = 2000.0;
  p->node_radius_multiplier = 0.0005;
  p->link_node_ratio = 1.0;
  p->refresh_period = (unsigned int)100;
  p->size_mode = (enum anonymous$59)LINEAR;
  p->node_size_variable = (enum anonymous$60)INST_OUTBOUND;
  p->stack_level = (unsigned int)0;
  g_free((void *)p->filter);
  p->filter=g_strdup("ip or ip6");
  g_free((void *)p->fontname);
  p->fontname=g_strdup("Sans 8");
  g_free((void *)p->text_color);
  p->text_color=g_strdup("#ffff00");
  g_strfreev(p->colors);
  p->colors=g_strsplit("#ff0000;WWW,HTTP #0000ff;DOMAIN #00ff00 #ffff00 #ff00ff #00ffff #ffffff #ff7700 #ff0077 #ffaa77 #7777ff #aaaa33", " ", 0);
  p->colors=protohash_compact(p->colors);
  protohash_read_prefvect(p->colors);
  g_free((void *)p->center_node);
  p->center_node=g_strdup("");
}

// set_ethent
// file resolv.c line 269
static void set_ethent(char *path)
{
  if(!(eth_p == ((struct _IO_FILE *)NULL)))
    rewind(eth_p);

  else
    eth_p=fopen(path, "r");
}

// set_filter
// file capture.h line 39
signed int set_filter(char *filter_string, char *device)
{
  char ebuf[300l];
  unsigned int netnum;
  unsigned int netmask = (unsigned int)0;
  struct bpf_program fp;
  signed int return_value_pcap_lookupnet$2;
  char *return_value_dcgettext$3;
  char *return_value_pcap_geterr$4;
  signed int return_value_pcap_setfilter$7;
  char *return_value_dcgettext$5;
  char *return_value_pcap_geterr$6;
  if(pch_struct == ((struct pcap *)NULL))
    return 1;

  else
  {
    if(!(device == ((char *)NULL)))
    {
      return_value_pcap_lookupnet$2=pcap_lookupnet(device, &netnum, &netmask, ebuf);
      if(!(return_value_pcap_lookupnet$2 >= 0))
      {
        char *return_value_dcgettext$1;
        return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Couldn't obtain netmask info (%s). Filters involving broadcast addresses could behave incorrectly.", 5);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$1, (const void *)ebuf);
        netmask = (unsigned int)0;
      }

    }

    signed int return_value_pcap_compile$8;
    return_value_pcap_compile$8=pcap_compile(pch_struct, &fp, filter_string, 1, netmask);
    if(!(return_value_pcap_compile$8 >= 0))
    {
      return_value_dcgettext$3=dcgettext((const char *)(void *)0, "Unable to parse filter string (%s). Filter ignored.", 5);
      return_value_pcap_geterr$4=pcap_geterr(pch_struct);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$3, return_value_pcap_geterr$4);
    }

    else
    {
      return_value_pcap_setfilter$7=pcap_setfilter(pch_struct, &fp);
      if(!(return_value_pcap_setfilter$7 >= 0))
      {
        return_value_dcgettext$5=dcgettext((const char *)(void *)0, "Can't install filter (%s). Filter ignored.", 5);
        return_value_pcap_geterr$6=pcap_geterr(pch_struct);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$5, return_value_pcap_geterr$6);
      }

    }
    return 0;
  }
}

// set_node_name
// file node.c line 324
static void set_node_name(struct anonymous$19 *node, const struct anonymous$39 *sequence)
{
  const struct anonymous$39 *iter;
  signed int cont;
  if(!((G_LOG_LEVEL_DEBUG & (signed int)appdata.debug_mask) == 0))
  {
    char *msgid;
    msgid=node_id_dump(&node->node_id);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "set_node_name: node id [%s]", msgid);
    g_free((void *)msgid);
  }

  cont = (signed int)!(0 != 0);
  iter = sequence;
  _Bool tmp_if_expr$3;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$8;
  signed int tmp_statement_expression$6;
  char *tmp_if_expr$5;
  _Bool tmp_if_expr$12;
  signed int tmp_statement_expression$10;
  char *tmp_if_expr$9;
  for( ; !(iter->protocol == ((const char *)NULL)) && !(cont == 0); iter = iter + 1l)
  {
    const struct _GList *name_item;
    const struct anonymous$36 *name;
    const struct anonymous$26 *protocol;
    unsigned int j = (unsigned int)5;
    for( ; !(cont == 0) && !(j == 0u); j = j - 1u)
    {
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, " Searching %s at stack level %d", iter->protocol, j);
      protocol=protocol_stack_find(&node->node_stats.stats_protos, (unsigned long int)j, iter->protocol);
      if(protocol == ((const struct anonymous$26 *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        unsigned long int set_node_name$$1$$2$$1$$1$$1$$1$$__s1_len;
        unsigned long int set_node_name$$1$$2$$1$$1$$1$$1$$__s2_len;
        signed int return_value___builtin_strcmp$2;
        return_value___builtin_strcmp$2=__builtin_strcmp(protocol->name, iter->protocol);
        tmp_statement_expression$1 = return_value___builtin_strcmp$2;
        tmp_if_expr$3 = tmp_statement_expression$1 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$3)
      {
        name_item = protocol->node_names;
        if(name_item == ((const struct _GList *)NULL))
          g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "  found protocol without names, ignore");

        else
        {
          name = (const struct anonymous$36 *)name_item->data;
          if(!((G_LOG_LEVEL_DEBUG & (signed int)appdata.debug_mask) == 0))
          {
            char *msgname;
            msgname=node_name_dump(name);
            if(!(name->res_name == ((struct _GString *)NULL)))
              tmp_if_expr$4 = (_Bool)1;

            else
              tmp_if_expr$4 = !(iter->must_resolve != 0) ? (_Bool)1 : (_Bool)0;
            if(pref.name_res == 0 || tmp_if_expr$4)
              g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "  found protocol with name [%s]", msgname);

            else
              g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "  found protocol with UNRESOLVED name [%s], ignored", msgname);
            g_free((void *)msgname);
          }

          if(!(name->res_name == ((struct _GString *)NULL)))
            tmp_if_expr$13 = (_Bool)1;

          else
            tmp_if_expr$13 = !(iter->must_resolve != 0) ? (_Bool)1 : (_Bool)0;
          if(pref.name_res == 0 || tmp_if_expr$13)
          {
            if(!(name->res_name == ((struct _GString *)NULL)))
            {
              if(node->name == ((struct _GString *)NULL))
                tmp_if_expr$8 = (_Bool)1;

              else
              {
                unsigned long int __s1_len;
                unsigned long int __s2_len;
                signed int return_value___builtin_strcmp$7;
                return_value___builtin_strcmp$7=__builtin_strcmp(node->name->str, name->res_name->str);
                tmp_statement_expression$6 = return_value___builtin_strcmp$7;
                tmp_if_expr$8 = tmp_statement_expression$6 != 0 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$8)
              {
                if(!(node->name == ((struct _GString *)NULL)))
                  tmp_if_expr$5 = node->name->str;

                else
                  tmp_if_expr$5 = "<none>";
                g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "  set node name from %s to %s", tmp_if_expr$5, name->res_name->str);
                g_string_assign(node->name, name->res_name->str);
              }

            }

            if(node->numeric_name == ((struct _GString *)NULL))
              tmp_if_expr$12 = (_Bool)1;

            else
            {
              unsigned long int set_node_name$$1$$2$$1$$1$$1$$4$$2$$__s1_len;
              unsigned long int set_node_name$$1$$2$$1$$1$$1$$4$$2$$__s2_len;
              signed int return_value___builtin_strcmp$11;
              return_value___builtin_strcmp$11=__builtin_strcmp(node->numeric_name->str, name->numeric_name->str);
              tmp_statement_expression$10 = return_value___builtin_strcmp$11;
              tmp_if_expr$12 = tmp_statement_expression$10 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$12)
            {
              if(!(node->numeric_name == ((struct _GString *)NULL)))
                tmp_if_expr$9 = node->numeric_name->str;

              else
                tmp_if_expr$9 = "none";
              g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "  set node numeric_name from %s to %s", tmp_if_expr$9, name->numeric_name->str);
              g_string_assign(node->numeric_name, name->numeric_name->str);
            }

            cont = 0;
          }

        }
      }

    }
  }
  g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "set_node_name END --");
}

// set_statusbar_msg
// file diagram.h line 31
void set_statusbar_msg(char *str)
{
  static char *status_string = (char *)(void *)0;
  if(!(status_string == ((char *)NULL)))
    g_free((void *)status_string);

  status_string=g_strdup(str);
  gtk_statusbar_pop(appdata.statusbar, (unsigned int)0);
  gtk_statusbar_push(appdata.statusbar, (unsigned int)0, status_string);
}

// setup_link_type
// file decode_proto.h line 28
signed int setup_link_type(unsigned int linktype)
{
  signed int i;
  lkentry = (const struct linktype_data_tag *)(void *)0;
  i = 0;
  for( ; !(linktypes[(signed long int)i].lt_desc == ((const char *)NULL)); i = i + 1)
    if(linktypes[(signed long int)i].dlt_linktype == linktype)
    {
      lkentry = linktypes + (signed long int)i;
      char *return_value_dcgettext$1;
      return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Link type is %s", 5);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$1, lkentry->lt_desc);
      return (signed int)!(0 != 0);
    }

  return 0;
}

// show_widget
// file ui_utils.h line 51
void show_widget(struct _GtkWidget *window, const char *lblname)
{
  struct _GtkWidget *widget;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$2;
  return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, lblname);
  widget = (struct _GtkWidget *)return_value_g_object_get_data$2;
  gtk_widget_show(widget);
}

// signal_export
// file main.c line 415
static void signal_export(signed int signum)
{
  appdata.request_dump = (signed int)!(0 != 0);
}

// start_capture
// file capture.h line 34
signed int start_capture(void)
{
  struct _GnomeCanvas *gc;
  if((signed int)capture_status == PLAY)
    return (signed int)!(0 != 0);

  else
  {
    if((signed int)capture_status == STOP)
    {
      protocol_summary_open();
      nodes_catalog_open();
      links_catalog_open();
    }

    if((signed int)capture_status == STOP && !(appdata.interface == ((char *)NULL)))
    {
      char *return_value_dcgettext$1;
      return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Starting live capture", 5);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, return_value_dcgettext$1);
      capture_source=gdk_input_add(pcap_fd, (enum anonymous$4)GDK_INPUT_READ, (void (*)(void *, signed int, enum anonymous$4))gdk_input_callback, (void *)0);
    }

    else
      if(appdata.interface == ((char *)NULL))
      {
        char *return_value_dcgettext$2;
        return_value_dcgettext$2=dcgettext((const char *)(void *)0, "Starting offline capture", 5);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, return_value_dcgettext$2);
        unsigned int return_value_g_timeout_add_full$3;
        return_value_g_timeout_add_full$3=g_timeout_add_full(0, (unsigned int)1, (signed int (*)(void *))get_offline_packet, (void *)0, (void (*)(void *))cap_t_o_destroy);
        capture_source = (signed int)return_value_g_timeout_add_full$3;
      }

    struct _GtkWidget *return_value_glade_xml_get_widget$4;
    return_value_glade_xml_get_widget$4=glade_xml_get_widget(appdata.xml, "canvas1");
    unsigned long int return_value_gnome_canvas_get_type$5;
    return_value_gnome_canvas_get_type$5=gnome_canvas_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$4, return_value_gnome_canvas_get_type$5);
    gc = (struct _GnomeCanvas *)return_value_g_type_check_instance_cast$6;
    if(!(gc == ((struct _GnomeCanvas *)NULL)))
      gc->aa = (unsigned int)!(0 != 0);

    capture_status = (enum status_t)PLAY;
    return (signed int)!(0 != 0);
  }
}

// start_threads
// file thread_resolve.c line 167
static void start_threads()
{
  unsigned long int curth;
  signed int i;
  signed int maxth = 6;
  union pthread_attr_t attr;
  request_stop_thread = 0;
  signed int return_value_pthread_attr_init$1;
  return_value_pthread_attr_init$1=pthread_attr_init(&attr);
  _Bool tmp_if_expr$3;
  signed int return_value_pthread_attr_setdetachstate$2;
  if(!(return_value_pthread_attr_init$1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_pthread_attr_setdetachstate$2=pthread_attr_setdetachstate(&attr, 1);
    tmp_if_expr$3 = return_value_pthread_attr_setdetachstate$2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, "pthread_attr_init failed, resolver will not be available\n");

  else
  {
    i = 0;
    for( ; !(i >= maxth); i = i + 1)
    {
      signed int return_value_pthread_create$4;
      return_value_pthread_create$4=pthread_create(&curth, (const union pthread_attr_t *)(void *)0, thread_pool_routine, (void *)0);
      if(!(return_value_pthread_create$4 == 0))
      {
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, "pthread_create failed, resolver has only %d threads\n", i);
        break;
      }

      resolver_threads[(signed long int)i] = curth;
    }
    resolver_threads_num = i;
  }
}

// stats_info_create
// file info_windows.c line 771
static struct _GtkWidget * stats_info_create(const char *idkey, void *key)
{
  struct _GtkWidget *window;
  struct _GladeXML *xml_info_window;
  struct _GtkTreeView *gv;
  xml_info_window=glade_xml_new(appdata.glade_file, "node_proto_info", (const char *)(void *)0);
  if(xml_info_window == ((struct _GladeXML *)NULL))
  {
    char *return_value_dcgettext$1;
    return_value_dcgettext$1=dcgettext((const char *)(void *)0, "We could not load the interface! (%s)", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_ERROR, return_value_dcgettext$1, appdata.glade_file);

  __CPROVER_DUMP_L2:
    ;
    goto __CPROVER_DUMP_L2;
    return (struct _GtkWidget *)(void *)0;
  }

  else
  {
    glade_xml_signal_autoconnect(xml_info_window);
    window=glade_xml_get_widget(xml_info_window, "node_proto_info");
    gtk_widget_show(window);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$2, "src_label");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$3, "dst_label");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$4, "node_iproto_name");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$5, "node_iproto_numeric_name");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$6, "node_iproto_name_b");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$7, "node_iproto_numeric_name_b");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$8, "total_label");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$9, "inbound_label");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$10, "outbound_label");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
    return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$11, "node_iproto_avg");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$12, "node_iproto_avg_in");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$13, "node_iproto_avg_out");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
    return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$14, "node_iproto_accum");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$15, "node_iproto_accum_in");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$16, "node_iproto_accum_out");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
    return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$17, "node_iproto_avgsize");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$18, "node_iproto_avgsize_in");
    struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
    return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    register_glade_widget(xml_info_window, (struct _GObject *)return_value_g_type_check_instance_cast$19, "node_iproto_avgsize_out");
    struct _GtkWidget *return_value_glade_xml_get_widget$20;
    return_value_glade_xml_get_widget$20=glade_xml_get_widget(xml_info_window, "node_iproto_proto");
    unsigned long int return_value_gtk_tree_view_get_type$21;
    return_value_gtk_tree_view_get_type$21=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
    return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$20, return_value_gtk_tree_view_get_type$21);
    gv = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$22;
    register_treeview(window, gv);
    create_protocols_table(window);
    g_object_unref((void *)xml_info_window);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
    return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$23, idkey, key);
    stats_info_windows=g_list_prepend(stats_info_windows, (void *)window);
    return window;
  }
}

// stats_info_update
// file info_windows.c line 831
static void stats_info_update(struct _GtkWidget *window, const struct anonymous$27 *stats)
{
  if(stats == ((const struct anonymous$27 *)NULL))
  {
    update_gtklabel(window, "node_iproto_avg", "X");
    update_gtklabel(window, "node_iproto_accum", "X");
    update_gtklabel(window, "node_iproto_avgsize", "X");
    update_gtklabel(window, "node_iproto_avg_in", "X");
    update_gtklabel(window, "node_iproto_avg_out", "X");
    update_gtklabel(window, "node_iproto_accum_in", "X");
    update_gtklabel(window, "node_iproto_accum_out", "X");
    update_gtklabel(window, "node_iproto_avgsize_in", "X");
    update_gtklabel(window, "node_iproto_avgsize_out", "X");
    update_protocols_table(window, (const struct anonymous$25 *)(void *)0);
    unsigned long int return_value_gtk_widget_get_type$1;
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_widget_get_type$1);
    gtk_widget_queue_resize((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  }

  else
  {
    char *str;
    str=traffic_to_str(stats->stats.average, (signed int)!(0 != 0));
    update_gtklabel(window, "node_iproto_avg", str);
    g_free((void *)str);
    str=traffic_to_str(stats->stats.accumulated, 0);
    update_gtklabel(window, "node_iproto_accum", str);
    g_free((void *)str);
    str=traffic_to_str(stats->stats.avg_size, 0);
    update_gtklabel(window, "node_iproto_avgsize", str);
    g_free((void *)str);
    str=traffic_to_str(stats->stats_in.average, (signed int)!(0 != 0));
    update_gtklabel(window, "node_iproto_avg_in", str);
    g_free((void *)str);
    str=traffic_to_str(stats->stats_out.average, (signed int)!(0 != 0));
    update_gtklabel(window, "node_iproto_avg_out", str);
    g_free((void *)str);
    str=traffic_to_str(stats->stats_in.accumulated, 0);
    update_gtklabel(window, "node_iproto_accum_in", str);
    g_free((void *)str);
    str=traffic_to_str(stats->stats_out.accumulated, 0);
    update_gtklabel(window, "node_iproto_accum_out", str);
    g_free((void *)str);
    str=traffic_to_str(stats->stats_in.avg_size, 0);
    update_gtklabel(window, "node_iproto_avgsize_in", str);
    g_free((void *)str);
    str=traffic_to_str(stats->stats_out.avg_size, 0);
    update_gtklabel(window, "node_iproto_avgsize_out", str);
    g_free((void *)str);
    update_protocols_table(window, &stats->stats_protos);
  }
}

// stop_capture
// file capture.h line 36
signed int stop_capture(void)
{
  struct pcap_stat ps;
  char *return_value_dcgettext$2;
  if((signed int)capture_status == STOP)
    return (signed int)!(0 != 0);

  else
  {
    if(!(appdata.interface == ((char *)NULL)))
    {
      char *return_value_dcgettext$1;
      return_value_dcgettext$1=dcgettext((const char *)(void *)0, "Stopping live capture", 5);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, return_value_dcgettext$1);
      gdk_input_remove(capture_source);
    }

    else
    {
      return_value_dcgettext$2=dcgettext((const char *)(void *)0, "Stopping offline capture", 5);
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, return_value_dcgettext$2);
    }
    capture_status = (enum status_t)STOP;
    protocol_summary_close();
    nodes_catalog_close();
    links_catalog_close();
    delete_conversations();
    new_nodes_clear();
    if(appdata.interface == ((char *)NULL))
      get_offline_packet();

    pcap_stats(pch_struct, &ps);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, "libpcap received %d packets, dropped %d. EtherApe saw %lu", ps.ps_recv, ps.ps_drop, appdata.n_packets);
    pcap_close(pch_struct);
    char *return_value_dcgettext$3;
    return_value_dcgettext$3=dcgettext((const char *)(void *)0, "Capture device stopped or file closed", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_INFO, return_value_dcgettext$3);
    return (signed int)!(0 != 0);
  }
}

// stop_threads
// file thread_resolve.c line 203
static void stop_threads()
{
  pthread_mutex_lock(&resolvemtx);
  request_stop_thread = 1;
  pthread_cond_broadcast(&resolvecond);
  pthread_mutex_unlock(&resolvemtx);
  resolver_threads_num = 0;
}

// strlongip
// file ip-cache.h line 66
char * strlongip(struct anonymous$20 *ip)
{
  const char *return_value_address_to_str$1;
  return_value_address_to_str$1=address_to_str(ip);
  return (char *)return_value_address_to_str$1;
}

// strtdiff
// file ip-cache.c line 93
char * strtdiff(char *d, unsigned long int lend, signed long int signeddiff)
{
  unsigned long int diff;
  unsigned long int seconds;
  unsigned long int minutes;
  unsigned long int hours;
  signed long int days;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(d == ((char *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "ip-cache.c", 99, (const char *)"strtdiff", "d");

  }
  while((_Bool)0);
  signed long int return_value_labs$8;
  return_value_labs$8=labs(signeddiff);
  diff = (unsigned long int)return_value_labs$8;
  unsigned long int return_value_strlen$2;
  unsigned long int return_value_strlen$3;
  unsigned long int return_value_strlen$4;
  unsigned long int return_value_strlen$5;
  unsigned long int return_value_strlen$6;
  unsigned long int return_value_strlen$7;
  if(!(diff == 0ul))
  {
    seconds = diff % (unsigned long int)60;
    diff = diff / (unsigned long int)60;
    minutes = diff % (unsigned long int)60;
    diff = diff / (unsigned long int)60;
    hours = diff % (unsigned long int)24;
    days = signeddiff / (signed long int)(60 * 60 * 24);
    if(!(days == 0l))
      snprintf(d, lend, "%lid", days);

    else
      *d = (char)0;
    if(!(hours == 0ul))
    {
      return_value_strlen$2=strlen(d);
      return_value_strlen$3=strlen(d);
      snprintf(d + (signed long int)return_value_strlen$2, lend - return_value_strlen$3, "%luh", hours);
    }

    if(!(minutes == 0ul))
    {
      return_value_strlen$4=strlen(d);
      return_value_strlen$5=strlen(d);
      snprintf(d + (signed long int)return_value_strlen$4, lend - return_value_strlen$5, "%lum", minutes);
    }

    if(!(seconds == 0ul))
    {
      return_value_strlen$6=strlen(d);
      return_value_strlen$7=strlen(d);
      snprintf(d + (signed long int)return_value_strlen$6, lend - return_value_strlen$7, "%lus", seconds);
    }

  }

  else
    snprintf(d, lend, "0s");
  return d;
}

// substract_times
// file basic_stats.c line 41
struct timeval substract_times(struct timeval a, struct timeval b)
{
  struct timeval result;
  if(!(a.tv_usec >= b.tv_usec))
  {
    signed int nsec = (signed int)((b.tv_usec - a.tv_usec) / (signed long int)1000000 + (signed long int)1);
    b.tv_usec = b.tv_usec - (signed long int)(1000000 * nsec);
    b.tv_sec = b.tv_sec + (signed long int)nsec;
  }

  if(a.tv_usec + -b.tv_usec >= 1000001l)
  {
    signed int substract_times$$1$$2$$nsec = (signed int)((a.tv_usec - b.tv_usec) / (signed long int)1000000);
    b.tv_usec = b.tv_usec + (signed long int)(1000000 * substract_times$$1$$2$$nsec);
    b.tv_sec = b.tv_sec - (signed long int)substract_times$$1$$2$$nsec;
  }

  result.tv_sec = a.tv_sec - b.tv_sec;
  result.tv_usec = a.tv_usec - b.tv_usec;
  return result;
}

// substract_times_ms
// file basic_stats.h line 31
double substract_times_ms(struct timeval *a, struct timeval *b)
{
  double result = (double)(a->tv_sec - b->tv_sec) * 1000.0 + (double)(a->tv_usec - b->tv_usec) / 1000.0;
  return result;
}

// thread_close
// file thread_resolve.h line 24
void thread_close(void)
{
  stop_threads();
  close_mutex();
}

// thread_lookup
// file thread_resolve.h line 27
const char * thread_lookup(struct anonymous$20 *ip)
{
  const char *ipname;
  signed int is_expired = 0;
  if(ip == ((struct anonymous$20 *)NULL))
    return "";

  else
  {
    pthread_mutex_lock(&resolvemtx);
    ipname=ipcache_getnameip(ip, &is_expired);
    if(!(is_expired == 0))
      sendrequest_inverse(ip);

    pthread_mutex_unlock(&resolvemtx);
    return ipname;
  }
}

// thread_open
// file thread_resolve.h line 21
signed int thread_open(void)
{
  signed int return_value_open_mutex$1;
  return_value_open_mutex$1=open_mutex();
  if(!(return_value_open_mutex$1 == 0))
    return 1;

  else
  {
    ipcache_init();
    start_threads();
    return 0;
  }
}

// thread_pool_routine
// file thread_resolve.c line 95
static void * thread_pool_routine(void *dt)
{
  struct ipcache_item *curitem;
  struct ipresolve_link *el;
  struct hostent resultbuf;
  struct hostent *resultptr;
  char extrabuf[4096l];
  signed int errnovar;
  signed int result;
  signed int tmp_if_expr$1;
  while(request_stop_thread == 0)
  {
    pthread_mutex_lock(&resolvemtx);
    if(resolveListHead == ((struct ipresolve_link *)NULL) && request_stop_thread == 0)
      pthread_cond_wait(&resolvecond, &resolvemtx);

    if(!(request_stop_thread == 0))
    {
      pthread_mutex_unlock(&resolvemtx);
      break;
    }

    if(!(resolveListHead == ((struct ipresolve_link *)NULL)))
    {
      el = resolveListHead;
      resolveListHead = el->next;
      curitem = el->itemToResolve;
      pthread_mutex_unlock(&resolvemtx);
      free((void *)el);
      if(curitem->ip.$anon0.$anon0.type == 2u)
        tmp_if_expr$1 = 32 / 8;

      else
        tmp_if_expr$1 = curitem->ip.$anon0.$anon0.type == (unsigned int)10 ? 128 / 8 : 0;
      result=gethostbyaddr_r((const void *)&curitem->ip.$anon0.$anon0.$anon0.addr8, (unsigned int)tmp_if_expr$1, (signed int)curitem->ip.$anon0.$anon0.type, &resultbuf, extrabuf, sizeof(char [4096l]) /*4096ul*/ , &resultptr, &errnovar);
      if(errnovar == 34 && !(result == 0))
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, "Insufficient memory allocated to gethostbyaddr_r\n");

      if(!(request_stop_thread == 0))
        break;

      pthread_mutex_lock(&resolvemtx);
      if(resultptr == ((struct hostent *)NULL) || !(result == 0))
        ipcache_request_failed(curitem);

      else
        ipcache_request_succeeded(curitem, 3600L * 24L, resultptr->h_name);
    }

    pthread_mutex_unlock(&resolvemtx);
  }
  return (void *)0;
}

// timeout_changed
// file diagram.h line 35
void timeout_changed(void)
{
  g_source_remove((unsigned int)diagram_timeout);
}

// timeval_to_str
// file ui_utils.h line 39
char * timeval_to_str(struct timeval last_heard)
{
  char *str;
  struct timeval diff;
  struct tm broken_time;
  diff=substract_times(appdata.now, last_heard);
  if(!(diff.tv_sec >= 61l))
  {
    char *return_value_dcgettext$1;
    return_value_dcgettext$1=dcgettext((const char *)(void *)0, "%ld\" ago", 5);
    char *return_value_g_strdup_printf$2;
    return_value_g_strdup_printf$2=g_strdup_printf(return_value_dcgettext$1, (signed long int)diff.tv_sec);
    return return_value_g_strdup_printf$2;
  }

  if(!(diff.tv_sec >= 600l))
  {
    char *return_value_dcgettext$3;
    return_value_dcgettext$3=dcgettext((const char *)(void *)0, "%ld'%ld\" ago", 5);
    double return_value_floor$4;
    return_value_floor$4=floor((double)diff.tv_sec / (double)60);
    char *return_value_g_strdup_printf$5;
    return_value_g_strdup_printf$5=g_strdup_printf(return_value_dcgettext$3, (signed long int)return_value_floor$4, (signed long int)diff.tv_sec % (signed long int)60);
    return return_value_g_strdup_printf$5;
  }

  struct tm *return_value_localtime_r$6;
  return_value_localtime_r$6=localtime_r((signed long int *)&last_heard.tv_sec, &broken_time);
  if(return_value_localtime_r$6 == ((struct tm *)NULL))
  {
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, "Time conversion failed in timeval_to_str");
    return (char *)(void *)0;
  }

  else
  {
    if(!(diff.tv_sec >= 86400l))
      str=g_strdup_printf("%d:%d", broken_time.tm_hour, broken_time.tm_min);

    else
    {
      char *return_value_dcgettext$7;
      return_value_dcgettext$7=dcgettext((const char *)(void *)0, "%d/%d %d:%d", 5);
      str=g_strdup_printf(return_value_dcgettext$7, broken_time.tm_mon, broken_time.tm_mday, broken_time.tm_hour, broken_time.tm_min);
    }
    return str;
  }
}

// toggle_protocols_window
// file info_windows.c line 582
void toggle_protocols_window(void)
{
  struct _GtkWidget *protocols_check;
  protocols_check=glade_xml_get_widget(appdata.xml, "protocols_check");
  if(!(protocols_check == ((struct _GtkWidget *)NULL)))
  {
    unsigned long int return_value_gtk_menu_item_get_type$1;
    return_value_gtk_menu_item_get_type$1=gtk_menu_item_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)protocols_check, return_value_gtk_menu_item_get_type$1);
    gtk_menu_item_activate((struct _GtkMenuItem *)return_value_g_type_check_instance_cast$2);
  }

}

// traffic_compare
// file diagram.c line 899
static signed int traffic_compare(const void *a, const void *b)
{
  struct anonymous$19 *node_a;
  struct anonymous$19 *node_b;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(a == NULL))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "diagram.c", 903, (const char *)"traffic_compare", "a != NULL");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int traffic_compare$$1$$2$$1$$_g_boolean_var_;
    if(!(b == NULL))
      traffic_compare$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      traffic_compare$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = traffic_compare$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "diagram.c", 904, (const char *)"traffic_compare", "b != NULL");

  }
  while((_Bool)0);
  node_a = (struct anonymous$19 *)a;
  node_b = (struct anonymous$19 *)b;
  if(node_a->node_stats.stats.average < node_b->node_stats.stats.average)
    return 1;

  else
    if(node_a->node_stats.stats.average > node_b->node_stats.stats.average)
      return -1;

    else
    {
      signed int return_value_node_id_compare$3;
      return_value_node_id_compare$3=node_id_compare(&node_a->node_id, &node_b->node_id);
      return return_value_node_id_compare$3;
    }
}

// traffic_stats_add_packet
// file traffic_stats.h line 38
void traffic_stats_add_packet(struct anonymous$27 *pkt_stat, struct anonymous$6 *new_pkt, enum anonymous$7 dir)
{
  struct anonymous$62 *newit;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(pkt_stat == ((struct anonymous$27 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "traffic_stats.c", 76, (const char *)"traffic_stats_add_packet", "pkt_stat");

  }
  while((_Bool)0);
  signed int tmp_statement_expression$2;
  do
  {
    signed int traffic_stats_add_packet$$1$$2$$1$$_g_boolean_var_;
    if(!(new_pkt == ((struct anonymous$6 *)NULL)))
      traffic_stats_add_packet$$1$$2$$1$$_g_boolean_var_ = 1;

    else
      traffic_stats_add_packet$$1$$2$$1$$_g_boolean_var_ = 0;
    tmp_statement_expression$2 = traffic_stats_add_packet$$1$$2$$1$$_g_boolean_var_;
    if((signed long int)tmp_statement_expression$2 == 0l)
      g_assertion_message_expr((char *)0, "traffic_stats.c", 77, (const char *)"traffic_stats_add_packet", "new_pkt");

  }
  while((_Bool)0);
  newit=packet_list_item_create(new_pkt, dir);
  g_queue_push_head(&pkt_stat->pkt_list, (void *)newit);
  basic_stats_add(&pkt_stat->stats, (double)newit->info->size);
  if(!((signed int)newit->direction == OUTBOUND))
    basic_stats_add(&pkt_stat->stats_in, (double)newit->info->size);

  if(!((signed int)newit->direction == INBOUND))
    basic_stats_add(&pkt_stat->stats_out, (double)newit->info->size);

  protocol_stack_add_pkt(&pkt_stat->stats_protos, newit->info);
}

// traffic_stats_dump
// file traffic_stats.h line 43
char * traffic_stats_dump(const struct anonymous$27 *pkt_stat)
{
  char *msg;
  char *msg_tot;
  char *msg_in;
  char *msg_out;
  char *msg_proto;
  char *return_value_g_strdup$1;
  if(pkt_stat == ((const struct anonymous$27 *)NULL))
  {
    return_value_g_strdup$1=g_strdup("traffic_stats_t NULL");
    return return_value_g_strdup$1;
  }

  else
  {
    msg_tot=basic_stats_dump(&pkt_stat->stats);
    msg_in=basic_stats_dump(&pkt_stat->stats_in);
    msg_out=basic_stats_dump(&pkt_stat->stats_out);
    msg_proto=protocol_stack_dump(&pkt_stat->stats_protos);
    msg=g_strdup_printf("active_packets: %u\n  in : [%s]\n  out: [%s]\n  tot: [%s]\n  protocols:\n  %s", pkt_stat->pkt_list.length, msg_in, msg_out, msg_tot, msg_proto);
    g_free((void *)msg_tot);
    g_free((void *)msg_in);
    g_free((void *)msg_out);
    g_free((void *)msg_proto);
    return msg;
  }
}

// traffic_stats_init
// file traffic_stats.h line 36
void traffic_stats_init(struct anonymous$27 *pkt_stat)
{
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(pkt_stat == ((struct anonymous$27 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "traffic_stats.c", 38, (const char *)"traffic_stats_init", "pkt_stat");

  }
  while((_Bool)0);
  g_queue_init(&pkt_stat->pkt_list);
  basic_stats_reset(&pkt_stat->stats);
  basic_stats_reset(&pkt_stat->stats_in);
  basic_stats_reset(&pkt_stat->stats_out);
  protocol_stack_open(&pkt_stat->stats_protos);
}

// traffic_stats_purge_expired_packets
// file traffic_stats.c line 98
void traffic_stats_purge_expired_packets(struct anonymous$27 *pkt_stat, double pkt_expire_time, double proto_expire_time)
{
  double diffms;
  struct anonymous$62 *packet;
  while(!(pkt_stat->pkt_list.head == ((struct _GList *)NULL)))
  {
    void *return_value_g_queue_peek_tail$1;
    return_value_g_queue_peek_tail$1=g_queue_peek_tail(&pkt_stat->pkt_list);
    packet = (struct anonymous$62 *)return_value_g_queue_peek_tail$1;
    diffms=substract_times_ms(&appdata.now, &packet->info->timestamp);
    if(diffms < pkt_expire_time)
      break;

    basic_stats_sub(&pkt_stat->stats, (double)packet->info->size);
    if(!((signed int)packet->direction == OUTBOUND))
      basic_stats_sub(&pkt_stat->stats_in, (double)packet->info->size);

    if(!((signed int)packet->direction == INBOUND))
      basic_stats_sub(&pkt_stat->stats_out, (double)packet->info->size);

    protocol_stack_sub_pkt(&pkt_stat->stats_protos, packet->info);
    g_queue_pop_tail(&pkt_stat->pkt_list);
    packet_list_item_delete(packet);
  }
  if(pkt_stat->pkt_list.head == ((struct _GList *)NULL))
  {
    pkt_stat->stats.average = (double)0;
    pkt_stat->stats_in.average = (double)0;
    pkt_stat->stats_out.average = (double)0;
  }

  protocol_stack_purge_expired(&pkt_stat->stats_protos, proto_expire_time);
}

// traffic_stats_reset
// file traffic_stats.h line 37
void traffic_stats_reset(struct anonymous$27 *pkt_stat)
{
  void *it;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(pkt_stat == ((struct anonymous$27 *)NULL)))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "traffic_stats.c", 54, (const char *)"traffic_stats_reset", "pkt_stat");

  }
  while((_Bool)0);
  do
  {
    it=g_queue_pop_head(&pkt_stat->pkt_list);
    if(it == NULL)
      break;

    packet_list_item_delete((struct anonymous$62 *)it);
  }
  while((_Bool)1);
  protocol_stack_reset(&pkt_stat->stats_protos);
  basic_stats_reset(&pkt_stat->stats);
  basic_stats_reset(&pkt_stat->stats_in);
  basic_stats_reset(&pkt_stat->stats_out);
}

// traffic_stats_update
// file traffic_stats.h line 42
signed int traffic_stats_update(struct anonymous$27 *pkt_stat, double avg_time, double proto_expire_time)
{
  traffic_stats_purge_expired_packets(pkt_stat, avg_time, proto_expire_time);
  signed int return_value_g_queue_is_empty$1;
  return_value_g_queue_is_empty$1=g_queue_is_empty(&pkt_stat->pkt_list);
  if(return_value_g_queue_is_empty$1 == 0)
  {
    double ms_from_oldest = avg_time;
    basic_stats_avg(&pkt_stat->stats, ms_from_oldest);
    basic_stats_avg(&pkt_stat->stats_in, ms_from_oldest);
    basic_stats_avg(&pkt_stat->stats_out, ms_from_oldest);
    protocol_stack_avg(&pkt_stat->stats_protos, ms_from_oldest);
    return (signed int)!(0 != 0);
  }

  return 0;
}

// traffic_stats_xml
// file traffic_stats.h line 44
char * traffic_stats_xml(const struct anonymous$27 *pkt_stat)
{
  char *msg;
  char *msg_tot;
  char *msg_in;
  char *msg_out;
  char *msg_proto;
  char *return_value_xmltag$1;
  if(pkt_stat == ((const struct anonymous$27 *)NULL))
  {
    return_value_xmltag$1=xmltag("traffic_stats", "");
    return return_value_xmltag$1;
  }

  else
  {
    msg_tot=basic_stats_xml(&pkt_stat->stats);
    msg_in=basic_stats_xml(&pkt_stat->stats_in);
    msg_out=basic_stats_xml(&pkt_stat->stats_out);
    msg_proto=protocol_stack_xml(&pkt_stat->stats_protos);
    msg=xmltag("traffic_stats", "\n<active_packets>%u</active_packets>\n<in>\n%s</in>\n<out>\n%s</out>\n<tot>\n%s</tot>\n%s", pkt_stat->pkt_list.length, msg_in, msg_out, msg_tot, msg_proto);
    g_free((void *)msg_tot);
    g_free((void *)msg_in);
    g_free((void *)msg_out);
    g_free((void *)msg_proto);
    return msg;
  }
}

// traffic_to_str
// file ui_utils.h line 42
char * traffic_to_str(double traffic, signed int is_speed)
{
  char *str;
  if(!(is_speed == 0))
  {
    if(traffic > 1000000000.0)
      str=g_strdup_printf("%.2f Gbps", traffic / 1000000000.0);

    else
      if(traffic > 1.000000e+6)
        str=g_strdup_printf("%.2f Mbps", traffic / (double)1000000);

      else
        if(traffic > 1000.000000)
          str=g_strdup_printf("%.2f Kbps", traffic / (double)1000);

        else
          str=g_strdup_printf("%.0f bps", traffic);
  }

  else
  {
    if(traffic < 1.000000 && IEEE_FLOAT_NOTEQUAL(traffic, 0.000000))
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, "Ill traffic value in traffic_to_str");

    if(traffic > 1.073742e+9)
      str=g_strdup_printf("%.2f Gbytes", traffic / (1024.0 * 1024.0 * 1024.0));

    else
      if(traffic > 1.048576e+6)
        str=g_strdup_printf("%.2f Mbytes", (traffic / (double)1024) / (double)1024);

      else
        if(traffic > 1024.000000)
          str=g_strdup_printf("%.2f Kbytes", traffic / (double)1024);

        else
          str=g_strdup_printf("%.0f bytes", traffic);
  }
  return str;
}

// type_to_str
// file util.c line 382
const char * type_to_str(const struct anonymous$20 *ad)
{
  if(ad == ((const struct anonymous$20 *)NULL))
    return "<null addr>";

  else
    switch(ad->$anon0.$anon0.type)
    {
      case (unsigned int)2:
        return "IP";
      case (unsigned int)10:
        return "IPv6";
      default:
        return "<invalid address family>";
    }
}

// update_diagram
// file diagram.h line 27
unsigned int update_diagram(struct _GtkWidget *canvas)
{
  double diffms;
  enum status_t status;
  if(!(appdata.export_file_signal == ((char *)NULL)) && !(appdata.request_dump == 0))
  {
    char *return_value_dcgettext$1;
    return_value_dcgettext$1=dcgettext((const char *)(void *)0, "SIGUSR1 received: exporting to %s", 5);
    g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_WARNING, return_value_dcgettext$1, appdata.export_file_signal);
    dump_xml(appdata.export_file_signal);
    appdata.request_dump = 0;
  }

  status=get_capture_status();
  signed int return_value_gtk_events_pending$2;
  if((signed int)status == PAUSE)
    return (unsigned int)0;

  else
    if((signed int)status == CAP_EOF)
    {
      gui_eof_capture();
      return (unsigned int)0;
    }

    else
      if(!(already_updating == 0))
      {
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, "update_diagram called while already updating");
        return (unsigned int)0;
      }

      else
      {
        already_updating = (signed int)!(0 != 0);
        gettimeofday(&appdata.now, (struct timezone *)(void *)0);
        diagram_update_nodes(canvas);
        diagram_update_links(canvas);
        protocol_summary_update_all();
        update_legend();
        update_info_windows();
        static struct timeval last_refresh_time = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
        if(last_refresh_time.tv_sec == 0l && last_refresh_time.tv_usec == 0l)
          last_refresh_time = appdata.now;

        do
        {
          return_value_gtk_events_pending$2=gtk_events_pending();
          if(return_value_gtk_events_pending$2 == 0)
            break;

          gtk_main_iteration();
        }
        while((_Bool)1);
        gettimeofday(&appdata.now, (struct timezone *)(void *)0);
        diffms=substract_times_ms(&appdata.now, &last_refresh_time);
        last_refresh_time = appdata.now;
        already_updating = 0;
        if(is_idle == 0)
        {
          if(diffms > (double)pref.refresh_period * 1.2)
            return (unsigned int)0;

        }

        else
          if(diffms < (double)pref.refresh_period)
            return (unsigned int)0;

        if(!(stop_requested == 0))
          gui_stop_capture();

        return (unsigned int)!(0 != 0);
      }
}

// update_gtklabel
// file ui_utils.h line 48
void update_gtklabel(struct _GtkWidget *window, const char *lblname, const char *value)
{
  struct _GtkLabel *lbl;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$2;
  return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, lblname);
  unsigned long int return_value_gtk_label_get_type$3;
  return_value_gtk_label_get_type$3=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_g_object_get_data$2, return_value_gtk_label_get_type$3);
  lbl = (struct _GtkLabel *)return_value_g_type_check_instance_cast$4;
  signed int start;
  signed int end;
  signed int sel;
  sel=gtk_label_get_selection_bounds(lbl, &start, &end);
  gtk_label_set_text(lbl, value);
  if(!(sel == 0))
    gtk_label_select_region(lbl, start, end);

}

// update_info_windows
// file info_windows.h line 26
unsigned int update_info_windows(void)
{
  enum status_t status;
  status=get_capture_status();
  if(!((signed int)status == STOP) && !((signed int)status == PLAY))
    return (unsigned int)!(0 != 0);

  else
  {
    gettimeofday(&appdata.now, (struct timezone *)(void *)0);
    update_protocols_window();
    update_stats_info_windows();
    update_prot_info_windows();
    nodes_wnd_update();
    return (unsigned int)!(0 != 0);
  }
}

// update_legend
// file diagram.c line 500
static void update_legend(void)
{
  struct _GtkWidget *prot_table;
  prot_table=glade_xml_get_widget(appdata.xml, "prot_table");
  if(!(prot_table == ((struct _GtkWidget *)NULL)))
  {
    unsigned long int return_value_gtk_container_get_type$1;
    return_value_gtk_container_get_type$1=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)prot_table, return_value_gtk_container_get_type$1);
    gtk_container_foreach((struct _GtkContainer *)return_value_g_type_check_instance_cast$2, (void (*)(struct _GtkWidget *, void *))purge_expired_legend_protocol, (void *)0);
    const struct anonymous$25 *return_value_protocol_summary_stack$3;
    return_value_protocol_summary_stack$3=protocol_summary_stack();
    check_new_protocol(prot_table, return_value_protocol_summary_stack$3);
  }

}

// update_link
// file links.c line 175
static signed int update_link(struct anonymous$16 *link_id, struct anonymous$28 *link, void *delete_list_ptr)
{
  double diffms;
  signed int tmp_statement_expression$1;
  do
  {
    signed int _g_boolean_var_;
    if(!(delete_list_ptr == NULL))
      _g_boolean_var_ = 1;

    else
      _g_boolean_var_ = 0;
    tmp_statement_expression$1 = _g_boolean_var_;
    if((signed long int)tmp_statement_expression$1 == 0l)
      g_assertion_message_expr((char *)0, "links.c", 179, (const char *)"update_link", "delete_list_ptr");

  }
  while((_Bool)0);
  signed int return_value_traffic_stats_update$3;
  return_value_traffic_stats_update$3=traffic_stats_update(&link->link_stats, pref.averaging_time, pref.proto_link_timeout_time);
  if(!(return_value_traffic_stats_update$3 == 0))
  {
    unsigned int i = (unsigned int)5;
    for( ; !(i == 4294967295u); i = i - 1u)
    {
      if(!(link->main_prot[(signed long int)i] == ((char *)NULL)))
        g_free((void *)link->main_prot[(signed long int)i]);

      link->main_prot[(signed long int)i]=protocol_stack_sort_most_used(&link->link_stats.stats_protos, (unsigned long int)i);
    }
  }

  else
    if(IEEE_FLOAT_NOTEQUAL(pref.link_timeout_time, 0.000000))
    {
      diffms=substract_times_ms(&appdata.now, &link->link_stats.stats.last_time);
      if(diffms >= pref.link_timeout_time)
      {
        struct _GList **delete_list = (struct _GList **)delete_list_ptr;
        *delete_list=g_list_prepend(*delete_list, (void *)link_id);
        char *return_value_dcgettext$2;
        return_value_dcgettext$2=dcgettext((const char *)(void *)0, "Queuing link for remove", 5);
        g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_DEBUG, return_value_dcgettext$2);
      }

    }

  return 0;
}

// update_link_info_window
// file info_windows.c line 972
static void update_link_info_window(struct _GtkWidget *window)
{
  const struct anonymous$16 *link_id;
  const struct anonymous$28 *link;
  const struct anonymous$19 *node;
  char *linkname;
  show_widget(window, "src_label");
  show_widget(window, "dst_label");
  char *return_value_dcgettext$1;
  return_value_dcgettext$1=dcgettext((const char *)(void *)0, "B->A", 5);
  update_gtklabel(window, "inbound_label", return_value_dcgettext$1);
  char *return_value_dcgettext$2;
  return_value_dcgettext$2=dcgettext((const char *)(void *)0, "A->B", 5);
  update_gtklabel(window, "outbound_label", return_value_dcgettext$2);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$4;
  return_value_g_object_get_data$4=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$3, "link_id");
  link_id = (const struct anonymous$16 *)return_value_g_object_get_data$4;
  link=links_catalog_find(link_id);
  if(link == ((const struct anonymous$28 *)NULL))
  {
    char *return_value_dcgettext$5;
    return_value_dcgettext$5=dcgettext((const char *)(void *)0, "Link timed out", 5);
    update_gtklabel(window, "node_iproto_numeric_name", return_value_dcgettext$5);
    update_gtklabel(window, "node_iproto_numeric_name_b", "");
    stats_info_update(window, (const struct anonymous$27 *)(void *)0);
    goto __CPROVER_DUMP_L6;
  }

  linkname=link_id_node_names(link_id);
  unsigned long int return_value_gtk_window_get_type$6;
  return_value_gtk_window_get_type$6=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_window_get_type$6);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$7, linkname);
  g_free((void *)linkname);
  node=nodes_catalog_find(&link_id->src);
  if(!(node == ((const struct anonymous$19 *)NULL)))
  {
    update_gtklabel(window, "node_iproto_name", node->name->str);
    update_gtklabel(window, "node_iproto_numeric_name", node->numeric_name->str);
  }

  else
  {
    char *return_value_dcgettext$8;
    return_value_dcgettext$8=dcgettext((const char *)(void *)0, "Node timed out", 5);
    update_gtklabel(window, "node_iproto_name", return_value_dcgettext$8);
    char *return_value_dcgettext$9;
    return_value_dcgettext$9=dcgettext((const char *)(void *)0, "Node timed out", 5);
    update_gtklabel(window, "node_iproto_numeric_name", return_value_dcgettext$9);
  }
  node=nodes_catalog_find(&link_id->dst);
  if(!(node == ((const struct anonymous$19 *)NULL)))
  {
    update_gtklabel(window, "node_iproto_name_b", node->name->str);
    update_gtklabel(window, "node_iproto_numeric_name_b", node->numeric_name->str);
  }

  else
  {
    char *return_value_dcgettext$10;
    return_value_dcgettext$10=dcgettext((const char *)(void *)0, "Node timed out", 5);
    update_gtklabel(window, "node_iproto_name_b", return_value_dcgettext$10);
    char *return_value_dcgettext$11;
    return_value_dcgettext$11=dcgettext((const char *)(void *)0, "Node timed out", 5);
    update_gtklabel(window, "node_iproto_numeric_name_b", return_value_dcgettext$11);
  }
  stats_info_update(window, &link->link_stats);

__CPROVER_DUMP_L6:
  ;
}

// update_node_protocols_window
// file info_windows.c line 908
static void update_node_protocols_window(struct _GtkWidget *window)
{
  const struct anonymous$5 *node_id;
  const struct anonymous$19 *node;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
  void *return_value_g_object_get_data$2;
  return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "node_id");
  node_id = (const struct anonymous$5 *)return_value_g_object_get_data$2;
  node=nodes_catalog_find(node_id);
  if(node == ((const struct anonymous$19 *)NULL))
  {
    char *return_value_dcgettext$3;
    return_value_dcgettext$3=dcgettext((const char *)(void *)0, "Node timed out", 5);
    update_gtklabel(window, "node_iproto_numeric_name", return_value_dcgettext$3);
    stats_info_update(window, (const struct anonymous$27 *)(void *)0);
    goto __CPROVER_DUMP_L2;
  }

  unsigned long int return_value_gtk_window_get_type$4;
  return_value_gtk_window_get_type$4=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_window_get_type$4);
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, node->name->str);
  update_gtklabel(window, "node_iproto_name", node->name->str);
  update_gtklabel(window, "node_iproto_numeric_name", node->numeric_name->str);
  stats_info_update(window, &node->node_stats);

__CPROVER_DUMP_L2:
  ;
}

// update_prot_info_window
// file info_windows.c line 186
static void update_prot_info_window(struct anonymous$29 *prot_info_window)
{
  const struct anonymous$26 *prot;
  struct _GtkWidget *window;
  struct _GtkWidget *widget;
  char *str;
  window = prot_info_window->window;
  if(!(window == ((struct _GtkWidget *)NULL)))
  {
    prot=protocol_summary_find((unsigned long int)pref.stack_level, prot_info_window->prot_name);
    if(prot == ((const struct anonymous$26 *)NULL))
    {
      struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
      return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
      void *return_value_g_object_get_data$2;
      return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "average");
      widget = (struct _GtkWidget *)return_value_g_object_get_data$2;
      unsigned long int return_value_gtk_label_get_type$3;
      return_value_gtk_label_get_type$3=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_label_get_type$3);
      gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, "X");
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
      void *return_value_g_object_get_data$6;
      return_value_g_object_get_data$6=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$5, "accumulated");
      widget = (struct _GtkWidget *)return_value_g_object_get_data$6;
      unsigned long int return_value_gtk_label_get_type$7;
      return_value_gtk_label_get_type$7=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_label_get_type$7);
      gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$8, "X");
      unsigned long int return_value_gtk_widget_get_type$9;
      return_value_gtk_widget_get_type$9=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
      return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)prot_info_window->window, return_value_gtk_widget_get_type$9);
      gtk_widget_queue_resize((struct _GtkWidget *)return_value_g_type_check_instance_cast$10);
      goto __CPROVER_DUMP_L3;
    }

    unsigned long int return_value_gtk_window_get_type$11;
    return_value_gtk_window_get_type$11=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_window_get_type$11);
    gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$12, prot_info_window->prot_name);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    void *return_value_g_object_get_data$14;
    return_value_g_object_get_data$14=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$13, "name_label");
    widget = (struct _GtkWidget *)return_value_g_object_get_data$14;
    unsigned long int return_value_gtk_label_get_type$15;
    return_value_gtk_label_get_type$15=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_label_get_type$15);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$16, prot_info_window->prot_name);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
    return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    void *return_value_g_object_get_data$18;
    return_value_g_object_get_data$18=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$17, "last_heard_label");
    widget = (struct _GtkWidget *)return_value_g_object_get_data$18;
    str=timeval_to_str(prot->stats.last_time);
    unsigned long int return_value_gtk_label_get_type$19;
    return_value_gtk_label_get_type$19=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
    return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_label_get_type$19);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$20, str);
    g_free((void *)str);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
    return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    void *return_value_g_object_get_data$22;
    return_value_g_object_get_data$22=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$21, "average");
    widget = (struct _GtkWidget *)return_value_g_object_get_data$22;
    str=traffic_to_str(prot->stats.average, (signed int)!(0 != 0));
    unsigned long int return_value_gtk_label_get_type$23;
    return_value_gtk_label_get_type$23=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
    return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_label_get_type$23);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$24, str);
    g_free((void *)str);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
    return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
    void *return_value_g_object_get_data$26;
    return_value_g_object_get_data$26=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$25, "accumulated");
    widget = (struct _GtkWidget *)return_value_g_object_get_data$26;
    str=traffic_to_str(prot->stats.accumulated, 0);
    unsigned long int return_value_gtk_label_get_type$27;
    return_value_gtk_label_get_type$27=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
    return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_label_get_type$27);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$28, str);
    g_free((void *)str);
    unsigned long int return_value_gtk_widget_get_type$29;
    return_value_gtk_widget_get_type$29=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
    return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)prot_info_window->window, return_value_gtk_widget_get_type$29);
    gtk_widget_queue_resize((struct _GtkWidget *)return_value_g_type_check_instance_cast$30);
  }


__CPROVER_DUMP_L3:
  ;
}

// update_prot_info_windows
// file info_windows.c line 230
static void update_prot_info_windows(void)
{
  struct _GList *list_item = (struct _GList *)(void *)0;
  struct _GList *remove_item;
  struct anonymous$29 *prot_info_window = (struct anonymous$29 *)(void *)0;
  enum status_t status;
  status=get_capture_status();
  list_item = prot_info_windows;
  while(!(list_item == ((struct _GList *)NULL)))
  {
    prot_info_window = (struct anonymous$29 *)list_item->data;
    if((signed int)status == STOP)
    {
      g_free((void *)prot_info_window->prot_name);
      unsigned long int return_value_gtk_widget_get_type$1;
      return_value_gtk_widget_get_type$1=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)prot_info_window->window, return_value_gtk_widget_get_type$1);
      gtk_widget_destroy((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
      remove_item = list_item;
      list_item = list_item->next;
      prot_info_windows=g_list_remove_link(prot_info_windows, remove_item);
    }

    else
    {
      update_prot_info_window(prot_info_window);
      list_item = list_item->next;
    }
  }
}

// update_protocols_row
// file info_windows.c line 435
static void update_protocols_row(struct _GtkListStore *gs, struct _GtkTreeIter *it, const struct protocol_list_item_t_tag *row_proto)
{
  char *ga;
  char *gb;
  char *gc;
  char *gd;
  char *ge;
  char *gf;
  const struct anonymous$21 *ps;
  ga=traffic_to_str(row_proto->rowstats.accumulated, 0);
  gb=g_strdup_printf("%lu", row_proto->rowstats.accu_packets);
  ps=services_port_find(row_proto->name);
  if(!(ps == ((const struct anonymous$21 *)NULL)))
    gc=g_strdup_printf("%d", ps->port);

  else
    gc=g_strdup("-");
  gd=traffic_to_str(row_proto->rowstats.average, (signed int)!(0 != 0));
  ge=timeval_to_str(row_proto->rowstats.last_time);
  gf=traffic_to_str(row_proto->rowstats.avg_size, 0);
  gtk_list_store_set(gs, it, 4, ga, 7, gb, 2, gc, 3, gd, 6, ge, 5, gf, -1);
  g_free((void *)ga);
  g_free((void *)gb);
  g_free((void *)gc);
  g_free((void *)gd);
  g_free((void *)ge);
  g_free((void *)gf);
}

// update_protocols_table
// file info_windows.c line 469
static void update_protocols_table(struct _GtkWidget *window, const struct anonymous$25 *pstk)
{
  struct _GtkListStore *gs;
  struct _GList *item;
  signed int res;
  struct _GtkTreeIter it;
  gs=create_protocols_table(window);
  unsigned long int return_value_gtk_tree_model_get_type$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  signed int tmp_statement_expression$6;
  signed int tmp_statement_expression$7;
  unsigned long int return_value_gtk_tree_model_get_type$9;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  if(!(gs == ((struct _GtkListStore *)NULL)))
  {
    if(!(pstk == ((const struct anonymous$25 *)NULL)))
      item = pstk->protostack[(signed long int)pref.stack_level];

    else
      item = (struct _GList *)(void *)0;
    unsigned long int return_value_gtk_tree_model_get_type$1;
    return_value_gtk_tree_model_get_type$1=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)gs, return_value_gtk_tree_model_get_type$1);
    res=gtk_tree_model_get_iter_first((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$2, &it);
    while(!(item == ((struct _GList *)NULL)) || !(res == 0))
    {
      const struct anonymous$26 *stack_proto = (const struct anonymous$26 *)(void *)0;
      struct protocol_list_item_t_tag *row_proto = (struct protocol_list_item_t_tag *)(void *)0;
      if(!(res == 0))
      {
        return_value_gtk_tree_model_get_type$3=gtk_tree_model_get_type();
        return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)gs, return_value_gtk_tree_model_get_type$3);
        gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$4, &it, 8, &row_proto, -1);
      }

      if(item == ((struct _GList *)NULL))
      {
        if(!(res == 0))
        {
          g_free((void *)row_proto->name);
          g_free((void *)row_proto);
          res=gtk_list_store_remove(gs, &it);
        }

      }

      else
      {
        stack_proto = (const struct anonymous$26 *)item->data;
        if(res == 0)
        {
          void *return_value_g_malloc$5;
          return_value_g_malloc$5=g_malloc(sizeof(struct protocol_list_item_t_tag) /*80ul*/ );
          row_proto = (struct protocol_list_item_t_tag *)return_value_g_malloc$5;
          do
          {
            signed int _g_boolean_var_;
            if(!(row_proto == ((struct protocol_list_item_t_tag *)NULL)))
              _g_boolean_var_ = 1;

            else
              _g_boolean_var_ = 0;
            tmp_statement_expression$6 = _g_boolean_var_;
            if((signed long int)tmp_statement_expression$6 == 0l)
              g_assertion_message_expr((char *)0, "info_windows.c", 515, (const char *)"update_protocols_table", "row_proto");

          }
          while((_Bool)0);
          row_proto->name=g_strdup(stack_proto->name);
          row_proto->color=protohash_color(stack_proto->name);
          gtk_list_store_append(gs, &it);
          gtk_list_store_set(gs, &it, 1, row_proto->name, 0, &row_proto->color, 8, row_proto, -1);
        }

        else
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp$8;
          return_value___builtin_strcmp$8=__builtin_strcmp(row_proto->name, stack_proto->name);
          tmp_statement_expression$7 = return_value___builtin_strcmp$8;
          if(!(tmp_statement_expression$7 == 0))
          {
            g_free((void *)row_proto->name);
            g_free((void *)row_proto);
            res=gtk_list_store_remove(gs, &it);
            continue;
          }

        }
        row_proto->rowstats = stack_proto->stats;
        update_protocols_row(gs, &it, row_proto);
        if(!(res == 0))
        {
          return_value_gtk_tree_model_get_type$9=gtk_tree_model_get_type();
          return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)gs, return_value_gtk_tree_model_get_type$9);
          res=gtk_tree_model_iter_next((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$10, &it);
        }

        item = item->next;
      }
    }
  }

}

// update_protocols_window
// file info_windows.c line 559
static void update_protocols_window(void)
{
  struct _GtkWidget *window;
  struct _GtkTreeView *gv;
  window=glade_xml_get_widget(appdata.xml, "protocols_window");
  gv=retrieve_treeview(window);
  if(gv == ((struct _GtkTreeView *)NULL))
  {
    struct _GtkWidget *return_value_glade_xml_get_widget$1;
    return_value_glade_xml_get_widget$1=glade_xml_get_widget(appdata.xml, "prot_clist");
    unsigned long int return_value_gtk_tree_view_get_type$2;
    return_value_gtk_tree_view_get_type$2=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$1, return_value_gtk_tree_view_get_type$2);
    gv = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$3;
    if(gv == ((struct _GtkTreeView *)NULL))
    {
      g_log((char *)0, (enum anonymous$30)G_LOG_LEVEL_CRITICAL, "can't find prot_clist");
      goto __CPROVER_DUMP_L3;
    }

    register_treeview(window, gv);
  }

  const struct anonymous$25 *return_value_protocol_summary_stack$4;
  return_value_protocol_summary_stack$4=protocol_summary_stack();
  update_protocols_table(window, return_value_protocol_summary_stack$4);

__CPROVER_DUMP_L3:
  ;
}

// update_stats_info_windows
// file info_windows.c line 716
static void update_stats_info_windows(void)
{
  struct _GList *list_item;
  struct _GtkWidget *window;
  enum status_t status;
  double diffms;
  status=get_capture_status();
  static struct timeval last_update_time = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
  diffms=substract_times_ms(&appdata.now, &last_update_time);
  if(!(pref.refresh_period >= 500u))
  {
    if(!(diffms < 500.000000))
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    list_item = stats_info_windows;
    while(!(list_item == ((struct _GList *)NULL)))
    {
      window = (struct _GtkWidget *)list_item->data;
      if((signed int)status == STOP)
      {
        struct _GList *remove_item = list_item;
        list_item = list_item->next;
        stats_info_windows=g_list_delete_link(stats_info_windows, remove_item);
        struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
        return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
        void *return_value_g_object_get_data$2;
        return_value_g_object_get_data$2=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$1, "node_id");
        g_free(return_value_g_object_get_data$2);
        struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
        return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
        void *return_value_g_object_get_data$4;
        return_value_g_object_get_data$4=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$3, "link_id");
        g_free(return_value_g_object_get_data$4);
        unsigned long int return_value_gtk_widget_get_type$5;
        return_value_gtk_widget_get_type$5=gtk_widget_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
        return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_widget_get_type$5);
        gtk_widget_destroy((struct _GtkWidget *)return_value_g_type_check_instance_cast$6);
      }

      else
      {
        struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
        return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)window, (unsigned long int)(20 << 2));
        void *return_value_g_object_get_data$8;
        return_value_g_object_get_data$8=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$7, "node_id");
        if(!(return_value_g_object_get_data$8 == NULL))
          update_node_protocols_window(window);

        else
          update_link_info_window(window);
        list_item = list_item->next;
      }
    }
    last_update_time = appdata.now;
  }
}

// xmltag
// file util.c line 404
char * xmltag(const char *name, const char *fmt, ...)
{
  char *msg;
  char *xml;
  void **ap = (void **)&fmt;
  msg=g_strdup_vprintf(fmt, ap);
  ap = ((void **)NULL);
  xml=g_strdup_printf("<%s>%s</%s>\n", name, msg, name);
  g_free((void *)msg);
  return xml;
}

