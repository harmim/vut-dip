// #anon_enum$CONSPEC_UNKNOWN=0$CONSPEC_DECIMAL=1$CONSPEC_OCTAL=2$CONSPEC_UNSIGNED=3$CONSPEC_HEX=4$CONSPEC_HEX_UP=5$CONSPEC_FLOAT=6$CONSPEC_FLOAT_UP=7$CONSPEC_EXP=8$CONSPEC_EXP_UP=9$CONSPEC_F_OR_G=10$CONSPEC_F_OR_G_UP=11$CONSPEC_HEX_EXP=12$CONSPEC_HEX_EXP_UP=13$CONSPEC_CHAR=14$CONSPEC_STRING=15$CONSPEC_POINTER=16$CONSPEC_STRERROR=17$CONSPEC_BYTES_SO_FAR=18
// file ../../src/estream-printf.c line 169
enum anonymous$12 { CONSPEC_UNKNOWN=0, CONSPEC_DECIMAL=1, CONSPEC_OCTAL=2, CONSPEC_UNSIGNED=3, CONSPEC_HEX=4, CONSPEC_HEX_UP=5, CONSPEC_FLOAT=6, CONSPEC_FLOAT_UP=7, CONSPEC_EXP=8, CONSPEC_EXP_UP=9, CONSPEC_F_OR_G=10, CONSPEC_F_OR_G_UP=11, CONSPEC_HEX_EXP=12, CONSPEC_HEX_EXP_UP=13, CONSPEC_CHAR=14, CONSPEC_STRING=15, CONSPEC_POINTER=16, CONSPEC_STRERROR=17, CONSPEC_BYTES_SO_FAR=18 };

// #anon_enum$GPG_ERR_NO_ERROR=0$GPG_ERR_GENERAL=1$GPG_ERR_UNKNOWN_PACKET=2$GPG_ERR_UNKNOWN_VERSION=3$GPG_ERR_PUBKEY_ALGO=4$GPG_ERR_DIGEST_ALGO=5$GPG_ERR_BAD_PUBKEY=6$GPG_ERR_BAD_SECKEY=7$GPG_ERR_BAD_SIGNATURE=8$GPG_ERR_NO_PUBKEY=9$GPG_ERR_CHECKSUM=10$GPG_ERR_BAD_PASSPHRASE=11$GPG_ERR_CIPHER_ALGO=12$GPG_ERR_KEYRING_OPEN=13$GPG_ERR_INV_PACKET=14$GPG_ERR_INV_ARMOR=15$GPG_ERR_NO_USER_ID=16$GPG_ERR_NO_SECKEY=17$GPG_ERR_WRONG_SECKEY=18$GPG_ERR_BAD_KEY=19$GPG_ERR_COMPR_ALGO=20$GPG_ERR_NO_PRIME=21$GPG_ERR_NO_ENCODING_METHOD=22$GPG_ERR_NO_ENCRYPTION_SCHEME=23$GPG_ERR_NO_SIGNATURE_SCHEME=24$GPG_ERR_INV_ATTR=25$GPG_ERR_NO_VALUE=26$GPG_ERR_NOT_FOUND=27$GPG_ERR_VALUE_NOT_FOUND=28$GPG_ERR_SYNTAX=29$GPG_ERR_BAD_MPI=30$GPG_ERR_INV_PASSPHRASE=31$GPG_ERR_SIG_CLASS=32$GPG_ERR_RESOURCE_LIMIT=33$GPG_ERR_INV_KEYRING=34$GPG_ERR_TRUSTDB=35$GPG_ERR_BAD_CERT=36$GPG_ERR_INV_USER_ID=37$GPG_ERR_UNEXPECTED=38$GPG_ERR_TIME_CONFLICT=39$GPG_ERR_KEYSERVER=40$GPG_ERR_WRONG_PUBKEY_ALGO=41$GPG_ERR_TRIBUTE_TO_D_A=42$GPG_ERR_WEAK_KEY=43$GPG_ERR_INV_KEYLEN=44$GPG_ERR_INV_ARG=45$GPG_ERR_BAD_URI=46$GPG_ERR_INV_URI=47$GPG_ERR_NETWORK=48$GPG_ERR_UNKNOWN_HOST=49$GPG_ERR_SELFTEST_FAILED=50$GPG_ERR_NOT_ENCRYPTED=51$GPG_ERR_NOT_PROCESSED=52$GPG_ERR_UNUSABLE_PUBKEY=53$GPG_ERR_UNUSABLE_SECKEY=54$GPG_ERR_INV_VALUE=55$GPG_ERR_BAD_CERT_CHAIN=56$GPG_ERR_MISSING_CERT=57$GPG_ERR_NO_DATA=58$GPG_ERR_BUG=59$GPG_ERR_NOT_SUPPORTED=60$GPG_ERR_INV_OP=61$GPG_ERR_TIMEOUT=62$GPG_ERR_INTERNAL=63$GPG_ERR_EOF_GCRYPT=64$GPG_ERR_INV_OBJ=65$GPG_ERR_TOO_SHORT=66$GPG_ERR_TOO_LARGE=67$GPG_ERR_NO_OBJ=68$GPG_ERR_NOT_IMPLEMENTED=69$GPG_ERR_CONFLICT=70$GPG_ERR_INV_CIPHER_MODE=71$GPG_ERR_INV_FLAG=72$GPG_ERR_INV_HANDLE=73$GPG_ERR_TRUNCATED=74$GPG_ERR_INCOMPLETE_LINE=75$GPG_ERR_INV_RESPONSE=76$GPG_ERR_NO_AGENT=77$GPG_ERR_AGENT=78$GPG_ERR_INV_DATA=79$GPG_ERR_ASSUAN_SERVER_FAULT=80$GPG_ERR_ASSUAN=81$GPG_ERR_INV_SESSION_KEY=82$GPG_ERR_INV_SEXP=83$GPG_ERR_UNSUPPORTED_ALGORITHM=84$GPG_ERR_NO_PIN_ENTRY=85$GPG_ERR_PIN_ENTRY=86$GPG_ERR_BAD_PIN=87$GPG_ERR_INV_NAME=88$GPG_ERR_BAD_DATA=89$GPG_ERR_INV_PARAMETER=90$GPG_ERR_WRONG_CARD=91$GPG_ERR_NO_DIRMNGR=92$GPG_ERR_DIRMNGR=93$GPG_ERR_CERT_REVOKED=94$GPG_ERR_NO_CRL_KNOWN=95$GPG_ERR_CRL_TOO_OLD=96$GPG_ERR_LINE_TOO_LONG=97$GPG_ERR_NOT_TRUSTED=98$GPG_ERR_CANCELED=99$GPG_ERR_BAD_CA_CERT=100$GPG_ERR_CERT_EXPIRED=101$GPG_ERR_CERT_TOO_YOUNG=102$GPG_ERR_UNSUPPORTED_CERT=103$GPG_ERR_UNKNOWN_SEXP=104$GPG_ERR_UNSUPPORTED_PROTECTION=105$GPG_ERR_CORRUPTED_PROTECTION=106$GPG_ERR_AMBIGUOUS_NAME=107$GPG_ERR_CARD=108$GPG_ERR_CARD_RESET=109$GPG_ERR_CARD_REMOVED=110$GPG_ERR_INV_CARD=111$GPG_ERR_CARD_NOT_PRESENT=112$GPG_ERR_NO_PKCS15_APP=113$GPG_ERR_NOT_CONFIRMED=114$GPG_ERR_CONFIGURATION=115$GPG_ERR_NO_POLICY_MATCH=116$GPG_ERR_INV_INDEX=117$GPG_ERR_INV_ID=118$GPG_ERR_NO_SCDAEMON=119$GPG_ERR_SCDAEMON=120$GPG_ERR_UNSUPPORTED_PROTOCOL=121$GPG_ERR_BAD_PIN_METHOD=122$GPG_ERR_CARD_NOT_INITIALIZED=123$GPG_ERR_UNSUPPORTED_OPERATION=124$GPG_ERR_WRONG_KEY_USAGE=125$GPG_ERR_NOTHING_FOUND=126$GPG_ERR_WRONG_BLOB_TYPE=127$GPG_ERR_MISSING_VALUE=128$GPG_ERR_HARDWARE=129$GPG_ERR_PIN_BLOCKED=130$GPG_ERR_USE_CONDITIONS=131$GPG_ERR_PIN_NOT_SYNCED=132$GPG_ERR_INV_CRL=133$GPG_ERR_BAD_BER=134$GPG_ERR_INV_BER=135$GPG_ERR_ELEMENT_NOT_FOUND=136$GPG_ERR_IDENTIFIER_NOT_FOUND=137$GPG_ERR_INV_TAG=138$GPG_ERR_INV_LENGTH=139$GPG_ERR_INV_KEYINFO=140$GPG_ERR_UNEXPECTED_TAG=141$GPG_ERR_NOT_DER_ENCODED=142$GPG_ERR_NO_CMS_OBJ=143$GPG_ERR_INV_CMS_OBJ=144$GPG_ERR_UNKNOWN_CMS_OBJ=145$GPG_ERR_UNSUPPORTED_CMS_OBJ=146$GPG_ERR_UNSUPPORTED_ENCODING=147$GPG_ERR_UNSUPPORTED_CMS_VERSION=148$GPG_ERR_UNKNOWN_ALGORITHM=149$GPG_ERR_INV_ENGINE=150$GPG_ERR_PUBKEY_NOT_TRUSTED=151$GPG_ERR_DECRYPT_FAILED=152$GPG_ERR_KEY_EXPIRED=153$GPG_ERR_SIG_EXPIRED=154$GPG_ERR_ENCODING_PROBLEM=155$GPG_ERR_INV_STATE=156$GPG_ERR_DUP_VALUE=157$GPG_ERR_MISSING_ACTION=158$GPG_ERR_MODULE_NOT_FOUND=159$GPG_ERR_INV_OID_STRING=160$GPG_ERR_INV_TIME=161$GPG_ERR_INV_CRL_OBJ=162$GPG_ERR_UNSUPPORTED_CRL_VERSION=163$GPG_ERR_INV_CERT_OBJ=164$GPG_ERR_UNKNOWN_NAME=165$GPG_ERR_LOCALE_PROBLEM=166$GPG_ERR_NOT_LOCKED=167$GPG_ERR_PROTOCOL_VIOLATION=168$GPG_ERR_INV_MAC=169$GPG_ERR_INV_REQUEST=170$GPG_ERR_UNKNOWN_EXTN=171$GPG_ERR_UNKNOWN_CRIT_EXTN=172$GPG_ERR_LOCKED=173$GPG_ERR_UNKNOWN_OPTION=174$GPG_ERR_UNKNOWN_COMMAND=175$GPG_ERR_NOT_OPERATIONAL=176$GPG_ERR_NO_PASSPHRASE=177$GPG_ERR_NO_PIN=178$GPG_ERR_NOT_ENABLED=179$GPG_ERR_NO_ENGINE=180$GPG_ERR_MISSING_KEY=181$GPG_ERR_TOO_MANY=182$GPG_ERR_LIMIT_REACHED=183$GPG_ERR_NOT_INITIALIZED=184$GPG_ERR_MISSING_ISSUER_CERT=185$GPG_ERR_NO_KEYSERVER=186$GPG_ERR_INV_CURVE=187$GPG_ERR_UNKNOWN_CURVE=188$GPG_ERR_DUP_KEY=189$GPG_ERR_AMBIGUOUS=190$GPG_ERR_NO_CRYPT_CTX=191$GPG_ERR_WRONG_CRYPT_CTX=192$GPG_ERR_BAD_CRYPT_CTX=193$GPG_ERR_CRYPT_CTX_CONFLICT=194$GPG_ERR_BROKEN_PUBKEY=195$GPG_ERR_BROKEN_SECKEY=196$GPG_ERR_MAC_ALGO=197$GPG_ERR_FULLY_CANCELED=198$GPG_ERR_UNFINISHED=199$GPG_ERR_BUFFER_TOO_SHORT=200$GPG_ERR_SEXP_INV_LEN_SPEC=201$GPG_ERR_SEXP_STRING_TOO_LONG=202$GPG_ERR_SEXP_UNMATCHED_PAREN=203$GPG_ERR_SEXP_NOT_CANONICAL=204$GPG_ERR_SEXP_BAD_CHARACTER=205$GPG_ERR_SEXP_BAD_QUOTATION=206$GPG_ERR_SEXP_ZERO_PREFIX=207$GPG_ERR_SEXP_NESTED_DH=208$GPG_ERR_SEXP_UNMATCHED_DH=209$GPG_ERR_SEXP_UNEXPECTED_PUNC=210$GPG_ERR_SEXP_BAD_HEX_CHAR=211$GPG_ERR_SEXP_ODD_HEX_NUMBERS=212$GPG_ERR_SEXP_BAD_OCT_CHAR=213$GPG_ERR_SERVER_FAILED=219$GPG_ERR_NO_NAME=220$GPG_ERR_NO_KEY=221$GPG_ERR_LEGACY_KEY=222$GPG_ERR_REQUEST_TOO_SHORT=223$GPG_ERR_REQUEST_TOO_LONG=224$GPG_ERR_OBJ_TERM_STATE=225$GPG_ERR_NO_CERT_CHAIN=226$GPG_ERR_CERT_TOO_LARGE=227$GPG_ERR_INV_RECORD=228$GPG_ERR_BAD_MAC=229$GPG_ERR_UNEXPECTED_MSG=230$GPG_ERR_COMPR_FAILED=231$GPG_ERR_WOULD_WRAP=232$GPG_ERR_FATAL_ALERT=233$GPG_ERR_NO_CIPHER=234$GPG_ERR_MISSING_CLIENT_CERT=235$GPG_ERR_CLOSE_NOTIFY=236$GPG_ERR_TICKET_EXPIRED=237$GPG_ERR_BAD_TICKET=238$GPG_ERR_UNKNOWN_IDENTITY=239$GPG_ERR_BAD_HS_CERT=240$GPG_ERR_BAD_HS_CERT_REQ=241$GPG_ERR_BAD_HS_CERT_VER=242$GPG_ERR_BAD_HS_CHANGE_CIPHER=243$GPG_ERR_BAD_HS_CLIENT_HELLO=244$GPG_ERR_BAD_HS_SERVER_HELLO=245$GPG_ERR_BAD_HS_SERVER_HELLO_DONE=246$GPG_ERR_BAD_HS_FINISHED=247$GPG_ERR_BAD_HS_SERVER_KEX=248$GPG_ERR_BAD_HS_CLIENT_KEX=249$GPG_ERR_BOGUS_STRING=250$GPG_ERR_FORBIDDEN=251$GPG_ERR_KEY_DISABLED=252$GPG_ERR_KEY_ON_CARD=253$GPG_ERR_INV_LOCK_OBJ=254$GPG_ERR_TRUE=255$GPG_ERR_FALSE=256$GPG_ERR_ASS_GENERAL=257$GPG_ERR_ASS_ACCEPT_FAILED=258$GPG_ERR_ASS_CONNECT_FAILED=259$GPG_ERR_ASS_INV_RESPONSE=260$GPG_ERR_ASS_INV_VALUE=261$GPG_ERR_ASS_INCOMPLETE_LINE=262$GPG_ERR_ASS_LINE_TOO_LONG=263$GPG_ERR_ASS_NESTED_COMMANDS=264$GPG_ERR_ASS_NO_DATA_CB=265$GPG_ERR_ASS_NO_INQUIRE_CB=266$GPG_ERR_ASS_NOT_A_SERVER=267$GPG_ERR_ASS_NOT_A_CLIENT=268$GPG_ERR_ASS_SERVER_START=269$GPG_ERR_ASS_READ_ERROR=270$GPG_ERR_ASS_WRITE_ERROR=271$GPG_ERR_ASS_TOO_MUCH_DATA=273$GPG_ERR_ASS_UNEXPECTED_CMD=274$GPG_ERR_ASS_UNKNOWN_CMD=275$GPG_ERR_ASS_SYNTAX=276$GPG_ERR_ASS_CANCELED=277$GPG_ERR_ASS_NO_INPUT=278$GPG_ERR_ASS_NO_OUTPUT=279$GPG_ERR_ASS_PARAMETER=280$GPG_ERR_ASS_UNKNOWN_INQUIRE=281$GPG_ERR_LDAP_GENERAL=721$GPG_ERR_LDAP_ATTR_GENERAL=722$GPG_ERR_LDAP_NAME_GENERAL=723$GPG_ERR_LDAP_SECURITY_GENERAL=724$GPG_ERR_LDAP_SERVICE_GENERAL=725$GPG_ERR_LDAP_UPDATE_GENERAL=726$GPG_ERR_LDAP_E_GENERAL=727$GPG_ERR_LDAP_X_GENERAL=728$GPG_ERR_LDAP_OTHER_GENERAL=729$GPG_ERR_LDAP_X_CONNECTING=750$GPG_ERR_LDAP_REFERRAL_LIMIT=751$GPG_ERR_LDAP_CLIENT_LOOP=752$GPG_ERR_LDAP_NO_RESULTS=754$GPG_ERR_LDAP_CONTROL_NOT_FOUND=755$GPG_ERR_LDAP_NOT_SUPPORTED=756$GPG_ERR_LDAP_CONNECT=757$GPG_ERR_LDAP_NO_MEMORY=758$GPG_ERR_LDAP_PARAM=759$GPG_ERR_LDAP_USER_CANCELLED=760$GPG_ERR_LDAP_FILTER=761$GPG_ERR_LDAP_AUTH_UNKNOWN=762$GPG_ERR_LDAP_TIMEOUT=763$GPG_ERR_LDAP_DECODING=764$GPG_ERR_LDAP_ENCODING=765$GPG_ERR_LDAP_LOCAL=766$GPG_ERR_LDAP_SERVER_DOWN=767$GPG_ERR_LDAP_SUCCESS=768$GPG_ERR_LDAP_OPERATIONS=769$GPG_ERR_LDAP_PROTOCOL=770$GPG_ERR_LDAP_TIMELIMIT=771$GPG_ERR_LDAP_SIZELIMIT=772$GPG_ERR_LDAP_COMPARE_FALSE=773$GPG_ERR_LDAP_COMPARE_TRUE=774$GPG_ERR_LDAP_UNSUPPORTED_AUTH=775$GPG_ERR_LDAP_STRONG_AUTH_RQRD=776$GPG_ERR_LDAP_PARTIAL_RESULTS=777$GPG_ERR_LDAP_REFERRAL=778$GPG_ERR_LDAP_ADMINLIMIT=779$GPG_ERR_LDAP_UNAVAIL_CRIT_EXTN=780$GPG_ERR_LDAP_CONFIDENT_RQRD=781$GPG_ERR_LDAP_SASL_BIND_INPROG=782$GPG_ERR_LDAP_NO_SUCH_ATTRIBUTE=784$GPG_ERR_LDAP_UNDEFINED_TYPE=785$GPG_ERR_LDAP_BAD_MATCHING=786$GPG_ERR_LDAP_CONST_VIOLATION=787$GPG_ERR_LDAP_TYPE_VALUE_EXISTS=788$GPG_ERR_LDAP_INV_SYNTAX=789$GPG_ERR_LDAP_NO_SUCH_OBJ=800$GPG_ERR_LDAP_ALIAS_PROBLEM=801$GPG_ERR_LDAP_INV_DN_SYNTAX=802$GPG_ERR_LDAP_IS_LEAF=803$GPG_ERR_LDAP_ALIAS_DEREF=804$GPG_ERR_LDAP_X_PROXY_AUTH_FAIL=815$GPG_ERR_LDAP_BAD_AUTH=816$GPG_ERR_LDAP_INV_CREDENTIALS=817$GPG_ERR_LDAP_INSUFFICIENT_ACC=818$GPG_ERR_LDAP_BUSY=819$GPG_ERR_LDAP_UNAVAILABLE=820$GPG_ERR_LDAP_UNWILL_TO_PERFORM=821$GPG_ERR_LDAP_LOOP_DETECT=822$GPG_ERR_LDAP_NAMING_VIOLATION=832$GPG_ERR_LDAP_OBJ_CLS_VIOLATION=833$GPG_ERR_LDAP_NOT_ALLOW_NONLEAF=834$GPG_ERR_LDAP_NOT_ALLOW_ON_RDN=835$GPG_ERR_LDAP_ALREADY_EXISTS=836$GPG_ERR_LDAP_NO_OBJ_CLASS_MODS=837$GPG_ERR_LDAP_RESULTS_TOO_LARGE=838$GPG_ERR_LDAP_AFFECTS_MULT_DSAS=839$GPG_ERR_LDAP_VLV=844$GPG_ERR_LDAP_OTHER=848$GPG_ERR_LDAP_CUP_RESOURCE_LIMIT=881$GPG_ERR_LDAP_CUP_SEC_VIOLATION=882$GPG_ERR_LDAP_CUP_INV_DATA=883$GPG_ERR_LDAP_CUP_UNSUP_SCHEME=884$GPG_ERR_LDAP_CUP_RELOAD=885$GPG_ERR_LDAP_CANCELLED=886$GPG_ERR_LDAP_NO_SUCH_OPERATION=887$GPG_ERR_LDAP_TOO_LATE=888$GPG_ERR_LDAP_CANNOT_CANCEL=889$GPG_ERR_LDAP_ASSERTION_FAILED=890$GPG_ERR_LDAP_PROX_AUTH_DENIED=891$GPG_ERR_USER_1=1024$GPG_ERR_USER_2=1025$GPG_ERR_USER_3=1026$GPG_ERR_USER_4=1027$GPG_ERR_USER_5=1028$GPG_ERR_USER_6=1029$GPG_ERR_USER_7=1030$GPG_ERR_USER_8=1031$GPG_ERR_USER_9=1032$GPG_ERR_USER_10=1033$GPG_ERR_USER_11=1034$GPG_ERR_USER_12=1035$GPG_ERR_USER_13=1036$GPG_ERR_USER_14=1037$GPG_ERR_USER_15=1038$GPG_ERR_USER_16=1039$GPG_ERR_MISSING_ERRNO=16381$GPG_ERR_UNKNOWN_ERRNO=16382$GPG_ERR_EOF=16383$GPG_ERR_E2BIG=32768$GPG_ERR_EACCES=32769$GPG_ERR_EADDRINUSE=32770$GPG_ERR_EADDRNOTAVAIL=32771$GPG_ERR_EADV=32772$GPG_ERR_EAFNOSUPPORT=32773$GPG_ERR_EAGAIN=32774$GPG_ERR_EALREADY=32775$GPG_ERR_EAUTH=32776$GPG_ERR_EBACKGROUND=32777$GPG_ERR_EBADE=32778$GPG_ERR_EBADF=32779$GPG_ERR_EBADFD=32780$GPG_ERR_EBADMSG=32781$GPG_ERR_EBADR=32782$GPG_ERR_EBADRPC=32783$GPG_ERR_EBADRQC=32784$GPG_ERR_EBADSLT=32785$GPG_ERR_EBFONT=32786$GPG_ERR_EBUSY=32787$GPG_ERR_ECANCELED=32788$GPG_ERR_ECHILD=32789$GPG_ERR_ECHRNG=32790$GPG_ERR_ECOMM=32791$GPG_ERR_ECONNABORTED=32792$GPG_ERR_ECONNREFUSED=32793$GPG_ERR_ECONNRESET=32794$GPG_ERR_ED=32795$GPG_ERR_EDEADLK=32796$GPG_ERR_EDEADLOCK=32797$GPG_ERR_EDESTADDRREQ=32798$GPG_ERR_EDIED=32799$GPG_ERR_EDOM=32800$GPG_ERR_EDOTDOT=32801$GPG_ERR_EDQUOT=32802$GPG_ERR_EEXIST=32803$GPG_ERR_EFAULT=32804$GPG_ERR_EFBIG=32805$GPG_ERR_EFTYPE=32806$GPG_ERR_EGRATUITOUS=32807$GPG_ERR_EGREGIOUS=32808$GPG_ERR_EHOSTDOWN=32809$GPG_ERR_EHOSTUNREACH=32810$GPG_ERR_EIDRM=32811$GPG_ERR_EIEIO=32812$GPG_ERR_EILSEQ=32813$GPG_ERR_EINPROGRESS=32814$GPG_ERR_EINTR=32815$GPG_ERR_EINVAL=32816$GPG_ERR_EIO=32817$GPG_ERR_EISCONN=32818$GPG_ERR_EISDIR=32819$GPG_ERR_EISNAM=32820$GPG_ERR_EL2HLT=32821$GPG_ERR_EL2NSYNC=32822$GPG_ERR_EL3HLT=32823$GPG_ERR_EL3RST=32824$GPG_ERR_ELIBACC=32825$GPG_ERR_ELIBBAD=32826$GPG_ERR_ELIBEXEC=32827$GPG_ERR_ELIBMAX=32828$GPG_ERR_ELIBSCN=32829$GPG_ERR_ELNRNG=32830$GPG_ERR_ELOOP=32831$GPG_ERR_EMEDIUMTYPE=32832$GPG_ERR_EMFILE=32833$GPG_ERR_EMLINK=32834$GPG_ERR_EMSGSIZE=32835$GPG_ERR_EMULTIHOP=32836$GPG_ERR_ENAMETOOLONG=32837$GPG_ERR_ENAVAIL=32838$GPG_ERR_ENEEDAUTH=32839$GPG_ERR_ENETDOWN=32840$GPG_ERR_ENETRESET=32841$GPG_ERR_ENETUNREACH=32842$GPG_ERR_ENFILE=32843$GPG_ERR_ENOANO=32844$GPG_ERR_ENOBUFS=32845$GPG_ERR_ENOCSI=32846$GPG_ERR_ENODATA=32847$GPG_ERR_ENODEV=32848$GPG_ERR_ENOENT=32849$GPG_ERR_ENOEXEC=32850$GPG_ERR_ENOLCK=32851$GPG_ERR_ENOLINK=32852$GPG_ERR_ENOMEDIUM=32853$GPG_ERR_ENOMEM=32854$GPG_ERR_ENOMSG=32855$GPG_ERR_ENONET=32856$GPG_ERR_ENOPKG=32857$GPG_ERR_ENOPROTOOPT=32858$GPG_ERR_ENOSPC=32859$GPG_ERR_ENOSR=32860$GPG_ERR_ENOSTR=32861$GPG_ERR_ENOSYS=32862$GPG_ERR_ENOTBLK=32863$GPG_ERR_ENOTCONN=32864$GPG_ERR_ENOTDIR=32865$GPG_ERR_ENOTEMPTY=32866$GPG_ERR_ENOTNAM=32867$GPG_ERR_ENOTSOCK=32868$GPG_ERR_ENOTSUP=32869$GPG_ERR_ENOTTY=32870$GPG_ERR_ENOTUNIQ=32871$GPG_ERR_ENXIO=32872$GPG_ERR_EOPNOTSUPP=32873$GPG_ERR_EOVERFLOW=32874$GPG_ERR_EPERM=32875$GPG_ERR_EPFNOSUPPORT=32876$GPG_ERR_EPIPE=32877$GPG_ERR_EPROCLIM=32878$GPG_ERR_EPROCUNAVAIL=32879$GPG_ERR_EPROGMISMATCH=32880$GPG_ERR_EPROGUNAVAIL=32881$GPG_ERR_EPROTO=32882$GPG_ERR_EPROTONOSUPPORT=32883$GPG_ERR_EPROTOTYPE=32884$GPG_ERR_ERANGE=32885$GPG_ERR_EREMCHG=32886$GPG_ERR_EREMOTE=32887$GPG_ERR_EREMOTEIO=32888$GPG_ERR_ERESTART=32889$GPG_ERR_EROFS=32890$GPG_ERR_ERPCMISMATCH=32891$GPG_ERR_ESHUTDOWN=32892$GPG_ERR_ESOCKTNOSUPPORT=32893$GPG_ERR_ESPIPE=32894$GPG_ERR_ESRCH=32895$GPG_ERR_ESRMNT=32896$GPG_ERR_ESTALE=32897$GPG_ERR_ESTRPIPE=32898$GPG_ERR_ETIME=32899$GPG_ERR_ETIMEDOUT=32900$GPG_ERR_ETOOMANYREFS=32901$GPG_ERR_ETXTBSY=32902$GPG_ERR_EUCLEAN=32903$GPG_ERR_EUNATCH=32904$GPG_ERR_EUSERS=32905$GPG_ERR_EWOULDBLOCK=32906$GPG_ERR_EXDEV=32907$GPG_ERR_EXFULL=32908$GPG_ERR_CODE_DIM=65536
// file ./../src/gpg-error.h line 130
enum anonymous$4 { GPG_ERR_NO_ERROR=0, GPG_ERR_GENERAL=1, GPG_ERR_UNKNOWN_PACKET=2, GPG_ERR_UNKNOWN_VERSION=3, GPG_ERR_PUBKEY_ALGO=4, GPG_ERR_DIGEST_ALGO=5, GPG_ERR_BAD_PUBKEY=6, GPG_ERR_BAD_SECKEY=7, GPG_ERR_BAD_SIGNATURE=8, GPG_ERR_NO_PUBKEY=9, GPG_ERR_CHECKSUM=10, GPG_ERR_BAD_PASSPHRASE=11, GPG_ERR_CIPHER_ALGO=12, GPG_ERR_KEYRING_OPEN=13, GPG_ERR_INV_PACKET=14, GPG_ERR_INV_ARMOR=15, GPG_ERR_NO_USER_ID=16, GPG_ERR_NO_SECKEY=17, GPG_ERR_WRONG_SECKEY=18, GPG_ERR_BAD_KEY=19, GPG_ERR_COMPR_ALGO=20, GPG_ERR_NO_PRIME=21, GPG_ERR_NO_ENCODING_METHOD=22, GPG_ERR_NO_ENCRYPTION_SCHEME=23, GPG_ERR_NO_SIGNATURE_SCHEME=24, GPG_ERR_INV_ATTR=25, GPG_ERR_NO_VALUE=26, GPG_ERR_NOT_FOUND=27, GPG_ERR_VALUE_NOT_FOUND=28, GPG_ERR_SYNTAX=29, GPG_ERR_BAD_MPI=30, GPG_ERR_INV_PASSPHRASE=31, GPG_ERR_SIG_CLASS=32, GPG_ERR_RESOURCE_LIMIT=33, GPG_ERR_INV_KEYRING=34, GPG_ERR_TRUSTDB=35, GPG_ERR_BAD_CERT=36, GPG_ERR_INV_USER_ID=37, GPG_ERR_UNEXPECTED=38, GPG_ERR_TIME_CONFLICT=39, GPG_ERR_KEYSERVER=40, GPG_ERR_WRONG_PUBKEY_ALGO=41, GPG_ERR_TRIBUTE_TO_D_A=42, GPG_ERR_WEAK_KEY=43, GPG_ERR_INV_KEYLEN=44, GPG_ERR_INV_ARG=45, GPG_ERR_BAD_URI=46, GPG_ERR_INV_URI=47, GPG_ERR_NETWORK=48, GPG_ERR_UNKNOWN_HOST=49, GPG_ERR_SELFTEST_FAILED=50, GPG_ERR_NOT_ENCRYPTED=51, GPG_ERR_NOT_PROCESSED=52, GPG_ERR_UNUSABLE_PUBKEY=53, GPG_ERR_UNUSABLE_SECKEY=54, GPG_ERR_INV_VALUE=55, GPG_ERR_BAD_CERT_CHAIN=56, GPG_ERR_MISSING_CERT=57, GPG_ERR_NO_DATA=58, GPG_ERR_BUG=59, GPG_ERR_NOT_SUPPORTED=60, GPG_ERR_INV_OP=61, GPG_ERR_TIMEOUT=62, GPG_ERR_INTERNAL=63, GPG_ERR_EOF_GCRYPT=64, GPG_ERR_INV_OBJ=65, GPG_ERR_TOO_SHORT=66, GPG_ERR_TOO_LARGE=67, GPG_ERR_NO_OBJ=68, GPG_ERR_NOT_IMPLEMENTED=69, GPG_ERR_CONFLICT=70, GPG_ERR_INV_CIPHER_MODE=71, GPG_ERR_INV_FLAG=72, GPG_ERR_INV_HANDLE=73, GPG_ERR_TRUNCATED=74, GPG_ERR_INCOMPLETE_LINE=75, GPG_ERR_INV_RESPONSE=76, GPG_ERR_NO_AGENT=77, GPG_ERR_AGENT=78, GPG_ERR_INV_DATA=79, GPG_ERR_ASSUAN_SERVER_FAULT=80, GPG_ERR_ASSUAN=81, GPG_ERR_INV_SESSION_KEY=82, GPG_ERR_INV_SEXP=83, GPG_ERR_UNSUPPORTED_ALGORITHM=84, GPG_ERR_NO_PIN_ENTRY=85, GPG_ERR_PIN_ENTRY=86, GPG_ERR_BAD_PIN=87, GPG_ERR_INV_NAME=88, GPG_ERR_BAD_DATA=89, GPG_ERR_INV_PARAMETER=90, GPG_ERR_WRONG_CARD=91, GPG_ERR_NO_DIRMNGR=92, GPG_ERR_DIRMNGR=93, GPG_ERR_CERT_REVOKED=94, GPG_ERR_NO_CRL_KNOWN=95, GPG_ERR_CRL_TOO_OLD=96, GPG_ERR_LINE_TOO_LONG=97, GPG_ERR_NOT_TRUSTED=98, GPG_ERR_CANCELED=99, GPG_ERR_BAD_CA_CERT=100, GPG_ERR_CERT_EXPIRED=101, GPG_ERR_CERT_TOO_YOUNG=102, GPG_ERR_UNSUPPORTED_CERT=103, GPG_ERR_UNKNOWN_SEXP=104, GPG_ERR_UNSUPPORTED_PROTECTION=105, GPG_ERR_CORRUPTED_PROTECTION=106, GPG_ERR_AMBIGUOUS_NAME=107, GPG_ERR_CARD=108, GPG_ERR_CARD_RESET=109, GPG_ERR_CARD_REMOVED=110, GPG_ERR_INV_CARD=111, GPG_ERR_CARD_NOT_PRESENT=112, GPG_ERR_NO_PKCS15_APP=113, GPG_ERR_NOT_CONFIRMED=114, GPG_ERR_CONFIGURATION=115, GPG_ERR_NO_POLICY_MATCH=116, GPG_ERR_INV_INDEX=117, GPG_ERR_INV_ID=118, GPG_ERR_NO_SCDAEMON=119, GPG_ERR_SCDAEMON=120, GPG_ERR_UNSUPPORTED_PROTOCOL=121, GPG_ERR_BAD_PIN_METHOD=122, GPG_ERR_CARD_NOT_INITIALIZED=123, GPG_ERR_UNSUPPORTED_OPERATION=124, GPG_ERR_WRONG_KEY_USAGE=125, GPG_ERR_NOTHING_FOUND=126, GPG_ERR_WRONG_BLOB_TYPE=127, GPG_ERR_MISSING_VALUE=128, GPG_ERR_HARDWARE=129, GPG_ERR_PIN_BLOCKED=130, GPG_ERR_USE_CONDITIONS=131, GPG_ERR_PIN_NOT_SYNCED=132, GPG_ERR_INV_CRL=133, GPG_ERR_BAD_BER=134, GPG_ERR_INV_BER=135, GPG_ERR_ELEMENT_NOT_FOUND=136, GPG_ERR_IDENTIFIER_NOT_FOUND=137, GPG_ERR_INV_TAG=138, GPG_ERR_INV_LENGTH=139, GPG_ERR_INV_KEYINFO=140, GPG_ERR_UNEXPECTED_TAG=141, GPG_ERR_NOT_DER_ENCODED=142, GPG_ERR_NO_CMS_OBJ=143, GPG_ERR_INV_CMS_OBJ=144, GPG_ERR_UNKNOWN_CMS_OBJ=145, GPG_ERR_UNSUPPORTED_CMS_OBJ=146, GPG_ERR_UNSUPPORTED_ENCODING=147, GPG_ERR_UNSUPPORTED_CMS_VERSION=148, GPG_ERR_UNKNOWN_ALGORITHM=149, GPG_ERR_INV_ENGINE=150, GPG_ERR_PUBKEY_NOT_TRUSTED=151, GPG_ERR_DECRYPT_FAILED=152, GPG_ERR_KEY_EXPIRED=153, GPG_ERR_SIG_EXPIRED=154, GPG_ERR_ENCODING_PROBLEM=155, GPG_ERR_INV_STATE=156, GPG_ERR_DUP_VALUE=157, GPG_ERR_MISSING_ACTION=158, GPG_ERR_MODULE_NOT_FOUND=159, GPG_ERR_INV_OID_STRING=160, GPG_ERR_INV_TIME=161, GPG_ERR_INV_CRL_OBJ=162, GPG_ERR_UNSUPPORTED_CRL_VERSION=163, GPG_ERR_INV_CERT_OBJ=164, GPG_ERR_UNKNOWN_NAME=165, GPG_ERR_LOCALE_PROBLEM=166, GPG_ERR_NOT_LOCKED=167, GPG_ERR_PROTOCOL_VIOLATION=168, GPG_ERR_INV_MAC=169, GPG_ERR_INV_REQUEST=170, GPG_ERR_UNKNOWN_EXTN=171, GPG_ERR_UNKNOWN_CRIT_EXTN=172, GPG_ERR_LOCKED=173, GPG_ERR_UNKNOWN_OPTION=174, GPG_ERR_UNKNOWN_COMMAND=175, GPG_ERR_NOT_OPERATIONAL=176, GPG_ERR_NO_PASSPHRASE=177, GPG_ERR_NO_PIN=178, GPG_ERR_NOT_ENABLED=179, GPG_ERR_NO_ENGINE=180, GPG_ERR_MISSING_KEY=181, GPG_ERR_TOO_MANY=182, GPG_ERR_LIMIT_REACHED=183, GPG_ERR_NOT_INITIALIZED=184, GPG_ERR_MISSING_ISSUER_CERT=185, GPG_ERR_NO_KEYSERVER=186, GPG_ERR_INV_CURVE=187, GPG_ERR_UNKNOWN_CURVE=188, GPG_ERR_DUP_KEY=189, GPG_ERR_AMBIGUOUS=190, GPG_ERR_NO_CRYPT_CTX=191, GPG_ERR_WRONG_CRYPT_CTX=192, GPG_ERR_BAD_CRYPT_CTX=193, GPG_ERR_CRYPT_CTX_CONFLICT=194, GPG_ERR_BROKEN_PUBKEY=195, GPG_ERR_BROKEN_SECKEY=196, GPG_ERR_MAC_ALGO=197, GPG_ERR_FULLY_CANCELED=198, GPG_ERR_UNFINISHED=199, GPG_ERR_BUFFER_TOO_SHORT=200, GPG_ERR_SEXP_INV_LEN_SPEC=201, GPG_ERR_SEXP_STRING_TOO_LONG=202, GPG_ERR_SEXP_UNMATCHED_PAREN=203, GPG_ERR_SEXP_NOT_CANONICAL=204, GPG_ERR_SEXP_BAD_CHARACTER=205, GPG_ERR_SEXP_BAD_QUOTATION=206, GPG_ERR_SEXP_ZERO_PREFIX=207, GPG_ERR_SEXP_NESTED_DH=208, GPG_ERR_SEXP_UNMATCHED_DH=209, GPG_ERR_SEXP_UNEXPECTED_PUNC=210, GPG_ERR_SEXP_BAD_HEX_CHAR=211, GPG_ERR_SEXP_ODD_HEX_NUMBERS=212, GPG_ERR_SEXP_BAD_OCT_CHAR=213, GPG_ERR_SERVER_FAILED=219, GPG_ERR_NO_NAME=220, GPG_ERR_NO_KEY=221, GPG_ERR_LEGACY_KEY=222, GPG_ERR_REQUEST_TOO_SHORT=223, GPG_ERR_REQUEST_TOO_LONG=224, GPG_ERR_OBJ_TERM_STATE=225, GPG_ERR_NO_CERT_CHAIN=226, GPG_ERR_CERT_TOO_LARGE=227, GPG_ERR_INV_RECORD=228, GPG_ERR_BAD_MAC=229, GPG_ERR_UNEXPECTED_MSG=230, GPG_ERR_COMPR_FAILED=231, GPG_ERR_WOULD_WRAP=232, GPG_ERR_FATAL_ALERT=233, GPG_ERR_NO_CIPHER=234, GPG_ERR_MISSING_CLIENT_CERT=235, GPG_ERR_CLOSE_NOTIFY=236, GPG_ERR_TICKET_EXPIRED=237, GPG_ERR_BAD_TICKET=238, GPG_ERR_UNKNOWN_IDENTITY=239, GPG_ERR_BAD_HS_CERT=240, GPG_ERR_BAD_HS_CERT_REQ=241, GPG_ERR_BAD_HS_CERT_VER=242, GPG_ERR_BAD_HS_CHANGE_CIPHER=243, GPG_ERR_BAD_HS_CLIENT_HELLO=244, GPG_ERR_BAD_HS_SERVER_HELLO=245, GPG_ERR_BAD_HS_SERVER_HELLO_DONE=246, GPG_ERR_BAD_HS_FINISHED=247, GPG_ERR_BAD_HS_SERVER_KEX=248, GPG_ERR_BAD_HS_CLIENT_KEX=249, GPG_ERR_BOGUS_STRING=250, GPG_ERR_FORBIDDEN=251, GPG_ERR_KEY_DISABLED=252, GPG_ERR_KEY_ON_CARD=253, GPG_ERR_INV_LOCK_OBJ=254, GPG_ERR_TRUE=255, GPG_ERR_FALSE=256, GPG_ERR_ASS_GENERAL=257, GPG_ERR_ASS_ACCEPT_FAILED=258, GPG_ERR_ASS_CONNECT_FAILED=259, GPG_ERR_ASS_INV_RESPONSE=260, GPG_ERR_ASS_INV_VALUE=261, GPG_ERR_ASS_INCOMPLETE_LINE=262, GPG_ERR_ASS_LINE_TOO_LONG=263, GPG_ERR_ASS_NESTED_COMMANDS=264, GPG_ERR_ASS_NO_DATA_CB=265, GPG_ERR_ASS_NO_INQUIRE_CB=266, GPG_ERR_ASS_NOT_A_SERVER=267, GPG_ERR_ASS_NOT_A_CLIENT=268, GPG_ERR_ASS_SERVER_START=269, GPG_ERR_ASS_READ_ERROR=270, GPG_ERR_ASS_WRITE_ERROR=271, GPG_ERR_ASS_TOO_MUCH_DATA=273, GPG_ERR_ASS_UNEXPECTED_CMD=274, GPG_ERR_ASS_UNKNOWN_CMD=275, GPG_ERR_ASS_SYNTAX=276, GPG_ERR_ASS_CANCELED=277, GPG_ERR_ASS_NO_INPUT=278, GPG_ERR_ASS_NO_OUTPUT=279, GPG_ERR_ASS_PARAMETER=280, GPG_ERR_ASS_UNKNOWN_INQUIRE=281, GPG_ERR_LDAP_GENERAL=721, GPG_ERR_LDAP_ATTR_GENERAL=722, GPG_ERR_LDAP_NAME_GENERAL=723, GPG_ERR_LDAP_SECURITY_GENERAL=724, GPG_ERR_LDAP_SERVICE_GENERAL=725, GPG_ERR_LDAP_UPDATE_GENERAL=726, GPG_ERR_LDAP_E_GENERAL=727, GPG_ERR_LDAP_X_GENERAL=728, GPG_ERR_LDAP_OTHER_GENERAL=729, GPG_ERR_LDAP_X_CONNECTING=750, GPG_ERR_LDAP_REFERRAL_LIMIT=751, GPG_ERR_LDAP_CLIENT_LOOP=752, GPG_ERR_LDAP_NO_RESULTS=754, GPG_ERR_LDAP_CONTROL_NOT_FOUND=755, GPG_ERR_LDAP_NOT_SUPPORTED=756, GPG_ERR_LDAP_CONNECT=757, GPG_ERR_LDAP_NO_MEMORY=758, GPG_ERR_LDAP_PARAM=759, GPG_ERR_LDAP_USER_CANCELLED=760, GPG_ERR_LDAP_FILTER=761, GPG_ERR_LDAP_AUTH_UNKNOWN=762, GPG_ERR_LDAP_TIMEOUT=763, GPG_ERR_LDAP_DECODING=764, GPG_ERR_LDAP_ENCODING=765, GPG_ERR_LDAP_LOCAL=766, GPG_ERR_LDAP_SERVER_DOWN=767, GPG_ERR_LDAP_SUCCESS=768, GPG_ERR_LDAP_OPERATIONS=769, GPG_ERR_LDAP_PROTOCOL=770, GPG_ERR_LDAP_TIMELIMIT=771, GPG_ERR_LDAP_SIZELIMIT=772, GPG_ERR_LDAP_COMPARE_FALSE=773, GPG_ERR_LDAP_COMPARE_TRUE=774, GPG_ERR_LDAP_UNSUPPORTED_AUTH=775, GPG_ERR_LDAP_STRONG_AUTH_RQRD=776, GPG_ERR_LDAP_PARTIAL_RESULTS=777, GPG_ERR_LDAP_REFERRAL=778, GPG_ERR_LDAP_ADMINLIMIT=779, GPG_ERR_LDAP_UNAVAIL_CRIT_EXTN=780, GPG_ERR_LDAP_CONFIDENT_RQRD=781, GPG_ERR_LDAP_SASL_BIND_INPROG=782, GPG_ERR_LDAP_NO_SUCH_ATTRIBUTE=784, GPG_ERR_LDAP_UNDEFINED_TYPE=785, GPG_ERR_LDAP_BAD_MATCHING=786, GPG_ERR_LDAP_CONST_VIOLATION=787, GPG_ERR_LDAP_TYPE_VALUE_EXISTS=788, GPG_ERR_LDAP_INV_SYNTAX=789, GPG_ERR_LDAP_NO_SUCH_OBJ=800, GPG_ERR_LDAP_ALIAS_PROBLEM=801, GPG_ERR_LDAP_INV_DN_SYNTAX=802, GPG_ERR_LDAP_IS_LEAF=803, GPG_ERR_LDAP_ALIAS_DEREF=804, GPG_ERR_LDAP_X_PROXY_AUTH_FAIL=815, GPG_ERR_LDAP_BAD_AUTH=816, GPG_ERR_LDAP_INV_CREDENTIALS=817, GPG_ERR_LDAP_INSUFFICIENT_ACC=818, GPG_ERR_LDAP_BUSY=819, GPG_ERR_LDAP_UNAVAILABLE=820, GPG_ERR_LDAP_UNWILL_TO_PERFORM=821, GPG_ERR_LDAP_LOOP_DETECT=822, GPG_ERR_LDAP_NAMING_VIOLATION=832, GPG_ERR_LDAP_OBJ_CLS_VIOLATION=833, GPG_ERR_LDAP_NOT_ALLOW_NONLEAF=834, GPG_ERR_LDAP_NOT_ALLOW_ON_RDN=835, GPG_ERR_LDAP_ALREADY_EXISTS=836, GPG_ERR_LDAP_NO_OBJ_CLASS_MODS=837, GPG_ERR_LDAP_RESULTS_TOO_LARGE=838, GPG_ERR_LDAP_AFFECTS_MULT_DSAS=839, GPG_ERR_LDAP_VLV=844, GPG_ERR_LDAP_OTHER=848, GPG_ERR_LDAP_CUP_RESOURCE_LIMIT=881, GPG_ERR_LDAP_CUP_SEC_VIOLATION=882, GPG_ERR_LDAP_CUP_INV_DATA=883, GPG_ERR_LDAP_CUP_UNSUP_SCHEME=884, GPG_ERR_LDAP_CUP_RELOAD=885, GPG_ERR_LDAP_CANCELLED=886, GPG_ERR_LDAP_NO_SUCH_OPERATION=887, GPG_ERR_LDAP_TOO_LATE=888, GPG_ERR_LDAP_CANNOT_CANCEL=889, GPG_ERR_LDAP_ASSERTION_FAILED=890, GPG_ERR_LDAP_PROX_AUTH_DENIED=891, GPG_ERR_USER_1=1024, GPG_ERR_USER_2=1025, GPG_ERR_USER_3=1026, GPG_ERR_USER_4=1027, GPG_ERR_USER_5=1028, GPG_ERR_USER_6=1029, GPG_ERR_USER_7=1030, GPG_ERR_USER_8=1031, GPG_ERR_USER_9=1032, GPG_ERR_USER_10=1033, GPG_ERR_USER_11=1034, GPG_ERR_USER_12=1035, GPG_ERR_USER_13=1036, GPG_ERR_USER_14=1037, GPG_ERR_USER_15=1038, GPG_ERR_USER_16=1039, GPG_ERR_MISSING_ERRNO=16381, GPG_ERR_UNKNOWN_ERRNO=16382, GPG_ERR_EOF=16383, GPG_ERR_E2BIG=32768, GPG_ERR_EACCES=32769, GPG_ERR_EADDRINUSE=32770, GPG_ERR_EADDRNOTAVAIL=32771, GPG_ERR_EADV=32772, GPG_ERR_EAFNOSUPPORT=32773, GPG_ERR_EAGAIN=32774, GPG_ERR_EALREADY=32775, GPG_ERR_EAUTH=32776, GPG_ERR_EBACKGROUND=32777, GPG_ERR_EBADE=32778, GPG_ERR_EBADF=32779, GPG_ERR_EBADFD=32780, GPG_ERR_EBADMSG=32781, GPG_ERR_EBADR=32782, GPG_ERR_EBADRPC=32783, GPG_ERR_EBADRQC=32784, GPG_ERR_EBADSLT=32785, GPG_ERR_EBFONT=32786, GPG_ERR_EBUSY=32787, GPG_ERR_ECANCELED=32788, GPG_ERR_ECHILD=32789, GPG_ERR_ECHRNG=32790, GPG_ERR_ECOMM=32791, GPG_ERR_ECONNABORTED=32792, GPG_ERR_ECONNREFUSED=32793, GPG_ERR_ECONNRESET=32794, GPG_ERR_ED=32795, GPG_ERR_EDEADLK=32796, GPG_ERR_EDEADLOCK=32797, GPG_ERR_EDESTADDRREQ=32798, GPG_ERR_EDIED=32799, GPG_ERR_EDOM=32800, GPG_ERR_EDOTDOT=32801, GPG_ERR_EDQUOT=32802, GPG_ERR_EEXIST=32803, GPG_ERR_EFAULT=32804, GPG_ERR_EFBIG=32805, GPG_ERR_EFTYPE=32806, GPG_ERR_EGRATUITOUS=32807, GPG_ERR_EGREGIOUS=32808, GPG_ERR_EHOSTDOWN=32809, GPG_ERR_EHOSTUNREACH=32810, GPG_ERR_EIDRM=32811, GPG_ERR_EIEIO=32812, GPG_ERR_EILSEQ=32813, GPG_ERR_EINPROGRESS=32814, GPG_ERR_EINTR=32815, GPG_ERR_EINVAL=32816, GPG_ERR_EIO=32817, GPG_ERR_EISCONN=32818, GPG_ERR_EISDIR=32819, GPG_ERR_EISNAM=32820, GPG_ERR_EL2HLT=32821, GPG_ERR_EL2NSYNC=32822, GPG_ERR_EL3HLT=32823, GPG_ERR_EL3RST=32824, GPG_ERR_ELIBACC=32825, GPG_ERR_ELIBBAD=32826, GPG_ERR_ELIBEXEC=32827, GPG_ERR_ELIBMAX=32828, GPG_ERR_ELIBSCN=32829, GPG_ERR_ELNRNG=32830, GPG_ERR_ELOOP=32831, GPG_ERR_EMEDIUMTYPE=32832, GPG_ERR_EMFILE=32833, GPG_ERR_EMLINK=32834, GPG_ERR_EMSGSIZE=32835, GPG_ERR_EMULTIHOP=32836, GPG_ERR_ENAMETOOLONG=32837, GPG_ERR_ENAVAIL=32838, GPG_ERR_ENEEDAUTH=32839, GPG_ERR_ENETDOWN=32840, GPG_ERR_ENETRESET=32841, GPG_ERR_ENETUNREACH=32842, GPG_ERR_ENFILE=32843, GPG_ERR_ENOANO=32844, GPG_ERR_ENOBUFS=32845, GPG_ERR_ENOCSI=32846, GPG_ERR_ENODATA=32847, GPG_ERR_ENODEV=32848, GPG_ERR_ENOENT=32849, GPG_ERR_ENOEXEC=32850, GPG_ERR_ENOLCK=32851, GPG_ERR_ENOLINK=32852, GPG_ERR_ENOMEDIUM=32853, GPG_ERR_ENOMEM=32854, GPG_ERR_ENOMSG=32855, GPG_ERR_ENONET=32856, GPG_ERR_ENOPKG=32857, GPG_ERR_ENOPROTOOPT=32858, GPG_ERR_ENOSPC=32859, GPG_ERR_ENOSR=32860, GPG_ERR_ENOSTR=32861, GPG_ERR_ENOSYS=32862, GPG_ERR_ENOTBLK=32863, GPG_ERR_ENOTCONN=32864, GPG_ERR_ENOTDIR=32865, GPG_ERR_ENOTEMPTY=32866, GPG_ERR_ENOTNAM=32867, GPG_ERR_ENOTSOCK=32868, GPG_ERR_ENOTSUP=32869, GPG_ERR_ENOTTY=32870, GPG_ERR_ENOTUNIQ=32871, GPG_ERR_ENXIO=32872, GPG_ERR_EOPNOTSUPP=32873, GPG_ERR_EOVERFLOW=32874, GPG_ERR_EPERM=32875, GPG_ERR_EPFNOSUPPORT=32876, GPG_ERR_EPIPE=32877, GPG_ERR_EPROCLIM=32878, GPG_ERR_EPROCUNAVAIL=32879, GPG_ERR_EPROGMISMATCH=32880, GPG_ERR_EPROGUNAVAIL=32881, GPG_ERR_EPROTO=32882, GPG_ERR_EPROTONOSUPPORT=32883, GPG_ERR_EPROTOTYPE=32884, GPG_ERR_ERANGE=32885, GPG_ERR_EREMCHG=32886, GPG_ERR_EREMOTE=32887, GPG_ERR_EREMOTEIO=32888, GPG_ERR_ERESTART=32889, GPG_ERR_EROFS=32890, GPG_ERR_ERPCMISMATCH=32891, GPG_ERR_ESHUTDOWN=32892, GPG_ERR_ESOCKTNOSUPPORT=32893, GPG_ERR_ESPIPE=32894, GPG_ERR_ESRCH=32895, GPG_ERR_ESRMNT=32896, GPG_ERR_ESTALE=32897, GPG_ERR_ESTRPIPE=32898, GPG_ERR_ETIME=32899, GPG_ERR_ETIMEDOUT=32900, GPG_ERR_ETOOMANYREFS=32901, GPG_ERR_ETXTBSY=32902, GPG_ERR_EUCLEAN=32903, GPG_ERR_EUNATCH=32904, GPG_ERR_EUSERS=32905, GPG_ERR_EWOULDBLOCK=32906, GPG_ERR_EXDEV=32907, GPG_ERR_EXFULL=32908, GPG_ERR_CODE_DIM=65536 };

// #anon_enum$GPG_ERR_SOURCE_UNKNOWN=0$GPG_ERR_SOURCE_GCRYPT=1$GPG_ERR_SOURCE_GPG=2$GPG_ERR_SOURCE_GPGSM=3$GPG_ERR_SOURCE_GPGAGENT=4$GPG_ERR_SOURCE_PINENTRY=5$GPG_ERR_SOURCE_SCD=6$GPG_ERR_SOURCE_GPGME=7$GPG_ERR_SOURCE_KEYBOX=8$GPG_ERR_SOURCE_KSBA=9$GPG_ERR_SOURCE_DIRMNGR=10$GPG_ERR_SOURCE_GSTI=11$GPG_ERR_SOURCE_GPA=12$GPG_ERR_SOURCE_KLEO=13$GPG_ERR_SOURCE_G13=14$GPG_ERR_SOURCE_ASSUAN=15$GPG_ERR_SOURCE_TLS=17$GPG_ERR_SOURCE_ANY=31$GPG_ERR_SOURCE_USER_1=32$GPG_ERR_SOURCE_USER_2=33$GPG_ERR_SOURCE_USER_3=34$GPG_ERR_SOURCE_USER_4=35$GPG_ERR_SOURCE_DIM=128
// file ./gpg-error.h line 96
enum anonymous$2 { GPG_ERR_SOURCE_UNKNOWN=0, GPG_ERR_SOURCE_GCRYPT=1, GPG_ERR_SOURCE_GPG=2, GPG_ERR_SOURCE_GPGSM=3, GPG_ERR_SOURCE_GPGAGENT=4, GPG_ERR_SOURCE_PINENTRY=5, GPG_ERR_SOURCE_SCD=6, GPG_ERR_SOURCE_GPGME=7, GPG_ERR_SOURCE_KEYBOX=8, GPG_ERR_SOURCE_KSBA=9, GPG_ERR_SOURCE_DIRMNGR=10, GPG_ERR_SOURCE_GSTI=11, GPG_ERR_SOURCE_GPA=12, GPG_ERR_SOURCE_KLEO=13, GPG_ERR_SOURCE_G13=14, GPG_ERR_SOURCE_ASSUAN=15, GPG_ERR_SOURCE_TLS=17, GPG_ERR_SOURCE_ANY=31, GPG_ERR_SOURCE_USER_1=32, GPG_ERR_SOURCE_USER_2=33, GPG_ERR_SOURCE_USER_3=34, GPG_ERR_SOURCE_USER_4=35, GPG_ERR_SOURCE_DIM=128 };

// #anon_enum$LENMOD_NONE=0$LENMOD_CHAR=1$LENMOD_SHORT=2$LENMOD_LONG=3$LENMOD_LONGLONG=4$LENMOD_INTMAX=5$LENMOD_SIZET=6$LENMOD_PTRDIFF=7$LENMOD_LONGDBL=8
// file ../../src/estream-printf.c line 155
enum anonymous$11 { LENMOD_NONE=0, LENMOD_CHAR=1, LENMOD_SHORT=2, LENMOD_LONG=3, LENMOD_LONGLONG=4, LENMOD_INTMAX=5, LENMOD_SIZET=6, LENMOD_PTRDIFF=7, LENMOD_LONGDBL=8 };

// #anon_enum$VALTYPE_UNSUPPORTED=0$VALTYPE_CHAR=1$VALTYPE_SCHAR=2$VALTYPE_UCHAR=3$VALTYPE_SHORT=4$VALTYPE_USHORT=5$VALTYPE_INT=6$VALTYPE_UINT=7$VALTYPE_LONG=8$VALTYPE_ULONG=9$VALTYPE_LONGLONG=10$VALTYPE_ULONGLONG=11$VALTYPE_DOUBLE=12$VALTYPE_LONGDOUBLE=13$VALTYPE_STRING=14$VALTYPE_INTMAX=15$VALTYPE_UINTMAX=16$VALTYPE_SIZE=17$VALTYPE_PTRDIFF=18$VALTYPE_POINTER=19$VALTYPE_CHAR_PTR=20$VALTYPE_SCHAR_PTR=21$VALTYPE_SHORT_PTR=22$VALTYPE_INT_PTR=23$VALTYPE_LONG_PTR=24$VALTYPE_LONGLONG_PTR=25$VALTYPE_INTMAX_PTR=26$VALTYPE_SIZE_PTR=27$VALTYPE_PTRDIFF_PTR=28
// file ../../src/estream-printf.c line 196
enum anonymous$13 { VALTYPE_UNSUPPORTED=0, VALTYPE_CHAR=1, VALTYPE_SCHAR=2, VALTYPE_UCHAR=3, VALTYPE_SHORT=4, VALTYPE_USHORT=5, VALTYPE_INT=6, VALTYPE_UINT=7, VALTYPE_LONG=8, VALTYPE_ULONG=9, VALTYPE_LONGLONG=10, VALTYPE_ULONGLONG=11, VALTYPE_DOUBLE=12, VALTYPE_LONGDOUBLE=13, VALTYPE_STRING=14, VALTYPE_INTMAX=15, VALTYPE_UINTMAX=16, VALTYPE_SIZE=17, VALTYPE_PTRDIFF=18, VALTYPE_POINTER=19, VALTYPE_CHAR_PTR=20, VALTYPE_SCHAR_PTR=21, VALTYPE_SHORT_PTR=22, VALTYPE_INT_PTR=23, VALTYPE_LONG_PTR=24, VALTYPE_LONGLONG_PTR=25, VALTYPE_INTMAX_PTR=26, VALTYPE_SIZE_PTR=27, VALTYPE_PTRDIFF_PTR=28 };

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$1;

// tag-#anon#ST[BF{U32}$U32$'err'||BF{U32}$U32$'eof'||BF{U32}$U32$'hup'||BF{U5}$U5$'$bit_field_pad0'||U24'$pad0'|]
// file ../../src/estream.c line 194
struct anonymous$16;

// tag-#anon#ST[BF{U32}$U32$'grow'||BF{U7}$U7$'$bit_field_pad0'||U24'$pad0'|]
// file ../../src/estream.c line 578
struct anonymous$0;

// tag-#anon#ST[BF{U32}$U32$'magic'||BF{U32}$U32$'writing'||BF{U32}$U32$'reserved'|]
// file ./gpg-error.h line 996
struct anonymous$15;

// tag-#anon#ST[S64'_vers'||SYM#tag-#anon#UN[ARR40{vS8}$vS8$'_priv'||S64'_x_align'||*{S64}$S64$'_xp_align'|]#'u'|]
// file ./../src/gpg-error.h line 946
struct anonymous$5;

// tag-#anon#ST[S64'vers'||SYM#tag-#anon#UN[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'mtx'||*{S64}$S64$'dummy'|]#'u'|]
// file ../../src/posix-lock-obj.h line 30
struct anonymous$10;

// tag-#anon#UN[ARR40{vS8}$vS8$'_priv'||S64'_x_align'||*{S64}$S64$'_xp_align'|]
// file ./../src/gpg-error.h line 949
union anonymous$6;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$8;

// tag-#anon#UN[S32'fd'||S32'sock'||S32'rvid'||*{V}$V$'handle'|]
// file ./gpg-error.h line 1070
union anonymous;

// tag-#anon#UN[S8'a_char'||S8'a_schar'||U8'a_uchar'||S16'a_short'||U16'a_ushort'||S32'a_int'||U32'a_uint'||S64'a_long'||U64'a_ulong'||S64'a_longlong'||U64'a_ulonglong'||F64'a_double'||F128'a_longdouble'||*{cS8}$cS8$'a_string'||S64'a_intmax'||S64'a_uintmax'||U64'a_size'||S64'a_ptrdiff'||*{V}$V$'a_void_ptr'||*{S8}$S8$'a_char_ptr'||*{S8}$S8$'a_schar_ptr'||*{S16}$S16$'a_short_ptr'||*{S32}$S32$'a_int_ptr'||*{S64}$S64$'a_long_ptr'||*{S64}$S64$'a_longlong_ptr'||*{S64}$S64$'a_intmax_ptr'||*{U64}$U64$'a_size_ptr'||*{S64}$S64$'a_ptrdiff_ptr'|]
// file ../../src/estream-printf.c line 231
union anonymous$14;

// tag-#anon#UN[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'mtx'||*{S64}$S64$'dummy'|]
// file ../../src/posix-lock-obj.h line 34
union anonymous$9;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$7;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_gpgrt__stream
// file ./gpg-error.h line 989
struct _gpgrt__stream;

// tag-_gpgrt_cookie_io_functions
// file ./gpg-error.h line 1042
struct _gpgrt_cookie_io_functions;

// tag-_gpgrt_poll_s
// file ./gpg-error.h line 1088
struct _gpgrt_poll_s;

// tag-_gpgrt_stream_internal
// file ./gpg-error.h line 988
struct _gpgrt_stream_internal;

// tag-_gpgrt_syshd
// file ./gpg-error.h line 1067
struct _gpgrt_syshd;

// tag-argspec_s
// file ../../src/estream-printf.c line 280
struct argspec_s;

// tag-dynamic_buffer_parm_s
// file ../../src/estream-printf.c line 1755
struct dynamic_buffer_parm_s;

// tag-estream_cookie_fd
// file ../../src/estream.c line 881
struct estream_cookie_fd;

// tag-estream_cookie_fp
// file ../../src/estream.c line 1303
struct estream_cookie_fp;

// tag-estream_cookie_mem
// file ../../src/estream.c line 568
struct estream_cookie_mem;

// tag-estream_list_s
// file ../../src/estream.c line 211
struct estream_list_s;

// tag-fixed_buffer_parm_s
// file ../../src/estream-printf.c line 1676
struct fixed_buffer_parm_s;

// tag-gpgrt_syshd_types
// file ./gpg-error.h line 1058
enum gpgrt_syshd_types { GPGRT_SYSHD_NONE=0, GPGRT_SYSHD_FD=1, GPGRT_SYSHD_SOCK=2, GPGRT_SYSHD_RVID=3, GPGRT_SYSHD_HANDLE=4 };

// tag-notify_list_s
// file ../../src/estream.c line 156
struct notify_list_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-valueitem_s
// file ../../src/estream-printf.c line 300
struct valueitem_s;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// _IO_putc
// file /usr/include/libio.h line 435
extern signed int _IO_putc(signed int, struct _IO_FILE *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _gpg_err_code_from_errno
// file ../../src/code-from-errno.c line 35
enum anonymous$4 _gpg_err_code_from_errno(signed int err);
// _gpg_err_code_from_syserror
// file ../../src/code-from-errno.c line 55
enum anonymous$4 _gpg_err_code_from_syserror(void);
// _gpg_err_code_to_errno
// file ../../src/code-to-errno.c line 32
signed int _gpg_err_code_to_errno(enum anonymous$4 code);
// _gpg_err_deinit
// file ../../src/init.c line 131
void _gpg_err_deinit(signed int mode);
// _gpg_err_init
// file ../../src/init.c line 88
unsigned int _gpg_err_init(void);
// _gpg_err_set_errno
// file ../../src/init.c line 206
void _gpg_err_set_errno(signed int err);
// _gpg_error_check_version
// file ../../src/version.c line 116
const char * _gpg_error_check_version(const char *req_version);
// _gpg_strerror
// file ../../src/strerror.c line 38
const char * _gpg_strerror(unsigned int err);
// _gpg_strerror_r
// file ../../src/strerror.c line 137
signed int _gpg_strerror_r(unsigned int err, char *buf, unsigned long int buflen);
// _gpg_strsource
// file ../../src/strsource.c line 33
const char * _gpg_strsource(unsigned int err);
// _gpgrt__get_std_stream
// file ../../src/estream.c line 3254
struct _gpgrt__stream * _gpgrt__get_std_stream(signed int fd);
// _gpgrt__getc_underflow
// file ../../src/estream.c line 3778
signed int _gpgrt__getc_underflow(struct _gpgrt__stream *stream);
// _gpgrt__pending
// file ../../src/estream.c line 3596
signed int _gpgrt__pending(struct _gpgrt__stream *stream);
// _gpgrt__pending_unlocked
// file ../../src/estream.c line 3581
signed int _gpgrt__pending_unlocked(struct _gpgrt__stream *stream);
// _gpgrt__putc_overflow
// file ../../src/estream.c line 3791
signed int _gpgrt__putc_overflow(signed int c, struct _gpgrt__stream *stream);
// _gpgrt__set_std_fd
// file ../../src/estream.c line 3238
void _gpgrt__set_std_fd(signed int no, signed int fd);
// _gpgrt_clearerr
// file ../../src/estream.c line 3659
void _gpgrt_clearerr(struct _gpgrt__stream *stream);
// _gpgrt_clearerr_unlocked
// file ../../src/estream.c line 3649
void _gpgrt_clearerr_unlocked(struct _gpgrt__stream *stream);
// _gpgrt_es_init
// file ../../src/gpgrt-int.h line 54
signed int _gpgrt_es_init(void);
// _gpgrt_estream_asprintf
// file ../../src/estream-printf.c line 1845
signed int _gpgrt_estream_asprintf(char **bufp, const char *format, ...);
// _gpgrt_estream_bsprintf
// file ../../src/estream-printf.c line 1863
char * _gpgrt_estream_bsprintf(const char *format, ...);
// _gpgrt_estream_format
// file ../../src/estream-printf.h line 126
signed int _gpgrt_estream_format(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, const char *format, void **vaargs);
// _gpgrt_estream_format::outfnc$object
// 
signed int outfnc$object(void *, const char *, unsigned long int);
// _gpgrt_estream_fprintf
// file ../../src/estream-printf.c line 1653
signed int _gpgrt_estream_fprintf(struct _IO_FILE *fp, const char *format, ...);
// _gpgrt_estream_printf
// file ../../src/estream-printf.c line 1639
signed int _gpgrt_estream_printf(const char *format, ...);
// _gpgrt_estream_snprintf
// file ../../src/estream-printf.c line 1739
signed int _gpgrt_estream_snprintf(char *buf, unsigned long int bufsize, const char *format, ...);
// _gpgrt_estream_vasprintf
// file ../../src/estream-printf.c line 1804
signed int _gpgrt_estream_vasprintf(char **bufp, const char *format, void **arg_ptr);
// _gpgrt_estream_vfprintf
// file ../../src/estream-printf.c line 1667
signed int _gpgrt_estream_vfprintf(struct _IO_FILE *fp, const char *format, void **arg_ptr);
// _gpgrt_estream_vsnprintf
// file ../../src/estream-printf.c line 1714
signed int _gpgrt_estream_vsnprintf(char *buf, unsigned long int bufsize, const char *format, void **arg_ptr);
// _gpgrt_fclose
// file ../../src/estream.c line 3389
signed int _gpgrt_fclose(struct _gpgrt__stream *stream);
// _gpgrt_fclose_snatch
// file ../../src/estream.c line 3408
signed int _gpgrt_fclose_snatch(struct _gpgrt__stream *stream, void **r_buffer, unsigned long int *r_buflen);
// _gpgrt_fclose_snatch::1::1::func_ioctl$object
// 
signed int func_ioctl$object(void *, signed int, void *, unsigned long int *);
// _gpgrt_fdopen
// file ../../src/estream.c line 3075
struct _gpgrt__stream * _gpgrt_fdopen(signed int filedes, const char *mode);
// _gpgrt_fdopen_nc
// file ../../src/estream.c line 3082
struct _gpgrt__stream * _gpgrt_fdopen_nc(signed int filedes, const char *mode);
// _gpgrt_feof
// file ../../src/estream.c line 3616
signed int _gpgrt_feof(struct _gpgrt__stream *stream);
// _gpgrt_feof_unlocked
// file ../../src/estream.c line 3609
signed int _gpgrt_feof_unlocked(struct _gpgrt__stream *stream);
// _gpgrt_ferror
// file ../../src/estream.c line 3636
signed int _gpgrt_ferror(struct _gpgrt__stream *stream);
// _gpgrt_ferror_unlocked
// file ../../src/estream.c line 3629
signed int _gpgrt_ferror_unlocked(struct _gpgrt__stream *stream);
// _gpgrt_fflush
// file ../../src/estream.c line 3685
signed int _gpgrt_fflush(struct _gpgrt__stream *stream);
// _gpgrt_fgetc
// file ../../src/estream.c line 3803
signed int _gpgrt_fgetc(struct _gpgrt__stream *stream);
// _gpgrt_fgets
// file ../../src/estream.c line 3925
char * _gpgrt_fgets(char * restrict buffer, signed int length, struct _gpgrt__stream * restrict stream);
// _gpgrt_fileno
// file ../../src/estream.c line 3551
signed int _gpgrt_fileno(struct _gpgrt__stream *stream);
// _gpgrt_fileno_unlocked
// file ../../src/estream.c line 3492
signed int _gpgrt_fileno_unlocked(struct _gpgrt__stream *stream);
// _gpgrt_flockfile
// file ../../src/estream.c line 3530
void _gpgrt_flockfile(struct _gpgrt__stream *stream);
// _gpgrt_fname_get
// file ../../src/estream.c line 4734
const char * _gpgrt_fname_get(struct _gpgrt__stream *stream);
// _gpgrt_fname_set
// file ../../src/estream.c line 4719
void _gpgrt_fname_set(struct _gpgrt__stream *stream, const char *fname);
// _gpgrt_fopen
// file ../../src/estream.c line 2836
struct _gpgrt__stream * _gpgrt_fopen(const char * restrict path, const char * restrict mode);
// _gpgrt_fopencookie
// file ../../src/estream.c line 3003
struct _gpgrt__stream * _gpgrt_fopencookie(void * restrict cookie, const char * restrict mode, struct _gpgrt_cookie_io_functions functions);
// _gpgrt_fopenmem
// file ../../src/estream.c line 2935
struct _gpgrt__stream * _gpgrt_fopenmem(unsigned long int memlimit, const char * restrict mode);
// _gpgrt_fopenmem_init
// file ../../src/estream.c line 2972
struct _gpgrt__stream * _gpgrt_fopenmem_init(unsigned long int memlimit, const char * restrict mode, const void *data, unsigned long int datalen);
// _gpgrt_fpopen
// file ../../src/estream.c line 3137
struct _gpgrt__stream * _gpgrt_fpopen(struct _IO_FILE *fp, const char *mode);
// _gpgrt_fpopen_nc
// file ../../src/estream.c line 3145
struct _gpgrt__stream * _gpgrt_fpopen_nc(struct _IO_FILE *fp, const char *mode);
// _gpgrt_fprintf
// file ../../src/estream.c line 4202
signed int _gpgrt_fprintf(struct _gpgrt__stream * restrict stream, const char * restrict format, ...);
// _gpgrt_fprintf_unlocked
// file ../../src/estream.c line 4187
signed int _gpgrt_fprintf_unlocked(struct _gpgrt__stream * restrict stream, const char * restrict format, ...);
// _gpgrt_fputc
// file ../../src/estream.c line 3816
signed int _gpgrt_fputc(signed int c, struct _gpgrt__stream *stream);
// _gpgrt_fputs
// file ../../src/estream.c line 3967
signed int _gpgrt_fputs(const char * restrict s, struct _gpgrt__stream * restrict stream);
// _gpgrt_fputs_unlocked
// file ../../src/estream.c line 3955
signed int _gpgrt_fputs_unlocked(const char * restrict s, struct _gpgrt__stream * restrict stream);
// _gpgrt_fread
// file ../../src/estream.c line 3883
unsigned long int _gpgrt_fread(void * restrict ptr, unsigned long int size, unsigned long int nitems, struct _gpgrt__stream * restrict stream);
// _gpgrt_free
// file ../../src/init.c line 199
void _gpgrt_free(void *a);
// _gpgrt_freopen
// file ../../src/estream.c line 3320
struct _gpgrt__stream * _gpgrt_freopen(const char * restrict path, const char * restrict mode, struct _gpgrt__stream * restrict stream);
// _gpgrt_fseek
// file ../../src/estream.c line 3715
signed int _gpgrt_fseek(struct _gpgrt__stream *stream, signed long int offset, signed int whence);
// _gpgrt_fseeko
// file ../../src/estream.c line 3728
signed int _gpgrt_fseeko(struct _gpgrt__stream *stream, signed long int offset, signed int whence);
// _gpgrt_ftell
// file ../../src/estream.c line 3741
signed long int _gpgrt_ftell(struct _gpgrt__stream *stream);
// _gpgrt_ftello
// file ../../src/estream.c line 3754
signed long int _gpgrt_ftello(struct _gpgrt__stream *stream);
// _gpgrt_ftrylockfile
// file ../../src/estream.c line 3537
signed int _gpgrt_ftrylockfile(struct _gpgrt__stream *stream);
// _gpgrt_funlockfile
// file ../../src/estream.c line 3544
void _gpgrt_funlockfile(struct _gpgrt__stream *stream);
// _gpgrt_fwrite
// file ../../src/estream.c line 3904
unsigned long int _gpgrt_fwrite(const void * restrict ptr, unsigned long int size, unsigned long int nitems, struct _gpgrt__stream * restrict stream);
// _gpgrt_get_nonblock
// file ../../src/estream.c line 4473
signed int _gpgrt_get_nonblock(struct _gpgrt__stream *stream);
// _gpgrt_get_std_stream
// file ../../src/visibility.c line 277
struct _gpgrt__stream * _gpgrt_get_std_stream(signed int fd);
// _gpgrt_getc_underflow
// file ../../src/visibility.c line 391
signed int _gpgrt_getc_underflow(struct _gpgrt__stream *stream);
// _gpgrt_getline
// file ../../src/estream.c line 3982
signed long int _gpgrt_getline(char * restrict * restrict lineptr, unsigned long int * restrict n, struct _gpgrt__stream * restrict stream);
// _gpgrt_lock_destroy
// file ../../src/posix-lock.c line 237
enum anonymous$4 _gpgrt_lock_destroy(struct anonymous$5 *lockhd);
// _gpgrt_lock_init
// file ../../src/posix-lock.c line 128
enum anonymous$4 _gpgrt_lock_init(struct anonymous$5 *lockhd);
// _gpgrt_lock_lock
// file ../../src/posix-lock.c line 166
enum anonymous$4 _gpgrt_lock_lock(struct anonymous$5 *lockhd);
// _gpgrt_lock_trylock
// file ../../src/posix-lock.c line 189
enum anonymous$4 _gpgrt_lock_trylock(struct anonymous$5 *lockhd);
// _gpgrt_lock_unlock
// file ../../src/posix-lock.c line 212
enum anonymous$4 _gpgrt_lock_unlock(struct anonymous$5 *lockhd);
// _gpgrt_malloc
// file ../../src/init.c line 189
void * _gpgrt_malloc(unsigned long int n);
// _gpgrt_mopen
// file ../../src/estream.c line 2896
struct _gpgrt__stream * _gpgrt_mopen(void * restrict data, unsigned long int data_n, unsigned long int data_len, unsigned int grow, void * (*func_realloc)(void *, unsigned long int), void (*func_free)(void *), const char * restrict mode);
// _gpgrt_mopen::func_free$object
// 
void func_free$object(void *);
// _gpgrt_mopen::func_realloc$object
// 
void * func_realloc$object(void *, unsigned long int);
// _gpgrt_onclose
// file ../../src/estream.c line 3478
signed int _gpgrt_onclose(struct _gpgrt__stream *stream, signed int mode, void (*fnc)(struct _gpgrt__stream *, void *), void *fnc_value);
// _gpgrt_onclose::fnc$object
// 
void fnc$object(struct _gpgrt__stream *, void *);
// _gpgrt_opaque_get
// file ../../src/estream.c line 4679
void * _gpgrt_opaque_get(struct _gpgrt__stream *stream);
// _gpgrt_opaque_set
// file ../../src/estream.c line 4670
void _gpgrt_opaque_set(struct _gpgrt__stream *stream, void *opaque);
// _gpgrt_pending
// file ../../src/visibility.c line 301
signed int _gpgrt_pending(struct _gpgrt__stream *stream);
// _gpgrt_pending_unlocked
// file ../../src/visibility.c line 307
signed int _gpgrt_pending_unlocked(struct _gpgrt__stream *stream);
// _gpgrt_poll
// file ../../src/estream.c line 4496
signed int _gpgrt_poll(struct _gpgrt_poll_s *fds, unsigned int nfds, signed int timeout);
// _gpgrt_putc_overflow
// file ../../src/visibility.c line 403
signed int _gpgrt_putc_overflow(signed int c, struct _gpgrt__stream *stream);
// _gpgrt_read
// file ../../src/estream.c line 3843
signed int _gpgrt_read(struct _gpgrt__stream * restrict stream, void * restrict buffer, unsigned long int bytes_to_read, unsigned long int * restrict bytes_read);
// _gpgrt_read_line
// file ../../src/estream.c line 4066
signed long int _gpgrt_read_line(struct _gpgrt__stream *stream, char **addr_of_buffer, unsigned long int *length_of_buffer, unsigned long int *max_length);
// _gpgrt_realloc
// file ../../src/init.c line 169
void * _gpgrt_realloc(void *a, unsigned long int n);
// _gpgrt_rewind
// file ../../src/estream.c line 3767
void _gpgrt_rewind(struct _gpgrt__stream *stream);
// _gpgrt_set_alloc_func
// file ../../src/init.c line 161
void _gpgrt_set_alloc_func(void * (*f)(void *, unsigned long int));
// _gpgrt_set_alloc_func::f$object
// 
void * f$object(void *, unsigned long int);
// _gpgrt_set_binary
// file ../../src/estream.c line 4394
void _gpgrt_set_binary(struct _gpgrt__stream *stream);
// _gpgrt_set_nonblock
// file ../../src/estream.c line 4440
signed int _gpgrt_set_nonblock(struct _gpgrt__stream *stream, signed int onoff);
// _gpgrt_set_nonblock::1::func_ioctl$object
// 
signed int func_ioctl$object(void *, signed int, void *, unsigned long int *);
// _gpgrt_set_std_fd
// file ../../src/visibility.c line 271
void _gpgrt_set_std_fd(signed int no, signed int fd);
// _gpgrt_set_syscall_clamp
// file ../../src/estream.c line 552
void _gpgrt_set_syscall_clamp(void (*pre)(void), void (*post)(void));
// _gpgrt_set_syscall_clamp::post$object
// 
void post$object(void);
// _gpgrt_set_syscall_clamp::pre$object
// 
void pre$object(void);
// _gpgrt_setvbuf
// file ../../src/estream.c line 4367
signed int _gpgrt_setvbuf(struct _gpgrt__stream * restrict stream, char * restrict buf, signed int type, unsigned long int size);
// _gpgrt_syshd
// file ../../src/estream.c line 3568
signed int _gpgrt_syshd(struct _gpgrt__stream *stream, struct _gpgrt_syshd *syshd);
// _gpgrt_syshd_unlocked
// file ../../src/estream.c line 3514
signed int _gpgrt_syshd_unlocked(struct _gpgrt__stream *stream, struct _gpgrt_syshd *syshd);
// _gpgrt_sysopen
// file ../../src/estream.c line 3218
struct _gpgrt__stream * _gpgrt_sysopen(struct _gpgrt_syshd *syshd, const char *mode);
// _gpgrt_sysopen_nc
// file ../../src/estream.c line 3226
struct _gpgrt__stream * _gpgrt_sysopen_nc(struct _gpgrt_syshd *syshd, const char *mode);
// _gpgrt_tmpfile
// file ../../src/estream.c line 4320
struct _gpgrt__stream * _gpgrt_tmpfile(void);
// _gpgrt_ungetc
// file ../../src/estream.c line 3829
signed int _gpgrt_ungetc(signed int c, struct _gpgrt__stream *stream);
// _gpgrt_vfprintf
// file ../../src/estream.c line 4172
signed int _gpgrt_vfprintf(struct _gpgrt__stream * restrict stream, const char * restrict format, void **ap);
// _gpgrt_vfprintf_unlocked
// file ../../src/estream.c line 4163
signed int _gpgrt_vfprintf_unlocked(struct _gpgrt__stream * restrict stream, const char * restrict format, void **ap);
// _gpgrt_write
// file ../../src/estream.c line 3863
signed int _gpgrt_write(struct _gpgrt__stream * restrict stream, const void * restrict buffer, unsigned long int bytes_to_write, unsigned long int * restrict bytes_written);
// _gpgrt_write_hexstring
// file ../../src/estream.c line 4832
signed int _gpgrt_write_hexstring(struct _gpgrt__stream * restrict stream, const void * restrict buffer, unsigned long int length, signed int reserved, unsigned long int * restrict bytes_written);
// _gpgrt_write_sanitized
// file ../../src/estream.c line 4756
signed int _gpgrt_write_sanitized(struct _gpgrt__stream * restrict stream, const void * restrict buffer, unsigned long int length, const char *delimiters, unsigned long int * restrict bytes_written);
// _gpgrt_yield
// file ../../src/posix-thread.c line 48
enum anonymous$4 _gpgrt_yield(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accountant_thread
// file ../../tests/t-lock.c line 162
static void * accountant_thread(void *arg);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_accounts
// file ../../tests/t-lock.c line 86
static void check_accounts(void);
// check_pending
// file ../../src/estream.c line 2224
static signed int check_pending(struct _gpgrt__stream * restrict stream);
// check_pending_fbf
// file ../../src/estream.c line 2125
static signed int check_pending_fbf(struct _gpgrt__stream * restrict stream);
// check_pending_fbf::1::func_read$object
// 
signed long int func_read$object(void *, void *, unsigned long int);
// check_pending_nbf
// file ../../src/estream.c line 2062
static signed int check_pending_nbf(struct _gpgrt__stream * restrict stream);
// check_pending_nbf::1::func_read$object
// 
signed long int func_read$object(void *, void *, unsigned long int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// compare_versions
// file ../../src/version.c line 82
static const char * compare_versions(const char *my_version, const char *req_version);
// compute_type
// file ../../src/estream-printf.c line 355
static void compute_type(struct argspec_s *arg);
// cright_blurb
// file ../../src/version.c line 37
static const char * cright_blurb(void);
// custom_realloc$object
// 
void * custom_realloc$object(void *, unsigned long int);
// destroy_stream_lock
// file ../../src/estream.c line 365
static void destroy_stream_lock(struct _gpgrt__stream * restrict stream);
// dgettext
// file /usr/include/libintl.h line 44
extern char * dgettext(const char *, const char *);
// die
// file ../../tests/t-common.h line 38
static void die(const char *format, ...);
// do_close
// file ../../src/estream.c line 1964
static signed int do_close(struct _gpgrt__stream *stream, signed int with_locked_list);
// do_deinit
// file ../../src/estream.c line 506
static void do_deinit(void);
// do_fdopen
// file ../../src/estream.c line 3033
static struct _gpgrt__stream * do_fdopen(signed int filedes, const char *mode, signed int no_close, signed int with_locked_list);
// do_fflush
// file ../../src/estream.c line 3668
static signed int do_fflush(struct _gpgrt__stream *stream);
// do_format
// file ../../src/estream-printf.c line 1347
static signed int do_format(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, const char *format, struct argspec_s *argspecs, unsigned long int argspecs_len, struct valueitem_s *valuetable, signed int myerrno, unsigned long int *nbytes);
// do_format::outfnc$object
// 
signed int outfnc$object(void *, const char *, unsigned long int);
// do_fpopen
// file ../../src/estream.c line 3090
static struct _gpgrt__stream * do_fpopen(struct _IO_FILE *fp, const char *mode, signed int no_close, signed int with_locked_list);
// do_list_add
// file ../../src/estream.c line 456
static signed int do_list_add(struct _gpgrt__stream *stream, signed int with_locked_list);
// do_list_remove
// file ../../src/estream.c line 485
static void do_list_remove(struct _gpgrt__stream *stream, signed int with_locked_list);
// do_onclose
// file ../../src/estream.c line 1995
static signed int do_onclose(struct _gpgrt__stream *stream, signed int mode, void (*fnc)(struct _gpgrt__stream *, void *), void *fnc_value);
// do_onclose::fnc$object
// 
void fnc$object(struct _gpgrt__stream *, void *);
// do_sysopen
// file ../../src/estream.c line 3188
static struct _gpgrt__stream * do_sysopen(struct _gpgrt_syshd *syshd, const char *mode, signed int no_close);
// doreadline
// file ../../src/estream.c line 2586
static signed int doreadline(struct _gpgrt__stream * restrict stream, unsigned long int max_length, char * restrict * restrict line, unsigned long int * restrict line_length);
// dup
// file /usr/include/unistd.h line 531
extern signed int dup(signed int);
// dynamic_buffer_out
// file ../../src/estream-printf.c line 1765
static signed int dynamic_buffer_out(void *outfncarg, const char *buf, unsigned long int buflen);
// es_create
// file ../../src/estream.c line 1906
static signed int es_create(struct _gpgrt__stream **stream, void *cookie, struct _gpgrt_syshd *syshd, struct _gpgrt_cookie_io_functions functions, unsigned int modeflags, signed int samethread, signed int with_locked_list);
// es_deinitialize
// file ../../src/estream.c line 1878
static signed int es_deinitialize(struct _gpgrt__stream *stream);
// es_deinitialize::1::func_close$object
// 
signed int func_close$object(void *);
// es_empty
// file ../../src/estream.c line 1824
static void es_empty(struct _gpgrt__stream *stream);
// es_fill
// file ../../src/estream.c line 1690
static signed int es_fill(struct _gpgrt__stream *stream);
// es_fill::1::2::func_read$object
// 
signed long int func_read$object(void *, void *, unsigned long int);
// es_flush
// file ../../src/estream.c line 1745
static signed int es_flush(struct _gpgrt__stream *stream);
// es_flush::1::func_write$object
// 
signed long int func_write$object(void *, const void *, unsigned long int);
// es_func_fd_destroy
// file ../../src/estream.c line 1051
static signed int es_func_fd_destroy(void *cookie);
// es_func_fd_ioctl
// file ../../src/estream.c line 1010
static signed int es_func_fd_ioctl(void *cookie, signed int cmd, void *ptr, unsigned long int *len);
// es_func_fd_read
// file ../../src/estream.c line 917
static signed long int es_func_fd_read(void *cookie, void *buffer, unsigned long int size);
// es_func_fd_seek
// file ../../src/estream.c line 978
static signed int es_func_fd_seek(void *cookie, signed long int *offset, signed int whence);
// es_func_fd_write
// file ../../src/estream.c line 948
static signed long int es_func_fd_write(void *cookie, const void *buffer, unsigned long int size);
// es_func_fp_destroy
// file ../../src/estream.c line 1453
static signed int es_func_fp_destroy(void *cookie);
// es_func_fp_read
// file ../../src/estream.c line 1341
static signed long int es_func_fp_read(void *cookie, void *buffer, unsigned long int size);
// es_func_fp_seek
// file ../../src/estream.c line 1416
static signed int es_func_fp_seek(void *cookie, signed long int *offset, signed int whence);
// es_func_fp_write
// file ../../src/estream.c line 1367
static signed long int es_func_fp_write(void *cookie, const void *buffer, unsigned long int size);
// es_func_mem_destroy
// file ../../src/estream.c line 855
static signed int es_func_mem_destroy(void *cookie);
// es_func_mem_ioctl
// file ../../src/estream.c line 827
static signed int es_func_mem_ioctl(void *cookie, signed int cmd, void *ptr, unsigned long int *len);
// es_func_mem_read
// file ../../src/estream.c line 642
static signed long int es_func_mem_read(void *cookie, void *buffer, unsigned long int size);
// es_func_mem_seek
// file ../../src/estream.c line 752
static signed int es_func_mem_seek(void *cookie, signed long int *offset, signed int whence);
// es_func_mem_write
// file ../../src/estream.c line 666
static signed long int es_func_mem_write(void *cookie, const void *buffer, unsigned long int size);
// es_offset_calculate
// file ../../src/estream.c line 2806
static signed long int es_offset_calculate(struct _gpgrt__stream *stream);
// es_opaque_ctrl
// file ../../src/estream.c line 2822
static void es_opaque_ctrl(struct _gpgrt__stream * restrict stream, void * restrict opaque_new, void ** restrict opaque_old);
// es_peek
// file ../../src/estream.c line 2529
static signed int es_peek(struct _gpgrt__stream * restrict stream, unsigned char ** restrict data, unsigned long int * restrict data_len);
// es_print
// file ../../src/estream.c line 2732
static signed int es_print(struct _gpgrt__stream * restrict stream, const char * restrict format, void **ap);
// es_read_fbf
// file ../../src/estream.c line 2077
static signed int es_read_fbf(struct _gpgrt__stream * restrict stream, unsigned char * restrict buffer, unsigned long int bytes_to_read, unsigned long int * restrict bytes_read);
// es_read_lbf
// file ../../src/estream.c line 2147
static signed int es_read_lbf(struct _gpgrt__stream * restrict stream, unsigned char * restrict buffer, unsigned long int bytes_to_read, unsigned long int * restrict bytes_read);
// es_read_nbf
// file ../../src/estream.c line 2024
static signed int es_read_nbf(struct _gpgrt__stream * restrict stream, unsigned char * restrict buffer, unsigned long int bytes_to_read, unsigned long int * restrict bytes_read);
// es_read_nbf::1::func_read$object
// 
signed long int func_read$object(void *, void *, unsigned long int);
// es_readn
// file ../../src/estream.c line 2161
static signed int es_readn(struct _gpgrt__stream * restrict stream, void * restrict buffer_arg, unsigned long int bytes_to_read, unsigned long int * restrict bytes_read);
// es_seek
// file ../../src/estream.c line 2280
static signed int es_seek(struct _gpgrt__stream * restrict stream, signed long int offset, signed int whence, signed long int * restrict offset_new);
// es_seek::1::func_seek$object
// 
signed int func_seek$object(void *, signed long int *, signed int);
// es_set_buffering
// file ../../src/estream.c line 2746
static signed int es_set_buffering(struct _gpgrt__stream * restrict stream, char * restrict buffer, signed int mode, unsigned long int size);
// es_skip
// file ../../src/estream.c line 2566
static signed int es_skip(struct _gpgrt__stream *stream, unsigned long int size);
// es_unreadn
// file ../../src/estream.c line 2254
static void es_unreadn(struct _gpgrt__stream * restrict stream, const unsigned char * restrict data, unsigned long int data_n, unsigned long int * restrict bytes_unread);
// es_write_fbf
// file ../../src/estream.c line 2395
static signed int es_write_fbf(struct _gpgrt__stream * restrict stream, const unsigned char * restrict buffer, unsigned long int bytes_to_write, unsigned long int * restrict bytes_written);
// es_write_lbf
// file ../../src/estream.c line 2439
static signed int es_write_lbf(struct _gpgrt__stream * restrict stream, const unsigned char * restrict buffer, unsigned long int bytes_to_write, unsigned long int * restrict bytes_written);
// es_write_nbf
// file ../../src/estream.c line 2347
static signed int es_write_nbf(struct _gpgrt__stream * restrict stream, const unsigned char * restrict buffer, unsigned long int bytes_to_write, unsigned long int * restrict bytes_written);
// es_write_nbf::1::func_write$object
// 
signed long int func_write$object(void *, const void *, unsigned long int);
// es_writen
// file ../../src/estream.c line 2473
static signed int es_writen(struct _gpgrt__stream * restrict stream, const void * restrict buffer, unsigned long int bytes_to_write, unsigned long int * restrict bytes_written);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fail
// file ../../tests/t-common.h line 60
static void fail(const char *format, ...);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// fixed_buffer_out
// file ../../src/estream-printf.c line 1686
static signed int fixed_buffer_out(void *outfncarg, const char *buf, unsigned long int buflen);
// flockfile
// file /usr/include/stdio.h line 912
extern void flockfile(struct _IO_FILE *);
// fname_set_internal
// file ../../src/estream.c line 4692
static void fname_set_internal(struct _gpgrt__stream *stream, const char *fname, signed int quote);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// func_fd_create
// file ../../src/estream.c line 890
static signed int func_fd_create(void **cookie, signed int fd, unsigned int modeflags, signed int no_close);
// func_file_create
// file ../../src/estream.c line 1495
static signed int func_file_create(void **cookie, signed int *filedes, const char *path, unsigned int modeflags, unsigned int cmode);
// func_fp_create
// file ../../src/estream.c line 1312
static signed int func_fp_create(void **cookie, struct _IO_FILE *fp, unsigned int modeflags, signed int no_close);
// func_mem_create
// file ../../src/estream.c line 594
static signed int func_mem_create(void * restrict * restrict cookie, unsigned char * restrict data, unsigned long int data_n, unsigned long int data_len, unsigned long int block_size, unsigned int grow, void * (*func_realloc)(void *, unsigned long int), void (*func_free)(void *), unsigned int modeflags, unsigned long int memory_limit);
// func_mem_create::func_free$object
// 
void func_free$object(void *);
// func_mem_create::func_realloc$object
// 
void * func_realloc$object(void *, unsigned long int);
// funlockfile
// file /usr/include/stdio.h line 919
extern void funlockfile(struct _IO_FILE *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// get_lock_object
// file ../../src/posix-lock.c line 108
static struct anonymous$10 * get_lock_object(struct anonymous$5 *lockhd);
// get_rand
// file ../../tests/t-lock.c line 111
static unsigned int get_rand(signed int high);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gpg_err_code
// file ./gpg-error.h line 849
static inline enum anonymous$4 gpg_err_code(unsigned int err);
// gpg_err_code_from_errno
// file ./gpg-error.h line 889
enum anonymous$4 gpg_err_code_from_errno(signed int err);
// gpg_err_code_from_syserror
// file ../../src/visibility.c line 57
enum anonymous$4 gpg_err_code_from_syserror(void);
// gpg_err_code_to_errno
// file ./gpg-error.h line 894
signed int gpg_err_code_to_errno(enum anonymous$4 code);
// gpg_err_deinit
// file ../../src/visibility.c line 76
void gpg_err_deinit(signed int mode);
// gpg_err_init
// file ../../src/visibility.c line 70
unsigned int gpg_err_init(void);
// gpg_err_set_errno
// file ../../src/visibility.c line 63
void gpg_err_set_errno(signed int err);
// gpg_err_source
// file ./gpg-error.h line 857
static inline enum anonymous$2 gpg_err_source(unsigned int err);
// gpg_error_check_version
// file ./../src/gpg-error.h line 909
const char * gpg_error_check_version(const char *req_version);
// gpg_strerror
// file ./../src/gpg-error.h line 868
const char * gpg_strerror(unsigned int err);
// gpg_strerror_r
// file ../../src/visibility.c line 33
signed int gpg_strerror_r(unsigned int err, char *buf, unsigned long int buflen);
// gpg_strsource
// file ../../src/visibility.c line 39
const char * gpg_strsource(unsigned int err);
// gpgrt_asprintf
// file ../../src/visibility.c line 644
signed int gpgrt_asprintf(char **r_buf, const char * restrict format, ...);
// gpgrt_bsprintf
// file ../../src/visibility.c line 663
char * gpgrt_bsprintf(const char * restrict format, ...);
// gpgrt_check_version
// file ../../src/visibility.c line 88
const char * gpgrt_check_version(const char *req_version);
// gpgrt_clearerr
// file ../../src/visibility.c line 337
void gpgrt_clearerr(struct _gpgrt__stream *stream);
// gpgrt_clearerr_unlocked
// file ../../src/visibility.c line 343
void gpgrt_clearerr_unlocked(struct _gpgrt__stream *stream);
// gpgrt_fclose
// file ../../src/visibility.c line 228
signed int gpgrt_fclose(struct _gpgrt__stream *stream);
// gpgrt_fclose_snatch
// file ../../src/visibility.c line 234
signed int gpgrt_fclose_snatch(struct _gpgrt__stream *stream, void **r_buffer, unsigned long int *r_buflen);
// gpgrt_fdopen
// file ../../src/visibility.c line 176
struct _gpgrt__stream * gpgrt_fdopen(signed int filedes, const char *mode);
// gpgrt_fdopen_nc
// file ../../src/visibility.c line 182
struct _gpgrt__stream * gpgrt_fdopen_nc(signed int filedes, const char *mode);
// gpgrt_feof
// file ../../src/visibility.c line 313
signed int gpgrt_feof(struct _gpgrt__stream *stream);
// gpgrt_feof_unlocked
// file ../../src/visibility.c line 319
signed int gpgrt_feof_unlocked(struct _gpgrt__stream *stream);
// gpgrt_ferror
// file ../../src/visibility.c line 325
signed int gpgrt_ferror(struct _gpgrt__stream *stream);
// gpgrt_ferror_unlocked
// file ../../src/visibility.c line 331
signed int gpgrt_ferror_unlocked(struct _gpgrt__stream *stream);
// gpgrt_fflush
// file ../../src/visibility.c line 349
signed int gpgrt_fflush(struct _gpgrt__stream *stream);
// gpgrt_fgetc
// file ../../src/visibility.c line 385
signed int gpgrt_fgetc(struct _gpgrt__stream *stream);
// gpgrt_fgets
// file ../../src/visibility.c line 464
char * gpgrt_fgets(char * restrict buffer, signed int length, struct _gpgrt__stream * restrict stream);
// gpgrt_fileno
// file ../../src/visibility.c line 247
signed int gpgrt_fileno(struct _gpgrt__stream *stream);
// gpgrt_fileno_unlocked
// file ../../src/visibility.c line 253
signed int gpgrt_fileno_unlocked(struct _gpgrt__stream *stream);
// gpgrt_flockfile
// file ../../src/visibility.c line 283
void gpgrt_flockfile(struct _gpgrt__stream *stream);
// gpgrt_fname_get
// file ../../src/visibility.c line 638
const char * gpgrt_fname_get(struct _gpgrt__stream *stream);
// gpgrt_fname_set
// file ../../src/visibility.c line 632
void gpgrt_fname_set(struct _gpgrt__stream *stream, const char *fname);
// gpgrt_fopen
// file ../../src/visibility.c line 145
struct _gpgrt__stream * gpgrt_fopen(const char * restrict path, const char * restrict mode);
// gpgrt_fopencookie
// file ../../src/visibility.c line 220
struct _gpgrt__stream * gpgrt_fopencookie(void * restrict cookie, const char * restrict mode, struct _gpgrt_cookie_io_functions functions);
// gpgrt_fopenmem
// file ../../src/visibility.c line 163
struct _gpgrt__stream * gpgrt_fopenmem(unsigned long int memlimit, const char * restrict mode);
// gpgrt_fopenmem_init
// file ../../src/visibility.c line 169
struct _gpgrt__stream * gpgrt_fopenmem_init(unsigned long int memlimit, const char * restrict mode, const void *data, unsigned long int datalen);
// gpgrt_fpopen
// file ../../src/visibility.c line 200
struct _gpgrt__stream * gpgrt_fpopen(struct _IO_FILE *fp, const char *mode);
// gpgrt_fpopen_nc
// file ../../src/visibility.c line 206
struct _gpgrt__stream * gpgrt_fpopen_nc(struct _IO_FILE *fp, const char *mode);
// gpgrt_fprintf
// file ../../src/visibility.c line 549
signed int gpgrt_fprintf(struct _gpgrt__stream * restrict stream, const char * restrict format, ...);
// gpgrt_fprintf_unlocked
// file ../../src/visibility.c line 563
signed int gpgrt_fprintf_unlocked(struct _gpgrt__stream * restrict stream, const char * restrict format, ...);
// gpgrt_fputc
// file ../../src/visibility.c line 397
signed int gpgrt_fputc(signed int c, struct _gpgrt__stream *stream);
// gpgrt_fputs
// file ../../src/visibility.c line 471
signed int gpgrt_fputs(const char * restrict s, struct _gpgrt__stream * restrict stream);
// gpgrt_fputs_unlocked
// file ../../src/visibility.c line 477
signed int gpgrt_fputs_unlocked(const char * restrict s, struct _gpgrt__stream * restrict stream);
// gpgrt_fread
// file ../../src/visibility.c line 450
unsigned long int gpgrt_fread(void * restrict ptr, unsigned long int size, unsigned long int nitems, struct _gpgrt__stream * restrict stream);
// gpgrt_free
// file ../../src/visibility.c line 500
void gpgrt_free(void *a);
// gpgrt_freopen
// file ../../src/visibility.c line 212
struct _gpgrt__stream * gpgrt_freopen(const char * restrict path, const char * restrict mode, struct _gpgrt__stream * restrict stream);
// gpgrt_fseek
// file ../../src/visibility.c line 355
signed int gpgrt_fseek(struct _gpgrt__stream *stream, signed long int offset, signed int whence);
// gpgrt_fseeko
// file ../../src/visibility.c line 361
signed int gpgrt_fseeko(struct _gpgrt__stream *stream, signed long int offset, signed int whence);
// gpgrt_ftell
// file ../../src/visibility.c line 367
signed long int gpgrt_ftell(struct _gpgrt__stream *stream);
// gpgrt_ftello
// file ../../src/visibility.c line 373
signed long int gpgrt_ftello(struct _gpgrt__stream *stream);
// gpgrt_ftrylockfile
// file ../../src/visibility.c line 289
signed int gpgrt_ftrylockfile(struct _gpgrt__stream *stream);
// gpgrt_funlockfile
// file ../../src/visibility.c line 295
void gpgrt_funlockfile(struct _gpgrt__stream *stream);
// gpgrt_fwrite
// file ../../src/visibility.c line 457
unsigned long int gpgrt_fwrite(const void * restrict ptr, unsigned long int size, unsigned long int nitems, struct _gpgrt__stream * restrict stream);
// gpgrt_get_nonblock
// file ../../src/visibility.c line 602
signed int gpgrt_get_nonblock(struct _gpgrt__stream *stream);
// gpgrt_getline
// file ../../src/visibility.c line 484
signed long int gpgrt_getline(char * restrict * restrict lineptr, unsigned long int * restrict n, struct _gpgrt__stream * restrict stream);
// gpgrt_lock_destroy
// file ./../src/gpg-error.h line 972
enum anonymous$4 gpgrt_lock_destroy(struct anonymous$5 *lockhd);
// gpgrt_lock_init
// file ./../src/gpg-error.h line 968
enum anonymous$4 gpgrt_lock_init(struct anonymous$5 *lockhd);
// gpgrt_lock_lock
// file ./../src/gpg-error.h line 969
enum anonymous$4 gpgrt_lock_lock(struct anonymous$5 *lockhd);
// gpgrt_lock_trylock
// file ../../src/visibility.c line 119
enum anonymous$4 gpgrt_lock_trylock(struct anonymous$5 *lockhd);
// gpgrt_lock_unlock
// file ./../src/gpg-error.h line 971
enum anonymous$4 gpgrt_lock_unlock(struct anonymous$5 *lockhd);
// gpgrt_mopen
// file ../../src/visibility.c line 152
struct _gpgrt__stream * gpgrt_mopen(void * restrict data, unsigned long int data_n, unsigned long int data_len, unsigned int grow, void * (*func_realloc)(void *, unsigned long int), void (*func_free)(void *), const char * restrict mode);
// gpgrt_mopen::func_free$object
// 
void func_free$object(void *);
// gpgrt_mopen::func_realloc$object
// 
void * func_realloc$object(void *, unsigned long int);
// gpgrt_onclose
// file ../../src/visibility.c line 240
signed int gpgrt_onclose(struct _gpgrt__stream *stream, signed int mode, void (*fnc)(struct _gpgrt__stream *, void *), void *fnc_value);
// gpgrt_onclose::fnc$object
// 
void fnc$object(struct _gpgrt__stream *, void *);
// gpgrt_opaque_get
// file ../../src/visibility.c line 626
void * gpgrt_opaque_get(struct _gpgrt__stream *stream);
// gpgrt_opaque_set
// file ../../src/visibility.c line 620
void gpgrt_opaque_set(struct _gpgrt__stream *stream, void *opaque);
// gpgrt_poll
// file ../../src/visibility.c line 608
signed int gpgrt_poll(struct _gpgrt_poll_s *fds, unsigned int nfds, signed int timeout);
// gpgrt_printf
// file ../../src/visibility.c line 523
signed int gpgrt_printf(const char * restrict format, ...);
// gpgrt_printf_unlocked
// file ../../src/visibility.c line 536
signed int gpgrt_printf_unlocked(const char * restrict format, ...);
// gpgrt_read
// file ../../src/visibility.c line 415
signed int gpgrt_read(struct _gpgrt__stream * restrict stream, void * restrict buffer, unsigned long int bytes_to_read, unsigned long int * restrict bytes_read);
// gpgrt_read_line
// file ../../src/visibility.c line 491
signed long int gpgrt_read_line(struct _gpgrt__stream *stream, char **addr_of_buffer, unsigned long int *length_of_buffer, unsigned long int *max_length);
// gpgrt_rewind
// file ../../src/visibility.c line 379
void gpgrt_rewind(struct _gpgrt__stream *stream);
// gpgrt_set_alloc_func
// file ../../src/visibility.c line 100
void gpgrt_set_alloc_func(void * (*f)(void *, unsigned long int));
// gpgrt_set_alloc_func::f$object
// 
void * f$object(void *, unsigned long int);
// gpgrt_set_binary
// file ../../src/visibility.c line 590
void gpgrt_set_binary(struct _gpgrt__stream *stream);
// gpgrt_set_nonblock
// file ../../src/visibility.c line 596
signed int gpgrt_set_nonblock(struct _gpgrt__stream *stream, signed int onoff);
// gpgrt_set_syscall_clamp
// file ../../src/visibility.c line 94
void gpgrt_set_syscall_clamp(void (*pre)(void), void (*post)(void));
// gpgrt_set_syscall_clamp::post$object
// 
void post$object(void);
// gpgrt_set_syscall_clamp::pre$object
// 
void pre$object(void);
// gpgrt_setbuf
// file ../../src/visibility.c line 584
void gpgrt_setbuf(struct _gpgrt__stream * restrict stream, char * restrict buf);
// gpgrt_setvbuf
// file ../../src/visibility.c line 577
signed int gpgrt_setvbuf(struct _gpgrt__stream * restrict stream, char * restrict buf, signed int type, unsigned long int size);
// gpgrt_snprintf
// file ../../src/visibility.c line 690
signed int gpgrt_snprintf(char *buf, unsigned long int bufsize, const char *format, ...);
// gpgrt_syshd
// file ../../src/visibility.c line 259
signed int gpgrt_syshd(struct _gpgrt__stream *stream, struct _gpgrt_syshd *syshd);
// gpgrt_syshd_unlocked
// file ../../src/visibility.c line 265
signed int gpgrt_syshd_unlocked(struct _gpgrt__stream *stream, struct _gpgrt_syshd *syshd);
// gpgrt_sysopen
// file ../../src/visibility.c line 188
struct _gpgrt__stream * gpgrt_sysopen(struct _gpgrt_syshd *syshd, const char *mode);
// gpgrt_sysopen_nc
// file ../../src/visibility.c line 194
struct _gpgrt__stream * gpgrt_sysopen_nc(struct _gpgrt_syshd *syshd, const char *mode);
// gpgrt_tmpfile
// file ../../src/visibility.c line 614
struct _gpgrt__stream * gpgrt_tmpfile(void);
// gpgrt_ungetc
// file ../../src/visibility.c line 409
signed int gpgrt_ungetc(signed int c, struct _gpgrt__stream *stream);
// gpgrt_vasprintf
// file ../../src/visibility.c line 657
signed int gpgrt_vasprintf(char **r_buf, const char * restrict format, void **ap);
// gpgrt_vbsprintf
// file ../../src/visibility.c line 678
char * gpgrt_vbsprintf(const char * restrict format, void **ap);
// gpgrt_vfprintf
// file ../../src/visibility.c line 507
signed int gpgrt_vfprintf(struct _gpgrt__stream * restrict stream, const char * restrict format, void **ap);
// gpgrt_vfprintf_unlocked
// file ../../src/visibility.c line 515
signed int gpgrt_vfprintf_unlocked(struct _gpgrt__stream * restrict stream, const char * restrict format, void **ap);
// gpgrt_vsnprintf
// file ../../src/visibility.c line 703
signed int gpgrt_vsnprintf(char *buf, unsigned long int bufsize, const char *format, void **arg_ptr);
// gpgrt_write
// file ../../src/visibility.c line 423
signed int gpgrt_write(struct _gpgrt__stream * restrict stream, const void * restrict buffer, unsigned long int bytes_to_write, unsigned long int * restrict bytes_written);
// gpgrt_write_hexstring
// file ../../src/visibility.c line 441
signed int gpgrt_write_hexstring(struct _gpgrt__stream * restrict stream, const void * restrict buffer, unsigned long int length, signed int reserved, unsigned long int * restrict bytes_written);
// gpgrt_write_sanitized
// file ../../src/visibility.c line 431
signed int gpgrt_write_sanitized(struct _gpgrt__stream * restrict stream, const void * restrict buffer, unsigned long int length, const char *delimiters, unsigned long int * restrict bytes_written);
// gpgrt_yield
// file ./../src/gpg-error.h line 978
enum anonymous$4 gpgrt_yield(void);
// init_accounts
// file ../../tests/t-lock.c line 75
static void init_accounts(void);
// init_stream_lock
// file ../../src/estream.c line 347
static signed int init_stream_lock(struct _gpgrt__stream * restrict stream);
// init_stream_obj
// file ../../src/estream.c line 1834
static void init_stream_obj(struct _gpgrt__stream *stream, void *cookie, struct _gpgrt_syshd *syshd, struct _gpgrt_cookie_io_functions functions, unsigned int modeflags, signed int samethread);
// lock_list
// file ../../src/estream.c line 418
static void lock_list(void);
// lock_stream
// file ../../src/estream.c line 377
static void lock_stream(struct _gpgrt__stream * restrict stream);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mem_alloc
// file ../../src/estream.c line 265
static void * mem_alloc(unsigned long int n);
// mem_free
// file ../../src/estream.c line 277
static void mem_free(void *p);
// mem_realloc
// file ../../src/estream.c line 271
static void * mem_realloc(void *p, unsigned long int n);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memrchr
// file /usr/include/string.h line 121
extern void * memrchr(const void *, signed int, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// msgidxof
// file ../../src/err-sources.h line 80
static inline signed int msgidxof(signed int code);
// msgidxof$link1
// file ../../src/err-codes.h line 788
static inline signed int msgidxof$link1(signed int code$link1);
// nl_langinfo
// file /usr/include/langinfo.h line 583
extern char * nl_langinfo(signed int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// pad_out
// file ../../src/estream-printf.c line 823
static signed int pad_out(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, signed int padchar, signed int count, unsigned long int *nbytes);
// pad_out::outfnc$object
// 
signed int outfnc$object(void *, const char *, unsigned long int);
// parse_format
// file ../../src/estream-printf.c line 453
static signed int parse_format(const char *format, struct argspec_s **argspecs_addr, unsigned long int max_argspecs, unsigned long int *r_argspecs_count);
// parse_mode
// file ../../src/estream.c line 1572
static signed int parse_mode(const char *modestr, unsigned int *modeflags, signed int *samethread, unsigned int *r_cmode);
// parse_version_number
// file ../../src/version.c line 51
static const char * parse_version_number(const char *s, signed int *number);
// parse_version_string
// file ../../src/version.c line 68
static const char * parse_version_string(const char *s, signed int *major, signed int *minor);
// pick_account
// file ../../tests/t-lock.c line 120
static signed int pick_account(void);
// pick_value
// file ../../tests/t-lock.c line 128
static signed int pick_value(void);
// plain_stdio_out
// file ../../src/estream-printf.c line 1627
static signed int plain_stdio_out(void *outfncarg, const char *buf, unsigned long int buflen);
// post_syscall_func$object
// 
void post_syscall_func$object(void);
// pr_bytes_so_far
// file ../../src/estream-printf.c line 1292
static signed int pr_bytes_so_far(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, struct argspec_s *arg, union anonymous$14 value, unsigned long int *nbytes);
// pr_bytes_so_far::outfnc$object
// 
signed int outfnc$object(void *, const char *, unsigned long int);
// pr_char
// file ../../src/estream-printf.c line 1178
static signed int pr_char(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, struct argspec_s *arg, union anonymous$14 value, unsigned long int *nbytes);
// pr_char::outfnc$object
// 
signed int outfnc$object(void *, const char *, unsigned long int);
// pr_float
// file ../../src/estream-printf.c line 1055
static signed int pr_float(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, struct argspec_s *arg, union anonymous$14 value, unsigned long int *nbytes);
// pr_float::outfnc$object
// 
signed int outfnc$object(void *, const char *, unsigned long int);
// pr_integer
// file ../../src/estream-printf.c line 849
static signed int pr_integer(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, struct argspec_s *arg, union anonymous$14 value, unsigned long int *nbytes);
// pr_integer::outfnc$object
// 
signed int outfnc$object(void *, const char *, unsigned long int);
// pr_pointer
// file ../../src/estream-printf.c line 1247
static signed int pr_pointer(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, struct argspec_s *arg, union anonymous$14 value, unsigned long int *nbytes);
// pr_pointer::outfnc$object
// 
signed int outfnc$object(void *, const char *, unsigned long int);
// pr_string
// file ../../src/estream-printf.c line 1198
static signed int pr_string(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, struct argspec_s *arg, union anonymous$14 value, unsigned long int *nbytes);
// pr_string::outfnc$object
// 
signed int outfnc$object(void *, const char *, unsigned long int);
// pre_syscall_func$object
// 
void pre_syscall_func$object(void);
// print_accounts
// file ../../tests/t-lock.c line 99
static void print_accounts(void);
// print_writer
// file ../../src/estream.c line 2717
static signed int print_writer(void *outfncarg, const char *buf, unsigned long int buflen);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$7 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$7 *, const union anonymous$8 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$7 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous$7 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$7 *);
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_values
// file ../../src/estream-printf.c line 716
static signed int read_values(struct valueitem_s *valuetable, unsigned long int valuetable_len, __builtin_va_list vaargs);
// real_init
// file ../../src/init.c line 70
static void real_init(void);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// revision_thread
// file ../../tests/t-lock.c line 136
static void * revision_thread(void *arg);
// run_test
// file ../../tests/t-lock.c line 198
static void run_test(void);
// sched_yield
// file /usr/include/sched.h line 65
extern signed int sched_yield(void);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$1 *, struct anonymous$1 *, struct anonymous$1 *, struct timeval *);
// show
// file ../../tests/t-common.h line 84
static void show(const char *format, ...);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strerror_r
// file /usr/include/string.h line 437
extern char * strerror_r(signed int, char *, unsigned long int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strspn
// file /usr/include/string.h line 288
extern unsigned long int strspn(const char *, const char *);
// system_strerror_r
// file ../../src/strerror.c line 65
static signed int system_strerror_r(signed int no, char *buf, unsigned long int buflen);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tmpfd
// file ../../src/estream.c line 4219
static signed int tmpfd(void);
// tmpfile
// file /usr/include/stdio.h line 195
extern struct _IO_FILE * tmpfile(void);
// trylock_stream
// file ../../src/estream.c line 389
static signed int trylock_stream(struct _gpgrt__stream * restrict stream);
// unlock_list
// file ../../src/estream.c line 427
static void unlock_list(void);
// unlock_stream
// file ../../src/estream.c line 406
static void unlock_stream(struct _gpgrt__stream * restrict stream);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$1
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$16
{
  // err
  unsigned int err : 1;
  // eof
  unsigned int eof : 1;
  // hup
  unsigned int hup : 1;
};

struct anonymous$0
{
  // grow
  unsigned int grow : 1;
};

struct anonymous$15
{
  // magic
  unsigned int magic : 16;
  // writing
  unsigned int writing : 1;
  // reserved
  unsigned int reserved : 15;
};

union anonymous$6
{
  // _priv
  volatile char _priv[40l];
  // _x_align
  signed long int _x_align;
  // _xp_align
  signed long int *_xp_align;
};

struct anonymous$5
{
  // _vers
  signed long int _vers;
  // u
  union anonymous$6 u;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$7
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$9
{
  // mtx
  union anonymous$7 mtx;
  // dummy
  signed long int *dummy;
};

struct anonymous$10
{
  // vers
  signed long int vers;
  // u
  union anonymous$9 u;
};

union anonymous$8
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous
{
  // fd
  signed int fd;
  // sock
  signed int sock;
  // rvid
  signed int rvid;
  // handle
  void *handle;
};

union anonymous$14
{
  // a_char
  char a_char;
  // a_schar
  signed char a_schar;
  // a_uchar
  unsigned char a_uchar;
  // a_short
  signed short int a_short;
  // a_ushort
  unsigned short int a_ushort;
  // a_int
  signed int a_int;
  // a_uint
  unsigned int a_uint;
  // a_long
  signed long int a_long;
  // a_ulong
  unsigned long int a_ulong;
  // a_longlong
  signed long long int a_longlong;
  // a_ulonglong
  unsigned long long int a_ulonglong;
  // a_double
  double a_double;
  // a_longdouble
  long double a_longdouble;
  // a_string
  const char *a_string;
  // a_intmax
  signed long int a_intmax;
  // a_uintmax
  signed long int a_uintmax;
  // a_size
  unsigned long int a_size;
  // a_ptrdiff
  signed long int a_ptrdiff;
  // a_void_ptr
  void *a_void_ptr;
  // a_char_ptr
  char *a_char_ptr;
  // a_schar_ptr
  signed char *a_schar_ptr;
  // a_short_ptr
  signed short int *a_short_ptr;
  // a_int_ptr
  signed int *a_int_ptr;
  // a_long_ptr
  signed long int *a_long_ptr;
  // a_longlong_ptr
  signed long long int *a_longlong_ptr;
  // a_intmax_ptr
  signed long int *a_intmax_ptr;
  // a_size_ptr
  unsigned long int *a_size_ptr;
  // a_ptrdiff_ptr
  signed long int *a_ptrdiff_ptr;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _gpgrt__stream
{
  // flags
  struct anonymous$15 flags;
  // buffer
  unsigned char *buffer;
  // buffer_size
  unsigned long int buffer_size;
  // data_len
  unsigned long int data_len;
  // data_offset
  unsigned long int data_offset;
  // data_flushed
  unsigned long int data_flushed;
  // unread_buffer
  unsigned char *unread_buffer;
  // unread_buffer_size
  unsigned long int unread_buffer_size;
  // unread_data_len
  unsigned long int unread_data_len;
  // intern
  struct _gpgrt_stream_internal *intern;
};

struct _gpgrt_cookie_io_functions
{
  // func_read
  signed long int (*func_read)(void *, void *, unsigned long int);
  // func_write
  signed long int (*func_write)(void *, const void *, unsigned long int);
  // func_seek
  signed int (*func_seek)(void *, signed long int *, signed int);
  // func_close
  signed int (*func_close)(void *);
};

struct _gpgrt_poll_s
{
  // stream
  struct _gpgrt__stream *stream;
  // want_read
  unsigned int want_read : 1;
  // want_write
  unsigned int want_write : 1;
  // want_oob
  unsigned int want_oob : 1;
  // want_rdhup
  unsigned int want_rdhup : 1;
  // _reserv1
  unsigned int _reserv1 : 4;
  // got_read
  unsigned int got_read : 1;
  // got_write
  unsigned int got_write : 1;
  // got_oob
  unsigned int got_oob : 1;
  // got_rdhup
  unsigned int got_rdhup : 1;
  // _reserv2
  unsigned int _reserv2 : 4;
  // got_err
  unsigned int got_err : 1;
  // got_hup
  unsigned int got_hup : 1;
  // got_nval
  unsigned int got_nval : 1;
  // _reserv3
  unsigned int _reserv3 : 4;
  // ignore
  unsigned int ignore : 1;
  // user
  unsigned int user : 8;
};

struct _gpgrt_syshd
{
  // type
  enum gpgrt_syshd_types type;
  // u
  union anonymous u;
};

struct _gpgrt_stream_internal
{
  // buffer
  unsigned char buffer[8192l];
  // unread_buffer
  unsigned char unread_buffer[16l];
  // lock
  struct anonymous$5 lock;
  // cookie
  void *cookie;
  // opaque
  void *opaque;
  // modeflags
  unsigned int modeflags;
  // printable_fname
  char *printable_fname;
  // offset
  signed long int offset;
  // func_read
  signed long int (*func_read)(void *, void *, unsigned long int);
  // func_write
  signed long int (*func_write)(void *, const void *, unsigned long int);
  // func_seek
  signed int (*func_seek)(void *, signed long int *, signed int);
  // func_close
  signed int (*func_close)(void *);
  // func_ioctl
  signed int (*func_ioctl)(void *, signed int, void *, unsigned long int *);
  // strategy
  signed int strategy;
  // syshd
  struct _gpgrt_syshd syshd;
  // indicators
  struct anonymous$16 indicators;
  // deallocate_buffer
  unsigned int deallocate_buffer : 1;
  // is_stdstream
  unsigned int is_stdstream : 1;
  // stdstream_fd
  unsigned int stdstream_fd : 2;
  // printable_fname_inuse
  unsigned int printable_fname_inuse : 1;
  // samethread
  unsigned int samethread : 1;
  // print_ntotal
  unsigned long int print_ntotal;
  // onclose
  struct notify_list_s *onclose;
};

struct argspec_s
{
  // length
  unsigned long int length;
  // flags
  unsigned int flags;
  // width
  signed int width;
  // precision
  signed int precision;
  // lenmod
  enum anonymous$11 lenmod;
  // conspec
  enum anonymous$12 conspec;
  // arg_pos
  signed int arg_pos;
  // width_pos
  signed int width_pos;
  // precision_pos
  signed int precision_pos;
  // vt
  enum anonymous$13 vt;
};

struct dynamic_buffer_parm_s
{
  // error_flag
  signed int error_flag;
  // alloced
  unsigned long int alloced;
  // used
  unsigned long int used;
  // buffer
  char *buffer;
};

struct estream_cookie_fd
{
  // fd
  signed int fd;
  // no_close
  signed int no_close;
  // nonblock
  signed int nonblock;
};

struct estream_cookie_fp
{
  // fp
  struct _IO_FILE *fp;
  // no_close
  signed int no_close;
};

struct estream_cookie_mem
{
  // modeflags
  unsigned int modeflags;
  // memory
  unsigned char *memory;
  // memory_size
  unsigned long int memory_size;
  // memory_limit
  unsigned long int memory_limit;
  // offset
  unsigned long int offset;
  // data_len
  unsigned long int data_len;
  // block_size
  unsigned long int block_size;
  // flags
  struct anonymous$0 flags;
  // func_realloc
  void * (*func_realloc)(void *, unsigned long int);
  // func_free
  void (*func_free)(void *);
};

struct estream_list_s
{
  // next
  struct estream_list_s *next;
  // stream
  struct _gpgrt__stream *stream;
};

struct fixed_buffer_parm_s
{
  // size
  unsigned long int size;
  // count
  unsigned long int count;
  // used
  unsigned long int used;
  // buffer
  char *buffer;
};

struct notify_list_s
{
  // next
  struct notify_list_s *next;
  // fnc
  void (*fnc)(struct _gpgrt__stream *, void *);
  // fnc_value
  void *fnc_value;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct valueitem_s
{
  // vt
  enum anonymous$13 vt;
  // value
  union anonymous$14 value;
};


// account
// file ../../tests/t-lock.c line 56
static signed int account[8l];
// accounts_lock
// file ../../tests/t-lock.c line 57
static struct anonymous$5 accounts_lock = { ._vers=(signed long int)1, .u={ ._priv={ (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0 } } };
// custom_realloc
// file ../../src/init.c line 65
static void * (*custom_realloc)(void *, unsigned long int);
// custom_std_fds
// file ../../src/estream.c line 222
static signed int custom_std_fds[3l];
// custom_std_fds_valid
// file ../../src/estream.c line 223
static unsigned char custom_std_fds_valid[3l];
// debug
// file ../../tests/t-common.h line 33
static signed int debug;
// err_code_from_index
// file ./code-from-errno.h line 22
static const signed int err_code_from_index[126l] = { GPG_ERR_EPERM, GPG_ERR_ENOENT, GPG_ERR_ESRCH, GPG_ERR_EINTR, GPG_ERR_EIO, GPG_ERR_ENXIO, GPG_ERR_E2BIG, GPG_ERR_ENOEXEC, GPG_ERR_EBADF, GPG_ERR_ECHILD, GPG_ERR_EAGAIN, GPG_ERR_EWOULDBLOCK, GPG_ERR_ENOMEM, GPG_ERR_EACCES, GPG_ERR_EFAULT, GPG_ERR_ENOTBLK, GPG_ERR_EBUSY, GPG_ERR_EEXIST, GPG_ERR_EXDEV, GPG_ERR_ENODEV, GPG_ERR_ENOTDIR, GPG_ERR_EISDIR, GPG_ERR_EINVAL, GPG_ERR_ENFILE, GPG_ERR_EMFILE, GPG_ERR_ENOTTY, GPG_ERR_ETXTBSY, GPG_ERR_EFBIG, GPG_ERR_ENOSPC, GPG_ERR_ESPIPE, GPG_ERR_EROFS, GPG_ERR_EMLINK, GPG_ERR_EPIPE, GPG_ERR_EDOM, GPG_ERR_ERANGE, GPG_ERR_EDEADLK, GPG_ERR_EDEADLOCK, GPG_ERR_ENAMETOOLONG, GPG_ERR_ENOLCK, GPG_ERR_ENOSYS, GPG_ERR_ENOTEMPTY, GPG_ERR_ELOOP, GPG_ERR_ENOMSG, GPG_ERR_EIDRM, GPG_ERR_ECHRNG, GPG_ERR_EL2NSYNC, GPG_ERR_EL3HLT, GPG_ERR_EL3RST, GPG_ERR_ELNRNG, GPG_ERR_EUNATCH, GPG_ERR_ENOCSI, GPG_ERR_EL2HLT, GPG_ERR_EBADE, GPG_ERR_EBADR, GPG_ERR_EXFULL, GPG_ERR_ENOANO, GPG_ERR_EBADRQC, GPG_ERR_EBADSLT, GPG_ERR_EBFONT, GPG_ERR_ENOSTR, GPG_ERR_ENODATA, GPG_ERR_ETIME, GPG_ERR_ENOSR, GPG_ERR_ENONET, GPG_ERR_ENOPKG, GPG_ERR_EREMOTE, GPG_ERR_ENOLINK, GPG_ERR_EADV, GPG_ERR_ESRMNT, GPG_ERR_ECOMM, GPG_ERR_EPROTO, GPG_ERR_EMULTIHOP, GPG_ERR_EDOTDOT, GPG_ERR_EBADMSG, GPG_ERR_EOVERFLOW, GPG_ERR_ENOTUNIQ, GPG_ERR_EBADFD, GPG_ERR_EREMCHG, GPG_ERR_ELIBACC, GPG_ERR_ELIBBAD, GPG_ERR_ELIBSCN, GPG_ERR_ELIBMAX, GPG_ERR_ELIBEXEC, GPG_ERR_EILSEQ, GPG_ERR_ERESTART, GPG_ERR_ESTRPIPE, GPG_ERR_EUSERS, GPG_ERR_ENOTSOCK, GPG_ERR_EDESTADDRREQ, GPG_ERR_EMSGSIZE, GPG_ERR_EPROTOTYPE, GPG_ERR_ENOPROTOOPT, GPG_ERR_EPROTONOSUPPORT, GPG_ERR_ESOCKTNOSUPPORT, GPG_ERR_ENOTSUP, GPG_ERR_EOPNOTSUPP, GPG_ERR_EPFNOSUPPORT, GPG_ERR_EAFNOSUPPORT, GPG_ERR_EADDRINUSE, GPG_ERR_EADDRNOTAVAIL, GPG_ERR_ENETDOWN, GPG_ERR_ENETUNREACH, GPG_ERR_ENETRESET, GPG_ERR_ECONNABORTED, GPG_ERR_ECONNRESET, GPG_ERR_ENOBUFS, GPG_ERR_EISCONN, GPG_ERR_ENOTCONN, GPG_ERR_ESHUTDOWN, GPG_ERR_ETOOMANYREFS, GPG_ERR_ETIMEDOUT, GPG_ERR_ECONNREFUSED, GPG_ERR_EHOSTDOWN, GPG_ERR_EHOSTUNREACH, GPG_ERR_EALREADY, GPG_ERR_EINPROGRESS, GPG_ERR_ESTALE, GPG_ERR_EUCLEAN, GPG_ERR_ENOTNAM, GPG_ERR_ENAVAIL, GPG_ERR_EISNAM, GPG_ERR_EREMOTEIO, GPG_ERR_EDQUOT, GPG_ERR_ENOMEDIUM, GPG_ERR_EMEDIUMTYPE, GPG_ERR_ECANCELED };
// err_code_to_errno
// file ./code-to-errno.h line 30
static const signed int err_code_to_errno[141l] = { 7, 13, 98, 99, 68, 97, 11, 114, 0, 0, 52, 9, 77, 74, 53, 0, 56, 57, 59, 16, 125, 10, 44, 70, 103, 111, 104, 0, 35, 35, 89, 0, 33, 73, 122, 17, 14, 27, 0, 0, 0, 112, 113, 43, 0, 84, 115, 4, 22, 5, 106, 21, 120, 51, 45, 46, 47, 79, 80, 83, 82, 81, 48, 40, 124, 24, 31, 90, 72, 36, 119, 0, 100, 102, 101, 23, 55, 105, 50, 61, 19, 2, 8, 37, 67, 123, 12, 42, 64, 65, 92, 28, 63, 60, 38, 15, 107, 20, 39, 118, 88, 95, 25, 76, 6, 95, 75, 1, 96, 32, 0, 0, 0, 0, 71, 93, 91, 34, 78, 66, 121, 85, 30, 0, 108, 94, 29, 3, 69, 116, 86, 62, 110, 109, 26, 117, 49, 87, 11, 18, 54 };
// errorcount
// file ../../tests/t-common.h line 34
static signed int errorcount;
// estream_functions_fd
// file ../../src/estream.c line 1071
static struct _gpgrt_cookie_io_functions estream_functions_fd;
// estream_functions_fd
// file ../../src/estream.c line 1071
static struct _gpgrt_cookie_io_functions estream_functions_fd = { .func_read=es_func_fd_read, .func_write=es_func_fd_write, .func_seek=es_func_fd_seek,
    .func_close=es_func_fd_destroy };
// estream_functions_fp
// file ../../src/estream.c line 1480
static struct _gpgrt_cookie_io_functions estream_functions_fp;
// estream_functions_fp
// file ../../src/estream.c line 1480
static struct _gpgrt_cookie_io_functions estream_functions_fp = { .func_read=es_func_fp_read, .func_write=es_func_fp_write, .func_seek=es_func_fp_seek,
    .func_close=es_func_fp_destroy };
// estream_functions_mem
// file ../../src/estream.c line 868
static struct _gpgrt_cookie_io_functions estream_functions_mem;
// estream_functions_mem
// file ../../src/estream.c line 868
static struct _gpgrt_cookie_io_functions estream_functions_mem = { .func_read=es_func_mem_read, .func_write=es_func_mem_write, .func_seek=es_func_mem_seek,
    .func_close=es_func_mem_destroy };
// estream_list
// file ../../src/estream.c line 217
static struct estream_list_s *estream_list;
// estream_list_lock
// file ../../src/estream.c line 219
static struct anonymous$5 estream_list_lock = { ._vers=(signed long int)1, .u={ ._priv={ (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0 } } };
// msgidx
// file ../../src/err-sources.h line 52
static const signed int msgidx[23l] = { 0, 19, 26, 32, 38, 48, 57, 61, 67, 74, 79, 87, 92, 96, 106, 110, 117, 121, 132, 154, 176, 198, 220 };
// msgidx$link1
// file ../../src/err-codes.h line 406
static const signed int msgidx$link1[377l] = { 0, 8, 22, 37, 63, 92, 117, 132, 147, 161, 175, 190, 205, 230, 243, 258, 272, 283, 297, 319, 335, 365, 385, 409, 435, 460, 478, 487, 497, 513, 526, 540, 559, 583, 603, 619, 634, 650, 666, 683, 697, 713, 740, 757, 777, 796, 813, 833, 845, 859, 872, 888, 907, 926, 946, 966, 980, 1002, 1022, 1030, 1034, 1048, 1071, 1079, 1094, 1107, 1122, 1151, 1180, 1203, 1219, 1235, 1255, 1268, 1283, 1300, 1316, 1333, 1350, 1362, 1375, 1406, 1427, 1447, 1468, 1490, 1502, 1517, 1525, 1538, 1547, 1565, 1576, 1587, 1601, 1621, 1634, 1646, 1660, 1672, 1692, 1711, 1731, 1753, 1777, 1798, 1821, 1842, 1857, 1868, 1888, 1901, 1914, 1931, 1953, 1967, 1987, 2003, 2017, 2028, 2048, 2071, 2092, 2107, 2128, 2150, 2166, 2180, 2196, 2210, 2227, 2239, 2271, 2291, 2303, 2313, 2325, 2343, 2364, 2376, 2391, 2408, 2423, 2439, 2453, 2472, 2491, 2514, 2535, 2559, 2577, 2599, 2622, 2640, 2652, 2670, 2687, 2701, 2718, 2733, 2756, 2775, 2788, 2807, 2831, 2858, 2871, 2896, 2907, 2926, 2938, 2954, 2972, 2999, 3006, 3021, 3037, 3053, 3073, 3086, 3098, 3115, 3127, 3144, 3158, 3174, 3201, 3224, 3247, 3270, 3285, 3302, 3320, 3341, 3360, 3391, 3409, 3427, 3449, 3475, 3502, 3519, 3560, 3592, 3630, 3657, 3687, 3717, 3745, 3782, 3806, 3854, 3896, 3936, 3972, 3999, 4007, 4014, 4025, 4043, 4060, 4091, 4112, 4137, 4152, 4176, 4195, 4231, 4252, 4281, 4301, 4328, 4356, 4371, 4382, 4399, 4436, 4481, 4525, 4565, 4603, 4641, 4683, 4717, 4762, 4807, 4820, 4830, 4843, 4878, 4898, 4903, 4909, 4927, 4950, 4974, 4995, 5023, 5053, 5081, 5101, 5125, 5152, 5170, 5188, 5216, 5231, 5247, 5275, 5298, 5318, 5335, 5363, 5387, 5412, 5432, 5452, 5471, 5500, 5524, 5552, 5579, 5605, 5634, 5658, 5683, 5710, 5739, 5756, 5781, 5804, 5826, 5845, 5867, 5900, 5930, 5953, 5988, 6004, 6024, 6044, 6061, 6088, 6101, 6123, 6143, 6171, 6199, 6218, 6236, 6277, 6317, 6356, 6370, 6405, 6444, 6477, 6504, 6527, 6557, 6588, 6617, 6643, 6666, 6686, 6705, 6731, 6752, 6785, 6822, 6856, 6881, 6910, 6930, 6957, 6993, 7015, 7037, 7065, 7104, 7138, 7160, 7192, 7215, 7252, 7281, 7298, 7326, 7353, 7374, 7401, 7425, 7440, 7468, 7492, 7511, 7533, 7570, 7596, 7622, 7648, 7674, 7700, 7726, 7752, 7778, 7804, 7831, 7858, 7885, 7912, 7939, 7966, 7993, 8016, 8037, 8049 };
// msgstr
// file ../../src/err-sources.h line 27
static const char msgstr[235l] = { 'U', 'n', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', ' ', 's', 'o', 'u', 'r', 'c', 'e', 0, 'g', 'c', 'r', 'y', 'p', 't', 0, 'G', 'n', 'u', 'P', 'G', 0, 'G', 'p', 'g', 'S', 'M', 0, 'G', 'P', 'G', ' ', 'A', 'g', 'e', 'n', 't', 0, 'P', 'i', 'n', 'e', 'n', 't', 'r', 'y', 0, 'S', 'C', 'D', 0, 'G', 'P', 'G', 'M', 'E', 0, 'K', 'e', 'y', 'b', 'o', 'x', 0, 'K', 'S', 'B', 'A', 0, 'D', 'i', 'r', 'm', 'n', 'g', 'r', 0, 'G', 'S', 'T', 'I', 0, 'G', 'P', 'A', 0, 'K', 'l', 'e', 'o', 'p', 'a', 't', 'r', 'a', 0, 'G', '1', '3', 0, 'A', 's', 's', 'u', 'a', 'n', 0, 'T', 'L', 'S', 0, 'A', 'n', 'y', ' ', 's', 'o', 'u', 'r', 'c', 'e', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's', 'o', 'u', 'r', 'c', 'e', ' ', '1', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's', 'o', 'u', 'r', 'c', 'e', ' ', '2', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's', 'o', 'u', 'r', 'c', 'e', ' ', '3', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's', 'o', 'u', 'r', 'c', 'e', ' ', '4', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 's', 'o', 'u', 'r', 'c', 'e', 0 };
// msgstr$link1
// file ../../src/err-codes.h line 27
static const char msgstr$link1[8068l] = { 'S', 'u', 'c', 'c', 'e', 's', 's', 0, 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p', 'a', 'c', 'k', 'e', 't', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 'p', 'a', 'c', 'k', 'e', 't', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'p', 'u', 'b', 'l', 'i', 'c', ' ', 'k', 'e', 'y', ' ', 'a', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'd', 'i', 'g', 'e', 's', 't', ' ', 'a', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 0, 'B', 'a', 'd', ' ', 'p', 'u', 'b', 'l', 'i', 'c', ' ', 'k', 'e', 'y', 0, 'B', 'a', 'd', ' ', 's', 'e', 'c', 'r', 'e', 't', ' ', 'k', 'e', 'y', 0, 'B', 'a', 'd', ' ', 's', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', 0, 'N', 'o', ' ', 'p', 'u', 'b', 'l', 'i', 'c', ' ', 'k', 'e', 'y', 0, 'C', 'h', 'e', 'c', 'k', 's', 'u', 'm', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'B', 'a', 'd', ' ', 'p', 'a', 's', 's', 'p', 'h', 'r', 'a', 's', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'c', 'i', 'p', 'h', 'e', 'r', ' ', 'a', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 0, 'K', 'e', 'y', 'r', 'i', 'n', 'g', ' ', 'o', 'p', 'e', 'n', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'p', 'a', 'c', 'k', 'e', 't', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'a', 'r', 'm', 'o', 'r', 0, 'N', 'o', ' ', 'u', 's', 'e', 'r', ' ', 'I', 'D', 0, 'N', 'o', ' ', 's', 'e', 'c', 'r', 'e', 't', ' ', 'k', 'e', 'y', 0, 'W', 'r', 'o', 'n', 'g', ' ', 's', 'e', 'c', 'r', 'e', 't', ' ', 'k', 'e', 'y', ' ', 'u', 's', 'e', 'd', 0, 'B', 'a', 'd', ' ', 's', 'e', 's', 's', 'i', 'o', 'n', ' ', 'k', 'e', 'y', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'c', 'o', 'm', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', ' ', 'a', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 0, 'N', 'u', 'm', 'b', 'e', 'r', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'p', 'r', 'i', 'm', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g', ' ', 'm', 'e', 't', 'h', 'o', 'd', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'e', 'n', 'c', 'r', 'y', 'p', 't', 'i', 'o', 'n', ' ', 's', 'c', 'h', 'e', 'm', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 's', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', ' ', 's', 'c', 'h', 'e', 'm', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'a', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0, 'N', 'o', ' ', 'v', 'a', 'l', 'u', 'e', 0, 'N', 'o', 't', ' ', 'f', 'o', 'u', 'n', 'd', 0, 'V', 'a', 'l', 'u', 'e', ' ', 'n', 'o', 't', ' ', 'f', 'o', 'u', 'n', 'd', 0, 'S', 'y', 'n', 't', 'a', 'x', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'B', 'a', 'd', ' ', 'M', 'P', 'I', ' ', 'v', 'a', 'l', 'u', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'p', 'a', 's', 's', 'p', 'h', 'r', 'a', 's', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 's', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', ' ', 'c', 'l', 'a', 's', 's', 0, 'R', 'e', 's', 'o', 'u', 'r', 'c', 'e', 's', ' ', 'e', 'x', 'h', 'a', 'u', 's', 't', 'e', 'd', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'k', 'e', 'y', 'r', 'i', 'n', 'g', 0, 'T', 'r', 'u', 's', 't', ' ', 'D', 'B', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'B', 'a', 'd', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'u', 's', 'e', 'r', ' ', 'I', 'D', 0, 'U', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'T', 'i', 'm', 'e', ' ', 'c', 'o', 'n', 'f', 'l', 'i', 'c', 't', 0, 'K', 'e', 'y', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'W', 'r', 'o', 'n', 'g', ' ', 'p', 'u', 'b', 'l', 'i', 'c', ' ', 'k', 'e', 'y', ' ', 'a', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 0, 'T', 'r', 'i', 'b', 'u', 't', 'e', ' ', 't', 'o', ' ', 'D', '.', ' ', 'A', '.', 0, 'W', 'e', 'a', 'k', ' ', 'e', 'n', 'c', 'r', 'y', 'p', 't', 'i', 'o', 'n', ' ', 'k', 'e', 'y', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'k', 'e', 'y', ' ', 'l', 'e', 'n', 'g', 't', 'h', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 0, 'S', 'y', 'n', 't', 'a', 'x', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'U', 'R', 'I', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'U', 'R', 'I', 0, 'N', 'e', 't', 'w', 'o', 'r', 'k', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'h', 'o', 's', 't', 0, 'S', 'e', 'l', 'f', 't', 'e', 's', 't', ' ', 'f', 'a', 'i', 'l', 'e', 'd', 0, 'D', 'a', 't', 'a', ' ', 'n', 'o', 't', ' ', 'e', 'n', 'c', 'r', 'y', 'p', 't', 'e', 'd', 0, 'D', 'a', 't', 'a', ' ', 'n', 'o', 't', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'e', 'd', 0, 'U', 'n', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'p', 'u', 'b', 'l', 'i', 'c', ' ', 'k', 'e', 'y', 0, 'U', 'n', 'u', 's', 'a', 'b', 'l', 'e', ' ', 's', 'e', 'c', 'r', 'e', 't', ' ', 'k', 'e', 'y', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'v', 'a', 'l', 'u', 'e', 0, 'B', 'a', 'd', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', ' ', 'c', 'h', 'a', 'i', 'n', 0, 'M', 'i', 's', 's', 'i', 'n', 'g', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0, 'N', 'o', ' ', 'd', 'a', 't', 'a', 0, 'B', 'u', 'g', 0, 'N', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'c', 'o', 'd', 'e', 0, 'T', 'i', 'm', 'e', 'o', 'u', 't', 0, 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'E', 'O', 'F', ' ', '(', 'g', 'c', 'r', 'y', 'p', 't', ')', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'o', 'b', 'j', 'e', 'c', 't', 0, 'P', 'r', 'o', 'v', 'i', 'd', 'e', 'd', ' ', 'o', 'b', 'j', 'e', 'c', 't', ' ', 'i', 's', ' ', 't', 'o', 'o', ' ', 's', 'h', 'o', 'r', 't', 0, 'P', 'r', 'o', 'v', 'i', 'd', 'e', 'd', ' ', 'o', 'b', 'j', 'e', 'c', 't', ' ', 'i', 's', ' ', 't', 'o', 'o', ' ', 'l', 'a', 'r', 'g', 'e', 0, 'M', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i', 't', 'e', 'm', ' ', 'i', 'n', ' ', 'o', 'b', 'j', 'e', 'c', 't', 0, 'N', 'o', 't', ' ', 'i', 'm', 'p', 'l', 'e', 'm', 'e', 'n', 't', 'e', 'd', 0, 'C', 'o', 'n', 'f', 'l', 'i', 'c', 't', 'i', 'n', 'g', ' ', 'u', 's', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'c', 'i', 'p', 'h', 'e', 'r', ' ', 'm', 'o', 'd', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'f', 'l', 'a', 'g', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'h', 'a', 'n', 'd', 'l', 'e', 0, 'R', 'e', 's', 'u', 'l', 't', ' ', 't', 'r', 'u', 'n', 'c', 'a', 't', 'e', 'd', 0, 'I', 'n', 'c', 'o', 'm', 'p', 'l', 'e', 't', 'e', ' ', 'l', 'i', 'n', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'r', 'e', 's', 'p', 'o', 'n', 's', 'e', 0, 'N', 'o', ' ', 'a', 'g', 'e', 'n', 't', ' ', 'r', 'u', 'n', 'n', 'i', 'n', 'g', 0, 'A', 'g', 'e', 'n', 't', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'd', 'a', 't', 'a', 0, 'U', 'n', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'c', ' ', 'A', 's', 's', 'u', 'a', 'n', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'f', 'a', 'u', 'l', 't', 0, 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'A', 's', 's', 'u', 'a', 'n', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 's', 'e', 's', 's', 'i', 'o', 'n', ' ', 'k', 'e', 'y', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'S', '-', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0, 'U', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'a', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 0, 'N', 'o', ' ', 'p', 'i', 'n', 'e', 'n', 't', 'r', 'y', 0, 'p', 'i', 'n', 'e', 'n', 't', 'r', 'y', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'B', 'a', 'd', ' ', 'P', 'I', 'N', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'n', 'a', 'm', 'e', 0, 'B', 'a', 'd', ' ', 'd', 'a', 't', 'a', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'p', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', 0, 'W', 'r', 'o', 'n', 'g', ' ', 'c', 'a', 'r', 'd', 0, 'N', 'o', ' ', 'd', 'i', 'r', 'm', 'n', 'g', 'r', 0, 'd', 'i', 'r', 'm', 'n', 'g', 'r', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', ' ', 'r', 'e', 'v', 'o', 'k', 'e', 'd', 0, 'N', 'o', ' ', 'C', 'R', 'L', ' ', 'k', 'n', 'o', 'w', 'n', 0, 'C', 'R', 'L', ' ', 't', 'o', 'o', ' ', 'o', 'l', 'd', 0, 'L', 'i', 'n', 'e', ' ', 't', 'o', 'o', ' ', 'l', 'o', 'n', 'g', 0, 'N', 'o', 't', ' ', 't', 'r', 'u', 's', 't', 'e', 'd', 0, 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'c', 'a', 'n', 'c', 'e', 'l', 'l', 'e', 'd', 0, 'B', 'a', 'd', ' ', 'C', 'A', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0, 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', ' ', 'e', 'x', 'p', 'i', 'r', 'e', 'd', 0, 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', ' ', 't', 'o', 'o', ' ', 'y', 'o', 'u', 'n', 'g', 0, 'U', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'S', '-', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0, 'U', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'p', 'r', 'o', 't', 'e', 'c', 't', 'i', 'o', 'n', 0, 'C', 'o', 'r', 'r', 'u', 'p', 't', 'e', 'd', ' ', 'p', 'r', 'o', 't', 'e', 'c', 't', 'i', 'o', 'n', 0, 'A', 'm', 'b', 'i', 'g', 'u', 'o', 'u', 's', ' ', 'n', 'a', 'm', 'e', 0, 'C', 'a', 'r', 'd', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'C', 'a', 'r', 'd', ' ', 'r', 'e', 's', 'e', 't', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', 0, 'C', 'a', 'r', 'd', ' ', 'r', 'e', 'm', 'o', 'v', 'e', 'd', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'c', 'a', 'r', 'd', 0, 'C', 'a', 'r', 'd', ' ', 'n', 'o', 't', ' ', 'p', 'r', 'e', 's', 'e', 'n', 't', 0, 'N', 'o', ' ', 'P', 'K', 'C', 'S', '1', '5', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', 0, 'N', 'o', 't', ' ', 'c', 'o', 'n', 'f', 'i', 'r', 'm', 'e', 'd', 0, 'C', 'o', 'n', 'f', 'i', 'g', 'u', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'N', 'o', ' ', 'p', 'o', 'l', 'i', 'c', 'y', ' ', 'm', 'a', 't', 'c', 'h', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'i', 'n', 'd', 'e', 'x', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'I', 'D', 0, 'N', 'o', ' ', 'S', 'm', 'a', 'r', 't', 'C', 'a', 'r', 'd', ' ', 'd', 'a', 'e', 'm', 'o', 'n', 0, 'S', 'm', 'a', 'r', 't', 'C', 'a', 'r', 'd', ' ', 'd', 'a', 'e', 'm', 'o', 'n', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'U', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'p', 'r', 'o', 't', 'o', 'c', 'o', 'l', 0, 'B', 'a', 'd', ' ', 'P', 'I', 'N', ' ', 'm', 'e', 't', 'h', 'o', 'd', 0, 'C', 'a', 'r', 'd', ' ', 'n', 'o', 't', ' ', 'i', 'n', 'i', 't', 'i', 'a', 'l', 'i', 'z', 'e', 'd', 0, 'U', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 0, 'W', 'r', 'o', 'n', 'g', ' ', 'k', 'e', 'y', ' ', 'u', 's', 'a', 'g', 'e', 0, 'N', 'o', 't', 'h', 'i', 'n', 'g', ' ', 'f', 'o', 'u', 'n', 'd', 0, 'W', 'r', 'o', 'n', 'g', ' ', 'b', 'l', 'o', 'b', ' ', 't', 'y', 'p', 'e', 0, 'M', 'i', 's', 's', 'i', 'n', 'g', ' ', 'v', 'a', 'l', 'u', 'e', 0, 'H', 'a', 'r', 'd', 'w', 'a', 'r', 'e', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm', 0, 'P', 'I', 'N', ' ', 'b', 'l', 'o', 'c', 'k', 'e', 'd', 0, 'C', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', ' ', 'o', 'f', ' ', 'u', 's', 'e', ' ', 'n', 'o', 't', ' ', 's', 'a', 't', 'i', 's', 'f', 'i', 'e', 'd', 0, 'P', 'I', 'N', 's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 's', 'y', 'n', 'c', 'e', 'd', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'C', 'R', 'L', 0, 'B', 'E', 'R', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'B', 'E', 'R', 0, 'E', 'l', 'e', 'm', 'e', 'n', 't', ' ', 'n', 'o', 't', ' ', 'f', 'o', 'u', 'n', 'd', 0, 'I', 'd', 'e', 'n', 't', 'i', 'f', 'i', 'e', 'r', ' ', 'n', 'o', 't', ' ', 'f', 'o', 'u', 'n', 'd', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 't', 'a', 'g', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'e', 'n', 'g', 't', 'h', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'k', 'e', 'y', ' ', 'i', 'n', 'f', 'o', 0, 'U', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 't', 'a', 'g', 0, 'N', 'o', 't', ' ', 'D', 'E', 'R', ' ', 'e', 'n', 'c', 'o', 'd', 'e', 'd', 0, 'N', 'o', ' ', 'C', 'M', 'S', ' ', 'o', 'b', 'j', 'e', 'c', 't', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'C', 'M', 'S', ' ', 'o', 'b', 'j', 'e', 'c', 't', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'C', 'M', 'S', ' ', 'o', 'b', 'j', 'e', 'c', 't', 0, 'U', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'C', 'M', 'S', ' ', 'o', 'b', 'j', 'e', 'c', 't', 0, 'U', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g', 0, 'U', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'C', 'M', 'S', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'a', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'c', 'r', 'y', 'p', 't', 'o', ' ', 'e', 'n', 'g', 'i', 'n', 'e', 0, 'P', 'u', 'b', 'l', 'i', 'c', ' ', 'k', 'e', 'y', ' ', 'n', 'o', 't', ' ', 't', 'r', 'u', 's', 't', 'e', 'd', 0, 'D', 'e', 'c', 'r', 'y', 'p', 't', 'i', 'o', 'n', ' ', 'f', 'a', 'i', 'l', 'e', 'd', 0, 'K', 'e', 'y', ' ', 'e', 'x', 'p', 'i', 'r', 'e', 'd', 0, 'S', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', ' ', 'e', 'x', 'p', 'i', 'r', 'e', 'd', 0, 'E', 'n', 'c', 'o', 'd', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 's', 't', 'a', 't', 'e', 0, 'D', 'u', 'p', 'l', 'i', 'c', 'a', 't', 'e', 'd', ' ', 'v', 'a', 'l', 'u', 'e', 0, 'M', 'i', 's', 's', 'i', 'n', 'g', ' ', 'a', 'c', 't', 'i', 'o', 'n', 0, 'A', 'S', 'N', '.', '1', ' ', 'm', 'o', 'd', 'u', 'l', 'e', ' ', 'n', 'o', 't', ' ', 'f', 'o', 'u', 'n', 'd', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'O', 'I', 'D', ' ', 's', 't', 'r', 'i', 'n', 'g', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 't', 'i', 'm', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'C', 'R', 'L', ' ', 'o', 'b', 'j', 'e', 'c', 't', 0, 'U', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'C', 'R', 'L', ' ', 'v', 'e', 'r', 's', 'i', 'o', 'n', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', ' ', 'o', 'b', 'j', 'e', 'c', 't', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'n', 'a', 'm', 'e', 0, 'A', ' ', 'l', 'o', 'c', 'a', 'l', 'e', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'f', 'a', 'i', 'l', 'e', 'd', 0, 'N', 'o', 't', ' ', 'l', 'o', 'c', 'k', 'e', 'd', 0, 'P', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'v', 'i', 'o', 'l', 'a', 't', 'i', 'o', 'n', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'M', 'A', 'C', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'e', 'x', 't', 'e', 'n', 's', 'i', 'o', 'n', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ', 'e', 'x', 't', 'e', 'n', 's', 'i', 'o', 'n', 0, 'L', 'o', 'c', 'k', 'e', 'd', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'o', 'p', 't', 'i', 'o', 'n', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'c', 'o', 'm', 'm', 'a', 'n', 'd', 0, 'N', 'o', 't', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 0, 'N', 'o', ' ', 'p', 'a', 's', 's', 'p', 'h', 'r', 'a', 's', 'e', ' ', 'g', 'i', 'v', 'e', 'n', 0, 'N', 'o', ' ', 'P', 'I', 'N', ' ', 'g', 'i', 'v', 'e', 'n', 0, 'N', 'o', 't', ' ', 'e', 'n', 'a', 'b', 'l', 'e', 'd', 0, 'N', 'o', ' ', 'c', 'r', 'y', 'p', 't', 'o', ' ', 'e', 'n', 'g', 'i', 'n', 'e', 0, 'M', 'i', 's', 's', 'i', 'n', 'g', ' ', 'k', 'e', 'y', 0, 'T', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'o', 'b', 'j', 'e', 'c', 't', 's', 0, 'L', 'i', 'm', 'i', 't', ' ', 'r', 'e', 'a', 'c', 'h', 'e', 'd', 0, 'N', 'o', 't', ' ', 'i', 'n', 'i', 't', 'i', 'a', 'l', 'i', 'z', 'e', 'd', 0, 'M', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i', 's', 's', 'u', 'e', 'r', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0, 'N', 'o', ' ', 'k', 'e', 'y', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'e', 'l', 'l', 'i', 'p', 't', 'i', 'c', ' ', 'c', 'u', 'r', 'v', 'e', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'e', 'l', 'l', 'i', 'p', 't', 'i', 'c', ' ', 'c', 'u', 'r', 'v', 'e', 0, 'D', 'u', 'p', 'l', 'i', 'c', 'a', 't', 'e', 'd', ' ', 'k', 'e', 'y', 0, 'A', 'm', 'b', 'i', 'g', 'u', 'o', 'u', 's', ' ', 'r', 'e', 's', 'u', 'l', 't', 0, 'N', 'o', ' ', 'c', 'r', 'y', 'p', 't', 'o', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', 0, 'W', 'r', 'o', 'n', 'g', ' ', 'c', 'r', 'y', 'p', 't', 'o', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', 0, 'B', 'a', 'd', ' ', 'c', 'r', 'y', 'p', 't', 'o', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', 0, 'C', 'o', 'n', 'f', 'l', 'i', 'c', 't', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'c', 'r', 'y', 'p', 't', 'o', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', 0, 'B', 'r', 'o', 'k', 'e', 'n', ' ', 'p', 'u', 'b', 'l', 'i', 'c', ' ', 'k', 'e', 'y', 0, 'B', 'r', 'o', 'k', 'e', 'n', ' ', 's', 'e', 'c', 'r', 'e', 't', ' ', 'k', 'e', 'y', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'M', 'A', 'C', ' ', 'a', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 0, 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'f', 'u', 'l', 'l', 'y', ' ', 'c', 'a', 'n', 'c', 'e', 'l', 'l', 'e', 'd', 0, 'O', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 'y', 'e', 't', ' ', 'f', 'i', 'n', 'i', 's', 'h', 'e', 'd', 0, 'B', 'u', 'f', 'f', 'e', 'r', ' ', 't', 'o', 'o', ' ', 's', 'h', 'o', 'r', 't', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'e', 'n', 'g', 't', 'h', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'r', ' ', 'i', 'n', ' ', 'S', '-', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0, 'S', 't', 'r', 'i', 'n', 'g', ' ', 't', 'o', 'o', ' ', 'l', 'o', 'n', 'g', ' ', 'i', 'n', ' ', 'S', '-', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0, 'U', 'n', 'm', 'a', 't', 'c', 'h', 'e', 'd', ' ', 'p', 'a', 'r', 'e', 'n', 't', 'h', 'e', 's', 'e', 's', ' ', 'i', 'n', ' ', 'S', '-', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0, 'S', '-', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 'c', 'a', 'n', 'o', 'n', 'i', 'c', 'a', 'l', 0, 'B', 'a', 'd', ' ', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', ' ', 'i', 'n', ' ', 'S', '-', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0, 'B', 'a', 'd', ' ', 'q', 'u', 'o', 't', 'a', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 'S', '-', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0, 'Z', 'e', 'r', 'o', ' ', 'p', 'r', 'e', 'f', 'i', 'x', ' ', 'i', 'n', ' ', 'S', '-', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0, 'N', 'e', 's', 't', 'e', 'd', ' ', 'd', 'i', 's', 'p', 'l', 'a', 'y', ' ', 'h', 'i', 'n', 't', 's', ' ', 'i', 'n', ' ', 'S', '-', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0, 'U', 'n', 'm', 'a', 't', 'c', 'h', 'e', 'd', ' ', 'd', 'i', 's', 'p', 'l', 'a', 'y', ' ', 'h', 'i', 'n', 't', 's', 0, 'U', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'r', 'e', 's', 'e', 'r', 'v', 'e', 'd', ' ', 'p', 'u', 'n', 'c', 't', 'u', 'a', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 'S', '-', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0, 'B', 'a', 'd', ' ', 'h', 'e', 'x', 'a', 'd', 'e', 'c', 'i', 'm', 'a', 'l', ' ', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', ' ', 'i', 'n', ' ', 'S', '-', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0, 'O', 'd', 'd', ' ', 'h', 'e', 'x', 'a', 'd', 'e', 'c', 'i', 'm', 'a', 'l', ' ', 'n', 'u', 'm', 'b', 'e', 'r', 's', ' ', 'i', 'n', ' ', 'S', '-', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0, 'B', 'a', 'd', ' ', 'o', 'c', 't', 'a', 'l', ' ', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', ' ', 'i', 'n', ' ', 'S', '-', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 0, 'S', 'e', 'r', 'v', 'e', 'r', ' ', 'i', 'n', 'd', 'i', 'c', 'a', 't', 'e', 'd', ' ', 'a', ' ', 'f', 'a', 'i', 'l', 'u', 'r', 'e', 0, 'N', 'o', ' ', 'n', 'a', 'm', 'e', 0, 'N', 'o', ' ', 'k', 'e', 'y', 0, 'L', 'e', 'g', 'a', 'c', 'y', ' ', 'k', 'e', 'y', 0, 'R', 'e', 'q', 'u', 'e', 's', 't', ' ', 't', 'o', 'o', ' ', 's', 'h', 'o', 'r', 't', 0, 'R', 'e', 'q', 'u', 'e', 's', 't', ' ', 't', 'o', 'o', ' ', 'l', 'o', 'n', 'g', 0, 'O', 'b', 'j', 'e', 'c', 't', ' ', 'i', 's', ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 's', 't', 'a', 't', 'e', 0, 'N', 'o', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', ' ', 'c', 'h', 'a', 'i', 'n', 0, 'C', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', ' ', 'i', 's', ' ', 't', 'o', 'o', ' ', 'l', 'a', 'r', 'g', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'r', 'e', 'c', 'o', 'r', 'd', 0, 'T', 'h', 'e', ' ', 'M', 'A', 'C', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'v', 'e', 'r', 'i', 'f', 'y', 0, 'U', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', 0, 'C', 'o', 'm', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'd', 'e', 'c', 'o', 'm', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', ' ', 'f', 'a', 'i', 'l', 'e', 'd', 0, 'A', ' ', 'c', 'o', 'u', 'n', 't', 'e', 'r', ' ', 'w', 'o', 'u', 'l', 'd', ' ', 'w', 'r', 'a', 'p', 0, 'F', 'a', 't', 'a', 'l', ' ', 'a', 'l', 'e', 'r', 't', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', ' ', 'r', 'e', 'c', 'e', 'i', 'v', 'e', 'd', 0, 'N', 'o', ' ', 'c', 'i', 'p', 'h', 'e', 'r', ' ', 'a', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', 0, 'M', 'i', 's', 's', 'i', 'n', 'g', ' ', 'c', 'l', 'i', 'e', 'n', 't', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', 0, 'C', 'l', 'o', 's', 'e', ' ', 'n', 'o', 't', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'r', 'e', 'c', 'e', 'i', 'v', 'e', 'd', 0, 'T', 'i', 'c', 'k', 'e', 't', ' ', 'e', 'x', 'p', 'i', 'r', 'e', 'd', 0, 'B', 'a', 'd', ' ', 't', 'i', 'c', 'k', 'e', 't', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'i', 'd', 'e', 'n', 't', 'i', 't', 'y', 0, 'B', 'a', 'd', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', ' ', 'i', 'n', ' ', 'h', 'a', 'n', 'd', 's', 'h', 'a', 'k', 'e', 0, 'B', 'a', 'd', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', ' ', 'i', 'n', ' ', 'h', 'a', 'n', 'd', 's', 'h', 'a', 'k', 'e', 0, 'B', 'a', 'd', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e', ' ', 'v', 'e', 'r', 'i', 'f', 'y', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', ' ', 'i', 'n', ' ', 'h', 'a', 'n', 'd', 's', 'h', 'a', 'k', 'e', 0, 'B', 'a', 'd', ' ', 'c', 'h', 'a', 'n', 'g', 'e', ' ', 'c', 'i', 'p', 'h', 'e', 'r', ' ', 'm', 'e', 's', 's', 's', 'a', 'g', 'e', ' ', 'i', 'n', ' ', 'h', 'a', 'n', 'd', 's', 'h', 'a', 'k', 'e', 0, 'B', 'a', 'd', ' ', 'c', 'l', 'i', 'e', 'n', 't', ' ', 'h', 'e', 'l', 'l', 'o', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', ' ', 'i', 'n', ' ', 'h', 'a', 'n', 'd', 's', 'h', 'a', 'k', 'e', 0, 'B', 'a', 'd', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'h', 'e', 'l', 'l', 'o', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', ' ', 'i', 'n', ' ', 'h', 'a', 'n', 'd', 's', 'h', 'a', 'k', 'e', 0, 'B', 'a', 'd', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'h', 'e', 'l', 'l', 'o', ' ', 'd', 'o', 'n', 'e', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', ' ', 'i', 'n', ' ', 'h', 'a', 'n', 's', 'h', 'a', 'k', 'e', 0, 'B', 'a', 'd', ' ', 'f', 'i', 'n', 'i', 's', 'h', 'e', 'd', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', ' ', 'i', 'n', ' ', 'h', 'a', 'n', 'd', 's', 'h', 'a', 'k', 'e', 0, 'B', 'a', 'd', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'k', 'e', 'y', ' ', 'e', 'x', 'c', 'h', 'a', 'n', 'g', 'e', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', ' ', 'i', 'n', ' ', 'h', 'a', 'n', 'd', 's', 'h', 'a', 'k', 'e', 0, 'B', 'a', 'd', ' ', 'c', 'l', 'i', 'e', 'n', 't', ' ', 'k', 'e', 'y', ' ', 'e', 'x', 'c', 'h', 'a', 'n', 'g', 'e', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', ' ', 'i', 'n', ' ', 'h', 'a', 'n', 'd', 's', 'h', 'a', 'k', 'e', 0, 'B', 'o', 'g', 'u', 's', ' ', 's', 't', 'r', 'i', 'n', 'g', 0, 'F', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', 0, 'K', 'e', 'y', ' ', 'd', 'i', 's', 'a', 'b', 'l', 'e', 'd', 0, 'N', 'o', 't', ' ', 'p', 'o', 's', 's', 'i', 'b', 'l', 'e', ' ', 'w', 'i', 't', 'h', ' ', 'a', ' ', 'c', 'a', 'r', 'd', ' ', 'b', 'a', 's', 'e', 'd', ' ', 'k', 'e', 'y', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'o', 'c', 'k', ' ', 'o', 'b', 'j', 'e', 'c', 't', 0, 'T', 'r', 'u', 'e', 0, 'F', 'a', 'l', 's', 'e', 0, 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'I', 'P', 'C', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'I', 'P', 'C', ' ', 'a', 'c', 'c', 'e', 'p', 't', ' ', 'c', 'a', 'l', 'l', ' ', 'f', 'a', 'i', 'l', 'e', 'd', 0, 'I', 'P', 'C', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', ' ', 'c', 'a', 'l', 'l', ' ', 'f', 'a', 'i', 'l', 'e', 'd', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'I', 'P', 'C', ' ', 'r', 'e', 's', 'p', 'o', 'n', 's', 'e', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'p', 'a', 's', 's', 'e', 'd', ' ', 't', 'o', ' ', 'I', 'P', 'C', 0, 'I', 'n', 'c', 'o', 'm', 'p', 'l', 'e', 't', 'e', ' ', 'l', 'i', 'n', 'e', ' ', 'p', 'a', 's', 's', 'e', 'd', ' ', 't', 'o', ' ', 'I', 'P', 'C', 0, 'L', 'i', 'n', 'e', ' ', 'p', 'a', 's', 's', 'e', 'd', ' ', 't', 'o', ' ', 'I', 'P', 'C', ' ', 't', 'o', 'o', ' ', 'l', 'o', 'n', 'g', 0, 'N', 'e', 's', 't', 'e', 'd', ' ', 'I', 'P', 'C', ' ', 'c', 'o', 'm', 'm', 'a', 'n', 'd', 's', 0, 'N', 'o', ' ', 'd', 'a', 't', 'a', ' ', 'c', 'a', 'l', 'l', 'b', 'a', 'c', 'k', ' ', 'i', 'n', ' ', 'I', 'P', 'C', 0, 'N', 'o', ' ', 'i', 'n', 'q', 'u', 'i', 'r', 'e', ' ', 'c', 'a', 'l', 'l', 'b', 'a', 'c', 'k', ' ', 'i', 'n', ' ', 'I', 'P', 'C', 0, 'N', 'o', 't', ' ', 'a', 'n', ' ', 'I', 'P', 'C', ' ', 's', 'e', 'r', 'v', 'e', 'r', 0, 'N', 'o', 't', ' ', 'a', 'n', ' ', 'I', 'P', 'C', ' ', 'c', 'l', 'i', 'e', 'n', 't', 0, 'P', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 's', 't', 'a', 'r', 't', 'i', 'n', 'g', ' ', 'I', 'P', 'C', ' ', 's', 'e', 'r', 'v', 'e', 'r', 0, 'I', 'P', 'C', ' ', 'r', 'e', 'a', 'd', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'I', 'P', 'C', ' ', 'w', 'r', 'i', 't', 'e', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'T', 'o', 'o', ' ', 'm', 'u', 'c', 'h', ' ', 'd', 'a', 't', 'a', ' ', 'f', 'o', 'r', ' ', 'I', 'P', 'C', ' ', 'l', 'a', 'y', 'e', 'r', 0, 'U', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'I', 'P', 'C', ' ', 'c', 'o', 'm', 'm', 'a', 'n', 'd', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'I', 'P', 'C', ' ', 'c', 'o', 'm', 'm', 'a', 'n', 'd', 0, 'I', 'P', 'C', ' ', 's', 'y', 'n', 't', 'a', 'x', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'I', 'P', 'C', ' ', 'c', 'a', 'l', 'l', ' ', 'h', 'a', 's', ' ', 'b', 'e', 'e', 'n', ' ', 'c', 'a', 'n', 'c', 'e', 'l', 'l', 'e', 'd', 0, 'N', 'o', ' ', 'i', 'n', 'p', 'u', 't', ' ', 's', 'o', 'u', 'r', 'c', 'e', ' ', 'f', 'o', 'r', ' ', 'I', 'P', 'C', 0, 'N', 'o', ' ', 'o', 'u', 't', 'p', 'u', 't', ' ', 's', 'o', 'u', 'r', 'c', 'e', ' ', 'f', 'o', 'r', ' ', 'I', 'P', 'C', 0, 'I', 'P', 'C', ' ', 'p', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'I', 'P', 'C', ' ', 'i', 'n', 'q', 'u', 'i', 'r', 'e', 0, 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'L', 'D', 'A', 'P', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'L', 'D', 'A', 'P', ' ', 'a', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'L', 'D', 'A', 'P', ' ', 'n', 'a', 'm', 'e', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'L', 'D', 'A', 'P', ' ', 's', 'e', 'c', 'u', 'r', 'i', 't', 'y', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'L', 'D', 'A', 'P', ' ', 's', 'e', 'r', 'v', 'i', 'c', 'e', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'G', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'L', 'D', 'A', 'P', ' ', 'u', 'p', 'd', 'a', 't', 'e', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'E', 'x', 'p', 'e', 'r', 'i', 'm', 'e', 'n', 't', 'a', 'l', ' ', 'L', 'D', 'A', 'P', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', 0, 'P', 'r', 'i', 'v', 'a', 't', 'e', ' ', 'L', 'D', 'A', 'P', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', 0, 'O', 't', 'h', 'e', 'r', ' ', 'g', 'e', 'n', 'e', 'r', 'a', 'l', ' ', 'L', 'D', 'A', 'P', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'L', 'D', 'A', 'P', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'n', 'g', ' ', 'f', 'a', 'i', 'l', 'e', 'd', ' ', '(', 'X', ')', 0, 'L', 'D', 'A', 'P', ' ', 'r', 'e', 'f', 'e', 'r', 'r', 'a', 'l', ' ', 'l', 'i', 'm', 'i', 't', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 'e', 'd', 0, 'L', 'D', 'A', 'P', ' ', 'c', 'l', 'i', 'e', 'n', 't', ' ', 'l', 'o', 'o', 'p', 0, 'N', 'o', ' ', 'L', 'D', 'A', 'P', ' ', 'r', 'e', 's', 'u', 'l', 't', 's', ' ', 'r', 'e', 't', 'u', 'r', 'n', 'e', 'd', 0, 'L', 'D', 'A', 'P', ' ', 'c', 'o', 'n', 't', 'r', 'o', 'l', ' ', 'n', 'o', 't', ' ', 'f', 'o', 'u', 'n', 'd', 0, 'N', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'L', 'D', 'A', 'P', 0, 'L', 'D', 'A', 'P', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ' ', 'i', 'n', ' ', 'L', 'D', 'A', 'P', 0, 'B', 'a', 'd', ' ', 'p', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', ' ', 't', 'o', ' ', 'a', 'n', ' ', 'L', 'D', 'A', 'P', ' ', 'r', 'o', 'u', 't', 'i', 'n', 'e', 0, 'U', 's', 'e', 'r', ' ', 'c', 'a', 'n', 'c', 'e', 'l', 'l', 'e', 'd', ' ', 'L', 'D', 'A', 'P', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 0, 'B', 'a', 'd', ' ', 'L', 'D', 'A', 'P', ' ', 's', 'e', 'a', 'r', 'c', 'h', ' ', 'f', 'i', 'l', 't', 'e', 'r', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'L', 'D', 'A', 'P', ' ', 'a', 'u', 't', 'h', 'e', 'n', 't', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'm', 'e', 't', 'h', 'o', 'd', 0, 'T', 'i', 'm', 'e', 'o', 'u', 't', ' ', 'i', 'n', ' ', 'L', 'D', 'A', 'P', 0, 'L', 'D', 'A', 'P', ' ', 'd', 'e', 'c', 'o', 'd', 'i', 'n', 'g', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'L', 'D', 'A', 'P', ' ', 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'L', 'D', 'A', 'P', ' ', 'l', 'o', 'c', 'a', 'l', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'C', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'o', 'n', 't', 'a', 'c', 't', ' ', 'L', 'D', 'A', 'P', ' ', 's', 'e', 'r', 'v', 'e', 'r', 0, 'L', 'D', 'A', 'P', ' ', 's', 'u', 'c', 'c', 'e', 's', 's', 0, 'L', 'D', 'A', 'P', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', 's', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'L', 'D', 'A', 'P', ' ', 'p', 'r', 'o', 't', 'o', 'c', 'o', 'l', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'T', 'i', 'm', 'e', ' ', 'l', 'i', 'm', 'i', 't', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 'e', 'd', ' ', 'i', 'n', ' ', 'L', 'D', 'A', 'P', 0, 'S', 'i', 'z', 'e', ' ', 'l', 'i', 'm', 'i', 't', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 'e', 'd', ' ', 'i', 'n', ' ', 'L', 'D', 'A', 'P', 0, 'L', 'D', 'A', 'P', ' ', 'c', 'o', 'm', 'p', 'a', 'r', 'e', ' ', 'f', 'a', 'l', 's', 'e', 0, 'L', 'D', 'A', 'P', ' ', 'c', 'o', 'm', 'p', 'a', 'r', 'e', ' ', 't', 'r', 'u', 'e', 0, 'L', 'D', 'A', 'P', ' ', 'a', 'u', 't', 'h', 'e', 'n', 't', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'm', 'e', 't', 'h', 'o', 'd', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', 0, 'S', 't', 'r', 'o', 'n', 'g', '(', 'e', 'r', ')', ' ', 'L', 'D', 'A', 'P', ' ', 'a', 'u', 't', 'h', 'e', 'n', 't', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', 0, 'P', 'a', 'r', 't', 'i', 'a', 'l', ' ', 'L', 'D', 'A', 'P', ' ', 'r', 'e', 's', 'u', 'l', 't', 's', '+', 'r', 'e', 'f', 'e', 'r', 'r', 'a', 'l', ' ', 'r', 'e', 'c', 'e', 'i', 'v', 'e', 'd', 0, 'L', 'D', 'A', 'P', ' ', 'r', 'e', 'f', 'e', 'r', 'r', 'a', 'l', 0, 'A', 'd', 'm', 'i', 'n', 'i', 's', 't', 'r', 'a', 't', 'i', 'v', 'e', ' ', 'L', 'D', 'A', 'P', ' ', 'l', 'i', 'm', 'i', 't', ' ', 'e', 'x', 'c', 'e', 'e', 'd', 'e', 'd', 0, 'C', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ', 'L', 'D', 'A', 'P', ' ', 'e', 'x', 't', 'e', 'n', 's', 'i', 'o', 'n', ' ', 'i', 's', ' ', 'u', 'n', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 0, 'C', 'o', 'n', 'f', 'i', 'd', 'e', 'n', 't', 'i', 'a', 'l', 'i', 't', 'y', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', ' ', 'b', 'y', ' ', 'L', 'D', 'A', 'P', 0, 'L', 'D', 'A', 'P', ' ', 'S', 'A', 'S', 'L', ' ', 'b', 'i', 'n', 'd', ' ', 'i', 'n', ' ', 'p', 'r', 'o', 'g', 'r', 'e', 's', 's', 0, 'N', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'L', 'D', 'A', 'P', ' ', 'a', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', 0, 'U', 'n', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'L', 'D', 'A', 'P', ' ', 'a', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', ' ', 't', 'y', 'p', 'e', 0, 'I', 'n', 'a', 'p', 'p', 'r', 'o', 'p', 'r', 'i', 'a', 't', 'e', ' ', 'm', 'a', 't', 'c', 'h', 'i', 'n', 'g', ' ', 'i', 'n', ' ', 'L', 'D', 'A', 'P', 0, 'C', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' ', 'v', 'i', 'o', 'l', 'a', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 'L', 'D', 'A', 'P', 0, 'L', 'D', 'A', 'P', ' ', 't', 'y', 'p', 'e', ' ', 'o', 'r', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'e', 'x', 'i', 's', 't', 's', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 's', 'y', 'n', 't', 'a', 'x', ' ', 'i', 'n', ' ', 'L', 'D', 'A', 'P', 0, 'N', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'L', 'D', 'A', 'P', ' ', 'o', 'b', 'j', 'e', 'c', 't', 0, 'L', 'D', 'A', 'P', ' ', 'a', 'l', 'i', 'a', 's', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'D', 'N', ' ', 's', 'y', 'n', 't', 'a', 'x', ' ', 'i', 'n', ' ', 'L', 'D', 'A', 'P', 0, 'L', 'D', 'A', 'P', ' ', 'e', 'n', 't', 'r', 'y', ' ', 'i', 's', ' ', 'a', ' ', 'l', 'e', 'a', 'f', 0, 'L', 'D', 'A', 'P', ' ', 'a', 'l', 'i', 'a', 's', ' ', 'd', 'e', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm', 0, 'L', 'D', 'A', 'P', ' ', 'p', 'r', 'o', 'x', 'y', ' ', 'a', 'u', 't', 'h', 'o', 'r', 'i', 'z', 'a', 't', 'i', 'o', 'n', ' ', 'f', 'a', 'i', 'l', 'u', 'r', 'e', ' ', '(', 'X', ')', 0, 'I', 'n', 'a', 'p', 'p', 'r', 'o', 'p', 'r', 'i', 'a', 't', 'e', ' ', 'L', 'D', 'A', 'P', ' ', 'a', 'u', 't', 'h', 'e', 'n', 't', 'i', 'c', 'a', 't', 'i', 'o', 'n', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'L', 'D', 'A', 'P', ' ', 'c', 'r', 'e', 'd', 'e', 'n', 't', 'i', 'a', 'l', 's', 0, 'I', 'n', 's', 'u', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', ' ', 'a', 'c', 'c', 'e', 's', 's', ' ', 'f', 'o', 'r', ' ', 'L', 'D', 'A', 'P', 0, 'L', 'D', 'A', 'P', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'i', 's', ' ', 'b', 'u', 's', 'y', 0, 'L', 'D', 'A', 'P', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'i', 's', ' ', 'u', 'n', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', 0, 'L', 'D', 'A', 'P', ' ', 's', 'e', 'r', 'v', 'e', 'r', ' ', 'i', 's', ' ', 'u', 'n', 'w', 'i', 'l', 'l', 'i', 'n', 'g', ' ', 't', 'o', ' ', 'p', 'e', 'r', 'f', 'o', 'r', 'm', 0, 'L', 'o', 'o', 'p', ' ', 'd', 'e', 't', 'e', 'c', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'L', 'D', 'A', 'P', 0, 'L', 'D', 'A', 'P', ' ', 'n', 'a', 'm', 'i', 'n', 'g', ' ', 'v', 'i', 'o', 'l', 'a', 't', 'i', 'o', 'n', 0, 'L', 'D', 'A', 'P', ' ', 'o', 'b', 'j', 'e', 'c', 't', ' ', 'c', 'l', 'a', 's', 's', ' ', 'v', 'i', 'o', 'l', 'a', 't', 'i', 'o', 'n', 0, 'L', 'D', 'A', 'P', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd', ' ', 'o', 'n', ' ', 'n', 'o', 'n', '-', 'l', 'e', 'a', 'f', 0, 'L', 'D', 'A', 'P', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd', ' ', 'o', 'n', ' ', 'R', 'D', 'N', 0, 'A', 'l', 'r', 'e', 'a', 'd', 'y', ' ', 'e', 'x', 'i', 's', 't', 's', ' ', '(', 'L', 'D', 'A', 'P', ')', 0, 'C', 'a', 'n', 'n', 'o', 't', ' ', 'm', 'o', 'd', 'i', 'f', 'y', ' ', 'L', 'D', 'A', 'P', ' ', 'o', 'b', 'j', 'e', 'c', 't', ' ', 'c', 'l', 'a', 's', 's', 0, 'L', 'D', 'A', 'P', ' ', 'r', 'e', 's', 'u', 'l', 't', 's', ' ', 't', 'o', 'o', ' ', 'l', 'a', 'r', 'g', 'e', 0, 'L', 'D', 'A', 'P', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'a', 'f', 'f', 'e', 'c', 't', 's', ' ', 'm', 'u', 'l', 't', 'i', 'p', 'l', 'e', ' ', 'D', 'S', 'A', 's', 0, 'V', 'i', 'r', 't', 'u', 'a', 'l', ' ', 'L', 'D', 'A', 'P', ' ', 'l', 'i', 's', 't', ' ', 'v', 'i', 'e', 'w', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'O', 't', 'h', 'e', 'r', ' ', 'L', 'D', 'A', 'P', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'R', 'e', 's', 'o', 'u', 'r', 'c', 'e', 's', ' ', 'e', 'x', 'h', 'a', 'u', 's', 't', 'e', 'd', ' ', 'i', 'n', ' ', 'L', 'C', 'U', 'P', 0, 'S', 'e', 'c', 'u', 'r', 'i', 't', 'y', ' ', 'v', 'i', 'o', 'l', 'a', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 'L', 'C', 'U', 'P', 0, 'I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'd', 'a', 't', 'a', ' ', 'i', 'n', ' ', 'L', 'C', 'U', 'P', 0, 'U', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 's', 'c', 'h', 'e', 'm', 'e', ' ', 'i', 'n', ' ', 'L', 'C', 'U', 'P', 0, 'R', 'e', 'l', 'o', 'a', 'd', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', ' ', 'i', 'n', ' ', 'L', 'C', 'U', 'P', 0, 'L', 'D', 'A', 'P', ' ', 'c', 'a', 'n', 'c', 'e', 'l', 'l', 'e', 'd', 0, 'N', 'o', ' ', 'L', 'D', 'A', 'P', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 't', 'o', ' ', 'c', 'a', 'n', 'c', 'e', 'l', 0, 'T', 'o', 'o', ' ', 'l', 'a', 't', 'e', ' ', 't', 'o', ' ', 'c', 'a', 'n', 'c', 'e', 'l', ' ', 'L', 'D', 'A', 'P', 0, 'C', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'a', 'n', 'c', 'e', 'l', ' ', 'L', 'D', 'A', 'P', 0, 'L', 'D', 'A', 'P', ' ', 'a', 's', 's', 'e', 'r', 't', 'i', 'o', 'n', ' ', 'f', 'a', 'i', 'l', 'e', 'd', 0, 'P', 'r', 'o', 'x', 'i', 'e', 'd', ' ', 'a', 'u', 't', 'h', 'o', 'r', 'i', 'z', 'a', 't', 'i', 'o', 'n', ' ', 'd', 'e', 'n', 'i', 'e', 'd', ' ', 'b', 'y', ' ', 'L', 'D', 'A', 'P', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '1', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '2', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '3', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '4', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '5', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '6', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '7', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '8', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '9', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '1', '0', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '1', '1', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '1', '2', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '1', '3', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '1', '4', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '1', '5', 0, 'U', 's', 'e', 'r', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '1', '6', 0, 'S', 'y', 's', 't', 'e', 'm', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', '/', 'o', ' ', 'e', 'r', 'r', 'n', 'o', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 's', 'y', 's', 't', 'e', 'm', ' ', 'e', 'r', 'r', 'o', 'r', 0, 'E', 'n', 'd', ' ', 'o', 'f', ' ', 'f', 'i', 'l', 'e', 0, 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', 0 };
// post_syscall_func
// file ../../src/estream.c line 227
static void (*post_syscall_func)(void);
// pre_syscall_func
// file ../../src/estream.c line 226
static void (*pre_syscall_func)(void);
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// stop_revision_thread
// file ../../tests/t-lock.c line 70
static volatile signed int stop_revision_thread;
// verbose
// file ../../tests/t-common.h line 32
static signed int verbose;

// _gpg_err_code_from_errno
// file ../../src/code-from-errno.c line 35
enum anonymous$4 _gpg_err_code_from_errno(signed int err)
{
  signed int idx;
  if(err == 0)
    return (enum anonymous$4)GPG_ERR_NO_ERROR;

  else
  {
    idx = 0 != 0 ? -1 : (err >= 1 && err <= 11 ? err - 1 : (err >= 11 && err <= 35 ? err - 0 : (err >= 35 && err <= 40 ? err - -1 : (err >= 42 && err <= 57 ? err - 0 : (err >= 59 && err <= 95 ? err - 1 : (err >= 95 && err <= 125 ? err - 0 : -1))))));
    if(!(idx >= 0))
      return (enum anonymous$4)GPG_ERR_UNKNOWN_ERRNO;

    else
      return (enum anonymous$4)(1 << 15 | err_code_from_index[(signed long int)idx]);
  }
}

// _gpg_err_code_from_syserror
// file ../../src/code-from-errno.c line 55
enum anonymous$4 _gpg_err_code_from_syserror(void)
{
  signed int err;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  err = *return_value___errno_location$1;
  signed int idx;
  if(err == 0)
    return (enum anonymous$4)GPG_ERR_MISSING_ERRNO;

  else
  {
    idx = 0 != 0 ? -1 : (err >= 1 && err <= 11 ? err - 1 : (err >= 11 && err <= 35 ? err - 0 : (err >= 35 && err <= 40 ? err - -1 : (err >= 42 && err <= 57 ? err - 0 : (err >= 59 && err <= 95 ? err - 1 : (err >= 95 && err <= 125 ? err - 0 : -1))))));
    if(!(idx >= 0))
      return (enum anonymous$4)GPG_ERR_UNKNOWN_ERRNO;

    else
      return (enum anonymous$4)(1 << 15 | err_code_from_index[(signed long int)idx]);
  }
}

// _gpg_err_code_to_errno
// file ../../src/code-to-errno.c line 32
signed int _gpg_err_code_to_errno(enum anonymous$4 code)
{
  if((32768 & (signed int)code) == 0)
    return 0;

  else
  {
    code = code & (enum anonymous$4)~(1 << 15);
    if(!((unsigned long int)code >= 141ul))
      return err_code_to_errno[(signed long int)code];

    else
      return 0;
  }
}

// _gpg_err_deinit
// file ../../src/init.c line 131
void _gpg_err_deinit(signed int mode)
{
  (void)mode;
}

// _gpg_err_init
// file ../../src/init.c line 88
unsigned int _gpg_err_init(void)
{
  real_init();
  return (unsigned int)0;
}

// _gpg_err_set_errno
// file ../../src/init.c line 206
void _gpg_err_set_errno(signed int err)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = err;
}

// _gpg_error_check_version
// file ../../src/version.c line 116
const char * _gpg_error_check_version(const char *req_version)
{
  const char *return_value_cright_blurb$1;
  if(!(req_version == ((const char *)NULL)))
  {
    if(!((signed int)*req_version == 1))
      goto __CPROVER_DUMP_L1;

    if(!((signed int)req_version[1l] == 1))
      goto __CPROVER_DUMP_L1;

    return_value_cright_blurb$1=cright_blurb();
    return return_value_cright_blurb$1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    const char *return_value_compare_versions$2;
    return_value_compare_versions$2=compare_versions("1.21", req_version);
    return return_value_compare_versions$2;
  }
}

// _gpg_strerror
// file ../../src/strerror.c line 38
const char * _gpg_strerror(unsigned int err)
{
  enum anonymous$4 code;
  code=gpg_err_code(err);
  char *return_value_strerror$1;
  if(!((32768 & (signed int)code) == 0))
  {
    signed int no;
    no=gpg_err_code_to_errno(code);
    if(!(no == 0))
    {
      return_value_strerror$1=strerror(no);
      return return_value_strerror$1;
    }

    else
      code = (enum anonymous$4)GPG_ERR_UNKNOWN_ERRNO;
  }

  signed int return_value_msgidxof$2;
  return_value_msgidxof$2=msgidxof$link1((signed int)code);
  char *return_value_dgettext$3;
  return_value_dgettext$3=dgettext("libgpg-error", msgstr$link1 + (signed long int)msgidx$link1[(signed long int)return_value_msgidxof$2]);
  return return_value_dgettext$3;
}

// _gpg_strerror_r
// file ../../src/strerror.c line 137
signed int _gpg_strerror_r(unsigned int err, char *buf, unsigned long int buflen)
{
  enum anonymous$4 code;
  code=gpg_err_code(err);
  const char *errstr;
  unsigned long int errstr_len;
  unsigned long int cpy_len;
  if(!((32768 & (signed int)code) == 0))
  {
    signed int no;
    no=gpg_err_code_to_errno(code);
    if(!(no == 0))
    {
      signed int system_err;
      system_err=system_strerror_r(no, buf, buflen);
      if(!(system_err == 22))
      {
        if(!(buflen == 0ul))
          buf[(signed long int)(buflen - (unsigned long int)1)] = (char)0;

        return system_err;
      }

    }

    code = (enum anonymous$4)GPG_ERR_UNKNOWN_ERRNO;
  }

  signed int return_value_msgidxof$1;
  return_value_msgidxof$1=msgidxof$link1((signed int)code);
  errstr=dgettext("libgpg-error", msgstr$link1 + (signed long int)msgidx$link1[(signed long int)return_value_msgidxof$1]);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(errstr);
  errstr_len = return_value_strlen$2 + (unsigned long int)1;
  cpy_len = errstr_len < buflen ? errstr_len : buflen;
  memcpy((void *)buf, (const void *)errstr, cpy_len);
  if(!(buflen == 0ul))
    buf[(signed long int)(buflen - (unsigned long int)1)] = (char)0;

  return cpy_len == errstr_len ? 0 : 34;
}

// _gpg_strsource
// file ../../src/strsource.c line 33
const char * _gpg_strsource(unsigned int err)
{
  enum anonymous$2 source;
  source=gpg_err_source(err);
  signed int return_value_msgidxof$1;
  return_value_msgidxof$1=msgidxof((signed int)source);
  char *return_value_dgettext$2;
  return_value_dgettext$2=dgettext("libgpg-error", msgstr + (signed long int)msgidx[(signed long int)return_value_msgidxof$1]);
  return return_value_dgettext$2;
}

// _gpgrt__get_std_stream
// file ../../src/estream.c line 3254
struct _gpgrt__stream * _gpgrt__get_std_stream(signed int fd)
{
  struct estream_list_s *list_obj;
  struct _gpgrt__stream *stream = (struct _gpgrt__stream *)(void *)0;
  fd = fd % 3;
  lock_list();
  list_obj = estream_list;
  for( ; !(list_obj == ((struct estream_list_s *)NULL)); list_obj = list_obj->next)
    if(!(list_obj->stream == ((struct _gpgrt__stream *)NULL)))
    {
      if(!(list_obj->stream->intern->is_stdstream == 0u))
      {
        if((signed int)list_obj->stream->intern->stdstream_fd == fd)
        {
          stream = list_obj->stream;
          break;
        }

      }

    }

  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(stream == ((struct _gpgrt__stream *)NULL))
  {
    if(fd == 0)
      tmp_if_expr$2 = custom_std_fds_valid[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      stream=do_fdopen(custom_std_fds[(signed long int)0], "r", 1, 1);

    else
    {
      if(fd == 1)
        tmp_if_expr$1 = custom_std_fds_valid[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        stream=do_fdopen(custom_std_fds[(signed long int)1], "a", 1, 1);

      else
        if(!(custom_std_fds_valid[2l] == 0))
          stream=do_fdopen(custom_std_fds[(signed long int)2], "a", 1, 1);

    }
    if(stream == ((struct _gpgrt__stream *)NULL))
    {
      if(fd == 0)
        stream=do_fpopen(stdin, "r", 1, 1);

      else
        if(fd == 1)
          stream=do_fpopen(stdout, "a", 1, 1);

        else
          stream=do_fpopen(stderr, "a", 1, 1);
    }

    if(stream == ((struct _gpgrt__stream *)NULL))
    {
      stream=do_fpopen((struct _IO_FILE *)(void *)0, fd != 0 ? "a" : "r", 0, 1);
      if(stream == ((struct _gpgrt__stream *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        char *return_value_strerror$4;
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        fprintf(stderr, "fatal: error creating a dummy estream for %d: %s\n", fd, return_value_strerror$4);
        abort();
      }

    }

    stream->intern->is_stdstream = (unsigned int)1;
    stream->intern->stdstream_fd = (unsigned int)fd;
    if(fd == 2)
      es_set_buffering(stream, (char *)(void *)0, 1, (unsigned long int)0);

    fname_set_internal(stream, fd == 0 ? "[stdin]" : (fd == 1 ? "[stdout]" : "[stderr]"), 0);
  }

  unlock_list();
  return stream;
}

// _gpgrt__getc_underflow
// file ../../src/estream.c line 3778
signed int _gpgrt__getc_underflow(struct _gpgrt__stream *stream)
{
  signed int err;
  unsigned char c;
  unsigned long int bytes_read;
  err=es_readn(stream, (void *)&c, (unsigned long int)1, &bytes_read);
  return err != 0 || !(bytes_read != 0ul) ? -1 : (signed int)c;
}

// _gpgrt__pending
// file ../../src/estream.c line 3596
signed int _gpgrt__pending(struct _gpgrt__stream *stream)
{
  signed int ret;
  lock_stream(stream);
  ret=_gpgrt__pending_unlocked(stream);
  unlock_stream(stream);
  return ret;
}

// _gpgrt__pending_unlocked
// file ../../src/estream.c line 3581
signed int _gpgrt__pending_unlocked(struct _gpgrt__stream *stream)
{
  signed int return_value_check_pending$1;
  return_value_check_pending$1=check_pending(stream);
  return return_value_check_pending$1;
}

// _gpgrt__putc_overflow
// file ../../src/estream.c line 3791
signed int _gpgrt__putc_overflow(signed int c, struct _gpgrt__stream *stream)
{
  unsigned char d = (unsigned char)c;
  signed int err;
  err=es_writen(stream, (const void *)&d, (unsigned long int)1, (unsigned long int *)(void *)0);
  return err != 0 ? -1 : c;
}

// _gpgrt__set_std_fd
// file ../../src/estream.c line 3238
void _gpgrt__set_std_fd(signed int no, signed int fd)
{
  lock_list();
  if(no >= 0 && !(no >= 3))
  {
    if(custom_std_fds_valid[(signed long int)no] == 0)
    {
      custom_std_fds[(signed long int)no] = fd;
      custom_std_fds_valid[(signed long int)no] = (unsigned char)1;
    }

  }

  unlock_list();
}

// _gpgrt_clearerr
// file ../../src/estream.c line 3659
void _gpgrt_clearerr(struct _gpgrt__stream *stream)
{
  lock_stream(stream);
  _gpgrt_clearerr_unlocked(stream);
  unlock_stream(stream);
}

// _gpgrt_clearerr_unlocked
// file ../../src/estream.c line 3649
void _gpgrt_clearerr_unlocked(struct _gpgrt__stream *stream)
{
  stream->intern->indicators.eof = (unsigned int)0;
  stream->intern->indicators.err = (unsigned int)0;
}

// _gpgrt_es_init
// file ../../src/gpgrt-int.h line 54
signed int _gpgrt_es_init(void)
{
  static signed int initialized;
  if(initialized == 0)
  {
    initialized = 1;
    atexit(do_deinit);
  }

  return 0;
}

// _gpgrt_estream_asprintf
// file ../../src/estream-printf.c line 1845
signed int _gpgrt_estream_asprintf(char **bufp, const char *format, ...)
{
  signed int rc;
  void **arg_ptr = (void **)&format;
  rc=_gpgrt_estream_vasprintf(bufp, format, arg_ptr);
  arg_ptr = ((void **)NULL);
  return rc;
}

// _gpgrt_estream_bsprintf
// file ../../src/estream-printf.c line 1863
char * _gpgrt_estream_bsprintf(const char *format, ...)
{
  signed int rc;
  void **ap;
  char *buf;
  ap = (void **)&format;
  rc=_gpgrt_estream_vasprintf(&buf, format, ap);
  ap = ((void **)NULL);
  if(!(rc >= 0))
    return (char *)(void *)0;

  else
    return buf;
}

// _gpgrt_estream_format
// file ../../src/estream-printf.h line 126
signed int _gpgrt_estream_format(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, const char *format, void **vaargs)
{
  struct argspec_s argspecs_buffer[5l];
  struct argspec_s *argspecs = argspecs_buffer;
  unsigned long int argspecs_len;
  struct valueitem_s valuetable_buffer[8l];
  struct valueitem_s *valuetable = valuetable_buffer;
  signed int rc;
  unsigned long int argidx;
  unsigned long int validx;
  signed int max_pos;
  unsigned long int nbytes = (unsigned long int)0;
  signed int myerrno;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  myerrno = *return_value___errno_location$1;
  rc=parse_format(format, &argspecs, sizeof(struct argspec_s [5l]) /*240ul*/  / sizeof(struct argspec_s) /*48ul*/ , &argspecs_len);
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$7;
  unsigned long int return_value_strlen$6;
  if(rc == 0)
  {
    argidx = (unsigned long int)0;
    max_pos = 0;
    for( ; !(argidx >= argspecs_len); argidx = argidx + 1ul)
    {
      if(!((argspecs + (signed long int)argidx)->arg_pos == -1))
      {
        if(!(max_pos >= (argspecs + (signed long int)argidx)->arg_pos))
          max_pos = (argspecs + (signed long int)argidx)->arg_pos;

      }

      if(!(max_pos >= (argspecs + (signed long int)argidx)->width_pos))
        max_pos = (argspecs + (signed long int)argidx)->width_pos;

      if(!(max_pos >= (argspecs + (signed long int)argidx)->precision_pos))
        max_pos = (argspecs + (signed long int)argidx)->precision_pos;

    }
    if(max_pos == 0)
    {
      argidx = (unsigned long int)0;
      for( ; !(argidx >= argspecs_len); argidx = argidx + 1ul)
      {
        if((argspecs + (signed long int)argidx)->width == -2)
        {
          max_pos = max_pos + 1;
          (argspecs + (signed long int)argidx)->width_pos = max_pos;
        }

        if((argspecs + (signed long int)argidx)->precision == -2)
        {
          max_pos = max_pos + 1;
          (argspecs + (signed long int)argidx)->precision_pos = max_pos;
        }

        if(!((argspecs + (signed long int)argidx)->arg_pos == -1))
        {
          max_pos = max_pos + 1;
          (argspecs + (signed long int)argidx)->arg_pos = max_pos;
        }

      }
    }

    else
    {
      argidx = (unsigned long int)0;
      for( ; !(argidx >= argspecs_len); argidx = argidx + 1ul)
      {
        if((argspecs + (signed long int)argidx)->arg_pos == 0)
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          if((argspecs + (signed long int)argidx)->width == -2)
            tmp_if_expr$2 = !((argspecs + (signed long int)argidx)->width_pos != 0) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$2 = (_Bool)0;
          tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$3)
          tmp_if_expr$5 = (_Bool)1;

        else
        {
          if((argspecs + (signed long int)argidx)->precision == -2)
            tmp_if_expr$4 = !((argspecs + (signed long int)argidx)->precision_pos != 0) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$5)
          goto leave_einval;

      }
    }
    if(!(max_pos >= 0))
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      return_value_strlen$6=strlen(format);
      tmp_if_expr$7 = (unsigned long int)max_pos >= return_value_strlen$6 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$7)
    {
      if((unsigned long int)max_pos >= 9ul)
      {
        void *return_value_calloc$8;
        return_value_calloc$8=calloc((unsigned long int)max_pos, sizeof(struct valueitem_s) /*32ul*/ );
        valuetable = (struct valueitem_s *)return_value_calloc$8;
        if(valuetable == ((struct valueitem_s *)NULL))
          goto leave_error;

      }

      else
      {
        validx = (unsigned long int)0;
        for( ; !(validx >= 8ul); validx = validx + 1ul)
          (valuetable + (signed long int)validx)->vt = (enum anonymous$13)VALTYPE_UNSUPPORTED;
      }
      argidx = (unsigned long int)0;
      for( ; !(argidx >= argspecs_len); argidx = argidx + 1ul)
      {
        if(!((argspecs + (signed long int)argidx)->arg_pos == -1))
        {
          validx = (unsigned long int)((argspecs + (signed long int)argidx)->arg_pos - 1);
          if((valuetable + (signed long int)validx)->vt != /*enum*/VALTYPE_UNSUPPORTED)
            goto leave_einval;

          (valuetable + (signed long int)validx)->vt = (argspecs + (signed long int)argidx)->vt;
        }

        if((argspecs + (signed long int)argidx)->width == -2)
        {
          validx = (unsigned long int)((argspecs + (signed long int)argidx)->width_pos - 1);
          if((valuetable + (signed long int)validx)->vt != /*enum*/VALTYPE_UNSUPPORTED)
            goto leave_einval;

          (valuetable + (signed long int)validx)->vt = (enum anonymous$13)VALTYPE_INT;
        }

        if((argspecs + (signed long int)argidx)->precision == -2)
        {
          validx = (unsigned long int)((argspecs + (signed long int)argidx)->precision_pos - 1);
          if((valuetable + (signed long int)validx)->vt != /*enum*/VALTYPE_UNSUPPORTED)
            goto leave_einval;

          (valuetable + (signed long int)validx)->vt = (enum anonymous$13)VALTYPE_INT;
        }

      }
      rc=read_values(valuetable, (unsigned long int)max_pos, vaargs);
      if(!(rc == 0))
        goto leave_einval;

      rc=do_format(outfnc, outfncarg, format, argspecs, argspecs_len, valuetable, myerrno, &nbytes);
    }

    else
    {
      do
      {

      leave_einval:
        ;
        signed int *return_value___errno_location$9;
        return_value___errno_location$9=__errno_location();
        *return_value___errno_location$9 = 22;
      }
      while((_Bool)0);

    leave_error:
      ;
      rc = -1;
    }
  }


leave:
  ;
  if(!(valuetable == valuetable_buffer))
    free((void *)valuetable);

  if(!(argspecs == argspecs_buffer))
    free((void *)argspecs);

  return rc;
}

// _gpgrt_estream_fprintf
// file ../../src/estream-printf.c line 1653
signed int _gpgrt_estream_fprintf(struct _IO_FILE *fp, const char *format, ...)
{
  signed int rc;
  void **arg_ptr = (void **)&format;
  rc=_gpgrt_estream_format(plain_stdio_out, (void *)fp, format, arg_ptr);
  arg_ptr = ((void **)NULL);
  return rc;
}

// _gpgrt_estream_printf
// file ../../src/estream-printf.c line 1639
signed int _gpgrt_estream_printf(const char *format, ...)
{
  signed int rc;
  void **arg_ptr = (void **)&format;
  rc=_gpgrt_estream_format(plain_stdio_out, (void *)stderr, format, arg_ptr);
  arg_ptr = ((void **)NULL);
  return rc;
}

// _gpgrt_estream_snprintf
// file ../../src/estream-printf.c line 1739
signed int _gpgrt_estream_snprintf(char *buf, unsigned long int bufsize, const char *format, ...)
{
  signed int rc;
  void **arg_ptr = (void **)&format;
  rc=_gpgrt_estream_vsnprintf(buf, bufsize, format, arg_ptr);
  arg_ptr = ((void **)NULL);
  return rc;
}

// _gpgrt_estream_vasprintf
// file ../../src/estream-printf.c line 1804
signed int _gpgrt_estream_vasprintf(char **bufp, const char *format, void **arg_ptr)
{
  struct dynamic_buffer_parm_s parm;
  signed int rc;
  parm.error_flag = 0;
  parm.alloced = (unsigned long int)512;
  parm.used = (unsigned long int)0;
  void *return_value__gpgrt_realloc$1;
  return_value__gpgrt_realloc$1=_gpgrt_realloc((void *)0, parm.alloced);
  parm.buffer = (char *)return_value__gpgrt_realloc$1;
  if(parm.buffer == ((char *)NULL))
  {
    *bufp = (char *)(void *)0;
    return -1;
  }

  else
  {
    rc=_gpgrt_estream_format(dynamic_buffer_out, (void *)&parm, format, arg_ptr);
    if(rc == 0)
      rc=dynamic_buffer_out((void *)&parm, "", (unsigned long int)1);

    if(!(parm.error_flag == 0) && !(rc == -1))
    {
      rc = -1;
      do
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        *return_value___errno_location$2 = parm.error_flag;
      }
      while((_Bool)0);
    }

    if(rc == -1)
    {
      memset((void *)parm.buffer, 0, parm.used);
      if(!(parm.buffer == ((char *)NULL)))
        _gpgrt_realloc((void *)parm.buffer, (unsigned long int)0);

      *bufp = (char *)(void *)0;
      return -1;
    }

    else
    {
      /* assertion parm.used */
      assert(parm.used != 0ul);
      *bufp = parm.buffer;
      return (signed int)(parm.used - (unsigned long int)1);
    }
  }
}

// _gpgrt_estream_vfprintf
// file ../../src/estream-printf.c line 1667
signed int _gpgrt_estream_vfprintf(struct _IO_FILE *fp, const char *format, void **arg_ptr)
{
  signed int return_value__gpgrt_estream_format$1;
  return_value__gpgrt_estream_format$1=_gpgrt_estream_format(plain_stdio_out, (void *)fp, format, arg_ptr);
  return return_value__gpgrt_estream_format$1;
}

// _gpgrt_estream_vsnprintf
// file ../../src/estream-printf.c line 1714
signed int _gpgrt_estream_vsnprintf(char *buf, unsigned long int bufsize, const char *format, void **arg_ptr)
{
  struct fixed_buffer_parm_s parm;
  signed int rc;
  parm.size = bufsize;
  parm.count = (unsigned long int)0;
  parm.used = (unsigned long int)0;
  parm.buffer = bufsize != 0ul ? buf : (char *)(void *)0;
  rc=_gpgrt_estream_format(fixed_buffer_out, (void *)&parm, format, arg_ptr);
  if(rc == 0)
    rc=fixed_buffer_out((void *)&parm, "", (unsigned long int)1);

  if(rc == -1)
    return -1;

  else
  {
    if(parm.count >= parm.size && !(parm.size == 0ul) && !(buf == ((char *)NULL)) && !(bufsize == 0ul))
      buf[(signed long int)(parm.size - (unsigned long int)1)] = (char)0;

    parm.count = parm.count - 1ul;
    return (signed int)parm.count;
  }
}

// _gpgrt_fclose
// file ../../src/estream.c line 3389
signed int _gpgrt_fclose(struct _gpgrt__stream *stream)
{
  signed int err;
  err=do_close(stream, 0);
  return err;
}

// _gpgrt_fclose_snatch
// file ../../src/estream.c line 3408
signed int _gpgrt_fclose_snatch(struct _gpgrt__stream *stream, void **r_buffer, unsigned long int *r_buflen)
{
  signed int err;
  if(!(r_buffer == ((void **)NULL)))
  {
    signed int (*func_ioctl)(void *, signed int, void *, unsigned long int *) = stream->intern->func_ioctl;
    unsigned long int buflen;
    *r_buffer = (void *)0;
    if(func_ioctl == ((signed int (*)(void *, signed int, void *, unsigned long int *))NULL))
    {
      do
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        *return_value___errno_location$1 = 95;
      }
      while((_Bool)0);
      err = -1;
      goto leave;
    }

    if(!(stream->flags.writing == 0u))
    {
      err=es_flush(stream);
      if(!(err == 0))
        goto leave;

      stream->flags.writing = (unsigned int)0;
    }

    err=func_ioctl(stream->intern->cookie, 1, (void *)r_buffer, &buflen);
    if(!(r_buflen == ((unsigned long int *)NULL)))
      *r_buflen = buflen;

  }

  err=do_close(stream, 0);

leave:
  ;
  if(!(r_buffer == ((void **)NULL)) && !(err == 0))
  {
    mem_free(*r_buffer);
    *r_buffer = (void *)0;
  }

  return err;
}

// _gpgrt_fdopen
// file ../../src/estream.c line 3075
struct _gpgrt__stream * _gpgrt_fdopen(signed int filedes, const char *mode)
{
  struct _gpgrt__stream *return_value_do_fdopen$1;
  return_value_do_fdopen$1=do_fdopen(filedes, mode, 0, 0);
  return return_value_do_fdopen$1;
}

// _gpgrt_fdopen_nc
// file ../../src/estream.c line 3082
struct _gpgrt__stream * _gpgrt_fdopen_nc(signed int filedes, const char *mode)
{
  struct _gpgrt__stream *return_value_do_fdopen$1;
  return_value_do_fdopen$1=do_fdopen(filedes, mode, 1, 0);
  return return_value_do_fdopen$1;
}

// _gpgrt_feof
// file ../../src/estream.c line 3616
signed int _gpgrt_feof(struct _gpgrt__stream *stream)
{
  signed int ret;
  lock_stream(stream);
  ret=_gpgrt_feof_unlocked(stream);
  unlock_stream(stream);
  return ret;
}

// _gpgrt_feof_unlocked
// file ../../src/estream.c line 3609
signed int _gpgrt_feof_unlocked(struct _gpgrt__stream *stream)
{
  return (signed int)stream->intern->indicators.eof;
}

// _gpgrt_ferror
// file ../../src/estream.c line 3636
signed int _gpgrt_ferror(struct _gpgrt__stream *stream)
{
  signed int ret;
  lock_stream(stream);
  ret=_gpgrt_ferror_unlocked(stream);
  unlock_stream(stream);
  return ret;
}

// _gpgrt_ferror_unlocked
// file ../../src/estream.c line 3629
signed int _gpgrt_ferror_unlocked(struct _gpgrt__stream *stream)
{
  return (signed int)stream->intern->indicators.err;
}

// _gpgrt_fflush
// file ../../src/estream.c line 3685
signed int _gpgrt_fflush(struct _gpgrt__stream *stream)
{
  signed int err;
  if(!(stream == ((struct _gpgrt__stream *)NULL)))
  {
    lock_stream(stream);
    err=do_fflush(stream);
    unlock_stream(stream);
  }

  else
  {
    struct estream_list_s *item;
    err = 0;
    lock_list();
    item = estream_list;
    for( ; !(item == ((struct estream_list_s *)NULL)); item = item->next)
      if(!(item->stream == ((struct _gpgrt__stream *)NULL)))
      {
        lock_stream(item->stream);
        signed int return_value_do_fflush$1;
        return_value_do_fflush$1=do_fflush(item->stream);
        err = err | return_value_do_fflush$1;
        unlock_stream(item->stream);
      }

    unlock_list();
  }
  return err != 0 ? -1 : 0;
}

// _gpgrt_fgetc
// file ../../src/estream.c line 3803
signed int _gpgrt_fgetc(struct _gpgrt__stream *stream)
{
  signed int ret;
  lock_stream(stream);
  _Bool tmp_if_expr$1;
  if(stream->flags.writing == 0u)
    tmp_if_expr$1 = stream->data_offset < stream->data_len ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = !(stream->unread_data_len != 0ul) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  signed int tmp_if_expr$5;
  unsigned long int tmp_post$3;
  signed int return_value__gpgrt__getc_underflow$4;
  if(tmp_if_expr$2)
  {
    tmp_post$3 = stream->data_offset;
    stream->data_offset = stream->data_offset + 1ul;
    tmp_if_expr$5 = (signed int)stream->buffer[(signed long int)tmp_post$3];
  }

  else
  {
    return_value__gpgrt__getc_underflow$4=_gpgrt__getc_underflow(stream);
    tmp_if_expr$5 = return_value__gpgrt__getc_underflow$4;
  }
  ret = tmp_if_expr$5;
  unlock_stream(stream);
  return ret;
}

// _gpgrt_fgets
// file ../../src/estream.c line 3925
char * _gpgrt_fgets(char * restrict buffer, signed int length, struct _gpgrt__stream * restrict stream)
{
  unsigned char *s = (unsigned char *)buffer;
  signed int c;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  signed int tmp_if_expr$5;
  unsigned long int tmp_post$3;
  signed int return_value__gpgrt__getc_underflow$4;
  unsigned char *tmp_post$6;
  unsigned char *tmp_post$7;
  if(length == 0)
    return (char *)(void *)0;

  else
  {
    c = -1;
    lock_stream(stream);
    for( ; length >= 2; length = length - 1)
    {
      if(stream->flags.writing == 0u)
        tmp_if_expr$1 = stream->data_offset < stream->data_len ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = !(stream->unread_data_len != 0ul) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
      {
        tmp_post$3 = stream->data_offset;
        stream->data_offset = stream->data_offset + 1ul;
        tmp_if_expr$5 = (signed int)stream->buffer[(signed long int)tmp_post$3];
      }

      else
      {
        return_value__gpgrt__getc_underflow$4=_gpgrt__getc_underflow(stream);
        tmp_if_expr$5 = return_value__gpgrt__getc_underflow$4;
      }
      c = tmp_if_expr$5;
      if(c == -1)
        break;

      if(c == 10)
        break;

      tmp_post$6 = s;
      s = s + 1l;
      *tmp_post$6 = (unsigned char)c;
    }
    unlock_stream(stream);
    if(s == (unsigned char *)buffer && c == -1)
      return (char *)(void *)0;

    else
    {
      if(length >= 2 && !(c == -1))
      {
        tmp_post$7 = s;
        s = s + 1l;
        *tmp_post$7 = (unsigned char)c;
      }

      *s = (unsigned char)0;
      return buffer;
    }
  }
}

// _gpgrt_fileno
// file ../../src/estream.c line 3551
signed int _gpgrt_fileno(struct _gpgrt__stream *stream)
{
  signed int ret;
  lock_stream(stream);
  ret=_gpgrt_fileno_unlocked(stream);
  unlock_stream(stream);
  return ret;
}

// _gpgrt_fileno_unlocked
// file ../../src/estream.c line 3492
signed int _gpgrt_fileno_unlocked(struct _gpgrt__stream *stream)
{
  struct _gpgrt_syshd syshd;
  signed int return_value__gpgrt_syshd_unlocked$1;
  return_value__gpgrt_syshd_unlocked$1=_gpgrt_syshd_unlocked(stream, &syshd);
  if(!(return_value__gpgrt_syshd_unlocked$1 == 0))
    return -1;

  else
    switch((signed int)syshd.type)
    {
      case GPGRT_SYSHD_FD:
        return syshd.u.fd;
      case GPGRT_SYSHD_SOCK:
        return syshd.u.sock;
      default:
      {
        do
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          *return_value___errno_location$2 = 22;
        }
        while((_Bool)0);
        return -1;
      }
    }
}

// _gpgrt_flockfile
// file ../../src/estream.c line 3530
void _gpgrt_flockfile(struct _gpgrt__stream *stream)
{
  lock_stream(stream);
}

// _gpgrt_fname_get
// file ../../src/estream.c line 4734
const char * _gpgrt_fname_get(struct _gpgrt__stream *stream)
{
  const char *fname;
  lock_stream(stream);
  fname = stream->intern->printable_fname;
  if(!(fname == ((const char *)NULL)))
    stream->intern->printable_fname_inuse = (unsigned int)1;

  unlock_stream(stream);
  if(fname == ((const char *)NULL))
    fname = "[?]";

  return fname;
}

// _gpgrt_fname_set
// file ../../src/estream.c line 4719
void _gpgrt_fname_set(struct _gpgrt__stream *stream, const char *fname)
{
  if(!(fname == ((const char *)NULL)))
  {
    lock_stream(stream);
    fname_set_internal(stream, fname, 1);
    unlock_stream(stream);
  }

}

// _gpgrt_fopen
// file ../../src/estream.c line 2836
struct _gpgrt__stream * _gpgrt_fopen(const char * restrict path, const char * restrict mode)
{
  unsigned int modeflags;
  unsigned int cmode;
  signed int samethread;
  signed int create_called;
  struct _gpgrt__stream *stream;
  void *cookie;
  signed int err;
  signed int fd;
  struct _gpgrt_syshd syshd;
  stream = (struct _gpgrt__stream *)(void *)0;
  cookie = (void *)0;
  create_called = 0;
  err=parse_mode(mode, &modeflags, &samethread, &cmode);
  if(err == 0)
  {
    err=func_file_create(&cookie, &fd, path, modeflags, cmode);
    if(err == 0)
    {
      syshd.type = (enum gpgrt_syshd_types)GPGRT_SYSHD_FD;
      syshd.u.fd = fd;
      create_called = 1;
      err=es_create(&stream, cookie, &syshd, estream_functions_fd, modeflags, samethread, 0);
      if(err == 0)
      {
        if(!(path == ((const char *)NULL)) && !(stream == ((struct _gpgrt__stream *)NULL)))
          fname_set_internal(stream, path, 1);

      }

    }

  }


out:
  ;
  if(!(create_called == 0) && !(err == 0))
    estream_functions_fd.func_close(cookie);

  return stream;
}

// _gpgrt_fopencookie
// file ../../src/estream.c line 3003
struct _gpgrt__stream * _gpgrt_fopencookie(void * restrict cookie, const char * restrict mode, struct _gpgrt_cookie_io_functions functions)
{
  unsigned int modeflags;
  signed int samethread;
  struct _gpgrt__stream *stream;
  signed int err;
  struct _gpgrt_syshd syshd;
  stream = (struct _gpgrt__stream *)(void *)0;
  modeflags = (unsigned int)0;
  err=parse_mode(mode, &modeflags, &samethread, (unsigned int *)(void *)0);
  if(err == 0)
  {
    memset((void *)&syshd, 0, sizeof(struct _gpgrt_syshd) /*16ul*/ );
    err=es_create(&stream, cookie, &syshd, functions, modeflags, samethread, 0);
  }


out:
  ;
  return stream;
}

// _gpgrt_fopenmem
// file ../../src/estream.c line 2935
struct _gpgrt__stream * _gpgrt_fopenmem(unsigned long int memlimit, const char * restrict mode)
{
  unsigned int modeflags;
  signed int samethread;
  struct _gpgrt__stream *stream = (struct _gpgrt__stream *)(void *)0;
  void *cookie = (void *)0;
  struct _gpgrt_syshd syshd;
  signed int return_value_parse_mode$1;
  return_value_parse_mode$1=parse_mode(mode, &modeflags, &samethread, (unsigned int *)(void *)0);
  if(!(return_value_parse_mode$1 == 0))
    return (struct _gpgrt__stream *)(void *)0;

  else
  {
    modeflags = modeflags | (unsigned int)02;
    signed int return_value_func_mem_create$2;
    return_value_func_mem_create$2=func_mem_create(&cookie, (unsigned char *)(void *)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)8192, (unsigned int)1, mem_realloc, mem_free, modeflags, memlimit);
    if(!(return_value_func_mem_create$2 == 0))
      return (struct _gpgrt__stream *)(void *)0;

    else
    {
      memset((void *)&syshd, 0, sizeof(struct _gpgrt_syshd) /*16ul*/ );
      signed int return_value_es_create$3;
      return_value_es_create$3=es_create(&stream, cookie, &syshd, estream_functions_mem, modeflags, samethread, 0);
      if(!(return_value_es_create$3 == 0))
        estream_functions_mem.func_close(cookie);

      if(!(stream == ((struct _gpgrt__stream *)NULL)))
        stream->intern->func_ioctl = es_func_mem_ioctl;

      return stream;
    }
  }
}

// _gpgrt_fopenmem_init
// file ../../src/estream.c line 2972
struct _gpgrt__stream * _gpgrt_fopenmem_init(unsigned long int memlimit, const char * restrict mode, const void *data, unsigned long int datalen)
{
  struct _gpgrt__stream *stream;
  if(!(memlimit == 0ul) && !(memlimit >= datalen))
    memlimit = datalen;

  stream=_gpgrt_fopenmem(memlimit, mode);
  if(!(data == NULL) && !(stream == ((struct _gpgrt__stream *)NULL)) && !(datalen == 0ul))
  {
    signed int return_value_es_writen$3;
    return_value_es_writen$3=es_writen(stream, data, datalen, (unsigned long int *)(void *)0);
    if(!(return_value_es_writen$3 == 0))
    {
      signed int saveerrno;
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      saveerrno = *return_value___errno_location$1;
      _gpgrt_fclose(stream);
      stream = (struct _gpgrt__stream *)(void *)0;
      do
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        *return_value___errno_location$2 = saveerrno;
      }
      while((_Bool)0);
    }

    else
    {
      es_seek(stream, 0L, 0, (signed long int *)(void *)0);
      stream->intern->indicators.eof = (unsigned int)0;
      stream->intern->indicators.err = (unsigned int)0;
    }
  }

  return stream;
}

// _gpgrt_fpopen
// file ../../src/estream.c line 3137
struct _gpgrt__stream * _gpgrt_fpopen(struct _IO_FILE *fp, const char *mode)
{
  struct _gpgrt__stream *return_value_do_fpopen$1;
  return_value_do_fpopen$1=do_fpopen(fp, mode, 0, 0);
  return return_value_do_fpopen$1;
}

// _gpgrt_fpopen_nc
// file ../../src/estream.c line 3145
struct _gpgrt__stream * _gpgrt_fpopen_nc(struct _IO_FILE *fp, const char *mode)
{
  struct _gpgrt__stream *return_value_do_fpopen$1;
  return_value_do_fpopen$1=do_fpopen(fp, mode, 1, 0);
  return return_value_do_fpopen$1;
}

// _gpgrt_fprintf
// file ../../src/estream.c line 4202
signed int _gpgrt_fprintf(struct _gpgrt__stream * restrict stream, const char * restrict format, ...)
{
  signed int ret;
  void **ap = (void **)&format;
  lock_stream(stream);
  ret=es_print(stream, format, ap);
  unlock_stream(stream);
  ap = ((void **)NULL);
  return ret;
}

// _gpgrt_fprintf_unlocked
// file ../../src/estream.c line 4187
signed int _gpgrt_fprintf_unlocked(struct _gpgrt__stream * restrict stream, const char * restrict format, ...)
{
  signed int ret;
  void **ap = (void **)&format;
  ret=es_print(stream, format, ap);
  ap = ((void **)NULL);
  return ret;
}

// _gpgrt_fputc
// file ../../src/estream.c line 3816
signed int _gpgrt_fputc(signed int c, struct _gpgrt__stream *stream)
{
  signed int ret;
  lock_stream(stream);
  _Bool tmp_if_expr$1;
  if(!(stream->flags.writing == 0u))
    tmp_if_expr$1 = stream->data_offset < stream->buffer_size ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  signed int tmp_if_expr$4;
  unsigned long int tmp_post$2;
  signed int return_value__gpgrt__putc_overflow$3;
  if(!(c == 10) && tmp_if_expr$1)
  {
    tmp_post$2 = stream->data_offset;
    stream->data_offset = stream->data_offset + 1ul;
    stream->buffer[(signed long int)tmp_post$2] = (unsigned char)c;
    tmp_if_expr$4 = (signed int)stream->buffer[(signed long int)tmp_post$2];
  }

  else
  {
    return_value__gpgrt__putc_overflow$3=_gpgrt__putc_overflow(c, stream);
    tmp_if_expr$4 = return_value__gpgrt__putc_overflow$3;
  }
  ret = tmp_if_expr$4;
  unlock_stream(stream);
  return ret;
}

// _gpgrt_fputs
// file ../../src/estream.c line 3967
signed int _gpgrt_fputs(const char * restrict s, struct _gpgrt__stream * restrict stream)
{
  unsigned long int length;
  signed int err;
  length=strlen(s);
  lock_stream(stream);
  err=es_writen(stream, (const void *)s, length, (unsigned long int *)(void *)0);
  unlock_stream(stream);
  return err != 0 ? -1 : 0;
}

// _gpgrt_fputs_unlocked
// file ../../src/estream.c line 3955
signed int _gpgrt_fputs_unlocked(const char * restrict s, struct _gpgrt__stream * restrict stream)
{
  unsigned long int length;
  signed int err;
  length=strlen(s);
  err=es_writen(stream, (const void *)s, length, (unsigned long int *)(void *)0);
  return err != 0 ? -1 : 0;
}

// _gpgrt_fread
// file ../../src/estream.c line 3883
unsigned long int _gpgrt_fread(void * restrict ptr, unsigned long int size, unsigned long int nitems, struct _gpgrt__stream * restrict stream)
{
  unsigned long int ret;
  unsigned long int bytes;
  if(!(nitems * size == 0ul))
  {
    lock_stream(stream);
    es_readn(stream, ptr, size * nitems, &bytes);
    unlock_stream(stream);
    ret = bytes / size;
  }

  else
    ret = (unsigned long int)0;
  return ret;
}

// _gpgrt_free
// file ../../src/init.c line 199
void _gpgrt_free(void *a)
{
  _gpgrt_realloc(a, (unsigned long int)0);
}

// _gpgrt_freopen
// file ../../src/estream.c line 3320
struct _gpgrt__stream * _gpgrt_freopen(const char * restrict path, const char * restrict mode, struct _gpgrt__stream * restrict stream)
{
  signed int err;
  if(!(path == ((const char *)NULL)))
  {
    unsigned int modeflags;
    unsigned int cmode;
    signed int dummy;
    signed int samethread;
    signed int create_called;
    void *cookie;
    signed int fd;
    struct _gpgrt_syshd syshd;
    cookie = (void *)0;
    create_called = 0;
    samethread = (signed int)stream->intern->samethread;
    lock_stream(stream);
    es_deinitialize(stream);
    err=parse_mode(mode, &modeflags, &dummy, &cmode);
    if(err == 0)
    {
      (void)dummy;
      err=func_file_create(&cookie, &fd, path, modeflags, cmode);
      if(err == 0)
      {
        syshd.type = (enum gpgrt_syshd_types)GPGRT_SYSHD_FD;
        syshd.u.fd = fd;
        create_called = 1;
        init_stream_obj(stream, cookie, &syshd, estream_functions_fd, modeflags, samethread);
      }

    }


  leave:
    ;
    if(!(err == 0))
    {
      if(!(create_called == 0))
        es_func_fd_destroy(cookie);

      do_close(stream, 0);
      stream = (struct _gpgrt__stream *)(void *)0;
    }

    else
    {
      if(!(path == ((const char *)NULL)))
        fname_set_internal(stream, path, 1);

      unlock_stream(stream);
    }
  }

  else
  {
    do
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 22;
    }
    while((_Bool)0);
    es_deinitialize(stream);
    do_close(stream, 0);
    stream = (struct _gpgrt__stream *)(void *)0;
  }
  return stream;
}

// _gpgrt_fseek
// file ../../src/estream.c line 3715
signed int _gpgrt_fseek(struct _gpgrt__stream *stream, signed long int offset, signed int whence)
{
  signed int err;
  lock_stream(stream);
  err=es_seek(stream, offset, whence, (signed long int *)(void *)0);
  unlock_stream(stream);
  return err;
}

// _gpgrt_fseeko
// file ../../src/estream.c line 3728
signed int _gpgrt_fseeko(struct _gpgrt__stream *stream, signed long int offset, signed int whence)
{
  signed int err;
  lock_stream(stream);
  err=es_seek(stream, offset, whence, (signed long int *)(void *)0);
  unlock_stream(stream);
  return err;
}

// _gpgrt_ftell
// file ../../src/estream.c line 3741
signed long int _gpgrt_ftell(struct _gpgrt__stream *stream)
{
  signed long int ret;
  lock_stream(stream);
  ret=es_offset_calculate(stream);
  unlock_stream(stream);
  return ret;
}

// _gpgrt_ftello
// file ../../src/estream.c line 3754
signed long int _gpgrt_ftello(struct _gpgrt__stream *stream)
{
  signed long int ret = (signed long int)-1;
  lock_stream(stream);
  ret=es_offset_calculate(stream);
  unlock_stream(stream);
  return ret;
}

// _gpgrt_ftrylockfile
// file ../../src/estream.c line 3537
signed int _gpgrt_ftrylockfile(struct _gpgrt__stream *stream)
{
  signed int return_value_trylock_stream$1;
  return_value_trylock_stream$1=trylock_stream(stream);
  return return_value_trylock_stream$1;
}

// _gpgrt_funlockfile
// file ../../src/estream.c line 3544
void _gpgrt_funlockfile(struct _gpgrt__stream *stream)
{
  unlock_stream(stream);
}

// _gpgrt_fwrite
// file ../../src/estream.c line 3904
unsigned long int _gpgrt_fwrite(const void * restrict ptr, unsigned long int size, unsigned long int nitems, struct _gpgrt__stream * restrict stream)
{
  unsigned long int ret;
  unsigned long int bytes;
  if(!(nitems * size == 0ul))
  {
    lock_stream(stream);
    es_writen(stream, ptr, size * nitems, &bytes);
    unlock_stream(stream);
    ret = bytes / size;
  }

  else
    ret = (unsigned long int)0;
  return ret;
}

// _gpgrt_get_nonblock
// file ../../src/estream.c line 4473
signed int _gpgrt_get_nonblock(struct _gpgrt__stream *stream)
{
  signed int ret;
  lock_stream(stream);
  ret = (signed int)!(!((stream->intern->modeflags & (unsigned int)04000) != 0u));
  unlock_stream(stream);
  return ret;
}

// _gpgrt_get_std_stream
// file ../../src/visibility.c line 277
struct _gpgrt__stream * _gpgrt_get_std_stream(signed int fd)
{
  struct _gpgrt__stream *return_value__gpgrt__get_std_stream$1;
  return_value__gpgrt__get_std_stream$1=_gpgrt__get_std_stream(fd);
  return return_value__gpgrt__get_std_stream$1;
}

// _gpgrt_getc_underflow
// file ../../src/visibility.c line 391
signed int _gpgrt_getc_underflow(struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt__getc_underflow$1;
  return_value__gpgrt__getc_underflow$1=_gpgrt__getc_underflow(stream);
  return return_value__gpgrt__getc_underflow$1;
}

// _gpgrt_getline
// file ../../src/estream.c line 3982
signed long int _gpgrt_getline(char * restrict * restrict lineptr, unsigned long int * restrict n, struct _gpgrt__stream * restrict stream)
{
  char *line = (char *)(void *)0;
  unsigned long int line_n = (unsigned long int)0;
  signed int err;
  lock_stream(stream);
  err=doreadline(stream, (unsigned long int)0, &line, &line_n);
  unlock_stream(stream);
  if(err == 0)
  {
    if(!(*n == 0ul))
    {
      if(!(*n >= 1ul + line_n))
      {
        void *p;
        p=mem_realloc((void *)*lineptr, line_n + (unsigned long int)1);
        if(p == NULL)
          err = -1;

        else
          if(!(*lineptr == (char *)p))
            *lineptr = (char *)p;

      }

      if(err == 0)
      {
        memcpy((void *)*lineptr, (const void *)line, line_n + (unsigned long int)1);
        if(!(*n == line_n))
          *n = line_n;

      }

      mem_free((void *)line);
    }

    else
    {
      *lineptr = line;
      *n = line_n;
    }
  }


out:
  ;
  return err != 0 ? (signed long int)err : (signed long int)line_n;
}

// _gpgrt_lock_destroy
// file ../../src/posix-lock.c line 237
enum anonymous$4 _gpgrt_lock_destroy(struct anonymous$5 *lockhd)
{
  struct anonymous$10 *lock;
  lock=get_lock_object(lockhd);
  signed int rc;
  enum anonymous$4 return_value_gpg_err_code_from_errno$1;
  rc=pthread_mutex_destroy(&lock->u.mtx);
  if(!(rc == 0))
  {
    return_value_gpg_err_code_from_errno$1=gpg_err_code_from_errno(rc);
    rc = (signed int)return_value_gpg_err_code_from_errno$1;
  }

  else
  {
    struct anonymous$5 tmp = { ._vers=(signed long int)1, .u={ ._priv={ (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0, (volatile char)0 } } };
    memcpy((void *)lockhd, (const void *)&tmp, sizeof(struct anonymous$5) /*48ul*/ );
  }
  return (enum anonymous$4)rc;
}

// _gpgrt_lock_init
// file ../../src/posix-lock.c line 128
enum anonymous$4 _gpgrt_lock_init(struct anonymous$5 *lockhd)
{
  struct anonymous$10 *lock = (struct anonymous$10 *)lockhd;
  signed int rc;
  if(lock->vers == 0l)
    lock->vers = (signed long int)1;

  else
    lock=get_lock_object(lockhd);
  enum anonymous$4 return_value_gpg_err_code_from_errno$1;
  rc=pthread_mutex_init(&lock->u.mtx, (const union anonymous$8 *)(void *)0);
  if(!(rc == 0))
  {
    return_value_gpg_err_code_from_errno$1=gpg_err_code_from_errno(rc);
    rc = (signed int)return_value_gpg_err_code_from_errno$1;
  }

  return (enum anonymous$4)rc;
}

// _gpgrt_lock_lock
// file ../../src/posix-lock.c line 166
enum anonymous$4 _gpgrt_lock_lock(struct anonymous$5 *lockhd)
{
  struct anonymous$10 *lock;
  lock=get_lock_object(lockhd);
  signed int rc;
  enum anonymous$4 return_value_gpg_err_code_from_errno$1;
  rc=pthread_mutex_lock(&lock->u.mtx);
  if(!(rc == 0))
  {
    return_value_gpg_err_code_from_errno$1=gpg_err_code_from_errno(rc);
    rc = (signed int)return_value_gpg_err_code_from_errno$1;
  }

  return (enum anonymous$4)rc;
}

// _gpgrt_lock_trylock
// file ../../src/posix-lock.c line 189
enum anonymous$4 _gpgrt_lock_trylock(struct anonymous$5 *lockhd)
{
  struct anonymous$10 *lock;
  lock=get_lock_object(lockhd);
  signed int rc;
  enum anonymous$4 return_value_gpg_err_code_from_errno$1;
  rc=pthread_mutex_trylock(&lock->u.mtx);
  if(!(rc == 0))
  {
    return_value_gpg_err_code_from_errno$1=gpg_err_code_from_errno(rc);
    rc = (signed int)return_value_gpg_err_code_from_errno$1;
  }

  return (enum anonymous$4)rc;
}

// _gpgrt_lock_unlock
// file ../../src/posix-lock.c line 212
enum anonymous$4 _gpgrt_lock_unlock(struct anonymous$5 *lockhd)
{
  struct anonymous$10 *lock;
  lock=get_lock_object(lockhd);
  signed int rc;
  enum anonymous$4 return_value_gpg_err_code_from_errno$1;
  rc=pthread_mutex_unlock(&lock->u.mtx);
  if(!(rc == 0))
  {
    return_value_gpg_err_code_from_errno$1=gpg_err_code_from_errno(rc);
    rc = (signed int)return_value_gpg_err_code_from_errno$1;
  }

  return (enum anonymous$4)rc;
}

// _gpgrt_malloc
// file ../../src/init.c line 189
void * _gpgrt_malloc(unsigned long int n)
{
  if(n == 0ul)
    n = n + 1ul;

  void *return_value__gpgrt_realloc$1;
  return_value__gpgrt_realloc$1=_gpgrt_realloc((void *)0, n);
  return return_value__gpgrt_realloc$1;
}

// _gpgrt_mopen
// file ../../src/estream.c line 2896
struct _gpgrt__stream * _gpgrt_mopen(void * restrict data, unsigned long int data_n, unsigned long int data_len, unsigned int grow, void * (*func_realloc)(void *, unsigned long int), void (*func_free)(void *), const char * restrict mode)
{
  signed int create_called = 0;
  struct _gpgrt__stream *stream = (struct _gpgrt__stream *)(void *)0;
  void *cookie = (void *)0;
  unsigned int modeflags;
  signed int samethread;
  signed int err;
  struct _gpgrt_syshd syshd;
  err=parse_mode(mode, &modeflags, &samethread, (unsigned int *)(void *)0);
  if(err == 0)
  {
    err=func_mem_create(&cookie, (unsigned char *)data, data_n, data_len, (unsigned long int)8192, grow, func_realloc, func_free, modeflags, (unsigned long int)0);
    if(err == 0)
    {
      memset((void *)&syshd, 0, sizeof(struct _gpgrt_syshd) /*16ul*/ );
      create_called = 1;
      err=es_create(&stream, cookie, &syshd, estream_functions_mem, modeflags, samethread, 0);
    }

  }


out:
  ;
  if(!(create_called == 0) && !(err == 0))
    estream_functions_mem.func_close(cookie);

  return stream;
}

// _gpgrt_onclose
// file ../../src/estream.c line 3478
signed int _gpgrt_onclose(struct _gpgrt__stream *stream, signed int mode, void (*fnc)(struct _gpgrt__stream *, void *), void *fnc_value)
{
  signed int err;
  lock_stream(stream);
  err=do_onclose(stream, mode, fnc, fnc_value);
  unlock_stream(stream);
  return err;
}

// _gpgrt_opaque_get
// file ../../src/estream.c line 4679
void * _gpgrt_opaque_get(struct _gpgrt__stream *stream)
{
  void *opaque;
  lock_stream(stream);
  es_opaque_ctrl(stream, (void *)0, &opaque);
  unlock_stream(stream);
  return opaque;
}

// _gpgrt_opaque_set
// file ../../src/estream.c line 4670
void _gpgrt_opaque_set(struct _gpgrt__stream *stream, void *opaque)
{
  lock_stream(stream);
  es_opaque_ctrl(stream, opaque, (void ** restrict )(void *)0);
  unlock_stream(stream);
}

// _gpgrt_pending
// file ../../src/visibility.c line 301
signed int _gpgrt_pending(struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt__pending$1;
  return_value__gpgrt__pending$1=_gpgrt__pending(stream);
  return return_value__gpgrt__pending$1;
}

// _gpgrt_pending_unlocked
// file ../../src/visibility.c line 307
signed int _gpgrt_pending_unlocked(struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt__pending_unlocked$1;
  return_value__gpgrt__pending_unlocked$1=_gpgrt__pending_unlocked(stream);
  return return_value__gpgrt__pending_unlocked$1;
}

// _gpgrt_poll
// file ../../src/estream.c line 4496
signed int _gpgrt_poll(struct _gpgrt_poll_s *fds, unsigned int nfds, signed int timeout)
{
  struct _gpgrt_poll_s *item;
  signed int count = 0;
  struct anonymous$1 readfds;
  struct anonymous$1 writefds;
  struct anonymous$1 exceptfds;
  signed int any_readfd;
  signed int any_writefd;
  signed int any_exceptfd;
  signed int idx;
  signed int max_fd;
  signed int fd;
  signed int ret;
  signed int any;
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$3;
  if(fds == ((struct _gpgrt_poll_s *)NULL))
  {
    do
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 22;
    }
    while((_Bool)0);
    return -1;
  }

  else
  {
    item = fds;
    idx = 0;
    for( ; !((unsigned int)idx >= nfds); idx = idx + 1)
    {
      item->got_read = (unsigned int)0;
      item->got_write = (unsigned int)0;
      item->got_oob = (unsigned int)0;
      item->got_rdhup = (unsigned int)0;
      item->got_err = (unsigned int)0;
      item->got_hup = (unsigned int)0;
      item->got_nval = (unsigned int)0;
      item = item + 1l;
    }
    item = fds;
    idx = 0;
    for( ; !((unsigned int)idx >= nfds); idx = idx + 1)
    {
      if(item->ignore == 0u)
      {
        if(!(item->want_read == 0u))
        {
          signed int return_value__gpgrt__pending$2;
          return_value__gpgrt__pending$2=_gpgrt__pending(item->stream);
          if(!(return_value__gpgrt__pending$2 == 0))
          {
            item->got_read = (unsigned int)1;
            count = count + 1;
          }

        }

      }

      item = item + 1l;
    }
    item = fds;
    idx = 0;
    for( ; !((unsigned int)idx >= nfds); idx = idx + 1)
      item = item + 1l;
    if(!(count == 0))
      return count;

    else
    {
      any_exceptfd = 0;
      any_writefd = any_exceptfd;
      any_readfd = any_writefd;
      max_fd = 0;
      item = fds;
      idx = 0;
      for( ; !((unsigned int)idx >= nfds); idx = idx + 1)
      {
        if(item->ignore == 0u)
        {
          fd=_gpgrt_fileno(item->stream);
          if(!(fd == -1))
          {
            if(!(item->want_read == 0u))
            {
              if(any_readfd == 0)
              {
                do
                {
                  signed int __d0;
                  signed int _gpgrt_poll$$1$$5$$1$$1$$1$$1$$__d1;
                  asm("cld; rep; stosq" : "=c"(__d0), "=D"(_gpgrt_poll$$1$$5$$1$$1$$1$$1$$__d1) : "a"(0), "0"(sizeof(struct anonymous$1) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readfds)->fds_bits[(signed long int)0]) : "memory");
                }
                while((_Bool)0);
                any_readfd = 1;
              }

              (&readfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
              if(!(max_fd >= fd))
                max_fd = fd;

            }

            if(!(item->want_write == 0u))
            {
              if(any_writefd == 0)
              {
                do
                {
                  signed int _gpgrt_poll$$1$$5$$1$$2$$1$$1$$__d0;
                  signed int _gpgrt_poll$$1$$5$$1$$2$$1$$1$$__d1;
                  asm("cld; rep; stosq" : "=c"(_gpgrt_poll$$1$$5$$1$$2$$1$$1$$__d0), "=D"(_gpgrt_poll$$1$$5$$1$$2$$1$$1$$__d1) : "a"(0), "0"(sizeof(struct anonymous$1) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&writefds)->fds_bits[(signed long int)0]) : "memory");
                }
                while((_Bool)0);
                any_writefd = 1;
              }

              (&writefds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&writefds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
              if(!(max_fd >= fd))
                max_fd = fd;

            }

            if(!(item->want_oob == 0u))
            {
              if(any_exceptfd == 0)
              {
                do
                {
                  signed int _gpgrt_poll$$1$$5$$1$$3$$1$$1$$__d0;
                  signed int __d1;
                  asm("cld; rep; stosq" : "=c"(_gpgrt_poll$$1$$5$$1$$3$$1$$1$$__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$1) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&exceptfds)->fds_bits[(signed long int)0]) : "memory");
                }
                while((_Bool)0);
                any_exceptfd = 1;
              }

              (&exceptfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&exceptfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
              if(!(max_fd >= fd))
                max_fd = fd;

            }

          }

        }

        item = item + 1l;
      }
      if(!(pre_syscall_func == ((void (*)(void))NULL)))
        pre_syscall_func();

      do
      {
        struct timeval timeout_val;
        timeout_val.tv_sec = (signed long int)(timeout / 1000);
        timeout_val.tv_usec = (signed long int)((timeout % 1000) * 1000);
        ret=select(max_fd + 1, any_readfd != 0 ? &readfds : (struct anonymous$1 *)(void *)0, any_writefd != 0 ? &writefds : (struct anonymous$1 *)(void *)0, any_exceptfd != 0 ? &exceptfds : (struct anonymous$1 *)(void *)0, timeout == -1 ? (struct timeval *)(void *)0 : &timeout_val);
        if(ret == -1)
        {
          return_value___errno_location$3=__errno_location();
          tmp_if_expr$4 = *return_value___errno_location$3 == 4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$4 = (_Bool)0;
      }
      while(tmp_if_expr$4);
      if(!(post_syscall_func == ((void (*)(void))NULL)))
        post_syscall_func();

      if(ret == -1)
        return -1;

      else
        if(ret == 0)
          return 0;

        else
        {
          item = fds;
          idx = 0;
          for( ; !((unsigned int)idx >= nfds); idx = idx + 1)
          {
            if(item->ignore == 0u)
            {
              fd=_gpgrt_fileno(item->stream);
              if(fd == -1)
              {
                item->got_err = (unsigned int)1;
                count = count + 1;
              }

              else
              {
                any = 0;
                if(!(item->stream->intern->indicators.hup == 0u))
                {
                  item->got_hup = (unsigned int)1;
                  any = 1;
                }

                if(!(item->want_read == 0u))
                {
                  if(!((readfds.fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
                  {
                    item->got_read = (unsigned int)1;
                    any = 1;
                  }

                }

                if(!(item->want_write == 0u))
                {
                  if(!((writefds.fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
                  {
                    item->got_write = (unsigned int)1;
                    any = 1;
                  }

                }

                if(!(item->want_oob == 0u))
                {
                  if(!((exceptfds.fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
                  {
                    item->got_oob = (unsigned int)1;
                    any = 1;
                  }

                }

                if(!(any == 0))
                  count = count + 1;

              }
            }

            item = item + 1l;
          }
          return count;
        }
    }
  }
}

// _gpgrt_putc_overflow
// file ../../src/visibility.c line 403
signed int _gpgrt_putc_overflow(signed int c, struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt__putc_overflow$1;
  return_value__gpgrt__putc_overflow$1=_gpgrt__putc_overflow(c, stream);
  return return_value__gpgrt__putc_overflow$1;
}

// _gpgrt_read
// file ../../src/estream.c line 3843
signed int _gpgrt_read(struct _gpgrt__stream * restrict stream, void * restrict buffer, unsigned long int bytes_to_read, unsigned long int * restrict bytes_read)
{
  signed int err;
  if(!(bytes_to_read == 0ul))
  {
    lock_stream(stream);
    err=es_readn(stream, buffer, bytes_to_read, bytes_read);
    unlock_stream(stream);
  }

  else
    err = 0;
  return err;
}

// _gpgrt_read_line
// file ../../src/estream.c line 4066
signed long int _gpgrt_read_line(struct _gpgrt__stream *stream, char **addr_of_buffer, unsigned long int *length_of_buffer, unsigned long int *max_length)
{
  signed int c;
  char *buffer = *addr_of_buffer;
  unsigned long int length = *length_of_buffer;
  unsigned long int nbytes = (unsigned long int)0;
  unsigned long int maxlen;
  unsigned long int tmp_if_expr$1;
  if(!(max_length == ((unsigned long int *)NULL)))
    tmp_if_expr$1 = *max_length;

  else
    tmp_if_expr$1 = (unsigned long int)0;
  maxlen = tmp_if_expr$1;
  char *p;
  if(buffer == ((char *)NULL))
  {
    length = (unsigned long int)256;
    void *return_value_mem_alloc$2;
    return_value_mem_alloc$2=mem_alloc(length);
    buffer = (char *)return_value_mem_alloc$2;
    *addr_of_buffer = buffer;
    if(buffer == ((char *)NULL))
    {
      *length_of_buffer = (unsigned long int)0;
      if(!(max_length == ((unsigned long int *)NULL)))
        *max_length = (unsigned long int)0;

      return (signed long int)-1;
    }

    *length_of_buffer = length;
  }

  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  signed int tmp_if_expr$8;
  unsigned long int tmp_post$6;
  signed int return_value__gpgrt__getc_underflow$7;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  signed int tmp_if_expr$13;
  unsigned long int tmp_post$11;
  signed int return_value__gpgrt__getc_underflow$12;
  char *tmp_post$14;
  char *tmp_post$18;
  if(!(length >= 4ul))
  {
    do
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 22;
    }
    while((_Bool)0);
    return (signed long int)-1;
  }

  else
  {
    length = length - (unsigned long int)3;
    lock_stream(stream);
    p = buffer;
    do
    {
      if(stream->flags.writing == 0u)
        tmp_if_expr$4 = stream->data_offset < stream->data_len ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = !(stream->unread_data_len != 0ul) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
      {
        tmp_post$6 = stream->data_offset;
        stream->data_offset = stream->data_offset + 1ul;
        tmp_if_expr$8 = (signed int)stream->buffer[(signed long int)tmp_post$6];
      }

      else
      {
        return_value__gpgrt__getc_underflow$7=_gpgrt__getc_underflow(stream);
        tmp_if_expr$8 = return_value__gpgrt__getc_underflow$7;
      }
      c = tmp_if_expr$8;
      if(c == -1)
        break;

      if(nbytes == length)
      {
        if(!(maxlen == 0ul) && !(maxlen >= length))
        {
          while(!(c == 10))
          {
            if(stream->flags.writing == 0u)
              tmp_if_expr$9 = stream->data_offset < stream->data_len ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$9 = (_Bool)0;
            if(tmp_if_expr$9)
              tmp_if_expr$10 = !(stream->unread_data_len != 0ul) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$10 = (_Bool)0;
            if(tmp_if_expr$10)
            {
              tmp_post$11 = stream->data_offset;
              stream->data_offset = stream->data_offset + 1ul;
              tmp_if_expr$13 = (signed int)stream->buffer[(signed long int)tmp_post$11];
            }

            else
            {
              return_value__gpgrt__getc_underflow$12=_gpgrt__getc_underflow(stream);
              tmp_if_expr$13 = return_value__gpgrt__getc_underflow$12;
            }
            c = tmp_if_expr$13;
            if(c == -1)
              break;

          }
          tmp_post$14 = p;
          p = p + 1l;
          *tmp_post$14 = (char)10;
          nbytes = nbytes + 1ul;
          if(!(max_length == ((unsigned long int *)NULL)))
            *max_length = (unsigned long int)0;

          break;
        }

        length = length + (unsigned long int)3;
        length = length + (unsigned long int)(length < (unsigned long int)1024 ? 256 : 1024);
        void *return_value_mem_realloc$15;
        return_value_mem_realloc$15=mem_realloc((void *)buffer, length);
        *addr_of_buffer = (char *)return_value_mem_realloc$15;
        if(*addr_of_buffer == ((char *)NULL))
        {
          signed int save_errno;
          signed int *return_value___errno_location$16;
          return_value___errno_location$16=__errno_location();
          save_errno = *return_value___errno_location$16;
          mem_free((void *)buffer);
          *length_of_buffer = (unsigned long int)0;
          if(!(max_length == ((unsigned long int *)NULL)))
            *max_length = (unsigned long int)0;

          unlock_stream(stream);
          do
          {
            signed int *return_value___errno_location$17;
            return_value___errno_location$17=__errno_location();
            *return_value___errno_location$17 = save_errno;
          }
          while((_Bool)0);
          return (signed long int)-1;
        }

        buffer = *addr_of_buffer;
        *length_of_buffer = length;
        length = length - (unsigned long int)3;
        p = buffer + (signed long int)nbytes;
      }

      tmp_post$18 = p;
      p = p + 1l;
      *tmp_post$18 = (char)c;
      nbytes = nbytes + 1ul;
      if(c == 10)
        break;

    }
    while((_Bool)1);
    *p = (char)0;
    unlock_stream(stream);
    return (signed long int)nbytes;
  }
}

// _gpgrt_realloc
// file ../../src/init.c line 169
void * _gpgrt_realloc(void *a, unsigned long int n)
{
  void *return_value;
  void *return_value_malloc$1;
  if(!(custom_realloc == ((void * (*)(void *, unsigned long int))NULL)))
  {
    return_value=custom_realloc(a, n);
    return return_value;
  }

  else
    if(n == 0ul)
    {
      free(a);
      return (void *)0;
    }

    else
      if(a == NULL)
      {
        return_value_malloc$1=malloc(n);
        return return_value_malloc$1;
      }

      else
      {
        void *return_value_realloc$2;
        return_value_realloc$2=realloc(a, n);
        return return_value_realloc$2;
      }
}

// _gpgrt_rewind
// file ../../src/estream.c line 3767
void _gpgrt_rewind(struct _gpgrt__stream *stream)
{
  lock_stream(stream);
  es_seek(stream, 0L, 0, (signed long int *)(void *)0);
  stream->intern->indicators.err = (unsigned int)0;
  unlock_stream(stream);
}

// _gpgrt_set_alloc_func
// file ../../src/init.c line 161
void _gpgrt_set_alloc_func(void * (*f)(void *, unsigned long int))
{
  custom_realloc = f;
}

// _gpgrt_set_binary
// file ../../src/estream.c line 4394
void _gpgrt_set_binary(struct _gpgrt__stream *stream)
{
  lock_stream(stream);
  if((0u & stream->intern->modeflags) == 0u)
    stream->intern->modeflags = stream->intern->modeflags | (unsigned int)0;

  unlock_stream(stream);
}

// _gpgrt_set_nonblock
// file ../../src/estream.c line 4440
signed int _gpgrt_set_nonblock(struct _gpgrt__stream *stream, signed int onoff)
{
  signed int (*func_ioctl)(void *, signed int, void *, unsigned long int *);
  signed int ret;
  lock_stream(stream);
  func_ioctl = stream->intern->func_ioctl;
  if(func_ioctl == ((signed int (*)(void *, signed int, void *, unsigned long int *))NULL))
  {
    do
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 95;
    }
    while((_Bool)0);
    ret = -1;
  }

  else
  {
    unsigned int save_flags = stream->intern->modeflags;
    if(!(onoff == 0))
      stream->intern->modeflags = stream->intern->modeflags | (unsigned int)04000;

    else
      stream->intern->modeflags = stream->intern->modeflags & (unsigned int)~04000;
    ret=func_ioctl(stream->intern->cookie, 2, (void *)(onoff != 0 ? "" : (char *)(void *)0), (unsigned long int *)(void *)0);
    if(!(ret == 0))
      stream->intern->modeflags = save_flags;

  }
  unlock_stream(stream);
  return ret;
}

// _gpgrt_set_std_fd
// file ../../src/visibility.c line 271
void _gpgrt_set_std_fd(signed int no, signed int fd)
{
  _gpgrt__set_std_fd(no, fd);
}

// _gpgrt_set_syscall_clamp
// file ../../src/estream.c line 552
void _gpgrt_set_syscall_clamp(void (*pre)(void), void (*post)(void))
{
  pre_syscall_func = pre;
  post_syscall_func = post;
}

// _gpgrt_setvbuf
// file ../../src/estream.c line 4367
signed int _gpgrt_setvbuf(struct _gpgrt__stream * restrict stream, char * restrict buf, signed int type, unsigned long int size)
{
  signed int err;
  if((buf == ((char *)NULL) || type == 2 || !(size == 0ul)) && (type == 0 || type == 1 || type == 2))
  {
    lock_stream(stream);
    err=es_set_buffering(stream, buf, type, size);
    unlock_stream(stream);
  }

  else
  {
    do
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 22;
    }
    while((_Bool)0);
    err = -1;
  }
  return err;
}

// _gpgrt_syshd
// file ../../src/estream.c line 3568
signed int _gpgrt_syshd(struct _gpgrt__stream *stream, struct _gpgrt_syshd *syshd)
{
  signed int ret;
  lock_stream(stream);
  ret=_gpgrt_syshd_unlocked(stream, syshd);
  unlock_stream(stream);
  return ret;
}

// _gpgrt_syshd_unlocked
// file ../../src/estream.c line 3514
signed int _gpgrt_syshd_unlocked(struct _gpgrt__stream *stream, struct _gpgrt_syshd *syshd)
{
  _Bool tmp_if_expr$2;
  if(stream == ((struct _gpgrt__stream *)NULL) || syshd == ((struct _gpgrt_syshd *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)stream->intern->syshd.type == GPGRT_SYSHD_NONE ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    if(!(syshd == ((struct _gpgrt_syshd *)NULL)))
      syshd->type = (enum gpgrt_syshd_types)GPGRT_SYSHD_NONE;

    do
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 22;
    }
    while((_Bool)0);
    return -1;
  }

  else
  {
    *syshd = stream->intern->syshd;
    return 0;
  }
}

// _gpgrt_sysopen
// file ../../src/estream.c line 3218
struct _gpgrt__stream * _gpgrt_sysopen(struct _gpgrt_syshd *syshd, const char *mode)
{
  struct _gpgrt__stream *return_value_do_sysopen$1;
  return_value_do_sysopen$1=do_sysopen(syshd, mode, 0);
  return return_value_do_sysopen$1;
}

// _gpgrt_sysopen_nc
// file ../../src/estream.c line 3226
struct _gpgrt__stream * _gpgrt_sysopen_nc(struct _gpgrt_syshd *syshd, const char *mode)
{
  struct _gpgrt__stream *return_value_do_sysopen$1;
  return_value_do_sysopen$1=do_sysopen(syshd, mode, 1);
  return return_value_do_sysopen$1;
}

// _gpgrt_tmpfile
// file ../../src/estream.c line 4320
struct _gpgrt__stream * _gpgrt_tmpfile(void)
{
  unsigned int modeflags;
  signed int create_called;
  struct _gpgrt__stream *stream;
  void *cookie;
  signed int err;
  signed int fd;
  struct _gpgrt_syshd syshd;
  create_called = 0;
  stream = (struct _gpgrt__stream *)(void *)0;
  modeflags = (unsigned int)(02 | 01000 | 0100);
  cookie = (void *)0;
  fd=tmpfd();
  if(fd == -1)
    err = -1;

  else
  {
    err=func_fd_create(&cookie, fd, modeflags, 0);
    if(err == 0)
    {
      syshd.type = (enum gpgrt_syshd_types)GPGRT_SYSHD_FD;
      syshd.u.fd = fd;
      create_called = 1;
      err=es_create(&stream, cookie, &syshd, estream_functions_fd, modeflags, 0, 0);
    }

  }

out:
  ;
  if(!(err == 0))
  {
    if(!(create_called == 0))
      es_func_fd_destroy(cookie);

    else
      if(!(fd == -1))
        close(fd);

    stream = (struct _gpgrt__stream *)(void *)0;
  }

  return stream;
}

// _gpgrt_ungetc
// file ../../src/estream.c line 3829
signed int _gpgrt_ungetc(signed int c, struct _gpgrt__stream *stream)
{
  unsigned char data = (unsigned char)c;
  unsigned long int data_unread;
  lock_stream(stream);
  es_unreadn(stream, &data, (unsigned long int)1, &data_unread);
  unlock_stream(stream);
  return data_unread != 0ul ? c : -1;
}

// _gpgrt_vfprintf
// file ../../src/estream.c line 4172
signed int _gpgrt_vfprintf(struct _gpgrt__stream * restrict stream, const char * restrict format, void **ap)
{
  signed int ret;
  lock_stream(stream);
  ret=es_print(stream, format, ap);
  unlock_stream(stream);
  return ret;
}

// _gpgrt_vfprintf_unlocked
// file ../../src/estream.c line 4163
signed int _gpgrt_vfprintf_unlocked(struct _gpgrt__stream * restrict stream, const char * restrict format, void **ap)
{
  signed int return_value_es_print$1;
  return_value_es_print$1=es_print(stream, format, ap);
  return return_value_es_print$1;
}

// _gpgrt_write
// file ../../src/estream.c line 3863
signed int _gpgrt_write(struct _gpgrt__stream * restrict stream, const void * restrict buffer, unsigned long int bytes_to_write, unsigned long int * restrict bytes_written)
{
  signed int err;
  if(!(bytes_to_write == 0ul))
  {
    lock_stream(stream);
    err=es_writen(stream, buffer, bytes_to_write, bytes_written);
    unlock_stream(stream);
  }

  else
    err = 0;
  return err;
}

// _gpgrt_write_hexstring
// file ../../src/estream.c line 4832
signed int _gpgrt_write_hexstring(struct _gpgrt__stream * restrict stream, const void * restrict buffer, unsigned long int length, signed int reserved, unsigned long int * restrict bytes_written)
{
  signed int ret;
  const unsigned char *s;
  unsigned long int count = (unsigned long int)0;
  (void)reserved;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$6;
  signed int tmp_if_expr$5;
  unsigned long int tmp_post$1;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$3;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$12;
  signed int tmp_if_expr$11;
  unsigned long int tmp_post$7;
  signed int tmp_if_expr$8;
  signed int tmp_if_expr$9;
  if(length == 0ul)
    return 0;

  else
  {
    lock_stream(stream);
    s = (const unsigned char *)buffer;
    for( ; !(length == 0ul); length = length - 1ul)
    {
      if(!(stream->flags.writing == 0u))
        tmp_if_expr$4 = stream->data_offset < stream->buffer_size ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
      {
        if(!(((signed int)*s >> 4 & 15) >= 10))
          tmp_if_expr$5 = ((signed int)*s >> 4 & 15) + 48;

        else
          tmp_if_expr$5 = (((signed int)*s >> 4 & 15) - 10) + 65;
        tmp_if_expr$6 = tmp_if_expr$5 != 10 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
      {
        tmp_post$1 = stream->data_offset;
        stream->data_offset = stream->data_offset + 1ul;
        if(!(((signed int)*s >> 4 & 15) >= 10))
          tmp_if_expr$2 = ((signed int)*s >> 4 & 15) + 48;

        else
          tmp_if_expr$2 = (((signed int)*s >> 4 & 15) - 10) + 65;
        stream->buffer[(signed long int)tmp_post$1] = (unsigned char)tmp_if_expr$2;
      }

      else
      {
        if(!(((signed int)*s >> 4 & 15) >= 10))
          tmp_if_expr$3 = ((signed int)*s >> 4 & 15) + 48;

        else
          tmp_if_expr$3 = (((signed int)*s >> 4 & 15) - 10) + 65;
        _gpgrt__putc_overflow(tmp_if_expr$3, stream);
      }
      if(!(stream->flags.writing == 0u))
        tmp_if_expr$10 = stream->data_offset < stream->buffer_size ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$10 = (_Bool)0;
      if(tmp_if_expr$10)
      {
        if(!((15 & (signed int)*s) >= 10))
          tmp_if_expr$11 = ((signed int)*s & 15) + 48;

        else
          tmp_if_expr$11 = (((signed int)*s & 15) - 10) + 65;
        tmp_if_expr$12 = tmp_if_expr$11 != 10 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$12 = (_Bool)0;
      if(tmp_if_expr$12)
      {
        tmp_post$7 = stream->data_offset;
        stream->data_offset = stream->data_offset + 1ul;
        if(!((15 & (signed int)*s) >= 10))
          tmp_if_expr$8 = ((signed int)*s & 15) + 48;

        else
          tmp_if_expr$8 = (((signed int)*s & 15) - 10) + 65;
        stream->buffer[(signed long int)tmp_post$7] = (unsigned char)tmp_if_expr$8;
      }

      else
      {
        if(!((15 & (signed int)*s) >= 10))
          tmp_if_expr$9 = ((signed int)*s & 15) + 48;

        else
          tmp_if_expr$9 = (((signed int)*s & 15) - 10) + 65;
        _gpgrt__putc_overflow(tmp_if_expr$9, stream);
      }
      count = count + (unsigned long int)2;
      s = s + 1l;
    }
    if(!(bytes_written == ((unsigned long int *)NULL)))
      *bytes_written = count;

    signed int return_value__gpgrt_ferror_unlocked$13;
    return_value__gpgrt_ferror_unlocked$13=_gpgrt_ferror_unlocked(stream);
    ret = return_value__gpgrt_ferror_unlocked$13 != 0 ? -1 : 0;
    unlock_stream(stream);
    return ret;
  }
}

// _gpgrt_write_sanitized
// file ../../src/estream.c line 4756
signed int _gpgrt_write_sanitized(struct _gpgrt__stream * restrict stream, const void * restrict buffer, unsigned long int length, const char *delimiters, unsigned long int * restrict bytes_written)
{
  const unsigned char *p = (const unsigned char *)buffer;
  unsigned long int count = (unsigned long int)0;
  signed int ret;
  lock_stream(stream);
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$22;
  _Bool tmp_if_expr$21;
  char *return_value_strchr$19;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$2;
  unsigned long int tmp_post$1;
  _Bool tmp_if_expr$4;
  unsigned long int tmp_post$3;
  _Bool tmp_if_expr$6;
  unsigned long int tmp_post$5;
  _Bool tmp_if_expr$8;
  unsigned long int tmp_post$7;
  _Bool tmp_if_expr$10;
  unsigned long int tmp_post$9;
  _Bool tmp_if_expr$12;
  unsigned long int tmp_post$11;
  _Bool tmp_if_expr$14;
  unsigned long int tmp_post$13;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$17;
  unsigned long int tmp_post$15;
  for( ; !(length == 0ul); count = count + 1ul)
  {
    if(!((signed int)*p >= 0x20))
      tmp_if_expr$18 = (_Bool)1;

    else
      tmp_if_expr$18 = (signed int)*p == 0x7f ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$18)
      tmp_if_expr$22 = (_Bool)1;

    else
    {
      if(!(delimiters == ((const char *)NULL)))
      {
        return_value_strchr$19=strchr(delimiters, (signed int)*p);
        if(!(return_value_strchr$19 == ((char *)NULL)))
          tmp_if_expr$20 = (_Bool)1;

        else
          tmp_if_expr$20 = (signed int)*p == 92 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$21 = tmp_if_expr$20 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$21 = (_Bool)0;
      tmp_if_expr$22 = tmp_if_expr$21 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$22)
    {
      if(!(stream->flags.writing == 0u))
        tmp_if_expr$2 = stream->data_offset < stream->buffer_size ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
      {
        tmp_post$1 = stream->data_offset;
        stream->data_offset = stream->data_offset + 1ul;
        stream->buffer[(signed long int)tmp_post$1] = (unsigned char)92;
      }

      else
        _gpgrt__putc_overflow(92, stream);
      count = count + 1ul;
      if((signed int)*p == 10)
      {
        if(!(stream->flags.writing == 0u))
          tmp_if_expr$4 = stream->data_offset < stream->buffer_size ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(tmp_if_expr$4)
        {
          tmp_post$3 = stream->data_offset;
          stream->data_offset = stream->data_offset + 1ul;
          stream->buffer[(signed long int)tmp_post$3] = (unsigned char)110;
        }

        else
          _gpgrt__putc_overflow(110, stream);
        count = count + 1ul;
      }

      else
        if((signed int)*p == 13)
        {
          if(!(stream->flags.writing == 0u))
            tmp_if_expr$6 = stream->data_offset < stream->buffer_size ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$6 = (_Bool)0;
          if(tmp_if_expr$6)
          {
            tmp_post$5 = stream->data_offset;
            stream->data_offset = stream->data_offset + 1ul;
            stream->buffer[(signed long int)tmp_post$5] = (unsigned char)114;
          }

          else
            _gpgrt__putc_overflow(114, stream);
          count = count + 1ul;
        }

        else
          if((signed int)*p == 12)
          {
            if(!(stream->flags.writing == 0u))
              tmp_if_expr$8 = stream->data_offset < stream->buffer_size ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$8 = (_Bool)0;
            if(tmp_if_expr$8)
            {
              tmp_post$7 = stream->data_offset;
              stream->data_offset = stream->data_offset + 1ul;
              stream->buffer[(signed long int)tmp_post$7] = (unsigned char)102;
            }

            else
              _gpgrt__putc_overflow(102, stream);
            count = count + 1ul;
          }

          else
            if((signed int)*p == 11)
            {
              if(!(stream->flags.writing == 0u))
                tmp_if_expr$10 = stream->data_offset < stream->buffer_size ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$10 = (_Bool)0;
              if(tmp_if_expr$10)
              {
                tmp_post$9 = stream->data_offset;
                stream->data_offset = stream->data_offset + 1ul;
                stream->buffer[(signed long int)tmp_post$9] = (unsigned char)118;
              }

              else
                _gpgrt__putc_overflow(118, stream);
              count = count + 1ul;
            }

            else
              if((signed int)*p == 8)
              {
                if(!(stream->flags.writing == 0u))
                  tmp_if_expr$12 = stream->data_offset < stream->buffer_size ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$12 = (_Bool)0;
                if(tmp_if_expr$12)
                {
                  tmp_post$11 = stream->data_offset;
                  stream->data_offset = stream->data_offset + 1ul;
                  stream->buffer[(signed long int)tmp_post$11] = (unsigned char)98;
                }

                else
                  _gpgrt__putc_overflow(98, stream);
                count = count + 1ul;
              }

              else
                if(*p == 0)
                {
                  if(!(stream->flags.writing == 0u))
                    tmp_if_expr$14 = stream->data_offset < stream->buffer_size ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$14 = (_Bool)0;
                  if(tmp_if_expr$14)
                  {
                    tmp_post$13 = stream->data_offset;
                    stream->data_offset = stream->data_offset + 1ul;
                    stream->buffer[(signed long int)tmp_post$13] = (unsigned char)48;
                  }

                  else
                    _gpgrt__putc_overflow(48, stream);
                  count = count + 1ul;
                }

                else
                {
                  _gpgrt_fprintf_unlocked(stream, "x%02x", *p);
                  count = count + (unsigned long int)3;
                }
    }

    else
    {
      if(!(stream->flags.writing == 0u))
        tmp_if_expr$16 = stream->data_offset < stream->buffer_size ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$16 = (_Bool)0;
      if(tmp_if_expr$16)
        tmp_if_expr$17 = (signed int)*p != 10 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$17 = (_Bool)0;
      if(tmp_if_expr$17)
      {
        tmp_post$15 = stream->data_offset;
        stream->data_offset = stream->data_offset + 1ul;
        stream->buffer[(signed long int)tmp_post$15] = *p;
      }

      else
        _gpgrt__putc_overflow((signed int)*p, stream);
      count = count + 1ul;
    }
    length = length - 1ul;
    p = p + 1l;
  }
  if(!(bytes_written == ((unsigned long int *)NULL)))
    *bytes_written = count;

  signed int return_value__gpgrt_ferror_unlocked$23;
  return_value__gpgrt_ferror_unlocked$23=_gpgrt_ferror_unlocked(stream);
  ret = return_value__gpgrt_ferror_unlocked$23 != 0 ? -1 : 0;
  unlock_stream(stream);
  return ret;
}

// _gpgrt_yield
// file ../../src/posix-thread.c line 48
enum anonymous$4 _gpgrt_yield(void)
{
  sched_yield();
  return (enum anonymous$4)0;
}

// accountant_thread
// file ../../tests/t-lock.c line 162
static void * accountant_thread(void *arg)
{
  enum anonymous$4 rc;
  signed int i;
  signed int acc1;
  signed int acc2;
  signed int value;
  (void)arg;
  i = 0;
  const char *return_value_gpg_strerror$1;
  const char *return_value_gpg_strerror$2;
  for( ; !(i >= 1000); i = i + 1)
  {
    rc=gpgrt_lock_lock(&accounts_lock);
    if(!(rc == /*enum*/GPG_ERR_NO_ERROR))
    {
      return_value_gpg_strerror$1=gpg_strerror((unsigned int)rc);
      fail("gpgrt_lock_lock failed at %d: %s", 178, return_value_gpg_strerror$1);
    }

    acc1=pick_account();
    acc2=pick_account();
    value=pick_value();
    account[(signed long int)acc1] = account[(signed long int)acc1] + value;
    account[(signed long int)acc2] = account[(signed long int)acc2] - value;
    rc=gpgrt_lock_unlock(&accounts_lock);
    if(!(rc == /*enum*/GPG_ERR_NO_ERROR))
    {
      return_value_gpg_strerror$2=gpg_strerror((unsigned int)rc);
      fail("gpgrt_lock_unlock failed at %d: %s", 188, return_value_gpg_strerror$2);
    }

    if(i % 8 == 0 && !(i == 0))
      gpgrt_yield();

  }
  return (void *)0;
}

// check_accounts
// file ../../tests/t-lock.c line 86
static void check_accounts(void)
{
  signed int i;
  signed int sum = 0;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    sum = sum + account[(signed long int)i];
  if(!(sum == 8))
    die("accounts out of balance");

}

// check_pending
// file ../../src/estream.c line 2224
static signed int check_pending(struct _gpgrt__stream * restrict stream)
{
  if(!(stream->flags.writing == 0u))
  {
    signed int return_value_es_flush$1;
    return_value_es_flush$1=es_flush(stream);
    if(!(return_value_es_flush$1 == 0))
      return 0;

    stream->flags.writing = (unsigned int)0;
  }

  signed int return_value_check_pending_nbf$2;
  signed int return_value_check_pending_fbf$3;
  if(!(stream->unread_data_len == 0ul))
    return 1;

  else
    switch(stream->intern->strategy)
    {
      case 2:
      {
        return_value_check_pending_nbf$2=check_pending_nbf(stream);
        return return_value_check_pending_nbf$2;
      }
      case 1:

      case 0:
      {
        return_value_check_pending_fbf$3=check_pending_fbf(stream);
        return return_value_check_pending_fbf$3;
      }
      default:
        return 0;
    }
}

// check_pending_fbf
// file ../../src/estream.c line 2125
static signed int check_pending_fbf(struct _gpgrt__stream * restrict stream)
{
  signed long int (*func_read)(void *, void *, unsigned long int) = stream->intern->func_read;
  char buffer[1l];
  if(stream->data_offset == stream->data_len)
  {
    signed long int return_value;
    return_value=func_read(stream->intern->cookie, (void *)buffer, (unsigned long int)0);
    if(return_value == 0l)
      return 1;

  }

  else
    return 1;
  return 0;
}

// check_pending_nbf
// file ../../src/estream.c line 2062
static signed int check_pending_nbf(struct _gpgrt__stream * restrict stream)
{
  signed long int (*func_read)(void *, void *, unsigned long int) = stream->intern->func_read;
  char buffer[1l];
  signed long int return_value;
  return_value=func_read(stream->intern->cookie, (void *)buffer, (unsigned long int)0);
  if(return_value == 0l)
    return 1;

  else
    return 0;
}

// compare_versions
// file ../../src/version.c line 82
static const char * compare_versions(const char *my_version, const char *req_version)
{
  signed int my_major;
  signed int my_minor;
  signed int rq_major;
  signed int rq_minor;
  const char *my_plvl;
  const char *rq_plvl;
  if(req_version == ((const char *)NULL))
    return my_version;

  else
    if(my_version == ((const char *)NULL))
      return (const char *)(void *)0;

    else
    {
      my_plvl=parse_version_string(my_version, &my_major, &my_minor);
      if(my_plvl == ((const char *)NULL))
        return (const char *)(void *)0;

      else
      {
        rq_plvl=parse_version_string(req_version, &rq_major, &rq_minor);
        if(rq_plvl == ((const char *)NULL))
          return (const char *)(void *)0;

        else
          if(my_major == rq_major && my_minor >= rq_minor || !(rq_major >= my_major))
            return my_version;

          else
            return (const char *)(void *)0;
      }
    }
}

// compute_type
// file ../../src/estream-printf.c line 355
static void compute_type(struct argspec_s *arg)
{
  switch((signed int)arg->conspec)
  {
    case CONSPEC_UNKNOWN:
    {
      arg->vt = (enum anonymous$13)VALTYPE_UNSUPPORTED;
      break;
    }
    case CONSPEC_DECIMAL:
    {
      switch((signed int)arg->lenmod)
      {
        case LENMOD_CHAR:
        {
          arg->vt = (enum anonymous$13)VALTYPE_SCHAR;
          break;
        }
        case LENMOD_SHORT:
        {
          arg->vt = (enum anonymous$13)VALTYPE_SHORT;
          break;
        }
        case LENMOD_LONG:
        {
          arg->vt = (enum anonymous$13)VALTYPE_LONG;
          break;
        }
        case LENMOD_LONGLONG:
        {
          arg->vt = (enum anonymous$13)VALTYPE_LONGLONG;
          break;
        }
        case LENMOD_INTMAX:
        {
          arg->vt = (enum anonymous$13)VALTYPE_INTMAX;
          break;
        }
        case LENMOD_SIZET:
        {
          arg->vt = (enum anonymous$13)VALTYPE_SIZE;
          break;
        }
        case LENMOD_PTRDIFF:
        {
          arg->vt = (enum anonymous$13)VALTYPE_PTRDIFF;
          break;
        }
        default:
          arg->vt = (enum anonymous$13)VALTYPE_INT;
      }
      break;
    }
    case CONSPEC_OCTAL:

    case CONSPEC_UNSIGNED:

    case CONSPEC_HEX:

    case CONSPEC_HEX_UP:
    {
      switch((signed int)arg->lenmod)
      {
        case LENMOD_CHAR:
        {
          arg->vt = (enum anonymous$13)VALTYPE_UCHAR;
          break;
        }
        case LENMOD_SHORT:
        {
          arg->vt = (enum anonymous$13)VALTYPE_USHORT;
          break;
        }
        case LENMOD_LONG:
        {
          arg->vt = (enum anonymous$13)VALTYPE_ULONG;
          break;
        }
        case LENMOD_LONGLONG:
        {
          arg->vt = (enum anonymous$13)VALTYPE_ULONGLONG;
          break;
        }
        case LENMOD_INTMAX:
        {
          arg->vt = (enum anonymous$13)VALTYPE_UINTMAX;
          break;
        }
        case LENMOD_SIZET:
        {
          arg->vt = (enum anonymous$13)VALTYPE_SIZE;
          break;
        }
        case LENMOD_PTRDIFF:
        {
          arg->vt = (enum anonymous$13)VALTYPE_PTRDIFF;
          break;
        }
        default:
          arg->vt = (enum anonymous$13)VALTYPE_UINT;
      }
      break;
    }
    case CONSPEC_FLOAT:

    case CONSPEC_FLOAT_UP:

    case CONSPEC_EXP:

    case CONSPEC_EXP_UP:

    case CONSPEC_F_OR_G:

    case CONSPEC_F_OR_G_UP:

    case CONSPEC_HEX_EXP:

    case CONSPEC_HEX_EXP_UP:
    {
      switch((signed int)arg->lenmod)
      {
        case LENMOD_LONGDBL:
        {
          arg->vt = (enum anonymous$13)VALTYPE_LONGDOUBLE;
          break;
        }
        case LENMOD_LONG:
        {
          arg->vt = (enum anonymous$13)VALTYPE_DOUBLE;
          break;
        }
        default:
          arg->vt = (enum anonymous$13)VALTYPE_DOUBLE;
      }
      break;
    }
    case CONSPEC_CHAR:
    {
      arg->vt = (enum anonymous$13)VALTYPE_INT;
      break;
    }
    case CONSPEC_STRING:
    {
      arg->vt = (enum anonymous$13)VALTYPE_STRING;
      break;
    }
    case CONSPEC_POINTER:
    {
      arg->vt = (enum anonymous$13)VALTYPE_POINTER;
      break;
    }
    case CONSPEC_STRERROR:
    {
      arg->vt = (enum anonymous$13)VALTYPE_STRING;
      break;
    }
    case CONSPEC_BYTES_SO_FAR:
      switch((signed int)arg->lenmod)
      {
        case LENMOD_CHAR:
        {
          arg->vt = (enum anonymous$13)VALTYPE_SCHAR_PTR;
          break;
        }
        case LENMOD_SHORT:
        {
          arg->vt = (enum anonymous$13)VALTYPE_SHORT_PTR;
          break;
        }
        case LENMOD_LONG:
        {
          arg->vt = (enum anonymous$13)VALTYPE_LONG_PTR;
          break;
        }
        case LENMOD_LONGLONG:
        {
          arg->vt = (enum anonymous$13)VALTYPE_LONGLONG_PTR;
          break;
        }
        case LENMOD_INTMAX:
        {
          arg->vt = (enum anonymous$13)VALTYPE_INTMAX_PTR;
          break;
        }
        case LENMOD_SIZET:
        {
          arg->vt = (enum anonymous$13)VALTYPE_SIZE_PTR;
          break;
        }
        case LENMOD_PTRDIFF:
        {
          arg->vt = (enum anonymous$13)VALTYPE_PTRDIFF_PTR;
          break;
        }
        default:
          arg->vt = (enum anonymous$13)VALTYPE_INT_PTR;
      }
  }
}

// cright_blurb
// file ../../src/version.c line 37
static const char * cright_blurb(void)
{
  static const char blurb[128l] = { '\n', '\n', 'T', 'h', 'i', 's', ' ', 'i', 's', ' ', 'L', 'i', 'b', 'g', 'p', 'g', '-', 'e', 'r', 'r', 'o', 'r', ' ', '1', '.', '2', '1', ' ', '-', ' ', 'A', 'n', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', 'l', 'i', 'b', 'r', 'a', 'r', 'y', '\n', 'C', 'o', 'p', 'y', 'r', 'i', 'g', 'h', 't', ' ', '2', '0', '0', '3', ',', ' ', '2', '0', '0', '4', ',', ' ', '2', '0', '1', '0', ',', ' ', '2', '0', '1', '3', ',', ' ', '2', '0', '1', '4', ',', ' ', '2', '0', '1', '5', ' ', 'g', '1', '0', ' ', 'C', 'o', 'd', 'e', ' ', 'G', 'm', 'b', 'H', '\n', '\n', '(', '1', 'b', 'b', ' ', '<', 'n', 'o', 'n', 'e', '>', ')', '\n', '\n', '\n', 0 };
  return blurb;
}

// destroy_stream_lock
// file ../../src/estream.c line 365
static void destroy_stream_lock(struct _gpgrt__stream * restrict stream)
{
  if(stream->intern->samethread == 0u)
    _gpgrt_lock_destroy(&stream->intern->lock);

}

// die
// file ../../tests/t-common.h line 38
static void die(const char *format, ...)
{
  void **arg_ptr;
  fflush(stdout);
  flockfile(stderr);
  fprintf(stderr, "%s: ", (const void *)"t-lock");
  arg_ptr = (void **)&format;
  vfprintf(stderr, format, arg_ptr);
  arg_ptr = ((void **)NULL);
  unsigned long int return_value_strlen$1;
  if(!(*format == 0))
  {
    return_value_strlen$1=strlen(format);
    if(!((signed int)format[-1l + (signed long int)return_value_strlen$1] == 10))
      _IO_putc(10, stderr);

  }

  funlockfile(stderr);
  exit(1);
}

// do_close
// file ../../src/estream.c line 1964
static signed int do_close(struct _gpgrt__stream *stream, signed int with_locked_list)
{
  signed int err;
  if(!(stream == ((struct _gpgrt__stream *)NULL)))
  {
    do_list_remove(stream, with_locked_list);
    while(!(stream->intern->onclose == ((struct notify_list_s *)NULL)))
    {
      struct notify_list_s *tmp = stream->intern->onclose->next;
      if(!(stream->intern->onclose->fnc == ((void (*)(struct _gpgrt__stream *, void *))NULL)))
        stream->intern->onclose->fnc(stream, stream->intern->onclose->fnc_value);

      mem_free((void *)stream->intern->onclose);
      stream->intern->onclose = tmp;
    }
    err=es_deinitialize(stream);
    destroy_stream_lock(stream);
    mem_free((void *)stream->intern);
    mem_free((void *)stream);
  }

  else
    err = 0;
  return err;
}

// do_deinit
// file ../../src/estream.c line 506
static void do_deinit(void)
{
  _gpgrt_fflush((struct _gpgrt__stream *)(void *)0);
  pre_syscall_func = (void (*)(void))(void *)0;
  post_syscall_func = (void (*)(void))(void *)0;
}

// do_fdopen
// file ../../src/estream.c line 3033
static struct _gpgrt__stream * do_fdopen(signed int filedes, const char *mode, signed int no_close, signed int with_locked_list)
{
  unsigned int modeflags;
  signed int samethread;
  signed int create_called;
  struct _gpgrt__stream *stream;
  void *cookie;
  signed int err;
  struct _gpgrt_syshd syshd;
  stream = (struct _gpgrt__stream *)(void *)0;
  cookie = (void *)0;
  create_called = 0;
  err=parse_mode(mode, &modeflags, &samethread, (unsigned int *)(void *)0);
  if(err == 0)
  {
    err=func_fd_create(&cookie, filedes, modeflags, no_close);
    if(err == 0)
    {
      syshd.type = (enum gpgrt_syshd_types)GPGRT_SYSHD_FD;
      syshd.u.fd = filedes;
      create_called = 1;
      err=es_create(&stream, cookie, &syshd, estream_functions_fd, modeflags, samethread, with_locked_list);
      if(err == 0 && !(stream == ((struct _gpgrt__stream *)NULL)))
      {
        stream->intern->func_ioctl = es_func_fd_ioctl;
        if(!((2048u & modeflags) == 0u))
          err=es_func_fd_ioctl(cookie, 2, (void *)"", (unsigned long int *)(void *)0);

      }

    }

  }


out:
  ;
  if(!(create_called == 0) && !(err == 0))
    estream_functions_fd.func_close(cookie);

  return stream;
}

// do_fflush
// file ../../src/estream.c line 3668
static signed int do_fflush(struct _gpgrt__stream *stream)
{
  signed int err;
  if(!(stream->flags.writing == 0u))
    err=es_flush(stream);

  else
  {
    es_empty(stream);
    err = 0;
  }
  return err;
}

// do_format
// file ../../src/estream-printf.c line 1347
static signed int do_format(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, const char *format, struct argspec_s *argspecs, unsigned long int argspecs_len, struct valueitem_s *valuetable, signed int myerrno, unsigned long int *nbytes)
{
  signed int rc = 0;
  const char *s;
  struct argspec_s *arg = argspecs;
  signed int argidx = 0;
  unsigned long int n;
  union anonymous$14 value;
  s = format;
  _Bool tmp_if_expr$1;
  while(!(*s == 0))
    if(!((signed int)*s == 37))
      s = s + 1l;

    else
    {
      if(!(s == format))
      {
        n = (unsigned long int)(s - format);
        rc=outfnc(outfncarg, format, n);
        if(!(rc == 0))
          return rc;

        *nbytes = *nbytes + n;
      }

      if((signed int)s[1l] == 37)
      {
        rc=outfnc(outfncarg, s, (unsigned long int)1);
        if(!(rc == 0))
          return rc;

        *nbytes = *nbytes + (unsigned long int)1;
        s = s + (signed long int)2;
        format = s;
      }

      else
      {
        s = s + (signed long int)arg->length;
        format = s;
        /* assertion argidx < argspecs_len */
        assert((unsigned long int)argidx < argspecs_len);
        argidx = argidx + 1;
        if(arg->width == -2)
        {
          /* assertion valuetable[arg->width_pos-1].vt == VALTYPE_INT */
          assert((signed int)(valuetable + (signed long int)(arg->width_pos - 1))->vt == VALTYPE_INT);
          arg->width = (valuetable + (signed long int)(arg->width_pos - 1))->value.a_int;
          if(!(arg->width >= 0))
          {
            arg->width = -arg->width;
            arg->flags = arg->flags | (unsigned int)2;
          }

        }

        if(arg->precision == -2)
        {
          /* assertion valuetable[arg->precision_pos-1].vt == VALTYPE_INT */
          assert((signed int)(valuetable + (signed long int)(arg->precision_pos - 1))->vt == VALTYPE_INT);
          arg->precision = (valuetable + (signed long int)(arg->precision_pos - 1))->value.a_int;
          if(!(arg->precision >= 0))
            arg->precision = -1;

        }

        if(arg->arg_pos == -1)
          tmp_if_expr$1 = (signed int)arg->conspec == CONSPEC_STRERROR ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
          value.a_string=strerror(myerrno);

        else
        {
          /* assertion arg->vt == valuetable[arg->arg_pos-1].vt */
          assert(arg->vt == (valuetable + (signed long int)(arg->arg_pos - 1))->vt);
          value = (valuetable + (signed long int)(arg->arg_pos - 1))->value;
        }
        switch((signed int)arg->conspec)
        {
          case CONSPEC_UNKNOWN:
          {
            /* assertion !"bug" */
            assert(!((_Bool)"bug"));
            break;
          }
          case CONSPEC_DECIMAL:

          case CONSPEC_UNSIGNED:

          case CONSPEC_OCTAL:

          case CONSPEC_HEX:

          case CONSPEC_HEX_UP:
          {
            rc=pr_integer(outfnc, outfncarg, arg, value, nbytes);
            break;
          }
          case CONSPEC_FLOAT:

          case CONSPEC_FLOAT_UP:

          case CONSPEC_EXP:

          case CONSPEC_EXP_UP:

          case CONSPEC_F_OR_G:

          case CONSPEC_F_OR_G_UP:

          case CONSPEC_HEX_EXP:

          case CONSPEC_HEX_EXP_UP:
          {
            rc=pr_float(outfnc, outfncarg, arg, value, nbytes);
            break;
          }
          case CONSPEC_CHAR:
          {
            rc=pr_char(outfnc, outfncarg, arg, value, nbytes);
            break;
          }
          case CONSPEC_STRING:

          case CONSPEC_STRERROR:
          {
            rc=pr_string(outfnc, outfncarg, arg, value, nbytes);
            break;
          }
          case CONSPEC_POINTER:
          {
            rc=pr_pointer(outfnc, outfncarg, arg, value, nbytes);
            break;
          }
          case CONSPEC_BYTES_SO_FAR:
            rc=pr_bytes_so_far(outfnc, outfncarg, arg, value, nbytes);
        }
        if(!(rc == 0))
          return rc;

        arg = arg + 1l;
      }
    }
  n = (unsigned long int)(s - format);
  signed int tmp_if_expr$2;
  signed int return_value;
  if(!(n == 0ul))
  {
    return_value=outfnc(outfncarg, format, n);
    tmp_if_expr$2 = return_value;
  }

  else
    tmp_if_expr$2 = 0;
  rc = tmp_if_expr$2;
  if(rc == 0)
    *nbytes = *nbytes + n;

  return rc;
}

// do_fpopen
// file ../../src/estream.c line 3090
static struct _gpgrt__stream * do_fpopen(struct _IO_FILE *fp, const char *mode, signed int no_close, signed int with_locked_list)
{
  unsigned int modeflags;
  unsigned int cmode;
  signed int samethread;
  signed int create_called;
  struct _gpgrt__stream *stream;
  void *cookie;
  signed int err;
  struct _gpgrt_syshd syshd;
  stream = (struct _gpgrt__stream *)(void *)0;
  cookie = (void *)0;
  create_called = 0;
  err=parse_mode(mode, &modeflags, &samethread, &cmode);
  signed int tmp_if_expr$2;
  signed int return_value_fileno$1;
  if(err == 0)
  {
    if(!(fp == ((struct _IO_FILE *)NULL)))
      fflush(fp);

    err=func_fp_create(&cookie, fp, modeflags, no_close);
    if(err == 0)
    {
      syshd.type = (enum gpgrt_syshd_types)GPGRT_SYSHD_FD;
      if(!(fp == ((struct _IO_FILE *)NULL)))
      {
        return_value_fileno$1=fileno(fp);
        tmp_if_expr$2 = return_value_fileno$1;
      }

      else
        tmp_if_expr$2 = -1;
      syshd.u.fd = tmp_if_expr$2;
      create_called = 1;
      err=es_create(&stream, cookie, &syshd, estream_functions_fp, modeflags, samethread, with_locked_list);
    }

  }


out:
  ;
  if(!(create_called == 0) && !(err == 0))
    estream_functions_fp.func_close(cookie);

  return stream;
}

// do_list_add
// file ../../src/estream.c line 456
static signed int do_list_add(struct _gpgrt__stream *stream, signed int with_locked_list)
{
  struct estream_list_s *item;
  if(with_locked_list == 0)
    lock_list();

  item = estream_list;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(item == ((struct estream_list_s *)NULL)))
      tmp_if_expr$1 = item->stream != ((struct _gpgrt__stream *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    item = item->next;
  }
  while((_Bool)1);
  if(item == ((struct estream_list_s *)NULL))
  {
    void *return_value_mem_alloc$2;
    return_value_mem_alloc$2=mem_alloc(sizeof(struct estream_list_s) /*16ul*/ );
    item = (struct estream_list_s *)return_value_mem_alloc$2;
    if(!(item == ((struct estream_list_s *)NULL)))
    {
      item->next = estream_list;
      estream_list = item;
    }

  }

  if(!(item == ((struct estream_list_s *)NULL)))
    item->stream = stream;

  if(with_locked_list == 0)
    unlock_list();

  return item != ((struct estream_list_s *)NULL) ? 0 : -1;
}

// do_list_remove
// file ../../src/estream.c line 485
static void do_list_remove(struct _gpgrt__stream *stream, signed int with_locked_list)
{
  struct estream_list_s *item;
  if(with_locked_list == 0)
    lock_list();

  item = estream_list;
  for( ; !(item == ((struct estream_list_s *)NULL)); item = item->next)
    if(item->stream == stream)
    {
      item->stream = (struct _gpgrt__stream *)(void *)0;
      break;
    }

  if(with_locked_list == 0)
    unlock_list();

}

// do_onclose
// file ../../src/estream.c line 1995
static signed int do_onclose(struct _gpgrt__stream *stream, signed int mode, void (*fnc)(struct _gpgrt__stream *, void *), void *fnc_value)
{
  struct notify_list_s *item;
  if(mode == 0)
  {
    item = stream->intern->onclose;
    for( ; !(item == ((struct notify_list_s *)NULL)); item = item->next)
      if(!(item->fnc == ((void (*)(struct _gpgrt__stream *, void *))NULL)))
      {
        if(item->fnc == fnc)
        {
          if(item->fnc_value == fnc_value)
            item->fnc = (void (*)(struct _gpgrt__stream *, void *))(void *)0;

        }

      }

  }

  else
  {
    void *return_value_mem_alloc$1;
    return_value_mem_alloc$1=mem_alloc(sizeof(struct notify_list_s) /*24ul*/ );
    item = (struct notify_list_s *)return_value_mem_alloc$1;
    if(item == ((struct notify_list_s *)NULL))
      return -1;

    item->fnc = fnc;
    item->fnc_value = fnc_value;
    item->next = stream->intern->onclose;
    stream->intern->onclose = item;
  }
  return 0;
}

// do_sysopen
// file ../../src/estream.c line 3188
static struct _gpgrt__stream * do_sysopen(struct _gpgrt_syshd *syshd, const char *mode, signed int no_close)
{
  struct _gpgrt__stream *stream;
  if((signed int)syshd->type == GPGRT_SYSHD_FD || (signed int)syshd->type == GPGRT_SYSHD_SOCK)
  {
    stream=do_fdopen(syshd->u.fd, mode, no_close, 0);
    goto __CPROVER_DUMP_L3;
  }

  do
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
  }
  while((_Bool)0);
  stream = (struct _gpgrt__stream *)(void *)0;

__CPROVER_DUMP_L3:
  ;
  return stream;
}

// doreadline
// file ../../src/estream.c line 2586
static signed int doreadline(struct _gpgrt__stream * restrict stream, unsigned long int max_length, char * restrict * restrict line, unsigned long int * restrict line_length)
{
  unsigned long int space_left;
  unsigned long int line_size;
  struct _gpgrt__stream *line_stream;
  char *line_new;
  void *line_stream_cookie;
  char *newline;
  unsigned char *data;
  unsigned long int data_len;
  signed int err;
  struct _gpgrt_syshd syshd;
  line_new = (char *)(void *)0;
  line_stream = (struct _gpgrt__stream *)(void *)0;
  line_stream_cookie = (void *)0;
  err=func_mem_create(&line_stream_cookie, (unsigned char *)(void *)0, (unsigned long int)0, (unsigned long int)0, (unsigned long int)8192, (unsigned int)1, mem_realloc, mem_free, (unsigned int)02, (unsigned long int)0);
  if(err == 0)
  {
    memset((void *)&syshd, 0, sizeof(struct _gpgrt_syshd) /*16ul*/ );
    err=es_create(&line_stream, line_stream_cookie, &syshd, estream_functions_mem, (unsigned int)02, 1, 0);
    if(err == 0)
    {
      space_left = max_length;
      line_size = (unsigned long int)0;
      while((_Bool)1)
      {
        if(space_left == 1ul && !(max_length == 0ul))
          break;

        err=es_peek(stream, &data, &data_len);
        if(data_len == 0ul || !(err == 0))
          break;

        if(!(space_left + 18446744073709551615ul >= data_len))
          data_len = space_left - (unsigned long int)1;

        void *return_value_memchr$1;
        return_value_memchr$1=memchr((const void *)data, 10, data_len);
        newline = (char *)return_value_memchr$1;
        if(!(newline == ((char *)NULL)))
        {
          data_len = (unsigned long int)((newline - (char *)data) + (signed long int)1);
          err=_gpgrt_write(line_stream, (const void *)data, data_len, (unsigned long int *)(void *)0);
          if(err == 0)
          {
            space_left = space_left - data_len;
            line_size = line_size + data_len;
            es_skip(stream, data_len);
            break;
          }

        }

        else
        {
          err=_gpgrt_write(line_stream, (const void *)data, data_len, (unsigned long int *)(void *)0);
          if(err == 0)
          {
            space_left = space_left - data_len;
            line_size = line_size + data_len;
            es_skip(stream, data_len);
          }

        }
        if(!(err == 0))
          break;

      }
      if(err == 0)
      {
        if(line_size == 0ul && max_length >= 2ul)
          stream->intern->indicators.eof = (unsigned int)1;

        else
        {
          err=es_seek(line_stream, (signed long int)0, 0, (signed long int *)(void *)0);
          if(err == 0)
          {
            if(*line == ((char *)NULL))
            {
              void *return_value_mem_alloc$2;
              return_value_mem_alloc$2=mem_alloc(line_size + (unsigned long int)1);
              line_new = (char *)return_value_mem_alloc$2;
              if(line_new == ((char *)NULL))
              {
                err = -1;
                goto out;
              }

            }

            else
              line_new = *line;
            err=_gpgrt_read(line_stream, (void *)line_new, line_size, (unsigned long int *)(void *)0);
            if(err == 0)
            {
              line_new[(signed long int)line_size] = (char)0;
              if(*line == ((char *)NULL))
                *line = line_new;

              if(!(line_length == ((unsigned long int *)NULL)))
                *line_length = line_size;

            }

          }

        }
      }

    }

  }


out:
  ;
  if(!(line_stream == ((struct _gpgrt__stream *)NULL)))
    do_close(line_stream, 0);

  else
    if(!(line_stream_cookie == NULL))
      es_func_mem_destroy(line_stream_cookie);

  if(!(err == 0))
  {
    if(*line == ((char *)NULL))
      mem_free((void *)line_new);

    stream->intern->indicators.err = (unsigned int)1;
  }

  return err;
}

// dynamic_buffer_out
// file ../../src/estream-printf.c line 1765
static signed int dynamic_buffer_out(void *outfncarg, const char *buf, unsigned long int buflen)
{
  struct dynamic_buffer_parm_s *parm = (struct dynamic_buffer_parm_s *)outfncarg;
  signed int tmp_if_expr$5;
  signed int *return_value___errno_location$4;
  if(!(parm->error_flag == 0))
  {
    do
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = parm->error_flag;
    }
    while((_Bool)0);
    return -1;
  }

  else
  {
    if(parm->used + buflen >= parm->alloced)
    {
      char *p;
      parm->alloced = parm->alloced + buflen + (unsigned long int)512;
      void *return_value__gpgrt_realloc$2;
      return_value__gpgrt_realloc$2=_gpgrt_realloc((void *)parm->buffer, parm->alloced);
      p = (char *)return_value__gpgrt_realloc$2;
      if(p == ((char *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 0))
        {
          return_value___errno_location$4=__errno_location();
          tmp_if_expr$5 = *return_value___errno_location$4;
        }

        else
          tmp_if_expr$5 = 12;
        parm->error_flag = tmp_if_expr$5;
        memset((void *)parm->buffer, 0, parm->used);
        return -1;
      }

      parm->buffer = p;
    }

    memcpy((void *)(parm->buffer + (signed long int)parm->used), (const void *)buf, buflen);
    parm->used = parm->used + buflen;
    return 0;
  }
}

// es_create
// file ../../src/estream.c line 1906
static signed int es_create(struct _gpgrt__stream **stream, void *cookie, struct _gpgrt_syshd *syshd, struct _gpgrt_cookie_io_functions functions, unsigned int modeflags, signed int samethread, signed int with_locked_list)
{
  struct _gpgrt_stream_internal *stream_internal_new;
  struct _gpgrt__stream *stream_new;
  signed int err;
  stream_new = (struct _gpgrt__stream *)(void *)0;
  stream_internal_new = (struct _gpgrt_stream_internal *)(void *)0;
  void *return_value_mem_alloc$1;
  return_value_mem_alloc$1=mem_alloc(sizeof(struct _gpgrt__stream) /*80ul*/ );
  stream_new = (struct _gpgrt__stream *)return_value_mem_alloc$1;
  void *return_value_mem_alloc$2;
  if(stream_new == ((struct _gpgrt__stream *)NULL))
    err = -1;

  else
  {
    return_value_mem_alloc$2=mem_alloc(sizeof(struct _gpgrt_stream_internal) /*8384ul*/ );
    stream_internal_new = (struct _gpgrt_stream_internal *)return_value_mem_alloc$2;
    if(stream_internal_new == ((struct _gpgrt_stream_internal *)NULL))
      err = -1;

    else
    {
      stream_new->buffer = stream_internal_new->buffer;
      stream_new->buffer_size = sizeof(unsigned char [8192l]) /*8192ul*/ ;
      stream_new->unread_buffer = stream_internal_new->unread_buffer;
      stream_new->unread_buffer_size = sizeof(unsigned char [16l]) /*16ul*/ ;
      stream_new->intern = stream_internal_new;
      init_stream_obj(stream_new, cookie, syshd, functions, modeflags, samethread);
      init_stream_lock(stream_new);
      err=do_list_add(stream_new, with_locked_list);
      if(err == 0)
        *stream = stream_new;

    }
  }

out:
  ;
  if(!(err == 0))
  {
    if(!(stream_new == ((struct _gpgrt__stream *)NULL)))
    {
      es_deinitialize(stream_new);
      destroy_stream_lock(stream_new);
      mem_free((void *)stream_new->intern);
      mem_free((void *)stream_new);
    }

  }

  return err;
}

// es_deinitialize
// file ../../src/estream.c line 1878
static signed int es_deinitialize(struct _gpgrt__stream *stream)
{
  signed int (*func_close)(void *);
  signed int err;
  signed int tmp_err;
  func_close = stream->intern->func_close;
  err = 0;
  if(!(stream->flags.writing == 0u))
    do
    {
      tmp_err=es_flush(stream);
      if(err == 0 && !(tmp_err == 0))
        err = tmp_err;

    }
    while((_Bool)0);

  if(!(func_close == ((signed int (*)(void *))NULL)))
  {
    tmp_err=func_close(stream->intern->cookie);
    if(err == 0 && !(tmp_err == 0))
      err = tmp_err;

  }

  mem_free((void *)stream->intern->printable_fname);
  stream->intern->printable_fname = (char *)(void *)0;
  stream->intern->printable_fname_inuse = (unsigned int)0;
  while(!(stream->intern->onclose == ((struct notify_list_s *)NULL)))
  {
    struct notify_list_s *tmp = stream->intern->onclose->next;
    mem_free((void *)stream->intern->onclose);
    stream->intern->onclose = tmp;
  }
  return err;
}

// es_empty
// file ../../src/estream.c line 1824
static void es_empty(struct _gpgrt__stream *stream)
{
  /* assertion !stream->flags.writing */
  assert(!(stream->flags.writing != 0u));
  stream->data_len = (unsigned long int)0;
  stream->data_offset = (unsigned long int)0;
  stream->unread_data_len = (unsigned long int)0;
}

// es_fill
// file ../../src/estream.c line 1690
static signed int es_fill(struct _gpgrt__stream *stream)
{
  unsigned long int bytes_read = (unsigned long int)0;
  signed int err;
  if(stream->intern->func_read == ((signed long int (*)(void *, void *, unsigned long int))NULL))
  {
    do
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 95;
    }
    while((_Bool)0);
    err = -1;
  }

  else
    if(stream->buffer_size == 0ul)
      err = 0;

    else
    {
      signed long int (*func_read)(void *, void *, unsigned long int) = stream->intern->func_read;
      signed long int ret;
      ret=func_read(stream->intern->cookie, (void *)stream->buffer, stream->buffer_size);
      if(ret == -1l)
      {
        bytes_read = (unsigned long int)0;
        err = -1;
      }

      else
      {
        bytes_read = (unsigned long int)ret;
        err = 0;
      }
    }
  if(!(err == 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    if(!(*return_value___errno_location$3 == 11))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      if(*return_value___errno_location$2 == 32)
        stream->intern->indicators.hup = (unsigned int)1;

      stream->intern->indicators.err = (unsigned int)1;
    }

  }

  else
    if(bytes_read == 0ul)
      stream->intern->indicators.eof = (unsigned int)1;

  stream->intern->offset = stream->intern->offset + (signed long int)stream->data_len;
  stream->data_len = bytes_read;
  stream->data_offset = (unsigned long int)0;
  return err;
}

// es_flush
// file ../../src/estream.c line 1745
static signed int es_flush(struct _gpgrt__stream *stream)
{
  signed long int (*func_write)(void *, const void *, unsigned long int) = stream->intern->func_write;
  signed int err;
  /* assertion stream->flags.writing */
  assert(stream->flags.writing != 0u);
  if(!(stream->data_offset == 0ul))
  {
    unsigned long int bytes_written;
    unsigned long int data_flushed;
    signed long int ret;
    if(func_write == ((signed long int (*)(void *, const void *, unsigned long int))NULL))
    {
      err = 95;
      goto out;
    }

    data_flushed = (unsigned long int)0;
    err = 0;
    if((signed long int)stream->data_offset + -((signed long int)data_flushed) >= 1l)
    {
      if(err == 0)
      {
        ret=func_write(stream->intern->cookie, (const void *)(stream->buffer + (signed long int)data_flushed), stream->data_offset - data_flushed);
        if(ret == -1l)
        {
          bytes_written = (unsigned long int)0;
          err = -1;
        }

        else
          bytes_written = (unsigned long int)ret;
        data_flushed = data_flushed + bytes_written;
      }

    }

    stream->data_flushed = stream->data_flushed + data_flushed;
    if(stream->data_offset == data_flushed)
    {
      stream->intern->offset = stream->intern->offset + (signed long int)stream->data_offset;
      stream->data_offset = (unsigned long int)0;
      stream->data_flushed = (unsigned long int)0;
      func_write(stream->intern->cookie, (void *)0, (unsigned long int)0);
    }

  }

  else
    err = 0;

out:
  ;
  signed int *return_value___errno_location$2;
  if(!(err == 0))
  {
    return_value___errno_location$2=__errno_location();
    if(!(*return_value___errno_location$2 == 11))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 32)
        stream->intern->indicators.hup = (unsigned int)1;

      stream->intern->indicators.err = (unsigned int)1;
    }

  }

  return err;
}

// es_func_fd_destroy
// file ../../src/estream.c line 1051
static signed int es_func_fd_destroy(void *cookie)
{
  struct estream_cookie_fd *fd_cookie = (struct estream_cookie_fd *)cookie;
  signed int err;
  signed int tmp_if_expr$2;
  signed int return_value_close$1;
  if(!(fd_cookie == ((struct estream_cookie_fd *)NULL)))
  {
    if(fd_cookie->fd == -1)
      err = 0;

    else
    {
      if(!(fd_cookie->no_close == 0))
        tmp_if_expr$2 = 0;

      else
      {
        return_value_close$1=close(fd_cookie->fd);
        tmp_if_expr$2 = return_value_close$1;
      }
      err = tmp_if_expr$2;
    }
    mem_free((void *)fd_cookie);
  }

  else
    err = 0;
  return err;
}

// es_func_fd_ioctl
// file ../../src/estream.c line 1010
static signed int es_func_fd_ioctl(void *cookie, signed int cmd, void *ptr, unsigned long int *len)
{
  struct estream_cookie_fd *fd_cookie = (struct estream_cookie_fd *)cookie;
  signed int ret;
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$3;
  if(len == ((unsigned long int *)NULL) && cmd == 2)
  {
    fd_cookie->nonblock = (signed int)!(!(ptr != NULL));
    if(fd_cookie->fd == -1)
    {
      do
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        *return_value___errno_location$1 = 22;
      }
      while((_Bool)0);
      ret = -1;
    }

    else
    {
      do
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        *return_value___errno_location$2 = 0;
      }
      while((_Bool)0);
      ret=fcntl(fd_cookie->fd, 3, 0);
      if(ret == -1)
      {
        return_value___errno_location$3=__errno_location();
        tmp_if_expr$4 = *return_value___errno_location$3 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(!tmp_if_expr$4)
      {
        if(!(fd_cookie->nonblock == 0))
          ret=fcntl(fd_cookie->fd, 4, ret | 04000);

        else
          ret=fcntl(fd_cookie->fd, 4, ret & ~04000);
      }

    }
  }

  else
  {
    do
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      *return_value___errno_location$5 = 22;
    }
    while((_Bool)0);
    ret = -1;
  }
  return ret;
}

// es_func_fd_read
// file ../../src/estream.c line 917
static signed long int es_func_fd_read(void *cookie, void *buffer, unsigned long int size)
{
  struct estream_cookie_fd *file_cookie = (struct estream_cookie_fd *)cookie;
  signed long int bytes_read;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  if(size == 0ul)
    bytes_read = (signed long int)-1;

  else
    if(file_cookie->fd == -1)
    {
      _gpgrt_yield();
      bytes_read = (signed long int)0;
    }

    else
    {
      if(!(pre_syscall_func == ((void (*)(void))NULL)))
        pre_syscall_func();

      do
      {
        bytes_read=read(file_cookie->fd, buffer, size);
        if(bytes_read == -1l)
        {
          return_value___errno_location$1=__errno_location();
          tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$2 = (_Bool)0;
      }
      while(tmp_if_expr$2);
      if(!(post_syscall_func == ((void (*)(void))NULL)))
        post_syscall_func();

    }
  return bytes_read;
}

// es_func_fd_seek
// file ../../src/estream.c line 978
static signed int es_func_fd_seek(void *cookie, signed long int *offset, signed int whence)
{
  struct estream_cookie_fd *file_cookie = (struct estream_cookie_fd *)cookie;
  signed long int offset_new;
  signed int err;
  if(file_cookie->fd == -1)
  {
    do
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 29;
    }
    while((_Bool)0);
    err = -1;
  }

  else
  {
    if(!(pre_syscall_func == ((void (*)(void))NULL)))
      pre_syscall_func();

    offset_new=lseek(file_cookie->fd, *offset, whence);
    if(!(post_syscall_func == ((void (*)(void))NULL)))
      post_syscall_func();

    if(offset_new == -1l)
      err = -1;

    else
    {
      *offset = offset_new;
      err = 0;
    }
  }
  return err;
}

// es_func_fd_write
// file ../../src/estream.c line 948
static signed long int es_func_fd_write(void *cookie, const void *buffer, unsigned long int size)
{
  struct estream_cookie_fd *file_cookie = (struct estream_cookie_fd *)cookie;
  signed long int bytes_written;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  if(file_cookie->fd == -1)
  {
    _gpgrt_yield();
    bytes_written = (signed long int)size;
  }

  else
    if(!(buffer == NULL))
    {
      if(!(pre_syscall_func == ((void (*)(void))NULL)))
        pre_syscall_func();

      do
      {
        bytes_written=write(file_cookie->fd, buffer, size);
        if(bytes_written == -1l)
        {
          return_value___errno_location$1=__errno_location();
          tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$2 = (_Bool)0;
      }
      while(tmp_if_expr$2);
      if(!(post_syscall_func == ((void (*)(void))NULL)))
        post_syscall_func();

    }

    else
      bytes_written = (signed long int)size;
  return bytes_written;
}

// es_func_fp_destroy
// file ../../src/estream.c line 1453
static signed int es_func_fp_destroy(void *cookie)
{
  struct estream_cookie_fp *fp_cookie = (struct estream_cookie_fp *)cookie;
  signed int err;
  signed int tmp_if_expr$2;
  signed int return_value_fclose$1;
  if(!(fp_cookie == ((struct estream_cookie_fp *)NULL)))
  {
    if(!(fp_cookie->fp == ((struct _IO_FILE *)NULL)))
    {
      if(!(pre_syscall_func == ((void (*)(void))NULL)))
        pre_syscall_func();

      fflush(fp_cookie->fp);
      if(!(post_syscall_func == ((void (*)(void))NULL)))
        post_syscall_func();

      if(!(fp_cookie->no_close == 0))
        tmp_if_expr$2 = 0;

      else
      {
        return_value_fclose$1=fclose(fp_cookie->fp);
        tmp_if_expr$2 = return_value_fclose$1;
      }
      err = tmp_if_expr$2;
    }

    else
      err = 0;
    mem_free((void *)fp_cookie);
  }

  else
    err = 0;
  return err;
}

// es_func_fp_read
// file ../../src/estream.c line 1341
static signed long int es_func_fp_read(void *cookie, void *buffer, unsigned long int size)
{
  struct estream_cookie_fp *file_cookie = (struct estream_cookie_fp *)cookie;
  signed long int bytes_read;
  signed int return_value_ferror$2;
  if(size == 0ul)
    return (signed long int)-1;

  else
  {
    if(!(file_cookie->fp == ((struct _IO_FILE *)NULL)))
    {
      if(!(pre_syscall_func == ((void (*)(void))NULL)))
        pre_syscall_func();

      unsigned long int return_value_fread$1;
      return_value_fread$1=fread(buffer, (unsigned long int)1, size, file_cookie->fp);
      bytes_read = (signed long int)return_value_fread$1;
      if(!(post_syscall_func == ((void (*)(void))NULL)))
        post_syscall_func();

    }

    else
      bytes_read = (signed long int)0;
    if(bytes_read == 0l)
    {
      return_value_ferror$2=ferror(file_cookie->fp);
      if(return_value_ferror$2 == 0)
        goto __CPROVER_DUMP_L6;

      return (signed long int)-1;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      return bytes_read;
    }
  }
}

// es_func_fp_seek
// file ../../src/estream.c line 1416
static signed int es_func_fp_seek(void *cookie, signed long int *offset, signed int whence)
{
  struct estream_cookie_fp *file_cookie = (struct estream_cookie_fp *)cookie;
  signed long int offset_new;
  if(file_cookie->fp == ((struct _IO_FILE *)NULL))
  {
    do
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 29;
    }
    while((_Bool)0);
    return -1;
  }

  else
  {
    if(!(pre_syscall_func == ((void (*)(void))NULL)))
      pre_syscall_func();

    signed int return_value_fseek$2;
    return_value_fseek$2=fseek(file_cookie->fp, (signed long int)*offset, whence);
    if(!(return_value_fseek$2 == 0))
    {
      if(!(post_syscall_func == ((void (*)(void))NULL)))
        post_syscall_func();

      return -1;
    }

    else
    {
      offset_new=ftell(file_cookie->fp);
      if(!(post_syscall_func == ((void (*)(void))NULL)))
        post_syscall_func();

      if(offset_new == -1l)
        return -1;

      else
      {
        *offset = offset_new;
        return 0;
      }
    }
  }
}

// es_func_fp_write
// file ../../src/estream.c line 1367
static signed long int es_func_fp_write(void *cookie, const void *buffer, unsigned long int size)
{
  struct estream_cookie_fp *file_cookie = (struct estream_cookie_fp *)cookie;
  unsigned long int bytes_written;
  if(!(file_cookie->fp == ((struct _IO_FILE *)NULL)))
  {
    if(!(pre_syscall_func == ((void (*)(void))NULL)))
      pre_syscall_func();

    if(!(buffer == NULL))
      bytes_written=fwrite(buffer, (unsigned long int)1, size, file_cookie->fp);

    else
      bytes_written = size;
    fflush(file_cookie->fp);
    if(!(post_syscall_func == ((void (*)(void))NULL)))
      post_syscall_func();

  }

  else
    bytes_written = size;
  if(!(bytes_written == size))
    return (signed long int)-1;

  else
    return (signed long int)bytes_written;
}

// es_func_mem_destroy
// file ../../src/estream.c line 855
static signed int es_func_mem_destroy(void *cookie)
{
  struct estream_cookie_mem *mem_cookie = (struct estream_cookie_mem *)cookie;
  if(!(cookie == NULL))
  {
    mem_cookie->func_free((void *)mem_cookie->memory);
    mem_free((void *)mem_cookie);
  }

  return 0;
}

// es_func_mem_ioctl
// file ../../src/estream.c line 827
static signed int es_func_mem_ioctl(void *cookie, signed int cmd, void *ptr, unsigned long int *len)
{
  struct estream_cookie_mem *mem_cookie = (struct estream_cookie_mem *)cookie;
  signed int ret;
  if(cmd == 1)
  {
    *((void **)ptr) = (void *)mem_cookie->memory;
    *len = mem_cookie->offset;
    mem_cookie->memory = (unsigned char *)(void *)0;
    mem_cookie->memory_size = (unsigned long int)0;
    mem_cookie->offset = (unsigned long int)0;
    ret = 0;
  }

  else
  {
    do
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 22;
    }
    while((_Bool)0);
    ret = -1;
  }
  return ret;
}

// es_func_mem_read
// file ../../src/estream.c line 642
static signed long int es_func_mem_read(void *cookie, void *buffer, unsigned long int size)
{
  struct estream_cookie_mem *mem_cookie = (struct estream_cookie_mem *)cookie;
  signed long int ret;
  if(size == 0ul)
    return (signed long int)(mem_cookie->data_len - mem_cookie->offset != 0ul ? 0 : -1);

  else
  {
    if(!(mem_cookie->data_len + -mem_cookie->offset >= size))
      size = mem_cookie->data_len - mem_cookie->offset;

    if(!(size == 0ul))
    {
      memcpy(buffer, (const void *)(mem_cookie->memory + (signed long int)mem_cookie->offset), size);
      mem_cookie->offset = mem_cookie->offset + size;
    }

    ret = (signed long int)size;
    return ret;
  }
}

// es_func_mem_seek
// file ../../src/estream.c line 752
static signed int es_func_mem_seek(void *cookie, signed long int *offset, signed int whence)
{
  struct estream_cookie_mem *mem_cookie = (struct estream_cookie_mem *)cookie;
  signed long int pos_new;
  switch(whence)
  {
    case 0:
    {
      pos_new = *offset;
      break;
    }
    case 1:
    {
      mem_cookie->offset = mem_cookie->offset + (unsigned long int)*offset;
      pos_new = (signed long int)mem_cookie->offset;
      break;
    }
    case 2:
    {
      mem_cookie->data_len = mem_cookie->data_len + (unsigned long int)*offset;
      pos_new = (signed long int)mem_cookie->data_len;
      break;
    }
    default:
    {
      do
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        *return_value___errno_location$1 = 22;
      }
      while((_Bool)0);
      return -1;
    }
  }
  if(!(mem_cookie->memory_size >= (unsigned long int)pos_new))
  {
    unsigned long int newsize;
    void *newbuf;
    if(mem_cookie->flags.grow == 0u)
    {
      do
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        *return_value___errno_location$2 = 28;
      }
      while((_Bool)0);
      return -1;
    }

    newsize = ((unsigned long int)pos_new + mem_cookie->block_size) - (unsigned long int)1;
    if(!(newsize >= (unsigned long int)pos_new))
    {
      do
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        *return_value___errno_location$3 = 22;
      }
      while((_Bool)0);
      return -1;
    }

    newsize = newsize / mem_cookie->block_size;
    newsize = newsize * mem_cookie->block_size;
    if(!(mem_cookie->memory_limit == 0ul))
    {
      if(!(mem_cookie->memory_limit >= newsize))
      {
        do
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          *return_value___errno_location$4 = 28;
        }
        while((_Bool)0);
        return -1;
      }

    }

    /* assertion mem_cookie->func_realloc */
    assert(mem_cookie->func_realloc != ((void * (*)(void *, unsigned long int))NULL));
    newbuf=mem_cookie->func_realloc((void *)mem_cookie->memory, newsize);
    if(newbuf == NULL)
      return -1;

    mem_cookie->memory = (unsigned char *)newbuf;
    mem_cookie->memory_size = newsize;
  }

  if(!(mem_cookie->data_len >= (unsigned long int)pos_new))
  {
    memset((void *)(mem_cookie->memory + (signed long int)mem_cookie->data_len), 0, (unsigned long int)pos_new - mem_cookie->data_len);
    mem_cookie->data_len = (unsigned long int)pos_new;
  }

  mem_cookie->offset = (unsigned long int)pos_new;
  *offset = pos_new;
  return 0;
}

// es_func_mem_write
// file ../../src/estream.c line 666
static signed long int es_func_mem_write(void *cookie, const void *buffer, unsigned long int size)
{
  struct estream_cookie_mem *mem_cookie = (struct estream_cookie_mem *)cookie;
  signed long int ret;
  unsigned long int nleft;
  if(size == 0ul)
    return (signed long int)0;

  else
  {
    if(!((1024u & mem_cookie->modeflags) == 0u))
      mem_cookie->offset = mem_cookie->data_len;

    /* assertion mem_cookie->memory_size >= mem_cookie->offset */
    assert(mem_cookie->memory_size >= mem_cookie->offset);
    nleft = mem_cookie->memory_size - mem_cookie->offset;
    if(mem_cookie->flags.grow == 0u)
    {
      if(!(nleft >= size))
        size = nleft;

    }

    if(!(nleft >= size))
    {
      unsigned char *newbuf;
      unsigned long int newsize;
      if(mem_cookie->memory_size == 0ul)
        newsize = size;

      else
        newsize = mem_cookie->memory_size + (size - nleft);
      if(!(newsize >= mem_cookie->offset))
      {
        do
        {
          signed int *return_value___errno_location$1;
          return_value___errno_location$1=__errno_location();
          *return_value___errno_location$1 = 22;
        }
        while((_Bool)0);
        return (signed long int)-1;
      }

      if(!(mem_cookie->block_size == 0ul))
      {
        newsize = newsize + (mem_cookie->block_size - (unsigned long int)1);
        if(!(newsize >= mem_cookie->offset))
        {
          do
          {
            signed int *return_value___errno_location$2;
            return_value___errno_location$2=__errno_location();
            *return_value___errno_location$2 = 22;
          }
          while((_Bool)0);
          return (signed long int)-1;
        }

        newsize = newsize / mem_cookie->block_size;
        newsize = newsize * mem_cookie->block_size;
      }

      if(!(mem_cookie->memory_limit == 0ul))
      {
        if(!(mem_cookie->memory_limit >= newsize))
        {
          do
          {
            signed int *return_value___errno_location$3;
            return_value___errno_location$3=__errno_location();
            *return_value___errno_location$3 = 28;
          }
          while((_Bool)0);
          return (signed long int)-1;
        }

      }

      /* assertion mem_cookie->func_realloc */
      assert(mem_cookie->func_realloc != ((void * (*)(void *, unsigned long int))NULL));
      void *return_value;
      return_value=mem_cookie->func_realloc((void *)mem_cookie->memory, newsize);
      newbuf = (unsigned char *)return_value;
      if(newbuf == ((unsigned char *)NULL))
        return (signed long int)-1;

      mem_cookie->memory = newbuf;
      mem_cookie->memory_size = newsize;
      /* assertion mem_cookie->memory_size >= mem_cookie->offset */
      assert(mem_cookie->memory_size >= mem_cookie->offset);
      nleft = mem_cookie->memory_size - mem_cookie->offset;
      /* assertion size <= nleft */
      assert(size <= nleft);
    }

    memcpy((void *)(mem_cookie->memory + (signed long int)mem_cookie->offset), buffer, size);
    if(!(mem_cookie->data_len >= mem_cookie->offset + size))
      mem_cookie->data_len = mem_cookie->offset + size;

    mem_cookie->offset = mem_cookie->offset + size;
    ret = (signed long int)size;
    return ret;
  }
}

// es_offset_calculate
// file ../../src/estream.c line 2806
static signed long int es_offset_calculate(struct _gpgrt__stream *stream)
{
  signed long int offset = (signed long int)((unsigned long int)stream->intern->offset + stream->data_offset);
  if(!((unsigned long int)offset >= stream->unread_data_len))
    offset = (signed long int)0;

  else
    offset = offset - (signed long int)stream->unread_data_len;
  return offset;
}

// es_opaque_ctrl
// file ../../src/estream.c line 2822
static void es_opaque_ctrl(struct _gpgrt__stream * restrict stream, void * restrict opaque_new, void ** restrict opaque_old)
{
  if(!(opaque_old == ((void ** restrict )NULL)))
    *opaque_old = stream->intern->opaque;

  if(!(opaque_new == NULL))
    stream->intern->opaque = opaque_new;

}

// es_peek
// file ../../src/estream.c line 2529
static signed int es_peek(struct _gpgrt__stream * restrict stream, unsigned char ** restrict data, unsigned long int * restrict data_len)
{
  signed int err;
  if(!(stream->flags.writing == 0u))
  {
    err=es_flush(stream);
    if(!(err == 0))
      goto out;

    stream->flags.writing = (unsigned int)0;
  }

  if(stream->data_offset == stream->data_len)
  {
    err=es_fill(stream);
    if(!(err == 0))
      goto out;

  }

  if(!(data == ((unsigned char ** restrict )NULL)))
    *data = stream->buffer + (signed long int)stream->data_offset;

  if(!(data_len == ((unsigned long int *)NULL)))
    *data_len = stream->data_len - stream->data_offset;

  err = 0;

out:
  ;
  return err;
}

// es_print
// file ../../src/estream.c line 2732
static signed int es_print(struct _gpgrt__stream * restrict stream, const char * restrict format, void **ap)
{
  signed int rc;
  stream->intern->print_ntotal = (unsigned long int)0;
  rc=_gpgrt_estream_format(print_writer, (void *)stream, format, ap);
  if(!(rc == 0))
    return -1;

  else
    return (signed int)stream->intern->print_ntotal;
}

// es_read_fbf
// file ../../src/estream.c line 2077
static signed int es_read_fbf(struct _gpgrt__stream * restrict stream, unsigned char * restrict buffer, unsigned long int bytes_to_read, unsigned long int * restrict bytes_read)
{
  unsigned long int data_available;
  unsigned long int data_to_read;
  unsigned long int data_read;
  signed int err;
  data_read = (unsigned long int)0;
  err = 0;
  while(err == 0 && !(bytes_to_read == data_read))
  {
    if(stream->data_offset == stream->data_len)
    {
      err=es_fill(stream);
      if(err == 0)
      {
        if(stream->data_len == 0ul)
          break;

      }

    }

    if(err == 0)
    {
      data_to_read = bytes_to_read - data_read;
      data_available = stream->data_len - stream->data_offset;
      if(!(data_available >= data_to_read))
        data_to_read = data_available;

      memcpy((void *)(buffer + (signed long int)data_read), (const void *)(stream->buffer + (signed long int)stream->data_offset), data_to_read);
      stream->data_offset = stream->data_offset + data_to_read;
      data_read = data_read + data_to_read;
    }

  }
  *bytes_read = data_read;
  return err;
}

// es_read_lbf
// file ../../src/estream.c line 2147
static signed int es_read_lbf(struct _gpgrt__stream * restrict stream, unsigned char * restrict buffer, unsigned long int bytes_to_read, unsigned long int * restrict bytes_read)
{
  signed int err;
  err=es_read_fbf(stream, buffer, bytes_to_read, bytes_read);
  return err;
}

// es_read_nbf
// file ../../src/estream.c line 2024
static signed int es_read_nbf(struct _gpgrt__stream * restrict stream, unsigned char * restrict buffer, unsigned long int bytes_to_read, unsigned long int * restrict bytes_read)
{
  signed long int (*func_read)(void *, void *, unsigned long int) = stream->intern->func_read;
  unsigned long int data_read;
  signed long int ret;
  signed int err;
  data_read = (unsigned long int)0;
  err = 0;
  if(!(bytes_to_read == data_read))
  {
    ret=func_read(stream->intern->cookie, (void *)(buffer + (signed long int)data_read), bytes_to_read - data_read);
    if(ret == -1l)
      err = -1;

    else
      if(!(ret == 0l))
        data_read = data_read + (unsigned long int)ret;

  }

  stream->intern->offset = stream->intern->offset + (signed long int)data_read;
  *bytes_read = data_read;
  return err;
}

// es_readn
// file ../../src/estream.c line 2161
static signed int es_readn(struct _gpgrt__stream * restrict stream, void * restrict buffer_arg, unsigned long int bytes_to_read, unsigned long int * restrict bytes_read)
{
  unsigned char *buffer = (unsigned char *)buffer_arg;
  unsigned long int data_read_unread;
  unsigned long int data_read;
  signed int err;
  data_read_unread = (unsigned long int)0;
  data_read = (unsigned long int)0;
  err = 0;
  if(!(stream->flags.writing == 0u))
  {
    err=es_flush(stream);
    if(!(err == 0))
      goto out;

    stream->flags.writing = (unsigned int)0;
  }

  for( ; !(bytes_to_read == data_read_unread); data_read_unread = data_read_unread + 1ul)
  {
    if(stream->unread_data_len == 0ul)
      break;

    buffer[(signed long int)data_read_unread] = stream->unread_buffer[(signed long int)(stream->unread_data_len - (unsigned long int)1)];
    stream->unread_data_len = stream->unread_data_len - 1ul;
  }
  switch(stream->intern->strategy)
  {
    case 2:
    {
      err=es_read_nbf(stream, buffer + (signed long int)data_read_unread, bytes_to_read - data_read_unread, &data_read);
      break;
    }
    case 1:
    {
      err=es_read_lbf(stream, buffer + (signed long int)data_read_unread, bytes_to_read - data_read_unread, &data_read);
      break;
    }
    case 0:
      err=es_read_fbf(stream, buffer + (signed long int)data_read_unread, bytes_to_read - data_read_unread, &data_read);
  }

out:
  ;
  if(!(bytes_read == ((unsigned long int *)NULL)))
    *bytes_read = data_read_unread + data_read;

  return err;
}

// es_seek
// file ../../src/estream.c line 2280
static signed int es_seek(struct _gpgrt__stream * restrict stream, signed long int offset, signed int whence, signed long int * restrict offset_new)
{
  signed int (*func_seek)(void *, signed long int *, signed int) = stream->intern->func_seek;
  signed int err;
  signed int ret;
  signed long int off;
  if(func_seek == ((signed int (*)(void *, signed long int *, signed int))NULL))
  {
    do
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 95;
    }
    while((_Bool)0);
    err = -1;
  }

  else
  {
    if(!(stream->flags.writing == 0u))
    {
      err=es_flush(stream);
      if(!(err == 0))
        goto out;

      stream->flags.writing = (unsigned int)0;
    }

    off = offset;
    if(whence == 1)
    {
      off = (signed long int)(((unsigned long int)off - stream->data_len) + stream->data_offset);
      off = off - (signed long int)stream->unread_data_len;
    }

    ret=func_seek(stream->intern->cookie, &off, whence);
    if(ret == -1)
      err = -1;

    else
    {
      err = 0;
      es_empty(stream);
      if(!(offset_new == ((signed long int *)NULL)))
        *offset_new = off;

      stream->intern->indicators.eof = (unsigned int)0;
      stream->intern->offset = off;
    }
  }

out:
  ;
  if(!(err == 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 32)
      stream->intern->indicators.hup = (unsigned int)1;

    stream->intern->indicators.err = (unsigned int)1;
  }

  return err;
}

// es_set_buffering
// file ../../src/estream.c line 2746
static signed int es_set_buffering(struct _gpgrt__stream * restrict stream, char * restrict buffer, signed int mode, unsigned long int size)
{
  signed int err;
  if(!(stream->flags.writing == 0u))
  {
    err=es_flush(stream);
    if(!(err == 0))
      goto out;

  }

  else
    es_empty(stream);
  stream->intern->indicators.eof = (unsigned int)0;
  if(!(stream->intern->deallocate_buffer == 0u))
  {
    stream->intern->deallocate_buffer = (unsigned int)0;
    mem_free((void *)stream->buffer);
    stream->buffer = (unsigned char *)(void *)0;
  }

  if(mode == 2)
    stream->buffer_size = (unsigned long int)0;

  else
  {
    void *buffer_new;
    if(!(buffer == ((char *)NULL)))
      buffer_new = (void *)buffer;

    else
    {
      if(size == 0ul)
        size = (unsigned long int)8192;

      buffer_new=mem_alloc(size);
      if(buffer_new == NULL)
      {
        err = -1;
        goto out;
      }

    }
    stream->buffer = (unsigned char *)buffer_new;
    stream->buffer_size = size;
    if(buffer == ((char *)NULL))
      stream->intern->deallocate_buffer = (unsigned int)1;

  }
  stream->intern->strategy = mode;
  err = 0;

out:
  ;
  return err;
}

// es_skip
// file ../../src/estream.c line 2566
static signed int es_skip(struct _gpgrt__stream *stream, unsigned long int size)
{
  signed int err;
  if(!(stream->data_len >= stream->data_offset + size))
  {
    do
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 22;
    }
    while((_Bool)0);
    err = -1;
  }

  else
  {
    stream->data_offset = stream->data_offset + size;
    err = 0;
  }
  return err;
}

// es_unreadn
// file ../../src/estream.c line 2254
static void es_unreadn(struct _gpgrt__stream * restrict stream, const unsigned char * restrict data, unsigned long int data_n, unsigned long int * restrict bytes_unread)
{
  unsigned long int space_left = stream->unread_buffer_size - stream->unread_data_len;
  if(!(space_left >= data_n))
    data_n = space_left;

  if(!(data_n == 0ul))
  {
    memcpy((void *)(stream->unread_buffer + (signed long int)stream->unread_data_len), (const void *)data, data_n);
    stream->unread_data_len = stream->unread_data_len + data_n;
    stream->intern->indicators.eof = (unsigned int)0;
  }


out:
  ;
  if(!(bytes_unread == ((unsigned long int *)NULL)))
    *bytes_unread = data_n;

}

// es_write_fbf
// file ../../src/estream.c line 2395
static signed int es_write_fbf(struct _gpgrt__stream * restrict stream, const unsigned char * restrict buffer, unsigned long int bytes_to_write, unsigned long int * restrict bytes_written)
{
  unsigned long int space_available;
  unsigned long int data_to_write;
  unsigned long int data_written;
  signed int err;
  data_written = (unsigned long int)0;
  err = 0;
  while(err == 0 && !(bytes_to_write == data_written))
  {
    if(stream->data_offset == stream->buffer_size)
      err=es_flush(stream);

    if(err == 0)
    {
      data_to_write = bytes_to_write - data_written;
      space_available = stream->buffer_size - stream->data_offset;
      if(!(space_available >= data_to_write))
        data_to_write = space_available;

      memcpy((void *)(stream->buffer + (signed long int)stream->data_offset), (const void *)(buffer + (signed long int)data_written), data_to_write);
      stream->data_offset = stream->data_offset + data_to_write;
      data_written = data_written + data_to_write;
    }

  }
  *bytes_written = data_written;
  return err;
}

// es_write_lbf
// file ../../src/estream.c line 2439
static signed int es_write_lbf(struct _gpgrt__stream * restrict stream, const unsigned char * restrict buffer, unsigned long int bytes_to_write, unsigned long int * restrict bytes_written)
{
  unsigned long int data_flushed = (unsigned long int)0;
  unsigned long int data_buffered = (unsigned long int)0;
  unsigned char *nlp;
  signed int err = 0;
  void *return_value_memrchr$1;
  return_value_memrchr$1=memrchr((const void *)buffer, 10, bytes_to_write);
  nlp = (unsigned char *)return_value_memrchr$1;
  if(!(nlp == ((unsigned char *)NULL)))
  {
    err=es_flush(stream);
    if(err == 0)
      err=es_write_nbf(stream, buffer, (unsigned long int)((nlp - buffer) + (signed long int)1), &data_flushed);

  }

  if(err == 0)
    err=es_write_fbf(stream, buffer + (signed long int)data_flushed, bytes_to_write - data_flushed, &data_buffered);

  *bytes_written = data_flushed + data_buffered;
  return err;
}

// es_write_nbf
// file ../../src/estream.c line 2347
static signed int es_write_nbf(struct _gpgrt__stream * restrict stream, const unsigned char * restrict buffer, unsigned long int bytes_to_write, unsigned long int * restrict bytes_written)
{
  signed long int (*func_write)(void *, const void *, unsigned long int) = stream->intern->func_write;
  unsigned long int data_written;
  signed long int ret;
  signed int err;
  if(func_write == ((signed long int (*)(void *, const void *, unsigned long int))NULL) && !(bytes_to_write == 0ul))
    err = 95;

  else
  {
    data_written = (unsigned long int)0;
    err = 0;
    if(!(bytes_to_write == data_written))
    {
      ret=func_write(stream->intern->cookie, (const void *)(buffer + (signed long int)data_written), bytes_to_write - data_written);
      if(ret == -1l)
        err = -1;

      else
        data_written = data_written + (unsigned long int)ret;
    }

    stream->intern->offset = stream->intern->offset + (signed long int)data_written;
    *bytes_written = data_written;
  }

out:
  ;
  return err;
}

// es_writen
// file ../../src/estream.c line 2473
static signed int es_writen(struct _gpgrt__stream * restrict stream, const void * restrict buffer, unsigned long int bytes_to_write, unsigned long int * restrict bytes_written)
{
  unsigned long int data_written;
  signed int err;
  data_written = (unsigned long int)0;
  err = 0;
  if(stream->flags.writing == 0u)
  {
    if(!(stream->intern->func_seek == ((signed int (*)(void *, signed long int *, signed int))NULL)))
    {
      err=es_seek(stream, (signed long int)0, 1, (signed long int *)(void *)0);
      if(!(err == 0))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        if(*return_value___errno_location$1 == 29)
          err = 0;

        else
          goto out;
      }

    }

  }

  switch(stream->intern->strategy)
  {
    case 2:
    {
      err=es_write_nbf(stream, (const unsigned char *)buffer, bytes_to_write, &data_written);
      break;
    }
    case 1:
    {
      err=es_write_lbf(stream, (const unsigned char *)buffer, bytes_to_write, &data_written);
      break;
    }
    case 0:
      err=es_write_fbf(stream, (const unsigned char *)buffer, bytes_to_write, &data_written);
  }

out:
  ;
  if(!(bytes_written == ((unsigned long int *)NULL)))
    *bytes_written = data_written;

  if(!(data_written == 0ul))
  {
    if(stream->flags.writing == 0u)
      stream->flags.writing = (unsigned int)1;

  }

  return err;
}

// fail
// file ../../tests/t-common.h line 60
static void fail(const char *format, ...)
{
  void **arg_ptr;
  fflush(stdout);
  flockfile(stderr);
  fprintf(stderr, "%s: ", (const void *)"t-lock");
  arg_ptr = (void **)&format;
  vfprintf(stderr, format, arg_ptr);
  arg_ptr = ((void **)NULL);
  unsigned long int return_value_strlen$1;
  if(!(*format == 0))
  {
    return_value_strlen$1=strlen(format);
    if(!((signed int)format[-1l + (signed long int)return_value_strlen$1] == 10))
      _IO_putc(10, stderr);

  }

  funlockfile(stderr);
  errorcount = errorcount + 1;
  if(errorcount >= 50)
    die("stopped after 50 errors.");

}

// fixed_buffer_out
// file ../../src/estream-printf.c line 1686
static signed int fixed_buffer_out(void *outfncarg, const char *buf, unsigned long int buflen)
{
  struct fixed_buffer_parm_s *parm = (struct fixed_buffer_parm_s *)outfncarg;
  parm->count = parm->count + buflen;
  _Bool tmp_if_expr$1;
  unsigned long int tmp_post$2;
  const char *tmp_post$3;
  if(!(parm->buffer == ((char *)NULL)))
  {
    if(!(parm->used + buflen >= parm->size))
    {
      memcpy((void *)(parm->buffer + (signed long int)parm->used), (const void *)buf, buflen);
      parm->used = parm->used + buflen;
    }

    else
      do
      {
        if(!(buflen == 0ul))
          tmp_if_expr$1 = parm->used < parm->size ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(!tmp_if_expr$1)
          break;

        tmp_post$2 = parm->used;
        parm->used = parm->used + 1ul;
        tmp_post$3 = buf;
        buf = buf + 1l;
        parm->buffer[(signed long int)tmp_post$2] = *tmp_post$3;
        buflen = buflen - 1ul;
      }
      while((_Bool)1);
  }

  return 0;
}

// fname_set_internal
// file ../../src/estream.c line 4692
static void fname_set_internal(struct _gpgrt__stream *stream, const char *fname, signed int quote)
{
  if(!(stream->intern->printable_fname == ((char *)NULL)))
  {
    if(stream->intern->printable_fname_inuse == 0u)
    {
      mem_free((void *)stream->intern->printable_fname);
      stream->intern->printable_fname = (char *)(void *)0;
    }

  }

  if(stream->intern->printable_fname == ((char *)NULL))
  {
    if(!((signed int)*fname == 91))
      quote = 0;

    else
      quote = (signed int)!(!(quote != 0));
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(fname);
    void *return_value_mem_alloc$2;
    return_value_mem_alloc$2=mem_alloc(return_value_strlen$1 + (unsigned long int)quote + (unsigned long int)1);
    stream->intern->printable_fname = (char *)return_value_mem_alloc$2;
    if(!(quote == 0))
      stream->intern->printable_fname[(signed long int)0] = (char)92;

    strcpy(stream->intern->printable_fname + (signed long int)quote, fname);
  }

}

// func_fd_create
// file ../../src/estream.c line 890
static signed int func_fd_create(void **cookie, signed int fd, unsigned int modeflags, signed int no_close)
{
  struct estream_cookie_fd *fd_cookie;
  signed int err;
  void *return_value_mem_alloc$1;
  return_value_mem_alloc$1=mem_alloc(sizeof(struct estream_cookie_fd) /*12ul*/ );
  fd_cookie = (struct estream_cookie_fd *)return_value_mem_alloc$1;
  if(fd_cookie == ((struct estream_cookie_fd *)NULL))
    err = -1;

  else
  {
    fd_cookie->fd = fd;
    fd_cookie->no_close = no_close;
    fd_cookie->nonblock = (signed int)!(!((modeflags & (unsigned int)04000) != 0u));
    *cookie = (void *)fd_cookie;
    err = 0;
  }
  return err;
}

// func_file_create
// file ../../src/estream.c line 1495
static signed int func_file_create(void **cookie, signed int *filedes, const char *path, unsigned int modeflags, unsigned int cmode)
{
  struct estream_cookie_fd *file_cookie;
  signed int err;
  signed int fd;
  err = 0;
  fd = -1;
  void *return_value_mem_alloc$1;
  return_value_mem_alloc$1=mem_alloc(sizeof(struct estream_cookie_fd) /*12ul*/ );
  file_cookie = (struct estream_cookie_fd *)return_value_mem_alloc$1;
  if(file_cookie == ((struct estream_cookie_fd *)NULL))
    err = -1;

  else
  {
    fd=open(path, (signed int)modeflags, cmode);
    if(fd == -1)
      err = -1;

    else
    {
      file_cookie->fd = fd;
      file_cookie->no_close = 0;
      *cookie = (void *)file_cookie;
      *filedes = fd;
    }
  }

out:
  ;
  if(!(err == 0))
    mem_free((void *)file_cookie);

  return err;
}

// func_fp_create
// file ../../src/estream.c line 1312
static signed int func_fp_create(void **cookie, struct _IO_FILE *fp, unsigned int modeflags, signed int no_close)
{
  struct estream_cookie_fp *fp_cookie;
  signed int err;
  void *return_value_mem_alloc$1;
  return_value_mem_alloc$1=mem_alloc(sizeof(struct estream_cookie_fp) /*16ul*/ );
  fp_cookie = (struct estream_cookie_fp *)return_value_mem_alloc$1;
  if(fp_cookie == ((struct estream_cookie_fp *)NULL))
    err = -1;

  else
  {
    (void)modeflags;
    fp_cookie->fp = fp;
    fp_cookie->no_close = no_close;
    *cookie = (void *)fp_cookie;
    err = 0;
  }
  return err;
}

// func_mem_create
// file ../../src/estream.c line 594
static signed int func_mem_create(void * restrict * restrict cookie, unsigned char * restrict data, unsigned long int data_n, unsigned long int data_len, unsigned long int block_size, unsigned int grow, void * (*func_realloc)(void *, unsigned long int), void (*func_free)(void *), unsigned int modeflags, unsigned long int memory_limit)
{
  struct estream_cookie_mem *mem_cookie;
  signed int err;
  if(data == ((unsigned char *)NULL) && (!(data_len == 0ul) || !(data_n == 0ul)))
  {
    do
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 22;
    }
    while((_Bool)0);
    return -1;
  }

  else
    if(func_realloc == ((void * (*)(void *, unsigned long int))NULL) && !(func_free == ((void (*)(void *))NULL)) && !(grow == 0u))
    {
      do
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        *return_value___errno_location$2 = 22;
      }
      while((_Bool)0);
      return -1;
    }

    else
    {
      void *return_value_mem_alloc$3;
      return_value_mem_alloc$3=mem_alloc(sizeof(struct estream_cookie_mem) /*80ul*/ );
      mem_cookie = (struct estream_cookie_mem *)return_value_mem_alloc$3;
      if(mem_cookie == ((struct estream_cookie_mem *)NULL))
        err = -1;

      else
      {
        mem_cookie->modeflags = modeflags;
        mem_cookie->memory = data;
        mem_cookie->memory_size = data_n;
        mem_cookie->memory_limit = memory_limit;
        mem_cookie->offset = (unsigned long int)0;
        mem_cookie->data_len = data_len;
        mem_cookie->block_size = block_size;
        mem_cookie->flags.grow = (unsigned int)!(!(grow != 0u));
        mem_cookie->func_realloc = grow != 0u ? (func_realloc != ((void * (*)(void *, unsigned long int))NULL) ? func_realloc : mem_realloc) : (void * (*)(void *, unsigned long int))(void *)0;
        mem_cookie->func_free = func_free != ((void (*)(void *))NULL) ? func_free : mem_free;
        *cookie = (void *)mem_cookie;
        err = 0;
      }
      return err;
    }
}

// get_lock_object
// file ../../src/posix-lock.c line 108
static struct anonymous$10 * get_lock_object(struct anonymous$5 *lockhd)
{
  struct anonymous$10 *lock = (struct anonymous$10 *)lockhd;
  if(!(lock->vers == 1l))
  {
    /* assertion !"lock ABI version" */
    assert(!((_Bool)"lock ABI version"));
    abort();
  }

  return lock;
}

// get_rand
// file ../../tests/t-lock.c line 111
static unsigned int get_rand(signed int high)
{
  signed int return_value_rand$1;
  return_value_rand$1=rand();
  return (unsigned int)(1 + (signed int)(((double)(high + 1) * (double)return_value_rand$1) / ((double)2147483647 + 1.0))) - (unsigned int)1;
}

// gpg_err_code
// file ./gpg-error.h line 849
static inline enum anonymous$4 gpg_err_code(unsigned int err)
{
  return (enum anonymous$4)(err & (unsigned int)(GPG_ERR_CODE_DIM - 1));
}

// gpg_err_code_from_errno
// file ./gpg-error.h line 889
enum anonymous$4 gpg_err_code_from_errno(signed int err)
{
  enum anonymous$4 return_value__gpg_err_code_from_errno$1;
  return_value__gpg_err_code_from_errno$1=_gpg_err_code_from_errno(err);
  return return_value__gpg_err_code_from_errno$1;
}

// gpg_err_code_from_syserror
// file ../../src/visibility.c line 57
enum anonymous$4 gpg_err_code_from_syserror(void)
{
  enum anonymous$4 return_value__gpg_err_code_from_syserror$1;
  return_value__gpg_err_code_from_syserror$1=_gpg_err_code_from_syserror();
  return return_value__gpg_err_code_from_syserror$1;
}

// gpg_err_code_to_errno
// file ./gpg-error.h line 894
signed int gpg_err_code_to_errno(enum anonymous$4 code)
{
  signed int return_value__gpg_err_code_to_errno$1;
  return_value__gpg_err_code_to_errno$1=_gpg_err_code_to_errno(code);
  return return_value__gpg_err_code_to_errno$1;
}

// gpg_err_deinit
// file ../../src/visibility.c line 76
void gpg_err_deinit(signed int mode)
{
  _gpg_err_deinit(mode);
}

// gpg_err_init
// file ../../src/visibility.c line 70
unsigned int gpg_err_init(void)
{
  unsigned int return_value__gpg_err_init$1;
  return_value__gpg_err_init$1=_gpg_err_init();
  return return_value__gpg_err_init$1;
}

// gpg_err_set_errno
// file ../../src/visibility.c line 63
void gpg_err_set_errno(signed int err)
{
  _gpg_err_set_errno(err);
}

// gpg_err_source
// file ./gpg-error.h line 857
static inline enum anonymous$2 gpg_err_source(unsigned int err)
{
  return (enum anonymous$2)(err >> 24 & (unsigned int)(GPG_ERR_SOURCE_DIM - 1));
}

// gpg_error_check_version
// file ./../src/gpg-error.h line 909
const char * gpg_error_check_version(const char *req_version)
{
  const char *return_value__gpg_error_check_version$1;
  return_value__gpg_error_check_version$1=_gpg_error_check_version(req_version);
  return return_value__gpg_error_check_version$1;
}

// gpg_strerror
// file ./../src/gpg-error.h line 868
const char * gpg_strerror(unsigned int err)
{
  const char *return_value__gpg_strerror$1;
  return_value__gpg_strerror$1=_gpg_strerror(err);
  return return_value__gpg_strerror$1;
}

// gpg_strerror_r
// file ../../src/visibility.c line 33
signed int gpg_strerror_r(unsigned int err, char *buf, unsigned long int buflen)
{
  signed int return_value__gpg_strerror_r$1;
  return_value__gpg_strerror_r$1=_gpg_strerror_r(err, buf, buflen);
  return return_value__gpg_strerror_r$1;
}

// gpg_strsource
// file ../../src/visibility.c line 39
const char * gpg_strsource(unsigned int err)
{
  const char *return_value__gpg_strsource$1;
  return_value__gpg_strsource$1=_gpg_strsource(err);
  return return_value__gpg_strsource$1;
}

// gpgrt_asprintf
// file ../../src/visibility.c line 644
signed int gpgrt_asprintf(char **r_buf, const char * restrict format, ...)
{
  void **ap;
  signed int rc;
  ap = (void **)&format;
  rc=_gpgrt_estream_vasprintf(r_buf, format, ap);
  ap = ((void **)NULL);
  return rc;
}

// gpgrt_bsprintf
// file ../../src/visibility.c line 663
char * gpgrt_bsprintf(const char * restrict format, ...)
{
  signed int rc;
  void **ap;
  char *buf;
  ap = (void **)&format;
  rc=_gpgrt_estream_vasprintf(&buf, format, ap);
  ap = ((void **)NULL);
  if(!(rc >= 0))
    return (char *)(void *)0;

  else
    return buf;
}

// gpgrt_check_version
// file ../../src/visibility.c line 88
const char * gpgrt_check_version(const char *req_version)
{
  const char *return_value__gpg_error_check_version$1;
  return_value__gpg_error_check_version$1=_gpg_error_check_version(req_version);
  return return_value__gpg_error_check_version$1;
}

// gpgrt_clearerr
// file ../../src/visibility.c line 337
void gpgrt_clearerr(struct _gpgrt__stream *stream)
{
  _gpgrt_clearerr(stream);
}

// gpgrt_clearerr_unlocked
// file ../../src/visibility.c line 343
void gpgrt_clearerr_unlocked(struct _gpgrt__stream *stream)
{
  _gpgrt_clearerr_unlocked(stream);
}

// gpgrt_fclose
// file ../../src/visibility.c line 228
signed int gpgrt_fclose(struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt_fclose$1;
  return_value__gpgrt_fclose$1=_gpgrt_fclose(stream);
  return return_value__gpgrt_fclose$1;
}

// gpgrt_fclose_snatch
// file ../../src/visibility.c line 234
signed int gpgrt_fclose_snatch(struct _gpgrt__stream *stream, void **r_buffer, unsigned long int *r_buflen)
{
  signed int return_value__gpgrt_fclose_snatch$1;
  return_value__gpgrt_fclose_snatch$1=_gpgrt_fclose_snatch(stream, r_buffer, r_buflen);
  return return_value__gpgrt_fclose_snatch$1;
}

// gpgrt_fdopen
// file ../../src/visibility.c line 176
struct _gpgrt__stream * gpgrt_fdopen(signed int filedes, const char *mode)
{
  struct _gpgrt__stream *return_value__gpgrt_fdopen$1;
  return_value__gpgrt_fdopen$1=_gpgrt_fdopen(filedes, mode);
  return return_value__gpgrt_fdopen$1;
}

// gpgrt_fdopen_nc
// file ../../src/visibility.c line 182
struct _gpgrt__stream * gpgrt_fdopen_nc(signed int filedes, const char *mode)
{
  struct _gpgrt__stream *return_value__gpgrt_fdopen_nc$1;
  return_value__gpgrt_fdopen_nc$1=_gpgrt_fdopen_nc(filedes, mode);
  return return_value__gpgrt_fdopen_nc$1;
}

// gpgrt_feof
// file ../../src/visibility.c line 313
signed int gpgrt_feof(struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt_feof$1;
  return_value__gpgrt_feof$1=_gpgrt_feof(stream);
  return return_value__gpgrt_feof$1;
}

// gpgrt_feof_unlocked
// file ../../src/visibility.c line 319
signed int gpgrt_feof_unlocked(struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt_feof_unlocked$1;
  return_value__gpgrt_feof_unlocked$1=_gpgrt_feof_unlocked(stream);
  return return_value__gpgrt_feof_unlocked$1;
}

// gpgrt_ferror
// file ../../src/visibility.c line 325
signed int gpgrt_ferror(struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt_ferror$1;
  return_value__gpgrt_ferror$1=_gpgrt_ferror(stream);
  return return_value__gpgrt_ferror$1;
}

// gpgrt_ferror_unlocked
// file ../../src/visibility.c line 331
signed int gpgrt_ferror_unlocked(struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt_ferror_unlocked$1;
  return_value__gpgrt_ferror_unlocked$1=_gpgrt_ferror_unlocked(stream);
  return return_value__gpgrt_ferror_unlocked$1;
}

// gpgrt_fflush
// file ../../src/visibility.c line 349
signed int gpgrt_fflush(struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt_fflush$1;
  return_value__gpgrt_fflush$1=_gpgrt_fflush(stream);
  return return_value__gpgrt_fflush$1;
}

// gpgrt_fgetc
// file ../../src/visibility.c line 385
signed int gpgrt_fgetc(struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt_fgetc$1;
  return_value__gpgrt_fgetc$1=_gpgrt_fgetc(stream);
  return return_value__gpgrt_fgetc$1;
}

// gpgrt_fgets
// file ../../src/visibility.c line 464
char * gpgrt_fgets(char * restrict buffer, signed int length, struct _gpgrt__stream * restrict stream)
{
  char *return_value__gpgrt_fgets$1;
  return_value__gpgrt_fgets$1=_gpgrt_fgets(buffer, length, stream);
  return return_value__gpgrt_fgets$1;
}

// gpgrt_fileno
// file ../../src/visibility.c line 247
signed int gpgrt_fileno(struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt_fileno$1;
  return_value__gpgrt_fileno$1=_gpgrt_fileno(stream);
  return return_value__gpgrt_fileno$1;
}

// gpgrt_fileno_unlocked
// file ../../src/visibility.c line 253
signed int gpgrt_fileno_unlocked(struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt_fileno_unlocked$1;
  return_value__gpgrt_fileno_unlocked$1=_gpgrt_fileno_unlocked(stream);
  return return_value__gpgrt_fileno_unlocked$1;
}

// gpgrt_flockfile
// file ../../src/visibility.c line 283
void gpgrt_flockfile(struct _gpgrt__stream *stream)
{
  _gpgrt_flockfile(stream);
}

// gpgrt_fname_get
// file ../../src/visibility.c line 638
const char * gpgrt_fname_get(struct _gpgrt__stream *stream)
{
  const char *return_value__gpgrt_fname_get$1;
  return_value__gpgrt_fname_get$1=_gpgrt_fname_get(stream);
  return return_value__gpgrt_fname_get$1;
}

// gpgrt_fname_set
// file ../../src/visibility.c line 632
void gpgrt_fname_set(struct _gpgrt__stream *stream, const char *fname)
{
  _gpgrt_fname_set(stream, fname);
}

// gpgrt_fopen
// file ../../src/visibility.c line 145
struct _gpgrt__stream * gpgrt_fopen(const char * restrict path, const char * restrict mode)
{
  struct _gpgrt__stream *return_value__gpgrt_fopen$1;
  return_value__gpgrt_fopen$1=_gpgrt_fopen(path, mode);
  return return_value__gpgrt_fopen$1;
}

// gpgrt_fopencookie
// file ../../src/visibility.c line 220
struct _gpgrt__stream * gpgrt_fopencookie(void * restrict cookie, const char * restrict mode, struct _gpgrt_cookie_io_functions functions)
{
  struct _gpgrt__stream *return_value__gpgrt_fopencookie$1;
  return_value__gpgrt_fopencookie$1=_gpgrt_fopencookie(cookie, mode, functions);
  return return_value__gpgrt_fopencookie$1;
}

// gpgrt_fopenmem
// file ../../src/visibility.c line 163
struct _gpgrt__stream * gpgrt_fopenmem(unsigned long int memlimit, const char * restrict mode)
{
  struct _gpgrt__stream *return_value__gpgrt_fopenmem$1;
  return_value__gpgrt_fopenmem$1=_gpgrt_fopenmem(memlimit, mode);
  return return_value__gpgrt_fopenmem$1;
}

// gpgrt_fopenmem_init
// file ../../src/visibility.c line 169
struct _gpgrt__stream * gpgrt_fopenmem_init(unsigned long int memlimit, const char * restrict mode, const void *data, unsigned long int datalen)
{
  struct _gpgrt__stream *return_value__gpgrt_fopenmem_init$1;
  return_value__gpgrt_fopenmem_init$1=_gpgrt_fopenmem_init(memlimit, mode, data, datalen);
  return return_value__gpgrt_fopenmem_init$1;
}

// gpgrt_fpopen
// file ../../src/visibility.c line 200
struct _gpgrt__stream * gpgrt_fpopen(struct _IO_FILE *fp, const char *mode)
{
  struct _gpgrt__stream *return_value__gpgrt_fpopen$1;
  return_value__gpgrt_fpopen$1=_gpgrt_fpopen(fp, mode);
  return return_value__gpgrt_fpopen$1;
}

// gpgrt_fpopen_nc
// file ../../src/visibility.c line 206
struct _gpgrt__stream * gpgrt_fpopen_nc(struct _IO_FILE *fp, const char *mode)
{
  struct _gpgrt__stream *return_value__gpgrt_fpopen_nc$1;
  return_value__gpgrt_fpopen_nc$1=_gpgrt_fpopen_nc(fp, mode);
  return return_value__gpgrt_fpopen_nc$1;
}

// gpgrt_fprintf
// file ../../src/visibility.c line 549
signed int gpgrt_fprintf(struct _gpgrt__stream * restrict stream, const char * restrict format, ...)
{
  void **ap;
  signed int rc;
  ap = (void **)&format;
  rc=_gpgrt_vfprintf(stream, format, ap);
  ap = ((void **)NULL);
  return rc;
}

// gpgrt_fprintf_unlocked
// file ../../src/visibility.c line 563
signed int gpgrt_fprintf_unlocked(struct _gpgrt__stream * restrict stream, const char * restrict format, ...)
{
  void **ap;
  signed int rc;
  ap = (void **)&format;
  rc=_gpgrt_vfprintf_unlocked(stream, format, ap);
  ap = ((void **)NULL);
  return rc;
}

// gpgrt_fputc
// file ../../src/visibility.c line 397
signed int gpgrt_fputc(signed int c, struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt_fputc$1;
  return_value__gpgrt_fputc$1=_gpgrt_fputc(c, stream);
  return return_value__gpgrt_fputc$1;
}

// gpgrt_fputs
// file ../../src/visibility.c line 471
signed int gpgrt_fputs(const char * restrict s, struct _gpgrt__stream * restrict stream)
{
  signed int return_value__gpgrt_fputs$1;
  return_value__gpgrt_fputs$1=_gpgrt_fputs(s, stream);
  return return_value__gpgrt_fputs$1;
}

// gpgrt_fputs_unlocked
// file ../../src/visibility.c line 477
signed int gpgrt_fputs_unlocked(const char * restrict s, struct _gpgrt__stream * restrict stream)
{
  signed int return_value__gpgrt_fputs_unlocked$1;
  return_value__gpgrt_fputs_unlocked$1=_gpgrt_fputs_unlocked(s, stream);
  return return_value__gpgrt_fputs_unlocked$1;
}

// gpgrt_fread
// file ../../src/visibility.c line 450
unsigned long int gpgrt_fread(void * restrict ptr, unsigned long int size, unsigned long int nitems, struct _gpgrt__stream * restrict stream)
{
  unsigned long int return_value__gpgrt_fread$1;
  return_value__gpgrt_fread$1=_gpgrt_fread(ptr, size, nitems, stream);
  return return_value__gpgrt_fread$1;
}

// gpgrt_free
// file ../../src/visibility.c line 500
void gpgrt_free(void *a)
{
  if(!(a == NULL))
    _gpgrt_free(a);

}

// gpgrt_freopen
// file ../../src/visibility.c line 212
struct _gpgrt__stream * gpgrt_freopen(const char * restrict path, const char * restrict mode, struct _gpgrt__stream * restrict stream)
{
  struct _gpgrt__stream *return_value__gpgrt_freopen$1;
  return_value__gpgrt_freopen$1=_gpgrt_freopen(path, mode, stream);
  return return_value__gpgrt_freopen$1;
}

// gpgrt_fseek
// file ../../src/visibility.c line 355
signed int gpgrt_fseek(struct _gpgrt__stream *stream, signed long int offset, signed int whence)
{
  signed int return_value__gpgrt_fseek$1;
  return_value__gpgrt_fseek$1=_gpgrt_fseek(stream, offset, whence);
  return return_value__gpgrt_fseek$1;
}

// gpgrt_fseeko
// file ../../src/visibility.c line 361
signed int gpgrt_fseeko(struct _gpgrt__stream *stream, signed long int offset, signed int whence)
{
  signed int return_value__gpgrt_fseeko$1;
  return_value__gpgrt_fseeko$1=_gpgrt_fseeko(stream, offset, whence);
  return return_value__gpgrt_fseeko$1;
}

// gpgrt_ftell
// file ../../src/visibility.c line 367
signed long int gpgrt_ftell(struct _gpgrt__stream *stream)
{
  signed long int return_value__gpgrt_ftell$1;
  return_value__gpgrt_ftell$1=_gpgrt_ftell(stream);
  return return_value__gpgrt_ftell$1;
}

// gpgrt_ftello
// file ../../src/visibility.c line 373
signed long int gpgrt_ftello(struct _gpgrt__stream *stream)
{
  signed long int return_value__gpgrt_ftello$1;
  return_value__gpgrt_ftello$1=_gpgrt_ftello(stream);
  return return_value__gpgrt_ftello$1;
}

// gpgrt_ftrylockfile
// file ../../src/visibility.c line 289
signed int gpgrt_ftrylockfile(struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt_ftrylockfile$1;
  return_value__gpgrt_ftrylockfile$1=_gpgrt_ftrylockfile(stream);
  return return_value__gpgrt_ftrylockfile$1;
}

// gpgrt_funlockfile
// file ../../src/visibility.c line 295
void gpgrt_funlockfile(struct _gpgrt__stream *stream)
{
  _gpgrt_funlockfile(stream);
}

// gpgrt_fwrite
// file ../../src/visibility.c line 457
unsigned long int gpgrt_fwrite(const void * restrict ptr, unsigned long int size, unsigned long int nitems, struct _gpgrt__stream * restrict stream)
{
  unsigned long int return_value__gpgrt_fwrite$1;
  return_value__gpgrt_fwrite$1=_gpgrt_fwrite(ptr, size, nitems, stream);
  return return_value__gpgrt_fwrite$1;
}

// gpgrt_get_nonblock
// file ../../src/visibility.c line 602
signed int gpgrt_get_nonblock(struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt_get_nonblock$1;
  return_value__gpgrt_get_nonblock$1=_gpgrt_get_nonblock(stream);
  return return_value__gpgrt_get_nonblock$1;
}

// gpgrt_getline
// file ../../src/visibility.c line 484
signed long int gpgrt_getline(char * restrict * restrict lineptr, unsigned long int * restrict n, struct _gpgrt__stream * restrict stream)
{
  signed long int return_value__gpgrt_getline$1;
  return_value__gpgrt_getline$1=_gpgrt_getline(lineptr, n, stream);
  return return_value__gpgrt_getline$1;
}

// gpgrt_lock_destroy
// file ./../src/gpg-error.h line 972
enum anonymous$4 gpgrt_lock_destroy(struct anonymous$5 *lockhd)
{
  enum anonymous$4 return_value__gpgrt_lock_destroy$1;
  return_value__gpgrt_lock_destroy$1=_gpgrt_lock_destroy(lockhd);
  return return_value__gpgrt_lock_destroy$1;
}

// gpgrt_lock_init
// file ./../src/gpg-error.h line 968
enum anonymous$4 gpgrt_lock_init(struct anonymous$5 *lockhd)
{
  enum anonymous$4 return_value__gpgrt_lock_init$1;
  return_value__gpgrt_lock_init$1=_gpgrt_lock_init(lockhd);
  return return_value__gpgrt_lock_init$1;
}

// gpgrt_lock_lock
// file ./../src/gpg-error.h line 969
enum anonymous$4 gpgrt_lock_lock(struct anonymous$5 *lockhd)
{
  enum anonymous$4 return_value__gpgrt_lock_lock$1;
  return_value__gpgrt_lock_lock$1=_gpgrt_lock_lock(lockhd);
  return return_value__gpgrt_lock_lock$1;
}

// gpgrt_lock_trylock
// file ../../src/visibility.c line 119
enum anonymous$4 gpgrt_lock_trylock(struct anonymous$5 *lockhd)
{
  enum anonymous$4 return_value__gpgrt_lock_trylock$1;
  return_value__gpgrt_lock_trylock$1=_gpgrt_lock_trylock(lockhd);
  return return_value__gpgrt_lock_trylock$1;
}

// gpgrt_lock_unlock
// file ./../src/gpg-error.h line 971
enum anonymous$4 gpgrt_lock_unlock(struct anonymous$5 *lockhd)
{
  enum anonymous$4 return_value__gpgrt_lock_unlock$1;
  return_value__gpgrt_lock_unlock$1=_gpgrt_lock_unlock(lockhd);
  return return_value__gpgrt_lock_unlock$1;
}

// gpgrt_mopen
// file ../../src/visibility.c line 152
struct _gpgrt__stream * gpgrt_mopen(void * restrict data, unsigned long int data_n, unsigned long int data_len, unsigned int grow, void * (*func_realloc)(void *, unsigned long int), void (*func_free)(void *), const char * restrict mode)
{
  struct _gpgrt__stream *return_value__gpgrt_mopen$1;
  return_value__gpgrt_mopen$1=_gpgrt_mopen(data, data_n, data_len, grow, func_realloc, func_free, mode);
  return return_value__gpgrt_mopen$1;
}

// gpgrt_onclose
// file ../../src/visibility.c line 240
signed int gpgrt_onclose(struct _gpgrt__stream *stream, signed int mode, void (*fnc)(struct _gpgrt__stream *, void *), void *fnc_value)
{
  signed int return_value__gpgrt_onclose$1;
  return_value__gpgrt_onclose$1=_gpgrt_onclose(stream, mode, fnc, fnc_value);
  return return_value__gpgrt_onclose$1;
}

// gpgrt_opaque_get
// file ../../src/visibility.c line 626
void * gpgrt_opaque_get(struct _gpgrt__stream *stream)
{
  void *return_value__gpgrt_opaque_get$1;
  return_value__gpgrt_opaque_get$1=_gpgrt_opaque_get(stream);
  return return_value__gpgrt_opaque_get$1;
}

// gpgrt_opaque_set
// file ../../src/visibility.c line 620
void gpgrt_opaque_set(struct _gpgrt__stream *stream, void *opaque)
{
  _gpgrt_opaque_set(stream, opaque);
}

// gpgrt_poll
// file ../../src/visibility.c line 608
signed int gpgrt_poll(struct _gpgrt_poll_s *fds, unsigned int nfds, signed int timeout)
{
  signed int return_value__gpgrt_poll$1;
  return_value__gpgrt_poll$1=_gpgrt_poll(fds, nfds, timeout);
  return return_value__gpgrt_poll$1;
}

// gpgrt_printf
// file ../../src/visibility.c line 523
signed int gpgrt_printf(const char * restrict format, ...)
{
  void **ap;
  signed int rc;
  ap = (void **)&format;
  struct _gpgrt__stream *return_value__gpgrt_get_std_stream$1;
  return_value__gpgrt_get_std_stream$1=_gpgrt_get_std_stream(1);
  rc=_gpgrt_vfprintf(return_value__gpgrt_get_std_stream$1, format, ap);
  ap = ((void **)NULL);
  return rc;
}

// gpgrt_printf_unlocked
// file ../../src/visibility.c line 536
signed int gpgrt_printf_unlocked(const char * restrict format, ...)
{
  void **ap;
  signed int rc;
  ap = (void **)&format;
  struct _gpgrt__stream *return_value__gpgrt_get_std_stream$1;
  return_value__gpgrt_get_std_stream$1=_gpgrt_get_std_stream(1);
  rc=_gpgrt_vfprintf_unlocked(return_value__gpgrt_get_std_stream$1, format, ap);
  ap = ((void **)NULL);
  return rc;
}

// gpgrt_read
// file ../../src/visibility.c line 415
signed int gpgrt_read(struct _gpgrt__stream * restrict stream, void * restrict buffer, unsigned long int bytes_to_read, unsigned long int * restrict bytes_read)
{
  signed int return_value__gpgrt_read$1;
  return_value__gpgrt_read$1=_gpgrt_read(stream, buffer, bytes_to_read, bytes_read);
  return return_value__gpgrt_read$1;
}

// gpgrt_read_line
// file ../../src/visibility.c line 491
signed long int gpgrt_read_line(struct _gpgrt__stream *stream, char **addr_of_buffer, unsigned long int *length_of_buffer, unsigned long int *max_length)
{
  signed long int return_value__gpgrt_read_line$1;
  return_value__gpgrt_read_line$1=_gpgrt_read_line(stream, addr_of_buffer, length_of_buffer, max_length);
  return return_value__gpgrt_read_line$1;
}

// gpgrt_rewind
// file ../../src/visibility.c line 379
void gpgrt_rewind(struct _gpgrt__stream *stream)
{
  _gpgrt_rewind(stream);
}

// gpgrt_set_alloc_func
// file ../../src/visibility.c line 100
void gpgrt_set_alloc_func(void * (*f)(void *, unsigned long int))
{
  _gpgrt_set_alloc_func(f);
}

// gpgrt_set_binary
// file ../../src/visibility.c line 590
void gpgrt_set_binary(struct _gpgrt__stream *stream)
{
  _gpgrt_set_binary(stream);
}

// gpgrt_set_nonblock
// file ../../src/visibility.c line 596
signed int gpgrt_set_nonblock(struct _gpgrt__stream *stream, signed int onoff)
{
  signed int return_value__gpgrt_set_nonblock$1;
  return_value__gpgrt_set_nonblock$1=_gpgrt_set_nonblock(stream, onoff);
  return return_value__gpgrt_set_nonblock$1;
}

// gpgrt_set_syscall_clamp
// file ../../src/visibility.c line 94
void gpgrt_set_syscall_clamp(void (*pre)(void), void (*post)(void))
{
  _gpgrt_set_syscall_clamp(pre, post);
}

// gpgrt_setbuf
// file ../../src/visibility.c line 584
void gpgrt_setbuf(struct _gpgrt__stream * restrict stream, char * restrict buf)
{
  _gpgrt_setvbuf(stream, buf, buf != ((char *)NULL) ? 0 : 2, (unsigned long int)8192);
}

// gpgrt_setvbuf
// file ../../src/visibility.c line 577
signed int gpgrt_setvbuf(struct _gpgrt__stream * restrict stream, char * restrict buf, signed int type, unsigned long int size)
{
  signed int return_value__gpgrt_setvbuf$1;
  return_value__gpgrt_setvbuf$1=_gpgrt_setvbuf(stream, buf, type, size);
  return return_value__gpgrt_setvbuf$1;
}

// gpgrt_snprintf
// file ../../src/visibility.c line 690
signed int gpgrt_snprintf(char *buf, unsigned long int bufsize, const char *format, ...)
{
  signed int rc;
  void **arg_ptr = (void **)&format;
  rc=_gpgrt_estream_vsnprintf(buf, bufsize, format, arg_ptr);
  arg_ptr = ((void **)NULL);
  return rc;
}

// gpgrt_syshd
// file ../../src/visibility.c line 259
signed int gpgrt_syshd(struct _gpgrt__stream *stream, struct _gpgrt_syshd *syshd)
{
  signed int return_value__gpgrt_syshd$1;
  return_value__gpgrt_syshd$1=_gpgrt_syshd(stream, syshd);
  return return_value__gpgrt_syshd$1;
}

// gpgrt_syshd_unlocked
// file ../../src/visibility.c line 265
signed int gpgrt_syshd_unlocked(struct _gpgrt__stream *stream, struct _gpgrt_syshd *syshd)
{
  signed int return_value__gpgrt_syshd_unlocked$1;
  return_value__gpgrt_syshd_unlocked$1=_gpgrt_syshd_unlocked(stream, syshd);
  return return_value__gpgrt_syshd_unlocked$1;
}

// gpgrt_sysopen
// file ../../src/visibility.c line 188
struct _gpgrt__stream * gpgrt_sysopen(struct _gpgrt_syshd *syshd, const char *mode)
{
  struct _gpgrt__stream *return_value__gpgrt_sysopen$1;
  return_value__gpgrt_sysopen$1=_gpgrt_sysopen(syshd, mode);
  return return_value__gpgrt_sysopen$1;
}

// gpgrt_sysopen_nc
// file ../../src/visibility.c line 194
struct _gpgrt__stream * gpgrt_sysopen_nc(struct _gpgrt_syshd *syshd, const char *mode)
{
  struct _gpgrt__stream *return_value__gpgrt_sysopen_nc$1;
  return_value__gpgrt_sysopen_nc$1=_gpgrt_sysopen_nc(syshd, mode);
  return return_value__gpgrt_sysopen_nc$1;
}

// gpgrt_tmpfile
// file ../../src/visibility.c line 614
struct _gpgrt__stream * gpgrt_tmpfile(void)
{
  struct _gpgrt__stream *return_value__gpgrt_tmpfile$1;
  return_value__gpgrt_tmpfile$1=_gpgrt_tmpfile();
  return return_value__gpgrt_tmpfile$1;
}

// gpgrt_ungetc
// file ../../src/visibility.c line 409
signed int gpgrt_ungetc(signed int c, struct _gpgrt__stream *stream)
{
  signed int return_value__gpgrt_ungetc$1;
  return_value__gpgrt_ungetc$1=_gpgrt_ungetc(c, stream);
  return return_value__gpgrt_ungetc$1;
}

// gpgrt_vasprintf
// file ../../src/visibility.c line 657
signed int gpgrt_vasprintf(char **r_buf, const char * restrict format, void **ap)
{
  signed int return_value__gpgrt_estream_vasprintf$1;
  return_value__gpgrt_estream_vasprintf$1=_gpgrt_estream_vasprintf(r_buf, format, ap);
  return return_value__gpgrt_estream_vasprintf$1;
}

// gpgrt_vbsprintf
// file ../../src/visibility.c line 678
char * gpgrt_vbsprintf(const char * restrict format, void **ap)
{
  signed int rc;
  char *buf;
  rc=_gpgrt_estream_vasprintf(&buf, format, ap);
  if(!(rc >= 0))
    return (char *)(void *)0;

  else
    return buf;
}

// gpgrt_vfprintf
// file ../../src/visibility.c line 507
signed int gpgrt_vfprintf(struct _gpgrt__stream * restrict stream, const char * restrict format, void **ap)
{
  signed int return_value__gpgrt_vfprintf$1;
  return_value__gpgrt_vfprintf$1=_gpgrt_vfprintf(stream, format, ap);
  return return_value__gpgrt_vfprintf$1;
}

// gpgrt_vfprintf_unlocked
// file ../../src/visibility.c line 515
signed int gpgrt_vfprintf_unlocked(struct _gpgrt__stream * restrict stream, const char * restrict format, void **ap)
{
  signed int return_value__gpgrt_vfprintf_unlocked$1;
  return_value__gpgrt_vfprintf_unlocked$1=_gpgrt_vfprintf_unlocked(stream, format, ap);
  return return_value__gpgrt_vfprintf_unlocked$1;
}

// gpgrt_vsnprintf
// file ../../src/visibility.c line 703
signed int gpgrt_vsnprintf(char *buf, unsigned long int bufsize, const char *format, void **arg_ptr)
{
  signed int return_value__gpgrt_estream_vsnprintf$1;
  return_value__gpgrt_estream_vsnprintf$1=_gpgrt_estream_vsnprintf(buf, bufsize, format, arg_ptr);
  return return_value__gpgrt_estream_vsnprintf$1;
}

// gpgrt_write
// file ../../src/visibility.c line 423
signed int gpgrt_write(struct _gpgrt__stream * restrict stream, const void * restrict buffer, unsigned long int bytes_to_write, unsigned long int * restrict bytes_written)
{
  signed int return_value__gpgrt_write$1;
  return_value__gpgrt_write$1=_gpgrt_write(stream, buffer, bytes_to_write, bytes_written);
  return return_value__gpgrt_write$1;
}

// gpgrt_write_hexstring
// file ../../src/visibility.c line 441
signed int gpgrt_write_hexstring(struct _gpgrt__stream * restrict stream, const void * restrict buffer, unsigned long int length, signed int reserved, unsigned long int * restrict bytes_written)
{
  signed int return_value__gpgrt_write_hexstring$1;
  return_value__gpgrt_write_hexstring$1=_gpgrt_write_hexstring(stream, buffer, length, reserved, bytes_written);
  return return_value__gpgrt_write_hexstring$1;
}

// gpgrt_write_sanitized
// file ../../src/visibility.c line 431
signed int gpgrt_write_sanitized(struct _gpgrt__stream * restrict stream, const void * restrict buffer, unsigned long int length, const char *delimiters, unsigned long int * restrict bytes_written)
{
  signed int return_value__gpgrt_write_sanitized$1;
  return_value__gpgrt_write_sanitized$1=_gpgrt_write_sanitized(stream, buffer, length, delimiters, bytes_written);
  return return_value__gpgrt_write_sanitized$1;
}

// gpgrt_yield
// file ./../src/gpg-error.h line 978
enum anonymous$4 gpgrt_yield(void)
{
  enum anonymous$4 return_value__gpgrt_yield$1;
  return_value__gpgrt_yield$1=_gpgrt_yield();
  return return_value__gpgrt_yield$1;
}

// init_accounts
// file ../../tests/t-lock.c line 75
static void init_accounts(void)
{
  signed int i = 0;
  for( ; !(i >= 8); i = i + 1)
    account[(signed long int)i] = 42;
}

// init_stream_lock
// file ../../src/estream.c line 347
static signed int init_stream_lock(struct _gpgrt__stream * restrict stream)
{
  signed int rc;
  if(stream->intern->samethread == 0u)
  {
    memset((void *)&stream->intern->lock, 0, sizeof(struct anonymous$5) /*48ul*/ );
    enum anonymous$4 return_value__gpgrt_lock_init$1;
    return_value__gpgrt_lock_init$1=_gpgrt_lock_init(&stream->intern->lock);
    rc = (signed int)return_value__gpgrt_lock_init$1;
  }

  else
    rc = 0;
  return rc;
}

// init_stream_obj
// file ../../src/estream.c line 1834
static void init_stream_obj(struct _gpgrt__stream *stream, void *cookie, struct _gpgrt_syshd *syshd, struct _gpgrt_cookie_io_functions functions, unsigned int modeflags, signed int samethread)
{
  stream->intern->cookie = cookie;
  stream->intern->opaque = (void *)0;
  stream->intern->offset = (signed long int)0;
  stream->intern->func_read = functions.func_read;
  stream->intern->func_write = functions.func_write;
  stream->intern->func_seek = functions.func_seek;
  stream->intern->func_ioctl = (signed int (*)(void *, signed int, void *, unsigned long int *))(void *)0;
  stream->intern->func_close = functions.func_close;
  stream->intern->strategy = 0;
  stream->intern->syshd = *syshd;
  stream->intern->print_ntotal = (unsigned long int)0;
  stream->intern->indicators.err = (unsigned int)0;
  stream->intern->indicators.eof = (unsigned int)0;
  stream->intern->indicators.hup = (unsigned int)0;
  stream->intern->is_stdstream = (unsigned int)0;
  stream->intern->stdstream_fd = (unsigned int)0;
  stream->intern->deallocate_buffer = (unsigned int)0;
  stream->intern->printable_fname = (char *)(void *)0;
  stream->intern->printable_fname_inuse = (unsigned int)0;
  stream->intern->samethread = (unsigned int)!(!(samethread != 0));
  stream->intern->onclose = (struct notify_list_s *)(void *)0;
  stream->data_len = (unsigned long int)0;
  stream->data_offset = (unsigned long int)0;
  stream->data_flushed = (unsigned long int)0;
  stream->unread_data_len = (unsigned long int)0;
  if(!((1u & modeflags) == 0u) || !((2u & modeflags) == 0u))
    stream->flags.writing = (unsigned int)1;

  else
    stream->flags.writing = (unsigned int)0;
}

// lock_list
// file ../../src/estream.c line 418
static void lock_list(void)
{
  _gpgrt_lock_lock(&estream_list_lock);
}

// lock_stream
// file ../../src/estream.c line 377
static void lock_stream(struct _gpgrt__stream * restrict stream)
{
  if(stream->intern->samethread == 0u)
    _gpgrt_lock_lock(&stream->intern->lock);

}

// main
// file ../../tests/t-lock.c line 271
signed int main(signed int argc, char **argv)
{
  signed int last_argc = -1;
  signed int rc;
  if(!(argc == 0))
  {
    argc = argc - 1;
    argv = argv + 1l;
  }

  signed int return_value_strcmp$2;
  while(!(last_argc == argc) && !(argc == 0))
  {
    last_argc = argc;
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(*argv, "--help");
    if(return_value_strcmp$1 == 0)
    {
      puts("usage: ./t-lock [options]\n\nOptions:\n  --verbose      Show what is going on\n  --debug        Flyswatter\n");
      exit(0);
    }

    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(*argv, "--verbose");
    if(return_value_strcmp$3 == 0)
    {
      verbose = 1;
      argc = argc - 1;
      argv = argv + 1l;
    }

    else
    {
      return_value_strcmp$2=strcmp(*argv, "--debug");
      if(return_value_strcmp$2 == 0)
      {
        debug = 1;
        verbose = debug;
        argc = argc - 1;
        argv = argv + 1l;
      }

    }
  }
  signed long int return_value_time$4;
  return_value_time$4=time((signed long int *)(void *)0);
  signed int return_value_getpid$5;
  return_value_getpid$5=getpid();
  srand((unsigned int)(return_value_time$4 * (signed long int)return_value_getpid$5));
  const char *return_value_gpg_error_check_version$6;
  return_value_gpg_error_check_version$6=gpg_error_check_version("1.21");
  if(return_value_gpg_error_check_version$6 == ((const char *)NULL))
  {
    die("gpg_error_check_version returned an error");
    errorcount = errorcount + 1;
  }

  init_accounts();
  check_accounts();
  run_test();
  check_accounts();
  run_test();
  check_accounts();
  enum anonymous$4 return_value_gpgrt_lock_init$7;
  return_value_gpgrt_lock_init$7=gpgrt_lock_init(&accounts_lock);
  rc = (signed int)return_value_gpgrt_lock_init$7;
  const char *return_value_gpg_strerror$8;
  if(!(rc == 0))
  {
    return_value_gpg_strerror$8=gpg_strerror((unsigned int)rc);
    fail("gpgrt_lock_init failed at %d: %s", 324, return_value_gpg_strerror$8);
  }

  run_test();
  check_accounts();
  if(!(verbose == 0))
    print_accounts();

  return errorcount != 0 ? 1 : 0;
}

// mem_alloc
// file ../../src/estream.c line 265
static void * mem_alloc(unsigned long int n)
{
  void *return_value__gpgrt_malloc$1;
  return_value__gpgrt_malloc$1=_gpgrt_malloc(n);
  return return_value__gpgrt_malloc$1;
}

// mem_free
// file ../../src/estream.c line 277
static void mem_free(void *p)
{
  if(!(p == NULL))
    _gpgrt_free(p);

}

// mem_realloc
// file ../../src/estream.c line 271
static void * mem_realloc(void *p, unsigned long int n)
{
  void *return_value__gpgrt_realloc$1;
  return_value__gpgrt_realloc$1=_gpgrt_realloc(p, n);
  return return_value__gpgrt_realloc$1;
}

// msgidxof
// file ../../src/err-sources.h line 80
static inline signed int msgidxof(signed int code)
{
  return 0 != 0 ? 0 : (code >= 0 && code <= 15 ? code - 0 : (code >= 17 && code <= 17 ? code - 1 : (code >= 31 && code <= 35 ? code - 14 : 36 - 14)));
}

// msgidxof$link1
// file ../../src/err-codes.h line 788
static inline signed int msgidxof$link1(signed int code$link1)
{
  return 0 != 0 ? 0 : (code$link1 >= 0 && code$link1 <= 213 ? code$link1 - 0 : (code$link1 >= 219 && code$link1 <= 271 ? code$link1 - 5 : (code$link1 >= 273 && code$link1 <= 281 ? code$link1 - 6 : (code$link1 >= 721 && code$link1 <= 729 ? code$link1 - 445 : (code$link1 >= 750 && code$link1 <= 752 ? code$link1 - 465 : (code$link1 >= 754 && code$link1 <= 782 ? code$link1 - 466 : (code$link1 >= 784 && code$link1 <= 789 ? code$link1 - 467 : (code$link1 >= 800 && code$link1 <= 804 ? code$link1 - 477 : (code$link1 >= 815 && code$link1 <= 822 ? code$link1 - 487 : (code$link1 >= 832 && code$link1 <= 839 ? code$link1 - 496 : (code$link1 >= 844 && code$link1 <= 844 ? code$link1 - 500 : (code$link1 >= 848 && code$link1 <= 848 ? code$link1 - 503 : (code$link1 >= 881 && code$link1 <= 891 ? code$link1 - 535 : (code$link1 >= 1024 && code$link1 <= 1039 ? code$link1 - 667 : (code$link1 >= 16381 && code$link1 <= 16383 ? code$link1 - 16008 : 16384 - 16008)))))))))))))));
}

// pad_out
// file ../../src/estream-printf.c line 823
static signed int pad_out(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, signed int padchar, signed int count, unsigned long int *nbytes)
{
  char buf[32l];
  unsigned long int n;
  signed int rc;
  if(count >= 1)
  {
    n = (unsigned long int)count <= sizeof(char [32l]) /*32ul*/  ? (unsigned long int)count : sizeof(char [32l]) /*32ul*/ ;
    memset((void *)buf, padchar, n);
    rc=outfnc(outfncarg, buf, n);
    if(!(rc == 0))
      return rc;

    *nbytes = *nbytes + n;
    count = count - (signed int)n;
  }

  return 0;
}

// parse_format
// file ../../src/estream-printf.c line 453
static signed int parse_format(const char *format, struct argspec_s **argspecs_addr, unsigned long int max_argspecs, unsigned long int *r_argspecs_count)
{
  const char *s;
  struct argspec_s *argspecs = *argspecs_addr;
  struct argspec_s *arg;
  unsigned long int argcount = (unsigned long int)0;
  const char *tmp_post$1;
  _Bool tmp_if_expr$2;
  const char *tmp_post$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$7;
  const char *tmp_post$5;
  _Bool tmp_if_expr$6;
  const char *tmp_post$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$12;
  const char *tmp_post$10;
  _Bool tmp_if_expr$11;
  if(!(format == ((const char *)NULL)))
  {
    for( ; !(*format == 0); format = format + 1l)
    {
      unsigned int flags;
      signed int width;
      signed int precision;
      enum anonymous$11 lenmod;
      enum anonymous$12 conspec;
      signed int arg_pos;
      signed int width_pos;
      signed int precision_pos;
      if((signed int)*format == 37)
      {
        format = format + 1l;
        s = format;
        if(*s == 0)
          goto leave_einval;

        if(!((signed int)*s == 37))
        {
          arg_pos = 0;
          if((signed int)*s >= 49)
          {
            if(!((signed int)*s >= 58))
            {
              const char *save_s = s;
              tmp_post$1 = s;
              s = s + 1l;
              arg_pos = (signed int)*tmp_post$1 - 48;
              do
              {
                if((signed int)*s >= 48)
                  tmp_if_expr$2 = (signed int)*s <= 57 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$2 = (_Bool)0;
                if(!tmp_if_expr$2)
                  break;

                arg_pos = 10 * arg_pos + ((signed int)*s - 48);
                s = s + 1l;
              }
              while((_Bool)1);
              if(!(arg_pos >= 0))
                goto leave_einval;

              if((signed int)*s == 36)
                s = s + 1l;

              else
              {
                arg_pos = 0;
                s = save_s;
              }
            }

          }

          flags = (unsigned int)0;
          for( ; !(*s == 0); s = s + 1l)
            switch((signed int)*s)
            {
              case 39:
              {
                flags = flags | (unsigned int)1;
                break;
              }
              case 45:
              {
                flags = flags | (unsigned int)2;
                break;
              }
              case 43:
              {
                flags = flags | (unsigned int)4;
                break;
              }
              case 32:
              {
                flags = flags | (unsigned int)8;
                break;
              }
              case 35:
              {
                flags = flags | (unsigned int)16;
                break;
              }
              case 48:
              {
                flags = flags | (unsigned int)32;
                break;
              }
              default:
                goto flags_parsed;
            }

        flags_parsed:
          ;
          width_pos = 0;
          if((signed int)*s == 42)
          {
            width = -2;
            s = s + 1l;
            if(!(arg_pos == 0))
            {
              if((signed int)*s >= 49)
              {
                if(!((signed int)*s >= 58))
                {
                  tmp_post$3 = s;
                  s = s + 1l;
                  width_pos = (signed int)*tmp_post$3 - 48;
                  do
                  {
                    if((signed int)*s >= 48)
                      tmp_if_expr$4 = (signed int)*s <= 57 ? (_Bool)1 : (_Bool)0;

                    else
                      tmp_if_expr$4 = (_Bool)0;
                    if(!tmp_if_expr$4)
                      break;

                    width_pos = 10 * width_pos + ((signed int)*s - 48);
                    s = s + 1l;
                  }
                  while((_Bool)1);
                  if(!(width_pos >= 1))
                    goto leave_einval;

                  if(!((signed int)*s == 36))
                    goto leave_einval;

                  s = s + 1l;
                }

              }

            }

          }

          else
          {
            if((signed int)*s >= 48)
              tmp_if_expr$7 = (signed int)*s <= 57 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$7 = (_Bool)0;
            if(tmp_if_expr$7)
            {
              tmp_post$5 = s;
              s = s + 1l;
              width = (signed int)*tmp_post$5 - 48;
              do
              {
                if((signed int)*s >= 48)
                  tmp_if_expr$6 = (signed int)*s <= 57 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$6 = (_Bool)0;
                if(!tmp_if_expr$6)
                  break;

                if(width == 0)
                {
                  if((signed int)*s == 48)
                    goto leave_einval;

                }

                width = 10 * width + ((signed int)*s - 48);
                s = s + 1l;
              }
              while((_Bool)1);
              if(!(width >= 0))
                goto leave_einval;

            }

            else
              width = -1;
          }
          precision_pos = 0;
          precision = -1;
          if((signed int)*s == 46)
          {
            signed int ignore_value = (signed int)((signed int)s[(signed long int)1] == 45);
            s = s + 1l;
            if((signed int)*s == 42)
            {
              precision = -2;
              s = s + 1l;
              if(!(arg_pos == 0))
              {
                if((signed int)*s >= 49)
                {
                  if(!((signed int)*s >= 58))
                  {
                    tmp_post$8 = s;
                    s = s + 1l;
                    precision_pos = (signed int)*tmp_post$8 - 48;
                    do
                    {
                      if((signed int)*s >= 48)
                        tmp_if_expr$9 = (signed int)*s <= 57 ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr$9 = (_Bool)0;
                      if(!tmp_if_expr$9)
                        break;

                      precision_pos = 10 * precision_pos + ((signed int)*s - 48);
                      s = s + 1l;
                    }
                    while((_Bool)1);
                    if(!(precision_pos >= 1))
                      goto leave_einval;

                    if(!((signed int)*s == 36))
                      goto leave_einval;

                    s = s + 1l;
                  }

                }

              }

            }

            else
            {
              if((signed int)*s >= 48)
                tmp_if_expr$12 = (signed int)*s <= 57 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$12 = (_Bool)0;
              if(tmp_if_expr$12)
              {
                tmp_post$10 = s;
                s = s + 1l;
                precision = (signed int)*tmp_post$10 - 48;
                do
                {
                  if((signed int)*s >= 48)
                    tmp_if_expr$11 = (signed int)*s <= 57 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$11 = (_Bool)0;
                  if(!tmp_if_expr$11)
                    break;

                  if(precision == 0)
                  {
                    if((signed int)*s == 48)
                      goto leave_einval;

                  }

                  precision = 10 * precision + ((signed int)*s - 48);
                  s = s + 1l;
                }
                while((_Bool)1);
                if(!(precision >= 0))
                  goto leave_einval;

              }

              else
                precision = 0;
            }
            if(!(ignore_value == 0))
              precision = -1;

          }

          switch((signed int)*s)
          {
            case 104:
            {
              if((signed int)s[1l] == 104)
              {
                lenmod = (enum anonymous$11)LENMOD_CHAR;
                s = s + 1l;
              }

              else
                lenmod = (enum anonymous$11)LENMOD_SHORT;
              s = s + 1l;
              break;
            }
            case 108:
            {
              if((signed int)s[1l] == 108)
              {
                lenmod = (enum anonymous$11)LENMOD_LONGLONG;
                s = s + 1l;
              }

              else
                lenmod = (enum anonymous$11)LENMOD_LONG;
              s = s + 1l;
              break;
            }
            case 106:
            {
              lenmod = (enum anonymous$11)LENMOD_INTMAX;
              s = s + 1l;
              break;
            }
            case 122:
            {
              lenmod = (enum anonymous$11)LENMOD_SIZET;
              s = s + 1l;
              break;
            }
            case 116:
            {
              lenmod = (enum anonymous$11)LENMOD_PTRDIFF;
              s = s + 1l;
              break;
            }
            case 76:
            {
              lenmod = (enum anonymous$11)LENMOD_LONGDBL;
              s = s + 1l;
              break;
            }
            default:
              lenmod = (enum anonymous$11)LENMOD_NONE;
          }
          switch((signed int)*s)
          {
            case 100:

            case 105:
            {
              conspec = (enum anonymous$12)CONSPEC_DECIMAL;
              break;
            }
            case 111:
            {
              conspec = (enum anonymous$12)CONSPEC_OCTAL;
              break;
            }
            case 117:
            {
              conspec = (enum anonymous$12)CONSPEC_UNSIGNED;
              break;
            }
            case 120:
            {
              conspec = (enum anonymous$12)CONSPEC_HEX;
              break;
            }
            case 88:
            {
              conspec = (enum anonymous$12)CONSPEC_HEX_UP;
              break;
            }
            case 102:
            {
              conspec = (enum anonymous$12)CONSPEC_FLOAT;
              break;
            }
            case 70:
            {
              conspec = (enum anonymous$12)CONSPEC_FLOAT_UP;
              break;
            }
            case 101:
            {
              conspec = (enum anonymous$12)CONSPEC_EXP;
              break;
            }
            case 69:
            {
              conspec = (enum anonymous$12)CONSPEC_EXP_UP;
              break;
            }
            case 103:
            {
              conspec = (enum anonymous$12)CONSPEC_F_OR_G;
              break;
            }
            case 71:
            {
              conspec = (enum anonymous$12)CONSPEC_F_OR_G_UP;
              break;
            }
            case 97:
            {
              conspec = (enum anonymous$12)CONSPEC_HEX_EXP;
              break;
            }
            case 65:
            {
              conspec = (enum anonymous$12)CONSPEC_HEX_EXP_UP;
              break;
            }
            case 99:
            {
              conspec = (enum anonymous$12)CONSPEC_CHAR;
              break;
            }
            case 115:
            {
              conspec = (enum anonymous$12)CONSPEC_STRING;
              break;
            }
            case 112:
            {
              conspec = (enum anonymous$12)CONSPEC_POINTER;
              break;
            }
            case 110:
            {
              conspec = (enum anonymous$12)CONSPEC_BYTES_SO_FAR;
              break;
            }
            case 67:
            {
              conspec = (enum anonymous$12)CONSPEC_CHAR;
              lenmod = (enum anonymous$11)LENMOD_LONG;
              break;
            }
            case 83:
            {
              conspec = (enum anonymous$12)CONSPEC_STRING;
              lenmod = (enum anonymous$11)LENMOD_LONG;
              break;
            }
            case 109:
            {
              conspec = (enum anonymous$12)CONSPEC_STRERROR;
              arg_pos = -1;
              break;
            }
            default:
              conspec = (enum anonymous$12)CONSPEC_UNKNOWN;
          }
          if(argcount >= max_argspecs)
          {
            unsigned long int n;
            unsigned long int newmax;
            struct argspec_s *newarg;
            newmax = max_argspecs + (unsigned long int)10;
            if(max_argspecs >= newmax)
              goto leave_einval;

            void *return_value_calloc$13;
            return_value_calloc$13=calloc(newmax, sizeof(struct argspec_s) /*48ul*/ );
            newarg = (struct argspec_s *)return_value_calloc$13;
            if(newarg == ((struct argspec_s *)NULL))
              goto leave;

            n = (unsigned long int)0;
            for( ; !(n >= argcount); n = n + 1ul)
              newarg[(signed long int)n] = argspecs[(signed long int)n];
            if(!(argspecs == *argspecs_addr))
              free((void *)argspecs);

            argspecs = newarg;
            max_argspecs = newmax;
          }

          arg = argspecs + (signed long int)argcount;
          arg->length = (unsigned long int)((s - format) + (signed long int)2);
          arg->flags = flags;
          arg->width = width;
          arg->precision = precision;
          arg->lenmod = lenmod;
          arg->conspec = conspec;
          arg->arg_pos = arg_pos;
          arg->width_pos = width_pos;
          arg->precision_pos = precision_pos;
          compute_type(arg);
          argcount = argcount + 1ul;
          format = s;
        }

      }

    }
    *argspecs_addr = argspecs;
    *r_argspecs_count = argcount;
    return 0;
  }

  else
  {
    do
    {

    leave_einval:
      ;
      signed int *return_value___errno_location$14;
      return_value___errno_location$14=__errno_location();
      *return_value___errno_location$14 = 22;
    }
    while((_Bool)0);

  leave:
    ;
    if(!(argspecs == *argspecs_addr))
      free((void *)argspecs);

    *argspecs_addr = (struct argspec_s *)(void *)0;
    return -1;
  }
}

// parse_mode
// file ../../src/estream.c line 1572
static signed int parse_mode(const char *modestr, unsigned int *modeflags, signed int *samethread, unsigned int *r_cmode)
{
  unsigned int omode;
  unsigned int oflags;
  unsigned int cmode;
  signed int got_cmode = 0;
  *samethread = 0;
  switch((signed int)*modestr)
  {
    case 114:
    {
      omode = (unsigned int)00;
      oflags = (unsigned int)0;
      break;
    }
    case 119:
    {
      omode = (unsigned int)01;
      oflags = (unsigned int)(01000 | 0100);
      break;
    }
    case 97:
    {
      omode = (unsigned int)01;
      oflags = (unsigned int)(02000 | 0100);
      break;
    }
    default:
    {
      do
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        *return_value___errno_location$1 = 22;
      }
      while((_Bool)0);
      return -1;
    }
  }
  modestr = modestr + 1l;
  while(!(*modestr == 0))
    switch((signed int)*modestr)
    {
      case 43:
      {
        omode = (unsigned int)02;
        goto __CPROVER_DUMP_L11;
      }
      case 98:
      {
        oflags = oflags | (unsigned int)0;
        goto __CPROVER_DUMP_L11;
      }
      case 120:
      {
        oflags = oflags | (unsigned int)0200;
        goto __CPROVER_DUMP_L11;
      }
      case 44:
        goto keyvalue;
      default:
      {

      __CPROVER_DUMP_L11:
        ;
        modestr = modestr + 1l;
      }
    }

keyvalue:
  ;
  cmode = (unsigned int)0;
  _Bool tmp_if_expr$4;
  char *return_value_strchr$6;
  signed int return_value_strncmp$12;
  char *return_value_strchr$8;
  signed int return_value_strncmp$11;
  char *return_value_strchr$10;
  unsigned long int return_value_strcspn$2;
  for( ; (signed int)*modestr == 44; modestr = modestr + (signed long int)return_value_strcspn$2)
  {
    modestr = modestr + 1l;
    unsigned long int return_value_strspn$3;
    return_value_strspn$3=strspn(modestr, " \t");
    modestr = modestr + (signed long int)return_value_strspn$3;
    signed int return_value_strncmp$13;
    return_value_strncmp$13=strncmp(modestr, "mode=", (unsigned long int)5);
    if(return_value_strncmp$13 == 0)
    {
      signed int idx;
      got_cmode = 1;
      modestr = modestr + (signed long int)5;
      idx = 0;
      do
      {
        if(!(idx >= 10))
          tmp_if_expr$4 = *modestr != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          break;

        /* tag-#anon#lST[S8'letter'||U24'$pad0'||U32'value'|] */
struct anonymous$3
{
  // letter
  char letter;
  // value
  unsigned int value;
};

/* */
        ;
        static struct anonymous$3 table[10l] = { { .letter=(char)45, .value=(unsigned int)0 }, 
    { .letter=(char)114, .value=(unsigned int)0400 }, 
    { .letter=(char)119, .value=(unsigned int)0200 }, 
    { .letter=(char)120, .value=(unsigned int)0100 }, 
    { .letter=(char)114, .value=(unsigned int)(0400 >> 3) }, 
    { .letter=(char)119, .value=(unsigned int)(0200 >> 3) }, 
    { .letter=(char)120, .value=(unsigned int)(0100 >> 3) }, 
    { .letter=(char)114, .value=(unsigned int)((0400 >> 3) >> 3) }, 
    { .letter=(char)119, .value=(unsigned int)((0200 >> 3) >> 3) }, 
    { .letter=(char)120, .value=(unsigned int)((0100 >> 3) >> 3) } };
        if(*modestr == table[(signed long int)idx].letter)
          cmode = cmode | table[(signed long int)idx].value;

        else
          if(!((signed int)*modestr == 45))
            break;

        idx = idx + 1;
        modestr = modestr + 1l;
      }
      while((_Bool)1);
      if(!(*modestr == 0))
      {
        return_value_strchr$6=strchr(" \t,", (signed int)*modestr);
        if(return_value_strchr$6 == ((char *)NULL))
        {
          do
          {
            signed int *return_value___errno_location$5;
            return_value___errno_location$5=__errno_location();
            *return_value___errno_location$5 = 22;
          }
          while((_Bool)0);
          return -1;
        }

      }

    }

    else
    {
      return_value_strncmp$12=strncmp(modestr, "samethread", (unsigned long int)10);
      if(return_value_strncmp$12 == 0)
      {
        modestr = modestr + (signed long int)10;
        if(!(*modestr == 0))
        {
          return_value_strchr$8=strchr(" \t,", (signed int)*modestr);
          if(return_value_strchr$8 == ((char *)NULL))
          {
            do
            {
              signed int *return_value___errno_location$7;
              return_value___errno_location$7=__errno_location();
              *return_value___errno_location$7 = 22;
            }
            while((_Bool)0);
            return -1;
          }

        }

        *samethread = 1;
      }

      else
      {
        return_value_strncmp$11=strncmp(modestr, "nonblock", (unsigned long int)8);
        if(return_value_strncmp$11 == 0)
        {
          modestr = modestr + (signed long int)8;
          if(!(*modestr == 0))
          {
            return_value_strchr$10=strchr(" \t,", (signed int)*modestr);
            if(return_value_strchr$10 == ((char *)NULL))
            {
              do
              {
                signed int *return_value___errno_location$9;
                return_value___errno_location$9=__errno_location();
                *return_value___errno_location$9 = 22;
              }
              while((_Bool)0);
              return -1;
            }

          }

          oflags = oflags | (unsigned int)04000;
        }

      }
    }
    return_value_strcspn$2=strcspn(modestr, ",");
  }
  if(got_cmode == 0)
    cmode = (unsigned int)(0400 | 0200 | 0400 >> 3 | 0200 >> 3 | (0400 >> 3) >> 3);

  *modeflags = omode | oflags;
  if(!(r_cmode == ((unsigned int *)NULL)))
    *r_cmode = cmode;

  return 0;
}

// parse_version_number
// file ../../src/version.c line 51
static const char * parse_version_number(const char *s, signed int *number)
{
  signed int val = 0;
  _Bool tmp_if_expr$1;
  if((signed int)*s == 48)
  {
    if(!((signed int)s[1l] >= 48))
      goto __CPROVER_DUMP_L1;

    if((signed int)s[1l] >= 58)
      goto __CPROVER_DUMP_L1;

    return (const char *)(void *)0;
  }

  else
  {
    do
    {

    __CPROVER_DUMP_L1:
      ;
      if((signed int)*s >= 48)
        tmp_if_expr$1 = (signed int)*s <= 57 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      val = val * 10;
      val = val + ((signed int)*s - 48);
      s = s + 1l;
    }
    while((_Bool)1);
    *number = val;
    return val < 0 ? (const char *)(void *)0 : s;
  }
}

// parse_version_string
// file ../../src/version.c line 68
static const char * parse_version_string(const char *s, signed int *major, signed int *minor)
{
  s=parse_version_number(s, major);
  _Bool tmp_if_expr$1;
  if(s == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*s != 46 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return (const char *)(void *)0;

  else
  {
    s = s + 1l;
    s=parse_version_number(s, minor);
    if(s == ((const char *)NULL))
      return (const char *)(void *)0;

    else
      return s;
  }
}

// pick_account
// file ../../tests/t-lock.c line 120
static signed int pick_account(void)
{
  unsigned int return_value_get_rand$1;
  return_value_get_rand$1=get_rand(8 - 1);
  return (signed int)return_value_get_rand$1;
}

// pick_value
// file ../../tests/t-lock.c line 128
static signed int pick_value(void)
{
  unsigned int return_value_get_rand$1;
  return_value_get_rand$1=get_rand(50);
  return (signed int)return_value_get_rand$1;
}

// plain_stdio_out
// file ../../src/estream-printf.c line 1627
static signed int plain_stdio_out(void *outfncarg, const char *buf, unsigned long int buflen)
{
  struct _IO_FILE *fp = (struct _IO_FILE *)outfncarg;
  unsigned long int return_value_fwrite$1;
  return_value_fwrite$1=fwrite((const void *)buf, buflen, (unsigned long int)1, fp);
  if(!(return_value_fwrite$1 == 1ul))
    return -1;

  else
    return 0;
}

// pr_bytes_so_far
// file ../../src/estream-printf.c line 1292
static signed int pr_bytes_so_far(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, struct argspec_s *arg, union anonymous$14 value, unsigned long int *nbytes)
{
  (void)outfnc;
  (void)outfncarg;
  switch((signed int)arg->vt)
  {
    case VALTYPE_SCHAR_PTR:
    {
      *value.a_schar_ptr = (signed char)(unsigned int)*nbytes;
      break;
    }
    case VALTYPE_SHORT_PTR:
    {
      *value.a_short_ptr = (signed short int)(unsigned int)*nbytes;
      break;
    }
    case VALTYPE_LONG_PTR:
    {
      *value.a_long_ptr = (signed long int)*nbytes;
      break;
    }
    case VALTYPE_LONGLONG_PTR:
    {
      *value.a_longlong_ptr = (signed long long int)*nbytes;
      break;
    }
    case VALTYPE_INTMAX_PTR:
    {
      *value.a_intmax_ptr = (signed long int)*nbytes;
      break;
    }
    case VALTYPE_SIZE_PTR:
    {
      *value.a_size_ptr = *nbytes;
      break;
    }
    case VALTYPE_PTRDIFF_PTR:
    {
      *value.a_ptrdiff_ptr = (signed long int)*nbytes;
      break;
    }
    case VALTYPE_INT_PTR:
    {
      *value.a_int_ptr = (signed int)*nbytes;
      break;
    }
    default:
      return -1;
  }
  return 0;
}

// pr_char
// file ../../src/estream-printf.c line 1178
static signed int pr_char(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, struct argspec_s *arg, union anonymous$14 value, unsigned long int *nbytes)
{
  signed int rc;
  char buf[1l];
  if(!((signed int)arg->vt == VALTYPE_INT))
    return -1;

  else
  {
    buf[(signed long int)0] = (char)(unsigned int)value.a_int;
    rc=outfnc(outfncarg, buf, (unsigned long int)1);
    if(!(rc == 0))
      return rc;

    else
    {
      *nbytes = *nbytes + (unsigned long int)1;
      return 0;
    }
  }
}

// pr_float
// file ../../src/estream-printf.c line 1055
static signed int pr_float(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, struct argspec_s *arg, union anonymous$14 value, unsigned long int *nbytes)
{
  signed int rc;
  long double adblfloat = (long double)0;
  signed int use_dbl = 0;
  double afloat;
  char numbuf[350l];
  char formatstr[20l];
  char *p;
  char *pend;
  unsigned long int n;
  char signchar = (char)0;
  signed int n_extra;
  switch((signed int)arg->vt)
  {
    case VALTYPE_DOUBLE:
    {
      afloat = value.a_double;
      break;
    }
    case VALTYPE_LONGDOUBLE:
    {
      afloat = (double)0;
      adblfloat = value.a_longdouble;
      use_dbl = 1;
      break;
    }
    default:
      return -1;
  }
  p = formatstr + (signed long int)sizeof(char [20l]) /*20ul*/ ;
  p = p - 1l;
  *p = (char)0;
  switch((signed int)arg->conspec)
  {
    case CONSPEC_FLOAT:
    {
      p = p - 1l;
      *p = (char)102;
      break;
    }
    case CONSPEC_FLOAT_UP:
    {
      p = p - 1l;
      *p = (char)70;
      break;
    }
    case CONSPEC_EXP:
    {
      p = p - 1l;
      *p = (char)101;
      break;
    }
    case CONSPEC_EXP_UP:
    {
      p = p - 1l;
      *p = (char)69;
      break;
    }
    case CONSPEC_F_OR_G:
    {
      p = p - 1l;
      *p = (char)103;
      break;
    }
    case CONSPEC_F_OR_G_UP:
    {
      p = p - 1l;
      *p = (char)71;
      break;
    }
    case CONSPEC_HEX_EXP:
    {
      p = p - 1l;
      *p = (char)97;
      break;
    }
    case CONSPEC_HEX_EXP_UP:
    {
      p = p - 1l;
      *p = (char)65;
      break;
    }
    default:
      return -1;
  }
  if(!(use_dbl == 0))
  {
    p = p - 1l;
    *p = (char)76;
  }

  signed int tmp_if_expr$1;
  if(!(arg->precision == -1))
  {
    if(!(arg->precision >= 101))
      tmp_if_expr$1 = arg->precision;

    else
      tmp_if_expr$1 = 100;
    n = (unsigned long int)tmp_if_expr$1;
    do
    {
      p = p - 1l;
      *p = (char)((unsigned long int)48 + n % (unsigned long int)10);
      n = n / (unsigned long int)10;
    }
    while(!(n == 0ul));
    p = p - 1l;
    *p = (char)46;
  }

  if(!((16u & arg->flags) == 0u))
  {
    p = p - 1l;
    *p = (char)35;
  }

  p = p - 1l;
  *p = (char)37;
  if(!(use_dbl == 0))
    sprintf(numbuf, p, adblfloat);

  else
    sprintf(numbuf, p, afloat);
  p = numbuf;
  n=strlen(numbuf);
  pend = p + (signed long int)n;
  if((signed int)*p == 45)
  {
    signchar = (char)45;
    p = p + 1l;
    n = n - 1ul;
  }

  else
    if(!((4u & arg->flags) == 0u))
      signchar = (char)43;

    else
      if(!((8u & arg->flags) == 0u))
        signchar = (char)32;

  n_extra = (signed int)!(!(signchar != 0));
  if((2u & arg->flags) == 0u)
  {
    if(!(arg->width >= 0))
      goto __CPROVER_DUMP_L26;

    if(n >= (unsigned long int)(arg->width + -n_extra))
      goto __CPROVER_DUMP_L26;

    rc=pad_out(outfnc, outfncarg, 32, (signed int)((unsigned long int)(arg->width - n_extra) - n), nbytes);
    if(rc == 0)
      goto __CPROVER_DUMP_L26;

    return rc;
  }

  else
  {

  __CPROVER_DUMP_L26:
    ;
    if(!(signchar == 0))
    {
      rc=outfnc(outfncarg, &signchar, (unsigned long int)1);
      if(!(rc == 0))
        return rc;

      *nbytes = *nbytes + (unsigned long int)1;
    }

    rc=outfnc(outfncarg, p, (unsigned long int)(pend - p));
    if(!(rc == 0))
      return rc;

    else
    {
      *nbytes = *nbytes + (unsigned long int)(pend - p);
      if(!((2u & arg->flags) == 0u))
      {
        rc=pad_out(outfnc, outfncarg, 32, (signed int)((unsigned long int)(arg->width - n_extra) - n), nbytes);
        return rc;
      }

      else
        return 0;
    }
  }
}

// pr_integer
// file ../../src/estream-printf.c line 849
static signed int pr_integer(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, struct argspec_s *arg, union anonymous$14 value, unsigned long int *nbytes)
{
  signed int rc;
  unsigned long long int aulong;
  char numbuf[100l];
  char *p;
  char *pend;
  unsigned long int n;
  char signchar = (char)0;
  signed int n_prec;
  signed int n_extra;
  if((signed int)arg->conspec == CONSPEC_DECIMAL)
  {
    signed long long int along;
    switch((signed int)arg->vt)
    {
      case VALTYPE_SHORT:
      {
        along = (signed long long int)value.a_short;
        break;
      }
      case VALTYPE_INT:
      {
        along = (signed long long int)value.a_int;
        break;
      }
      case VALTYPE_LONG:
      {
        along = value.a_long;
        break;
      }
      case VALTYPE_LONGLONG:
      {
        along = value.a_longlong;
        break;
      }
      case VALTYPE_SIZE:
      {
        along = (signed long long int)value.a_size;
        break;
      }
      case VALTYPE_INTMAX:
      {
        along = value.a_intmax;
        break;
      }
      case VALTYPE_PTRDIFF:
      {
        along = value.a_ptrdiff;
        break;
      }
      default:
        return -1;
    }
    if(!(along >= 0l))
    {
      aulong = (unsigned long long int)-along;
      signchar = (char)45;
    }

    else
      aulong = (unsigned long long int)along;
  }

  else
    switch((signed int)arg->vt)
    {
      case VALTYPE_USHORT:
      {
        aulong = (unsigned long long int)value.a_ushort;
        break;
      }
      case VALTYPE_UINT:
      {
        aulong = (unsigned long long int)value.a_uint;
        break;
      }
      case VALTYPE_ULONG:
      {
        aulong = value.a_ulong;
        break;
      }
      case VALTYPE_ULONGLONG:
      {
        aulong = value.a_ulonglong;
        break;
      }
      case VALTYPE_SIZE:
      {
        aulong = value.a_size;
        break;
      }
      case VALTYPE_UINTMAX:
      {
        aulong = (unsigned long long int)value.a_uintmax;
        break;
      }
      case VALTYPE_PTRDIFF:
      {
        aulong = (unsigned long long int)value.a_ptrdiff;
        break;
      }
      default:
        return -1;
    }
  if(!((signed int)signchar == 45))
  {
    if(!((4u & arg->flags) == 0u))
      signchar = (char)43;

    else
      if(!((8u & arg->flags) == 0u))
        signchar = (char)32;

  }

  n_extra = (signed int)!(!(signchar != 0));
  pend = numbuf + (signed long int)(sizeof(char [100l]) /*100ul*/  / sizeof(char) /*1ul*/ );
  p = pend;
  _Bool tmp_if_expr$2;
  if(aulong == 0ull)
    tmp_if_expr$2 = !(arg->precision != 0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  _Bool tmp_if_expr$1;
  if(!tmp_if_expr$2)
  {
    if((signed int)arg->conspec == CONSPEC_DECIMAL)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)arg->conspec == CONSPEC_UNSIGNED ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      signed int grouping = -1;
      const char *grouping_string;
      grouping_string=nl_langinfo(65537);
      while((_Bool)1)
      {
        if(!((1u & arg->flags) == 0u))
        {
          grouping = grouping + 1;
          if(grouping == 3)
          {
            if(!(*grouping_string == 0))
            {
              p = p - 1l;
              *p = *grouping_string;
              grouping = 0;
            }

          }

        }

        p = p - 1l;
        *p = (char)((unsigned long int)48 + aulong % (unsigned long int)10);
        aulong = aulong / (unsigned long long int)10;
        if(aulong == 0ull)
          break;

      }
    }

    else
      if((signed int)arg->conspec == CONSPEC_OCTAL)
      {
        do
        {
          p = p - 1l;
          *p = (char)((unsigned long int)48 + aulong % (unsigned long int)8);
          aulong = aulong / (unsigned long long int)8;
        }
        while(!(aulong == 0ull));
        if(!((16u & arg->flags) == 0u))
        {
          if(!((signed int)*p == 48))
          {
            p = p - 1l;
            *p = (char)48;
          }

        }

      }

      else
      {
        const char *digits = (signed int)arg->conspec == CONSPEC_HEX ? "0123456789abcdef" : "0123456789ABCDEF";
        do
        {
          p = p - 1l;
          *p = digits[(signed long int)(aulong % (unsigned long int)16)];
          aulong = aulong / (unsigned long long int)16;
        }
        while(!(aulong == 0ull));
        if(!((16u & arg->flags) == 0u))
          n_extra = n_extra + 2;

      }
  }

  n = (unsigned long int)(pend - p);
  _Bool tmp_if_expr$4;
  if(!((32u & arg->flags) == 0u))
    tmp_if_expr$4 = arg->precision == -1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$4 = (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = !((arg->flags & (unsigned int)2) != 0u) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$5 = (_Bool)0;
  _Bool tmp_if_expr$6;
  if(!(n == 0ul) && tmp_if_expr$5)
    tmp_if_expr$6 = (unsigned long int)(arg->width - n_extra) > n ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$6 = (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$6)
    n_prec = (signed int)((unsigned long int)(arg->width - n_extra) - n);

  else
  {
    if(arg->precision >= 1)
      tmp_if_expr$3 = (unsigned long int)arg->precision > n ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      n_prec = (signed int)((unsigned long int)arg->precision - n);

    else
      n_prec = 0;
  }
  _Bool tmp_if_expr$7;
  if((2u & arg->flags) == 0u)
  {
    if(!(arg->width >= 0))
      goto __CPROVER_DUMP_L50;

    if(n >= (unsigned long int)(arg->width + -n_extra))
      goto __CPROVER_DUMP_L50;

    if(!((unsigned long int)(arg->width + -n_extra) + -n >= (unsigned long int)n_prec))
      goto __CPROVER_DUMP_L50;

    rc=pad_out(outfnc, outfncarg, 32, (signed int)(((unsigned long int)(arg->width - n_extra) - n) - (unsigned long int)n_prec), nbytes);
    if(rc == 0)
      goto __CPROVER_DUMP_L50;

    return rc;
  }

  else
  {

  __CPROVER_DUMP_L50:
    ;
    if(!(signchar == 0))
    {
      rc=outfnc(outfncarg, &signchar, (unsigned long int)1);
      if(!(rc == 0))
        return rc;

      *nbytes = *nbytes + (unsigned long int)1;
    }

    if(!((16u & arg->flags) == 0u))
    {
      if((signed int)arg->conspec == CONSPEC_HEX)
        tmp_if_expr$7 = (_Bool)1;

      else
        tmp_if_expr$7 = (signed int)arg->conspec == CONSPEC_HEX_UP ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$7)
      {
        rc=outfnc(outfncarg, (signed int)arg->conspec == CONSPEC_HEX ? "0x" : "0X", (unsigned long int)2);
        if(!(rc == 0))
          return rc;

        *nbytes = *nbytes + (unsigned long int)2;
      }

    }

    if(!(n_prec == 0))
    {
      rc=pad_out(outfnc, outfncarg, 48, n_prec, nbytes);
      if(rc == 0)
        goto __CPROVER_DUMP_L57;

      return rc;
    }

    else
    {

    __CPROVER_DUMP_L57:
      ;
      rc=outfnc(outfncarg, p, (unsigned long int)(pend - p));
      if(!(rc == 0))
        return rc;

      else
      {
        *nbytes = *nbytes + (unsigned long int)(pend - p);
        if(!((2u & arg->flags) == 0u))
        {
          rc=pad_out(outfnc, outfncarg, 32, (signed int)((unsigned long int)((arg->width - n_extra) - n_prec) - n), nbytes);
          return rc;
        }

        else
          return 0;
      }
    }
  }
}

// pr_pointer
// file ../../src/estream-printf.c line 1247
static signed int pr_pointer(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, struct argspec_s *arg, union anonymous$14 value, unsigned long int *nbytes)
{
  signed int rc;
  unsigned long int aulong;
  char numbuf[100l];
  char *p;
  char *pend;
  if(!((signed int)arg->vt == VALTYPE_POINTER))
    return -1;

  else
  {
    aulong = (unsigned long int)value.a_void_ptr;
    pend = numbuf + (signed long int)(sizeof(char [100l]) /*100ul*/  / sizeof(char) /*1ul*/ );
    p = pend;
    do
    {
      p = p - 1l;
      *p = "0123456789abcdefx"[(signed long int)(aulong % (unsigned long int)16)];
      aulong = aulong / (unsigned long int)16;
    }
    while(!(aulong == 0ul));
    for( ; !((unsigned long int)(pend - p) >= sizeof(unsigned long int) * 2 /*16ul*/ ); *p = (char)48)
      p = p - 1l;
    p = p - 1l;
    *p = (char)120;
    p = p - 1l;
    *p = (char)48;
    rc=outfnc(outfncarg, p, (unsigned long int)(pend - p));
    if(!(rc == 0))
      return rc;

    else
    {
      *nbytes = *nbytes + (unsigned long int)(pend - p);
      return 0;
    }
  }
}

// pr_string
// file ../../src/estream-printf.c line 1198
static signed int pr_string(signed int (*outfnc)(void *, const char *, unsigned long int), void *outfncarg, struct argspec_s *arg, union anonymous$14 value, unsigned long int *nbytes)
{
  signed int rc;
  unsigned long int n;
  const char *string;
  const char *s;
  _Bool tmp_if_expr$1;
  if(!((signed int)arg->vt == VALTYPE_STRING))
    return -1;

  else
  {
    string = value.a_string;
    if(string == ((const char *)NULL))
      string = "(null)";

    if(arg->precision >= 0)
    {
      n = (unsigned long int)0;
      s = string;
      do
      {
        if(!(n >= (unsigned long int)arg->precision))
          tmp_if_expr$1 = *s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(!tmp_if_expr$1)
          break;

        n = n + 1ul;
        s = s + 1l;
      }
      while((_Bool)1);
    }

    else
      n=strlen(string);
    if((2u & arg->flags) == 0u)
    {
      if(!(arg->width >= 0))
        goto __CPROVER_DUMP_L9;

      if(n >= (unsigned long int)arg->width)
        goto __CPROVER_DUMP_L9;

      rc=pad_out(outfnc, outfncarg, 32, (signed int)((unsigned long int)arg->width - n), nbytes);
      if(rc == 0)
        goto __CPROVER_DUMP_L9;

      return rc;
    }

    else
    {

    __CPROVER_DUMP_L9:
      ;
      rc=outfnc(outfncarg, string, n);
      if(!(rc == 0))
        return rc;

      else
      {
        *nbytes = *nbytes + n;
        if(!((2u & arg->flags) == 0u))
        {
          rc=pad_out(outfnc, outfncarg, 32, (signed int)((unsigned long int)arg->width - n), nbytes);
          return rc;
        }

        else
          return 0;
      }
    }
  }
}

// print_accounts
// file ../../tests/t-lock.c line 99
static void print_accounts(void)
{
  signed int i = 0;
  for( ; !(i >= 8); i = i + 1)
    printf("account %d: %6d\n", i, account[(signed long int)i]);
}

// print_writer
// file ../../src/estream.c line 2717
static signed int print_writer(void *outfncarg, const char *buf, unsigned long int buflen)
{
  struct _gpgrt__stream *stream = (struct _gpgrt__stream *)outfncarg;
  unsigned long int nwritten;
  signed int rc;
  nwritten = (unsigned long int)0;
  rc=es_writen(stream, (const void *)buf, buflen, &nwritten);
  stream->intern->print_ntotal = stream->intern->print_ntotal + nwritten;
  return rc;
}

// read_values
// file ../../src/estream-printf.c line 716
static signed int read_values(struct valueitem_s *valuetable, unsigned long int valuetable_len, __builtin_va_list vaargs)
{
  signed int validx = 0;
  signed int return_value_gcc_builtin_va_arg$1;
  signed int return_value_gcc_builtin_va_arg$2;
  signed int return_value_gcc_builtin_va_arg$3;
  signed int return_value_gcc_builtin_va_arg$4;
  signed int return_value_gcc_builtin_va_arg$5;
  unsigned long int return_value_gcc_builtin_va_arg$6;
  for( ; !((unsigned long int)validx >= valuetable_len); validx = validx + 1)
  {
    union anonymous$14 *value = &(valuetable + (signed long int)validx)->value;
    enum anonymous$13 vt = (valuetable + (signed long int)validx)->vt;
    switch((signed int)vt)
    {
      case VALTYPE_CHAR:
      {
        return_value_gcc_builtin_va_arg$1=va_arg(vaargs, __typeof__(return_value_gcc_builtin_va_arg$1));
        value->a_char = (char)return_value_gcc_builtin_va_arg$1;
        break;
      }
      case VALTYPE_CHAR_PTR:
      {
        value->a_char_ptr=va_arg(vaargs, __typeof__(value->a_char_ptr));
        break;
      }
      case VALTYPE_SCHAR:
      {
        return_value_gcc_builtin_va_arg$2=va_arg(vaargs, __typeof__(return_value_gcc_builtin_va_arg$2));
        value->a_schar = (signed char)return_value_gcc_builtin_va_arg$2;
        break;
      }
      case VALTYPE_SCHAR_PTR:
      {
        value->a_schar_ptr=va_arg(vaargs, __typeof__(value->a_schar_ptr));
        break;
      }
      case VALTYPE_UCHAR:
      {
        return_value_gcc_builtin_va_arg$3=va_arg(vaargs, __typeof__(return_value_gcc_builtin_va_arg$3));
        value->a_uchar = (unsigned char)return_value_gcc_builtin_va_arg$3;
        break;
      }
      case VALTYPE_SHORT:
      {
        return_value_gcc_builtin_va_arg$4=va_arg(vaargs, __typeof__(return_value_gcc_builtin_va_arg$4));
        value->a_short = (signed short int)return_value_gcc_builtin_va_arg$4;
        break;
      }
      case VALTYPE_USHORT:
      {
        return_value_gcc_builtin_va_arg$5=va_arg(vaargs, __typeof__(return_value_gcc_builtin_va_arg$5));
        value->a_ushort = (unsigned short int)return_value_gcc_builtin_va_arg$5;
        break;
      }
      case VALTYPE_SHORT_PTR:
      {
        value->a_short_ptr=va_arg(vaargs, __typeof__(value->a_short_ptr));
        break;
      }
      case VALTYPE_INT:
      {
        value->a_int=va_arg(vaargs, __typeof__(value->a_int));
        break;
      }
      case VALTYPE_INT_PTR:
      {
        value->a_int_ptr=va_arg(vaargs, __typeof__(value->a_int_ptr));
        break;
      }
      case VALTYPE_UINT:
      {
        value->a_uint=va_arg(vaargs, __typeof__(value->a_uint));
        break;
      }
      case VALTYPE_LONG:
      {
        value->a_long=va_arg(vaargs, __typeof__(value->a_long));
        break;
      }
      case VALTYPE_ULONG:
      {
        value->a_ulong=va_arg(vaargs, __typeof__(value->a_ulong));
        break;
      }
      case VALTYPE_LONG_PTR:
      {
        value->a_long_ptr=va_arg(vaargs, __typeof__(value->a_long_ptr));
        break;
      }
      case VALTYPE_LONGLONG:
      {
        value->a_longlong=va_arg(vaargs, __typeof__(value->a_longlong));
        break;
      }
      case VALTYPE_ULONGLONG:
      {
        value->a_ulonglong=va_arg(vaargs, __typeof__(value->a_ulonglong));
        break;
      }
      case VALTYPE_LONGLONG_PTR:
      {
        value->a_longlong_ptr=va_arg(vaargs, __typeof__(value->a_longlong_ptr));
        break;
      }
      case VALTYPE_DOUBLE:
      {
        value->a_double=va_arg(vaargs, __typeof__(value->a_double));
        break;
      }
      case VALTYPE_LONGDOUBLE:
      {
        value->a_longdouble=va_arg(vaargs, __typeof__(value->a_longdouble));
        break;
      }
      case VALTYPE_STRING:
      {
        value->a_string=va_arg(vaargs, __typeof__(value->a_string));
        break;
      }
      case VALTYPE_POINTER:
      {
        value->a_void_ptr=va_arg(vaargs, __typeof__(value->a_void_ptr));
        break;
      }
      case VALTYPE_INTMAX:
      {
        value->a_intmax=va_arg(vaargs, __typeof__(value->a_intmax));
        break;
      }
      case VALTYPE_INTMAX_PTR:
      {
        value->a_intmax_ptr=va_arg(vaargs, __typeof__(value->a_intmax_ptr));
        break;
      }
      case VALTYPE_UINTMAX:
      {
        return_value_gcc_builtin_va_arg$6=va_arg(vaargs, __typeof__(return_value_gcc_builtin_va_arg$6));
        value->a_uintmax = (signed long int)return_value_gcc_builtin_va_arg$6;
        break;
      }
      case VALTYPE_SIZE:
      {
        value->a_size=va_arg(vaargs, __typeof__(value->a_size));
        break;
      }
      case VALTYPE_SIZE_PTR:
      {
        value->a_size_ptr=va_arg(vaargs, __typeof__(value->a_size_ptr));
        break;
      }
      case VALTYPE_PTRDIFF:
      {
        value->a_ptrdiff=va_arg(vaargs, __typeof__(value->a_ptrdiff));
        break;
      }
      case VALTYPE_PTRDIFF_PTR:
      {
        value->a_ptrdiff_ptr=va_arg(vaargs, __typeof__(value->a_ptrdiff_ptr));
        break;
      }
      default:
        return -1;
    }
  }
  return 0;
}

// real_init
// file ../../src/init.c line 70
static void real_init(void)
{
  char *locale_dir = "/usr/share/locale";
  if(!(locale_dir == ((char *)NULL)))
    bindtextdomain("libgpg-error", locale_dir);

  _gpgrt_es_init();
}

// revision_thread
// file ../../tests/t-lock.c line 136
static void * revision_thread(void *arg)
{
  enum anonymous$4 rc;
  signed int i = 0;
  (void)arg;
  const char *return_value_gpg_strerror$1;
  const char *return_value_gpg_strerror$2;
  while(stop_revision_thread == 0)
  {
    rc=gpgrt_lock_lock(&accounts_lock);
    if(!(rc == /*enum*/GPG_ERR_NO_ERROR))
    {
      return_value_gpg_strerror$1=gpg_strerror((unsigned int)rc);
      fail("gpgrt_lock_lock failed at %d: %s", 147, return_value_gpg_strerror$1);
    }

    check_accounts();
    rc=gpgrt_lock_unlock(&accounts_lock);
    if(!(rc == /*enum*/GPG_ERR_NO_ERROR))
    {
      return_value_gpg_strerror$2=gpg_strerror((unsigned int)rc);
      fail("gpgrt_lock_unlock failed at %d: %s", 152, return_value_gpg_strerror$2);
    }

    i = i + 1;
    if(i % 7 == 0)
      gpgrt_yield();

  }
  return (void *)0;
}

// run_test
// file ../../tests/t-lock.c line 198
static void run_test(void)
{
  unsigned long int rthread;
  unsigned long int athreads[5l];
  signed int i;
  stop_revision_thread = 0;
  pthread_create(&rthread, (const union pthread_attr_t *)(void *)0, revision_thread, (void *)0);
  i = 0;
  for( ; !(i >= 5); i = i + 1)
    pthread_create(&athreads[(signed long int)i], (const union pthread_attr_t *)(void *)0, accountant_thread, (void *)0);
  i = 0;
  for( ; !(i >= 5); i = i + 1)
  {
    pthread_join(athreads[(signed long int)i], (void **)(void *)0);
    show("accountant thread %d has terminated", i);
  }
  stop_revision_thread = 1;
  pthread_join(rthread, (void **)(void *)0);
  show("revision thread has terminated");
  gpgrt_lock_destroy(&accounts_lock);
}

// show
// file ../../tests/t-common.h line 84
static void show(const char *format, ...)
{
  void **arg_ptr;
  unsigned long int return_value_strlen$1;
  if(!(verbose == 0))
  {
    flockfile(stderr);
    fprintf(stderr, "%s: ", (const void *)"t-lock");
    arg_ptr = (void **)&format;
    vfprintf(stderr, format, arg_ptr);
    if(!(*format == 0))
    {
      return_value_strlen$1=strlen(format);
      if(!((signed int)format[-1l + (signed long int)return_value_strlen$1] == 10))
        _IO_putc(10, stderr);

    }

    arg_ptr = ((void **)NULL);
    funlockfile(stderr);
  }

}

// system_strerror_r
// file ../../src/strerror.c line 65
static signed int system_strerror_r(signed int no, char *buf, unsigned long int buflen)
{
  char *errstr;
  errstr=strerror_r(no, buf, buflen);
  if(!(errstr == buf))
  {
    unsigned long int errstr_len;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(errstr);
    errstr_len = return_value_strlen$1 + (unsigned long int)1;
    unsigned long int cpy_len = errstr_len < buflen ? errstr_len : buflen;
    memcpy((void *)buf, (const void *)errstr, cpy_len);
    return cpy_len == errstr_len ? 0 : 34;
  }

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(buf);
    if(1ul + return_value_strlen$2 >= buflen)
      return 34;

    return 0;
  }
}

// tmpfd
// file ../../src/estream.c line 4219
static signed int tmpfd(void)
{
  struct _IO_FILE *fp;
  signed int fp_fd;
  signed int fd;
  fp = (struct _IO_FILE *)(void *)0;
  fd = -1;
  fp=tmpfile();
  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    fp_fd=fileno(fp);
    fd=dup(fp_fd);
  }


out:
  ;
  if(!(fp == ((struct _IO_FILE *)NULL)))
    fclose(fp);

  return fd;
}

// trylock_stream
// file ../../src/estream.c line 389
static signed int trylock_stream(struct _gpgrt__stream * restrict stream)
{
  signed int rc;
  if(stream->intern->samethread == 0u)
  {
    enum anonymous$4 return_value__gpgrt_lock_trylock$1;
    return_value__gpgrt_lock_trylock$1=_gpgrt_lock_trylock(&stream->intern->lock);
    rc = return_value__gpgrt_lock_trylock$1 != (enum anonymous$4)0 ? 0 : -1;
  }

  else
    rc = 0;
  return rc;
}

// unlock_list
// file ../../src/estream.c line 427
static void unlock_list(void)
{
  _gpgrt_lock_unlock(&estream_list_lock);
}

// unlock_stream
// file ../../src/estream.c line 406
static void unlock_stream(struct _gpgrt__stream * restrict stream)
{
  if(stream->intern->samethread == 0u)
    _gpgrt_lock_unlock(&stream->intern->lock);

}

