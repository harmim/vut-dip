// #anon_enum$GDK_CAP_NOT_LAST=0$GDK_CAP_BUTT=1$GDK_CAP_ROUND=2$GDK_CAP_PROJECTING=3
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 48
enum anonymous$29 { GDK_CAP_NOT_LAST=0, GDK_CAP_BUTT=1, GDK_CAP_ROUND=2, GDK_CAP_PROJECTING=3 };

// #anon_enum$GDK_CLIP_BY_CHILDREN=0$GDK_INCLUDE_INFERIORS=1
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 132
enum anonymous$27 { GDK_CLIP_BY_CHILDREN=0, GDK_INCLUDE_INFERIORS=1 };

// #anon_enum$GDK_COPY=0$GDK_INVERT=1$GDK_XOR=2$GDK_CLEAR=3$GDK_AND=4$GDK_AND_REVERSE=5$GDK_AND_INVERT=6$GDK_NOOP=7$GDK_OR=8$GDK_EQUIV=9$GDK_OR_REVERSE=10$GDK_COPY_INVERT=11$GDK_OR_INVERT=12$GDK_NAND=13$GDK_NOR=14$GDK_SET=15
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 88
enum anonymous$25 { GDK_COPY=0, GDK_INVERT=1, GDK_XOR=2, GDK_CLEAR=3, GDK_AND=4, GDK_AND_REVERSE=5, GDK_AND_INVERT=6, GDK_NOOP=7, GDK_OR=8, GDK_EQUIV=9, GDK_OR_REVERSE=10, GDK_COPY_INVERT=11, GDK_OR_INVERT=12, GDK_NAND=13, GDK_NOR=14, GDK_SET=15 };

// #anon_enum$GDK_FONT_FONT=0$GDK_FONT_FONTSET=1
// file /usr/include/gtk-2.0/gdk/gdkfont.h line 43
enum anonymous$20 { GDK_FONT_FONT=0, GDK_FONT_FONTSET=1 };

// #anon_enum$GDK_JOIN_MITER=0$GDK_JOIN_ROUND=1$GDK_JOIN_BEVEL=2
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 113
enum anonymous$30 { GDK_JOIN_MITER=0, GDK_JOIN_ROUND=1, GDK_JOIN_BEVEL=2 };

// #anon_enum$GDK_LINE_SOLID=0$GDK_LINE_ON_OFF_DASH=1$GDK_LINE_DOUBLE_DASH=2
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 125
enum anonymous$28 { GDK_LINE_SOLID=0, GDK_LINE_ON_OFF_DASH=1, GDK_LINE_DOUBLE_DASH=2 };

// #anon_enum$GDK_LSB_FIRST=0$GDK_MSB_FIRST=1
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 118
enum anonymous$19 { GDK_LSB_FIRST=0, GDK_MSB_FIRST=1 };

// #anon_enum$GDK_NOTHING=-1$GDK_DELETE=0$GDK_DESTROY=1$GDK_EXPOSE=2$GDK_MOTION_NOTIFY=3$GDK_BUTTON_PRESS=4$GDK_2BUTTON_PRESS=5$GDK_3BUTTON_PRESS=6$GDK_BUTTON_RELEASE=7$GDK_KEY_PRESS=8$GDK_KEY_RELEASE=9$GDK_ENTER_NOTIFY=10$GDK_LEAVE_NOTIFY=11$GDK_FOCUS_CHANGE=12$GDK_CONFIGURE=13$GDK_MAP=14$GDK_UNMAP=15$GDK_PROPERTY_NOTIFY=16$GDK_SELECTION_CLEAR=17$GDK_SELECTION_REQUEST=18$GDK_SELECTION_NOTIFY=19$GDK_PROXIMITY_IN=20$GDK_PROXIMITY_OUT=21$GDK_DRAG_ENTER=22$GDK_DRAG_LEAVE=23$GDK_DRAG_MOTION=24$GDK_DRAG_STATUS=25$GDK_DROP_START=26$GDK_DROP_FINISHED=27$GDK_CLIENT_EVENT=28$GDK_VISIBILITY_NOTIFY=29$GDK_NO_EXPOSE=30$GDK_SCROLL=31$GDK_WINDOW_STATE=32$GDK_SETTING=33$GDK_OWNER_CHANGE=34$GDK_GRAB_BROKEN=35$GDK_DAMAGE=36$GDK_EVENT_LAST=37
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 115
enum anonymous$18 { GDK_NOTHING=-1, GDK_DELETE=0, GDK_DESTROY=1, GDK_EXPOSE=2, GDK_MOTION_NOTIFY=3, GDK_BUTTON_PRESS=4, GDK_2BUTTON_PRESS=5, GDK_3BUTTON_PRESS=6, GDK_BUTTON_RELEASE=7, GDK_KEY_PRESS=8, GDK_KEY_RELEASE=9, GDK_ENTER_NOTIFY=10, GDK_LEAVE_NOTIFY=11, GDK_FOCUS_CHANGE=12, GDK_CONFIGURE=13, GDK_MAP=14, GDK_UNMAP=15, GDK_PROPERTY_NOTIFY=16, GDK_SELECTION_CLEAR=17, GDK_SELECTION_REQUEST=18, GDK_SELECTION_NOTIFY=19, GDK_PROXIMITY_IN=20, GDK_PROXIMITY_OUT=21, GDK_DRAG_ENTER=22, GDK_DRAG_LEAVE=23, GDK_DRAG_MOTION=24, GDK_DRAG_STATUS=25, GDK_DROP_START=26, GDK_DROP_FINISHED=27, GDK_CLIENT_EVENT=28, GDK_VISIBILITY_NOTIFY=29, GDK_NO_EXPOSE=30, GDK_SCROLL=31, GDK_WINDOW_STATE=32, GDK_SETTING=33, GDK_OWNER_CHANGE=34, GDK_GRAB_BROKEN=35, GDK_DAMAGE=36, GDK_EVENT_LAST=37 };

// #anon_enum$GDK_SHIFT_MASK=1$GDK_LOCK_MASK=2$GDK_CONTROL_MASK=4$GDK_MOD1_MASK=8$GDK_MOD2_MASK=16$GDK_MOD3_MASK=32$GDK_MOD4_MASK=64$GDK_MOD5_MASK=128$GDK_BUTTON1_MASK=256$GDK_BUTTON2_MASK=512$GDK_BUTTON3_MASK=1024$GDK_BUTTON4_MASK=2048$GDK_BUTTON5_MASK=4096$GDK_SUPER_MASK=67108864$GDK_HYPER_MASK=134217728$GDK_META_MASK=268435456$GDK_RELEASE_MASK=1073741824$GDK_MODIFIER_MASK=1543512063
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 126
enum anonymous$24 { GDK_SHIFT_MASK=1, GDK_LOCK_MASK=2, GDK_CONTROL_MASK=4, GDK_MOD1_MASK=8, GDK_MOD2_MASK=16, GDK_MOD3_MASK=32, GDK_MOD4_MASK=64, GDK_MOD5_MASK=128, GDK_BUTTON1_MASK=256, GDK_BUTTON2_MASK=512, GDK_BUTTON3_MASK=1024, GDK_BUTTON4_MASK=2048, GDK_BUTTON5_MASK=4096, GDK_SUPER_MASK=67108864, GDK_HYPER_MASK=134217728, GDK_META_MASK=268435456, GDK_RELEASE_MASK=1073741824, GDK_MODIFIER_MASK=1543512063 };

// #anon_enum$GDK_SOLID=0$GDK_TILED=1$GDK_STIPPLED=2$GDK_OPAQUE_STIPPLED=3
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 62
enum anonymous$26 { GDK_SOLID=0, GDK_TILED=1, GDK_STIPPLED=2, GDK_OPAQUE_STIPPLED=3 };

// #anon_enum$GDK_VISUAL_STATIC_GRAY=0$GDK_VISUAL_GRAYSCALE=1$GDK_VISUAL_STATIC_COLOR=2$GDK_VISUAL_PSEUDO_COLOR=3$GDK_VISUAL_TRUE_COLOR=4$GDK_VISUAL_DIRECT_COLOR=5
// file /usr/include/gtk-2.0/gdk/gdkvisual.h line 55
enum anonymous$9 { GDK_VISUAL_STATIC_GRAY=0, GDK_VISUAL_GRAYSCALE=1, GDK_VISUAL_STATIC_COLOR=2, GDK_VISUAL_PSEUDO_COLOR=3, GDK_VISUAL_TRUE_COLOR=4, GDK_VISUAL_DIRECT_COLOR=5 };

// #anon_enum$GTK_ACCEL_VISIBLE=1$GTK_ACCEL_LOCKED=2$GTK_ACCEL_MASK=7
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 51
enum anonymous$1 { GTK_ACCEL_VISIBLE=1, GTK_ACCEL_LOCKED=2, GTK_ACCEL_MASK=7 };

// #anon_enum$GTK_BUTTONS_NONE=0$GTK_BUTTONS_OK=1$GTK_BUTTONS_CLOSE=2$GTK_BUTTONS_CANCEL=3$GTK_BUTTONS_YES_NO=4$GTK_BUTTONS_OK_CANCEL=5
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 89
enum anonymous$21 { GTK_BUTTONS_NONE=0, GTK_BUTTONS_OK=1, GTK_BUTTONS_CLOSE=2, GTK_BUTTONS_CANCEL=3, GTK_BUTTONS_YES_NO=4, GTK_BUTTONS_OK_CANCEL=5 };

// #anon_enum$GTK_DIALOG_MODAL=1$GTK_DIALOG_DESTROY_WITH_PARENT=2$GTK_DIALOG_NO_SEPARATOR=4
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 41
enum anonymous$22 { GTK_DIALOG_MODAL=1, GTK_DIALOG_DESTROY_WITH_PARENT=2, GTK_DIALOG_NO_SEPARATOR=4 };

// #anon_enum$GTK_FILE_CHOOSER_ACTION_OPEN=0$GTK_FILE_CHOOSER_ACTION_SAVE=1$GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2$GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER=3
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 56
enum anonymous$7 { GTK_FILE_CHOOSER_ACTION_OPEN=0, GTK_FILE_CHOOSER_ACTION_SAVE=1, GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER=2, GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER=3 };

// #anon_enum$GTK_MESSAGE_INFO=0$GTK_MESSAGE_WARNING=1$GTK_MESSAGE_QUESTION=2$GTK_MESSAGE_ERROR=3$GTK_MESSAGE_OTHER=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 221
enum anonymous$23 { GTK_MESSAGE_INFO=0, GTK_MESSAGE_WARNING=1, GTK_MESSAGE_QUESTION=2, GTK_MESSAGE_ERROR=3, GTK_MESSAGE_OTHER=4 };

// #anon_enum$GTK_ORIENTATION_HORIZONTAL=0$GTK_ORIENTATION_VERTICAL=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 262
enum anonymous$11 { GTK_ORIENTATION_HORIZONTAL=0, GTK_ORIENTATION_VERTICAL=1 };

// #anon_enum$GTK_POLICY_ALWAYS=0$GTK_POLICY_AUTOMATIC=1$GTK_POLICY_NEVER=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 305
enum anonymous$31 { GTK_POLICY_ALWAYS=0, GTK_POLICY_AUTOMATIC=1, GTK_POLICY_NEVER=2 };

// #anon_enum$GTK_RC_FG=1$GTK_RC_BG=2$GTK_RC_TEXT=4$GTK_RC_BASE=8
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 52
enum anonymous$0 { GTK_RC_FG=1, GTK_RC_BG=2, GTK_RC_TEXT=4, GTK_RC_BASE=8 };

// #anon_enum$GTK_SELECTION_NONE=0$GTK_SELECTION_SINGLE=1$GTK_SELECTION_BROWSE=2$GTK_SELECTION_MULTIPLE=3$GTK_SELECTION_EXTENDED=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 379
enum anonymous$6 { GTK_SELECTION_NONE=0, GTK_SELECTION_SINGLE=1, GTK_SELECTION_BROWSE=2, GTK_SELECTION_MULTIPLE=3, GTK_SELECTION_EXTENDED=3 };

// #anon_enum$GTK_SORT_ASCENDING=0$GTK_SORT_DESCENDING=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 476
enum anonymous$5 { GTK_SORT_ASCENDING=0, GTK_SORT_DESCENDING=1 };

// #anon_enum$GTK_TREE_VIEW_COLUMN_GROW_ONLY=0$GTK_TREE_VIEW_COLUMN_AUTOSIZE=1$GTK_TREE_VIEW_COLUMN_FIXED=2
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 45
enum anonymous$8 { GTK_TREE_VIEW_COLUMN_GROW_ONLY=0, GTK_TREE_VIEW_COLUMN_AUTOSIZE=1, GTK_TREE_VIEW_COLUMN_FIXED=2 };

// #anon_enum$GTK_UPDATE_ALWAYS=0$GTK_UPDATE_IF_VALID=1
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 53
enum anonymous$16 { GTK_UPDATE_ALWAYS=0, GTK_UPDATE_IF_VALID=1 };

// #anon_enum$GTK_UPDATE_CONTINUOUS=0$GTK_UPDATE_DISCONTINUOUS=1$GTK_UPDATE_DELAYED=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 434
enum anonymous$12 { GTK_UPDATE_CONTINUOUS=0, GTK_UPDATE_DISCONTINUOUS=1, GTK_UPDATE_DELAYED=2 };

// #anon_enum$G_CONNECT_AFTER=1$G_CONNECT_SWAPPED=2
// file /usr/include/glib-2.0/gobject/gsignal.h line 155
enum anonymous$17 { G_CONNECT_AFTER=1, G_CONNECT_SWAPPED=2 };

// #anon_enum$PANGO_UNDERLINE_NONE=0$PANGO_UNDERLINE_SINGLE=1$PANGO_UNDERLINE_DOUBLE=2$PANGO_UNDERLINE_LOW=3$PANGO_UNDERLINE_ERROR=4
// file /usr/include/pango-1.0/pango/pango-attributes.h line 201
enum anonymous$10 { PANGO_UNDERLINE_NONE=0, PANGO_UNDERLINE_SINGLE=1, PANGO_UNDERLINE_DOUBLE=2, PANGO_UNDERLINE_LOW=3, PANGO_UNDERLINE_ERROR=4 };

// tag-#anon#ST[*{V()->V}$V()->V$'f'||*{V}$V$'d'|]
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 165
struct anonymous$14;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$2;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$4;

// tag-#anon#UN[S32'v_int'||U32'v_uint'||S64'v_long'||U64'v_ulong'||S64'v_int64'||U64'v_uint64'||F32'v_float'||F64'v_double'||*{V}$V$'v_pointer'|]
// file /usr/include/glib-2.0/gobject/gvalue.h line 112
union anonymous$13;

// tag-#anon#UN[S8'char_data'||U8'uchar_data'||S32'bool_data'||S32'int_data'||U32'uint_data'||S64'long_data'||U64'ulong_data'||F32'float_data'||F64'double_data'||*{S8}$S8$'string_data'||*{SYM#tag-_GtkObject#}$SYM#tag-_GtkObject#$'object_data'||*{V}$V$'pointer_data'||SYM#tag-#anon#ST[*{V()->V}$V()->V$'f'||*{V}$V$'d'|]#'signal_data'|]
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 149
union anonymous$15;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$3;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-JackOptions
// file /usr/include/jack/types.h line 90
enum JackOptions { JackNullOption=0, JackNoStartServer=1, JackUseExactName=2, JackServerName=4, JackLoadName=8, JackLoadInit=16, JackSessionID=32 };

// tag-JackStatus
// file /usr/include/jack/types.h line 149
enum JackStatus { JackFailure=1, JackInvalidOption=2, JackNameNotUnique=4, JackServerStarted=8, JackServerFailed=16, JackServerError=32, JackNoSuchClient=64, JackLoadFailure=128, JackInitFailure=256, JackShmFailure=512, JackVersionError=1024, JackBackendError=2048, JackClientZombie=4096 };

// tag-_GArray
// file /usr/include/glib-2.0/glib/garray.h line 37
struct _GArray;

// tag-_GClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 74
struct _GClosure;

// tag-_GClosureNotifyData
// file /usr/include/glib-2.0/gobject/gclosure.h line 75
struct _GClosureNotifyData;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GSList
// file /usr/include/glib-2.0/glib/gslist.h line 37
struct _GSList;

// tag-_GString
// file /usr/include/glib-2.0/glib/gstring.h line 39
struct _GString;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_GValue
// file /usr/include/glib-2.0/gobject/gtype.h line 386
struct _GValue;

// tag-_GdkColor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 102
struct _GdkColor;

// tag-_GdkColormap
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 103
struct _GdkColormap;

// tag-_GdkDrawable
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 111
struct _GdkDrawable;

// tag-_GdkEventExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 48
struct _GdkEventExpose;

// tag-_GdkEventKey
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 54
struct _GdkEventKey;

// tag-_GdkFont
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 105
struct _GdkFont;

// tag-_GdkGC
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 106
struct _GdkGC;

// tag-_GdkGCValues
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 39
struct _GdkGCValues;

// tag-_GdkPixbuf
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 155
struct _GdkPixbuf;

// tag-_GdkRectangle
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 69
struct _GdkRectangle;

// tag-_GdkRegion
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 108
struct _GdkRegion;

// tag-_GdkScreen
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 116
struct _GdkScreen;

// tag-_GdkVisual
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 109
struct _GdkVisual;

// tag-_GladeXML
// file /usr/include/libglade-2.0/glade/glade-xml.h line 37
struct _GladeXML;

// tag-_GladeXMLPrivate
// file /usr/include/libglade-2.0/glade/glade-xml.h line 39
struct _GladeXMLPrivate;

// tag-_GtkAccelGroup
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 60
struct _GtkAccelGroup;

// tag-_GtkAccelGroupEntry
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 63
struct _GtkAccelGroupEntry;

// tag-_GtkAccelKey
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 62
struct _GtkAccelKey;

// tag-_GtkAdjustment
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 48
struct _GtkAdjustment;

// tag-_GtkArg
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 48
struct _GtkArg;

// tag-_GtkBin
// file /usr/include/gtk-2.0/gtk/gtkbin.h line 48
struct _GtkBin;

// tag-_GtkButton
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 48
struct _GtkButton;

// tag-_GtkCellEditable
// file /usr/include/gtk-2.0/gtk/gtkcelleditable.h line 37
struct _GtkCellEditable;

// tag-_GtkCellRenderer
// file /usr/include/gtk-2.0/gtk/gtkcellrenderer.h line 55
struct _GtkCellRenderer;

// tag-_GtkCellRendererText
// file /usr/include/gtk-2.0/gtk/gtkcellrenderertext.h line 41
struct _GtkCellRendererText;

// tag-_GtkCheckMenuItem
// file /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h line 48
struct _GtkCheckMenuItem;

// tag-_GtkComboBox
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 40
struct _GtkComboBox;

// tag-_GtkComboBoxEntry
// file /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h line 41
struct _GtkComboBoxEntry;

// tag-_GtkComboBoxEntryPrivate
// file /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h line 43
struct _GtkComboBoxEntryPrivate;

// tag-_GtkComboBoxPrivate
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 42
struct _GtkComboBoxPrivate;

// tag-_GtkContainer
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 51
struct _GtkContainer;

// tag-_GtkDialog
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 94
struct _GtkDialog;

// tag-_GtkEntry
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 63
struct _GtkEntry;

// tag-_GtkFileChooser
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 37
struct _GtkFileChooser;

// tag-_GtkFileFilter
// file /usr/include/gtk-2.0/gtk/gtkfilefilter.h line 36
struct _GtkFileFilter;

// tag-_GtkHScale
// file /usr/include/gtk-2.0/gtk/gtkhscale.h line 48
struct _GtkHScale;

// tag-_GtkIMContext
// file /usr/include/gtk-2.0/gtk/gtkimcontext.h line 42
struct _GtkIMContext;

// tag-_GtkItem
// file /usr/include/gtk-2.0/gtk/gtkitem.h line 48
struct _GtkItem;

// tag-_GtkLabel
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 49
struct _GtkLabel;

// tag-_GtkLabelSelectionInfo
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 52
struct _GtkLabelSelectionInfo;

// tag-_GtkListStore
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 42
struct _GtkListStore;

// tag-_GtkMenuItem
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 48
struct _GtkMenuItem;

// tag-_GtkMisc
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 48
struct _GtkMisc;

// tag-_GtkObject
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 49
struct _GtkObject;

// tag-_GtkRange
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 53
struct _GtkRange;

// tag-_GtkRangeLayout
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 50
struct _GtkRangeLayout;

// tag-_GtkRangeStepTimer
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 51
struct _GtkRangeStepTimer;

// tag-_GtkRcStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 57
struct _GtkRcStyle;

// tag-_GtkRequisition
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 478
struct _GtkRequisition;

// tag-_GtkScale
// file /usr/include/gtk-2.0/gtk/gtkscale.h line 48
struct _GtkScale;

// tag-_GtkScrolledWindow
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 52
struct _GtkScrolledWindow;

// tag-_GtkSpinButton
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 71
struct _GtkSpinButton;

// tag-_GtkStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 54
struct _GtkStyle;

// tag-_GtkTooltip
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 484
struct _GtkTooltip;

// tag-_GtkTreeIter
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 43
struct _GtkTreeIter;

// tag-_GtkTreeModel
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 46
struct _GtkTreeModel;

// tag-_GtkTreePath
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 44
struct _GtkTreePath;

// tag-_GtkTreeSelection
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 58
struct _GtkTreeSelection;

// tag-_GtkTreeStore
// file /usr/include/gtk-2.0/gtk/gtktreestore.h line 43
struct _GtkTreeStore;

// tag-_GtkTreeView
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 55
struct _GtkTreeView;

// tag-_GtkTreeViewColumn
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 52
struct _GtkTreeViewColumn;

// tag-_GtkTreeViewPrivate
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 57
struct _GtkTreeViewPrivate;

// tag-_GtkWidget
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 69
struct _GtkWidget;

// tag-_GtkWindow
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 485
struct _GtkWindow;

// tag-_GtkWindowGeometryInfo
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 50
struct _GtkWindowGeometryInfo;

// tag-_GtkWindowGroup
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 51
struct _GtkWindowGroup;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_LingotAudioHandler
// file lingot-audio.h line 39
struct _LingotAudioHandler;

// tag-_LingotAudioSystemProperties
// file lingot-audio.h line 79
struct _LingotAudioSystemProperties;

// tag-_LingotComplex
// file lingot-complex.h line 31
struct _LingotComplex;

// tag-_LingotConfig
// file lingot-config.h line 38
struct _LingotConfig;

// tag-_LingotConfigDialog
// file lingot-gui-config-dialog.h line 30
struct _LingotConfigDialog;

// tag-_LingotCore
// file lingot-core.h line 35
struct _LingotCore;

// tag-_LingotFilter
// file lingot-filter.h line 35
struct _LingotFilter;

// tag-_LingotGauge
// file lingot-gauge.h line 33
struct _LingotGauge;

// tag-_LingotMainFrame
// file lingot-defs.h line 49
struct _LingotMainFrame;

// tag-_LingotScale
// file lingot-config-scale.h line 28
struct _LingotScale;

// tag-_PangoAttrList
// file /usr/include/pango-1.0/pango/pango-attributes.h line 111
struct _PangoAttrList;

// tag-_PangoColor
// file /usr/include/pango-1.0/pango/pango-attributes.h line 32
struct _PangoColor;

// tag-_PangoFontDescription
// file /usr/include/pango-1.0/pango/pango-font.h line 40
struct _PangoFontDescription;

// tag-_PangoLayout
// file /usr/include/pango-1.0/pango/pango-layout.h line 32
struct _PangoLayout;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_cairo_font_options
// file /usr/include/cairo/cairo.h line 1366
struct _cairo_font_options;

// tag-_jack_client
// file /usr/include/jack/types.h line 72
struct _jack_client;

// tag-_jack_port
// file /usr/include/jack/types.h line 66
struct _jack_port;

// tag-_snd_pcm
// file /usr/include/alsa/pcm.h line 354
struct _snd_pcm;

// tag-_snd_pcm_access
// file /usr/include/alsa/pcm.h line 108
enum _snd_pcm_access { SND_PCM_ACCESS_MMAP_INTERLEAVED=0, SND_PCM_ACCESS_MMAP_NONINTERLEAVED=1, SND_PCM_ACCESS_MMAP_COMPLEX=2, SND_PCM_ACCESS_RW_INTERLEAVED=3, SND_PCM_ACCESS_RW_NONINTERLEAVED=4, SND_PCM_ACCESS_LAST=4 };

// tag-_snd_pcm_format
// file /usr/include/alsa/pcm.h line 123
enum _snd_pcm_format { SND_PCM_FORMAT_UNKNOWN=-1, SND_PCM_FORMAT_S8=0, SND_PCM_FORMAT_U8=1, SND_PCM_FORMAT_S16_LE=2, SND_PCM_FORMAT_S16_BE=3, SND_PCM_FORMAT_U16_LE=4, SND_PCM_FORMAT_U16_BE=5, SND_PCM_FORMAT_S24_LE=6, SND_PCM_FORMAT_S24_BE=7, SND_PCM_FORMAT_U24_LE=8, SND_PCM_FORMAT_U24_BE=9, SND_PCM_FORMAT_S32_LE=10, SND_PCM_FORMAT_S32_BE=11, SND_PCM_FORMAT_U32_LE=12, SND_PCM_FORMAT_U32_BE=13, SND_PCM_FORMAT_FLOAT_LE=14, SND_PCM_FORMAT_FLOAT_BE=15, SND_PCM_FORMAT_FLOAT64_LE=16, SND_PCM_FORMAT_FLOAT64_BE=17, SND_PCM_FORMAT_IEC958_SUBFRAME_LE=18, SND_PCM_FORMAT_IEC958_SUBFRAME_BE=19, SND_PCM_FORMAT_MU_LAW=20, SND_PCM_FORMAT_A_LAW=21, SND_PCM_FORMAT_IMA_ADPCM=22, SND_PCM_FORMAT_MPEG=23, SND_PCM_FORMAT_GSM=24, SND_PCM_FORMAT_SPECIAL=31, SND_PCM_FORMAT_S24_3LE=32, SND_PCM_FORMAT_S24_3BE=33, SND_PCM_FORMAT_U24_3LE=34, SND_PCM_FORMAT_U24_3BE=35, SND_PCM_FORMAT_S20_3LE=36, SND_PCM_FORMAT_S20_3BE=37, SND_PCM_FORMAT_U20_3LE=38, SND_PCM_FORMAT_U20_3BE=39, SND_PCM_FORMAT_S18_3LE=40, SND_PCM_FORMAT_S18_3BE=41, SND_PCM_FORMAT_U18_3LE=42, SND_PCM_FORMAT_U18_3BE=43, SND_PCM_FORMAT_G723_24=44, SND_PCM_FORMAT_G723_24_1B=45, SND_PCM_FORMAT_G723_40=46, SND_PCM_FORMAT_G723_40_1B=47, SND_PCM_FORMAT_DSD_U8=48, SND_PCM_FORMAT_DSD_U16_LE=49, SND_PCM_FORMAT_DSD_U32_LE=50, SND_PCM_FORMAT_DSD_U16_BE=51, SND_PCM_FORMAT_DSD_U32_BE=52, SND_PCM_FORMAT_LAST=52, SND_PCM_FORMAT_S16=2, SND_PCM_FORMAT_U16=4, SND_PCM_FORMAT_S24=6, SND_PCM_FORMAT_U24=8, SND_PCM_FORMAT_S32=10, SND_PCM_FORMAT_U32=12, SND_PCM_FORMAT_FLOAT=14, SND_PCM_FORMAT_FLOAT64=16, SND_PCM_FORMAT_IEC958_SUBFRAME=18 };

// tag-_snd_pcm_hw_params
// file /usr/include/alsa/pcm.h line 62
struct _snd_pcm_hw_params;

// tag-_snd_pcm_stream
// file /usr/include/alsa/pcm.h line 99
enum _snd_pcm_stream { SND_PCM_STREAM_PLAYBACK=0, SND_PCM_STREAM_CAPTURE=1, SND_PCM_STREAM_LAST=1 };

// tag-audio_system_t
// file lingot-config.h line 29
enum audio_system_t { AUDIO_SYSTEM_OSS=0, AUDIO_SYSTEM_ALSA=1, AUDIO_SYSTEM_JACK=2 };

// tag-message_type_t
// file lingot-msg.h line 29
enum message_type_t { ERROR=0, WARNING=1, INFO=2 };

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-window_type_t
// file lingot-config.h line 33
enum window_type_t { NONE=0, RECTANGULAR=1, HANNING=2, HAMMING=3 };

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __isnan
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 230
extern signed int __isnan(double);
// __isnanf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 230
extern signed int __isnanf(float);
// __isnanl
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 230
extern signed int __isnanl(long double);
// _lingot_fft_fft
// file lingot-fft.c line 63
void _lingot_fft_fft(double *in, struct _LingotComplex *out, unsigned long int N, unsigned long int offset, unsigned long int d1, unsigned long int step);
// asinh
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 90
extern double asinh(double);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// audio_system_t_to_str
// file lingot-config.c line 52
const char * audio_system_t_to_str(enum audio_system_t audio_system);
// bind_textdomain_codeset
// file /usr/include/libintl.h line 91
extern char * bind_textdomain_codeset(const char *, const char *);
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// ceil
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 178
extern double ceil(double);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// cos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern double cos(double);
// cosh
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 72
extern double cosh(double);
// fabs
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 181
extern double fabs(double);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// floor
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 184
extern double floor(double);
// fmod
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 187
extern double fmod(double, double);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_list_foreach
// file /usr/include/glib-2.0/glib/glist.h line 132
extern void g_list_foreach(struct _GList *, void (*)(void *, void *), void *);
// g_list_free
// file /usr/include/glib-2.0/glib/glist.h line 51
extern void g_list_free(struct _GList *);
// g_markup_printf_escaped
// file /usr/include/glib-2.0/glib/gmarkup.h line 232
extern char * g_markup_printf_escaped(const char *, ...);
// g_object_get_data
// file /usr/include/glib-2.0/gobject/gobject.h line 551
extern void * g_object_get_data(struct _GObject *, const char *);
// g_object_set
// file /usr/include/glib-2.0/gobject/gobject.h line 432
extern void g_object_set(void *, const char *, ...);
// g_object_set_data
// file /usr/include/glib-2.0/gobject/gobject.h line 554
extern void g_object_set_data(struct _GObject *, const char *, void *);
// g_object_unref
// file /usr/include/glib-2.0/gobject/gobject.h line 480
extern void g_object_unref(void *);
// g_signal_connect_data
// file /usr/include/glib-2.0/gobject/gsignal.h line 388
extern unsigned long int g_signal_connect_data(void *, const char *, void (*)(void), void *, void (*)(void *, struct _GClosure *), enum anonymous$17);
// g_signal_emit_by_name
// file /usr/include/glib-2.0/gobject/gsignal.h line 327
extern void g_signal_emit_by_name(void *, const char *, ...);
// g_snprintf
// file /usr/include/glib-2.0/glib/gutils.h line 201
extern signed int g_snprintf(char *, unsigned long int, const char *, ...);
// g_source_remove
// file /usr/include/glib-2.0/glib/gmain.h line 545
extern signed int g_source_remove(unsigned int);
// g_string_free
// file /usr/include/glib-2.0/glib/gstring.h line 56
extern char * g_string_free(struct _GString *, signed int);
// g_string_new
// file /usr/include/glib-2.0/glib/gstring.h line 49
extern struct _GString * g_string_new(const char *);
// g_string_printf
// file /usr/include/glib-2.0/glib/gstring.h line 140
extern void g_string_printf(struct _GString *, const char *, ...);
// g_timeout_add
// file /usr/include/glib-2.0/glib/gmain.h line 560
extern unsigned int g_timeout_add(unsigned int, signed int (*)(void *), void *);
// g_type_check_instance_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2168
extern struct _GTypeInstance * g_type_check_instance_cast(struct _GTypeInstance *, unsigned long int);
// gdk_color_alloc
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 154
signed int gdk_color_alloc(struct _GdkColormap *, struct _GdkColor *);
// gdk_color_black
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 152
signed int gdk_color_black(struct _GdkColormap *, struct _GdkColor *);
// gdk_colormap_get_system
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 100
struct _GdkColormap * gdk_colormap_get_system(void);
// gdk_draw_drawable
// file /usr/include/gtk-2.0/gdk/gdkdrawable.h line 326
void gdk_draw_drawable(struct _GdkDrawable *, struct _GdkGC *, struct _GdkDrawable *, signed int, signed int, signed int, signed int, signed int, signed int);
// gdk_draw_layout
// file /usr/include/gtk-2.0/gdk/gdkdrawable.h line 380
void gdk_draw_layout(struct _GdkDrawable *, struct _GdkGC *, signed int, signed int, struct _PangoLayout *);
// gdk_draw_line
// file /usr/include/gtk-2.0/gdk/gdkdrawable.h line 279
void gdk_draw_line(struct _GdkDrawable *, struct _GdkGC *, signed int, signed int, signed int, signed int);
// gdk_draw_rectangle
// file /usr/include/gtk-2.0/gdk/gdkdrawable.h line 285
void gdk_draw_rectangle(struct _GdkDrawable *, struct _GdkGC *, signed int, signed int, signed int, signed int, signed int);
// gdk_flush
// file /usr/include/gtk-2.0/gdk/gdk.h line 143
void gdk_flush(void);
// gdk_gc_get_values
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 233
void gdk_gc_get_values(struct _GdkGC *, struct _GdkGCValues *);
// gdk_gc_set_foreground
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 238
void gdk_gc_set_foreground(struct _GdkGC *, const struct _GdkColor *);
// gdk_pixbuf_new_from_xpm_data
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 310
struct _GdkPixbuf * gdk_pixbuf_new_from_xpm_data(const char **);
// gdk_pixmap_create_from_xpm_d
// file /usr/include/gtk-2.0/gdk/gdkpixmap.h line 95
struct _GdkDrawable * gdk_pixmap_create_from_xpm_d(struct _GdkDrawable *, struct _GdkDrawable **, const struct _GdkColor *, char **);
// gdk_pixmap_new
// file /usr/include/gtk-2.0/gdk/gdkpixmap.h line 69
struct _GdkDrawable * gdk_pixmap_new(struct _GdkDrawable *, signed int, signed int, signed int);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// gettext
// file /usr/include/libintl.h line 39
extern char * gettext(const char *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// glade_xml_get_widget
// file /usr/include/libglade-2.0/glade/glade-xml.h line 112
struct _GtkWidget * glade_xml_get_widget(struct _GladeXML *, const char *);
// glade_xml_new
// file /usr/include/libglade-2.0/glade/glade-xml.h line 59
struct _GladeXML * glade_xml_new(const char *, const char *, const char *);
// gtk_accel_group_new
// file /usr/include/gtk-2.0/gtk/gtkaccelgroup.h line 123
struct _GtkAccelGroup * gtk_accel_group_new(void);
// gtk_adjustment_get_value
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 92
double gtk_adjustment_get_value(struct _GtkAdjustment *);
// gtk_bin_get_type
// file /usr/include/gtk-2.0/gtk/gtkbin.h line 64
unsigned long int gtk_bin_get_type(void);
// gtk_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 91
unsigned long int gtk_button_get_type(void);
// gtk_cell_renderer_text_new
// file /usr/include/gtk-2.0/gtk/gtkcellrenderertext.h line 97
struct _GtkCellRenderer * gtk_cell_renderer_text_new(void);
// gtk_check_menu_item_get_active
// file /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h line 84
signed int gtk_check_menu_item_get_active(struct _GtkCheckMenuItem *);
// gtk_check_menu_item_get_type
// file /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h line 77
unsigned long int gtk_check_menu_item_get_type(void);
// gtk_check_menu_item_set_active
// file /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h line 82
void gtk_check_menu_item_set_active(struct _GtkCheckMenuItem *, signed int);
// gtk_combo_box_append_text
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 132
void gtk_combo_box_append_text(struct _GtkComboBox *, const char *);
// gtk_combo_box_entry_get_type
// file /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h line 65
unsigned long int gtk_combo_box_entry_get_type(void);
// gtk_combo_box_get_active_text
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 141
char * gtk_combo_box_get_active_text(struct _GtkComboBox *);
// gtk_combo_box_get_model
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 111
struct _GtkTreeModel * gtk_combo_box_get_model(struct _GtkComboBox *);
// gtk_combo_box_get_type
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 70
unsigned long int gtk_combo_box_get_type(void);
// gtk_combo_box_set_active_iter
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 105
void gtk_combo_box_set_active_iter(struct _GtkComboBox *, struct _GtkTreeIter *);
// gtk_container_add
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 111
void gtk_container_add(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_get_type
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 107
unsigned long int gtk_container_get_type(void);
// gtk_dialog_get_type
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 127
unsigned long int gtk_dialog_get_type(void);
// gtk_dialog_run
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 175
signed int gtk_dialog_run(struct _GtkDialog *);
// gtk_entry_get_text
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 216
const char * gtk_entry_get_text(struct _GtkEntry *);
// gtk_entry_get_type
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 166
unsigned long int gtk_entry_get_type(void);
// gtk_entry_set_text
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 213
void gtk_entry_set_text(struct _GtkEntry *, const char *);
// gtk_file_chooser_add_filter
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 232
void gtk_file_chooser_add_filter(struct _GtkFileChooser *, struct _GtkFileFilter *);
// gtk_file_chooser_dialog_new
// file /usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h line 57
struct _GtkWidget * gtk_file_chooser_dialog_new(const char *, struct _GtkWindow *, enum anonymous$7, const char *, ...);
// gtk_file_chooser_get_current_folder
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 175
char * gtk_file_chooser_get_current_folder(struct _GtkFileChooser *);
// gtk_file_chooser_get_filename
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 163
char * gtk_file_chooser_get_filename(struct _GtkFileChooser *);
// gtk_file_chooser_get_type
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 88
unsigned long int gtk_file_chooser_get_type(void);
// gtk_file_chooser_set_current_folder
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 173
signed int gtk_file_chooser_set_current_folder(struct _GtkFileChooser *, const char *);
// gtk_file_chooser_set_current_name
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 143
void gtk_file_chooser_set_current_name(struct _GtkFileChooser *, const char *);
// gtk_file_chooser_set_do_overwrite_confirmation
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 133
void gtk_file_chooser_set_do_overwrite_confirmation(struct _GtkFileChooser *, signed int);
// gtk_file_chooser_set_show_hidden
// file /usr/include/gtk-2.0/gtk/gtkfilechooser.h line 129
void gtk_file_chooser_set_show_hidden(struct _GtkFileChooser *, signed int);
// gtk_file_filter_add_pattern
// file /usr/include/gtk-2.0/gtk/gtkfilefilter.h line 68
void gtk_file_filter_add_pattern(struct _GtkFileFilter *, const char *);
// gtk_file_filter_new
// file /usr/include/gtk-2.0/gtk/gtkfilefilter.h line 61
struct _GtkFileFilter * gtk_file_filter_new(void);
// gtk_file_filter_set_name
// file /usr/include/gtk-2.0/gtk/gtkfilefilter.h line 62
void gtk_file_filter_set_name(struct _GtkFileFilter *, const char *);
// gtk_hscale_get_type
// file /usr/include/gtk-2.0/gtk/gtkhscale.h line 62
unsigned long int gtk_hscale_get_type(void);
// gtk_icon_theme_add_builtin_icon
// file /usr/include/gtk-2.0/gtk/gtkicontheme.h line 166
void gtk_icon_theme_add_builtin_icon(const char *, signed int, struct _GdkPixbuf *);
// gtk_init
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 94
void gtk_init(signed int *, char ***);
// gtk_label_get_type
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 109
unsigned long int gtk_label_get_type(void);
// gtk_label_set_markup
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 121
void gtk_label_set_markup(struct _GtkLabel *, const char *);
// gtk_label_set_text
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 112
void gtk_label_set_text(struct _GtkLabel *, const char *);
// gtk_list_store_clear
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 128
void gtk_list_store_clear(struct _GtkListStore *);
// gtk_list_store_get_type
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 77
unsigned long int gtk_list_store_get_type(void);
// gtk_main
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 145
void gtk_main(void);
// gtk_main_quit
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 147
void gtk_main_quit(void);
// gtk_message_dialog_new
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 101
struct _GtkWidget * gtk_message_dialog_new(struct _GtkWindow *, enum anonymous$22, enum anonymous$23, enum anonymous$21, const char *, ...);
// gtk_object_get_type
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 146
unsigned long int gtk_object_get_type(void);
// gtk_range_get_type
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 136
unsigned long int gtk_range_get_type(void);
// gtk_range_get_value
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 185
double gtk_range_get_value(struct _GtkRange *);
// gtk_range_set_value
// file /usr/include/gtk-2.0/gtk/gtkrange.h line 183
void gtk_range_set_value(struct _GtkRange *, double);
// gtk_scrolled_window_get_hadjustment
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 109
struct _GtkAdjustment * gtk_scrolled_window_get_hadjustment(struct _GtkScrolledWindow *);
// gtk_scrolled_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 102
unsigned long int gtk_scrolled_window_get_type(void);
// gtk_scrolled_window_set_policy
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 113
void gtk_scrolled_window_set_policy(struct _GtkScrolledWindow *, enum anonymous$31, enum anonymous$31);
// gtk_set_locale
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 132
char * gtk_set_locale(void);
// gtk_show_about_dialog
// file /usr/include/gtk-2.0/gtk/gtkaboutdialog.h line 75
void gtk_show_about_dialog(struct _GtkWindow *, const char *, ...);
// gtk_signal_connect_full
// file /usr/include/gtk-2.0/gtk/gtksignal.h line 121
unsigned long int gtk_signal_connect_full(struct _GtkObject *, const char *, void (*)(void), void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *), void *, void (*)(void *), signed int, signed int);
// gtk_spin_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 123
unsigned long int gtk_spin_button_get_type(void);
// gtk_spin_button_get_value
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 161
double gtk_spin_button_get_value(struct _GtkSpinButton *);
// gtk_spin_button_get_value_as_int
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 163
signed int gtk_spin_button_get_value_as_int(struct _GtkSpinButton *);
// gtk_spin_button_set_value
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 165
void gtk_spin_button_set_value(struct _GtkSpinButton *, double);
// gtk_tooltip_set_text
// file /usr/include/gtk-2.0/gtk/gtktooltip.h line 41
void gtk_tooltip_set_text(struct _GtkTooltip *, const char *);
// gtk_tree_model_get
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 234
void gtk_tree_model_get(struct _GtkTreeModel *, struct _GtkTreeIter *, ...);
// gtk_tree_model_get_iter
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 198
signed int gtk_tree_model_get_iter(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreePath *);
// gtk_tree_model_get_iter_first
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 206
signed int gtk_tree_model_get_iter_first(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_get_type
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 190
unsigned long int gtk_tree_model_get_type(void);
// gtk_tree_model_iter_n_children
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 221
signed int gtk_tree_model_iter_n_children(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_iter_next
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 214
signed int gtk_tree_model_iter_next(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_path_free
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 139
void gtk_tree_path_free(struct _GtkTreePath *);
// gtk_tree_path_new_from_string
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 126
struct _GtkTreePath * gtk_tree_path_new_from_string(const char *);
// gtk_tree_path_to_string
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 129
char * gtk_tree_path_to_string(struct _GtkTreePath *);
// gtk_tree_selection_count_selected_rows
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 97
signed int gtk_tree_selection_count_selected_rows(struct _GtkTreeSelection *);
// gtk_tree_selection_get_selected_rows
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 95
struct _GList * gtk_tree_selection_get_selected_rows(struct _GtkTreeSelection *, struct _GtkTreeModel **);
// gtk_tree_selection_set_mode
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 78
void gtk_tree_selection_set_mode(struct _GtkTreeSelection *, enum anonymous$6);
// gtk_tree_store_append
// file /usr/include/gtk-2.0/gtk/gtktreestore.h line 131
void gtk_tree_store_append(struct _GtkTreeStore *, struct _GtkTreeIter *, struct _GtkTreeIter *);
// gtk_tree_store_clear
// file /usr/include/gtk-2.0/gtk/gtktreestore.h line 139
void gtk_tree_store_clear(struct _GtkTreeStore *);
// gtk_tree_store_get_type
// file /usr/include/gtk-2.0/gtk/gtktreestore.h line 76
unsigned long int gtk_tree_store_get_type(void);
// gtk_tree_store_insert_before
// file /usr/include/gtk-2.0/gtk/gtktreestore.h line 108
void gtk_tree_store_insert_before(struct _GtkTreeStore *, struct _GtkTreeIter *, struct _GtkTreeIter *, struct _GtkTreeIter *);
// gtk_tree_store_new
// file /usr/include/gtk-2.0/gtk/gtktreestore.h line 77
struct _GtkTreeStore * gtk_tree_store_new(signed int, ...);
// gtk_tree_store_remove
// file /usr/include/gtk-2.0/gtk/gtktreestore.h line 102
signed int gtk_tree_store_remove(struct _GtkTreeStore *, struct _GtkTreeIter *);
// gtk_tree_store_set
// file /usr/include/gtk-2.0/gtk/gtktreestore.h line 91
void gtk_tree_store_set(struct _GtkTreeStore *, struct _GtkTreeIter *, ...);
// gtk_tree_view_append_column
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 167
signed int gtk_tree_view_append_column(struct _GtkTreeView *, struct _GtkTreeViewColumn *);
// gtk_tree_view_column_get_type
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 126
unsigned long int gtk_tree_view_column_get_type(void);
// gtk_tree_view_column_new
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 127
struct _GtkTreeViewColumn * gtk_tree_view_column_new(void);
// gtk_tree_view_column_pack_start
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 131
void gtk_tree_view_column_pack_start(struct _GtkTreeViewColumn *, struct _GtkCellRenderer *, signed int);
// gtk_tree_view_column_set_attributes
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 145
void gtk_tree_view_column_set_attributes(struct _GtkTreeViewColumn *, struct _GtkCellRenderer *, ...);
// gtk_tree_view_column_set_cell_data_func
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 148
void gtk_tree_view_column_set_cell_data_func(struct _GtkTreeViewColumn *, struct _GtkCellRenderer *, void (*)(struct _GtkTreeViewColumn *, struct _GtkCellRenderer *, struct _GtkTreeModel *, struct _GtkTreeIter *, void *), void *, void (*)(void *));
// gtk_tree_view_column_set_title
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 183
void gtk_tree_view_column_set_title(struct _GtkTreeViewColumn *, const char *);
// gtk_tree_view_get_columns
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 188
struct _GList * gtk_tree_view_get_columns(struct _GtkTreeView *);
// gtk_tree_view_get_model
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 145
struct _GtkTreeModel * gtk_tree_view_get_model(struct _GtkTreeView *);
// gtk_tree_view_get_path_at_pos
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 246
signed int gtk_tree_view_get_path_at_pos(struct _GtkTreeView *, signed int, signed int, struct _GtkTreePath **, struct _GtkTreeViewColumn **, signed int *, signed int *);
// gtk_tree_view_get_selection
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 148
struct _GtkTreeSelection * gtk_tree_view_get_selection(struct _GtkTreeView *);
// gtk_tree_view_get_type
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 140
unsigned long int gtk_tree_view_get_type(void);
// gtk_tree_view_new
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 141
struct _GtkWidget * gtk_tree_view_new(void);
// gtk_tree_view_set_model
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 146
void gtk_tree_view_set_model(struct _GtkTreeView *, struct _GtkTreeModel *);
// gtk_widget_add_accelerator
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 892
void gtk_widget_add_accelerator(struct _GtkWidget *, const char *, struct _GtkAccelGroup *, unsigned int, enum anonymous$24, enum anonymous$1);
// gtk_widget_create_pango_layout
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1189
struct _PangoLayout * gtk_widget_create_pango_layout(struct _GtkWidget *, const char *);
// gtk_widget_destroy
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 837
void gtk_widget_destroy(struct _GtkWidget *);
// gtk_widget_get_type
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 833
unsigned long int gtk_widget_get_type(void);
// gtk_widget_queue_draw
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 864
void gtk_widget_queue_draw(struct _GtkWidget *);
// gtk_widget_set_has_tooltip
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1304
void gtk_widget_set_has_tooltip(struct _GtkWidget *, signed int);
// gtk_widget_set_sensitive
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 964
void gtk_widget_set_sensitive(struct _GtkWidget *, signed int);
// gtk_widget_set_size_request
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1027
void gtk_widget_set_size_request(struct _GtkWidget *, signed int, signed int);
// gtk_widget_set_visible
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 969
void gtk_widget_set_visible(struct _GtkWidget *, signed int);
// gtk_widget_show
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 851
void gtk_widget_show(struct _GtkWidget *);
// gtk_widget_show_all
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 854
void gtk_widget_show_all(struct _GtkWidget *);
// gtk_window_add_accel_group
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 191
void gtk_window_add_accel_group(struct _GtkWindow *, struct _GtkAccelGroup *);
// gtk_window_get_icon
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 292
struct _GdkPixbuf * gtk_window_get_icon(struct _GtkWindow *);
// gtk_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 178
unsigned long int gtk_window_get_type(void);
// gtk_window_present
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 330
void gtk_window_present(struct _GtkWindow *);
// gtk_window_set_icon
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 285
void gtk_window_set_icon(struct _GtkWindow *, struct _GdkPixbuf *);
// gtk_window_set_title
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 180
void gtk_window_set_title(struct _GtkWindow *, const char *);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// jack_activate
// file /usr/include/jack/jack.h line 183
signed int jack_activate(struct _jack_client *);
// jack_client_close
// file /usr/include/jack/jack.h line 104
signed int jack_client_close(struct _jack_client *);
// jack_client_open
// file /usr/include/jack/jack.h line 88
struct _jack_client * jack_client_open(const char *, enum JackOptions, enum JackStatus *, ...);
// jack_connect
// file /usr/include/jack/jack.h line 848
signed int jack_connect(struct _jack_client *, const char *, const char *);
// jack_deactivate
// file /usr/include/jack/jack.h line 192
signed int jack_deactivate(struct _jack_client *);
// jack_get_buffer_size
// file /usr/include/jack/jack.h line 565
unsigned int jack_get_buffer_size(struct _jack_client *);
// jack_get_client_name
// file /usr/include/jack/jack.h line 118
char * jack_get_client_name(struct _jack_client *);
// jack_get_ports
// file /usr/include/jack/jack.h line 1137
const char ** jack_get_ports(struct _jack_client *, const char *, const char *, unsigned long int);
// jack_get_sample_rate
// file /usr/include/jack/jack.h line 554
unsigned int jack_get_sample_rate(struct _jack_client *);
// jack_on_shutdown
// file /usr/include/jack/jack.h line 300
void jack_on_shutdown(struct _jack_client *, void (*)(void *), void *);
// jack_port_by_name
// file /usr/include/jack/jack.h line 1147
struct _jack_port * jack_port_by_name(struct _jack_client *, const char *);
// jack_port_connected
// file /usr/include/jack/jack.h line 695
signed int jack_port_connected(const struct _jack_port *);
// jack_port_get_buffer
// file /usr/include/jack/jack.h line 649
void * jack_port_get_buffer(struct _jack_port *, unsigned int);
// jack_port_name
// file /usr/include/jack/jack.h line 657
const char * jack_port_name(const struct _jack_port *);
// jack_port_register
// file /usr/include/jack/jack.h line 624
struct _jack_port * jack_port_register(struct _jack_client *, const char *, const char *, unsigned long int, unsigned long int);
// jack_set_process_callback
// file /usr/include/jack/jack.h line 342
signed int jack_set_process_callback(struct _jack_client *, signed int (*)(unsigned int, void *), void *);
// lingot_audio_alsa_destroy
// file lingot-audio-alsa.h line 29
void lingot_audio_alsa_destroy(struct _LingotAudioHandler *audio);
// lingot_audio_alsa_get_audio_system_properties
// file lingot-audio-alsa.h line 31
struct _LingotAudioSystemProperties * lingot_audio_alsa_get_audio_system_properties(enum audio_system_t audio_system);
// lingot_audio_alsa_new
// file lingot-audio-alsa.h line 28
struct _LingotAudioHandler * lingot_audio_alsa_new(char *device, signed int sample_rate);
// lingot_audio_alsa_read
// file lingot-audio-alsa.h line 30
signed int lingot_audio_alsa_read(struct _LingotAudioHandler *audio);
// lingot_audio_audio_system_properties_destroy
// file lingot-audio.c line 138
void lingot_audio_audio_system_properties_destroy(struct _LingotAudioSystemProperties *properties);
// lingot_audio_destroy
// file lingot-audio.c line 68
void lingot_audio_destroy(struct _LingotAudioHandler *audio);
// lingot_audio_get_audio_system_properties
// file lingot-audio.c line 115
struct _LingotAudioSystemProperties * lingot_audio_get_audio_system_properties(enum audio_system_t audio_system);
// lingot_audio_jack_destroy
// file lingot-audio-jack.h line 29
void lingot_audio_jack_destroy(struct _LingotAudioHandler *audio);
// lingot_audio_jack_get_audio_system_properties
// file lingot-audio-jack.h line 31
struct _LingotAudioSystemProperties * lingot_audio_jack_get_audio_system_properties(enum audio_system_t audio_system);
// lingot_audio_jack_new
// file lingot-audio-jack.h line 28
struct _LingotAudioHandler * lingot_audio_jack_new(char *device, signed int sample_rate);
// lingot_audio_jack_process
// file lingot-audio-jack.c line 42
signed int lingot_audio_jack_process(unsigned int nframes, void *param);
// lingot_audio_jack_read
// file lingot-audio-jack.c line 149
signed int lingot_audio_jack_read(struct _LingotAudioHandler *audio);
// lingot_audio_jack_shutdown
// file lingot-audio-jack.c line 59
void lingot_audio_jack_shutdown(void *param);
// lingot_audio_jack_start
// file lingot-audio-jack.h line 33
signed int lingot_audio_jack_start(struct _LingotAudioHandler *audio);
// lingot_audio_jack_stop
// file lingot-audio-jack.h line 34
void lingot_audio_jack_stop(struct _LingotAudioHandler *audio);
// lingot_audio_new
// file lingot-audio.c line 35
struct _LingotAudioHandler * lingot_audio_new(enum audio_system_t audio_system, char *device, signed int sample_rate, void (*process_callback)(double *, signed int, void *), void *process_callback_arg);
// lingot_audio_new::process_callback$object
// 
void process_callback$object(double *, signed int, void *);
// lingot_audio_oss_destroy
// file lingot-audio-oss.h line 29
void lingot_audio_oss_destroy(struct _LingotAudioHandler *audio);
// lingot_audio_oss_get_audio_system_properties
// file lingot-audio-oss.h line 31
struct _LingotAudioSystemProperties * lingot_audio_oss_get_audio_system_properties(enum audio_system_t audio_system);
// lingot_audio_oss_new
// file lingot-audio-oss.h line 28
struct _LingotAudioHandler * lingot_audio_oss_new(char *device, signed int sample_rate);
// lingot_audio_oss_read
// file lingot-audio-oss.h line 30
signed int lingot_audio_oss_read(struct _LingotAudioHandler *audio);
// lingot_audio_read
// file lingot-audio.c line 92
signed int lingot_audio_read(struct _LingotAudioHandler *audio);
// lingot_audio_run_reading_thread
// file lingot-audio.c line 152
void lingot_audio_run_reading_thread(struct _LingotAudioHandler *audio);
// lingot_audio_start
// file lingot-audio.c line 170
signed int lingot_audio_start(struct _LingotAudioHandler *audio);
// lingot_audio_stop
// file lingot-audio.c line 193
void lingot_audio_stop(struct _LingotAudioHandler *audio);
// lingot_complex_add
// file lingot-complex.h line 39
void lingot_complex_add(struct _LingotComplex *a, struct _LingotComplex *b, struct _LingotComplex *c);
// lingot_complex_div
// file lingot-complex.c line 59
void lingot_complex_div(struct _LingotComplex *a, struct _LingotComplex *b, struct _LingotComplex *c);
// lingot_complex_mul
// file lingot-complex.h line 41
void lingot_complex_mul(struct _LingotComplex *a, struct _LingotComplex *b, struct _LingotComplex *c);
// lingot_complex_sub
// file lingot-complex.h line 40
void lingot_complex_sub(struct _LingotComplex *a, struct _LingotComplex *b, struct _LingotComplex *c);
// lingot_config_copy
// file lingot-config.c line 89
void lingot_config_copy(struct _LingotConfig *dst, struct _LingotConfig *src);
// lingot_config_destroy
// file lingot-config.c line 83
void lingot_config_destroy(struct _LingotConfig *config);
// lingot_config_load
// file lingot-config.c line 251
void lingot_config_load(struct _LingotConfig *config, char *filename);
// lingot_config_new
// file lingot-config.c line 73
struct _LingotConfig * lingot_config_new();
// lingot_config_restore_default_values
// file lingot-config.c line 98
void lingot_config_restore_default_values(struct _LingotConfig *config);
// lingot_config_save
// file lingot-config.c line 175
void lingot_config_save(struct _LingotConfig *config, char *filename);
// lingot_config_scale_allocate
// file lingot-config-scale.h line 44
void lingot_config_scale_allocate(struct _LingotScale *scale, unsigned short int notes);
// lingot_config_scale_copy
// file lingot-config-scale.h line 49
void lingot_config_scale_copy(struct _LingotScale *dst, struct _LingotScale *src);
// lingot_config_scale_destroy
// file lingot-config-scale.h line 45
void lingot_config_scale_destroy(struct _LingotScale *scale);
// lingot_config_scale_format_shift
// file lingot-config-scale.h line 48
void lingot_config_scale_format_shift(char *char_buffer, double cents, signed short int numerator, signed short int denominator);
// lingot_config_scale_load_scl
// file lingot-config-scale.c line 186
signed int lingot_config_scale_load_scl(struct _LingotScale *scale, char *filename);
// lingot_config_scale_new
// file lingot-config-scale.h line 43
struct _LingotScale * lingot_config_scale_new();
// lingot_config_scale_parse_shift
// file lingot-config-scale.h line 47
signed int lingot_config_scale_parse_shift(char *char_buffer, double *cents, signed short int *numerator, signed short int *denominator);
// lingot_config_scale_restore_default_values
// file lingot-config-scale.h line 50
void lingot_config_scale_restore_default_values(struct _LingotScale *scale);
// lingot_config_update_internal_params
// file lingot-config.c line 130
void lingot_config_update_internal_params(struct _LingotConfig *config);
// lingot_core_compute_fundamental_fequency
// file lingot-core.c line 338
void lingot_core_compute_fundamental_fequency(struct _LingotCore *core);
// lingot_core_destroy
// file lingot-core.c line 196
void lingot_core_destroy(struct _LingotCore *core);
// lingot_core_new
// file lingot-core.c line 49
struct _LingotCore * lingot_core_new(struct _LingotConfig *conf);
// lingot_core_read_callback
// file lingot-core.c line 240
signed int lingot_core_read_callback(double *read_buffer, signed int read_buffer_size, void *arg);
// lingot_core_run_computation_thread
// file lingot-core.c line 509
void lingot_core_run_computation_thread(struct _LingotCore *core);
// lingot_core_start
// file lingot-core.c line 461
void lingot_core_start(struct _LingotCore *core);
// lingot_core_stop
// file lingot-core.c line 484
void lingot_core_stop(struct _LingotCore *core);
// lingot_fft_create_phase_factors
// file lingot-fft.c line 41
void lingot_fft_create_phase_factors(struct _LingotConfig *conf);
// lingot_fft_destroy_phase_factors
// file lingot-fft.c line 54
void lingot_fft_destroy_phase_factors();
// lingot_fft_fft
// file lingot-fft.c line 97
void lingot_fft_fft(double *in, struct _LingotComplex *out, unsigned long int N);
// lingot_fft_spd
// file lingot-fft.c line 109
void lingot_fft_spd(double *in, signed int N1, double wi, double dw, double *out, signed int N2);
// lingot_fft_spd_diffs
// file lingot-fft.c line 136
void lingot_fft_spd_diffs(double *in, signed int N, double w, double *out_d1, double *out_d2);
// lingot_filter_cheby_design
// file lingot-filter.h line 55
struct _LingotFilter * lingot_filter_cheby_design(unsigned int n, double Rp, double wc);
// lingot_filter_destroy
// file lingot-filter.h line 57
void lingot_filter_destroy(struct _LingotFilter *filter);
// lingot_filter_filter
// file lingot-filter.h line 60
void lingot_filter_filter(struct _LingotFilter *filter, unsigned int n, double *in, double *out);
// lingot_filter_filter_sample
// file lingot-filter.h line 63
double lingot_filter_filter_sample(struct _LingotFilter *filter, double in);
// lingot_filter_new
// file lingot-filter.h line 49
struct _LingotFilter * lingot_filter_new(unsigned int Na, unsigned int Nb, double *a, double *b);
// lingot_filter_vector_product
// file lingot-filter.c line 98
void lingot_filter_vector_product(signed int n, struct _LingotComplex *vector, struct _LingotComplex *result);
// lingot_gauge_compute
// file lingot-gauge.h line 43
void lingot_gauge_compute(struct _LingotGauge *gauge, double sample);
// lingot_gauge_destroy
// file lingot-gauge.h line 42
void lingot_gauge_destroy(struct _LingotGauge *gauge);
// lingot_gauge_new
// file lingot-gauge.h line 41
struct _LingotGauge * lingot_gauge_new(double initial_position);
// lingot_gui_config_dialog_apply
// file lingot-gui-config-dialog.c line 260
signed int lingot_gui_config_dialog_apply(struct _LingotConfigDialog *dialog);
// lingot_gui_config_dialog_callback_button_apply
// file lingot-gui-config-dialog.c line 66
void lingot_gui_config_dialog_callback_button_apply(struct _GtkButton *button, struct _LingotConfigDialog *dialog);
// lingot_gui_config_dialog_callback_button_cancel
// file lingot-gui-config-dialog.c line 49
void lingot_gui_config_dialog_callback_button_cancel(struct _GtkButton *button, struct _LingotConfigDialog *dialog);
// lingot_gui_config_dialog_callback_button_default
// file lingot-gui-config-dialog.c line 73
void lingot_gui_config_dialog_callback_button_default(struct _GtkButton *button, struct _LingotConfigDialog *dialog);
// lingot_gui_config_dialog_callback_button_ok
// file lingot-gui-config-dialog.c line 54
void lingot_gui_config_dialog_callback_button_ok(struct _GtkButton *button, struct _LingotConfigDialog *dialog);
// lingot_gui_config_dialog_callback_cancel
// file lingot-gui-config-dialog.c line 79
void lingot_gui_config_dialog_callback_cancel(struct _GtkWidget *widget, struct _LingotConfigDialog *dialog);
// lingot_gui_config_dialog_callback_change_deviation
// file lingot-gui-config-dialog.c line 165
void lingot_gui_config_dialog_callback_change_deviation(struct _GtkWidget *widget, struct _LingotConfigDialog *dialog);
// lingot_gui_config_dialog_callback_change_input_system
// file lingot-gui-config-dialog.c line 118
void lingot_gui_config_dialog_callback_change_input_system(struct _GtkWidget *widget, struct _LingotConfigDialog *dialog);
// lingot_gui_config_dialog_callback_change_sample_rate
// file lingot-gui-config-dialog.c line 92
void lingot_gui_config_dialog_callback_change_sample_rate(struct _GtkWidget *widget, struct _LingotConfigDialog *dialog);
// lingot_gui_config_dialog_callback_close
// file lingot-gui-config-dialog.c line 85
void lingot_gui_config_dialog_callback_close(struct _GtkWidget *widget, struct _LingotConfigDialog *dialog);
// lingot_gui_config_dialog_close
// file lingot-gui-config-dialog.c line 318
void lingot_gui_config_dialog_close(struct _LingotConfigDialog *dialog);
// lingot_gui_config_dialog_combo_select_value
// file lingot-gui-config-dialog.c line 195
void lingot_gui_config_dialog_combo_select_value(struct _GtkWidget *combo, signed int value);
// lingot_gui_config_dialog_destroy
// file lingot-gui-config-dialog.c line 253
void lingot_gui_config_dialog_destroy(struct _LingotConfigDialog *dialog);
// lingot_gui_config_dialog_get_audio_system
// file lingot-gui-config-dialog.c line 188
enum audio_system_t lingot_gui_config_dialog_get_audio_system(struct _GtkComboBox *combo);
// lingot_gui_config_dialog_import_scl
// file lingot-gui-config-dialog-scale.c line 509
void lingot_gui_config_dialog_import_scl(void *data, struct _LingotConfigDialog *config_dialog);
// lingot_gui_config_dialog_rewrite
// file lingot-gui-config-dialog.c line 212
void lingot_gui_config_dialog_rewrite(struct _LingotConfigDialog *dialog);
// lingot_gui_config_dialog_scale_apply
// file lingot-gui-config-dialog-scale.h line 40
void lingot_gui_config_dialog_scale_apply(struct _LingotConfigDialog *dialog, struct _LingotScale *scale);
// lingot_gui_config_dialog_scale_key_press_cb
// file lingot-gui-config-dialog-scale.c line 552
signed int lingot_gui_config_dialog_scale_key_press_cb(struct _GtkWidget *widget, struct _GdkEventKey *kevent, void *data);
// lingot_gui_config_dialog_scale_rewrite
// file lingot-gui-config-dialog-scale.h line 44
void lingot_gui_config_dialog_scale_rewrite(struct _LingotConfigDialog *dialog, struct _LingotScale *scale);
// lingot_gui_config_dialog_scale_show
// file lingot-gui-config-dialog-scale.h line 33
void lingot_gui_config_dialog_scale_show(struct _LingotConfigDialog *dialog, struct _GladeXML *_gladeXML);
// lingot_gui_config_dialog_scale_table_query_tooltip
// file lingot-gui-config-dialog-scale.c line 588
signed int lingot_gui_config_dialog_scale_table_query_tooltip(struct _GtkWidget *widget, signed int x, signed int y, signed int keyboard_mode, struct _GtkTooltip *tooltip, void *user_data);
// lingot_gui_config_dialog_scale_tree_add_column
// file lingot-gui-config-dialog-scale.c line 314
void lingot_gui_config_dialog_scale_tree_add_column(struct _LingotConfigDialog *config_dialog);
// lingot_gui_config_dialog_scale_tree_add_row_tree
// file lingot-gui-config-dialog-scale.c line 37
void lingot_gui_config_dialog_scale_tree_add_row_tree(void *data, struct _GtkTreeView *treeview);
// lingot_gui_config_dialog_scale_tree_cell_edited_callback
// file lingot-gui-config-dialog-scale.c line 142
void lingot_gui_config_dialog_scale_tree_cell_edited_callback(struct _GtkCellRendererText *cell, char *path_string, char *new_text, void *user_data);
// lingot_gui_config_dialog_scale_tree_frequency_cell_data_function
// file lingot-gui-config-dialog-scale.c line 293
void lingot_gui_config_dialog_scale_tree_frequency_cell_data_function(struct _GtkTreeViewColumn *col, struct _GtkCellRenderer *renderer, struct _GtkTreeModel *model, struct _GtkTreeIter *iter, void *user_data);
// lingot_gui_config_dialog_scale_tree_remove_selected_items
// file lingot-gui-config-dialog-scale.c line 99
void lingot_gui_config_dialog_scale_tree_remove_selected_items(void *data, struct _GtkTreeView *treeview);
// lingot_gui_config_dialog_scale_tree_view_column_get_index
// file lingot-gui-config-dialog-scale.c line 569
signed int lingot_gui_config_dialog_scale_tree_view_column_get_index(struct _GtkTreeViewColumn *column);
// lingot_gui_config_dialog_scale_validate
// file lingot-gui-config-dialog-scale.h line 36
signed int lingot_gui_config_dialog_scale_validate(struct _LingotConfigDialog *dialog, struct _LingotScale *scale);
// lingot_gui_config_dialog_set_audio_system
// file lingot-gui-config-dialog.c line 170
void lingot_gui_config_dialog_set_audio_system(struct _GtkComboBox *combo, enum audio_system_t audio_system);
// lingot_gui_config_dialog_show
// file lingot-gui-config-dialog.c line 323
void lingot_gui_config_dialog_show(struct _LingotMainFrame *frame, struct _LingotConfig *config);
// lingot_gui_mainframe_callback_about
// file lingot-gui-mainframe.c line 86
void lingot_gui_mainframe_callback_about(struct _GtkWidget *w, struct _LingotMainFrame *frame);
// lingot_gui_mainframe_callback_config_dialog
// file lingot-gui-mainframe.c line 115
void lingot_gui_mainframe_callback_config_dialog(struct _GtkWidget *w, struct _LingotMainFrame *frame);
// lingot_gui_mainframe_callback_destroy
// file lingot-gui-mainframe.c line 79
void lingot_gui_mainframe_callback_destroy(struct _GtkWidget *w, struct _LingotMainFrame *frame);
// lingot_gui_mainframe_callback_error_dispatcher
// file lingot-gui-mainframe.c line 223
signed int lingot_gui_mainframe_callback_error_dispatcher(void *data);
// lingot_gui_mainframe_callback_gauge_computation
// file lingot-gui-mainframe.c line 200
signed int lingot_gui_mainframe_callback_gauge_computation(void *data);
// lingot_gui_mainframe_callback_open_config
// file lingot-gui-mainframe.c line 263
void lingot_gui_mainframe_callback_open_config(void *data, struct _LingotMainFrame *frame);
// lingot_gui_mainframe_callback_redraw
// file lingot-gui-mainframe.c line 74
void lingot_gui_mainframe_callback_redraw(struct _GtkWidget *w, struct _GdkEventExpose *e, struct _LingotMainFrame *frame);
// lingot_gui_mainframe_callback_save_config
// file lingot-gui-mainframe.c line 303
void lingot_gui_mainframe_callback_save_config(void *data, struct _LingotMainFrame *frame);
// lingot_gui_mainframe_callback_tout_spectrum_computation_display
// file lingot-gui-mainframe.c line 182
signed int lingot_gui_mainframe_callback_tout_spectrum_computation_display(void *data);
// lingot_gui_mainframe_callback_tout_visualization
// file lingot-gui-mainframe.c line 167
signed int lingot_gui_mainframe_callback_tout_visualization(void *data);
// lingot_gui_mainframe_callback_view_spectrum
// file lingot-gui-mainframe.c line 108
void lingot_gui_mainframe_callback_view_spectrum(struct _GtkWidget *w, struct _LingotMainFrame *frame);
// lingot_gui_mainframe_change_config
// file lingot-gui-mainframe.h line 79
void lingot_gui_mainframe_change_config(struct _LingotMainFrame *frame, struct _LingotConfig *conf);
// lingot_gui_mainframe_color
// file lingot-gui-mainframe.c line 340
void lingot_gui_mainframe_color(struct _GdkColor *color, signed int red, signed int green, signed int blue);
// lingot_gui_mainframe_create
// file lingot-gui-mainframe.c line 346
void lingot_gui_mainframe_create(signed int argc, char **argv);
// lingot_gui_mainframe_destroy
// file lingot-gui-mainframe.c line 504
void lingot_gui_mainframe_destroy(struct _LingotMainFrame *frame);
// lingot_gui_mainframe_draw_gauge
// file lingot-gui-mainframe.c line 527
void lingot_gui_mainframe_draw_gauge(struct _LingotMainFrame *frame);
// lingot_gui_mainframe_draw_spectrum_and_labels
// file lingot-gui-mainframe.c line 574
void lingot_gui_mainframe_draw_spectrum_and_labels(struct _LingotMainFrame *frame);
// lingot_gui_mainframe_get_closest_note_index
// file lingot-gui-mainframe.c line 120
unsigned short int lingot_gui_mainframe_get_closest_note_index(double freq, struct _LingotScale *scale, double deviation, double *error_cents);
// lingot_gui_mainframe_redraw
// file lingot-gui-mainframe.c line 520
void lingot_gui_mainframe_redraw(struct _LingotMainFrame *frame);
// lingot_map_parameters
// file lingot-config.c line 160
void lingot_map_parameters(struct _LingotConfig *config, void **params);
// lingot_msg_add
// file lingot-msg.c line 50
void lingot_msg_add(const char *msg, enum message_type_t type);
// lingot_msg_add_error
// file lingot-msg.h line 35
void lingot_msg_add_error(const char *msg);
// lingot_msg_add_info
// file lingot-msg.c line 46
void lingot_msg_add_info(const char *msg);
// lingot_msg_add_warning
// file lingot-msg.h line 36
void lingot_msg_add_warning(const char *msg);
// lingot_msg_get
// file lingot-msg.c line 77
signed int lingot_msg_get(char **msg, enum message_type_t *type);
// lingot_signal_get_fundamental_peak
// file lingot-signal.h line 43
signed int lingot_signal_get_fundamental_peak(struct _LingotConfig *conf, double *x, double *d2x, signed int N);
// lingot_signal_get_max
// file lingot-signal.h line 40
void lingot_signal_get_max(double *x, signed int N, signed int *Mi);
// lingot_signal_get_noise_threshold
// file lingot-signal.c line 31
double lingot_signal_get_noise_threshold(struct _LingotConfig *conf, double w);
// lingot_signal_is_peak
// file lingot-signal.c line 58
signed int lingot_signal_is_peak(struct _LingotConfig *conf, double *x, signed int index);
// lingot_signal_window
// file lingot-signal.h line 46
void lingot_signal_window(signed int N, double *out, enum window_type_t window_type);
// log10
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 112
extern double log10(double);
// log2
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 144
extern double log2(double);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// pango_font_description_from_string
// file /usr/include/pango-1.0/pango/pango-font.h line 270
struct _PangoFontDescription * pango_font_description_from_string(const char *);
// pango_layout_set_font_description
// file /usr/include/pango-1.0/pango/pango-layout.h line 164
void pango_layout_set_font_description(struct _PangoLayout *, const struct _PangoFontDescription *);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$3 *, const union anonymous$4 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$3 *, union anonymous *, struct timespec *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous *, const union anonymous$4 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// rint
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 279
extern double rint(double);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// sin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
extern double sin(double);
// sinh
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 74
extern double sinh(double);
// snd_config_update_free_global
// file /usr/include/alsa/conf.h line 95
signed int snd_config_update_free_global(void);
// snd_pcm_close
// file /usr/include/alsa/pcm.h line 459
signed int snd_pcm_close(struct _snd_pcm *);
// snd_pcm_hw_params
// file /usr/include/alsa/pcm.h line 473
signed int snd_pcm_hw_params(struct _snd_pcm *, struct _snd_pcm_hw_params *);
// snd_pcm_hw_params_any
// file /usr/include/alsa/pcm.h line 657
signed int snd_pcm_hw_params_any(struct _snd_pcm *, struct _snd_pcm_hw_params *);
// snd_pcm_hw_params_free
// file /usr/include/alsa/pcm.h line 711
void snd_pcm_hw_params_free(struct _snd_pcm_hw_params *);
// snd_pcm_hw_params_malloc
// file /usr/include/alsa/pcm.h line 710
signed int snd_pcm_hw_params_malloc(struct _snd_pcm_hw_params **);
// snd_pcm_hw_params_set_access
// file /usr/include/alsa/pcm.h line 718
signed int snd_pcm_hw_params_set_access(struct _snd_pcm *, struct _snd_pcm_hw_params *, enum _snd_pcm_access);
// snd_pcm_hw_params_set_channels
// file /usr/include/alsa/pcm.h line 744
signed int snd_pcm_hw_params_set_channels(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int);
// snd_pcm_hw_params_set_format
// file /usr/include/alsa/pcm.h line 726
signed int snd_pcm_hw_params_set_format(struct _snd_pcm *, struct _snd_pcm_hw_params *, enum _snd_pcm_format);
// snd_pcm_hw_params_set_rate_near
// file /usr/include/alsa/pcm.h line 760
signed int snd_pcm_hw_params_set_rate_near(struct _snd_pcm *, struct _snd_pcm_hw_params *, unsigned int *, signed int *);
// snd_pcm_open
// file /usr/include/alsa/pcm.h line 450
signed int snd_pcm_open(struct _snd_pcm **, const char *, enum _snd_pcm_stream, signed int);
// snd_pcm_prepare
// file /usr/include/alsa/pcm.h line 477
signed int snd_pcm_prepare(struct _snd_pcm *);
// snd_pcm_readi
// file /usr/include/alsa/pcm.h line 497
signed long int snd_pcm_readi(struct _snd_pcm *, void *, unsigned long int);
// snd_strerror
// file /usr/include/alsa/error.h line 45
const char * snd_strerror(signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// str_to_audio_system_t
// file lingot-config.c line 58
enum audio_system_t str_to_audio_system_t(char *audio_system);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// tan
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 67
extern double tan(double);
// textdomain
// file /usr/include/libintl.h line 82
extern char * textdomain(const char *);

struct anonymous$14
{
  // f
  void (*f)(void);
  // d
  void *d;
};

struct anonymous$2
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous$4
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$13
{
  // v_int
  signed int v_int;
  // v_uint
  unsigned int v_uint;
  // v_long
  signed long int v_long;
  // v_ulong
  unsigned long int v_ulong;
  // v_int64
  signed long int v_int64;
  // v_uint64
  unsigned long int v_uint64;
  // v_float
  float v_float;
  // v_double
  double v_double;
  // v_pointer
  void *v_pointer;
};

union anonymous$15
{
  // char_data
  char char_data;
  // uchar_data
  unsigned char uchar_data;
  // bool_data
  signed int bool_data;
  // int_data
  signed int int_data;
  // uint_data
  unsigned int uint_data;
  // long_data
  signed long int long_data;
  // ulong_data
  unsigned long int ulong_data;
  // float_data
  float float_data;
  // double_data
  double double_data;
  // string_data
  char *string_data;
  // object_data
  struct _GtkObject *object_data;
  // pointer_data
  void *pointer_data;
  // signal_data
  struct anonymous$14 signal_data;
};

union anonymous$3
{
  // __data
  struct anonymous$2 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _GArray
{
  // data
  char *data;
  // len
  unsigned int len;
};

struct _GClosure
{
  // ref_count
  volatile unsigned int ref_count : 15;
  // meta_marshal_nouse
  volatile unsigned int meta_marshal_nouse : 1;
  // n_guards
  volatile unsigned int n_guards : 1;
  // n_fnotifiers
  volatile unsigned int n_fnotifiers : 2;
  // n_inotifiers
  volatile unsigned int n_inotifiers : 8;
  // in_inotify
  volatile unsigned int in_inotify : 1;
  // floating
  volatile unsigned int floating : 1;
  // derivative_flag
  volatile unsigned int derivative_flag : 1;
  // in_marshal
  volatile unsigned int in_marshal : 1;
  // is_invalid
  volatile unsigned int is_invalid : 1;
  // marshal
  void (*marshal)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
  // data
  void *data;
  // notifiers
  struct _GClosureNotifyData *notifiers;
};

struct _GClosureNotifyData
{
  // data
  void *data;
  // notify
  void (*notify)(void *, struct _GClosure *);
};

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _GSList
{
  // data
  void *data;
  // next
  struct _GSList *next;
};

struct _GString
{
  // str
  char *str;
  // len
  unsigned long int len;
  // allocated_len
  unsigned long int allocated_len;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _GValue
{
  // g_type
  unsigned long int g_type;
  // data
  union anonymous$13 data[2l];
};

struct _GdkColor
{
  // pixel
  unsigned int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
};

struct _GdkColormap
{
  // parent_instance
  struct _GObject parent_instance;
  // size
  signed int size;
  // colors
  struct _GdkColor *colors;
  // visual
  struct _GdkVisual *visual;
  // windowing_data
  void *windowing_data;
};

struct _GdkDrawable
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GdkRectangle
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventExpose
{
  // type
  enum anonymous$18 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // area
  struct _GdkRectangle area;
  // region
  struct _GdkRegion *region;
  // count
  signed int count;
};

struct _GdkEventKey
{
  // type
  enum anonymous$18 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // state
  unsigned int state;
  // keyval
  unsigned int keyval;
  // length
  signed int length;
  // string
  char *string;
  // hardware_keycode
  unsigned short int hardware_keycode;
  // group
  unsigned char group;
  // is_modifier
  unsigned int is_modifier : 1;
};

struct _GdkFont
{
  // type
  enum anonymous$20 type;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct _GdkGC
{
  // parent_instance
  struct _GObject parent_instance;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // colormap
  struct _GdkColormap *colormap;
};

struct _GdkGCValues
{
  // foreground
  struct _GdkColor foreground;
  // background
  struct _GdkColor background;
  // font
  struct _GdkFont *font;
  // function
  enum anonymous$25 function;
  // fill
  enum anonymous$26 fill;
  // tile
  struct _GdkDrawable *tile;
  // stipple
  struct _GdkDrawable *stipple;
  // clip_mask
  struct _GdkDrawable *clip_mask;
  // subwindow_mode
  enum anonymous$27 subwindow_mode;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // graphics_exposures
  signed int graphics_exposures;
  // line_width
  signed int line_width;
  // line_style
  enum anonymous$28 line_style;
  // cap_style
  enum anonymous$29 cap_style;
  // join_style
  enum anonymous$30 join_style;
};

struct _GdkScreen
{
  // parent_instance
  struct _GObject parent_instance;
  // closed
  unsigned int closed : 1;
  // normal_gcs
  struct _GdkGC *normal_gcs[32l];
  // exposure_gcs
  struct _GdkGC *exposure_gcs[32l];
  // subwindow_gcs
  struct _GdkGC *subwindow_gcs[32l];
  // font_options
  struct _cairo_font_options *font_options;
  // resolution
  double resolution;
};

struct _GdkVisual
{
  // parent_instance
  struct _GObject parent_instance;
  // type
  enum anonymous$9 type;
  // depth
  signed int depth;
  // byte_order
  enum anonymous$19 byte_order;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
  // red_mask
  unsigned int red_mask;
  // red_shift
  signed int red_shift;
  // red_prec
  signed int red_prec;
  // green_mask
  unsigned int green_mask;
  // green_shift
  signed int green_shift;
  // green_prec
  signed int green_prec;
  // blue_mask
  unsigned int blue_mask;
  // blue_shift
  signed int blue_shift;
  // blue_prec
  signed int blue_prec;
};

struct _GladeXML
{
  // parent
  struct _GObject parent;
  // filename
  char *filename;
  // priv
  struct _GladeXMLPrivate *priv;
};

struct _GtkAccelGroup
{
  // parent
  struct _GObject parent;
  // lock_count
  unsigned int lock_count;
  // modifier_mask
  enum anonymous$24 modifier_mask;
  // acceleratables
  struct _GSList *acceleratables;
  // n_accels
  unsigned int n_accels;
  // priv_accels
  struct _GtkAccelGroupEntry *priv_accels;
};

struct _GtkAccelKey
{
  // accel_key
  unsigned int accel_key;
  // accel_mods
  enum anonymous$24 accel_mods;
  // accel_flags
  unsigned int accel_flags : 16;
};

struct _GtkAccelGroupEntry
{
  // key
  struct _GtkAccelKey key;
  // closure
  struct _GClosure *closure;
  // accel_path_quark
  unsigned int accel_path_quark;
};

struct _GtkObject
{
  // parent_instance
  struct _GObject parent_instance;
  // flags
  unsigned int flags;
};

struct _GtkAdjustment
{
  // parent_instance
  struct _GtkObject parent_instance;
  // lower
  double lower;
  // upper
  double upper;
  // value
  double value;
  // step_increment
  double step_increment;
  // page_increment
  double page_increment;
  // page_size
  double page_size;
};

struct _GtkArg
{
  // type
  unsigned long int type;
  // name
  char *name;
  // d
  union anonymous$15 d;
};

struct _GtkRequisition
{
  // width
  signed int width;
  // height
  signed int height;
};

struct _GtkWidget
{
  // object
  struct _GtkObject object;
  // private_flags
  unsigned short int private_flags;
  // state
  unsigned char state;
  // saved_state
  unsigned char saved_state;
  // name
  char *name;
  // style
  struct _GtkStyle *style;
  // requisition
  struct _GtkRequisition requisition;
  // allocation
  struct _GdkRectangle allocation;
  // window
  struct _GdkDrawable *window;
  // parent
  struct _GtkWidget *parent;
};

struct _GtkContainer
{
  // widget
  struct _GtkWidget widget;
  // focus_child
  struct _GtkWidget *focus_child;
  // border_width
  unsigned int border_width : 16;
  // need_resize
  unsigned int need_resize : 1;
  // resize_mode
  unsigned int resize_mode : 2;
  // reallocate_redraws
  unsigned int reallocate_redraws : 1;
  // has_focus_chain
  unsigned int has_focus_chain : 1;
};

struct _GtkBin
{
  // container
  struct _GtkContainer container;
  // child
  struct _GtkWidget *child;
};

struct _GtkButton
{
  // bin
  struct _GtkBin bin;
  // event_window
  struct _GdkDrawable *event_window;
  // label_text
  char *label_text;
  // activate_timeout
  unsigned int activate_timeout;
  // constructed
  unsigned int constructed : 1;
  // in_button
  unsigned int in_button : 1;
  // button_down
  unsigned int button_down : 1;
  // relief
  unsigned int relief : 2;
  // use_underline
  unsigned int use_underline : 1;
  // use_stock
  unsigned int use_stock : 1;
  // depressed
  unsigned int depressed : 1;
  // depress_on_activate
  unsigned int depress_on_activate : 1;
  // focus_on_click
  unsigned int focus_on_click : 1;
};

struct _GtkCellRenderer
{
  // parent
  struct _GtkObject parent;
  // xalign
  float xalign;
  // yalign
  float yalign;
  // width
  signed int width;
  // height
  signed int height;
  // xpad
  unsigned short int xpad;
  // ypad
  unsigned short int ypad;
  // mode
  unsigned int mode : 2;
  // visible
  unsigned int visible : 1;
  // is_expander
  unsigned int is_expander : 1;
  // is_expanded
  unsigned int is_expanded : 1;
  // cell_background_set
  unsigned int cell_background_set : 1;
  // sensitive
  unsigned int sensitive : 1;
  // editing
  unsigned int editing : 1;
};

struct _PangoColor
{
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
};

struct _GtkCellRendererText
{
  // parent
  struct _GtkCellRenderer parent;
  // text
  char *text;
  // font
  struct _PangoFontDescription *font;
  // font_scale
  double font_scale;
  // foreground
  struct _PangoColor foreground;
  // background
  struct _PangoColor background;
  // extra_attrs
  struct _PangoAttrList *extra_attrs;
  // underline_style
  enum anonymous$10 underline_style;
  // rise
  signed int rise;
  // fixed_height_rows
  signed int fixed_height_rows;
  // strikethrough
  unsigned int strikethrough : 1;
  // editable
  unsigned int editable : 1;
  // scale_set
  unsigned int scale_set : 1;
  // foreground_set
  unsigned int foreground_set : 1;
  // background_set
  unsigned int background_set : 1;
  // underline_set
  unsigned int underline_set : 1;
  // rise_set
  unsigned int rise_set : 1;
  // strikethrough_set
  unsigned int strikethrough_set : 1;
  // editable_set
  unsigned int editable_set : 1;
  // calc_fixed_height
  unsigned int calc_fixed_height : 1;
};

struct _GtkItem
{
  // bin
  struct _GtkBin bin;
};

struct _GtkMenuItem
{
  // item
  struct _GtkItem item;
  // submenu
  struct _GtkWidget *submenu;
  // event_window
  struct _GdkDrawable *event_window;
  // toggle_size
  unsigned short int toggle_size;
  // accelerator_width
  unsigned short int accelerator_width;
  // accel_path
  char *accel_path;
  // show_submenu_indicator
  unsigned int show_submenu_indicator : 1;
  // submenu_placement
  unsigned int submenu_placement : 1;
  // submenu_direction
  unsigned int submenu_direction : 1;
  // right_justify
  unsigned int right_justify : 1;
  // timer_from_keypress
  unsigned int timer_from_keypress : 1;
  // from_menubar
  unsigned int from_menubar : 1;
  // timer
  unsigned int timer;
};

struct _GtkCheckMenuItem
{
  // menu_item
  struct _GtkMenuItem menu_item;
  // active
  unsigned int active : 1;
  // always_show_toggle
  unsigned int always_show_toggle : 1;
  // inconsistent
  unsigned int inconsistent : 1;
  // draw_as_radio
  unsigned int draw_as_radio : 1;
};

struct _GtkComboBox
{
  // parent_instance
  struct _GtkBin parent_instance;
  // priv
  struct _GtkComboBoxPrivate *priv;
};

struct _GtkComboBoxEntry
{
  // parent_instance
  struct _GtkComboBox parent_instance;
  // priv
  struct _GtkComboBoxEntryPrivate *priv;
};

struct _GtkWindow
{
  // bin
  struct _GtkBin bin;
  // title
  char *title;
  // wmclass_name
  char *wmclass_name;
  // wmclass_class
  char *wmclass_class;
  // wm_role
  char *wm_role;
  // focus_widget
  struct _GtkWidget *focus_widget;
  // default_widget
  struct _GtkWidget *default_widget;
  // transient_parent
  struct _GtkWindow *transient_parent;
  // geometry_info
  struct _GtkWindowGeometryInfo *geometry_info;
  // frame
  struct _GdkDrawable *frame;
  // group
  struct _GtkWindowGroup *group;
  // configure_request_count
  unsigned short int configure_request_count;
  // allow_shrink
  unsigned int allow_shrink : 1;
  // allow_grow
  unsigned int allow_grow : 1;
  // configure_notify_received
  unsigned int configure_notify_received : 1;
  // need_default_position
  unsigned int need_default_position : 1;
  // need_default_size
  unsigned int need_default_size : 1;
  // position
  unsigned int position : 3;
  // type
  unsigned int type : 4;
  // has_user_ref_count
  unsigned int has_user_ref_count : 1;
  // has_focus
  unsigned int has_focus : 1;
  // modal
  unsigned int modal : 1;
  // destroy_with_parent
  unsigned int destroy_with_parent : 1;
  // has_frame
  unsigned int has_frame : 1;
  // iconify_initially
  unsigned int iconify_initially : 1;
  // stick_initially
  unsigned int stick_initially : 1;
  // maximize_initially
  unsigned int maximize_initially : 1;
  // decorated
  unsigned int decorated : 1;
  // type_hint
  unsigned int type_hint : 3;
  // gravity
  unsigned int gravity : 5;
  // is_active
  unsigned int is_active : 1;
  // has_toplevel_focus
  unsigned int has_toplevel_focus : 1;
  // frame_left
  unsigned int frame_left;
  // frame_top
  unsigned int frame_top;
  // frame_right
  unsigned int frame_right;
  // frame_bottom
  unsigned int frame_bottom;
  // keys_changed_handler
  unsigned int keys_changed_handler;
  // mnemonic_modifier
  enum anonymous$24 mnemonic_modifier;
  // screen
  struct _GdkScreen *screen;
};

struct _GtkDialog
{
  // window
  struct _GtkWindow window;
  // vbox
  struct _GtkWidget *vbox;
  // action_area
  struct _GtkWidget *action_area;
  // separator
  struct _GtkWidget *separator;
};

struct _GtkEntry
{
  // widget
  struct _GtkWidget widget;
  // text
  char *text;
  // editable
  unsigned int editable : 1;
  // visible
  unsigned int visible : 1;
  // overwrite_mode
  unsigned int overwrite_mode : 1;
  // in_drag
  unsigned int in_drag : 1;
  // text_length
  unsigned short int text_length;
  // text_max_length
  unsigned short int text_max_length;
  // text_area
  struct _GdkDrawable *text_area;
  // im_context
  struct _GtkIMContext *im_context;
  // popup_menu
  struct _GtkWidget *popup_menu;
  // current_pos
  signed int current_pos;
  // selection_bound
  signed int selection_bound;
  // cached_layout
  struct _PangoLayout *cached_layout;
  // cache_includes_preedit
  unsigned int cache_includes_preedit : 1;
  // need_im_reset
  unsigned int need_im_reset : 1;
  // has_frame
  unsigned int has_frame : 1;
  // activates_default
  unsigned int activates_default : 1;
  // cursor_visible
  unsigned int cursor_visible : 1;
  // in_click
  unsigned int in_click : 1;
  // is_cell_renderer
  unsigned int is_cell_renderer : 1;
  // editing_canceled
  unsigned int editing_canceled : 1;
  // mouse_cursor_obscured
  unsigned int mouse_cursor_obscured : 1;
  // select_words
  unsigned int select_words : 1;
  // select_lines
  unsigned int select_lines : 1;
  // resolved_dir
  unsigned int resolved_dir : 4;
  // truncate_multiline
  unsigned int truncate_multiline : 1;
  // button
  unsigned int button;
  // blink_timeout
  unsigned int blink_timeout;
  // recompute_idle
  unsigned int recompute_idle;
  // scroll_offset
  signed int scroll_offset;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
  // x_text_size
  unsigned short int x_text_size;
  // x_n_bytes
  unsigned short int x_n_bytes;
  // preedit_length
  unsigned short int preedit_length;
  // preedit_cursor
  unsigned short int preedit_cursor;
  // dnd_position
  signed int dnd_position;
  // drag_start_x
  signed int drag_start_x;
  // drag_start_y
  signed int drag_start_y;
  // invisible_char
  unsigned int invisible_char;
  // width_chars
  signed int width_chars;
};

struct _GtkRange
{
  // widget
  struct _GtkWidget widget;
  // adjustment
  struct _GtkAdjustment *adjustment;
  // update_policy
  enum anonymous$12 update_policy;
  // inverted
  unsigned int inverted : 1;
  // flippable
  unsigned int flippable : 1;
  // has_stepper_a
  unsigned int has_stepper_a : 1;
  // has_stepper_b
  unsigned int has_stepper_b : 1;
  // has_stepper_c
  unsigned int has_stepper_c : 1;
  // has_stepper_d
  unsigned int has_stepper_d : 1;
  // need_recalc
  unsigned int need_recalc : 1;
  // slider_size_fixed
  unsigned int slider_size_fixed : 1;
  // min_slider_size
  signed int min_slider_size;
  // orientation
  enum anonymous$11 orientation;
  // range_rect
  struct _GdkRectangle range_rect;
  // slider_start
  signed int slider_start;
  // slider_end
  signed int slider_end;
  // round_digits
  signed int round_digits;
  // trough_click_forward
  unsigned int trough_click_forward : 1;
  // update_pending
  unsigned int update_pending : 1;
  // layout
  struct _GtkRangeLayout *layout;
  // timer
  struct _GtkRangeStepTimer *timer;
  // slide_initial_slider_position
  signed int slide_initial_slider_position;
  // slide_initial_coordinate
  signed int slide_initial_coordinate;
  // update_timeout_id
  unsigned int update_timeout_id;
  // event_window
  struct _GdkDrawable *event_window;
};

struct _GtkScale
{
  // range
  struct _GtkRange range;
  // digits
  signed int digits;
  // draw_value
  unsigned int draw_value : 1;
  // value_pos
  unsigned int value_pos : 2;
};

struct _GtkHScale
{
  // scale
  struct _GtkScale scale;
};

struct _GtkIMContext
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GtkMisc
{
  // widget
  struct _GtkWidget widget;
  // xalign
  float xalign;
  // yalign
  float yalign;
  // xpad
  unsigned short int xpad;
  // ypad
  unsigned short int ypad;
};

struct _GtkLabel
{
  // misc
  struct _GtkMisc misc;
  // label
  char *label;
  // jtype
  unsigned int jtype : 2;
  // wrap
  unsigned int wrap : 1;
  // use_underline
  unsigned int use_underline : 1;
  // use_markup
  unsigned int use_markup : 1;
  // ellipsize
  unsigned int ellipsize : 3;
  // single_line_mode
  unsigned int single_line_mode : 1;
  // have_transform
  unsigned int have_transform : 1;
  // in_click
  unsigned int in_click : 1;
  // wrap_mode
  unsigned int wrap_mode : 3;
  // pattern_set
  unsigned int pattern_set : 1;
  // track_links
  unsigned int track_links : 1;
  // mnemonic_keyval
  unsigned int mnemonic_keyval;
  // text
  char *text;
  // attrs
  struct _PangoAttrList *attrs;
  // effective_attrs
  struct _PangoAttrList *effective_attrs;
  // layout
  struct _PangoLayout *layout;
  // mnemonic_widget
  struct _GtkWidget *mnemonic_widget;
  // mnemonic_window
  struct _GtkWindow *mnemonic_window;
  // select_info
  struct _GtkLabelSelectionInfo *select_info;
};

struct _GtkListStore
{
  // parent
  struct _GObject parent;
  // stamp
  signed int stamp;
  // seq
  void *seq;
  // _gtk_reserved1
  void *_gtk_reserved1;
  // sort_list
  struct _GList *sort_list;
  // n_columns
  signed int n_columns;
  // sort_column_id
  signed int sort_column_id;
  // order
  enum anonymous$5 order;
  // column_headers
  unsigned long int *column_headers;
  // length
  signed int length;
  // default_sort_func
  signed int (*default_sort_func)(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, void *);
  // default_sort_data
  void *default_sort_data;
  // default_sort_destroy
  void (*default_sort_destroy)(void *);
  // columns_dirty
  unsigned int columns_dirty : 1;
};

struct _GtkRcStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // bg_pixmap_name
  char *bg_pixmap_name[5l];
  // font_desc
  struct _PangoFontDescription *font_desc;
  // color_flags
  enum anonymous$0 color_flags[5l];
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // rc_properties
  struct _GArray *rc_properties;
  // rc_style_lists
  struct _GSList *rc_style_lists;
  // icon_factories
  struct _GSList *icon_factories;
  // engine_specified
  unsigned int engine_specified : 1;
};

struct _GtkScrolledWindow
{
  // container
  struct _GtkBin container;
  // hscrollbar
  struct _GtkWidget *hscrollbar;
  // vscrollbar
  struct _GtkWidget *vscrollbar;
  // hscrollbar_policy
  unsigned int hscrollbar_policy : 2;
  // vscrollbar_policy
  unsigned int vscrollbar_policy : 2;
  // hscrollbar_visible
  unsigned int hscrollbar_visible : 1;
  // vscrollbar_visible
  unsigned int vscrollbar_visible : 1;
  // window_placement
  unsigned int window_placement : 2;
  // focus_out
  unsigned int focus_out : 1;
  // shadow_type
  unsigned short int shadow_type;
};

struct _GtkSpinButton
{
  // entry
  struct _GtkEntry entry;
  // adjustment
  struct _GtkAdjustment *adjustment;
  // panel
  struct _GdkDrawable *panel;
  // timer
  unsigned int timer;
  // climb_rate
  double climb_rate;
  // timer_step
  double timer_step;
  // update_policy
  enum anonymous$16 update_policy;
  // in_child
  unsigned int in_child : 2;
  // click_child
  unsigned int click_child : 2;
  // button
  unsigned int button : 2;
  // need_timer
  unsigned int need_timer : 1;
  // timer_calls
  unsigned int timer_calls : 3;
  // digits
  unsigned int digits : 10;
  // numeric
  unsigned int numeric : 1;
  // wrap
  unsigned int wrap : 1;
  // snap_to_ticks
  unsigned int snap_to_ticks : 1;
};

struct _GtkStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // light
  struct _GdkColor light[5l];
  // dark
  struct _GdkColor dark[5l];
  // mid
  struct _GdkColor mid[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // text_aa
  struct _GdkColor text_aa[5l];
  // black
  struct _GdkColor black;
  // white
  struct _GdkColor white;
  // font_desc
  struct _PangoFontDescription *font_desc;
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // fg_gc
  struct _GdkGC *fg_gc[5l];
  // bg_gc
  struct _GdkGC *bg_gc[5l];
  // light_gc
  struct _GdkGC *light_gc[5l];
  // dark_gc
  struct _GdkGC *dark_gc[5l];
  // mid_gc
  struct _GdkGC *mid_gc[5l];
  // text_gc
  struct _GdkGC *text_gc[5l];
  // base_gc
  struct _GdkGC *base_gc[5l];
  // text_aa_gc
  struct _GdkGC *text_aa_gc[5l];
  // black_gc
  struct _GdkGC *black_gc;
  // white_gc
  struct _GdkGC *white_gc;
  // bg_pixmap
  struct _GdkDrawable *bg_pixmap[5l];
  // attach_count
  signed int attach_count;
  // depth
  signed int depth;
  // colormap
  struct _GdkColormap *colormap;
  // private_font
  struct _GdkFont *private_font;
  // private_font_desc
  struct _PangoFontDescription *private_font_desc;
  // rc_style
  struct _GtkRcStyle *rc_style;
  // styles
  struct _GSList *styles;
  // property_cache
  struct _GArray *property_cache;
  // icon_factories
  struct _GSList *icon_factories;
};

struct _GtkTreeIter
{
  // stamp
  signed int stamp;
  // user_data
  void *user_data;
  // user_data2
  void *user_data2;
  // user_data3
  void *user_data3;
};

struct _GtkTreeSelection
{
  // parent
  struct _GObject parent;
  // tree_view
  struct _GtkTreeView *tree_view;
  // type
  enum anonymous$6 type;
  // user_func
  signed int (*user_func)(struct _GtkTreeSelection *, struct _GtkTreeModel *, struct _GtkTreePath *, signed int, void *);
  // user_data
  void *user_data;
  // destroy
  void (*destroy)(void *);
};

struct _GtkTreeStore
{
  // parent
  struct _GObject parent;
  // stamp
  signed int stamp;
  // root
  void *root;
  // last
  void *last;
  // n_columns
  signed int n_columns;
  // sort_column_id
  signed int sort_column_id;
  // sort_list
  struct _GList *sort_list;
  // order
  enum anonymous$5 order;
  // column_headers
  unsigned long int *column_headers;
  // default_sort_func
  signed int (*default_sort_func)(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, void *);
  // default_sort_data
  void *default_sort_data;
  // default_sort_destroy
  void (*default_sort_destroy)(void *);
  // columns_dirty
  unsigned int columns_dirty : 1;
};

struct _GtkTreeView
{
  // parent
  struct _GtkContainer parent;
  // priv
  struct _GtkTreeViewPrivate *priv;
};

struct _GtkTreeViewColumn
{
  // parent
  struct _GtkObject parent;
  // tree_view
  struct _GtkWidget *tree_view;
  // button
  struct _GtkWidget *button;
  // child
  struct _GtkWidget *child;
  // arrow
  struct _GtkWidget *arrow;
  // alignment
  struct _GtkWidget *alignment;
  // window
  struct _GdkDrawable *window;
  // editable_widget
  struct _GtkCellEditable *editable_widget;
  // xalign
  float xalign;
  // property_changed_signal
  unsigned int property_changed_signal;
  // spacing
  signed int spacing;
  // column_type
  enum anonymous$8 column_type;
  // requested_width
  signed int requested_width;
  // button_request
  signed int button_request;
  // resized_width
  signed int resized_width;
  // width
  signed int width;
  // fixed_width
  signed int fixed_width;
  // min_width
  signed int min_width;
  // max_width
  signed int max_width;
  // drag_x
  signed int drag_x;
  // drag_y
  signed int drag_y;
  // title
  char *title;
  // cell_list
  struct _GList *cell_list;
  // sort_clicked_signal
  unsigned int sort_clicked_signal;
  // sort_column_changed_signal
  unsigned int sort_column_changed_signal;
  // sort_column_id
  signed int sort_column_id;
  // sort_order
  enum anonymous$5 sort_order;
  // visible
  unsigned int visible : 1;
  // resizable
  unsigned int resizable : 1;
  // clickable
  unsigned int clickable : 1;
  // dirty
  unsigned int dirty : 1;
  // show_sort_indicator
  unsigned int show_sort_indicator : 1;
  // maybe_reordered
  unsigned int maybe_reordered : 1;
  // reorderable
  unsigned int reorderable : 1;
  // use_resized_width
  unsigned int use_resized_width : 1;
  // expand
  unsigned int expand : 1;
};

struct _GtkWindowGroup
{
  // parent_instance
  struct _GObject parent_instance;
  // grabs
  struct _GSList *grabs;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct _LingotAudioHandler
{
  // audio_system
  signed int audio_system;
  // device
  char device[100l];
  // process_callback
  void (*process_callback)(double *, signed int, void *);
  // process_callback_arg
  void *process_callback_arg;
  // capture_handle
  struct _snd_pcm *capture_handle;
  // dsp
  signed int dsp;
  // read_buffer_size
  signed int read_buffer_size;
  // read_buffer
  signed short int *read_buffer;
  // flt_read_buffer
  double *flt_read_buffer;
  // jack_input_port
  struct _jack_port *jack_input_port;
  // jack_client
  struct _jack_client *jack_client;
  // nframes
  signed int nframes;
  // real_sample_rate
  unsigned int real_sample_rate;
  // thread_input_read
  unsigned long int thread_input_read;
  // thread_input_read_attr
  union pthread_attr_t thread_input_read_attr;
  // running
  signed int running;
  // interrupted
  signed int interrupted;
};

struct _LingotAudioSystemProperties
{
  // forced_sample_rate
  signed int forced_sample_rate;
  // n_sample_rates
  signed int n_sample_rates;
  // sample_rates
  signed int *sample_rates;
  // n_devices
  signed int n_devices;
  // devices
  char **devices;
};

struct _LingotComplex
{
  // r
  double r;
  // i
  double i;
};

struct _LingotConfig
{
  // audio_system
  enum audio_system_t audio_system;
  // audio_dev
  char audio_dev[3l][80l];
  // sample_rate
  signed int sample_rate;
  // oversampling
  unsigned int oversampling;
  // root_frequency_error
  double root_frequency_error;
  // min_frequency
  double min_frequency;
  // fft_size
  unsigned int fft_size;
  // calculation_rate
  double calculation_rate;
  // visualization_rate
  double visualization_rate;
  // temporal_window
  double temporal_window;
  // temporal_buffer_size
  unsigned int temporal_buffer_size;
  // noise_threshold_db
  double noise_threshold_db;
  // noise_threshold_nu
  double noise_threshold_nu;
  // window_type
  enum window_type_t window_type;
  // peak_number
  unsigned int peak_number;
  // peak_half_width
  unsigned int peak_half_width;
  // peak_rejection_relation_db
  double peak_rejection_relation_db;
  // peak_rejection_relation_nu
  double peak_rejection_relation_nu;
  // gain
  double gain;
  // gain_nu
  double gain_nu;
  // dft_number
  unsigned int dft_number;
  // dft_size
  unsigned int dft_size;
  // max_nr_iter
  unsigned int max_nr_iter;
  // gauge_rest_value
  double gauge_rest_value;
  // scale
  struct _LingotScale *scale;
};

struct _LingotConfigDialog
{
  // input_system
  struct _GtkComboBox *input_system;
  // input_dev
  struct _GtkComboBoxEntry *input_dev;
  // sample_rate
  struct _GtkComboBoxEntry *sample_rate;
  // calculation_rate
  struct _GtkHScale *calculation_rate;
  // visualization_rate
  struct _GtkHScale *visualization_rate;
  // noise_threshold
  struct _GtkHScale *noise_threshold;
  // gain
  struct _GtkHScale *gain;
  // oversampling
  struct _GtkSpinButton *oversampling;
  // fft_size
  struct _GtkComboBox *fft_size;
  // temporal_window
  struct _GtkSpinButton *temporal_window;
  // root_frequency_error
  struct _GtkSpinButton *root_frequency_error;
  // dft_number
  struct _GtkSpinButton *dft_number;
  // dft_size
  struct _GtkSpinButton *dft_size;
  // peak_number
  struct _GtkSpinButton *peak_number;
  // peak_halfwidth
  struct _GtkSpinButton *peak_halfwidth;
  // minimum_frequency
  struct _GtkSpinButton *minimum_frequency;
  // rejection_peak_relation
  struct _GtkHScale *rejection_peak_relation;
  // label_sample_rate1
  struct _GtkLabel *label_sample_rate1;
  // label_sample_rate2
  struct _GtkLabel *label_sample_rate2;
  // button_scale_add
  struct _GtkButton *button_scale_add;
  // button_scale_del
  struct _GtkButton *button_scale_del;
  // scale_name
  struct _GtkEntry *scale_name;
  // scale_treeview
  struct _GtkTreeView *scale_treeview;
  // conf
  struct _LingotConfig *conf;
  // conf_old
  struct _LingotConfig *conf_old;
  // mainframe
  struct _LingotMainFrame *mainframe;
  // win
  struct _GtkWidget *win;
};

struct _LingotCore
{
  // freq
  double freq;
  // X
  double *X;
  // audio
  struct _LingotAudioHandler *audio;
  // flt_read_buffer
  double *flt_read_buffer;
  // temporal_buffer
  double *temporal_buffer;
  // hamming_window_temporal
  double *hamming_window_temporal;
  // hamming_window_fft
  double *hamming_window_fft;
  // windowed_temporal_buffer
  double *windowed_temporal_buffer;
  // windowed_fft_buffer
  double *windowed_fft_buffer;
  // spd_fft
  double *spd_fft;
  // spd_dft
  double *spd_dft;
  // diff2_spd_fft
  double *diff2_spd_fft;
  // fft_out
  struct _LingotComplex *fft_out;
  // antialiasing_filter
  struct _LingotFilter *antialiasing_filter;
  // running
  signed int running;
  // conf
  struct _LingotConfig *conf;
  // thread_computation
  unsigned long int thread_computation;
  // thread_computation_attr
  union pthread_attr_t thread_computation_attr;
  // thread_computation_cond
  union anonymous$3 thread_computation_cond;
  // thread_computation_mutex
  union anonymous thread_computation_mutex;
  // temporal_buffer_mutex
  union anonymous temporal_buffer_mutex;
};

struct _LingotFilter
{
  // a
  double *a;
  // b
  double *b;
  // s
  double *s;
  // N
  unsigned int N;
};

struct _LingotGauge
{
  // filter
  struct _LingotFilter *filter;
  // position
  double position;
};

struct _LingotMainFrame
{
  // gauge_area
  struct _GtkWidget *gauge_area;
  // spectrum_area
  struct _GtkWidget *spectrum_area;
  // tone_label
  struct _GtkWidget *tone_label;
  // view_spectrum_item
  struct _GtkWidget *view_spectrum_item;
  // spectrum_frame
  struct _GtkWidget *spectrum_frame;
  // freq_label
  struct _GtkWidget *freq_label;
  // error_label
  struct _GtkWidget *error_label;
  // pix_spectrum
  struct _GdkDrawable *pix_spectrum;
  // pix_stick
  struct _GdkDrawable *pix_stick;
  // spectrum_scroll
  struct _GtkScrolledWindow *spectrum_scroll;
  // freq_filter
  struct _LingotFilter *freq_filter;
  // gauge
  struct _LingotGauge *gauge;
  // core
  struct _LingotCore *core;
  // win
  struct _GtkWidget *win;
  // gauge_color
  struct _GdkColor gauge_color;
  // spectrum_color
  struct _GdkColor spectrum_color;
  // config_dialog
  struct _LingotConfigDialog *config_dialog;
  // conf
  struct _LingotConfig *conf;
  // visualization_timer_uid
  unsigned int visualization_timer_uid;
  // freq_computation_timer_uid
  unsigned int freq_computation_timer_uid;
  // gauge_computation_uid
  unsigned int gauge_computation_uid;
  // error_dispatcher_uid
  unsigned int error_dispatcher_uid;
};

struct _LingotScale
{
  // name
  char *name;
  // notes
  unsigned short int notes;
  // offset_cents
  double *offset_cents;
  // offset_ratios
  signed short int *offset_ratios[2l];
  // base_frequency
  double base_frequency;
  // note_name
  char **note_name;
  // max_offset_rounded
  double max_offset_rounded;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};


// CONFIG_FILE_NAME
// file lingot.c line 41
char CONFIG_FILE_NAME[100l];
// background2_xpm
// file lingot-background.xpm line 23
static char *background2_xpm[175l] = { "160 100 74 1", "  c #000000", ". c #8E8D8E", "X c #9A898B", "o c #9A9294", "O c #9A999B", "+ c #A79699", "@ c #A7989A", "# c #9F9EA0", "$ c #A19FA1", "% c #A7A6A7", "& c #A8A6A8", "* c #A7A8A9", "= c #AAAAAB", "- c #BFBFBF", "; c #CD9A9D", ": c #D09B9F", "> c #DD9EA2", ", c #DDA1A5", "< c #ECA7AC", "1 c #EEAAAE", "2 c #F1A7AE", "3 c #F0AAAE", "4 c #E6B3AE", "5 c #EEADB0", "6 c #F0ADB0", "7 c #EEB6B9", "8 c #E7BDBA", "9 c #ECBCBE", "0 c #F1B4B9", "q c #F1BDBF", "w c #BFC0BF", "e c #B5E5AE", "r c #ABF1AE", "t c #B2F0B3", "y c #B7F1B9", "u c #B8F0BA", "i c #C0E8BA", "p c #EEBDC0", "a c #F0BEC1", "s c #BFEFC1", "d c #C2C2C2", "f c #CDC6C5", "g c #CCCBCD", "h c #CECFD0", "j c #D0CED0", "k c #CFD0D0", "l c #D1D1D1", "z c #DDD6D7", "x c #D7D6D8", "c c #D9D7D9", "v c #DBDADC", "b c #EEC0C2", "n c #F0C0C2", "m c #DDE0DF", "M c #D9EFDA", "N c #DDDFE1", "B c #F0DFE3", "V c #DEE0E1", "C c #E2E2E2", "Z c #EEE2E4", "A c #EEEEEE", "S c #F0E2E4", "D c #F1E7EB", "F c #F0EBEB", "G c #E2F0E3", "H c #E7F1EA", "J c #EDF0EE", "K c #EFEFF0", "L c #F1EFF3", "P c #EEF3F3", "I c #F2F2F2", "U c #F7F8F7", "Y c #F7F8F8", "T c #F9F9F9", "                                                                                                                                                                ", 
    " Oggfddgdfdddddd8-dw-8dd---8dd---8dd---8dd---8dd---8dd---8dd---8ddww-8wwdddddd-ddddd8dddddwd-8wddd-8dd---8dd---8dd---8dd---8dd---8dd---8dd---8dd---8dwddgffdggO ", 
    " gTTTTTTTTTYYYYYYYYYYYUUTYYYYYTYYYUUTYYYYYTYYYUUTYYYYYTUYYUUTYYYYYTTTTTTYTTTTTTTTYYYPYYYTTTTTTTYUYYYYYTUYYUUTYYYYYTUUYTUTYYYYYTUUYUTTYYYYYTYYYUUTYYTTTTTTTTTTTk ", 
    " fTTTTTTTTTYYYYYYYYYYUUUUYYYYYYYYYYUUYYYYYYYYYYUYYYYYYYYYYYUUYYYYTTTTTTTTTYTTTTTTTTYYYYYTTTTTTTTYYYYYYYYYYUUYYYYYYYYUTUUYYYYYYYYTUTUUYYYYYYYYYYUYYYTTTTTTTTTTTg ", 
    " fTTTTTTYYYYUUIUYUUULUUUUUUUUUUUUUUUIUIUUUUUUIUUUUUUUUUUUUUUUUUUUUUUUUUTYUYUUUYYUUUYYUUUYYYUUUYYUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUIIUUUUUUUUIUUUUUYTTTTTTTTTTf ", 
    " gTTTTTTUUYUIUIUIIUYLUUULULUIUUIIULUUIUUUILUIUIULUIIUIIUUUIUUUUUIUUUULIUUUUUUUUUUUULUUUUYYUIYIIUUULUUUIUUULUIUIUUILUILIULULIIUUIIULUUUIIUILUIUIULUIUTTTTTTTTTTg ", 
    " gTTTTTTUUUUUIUIIIUIUIUIIIUIIULIUIUIIIUIIUIUILIUIUIUIIULUIUIIUUIIUIUUIUULUUUIUIYUUIUUUUIUIUUIUIULUIUUIULUIUIIUUIIUIUUIIIIUIUIILIIUUIIIIUIUIUILIUIUIUIUYUTTTTTTd ", 
    " dTTTTTTUULUIIIIIUIILIIIUIIIIIIIIILUIIIIIIIIIUIIILIUIILUIULUIIIUUIUILUULLULUUUUIUIUULUUUIUUIUIIUULUIIULUIIIIILIIIIIILIIUILUIIUIIIIILUIIIIIIIIUIIILIIIUIUTTTTTTf ", 
    " dTTTYYULULLIIIIIIIIIIIILIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIUIIIUIULIUIUIUUIIIUIUIUIIIIUIUIIIIIIIIIIUIIIIFIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIILIIIIIIUUUUYTTTf ", 
    " dTTYYUUULIIIIFIIIFIIJIIILIIFIIIIIFIJIIIIIIFFIJLILIIIIIIIIIIIIIIIIIIIIIIIIUIIIIIIIUIIIIILUIUIIIIIILUIIIIIIIIIIIIIAIIIIIFILIIIFJIIIFIJIIIIIFIFIJPLIFIIIIIIUYTTTg ", 
    " dTTUULUUIILIAPIAJJIFIFIFIJIIJFIIAFPIAFFAJIIIIJIIILIIIIIIIIIIIIIUIIIUIUIIULIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIFIIJIIPFFIFIFIJIAIFIJLJJIIPIIKKPIIIIIUIIUYYTTd ", 
    " fTTUUUULIIIIAAFPFLJAAPFIFFJAIJFAAIIAIIPFIIFIJIIIFILFIIIIIIIIIIIIIIIIIIIIIIIUILUUIIIIUIIIIIIIIIIIILIIIIIIIIIJIIFIIFPIFFPIIJIIIIFKJAPAAFIAAFAAAAAAFIFIFIIUIUTTTd ", 
    " dTYYUIIIIIFJJAJFAAFAAAAAAAAAFPAAAAFFAFPPPAFFIIJFIIIIFIIIIIIIIJIIIIIIIAvccvczcvxccvcccvcvvFIIIIIIIIIJIJIFIIIIIJIJIALIAAIIFPFAAAFAAAFAAAAAFPAAAAAAFAJIIIILIUUUTd ", 
    " wYYUIUIILIJIJAAPAAPAAAAAAAAAAAAAAAAJAPFAFFPPFJLFIJIIJJIFIJJIFIJFvzvcxgO....X............OgvcccNFIJJIIIJIIJJJFIJIAJAAAJFAJAAAAAPAAAAAAAAAAAAAAAAAJALJFIFLUIUUTd ", 
    " wTYIIIIIIIFFJFAAAAAAAAAAAAAAAAAAAAAAPPAIFPAAJIJJIIJJIIJIIIAvzvcgO....OgvcvcvcvxcvccvcccvgO....OgcccvFIIFIIIIFJIJIIFFILJJKPAAAAAAAAAAAAAAAAAAAAAAAAJLAIIIIUUTTd ", 
    " wYTYUUIIFFIJFIAAAAAAAAAAAAAAAAAAAAPFAFJALJJPIFIIJIFIIFAmzzgO...OgvcvcvAIIIIFLIILIIILIIIIFvvcccg@...OgccmFIFIIIJIFPIIJJAPFFAAAAAAAAAAAAAAAAAAAAAAAAAJIJILIIUUTd ", 
    " -YYUUUIIFJLAAAAAAAAHAAAAAAAAAAAAAAAFPAJJFIJIFIFJIIJAvvgO..OgvcvvAIIPIPIPYLLIILIILLILULLPLYIIPIKvvcvgO..OgvvAIFPIPAJIAIAAFFPAIAAAAAAAAAAAAAAAAAAAAAAIJJILILUUTd ", 
    " 8YULUIIIIIJAAAAAAAAAAAAAAAAAAAAPFFPJFIFILAIJIIIIJvcgO.OgccvAIPPIIPIIIIILLLLILLLLILLILLIPLLLILPIIJPIJvcvgO.OgvvAFIIIJIAIPIAAJFAPIJAAAAAAAAAAAAAAAAAIFFIIIIUUTTd ", 
    " dTUUUUIIIAAAAAAAAAAAAAAAAAAAAAAPAFAIALIIJIPJJJAvgO.OgvvAPIIPPPIIIIIPIKILYLLLLLLIULUIIIIYLYLIIIIIIIPPIPIAvvfO.OgvAJIIFIJJJIIAAFPAFAAAAAAAAAAAAAAAAAFJIIIIIIUUTd ", 
    " dUTULIIIIIFAAAAAAAAAAAAAAAAAAAAFAPPJIJJAIIFAvvgOOgcvAIPIIIPIIPYIIPIIIIILYLLYLIYILLLLLIIPLLPPIPIIIIPIIIIIPPAvcgOOgcvAJIJLJFIIIFAPFAPAAAAAAAAAAAAAAAIFJFILUUUUTd ", 
    " -TYUIIIIIFIPAAAAAAAAAZAAAPFAAAAAAJIIIJJIJAvgO.OgvAIIPIIIIPIPPYPLYPPPYLPLLYYLYLLLLLLULYLLPPPPPPPPIPPPPPIPIIPIIPvgO.OgvAJIJIAAIAAPAFFFAAAAAAAAAAAAAAAJIIJIIUUUTd ", 
    " -YYUIUIIJIAAAAAAAAAAAAAAAAAAAAKLAIFFFIIAvgOOgcvJIPIIIPIPPIPPPPPPPPYPPLYLLLLLLLYLLTLLLYLLYYLPPYPIPPUPUIPPIPIPIPIAvcgOOkvAIJIIAAIFPPAPPFAAAAAAAAAAAAAJFIIIIIUUTd ", 
    " -YYUIUIIFAAAAAAAAAAAAAAAAFPPFKKJIIFIIAvgOOgvAIPPIIPIPPPPPPIPPPPPYPPPPPPLYLLLTLLTLLTLYLLLPLYPPPPPYPPPPPUIPIPPPPPIIIAvgOOgvAFJJIAPFIFAFPAAAAAAAAHAAAAIILIILUUTTd ", 
    " 8YYUUIIIIIAAAAAAAAAAAAAFAAPFJJLIFPPJAkOOgvAIIIIIIPIPIPPUIPPYPPPPPPPYPLYLTLTLLLLLLLLYLLYYPPPPYYPPPPPPPPPPIPIPPPYIIIIIAvgOOjAILIJIFPJAPFPAAAAAZAAAAAAFIFLIULUUTd ", 
    " dYYUUIIIIFJLAAAAAAAAAPFPAFJIPAIFPIAvg%gvAIIPPPYPIPUPPPPPPPYPPPPPPPPDDDBDKHHAHAGMGAHHHHHDDDDDLPPYPPPPPYPPPYPPYPPPIIJIIPJvg%gvAIJJIAIAAJFPFFAAAAAAAAAAFIIIUIUUUd ", 
    " dYYUIUIIJIAAAAAAAAAAAAAPFAPFIJAJAvgOOjAIPIPPPPPPPPPPPYPYPPPPPPAKKLBa0p0piyuuuutetuuutsu8000pBKDAPPPPPPPPPPPPPPYIPIPPPIIIAlOOgvAIFIAAIAAAAPAAAAAAAAAJIPIIIUUUUd ", 
    " -TYULIIILIAJAAAAAAAFPPAFAJIIJILAkOOgvAJPIPIPPPPIPPPPPPPPPPAPABb77p022224errrrrrrrrrrrre422210777bZAKIPPPPPPPPPPPPPIPIPIPFAvgOOjAPIFLIFAJFFPAAAAAAAAAIFILUIUUTd ", 
    " -UYUUUIIIJKFJAAAAAPFAAAIPIFFJAvg%gvAIPPPPIPIPPYPPUPPYPPAAZpp971122222224errrrrrrrrrrrre422222111177bCPPPPPPPPPPPPIPIPPPIPPIAvg%gvAJJJIIPIJAAAAAAAAAAAIIILUUUUd ", 
    " -UUUIULIIFAAAAAAAAAFPAIPIJJIAkOOgAIPPPPIPIPPPPPPPPPPPPCp775<111111122224errrrrrrrrrrrre42212221<1165777pZAPPPPPUPYPPPPPPIPPIIAgOOjAJAIFFIAAJFPPAAAAAIJIIIUUUTd ", 
    " 8YTULIIIJIAAAAAAAAAAAIFFFIIAg%gvAPIIIPPPIPPPPPPYPPAPZb7555155<5122212224errrrrrurrrrrre5222211266<<111117pBAAPPPPPPPPPYIPIIPIPAvg%jAIPAIJLJALAFAAAIIALILUIUTTd ", 
    " dTUUIIIIIFPJAAAAIFPAPJAIAAvg%kAIPPIPIPUPPPUPPPYPPZb77551<5<1<1<1<1227pp8uuuyyysMsyuuuyu87701221<651<11111179pZAPPPPYPPPPPIPPIPIJAk%gvAIIFJIJJPFAJFJJJJIIIUUUTd ", 
    " dUUUUIUIIIIFAPFJFJAIFIIAAkOOgAIIJIPIPPPPPPPYPPFCb7511155<1115550777pBBDDHHHHHHHKDHHHHHHDDDBp77p75<151111111157bAPPPPPPIPPPPIIJPPIAjOOgAJPIFIFAPFALFILJILIIUUTd ", 
    " -TYULIIILIJFFJJFPFFIJAAAk%gvAPPJPIPPYPPPPPPPJZb755<5<111<11797pBKDKLPPPYLLYLLLLTLLYLYLPPPPLKDDHBp777655111<11157pZAPPPPPPPPYPPPIPIAvg%kAAJJFIAAAJAAIAIIIUUUUYd ", 
    " -YYUUIIIIFIJIFJAPIPAIPAg*kAIPPIIIPIPPPPYPPKDb755<<5551<577pZKADPPPPLPPLLLLLLYLLLLLLLLLPLPPPPPPPPAAKCn775511113<<57pBAPPPYPPPPPPPPPIJAl%kAJIPIIAALIFAIFIILIUUTd ", 
    " -YYULUIIILILAIFFIAIIAAk%jAPPIPIIPPPPPPPPKCb71115111<557nCADPPPPPPPPPPPPLLLLLLLLLLLLLLPLLPLPPPPPPPPPPAABp7551111131179BAPPPPPPPPIIIPPIAg*kAFAFAIJFPIAIIIIUULYYd ", 
    " 8YYUUIIILIFJIJIJAIAAvf*jAJPIPIPPPIPYPPPHb051111<11577pZLPPPPPPPPPPPPLPKPLLLLLLLLLLLLLLLLPPPPPPPPPPPPPPPKCpp75111<11117pAPPPPYPPPPPPIPJAk&gvAIJAIJAJAIIIILUUYTd ", 
    " dYYUIIIIJIJJIJIJIFAkOOgAPPIPIIPPPPPPPAZp1111111557pZKKPPPPPPPHPPPPPPKPPLLPLKKKLLLLLKKPLLLPLPPPPPPPPPPPPPPPHSa7411111111pZAPPPPPPPPPPIPPAkOOgAAIIFAIIIIIIUIUTTd ", 
    " dYYUUUIIIILIFLAJAAk%gvAIJIPIPPPPPPPPAb7511111117pZDPPPPPPPPPPPPPPPPKPKKLLLLKKKLLLLLKKKKLPLPKPKPPHPPPPPPPYPPPFCb7111111157pZPYPPYPPPIPPPPAvg%hAJPIJAIJIIIUUYYTd ", 
    " -TYUIIIIIJIIFJIAAk%kAIPIPJIPPPPYYPACb511111117pDHPPPPPPPPPPPPPPPKKKPKKPKKKKKKDKKKDLKKKKKPKKKPKHPPPPPPPPPPPPPPPKZp7111111<5pCPPPPPPUPPPPPIPAh&kAFIIIIFIIIIIYYTd ", 
    " -UYUUULIIIIJPIFAk%gAPIJPIIPPPPIPPHb0611111119ZAPPPPPPHPPPPPPPPPPKKKKKKKKKKKKKKADKKLKKKKKKKKKPKKAPPPPPPPPPPPPPPPPAZp11111555pAPPPPPPPPPPIJIJAg%kAPFIIIIIIYYYTTd ", 
    " -TYUUUIIIIILIIFvOgAJIIPYPPPYPPPPZp55<551167bZPPPPPPPPPPPHPKPKKKPAKKKAKAKAAKKKAKKKAAKHDKKKKHKKKKAPAKPPKPKPPPPPPPPPPHb711<51157pZPPPPPYPYJPIIPAgOvPAPIIIUIUUUTTd ", 
    " 8TYUUUIIIIIIFJFgOvIIPPIPPPPPPPPZp11111511aCAPPPPPPPPPPKKPAPAKAKKAKHAKAAKDHKDAAAKKAAAAKKDKAKKKAAAJAPKKKPPHPKPPPPPPPPAZb1<113115pZPPPPPPPIIPJPIvOfAIFIIIIUILUTTd ", 
    " wTTLUULIIIIIJAk%jAIPJIPPPPPPPPZb511515579ZPYPPPPPPPPPPPKPKKHKKAAAAAAAAAAAAAKKAADKKAHAKAAHAAAAAAAAAAHKKKAAKPPPPPPPPPPPHb755<1111pZPPPPPPPIIPJIAg%jAPIIIILUUUTTd ", 
    " dYUUUUIIIIIJAk%gAPJIPIPPPPPPPZp15111<5pZAPPPPPPPKPHHPKKAAAKKKKKAAAAAAAAAAAAHKAAKKAADAAAAAAAAAAAAAAAKAAAJPKKKPHPPPPPPPPPZp5111111pDPPPPPPPPPIIPAk%gAIIIIULUUTTd ", 
    " dYTTUILUIIIFl%kAJIPPPYPPPPPAZ91111155pZPPPPPPPPPKPPAPKHAAKAAAAHAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAKDAAAAAAAAKAKPAJPAPPPPPPPPPZb1111115pBPPYPPPPIPPIPAk*kJIIUIUUUYTd ", 
    " dTTUUUUIIIAl&kAPIPIPPPPPPPKb75111147bZPPPPHPPPPJPAAAKKAAAAAAADAAAAAHAAAAAHKAAAAHAAAKKAAAKAAAAKHAAAAAAAAAJKKAKAPPPPPPPPPPPZb7111<157bCPPIPPPPPPIPAl&lAIIUUUTTTd ", 
    " dTTTUUUUIIvOgAPPPUPPPPPPPA91111155pHKPPPPPPPKPPAKJKAAAAAAAAAAAAAAAAAAAAAAAAHKAAKAAADKAAKDAAAAAAAAAAAAAAAAAKKAPJKPHPPPPPPPPPZp51111159ZPPPPPPYPPJPAgOVUILIUUTTf ", 
    " dTTUUIUIIIjOvIJPPPPPPPPPAb5111115pZPPPPPPPPPPPHPJKJAAAAAAAAAAAAAAAAAAAAKDAAAAKDAAAKKHAAHAAAAAAAHAAAAAAAAAAHJAAAKKPPPPPPPPPPPZp1111115bPPPYPPPPPIIFvOlFUUUUTTTd ", 
    " dTTTTTUUAl=lAIPPIPPPPPPPZ7111115pAPPPPPPPHPKKAAAPAAAAAAAAHAAAKKAAAAAHKAAAKADAAAAAAHZAAAAAAAAAAAAAKKAAAKAAAAAAKKKAPAKPPPPPPPPPAp5111118BPPPPPPYPIPPAl=lAUTTTTTd ", 
    " dTTTTYUIl&lAIIIIPPPYPPPZp511115pZPPPPPPKPPKPKAPAHAAAAAAAKKKAAHAAAAAAADKAAHAKAAAAAAAAAAAAAAAAAAAAAADAAAKAAAAAAAKAKHPPHKPKPPPPPPZp511111pZPPPPPPPPPIIIl=xITTTTTd ", 
    " dTTYYUIC$gPIIIPPIPPPPPAp511111pZPPPPPPPJPPKAAAAAAAAAAAAADAAAAAAKKACAAAKAAAAHAAAAAAAAAAAAAAAAAAKAAAHAAHDHDAAAADHAKKAAKKKKHPPPPPPZb511111bZPPPPYPIPIIIPh$CUTTTTw ", 
    " dTTTYYIlOVIIIIPIPPYPPAb511115pZPPPPPPPPPKKKAAAAAAAAAAAAAAAAAADAKKKKAAAKAAAAKAAAAAAAAAAAAAAAAAADAAAAAAAAAKAAAAAAAAAAAAPKPKPPPPPPPZp511115bAPPPPPPIIIUICOlITTTTf ", 
    " dTTTYIx=xAUUIPYYPPYPZp5<5115pHPPPPPPPHPKKAKKAHAAAAAAAAAAHKAKHAAAHAHDKDKAKAAAADKAAAAAAAAAAAAAAAHAAAHAAAAAAAAAAAAAAAAAAAKKPPKPPPPPPKp511155pSPPYPIIUPIUPx=xITTTf ", 
    " fTTTYC$kPIIPIPPPPPPAp511515pAPPPPPPPPKPKAKHAAKAAAAAAAAAAAAAAAAAKDAAKKHAADAAAAAAAAAAAAAAAAAAAAAAAAKDAAAAAAAAAAAAAAAAAAKAHKKPPPPPPPPAp511555pLPPPPPPIIUIIx$CTTTg ", 
    " dTTTUl$VUIYPIPPPPPPp515555pCIPPPPPKKPKPAAAAAAAAAAAAAAAHAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAHDAAAAAAAKKAAKDAAAAAAAKAAAAAAHKKKHKPPPPPPPPZp5555<7ZPIPPPIUUIUIC$xUTTf ", 
    " dTTTC$lPIYIPYYPPYIS7151557ZPPPPPPPPHKAAAAAAAAAAAAAAAAADAKDAAAAKKAAAAAAAAAAKHAAAAAAAAAAAAAAAAAAAAAAAAAKHAAAAAAAKAAAAAAAAKKPPHPPPPPPPPZ75<555pDPYPYPPIIUUIj%CTTd ", 
    " dTTTC$gCIUIPPIPYPA9535131bJPYPPPPPPPAAAAAAAAAAAAKKAAAAAAAAAAAADAAAAAAAAAHAAAKKAAAAAAAAAAAAAAAAAAAAAAAHKDHKAAADHKZAAAAAAKKKKKAPPPPPPPJb413115aSIYPPYPUPPCh%CTTd ", 
    " dTTTIc$OlVPYPYPPPn535355nZPPPPPPHKKJAAAAAAAAAAAHDAAAKAAAAHAKHAAAAAAAAAAKKAAAHAAAAAAAAAAAAAAAAAAHAAAAAKDAAKAAAAAAAAAAAAAAAKHKPPAPPPPPPZb613336nFYYPPYPCl$$xITTg ", 
    " dTTYYIVl#OlVPPIIS0133159AIPPPPPPKPKAAAAAAAAKAAAAAAADKAAAADKAAAAAAAAAAAAAAAAAAAAJAAAAAAADAAAAAAADAAAAAAAAAAAAAAAAAAAHAAAAAAKKHAPJPPPPPPAb113330SPPPPVx##jCITTTf ", 
    " fTTYYYUIClO#kPPSn333330ZPYPPPPPHPKAAAAAAAAAZAAAAAAAHAAAAAAKAAAAAAAAAAAAAAADAAAAFAAPAAAAAAAHAAAAKKAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAPPPPPYPPS033333qZPPxOOkVIYTTTTd ", 
    " dTTTTIUUIPVh=kx9333333nAPPPPPJIPKAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAJFJAAAKAAJLFAAAKAAAAAAAAAAAAAAAAKKAAAAAAAAAAAAAAAAAAKAAPPPPPPPPYJn6333339vk=kVPUUUYYTTf ", 
    " dTTTYUUYIIIPl#o;,<333nSPUYPPPPPPKPAAAAAAAAAAAAAHAAAAAAAAAAKAAAKAAAAAJJLPPFLKAAKKAAJAAIJAKAAAAAAAKHAAAKHHAAAAAAAAAAAAAAAAAAAKPAAJPJIPPPPISn611<>;o#kPIUIIUYYTTd ", 
    " dTTYYUUIIIPIPNgoX:<30SIPPYPPPPPKPAAPAAAAAAAAAAADAAAHKAAAAHKAKADAAAAPFFAFPAJAAKAIAAAIAAAAAKAKAAAADAAAAADDAAAAAAAAAAAAAAAAAAAAAAPJPPPPYPUUPS01<;XogVPYIIUUUTTTTd ", 
    " dTTTYUIUIIYPIPKVg@;,9FIPPPPPPIPJKAAAAAAAAAAAAAAKKAADKAAAAKDAHAAAAAAFAPPFAPFIALKFIJPIFAAPKAKAAKKAKAAAAAKAAAAAAHAAAAAAAAAAAAJKAAAJPPPPPPPPIF9,;+gNPPPPIUIUTTTTTd ", 
    " -TTUUULIIIIIPIIPPhOofvPIPPIPIJPJAPFPFFAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAFPIFIIJLIFIIFIJIFIIALJAAJFPAFJAAAAAAAAAAAAAAAAAAAAAAAPAFFPAAIPIPIPIIPVfookAPIIIIIIIIUUUTTd ", 
    " 8TTUUIUIIIIIIPIPPKVk#OkVJIPJILIIIAAAAPAAAAAAAAAAAAAAAAAAAAAALJPAAAAAPJJFIIFJJFIIFIAIIFIIAIJAAPFAPFAAAAAAAAAAAAAAAAAAAAAJAAIPAAIIAJIIPPJVkOOhVPPPPPIIIUIUIUUTTd ", 
    " wTTUUUIIIIIPIPJIPPIHNgOOkJPIIPAJIIPFPAPAAAAAAAAAAAAAAAAAAAAAAAAIFJIFIIJILJJLIIIJIIIIJLJJAFIIIAPFFIAAAAAAAAAAAAAAAAAAAAPALAFFPIAJIPIPIAkO#kVAIPIIPIIIIIILUULTTd ", 
    " wTTULIUUIIIJPLPPIIPPPPvk=gvAIIJIFFIJAIFAJAAAAAAAAAAAAAAAAAPFJAAJJLJPIFJPJIIJJIIIIJJAIIJIIAIFIJFPJAPAAAAAAAAAAAAAAAAAFAFKJJJIFIJIIJIAvg*hNHPPPIPPIPPIIIIULUUTTd ", 
    " dYYUIIIIIIPKJPILPIPIPIIKkOOgvAIPIFIJIAJAAFPPFJAAAAAAAAAAAAAAPAIIFIPFIIIIJAvvxvxvxccvvAPIJFIJIIPIJAAKAJAAAAAAAAAAZALAJPAPFIAPPFIIJAvhOOkHPIPPFIIPIJPIIIIUIUUTTd ", 
    " dYYUUUIIIIJIJFPPFPIPIJIPAvgOOlAIJFPIFLJIAJAFAPFAAAAAPAAAAPFAAFIPIFJPIAvvcgO.........ogvvvAIIJFIFLJAFPAIAAAAAAAAAJAAJAFALJAIFIJIIAjOOgvALPIPPIJLJJLIPIIIIIUUTTd ", 
    " dYYUIIIIPIAFIFPKAAIIAKIFPPAvg%gvAIIJIIFFIIAFPAPAAAAJFAPALAJFIIJFAJIAvgO..OjccccccxvvgO..OgvAFIJIIIPFAAFFPPFAAPAAAPALFIIJIIAPPIAvg%gvAIFKPLIIIPPFPPFIFPIUIUUUTd ", 
    " dYYUUIIIIIFPKJJPIJAPFPPIAPPIAgOOfvAIAPIIJJLAPFFAAAAAPFFJJFIPIFAIAvvgoOgccvFJIIJIJIJJAvccgOOgxvAIFFPIIAPPFAAPFFAAJAAJJIJIFJIFAvfOOgAIPIJPLIJAJAAPFAJIPIIIIIUUTd ", 
    " -YYUUIIIAJLAJAAAAFPPIAIPFIIJIAvgOOgvAFIFPFFIJPAAAAAAAFPAJIPFPAIAjO.OgvAJIIFIJIIIIAFIIIIIAvgO.OjAPPIJIFAAFPFAFPAAPJAIFFIPFIAvgOOgvAIILIPFIFIAAAAJKAIIPJIIIUUUTd ", 
    " -YYUIUIIIIAAAAAPFAAFJKAIFPAIFJIAvgOOjAIPIIPAIFPIFPAFPIJIFFIAIAvg%gxvAIFIJIIIIIFIIIIFPFIIIFAvcg%fvAAIFIPJIFPAPAIFFIIPIIJPIAlOogvAIJJIFFIIJPJAAAAAJAAFIIIIIUIUTd ", 
    " -TYULIIIIIPFAAAAAAAFJAJJIFIPPFIPFAvg*fvAFIJIAJIIAJILAFIIIJJFAkOOgAAIPIIIIJJIFIJPFJPIIJIAIIIIIAgOOgAFIIJAIIPPFJAIPIAFPJIAvg%gvAKJJIFJIPJJKAAAAAAAAAAIJIIIIIUTTd ", 
    " -UYUUUIIIFFPAAAAAAAPAALAAIJFIIAAPIIAhOOgvAKAIIFAIIFJIAIFIJAAk%gvAIIIFJIJIFIIIJLIFIFPFIAJAJIJLAAvg&gAIJFIJIFIFIIIFIFJIAvgoOjAIFPLAIIIFAAPALJAAAAAAAAFLJJILUUUTd ", 
    " -UUUIULIIIJAAAAAAAAAAAAFPAAJIPFIJAIKAvfOOhALAIJIAAIJFIPIJIAk%kALIJLFIPAIJPIFJIFIPFIAIFIIIAJAJIIIAg%kAJIJFFIIAIAIIIILAgOogvAIJIFIAJJJAFAFPAAAAAAAAAAAIILIIUUUUd ", 
    " 8YTULIIIFAAAAAAAAAAAAAAAAFPPFAPFAIJKIPAvf*gvAIIFIIIIIIFIFAj%gAIJJIJPIFIJIFFPAAIFAPAAAIJFIFIIAFIIFAj%kAJIIIJIIIFPFAAvg%gvAIIJLPIIIJLJLJAAAAAAAAAAAAAFJJILUIUUTd ", 
    " dTUUUIIIPFAAAAAAAAAAAAAAAPFAFJKIPJLIFPAIAjOOgvAIIFIPIIIJAk%kAPFIJFIIFIPAFFPAAAAFPIAAIFPPFIPIIJLJIJAk%kAIIILJFIPAAvgOOgAIPAJJIFIJFLJFIAAAAAAAAAAAAAAPPFIIIUUTTd ", 
    " dUUIUIUIIIAAAAAAAAAAAAAAAAAAPKAAAIFPPIFIFAvgOOgvAIIJIFIAk%kAJIFFIFIJAAFAPALJAAIAAAAAAAPFAAAFIJAIALJAj%kAAJIIIIAvgOOgvAIIFIAIFPAJAAKAJAAAAAAAAAAAAAAFIIIIIIUUTd ", 
    " -TYULUIILIJFFIFAAAAAAAAAAAAAAAJFFPAFIPLJIIJAvgOOlAIIIFAg%kAIFIPIPIJAAAAAAAAAAAAAAAAAAAAAJALAJAIJIJLFAk%jAIIIJAkOOgvAFIALJAFPIAAAAAJAAAAAAAAAAAAAAAJFILIIIIYYTd ", 
    " -YYUILIIIJFJJAJAAAAAAAAAAAAAAAAPAPFAIAJIFLJFIAvg%gvAFAj*lAAAIPFFAFAAIIAAAAAAAAAAAAAAAAAAAKJIFIAIFIAIJAj%kAJFmg%gvAIIIJIFIIIAJPFAAAAAAAAAAAAAAAAAAAFJFIJIIUITTd ", 
    " -YYIUIIIIFIAAAAAAAAAAAAAAAAAAAAAAFJFPAIIPIIIJIIFlOogvvOgAJFIAIJPAFPAAAAAAAAAAAAAAAAAAAAAAAAAAIAALJIJIJAgOcvgOOjAFIJPJFAIIAAPFAFAAAAAAAAAAAAAAAAAAAAIJIIIUUUYTd ", 
    " 8YYUUUIILIFIAAAAAAAAAAAAAAAAAAAAAAIJAAIAFAJFIFIJAvgOO-OvJPIJIFLFPPFAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAIIFJLvO-oOgvFIIIJFPIIJAAAFAAPAAAAAAAAAAAAAAAAAAAPFIJLLIIUYTd ", 
    " dYYUUUIIIIAAAAAAAAAAAAAAZAAAAAAAAAAAAJFAPAIIJIFIIIAvg%lAFPFIPAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJJJAFIIAIIAk%gvJJIIFIPFIFPFAAPPAAAAAAAAAAAAAAAAAAAAAAAIJIIIIUUTTd ", 
    " dYYUIIIIIAIAAAAAAAAAAAAAAAAAAAAAAAAAAAPFFAPPAIIJFJIIFmFAIIFFAPFFAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFFFPPJAIAJFAvAIJJIPIFIPAAIPPFAAAAAAAAAAAAAAAAAAAAAAAAAFIIJIULUTTd ", 
    " dUYUULIIFJFAAAAPAAAAAAAAAAAAAAAAAAPAAJFPFAFAIAPJIJJFIIIIIFAPAJAPAPAAAAAAAAAAAAAAAAAAAAAAAAAAAJJLJAFAJIFIFJJFIFIFIAJAAAJFPFJAAAAAAAAAAJAAAAAAAAAAAAAFIILIIUUTTd ", 
    " wYYUIULIIIJLAAAFJAAAAIFAAAJAAAAAJAFAALAAPAIJAIFIJIJIIFIAJIPFIFPFAFAAAAAPFAAAAPFAAJAAAAAAIFJAAFIAAAIIFIIJIIIIIIIIAIAFIPFFAPFAAAAPFAPFAFIAAAAAAAAJALAIFIIIILUTTd ", 
    " dTTYUIIIIJIFAFPJIFJJIFIAPAIJFJFFFIJIJIIIFIAIIIFIIIIIIIIIIIJJIIIIIPAFIFAAAAFFIFAAFIFIFJJIIFJFIFJJIPFIFIIIFIIFIIFIFIFIFFLIPFIJLAAFJIIJJFJFFJJJFIFFPAJILIIIUUYYTd ", 
    " fTTYUUUUIILIIIJFIJIJFJIJFIFIIIIIIJFFIFFJIJIIAIIFLLFIFFIIIFIIFIFPFIJIFIIJIPIJIIPJJPIFIIJFJJIIIIJIFIFIPJPIIIIIIIIIIIIIIILIFPIIAIJIIFJFIIJIIIFIIFIIJPFIIIIIUUUTTd ", 
    " dTTYUUUUUIIIIIFIIIFIIJFIIIIIJIFIIIIIILIIIFIIFPIIIIIIIIIIIIIIFLIIIIFIIFIFPIFIFFIJLJIFILIIIIILFILIIJIIIIIIIIIIIIIIIIIIFLIIJIFIFIJIFFLIIIIIJJIIJFIIIIIIIIIUUTTTTf ", 
    " dTTTYTTIIIIIIIIFIILIIIIJLIFIIIIJIJIIIILIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIILIIIIIIILIIJILIILJIFIIIILIIIIIJIIIFILIIFIIIIIIIIIIIIIIIIIIIILIJIFIIIIIILIFIIIIIIUTTTTTTd ", 
    " dTTTTTTUILUIIIILLILIILLIIIILLIIIIIILIIIIIIIIIIIIIUIIILLIIIIIIUIIIIIIIIIIIIIIIIIIILLIIIIIILLIIIUIIIIIIIIIULIIIIIIIIILIIIUIILIIIILIIIILILIIIILLLLIILLUIIUTTTTTTf ", 
    " dTTTTTTUUULIIIUUIIUIIIUIUIIUIIIIUIIUIIUUIULUIIULUIIIUIUIIIUILIIUIIIIUIIUIIIUILUUIUIIIILUIUIIIILUIULIIIUILIUUIUIIUUIUIUIIIIUUIIIILUIIUIIIIUIUIUIUIIUUUUUTTTTTTd ", 
    " fTTTTTTTUUUUUUILUIUUUULUIUIULULUIUIULULULIUIUUIULUUUUUIUIUIIUIUIIUUULULIIUUUUILIIUIUUIUIUIIUIIUULLUIUUULUUIUIIUUIIUULULUIULUIUIUUUIUIIUIIIUUIULUILUUUUUTTTTTTg ", 
    " gTTTTTTTTUUUIUUUUUUIUIUUUUUUIUUUUUUUIUUUUUUUIUUULULUUIUUUUUUUUUUUUIUUUUUUUIUIUUUUUUUIUUUUUUUUUUUUUUUUIUUUUUUUUUIUIUIUUUUUIUUUUULUUUUUUUUUUUIUUUUUUUUTTTTTTTTTf ", 
    " fTTTTTTTTTTTTYTYYTYUYYUYYUYYYYYUYYUYYUYYTUTYYYYYYYYYYYYUYYUYYUYTYYUYYYUTYYUYYYUTYYUYYYUTYYUYYYUUUYYYYYYYYYUYYUYYYYYUYYUYYUYYTUYUYYUYYUYYTUYUYYUYTTTTTTTTTTTTTg ", 
    " gTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTUTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTg ", 
    " Oggfggffdddfddddddddddddddddddddddddddddwd8dddddddddddddddddddddddddddddddddddddddddddddddddddd8wddddddddddddddddddddddddddddddddddddddddddddddddddddfgfdgflgO ", 
    "                                                                                                                                                                " };
// black_color
// file lingot-gui-mainframe.c line 48
struct _GdkColor black_color;
// cents_color
// file lingot-gui-mainframe.c line 49
struct _GdkColor cents_color;
// client
// file lingot-audio-jack.c line 34
struct _jack_client *client = (struct _jack_client *)(void *)0;
// decimation_input_index
// file lingot-core.c line 47
signed int decimation_input_index = 0;
// filechooser_config_last_folder
// file lingot-gui-mainframe.c line 72
char *filechooser_config_last_folder = (char *)(void *)0;
// freq_color
// file lingot-gui-mainframe.c line 55
struct _GdkColor freq_color;
// front
// file lingot-msg.c line 34
signed int front = 0;
// gauge_cents_font_desc
// file lingot-gui-mainframe.c line 70
struct _PangoFontDescription *gauge_cents_font_desc;
// gauge_color
// file lingot-gui-mainframe.c line 50
struct _GdkColor gauge_color;
// gauge_size_x
// file lingot-gui-mainframe.c line 59
signed int gauge_size_x = 160;
// gauge_size_y
// file lingot-gui-mainframe.c line 60
signed int gauge_size_y = 100;
// grid_color
// file lingot-gui-mainframe.c line 54
struct _GdkColor grid_color;
// last_ports
// file lingot-audio-jack.c line 40
char last_ports[10l][80l];
// lingotlogo
// file lingot-logo.xpm line 23
static const char *lingotlogo[338l] = { "80 80 257 2", "   c black", ".  c #2E4E41EA1FB9", "X  c #2F7542BE2093", "o  c #348B44B92376", "O  c #39E8475526C6", "+  c #3B8D48A42821", "@  c #3E2349B12992", "#  c #42BB4C972CB8", "$  c #47474FF73052", "%  c #48FB503430FF", "&  c #4CD853213414", "*  c #51CB55B43725", "=  c #564F5A4C3B43", "-  c #5A7D5D3C3E4E", ";  c #529657CF388C", ":  c #5C5B603040B4", ">  c #5E896199422C", ",  c #60A75D8440D7", "<  c #63CD64104550", "1  c #674F67624883", "2  c #678169444994", "3  c #6C8E6CCB4D3A", "4  c #68DA665B4854", "5  c #6F0671D250C7", "6  c #70DE6D2F4EF6", "7  c #7EF96D2055C3", "8  c #7D3767F552BA", "9  c #745F74285424", "0  c #7683792557B9", "q  c #7CB1741A57F4", "w  c #7FD8776C59C7", "e  c #7D4B7CD15BF3", "r  c #7D6D82F15F40", "t  c #79BC89195F75", "y  c #75438A075D75", "u  c #71C8929C6045", "i  c #6D1E94FB5F0A", "p  c #6DA59C5264E9", "a  c #70079ECD6897", "s  c #6FD995DC6258", "d  c #7D7F8B87653F", "f  c #7B278AA06300", "g  c #75C694C46609", "h  c #76F297BD6953", "j  c #73D69D906BB3", "k  c #7CA294916B2C", "l  c #7AEA9C466E26", "z  c #7EFA9DE57191", "x  c #67DCA2C865E8", "c  c #69B6A32F677E", "v  c #6D33A3B96AD7", "b  c #7054A9066EC7", "n  c #72F4A3E06ECE", "m  c #74D0A4A771B2", "M  c #7511AB17734D", "N  c #7AEDA601737E", "B  c #7ABCACAF7811", "V  c #7CD4AF197B14", "C  c #7EFCB2657D9F", "Z  c #84436ED0579C", "A  c #864C6FE35915", "S  c #88DA701159DC", "D  c #820F70D157E3", "F  c #85D473A35B19", "G  c #83777C2A5EF3", "H  c #89E8735A5BF1", "J  c #8C4E794E5F9F", "K  c #85587D7B6153", "L  c #8D7577E36092", "P  c #8DA17B94627A", "I  c #8F237F6B6934", "U  c #92DD7D2E6445", "Y  c #93FC7F2569D2", "T  c #812F81225F81", "R  c #838B84A0628D", "E  c #84518AE36654", "W  c #8F4983806686", "Q  c #8D5485E169D9", "!  c #8CD68D956B97", "~  c #87268DA668AF", "^  c #90588ED67342", "/  c #8D9E92D06DDC", "(  c #857791776C44", ")  c #84029CB772D7", "_  c #8DE597117233", "`  c #8EA19A3D75CF", "'  c #91A88511681E", "]  c #93CC86706B43", "[  c #949A8BF56DAD", "{  c #995F833D67AA", "}  c #9A7C850D6B28", "|  c #9D7C8A5F6CA9", " . c #96588B2B71A4", ".. c #9BC98BA5750F", "X. c #9F898E617A67", "o. c #935091BF6FC0", "O. c #93EC961172E4", "+. c #94C29BFD7561", "@. c #97AE9EA37AE0", "#. c #9A9895AD7646", "$. c #9A109B6B7728", "%. c #9B7E9E7579B6", "&. c #98E9958A7AE9", "*. c #8443A8D17B68", "=. c #8120B2D17EA4", "-. c #96F1A2117A1A", ";. c #9BF6A4EE7CEF", ":. c #9CD1A9A97FC5", ">. c #A17D8C156E36", ",. c #A42E8F787241", "<. c #A1E18FC77BA7", "1. c #A6F192E672F6", "2. c #A39793257D69", "3. c #AA4795E2753D", "4. c #AE389A5D78AC", "5. c #B30D9EE07BFF", "6. c #B6C7A3137F4A", "7. c #983F9F0B808C", "8. c #8C8DAE8E8457", "9. c #884BB0A5845A", "0. c #84D2B602836E", "q. c #8943B971878D", "w. c #8D8FBB9A8BDB", "e. c #8BD8B86388AD", "r. c #95C6A3BD82AE", "t. c #9F54ACF182B4", "y. c #9A1DA87E8829", "u. c #9168BDC38FD9", "i. c #9701BC539207", "p. c #A53F960382A8", "a. c #A6DB9A3684C9", "s. c #AC659BE684D9", "d. c #AA7397B180C1", "f. c #A5A4A40A861B", "g. c #A1EDADE18417", "h. c #A988AA688C0F", "j. c #B018ABF193A6", "k. c #A3CEB29F8728", "l. c #A5AAB6FB8A31", "z. c #A757BB5F8D2C", "x. c #A981BF438FFC", "c. c #AA06B6778D5A", "v. c #AA8BC025916C", "b. c #AFF6B2629531", "n. c #B7BAA4C9831B", "m. c #B9FFA681829E", "M. c #BA8AA84D8A3E", "N. c #B95EA8B58C7A", "B. c #BDA2AE1797A2", "V. c #B39EABAF95A1", "C. c #B8B4B69B9CC1", "Z. c #BC91AF6BA17F", "A. c #BE02B505A4AF", "S. c #BD15BCAEA5D5", "D. c #B8A4BEB9A1FC", "F. c #AC4FC5299459", "G. c #AFB7C58C9903", "H. c #AE87CB4B9844", "J. c #AEC8CBF898BB", "K. c #B413C5DE9DB1", "L. c #B26ECE2A9CF0", "P. c #B7B9C894A238", "I. c #B553CFD5A1AE", "U. c #BA0BC89DA479", "Y. c #BB3BCA51A68D", "T. c #BF93CD67AC76", "R. c #BE7BC86BAA3F", "E. c #B6DDD175A3D0", "W. c #BA16D33EA74D", "Q. c #BDD2D5B2AC06", "!. c #C1CBAECD87BC", "~. c #C315AFFE88E3", "^. c #C5D5B3178B8F", "/. c #C9C7B7C88EB1", "(. c #CB2FB8E2903D", "). c #CE7EBC989254", "_. c #C684B6F19D30", "`. c #D224BFD694C3", "'. c #CA84BE10ABD3", "]. c #C5FBB9F1A700", "[. c #D4B0C3559720", "{. c #D7A2C6AC99DF", "}. c #D907C7749A12", "|. c #DD3CCC359DE1", " X c #C1D1CE48AF76", ".X c #C9DBC334AD40", "XX c #C571CE8AB36D", "oX c #CAD0CEDBB923", "OX c #C105D785AFF8", "+X c #C3DFD694B323", "@X c #C548DA3FB579", "#X c #C808DC02B94B", "$X c #CC45D553BC6E", "%X c #CAB8DDA2BCE1", "&X c #C8DDD37DB87C", "*X c #D7D2C9AFAB07", "=X c #D951CCCEB2B0", "-X c #DE22D322BC6C", ";X c #E140D06EA108", ":X c #E5B3D535A487", ">X c #EA6BD9F5A805", ",X c #EE1ADE3FABCD", "<X c #E5C7D89CAE0C", "1X c #E294D538B2DD", "2X c #E830DB8CB90B", "3X c #F37AE3D7AF6B", "4X c #F619E709B22A", "5X c #F752E925B732", "6X c #F72CEA14BC70", "7X c #D000D805C144", "8X c #CEA1DFD7C17B", "9X c #D311D51DC431", "0X c #D29FDA28C4D8", "qX c #D738DD50CAB4", "wX c #DB3CDF0ECF59", "eX c #DB3BD3BCC7E2", "rX c #DDAADE16D202", "tX c #CFCFE188C316", "yX c #D2BAE2E4C6C8", "uX c #D69AE57BCB88", "iX c #D9EBE692CF48", "pX c #DD68E4FCD35D", "aX c #DE08EA70D50C", "sX c #E3B1DB62C8FC", "dX c #E4FEE0ABDAC4", "fX c #E215DE2AD715", "gX c #E5AAE293D5A7", "hX c #E5B0E57EDC9B", "jX c #E140EC3FD8B8", "kX c #E45DEE6ADD4C", "lX c #EC9CE5CAD492", "zX c #F861EBA7C35E", "xX c #F8ACEE49CB05", "cX c #F913EC91C5FE", "vX c #F958EF30CD2D", "bX c #F9F4F083D281", "nX c #F3AFEC22D68B", "mX c #FA66F1D9D5EB", "MX c #FB20F421DC8C", "NX c #EDD8E516CCE0", "BX c #E7CAF0BAE1C9", "VX c #EAD5E7ADE2E7", "CX c #ED07EA54E5DB", "ZX c #E80DF10EE225", "AX c #EA9DF261E5B6", "SX c #EED8F47DEADD", "DX c #F167F044EC18", "FX c #F787F2AFE303", "GX c #F246F639EE99", "HX c #FC03F658E4BE", "JX c #FCE7F857E952", "KX c #FD88F974EA48", "LX c #F4DDF7FFF1DD", "PX c #F76AF9F8F4EF", "IX c #F9B7FB74F7F9", "UX c #FDC7FE48FD59", "YX c None", "YXYXYXYXYXYXYXYXZ S H L Y ..<.p.X.X.X.X.X.X.p.X.X.....X...&...X......... ... ... . . .[  .} [ } [ ] ] ] ] ] ] ] Q ] ' ' ' Q Y Q W W W { H H S S YXYXYXYXYXYXYXYX", 
    "YXYXYXYXYXH H S H ..Z.eXdXVXVXVXVXVXhXhXVXaXrXpXrXrXrXqXqXuX0X0X7X7X7X#X&X$X&XXXXXXXXX XT.T.T.Y.U.U.P.P.K.K.G.G.F.F.F.x.x.x.x.x.F.F.z.:.:.$.W H H H J YXYXYXYXYX", 
    "YXYXYXYXYXS H Y ].DXUXUXUXUXUXIXPXPXLXLXGXSXSXAXAXAXkXkXkXjXaXaXiXiXiXiXuXyXtXtXtX%X%X#X#X@XQ.#XQ.Q.W.W.W.E.E.E.J.J.J.J.J.J.J.J.J.J.J.J.J.J.F.%.J H H YXYXYXYXYX", 
    "YXYXYXYXS S p.rXUXUXUXUXUXIXIXIXPXLXGXGXSXSXAXBXAXkXkXkXaXjXaXiXiXiXiXyXyXtXtXtX%X%X#X@X@X+XQ.Q.Q.W.Q.E.E.E.L.J.H.H.J.J.J.J.J.J.J.J.J.J.J.J.J.H.k.' H H YXYXYXYX", 
    "YXYXYXH S p.CXUXUXUXUXUXIXIXIXLXLXGXGXSXAXAXAXBXkXkXkXkXaXaXiXiXuXuXuXyXyXtX%X%X%X#X@X@X@X+XQ.Q.Q.Q.E.E.E.J.E.J.J.H.J.J.J.J.J.J.J.J.J.J.H.J.H.J.J.x.' H H YXYXYX", 
    "YXYXS Z <.VXUXUXUXUXUXUXIXPXLXLXLXSXSXAXAXZXBXBXkXaXkXaXiXpXiXiXuXyXyXyXtXtX%X%X#X@X@X@XQ.Q.Q.Q.W.W.E.I.E.J.J.J.J.J.J.J.J.J.J.J.H.J.H.J.J.J.J.J.J.J.z.{ S H YXYX", 
    "YXH Z Y eXUXUXUXUXUXIXIXPXLXLXLXGXSXAXAXAXZXBXkXkXkXaXaXiXiXiXiXyXyXtXtXtX%X%X#X#X@XQ.@XQ.Q.W.W.W.E.I.E.J.J.J.J.H.J.J.J.J.J.J.J.H.J.H.J.J.J.J.J.J.J.J.k.J H H YX", 
    "YXH H ].UXUXUXUXUXUXIXIXLXLXGXDXSXAXAXAXAXkXkXkXaXaXaXaXiXiXuXyXyXyXtX%X%X%X#X@X@X@X@XQ.Q.Q.W.W.E.I.J.J.J.J.J.J.H.J.J.J.J.J.J.J.J.J.J.J.J.H.H.J.J.J.J.H.$.H H YX", 
    "YXA ..CXUXUXUXUXIXIXIXLXLXGXSXSXSXAXAXAXkXkXaXkXaXaXiXiXuXuXuXyXyXtXtX%X%X#X#X@XQ.Q.Q.Q.Q.W.W.E.L.L.L.H.J.J.J.J.J.J.J.J.J.J.H.J.H.J.J.J.J.J.J.J.J.J.J.J.F.W S YX", 
    "A S ].UXUXUXUXIXIXIXLXLXLXSXSXSXAXBXBXkXaXkXaXaXaXiXiXiXuXuXyXyXtXtX%X%X%X#X@X@XQ.@XQ.Q.W.W.E.E.L.L.H.H.H.H.J.H.H.J.H.J.H.J.H.J.J.J.J.H.J.H.H.J.H.J.J.J.F.$.S S ", 
    "A Y dXUXUXUXIXIXPXLXLXGXSXSXSXAXAXBXkXkXkXaXaXaXaXiXiXuXuXyXtX%X#XR.D.C.b.h.f.f.f.f.k.h.h.c.G.G.L.L.H.H.J.J.H.J.J.J.J.J.H.J.J.J.H.J.H.J.J.J.J.J.J.J.H.J.H.z.W S ", 
    "S p.IXUXUXUXIXIXLXLXLXSXSXAXAXAXBXBXkXkXkXaXaXpXiXiXuX7XXXD.j.X.} ' P P U U { } { ' U U L P P ' [ $.:.F.F.J.H.H.J.H.J.H.J.J.H.J.J.J.J.J.J.H.H.J.H.J.J.J.J.F.{ H ", 
    "S A.UXUXUXIXPXLXLXLXSXSXAXAXAXAXkXkXkXkXjXaXiXpXyXXXj.#.U L U ..s.B.'.*X*X=X2X2X2X=X1X*X{._.M.4.>.U J J ] -.k.F.H.H.J.H.J.H.J.J.J.H.J.J.H.J.J.J.J.H.J.J.J.J.3.H ", 
    "S eXUXIXIXPXLXLXSXGXSXAXAXAXBXkXkXkXaXaXaXiX&Xb...P Y X.B.=XsXNXnXMXmXmXmXvXvXvXxXxXvXcXcX6X6X4X,X<X}.m.>.U J { %.c.H.J.J.J.H.J.J.J.J.H.J.J.J.J.J.J.H.J.J.J.:.T ", 
    "L fXUXUXPXLXLXLXGXSXAXAXAXBXkXkXkXkXaXiXXXs.U U <._.-XnXMXMXHXMXbXMXbXbXvXbXxXvXxXcXcXcXcXcX6X6X6X6X6X5X,X|.!.1.U J o.l.H.H.J.J.J.H.H.J.J.J.H.J.H.J.J.J.J.J.:.T ", 
    "Y dXIXPXLXLXGXGXSXAXAXAXBXkXkXkXaXpX.Xa.P ] N.eXnXHXHXMXMXMXMXmXbXbXbXbXbXvXcXxXcXcXcX6X6X6X6X6X5X5X5X4X4X4X4X,X}.6.U J [ k.H.J.J.J.J.J.J.H.J.J.J.J.J.H.J.J.z.W ", 
    "<.VXIXLXLXGXSXSXAXAXAXAXkXkXkXaX7Xs.U Y ].sXFXHXHXMXMXMXMXbXmXmXbXbXbXvXxXxXxXzXcXcXzXzX6X5X6X5X5X5X4X4X4X3X4X4X4X3X|.6.{ J #.z.H.H.H.J.H.J.J.J.J.J.J.H.J.J.x.' ", 
    "X.VXLXLXLXGXSXSXAXAXBXkXkXkXiXA.Y Y B.fXFXHXHXHXMXMXMXMXMXbXbXbXbXbXvXxXxXxXzXzX6XzX6X6X6X5X6X5X4X4X4X4X4X3X4X4X4X4X4X3X:X6.U W ;.F.J.H.J.H.H.J.H.J.J.J.J.J.x.' ", 
    "X.hXLXGXSXSXSXAXAXBXkXkXkXoXp.L a.eXHXJXHXHXHXMXMXMXMXMXmXbXbXbXvXvXxXxXxXzXzXzXcX6X6X6X6X5X4X5X4X3X4X4X;X4.|.4X4X4X4X4X4X4X}.1.T { :.H.J.H.H.J.J.H.J.H.J.J.x.' ", 
    "X.hXLXSXSXAXAXAXBXBXkXkXS.Y Y '.nXKXJXHXHXMXHXMXMXMXmXmXbXbXbXbXvXvXxXxXxXzXzXzX6X6X5X6X6X5X4X4X4X4X4X3X6.Z 1.,X4X4X4X4X4X4X4X>X/.{ W 4.H.H.H.H.J.J.J.J.J.J.x.' ", 
    "X.hXSXSXSXAXAXBXkXkXpXV.L p.sXJXHXHXHXHXHXMXMXMXMXmXmXbXmXvXbXvXvXxXxXcXzXzXzXzX6X6X6X5X4X4X4X4X4X4X4X:X{ J S /.4X4X4X4X4X4X4X4X4X;X1.T +.F.J.J.J.H.J.H.J.J.x.' ", 
    "X.hXSXAXAXAXBXBXBX9Xa.L N.lXKXJXHXHXHXHXMXMXMXMXMXmXbXbXvXvXvXxXxXxXcXcXzXzX6X5X6X6X5X5X4X4X4X4X4X4X4X(.H ( e Y :X4X4X4X4X4X3X4X4X4X>X6.J | x.J.J.J.J.J.J.J.x.W ", 
    "X.pXSXAXBXBXkXBXqXp.L ].FXJXJXHXHXHXHXMXMXMXMXMXmXbXbXbXmXvXxXxXcXcXcX6XzXzX6X6X6X5X5X5X4X4X4X4X4X4X3X3.W N y Z m.4X4X4X4X4X4X4X4X3X4X3X^.{ W :.H.H.J.H.J.J.x.' ", 
    "X.fXAXAXBXBXkXqXp.Y '.FXJXJXHXHXHXHXMXMXMXMXbXbXmXbXbXbXvXvXxXxXcXcXcX6X6XzX6X5X5X5X4X4X4X4X4X4X4X4X>X{ O.=.p e J |.4X3X4X3X4X4X4X4X4X4X3X/.{ W x.J.J.J.J.J.x.{ ", 
    "X.rXAXZXkXkXwX7.U '.JXJXHXHXHXHXMXMXMXMXMXmXbXbXmXbXbXxXxXxXcXcXcXcX6X6X6X6X6X5X4X4X4X4X3X4X4X4X4X4X).L -.N d f Z 3.3X3X4X4X4X4X4X4X4X4X4X3X).{ ' F.J.H.H.H.F.' ", 
    "X.rXAXkXkXrXa.I '.JXJXJXHXHXHXMXMXMXMXMXMXmXbXbXbXbXvXxXxXxXcXcXcX6X6X6X6X6X6X4X4X4X4X4X4X4X4X4X4X4X6.P 8.f P ( T S [.3X4X3X4X4X4X4X4X4X4X4X3X/.J [ F.H.H.H.F.' ", 
    "..iXZXkXaXj.L ].FXJXJXHXHXHXMXMXMXMXMXbXbXbXbXbXvXvXxXxXcXzXzXzX6XcX6X6X6X5X5X4X4X4X4X4X4X4X4X4X4X>X{ ! m e Z ! u D 1.,X4X4X4X3X4X4X4X4X3X4X4X3X^.J $.H.H.H.x.{ ", 
    "X.qXkXkX'.L V.HXJXJXHXHXHXHXMXMXMXMXMXbXbXbXbXvXvXvXxXcXzXzXzXzX6X6X6X5X5X5X4X3X4X4X4X4X4X4X4X4X5X}.G ` a F Z P ) t H [.4X4X4X4X4X4X3X4X4X4X4X4X4X6.H :.H.H.x.W ", 
    "..qXBX9X} <.lXKXJXJXHXHXMXMXMXMXMXbXbXbXbXbXvXvXvXxXcXzXcXzXzXzX6X6X5X5X5X4X4X4X4X4X4X4X4X4X4X4X4Xn.P *.u D 1.P +.u G >.>X4X4X4X4X4X4X4X4X4X4X4X4X:X1.W z.J.F.W ", 
    "..qXrXa.U eXHXHXJXHXHXFXMXMXMXMXMXbXbXbXbXbXvXxXxXcXzXzXzXzX6X6X5X6X5X5X4X4X4X4X4X4X4X4X4X3X4X4X,X| W n r J [.| ! *.u H /.4X4X4X3X4X3X4X4X4X4X3X4X4X[.{ | F.F.W ", 
    "..0XA.H <.dXHXHXHXHXFXMXMXMXMXMXbXbXbXbXvXvXxXxXcXcXzXzX6X6X6X6X5X5X5X4X4X4X4X3X4X4X4X3X3X4X4X4X}.J ( v e | 3Xm.J :.a T 3.3X4X3X4X4X4X4X3X4X3X4X4X4X;X1.H ;.F.' ", 
    "..7XoX7.U ..'.nXFXMXMXMXMXMXbXbXbXbXbXbXvXxXcXxXcXzXzX6X6X6X6X6X6X5X4X4X3X4X4X4X4X4X4X4X4X4X4X3X!.J l g D 6.4X).G r.b T W :X4X4X3X4X4X3X4X4X4X4X>X^.| J o.:.F.W ", 
    "X.0XaXuXS.<.L <..XnXMXMXMXmXmXmXmXbXvXxXxXxXxXxX6XzX6X6X6X6X6X6X5X4X4X3X4X4X4X3X3X4X4X4X4X4X4X3X>.W n t Z {.4X|.J +.V d F {.4X4X4X4X4X4X4X4X>X/.>.J ' :.F.J.F.{ ", 
    " .$XiXuXuX%XC. .U <.*XnXmXMXvXmXvXvXxXxXcXcXcXzXzXzX6X6X6X6X4X4X4X4X4X4X4X4X4X4X4X4X4X4X4X4X3X|.U ! v e { :X4X,X'  .8.d S [.4X4X4X4X4X4X>X[.1.J { :.H.J.J.J.x.W ", 
    "..$XiXuXuXuXtX&Xb.] L d.=XxXvXvXvXvXxXxXcXxXzX6X6X6X6X5X5X5X5X4X4X3X4X3X3X4X3X4X4X3X4X4X4X4X4X!.J ) u D 6.3X3X>X{  .9.E Z {.5X4X4X4X3X[.1.J { ;.F.J.H.H.J.J.F.W ", 
    "X.$XuXuXyXtXtXtX#XXXh.U U s.=XvXvXxXcXcXcXcXzX6X6X6X5X5X5X4X4X4X4X4X4X4X4X4X4X4X4X4X3X4X4X4X3X3.T n y A (.4X4X;XH _ 9.d H }.5X4X3X}.3.U W $.F.F.H.H.J.H.J.J.z.W ", 
    " .$XuXyXyXtX%X%X#X#X@XR.2.' U n.1XcXcXzXxX6XzX6X6X6X5X5X4X4X4X4X4X4X4X3X4X3X3X3X3X3X4X4X4X4X:XP ! v r J :X4X3X~.F -.*.r { :X3X|.6.W J %.F.J.J.J.H.H.J.J.J.J.F.T ", 
    "..&XyXtXtX%X%X%X%X#X+X@XOXK.%.P ' M.1XzXcX6X6X6X6X6X5X5X4X4X4X4X4X4X3X>X{.^.6.6.6.n.~.[.:X4X/.Z ) p F >.4X4X;XU K *.l F 1.|.6.U J +.l.H.H.J.J.H.H.H.H.J.J.J.F.{ ", 
    "| &XyX8XtX%X%X#X#X#X@X+XQ.Q.T.v.#.J } B.<X6X6X5X5X5X6X4X4X4X3X4X3X}.6.{ U J J J F H L P } n.} P n u Z ~.4X|.| Z d N E Z >.{ J o.l.H.H.H.H.H.J.J.H.H.J.J.J.J.F.W ", 
    " .&XtX8X%X%X#X@X@XQ.OXQ.Q.Q.Q.W.L.c.[ J | ^.<X6X5X5X4X4X4X4X4X;X6.U J [ o.R J J P J G Q [ H 8 Q j T J |.,X>.Z E l k D Z J o.k.J.J.H.H.H.H.H.H.J.H.H.J.H.J.J.F.W ", 
    " .XX%X%X%X#X@X@XOXOXOXQ.Q.W.W.E.I.L.H.g.[ J >./.,X3X4X3X4X4X[.{ J o.:.] K  .&.r.@. .W F ^ ^ S k a w | 3X`.L d m l K Z Q g.F.J.J.J.J.H.J.H.J.J.J.J.J.J.H.H.H.F.' ", 
    " .XXtX%X#X#X@X+XOXOXQ.Q.E.E.E.I.L.L.L.J.G.:.Q J >.).,X4X3X`.{ U k.k.R ' y.i.i.u.w.w.8.` K 7 K l g Z 4.4X`.P d k K F @.G.J.J.J.J.H.J.J.J.H.J.H.J.H.H.J.J.H.H.l.{ ", 
    " . X%X#X#X@X@X+XQ.Q.Q.W.W.E.I.L.J.L.J.J.H.L.F.;.W J 1.[.}.U ' z.G.K U y.u.u.w.q.q.0.0.9.) L e a f 8 U {.(.H 7 H K t.H.H.J.J.J.J.J.J.H.J.J.H.J.J.J.J.J.J.H.J.z.W ", 
    "|  X%X@X@X@XQ.Q.Q.Q.W.W.E.L.L.L.J.J.J.J.H.H.H.H.x.;.W U U U l.J.+.F y.u.w.q.q.q.0.=.V M m k h n G F H U U P [ :.G.H.H.H.J.J.J.J.H.J.J.J.J.J.J.H.H.J.J.J.J.J.F.W ", 
    "[ T.#X#XQ.@XQ.Q.Q.W.W.E.L.L.L.J.J.J.J.J.H.H.H.J.J.J.F.+.W :.H.F.K Q w.q.0.0.0.C V b v v v v v h q ! t.I %.x.J.J.J.J.J.J.J.J.J.J.J.H.J.H.H.J.J.J.J.J.J.J.H.H.F.W ", 
    "} T.@X@XQ.Q.Q.Q.W.E.E.L.L.L.L.J.H.J.H.J.H.H.J.J.H.J.H.F.F.H.H.z.F +.0.0.C 0.C B b c c v v v m d Z :.F.F.J.J.J.J.J.F.J.J.J.J.J.J.J.H.J.J.J.J.H.J.J.H.J.H.H.H.F.W ", 
    " .Y.@XQ.Q.Q.Q.W.W.E.L.L.L.L.H.J.J.J.J.H.J.J.H.J.H.J.J.J.J.J.J.k.7 ) =.V V B M c p c c v v n n K F z.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.H.J.J.J.H.J.J.J.H.H.H.F.' ", 
    "] U.Q.+XQ.Q.W.W.E.E.L.L.J.H.J.J.H.J.J.J.H.H.J.J.J.H.J.J.J.J.J.t.Z h V V M M v x c v v v b m a q Q J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.H.J.J.J.H.J.H.J.H.J.J.H.H.z.' ", 
    " .U.Q.Q.Q.W.W.E.J.I.L.J.J.J.J.J.H.J.J.J.J.H.H.J.J.J.J.H.H.J.J.k.Z g b b n c c x v v v v n m k Z @.J.J.J.J.J.H.J.J.H.J.J.H.J.J.H.H.J.J.J.J.H.J.J.J.J.H.J.J.J.F.W ", 
    "} U.Q.Q.W.W.I.E.E.J.J.J.J.J.J.J.J.J.H.J.J.J.J.J.J.H.J.J.J.J.J.z.F r c v c c c v v v v v m n G F z.J.J.J.H.J.J.H.H.J.H.J.J.H.H.J.J.J.H.J.J.J.H.J.H.J.J.J.H.J.F.W ", 
    "! P.Q.W.W.I.E.E.J.J.J.J.J.J.J.J.H.J.J.J.H.J.H.H.J.J.J.H.H.J.H.H.o.w i x x c c v v m v m m h F O.H.J.J.J.H.J.H.J.J.J.H.H.J.J.J.J.H.J.H.J.J.J.J.J.J.J.H.J.H.H.F.' ", 
    "] P.W.E.E.E.L.J.J.J.J.J.J.J.J.J.J.J.H.H.J.J.J.J.H.H.J.J.H.H.H.J.z.J w p c c v v v v m m j G K z.J.J.J.J.J.J.J.J.J.H.J.J.H.H.J.H.J.J.J.J.H.J.H.J.J.H.J.J.H.H.z.' ", 
    "' K.W.E.I.J.J.J.J.J.J.J.J.J.J.J.J.J.H.J.J.J.J.J.J.J.J.J.J.H.H.J.J.;.F r p v v b m n m j e F :.H.J.J.J.H.J.J.H.J.H.J.J.H.J.J.H.J.H.J.J.J.J.J.J.J.H.J.H.J.J.J.z.W ", 
    "' K.E.I.E.J.J.H.J.J.J.J.J.J.J.J.H.J.J.J.H.H.J.H.H.J.H.J.J.J.J.J.J.H.;.J F r g h h g f K F -.H.H.J.J.J.J.H.J.J.J.J.H.J.J.H.J.J.H.J.J.J.H.H.J.J.J.J.J.J.J.J.J.F.' ", 
    "] G.I.I.J.J.J.H.H.J.J.J.J.J.J.J.J.J.H.J.J.J.J.J.J.J.J.J.H.H.J.H.J.J.H.k.! F F F F Z 7 I t.J.J.J.J.H.J.H.J.J.J.J.J.H.J.H.H.J.J.H.H.J.H.J.J.J.J.J.H.J.J.J.J.J.F.W ", 
    "] G.I.J.G.@.O.l.F.J.J.J.J.J.J.J.H.J.J.J.H.J.H.J.J.H.J.H.J.J.J.J.J.J.J.J.F.z.+.o.o.O.y.F.J.J.J.H.J.J.J.J.J.H.J.H.H.J.J.H.J.J.H.J.J.J.J.J.H.J.J.J.J.J.J.J.J.J.F.W ", 
    "' F.L.L.-.; # 5 F.H.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.H.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.H.H.J.J.J.J.H.J.F.F.H.J.J.H.H.F.' ", 
    "' F.J.J._ # . 1 x.J.J.J.J.J.J.J.J.J.J.J.H.J.H.J.H.J.H.J.J.J.J.J.J.J.J.F.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.H.H.J.H.J.J.J.J.J.J.H.J.J.F.T 3 -.H.L.H.H.z.' ", 
    "' x.J.J.+.& o e F.J.J.J.J.J.J.J.J.J.J.J.J.H.J.J.J.J.J.J.H.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.H.H.J.J.J.J.H.J.H.J.H.H.J.F.+.$ o - +.:.z.H.z.' ", 
    "Q F.J.J.+.$ + T G.F.J.J.J.J.J.J.J.J.J.J.J.J.J.H.J.H.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.F.J.J.J.J.J.J.H.J.J.H.J.J.J.H.H.z.O.r - o X o $ * 3 :.F.' ", 
    "' z.H.J._ $ + ~ F.J.J.J.J.J.F.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.F.F.F.J.J.J.J.J.J.J.J.H.H.J.J.J.H.J.J.J.J.F.0 # o X X X o + + & #.F.' ", 
    "' F.J.J._ # + o.J.J.J.J.J.J.J.J.J.J.J.J.z./ E :.F.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.J.F.t.T 0 T t.J.J.J.J.J.J.J.H.F.F.F.H.J.H.J.J.J.F.T > > $ . O 2 T ! +.F.z.' ", 
    "U F.J.J._ # + O.J.J.J.J.J.J.J.J.J.J.J.J.+.& O 9 z.J.J.J.H.z.-.l.J.J.F.J.J.J.J.J.J.J.J.-.> O . + 0 F.J.J.J.J.J.x./ 5 2 5 ` z.J.J.J.H.H.F.l.:.1 . $ +.J.J.J.J.x.Q ", 
    "T F.J.J./ # + +.J.J.J.J.J.J.J.J.J.J.J.J.:.6 < / H.J.J.J.z.0 ; e k./ r -.F.J.J.J.J.J.z.5 o @ O o 5 x.J.J.J.J.F.~ & + + o # 0 F.J.J.J.H.H.H.F.> . * :.J.J.H.J.x.Q ", 
    "U z.L.H./ # + +.J.J.J.J.J.J.J.H.J.J.J.H.-.< < ;.L.J.J.J.:.* . - < # O ; / J.H.H.J.J.:.- o 7 = X 0 H.J.J.J.J.F.4 X - 0 & X % / F.H.H.J.J.J.:.- X = l.J.J.J.J.z.J ", 
    "J l.J.J.! @ # +.J.J.J.J.J.J.J.H.J.H.J.F.9 o # T J.J.J.J.:.* . o X # # X < F.H.H.J.J.:.- O , % X 6 F.J.J.J.J.:.- o T F.! & o = +.J.H.J.J.J.;.& X < z.J.J.J.J.l.H ", 
    "H :.L.H.! + + O.H.H.J.J.J.J.J.H.J.J.J.F.1 X * ;.J.J.J.J.+.$ . . # T G o % $.H.H.J.J.H.9 o X X X - :.J.J.H.H.F.- O r H.J.T O o T F.J.J.J.J.! + o 5 F.J.H.J.J.k.H ", 
    "H $.J.H.T o + 6 T ! +.+.:.k.F.H.J.J.J.:.= X - z.J.J.J.J.! @ . O 9 F.~ o + / H.H.J.J.J.:.6 - - # @ / J.J.H.H.F.9 O > :.:.T O X T F.J.J.J.J.~ O O T F.J.H.J.J.$.H ", 
    "S ! H.l.2 X X o @ # @ # * - e z.J.J.J.;.& o 3 F.H.H.H.H.T # . = :.H./ # # T F.J.J.J.L.J.F.F.:.r O 3 :.H.J.J.H.$.; + > < # o - +.J.H.J.J.F.T O O / H.H.H.J.F.] S ", 
    "S J l.F.T < < 3 5 5 3 1 - & 4 -.J.J.J.:.1 - _ H.H.H.H.H.-.2 < ! H.H.:.2 * T F.J.H.F.:.H.H.H.J.+.% # / H.J.J.H.H.+.< & & = 3 +.F.J.J.J.J.H.+.3 3 g.J.H.H.J.z.J S ", 
    "S H 3.H.F.l.l.F.F.F.H.x.k.-.:.H.J.J.J.H.k.:.H.J.H.H.H.H.F.F.l.H.H.H.H.:.-.F.H.J.H.T < T F.H.H.F.3 o 3 F.J.H.H.H.J.z.-.;.:.F.H.H.J.J.H.J.J.H.:.H.H.H.J.J.J.+.H S ", 
    "YXS T F.J.H.H.H.J.J.J.J.J.J.J.J.J.J.J.J.H.H.H.H.J.H.H.H.H.J.J.H.H.H.H.H.H.H.J.J.F.r o & T :.:.:.> o 5 F.J.H.H.H.J.J.J.J.J.J.J.J.J.J.J.J.H.J.J.J.J.J.J.J.x.' H YX", 
    "YXH S $.H.H.H.J.J.J.J.H.J.J.J.J.J.H.J.H.J.J.J.J.J.J.J.J.H.H.J.J.J.J.H.J.H.J.J.J.J.:.3 # + = = * @ - +.H.J.H.J.H.J.H.J.J.J.J.J.J.H.J.H.J.J.J.J.J.J.J.J.H.$.H H YX", 
    "YXH H J k.J.H.H.J.H.J.J.J.J.J.J.J.J.J.J.H.J.H.H.J.H.J.H.J.J.H.J.H.J.J.J.H.J.H.J.J.L.:.~ 9 > 2 3 T :.H.H.J.J.J.J.J.J.H.J.H.J.H.J.J.J.J.J.J.H.H.J.H.J.L.:.P S H YX", 
    "YXYXH S Q z.J.J.J.H.J.H.J.J.J.J.H.J.H.J.J.J.J.J.J.J.J.J.H.J.J.J.J.J.J.J.J.H.J.J.J.J.J.J.F.:.F.F.H.H.H.H.H.J.H.H.J.J.J.J.J.J.H.H.J.J.H.J.H.H.H.H.H.H.F.W S H YXYX", 
    "YXYXYXH H [ x.J.J.J.J.J.J.J.J.J.J.J.J.J.J.H.H.J.H.J.H.J.J.J.J.H.H.J.J.J.J.J.J.H.J.J.J.J.J.L.H.H.H.H.H.H.J.J.H.H.H.J.H.J.H.J.H.H.H.J.H.J.H.H.H.H.H.F.{ H H YXYXYX", 
    "YXYXYXYXH H Q k.H.J.J.J.J.J.J.J.H.J.J.J.H.H.H.H.J.H.H.H.J.J.J.J.J.J.J.J.H.H.H.H.J.J.J.J.H.H.H.H.H.H.H.H.H.H.H.H.J.J.H.H.H.H.H.H.J.J.J.J.J.J.H.H.:./ H H YXYXYXYX", 
    "YXYXYXYXYXH H P %.x.J.J.J.J.J.J.J.J.J.J.H.F.H.H.J.H.H.H.J.J.J.J.J.J.J.J.H.H.H.F.J.J.J.J.H.F.H.H.H.H.H.H.J.J.H.H.J.J.H.F.J.H.H.H.J.J.J.L.J.J.F.$.W H H YXYXYXYXYX", 
    "YXYXYXYXYXH H H J U #.:.z.z.x.x.F.F.F.F.F.F.z.F.F.F.F.l.F.F.F.F.F.z.F.F.F.F.F.F.F.F.F.F.F.F.z.F.F.F.z.F.F.F.F.z.F.F.F.F.F.F.F.z.F.F.z.:.:.$.W H S S S YXYXYXYXYX", 
    "YXYXYXYXYXYXYXYXJ S S J J ' ' ' W ' { T W { W W W W W W W W W W W W W ' ' T W { T { W W { W W W W W W W W W W W W W W W W W W W W { W J W H S S YXYXYXYXYXYXYXYX" };
// message
// file lingot-msg.c line 31
char message[5l][1000l];
// message_queue_mutex
// file lingot-msg.c line 36
union anonymous message_queue_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// message_type
// file lingot-msg.c line 32
enum message_type_t message_type[5l];
// noise_threshold_color
// file lingot-gui-mainframe.c line 53
struct _GdkColor noise_threshold_color;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// option_formats
// file lingot-config.c line 49
const char *option_formats = "mssddffdffffddfddf|d";
// options
// file lingot-config.c line 40
char *options[21l] = { "AUDIO_SYSTEM", "AUDIO_DEV", "AUDIO_DEV_ALSA", "SAMPLE_RATE", "OVERSAMPLING", "ROOT_FREQUENCY_ERROR", "MIN_FREQUENCY", "FFT_SIZE", "TEMPORAL_WINDOW", "NOISE_THRESHOLD", "CALCULATION_RATE", "VISUALIZATION_RATE", "PEAK_NUMBER", "PEAK_HALF_WIDTH", "PEAK_REJECTION_RELATION", "DFT_NUMBER", "DFT_SIZE", "GAIN", "|", "PEAK_ORDER", (char *)(void *)0 };
// rear
// file lingot-msg.c line 34
signed int rear = 0;
// spectrum_background_color
// file lingot-gui-mainframe.c line 51
struct _GdkColor spectrum_background_color;
// spectrum_bottom_margin
// file lingot-gui-mainframe.c line 65
signed int spectrum_bottom_margin = 16;
// spectrum_color
// file lingot-gui-mainframe.c line 52
struct _GdkColor spectrum_color;
// spectrum_legend_font_desc
// file lingot-gui-mainframe.c line 69
struct _PangoFontDescription *spectrum_legend_font_desc;
// spectrum_size_y
// file lingot-gui-mainframe.c line 62
signed int spectrum_size_y = 64;
// spectrum_top_margin
// file lingot-gui-mainframe.c line 66
signed int spectrum_top_margin = 12;
// spectrum_x_margin
// file lingot-gui-mainframe.c line 67
signed int spectrum_x_margin = 15;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// stop_mutex
// file lingot-audio-jack.c line 35
union anonymous stop_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// wn
// file lingot-fft.c line 38
struct _LingotComplex *wn = (struct _LingotComplex *)(void *)0;

// _lingot_fft_fft
// file lingot-fft.c line 63
void _lingot_fft_fft(double *in, struct _LingotComplex *out, unsigned long int N, unsigned long int offset, unsigned long int d1, unsigned long int step)
{
  struct _LingotComplex X1;
  struct _LingotComplex X2;
  unsigned long int Np2 = N >> 1;
  unsigned long int a;
  unsigned long int b;
  unsigned long int c;
  unsigned long int q;
  if(N == 2ul)
  {
    X1.r = in[(signed long int)offset];
    X1.i = 0.0;
    X2.r = in[(signed long int)(offset + step)];
    X2.i = 0.0;
    lingot_complex_add(&X1, &X2, &out[(signed long int)d1]);
    lingot_complex_sub(&X1, &X2, &out[(signed long int)(d1 + Np2)]);
  }

  else
  {
    _lingot_fft_fft(in, out, Np2, offset, d1, step << 1);
    _lingot_fft_fft(in, out, Np2, offset + step, d1 + Np2, step << 1);
    q = (unsigned long int)0;
    c = (unsigned long int)0;
    for( ; !(q >= N >> 1); c = c + step)
    {
      a = q + d1;
      b = a + Np2;
      X1 = out[(signed long int)a];
      lingot_complex_mul(&out[(signed long int)b], &wn[(signed long int)c], &X2);
      lingot_complex_add(&X1, &X2, &out[(signed long int)a]);
      lingot_complex_sub(&X1, &X2, &out[(signed long int)b]);
      q = q + 1ul;
    }
  }
}

// audio_system_t_to_str
// file lingot-config.c line 52
const char * audio_system_t_to_str(enum audio_system_t audio_system)
{
  const char *values[3l] = { "OSS", "ALSA", "JACK" };
  return values[(signed long int)audio_system];
}

// lingot_audio_alsa_destroy
// file lingot-audio-alsa.h line 29
void lingot_audio_alsa_destroy(struct _LingotAudioHandler *audio)
{
  if(!(audio == ((struct _LingotAudioHandler *)NULL)))
  {
    snd_pcm_close(audio->capture_handle);
    free((void *)audio->read_buffer);
  }

}

// lingot_audio_alsa_get_audio_system_properties
// file lingot-audio-alsa.h line 31
struct _LingotAudioSystemProperties * lingot_audio_alsa_get_audio_system_properties(enum audio_system_t audio_system)
{
  struct _LingotAudioSystemProperties *result;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)1 * sizeof(struct _LingotAudioSystemProperties) /*32ul*/ );
  result = (struct _LingotAudioSystemProperties *)return_value_malloc$1;
  result->forced_sample_rate = 0;
  result->n_devices = 0;
  result->devices = (char **)(void *)0;
  result->n_sample_rates = 5;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)result->n_sample_rates * sizeof(signed int) /*4ul*/ );
  result->sample_rates = (signed int *)return_value_malloc$2;
  result->sample_rates[(signed long int)0] = 8000;
  result->sample_rates[(signed long int)1] = 11025;
  result->sample_rates[(signed long int)2] = 22050;
  result->sample_rates[(signed long int)3] = 44100;
  result->sample_rates[(signed long int)4] = 48000;
  return result;
}

// lingot_audio_alsa_new
// file lingot-audio-alsa.h line 28
struct _LingotAudioHandler * lingot_audio_alsa_new(char *device, signed int sample_rate)
{
  struct _LingotAudioHandler *audio = (struct _LingotAudioHandler *)(void *)0;
  const char *exception;
  struct _snd_pcm_hw_params *hw_params = (struct _snd_pcm_hw_params *)(void *)0;
  signed int err;
  char error_message[1000l];
  unsigned int channels = (unsigned int)1;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _LingotAudioHandler) /*248ul*/ );
  audio = (struct _LingotAudioHandler *)return_value_malloc$1;
  audio->read_buffer = (signed short int *)(void *)0;
  audio->audio_system = AUDIO_SYSTEM_ALSA;
  audio->read_buffer_size = 128;
  snd_config_update_free_global();
  audio->capture_handle = (struct _snd_pcm *)(void *)0;
  exception = ((const char *)NULL);
  do
  {
    err=snd_pcm_open(&audio->capture_handle, device, (enum _snd_pcm_stream)SND_PCM_STREAM_CAPTURE, 0);
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror$2;
      return_value_snd_strerror$2=snd_strerror(err);
      sprintf(error_message, "Cannot open audio device %s.\n%s.", device, return_value_snd_strerror$2);
      exception = error_message;
      break;
    }

    strcpy(audio->device, device);
    err=snd_pcm_hw_params_malloc(&hw_params);
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror$3;
      return_value_snd_strerror$3=snd_strerror(err);
      sprintf(error_message, "Cannot allocate hardware parameter structure.\n%s.", return_value_snd_strerror$3);
      exception = error_message;
      break;
    }

    err=snd_pcm_hw_params_any(audio->capture_handle, hw_params);
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror$4;
      return_value_snd_strerror$4=snd_strerror(err);
      sprintf(error_message, "Cannot initialize hardware parameter structure.\n%s.", return_value_snd_strerror$4);
      exception = error_message;
      break;
    }

    err=snd_pcm_hw_params_set_access(audio->capture_handle, hw_params, (enum _snd_pcm_access)SND_PCM_ACCESS_RW_INTERLEAVED);
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror$5;
      return_value_snd_strerror$5=snd_strerror(err);
      sprintf(error_message, "Cannot set access type.\n%s", return_value_snd_strerror$5);
      exception = error_message;
      break;
    }

    err=snd_pcm_hw_params_set_format(audio->capture_handle, hw_params, (enum _snd_pcm_format)SND_PCM_FORMAT_S16_LE);
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror$6;
      return_value_snd_strerror$6=snd_strerror(err);
      sprintf(error_message, "Cannot set sample format.\n%s.", return_value_snd_strerror$6);
      exception = error_message;
      break;
    }

    unsigned int rate = (unsigned int)sample_rate;
    err=snd_pcm_hw_params_set_rate_near(audio->capture_handle, hw_params, &rate, ((signed int *)NULL));
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror$7;
      return_value_snd_strerror$7=snd_strerror(err);
      sprintf(error_message, "Cannot set sample rate.\n%s.", return_value_snd_strerror$7);
      exception = error_message;
      break;
    }

    audio->real_sample_rate = rate;
    err=snd_pcm_hw_params_set_channels(audio->capture_handle, hw_params, channels);
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror$8;
      return_value_snd_strerror$8=snd_strerror(err);
      sprintf(error_message, "Cannot set channel count.\n%s.", return_value_snd_strerror$8);
      exception = error_message;
      break;
    }

    err=snd_pcm_hw_params(audio->capture_handle, hw_params);
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror$9;
      return_value_snd_strerror$9=snd_strerror(err);
      sprintf(error_message, "Cannot set parameters.\n%s.", return_value_snd_strerror$9);
      exception = error_message;
      break;
    }

    err=snd_pcm_prepare(audio->capture_handle);
    if(!(err >= 0))
    {
      const char *return_value_snd_strerror$10;
      return_value_snd_strerror$10=snd_strerror(err);
      sprintf(error_message, "Cannot prepare audio interface for use.\n%s.", return_value_snd_strerror$10);
      exception = error_message;
      break;
    }

    void *return_value_malloc$11;
    return_value_malloc$11=malloc((unsigned long int)(channels * (unsigned int)audio->read_buffer_size) * sizeof(signed short int) /*2ul*/ );
    audio->read_buffer = (signed short int *)return_value_malloc$11;
    memset((void *)audio->read_buffer, 0, (unsigned long int)audio->read_buffer_size * sizeof(signed short int) /*2ul*/ );
  }
  while((_Bool)0);
  if(!(exception == ((const char *)NULL)))
  {
    if(!(audio->capture_handle == ((struct _snd_pcm *)NULL)))
      snd_pcm_close(audio->capture_handle);

    free((void *)audio);
    audio = (struct _LingotAudioHandler *)(void *)0;
    lingot_msg_add_error(exception);
  }

  if(!(hw_params == ((struct _snd_pcm_hw_params *)NULL)))
    snd_pcm_hw_params_free(hw_params);

  return audio;
}

// lingot_audio_alsa_read
// file lingot-audio-alsa.h line 30
signed int lingot_audio_alsa_read(struct _LingotAudioHandler *audio)
{
  signed int temp_sret;
  signed int i;
  signed long int return_value_snd_pcm_readi$1;
  return_value_snd_pcm_readi$1=snd_pcm_readi(audio->capture_handle, (void *)audio->read_buffer, (unsigned long int)audio->read_buffer_size);
  temp_sret = (signed int)return_value_snd_pcm_readi$1;
  if(!(temp_sret == audio->read_buffer_size))
  {
    char buff[100l];
    char *return_value_gettext$2;
    return_value_gettext$2=gettext("Read from audio interface failed.\n%s.");
    const char *return_value_snd_strerror$3;
    return_value_snd_strerror$3=snd_strerror(temp_sret);
    sprintf(buff, (const char *)return_value_gettext$2, return_value_snd_strerror$3);
    lingot_msg_add_error(buff);
    return -1;
  }

  i = 0;
  for( ; !(i >= audio->read_buffer_size); i = i + 1)
    audio->flt_read_buffer[(signed long int)i] = (double)audio->read_buffer[(signed long int)i];
  return 0;
}

// lingot_audio_audio_system_properties_destroy
// file lingot-audio.c line 138
void lingot_audio_audio_system_properties_destroy(struct _LingotAudioSystemProperties *properties)
{
  signed int i = 0;
  for( ; !(i >= properties->n_devices); i = i + 1)
    free((void *)properties->devices[(signed long int)i]);
  if(!(properties->sample_rates == ((signed int *)NULL)))
    free((void *)properties->sample_rates);

  if(!(properties->devices == ((char **)NULL)))
    free((void *)properties->devices);

}

// lingot_audio_destroy
// file lingot-audio.c line 68
void lingot_audio_destroy(struct _LingotAudioHandler *audio)
{
  if(!(audio == ((struct _LingotAudioHandler *)NULL)))
  {
    free((void *)audio->flt_read_buffer);
    switch(audio->audio_system)
    {
      case AUDIO_SYSTEM_OSS:
      {
        lingot_audio_oss_destroy(audio);
        break;
      }
      case AUDIO_SYSTEM_ALSA:
      {
        lingot_audio_alsa_destroy(audio);
        break;
      }
      case AUDIO_SYSTEM_JACK:
      {
        lingot_audio_jack_destroy(audio);
        break;
      }
      default:
        perror("unknown audio system\n");
    }
    free((void *)audio);
  }

}

// lingot_audio_get_audio_system_properties
// file lingot-audio.c line 115
struct _LingotAudioSystemProperties * lingot_audio_get_audio_system_properties(enum audio_system_t audio_system)
{
  struct _LingotAudioSystemProperties *result;
  switch((signed int)audio_system)
  {
    case AUDIO_SYSTEM_OSS:
    {
      result=lingot_audio_oss_get_audio_system_properties(audio_system);
      break;
    }
    case AUDIO_SYSTEM_ALSA:
    {
      result=lingot_audio_alsa_get_audio_system_properties(audio_system);
      break;
    }
    case AUDIO_SYSTEM_JACK:
    {
      result=lingot_audio_jack_get_audio_system_properties(audio_system);
      break;
    }
    default:
    {
      perror("unknown audio system\n");
      result = (struct _LingotAudioSystemProperties *)(void *)0;
    }
  }
  return result;
}

// lingot_audio_jack_destroy
// file lingot-audio-jack.h line 29
void lingot_audio_jack_destroy(struct _LingotAudioHandler *audio)
{
  if(!(audio == ((struct _LingotAudioHandler *)NULL)))
  {
    jack_client_close(audio->jack_client);
    client = (struct _jack_client *)(void *)0;
  }

}

// lingot_audio_jack_get_audio_system_properties
// file lingot-audio-jack.h line 31
struct _LingotAudioSystemProperties * lingot_audio_jack_get_audio_system_properties(enum audio_system_t audio_system)
{
  struct _LingotAudioSystemProperties *properties = (struct _LingotAudioSystemProperties *)(void *)0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)1 * sizeof(struct _LingotAudioSystemProperties) /*32ul*/ );
  properties = (struct _LingotAudioSystemProperties *)return_value_malloc$1;
  signed int sample_rate = -1;
  const char *client_name = "lingot-get-sample-rate";
  const char *server_name = (const char *)(void *)0;
  enum JackOptions lingot_audio_jack_get_audio_system_properties$$1$$options = (enum JackOptions)JackNoStartServer;
  enum JackStatus status;
  struct _jack_client *jack_client = (struct _jack_client *)(void *)0;
  const char **ports = (const char **)(void *)0;
  const char *exception;
  unsigned long int flags = (unsigned long int)2;
  exception = ((const char *)NULL);
  do
    if(!(client == ((struct _jack_client *)NULL)))
    {
      unsigned int return_value_jack_get_sample_rate$2;
      return_value_jack_get_sample_rate$2=jack_get_sample_rate(client);
      sample_rate = (signed int)return_value_jack_get_sample_rate$2;
      ports=jack_get_ports(client, (const char *)(void *)0, (const char *)(void *)0, flags);
    }

    else
    {
      jack_client=jack_client_open(client_name, lingot_audio_jack_get_audio_system_properties$$1$$options, &status, server_name);
      if(jack_client == ((struct _jack_client *)NULL))
      {
        char *return_value_gettext$3;
        return_value_gettext$3=gettext("Unable to connect to JACK server");
        exception = (const char *)return_value_gettext$3;
        goto __CPROVER_DUMP_L7;
      }

      if(!((JackServerStarted & (signed int)status) == 0))
        fprintf(stderr, "JACK server started\n");

      if(!((JackNameNotUnique & (signed int)status) == 0))
      {
        client_name=jack_get_client_name(jack_client);
        fprintf(stderr, "unique name `%s' assigned\n", client_name);
      }

      unsigned int return_value_jack_get_sample_rate$4;
      return_value_jack_get_sample_rate$4=jack_get_sample_rate(jack_client);
      sample_rate = (signed int)return_value_jack_get_sample_rate$4;
      ports=jack_get_ports(jack_client, (const char *)(void *)0, (const char *)(void *)0, flags);
    }
  while((_Bool)0);

__CPROVER_DUMP_L7:
  ;
  if(!(exception == ((const char *)NULL)))
    lingot_msg_add_warning(exception);

  properties->forced_sample_rate = 1;
  properties->n_devices = 0;
  properties->devices = (char **)(void *)0;
  if(!(ports == ((const char **)NULL)))
  {
    signed int i = 0;
    for( ; !(ports[(signed long int)i] == ((const char *)NULL)); i = i + 1)
      ;
    properties->n_devices = i;
    if(!(properties->n_devices == 0))
    {
      void *return_value_malloc$5;
      return_value_malloc$5=malloc((unsigned long int)properties->n_devices * sizeof(char *) /*8ul*/ );
      properties->devices = (char **)return_value_malloc$5;
      i = 0;
      for( ; !(ports[(signed long int)i] == ((const char *)NULL)); i = i + 1)
        properties->devices[(signed long int)i]=strdup(ports[(signed long int)i]);
    }

  }

  if(sample_rate == -1)
  {
    properties->n_sample_rates = 0;
    properties->sample_rates = (signed int *)(void *)0;
  }

  else
  {
    properties->n_sample_rates = 1;
    void *return_value_malloc$6;
    return_value_malloc$6=malloc((unsigned long int)properties->n_sample_rates * sizeof(signed int) /*4ul*/ );
    properties->sample_rates = (signed int *)return_value_malloc$6;
    properties->sample_rates[(signed long int)0] = sample_rate;
  }
  if(!(ports == ((const char **)NULL)))
    free((void *)ports);

  if(!(jack_client == ((struct _jack_client *)NULL)))
    jack_client_close(jack_client);

  return properties;
}

// lingot_audio_jack_new
// file lingot-audio-jack.h line 28
struct _LingotAudioHandler * lingot_audio_jack_new(char *device, signed int sample_rate)
{
  struct _LingotAudioHandler *audio = (struct _LingotAudioHandler *)(void *)0;
  const char *exception;
  const char **ports = (const char **)(void *)0;
  const char *client_name = "lingot";
  const char *server_name = (const char *)(void *)0;
  enum JackOptions lingot_audio_jack_new$$1$$options = (enum JackOptions)JackNoStartServer;
  enum JackStatus status;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _LingotAudioHandler) /*248ul*/ );
  audio = (struct _LingotAudioHandler *)return_value_malloc$1;
  strcpy(audio->device, "");
  audio->audio_system = AUDIO_SYSTEM_JACK;
  audio->jack_client=jack_client_open(client_name, lingot_audio_jack_new$$1$$options, &status, server_name);
  exception = ((const char *)NULL);
  do
  {
    if(audio->jack_client == ((struct _jack_client *)NULL))
    {
      char *return_value_gettext$2;
      return_value_gettext$2=gettext("Unable to connect to JACK server");
      exception = (const char *)return_value_gettext$2;
      goto __CPROVER_DUMP_L6;
    }

    if(!((JackServerStarted & (signed int)status) == 0))
      fprintf(stderr, "JACK server started\n");

    if(!((JackNameNotUnique & (signed int)status) == 0))
    {
      client_name=jack_get_client_name(audio->jack_client);
      fprintf(stderr, "unique name `%s' assigned\n", client_name);
    }

    jack_on_shutdown(audio->jack_client, lingot_audio_jack_shutdown, (void *)audio);
    audio->real_sample_rate=jack_get_sample_rate(audio->jack_client);
    unsigned int return_value_jack_get_buffer_size$3;
    return_value_jack_get_buffer_size$3=jack_get_buffer_size(audio->jack_client);
    audio->read_buffer_size = (signed int)return_value_jack_get_buffer_size$3;
    audio->jack_input_port=jack_port_register(audio->jack_client, "input", "32 bit float mono audio", (unsigned long int)1, (unsigned long int)0);
    if(audio->jack_input_port == ((struct _jack_port *)NULL))
    {
      char *return_value_gettext$4;
      return_value_gettext$4=gettext("No more JACK ports available");
      exception = (const char *)return_value_gettext$4;
      break;
    }

  }
  while((_Bool)0);

__CPROVER_DUMP_L6:
  ;
  if(!(exception == ((const char *)NULL)))
  {
    free((void *)audio);
    audio = (struct _LingotAudioHandler *)(void *)0;
    lingot_msg_add_error(exception);
  }

  if(!(ports == ((const char **)NULL)))
    free((void *)ports);

  if(!(audio == ((struct _LingotAudioHandler *)NULL)))
    client = audio->jack_client;

  return audio;
}

// lingot_audio_jack_process
// file lingot-audio-jack.c line 42
signed int lingot_audio_jack_process(unsigned int nframes, void *param)
{
  struct _LingotAudioHandler *audio = (struct _LingotAudioHandler *)param;
  audio->nframes = (signed int)nframes;
  pthread_mutex_lock(&stop_mutex);
  if(!(audio->running == 0))
  {
    lingot_audio_jack_read(audio);
    audio->process_callback(audio->flt_read_buffer, audio->read_buffer_size, audio->process_callback_arg);
  }

  pthread_mutex_unlock(&stop_mutex);
  return 0;
}

// lingot_audio_jack_read
// file lingot-audio-jack.c line 149
signed int lingot_audio_jack_read(struct _LingotAudioHandler *audio)
{
  signed int i;
  float *in;
  void *return_value_jack_port_get_buffer$1;
  return_value_jack_port_get_buffer$1=jack_port_get_buffer(audio->jack_input_port, (unsigned int)audio->nframes);
  in = (float *)return_value_jack_port_get_buffer$1;
  i = 0;
  for( ; !(i >= audio->nframes); i = i + 1)
    audio->flt_read_buffer[(signed long int)i] = (double)(in[(signed long int)i] * (float)32768);
  return 0;
}

// lingot_audio_jack_shutdown
// file lingot-audio-jack.c line 59
void lingot_audio_jack_shutdown(void *param)
{
  struct _LingotAudioHandler *audio = (struct _LingotAudioHandler *)param;
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Missing connection with JACK audio server");
  lingot_msg_add_error((const char *)return_value_gettext$1);
  pthread_mutex_lock(&stop_mutex);
  audio->interrupted = 1;
  pthread_mutex_unlock(&stop_mutex);
}

// lingot_audio_jack_start
// file lingot-audio-jack.h line 33
signed int lingot_audio_jack_start(struct _LingotAudioHandler *audio)
{
  signed int result = 0;
  signed int index = 0;
  const char **ports = (const char **)(void *)0;
  const char *exception;
  jack_set_process_callback(audio->jack_client, lingot_audio_jack_process, (void *)audio);
  exception = ((const char *)NULL);
  do
  {
    signed int return_value_jack_activate$2;
    return_value_jack_activate$2=jack_activate(audio->jack_client);
    if(!(return_value_jack_activate$2 == 0))
    {
      char *return_value_gettext$1;
      return_value_gettext$1=gettext("Cannot activate client");
      exception = (const char *)return_value_gettext$1;
      break;
    }

    ports=jack_get_ports(audio->jack_client, (const char *)(void *)0, (const char *)(void *)0, (unsigned long int)2);
    if(ports == ((const char **)NULL))
    {
      char *return_value_gettext$3;
      return_value_gettext$3=gettext("No active capture ports");
      exception = (const char *)return_value_gettext$3;
      break;
    }

    signed int j = 0;
    signed int connections = 0;
    j = 0;
    for( ; !(j >= 10); j = j + 1)
    {
      index = 0;
      for( ; !(ports[(signed long int)index] == ((const char *)NULL)); index = index + 1)
      {
        signed int return_value_strcmp$7;
        return_value_strcmp$7=strcmp(last_ports[(signed long int)j], ports[(signed long int)index]);
        if(return_value_strcmp$7 == 0)
        {
          const char *return_value_jack_port_name$5;
          return_value_jack_port_name$5=jack_port_name(audio->jack_input_port);
          signed int return_value_jack_connect$6;
          return_value_jack_connect$6=jack_connect(audio->jack_client, ports[(signed long int)index], return_value_jack_port_name$5);
          if(!(return_value_jack_connect$6 == 0))
          {
            char *return_value_gettext$4;
            return_value_gettext$4=gettext("Cannot connect input ports");
            exception = (const char *)return_value_gettext$4;
            break;
          }

          else
            connections = connections + 1;
        }

      }
    }
    if(connections == 0)
    {
      free((void *)ports);
      ports=jack_get_ports(audio->jack_client, (const char *)(void *)0, (const char *)(void *)0, (unsigned long int)(4 | 2));
      if(ports == ((const char **)NULL))
      {
        char *return_value_gettext$8;
        return_value_gettext$8=gettext("No physical capture ports");
        exception = (const char *)return_value_gettext$8;
        break;
      }

      const char *return_value_jack_port_name$10;
      return_value_jack_port_name$10=jack_port_name(audio->jack_input_port);
      signed int return_value_jack_connect$11;
      return_value_jack_connect$11=jack_connect(audio->jack_client, ports[(signed long int)0], return_value_jack_port_name$10);
      if(!(return_value_jack_connect$11 == 0))
      {
        char *return_value_gettext$9;
        return_value_gettext$9=gettext("Cannot connect input ports");
        exception = (const char *)return_value_gettext$9;
        break;
      }

    }

  }
  while((_Bool)0);
  if(!(exception == ((const char *)NULL)))
  {
    lingot_msg_add_error(exception);
    result = -1;
  }

  free((void *)ports);
  return result;
}

// lingot_audio_jack_stop
// file lingot-audio-jack.h line 34
void lingot_audio_jack_stop(struct _LingotAudioHandler *audio)
{
  const char **ports;
  ports=jack_get_ports(audio->jack_client, (const char *)(void *)0, (const char *)(void *)0, (unsigned long int)2);
  signed int tmp_post$1;
  if(!(ports == ((const char **)NULL)))
  {
    signed int i;
    signed int j = 0;
    i = 0;
    for( ; !(i >= 10); i = i + 1)
      strcpy(last_ports[(signed long int)i], "");
    i = 0;
    for( ; !(ports[(signed long int)i] == ((const char *)NULL)); i = i + 1)
    {
      struct _jack_port *return_value_jack_port_by_name$2;
      return_value_jack_port_by_name$2=jack_port_by_name(audio->jack_client, ports[(signed long int)i]);
      signed int return_value_jack_port_connected$3;
      return_value_jack_port_connected$3=jack_port_connected(return_value_jack_port_by_name$2);
      if(!(return_value_jack_port_connected$3 == 0))
      {
        tmp_post$1 = j;
        j = j + 1;
        strcpy(last_ports[(signed long int)tmp_post$1], ports[(signed long int)i]);
      }

    }
  }

  pthread_mutex_lock(&stop_mutex);
  jack_deactivate(audio->jack_client);
  pthread_mutex_unlock(&stop_mutex);
}

// lingot_audio_new
// file lingot-audio.c line 35
struct _LingotAudioHandler * lingot_audio_new(enum audio_system_t audio_system, char *device, signed int sample_rate, void (*process_callback)(double *, signed int, void *), void *process_callback_arg)
{
  struct _LingotAudioHandler *result = (struct _LingotAudioHandler *)(void *)0;
  switch((signed int)audio_system)
  {
    case AUDIO_SYSTEM_OSS:
    {
      result=lingot_audio_oss_new(device, sample_rate);
      break;
    }
    case AUDIO_SYSTEM_ALSA:
    {
      result=lingot_audio_alsa_new(device, sample_rate);
      break;
    }
    case AUDIO_SYSTEM_JACK:
      result=lingot_audio_jack_new(device, sample_rate);
  }
  if(!(result == ((struct _LingotAudioHandler *)NULL)))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)result->read_buffer_size * sizeof(double) /*8ul*/ );
    result->flt_read_buffer = (double *)return_value_malloc$1;
    memset((void *)result->flt_read_buffer, 0, (unsigned long int)result->read_buffer_size * sizeof(double) /*8ul*/ );
    result->process_callback = process_callback;
    result->process_callback_arg = process_callback_arg;
    result->interrupted = 0;
    result->running = 0;
  }

  return result;
}

// lingot_audio_oss_destroy
// file lingot-audio-oss.h line 29
void lingot_audio_oss_destroy(struct _LingotAudioHandler *audio)
{
  if(!(audio == ((struct _LingotAudioHandler *)NULL)))
  {
    close(audio->dsp);
    free((void *)audio->read_buffer);
  }

}

// lingot_audio_oss_get_audio_system_properties
// file lingot-audio-oss.h line 31
struct _LingotAudioSystemProperties * lingot_audio_oss_get_audio_system_properties(enum audio_system_t audio_system)
{
  struct _LingotAudioSystemProperties *result;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)1 * sizeof(struct _LingotAudioSystemProperties) /*32ul*/ );
  result = (struct _LingotAudioSystemProperties *)return_value_malloc$1;
  result->forced_sample_rate = 0;
  result->n_devices = 0;
  result->devices = (char **)(void *)0;
  result->n_sample_rates = 5;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)result->n_sample_rates * sizeof(signed int) /*4ul*/ );
  result->sample_rates = (signed int *)return_value_malloc$2;
  result->sample_rates[(signed long int)0] = 8000;
  result->sample_rates[(signed long int)1] = 11025;
  result->sample_rates[(signed long int)2] = 22050;
  result->sample_rates[(signed long int)3] = 44100;
  result->sample_rates[(signed long int)4] = 48000;
  return result;
}

// lingot_audio_oss_new
// file lingot-audio-oss.h line 28
struct _LingotAudioHandler * lingot_audio_oss_new(char *device, signed int sample_rate)
{
  signed int channels = 1;
  signed int format = 0x00000010;
  char error_message[100l];
  const char *exception;
  struct _LingotAudioHandler *audio;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _LingotAudioHandler) /*248ul*/ );
  audio = (struct _LingotAudioHandler *)return_value_malloc$1;
  audio->audio_system = AUDIO_SYSTEM_OSS;
  audio->dsp=open(device, 00);
  audio->read_buffer_size = 128;
  strcpy(audio->device, device);
  exception = ((const char *)NULL);
  do
  {
    if(!(audio->dsp >= 0))
    {
      char *return_value_gettext$2;
      return_value_gettext$2=gettext("Unable to open audio device %s.\n%s.");
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      sprintf(error_message, (const char *)return_value_gettext$2, device, return_value_strerror$4);
      exception = error_message;
      goto __CPROVER_DUMP_L9;
    }

    signed int return_value_ioctl$8;
    return_value_ioctl$8=ioctl(audio->dsp, (unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(80 << 0 + 8) | (unsigned int)(6 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &channels);
    if(!(return_value_ioctl$8 >= 0))
    {
      char *return_value_gettext$5;
      return_value_gettext$5=gettext("Error setting number of channels.\n%s.");
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      sprintf(error_message, (const char *)return_value_gettext$5, return_value_strerror$7);
      exception = error_message;
      break;
    }

    signed int return_value_ioctl$12;
    return_value_ioctl$12=ioctl(audio->dsp, (unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(80 << 0 + 8) | (unsigned int)(5 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &format);
    if(!(return_value_ioctl$12 >= 0))
    {
      char *return_value_gettext$9;
      return_value_gettext$9=gettext("Error setting bits per sample.\n%s.");
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      char *return_value_strerror$11;
      return_value_strerror$11=strerror(*return_value___errno_location$10);
      sprintf(error_message, (const char *)return_value_gettext$9, return_value_strerror$11);
      exception = error_message;
      break;
    }

    signed int fragment_size = 1;
    signed int DMA_buffer_size = 512;
    signed int param = 0;
    param = 0;
    for( ; !(fragment_size >= DMA_buffer_size); param = param + 1)
      fragment_size = fragment_size << 1;
    param = param | 0x00ff0000;
    signed int return_value_ioctl$16;
    return_value_ioctl$16=ioctl(audio->dsp, (unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(80 << 0 + 8) | (unsigned int)(10 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &param);
    if(!(return_value_ioctl$16 >= 0))
    {
      char *return_value_gettext$13;
      return_value_gettext$13=gettext("Error setting DMA buffer size.\n%s.");
      signed int *return_value___errno_location$14;
      return_value___errno_location$14=__errno_location();
      char *return_value_strerror$15;
      return_value_strerror$15=strerror(*return_value___errno_location$14);
      sprintf(error_message, (const char *)return_value_gettext$13, return_value_strerror$15);
      exception = error_message;
      break;
    }

    signed int return_value_ioctl$20;
    return_value_ioctl$20=ioctl(audio->dsp, (unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(80 << 0 + 8) | (unsigned int)(2 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &sample_rate);
    if(!(return_value_ioctl$20 >= 0))
    {
      char *return_value_gettext$17;
      return_value_gettext$17=gettext("Error setting sample rate.\n%s.");
      signed int *return_value___errno_location$18;
      return_value___errno_location$18=__errno_location();
      char *return_value_strerror$19;
      return_value_strerror$19=strerror(*return_value___errno_location$18);
      sprintf(error_message, (const char *)return_value_gettext$17, return_value_strerror$19);
      exception = error_message;
      break;
    }

    audio->real_sample_rate = (unsigned int)sample_rate;
    void *return_value_malloc$21;
    return_value_malloc$21=malloc((unsigned long int)audio->read_buffer_size * sizeof(signed short int) /*2ul*/ );
    audio->read_buffer = (signed short int *)return_value_malloc$21;
    memset((void *)audio->read_buffer, 0, (unsigned long int)audio->read_buffer_size * sizeof(signed short int) /*2ul*/ );
  }
  while((_Bool)0);

__CPROVER_DUMP_L9:
  ;
  if(!(exception == ((const char *)NULL)))
  {
    close(audio->dsp);
    free((void *)audio);
    audio = (struct _LingotAudioHandler *)(void *)0;
    lingot_msg_add_error(exception);
  }

  return audio;
}

// lingot_audio_oss_read
// file lingot-audio-oss.h line 30
signed int lingot_audio_oss_read(struct _LingotAudioHandler *audio)
{
  signed int i;
  signed int read_size;
  signed long int return_value_read$1;
  return_value_read$1=read(audio->dsp, (void *)audio->read_buffer, (unsigned long int)audio->read_buffer_size * sizeof(signed short int) /*2ul*/ );
  read_size = (signed int)return_value_read$1;
  if(!((unsigned long int)read_size == sizeof(signed short int) /*2ul*/  * (unsigned long int)audio->read_buffer_size))
  {
    char buff[100l];
    char *return_value_gettext$2;
    return_value_gettext$2=gettext("Read from audio interface failed.\n%s.");
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    sprintf(buff, (const char *)return_value_gettext$2, return_value_strerror$4);
    lingot_msg_add_error(buff);
    return -1;
  }

  i = 0;
  for( ; !(i >= audio->read_buffer_size); i = i + 1)
    audio->flt_read_buffer[(signed long int)i] = (double)audio->read_buffer[(signed long int)i];
  return 0;
}

// lingot_audio_read
// file lingot-audio.c line 92
signed int lingot_audio_read(struct _LingotAudioHandler *audio)
{
  signed int result = -1;
  if(!(audio == ((struct _LingotAudioHandler *)NULL)))
    switch(audio->audio_system)
    {
      case AUDIO_SYSTEM_OSS:
      {
        result=lingot_audio_oss_read(audio);
        break;
      }
      case AUDIO_SYSTEM_ALSA:
      {
        result=lingot_audio_alsa_read(audio);
        break;
      }
      default:
      {
        perror("unknown audio system\n");
        result = -1;
      }
    }

  return result;
}

// lingot_audio_run_reading_thread
// file lingot-audio.c line 152
void lingot_audio_run_reading_thread(struct _LingotAudioHandler *audio)
{
  signed int read_status = 0;
  while(!(audio->running == 0))
  {
    read_status=lingot_audio_read(audio);
    if(read_status == 0)
      audio->process_callback(audio->flt_read_buffer, audio->read_buffer_size, audio->process_callback_arg);

    else
    {
      audio->running = 0;
      audio->interrupted = 1;
    }
  }
}

// lingot_audio_start
// file lingot-audio.c line 170
signed int lingot_audio_start(struct _LingotAudioHandler *audio)
{
  signed int result = 0;
  if(!(audio->audio_system == AUDIO_SYSTEM_JACK))
  {
    pthread_attr_init(&audio->thread_input_read_attr);
    pthread_create(&audio->thread_input_read, &audio->thread_input_read_attr, (void * (*)(void *))lingot_audio_run_reading_thread, (void *)audio);
  }

  else
    result=lingot_audio_jack_start(audio);
  if(result == 0)
    audio->running = 1;

  return result;
}

// lingot_audio_stop
// file lingot-audio.c line 193
void lingot_audio_stop(struct _LingotAudioHandler *audio)
{
  void *thread_result;
  if(audio->running == 1)
  {
    audio->running = 0;
    if(!(audio->audio_system == AUDIO_SYSTEM_JACK))
    {
      pthread_cancel(audio->thread_input_read);
      pthread_join(audio->thread_input_read, &thread_result);
      pthread_attr_destroy(&audio->thread_input_read_attr);
    }

    else
      lingot_audio_jack_stop(audio);
  }

}

// lingot_complex_add
// file lingot-complex.h line 39
void lingot_complex_add(struct _LingotComplex *a, struct _LingotComplex *b, struct _LingotComplex *c)
{
  c->r = a->r + b->r;
  c->i = a->i + b->i;
}

// lingot_complex_div
// file lingot-complex.c line 59
void lingot_complex_div(struct _LingotComplex *a, struct _LingotComplex *b, struct _LingotComplex *c)
{
  double bm2 = b->r * b->r + b->i * b->i;
  if(!(c == a) && !(c == b))
  {
    c->r = (a->r * b->r + a->i * b->i) / bm2;
    c->i = (a->i * b->r - a->r * b->i) / bm2;
  }

  else
  {
    struct _LingotComplex r;
    r.r = (a->r * b->r + a->i * b->i) / bm2;
    r.i = (a->i * b->r - a->r * b->i) / bm2;
    *c = r;
  }
}

// lingot_complex_mul
// file lingot-complex.h line 41
void lingot_complex_mul(struct _LingotComplex *a, struct _LingotComplex *b, struct _LingotComplex *c)
{
  if(!(c == a) && !(c == b))
  {
    c->r = a->r * b->r - a->i * b->i;
    c->i = a->i * b->r + a->r * b->i;
  }

  else
  {
    struct _LingotComplex r;
    r.r = a->r * b->r - a->i * b->i;
    r.i = a->i * b->r + a->r * b->i;
    *c = r;
  }
}

// lingot_complex_sub
// file lingot-complex.h line 40
void lingot_complex_sub(struct _LingotComplex *a, struct _LingotComplex *b, struct _LingotComplex *c)
{
  c->r = a->r - b->r;
  c->i = a->i - b->i;
}

// lingot_config_copy
// file lingot-config.c line 89
void lingot_config_copy(struct _LingotConfig *dst, struct _LingotConfig *src)
{
  struct _LingotScale *dst_scale = dst->scale;
  *dst = *src;
  dst->scale = dst_scale;
  lingot_config_scale_copy(dst->scale, src->scale);
}

// lingot_config_destroy
// file lingot-config.c line 83
void lingot_config_destroy(struct _LingotConfig *config)
{
  lingot_config_scale_destroy(config->scale);
  free((void *)config->scale);
  free((void *)config);
}

// lingot_config_load
// file lingot-config.c line 251
void lingot_config_load(struct _LingotConfig *config, char *filename)
{
  struct _IO_FILE *fp;
  float aux;
  signed int line;
  signed int option_index;
  signed int deprecated_option = 0;
  char *char_buffer_pointer;
  void *params[20l];
  void *param = (void *)0;
  char *option = (char *)(void *)0;
  signed int reading_scale = 0;
  char *nl;
  signed int parse_errors = 0;
  signed int command_count = 0;
  lingot_config_restore_default_values(config);
  lingot_map_parameters(config, params);
  char char_buffer[100l];
  fp=fopen(filename, "r");
  signed int return_value_strcmp$11;
  signed int return_value_strcmp$14;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    sprintf(char_buffer, "error opening config file %s, assuming default values ", filename);
    perror(char_buffer);
  }

  else
  {
    line = 0;
    do
    {
      line = line + 1;
      char *return_value_fgets$1;
      return_value_fgets$1=fgets(char_buffer, 100, fp);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      if(!((signed int)char_buffer[0l] == 35))
      {
        static const char *delim = " \t=\n";
        char_buffer_pointer=strtok(char_buffer, delim);
        if(!(char_buffer_pointer == ((char *)NULL)))
        {
          signed int return_value_strcmp$2;
          return_value_strcmp$2=strcmp(char_buffer_pointer, "SCALE");
          if(return_value_strcmp$2 == 0)
          {
            reading_scale = 1;
            config->scale=lingot_config_scale_new();
            command_count = command_count + 1;
          }

          else
          {
            if(!(reading_scale == 0))
            {
              signed int return_value_strcmp$3;
              return_value_strcmp$3=strcmp(char_buffer_pointer, "NAME");
              if(return_value_strcmp$3 == 0)
              {
                char_buffer_pointer = char_buffer_pointer + (signed long int)4;
                for( ; (_Bool)1; char_buffer_pointer = char_buffer_pointer + 1l)
                {
                  nl=strchr(delim, (signed int)*char_buffer_pointer);
                  if(nl == ((char *)NULL))
                    break;

                }
                nl=strrchr(char_buffer_pointer, 13);
                if(!(nl == ((char *)NULL)))
                  *nl = (char)0;

                nl=strrchr(char_buffer_pointer, 10);
                if(!(nl == ((char *)NULL)))
                  *nl = (char)0;

                config->scale->name=strdup(char_buffer_pointer);
                continue;
              }

              signed int return_value_strcmp$4;
              return_value_strcmp$4=strcmp(char_buffer_pointer, "BASE_FREQUENCY");
              if(return_value_strcmp$4 == 0)
              {
                char_buffer_pointer=strtok((char *)(void *)0, delim);
                sscanf(char_buffer_pointer, "%lg", &config->scale->base_frequency);
                continue;
              }

              signed int return_value_strcmp$5;
              return_value_strcmp$5=strcmp(char_buffer_pointer, "NOTE_COUNT");
              if(return_value_strcmp$5 == 0)
              {
                char_buffer_pointer=strtok((char *)(void *)0, delim);
                sscanf(char_buffer_pointer, "%hu", &config->scale->notes);
                lingot_config_scale_allocate(config->scale, config->scale->notes);
                continue;
              }

              signed int return_value_strcmp$9;
              return_value_strcmp$9=strcmp(char_buffer_pointer, "NOTES");
              if(return_value_strcmp$9 == 0)
              {
                signed int i = 0;
                i = 0;
                for( ; !(i >= (signed int)config->scale->notes); i = i + 1)
                {
                  line = line + 1;
                  char *return_value_fgets$6;
                  return_value_fgets$6=fgets(char_buffer, 100, fp);
                  if(return_value_fgets$6 == ((char *)NULL))
                    break;

                  static const char *delim2 = " \t\n";
                  char_buffer_pointer=strtok(char_buffer, delim2);
                  config->scale->note_name[(signed long int)i]=strdup(char_buffer_pointer);
                  char_buffer_pointer=strtok((char *)(void *)0, delim2);
                  signed int return_value_lingot_config_scale_parse_shift$7;
                  return_value_lingot_config_scale_parse_shift$7=lingot_config_scale_parse_shift(char_buffer_pointer, &config->scale->offset_cents[(signed long int)i], &config->scale->offset_ratios[(signed long int)0][(signed long int)i], &config->scale->offset_ratios[(signed long int)1][(signed long int)i]);
                  if(return_value_lingot_config_scale_parse_shift$7 == 0)
                    parse_errors = 1;

                }
                line = line + 1;
                char *return_value_fgets$8;
                return_value_fgets$8=fgets(char_buffer, 100, fp);
                if(return_value_fgets$8 == ((char *)NULL))
                  break;

                continue;
              }

              signed int return_value_strcmp$10;
              return_value_strcmp$10=strcmp(char_buffer_pointer, "}");
              if(return_value_strcmp$10 == 0)
              {
                reading_scale = 0;
                continue;
              }

            }

            deprecated_option = 0;
            option_index = 0;
            for( ; !(options[(signed long int)option_index] == ((char *)NULL)); option_index = option_index + 1)
            {
              signed int return_value_strcmp$12;
              return_value_strcmp$12=strcmp(char_buffer_pointer, options[(signed long int)option_index]);
              if(return_value_strcmp$12 == 0)
                break;

              else
              {
                return_value_strcmp$11=strcmp("|", options[(signed long int)option_index]);
                if(return_value_strcmp$11 == 0)
                  deprecated_option = 1;

              }
            }
            option = options[(signed long int)option_index];
            param = params[(signed long int)option_index];
            if(option == ((char *)NULL))
            {
              fprintf(stderr, "warning: parse error at line %i: unknown keyword %s\n", line, char_buffer_pointer);
              parse_errors = 1;
            }

            else
            {
              if(!(deprecated_option == 0))
                fprintf(stdout, "warning: deprecated option %s\n", char_buffer_pointer);

              char_buffer_pointer=strtok((char *)(void *)0, delim);
              if(char_buffer_pointer == ((char *)NULL))
              {
                fprintf(stderr, "warning: parse error at line %i: value expected\n", line);
                parse_errors = 1;
              }

              else
                switch((signed int)option_formats[(signed long int)option_index])
                {
                  case 115:
                  {
                    sprintf((char *)param, "%s", char_buffer_pointer);
                    command_count = command_count + 1;
                    break;
                  }
                  case 100:
                  {
                    sscanf(char_buffer_pointer, "%d", (unsigned int *)param);
                    command_count = command_count + 1;
                    break;
                  }
                  case 102:
                  {
                    sscanf(char_buffer_pointer, "%f", &aux);
                    *((double *)param) = (double)aux;
                    command_count = command_count + 1;
                    break;
                  }
                  case 109:
                  {
                    return_value_strcmp$14=strcmp("AUDIO_SYSTEM", option);
                    if(return_value_strcmp$14 == 0)
                    {
                      command_count = command_count + 1;
                      *((enum audio_system_t *)param)=str_to_audio_system_t(char_buffer_pointer);
                      if(*((enum audio_system_t *)param) == /*enum*/4294967295)
                      {
                        *((enum audio_system_t *)param) = (enum audio_system_t)AUDIO_SYSTEM_ALSA;
                        char buff[1000l];
                        char *return_value_gettext$13;
                        return_value_gettext$13=gettext("Error parsing the configuration file, line %i: unrecognized audio system '%s', assuming default audio system.\n");
                        sprintf(buff, (const char *)return_value_gettext$13, line, char_buffer_pointer);
                        lingot_msg_add_warning(buff);
                        parse_errors = 1;
                      }

                    }

                  }
                }
            }
          }
        }

      }

    }
    while((_Bool)1);
    fclose(fp);
    if(!(parse_errors == 0))
    {
      char *return_value_gettext$15;
      return_value_gettext$15=gettext("The configuration file contains errors, and hence some default values have been chosen. Consider checking the settings and fixing the problem using the configuration dialog.");
      lingot_msg_add_warning((const char *)return_value_gettext$15);
    }

    lingot_config_update_internal_params(config);
  }
}

// lingot_config_new
// file lingot-config.c line 73
struct _LingotConfig * lingot_config_new()
{
  struct _LingotConfig *config;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _LingotConfig) /*408ul*/ );
  config = (struct _LingotConfig *)return_value_malloc$1;
  config->max_nr_iter = (unsigned int)10;
  config->window_type = (enum window_type_t)HAMMING;
  config->scale=lingot_config_scale_new();
  return config;
}

// lingot_config_restore_default_values
// file lingot-config.c line 98
void lingot_config_restore_default_values(struct _LingotConfig *config)
{
  config->audio_system = (enum audio_system_t)AUDIO_SYSTEM_ALSA;
  sprintf(config->audio_dev[(signed long int)AUDIO_SYSTEM_OSS], "%s", (const void *)"/dev/dsp");
  sprintf(config->audio_dev[(signed long int)AUDIO_SYSTEM_ALSA], "%s", (const void *)"plughw:0");
  config->sample_rate = 44100;
  config->oversampling = (unsigned int)25;
  config->root_frequency_error = (double)0;
  config->min_frequency = (double)15;
  config->fft_size = (unsigned int)512;
  config->temporal_window = 0.32;
  config->calculation_rate = (double)20;
  config->visualization_rate = (double)30;
  config->noise_threshold_db = 20.0;
  config->gain = (double)0;
  config->peak_number = (unsigned int)3;
  config->peak_half_width = (unsigned int)1;
  config->peak_rejection_relation_db = (double)20;
  config->dft_number = (unsigned int)2;
  config->dft_size = (unsigned int)15;
  lingot_config_scale_restore_default_values(config->scale);
  lingot_config_update_internal_params(config);
}

// lingot_config_save
// file lingot-config.c line 175
void lingot_config_save(struct _LingotConfig *config, char *filename)
{
  unsigned int i;
  struct _IO_FILE *fp;
  char *lc_all;
  void *params[20l];
  void *param = (void *)0;
  char *option = (char *)(void *)0;
  char buff[80l];
  lingot_map_parameters(config, params);
  lc_all=setlocale(6, (const char *)(void *)0);
  if(!(lc_all == ((char *)NULL)))
    lc_all=strdup(lc_all);

  setlocale(6, "C");
  fp=fopen(filename, "w");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    char lingot_config_save$$1$$1$$buff[100l];
    sprintf(lingot_config_save$$1$$1$$buff, "error saving config file %s ", filename);
    perror(lingot_config_save$$1$$1$$buff);
    goto __CPROVER_DUMP_L14;
  }

  fprintf(fp, "# Config file automatically created by lingot %s\n\n", (const void *)"0.9.1");
  i = (unsigned int)0;
  signed int return_value_strcmp$1;
  signed int return_value_strcmp$3;
  do
  {
    return_value_strcmp$1=strcmp(options[(signed long int)i], "|");
    if(return_value_strcmp$1 == 0)
      break;

    option = options[(signed long int)i];
    param = params[(signed long int)i];
    switch((signed int)option_formats[(signed long int)i])
    {
      case 115:
      {
        fprintf(fp, "%s = %s\n", option, (char *)param);
        break;
      }
      case 100:
      {
        fprintf(fp, "%s = %d\n", option, *((unsigned int *)param));
        break;
      }
      case 102:
      {
        fprintf(fp, "%s = %0.3f\n", option, *((double *)param));
        break;
      }
      case 109:
      {
        return_value_strcmp$3=strcmp("AUDIO_SYSTEM", option);
        if(return_value_strcmp$3 == 0)
        {
          const char *return_value_audio_system_t_to_str$2;
          return_value_audio_system_t_to_str$2=audio_system_t_to_str(*((enum audio_system_t *)param));
          fprintf(fp, "%s = %s\n", option, return_value_audio_system_t_to_str$2);
        }

      }
    }
    i = i + 1u;
  }
  while((_Bool)1);
  fprintf(fp, "\n");
  fprintf(fp, "SCALE = {\n");
  fprintf(fp, "NAME = %s\n", config->scale->name);
  fprintf(fp, "BASE_FREQUENCY = %f\n", config->scale->base_frequency);
  fprintf(fp, "NOTE_COUNT = %d\n", config->scale->notes);
  fprintf(fp, "NOTES = {\n");
  i = (unsigned int)0;
  for( ; !(i >= (unsigned int)config->scale->notes); i = i + 1u)
  {
    lingot_config_scale_format_shift(buff, config->scale->offset_cents[(signed long int)i], config->scale->offset_ratios[(signed long int)0][(signed long int)i], config->scale->offset_ratios[(signed long int)1][(signed long int)i]);
    fprintf(fp, "%s\t%s\n", config->scale->note_name[(signed long int)i], (const void *)buff);
  }
  fprintf(fp, "}\n");
  fprintf(fp, "}\n");
  fclose(fp);
  if(!(lc_all == ((char *)NULL)))
  {
    setlocale(6, lc_all);
    free((void *)lc_all);
  }


__CPROVER_DUMP_L14:
  ;
}

// lingot_config_scale_allocate
// file lingot-config-scale.h line 44
void lingot_config_scale_allocate(struct _LingotScale *scale, unsigned short int notes)
{
  scale->notes = notes;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)notes * sizeof(char *) /*8ul*/ );
  scale->note_name = (char **)return_value_malloc$1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)notes * sizeof(double) /*8ul*/ );
  scale->offset_cents = (double *)return_value_malloc$2;
  void *return_value_malloc$3;
  return_value_malloc$3=malloc((unsigned long int)notes * sizeof(signed short int) /*2ul*/ );
  scale->offset_ratios[(signed long int)0] = (signed short int *)return_value_malloc$3;
  void *return_value_malloc$4;
  return_value_malloc$4=malloc((unsigned long int)notes * sizeof(signed short int) /*2ul*/ );
  scale->offset_ratios[(signed long int)1] = (signed short int *)return_value_malloc$4;
}

// lingot_config_scale_copy
// file lingot-config-scale.h line 49
void lingot_config_scale_copy(struct _LingotScale *dst, struct _LingotScale *src)
{
  unsigned short int i;
  lingot_config_scale_destroy(dst);
  *dst = *src;
  dst->name=strdup(src->name);
  lingot_config_scale_allocate(dst, dst->notes);
  i = (unsigned short int)0;
  for( ; !((signed int)i >= (signed int)dst->notes); i = i + 1)
  {
    dst->note_name[(signed long int)i]=strdup(src->note_name[(signed long int)i]);
    dst->offset_cents[(signed long int)i] = src->offset_cents[(signed long int)i];
    dst->offset_ratios[(signed long int)0][(signed long int)i] = src->offset_ratios[(signed long int)0][(signed long int)i];
    dst->offset_ratios[(signed long int)1][(signed long int)i] = src->offset_ratios[(signed long int)1][(signed long int)i];
  }
}

// lingot_config_scale_destroy
// file lingot-config-scale.h line 45
void lingot_config_scale_destroy(struct _LingotScale *scale)
{
  unsigned short int i = (unsigned short int)0;
  for( ; !((signed int)i >= (signed int)scale->notes); i = i + 1)
    free((void *)scale->note_name[(signed long int)i]);
  if(!(scale->offset_cents == ((double *)NULL)))
    free((void *)scale->offset_cents);

  if(!(scale->offset_ratios[0l] == ((signed short int *)NULL)))
    free((void *)scale->offset_ratios[(signed long int)0]);

  if(!(scale->offset_ratios[1l] == ((signed short int *)NULL)))
    free((void *)scale->offset_ratios[(signed long int)1]);

  if(!(scale->note_name == ((char **)NULL)))
    free((void *)scale->note_name);

  if(!(scale->name == ((char *)NULL)))
    free((void *)scale->name);

  scale->name = (char *)(void *)0;
  scale->notes = (unsigned short int)0;
  scale->note_name = (char **)(void *)0;
  scale->offset_cents = (double *)(void *)0;
  scale->offset_ratios[(signed long int)0] = (signed short int *)(void *)0;
  scale->offset_ratios[(signed long int)1] = (signed short int *)(void *)0;
  scale->base_frequency = 0.0;
}

// lingot_config_scale_format_shift
// file lingot-config-scale.h line 48
void lingot_config_scale_format_shift(char *char_buffer, double cents, signed short int numerator, signed short int denominator)
{
  if(!((signed int)numerator >= 0))
    sprintf(char_buffer, "%0.4lf", cents);

  else
    sprintf(char_buffer, "%hd/%hd", numerator, denominator);
}

// lingot_config_scale_load_scl
// file lingot-config-scale.c line 186
signed int lingot_config_scale_load_scl(struct _LingotScale *scale, char *filename)
{
  struct _IO_FILE *fp;
  signed int i;
  char *char_buffer_pointer1;
  char *nl;
  signed int result = 1;
  char char_buffer[1000l];
  fp=fopen(filename, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    sprintf(char_buffer, "error opening scale file %s", filename);
    perror(char_buffer);
    return 0;
  }

  else
  {
    scale->base_frequency = 261.625565;
    fgets(char_buffer, 1000, fp);
    char *return_value_strchr$1;
    return_value_strchr$1=strchr(char_buffer, 33);
    if(!(return_value_strchr$1 == char_buffer))
    {
      fclose(fp);
      return 0;
    }

    else
    {
      fgets(char_buffer, 1000, fp);
      fgets(char_buffer, 1000, fp);
      nl=strrchr(char_buffer, 13);
      if(!(nl == ((char *)NULL)))
        *nl = (char)0;

      nl=strrchr(char_buffer, 10);
      if(!(nl == ((char *)NULL)))
        *nl = (char)0;

      scale->name=strdup(char_buffer);
      fgets(char_buffer, 1000, fp);
      sscanf(char_buffer, "%hu", &scale->notes);
      fgets(char_buffer, 1000, fp);
      lingot_config_scale_allocate(scale, scale->notes);
      scale->note_name[(signed long int)0]=strdup("1");
      scale->offset_cents[(signed long int)0] = 0.0;
      scale->offset_ratios[(signed long int)0][(signed long int)0] = (signed short int)1;
      scale->offset_ratios[(signed long int)1][(signed long int)0] = (signed short int)1;
      i = 1;
      for( ; !(i >= (signed int)scale->notes); i = i + 1)
      {
        fgets(char_buffer, 1000, fp);
        static const char *delim = " \t\n";
        char_buffer_pointer1=strtok(char_buffer, delim);
        signed int r;
        r=lingot_config_scale_parse_shift(char_buffer_pointer1, &scale->offset_cents[(signed long int)i], &scale->offset_ratios[(signed long int)0][(signed long int)i], &scale->offset_ratios[(signed long int)1][(signed long int)i]);
        if(r == 0)
          result = 0;

        sprintf(char_buffer, "%d", i + 1);
        scale->note_name[(signed long int)i]=strdup(char_buffer);
      }
      fclose(fp);
      return result;
    }
  }
}

// lingot_config_scale_new
// file lingot-config-scale.h line 43
struct _LingotScale * lingot_config_scale_new()
{
  struct _LingotScale *scale;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _LingotScale) /*64ul*/ );
  scale = (struct _LingotScale *)return_value_malloc$1;
  scale->name = (char *)(void *)0;
  scale->notes = (unsigned short int)0;
  scale->note_name = (char **)(void *)0;
  scale->offset_cents = (double *)(void *)0;
  scale->offset_ratios[(signed long int)0] = (signed short int *)(void *)0;
  scale->offset_ratios[(signed long int)1] = (signed short int *)(void *)0;
  scale->base_frequency = 0.0;
  return scale;
}

// lingot_config_scale_parse_shift
// file lingot-config-scale.h line 47
signed int lingot_config_scale_parse_shift(char *char_buffer, double *cents, signed short int *numerator, signed short int *denominator)
{
  char *char_buffer_pointer1;
  static const char *delim = "/";
  char_buffer_pointer1=strtok(char_buffer, delim);
  char *char_buffer_pointer2;
  char_buffer_pointer2=strtok((char *)(void *)0, delim);
  signed short int num;
  signed short int den;
  signed int result = 1;
  if(!(numerator == ((signed short int *)NULL)))
    *numerator = (signed short int)-1;

  if(!(denominator == ((signed short int *)NULL)))
    *denominator = (signed short int)-1;

  signed int n = 0;
  if(char_buffer_pointer2 == ((char *)NULL))
  {
    n=sscanf(char_buffer_pointer1, "%lf", cents);
    if(n == 0)
      result = 0;

  }

  else
  {
    n=sscanf(char_buffer_pointer1, "%hd", &num);
    if(n == 0)
      result = 0;

    else
    {
      n=sscanf(char_buffer_pointer2, "%hd", &den);
      if(n == 0)
        result = 0;

      else
      {
        double return_value_log2$1;
        return_value_log2$1=log2((1.0 * (double)num) / (double)den);
        *cents = 1200.0 * return_value_log2$1;
        if(!(numerator == ((signed short int *)NULL)))
          *numerator = num;

        if(!(denominator == ((signed short int *)NULL)))
          *denominator = den;

      }
    }
  }
  if(result == 0)
  {
    *numerator = (signed short int)1;
    *denominator = (signed short int)1;
    *cents = 0.0;
  }

  return result;
}

// lingot_config_scale_restore_default_values
// file lingot-config-scale.h line 50
void lingot_config_scale_restore_default_values(struct _LingotScale *scale)
{
  unsigned short int i;
  lingot_config_scale_destroy(scale);
  scale->name=strdup("Default equal-tempered scale");
  lingot_config_scale_allocate(scale, (unsigned short int)12);
  scale->base_frequency = 261.625565;
  static char *tone_string[12l] = { "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B" };
  scale->note_name[(signed long int)0]=strdup(tone_string[(signed long int)0]);
  scale->offset_cents[(signed long int)0] = 0.0;
  scale->offset_ratios[(signed long int)0][(signed long int)0] = (signed short int)1;
  scale->offset_ratios[(signed long int)1][(signed long int)0] = (signed short int)1;
  i = (unsigned short int)1;
  for( ; !((signed int)i >= (signed int)scale->notes); i = i + 1)
  {
    scale->note_name[(signed long int)i]=strdup(tone_string[(signed long int)i]);
    scale->offset_cents[(signed long int)i] = 100.0 * (double)i;
    scale->offset_ratios[(signed long int)0][(signed long int)i] = (signed short int)-1;
    scale->offset_ratios[(signed long int)1][(signed long int)i] = (signed short int)-1;
  }
}

// lingot_config_update_internal_params
// file lingot-config.c line 130
void lingot_config_update_internal_params(struct _LingotConfig *config)
{
  double return_value_ceil$1;
  return_value_ceil$1=ceil((config->temporal_window * (double)config->sample_rate) / (double)config->oversampling);
  config->temporal_buffer_size = (unsigned int)return_value_ceil$1;
  config->peak_rejection_relation_nu=pow(10.0, config->peak_rejection_relation_db / 10.0);
  config->noise_threshold_nu=pow(10.0, config->noise_threshold_db / 10.0);
  config->gain_nu=pow(10.0, config->gain / 20.0);
  struct _LingotScale *scale = config->scale;
  double tmp_if_expr$2;
  if((signed int)scale->notes == 1)
    scale->max_offset_rounded = 1200.0;

  else
  {
    signed int i;
    double max_offset = 0.0;
    i = 1;
    for( ; !(i >= (signed int)scale->notes); i = i + 1)
    {
      if(max_offset > scale->offset_cents[(signed long int)i] + -scale->offset_cents[(signed long int)(i + -1)])
        tmp_if_expr$2 = max_offset;

      else
        tmp_if_expr$2 = scale->offset_cents[(signed long int)i] - scale->offset_cents[(signed long int)(i - 1)];
      max_offset = tmp_if_expr$2;
    }
    scale->max_offset_rounded = max_offset;
  }
  config->gauge_rest_value = -0.45 * scale->max_offset_rounded;
  sprintf(config->audio_dev[(signed long int)AUDIO_SYSTEM_JACK], "%s", (const void *)"");
}

// lingot_core_compute_fundamental_fequency
// file lingot-core.c line 338
void lingot_core_compute_fundamental_fequency(struct _LingotCore *core)
{
  unsigned int i;
  unsigned int k;
  struct _LingotConfig *conf = core->conf;
  double delta_w_FFT = (2.0 * 3.14159265358979323846) / (double)conf->fft_size;
  double _1_N2 = 1.0 / (double)(conf->fft_size * conf->fft_size);
  pthread_mutex_lock(&core->temporal_buffer_mutex);
  if(!((signed int)conf->window_type == NONE))
  {
    i = (unsigned int)0;
    for( ; !(i >= conf->fft_size); i = i + 1u)
      core->windowed_fft_buffer[(signed long int)i] = core->temporal_buffer[(signed long int)((conf->temporal_buffer_size - conf->fft_size) + i)] * core->hamming_window_fft[(signed long int)i];
  }

  else
    memmove((void *)core->windowed_fft_buffer, (const void *)&core->temporal_buffer[(signed long int)(conf->temporal_buffer_size - conf->fft_size)], (unsigned long int)conf->fft_size * sizeof(double) /*8ul*/ );
  lingot_fft_fft(core->windowed_fft_buffer, core->fft_out, (unsigned long int)conf->fft_size);
  i = (unsigned int)0;
  unsigned int tmp_if_expr$1;
  do
  {
    if(conf->fft_size >= 257u)
      tmp_if_expr$1 = conf->fft_size >> 1;

    else
      tmp_if_expr$1 = (unsigned int)256;
    if(i >= tmp_if_expr$1)
      break;

    core->spd_fft[(signed long int)i] = ((core->fft_out + (signed long int)i)->r * (core->fft_out + (signed long int)i)->r + (core->fft_out + (signed long int)i)->i * (core->fft_out + (signed long int)i)->i) * _1_N2;
    i = i + 1u;
  }
  while((_Bool)1);
  unsigned int tmp_if_expr$2;
  if(conf->fft_size >= 257u)
    tmp_if_expr$2 = conf->fft_size >> 1;

  else
    tmp_if_expr$2 = (unsigned int)256;
  memcpy((void *)core->X, (const void *)core->spd_fft, (unsigned long int)tmp_if_expr$2 * sizeof(double) /*8ul*/ );
  core->diff2_spd_fft[(signed long int)0] = 0.0;
  i = (unsigned int)1;
  for( ; !(i >= (conf->fft_size >> 1) + 4294967295u); i = i + 1u)
  {
    core->diff2_spd_fft[(signed long int)i] = (2.0 * core->spd_fft[(signed long int)i] - core->spd_fft[(signed long int)(i - (unsigned int)1)]) - core->spd_fft[(signed long int)(i + (unsigned int)1)];
    if(core->diff2_spd_fft[(signed long int)i] < 0.0)
      core->diff2_spd_fft[(signed long int)i] = 0.0;

  }
  signed int Mi;
  Mi=lingot_signal_get_fundamental_peak(conf, core->spd_fft, core->diff2_spd_fft, (signed int)(conf->fft_size >> 1));
  _Bool tmp_if_expr$4;
  double return_value_fabs$3;
  if(Mi == (signed int)(conf->fft_size >> 1))
  {
    core->freq = 0.0;
    pthread_mutex_unlock(&core->temporal_buffer_mutex);
  }

  else
  {
    double w = (double)(Mi - 1) * delta_w_FFT;
    double d_w = delta_w_FFT;
    k = (unsigned int)0;
    for( ; !(k >= conf->dft_number); k = k + 1u)
    {
      d_w = (2.0 * d_w) / (double)(conf->dft_size - (unsigned int)1);
      if(k == 0u)
      {
        lingot_fft_spd(core->windowed_fft_buffer, (signed int)conf->fft_size, w + d_w, d_w, &core->spd_dft[(signed long int)1], (signed int)(conf->dft_size - (unsigned int)2));
        core->spd_dft[(signed long int)0] = core->spd_fft[(signed long int)(Mi - 1)];
        core->spd_dft[(signed long int)(conf->dft_size - (unsigned int)1)] = core->spd_fft[(signed long int)(Mi + 1)];
      }

      else
        lingot_fft_spd(core->windowed_fft_buffer, (signed int)conf->fft_size, w, d_w, core->spd_dft, (signed int)conf->dft_size);
      lingot_signal_get_max(core->spd_dft, (signed int)conf->dft_size, &Mi);
      w = w + (double)(Mi - 1) * d_w;
    }
    w = w + d_w;
    if(!((signed int)conf->window_type == NONE))
    {
      i = (unsigned int)0;
      for( ; !(i >= conf->temporal_buffer_size); i = i + 1u)
        core->windowed_temporal_buffer[(signed long int)i] = core->temporal_buffer[(signed long int)i] * core->hamming_window_temporal[(signed long int)i];
    }

    else
      memmove((void *)core->windowed_temporal_buffer, (const void *)core->temporal_buffer, (unsigned long int)conf->temporal_buffer_size * sizeof(double) /*8ul*/ );
    pthread_mutex_unlock(&core->temporal_buffer_mutex);
    double wk = -1.0e5;
    double wkm1 = w;
    double d1_SPD;
    double d2_SPD;
    k = (unsigned int)0;
    do
    {
      if(!(k >= conf->max_nr_iter))
      {
        return_value_fabs$3=fabs(wk - wkm1);
        tmp_if_expr$4 = return_value_fabs$3 > 1.0e-8 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(!tmp_if_expr$4)
        break;

      wk = wkm1;
      lingot_fft_spd_diffs(core->windowed_temporal_buffer, (signed int)conf->temporal_buffer_size, wk, &d1_SPD, &d2_SPD);
      wkm1 = wk - d1_SPD / d2_SPD;
      k = k + 1u;
    }
    while((_Bool)1);
    w = wkm1;
    core->freq = (w * (double)conf->sample_rate) / (2.0 * 3.14159265358979323846 * (double)conf->oversampling);
  }
}

// lingot_core_destroy
// file lingot-core.c line 196
void lingot_core_destroy(struct _LingotCore *core)
{
  if(!(core->audio == ((struct _LingotAudioHandler *)NULL)))
  {
    lingot_fft_destroy_phase_factors();
    free((void *)core->fft_out);
    lingot_audio_destroy(core->audio);
    free((void *)core->spd_fft);
    free((void *)core->X);
    free((void *)core->spd_dft);
    free((void *)core->diff2_spd_fft);
    free((void *)core->flt_read_buffer);
    free((void *)core->temporal_buffer);
    if(!(core->hamming_window_fft == ((double *)NULL)))
      free((void *)core->hamming_window_temporal);

    if(!(core->windowed_temporal_buffer == ((double *)NULL)))
      free((void *)core->windowed_temporal_buffer);

    if(!(core->hamming_window_fft == ((double *)NULL)))
      free((void *)core->hamming_window_fft);

    if(!(core->windowed_fft_buffer == ((double *)NULL)))
      free((void *)core->windowed_fft_buffer);

    if(!(core->antialiasing_filter == ((struct _LingotFilter *)NULL)))
      lingot_filter_destroy(core->antialiasing_filter);

    pthread_mutex_destroy(&core->temporal_buffer_mutex);
  }

  free((void *)core);
}

// lingot_core_new
// file lingot-core.c line 49
struct _LingotCore * lingot_core_new(struct _LingotConfig *conf)
{
  char buff[1000l];
  struct _LingotCore *core;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _LingotCore) /*320ul*/ );
  core = (struct _LingotCore *)return_value_malloc$1;
  core->conf = conf;
  core->running = 0;
  core->audio = (struct _LingotAudioHandler *)(void *)0;
  core->spd_fft = (double *)(void *)0;
  core->X = (double *)(void *)0;
  core->spd_dft = (double *)(void *)0;
  core->diff2_spd_fft = (double *)(void *)0;
  core->flt_read_buffer = (double *)(void *)0;
  core->temporal_buffer = (double *)(void *)0;
  core->windowed_temporal_buffer = (double *)(void *)0;
  core->windowed_fft_buffer = (double *)(void *)0;
  core->hamming_window_temporal = (double *)(void *)0;
  core->hamming_window_fft = (double *)(void *)0;
  core->antialiasing_filter = (struct _LingotFilter *)(void *)0;
  signed int requested_sample_rate = conf->sample_rate;
  if(!(conf->sample_rate >= 1))
    conf->sample_rate = 0;

  core->audio=lingot_audio_new(conf->audio_system, conf->audio_dev[(signed long int)conf->audio_system], conf->sample_rate, (void (*)(double *, signed int, void *))lingot_core_read_callback, (void *)core);
  if(!(core->audio == ((struct _LingotAudioHandler *)NULL)))
  {
    if(!((unsigned int)requested_sample_rate == core->audio->real_sample_rate))
    {
      conf->sample_rate = (signed int)core->audio->real_sample_rate;
      lingot_config_update_internal_params(conf);
      char *return_value_gettext$2;
      return_value_gettext$2=gettext("The requested sample rate is not available, the real sample rate has been set to %d Hz");
      sprintf(buff, (const char *)return_value_gettext$2, core->audio->real_sample_rate);
      lingot_msg_add_warning(buff);
    }

    if(!(conf->temporal_buffer_size >= conf->fft_size))
    {
      conf->temporal_window = ((double)conf->fft_size * (double)conf->oversampling) / (double)conf->sample_rate;
      conf->temporal_buffer_size = conf->fft_size;
      lingot_config_update_internal_params(conf);
      char *return_value_gettext$3;
      return_value_gettext$3=gettext("The temporal buffer is smaller than FFT size. It has been increased to %0.3f seconds");
      sprintf(buff, (const char *)return_value_gettext$3, conf->temporal_window);
      lingot_msg_add_warning(buff);
    }

    if(core->conf->fft_size >= 257u)
    {
      void *return_value_malloc$4;
      return_value_malloc$4=malloc((unsigned long int)(core->conf->fft_size >> 1) * sizeof(double) /*8ul*/ );
      core->spd_fft = (double *)return_value_malloc$4;
      void *return_value_malloc$5;
      return_value_malloc$5=malloc((unsigned long int)(core->conf->fft_size >> 1) * sizeof(double) /*8ul*/ );
      core->X = (double *)return_value_malloc$5;
      memset((void *)core->spd_fft, 0, (unsigned long int)(core->conf->fft_size >> 1) * sizeof(double) /*8ul*/ );
      memset((void *)core->X, 0, (unsigned long int)(core->conf->fft_size >> 1) * sizeof(double) /*8ul*/ );
    }

    else
    {
      void *return_value_malloc$6;
      return_value_malloc$6=malloc((unsigned long int)core->conf->fft_size * sizeof(double) /*8ul*/ );
      core->spd_fft = (double *)return_value_malloc$6;
      void *return_value_malloc$7;
      return_value_malloc$7=malloc((unsigned long int)core->conf->fft_size * sizeof(double) /*8ul*/ );
      core->X = (double *)return_value_malloc$7;
      memset((void *)core->spd_fft, 0, (unsigned long int)core->conf->fft_size * sizeof(double) /*8ul*/ );
      memset((void *)core->X, 0, (unsigned long int)core->conf->fft_size * sizeof(double) /*8ul*/ );
    }
    void *return_value_malloc$8;
    return_value_malloc$8=malloc((unsigned long int)core->conf->dft_size * sizeof(double) /*8ul*/ );
    core->spd_dft = (double *)return_value_malloc$8;
    memset((void *)core->spd_dft, 0, (unsigned long int)core->conf->dft_size * sizeof(double) /*8ul*/ );
    void *return_value_malloc$9;
    return_value_malloc$9=malloc((unsigned long int)core->conf->fft_size * sizeof(double) /*8ul*/ );
    core->diff2_spd_fft = (double *)return_value_malloc$9;
    memset((void *)core->diff2_spd_fft, 0, (unsigned long int)core->conf->fft_size * sizeof(double) /*8ul*/ );
    memset((void *)core->spd_dft, 0, (unsigned long int)core->conf->dft_size * sizeof(double) /*8ul*/ );
    lingot_fft_create_phase_factors(conf);
    void *return_value_malloc$10;
    return_value_malloc$10=malloc((unsigned long int)core->conf->fft_size * sizeof(struct _LingotComplex) /*16ul*/ );
    core->fft_out = (struct _LingotComplex *)return_value_malloc$10;
    memset((void *)core->fft_out, 0, (unsigned long int)core->conf->fft_size * sizeof(struct _LingotComplex) /*16ul*/ );
    void *return_value_malloc$11;
    return_value_malloc$11=malloc((unsigned long int)core->audio->read_buffer_size * sizeof(double) /*8ul*/ );
    core->flt_read_buffer = (double *)return_value_malloc$11;
    memset((void *)core->flt_read_buffer, 0, (unsigned long int)core->audio->read_buffer_size * sizeof(double) /*8ul*/ );
    void *return_value_malloc$12;
    return_value_malloc$12=malloc((unsigned long int)core->conf->temporal_buffer_size * sizeof(double) /*8ul*/ );
    core->temporal_buffer = (double *)return_value_malloc$12;
    memset((void *)core->temporal_buffer, 0, (unsigned long int)core->conf->temporal_buffer_size * sizeof(double) /*8ul*/ );
    core->hamming_window_temporal = (double *)(void *)0;
    core->hamming_window_fft = (double *)(void *)0;
    if(!((signed int)conf->window_type == NONE))
    {
      void *return_value_malloc$13;
      return_value_malloc$13=malloc((unsigned long int)core->conf->temporal_buffer_size * sizeof(double) /*8ul*/ );
      core->hamming_window_temporal = (double *)return_value_malloc$13;
      void *return_value_malloc$14;
      return_value_malloc$14=malloc((unsigned long int)core->conf->fft_size * sizeof(double) /*8ul*/ );
      core->hamming_window_fft = (double *)return_value_malloc$14;
      lingot_signal_window((signed int)core->conf->temporal_buffer_size, core->hamming_window_temporal, conf->window_type);
      lingot_signal_window((signed int)core->conf->fft_size, core->hamming_window_fft, conf->window_type);
    }

    void *return_value_malloc$15;
    return_value_malloc$15=malloc((unsigned long int)core->conf->temporal_buffer_size * sizeof(double) /*8ul*/ );
    core->windowed_temporal_buffer = (double *)return_value_malloc$15;
    memset((void *)core->windowed_temporal_buffer, 0, (unsigned long int)core->conf->temporal_buffer_size * sizeof(double) /*8ul*/ );
    void *return_value_malloc$16;
    return_value_malloc$16=malloc((unsigned long int)core->conf->fft_size * sizeof(double) /*8ul*/ );
    core->windowed_fft_buffer = (double *)return_value_malloc$16;
    memset((void *)core->windowed_fft_buffer, 0, (unsigned long int)core->conf->fft_size * sizeof(double) /*8ul*/ );
    core->antialiasing_filter=lingot_filter_cheby_design((unsigned int)8, 0.5, 0.9 / (double)core->conf->oversampling);
    pthread_mutex_init(&core->temporal_buffer_mutex, (const union anonymous$4 *)(void *)0);
    core->running = 1;
  }

  core->freq = 0.0;
  return core;
}

// lingot_core_read_callback
// file lingot-core.c line 240
signed int lingot_core_read_callback(double *read_buffer, signed int read_buffer_size, void *arg)
{
  unsigned int i;
  unsigned int decimation_output_index;
  signed int decimation_output_len;
  double *decimation_in;
  double *decimation_out;
  struct _LingotCore *core = (struct _LingotCore *)arg;
  struct _LingotConfig *conf = core->conf;
  memcpy((void *)core->flt_read_buffer, (const void *)read_buffer, (unsigned long int)read_buffer_size * sizeof(double) /*8ul*/ );
  if(IEEE_FLOAT_NOTEQUAL(conf->gain_nu, 1.0))
  {
    i = (unsigned int)0;
    for( ; !(i >= (unsigned int)read_buffer_size); i = i + 1u)
      core->flt_read_buffer[(signed long int)i] = core->flt_read_buffer[(signed long int)i] * conf->gain_nu;
  }

  decimation_output_len = (signed int)((unsigned int)1 + (unsigned int)(read_buffer_size - (decimation_input_index + 1)) / conf->oversampling);
  pthread_mutex_lock(&core->temporal_buffer_mutex);
  if(!((unsigned int)decimation_output_len >= conf->temporal_buffer_size))
    memmove((void *)core->temporal_buffer, (const void *)&core->temporal_buffer[(signed long int)decimation_output_len], (unsigned long int)(conf->temporal_buffer_size - (unsigned int)decimation_output_len) * sizeof(double) /*8ul*/ );

  if(conf->oversampling >= 2u)
  {
    decimation_in = core->flt_read_buffer;
    decimation_out = &core->temporal_buffer[(signed long int)(conf->temporal_buffer_size - (unsigned int)decimation_output_len)];
    lingot_filter_filter(core->antialiasing_filter, (unsigned int)read_buffer_size, decimation_in, decimation_in);
    decimation_output_index = (unsigned int)0;
    for( ; !(decimation_input_index >= read_buffer_size); decimation_input_index = decimation_input_index + (signed int)conf->oversampling)
    {
      decimation_out[(signed long int)decimation_output_index] = decimation_in[(signed long int)decimation_input_index];
      decimation_output_index = decimation_output_index + 1u;
    }
    decimation_input_index = decimation_input_index - read_buffer_size;
  }

  else
    memcpy((void *)&core->temporal_buffer[(signed long int)(conf->temporal_buffer_size - (unsigned int)decimation_output_len)], (const void *)core->flt_read_buffer, (unsigned long int)decimation_output_len * sizeof(double) /*8ul*/ );
  pthread_mutex_unlock(&core->temporal_buffer_mutex);
  return 0;
}

// lingot_core_run_computation_thread
// file lingot-core.c line 509
void lingot_core_run_computation_thread(struct _LingotCore *core)
{
  struct timeval t;
  struct timeval tout;
  struct timespec tspec;
  gettimeofday(&tout, (struct timezone *)(void *)0);
  t.tv_sec = (signed long int)0;
  t.tv_usec = (signed long int)(1e6 / core->conf->calculation_rate);
  unsigned int tmp_if_expr$1;
  while(!(core->running == 0))
  {
    lingot_core_compute_fundamental_fequency(core);
    do
    {
      (&tout)->tv_sec = (&t)->tv_sec + (&tout)->tv_sec;
      (&tout)->tv_usec = (&t)->tv_usec + (&tout)->tv_usec;
      if(tout.tv_usec >= 1000000l)
      {
        (&tout)->tv_sec = (&tout)->tv_sec + 1l;
        (&tout)->tv_usec = (&tout)->tv_usec - (signed long int)1000000;
      }

    }
    while((_Bool)0);
    tspec.tv_sec = tout.tv_sec;
    tspec.tv_nsec = (signed long int)1000 * tout.tv_usec;
    pthread_cond_timedwait(&core->thread_computation_cond, &core->thread_computation_mutex, &tspec);
    if(!(core->audio == ((struct _LingotAudioHandler *)NULL)))
    {
      if(!(core->audio->interrupted == 0))
      {
        if(core->conf->fft_size >= 257u)
          tmp_if_expr$1 = core->conf->fft_size >> 1;

        else
          tmp_if_expr$1 = core->conf->fft_size;
        memset((void *)core->X, 0, (unsigned long int)tmp_if_expr$1 * sizeof(double) /*8ul*/ );
        core->freq = 0.0;
        core->running = 0;
      }

    }

  }
}

// lingot_core_start
// file lingot-core.c line 461
void lingot_core_start(struct _LingotCore *core)
{
  signed int audio_status = 0;
  decimation_input_index = 0;
  if(!(core->audio == ((struct _LingotAudioHandler *)NULL)))
  {
    audio_status=lingot_audio_start(core->audio);
    if(audio_status == 0)
    {
      pthread_mutex_init(&core->thread_computation_mutex, (const union anonymous$4 *)(void *)0);
      pthread_cond_init(&core->thread_computation_cond, (const union anonymous$4 *)(void *)0);
      pthread_attr_init(&core->thread_computation_attr);
      pthread_create(&core->thread_computation, &core->thread_computation_attr, (void * (*)(void *))lingot_core_run_computation_thread, (void *)core);
    }

    core->running = 1;
  }

}

// lingot_core_stop
// file lingot-core.c line 484
void lingot_core_stop(struct _LingotCore *core)
{
  void *thread_result;
  unsigned int tmp_if_expr$1;
  if(core->running == 1)
  {
    core->running = 0;
    pthread_cancel(core->thread_computation);
    pthread_join(core->thread_computation, &thread_result);
    pthread_attr_destroy(&core->thread_computation_attr);
    if(core->conf->fft_size >= 257u)
      tmp_if_expr$1 = core->conf->fft_size >> 1;

    else
      tmp_if_expr$1 = core->conf->fft_size;
    memset((void *)core->X, 0, (unsigned long int)tmp_if_expr$1 * sizeof(double) /*8ul*/ );
    core->freq = 0.0;
  }

  if(!(core->audio == ((struct _LingotAudioHandler *)NULL)))
    lingot_audio_stop(core->audio);

}

// lingot_fft_create_phase_factors
// file lingot-fft.c line 41
void lingot_fft_create_phase_factors(struct _LingotConfig *conf)
{
  double alpha;
  unsigned int i;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(conf->fft_size >> 1) * sizeof(struct _LingotComplex) /*16ul*/ );
  wn = (struct _LingotComplex *)return_value_malloc$1;
  i = (unsigned int)0;
  for( ; !(i >= conf->fft_size >> 1); i = i + 1u)
  {
    alpha = (-2.0 * (double)i * 3.14159265358979323846) / (double)conf->fft_size;
    (wn + (signed long int)i)->r=cos(alpha);
    (wn + (signed long int)i)->i=sin(alpha);
  }
}

// lingot_fft_destroy_phase_factors
// file lingot-fft.c line 54
void lingot_fft_destroy_phase_factors()
{
  if(!(wn == ((struct _LingotComplex *)NULL)))
    free((void *)wn);

}

// lingot_fft_fft
// file lingot-fft.c line 97
void lingot_fft_fft(double *in, struct _LingotComplex *out, unsigned long int N)
{
  _lingot_fft_fft(in, out, N, (unsigned long int)0, (unsigned long int)0, (unsigned long int)1);
}

// lingot_fft_spd
// file lingot-fft.c line 109
void lingot_fft_spd(double *in, signed int N1, double wi, double dw, double *out, signed int N2)
{
  double Xr;
  double Xi;
  double lingot_fft_spd$$1$$wn;
  double N1_2 = (double)(N1 * N1);
  signed int i;
  signed int n;
  i = 0;
  for( ; !(i >= N2); i = i + 1)
  {
    Xr = 0.0;
    Xi = 0.0;
    n = 0;
    for( ; !(n >= N1); n = n + 1)
    {
      lingot_fft_spd$$1$$wn = (wi + dw * (double)i) * (double)n;
      double return_value_cos$1;
      return_value_cos$1=cos(lingot_fft_spd$$1$$wn);
      Xr = Xr + return_value_cos$1 * in[(signed long int)n];
      double return_value_sin$2;
      return_value_sin$2=sin(lingot_fft_spd$$1$$wn);
      Xi = Xi - return_value_sin$2 * in[(signed long int)n];
    }
    out[(signed long int)i] = (Xr * Xr + Xi * Xi) / N1_2;
  }
}

// lingot_fft_spd_diffs
// file lingot-fft.c line 136
void lingot_fft_spd_diffs(double *in, signed int N, double w, double *out_d1, double *out_d2)
{
  double x_cos_wn;
  double x_sin_wn;
  signed int n;
  double SUM_x_sin_wn = 0.0;
  double SUM_x_cos_wn = 0.0;
  double SUM_x_n_sin_wn = 0.0;
  double SUM_x_n_cos_wn = 0.0;
  double SUM_x_n2_sin_wn = 0.0;
  double SUM_x_n2_cos_wn = 0.0;
  n = 0;
  for( ; !(n >= N); n = n + 1)
  {
    double return_value_cos$1;
    return_value_cos$1=cos(w * (double)n);
    x_cos_wn = in[(signed long int)n] * return_value_cos$1;
    double return_value_sin$2;
    return_value_sin$2=sin(w * (double)n);
    x_sin_wn = in[(signed long int)n] * return_value_sin$2;
    SUM_x_sin_wn = SUM_x_sin_wn + x_sin_wn;
    SUM_x_cos_wn = SUM_x_cos_wn + x_cos_wn;
    SUM_x_n_sin_wn = SUM_x_n_sin_wn + x_sin_wn * (double)n;
    SUM_x_n_cos_wn = SUM_x_n_cos_wn + x_cos_wn * (double)n;
    SUM_x_n2_sin_wn = SUM_x_n2_sin_wn + x_sin_wn * (double)n * (double)n;
    SUM_x_n2_cos_wn = SUM_x_n2_cos_wn + x_cos_wn * (double)n * (double)n;
  }
  double N_2 = (double)(N * N);
  *out_d1 = (2.0 * (SUM_x_sin_wn * SUM_x_n_cos_wn - SUM_x_cos_wn * SUM_x_n_sin_wn)) / N_2;
  *out_d2 = (2.0 * (((SUM_x_n_cos_wn * SUM_x_n_cos_wn - SUM_x_sin_wn * SUM_x_n2_sin_wn) + SUM_x_n_sin_wn * SUM_x_n_sin_wn) - SUM_x_cos_wn * SUM_x_n2_cos_wn)) / N_2;
}

// lingot_filter_cheby_design
// file lingot-filter.h line 55
struct _LingotFilter * lingot_filter_cheby_design(unsigned int n, double Rp, double wc)
{
  signed int i;
  signed int k;
  signed int p;
  const signed long int p$array_size0 = (signed long int)(n + (unsigned int)1);
  double a[p$array_size0];
  const signed long int a$array_size0 = (signed long int)(n + (unsigned int)1);
  double b[a$array_size0];
  const signed long int b$array_size0 = (signed long int)(n + (unsigned int)1);
  double new_a[b$array_size0];
  const signed long int new_a$array_size0 = (signed long int)(n + (unsigned int)1);
  double new_b[new_a$array_size0];
  const signed long int new_b$array_size0 = (signed long int)n;
  struct _LingotComplex pole[new_b$array_size0];
  i = 0;
  for( ; !((unsigned int)i >= n); i = i + 1)
  {
    pole[(signed long int)i].r = 0.0;
    pole[(signed long int)i].i = 0.0;
  }
  double T = 2.0;
  double W;
  double return_value_tan$1;
  return_value_tan$1=tan((3.14159265358979323846 * wc) / T);
  W = (2.0 / T) * return_value_tan$1;
  double epsilon;
  double return_value_pow$2;
  return_value_pow$2=pow(10.0, 0.1 * Rp);
  epsilon=sqrt(return_value_pow$2 - (double)1);
  double v0;
  double return_value_asinh$3;
  return_value_asinh$3=asinh((double)1 / epsilon);
  v0 = return_value_asinh$3 / (double)n;
  double sv0;
  sv0=sinh(v0);
  double cv0;
  cv0=cosh(v0);
  double t;
  i = (signed int)-(n - (unsigned int)1);
  k = 0;
  for( ; !((unsigned int)k >= n); k = k + 1)
  {
    t = (3.14159265358979323846 * (double)i) / (2.0 * (double)n);
    double return_value_cos$4;
    return_value_cos$4=cos(t);
    pole[(signed long int)k].r = -sv0 * return_value_cos$4;
    double return_value_sin$5;
    return_value_sin$5=sin(t);
    pole[(signed long int)k].i = cv0 * return_value_sin$5;
    i = i + 2;
  }
  struct _LingotComplex gain;
  lingot_filter_vector_product((signed int)n, pole, &gain);
  if((1u & n) == 0u)
  {
    double f;
    f=pow(10.0, -0.05 * Rp);
    gain.r = gain.r * f;
    gain.i = gain.i * f;
  }

  double lingot_filter_cheby_design$$1$$f;
  lingot_filter_cheby_design$$1$$f=pow(W, (double)n);
  gain.r = gain.r * lingot_filter_cheby_design$$1$$f;
  gain.i = gain.i * lingot_filter_cheby_design$$1$$f;
  i = 0;
  for( ; !((unsigned int)i >= n); i = i + 1)
  {
    pole[(signed long int)i].r = pole[(signed long int)i].r * W;
    pole[(signed long int)i].i = pole[(signed long int)i].i * W;
  }
  const signed long int f$array_size0 = (signed long int)n;
  struct _LingotComplex sp[f$array_size0];
  i = 0;
  for( ; !((unsigned int)i >= n); i = i + 1)
  {
    sp[(signed long int)i].r = (2.0 - pole[(signed long int)i].r * T) / T;
    sp[(signed long int)i].i = (0.0 - pole[(signed long int)i].i * T) / T;
  }
  struct _LingotComplex tmp1;
  struct _LingotComplex aux2;
  lingot_filter_vector_product((signed int)n, sp, &tmp1);
  lingot_complex_div(&gain, &tmp1, &gain);
  i = 0;
  for( ; !((unsigned int)i >= n); i = i + 1)
  {
    tmp1.r = 2.0 + pole[(signed long int)i].r * T;
    tmp1.i = 0.0 + pole[(signed long int)i].i * T;
    aux2.r = 2.0 - pole[(signed long int)i].r * T;
    aux2.i = 0.0 - pole[(signed long int)i].i * T;
    lingot_complex_div(&tmp1, &aux2, &pole[(signed long int)i]);
  }
  a[(signed long int)0] = 1.0;
  b[(signed long int)0] = 1.0;
  new_a[(signed long int)0] = 1.0;
  new_b[(signed long int)0] = 1.0;
  i = 1;
  for( ; n >= (unsigned int)i; i = i + 1)
  {
    a[(signed long int)i] = 0.0;
    b[(signed long int)i] = 0.0;
    new_a[(signed long int)i] = 0.0;
    new_b[(signed long int)i] = 0.0;
  }
  if((1u & n) == 1u)
  {
    a[(signed long int)1] = -pole[(signed long int)(n / (unsigned int)2)].r;
    b[(signed long int)1] = 1.0;
  }

  p = 0;
  for( ; !((unsigned int)p >= n / 2u); p = p + 1)
  {
    double b1 = 2.0;
    double b2 = 1.0;
    double a1 = -2.0 * pole[(signed long int)p].r;
    double a2 = pole[(signed long int)p].r * pole[(signed long int)p].r + pole[(signed long int)p].i * pole[(signed long int)p].i;
    new_a[(signed long int)1] = a[(signed long int)1] + a1 * a[(signed long int)0];
    new_b[(signed long int)1] = b[(signed long int)1] + b1 * b[(signed long int)0];
    i = 2;
    for( ; n >= (unsigned int)i; i = i + 1)
    {
      new_a[(signed long int)i] = a[(signed long int)i] + a1 * a[(signed long int)(i - 1)] + a2 * a[(signed long int)(i - 2)];
      new_b[(signed long int)i] = b[(signed long int)i] + b1 * b[(signed long int)(i - 1)] + b2 * b[(signed long int)(i - 2)];
    }
    i = 1;
    for( ; n >= (unsigned int)i; i = i + 1)
    {
      a[(signed long int)i] = new_a[(signed long int)i];
      b[(signed long int)i] = new_b[(signed long int)i];
    }
  }
  gain.r=fabs(gain.r);
  i = 0;
  for( ; n >= (unsigned int)i; i = i + 1)
    b[(signed long int)i] = b[(signed long int)i] * gain.r;
  struct _LingotFilter *return_value_lingot_filter_new$6;
  return_value_lingot_filter_new$6=lingot_filter_new(n, n, a, b);
  return return_value_lingot_filter_new$6;
}

// lingot_filter_destroy
// file lingot-filter.h line 57
void lingot_filter_destroy(struct _LingotFilter *filter)
{
  free((void *)filter->a);
  free((void *)filter->b);
  free((void *)filter->s);
  free((void *)filter);
}

// lingot_filter_filter
// file lingot-filter.h line 60
void lingot_filter_filter(struct _LingotFilter *filter, unsigned int n, double *in, double *out)
{
  double w;
  double y;
  unsigned int i;
  signed int j;
  i = (unsigned int)0;
  for( ; !(i >= n); i = i + 1u)
  {
    w = in[(signed long int)i];
    y = 0.0;
    j = (signed int)(filter->N - (unsigned int)1);
    for( ; j >= 0; j = j - 1)
    {
      w = w - filter->a[(signed long int)(j + 1)] * filter->s[(signed long int)j];
      y = y + filter->b[(signed long int)(j + 1)] * filter->s[(signed long int)j];
      filter->s[(signed long int)(j + 1)] = filter->s[(signed long int)j];
    }
    y = y + w * filter->b[(signed long int)0];
    filter->s[(signed long int)0] = w;
    out[(signed long int)i] = y;
  }
}

// lingot_filter_filter_sample
// file lingot-filter.h line 63
double lingot_filter_filter_sample(struct _LingotFilter *filter, double in)
{
  double result;
  lingot_filter_filter(filter, (unsigned int)1, &in, &result);
  return result;
}

// lingot_filter_new
// file lingot-filter.h line 49
struct _LingotFilter * lingot_filter_new(unsigned int Na, unsigned int Nb, double *a, double *b)
{
  unsigned int i;
  struct _LingotFilter *filter;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _LingotFilter) /*32ul*/ );
  filter = (struct _LingotFilter *)return_value_malloc$1;
  filter->N = Na < Nb ? Nb : Na;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)(filter->N + (unsigned int)1) * sizeof(double) /*8ul*/ );
  filter->a = (double *)return_value_malloc$2;
  void *return_value_malloc$3;
  return_value_malloc$3=malloc((unsigned long int)(filter->N + (unsigned int)1) * sizeof(double) /*8ul*/ );
  filter->b = (double *)return_value_malloc$3;
  void *return_value_malloc$4;
  return_value_malloc$4=malloc((unsigned long int)(filter->N + (unsigned int)1) * sizeof(double) /*8ul*/ );
  filter->s = (double *)return_value_malloc$4;
  i = (unsigned int)0;
  for( ; !(i >= 1u + filter->N); i = i + 1u)
  {
    filter->s[(signed long int)i] = 0.0;
    filter->b[(signed long int)i] = filter->s[(signed long int)i];
    filter->a[(signed long int)i] = filter->b[(signed long int)i];
  }
  memcpy((void *)filter->a, (const void *)a, (unsigned long int)(Na + (unsigned int)1) * sizeof(double) /*8ul*/ );
  memcpy((void *)filter->b, (const void *)b, (unsigned long int)(Nb + (unsigned int)1) * sizeof(double) /*8ul*/ );
  i = (unsigned int)0;
  for( ; !(i >= 1u + filter->N); i = i + 1u)
  {
    filter->a[(signed long int)i] = filter->a[(signed long int)i] / a[(signed long int)0];
    filter->b[(signed long int)i] = filter->b[(signed long int)i] / a[(signed long int)0];
  }
  return filter;
}

// lingot_filter_vector_product
// file lingot-filter.c line 98
void lingot_filter_vector_product(signed int n, struct _LingotComplex *vector, struct _LingotComplex *result)
{
  signed int i;
  struct _LingotComplex aux1;
  result->r = 1.0;
  result->i = 0.0;
  i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    aux1.r = -(vector + (signed long int)i)->r;
    aux1.i = -(vector + (signed long int)i)->i;
    lingot_complex_mul(result, &aux1, result);
  }
}

// lingot_gauge_compute
// file lingot-gauge.h line 43
void lingot_gauge_compute(struct _LingotGauge *gauge, double sample)
{
  gauge->position=lingot_filter_filter_sample(gauge->filter, sample);
}

// lingot_gauge_destroy
// file lingot-gauge.h line 42
void lingot_gauge_destroy(struct _LingotGauge *gauge)
{
  lingot_filter_destroy(gauge->filter);
  free((void *)gauge);
}

// lingot_gauge_new
// file lingot-gauge.h line 41
struct _LingotGauge * lingot_gauge_new(double initial_position)
{
  double k = (double)60;
  double q = (double)6;
  double a[3l] = { k + 60.0 * (q + 60.0), -60.0 * (q + 2.0 * 60.0), 60.0 * 60.0 };
  double b[1l] = { k };
  struct _LingotGauge *gauge;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct _LingotGauge) /*16ul*/ );
  gauge = (struct _LingotGauge *)return_value_malloc$1;
  gauge->filter=lingot_filter_new((unsigned int)2, (unsigned int)0, a, b);
  lingot_gauge_compute(gauge, initial_position);
  return gauge;
}

// lingot_gui_config_dialog_apply
// file lingot-gui-config-dialog.c line 260
signed int lingot_gui_config_dialog_apply(struct _LingotConfigDialog *dialog)
{
  char *text1;
  const char *text2;
  struct _LingotConfig *conf = dialog->conf;
  signed int return_value_lingot_gui_config_dialog_scale_validate$1;
  return_value_lingot_gui_config_dialog_scale_validate$1=lingot_gui_config_dialog_scale_validate(dialog, conf->scale);
  if(return_value_lingot_gui_config_dialog_scale_validate$1 == 0)
    return 0;

  else
  {
    conf->audio_system=lingot_gui_config_dialog_get_audio_system(dialog->input_system);
    unsigned long int return_value_gtk_bin_get_type$2;
    return_value_gtk_bin_get_type$2=gtk_bin_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)dialog->input_dev, return_value_gtk_bin_get_type$2);
    unsigned long int return_value_gtk_entry_get_type$4;
    return_value_gtk_entry_get_type$4=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkBin *)return_value_g_type_check_instance_cast$3)->child, return_value_gtk_entry_get_type$4);
    const char *return_value_gtk_entry_get_text$6;
    return_value_gtk_entry_get_text$6=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$5);
    sprintf(conf->audio_dev[(signed long int)conf->audio_system], "%s", return_value_gtk_entry_get_text$6);
    conf->root_frequency_error=gtk_spin_button_get_value(dialog->root_frequency_error);
    unsigned long int return_value_gtk_range_get_type$7;
    return_value_gtk_range_get_type$7=gtk_range_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)dialog->calculation_rate, return_value_gtk_range_get_type$7);
    conf->calculation_rate=gtk_range_get_value((struct _GtkRange *)return_value_g_type_check_instance_cast$8);
    unsigned long int return_value_gtk_range_get_type$9;
    return_value_gtk_range_get_type$9=gtk_range_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)dialog->visualization_rate, return_value_gtk_range_get_type$9);
    conf->visualization_rate=gtk_range_get_value((struct _GtkRange *)return_value_g_type_check_instance_cast$10);
    conf->temporal_window=gtk_spin_button_get_value(dialog->temporal_window);
    unsigned long int return_value_gtk_range_get_type$11;
    return_value_gtk_range_get_type$11=gtk_range_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)dialog->noise_threshold, return_value_gtk_range_get_type$11);
    conf->noise_threshold_db=gtk_range_get_value((struct _GtkRange *)return_value_g_type_check_instance_cast$12);
    unsigned long int return_value_gtk_range_get_type$13;
    return_value_gtk_range_get_type$13=gtk_range_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
    return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)dialog->gain, return_value_gtk_range_get_type$13);
    conf->gain=gtk_range_get_value((struct _GtkRange *)return_value_g_type_check_instance_cast$14);
    signed int return_value_gtk_spin_button_get_value_as_int$15;
    return_value_gtk_spin_button_get_value_as_int$15=gtk_spin_button_get_value_as_int(dialog->oversampling);
    conf->oversampling = (unsigned int)return_value_gtk_spin_button_get_value_as_int$15;
    signed int return_value_gtk_spin_button_get_value_as_int$16;
    return_value_gtk_spin_button_get_value_as_int$16=gtk_spin_button_get_value_as_int(dialog->dft_number);
    conf->dft_number = (unsigned int)return_value_gtk_spin_button_get_value_as_int$16;
    unsigned long int return_value_gtk_spin_button_get_type$17;
    return_value_gtk_spin_button_get_type$17=gtk_spin_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)dialog->dft_size, return_value_gtk_spin_button_get_type$17);
    signed int return_value_gtk_spin_button_get_value_as_int$19;
    return_value_gtk_spin_button_get_value_as_int$19=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$18);
    conf->dft_size = (unsigned int)return_value_gtk_spin_button_get_value_as_int$19;
    signed int return_value_gtk_spin_button_get_value_as_int$20;
    return_value_gtk_spin_button_get_value_as_int$20=gtk_spin_button_get_value_as_int(dialog->peak_number);
    conf->peak_number = (unsigned int)return_value_gtk_spin_button_get_value_as_int$20;
    signed int return_value_gtk_spin_button_get_value_as_int$21;
    return_value_gtk_spin_button_get_value_as_int$21=gtk_spin_button_get_value_as_int(dialog->peak_halfwidth);
    conf->peak_half_width = (unsigned int)return_value_gtk_spin_button_get_value_as_int$21;
    unsigned long int return_value_gtk_range_get_type$22;
    return_value_gtk_range_get_type$22=gtk_range_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
    return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)dialog->rejection_peak_relation, return_value_gtk_range_get_type$22);
    conf->peak_rejection_relation_db=gtk_range_get_value((struct _GtkRange *)return_value_g_type_check_instance_cast$23);
    signed int return_value_gtk_spin_button_get_value_as_int$24;
    return_value_gtk_spin_button_get_value_as_int$24=gtk_spin_button_get_value_as_int(dialog->minimum_frequency);
    conf->min_frequency = (double)return_value_gtk_spin_button_get_value_as_int$24;
    text1=gtk_combo_box_get_active_text(dialog->fft_size);
    signed int return_value_atoi$25;
    return_value_atoi$25=atoi(text1);
    conf->fft_size = (unsigned int)return_value_atoi$25;
    g_free((void *)text1);
    unsigned long int return_value_gtk_bin_get_type$26;
    return_value_gtk_bin_get_type$26=gtk_bin_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
    return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)dialog->sample_rate, return_value_gtk_bin_get_type$26);
    unsigned long int return_value_gtk_entry_get_type$28;
    return_value_gtk_entry_get_type$28=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
    return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkBin *)return_value_g_type_check_instance_cast$27)->child, return_value_gtk_entry_get_type$28);
    text2=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$29);
    conf->sample_rate=atoi(text2);
    struct _LingotScale *scale = conf->scale;
    lingot_config_scale_destroy(scale);
    lingot_gui_config_dialog_scale_apply(dialog, scale);
    lingot_config_update_internal_params(conf);
    lingot_gui_mainframe_change_config(dialog->mainframe, conf);
    if(scale->max_offset_rounded > 200.000000)
    {
      char *return_value_gettext$30;
      return_value_gettext$30=gettext("The provided scale contains wide gaps in frequency that increase the gauge range and produce a loss of visual accuracy. Consider providing scales with at least 12 tones, or with a maximum distance between adjacent notes below 200 cents.");
      lingot_msg_add_warning((const char *)return_value_gettext$30);
    }

    return 1;
  }
}

// lingot_gui_config_dialog_callback_button_apply
// file lingot-gui-config-dialog.c line 66
void lingot_gui_config_dialog_callback_button_apply(struct _GtkButton *button, struct _LingotConfigDialog *dialog)
{
  signed int return_value_lingot_gui_config_dialog_apply$1;
  return_value_lingot_gui_config_dialog_apply$1=lingot_gui_config_dialog_apply(dialog);
  if(!(return_value_lingot_gui_config_dialog_apply$1 == 0))
    lingot_gui_config_dialog_rewrite(dialog);

}

// lingot_gui_config_dialog_callback_button_cancel
// file lingot-gui-config-dialog.c line 49
void lingot_gui_config_dialog_callback_button_cancel(struct _GtkButton *button, struct _LingotConfigDialog *dialog)
{
  lingot_gui_config_dialog_close(dialog);
}

// lingot_gui_config_dialog_callback_button_default
// file lingot-gui-config-dialog.c line 73
void lingot_gui_config_dialog_callback_button_default(struct _GtkButton *button, struct _LingotConfigDialog *dialog)
{
  lingot_config_restore_default_values(dialog->conf);
  lingot_gui_config_dialog_rewrite(dialog);
}

// lingot_gui_config_dialog_callback_button_ok
// file lingot-gui-config-dialog.c line 54
void lingot_gui_config_dialog_callback_button_ok(struct _GtkButton *button, struct _LingotConfigDialog *dialog)
{
  signed int return_value_lingot_gui_config_dialog_apply$1;
  return_value_lingot_gui_config_dialog_apply$1=lingot_gui_config_dialog_apply(dialog);
  if(!(return_value_lingot_gui_config_dialog_apply$1 == 0))
  {
    lingot_config_save(dialog->conf, CONFIG_FILE_NAME);
    lingot_config_copy(dialog->conf_old, dialog->conf);
    lingot_gui_config_dialog_close(dialog);
  }

}

// lingot_gui_config_dialog_callback_cancel
// file lingot-gui-config-dialog.c line 79
void lingot_gui_config_dialog_callback_cancel(struct _GtkWidget *widget, struct _LingotConfigDialog *dialog)
{
  lingot_gui_config_dialog_close(dialog);
}

// lingot_gui_config_dialog_callback_change_deviation
// file lingot-gui-config-dialog.c line 165
void lingot_gui_config_dialog_callback_change_deviation(struct _GtkWidget *widget, struct _LingotConfigDialog *dialog)
{
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)dialog->scale_treeview, return_value_gtk_widget_get_type$1);
  gtk_widget_queue_draw((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
}

// lingot_gui_config_dialog_callback_change_input_system
// file lingot-gui-config-dialog.c line 118
void lingot_gui_config_dialog_callback_change_input_system(struct _GtkWidget *widget, struct _LingotConfigDialog *dialog)
{
  char buff[10l];
  char *text;
  text=gtk_combo_box_get_active_text(dialog->input_system);
  enum audio_system_t audio_system;
  audio_system=str_to_audio_system_t(text);
  free((void *)text);
  struct _LingotAudioSystemProperties *properties;
  properties=lingot_audio_get_audio_system_properties(audio_system);
  if(!(properties == ((struct _LingotAudioSystemProperties *)NULL)))
  {
    if(!(properties->forced_sample_rate == 0))
    {
      if(properties->n_sample_rates >= 1)
      {
        sprintf(buff, "%d", properties->sample_rates[(signed long int)0]);
        unsigned long int return_value_gtk_bin_get_type$1;
        return_value_gtk_bin_get_type$1=gtk_bin_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
        return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)dialog->sample_rate, return_value_gtk_bin_get_type$1);
        unsigned long int return_value_gtk_entry_get_type$3;
        return_value_gtk_entry_get_type$3=gtk_entry_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
        return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkBin *)return_value_g_type_check_instance_cast$2)->child, return_value_gtk_entry_get_type$3);
        gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4, buff);
      }

    }

    unsigned long int return_value_gtk_widget_get_type$5;
    return_value_gtk_widget_get_type$5=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)dialog->sample_rate, return_value_gtk_widget_get_type$5);
    gtk_widget_set_sensitive((struct _GtkWidget *)return_value_g_type_check_instance_cast$6, (signed int)!(properties->forced_sample_rate != 0));
    struct _GtkListStore *model;
    unsigned long int return_value_gtk_combo_box_get_type$7;
    return_value_gtk_combo_box_get_type$7=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)dialog->sample_rate, return_value_gtk_combo_box_get_type$7);
    struct _GtkTreeModel *return_value_gtk_combo_box_get_model$9;
    return_value_gtk_combo_box_get_model$9=gtk_combo_box_get_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$8);
    unsigned long int return_value_gtk_list_store_get_type$10;
    return_value_gtk_list_store_get_type$10=gtk_list_store_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
    return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_combo_box_get_model$9, return_value_gtk_list_store_get_type$10);
    model = (struct _GtkListStore *)return_value_g_type_check_instance_cast$11;
    gtk_list_store_clear(model);
    signed int i = 0;
    for( ; !(i >= properties->n_sample_rates); i = i + 1)
    {
      sprintf(buff, "%d", properties->sample_rates[(signed long int)i]);
      unsigned long int return_value_gtk_combo_box_get_type$12;
      return_value_gtk_combo_box_get_type$12=gtk_combo_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
      return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)dialog->sample_rate, return_value_gtk_combo_box_get_type$12);
      gtk_combo_box_append_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$13, buff);
    }
    unsigned long int return_value_gtk_bin_get_type$14;
    return_value_gtk_bin_get_type$14=gtk_bin_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)dialog->input_dev, return_value_gtk_bin_get_type$14);
    unsigned long int return_value_gtk_entry_get_type$16;
    return_value_gtk_entry_get_type$16=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
    return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkBin *)return_value_g_type_check_instance_cast$15)->child, return_value_gtk_entry_get_type$16);
    gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$17, dialog->conf->audio_dev[(signed long int)audio_system]);
    unsigned long int return_value_gtk_widget_get_type$18;
    return_value_gtk_widget_get_type$18=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
    return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)dialog->input_dev, return_value_gtk_widget_get_type$18);
    gtk_widget_set_sensitive((struct _GtkWidget *)return_value_g_type_check_instance_cast$19, (signed int)((signed int)audio_system != AUDIO_SYSTEM_JACK));
    lingot_audio_audio_system_properties_destroy(properties);
  }

  else
  {
    unsigned long int return_value_gtk_bin_get_type$20;
    return_value_gtk_bin_get_type$20=gtk_bin_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
    return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)dialog->input_dev, return_value_gtk_bin_get_type$20);
    unsigned long int return_value_gtk_entry_get_type$22;
    return_value_gtk_entry_get_type$22=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
    return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkBin *)return_value_g_type_check_instance_cast$21)->child, return_value_gtk_entry_get_type$22);
    gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$23, "");
    unsigned long int return_value_gtk_widget_get_type$24;
    return_value_gtk_widget_get_type$24=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
    return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)dialog->input_dev, return_value_gtk_widget_get_type$24);
    gtk_widget_set_sensitive((struct _GtkWidget *)return_value_g_type_check_instance_cast$25, 0);
    unsigned long int return_value_gtk_widget_get_type$26;
    return_value_gtk_widget_get_type$26=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
    return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)dialog->sample_rate, return_value_gtk_widget_get_type$26);
    gtk_widget_set_sensitive((struct _GtkWidget *)return_value_g_type_check_instance_cast$27, 0);
  }
}

// lingot_gui_config_dialog_callback_change_sample_rate
// file lingot-gui-config-dialog.c line 92
void lingot_gui_config_dialog_callback_change_sample_rate(struct _GtkWidget *widget, struct _LingotConfigDialog *dialog)
{
  const char *text;
  unsigned long int return_value_gtk_bin_get_type$1;
  return_value_gtk_bin_get_type$1=gtk_bin_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)dialog->sample_rate, return_value_gtk_bin_get_type$1);
  unsigned long int return_value_gtk_entry_get_type$3;
  return_value_gtk_entry_get_type$3=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkBin *)return_value_g_type_check_instance_cast$2)->child, return_value_gtk_entry_get_type$3);
  text=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4);
  signed int sr;
  if(!(text == ((const char *)NULL)))
    sr=atoi(text);

  else
    sr = 44100;
  char buff1[20l];
  char buff2[20l];
  double srf = (double)sr;
  double os;
  unsigned long int return_value_gtk_spin_button_get_type$5;
  return_value_gtk_spin_button_get_type$5=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)dialog->oversampling, return_value_gtk_spin_button_get_type$5);
  os=gtk_spin_button_get_value((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$6);
  sprintf(buff1, "%d", sr);
  sprintf(buff2, " = %0.1f", srf / os);
  gtk_label_set_text(dialog->label_sample_rate1, buff1);
  gtk_label_set_text(dialog->label_sample_rate2, buff2);
}

// lingot_gui_config_dialog_callback_close
// file lingot-gui-config-dialog.c line 85
void lingot_gui_config_dialog_callback_close(struct _GtkWidget *widget, struct _LingotConfigDialog *dialog)
{
  lingot_gui_mainframe_change_config(dialog->mainframe, dialog->conf_old);
  gtk_widget_destroy(dialog->win);
  lingot_gui_config_dialog_destroy(dialog);
}

// lingot_gui_config_dialog_close
// file lingot-gui-config-dialog.c line 318
void lingot_gui_config_dialog_close(struct _LingotConfigDialog *dialog)
{
  dialog->mainframe->config_dialog = (struct _LingotConfigDialog *)(void *)0;
  gtk_widget_destroy(dialog->win);
}

// lingot_gui_config_dialog_combo_select_value
// file lingot-gui-config-dialog.c line 195
void lingot_gui_config_dialog_combo_select_value(struct _GtkWidget *combo, signed int value)
{
  struct _GtkTreeModel *model;
  unsigned long int return_value_gtk_combo_box_get_type$1;
  return_value_gtk_combo_box_get_type$1=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)combo, return_value_gtk_combo_box_get_type$1);
  model=gtk_combo_box_get_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$2);
  struct _GtkTreeIter iter;
  signed int valid;
  valid=gtk_tree_model_get_iter_first(model, &iter);
  unsigned long int return_value_gtk_combo_box_get_type$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  while(!(valid == 0))
  {
    char *str_data;
    gtk_tree_model_get(model, &iter, 0, &str_data, -1);
    signed int return_value_atoi$5;
    return_value_atoi$5=atoi(str_data);
    if(return_value_atoi$5 == value)
    {
      return_value_gtk_combo_box_get_type$3=gtk_combo_box_get_type();
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)combo, return_value_gtk_combo_box_get_type$3);
      gtk_combo_box_set_active_iter((struct _GtkComboBox *)return_value_g_type_check_instance_cast$4, &iter);
    }

    g_free((void *)str_data);
    valid=gtk_tree_model_iter_next(model, &iter);
  }
}

// lingot_gui_config_dialog_destroy
// file lingot-gui-config-dialog.c line 253
void lingot_gui_config_dialog_destroy(struct _LingotConfigDialog *dialog)
{
  dialog->mainframe->config_dialog = (struct _LingotConfigDialog *)(void *)0;
  lingot_config_destroy(dialog->conf);
  lingot_config_destroy(dialog->conf_old);
  free((void *)dialog);
}

// lingot_gui_config_dialog_get_audio_system
// file lingot-gui-config-dialog.c line 188
enum audio_system_t lingot_gui_config_dialog_get_audio_system(struct _GtkComboBox *combo)
{
  char *text;
  text=gtk_combo_box_get_active_text(combo);
  signed int result;
  enum audio_system_t return_value_str_to_audio_system_t$1;
  return_value_str_to_audio_system_t$1=str_to_audio_system_t(text);
  result = (signed int)return_value_str_to_audio_system_t$1;
  free((void *)text);
  return (enum audio_system_t)result;
}

// lingot_gui_config_dialog_import_scl
// file lingot-gui-config-dialog-scale.c line 509
void lingot_gui_config_dialog_import_scl(void *data, struct _LingotConfigDialog *config_dialog)
{
  struct _GtkWidget *dialog;
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Open Scale File");
  unsigned long int return_value_gtk_window_get_type$2;
  return_value_gtk_window_get_type$2=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)config_dialog->win, return_value_gtk_window_get_type$2);
  dialog=gtk_file_chooser_dialog_new((const char *)return_value_gettext$1, (struct _GtkWindow *)return_value_g_type_check_instance_cast$3, (enum anonymous$7)GTK_FILE_CHOOSER_ACTION_OPEN, "gtk-cancel", -6, (const void *)"gtk-open", -3, (void *)0);
  struct _GtkFileFilter *filefilter;
  filefilter=gtk_file_filter_new();
  char *return_value_gettext$4;
  return_value_gettext$4=gettext("Scala files");
  gtk_file_filter_set_name(filefilter, (const char *)return_value_gettext$4);
  gtk_file_filter_add_pattern(filefilter, "*.scl");
  unsigned long int return_value_gtk_file_chooser_get_type$5;
  return_value_gtk_file_chooser_get_type$5=gtk_file_chooser_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$5);
  gtk_file_chooser_add_filter((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$6, filefilter);
  static char *filechooser_last_folder = (char *)(void *)0;
  if(!(filechooser_last_folder == ((char *)NULL)))
  {
    unsigned long int return_value_gtk_file_chooser_get_type$7;
    return_value_gtk_file_chooser_get_type$7=gtk_file_chooser_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$7);
    gtk_file_chooser_set_current_folder((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$8, filechooser_last_folder);
  }

  unsigned long int return_value_gtk_dialog_get_type$16;
  return_value_gtk_dialog_get_type$16=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$16);
  signed int return_value_gtk_dialog_run$18;
  return_value_gtk_dialog_run$18=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$17);
  if(return_value_gtk_dialog_run$18 == -3)
  {
    char *filename;
    unsigned long int return_value_gtk_file_chooser_get_type$9;
    return_value_gtk_file_chooser_get_type$9=gtk_file_chooser_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$9);
    filename=gtk_file_chooser_get_filename((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$10);
    if(!(filechooser_last_folder == ((char *)NULL)))
      free((void *)filechooser_last_folder);

    unsigned long int return_value_gtk_file_chooser_get_type$11;
    return_value_gtk_file_chooser_get_type$11=gtk_file_chooser_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$11);
    char *return_value_gtk_file_chooser_get_current_folder$13;
    return_value_gtk_file_chooser_get_current_folder$13=gtk_file_chooser_get_current_folder((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$12);
    filechooser_last_folder=strdup(return_value_gtk_file_chooser_get_current_folder$13);
    struct _LingotScale *scale;
    scale=lingot_config_scale_new();
    signed int return_value_lingot_config_scale_load_scl$15;
    return_value_lingot_config_scale_load_scl$15=lingot_config_scale_load_scl(scale, filename);
    if(return_value_lingot_config_scale_load_scl$15 == 0)
    {
      char *return_value_gettext$14;
      return_value_gettext$14=gettext("The scale cannot be imported: file format error");
      lingot_msg_add_error((const char *)return_value_gettext$14);
      lingot_config_scale_destroy(scale);
      free((void *)scale);
    }

    else
      lingot_gui_config_dialog_scale_rewrite(config_dialog, scale);
    g_free((void *)filename);
  }

  gtk_widget_destroy(dialog);
}

// lingot_gui_config_dialog_rewrite
// file lingot-gui-config-dialog.c line 212
void lingot_gui_config_dialog_rewrite(struct _LingotConfigDialog *dialog)
{
  struct _LingotConfig *conf = dialog->conf;
  lingot_gui_config_dialog_set_audio_system(dialog->input_system, conf->audio_system);
  unsigned long int return_value_gtk_bin_get_type$1;
  return_value_gtk_bin_get_type$1=gtk_bin_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)dialog->input_dev, return_value_gtk_bin_get_type$1);
  unsigned long int return_value_gtk_entry_get_type$3;
  return_value_gtk_entry_get_type$3=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkBin *)return_value_g_type_check_instance_cast$2)->child, return_value_gtk_entry_get_type$3);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4, conf->audio_dev[(signed long int)conf->audio_system]);
  unsigned long int return_value_gtk_range_get_type$5;
  return_value_gtk_range_get_type$5=gtk_range_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)dialog->calculation_rate, return_value_gtk_range_get_type$5);
  gtk_range_set_value((struct _GtkRange *)return_value_g_type_check_instance_cast$6, conf->calculation_rate);
  unsigned long int return_value_gtk_range_get_type$7;
  return_value_gtk_range_get_type$7=gtk_range_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)dialog->visualization_rate, return_value_gtk_range_get_type$7);
  gtk_range_set_value((struct _GtkRange *)return_value_g_type_check_instance_cast$8, conf->visualization_rate);
  unsigned long int return_value_gtk_range_get_type$9;
  return_value_gtk_range_get_type$9=gtk_range_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)dialog->noise_threshold, return_value_gtk_range_get_type$9);
  gtk_range_set_value((struct _GtkRange *)return_value_g_type_check_instance_cast$10, conf->noise_threshold_db);
  unsigned long int return_value_gtk_range_get_type$11;
  return_value_gtk_range_get_type$11=gtk_range_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)dialog->gain, return_value_gtk_range_get_type$11);
  gtk_range_set_value((struct _GtkRange *)return_value_g_type_check_instance_cast$12, conf->gain);
  gtk_spin_button_set_value(dialog->oversampling, (double)conf->oversampling);
  gtk_spin_button_set_value(dialog->root_frequency_error, conf->root_frequency_error);
  gtk_spin_button_set_value(dialog->temporal_window, conf->temporal_window);
  gtk_spin_button_set_value(dialog->dft_number, (double)conf->dft_number);
  gtk_spin_button_set_value(dialog->dft_size, (double)conf->dft_size);
  gtk_spin_button_set_value(dialog->peak_number, (double)conf->peak_number);
  gtk_spin_button_set_value(dialog->peak_halfwidth, (double)conf->peak_half_width);
  gtk_spin_button_set_value(dialog->minimum_frequency, conf->min_frequency);
  unsigned long int return_value_gtk_range_get_type$13;
  return_value_gtk_range_get_type$13=gtk_range_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)dialog->rejection_peak_relation, return_value_gtk_range_get_type$13);
  gtk_range_set_value((struct _GtkRange *)return_value_g_type_check_instance_cast$14, conf->peak_rejection_relation_db);
  unsigned long int return_value_gtk_widget_get_type$15;
  return_value_gtk_widget_get_type$15=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)dialog->fft_size, return_value_gtk_widget_get_type$15);
  lingot_gui_config_dialog_combo_select_value((struct _GtkWidget *)return_value_g_type_check_instance_cast$16, (signed int)conf->fft_size);
  char buff[10l];
  sprintf(buff, "%d", conf->sample_rate);
  unsigned long int return_value_gtk_bin_get_type$17;
  return_value_gtk_bin_get_type$17=gtk_bin_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)dialog->sample_rate, return_value_gtk_bin_get_type$17);
  unsigned long int return_value_gtk_entry_get_type$19;
  return_value_gtk_entry_get_type$19=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkBin *)return_value_g_type_check_instance_cast$18)->child, return_value_gtk_entry_get_type$19);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$20, buff);
  lingot_gui_config_dialog_scale_rewrite(dialog, conf->scale);
}

// lingot_gui_config_dialog_scale_apply
// file lingot-gui-config-dialog-scale.h line 40
void lingot_gui_config_dialog_scale_apply(struct _LingotConfigDialog *dialog, struct _LingotScale *scale)
{
  struct _GtkTreeIter iter;
  struct _GtkTreeModel *model;
  model=gtk_tree_view_get_model(dialog->scale_treeview);
  double freq;
  double shift;
  signed short int shift_num;
  signed short int shift_den;
  char *shift_char;
  char *name;
  signed int i = 0;
  signed int rows;
  rows=gtk_tree_model_iter_n_children(model, (struct _GtkTreeIter *)(void *)0);
  gtk_tree_model_get_iter_first(model, &iter);
  gtk_tree_model_get(model, &iter, 2, &freq, -1);
  const char *return_value_gtk_entry_get_text$1;
  return_value_gtk_entry_get_text$1=gtk_entry_get_text(dialog->scale_name);
  scale->name=strdup(return_value_gtk_entry_get_text$1);
  scale->base_frequency = freq;
  lingot_config_scale_allocate(scale, (unsigned short int)rows);
  signed int return_value_gtk_tree_model_iter_next$2;
  do
  {
    gtk_tree_model_get(model, &iter, 0, &name, 1, &shift_char, -1);
    lingot_config_scale_parse_shift(shift_char, &shift, &shift_num, &shift_den);
    free((void *)shift_char);
    scale->note_name[(signed long int)i] = name;
    scale->offset_cents[(signed long int)i] = shift;
    scale->offset_ratios[(signed long int)0][(signed long int)i] = shift_num;
    scale->offset_ratios[(signed long int)1][(signed long int)i] = shift_den;
    i = i + 1;
    return_value_gtk_tree_model_iter_next$2=gtk_tree_model_iter_next(model, &iter);
  }
  while(!(return_value_gtk_tree_model_iter_next$2 == 0));
}

// lingot_gui_config_dialog_scale_key_press_cb
// file lingot-gui-config-dialog-scale.c line 552
signed int lingot_gui_config_dialog_scale_key_press_cb(struct _GtkWidget *widget, struct _GdkEventKey *kevent, void *data)
{
  struct _LingotConfigDialog *dialog = (struct _LingotConfigDialog *)data;
  if((signed int)kevent->type == GDK_KEY_PRESS)
  {
    if(kevent->keyval == 65535u)
    {
      struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
      return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)dialog->button_scale_del, (unsigned long int)(20 << 2));
      g_signal_emit_by_name((void *)(struct _GObject *)return_value_g_type_check_instance_cast$1, "clicked", (void *)0);
    }

    else
      if(kevent->keyval == 65379u)
      {
        struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
        return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)dialog->button_scale_add, (unsigned long int)(20 << 2));
        g_signal_emit_by_name((void *)(struct _GObject *)return_value_g_type_check_instance_cast$2, "clicked", (void *)0);
      }

  }

  return (signed int)!(0 != 0);
}

// lingot_gui_config_dialog_scale_rewrite
// file lingot-gui-config-dialog-scale.h line 44
void lingot_gui_config_dialog_scale_rewrite(struct _LingotConfigDialog *dialog, struct _LingotScale *scale)
{
  gtk_entry_set_text(dialog->scale_name, scale->name);
  struct _GtkTreeStore *store;
  struct _GtkTreeModel *return_value_gtk_tree_view_get_model$1;
  return_value_gtk_tree_view_get_model$1=gtk_tree_view_get_model(dialog->scale_treeview);
  store = (struct _GtkTreeStore *)return_value_gtk_tree_view_get_model$1;
  gtk_tree_store_clear(store);
  struct _GtkTreeIter iter2;
  char buff[80l];
  signed int i = 0;
  for( ; !(i >= (signed int)scale->notes); i = i + 1)
  {
    gtk_tree_store_append(store, &iter2, (struct _GtkTreeIter *)(void *)0);
    double freq;
    double return_value_pow$2;
    return_value_pow$2=pow(2.0, scale->offset_cents[(signed long int)i] / 1200.0);
    freq = scale->base_frequency * return_value_pow$2;
    lingot_config_scale_format_shift(buff, scale->offset_cents[(signed long int)i], scale->offset_ratios[(signed long int)0][(signed long int)i], scale->offset_ratios[(signed long int)1][(signed long int)i]);
    gtk_tree_store_set(store, &iter2, 0, scale->note_name[(signed long int)i], 1, (const void *)buff, 2, freq, -1);
  }
}

// lingot_gui_config_dialog_scale_show
// file lingot-gui-config-dialog-scale.h line 33
void lingot_gui_config_dialog_scale_show(struct _LingotConfigDialog *dialog, struct _GladeXML *_gladeXML)
{
  struct _GtkWidget *return_value_glade_xml_get_widget$1;
  return_value_glade_xml_get_widget$1=glade_xml_get_widget(_gladeXML, "scale_name");
  unsigned long int return_value_gtk_entry_get_type$2;
  return_value_gtk_entry_get_type$2=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$1, return_value_gtk_entry_get_type$2);
  dialog->scale_name = (struct _GtkEntry *)return_value_g_type_check_instance_cast$3;
  struct _GtkWidget *scroll;
  scroll=glade_xml_get_widget(_gladeXML, "scrolledwindow1");
  struct _GtkTreeStore *model_store;
  model_store=gtk_tree_store_new(3, (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(15 << 2));
  struct _GtkTreeModel *model;
  unsigned long int return_value_gtk_tree_model_get_type$4;
  return_value_gtk_tree_model_get_type$4=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)model_store, return_value_gtk_tree_model_get_type$4);
  model = (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$5;
  struct _GtkWidget *return_value_gtk_tree_view_new$6;
  return_value_gtk_tree_view_new$6=gtk_tree_view_new();
  unsigned long int return_value_gtk_tree_view_get_type$7;
  return_value_gtk_tree_view_get_type$7=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_tree_view_new$6, return_value_gtk_tree_view_get_type$7);
  dialog->scale_treeview = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$8;
  lingot_gui_config_dialog_scale_tree_add_column(dialog);
  gtk_tree_view_set_model(dialog->scale_treeview, model);
  struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection$9;
  return_value_gtk_tree_view_get_selection$9=gtk_tree_view_get_selection(dialog->scale_treeview);
  gtk_tree_selection_set_mode(return_value_gtk_tree_view_get_selection$9, (enum anonymous$6)GTK_SELECTION_MULTIPLE);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)model, (unsigned long int)(20 << 2));
  g_object_unref((void *)(struct _GObject *)return_value_g_type_check_instance_cast$10);
  unsigned long int return_value_gtk_container_get_type$11;
  return_value_gtk_container_get_type$11=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)scroll, return_value_gtk_container_get_type$11);
  unsigned long int return_value_gtk_widget_get_type$13;
  return_value_gtk_widget_get_type$13=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)dialog->scale_treeview, return_value_gtk_widget_get_type$13);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$12, (struct _GtkWidget *)return_value_g_type_check_instance_cast$14);
  struct _GtkWidget *return_value_glade_xml_get_widget$15;
  return_value_glade_xml_get_widget$15=glade_xml_get_widget(_gladeXML, "button_scale_del");
  unsigned long int return_value_gtk_button_get_type$16;
  return_value_gtk_button_get_type$16=gtk_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$15, return_value_gtk_button_get_type$16);
  dialog->button_scale_del = (struct _GtkButton *)return_value_g_type_check_instance_cast$17;
  struct _GtkWidget *return_value_glade_xml_get_widget$18;
  return_value_glade_xml_get_widget$18=glade_xml_get_widget(_gladeXML, "button_scale_add");
  unsigned long int return_value_gtk_button_get_type$19;
  return_value_gtk_button_get_type$19=gtk_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$18, return_value_gtk_button_get_type$19);
  dialog->button_scale_add = (struct _GtkButton *)return_value_g_type_check_instance_cast$20;
  struct _GtkButton *button_import;
  struct _GtkWidget *return_value_glade_xml_get_widget$21;
  return_value_glade_xml_get_widget$21=glade_xml_get_widget(_gladeXML, "button_scale_import");
  unsigned long int return_value_gtk_button_get_type$22;
  return_value_gtk_button_get_type$22=gtk_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
  return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$21, return_value_gtk_button_get_type$22);
  button_import = (struct _GtkButton *)return_value_g_type_check_instance_cast$23;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)dialog->scale_treeview, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$24, "key_press_event", (void (*)(void))lingot_gui_config_dialog_scale_key_press_cb, (void *)dialog, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$17)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
  return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)dialog->button_scale_add, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$25, "clicked", (void (*)(void))lingot_gui_config_dialog_scale_tree_add_row_tree, (void *)dialog->scale_treeview, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$17)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)dialog->button_scale_del, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$26, "clicked", (void (*)(void))lingot_gui_config_dialog_scale_tree_remove_selected_items, (void *)dialog->scale_treeview, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$17)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
  return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)button_import, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$27, "clicked", (void (*)(void))lingot_gui_config_dialog_import_scl, (void *)dialog, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$17)0);
  unsigned long int return_value_gtk_widget_get_type$28;
  return_value_gtk_widget_get_type$28=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
  return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)dialog->scale_treeview, return_value_gtk_widget_get_type$28);
  gtk_widget_set_has_tooltip((struct _GtkWidget *)return_value_g_type_check_instance_cast$29, (signed int)!(0 != 0));
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)dialog->scale_treeview, (unsigned long int)(20 << 2));
  g_signal_connect_data((void *)(struct _GObject *)return_value_g_type_check_instance_cast$30, "query-tooltip", (void (*)(void))lingot_gui_config_dialog_scale_table_query_tooltip, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$17)0);
}

// lingot_gui_config_dialog_scale_table_query_tooltip
// file lingot-gui-config-dialog-scale.c line 588
signed int lingot_gui_config_dialog_scale_table_query_tooltip(struct _GtkWidget *widget, signed int x, signed int y, signed int keyboard_mode, struct _GtkTooltip *tooltip, void *user_data)
{
  struct _GtkTreePath *path;
  struct _GtkTreeViewColumn *col;
  signed int cx;
  signed int cy;
  gtk_tree_view_get_path_at_pos((struct _GtkTreeView *)widget, x, y, &path, &col, &cx, &cy);
  signed int column_index;
  column_index=lingot_gui_config_dialog_scale_tree_view_column_get_index(col);
  char *return_value_gettext$1;
  char *return_value_gettext$2;
  char *return_value_gettext$3;
  switch(column_index)
  {
    case 0:
    {
      return_value_gettext$1=gettext("Note identifier, free text that will be displayed in the main window when tuning close to the given note. Don't use space characters here.");
      gtk_tooltip_set_text(tooltip, (const char *)return_value_gettext$1);
      break;
    }
    case 1:
    {
      return_value_gettext$2=gettext("Shift. You can define it as a deviation in cents from the reference note (the first one), or as a frequency ratio, like '3/2' or '5/4'. All the values must be between 0 and 1200 cents, or between 1/1 and 2/1 (i.e., all the notes must be in the same octave), and they must be well ordered.");
      gtk_tooltip_set_text(tooltip, (const char *)return_value_gettext$2);
      break;
    }
    case 2:
    {
      return_value_gettext$3=gettext("Frequency. You can enter here the absolute frequency for a given note as a reference, and all the other frequencies will shift according to the deviations specified in the 'Shift' column. You can use an absolute numeric value or the keywords 'mid-C' (261.625565 Hz) and 'mid-A' (440 Hz).");
      gtk_tooltip_set_text(tooltip, (const char *)return_value_gettext$3);
    }
  }
  return (signed int)!(0 != 0);
}

// lingot_gui_config_dialog_scale_tree_add_column
// file lingot-gui-config-dialog-scale.c line 314
void lingot_gui_config_dialog_scale_tree_add_column(struct _LingotConfigDialog *config_dialog)
{
  struct _GtkCellRenderer *renderer;
  struct _GtkTreeViewColumn *column;
  struct _GtkTreeView *treeview = config_dialog->scale_treeview;
  column=gtk_tree_view_column_new();
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Name");
  gtk_tree_view_column_set_title(column, (const char *)return_value_gettext$1);
  renderer=gtk_cell_renderer_text_new();
  gtk_tree_view_column_pack_start(column, renderer, 0);
  gtk_tree_view_column_set_attributes(column, renderer, (const void *)"text", 0, (void *)0);
  g_object_set((void *)renderer, "editable", !(0 != 0), (void *)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)renderer, (unsigned long int)(20 << 2));
  g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$2, "my_column_num", (void *)(unsigned long int)0);
  g_signal_connect_data((void *)renderer, "edited", (void (*)(void))lingot_gui_config_dialog_scale_tree_cell_edited_callback, (void *)config_dialog, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$17)0);
  gtk_tree_view_append_column(treeview, column);
  column=gtk_tree_view_column_new();
  char *return_value_gettext$3;
  return_value_gettext$3=gettext("Shift");
  gtk_tree_view_column_set_title(column, (const char *)return_value_gettext$3);
  renderer=gtk_cell_renderer_text_new();
  gtk_tree_view_column_pack_start(column, renderer, 0);
  gtk_tree_view_column_set_attributes(column, renderer, (const void *)"text", 1, (void *)0);
  g_object_set((void *)renderer, "editable", !(0 != 0), (void *)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)renderer, (unsigned long int)(20 << 2));
  g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$4, "my_column_num", (void *)(unsigned long int)1);
  g_signal_connect_data((void *)renderer, "edited", (void (*)(void))lingot_gui_config_dialog_scale_tree_cell_edited_callback, (void *)config_dialog, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$17)0);
  gtk_tree_view_append_column(treeview, column);
  column=gtk_tree_view_column_new();
  char *return_value_gettext$5;
  return_value_gettext$5=gettext("Frequency [Hz]");
  gtk_tree_view_column_set_title(column, (const char *)return_value_gettext$5);
  renderer=gtk_cell_renderer_text_new();
  gtk_tree_view_column_pack_start(column, renderer, 0);
  gtk_tree_view_column_set_attributes(column, renderer, (const void *)"text", 2, (void *)0);
  g_object_set((void *)renderer, "editable", !(0 != 0), (void *)0);
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)renderer, (unsigned long int)(20 << 2));
  g_object_set_data((struct _GObject *)return_value_g_type_check_instance_cast$6, "my_column_num", (void *)(unsigned long int)2);
  gtk_tree_view_column_set_cell_data_func(column, renderer, lingot_gui_config_dialog_scale_tree_frequency_cell_data_function, (void *)config_dialog, (void (*)(void *))(void *)0);
  g_signal_connect_data((void *)renderer, "edited", (void (*)(void))lingot_gui_config_dialog_scale_tree_cell_edited_callback, (void *)config_dialog, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$17)0);
  gtk_tree_view_append_column(treeview, column);
}

// lingot_gui_config_dialog_scale_tree_add_row_tree
// file lingot-gui-config-dialog-scale.c line 37
void lingot_gui_config_dialog_scale_tree_add_row_tree(void *data, struct _GtkTreeView *treeview)
{
  struct _GtkTreeModel *model;
  struct _GtkTreeStore *model_store;
  struct _GtkTreeIter iter1;
  struct _GtkTreeIter iter2;
  double freq;
  model=gtk_tree_view_get_model(treeview);
  model_store = (struct _GtkTreeStore *)model;
  struct _GtkTreeSelection *selection;
  selection=gtk_tree_view_get_selection(treeview);
  signed int return_value_gtk_tree_selection_count_selected_rows$4;
  return_value_gtk_tree_selection_count_selected_rows$4=gtk_tree_selection_count_selected_rows(selection);
  if(return_value_gtk_tree_selection_count_selected_rows$4 == 0)
    gtk_tree_store_append(model_store, &iter2, (struct _GtkTreeIter *)(void *)0);

  else
  {
    struct _GList *list;
    list=gtk_tree_selection_get_selected_rows(selection, &model);
    signed int ipath;
    char *return_value_gtk_tree_path_to_string$1;
    return_value_gtk_tree_path_to_string$1=gtk_tree_path_to_string((struct _GtkTreePath *)list->data);
    ipath=atoi(return_value_gtk_tree_path_to_string$1);
    struct _GString *fixed_path;
    fixed_path=g_string_new("");
    g_string_printf(fixed_path, "%d", ipath);
    struct _GtkTreePath *path;
    path=gtk_tree_path_new_from_string(fixed_path->str);
    g_string_free(fixed_path, (signed int)!(0 != 0));
    signed int valid = 0;
    if(!(path == ((struct _GtkTreePath *)NULL)))
    {
      signed int return_value_gtk_tree_model_get_iter$2;
      return_value_gtk_tree_model_get_iter$2=gtk_tree_model_get_iter(model, &iter1, path);
      if(!(return_value_gtk_tree_model_get_iter$2 == 0))
        valid = (signed int)!(0 != 0);

      gtk_tree_path_free(path);
    }

    g_list_foreach(list, (void (*)(void *, void *))gtk_tree_path_free, (void *)0);
    g_list_free(list);
    if(valid == 0)
      goto __CPROVER_DUMP_L7;

    if(ipath == 0)
    {
      char *return_value_gettext$3;
      return_value_gettext$3=gettext("You cannot insert before the reference note.");
      lingot_msg_add_warning((const char *)return_value_gettext$3);
      goto __CPROVER_DUMP_L7;
    }

    gtk_tree_store_insert_before(model_store, &iter2, (struct _GtkTreeIter *)(void *)0, &iter1);
  }
  gtk_tree_model_get_iter_first(model, &iter1);
  gtk_tree_model_get(model, &iter1, 2, &freq, -1);
  gtk_tree_store_set(model_store, &iter2, 0, (const void *)"?", 1, (const void *)"1/1", 2, freq, -1);

__CPROVER_DUMP_L7:
  ;
}

// lingot_gui_config_dialog_scale_tree_cell_edited_callback
// file lingot-gui-config-dialog-scale.c line 142
void lingot_gui_config_dialog_scale_tree_cell_edited_callback(struct _GtkCellRendererText *cell, char *path_string, char *new_text, void *user_data)
{
  struct _GtkTreeView *treeview;
  struct _GtkTreeModel *model;
  struct _GtkTreeStore *model_store;
  struct _GtkTreeIter iter;
  struct _GtkTreeIter iter2;
  struct _GtkCellRenderer *renderer;
  char *shift_char;
  char *stored_shift_char;
  double freq;
  double stored_freq;
  double base_freq;
  double stored_shift;
  double shift_cents;
  signed short int shift_numerator;
  signed short int shift_denominator;
  double shiftf2;
  double freq2;
  char *char_pointer;
  char buff[80l];
  const char *delim = " \t\n";
  struct _LingotConfigDialog *config_dialog = (struct _LingotConfigDialog *)user_data;
  signed int index;
  treeview = config_dialog->scale_treeview;
  struct _GtkTreeModel *return_value_gtk_tree_view_get_model$1;
  return_value_gtk_tree_view_get_model$1=gtk_tree_view_get_model(treeview);
  model_store = (struct _GtkTreeStore *)return_value_gtk_tree_view_get_model$1;
  struct _GtkTreeSelection *selection;
  selection=gtk_tree_view_get_selection(treeview);
  signed int return_value_gtk_tree_selection_count_selected_rows$2;
  return_value_gtk_tree_selection_count_selected_rows$2=gtk_tree_selection_count_selected_rows(selection);
  char *return_value_strchr$14;
  _Bool tmp_if_expr$16;
  char *return_value_strchr$15;
  char *return_value_strchr$9;
  _Bool tmp_if_expr$11;
  char *return_value_strchr$10;
  _Bool tmp_if_expr$13;
  char *return_value_strchr$12;
  double return_value_fabs$18;
  signed int return_value___isnan$20;
  double return_value_pow$21;
  signed int return_value_strcmp$23;
  signed int return_value_strcmp$22;
  double return_value_gtk_spin_button_get_value$24;
  double return_value_pow$25;
  double return_value_pow$26;
  signed int return_value_gtk_tree_model_iter_next$27;
  if(return_value_gtk_tree_selection_count_selected_rows$2 == 1)
  {
    struct _GList *list;
    list=gtk_tree_selection_get_selected_rows(selection, &model);
    signed int ipath;
    char *return_value_gtk_tree_path_to_string$3;
    return_value_gtk_tree_path_to_string$3=gtk_tree_path_to_string((struct _GtkTreePath *)list->data);
    ipath=atoi(return_value_gtk_tree_path_to_string$3);
    struct _GString *fixed_path;
    fixed_path=g_string_new("");
    g_string_printf(fixed_path, "%d", ipath);
    struct _GtkTreePath *path;
    path=gtk_tree_path_new_from_string(fixed_path->str);
    g_string_free(fixed_path, (signed int)!(0 != 0));
    signed int valid = 0;
    if(!(path == ((struct _GtkTreePath *)NULL)))
    {
      signed int return_value_gtk_tree_model_get_iter$4;
      return_value_gtk_tree_model_get_iter$4=gtk_tree_model_get_iter(model, &iter, path);
      if(!(return_value_gtk_tree_model_get_iter$4 == 0))
        valid = (signed int)!(0 != 0);

      gtk_tree_path_free(path);
    }

    g_list_foreach(list, (void (*)(void *, void *))gtk_tree_path_free, (void *)0);
    g_list_free(list);
    if(!(valid == 0))
    {
      renderer = &cell->parent;
      unsigned int column_number;
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)renderer, (unsigned long int)(20 << 2));
      void *return_value_g_object_get_data$6;
      return_value_g_object_get_data$6=g_object_get_data((struct _GObject *)return_value_g_type_check_instance_cast$5, "my_column_num");
      column_number = (unsigned int)(unsigned long int)return_value_g_object_get_data$6;
      switch(column_number)
      {
        case (unsigned int)0:
        {
          return_value_strchr$14=strchr(new_text, 32);
          if(!(return_value_strchr$14 == ((char *)NULL)))
            tmp_if_expr$16 = (_Bool)1;

          else
          {
            return_value_strchr$15=strchr(new_text, 9);
            tmp_if_expr$16 = return_value_strchr$15 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$16)
          {
            char *return_value_gettext$7;
            return_value_gettext$7=gettext("Do not use space characters for the note names.");
            lingot_msg_add_warning((const char *)return_value_gettext$7);
          }

          else
          {
            return_value_strchr$9=strchr(new_text, 10);
            if(!(return_value_strchr$9 == ((char *)NULL)))
              tmp_if_expr$11 = (_Bool)1;

            else
            {
              return_value_strchr$10=strchr(new_text, 123);
              tmp_if_expr$11 = return_value_strchr$10 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$11)
              tmp_if_expr$13 = (_Bool)1;

            else
            {
              return_value_strchr$12=strchr(new_text, 125);
              tmp_if_expr$13 = return_value_strchr$12 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$13)
            {
              char *return_value_gettext$8;
              return_value_gettext$8=gettext("The name contains illegal characters.");
              lingot_msg_add_warning((const char *)return_value_gettext$8);
            }

            else
            {
              char_pointer=strtok(new_text, delim);
              gtk_tree_store_set(model_store, &iter, 0, char_pointer == (char *)(void *)0 ? "?" : new_text, -1);
            }
          }
          break;
        }
        case (unsigned int)1:
        {
          lingot_config_scale_parse_shift(new_text, &shift_cents, &shift_numerator, &shift_denominator);
          if(ipath == 0)
          {
            return_value_fabs$18=fabs(shift_cents - 0.0);
            if(return_value_fabs$18 > 1e-10)
            {
              char *return_value_gettext$17;
              return_value_gettext$17=gettext("You cannot change the first shift, it must be 1/1.");
              lingot_msg_add_warning((const char *)return_value_gettext$17);
              break;
            }

          }

          return_value___isnan$20=__isnan(shift_cents);
          if(shift_cents <= -1.000000e-10 || shift_cents > 1200.0 || !(return_value___isnan$20 == 0))
          {
            char *return_value_gettext$19;
            return_value_gettext$19=gettext("The shift must be between 0 and 1200 cents, or between 1/1 and 2/1.");
            lingot_msg_add_warning((const char *)return_value_gettext$19);
            break;
          }

          gtk_tree_model_get(model, &iter, 1, &stored_shift_char, 2, &stored_freq, -1);
          lingot_config_scale_parse_shift(stored_shift_char, &stored_shift, (signed short int *)(void *)0, (signed short int *)(void *)0);
          free((void *)stored_shift_char);
          lingot_config_scale_format_shift(buff, shift_cents, shift_numerator, shift_denominator);
          return_value_pow$21=pow(2.0, (shift_cents - stored_shift) / 1200.0);
          gtk_tree_store_set(model_store, &iter, 1, (const void *)buff, 2, stored_freq * return_value_pow$21, -1);
          break;
        }
        case (unsigned int)2:
        {
          return_value_strcmp$23=strcmp(new_text, "mid-A");
          if(return_value_strcmp$23 == 0)
            freq = 440.0;

          else
          {
            return_value_strcmp$22=strcmp(new_text, "mid-C");
            if(return_value_strcmp$22 == 0)
              freq = 261.625565;

            else
              sscanf(new_text, "%lg", &freq);
          }
          gtk_tree_model_get(model, &iter, 1, &shift_char, 2, &stored_freq, -1);
          lingot_config_scale_parse_shift(shift_char, &shift_cents, (signed short int *)(void *)0, (signed short int *)(void *)0);
          free((void *)shift_char);
          return_value_gtk_spin_button_get_value$24=gtk_spin_button_get_value(config_dialog->root_frequency_error);
          return_value_pow$25=pow(2.0, -return_value_gtk_spin_button_get_value$24 / 1200.0);
          freq = freq * return_value_pow$25;
          return_value_pow$26=pow(2.0, -shift_cents / 1200.0);
          base_freq = freq * return_value_pow$26;
          gtk_tree_model_get_iter_first(model, &iter2);
          index = 0;
          do
          {
            gtk_tree_model_get(model, &iter2, 1, &shift_char, -1);
            lingot_config_scale_parse_shift(shift_char, &shiftf2, (signed short int *)(void *)0, (signed short int *)(void *)0);
            free((void *)shift_char);
            double return_value_pow$28;
            return_value_pow$28=pow(2.0, shiftf2 / 1200.0);
            freq2 = base_freq * return_value_pow$28;
            gtk_tree_store_set(model_store, &iter2, 2, index == ipath ? freq : freq2, -1);
            index = index + 1;
            return_value_gtk_tree_model_iter_next$27=gtk_tree_model_iter_next(model, &iter2);
          }
          while(!(return_value_gtk_tree_model_iter_next$27 == 0));
        }
      }
    }

  }

}

// lingot_gui_config_dialog_scale_tree_frequency_cell_data_function
// file lingot-gui-config-dialog-scale.c line 293
void lingot_gui_config_dialog_scale_tree_frequency_cell_data_function(struct _GtkTreeViewColumn *col, struct _GtkCellRenderer *renderer, struct _GtkTreeModel *model, struct _GtkTreeIter *iter, void *user_data)
{
  double freq;
  char buf[20l];
  struct _LingotConfigDialog *config_dialog = (struct _LingotConfigDialog *)user_data;
  gtk_tree_model_get(model, iter, 2, &freq, -1);
  double return_value_gtk_spin_button_get_value$1;
  return_value_gtk_spin_button_get_value$1=gtk_spin_button_get_value(config_dialog->root_frequency_error);
  double return_value_pow$2;
  return_value_pow$2=pow(2.0, return_value_gtk_spin_button_get_value$1 / 1200.0);
  freq = freq * return_value_pow$2;
  double return_value_fabs$4;
  return_value_fabs$4=fabs(freq - 440.0);
  double return_value_fabs$3;
  if(return_value_fabs$4 < 1e-3)
    g_object_set((void *)renderer, "text", (const void *)"mid-A", (void *)0);

  else
  {
    return_value_fabs$3=fabs(freq - 261.625565);
    if(return_value_fabs$3 < 1e-3)
      g_object_set((void *)renderer, "text", (const void *)"mid-C", (void *)0);

    else
    {
      g_snprintf(buf, sizeof(char [20l]) /*20ul*/ , "%.4f", freq);
      g_object_set((void *)renderer, "text", (const void *)buf, (void *)0);
    }
  }
}

// lingot_gui_config_dialog_scale_tree_remove_selected_items
// file lingot-gui-config-dialog-scale.c line 99
void lingot_gui_config_dialog_scale_tree_remove_selected_items(void *data, struct _GtkTreeView *treeview)
{
  struct _GtkTreeStore *store;
  struct _GtkTreeModel *model;
  struct _GtkTreeIter iter;
  struct _GtkTreeSelection *selection;
  selection=gtk_tree_view_get_selection(treeview);
  signed int return_value_gtk_tree_selection_count_selected_rows$1;
  return_value_gtk_tree_selection_count_selected_rows$1=gtk_tree_selection_count_selected_rows(selection);
  if(!(return_value_gtk_tree_selection_count_selected_rows$1 == 0))
  {
    struct _GList *list;
    list=gtk_tree_selection_get_selected_rows(selection, &model);
    unsigned long int return_value_gtk_tree_store_get_type$2;
    return_value_gtk_tree_store_get_type$2=gtk_tree_store_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)model, return_value_gtk_tree_store_get_type$2);
    store = (struct _GtkTreeStore *)return_value_g_type_check_instance_cast$3;
    signed int nRemoved = 0;
    while(!(list == ((struct _GList *)NULL)))
    {
      signed int ipath;
      char *return_value_gtk_tree_path_to_string$4;
      return_value_gtk_tree_path_to_string$4=gtk_tree_path_to_string((struct _GtkTreePath *)list->data);
      ipath=atoi(return_value_gtk_tree_path_to_string$4);
      ipath = ipath - nRemoved;
      struct _GString *fixed_path;
      fixed_path=g_string_new("");
      g_string_printf(fixed_path, "%d", ipath);
      struct _GtkTreePath *path;
      path=gtk_tree_path_new_from_string(fixed_path->str);
      g_string_free(fixed_path, (signed int)!(0 != 0));
      if(!(path == ((struct _GtkTreePath *)NULL)))
      {
        if(!(ipath == 0))
        {
          signed int return_value_gtk_tree_model_get_iter$5;
          return_value_gtk_tree_model_get_iter$5=gtk_tree_model_get_iter(model, &iter, path);
          if(!(return_value_gtk_tree_model_get_iter$5 == 0))
          {
            gtk_tree_store_remove(store, &iter);
            nRemoved = nRemoved + 1;
          }

        }

        gtk_tree_path_free(path);
      }

      list = list->next;
    }
    g_list_foreach(list, (void (*)(void *, void *))gtk_tree_path_free, (void *)0);
    g_list_free(list);
  }

}

// lingot_gui_config_dialog_scale_tree_view_column_get_index
// file lingot-gui-config-dialog-scale.c line 569
signed int lingot_gui_config_dialog_scale_tree_view_column_get_index(struct _GtkTreeViewColumn *column)
{
  struct _GtkTreeView *tree;
  unsigned long int return_value_gtk_tree_view_get_type$1;
  return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)column->tree_view, return_value_gtk_tree_view_get_type$1);
  tree = (struct _GtkTreeView *)return_value_g_type_check_instance_cast$2;
  struct _GList *cols;
  cols=gtk_tree_view_get_columns(tree);
  signed int counter = 0;
  while(!(cols == ((struct _GList *)NULL)))
  {
    unsigned long int return_value_gtk_tree_view_column_get_type$3;
    return_value_gtk_tree_view_column_get_type$3=gtk_tree_view_column_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)cols->data, return_value_gtk_tree_view_column_get_type$3);
    if(column == (struct _GtkTreeViewColumn *)return_value_g_type_check_instance_cast$4)
    {
      g_list_free(cols);
      return counter;
    }

    cols = cols->next;
    counter = counter + 1;
  }
  g_list_free(cols);
  return -1;
}

// lingot_gui_config_dialog_scale_validate
// file lingot-gui-config-dialog-scale.h line 36
signed int lingot_gui_config_dialog_scale_validate(struct _LingotConfigDialog *dialog, struct _LingotScale *scale)
{
  struct _GtkTreeIter iter;
  struct _GtkTreeIter iter2;
  struct _GtkTreeModel *model;
  model=gtk_tree_view_get_model(dialog->scale_treeview);
  char *name;
  char *name2;
  char *shift_char;
  double shift;
  double last_shift;
  signed int empty_names = 0;
  gtk_tree_model_get_iter_first(model, &iter);
  last_shift = -1.0;
  signed int row1 = 0;
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$7;
  signed int return_value_gtk_tree_model_iter_next$5;
  signed int return_value_gtk_tree_model_iter_next$1;
  do
  {
    gtk_tree_model_get(model, &iter, 0, &name, 1, &shift_char, -1);
    lingot_config_scale_parse_shift(shift_char, &shift, (signed short int *)(void *)0, (signed short int *)(void *)0);
    free((void *)shift_char);
    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(name, "");
    if(return_value_strcmp$2 == 0)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_strcmp$3=strcmp(name, "?");
      tmp_if_expr$4 = !(return_value_strcmp$3 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      empty_names = 1;

    gtk_tree_model_get_iter_first(model, &iter2);
    signed int row2 = 0;
    do
    {
      gtk_tree_model_get(model, &iter2, 0, &name2, -1);
      if(!(row1 == row2))
      {
        return_value_strcmp$7=strcmp(name, name2);
        if(return_value_strcmp$7 == 0)
        {
          char *return_value_gettext$6;
          return_value_gettext$6=gettext("There are notes with the same name");
          lingot_msg_add_error((const char *)return_value_gettext$6);
          free((void *)name);
          free((void *)name2);
          return 0;
        }

      }

      free((void *)name2);
      row2 = row2 + 1;
      return_value_gtk_tree_model_iter_next$5=gtk_tree_model_iter_next(model, &iter2);
    }
    while(!(return_value_gtk_tree_model_iter_next$5 == 0));
    free((void *)name);
    if(shift < last_shift)
    {
      char *return_value_gettext$8;
      return_value_gettext$8=gettext("There are invalid values in the scale: the notes should be ordered by frequency / shift");
      lingot_msg_add_error((const char *)return_value_gettext$8);
      return 0;
    }

    if(shift >= 1200.0)
    {
      char *return_value_gettext$9;
      return_value_gettext$9=gettext("There are invalid values in the scale: all the notes should be in the same octave");
      lingot_msg_add_error((const char *)return_value_gettext$9);
      return 0;
    }

    last_shift = shift;
    row1 = row1 + 1;
    return_value_gtk_tree_model_iter_next$1=gtk_tree_model_iter_next(model, &iter);
  }
  while(!(return_value_gtk_tree_model_iter_next$1 == 0));
  if(!(empty_names == 0))
  {
    char *return_value_gettext$10;
    return_value_gettext$10=gettext("There are notes without name");
    lingot_msg_add_warning((const char *)return_value_gettext$10);
    return 0;
  }

  return 1;
}

// lingot_gui_config_dialog_set_audio_system
// file lingot-gui-config-dialog.c line 170
void lingot_gui_config_dialog_set_audio_system(struct _GtkComboBox *combo, enum audio_system_t audio_system)
{
  const char *token;
  token=audio_system_t_to_str(audio_system);
  struct _GtkTreeModel *model;
  model=gtk_combo_box_get_model(combo);
  struct _GtkTreeIter iter;
  signed int valid;
  valid=gtk_tree_model_get_iter_first(model, &iter);
  while(!(valid == 0))
  {
    char *str_data;
    gtk_tree_model_get(model, &iter, 0, &str_data, -1);
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(str_data, token);
    if(return_value_strcmp$1 == 0)
      gtk_combo_box_set_active_iter(combo, &iter);

    g_free((void *)str_data);
    valid=gtk_tree_model_iter_next(model, &iter);
  }
}

// lingot_gui_config_dialog_show
// file lingot-gui-config-dialog.c line 323
void lingot_gui_config_dialog_show(struct _LingotMainFrame *frame, struct _LingotConfig *config)
{
  struct _GladeXML *_gladeXML = (struct _GladeXML *)(void *)0;
  struct _LingotConfig *tmp_if_expr$2;
  if(frame->config_dialog == ((struct _LingotConfigDialog *)NULL))
  {
    struct _LingotConfigDialog *dialog;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct _LingotConfigDialog) /*216ul*/ );
    dialog = (struct _LingotConfigDialog *)return_value_malloc$1;
    dialog->mainframe = frame;
    dialog->conf=lingot_config_new();
    dialog->conf_old=lingot_config_new();
    if(config == ((struct _LingotConfig *)NULL))
      tmp_if_expr$2 = frame->conf;

    else
      tmp_if_expr$2 = config;
    lingot_config_copy(dialog->conf, tmp_if_expr$2);
    lingot_config_copy(dialog->conf_old, frame->conf);
    struct _IO_FILE *fd;
    fd=fopen("src/glade/lingot-config-dialog.glade", "r");
    if(!(fd == ((struct _IO_FILE *)NULL)))
    {
      fclose(fd);
      _gladeXML=glade_xml_new("src/glade/lingot-config-dialog.glade", "dialog1", (const char *)(void *)0);
    }

    else
      _gladeXML=glade_xml_new("/usr/share/lingot/glade/lingot-config-dialog.glade", "dialog1", (const char *)(void *)0);
    dialog->win=glade_xml_get_widget(_gladeXML, "dialog1");
    unsigned long int return_value_gtk_window_get_type$3;
    return_value_gtk_window_get_type$3=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)dialog->win, return_value_gtk_window_get_type$3);
    unsigned long int return_value_gtk_window_get_type$5;
    return_value_gtk_window_get_type$5=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)frame->win, return_value_gtk_window_get_type$5);
    struct _GdkPixbuf *return_value_gtk_window_get_icon$7;
    return_value_gtk_window_get_icon$7=gtk_window_get_icon((struct _GtkWindow *)return_value_g_type_check_instance_cast$6);
    gtk_window_set_icon((struct _GtkWindow *)return_value_g_type_check_instance_cast$4, return_value_gtk_window_get_icon$7);
    dialog->mainframe->config_dialog = dialog;
    struct _GtkWidget *return_value_glade_xml_get_widget$8;
    return_value_glade_xml_get_widget$8=glade_xml_get_widget(_gladeXML, "input_system");
    unsigned long int return_value_gtk_combo_box_get_type$9;
    return_value_gtk_combo_box_get_type$9=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$8, return_value_gtk_combo_box_get_type$9);
    dialog->input_system = (struct _GtkComboBox *)return_value_g_type_check_instance_cast$10;
    struct _GtkWidget *return_value_glade_xml_get_widget$11;
    return_value_glade_xml_get_widget$11=glade_xml_get_widget(_gladeXML, "input_dev");
    unsigned long int return_value_gtk_combo_box_entry_get_type$12;
    return_value_gtk_combo_box_entry_get_type$12=gtk_combo_box_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$11, return_value_gtk_combo_box_entry_get_type$12);
    dialog->input_dev = (struct _GtkComboBoxEntry *)return_value_g_type_check_instance_cast$13;
    struct _GtkWidget *return_value_glade_xml_get_widget$14;
    return_value_glade_xml_get_widget$14=glade_xml_get_widget(_gladeXML, "sample_rate");
    unsigned long int return_value_gtk_combo_box_entry_get_type$15;
    return_value_gtk_combo_box_entry_get_type$15=gtk_combo_box_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$14, return_value_gtk_combo_box_entry_get_type$15);
    dialog->sample_rate = (struct _GtkComboBoxEntry *)return_value_g_type_check_instance_cast$16;
    struct _GtkWidget *return_value_glade_xml_get_widget$17;
    return_value_glade_xml_get_widget$17=glade_xml_get_widget(_gladeXML, "calculation_rate");
    unsigned long int return_value_gtk_hscale_get_type$18;
    return_value_gtk_hscale_get_type$18=gtk_hscale_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
    return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$17, return_value_gtk_hscale_get_type$18);
    dialog->calculation_rate = (struct _GtkHScale *)return_value_g_type_check_instance_cast$19;
    struct _GtkWidget *return_value_glade_xml_get_widget$20;
    return_value_glade_xml_get_widget$20=glade_xml_get_widget(_gladeXML, "visualization_rate");
    unsigned long int return_value_gtk_hscale_get_type$21;
    return_value_gtk_hscale_get_type$21=gtk_hscale_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
    return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$20, return_value_gtk_hscale_get_type$21);
    dialog->visualization_rate = (struct _GtkHScale *)return_value_g_type_check_instance_cast$22;
    struct _GtkWidget *return_value_glade_xml_get_widget$23;
    return_value_glade_xml_get_widget$23=glade_xml_get_widget(_gladeXML, "noise_threshold");
    unsigned long int return_value_gtk_hscale_get_type$24;
    return_value_gtk_hscale_get_type$24=gtk_hscale_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
    return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$23, return_value_gtk_hscale_get_type$24);
    dialog->noise_threshold = (struct _GtkHScale *)return_value_g_type_check_instance_cast$25;
    struct _GtkWidget *return_value_glade_xml_get_widget$26;
    return_value_glade_xml_get_widget$26=glade_xml_get_widget(_gladeXML, "gain");
    unsigned long int return_value_gtk_hscale_get_type$27;
    return_value_gtk_hscale_get_type$27=gtk_hscale_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
    return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$26, return_value_gtk_hscale_get_type$27);
    dialog->gain = (struct _GtkHScale *)return_value_g_type_check_instance_cast$28;
    struct _GtkWidget *return_value_glade_xml_get_widget$29;
    return_value_glade_xml_get_widget$29=glade_xml_get_widget(_gladeXML, "oversampling");
    unsigned long int return_value_gtk_spin_button_get_type$30;
    return_value_gtk_spin_button_get_type$30=gtk_spin_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$31;
    return_value_g_type_check_instance_cast$31=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$29, return_value_gtk_spin_button_get_type$30);
    dialog->oversampling = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$31;
    struct _GtkWidget *return_value_glade_xml_get_widget$32;
    return_value_glade_xml_get_widget$32=glade_xml_get_widget(_gladeXML, "fft_size");
    unsigned long int return_value_gtk_combo_box_get_type$33;
    return_value_gtk_combo_box_get_type$33=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
    return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$32, return_value_gtk_combo_box_get_type$33);
    dialog->fft_size = (struct _GtkComboBox *)return_value_g_type_check_instance_cast$34;
    struct _GtkWidget *return_value_glade_xml_get_widget$35;
    return_value_glade_xml_get_widget$35=glade_xml_get_widget(_gladeXML, "temporal_window");
    unsigned long int return_value_gtk_spin_button_get_type$36;
    return_value_gtk_spin_button_get_type$36=gtk_spin_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$37;
    return_value_g_type_check_instance_cast$37=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$35, return_value_gtk_spin_button_get_type$36);
    dialog->temporal_window = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$37;
    struct _GtkWidget *return_value_glade_xml_get_widget$38;
    return_value_glade_xml_get_widget$38=glade_xml_get_widget(_gladeXML, "root_frequency_error");
    unsigned long int return_value_gtk_spin_button_get_type$39;
    return_value_gtk_spin_button_get_type$39=gtk_spin_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$40;
    return_value_g_type_check_instance_cast$40=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$38, return_value_gtk_spin_button_get_type$39);
    dialog->root_frequency_error = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$40;
    struct _GtkWidget *return_value_glade_xml_get_widget$41;
    return_value_glade_xml_get_widget$41=glade_xml_get_widget(_gladeXML, "dft_number");
    unsigned long int return_value_gtk_spin_button_get_type$42;
    return_value_gtk_spin_button_get_type$42=gtk_spin_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$43;
    return_value_g_type_check_instance_cast$43=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$41, return_value_gtk_spin_button_get_type$42);
    dialog->dft_number = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$43;
    struct _GtkWidget *return_value_glade_xml_get_widget$44;
    return_value_glade_xml_get_widget$44=glade_xml_get_widget(_gladeXML, "dft_size");
    unsigned long int return_value_gtk_spin_button_get_type$45;
    return_value_gtk_spin_button_get_type$45=gtk_spin_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$46;
    return_value_g_type_check_instance_cast$46=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$44, return_value_gtk_spin_button_get_type$45);
    dialog->dft_size = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$46;
    struct _GtkWidget *return_value_glade_xml_get_widget$47;
    return_value_glade_xml_get_widget$47=glade_xml_get_widget(_gladeXML, "peak_number");
    unsigned long int return_value_gtk_spin_button_get_type$48;
    return_value_gtk_spin_button_get_type$48=gtk_spin_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$49;
    return_value_g_type_check_instance_cast$49=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$47, return_value_gtk_spin_button_get_type$48);
    dialog->peak_number = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$49;
    struct _GtkWidget *return_value_glade_xml_get_widget$50;
    return_value_glade_xml_get_widget$50=glade_xml_get_widget(_gladeXML, "peak_halfwidth");
    unsigned long int return_value_gtk_spin_button_get_type$51;
    return_value_gtk_spin_button_get_type$51=gtk_spin_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$52;
    return_value_g_type_check_instance_cast$52=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$50, return_value_gtk_spin_button_get_type$51);
    dialog->peak_halfwidth = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$52;
    struct _GtkWidget *return_value_glade_xml_get_widget$53;
    return_value_glade_xml_get_widget$53=glade_xml_get_widget(_gladeXML, "rejection_peak_relation");
    unsigned long int return_value_gtk_hscale_get_type$54;
    return_value_gtk_hscale_get_type$54=gtk_hscale_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$55;
    return_value_g_type_check_instance_cast$55=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$53, return_value_gtk_hscale_get_type$54);
    dialog->rejection_peak_relation = (struct _GtkHScale *)return_value_g_type_check_instance_cast$55;
    struct _GtkWidget *return_value_glade_xml_get_widget$56;
    return_value_glade_xml_get_widget$56=glade_xml_get_widget(_gladeXML, "label_sample_rate1");
    unsigned long int return_value_gtk_label_get_type$57;
    return_value_gtk_label_get_type$57=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$58;
    return_value_g_type_check_instance_cast$58=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$56, return_value_gtk_label_get_type$57);
    dialog->label_sample_rate1 = (struct _GtkLabel *)return_value_g_type_check_instance_cast$58;
    struct _GtkWidget *return_value_glade_xml_get_widget$59;
    return_value_glade_xml_get_widget$59=glade_xml_get_widget(_gladeXML, "label_sample_rate2");
    unsigned long int return_value_gtk_label_get_type$60;
    return_value_gtk_label_get_type$60=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$61;
    return_value_g_type_check_instance_cast$61=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$59, return_value_gtk_label_get_type$60);
    dialog->label_sample_rate2 = (struct _GtkLabel *)return_value_g_type_check_instance_cast$61;
    struct _GtkWidget *return_value_glade_xml_get_widget$62;
    return_value_glade_xml_get_widget$62=glade_xml_get_widget(_gladeXML, "minimum_frequency");
    unsigned long int return_value_gtk_spin_button_get_type$63;
    return_value_gtk_spin_button_get_type$63=gtk_spin_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$64;
    return_value_g_type_check_instance_cast$64=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$62, return_value_gtk_spin_button_get_type$63);
    dialog->minimum_frequency = (struct _GtkSpinButton *)return_value_g_type_check_instance_cast$64;
    lingot_gui_config_dialog_scale_show(dialog, _gladeXML);
    unsigned long int return_value_gtk_object_get_type$65;
    return_value_gtk_object_get_type$65=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$66;
    return_value_g_type_check_instance_cast$66=g_type_check_instance_cast((struct _GTypeInstance *)dialog->input_system, return_value_gtk_object_get_type$65);
    gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$66, "changed", (void (*)(void))lingot_gui_config_dialog_callback_change_input_system, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)dialog, (void (*)(void *))(void *)0, 0, 0);
    unsigned long int return_value_gtk_bin_get_type$67;
    return_value_gtk_bin_get_type$67=gtk_bin_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$68;
    return_value_g_type_check_instance_cast$68=g_type_check_instance_cast((struct _GTypeInstance *)dialog->sample_rate, return_value_gtk_bin_get_type$67);
    unsigned long int return_value_gtk_object_get_type$69;
    return_value_gtk_object_get_type$69=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$70;
    return_value_g_type_check_instance_cast$70=g_type_check_instance_cast((struct _GTypeInstance *)((struct _GtkBin *)return_value_g_type_check_instance_cast$68)->child, return_value_gtk_object_get_type$69);
    gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$70, "changed", (void (*)(void))lingot_gui_config_dialog_callback_change_sample_rate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)dialog, (void (*)(void *))(void *)0, 0, 0);
    unsigned long int return_value_gtk_object_get_type$71;
    return_value_gtk_object_get_type$71=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$72;
    return_value_g_type_check_instance_cast$72=g_type_check_instance_cast((struct _GTypeInstance *)dialog->oversampling, return_value_gtk_object_get_type$71);
    gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$72, "value_changed", (void (*)(void))lingot_gui_config_dialog_callback_change_sample_rate, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)dialog, (void (*)(void *))(void *)0, 0, 0);
    unsigned long int return_value_gtk_object_get_type$73;
    return_value_gtk_object_get_type$73=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$74;
    return_value_g_type_check_instance_cast$74=g_type_check_instance_cast((struct _GTypeInstance *)dialog->root_frequency_error, return_value_gtk_object_get_type$73);
    gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$74, "value_changed", (void (*)(void))lingot_gui_config_dialog_callback_change_deviation, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)dialog, (void (*)(void *))(void *)0, 0, 0);
    struct _GtkWidget *return_value_glade_xml_get_widget$75;
    return_value_glade_xml_get_widget$75=glade_xml_get_widget(_gladeXML, "button_default");
    unsigned long int return_value_gtk_object_get_type$76;
    return_value_gtk_object_get_type$76=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$77;
    return_value_g_type_check_instance_cast$77=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$75, return_value_gtk_object_get_type$76);
    g_signal_connect_data((void *)(struct _GtkObject *)return_value_g_type_check_instance_cast$77, "clicked", (void (*)(void))lingot_gui_config_dialog_callback_button_default, (void *)dialog, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$17)0);
    struct _GtkWidget *return_value_glade_xml_get_widget$78;
    return_value_glade_xml_get_widget$78=glade_xml_get_widget(_gladeXML, "button_apply");
    unsigned long int return_value_gtk_object_get_type$79;
    return_value_gtk_object_get_type$79=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$80;
    return_value_g_type_check_instance_cast$80=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$78, return_value_gtk_object_get_type$79);
    g_signal_connect_data((void *)(struct _GtkObject *)return_value_g_type_check_instance_cast$80, "clicked", (void (*)(void))lingot_gui_config_dialog_callback_button_apply, (void *)dialog, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$17)0);
    struct _GtkWidget *return_value_glade_xml_get_widget$81;
    return_value_glade_xml_get_widget$81=glade_xml_get_widget(_gladeXML, "button_accept");
    unsigned long int return_value_gtk_object_get_type$82;
    return_value_gtk_object_get_type$82=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$83;
    return_value_g_type_check_instance_cast$83=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$81, return_value_gtk_object_get_type$82);
    g_signal_connect_data((void *)(struct _GtkObject *)return_value_g_type_check_instance_cast$83, "clicked", (void (*)(void))lingot_gui_config_dialog_callback_button_ok, (void *)dialog, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$17)0);
    struct _GtkWidget *return_value_glade_xml_get_widget$84;
    return_value_glade_xml_get_widget$84=glade_xml_get_widget(_gladeXML, "button_cancel");
    unsigned long int return_value_gtk_object_get_type$85;
    return_value_gtk_object_get_type$85=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$86;
    return_value_g_type_check_instance_cast$86=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$84, return_value_gtk_object_get_type$85);
    g_signal_connect_data((void *)(struct _GtkObject *)return_value_g_type_check_instance_cast$86, "clicked", (void (*)(void))lingot_gui_config_dialog_callback_button_cancel, (void *)dialog, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$17)0);
    unsigned long int return_value_gtk_object_get_type$87;
    return_value_gtk_object_get_type$87=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$88;
    return_value_g_type_check_instance_cast$88=g_type_check_instance_cast((struct _GTypeInstance *)dialog->win, return_value_gtk_object_get_type$87);
    g_signal_connect_data((void *)(struct _GtkObject *)return_value_g_type_check_instance_cast$88, "destroy", (void (*)(void))lingot_gui_config_dialog_callback_close, (void *)dialog, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$17)0);
    lingot_gui_config_dialog_rewrite(dialog);
    gtk_widget_show(dialog->win);
    struct _GtkWidget *scroll;
    scroll=glade_xml_get_widget(_gladeXML, "scrolledwindow1");
    gtk_widget_show_all(scroll);
    g_object_unref((void *)_gladeXML);
  }

  else
  {
    if(!(config == ((struct _LingotConfig *)NULL)))
    {
      lingot_config_copy(frame->config_dialog->conf, config);
      lingot_gui_config_dialog_rewrite(frame->config_dialog);
    }

    unsigned long int return_value_gtk_window_get_type$89;
    return_value_gtk_window_get_type$89=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$90;
    return_value_g_type_check_instance_cast$90=g_type_check_instance_cast((struct _GTypeInstance *)frame->config_dialog->win, return_value_gtk_window_get_type$89);
    gtk_window_present((struct _GtkWindow *)return_value_g_type_check_instance_cast$90);
  }
  if(!(config == ((struct _LingotConfig *)NULL)))
    lingot_config_destroy(config);

}

// lingot_gui_mainframe_callback_about
// file lingot-gui-mainframe.c line 86
void lingot_gui_mainframe_callback_about(struct _GtkWidget *w, struct _LingotMainFrame *frame)
{
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Accurate and easy to use musical instrument tuner");
  char *return_value_gettext$2;
  return_value_gettext$2=gettext("translator-credits");
  static const char *artists[2l] = { "Matthew Blissett (Logo design)", (const char *)(void *)0 };
  static const char *authors[3l] = { "Ibán Cereijo Graña <ibancg@gmail.com>", 
    "Jairo Chapela Martínez <jairochapela@gmail.com>", 
    (const char *)(void *)0 };
  gtk_show_about_dialog((struct _GtkWindow *)(void *)0, "name", (const void *)"Lingot", (const void *)"version", (const void *)"0.9.1", (const void *)"copyright", (const void *)"© 2004-2011 Ibán Cereijo Graña\n© 2004-2011 Jairo Chapela Martínez", (const void *)"comments", (const char *)return_value_gettext$1, (const void *)"authors", (const void *)authors, (const void *)"artists", (const void *)artists, (const void *)"website-label", (const void *)"http://lingot.nongnu.org/", (const void *)"website", (const void *)"http://lingot.nongnu.org/", (const void *)"translator-credits", (const char *)return_value_gettext$2, (const void *)"logo-icon-name", (const void *)"lingot-logo", (void *)0);
}

// lingot_gui_mainframe_callback_config_dialog
// file lingot-gui-mainframe.c line 115
void lingot_gui_mainframe_callback_config_dialog(struct _GtkWidget *w, struct _LingotMainFrame *frame)
{
  lingot_gui_config_dialog_show(frame, (struct _LingotConfig *)(void *)0);
}

// lingot_gui_mainframe_callback_destroy
// file lingot-gui-mainframe.c line 79
void lingot_gui_mainframe_callback_destroy(struct _GtkWidget *w, struct _LingotMainFrame *frame)
{
  g_source_remove(frame->visualization_timer_uid);
  g_source_remove(frame->freq_computation_timer_uid);
  g_source_remove(frame->gauge_computation_uid);
  gtk_main_quit();
}

// lingot_gui_mainframe_callback_error_dispatcher
// file lingot-gui-mainframe.c line 223
signed int lingot_gui_mainframe_callback_error_dispatcher(void *data)
{
  unsigned int period;
  struct _GtkWidget *message_dialog;
  struct _LingotMainFrame *frame = (struct _LingotMainFrame *)data;
  char *error_message = (char *)(void *)0;
  enum message_type_t lingot_gui_mainframe_callback_error_dispatcher$$1$$message_type;
  signed int more_messages;
  struct _GtkWidget *tmp_if_expr$1;
  const char *tmp_if_expr$10;
  char *return_value_gettext$6;
  const char *tmp_if_expr$9;
  char *return_value_gettext$7;
  char *return_value_gettext$8;
  do
  {
    more_messages=lingot_msg_get(&error_message, &lingot_gui_mainframe_callback_error_dispatcher$$1$$message_type);
    if(!(more_messages == 0))
    {
      if(!(frame->config_dialog == ((struct _LingotConfigDialog *)NULL)))
        tmp_if_expr$1 = frame->config_dialog->win;

      else
        tmp_if_expr$1 = frame->win;
      unsigned long int return_value_gtk_window_get_type$2;
      return_value_gtk_window_get_type$2=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
      return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)tmp_if_expr$1, return_value_gtk_window_get_type$2);
      message_dialog=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$3, (enum anonymous$22)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$23)((signed int)lingot_gui_mainframe_callback_error_dispatcher$$1$$message_type == ERROR ? GTK_MESSAGE_ERROR : ((signed int)lingot_gui_mainframe_callback_error_dispatcher$$1$$message_type == WARNING ? GTK_MESSAGE_WARNING : GTK_MESSAGE_INFO)), (enum anonymous$21)GTK_BUTTONS_CLOSE, "%s", error_message);
      unsigned long int return_value_gtk_window_get_type$4;
      return_value_gtk_window_get_type$4=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)message_dialog, return_value_gtk_window_get_type$4);
      if((signed int)lingot_gui_mainframe_callback_error_dispatcher$$1$$message_type == ERROR)
      {
        return_value_gettext$6=gettext("Error");
        tmp_if_expr$10 = (const char *)return_value_gettext$6;
      }

      else
      {
        if((signed int)lingot_gui_mainframe_callback_error_dispatcher$$1$$message_type == WARNING)
        {
          return_value_gettext$7=gettext("Warning");
          tmp_if_expr$9 = (const char *)return_value_gettext$7;
        }

        else
        {
          return_value_gettext$8=gettext("Info");
          tmp_if_expr$9 = (const char *)return_value_gettext$8;
        }
        tmp_if_expr$10 = tmp_if_expr$9;
      }
      gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, tmp_if_expr$10);
      unsigned long int return_value_gtk_window_get_type$11;
      return_value_gtk_window_get_type$11=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
      return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)message_dialog, return_value_gtk_window_get_type$11);
      unsigned long int return_value_gtk_window_get_type$13;
      return_value_gtk_window_get_type$13=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
      return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)frame->win, return_value_gtk_window_get_type$13);
      struct _GdkPixbuf *return_value_gtk_window_get_icon$15;
      return_value_gtk_window_get_icon$15=gtk_window_get_icon((struct _GtkWindow *)return_value_g_type_check_instance_cast$14);
      gtk_window_set_icon((struct _GtkWindow *)return_value_g_type_check_instance_cast$12, return_value_gtk_window_get_icon$15);
      unsigned long int return_value_gtk_dialog_get_type$16;
      return_value_gtk_dialog_get_type$16=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
      return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)message_dialog, return_value_gtk_dialog_get_type$16);
      gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$17);
      gtk_widget_destroy(message_dialog);
      free((void *)error_message);
    }

  }
  while(!(more_messages == 0));
  period = (unsigned int)((double)1000 / 5.0);
  frame->error_dispatcher_uid=g_timeout_add(period, lingot_gui_mainframe_callback_error_dispatcher, (void *)frame);
  return 0;
}

// lingot_gui_mainframe_callback_gauge_computation
// file lingot-gui-mainframe.c line 200
signed int lingot_gui_mainframe_callback_gauge_computation(void *data)
{
  unsigned int period;
  double error_cents;
  struct _LingotMainFrame *frame = (struct _LingotMainFrame *)data;
  period = (unsigned int)((double)1000 / 60.0);
  frame->gauge_computation_uid=g_timeout_add(period, lingot_gui_mainframe_callback_gauge_computation, (void *)frame);
  _Bool tmp_if_expr$2;
  signed int return_value___isnan$1;
  if(frame->core->running == 0)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value___isnan$1=__isnan(frame->core->freq);
    tmp_if_expr$2 = return_value___isnan$1 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = frame->core->freq < 10.0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
    lingot_gauge_compute(frame->gauge, frame->conf->gauge_rest_value);

  else
  {
    lingot_gui_mainframe_get_closest_note_index(frame->core->freq, frame->conf->scale, frame->conf->root_frequency_error, &error_cents);
    lingot_gauge_compute(frame->gauge, error_cents);
  }
  return 0;
}

// lingot_gui_mainframe_callback_open_config
// file lingot-gui-mainframe.c line 263
void lingot_gui_mainframe_callback_open_config(void *data, struct _LingotMainFrame *frame)
{
  struct _GtkWidget *dialog;
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Open Configuration File");
  unsigned long int return_value_gtk_window_get_type$2;
  return_value_gtk_window_get_type$2=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)frame->win, return_value_gtk_window_get_type$2);
  dialog=gtk_file_chooser_dialog_new((const char *)return_value_gettext$1, (struct _GtkWindow *)return_value_g_type_check_instance_cast$3, (enum anonymous$7)GTK_FILE_CHOOSER_ACTION_OPEN, "gtk-cancel", -6, (const void *)"gtk-open", -3, (void *)0);
  struct _GtkFileFilter *filefilter;
  struct _LingotConfig *config = (struct _LingotConfig *)(void *)0;
  filefilter=gtk_file_filter_new();
  char *return_value_gettext$4;
  return_value_gettext$4=gettext("Lingot configuration files");
  gtk_file_filter_set_name(filefilter, (const char *)return_value_gettext$4);
  gtk_file_filter_add_pattern(filefilter, "*.conf");
  unsigned long int return_value_gtk_file_chooser_get_type$5;
  return_value_gtk_file_chooser_get_type$5=gtk_file_chooser_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$5);
  gtk_file_chooser_add_filter((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$6, filefilter);
  unsigned long int return_value_gtk_file_chooser_get_type$7;
  return_value_gtk_file_chooser_get_type$7=gtk_file_chooser_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$7);
  gtk_file_chooser_set_show_hidden((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$8, (signed int)!(0 != 0));
  if(!(filechooser_config_last_folder == ((char *)NULL)))
  {
    unsigned long int return_value_gtk_file_chooser_get_type$9;
    return_value_gtk_file_chooser_get_type$9=gtk_file_chooser_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$9);
    gtk_file_chooser_set_current_folder((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$10, filechooser_config_last_folder);
  }

  unsigned long int return_value_gtk_dialog_get_type$16;
  return_value_gtk_dialog_get_type$16=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$16);
  signed int return_value_gtk_dialog_run$18;
  return_value_gtk_dialog_run$18=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$17);
  if(return_value_gtk_dialog_run$18 == -3)
  {
    char *filename;
    unsigned long int return_value_gtk_file_chooser_get_type$11;
    return_value_gtk_file_chooser_get_type$11=gtk_file_chooser_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$11);
    filename=gtk_file_chooser_get_filename((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$12);
    if(!(filechooser_config_last_folder == ((char *)NULL)))
      free((void *)filechooser_config_last_folder);

    unsigned long int return_value_gtk_file_chooser_get_type$13;
    return_value_gtk_file_chooser_get_type$13=gtk_file_chooser_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
    return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$13);
    char *return_value_gtk_file_chooser_get_current_folder$15;
    return_value_gtk_file_chooser_get_current_folder$15=gtk_file_chooser_get_current_folder((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$14);
    filechooser_config_last_folder=strdup(return_value_gtk_file_chooser_get_current_folder$15);
    config=lingot_config_new();
    lingot_config_load(config, filename);
    g_free((void *)filename);
  }

  gtk_widget_destroy(dialog);
  if(!(config == ((struct _LingotConfig *)NULL)))
    lingot_gui_config_dialog_show(frame, config);

}

// lingot_gui_mainframe_callback_redraw
// file lingot-gui-mainframe.c line 74
void lingot_gui_mainframe_callback_redraw(struct _GtkWidget *w, struct _GdkEventExpose *e, struct _LingotMainFrame *frame)
{
  lingot_gui_mainframe_redraw(frame);
}

// lingot_gui_mainframe_callback_save_config
// file lingot-gui-mainframe.c line 303
void lingot_gui_mainframe_callback_save_config(void *data, struct _LingotMainFrame *frame)
{
  struct _GtkWidget *dialog;
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Save Configuration File");
  unsigned long int return_value_gtk_window_get_type$2;
  return_value_gtk_window_get_type$2=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)frame->win, return_value_gtk_window_get_type$2);
  dialog=gtk_file_chooser_dialog_new((const char *)return_value_gettext$1, (struct _GtkWindow *)return_value_g_type_check_instance_cast$3, (enum anonymous$7)GTK_FILE_CHOOSER_ACTION_SAVE, "gtk-cancel", -6, (const void *)"gtk-save", -3, (void *)0);
  unsigned long int return_value_gtk_file_chooser_get_type$4;
  return_value_gtk_file_chooser_get_type$4=gtk_file_chooser_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$4);
  gtk_file_chooser_set_do_overwrite_confirmation((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$5, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_file_chooser_get_type$6;
  return_value_gtk_file_chooser_get_type$6=gtk_file_chooser_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$6);
  gtk_file_chooser_set_current_name((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$7, "untitled.conf");
  struct _GtkFileFilter *filefilter;
  filefilter=gtk_file_filter_new();
  char *return_value_gettext$8;
  return_value_gettext$8=gettext("Lingot configuration files");
  gtk_file_filter_set_name(filefilter, (const char *)return_value_gettext$8);
  gtk_file_filter_add_pattern(filefilter, "*.conf");
  unsigned long int return_value_gtk_file_chooser_get_type$9;
  return_value_gtk_file_chooser_get_type$9=gtk_file_chooser_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$9);
  gtk_file_chooser_add_filter((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$10, filefilter);
  unsigned long int return_value_gtk_file_chooser_get_type$11;
  return_value_gtk_file_chooser_get_type$11=gtk_file_chooser_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$11);
  gtk_file_chooser_set_show_hidden((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$12, (signed int)!(0 != 0));
  if(!(filechooser_config_last_folder == ((char *)NULL)))
  {
    unsigned long int return_value_gtk_file_chooser_get_type$13;
    return_value_gtk_file_chooser_get_type$13=gtk_file_chooser_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
    return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$13);
    gtk_file_chooser_set_current_folder((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$14, filechooser_config_last_folder);
  }

  unsigned long int return_value_gtk_dialog_get_type$20;
  return_value_gtk_dialog_get_type$20=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
  return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$20);
  signed int return_value_gtk_dialog_run$22;
  return_value_gtk_dialog_run$22=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$21);
  if(return_value_gtk_dialog_run$22 == -3)
  {
    char *filename;
    unsigned long int return_value_gtk_file_chooser_get_type$15;
    return_value_gtk_file_chooser_get_type$15=gtk_file_chooser_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$15);
    filename=gtk_file_chooser_get_filename((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$16);
    if(!(filechooser_config_last_folder == ((char *)NULL)))
      free((void *)filechooser_config_last_folder);

    unsigned long int return_value_gtk_file_chooser_get_type$17;
    return_value_gtk_file_chooser_get_type$17=gtk_file_chooser_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_file_chooser_get_type$17);
    char *return_value_gtk_file_chooser_get_current_folder$19;
    return_value_gtk_file_chooser_get_current_folder$19=gtk_file_chooser_get_current_folder((struct _GtkFileChooser *)return_value_g_type_check_instance_cast$18);
    filechooser_config_last_folder=strdup(return_value_gtk_file_chooser_get_current_folder$19);
    lingot_config_save(frame->conf, filename);
    g_free((void *)filename);
  }

  gtk_widget_destroy(dialog);
}

// lingot_gui_mainframe_callback_tout_spectrum_computation_display
// file lingot-gui-mainframe.c line 182
signed int lingot_gui_mainframe_callback_tout_spectrum_computation_display(void *data)
{
  unsigned int period;
  struct _LingotMainFrame *frame = (struct _LingotMainFrame *)data;
  period = (unsigned int)((double)1000 / frame->conf->calculation_rate);
  frame->freq_computation_timer_uid=g_timeout_add(period, lingot_gui_mainframe_callback_tout_spectrum_computation_display, (void *)frame);
  lingot_gui_mainframe_draw_spectrum_and_labels(frame);
  return 0;
}

// lingot_gui_mainframe_callback_tout_visualization
// file lingot-gui-mainframe.c line 167
signed int lingot_gui_mainframe_callback_tout_visualization(void *data)
{
  unsigned int period;
  struct _LingotMainFrame *frame = (struct _LingotMainFrame *)data;
  period = (unsigned int)((double)1000 / frame->conf->visualization_rate);
  frame->visualization_timer_uid=g_timeout_add(period, lingot_gui_mainframe_callback_tout_visualization, (void *)frame);
  lingot_gui_mainframe_draw_gauge(frame);
  return 0;
}

// lingot_gui_mainframe_callback_view_spectrum
// file lingot-gui-mainframe.c line 108
void lingot_gui_mainframe_callback_view_spectrum(struct _GtkWidget *w, struct _LingotMainFrame *frame)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)frame->view_spectrum_item, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  gtk_widget_set_visible(frame->spectrum_frame, return_value_gtk_check_menu_item_get_active$3);
}

// lingot_gui_mainframe_change_config
// file lingot-gui-mainframe.h line 79
void lingot_gui_mainframe_change_config(struct _LingotMainFrame *frame, struct _LingotConfig *conf)
{
  lingot_core_stop(frame->core);
  lingot_core_destroy(frame->core);
  lingot_config_copy(frame->conf, conf);
  g_object_unref((void *)frame->pix_spectrum);
  signed int x;
  unsigned int tmp_if_expr$1;
  if(frame->conf->fft_size >= 257u)
    tmp_if_expr$1 = frame->conf->fft_size >> 1;

  else
    tmp_if_expr$1 = (unsigned int)256;
  x = (signed int)(tmp_if_expr$1 + (unsigned int)(2 * spectrum_x_margin));
  signed int y = spectrum_size_y + spectrum_top_margin + spectrum_bottom_margin;
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)frame->spectrum_area, return_value_gtk_widget_get_type$2);
  gtk_widget_set_size_request((struct _GtkWidget *)return_value_g_type_check_instance_cast$3, x, y);
  frame->pix_spectrum=gdk_pixmap_new(frame->spectrum_area->window, x, y, -1);
  gtk_scrolled_window_set_policy(frame->spectrum_scroll, (enum anonymous$31)(frame->conf->fft_size > (unsigned int)512 ? GTK_POLICY_ALWAYS : GTK_POLICY_NEVER), (enum anonymous$31)GTK_POLICY_NEVER);
  unsigned long int return_value_gtk_widget_get_type$4;
  return_value_gtk_widget_get_type$4=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)frame->spectrum_scroll, return_value_gtk_widget_get_type$4);
  gtk_widget_set_size_request((struct _GtkWidget *)return_value_g_type_check_instance_cast$5, 260 + 2 * spectrum_x_margin, spectrum_size_y + spectrum_bottom_margin + spectrum_top_margin + 4 + (frame->conf->fft_size > (unsigned int)512 ? 16 : 0));
  frame->core=lingot_core_new(frame->conf);
  lingot_core_start(frame->core);
  lingot_config_copy(conf, frame->conf);
}

// lingot_gui_mainframe_color
// file lingot-gui-mainframe.c line 340
void lingot_gui_mainframe_color(struct _GdkColor *color, signed int red, signed int green, signed int blue)
{
  color->red = (unsigned short int)red;
  color->green = (unsigned short int)green;
  color->blue = (unsigned short int)blue;
}

// lingot_gui_mainframe_create
// file lingot-gui-mainframe.c line 346
void lingot_gui_mainframe_create(signed int argc, char **argv)
{
  struct _LingotMainFrame *frame;
  struct _LingotConfig *conf;
  struct _GladeXML *_gladeXML = (struct _GladeXML *)(void *)0;
  if(filechooser_config_last_folder == ((char *)NULL))
  {
    char buff[1000l];
    char *return_value_getenv$1;
    return_value_getenv$1=getenv("HOME");
    sprintf(buff, "%s/%s", return_value_getenv$1, (const void *)".lingot/");
    filechooser_config_last_folder=strdup(buff);
  }

  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct _LingotMainFrame) /*168ul*/ );
  frame = (struct _LingotMainFrame *)return_value_malloc$2;
  frame->config_dialog = (struct _LingotConfigDialog *)(void *)0;
  frame->pix_stick = (struct _GdkDrawable *)(void *)0;
  frame->conf=lingot_config_new();
  conf = frame->conf;
  lingot_config_load(conf, CONFIG_FILE_NAME);
  frame->gauge=lingot_gauge_new(conf->gauge_rest_value);
  double freq_filter_a[2l] = { 1.0, -0.5 };
  double freq_filter_b[1l] = { 0.5 };
  frame->freq_filter=lingot_filter_new((unsigned int)1, (unsigned int)0, freq_filter_a, freq_filter_b);
  gtk_init(&argc, &argv);
  gtk_set_locale();
  struct _IO_FILE *fd;
  fd=fopen("src/glade/lingot-mainframe.glade", "r");
  if(!(fd == ((struct _IO_FILE *)NULL)))
  {
    fclose(fd);
    _gladeXML=glade_xml_new("src/glade/lingot-mainframe.glade", "window1", (const char *)(void *)0);
  }

  else
    _gladeXML=glade_xml_new("/usr/share/lingot/glade/lingot-mainframe.glade", "window1", (const char *)(void *)0);
  frame->win=glade_xml_get_widget(_gladeXML, "window1");
  struct _GdkPixbuf *logo;
  logo=gdk_pixbuf_new_from_xpm_data(lingotlogo);
  gtk_icon_theme_add_builtin_icon("lingot-logo", 64, logo);
  unsigned long int return_value_gtk_window_get_type$3;
  return_value_gtk_window_get_type$3=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)frame->win, return_value_gtk_window_get_type$3);
  gtk_window_set_icon((struct _GtkWindow *)return_value_g_type_check_instance_cast$4, logo);
  frame->gauge_area=glade_xml_get_widget(_gladeXML, "gauge_area");
  frame->spectrum_area=glade_xml_get_widget(_gladeXML, "spectrum_area");
  frame->freq_label=glade_xml_get_widget(_gladeXML, "freq_label");
  frame->tone_label=glade_xml_get_widget(_gladeXML, "tone_label");
  frame->error_label=glade_xml_get_widget(_gladeXML, "error_label");
  frame->spectrum_frame=glade_xml_get_widget(_gladeXML, "spectrum_frame");
  struct _GtkWidget *return_value_glade_xml_get_widget$5;
  return_value_glade_xml_get_widget$5=glade_xml_get_widget(_gladeXML, "scrolledwindow1");
  unsigned long int return_value_gtk_scrolled_window_get_type$6;
  return_value_gtk_scrolled_window_get_type$6=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$5, return_value_gtk_scrolled_window_get_type$6);
  frame->spectrum_scroll = (struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$7;
  frame->view_spectrum_item=glade_xml_get_widget(_gladeXML, "spectrum_item");
  unsigned long int return_value_gtk_check_menu_item_get_type$8;
  return_value_gtk_check_menu_item_get_type$8=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)frame->view_spectrum_item, return_value_gtk_check_menu_item_get_type$8);
  gtk_check_menu_item_set_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$9, (signed int)!(0 != 0));
  gtk_widget_show_all(frame->win);
  signed int x;
  unsigned int tmp_if_expr$10;
  if(conf->fft_size >= 257u)
    tmp_if_expr$10 = conf->fft_size >> 1;

  else
    tmp_if_expr$10 = (unsigned int)256;
  x = (signed int)(tmp_if_expr$10 + (unsigned int)(2 * spectrum_x_margin));
  signed int y = spectrum_size_y + spectrum_bottom_margin + spectrum_top_margin;
  gdk_pixmap_new(frame->gauge_area->window, gauge_size_x, gauge_size_y, -1);
  frame->pix_spectrum=gdk_pixmap_new(frame->spectrum_area->window, x, y, -1);
  struct _GtkWidget *return_value_glade_xml_get_widget$11;
  return_value_glade_xml_get_widget$11=glade_xml_get_widget(_gladeXML, "preferences_item");
  unsigned long int return_value_gtk_object_get_type$12;
  return_value_gtk_object_get_type$12=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$11, return_value_gtk_object_get_type$12);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$13, "activate", (void (*)(void))lingot_gui_mainframe_callback_config_dialog, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)frame, (void (*)(void *))(void *)0, 0, 0);
  struct _GtkWidget *return_value_glade_xml_get_widget$14;
  return_value_glade_xml_get_widget$14=glade_xml_get_widget(_gladeXML, "quit_item");
  unsigned long int return_value_gtk_object_get_type$15;
  return_value_gtk_object_get_type$15=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$14, return_value_gtk_object_get_type$15);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$16, "activate", (void (*)(void))lingot_gui_mainframe_callback_destroy, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)frame, (void (*)(void *))(void *)0, 0, 0);
  struct _GtkWidget *return_value_glade_xml_get_widget$17;
  return_value_glade_xml_get_widget$17=glade_xml_get_widget(_gladeXML, "about_item");
  unsigned long int return_value_gtk_object_get_type$18;
  return_value_gtk_object_get_type$18=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
  return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$17, return_value_gtk_object_get_type$18);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$19, "activate", (void (*)(void))lingot_gui_mainframe_callback_about, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)frame, (void (*)(void *))(void *)0, 0, 0);
  struct _GtkWidget *return_value_glade_xml_get_widget$20;
  return_value_glade_xml_get_widget$20=glade_xml_get_widget(_gladeXML, "spectrum_item");
  unsigned long int return_value_gtk_object_get_type$21;
  return_value_gtk_object_get_type$21=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$20, return_value_gtk_object_get_type$21);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$22, "activate", (void (*)(void))lingot_gui_mainframe_callback_view_spectrum, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)frame, (void (*)(void *))(void *)0, 0, 0);
  struct _GtkWidget *return_value_glade_xml_get_widget$23;
  return_value_glade_xml_get_widget$23=glade_xml_get_widget(_gladeXML, "open_config_item");
  unsigned long int return_value_gtk_object_get_type$24;
  return_value_gtk_object_get_type$24=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
  return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$23, return_value_gtk_object_get_type$24);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$25, "activate", (void (*)(void))lingot_gui_mainframe_callback_open_config, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)frame, (void (*)(void *))(void *)0, 0, 0);
  struct _GtkWidget *return_value_glade_xml_get_widget$26;
  return_value_glade_xml_get_widget$26=glade_xml_get_widget(_gladeXML, "save_config_item");
  unsigned long int return_value_gtk_object_get_type$27;
  return_value_gtk_object_get_type$27=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
  return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)return_value_glade_xml_get_widget$26, return_value_gtk_object_get_type$27);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$28, "activate", (void (*)(void))lingot_gui_mainframe_callback_save_config, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)frame, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$29;
  return_value_gtk_object_get_type$29=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)frame->gauge_area, return_value_gtk_object_get_type$29);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$30, "expose_event", (void (*)(void))lingot_gui_mainframe_callback_redraw, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)frame, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$31;
  return_value_gtk_object_get_type$31=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
  return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)frame->spectrum_area, return_value_gtk_object_get_type$31);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$32, "expose_event", (void (*)(void))lingot_gui_mainframe_callback_redraw, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)frame, (void (*)(void *))(void *)0, 0, 0);
  unsigned long int return_value_gtk_object_get_type$33;
  return_value_gtk_object_get_type$33=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
  return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)frame->win, return_value_gtk_object_get_type$33);
  gtk_signal_connect_full((struct _GtkObject *)return_value_g_type_check_instance_cast$34, "destroy", (void (*)(void))lingot_gui_mainframe_callback_destroy, (void (*)(struct _GtkObject *, void *, unsigned int, struct _GtkArg *))(void *)0, (void *)frame, (void (*)(void *))(void *)0, 0, 0);
  struct _GtkAccelGroup *accel_group;
  accel_group=gtk_accel_group_new();
  struct _GtkWidget *return_value_glade_xml_get_widget$35;
  return_value_glade_xml_get_widget$35=glade_xml_get_widget(_gladeXML, "preferences_item");
  gtk_widget_add_accelerator(return_value_glade_xml_get_widget$35, "activate", accel_group, (unsigned int)112, (enum anonymous$24)GDK_CONTROL_MASK, (enum anonymous$1)GTK_ACCEL_VISIBLE);
  unsigned long int return_value_gtk_window_get_type$36;
  return_value_gtk_window_get_type$36=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$37;
  return_value_g_type_check_instance_cast$37=g_type_check_instance_cast((struct _GTypeInstance *)frame->win, return_value_gtk_window_get_type$36);
  gtk_window_add_accel_group((struct _GtkWindow *)return_value_g_type_check_instance_cast$37, accel_group);
  unsigned int period = (unsigned int)((double)1000 / conf->visualization_rate);
  frame->visualization_timer_uid=g_timeout_add(period, lingot_gui_mainframe_callback_tout_visualization, (void *)frame);
  period = (unsigned int)((double)1000 / conf->calculation_rate);
  frame->freq_computation_timer_uid=g_timeout_add(period, lingot_gui_mainframe_callback_tout_spectrum_computation_display, (void *)frame);
  period = (unsigned int)((double)1000 / 60.0);
  frame->gauge_computation_uid=g_timeout_add(period, lingot_gui_mainframe_callback_gauge_computation, (void *)frame);
  period = (unsigned int)((double)1000 / 5.0);
  frame->error_dispatcher_uid=g_timeout_add(period, lingot_gui_mainframe_callback_error_dispatcher, (void *)frame);
  lingot_gui_mainframe_color(&gauge_color, 0xC000, 0x0000, 0x2000);
  lingot_gui_mainframe_color(&spectrum_background_color, 0x1111, 0x3333, 0x1111);
  lingot_gui_mainframe_color(&spectrum_color, 0x2222, 0xEEEE, 0x2222);
  lingot_gui_mainframe_color(&noise_threshold_color, 0x8888, 0x8888, 0x2222);
  lingot_gui_mainframe_color(&grid_color, 0x9000, 0x9000, 0x9000);
  lingot_gui_mainframe_color(&freq_color, 0xFFFF, 0x2222, 0x2222);
  lingot_gui_mainframe_color(&cents_color, 0x3000, 0x3000, 0x3000);
  struct _GdkColormap *return_value_gdk_colormap_get_system$38;
  return_value_gdk_colormap_get_system$38=gdk_colormap_get_system();
  gdk_color_alloc(return_value_gdk_colormap_get_system$38, &gauge_color);
  struct _GdkColormap *return_value_gdk_colormap_get_system$39;
  return_value_gdk_colormap_get_system$39=gdk_colormap_get_system();
  gdk_color_alloc(return_value_gdk_colormap_get_system$39, &spectrum_color);
  struct _GdkColormap *return_value_gdk_colormap_get_system$40;
  return_value_gdk_colormap_get_system$40=gdk_colormap_get_system();
  gdk_color_alloc(return_value_gdk_colormap_get_system$40, &spectrum_background_color);
  struct _GdkColormap *return_value_gdk_colormap_get_system$41;
  return_value_gdk_colormap_get_system$41=gdk_colormap_get_system();
  gdk_color_alloc(return_value_gdk_colormap_get_system$41, &noise_threshold_color);
  struct _GdkColormap *return_value_gdk_colormap_get_system$42;
  return_value_gdk_colormap_get_system$42=gdk_colormap_get_system();
  gdk_color_alloc(return_value_gdk_colormap_get_system$42, &grid_color);
  struct _GdkColormap *return_value_gdk_colormap_get_system$43;
  return_value_gdk_colormap_get_system$43=gdk_colormap_get_system();
  gdk_color_alloc(return_value_gdk_colormap_get_system$43, &freq_color);
  struct _GdkColormap *return_value_gdk_colormap_get_system$44;
  return_value_gdk_colormap_get_system$44=gdk_colormap_get_system();
  gdk_color_black(return_value_gdk_colormap_get_system$44, &black_color);
  struct _GdkColormap *return_value_gdk_colormap_get_system$45;
  return_value_gdk_colormap_get_system$45=gdk_colormap_get_system();
  gdk_color_alloc(return_value_gdk_colormap_get_system$45, &cents_color);
  spectrum_legend_font_desc=pango_font_description_from_string("Helvetica Plain 7");
  gauge_cents_font_desc=pango_font_description_from_string("Helvetica Plain 7");
  frame->core=lingot_core_new(conf);
  lingot_core_start(frame->core);
  g_object_unref((void *)_gladeXML);
  gtk_main();
}

// lingot_gui_mainframe_destroy
// file lingot-gui-mainframe.c line 504
void lingot_gui_mainframe_destroy(struct _LingotMainFrame *frame)
{
  lingot_core_stop(frame->core);
  lingot_core_destroy(frame->core);
  lingot_gauge_destroy(frame->gauge);
  lingot_filter_destroy(frame->freq_filter);
  lingot_config_destroy(frame->conf);
  if(!(frame->config_dialog == ((struct _LingotConfigDialog *)NULL)))
    lingot_gui_config_dialog_destroy(frame->config_dialog);

  free((void *)frame);
}

// lingot_gui_mainframe_draw_gauge
// file lingot-gui-mainframe.c line 527
void lingot_gui_mainframe_draw_gauge(struct _LingotMainFrame *frame)
{
  struct _GdkGC *gc = frame->gauge_area->style->fg_gc[(signed long int)frame->gauge_area->state];
  struct _GdkDrawable *w = frame->gauge_area->window;
  struct _GdkGCValues gv;
  gdk_gc_get_values(gc, &gv);
  double max = 1.0;
  if(frame->pix_stick == ((struct _GdkDrawable *)NULL))
    frame->pix_stick=gdk_pixmap_create_from_xpm_d(w, (struct _GdkDrawable **)(void *)0, (const struct _GdkColor *)(void *)0, background2_xpm);

  gdk_draw_drawable(w, gc, frame->pix_stick, 0, 0, 0, 0, 160, 100);
  gdk_gc_set_foreground(gc, &gauge_color);
  double normalized_error = frame->gauge->position / frame->conf->scale->max_offset_rounded;
  double angle = (normalized_error * 3.14159265358979323846) / (1.5 * max);
  double return_value_sin$1;
  return_value_sin$1=sin(angle);
  double return_value_rint$2;
  static double gauge_size = 90.0;
  return_value_rint$2=rint(gauge_size * return_value_sin$1);
  double return_value_cos$3;
  return_value_cos$3=cos(angle);
  double return_value_rint$4;
  return_value_rint$4=rint(gauge_size * return_value_cos$3);
  gdk_draw_line(w, gc, gauge_size_x >> 1, gauge_size_y - 1, (gauge_size_x >> 1) + (signed int)return_value_rint$2, (gauge_size_y - 1) - (signed int)return_value_rint$4);
  gdk_gc_set_foreground(gc, &cents_color);
  char buff[10l];
  sprintf(buff, frame->conf->scale->max_offset_rounded > 1.0 ? "-%.0f c" : "-%.1f c", 0.5 * frame->conf->scale->max_offset_rounded);
  struct _PangoLayout *layout1;
  layout1=gtk_widget_create_pango_layout(frame->gauge_area, buff);
  sprintf(buff, frame->conf->scale->max_offset_rounded > 1.0 ? "+%.0f c" : "+%.1f c", 0.5 * frame->conf->scale->max_offset_rounded);
  struct _PangoLayout *layout2;
  layout2=gtk_widget_create_pango_layout(frame->gauge_area, buff);
  pango_layout_set_font_description(layout1, gauge_cents_font_desc);
  gdk_draw_layout(w, gc, (signed int)(0.05 * (double)gauge_size_x), (signed int)(0.8 * (double)gauge_size_y), layout1);
  pango_layout_set_font_description(layout2, gauge_cents_font_desc);
  gdk_draw_layout(w, gc, (signed int)(0.75 * (double)gauge_size_x), (signed int)(0.8 * (double)gauge_size_y), layout2);
  g_object_unref((void *)layout1);
  g_object_unref((void *)layout2);
  gdk_flush();
}

// lingot_gui_mainframe_draw_spectrum_and_labels
// file lingot-gui-mainframe.c line 574
void lingot_gui_mainframe_draw_spectrum_and_labels(struct _LingotMainFrame *frame)
{
  char *current_tone;
  struct _GtkWidget *widget = (struct _GtkWidget *)(void *)0;
  struct _PangoLayout *layout;
  signed int spectrum_size_x;
  unsigned int tmp_if_expr$1;
  if(frame->conf->fft_size >= 257u)
    tmp_if_expr$1 = frame->conf->fft_size >> 1;

  else
    tmp_if_expr$1 = (unsigned int)256;
  spectrum_size_x = (signed int)tmp_if_expr$1;
  unsigned int i;
  signed int j;
  signed int old_j;
  unsigned short int note_index;
  struct _GdkGC *gc = frame->spectrum_area->style->fg_gc[(signed long int)frame->spectrum_area->state];
  struct _GdkDrawable *pixmap = frame->pix_spectrum;
  struct _GdkGCValues gv;
  gdk_gc_get_values(gc, &gv);
  gdk_gc_set_foreground(gc, &spectrum_background_color);
  gdk_draw_rectangle(pixmap, gc, (signed int)!(0 != 0), 0, 0, spectrum_size_x + 2 * spectrum_x_margin, spectrum_size_y + spectrum_bottom_margin + spectrum_top_margin);
  gdk_gc_set_foreground(gc, &grid_color);
  gdk_draw_line(pixmap, gc, spectrum_x_margin, spectrum_size_y + spectrum_top_margin, spectrum_x_margin + spectrum_size_x, spectrum_size_y + spectrum_top_margin);
  i = (unsigned int)0;
  static signed int minimum_grid_width = 50;
  static double scales[11l] = { 0.01, 0.05, 0.1, 0.2, 0.5, (double)1, (double)2, (double)4, (double)11, (double)22, -1.0 };
  for( ; scales[(signed long int)i] > 0.0; i = i + 1u)
    if((1e3 * scales[(signed long int)i] * (double)frame->conf->fft_size * (double)frame->conf->oversampling) / (double)frame->conf->sample_rate > (double)minimum_grid_width)
      break;

  if(scales[(signed long int)i] < 0.0)
    i = i - 1u;

  double scale = scales[(signed long int)i];
  signed int grid_width = (signed int)((1e3 * scales[(signed long int)i] * (double)frame->conf->fft_size * (double)frame->conf->oversampling) / (double)frame->conf->sample_rate);
  char buff[10l];
  double freq = 0.0;
  i = (unsigned int)0;
  double return_value_floor$3;
  double return_value_floor$2;
  for( ; (unsigned int)spectrum_size_x >= i; i = i + (unsigned int)grid_width)
  {
    gdk_draw_line(pixmap, gc, (signed int)((unsigned int)spectrum_x_margin + i), spectrum_top_margin, (signed int)((unsigned int)spectrum_x_margin + i), spectrum_size_y + spectrum_top_margin + 3);
    if(IEEE_FLOAT_EQUAL(freq, 0.0))
      sprintf(buff, "0 Hz");

    else
    {
      return_value_floor$3=floor(freq);
      if(IEEE_FLOAT_EQUAL(return_value_floor$3, freq))
        sprintf(buff, "%0.0f kHz", freq);

      else
      {
        return_value_floor$2=floor((double)10 * freq);
        if(IEEE_FLOAT_EQUAL(return_value_floor$2, 10.000000 * freq))
        {
          if(freq <= 1000.0)
            sprintf(buff, "%0.0f Hz", 1e3 * freq);

          else
            sprintf(buff, "%0.1f kHz", freq);
        }

        else
          if(freq <= 100.0)
            sprintf(buff, "%0.0f Hz", 1e3 * freq);

          else
            sprintf(buff, "%0.2f kHz", freq);
      }
    }
    layout=gtk_widget_create_pango_layout(frame->spectrum_area, buff);
    pango_layout_set_font_description(layout, spectrum_legend_font_desc);
    gdk_draw_layout(pixmap, gc, (signed int)((unsigned int)(spectrum_x_margin - 8) + i), spectrum_size_y + spectrum_top_margin + 5, layout);
    g_object_unref((void *)layout);
    freq = freq + scale;
  }
  sprintf(buff, "dB");
  layout=gtk_widget_create_pango_layout(frame->spectrum_area, buff);
  pango_layout_set_font_description(layout, spectrum_legend_font_desc);
  gdk_draw_layout(pixmap, gc, spectrum_x_margin - 6, 2, layout);
  g_object_unref((void *)layout);
  signed int grid_height;
  double return_value_pow$4;
  static double grid_db_height = (double)25;
  return_value_pow$4=pow(10.0, grid_db_height / 10.0);
  double return_value_log10$5;
  return_value_log10$5=log10(return_value_pow$4);
  grid_height = (signed int)((double)8 * return_value_log10$5);
  j = 0;
  i = (unsigned int)0;
  for( ; (unsigned int)spectrum_size_y >= i; i = i + (unsigned int)grid_height)
  {
    if(j == 0)
      sprintf(buff, " %i", j);

    else
      sprintf(buff, "%i", j);
    layout=gtk_widget_create_pango_layout(frame->spectrum_area, buff);
    pango_layout_set_font_description(layout, spectrum_legend_font_desc);
    gdk_draw_layout(pixmap, gc, 2, (signed int)(((unsigned int)(spectrum_size_y + spectrum_top_margin) - i) - (unsigned int)5), layout);
    g_object_unref((void *)layout);
    gdk_draw_line(pixmap, gc, spectrum_x_margin, (signed int)((unsigned int)(spectrum_size_y + spectrum_top_margin) - i), spectrum_x_margin + spectrum_size_x, (signed int)((unsigned int)(spectrum_size_y + spectrum_top_margin) - i));
    j = j + (signed int)grid_db_height;
  }
  gdk_gc_set_foreground(gc, &noise_threshold_color);
  j = -1;
  i = (unsigned int)0;
  signed int tmp_if_expr$7;
  double return_value_log10$6;
  for( ; !(i >= frame->conf->fft_size) && !(i >= (unsigned int)spectrum_size_x); i = i + 1u)
    if(!(i % 10u >= 6u))
    {
      double noise = frame->conf->noise_threshold_nu;
      old_j = j;
      if(noise > 1.0)
      {
        return_value_log10$6=log10(noise);
        tmp_if_expr$7 = (signed int)((double)8 * return_value_log10$6);
      }

      else
        tmp_if_expr$7 = 0;
      j = tmp_if_expr$7;
      if(j >= 0 && old_j >= 0 && !(j >= spectrum_size_y) && !(old_j >= spectrum_size_y))
        gdk_draw_line(pixmap, gc, (signed int)(((unsigned int)spectrum_x_margin + i) - (unsigned int)1), (spectrum_size_y + spectrum_top_margin) - old_j, (signed int)((unsigned int)spectrum_x_margin + i), (spectrum_size_y + spectrum_top_margin) - j);

    }

  gdk_gc_set_foreground(gc, &spectrum_color);
  signed int tmp_if_expr$10;
  double return_value_log10$9;
  signed int tmp_if_expr$13;
  double return_value_log10$12;
  if(!(frame->core->running == 0))
  {
    j = -1;
    struct _GtkAdjustment *adj;
    adj=gtk_scrolled_window_get_hadjustment(frame->spectrum_scroll);
    signed int min;
    double return_value_gtk_adjustment_get_value$8;
    return_value_gtk_adjustment_get_value$8=gtk_adjustment_get_value(adj);
    min = (signed int)(return_value_gtk_adjustment_get_value$8 - (double)spectrum_x_margin);
    signed int max = min + 256 + 3 * spectrum_x_margin;
    if(!(min >= 0))
      min = 0;

    if(max >= spectrum_size_x)
      max = spectrum_size_x;

    if(!(frame->core->running == 0))
    {
      i = (unsigned int)min;
      for( ; !(i >= (unsigned int)max); i = i + 1u)
      {
        if(frame->core->X[(signed long int)i] > 1.0)
        {
          return_value_log10$9=log10(frame->core->X[(signed long int)i]);
          tmp_if_expr$10 = (signed int)((double)8 * return_value_log10$9);
        }

        else
          tmp_if_expr$10 = 0;
        j = tmp_if_expr$10;
        if(j >= spectrum_size_y)
          j = spectrum_size_y - 1;

        static signed int spectrum_drawing_filled = (signed int)!(0 != 0);
        if(!(spectrum_drawing_filled == 0))
          gdk_draw_line(pixmap, gc, (signed int)((unsigned int)spectrum_x_margin + i), (spectrum_size_y + spectrum_top_margin) - 1, (signed int)((unsigned int)spectrum_x_margin + i), (spectrum_top_margin + spectrum_size_y) - j);

        else
        {
          if(j >= 0 && old_j >= 0 && !(j >= spectrum_size_y) && !(old_j >= spectrum_size_y))
            gdk_draw_line(pixmap, gc, (signed int)(((unsigned int)spectrum_x_margin + i) - (unsigned int)1), (spectrum_size_y + spectrum_top_margin) - old_j, (signed int)((unsigned int)spectrum_x_margin + i), (spectrum_size_y + spectrum_top_margin) - j);

          old_j = j;
        }
      }
      if(IEEE_FLOAT_NOTEQUAL(frame->core->freq, 0.0))
      {
        gdk_gc_set_foreground(gc, &freq_color);
        double return_value_rint$11;
        return_value_rint$11=rint((frame->core->freq * (double)frame->conf->fft_size * (double)frame->conf->oversampling) / (double)frame->conf->sample_rate);
        i = (unsigned int)(signed int)return_value_rint$11;
        if(!(i >= frame->conf->fft_size + 4294967295u))
        {
          if(!(i >= 4294967295u + (unsigned int)spectrum_size_x))
          {
            if(frame->core->X[(signed long int)i] > 1.0)
            {
              return_value_log10$12=log10(frame->core->X[(signed long int)i]);
              tmp_if_expr$13 = (signed int)((double)8 * return_value_log10$12);
            }

            else
              tmp_if_expr$13 = 0;
            j = tmp_if_expr$13;
            if(!(j >= spectrum_size_y + -1))
              gdk_draw_rectangle(pixmap, gc, (signed int)!(0 != 0), (signed int)(((unsigned int)spectrum_x_margin + i) - (unsigned int)1), ((spectrum_size_y + spectrum_top_margin) - j) - 1, 3, 3);

          }

        }

      }

    }

  }

  gdk_gc_set_foreground(gc, &black_color);
  widget = frame->spectrum_area;
  unsigned long int return_value_gtk_widget_get_type$14;
  return_value_gtk_widget_get_type$14=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_widget_get_type$14);
  gdk_draw_drawable(widget->window, widget->style->fg_gc[(signed long int)((struct _GtkWidget *)return_value_g_type_check_instance_cast$15)->state], pixmap, 0, 0, 0, 0, spectrum_size_x + 2 * spectrum_x_margin, spectrum_size_y + spectrum_bottom_margin + spectrum_top_margin);
  _Bool tmp_if_expr$18;
  signed int return_value___isnan$17;
  if(frame->core->running == 0)
    tmp_if_expr$18 = (_Bool)1;

  else
  {
    return_value___isnan$17=__isnan(frame->core->freq);
    tmp_if_expr$18 = return_value___isnan$17 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$19;
  if(tmp_if_expr$18)
    tmp_if_expr$19 = (_Bool)1;

  else
    tmp_if_expr$19 = frame->core->freq < 10.0 ? (_Bool)1 : (_Bool)0;
  static char freq_string[30l];
  static char error_string[30l];
  if(tmp_if_expr$19)
  {
    current_tone = "---";
    strcpy(error_string, "e = ---");
    strcpy(freq_string, "f = ---");
  }

  else
  {
    double error_cents;
    note_index=lingot_gui_mainframe_get_closest_note_index(frame->core->freq, frame->conf->scale, frame->conf->root_frequency_error, &error_cents);
    if(note_index == frame->conf->scale->notes)
      note_index = (unsigned short int)0;

    current_tone = frame->conf->scale->note_name[(signed long int)note_index];
    sprintf(error_string, "e = %+2.0f cents", frame->gauge->position);
    double return_value_lingot_filter_filter_sample$16;
    return_value_lingot_filter_filter_sample$16=lingot_filter_filter_sample(frame->freq_filter, frame->core->freq);
    sprintf(freq_string, "f = %6.2f Hz", return_value_lingot_filter_filter_sample$16);
  }
  unsigned long int return_value_gtk_label_get_type$20;
  return_value_gtk_label_get_type$20=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
  return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)frame->freq_label, return_value_gtk_label_get_type$20);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$21, freq_string);
  unsigned long int return_value_gtk_label_get_type$22;
  return_value_gtk_label_get_type$22=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
  return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)frame->error_label, return_value_gtk_label_get_type$22);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$23, error_string);
  char *markup;
  markup=g_markup_printf_escaped("<span size=\"xx-large\" weight=\"bold\">%s</span>", current_tone);
  unsigned long int return_value_gtk_label_get_type$24;
  return_value_gtk_label_get_type$24=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
  return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)frame->tone_label, return_value_gtk_label_get_type$24);
  gtk_label_set_markup((struct _GtkLabel *)return_value_g_type_check_instance_cast$25, markup);
  g_free((void *)markup);
}

// lingot_gui_mainframe_get_closest_note_index
// file lingot-gui-mainframe.c line 120
unsigned short int lingot_gui_mainframe_get_closest_note_index(double freq, struct _LingotScale *scale, double deviation, double *error_cents)
{
  unsigned short int note_index = (unsigned short int)0;
  unsigned short int index;
  double offset;
  double return_value_log2$1;
  return_value_log2$1=log2(freq / scale->base_frequency);
  offset = 1200.0 * return_value_log2$1 - deviation;
  offset=fmod(offset, 1200.0);
  if(offset < 0.0)
    offset = offset + 1200.0;

  double return_value_floor$2;
  return_value_floor$2=floor(((double)scale->notes * offset) / 1200.0);
  index = (unsigned short int)return_value_floor$2;
  double pitch_inf;
  double pitch_sup;
  signed int n = 0;
  double tmp_if_expr$3;
  do
  {
    n = n + 1;
    pitch_inf = scale->offset_cents[(signed long int)index];
    if(!(1 + (signed int)index >= (signed int)scale->notes))
      tmp_if_expr$3 = scale->offset_cents[(signed long int)((signed int)index + 1)];

    else
      tmp_if_expr$3 = 1200.0;
    pitch_sup = tmp_if_expr$3;
    if(offset > pitch_sup)
      index = index + 1;

    else
      if(offset < pitch_inf)
        index = index - 1;

      else
        break;
  }
  while((_Bool)1);
  double return_value_fabs$4;
  return_value_fabs$4=fabs(offset - pitch_inf);
  double return_value_fabs$5;
  return_value_fabs$5=fabs(offset - pitch_sup);
  if(return_value_fabs$4 < return_value_fabs$5)
  {
    note_index = index;
    *error_cents = offset - pitch_inf;
  }

  else
  {
    note_index = (unsigned short int)((signed int)index + 1);
    *error_cents = offset - pitch_sup;
  }
  return note_index;
}

// lingot_gui_mainframe_redraw
// file lingot-gui-mainframe.c line 520
void lingot_gui_mainframe_redraw(struct _LingotMainFrame *frame)
{
  lingot_gui_mainframe_draw_gauge(frame);
  lingot_gui_mainframe_draw_spectrum_and_labels(frame);
}

// lingot_map_parameters
// file lingot-config.c line 160
void lingot_map_parameters(struct _LingotConfig *config, void **params)
{
  void *c_params[20l] = { (void *)&config->audio_system, (void *)&config->audio_dev[(signed long int)AUDIO_SYSTEM_OSS], 
    (void *)&config->audio_dev[(signed long int)AUDIO_SYSTEM_ALSA], 
    (void *)&config->sample_rate, (void *)&config->oversampling, (void *)&config->root_frequency_error, (void *)&config->min_frequency, (void *)&config->fft_size, (void *)&config->temporal_window, (void *)&config->noise_threshold_db, (void *)&config->calculation_rate, (void *)&config->visualization_rate, (void *)&config->peak_number, (void *)&config->peak_half_width, (void *)&config->peak_rejection_relation_db, 
    (void *)&config->dft_number, (void *)&config->dft_size, (void *)&config->gain, (void *)0, (void *)&config->peak_half_width };
  memcpy((void *)params, (const void *)c_params, (unsigned long int)20 * sizeof(void *) /*8ul*/ );
}

// lingot_msg_add
// file lingot-msg.c line 50
void lingot_msg_add(const char *msg, enum message_type_t type)
{
  pthread_mutex_lock(&message_queue_mutex);
  if(front == (1 + rear) % 5)
    perror("The messages array is full!\n");

  else
  {
    signed int duplicated = 0;
    signed int i = front;
    while(!(i == rear))
    {
      i = (i + 1) % 5;
      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(message[(signed long int)i], msg);
      if(return_value_strcmp$1 == 0)
      {
        duplicated = 1;
        printf("duplicated message: %s\n", msg);
        break;
      }

    }
    if(duplicated == 0)
    {
      rear = (rear + 1) % 5;
      strcpy(message[(signed long int)rear], msg);
      message_type[(signed long int)rear] = type;
    }

  }
  pthread_mutex_unlock(&message_queue_mutex);
}

// lingot_msg_add_error
// file lingot-msg.h line 35
void lingot_msg_add_error(const char *msg)
{
  lingot_msg_add(msg, (enum message_type_t)ERROR);
}

// lingot_msg_add_info
// file lingot-msg.c line 46
void lingot_msg_add_info(const char *msg)
{
  lingot_msg_add(msg, (enum message_type_t)INFO);
}

// lingot_msg_add_warning
// file lingot-msg.h line 36
void lingot_msg_add_warning(const char *msg)
{
  lingot_msg_add(msg, (enum message_type_t)WARNING);
}

// lingot_msg_get
// file lingot-msg.c line 77
signed int lingot_msg_get(char **msg, enum message_type_t *type)
{
  signed int result = 0;
  *msg = (char *)(void *)0;
  pthread_mutex_lock(&message_queue_mutex);
  if(!(front == rear))
  {
    front = (front + 1) % 5;
    *msg=strdup(message[(signed long int)front]);
    *type = message_type[(signed long int)front];
    result = 1;
  }

  pthread_mutex_unlock(&message_queue_mutex);
  return result;
}

// lingot_signal_get_fundamental_peak
// file lingot-signal.h line 43
signed int lingot_signal_get_fundamental_peak(struct _LingotConfig *conf, double *x, double *d2x, signed int N)
{
  unsigned int i;
  unsigned int j;
  unsigned int m;
  const signed long int m$array_size0 = (signed long int)conf->peak_number;
  signed int p_index[m$array_size0];
  i = (unsigned int)0;
  for( ; !(i >= conf->peak_number); i = i + 1u)
    p_index[(signed long int)i] = -1;
  unsigned int lowest_index;
  double return_value_ceil$1;
  return_value_ceil$1=ceil(conf->min_frequency * ((1.0 * (double)conf->oversampling) / (double)conf->sample_rate) * (double)conf->fft_size);
  lowest_index = (unsigned int)return_value_ceil$1;
  if(!(lowest_index >= conf->peak_half_width))
    lowest_index = conf->peak_half_width;

  i = lowest_index;
  signed int return_value_lingot_signal_is_peak$2;
  for( ; !(i >= (unsigned int)N + -conf->peak_half_width); i = i + 1u)
  {
    return_value_lingot_signal_is_peak$2=lingot_signal_is_peak(conf, x, (signed int)i);
    if(!(return_value_lingot_signal_is_peak$2 == 0))
    {
      m = (unsigned int)0;
      j = (unsigned int)0;
      for( ; !(j >= conf->peak_number); j = j + 1u)
      {
        if(p_index[(signed long int)j] == -1)
        {
          m = j;
          break;
        }

        if(d2x[(signed long int)p_index[(signed long int)j]] < d2x[(signed long int)p_index[(signed long int)m]])
          m = j;

      }
      if(p_index[(signed long int)m] == -1)
        p_index[(signed long int)m] = (signed int)i;

      else
        if(d2x[(signed long int)i] > d2x[(signed long int)p_index[(signed long int)m]])
          p_index[(signed long int)m] = (signed int)i;

    }

  }
  double maximum = 0.0;
  signed int maximum_index = -1;
  i = (unsigned int)0;
  for( ; !(i >= conf->peak_number); i = i + 1u)
    if(!(p_index[(signed long int)i] == -1))
    {
      if(x[(signed long int)p_index[(signed long int)i]] > maximum)
      {
        maximum = x[(signed long int)p_index[(signed long int)i]];
        maximum_index = p_index[(signed long int)i];
      }

    }

  _Bool tmp_if_expr$3;
  if(maximum_index == -1)
    return N;

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= conf->peak_number); i = i + 1u)
    {
      if(p_index[(signed long int)i] == -1)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = conf->peak_rejection_relation_nu * x[(signed long int)p_index[(signed long int)i]] < maximum ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        p_index[(signed long int)i] = N;

    }
    m = (unsigned int)0;
    j = (unsigned int)0;
    for( ; !(j >= conf->peak_number); j = j + 1u)
      if(!(p_index[(signed long int)j] >= p_index[(signed long int)m]))
        m = j;

    return p_index[(signed long int)m];
  }
}

// lingot_signal_get_max
// file lingot-signal.h line 40
void lingot_signal_get_max(double *x, signed int N, signed int *Mi)
{
  signed int i;
  double M = -1.0;
  *Mi = -1;
  i = 0;
  for( ; !(i >= N); i = i + 1)
    if(x[(signed long int)i] > M)
    {
      M = x[(signed long int)i];
      *Mi = i;
    }

}

// lingot_signal_get_noise_threshold
// file lingot-signal.c line 31
double lingot_signal_get_noise_threshold(struct _LingotConfig *conf, double w)
{
  double return_value_pow$1;
  return_value_pow$1=pow(10.0, (conf->noise_threshold_db * (1.0 - (0.9 * w) / 3.14159265358979323846)) / 10.0);
  return return_value_pow$1;
}

// lingot_signal_is_peak
// file lingot-signal.c line 58
signed int lingot_signal_is_peak(struct _LingotConfig *conf, double *x, signed int index)
{
  unsigned int j;
  if(x[(signed long int)index] < conf->noise_threshold_nu)
    return 0;

  else
  {
    j = (unsigned int)0;
    for( ; !(j >= conf->peak_half_width); j = j + 1u)
    {
      if(x[(signed long int)(j + (unsigned int)index)] < x[(signed long int)(1u + j + (unsigned int)index)])
        return 0;

      if(x[(signed long int)((unsigned int)index + -j)] < x[(signed long int)((unsigned int)index + -j + 4294967295u)])
        return 0;

    }
    return 1;
  }
}

// lingot_signal_window
// file lingot-signal.h line 46
void lingot_signal_window(signed int N, double *out, enum window_type_t window_type)
{
  signed int i;
  double return_value_cos$1;
  double return_value_cos$2;
  switch((signed int)window_type)
  {
    case RECTANGULAR:
    {
      i = 0;
      for( ; !(i >= N); i = i + 1)
        out[(signed long int)i] = 1.0;
      break;
    }
    case HANNING:
    {
      i = 0;
      for( ; !(i >= N); i = i + 1)
      {
        return_value_cos$1=cos((2.0 * 3.14159265358979323846 * (double)i) / (double)(N - 1));
        out[(signed long int)i] = 0.5 * ((double)1 - return_value_cos$1);
      }
      break;
    }
    case HAMMING:
    {
      i = 0;
      for( ; !(i >= N); i = i + 1)
      {
        return_value_cos$2=cos((2.0 * 3.14159265358979323846 * (double)i) / (double)(N - 1));
        out[(signed long int)i] = 0.53836 - 0.46164 * return_value_cos$2;
      }
    }
  }
}

// main
// file lingot.c line 76
signed int main(signed int argc, char **argv)
{
  bindtextdomain("lingot", "/usr/share/locale");
  bind_textdomain_codeset("lingot", "UTF-8");
  textdomain("lingot");
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("HOME");
  sprintf(CONFIG_FILE_NAME, "%s/.lingot/lingot.conf", return_value_getenv$1);
  char *return_value_getenv$2;
  if(argc == 2 || argc >= 4)
  {
    printf("\nusage: lingot [-c config]\n\n");
    return -1;
  }

  else
    if(argc >= 2)
    {
      signed int c;
      while((_Bool)1)
      {
        signed int option_index = 0;
        static struct option long_options[2l] = { { .name="config", .has_arg=1, .flag=((signed int *)NULL), .val=99 }, 
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
        c=getopt_long(argc, argv, "c:", long_options, &option_index);
        if(c == -1)
          break;

        switch(c)
        {
          case 99:
          {
            return_value_getenv$2=getenv("HOME");
            sprintf(CONFIG_FILE_NAME, "%s/%s%s.conf", return_value_getenv$2, (const void *)".lingot/", optarg);
            printf("using config file %s\n", (const void *)CONFIG_FILE_NAME);
            break;
          }
          case 63:
            break;
          default:
            printf("?? getopt returned character code 0%o ??\n", c);
        }
      }
    }

  struct _IO_FILE *fp;
  fp=fopen(CONFIG_FILE_NAME, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    char config_dir[100l];
    char *return_value_getenv$3;
    return_value_getenv$3=getenv("HOME");
    sprintf(config_dir, "%s/.lingot/", return_value_getenv$3);
    printf("creating directory %s ...\n", (const void *)config_dir);
    mkdir(config_dir, (unsigned int)0777);
    printf("creating file %s ...\n", (const void *)CONFIG_FILE_NAME);
    struct _LingotConfig *new_conf;
    new_conf=lingot_config_new();
    lingot_config_restore_default_values(new_conf);
    lingot_config_save(new_conf, CONFIG_FILE_NAME);
    lingot_config_destroy(new_conf);
    printf("ok\n");
  }

  else
    fclose(fp);
  lingot_gui_mainframe_create(argc, argv);
  return 0;
}

// str_to_audio_system_t
// file lingot-config.c line 58
enum audio_system_t str_to_audio_system_t(char *audio_system)
{
  enum audio_system_t result = (enum audio_system_t)-1;
  const char *values[4l] = { "OSS", "ALSA", "JACK", (const char *)(void *)0 };
  signed int i = 0;
  for( ; !(values[(signed long int)i] == ((const char *)NULL)); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(audio_system, values[(signed long int)i]);
    if(return_value_strcmp$1 == 0)
    {
      result = (enum audio_system_t)i;
      break;
    }

  }
  return result;
}

