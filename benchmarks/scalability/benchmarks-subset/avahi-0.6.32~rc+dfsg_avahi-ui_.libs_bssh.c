// #anon_enum$ATK_LAYER_INVALID=0$ATK_LAYER_BACKGROUND=1$ATK_LAYER_CANVAS=2$ATK_LAYER_WIDGET=3$ATK_LAYER_MDI=4$ATK_LAYER_POPUP=5$ATK_LAYER_OVERLAY=6$ATK_LAYER_WINDOW=7
// file /usr/include/atk-1.0/atk/atkobject.h line 376
enum anonymous$25 { ATK_LAYER_INVALID=0, ATK_LAYER_BACKGROUND=1, ATK_LAYER_CANVAS=2, ATK_LAYER_WIDGET=3, ATK_LAYER_MDI=4, ATK_LAYER_POPUP=5, ATK_LAYER_OVERLAY=6, ATK_LAYER_WINDOW=7 };

// #anon_enum$ATK_ROLE_INVALID=0$ATK_ROLE_ACCEL_LABEL=1$ATK_ROLE_ALERT=2$ATK_ROLE_ANIMATION=3$ATK_ROLE_ARROW=4$ATK_ROLE_CALENDAR=5$ATK_ROLE_CANVAS=6$ATK_ROLE_CHECK_BOX=7$ATK_ROLE_CHECK_MENU_ITEM=8$ATK_ROLE_COLOR_CHOOSER=9$ATK_ROLE_COLUMN_HEADER=10$ATK_ROLE_COMBO_BOX=11$ATK_ROLE_DATE_EDITOR=12$ATK_ROLE_DESKTOP_ICON=13$ATK_ROLE_DESKTOP_FRAME=14$ATK_ROLE_DIAL=15$ATK_ROLE_DIALOG=16$ATK_ROLE_DIRECTORY_PANE=17$ATK_ROLE_DRAWING_AREA=18$ATK_ROLE_FILE_CHOOSER=19$ATK_ROLE_FILLER=20$ATK_ROLE_FONT_CHOOSER=21$ATK_ROLE_FRAME=22$ATK_ROLE_GLASS_PANE=23$ATK_ROLE_HTML_CONTAINER=24$ATK_ROLE_ICON=25$ATK_ROLE_IMAGE=26$ATK_ROLE_INTERNAL_FRAME=27$ATK_ROLE_LABEL=28$ATK_ROLE_LAYERED_PANE=29$ATK_ROLE_LIST=30$ATK_ROLE_LIST_ITEM=31$ATK_ROLE_MENU=32$ATK_ROLE_MENU_BAR=33$ATK_ROLE_MENU_ITEM=34$ATK_ROLE_OPTION_PANE=35$ATK_ROLE_PAGE_TAB=36$ATK_ROLE_PAGE_TAB_LIST=37$ATK_ROLE_PANEL=38$ATK_ROLE_PASSWORD_TEXT=39$ATK_ROLE_POPUP_MENU=40$ATK_ROLE_PROGRESS_BAR=41$ATK_ROLE_PUSH_BUTTON=42$ATK_ROLE_RADIO_BUTTON=43$ATK_ROLE_RADIO_MENU_ITEM=44$ATK_ROLE_ROOT_PANE=45$ATK_ROLE_ROW_HEADER=46$ATK_ROLE_SCROLL_BAR=47$ATK_ROLE_SCROLL_PANE=48$ATK_ROLE_SEPARATOR=49$ATK_ROLE_SLIDER=50$ATK_ROLE_SPLIT_PANE=51$ATK_ROLE_SPIN_BUTTON=52$ATK_ROLE_STATUSBAR=53$ATK_ROLE_TABLE=54$ATK_ROLE_TABLE_CELL=55$ATK_ROLE_TABLE_COLUMN_HEADER=56$ATK_ROLE_TABLE_ROW_HEADER=57$ATK_ROLE_TEAR_OFF_MENU_ITEM=58$ATK_ROLE_TERMINAL=59$ATK_ROLE_TEXT=60$ATK_ROLE_TOGGLE_BUTTON=61$ATK_ROLE_TOOL_BAR=62$ATK_ROLE_TOOL_TIP=63$ATK_ROLE_TREE=64$ATK_ROLE_TREE_TABLE=65$ATK_ROLE_UNKNOWN=66$ATK_ROLE_VIEWPORT=67$ATK_ROLE_WINDOW=68$ATK_ROLE_HEADER=69$ATK_ROLE_FOOTER=70$ATK_ROLE_PARAGRAPH=71$ATK_ROLE_RULER=72$ATK_ROLE_APPLICATION=73$ATK_ROLE_AUTOCOMPLETE=74$ATK_ROLE_EDITBAR=75$ATK_ROLE_EMBEDDED=76$ATK_ROLE_ENTRY=77$ATK_ROLE_CHART=78$ATK_ROLE_CAPTION=79$ATK_ROLE_DOCUMENT_FRAME=80$ATK_ROLE_HEADING=81$ATK_ROLE_PAGE=82$ATK_ROLE_SECTION=83$ATK_ROLE_REDUNDANT_OBJECT=84$ATK_ROLE_FORM=85$ATK_ROLE_LINK=86$ATK_ROLE_INPUT_METHOD_WINDOW=87$ATK_ROLE_TABLE_ROW=88$ATK_ROLE_TREE_ITEM=89$ATK_ROLE_DOCUMENT_SPREADSHEET=90$ATK_ROLE_DOCUMENT_PRESENTATION=91$ATK_ROLE_DOCUMENT_TEXT=92$ATK_ROLE_DOCUMENT_WEB=93$ATK_ROLE_DOCUMENT_EMAIL=94$ATK_ROLE_COMMENT=95$ATK_ROLE_LIST_BOX=96$ATK_ROLE_GROUPING=97$ATK_ROLE_IMAGE_MAP=98$ATK_ROLE_NOTIFICATION=99$ATK_ROLE_INFO_BAR=100$ATK_ROLE_LEVEL_BAR=101$ATK_ROLE_TITLE_BAR=102$ATK_ROLE_BLOCK_QUOTE=103$ATK_ROLE_AUDIO=104$ATK_ROLE_VIDEO=105$ATK_ROLE_DEFINITION=106$ATK_ROLE_ARTICLE=107$ATK_ROLE_LANDMARK=108$ATK_ROLE_LOG=109$ATK_ROLE_MARQUEE=110$ATK_ROLE_MATH=111$ATK_ROLE_RATING=112$ATK_ROLE_TIMER=113$ATK_ROLE_DESCRIPTION_LIST=114$ATK_ROLE_DESCRIPTION_TERM=115$ATK_ROLE_DESCRIPTION_VALUE=116$ATK_ROLE_STATIC=117$ATK_ROLE_MATH_FRACTION=118$ATK_ROLE_MATH_ROOT=119$ATK_ROLE_SUBSCRIPT=120$ATK_ROLE_SUPERSCRIPT=121$ATK_ROLE_LAST_DEFINED=122
// file /usr/include/atk-1.0/atk/atkobject.h line 232
enum anonymous$24 { ATK_ROLE_INVALID=0, ATK_ROLE_ACCEL_LABEL=1, ATK_ROLE_ALERT=2, ATK_ROLE_ANIMATION=3, ATK_ROLE_ARROW=4, ATK_ROLE_CALENDAR=5, ATK_ROLE_CANVAS=6, ATK_ROLE_CHECK_BOX=7, ATK_ROLE_CHECK_MENU_ITEM=8, ATK_ROLE_COLOR_CHOOSER=9, ATK_ROLE_COLUMN_HEADER=10, ATK_ROLE_COMBO_BOX=11, ATK_ROLE_DATE_EDITOR=12, ATK_ROLE_DESKTOP_ICON=13, ATK_ROLE_DESKTOP_FRAME=14, ATK_ROLE_DIAL=15, ATK_ROLE_DIALOG=16, ATK_ROLE_DIRECTORY_PANE=17, ATK_ROLE_DRAWING_AREA=18, ATK_ROLE_FILE_CHOOSER=19, ATK_ROLE_FILLER=20, ATK_ROLE_FONT_CHOOSER=21, ATK_ROLE_FRAME=22, ATK_ROLE_GLASS_PANE=23, ATK_ROLE_HTML_CONTAINER=24, ATK_ROLE_ICON=25, ATK_ROLE_IMAGE=26, ATK_ROLE_INTERNAL_FRAME=27, ATK_ROLE_LABEL=28, ATK_ROLE_LAYERED_PANE=29, ATK_ROLE_LIST=30, ATK_ROLE_LIST_ITEM=31, ATK_ROLE_MENU=32, ATK_ROLE_MENU_BAR=33, ATK_ROLE_MENU_ITEM=34, ATK_ROLE_OPTION_PANE=35, ATK_ROLE_PAGE_TAB=36, ATK_ROLE_PAGE_TAB_LIST=37, ATK_ROLE_PANEL=38, ATK_ROLE_PASSWORD_TEXT=39, ATK_ROLE_POPUP_MENU=40, ATK_ROLE_PROGRESS_BAR=41, ATK_ROLE_PUSH_BUTTON=42, ATK_ROLE_RADIO_BUTTON=43, ATK_ROLE_RADIO_MENU_ITEM=44, ATK_ROLE_ROOT_PANE=45, ATK_ROLE_ROW_HEADER=46, ATK_ROLE_SCROLL_BAR=47, ATK_ROLE_SCROLL_PANE=48, ATK_ROLE_SEPARATOR=49, ATK_ROLE_SLIDER=50, ATK_ROLE_SPLIT_PANE=51, ATK_ROLE_SPIN_BUTTON=52, ATK_ROLE_STATUSBAR=53, ATK_ROLE_TABLE=54, ATK_ROLE_TABLE_CELL=55, ATK_ROLE_TABLE_COLUMN_HEADER=56, ATK_ROLE_TABLE_ROW_HEADER=57, ATK_ROLE_TEAR_OFF_MENU_ITEM=58, ATK_ROLE_TERMINAL=59, ATK_ROLE_TEXT=60, ATK_ROLE_TOGGLE_BUTTON=61, ATK_ROLE_TOOL_BAR=62, ATK_ROLE_TOOL_TIP=63, ATK_ROLE_TREE=64, ATK_ROLE_TREE_TABLE=65, ATK_ROLE_UNKNOWN=66, ATK_ROLE_VIEWPORT=67, ATK_ROLE_WINDOW=68, ATK_ROLE_HEADER=69, ATK_ROLE_FOOTER=70, ATK_ROLE_PARAGRAPH=71, ATK_ROLE_RULER=72, ATK_ROLE_APPLICATION=73, ATK_ROLE_AUTOCOMPLETE=74, ATK_ROLE_EDITBAR=75, ATK_ROLE_EMBEDDED=76, ATK_ROLE_ENTRY=77, ATK_ROLE_CHART=78, ATK_ROLE_CAPTION=79, ATK_ROLE_DOCUMENT_FRAME=80, ATK_ROLE_HEADING=81, ATK_ROLE_PAGE=82, ATK_ROLE_SECTION=83, ATK_ROLE_REDUNDANT_OBJECT=84, ATK_ROLE_FORM=85, ATK_ROLE_LINK=86, ATK_ROLE_INPUT_METHOD_WINDOW=87, ATK_ROLE_TABLE_ROW=88, ATK_ROLE_TREE_ITEM=89, ATK_ROLE_DOCUMENT_SPREADSHEET=90, ATK_ROLE_DOCUMENT_PRESENTATION=91, ATK_ROLE_DOCUMENT_TEXT=92, ATK_ROLE_DOCUMENT_WEB=93, ATK_ROLE_DOCUMENT_EMAIL=94, ATK_ROLE_COMMENT=95, ATK_ROLE_LIST_BOX=96, ATK_ROLE_GROUPING=97, ATK_ROLE_IMAGE_MAP=98, ATK_ROLE_NOTIFICATION=99, ATK_ROLE_INFO_BAR=100, ATK_ROLE_LEVEL_BAR=101, ATK_ROLE_TITLE_BAR=102, ATK_ROLE_BLOCK_QUOTE=103, ATK_ROLE_AUDIO=104, ATK_ROLE_VIDEO=105, ATK_ROLE_DEFINITION=106, ATK_ROLE_ARTICLE=107, ATK_ROLE_LANDMARK=108, ATK_ROLE_LOG=109, ATK_ROLE_MARQUEE=110, ATK_ROLE_MATH=111, ATK_ROLE_RATING=112, ATK_ROLE_TIMER=113, ATK_ROLE_DESCRIPTION_LIST=114, ATK_ROLE_DESCRIPTION_TERM=115, ATK_ROLE_DESCRIPTION_VALUE=116, ATK_ROLE_STATIC=117, ATK_ROLE_MATH_FRACTION=118, ATK_ROLE_MATH_ROOT=119, ATK_ROLE_SUBSCRIPT=120, ATK_ROLE_SUPERSCRIPT=121, ATK_ROLE_LAST_DEFINED=122 };

// #anon_enum$AVAHI_BROWSER_NEW=0$AVAHI_BROWSER_REMOVE=1$AVAHI_BROWSER_CACHE_EXHAUSTED=2$AVAHI_BROWSER_ALL_FOR_NOW=3$AVAHI_BROWSER_FAILURE=4
// file ../avahi-common/defs.h line 284
enum anonymous$14 { AVAHI_BROWSER_NEW=0, AVAHI_BROWSER_REMOVE=1, AVAHI_BROWSER_CACHE_EXHAUSTED=2, AVAHI_BROWSER_ALL_FOR_NOW=3, AVAHI_BROWSER_FAILURE=4 };

// #anon_enum$AVAHI_CLIENT_IGNORE_USER_CONFIG=1$AVAHI_CLIENT_NO_FAIL=2
// file client.h line 48
enum anonymous$39 { AVAHI_CLIENT_IGNORE_USER_CONFIG=1, AVAHI_CLIENT_NO_FAIL=2 };

// #anon_enum$AVAHI_CLIENT_S_REGISTERING=1$AVAHI_CLIENT_S_RUNNING=2$AVAHI_CLIENT_S_COLLISION=3$AVAHI_CLIENT_FAILURE=100$AVAHI_CLIENT_CONNECTING=101
// file client.h line 40
enum anonymous$11 { AVAHI_CLIENT_S_REGISTERING=1, AVAHI_CLIENT_S_RUNNING=2, AVAHI_CLIENT_S_COLLISION=3, AVAHI_CLIENT_FAILURE=100, AVAHI_CLIENT_CONNECTING=101 };

// #anon_enum$AVAHI_DOMAIN_BROWSER_BROWSE=0$AVAHI_DOMAIN_BROWSER_BROWSE_DEFAULT=1$AVAHI_DOMAIN_BROWSER_REGISTER=2$AVAHI_DOMAIN_BROWSER_REGISTER_DEFAULT=3$AVAHI_DOMAIN_BROWSER_BROWSE_LEGACY=4$AVAHI_DOMAIN_BROWSER_MAX=5
// file ../avahi-common/defs.h line 303
enum anonymous$43 { AVAHI_DOMAIN_BROWSER_BROWSE=0, AVAHI_DOMAIN_BROWSER_BROWSE_DEFAULT=1, AVAHI_DOMAIN_BROWSER_REGISTER=2, AVAHI_DOMAIN_BROWSER_REGISTER_DEFAULT=3, AVAHI_DOMAIN_BROWSER_BROWSE_LEGACY=4, AVAHI_DOMAIN_BROWSER_MAX=5 };

// #anon_enum$AVAHI_ENTRY_GROUP_UNCOMMITED=0$AVAHI_ENTRY_GROUP_REGISTERING=1$AVAHI_ENTRY_GROUP_ESTABLISHED=2$AVAHI_ENTRY_GROUP_COLLISION=3$AVAHI_ENTRY_GROUP_FAILURE=4
// file ../avahi-common/defs.h line 230
enum anonymous$40 { AVAHI_ENTRY_GROUP_UNCOMMITED=0, AVAHI_ENTRY_GROUP_REGISTERING=1, AVAHI_ENTRY_GROUP_ESTABLISHED=2, AVAHI_ENTRY_GROUP_COLLISION=3, AVAHI_ENTRY_GROUP_FAILURE=4 };

// #anon_enum$AVAHI_LOOKUP_RESULT_CACHED=1$AVAHI_LOOKUP_RESULT_WIDE_AREA=2$AVAHI_LOOKUP_RESULT_MULTICAST=4$AVAHI_LOOKUP_RESULT_LOCAL=8$AVAHI_LOOKUP_RESULT_OUR_OWN=16$AVAHI_LOOKUP_RESULT_STATIC=32
// file ../avahi-common/defs.h line 270
enum anonymous$13 { AVAHI_LOOKUP_RESULT_CACHED=1, AVAHI_LOOKUP_RESULT_WIDE_AREA=2, AVAHI_LOOKUP_RESULT_MULTICAST=4, AVAHI_LOOKUP_RESULT_LOCAL=8, AVAHI_LOOKUP_RESULT_OUR_OWN=16, AVAHI_LOOKUP_RESULT_STATIC=32 };

// #anon_enum$AVAHI_LOOKUP_USE_WIDE_AREA=1$AVAHI_LOOKUP_USE_MULTICAST=2$AVAHI_LOOKUP_NO_TXT=4$AVAHI_LOOKUP_NO_ADDRESS=8
// file ../avahi-common/defs.h line 260
enum anonymous$44 { AVAHI_LOOKUP_USE_WIDE_AREA=1, AVAHI_LOOKUP_USE_MULTICAST=2, AVAHI_LOOKUP_NO_TXT=4, AVAHI_LOOKUP_NO_ADDRESS=8 };

// #anon_enum$AVAHI_PUBLISH_UNIQUE=1$AVAHI_PUBLISH_NO_PROBE=2$AVAHI_PUBLISH_NO_ANNOUNCE=4$AVAHI_PUBLISH_ALLOW_MULTIPLE=8$AVAHI_PUBLISH_NO_REVERSE=16$AVAHI_PUBLISH_NO_COOKIE=32$AVAHI_PUBLISH_UPDATE=64$AVAHI_PUBLISH_USE_WIDE_AREA=128$AVAHI_PUBLISH_USE_MULTICAST=256
// file ../avahi-common/defs.h line 243
enum anonymous$41 { AVAHI_PUBLISH_UNIQUE=1, AVAHI_PUBLISH_NO_PROBE=2, AVAHI_PUBLISH_NO_ANNOUNCE=4, AVAHI_PUBLISH_ALLOW_MULTIPLE=8, AVAHI_PUBLISH_NO_REVERSE=16, AVAHI_PUBLISH_NO_COOKIE=32, AVAHI_PUBLISH_UPDATE=64, AVAHI_PUBLISH_USE_WIDE_AREA=128, AVAHI_PUBLISH_USE_MULTICAST=256 };

// #anon_enum$AVAHI_RESOLVER_FOUND=0$AVAHI_RESOLVER_FAILURE=1
// file ../avahi-common/defs.h line 293
enum anonymous$12 { AVAHI_RESOLVER_FOUND=0, AVAHI_RESOLVER_FAILURE=1 };

// #anon_enum$AVAHI_WATCH_IN=1$AVAHI_WATCH_OUT=4$AVAHI_WATCH_ERR=8$AVAHI_WATCH_HUP=16
// file ../avahi-common/watch.h line 42
enum anonymous { AVAHI_WATCH_IN=1, AVAHI_WATCH_OUT=4, AVAHI_WATCH_ERR=8, AVAHI_WATCH_HUP=16 };

// #anon_enum$COMMAND_HELP=0$COMMAND_SSH=1$COMMAND_VNC=2$COMMAND_SHELL=3
// file bssh.c line 41
enum anonymous$9 { COMMAND_HELP=0, COMMAND_SSH=1, COMMAND_VNC=2, COMMAND_SHELL=3 };

// #anon_enum$DBUS_BUS_SESSION=0$DBUS_BUS_SYSTEM=1$DBUS_BUS_STARTER=2
// file /usr/include/dbus-1.0/dbus/dbus-shared.h line 56
enum anonymous$45 { DBUS_BUS_SESSION=0, DBUS_BUS_SYSTEM=1, DBUS_BUS_STARTER=2 };

// #anon_enum$DBUS_DISPATCH_DATA_REMAINS=0$DBUS_DISPATCH_COMPLETE=1$DBUS_DISPATCH_NEED_MEMORY=2
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 79
enum anonymous$27 { DBUS_DISPATCH_DATA_REMAINS=0, DBUS_DISPATCH_COMPLETE=1, DBUS_DISPATCH_NEED_MEMORY=2 };

// #anon_enum$DBUS_HANDLER_RESULT_HANDLED=0$DBUS_HANDLER_RESULT_NOT_YET_HANDLED=1$DBUS_HANDLER_RESULT_NEED_MEMORY=2
// file /usr/include/dbus-1.0/dbus/dbus-shared.h line 66
enum anonymous$42 { DBUS_HANDLER_RESULT_HANDLED=0, DBUS_HANDLER_RESULT_NOT_YET_HANDLED=1, DBUS_HANDLER_RESULT_NEED_MEMORY=2 };

// #anon_enum$GDK_CROSSING_NORMAL=0$GDK_CROSSING_GRAB=1$GDK_CROSSING_UNGRAB=2$GDK_CROSSING_GTK_GRAB=3$GDK_CROSSING_GTK_UNGRAB=4$GDK_CROSSING_STATE_CHANGED=5$GDK_CROSSING_TOUCH_BEGIN=6$GDK_CROSSING_TOUCH_END=7$GDK_CROSSING_DEVICE_SWITCH=8
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 467
enum anonymous$49 { GDK_CROSSING_NORMAL=0, GDK_CROSSING_GRAB=1, GDK_CROSSING_UNGRAB=2, GDK_CROSSING_GTK_GRAB=3, GDK_CROSSING_GTK_UNGRAB=4, GDK_CROSSING_STATE_CHANGED=5, GDK_CROSSING_TOUCH_BEGIN=6, GDK_CROSSING_TOUCH_END=7, GDK_CROSSING_DEVICE_SWITCH=8 };

// #anon_enum$GDK_NOTHING=-1$GDK_DELETE=0$GDK_DESTROY=1$GDK_EXPOSE=2$GDK_MOTION_NOTIFY=3$GDK_BUTTON_PRESS=4$GDK_2BUTTON_PRESS=5$GDK_DOUBLE_BUTTON_PRESS=5$GDK_3BUTTON_PRESS=6$GDK_TRIPLE_BUTTON_PRESS=6$GDK_BUTTON_RELEASE=7$GDK_KEY_PRESS=8$GDK_KEY_RELEASE=9$GDK_ENTER_NOTIFY=10$GDK_LEAVE_NOTIFY=11$GDK_FOCUS_CHANGE=12$GDK_CONFIGURE=13$GDK_MAP=14$GDK_UNMAP=15$GDK_PROPERTY_NOTIFY=16$GDK_SELECTION_CLEAR=17$GDK_SELECTION_REQUEST=18$GDK_SELECTION_NOTIFY=19$GDK_PROXIMITY_IN=20$GDK_PROXIMITY_OUT=21$GDK_DRAG_ENTER=22$GDK_DRAG_LEAVE=23$GDK_DRAG_MOTION=24$GDK_DRAG_STATUS=25$GDK_DROP_START=26$GDK_DROP_FINISHED=27$GDK_CLIENT_EVENT=28$GDK_VISIBILITY_NOTIFY=29$GDK_SCROLL=31$GDK_WINDOW_STATE=32$GDK_SETTING=33$GDK_OWNER_CHANGE=34$GDK_GRAB_BROKEN=35$GDK_DAMAGE=36$GDK_TOUCH_BEGIN=37$GDK_TOUCH_UPDATE=38$GDK_TOUCH_END=39$GDK_TOUCH_CANCEL=40$GDK_TOUCHPAD_SWIPE=41$GDK_TOUCHPAD_PINCH=42$GDK_EVENT_LAST=43
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 295
enum anonymous$46 { GDK_NOTHING=-1, GDK_DELETE=0, GDK_DESTROY=1, GDK_EXPOSE=2, GDK_MOTION_NOTIFY=3, GDK_BUTTON_PRESS=4, GDK_2BUTTON_PRESS=5, GDK_DOUBLE_BUTTON_PRESS=5, GDK_3BUTTON_PRESS=6, GDK_TRIPLE_BUTTON_PRESS=6, GDK_BUTTON_RELEASE=7, GDK_KEY_PRESS=8, GDK_KEY_RELEASE=9, GDK_ENTER_NOTIFY=10, GDK_LEAVE_NOTIFY=11, GDK_FOCUS_CHANGE=12, GDK_CONFIGURE=13, GDK_MAP=14, GDK_UNMAP=15, GDK_PROPERTY_NOTIFY=16, GDK_SELECTION_CLEAR=17, GDK_SELECTION_REQUEST=18, GDK_SELECTION_NOTIFY=19, GDK_PROXIMITY_IN=20, GDK_PROXIMITY_OUT=21, GDK_DRAG_ENTER=22, GDK_DRAG_LEAVE=23, GDK_DRAG_MOTION=24, GDK_DRAG_STATUS=25, GDK_DROP_START=26, GDK_DROP_FINISHED=27, GDK_CLIENT_EVENT=28, GDK_VISIBILITY_NOTIFY=29, GDK_SCROLL=31, GDK_WINDOW_STATE=32, GDK_SETTING=33, GDK_OWNER_CHANGE=34, GDK_GRAB_BROKEN=35, GDK_DAMAGE=36, GDK_TOUCH_BEGIN=37, GDK_TOUCH_UPDATE=38, GDK_TOUCH_END=39, GDK_TOUCH_CANCEL=40, GDK_TOUCHPAD_SWIPE=41, GDK_TOUCHPAD_PINCH=42, GDK_EVENT_LAST=43 };

// #anon_enum$GDK_NOTIFY_ANCESTOR=0$GDK_NOTIFY_VIRTUAL=1$GDK_NOTIFY_INFERIOR=2$GDK_NOTIFY_NONLINEAR=3$GDK_NOTIFY_NONLINEAR_VIRTUAL=4$GDK_NOTIFY_UNKNOWN=5
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 438
enum anonymous$50 { GDK_NOTIFY_ANCESTOR=0, GDK_NOTIFY_VIRTUAL=1, GDK_NOTIFY_INFERIOR=2, GDK_NOTIFY_NONLINEAR=3, GDK_NOTIFY_NONLINEAR_VIRTUAL=4, GDK_NOTIFY_UNKNOWN=5 };

// #anon_enum$GDK_OWNER_CHANGE_NEW_OWNER=0$GDK_OWNER_CHANGE_DESTROY=1$GDK_OWNER_CHANGE_CLOSE=2
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 545
enum anonymous$51 { GDK_OWNER_CHANGE_NEW_OWNER=0, GDK_OWNER_CHANGE_DESTROY=1, GDK_OWNER_CHANGE_CLOSE=2 };

// #anon_enum$GDK_SCROLL_UP=0$GDK_SCROLL_DOWN=1$GDK_SCROLL_LEFT=2$GDK_SCROLL_RIGHT=3$GDK_SCROLL_SMOOTH=4
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 408
enum anonymous$48 { GDK_SCROLL_UP=0, GDK_SCROLL_DOWN=1, GDK_SCROLL_LEFT=2, GDK_SCROLL_RIGHT=3, GDK_SCROLL_SMOOTH=4 };

// #anon_enum$GDK_SETTING_ACTION_NEW=0$GDK_SETTING_ACTION_CHANGED=1$GDK_SETTING_ACTION_DELETED=2
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 530
enum anonymous$53 { GDK_SETTING_ACTION_NEW=0, GDK_SETTING_ACTION_CHANGED=1, GDK_SETTING_ACTION_DELETED=2 };

// #anon_enum$GDK_VISIBILITY_UNOBSCURED=0$GDK_VISIBILITY_PARTIAL=1$GDK_VISIBILITY_FULLY_OBSCURED=2
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 353
enum anonymous$47 { GDK_VISIBILITY_UNOBSCURED=0, GDK_VISIBILITY_PARTIAL=1, GDK_VISIBILITY_FULLY_OBSCURED=2 };

// #anon_enum$GDK_WINDOW_STATE_WITHDRAWN=1$GDK_WINDOW_STATE_ICONIFIED=2$GDK_WINDOW_STATE_MAXIMIZED=4$GDK_WINDOW_STATE_STICKY=8$GDK_WINDOW_STATE_FULLSCREEN=16$GDK_WINDOW_STATE_ABOVE=32$GDK_WINDOW_STATE_BELOW=64$GDK_WINDOW_STATE_FOCUSED=128$GDK_WINDOW_STATE_TILED=256
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 508
enum anonymous$52 { GDK_WINDOW_STATE_WITHDRAWN=1, GDK_WINDOW_STATE_ICONIFIED=2, GDK_WINDOW_STATE_MAXIMIZED=4, GDK_WINDOW_STATE_STICKY=8, GDK_WINDOW_STATE_FULLSCREEN=16, GDK_WINDOW_STATE_ABOVE=32, GDK_WINDOW_STATE_BELOW=64, GDK_WINDOW_STATE_FOCUSED=128, GDK_WINDOW_STATE_TILED=256 };

// #anon_enum$GDK_X_CURSOR=0$GDK_ARROW=2$GDK_BASED_ARROW_DOWN=4$GDK_BASED_ARROW_UP=6$GDK_BOAT=8$GDK_BOGOSITY=10$GDK_BOTTOM_LEFT_CORNER=12$GDK_BOTTOM_RIGHT_CORNER=14$GDK_BOTTOM_SIDE=16$GDK_BOTTOM_TEE=18$GDK_BOX_SPIRAL=20$GDK_CENTER_PTR=22$GDK_CIRCLE=24$GDK_CLOCK=26$GDK_COFFEE_MUG=28$GDK_CROSS=30$GDK_CROSS_REVERSE=32$GDK_CROSSHAIR=34$GDK_DIAMOND_CROSS=36$GDK_DOT=38$GDK_DOTBOX=40$GDK_DOUBLE_ARROW=42$GDK_DRAFT_LARGE=44$GDK_DRAFT_SMALL=46$GDK_DRAPED_BOX=48$GDK_EXCHANGE=50$GDK_FLEUR=52$GDK_GOBBLER=54$GDK_GUMBY=56$GDK_HAND1=58$GDK_HAND2=60$GDK_HEART=62$GDK_ICON=64$GDK_IRON_CROSS=66$GDK_LEFT_PTR=68$GDK_LEFT_SIDE=70$GDK_LEFT_TEE=72$GDK_LEFTBUTTON=74$GDK_LL_ANGLE=76$GDK_LR_ANGLE=78$GDK_MAN=80$GDK_MIDDLEBUTTON=82$GDK_MOUSE=84$GDK_PENCIL=86$GDK_PIRATE=88$GDK_PLUS=90$GDK_QUESTION_ARROW=92$GDK_RIGHT_PTR=94$GDK_RIGHT_SIDE=96$GDK_RIGHT_TEE=98$GDK_RIGHTBUTTON=100$GDK_RTL_LOGO=102$GDK_SAILBOAT=104$GDK_SB_DOWN_ARROW=106$GDK_SB_H_DOUBLE_ARROW=108$GDK_SB_LEFT_ARROW=110$GDK_SB_RIGHT_ARROW=112$GDK_SB_UP_ARROW=114$GDK_SB_V_DOUBLE_ARROW=116$GDK_SHUTTLE=118$GDK_SIZING=120$GDK_SPIDER=122$GDK_SPRAYCAN=124$GDK_STAR=126$GDK_TARGET=128$GDK_TCROSS=130$GDK_TOP_LEFT_ARROW=132$GDK_TOP_LEFT_CORNER=134$GDK_TOP_RIGHT_CORNER=136$GDK_TOP_SIDE=138$GDK_TOP_TEE=140$GDK_TREK=142$GDK_UL_ANGLE=144$GDK_UMBRELLA=146$GDK_UR_ANGLE=148$GDK_WATCH=150$GDK_XTERM=152$GDK_LAST_CURSOR=153$GDK_BLANK_CURSOR=-2$GDK_CURSOR_IS_PIXMAP=-1
// file /usr/include/gtk-3.0/gdk/gdkcursor.h line 134
enum anonymous$34 { GDK_X_CURSOR=0, GDK_ARROW=2, GDK_BASED_ARROW_DOWN=4, GDK_BASED_ARROW_UP=6, GDK_BOAT=8, GDK_BOGOSITY=10, GDK_BOTTOM_LEFT_CORNER=12, GDK_BOTTOM_RIGHT_CORNER=14, GDK_BOTTOM_SIDE=16, GDK_BOTTOM_TEE=18, GDK_BOX_SPIRAL=20, GDK_CENTER_PTR=22, GDK_CIRCLE=24, GDK_CLOCK=26, GDK_COFFEE_MUG=28, GDK_CROSS=30, GDK_CROSS_REVERSE=32, GDK_CROSSHAIR=34, GDK_DIAMOND_CROSS=36, GDK_DOT=38, GDK_DOTBOX=40, GDK_DOUBLE_ARROW=42, GDK_DRAFT_LARGE=44, GDK_DRAFT_SMALL=46, GDK_DRAPED_BOX=48, GDK_EXCHANGE=50, GDK_FLEUR=52, GDK_GOBBLER=54, GDK_GUMBY=56, GDK_HAND1=58, GDK_HAND2=60, GDK_HEART=62, GDK_ICON=64, GDK_IRON_CROSS=66, GDK_LEFT_PTR=68, GDK_LEFT_SIDE=70, GDK_LEFT_TEE=72, GDK_LEFTBUTTON=74, GDK_LL_ANGLE=76, GDK_LR_ANGLE=78, GDK_MAN=80, GDK_MIDDLEBUTTON=82, GDK_MOUSE=84, GDK_PENCIL=86, GDK_PIRATE=88, GDK_PLUS=90, GDK_QUESTION_ARROW=92, GDK_RIGHT_PTR=94, GDK_RIGHT_SIDE=96, GDK_RIGHT_TEE=98, GDK_RIGHTBUTTON=100, GDK_RTL_LOGO=102, GDK_SAILBOAT=104, GDK_SB_DOWN_ARROW=106, GDK_SB_H_DOUBLE_ARROW=108, GDK_SB_LEFT_ARROW=110, GDK_SB_RIGHT_ARROW=112, GDK_SB_UP_ARROW=114, GDK_SB_V_DOUBLE_ARROW=116, GDK_SHUTTLE=118, GDK_SIZING=120, GDK_SPIDER=122, GDK_SPRAYCAN=124, GDK_STAR=126, GDK_TARGET=128, GDK_TCROSS=130, GDK_TOP_LEFT_ARROW=132, GDK_TOP_LEFT_CORNER=134, GDK_TOP_RIGHT_CORNER=136, GDK_TOP_SIDE=138, GDK_TOP_TEE=140, GDK_TREK=142, GDK_UL_ANGLE=144, GDK_UMBRELLA=146, GDK_UR_ANGLE=148, GDK_WATCH=150, GDK_XTERM=152, GDK_LAST_CURSOR=153, GDK_BLANK_CURSOR=-2, GDK_CURSOR_IS_PIXMAP=-1 };

// #anon_enum$GTK_BUTTONS_NONE=0$GTK_BUTTONS_OK=1$GTK_BUTTONS_CLOSE=2$GTK_BUTTONS_CANCEL=3$GTK_BUTTONS_YES_NO=4$GTK_BUTTONS_OK_CANCEL=5
// file /usr/include/gtk-3.0/gtk/gtkmessagedialog.h line 85
enum anonymous$17 { GTK_BUTTONS_NONE=0, GTK_BUTTONS_OK=1, GTK_BUTTONS_CLOSE=2, GTK_BUTTONS_CANCEL=3, GTK_BUTTONS_YES_NO=4, GTK_BUTTONS_OK_CANCEL=5 };

// #anon_enum$GTK_DIALOG_MODAL=1$GTK_DIALOG_DESTROY_WITH_PARENT=2$GTK_DIALOG_USE_HEADER_BAR=4
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 49
enum anonymous$30 { GTK_DIALOG_MODAL=1, GTK_DIALOG_DESTROY_WITH_PARENT=2, GTK_DIALOG_USE_HEADER_BAR=4 };

// #anon_enum$GTK_DIR_TAB_FORWARD=0$GTK_DIR_TAB_BACKWARD=1$GTK_DIR_UP=2$GTK_DIR_DOWN=3$GTK_DIR_LEFT=4$GTK_DIR_RIGHT=5
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 166
enum anonymous$22 { GTK_DIR_TAB_FORWARD=0, GTK_DIR_TAB_BACKWARD=1, GTK_DIR_UP=2, GTK_DIR_DOWN=3, GTK_DIR_LEFT=4, GTK_DIR_RIGHT=5 };

// #anon_enum$GTK_DRAG_RESULT_SUCCESS=0$GTK_DRAG_RESULT_NO_TARGET=1$GTK_DRAG_RESULT_USER_CANCELLED=2$GTK_DRAG_RESULT_TIMEOUT_EXPIRED=3$GTK_DRAG_RESULT_GRAB_BROKEN=4$GTK_DRAG_RESULT_ERROR=5
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 788
enum anonymous$23 { GTK_DRAG_RESULT_SUCCESS=0, GTK_DRAG_RESULT_NO_TARGET=1, GTK_DRAG_RESULT_USER_CANCELLED=2, GTK_DRAG_RESULT_TIMEOUT_EXPIRED=3, GTK_DRAG_RESULT_GRAB_BROKEN=4, GTK_DRAG_RESULT_ERROR=5 };

// #anon_enum$GTK_ICON_SIZE_INVALID=0$GTK_ICON_SIZE_MENU=1$GTK_ICON_SIZE_SMALL_TOOLBAR=2$GTK_ICON_SIZE_LARGE_TOOLBAR=3$GTK_ICON_SIZE_BUTTON=4$GTK_ICON_SIZE_DND=5$GTK_ICON_SIZE_DIALOG=6
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 188
enum anonymous$32 { GTK_ICON_SIZE_INVALID=0, GTK_ICON_SIZE_MENU=1, GTK_ICON_SIZE_SMALL_TOOLBAR=2, GTK_ICON_SIZE_LARGE_TOOLBAR=3, GTK_ICON_SIZE_BUTTON=4, GTK_ICON_SIZE_DND=5, GTK_ICON_SIZE_DIALOG=6 };

// #anon_enum$GTK_MESSAGE_INFO=0$GTK_MESSAGE_WARNING=1$GTK_MESSAGE_QUESTION=2$GTK_MESSAGE_ERROR=3$GTK_MESSAGE_OTHER=4
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 277
enum anonymous$29 { GTK_MESSAGE_INFO=0, GTK_MESSAGE_WARNING=1, GTK_MESSAGE_QUESTION=2, GTK_MESSAGE_ERROR=3, GTK_MESSAGE_OTHER=4 };

// #anon_enum$GTK_ORIENTATION_HORIZONTAL=0$GTK_ORIENTATION_VERTICAL=1
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 341
enum anonymous$16 { GTK_ORIENTATION_HORIZONTAL=0, GTK_ORIENTATION_VERTICAL=1 };

// #anon_enum$GTK_POLICY_ALWAYS=0$GTK_POLICY_AUTOMATIC=1$GTK_POLICY_NEVER=2$GTK_POLICY_EXTERNAL=3
// file /usr/include/gtk-3.0/gtk/gtkscrolledwindow.h line 136
enum anonymous$2 { GTK_POLICY_ALWAYS=0, GTK_POLICY_AUTOMATIC=1, GTK_POLICY_NEVER=2, GTK_POLICY_EXTERNAL=3 };

// #anon_enum$GTK_RC_FG=1$GTK_RC_BG=2$GTK_RC_TEXT=4$GTK_RC_BASE=8
// file /usr/include/gtk-3.0/gtk/deprecated/gtkrc.h line 57
enum anonymous$33 { GTK_RC_FG=1, GTK_RC_BG=2, GTK_RC_TEXT=4, GTK_RC_BASE=8 };

// #anon_enum$GTK_SELECTION_NONE=0$GTK_SELECTION_SINGLE=1$GTK_SELECTION_BROWSE=2$GTK_SELECTION_MULTIPLE=3
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 453
enum anonymous$1 { GTK_SELECTION_NONE=0, GTK_SELECTION_SINGLE=1, GTK_SELECTION_BROWSE=2, GTK_SELECTION_MULTIPLE=3 };

// #anon_enum$GTK_SHADOW_NONE=0$GTK_SHADOW_IN=1$GTK_SHADOW_OUT=2$GTK_SHADOW_ETCHED_IN=3$GTK_SHADOW_ETCHED_OUT=4
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 475
enum anonymous$5 { GTK_SHADOW_NONE=0, GTK_SHADOW_IN=1, GTK_SHADOW_OUT=2, GTK_SHADOW_ETCHED_IN=3, GTK_SHADOW_ETCHED_OUT=4 };

// #anon_enum$GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH=0$GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT=1$GTK_SIZE_REQUEST_CONSTANT_SIZE=2
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 824
enum anonymous$21 { GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH=0, GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT=1, GTK_SIZE_REQUEST_CONSTANT_SIZE=2 };

// #anon_enum$GTK_STATE_FLAG_NORMAL=0$GTK_STATE_FLAG_ACTIVE=1$GTK_STATE_FLAG_PRELIGHT=2$GTK_STATE_FLAG_SELECTED=4$GTK_STATE_FLAG_INSENSITIVE=8$GTK_STATE_FLAG_INCONSISTENT=16$GTK_STATE_FLAG_FOCUSED=32$GTK_STATE_FLAG_BACKDROP=64$GTK_STATE_FLAG_DIR_LTR=128$GTK_STATE_FLAG_DIR_RTL=256$GTK_STATE_FLAG_LINK=512$GTK_STATE_FLAG_VISITED=1024$GTK_STATE_FLAG_CHECKED=2048
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 865
enum anonymous$19 { GTK_STATE_FLAG_NORMAL=0, GTK_STATE_FLAG_ACTIVE=1, GTK_STATE_FLAG_PRELIGHT=2, GTK_STATE_FLAG_SELECTED=4, GTK_STATE_FLAG_INSENSITIVE=8, GTK_STATE_FLAG_INCONSISTENT=16, GTK_STATE_FLAG_FOCUSED=32, GTK_STATE_FLAG_BACKDROP=64, GTK_STATE_FLAG_DIR_LTR=128, GTK_STATE_FLAG_DIR_RTL=256, GTK_STATE_FLAG_LINK=512, GTK_STATE_FLAG_VISITED=1024, GTK_STATE_FLAG_CHECKED=2048 };

// #anon_enum$GTK_STATE_NORMAL=0$GTK_STATE_ACTIVE=1$GTK_STATE_PRELIGHT=2$GTK_STATE_SELECTED=3$GTK_STATE_INSENSITIVE=4$GTK_STATE_INCONSISTENT=5$GTK_STATE_FOCUSED=6
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 508
enum anonymous$18 { GTK_STATE_NORMAL=0, GTK_STATE_ACTIVE=1, GTK_STATE_PRELIGHT=2, GTK_STATE_SELECTED=3, GTK_STATE_INSENSITIVE=4, GTK_STATE_INCONSISTENT=5, GTK_STATE_FOCUSED=6 };

// #anon_enum$GTK_TEXT_DIR_NONE=0$GTK_TEXT_DIR_LTR=1$GTK_TEXT_DIR_RTL=2
// file /usr/include/gtk-3.0/gtk/gtkenums.h line 225
enum anonymous$20 { GTK_TEXT_DIR_NONE=0, GTK_TEXT_DIR_LTR=1, GTK_TEXT_DIR_RTL=2 };

// #anon_enum$GTK_WIDGET_HELP_TOOLTIP=0$GTK_WIDGET_HELP_WHATS_THIS=1
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 48
enum anonymous$26 { GTK_WIDGET_HELP_TOOLTIP=0, GTK_WIDGET_HELP_WHATS_THIS=1 };

// #anon_enum$G_CONNECT_AFTER=1$G_CONNECT_SWAPPED=2
// file /usr/include/glib-2.0/gobject/gsignal.h line 155
enum anonymous$7 { G_CONNECT_AFTER=1, G_CONNECT_SWAPPED=2 };

// #anon_enum$G_LOG_FLAG_RECURSION=1$G_LOG_FLAG_FATAL=2$G_LOG_LEVEL_ERROR=4$G_LOG_LEVEL_CRITICAL=8$G_LOG_LEVEL_WARNING=16$G_LOG_LEVEL_MESSAGE=32$G_LOG_LEVEL_INFO=64$G_LOG_LEVEL_DEBUG=128$G_LOG_LEVEL_MASK=-4
// file /usr/include/glib-2.0/glib/gmessages.h line 51
enum anonymous$10 { G_LOG_FLAG_RECURSION=1, G_LOG_FLAG_FATAL=2, G_LOG_LEVEL_ERROR=4, G_LOG_LEVEL_CRITICAL=8, G_LOG_LEVEL_WARNING=16, G_LOG_LEVEL_MESSAGE=32, G_LOG_LEVEL_INFO=64, G_LOG_LEVEL_DEBUG=128, G_LOG_LEVEL_MASK=-4 };

// #anon_enum$G_PARAM_READABLE=1$G_PARAM_WRITABLE=2$G_PARAM_READWRITE=3$G_PARAM_CONSTRUCT=4$G_PARAM_CONSTRUCT_ONLY=8$G_PARAM_LAX_VALIDATION=16$G_PARAM_STATIC_NAME=32$G_PARAM_PRIVATE=32$G_PARAM_STATIC_NICK=64$G_PARAM_STATIC_BLURB=128$G_PARAM_EXPLICIT_NOTIFY=1073741824$G_PARAM_DEPRECATED=-2147483648
// file /usr/include/glib-2.0/gobject/gparam.h line 150
enum anonymous$35 { G_PARAM_READABLE=1, G_PARAM_WRITABLE=2, G_PARAM_READWRITE=3, G_PARAM_CONSTRUCT=4, G_PARAM_CONSTRUCT_ONLY=8, G_PARAM_LAX_VALIDATION=16, G_PARAM_STATIC_NAME=32, G_PARAM_PRIVATE=32, G_PARAM_STATIC_NICK=64, G_PARAM_STATIC_BLURB=128, G_PARAM_EXPLICIT_NOTIFY=1073741824, G_PARAM_DEPRECATED=-2147483648 };

// #anon_enum$G_TYPE_FLAG_ABSTRACT=16$G_TYPE_FLAG_VALUE_ABSTRACT=32
// file /usr/include/glib-2.0/gobject/gtype.h line 993
enum anonymous$3 { G_TYPE_FLAG_ABSTRACT=16, G_TYPE_FLAG_VALUE_ABSTRACT=32 };

// #anon_enum$PANGO_ELLIPSIZE_NONE=0$PANGO_ELLIPSIZE_START=1$PANGO_ELLIPSIZE_MIDDLE=2$PANGO_ELLIPSIZE_END=3
// file /usr/include/pango-1.0/pango/pango-layout.h line 90
enum anonymous$0 { PANGO_ELLIPSIZE_NONE=0, PANGO_ELLIPSIZE_START=1, PANGO_ELLIPSIZE_MIDDLE=2, PANGO_ELLIPSIZE_END=3 };

// #anon_enum$STATE_INIT=0$STATE_PREPARING=1$STATE_PREPARED=2$STATE_RUNNING=3$STATE_RAN=4$STATE_DISPATCHING=5$STATE_DISPATCHED=6$STATE_QUIT=7$STATE_FAILURE=8
// file simple-watch.c line 84
enum anonymous$31 { STATE_INIT=0, STATE_PREPARING=1, STATE_PREPARED=2, STATE_RUNNING=3, STATE_RAN=4, STATE_DISPATCHING=5, STATE_DISPATCHED=6, STATE_QUIT=7, STATE_FAILURE=8 };

// tag-#anon#ST[*{S8}$S8$'dptr'||S32'dsize'||U32'$pad0'|]
// file /usr/include/gdbm.h line 56
struct anonymous$37;

// tag-#anon#ST[*{SYM#tag-DBusConnection#}$SYM#tag-DBusConnection#$'connection'||*{cSYM#tag-AvahiPoll#}$cSYM#tag-AvahiPoll#$'poll_api'||*{SYM#tag-AvahiTimeout#}$SYM#tag-AvahiTimeout#$'dispatch_timeout'||S32'ref'||U32'$pad0'|]
// file ../avahi-common/dbus-watch-glue.c line 61
struct anonymous$28;

// tag-#anon#ST[ARR10{S32}$S32$'dummy'|]
// file /usr/include/gdbm.h line 63
struct anonymous$36;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$8;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$38;

// tag-#anon#UN[S32'v_int'||U32'v_uint'||S64'v_long'||U64'v_ulong'||S64'v_int64'||U64'v_uint64'||F32'v_float'||F64'v_double'||*{V}$V$'v_pointer'|]
// file /usr/include/glib-2.0/gobject/gvalue.h line 112
union anonymous$54;

// tag-#anon#UN[SYM#tag-AvahiIPv6Address#'ipv6'||SYM#tag-AvahiIPv4Address#'ipv4'||ARR1{U8}$U8$'data'|]
// file ../avahi-common/address.h line 73
union anonymous$15;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$6;

// tag-AvahiAddress
// file ../avahi-common/address.h line 70
struct AvahiAddress;

// tag-AvahiAddressResolver
// file lookup.h line 242
struct AvahiAddressResolver;

// tag-AvahiAllocator
// file malloc.h line 75
struct AvahiAllocator;

// tag-AvahiClient
// file client.h line 37
struct AvahiClient;

// tag-AvahiDomainBrowser
// file lookup.h line 44
struct AvahiDomainBrowser;

// tag-AvahiEntryGroup
// file publish.h line 43
struct AvahiEntryGroup;

// tag-AvahiGLibPoll
// file ../avahi-glib/glib-watch.h line 36
struct AvahiGLibPoll;

// tag-AvahiGLibPoll$link1
// file glib-watch.h line 36
struct AvahiGLibPoll;

// tag-AvahiHostNameResolver
// file lookup.h line 211
struct AvahiHostNameResolver;

// tag-AvahiIPv4Address
// file ../avahi-common/address.h line 60
struct AvahiIPv4Address;

// tag-AvahiIPv6Address
// file ../avahi-common/address.h line 65
struct AvahiIPv6Address;

// tag-AvahiPoll
// file ../avahi-common/watch.h line 39
struct AvahiPoll$1;

// tag-AvahiPoll$link1
// file ../avahi-common/watch.h line 39
struct AvahiPoll$0;

// tag-AvahiPoll$link2
// file ../avahi-common/watch.h line 39
struct AvahiPoll;

// tag-AvahiRList
// file rlist.h line 30
struct AvahiRList;

// tag-AvahiRecordBrowser
// file lookup.h line 276
struct AvahiRecordBrowser;

// tag-AvahiServiceBrowser
// file lookup.h line 78
struct AvahiServiceBrowser;

// tag-AvahiServiceResolver
// file lookup.h line 157
struct AvahiServiceResolver;

// tag-AvahiServiceTypeBrowser
// file lookup.h line 123
struct AvahiServiceTypeBrowser;

// tag-AvahiSimplePoll
// file simple-watch.h line 34
struct AvahiSimplePoll$0;

// tag-AvahiSimplePoll$link1
// file simple-watch.h line 34
struct AvahiSimplePoll;

// tag-AvahiStringList
// file ../avahi-common/strlst.h line 40
struct AvahiStringList;

// tag-AvahiThreadedPoll
// file thread-watch.h line 32
struct AvahiThreadedPoll$0;

// tag-AvahiThreadedPoll$link1
// file thread-watch.h line 32
struct AvahiThreadedPoll;

// tag-AvahiTimeout
// file ../avahi-common/watch.h line 36
struct AvahiTimeout$1;

// tag-AvahiTimeout$link1
// file ../avahi-common/watch.h line 36
struct AvahiTimeout$0;

// tag-AvahiTimeout$link2
// file ../avahi-common/watch.h line 36
struct AvahiTimeout;

// tag-AvahiWatch
// file ../avahi-common/watch.h line 33
struct AvahiWatch$1;

// tag-AvahiWatch$link1
// file ../avahi-common/watch.h line 33
struct AvahiWatch;

// tag-AvahiWatch$link2
// file ../avahi-common/watch.h line 33
struct AvahiWatch$0;

// tag-Config
// file bssh.c line 48
struct Config;

// tag-DBusConnection
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 51
struct DBusConnection;

// tag-DBusError
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 43
struct DBusError;

// tag-DBusMessage
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 44
struct DBusMessage;

// tag-DBusMessageIter
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 46
struct DBusMessageIter;

// tag-DBusTimeout
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 45
struct DBusTimeout;

// tag-DBusWatch
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 43
struct DBusWatch;

// tag-TimeoutData
// file ../avahi-common/dbus-watch-glue.c line 196
struct TimeoutData;

// tag-_AtkObject
// file /usr/include/atk-1.0/atk/atkobject.h line 440
struct _AtkObject;

// tag-_AtkRelationSet
// file /usr/include/atk-1.0/atk/atkobject.h line 442
struct _AtkRelationSet;

// tag-_AuiServiceDialog
// file avahi-ui.h line 53
struct _AuiServiceDialog;

// tag-_AuiServiceDialogClass
// file avahi-ui.h line 41
struct _AuiServiceDialogClass;

// tag-_AuiServiceDialogPrivate
// file avahi-ui.h line 40
struct _AuiServiceDialogPrivate;

// tag-_GArray
// file /usr/include/glib-2.0/glib/garray.h line 37
struct _GArray;

// tag-_GClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 74
struct _GClosure;

// tag-_GClosureNotifyData
// file /usr/include/glib-2.0/gobject/gclosure.h line 75
struct _GClosureNotifyData;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GHashTable
// file /usr/include/glib-2.0/glib/ghash.h line 37
struct _GHashTable;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GMainContext
// file /usr/include/glib-2.0/glib/gmain.h line 48
struct _GMainContext;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GObjectClass
// file /usr/include/glib-2.0/gobject/gobject.h line 188
struct _GObjectClass;

// tag-_GObjectConstructParam
// file /usr/include/glib-2.0/gobject/gobject.h line 191
struct _GObjectConstructParam;

// tag-_GParamSpec
// file /usr/include/glib-2.0/gobject/gparam.h line 193
struct _GParamSpec;

// tag-_GPollFD
// file /usr/include/glib-2.0/glib/gpoll.h line 58
struct _GPollFD;

// tag-_GPtrArray
// file /usr/include/glib-2.0/glib/garray.h line 39
struct _GPtrArray;

// tag-_GSList
// file /usr/include/glib-2.0/glib/gslist.h line 37
struct _GSList;

// tag-_GSource
// file /usr/include/glib-2.0/glib/gmain.h line 64
struct _GSource;

// tag-_GSourceCallbackFuncs
// file /usr/include/glib-2.0/glib/gmain.h line 77
struct _GSourceCallbackFuncs;

// tag-_GSourceFuncs
// file /usr/include/glib-2.0/glib/gmain.h line 130
struct _GSourceFuncs;

// tag-_GSourcePrivate
// file /usr/include/glib-2.0/glib/gmain.h line 65
struct _GSourcePrivate;

// tag-_GTimeVal
// file /usr/include/glib-2.0/glib/gtypes.h line 449
struct _GTimeVal;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_GValue
// file /usr/include/glib-2.0/gobject/gtype.h line 386
struct _GValue;

// tag-_GdkAtom
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 102
struct _GdkAtom;

// tag-_GdkColor
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 132
struct _GdkColor;

// tag-_GdkCursor
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 134
struct _GdkCursor;

// tag-_GdkDevice
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 136
struct _GdkDevice;

// tag-_GdkDragContext
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 137
struct _GdkDragContext;

// tag-_GdkEvent
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 147
union _GdkEvent;

// tag-_GdkEventAny
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 123
struct _GdkEventAny;

// tag-_GdkEventButton
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 127
struct _GdkEventButton;

// tag-_GdkEventConfigure
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 133
struct _GdkEventConfigure;

// tag-_GdkEventCrossing
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 132
struct _GdkEventCrossing;

// tag-_GdkEventDND
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 138
struct _GdkEventDND;

// tag-_GdkEventExpose
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 124
struct _GdkEventExpose;

// tag-_GdkEventFocus
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 131
struct _GdkEventFocus;

// tag-_GdkEventGrabBroken
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 141
struct _GdkEventGrabBroken;

// tag-_GdkEventKey
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 130
struct _GdkEventKey;

// tag-_GdkEventMotion
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 126
struct _GdkEventMotion;

// tag-_GdkEventOwnerChange
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 136
struct _GdkEventOwnerChange;

// tag-_GdkEventProperty
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 134
struct _GdkEventProperty;

// tag-_GdkEventProximity
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 137
struct _GdkEventProximity;

// tag-_GdkEventScroll
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 129
struct _GdkEventScroll;

// tag-_GdkEventSelection
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 135
struct _GdkEventSelection;

// tag-_GdkEventSequence
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 145
struct _GdkEventSequence;

// tag-_GdkEventSetting
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 140
struct _GdkEventSetting;

// tag-_GdkEventTouch
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 128
struct _GdkEventTouch;

// tag-_GdkEventTouchpadPinch
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 143
struct _GdkEventTouchpadPinch;

// tag-_GdkEventTouchpadSwipe
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 142
struct _GdkEventTouchpadSwipe;

// tag-_GdkEventVisibility
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 125
struct _GdkEventVisibility;

// tag-_GdkEventWindowState
// file /usr/include/gtk-3.0/gdk/gdkevents.h line 139
struct _GdkEventWindowState;

// tag-_GdkScreen
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 142
struct _GdkScreen;

// tag-_GdkVisual
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 135
struct _GdkVisual;

// tag-_GdkWindow
// file /usr/include/gtk-3.0/gdk/gdktypes.h line 143
struct _GdkWindow;

// tag-_GtkAdjustment
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 34
struct _GtkAdjustment;

// tag-_GtkAdjustmentPrivate
// file /usr/include/gtk-3.0/gtk/gtkadjustment.h line 45
struct _GtkAdjustmentPrivate;

// tag-_GtkBin
// file /usr/include/gtk-3.0/gtk/gtkbin.h line 46
struct _GtkBin;

// tag-_GtkBinClass
// file /usr/include/gtk-3.0/gtk/gtkbin.h line 48
struct _GtkBinClass;

// tag-_GtkBinPrivate
// file /usr/include/gtk-3.0/gtk/gtkbin.h line 47
struct _GtkBinPrivate;

// tag-_GtkBox
// file /usr/include/gtk-3.0/gtk/gtkbox.h line 47
struct _GtkBox;

// tag-_GtkBoxPrivate
// file /usr/include/gtk-3.0/gtk/gtkbox.h line 48
struct _GtkBoxPrivate;

// tag-_GtkButton
// file /usr/include/gtk-3.0/gtk/gtkbutton.h line 46
struct _GtkButton;

// tag-_GtkButtonBox
// file /usr/include/gtk-3.0/gtk/gtkbbox.h line 45
struct _GtkButtonBox;

// tag-_GtkButtonBoxPrivate
// file /usr/include/gtk-3.0/gtk/gtkbbox.h line 46
struct _GtkButtonBoxPrivate;

// tag-_GtkButtonPrivate
// file /usr/include/gtk-3.0/gtk/gtkbutton.h line 47
struct _GtkButtonPrivate;

// tag-_GtkCellRenderer
// file /usr/include/gtk-3.0/gtk/gtkcellrenderer.h line 80
struct _GtkCellRenderer;

// tag-_GtkCellRendererPrivate
// file /usr/include/gtk-3.0/gtk/gtkcellrenderer.h line 81
struct _GtkCellRendererPrivate;

// tag-_GtkContainer
// file /usr/include/gtk-3.0/gtk/gtkcontainer.h line 46
struct _GtkContainer;

// tag-_GtkContainerClass
// file /usr/include/gtk-3.0/gtk/gtkcontainer.h line 48
struct _GtkContainerClass;

// tag-_GtkContainerPrivate
// file /usr/include/gtk-3.0/gtk/gtkcontainer.h line 47
struct _GtkContainerPrivate;

// tag-_GtkDialog
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 99
struct _GtkDialog;

// tag-_GtkDialogClass
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 101
struct _GtkDialogClass;

// tag-_GtkDialogPrivate
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 100
struct _GtkDialogPrivate;

// tag-_GtkEditable
// file /usr/include/gtk-3.0/gtk/gtkeditable.h line 43
struct _GtkEditable;

// tag-_GtkEntry
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 70
struct _GtkEntry;

// tag-_GtkEntryPrivate
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 71
struct _GtkEntryPrivate;

// tag-_GtkLabel
// file /usr/include/gtk-3.0/gtk/gtklabel.h line 48
struct _GtkLabel;

// tag-_GtkLabelPrivate
// file /usr/include/gtk-3.0/gtk/gtklabel.h line 49
struct _GtkLabelPrivate;

// tag-_GtkListStore
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 40
struct _GtkListStore;

// tag-_GtkListStorePrivate
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 41
struct _GtkListStorePrivate;

// tag-_GtkMisc
// file /usr/include/gtk-3.0/gtk/deprecated/gtkmisc.h line 46
struct _GtkMisc;

// tag-_GtkMiscPrivate
// file /usr/include/gtk-3.0/gtk/deprecated/gtkmisc.h line 47
struct _GtkMiscPrivate;

// tag-_GtkProgressBar
// file /usr/include/gtk-3.0/gtk/gtkprogressbar.h line 44
struct _GtkProgressBar;

// tag-_GtkProgressBarPrivate
// file /usr/include/gtk-3.0/gtk/gtkprogressbar.h line 45
struct _GtkProgressBarPrivate;

// tag-_GtkRcStyle
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 39
struct _GtkRcStyle;

// tag-_GtkScrolledWindow
// file /usr/include/gtk-3.0/gtk/gtkscrolledwindow.h line 45
struct _GtkScrolledWindow;

// tag-_GtkScrolledWindowPrivate
// file /usr/include/gtk-3.0/gtk/gtkscrolledwindow.h line 46
struct _GtkScrolledWindowPrivate;

// tag-_GtkSelectionData
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 41
struct _GtkSelectionData;

// tag-_GtkStyle
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 43
struct _GtkStyle;

// tag-_GtkTooltip
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 45
struct _GtkTooltip;

// tag-_GtkTreeIter
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 39
struct _GtkTreeIter;

// tag-_GtkTreeModel
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 42
struct _GtkTreeModel;

// tag-_GtkTreePath
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 40
struct _GtkTreePath;

// tag-_GtkTreeSelection
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 64
struct _GtkTreeSelection;

// tag-_GtkTreeSelectionPrivate
// file /usr/include/gtk-3.0/gtk/gtktreeselection.h line 37
struct _GtkTreeSelectionPrivate;

// tag-_GtkTreeView
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 61
struct _GtkTreeView;

// tag-_GtkTreeViewColumn
// file /usr/include/gtk-3.0/gtk/gtktreeviewcolumn.h line 41
struct _GtkTreeViewColumn;

// tag-_GtkTreeViewColumnPrivate
// file /usr/include/gtk-3.0/gtk/gtktreeviewcolumn.h line 43
struct _GtkTreeViewColumnPrivate;

// tag-_GtkTreeViewPrivate
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 63
struct _GtkTreeViewPrivate;

// tag-_GtkWidget
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 46
struct _GtkWidget;

// tag-_GtkWidgetClass
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 67
struct _GtkWidgetClass;

// tag-_GtkWidgetClassPrivate
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 68
struct _GtkWidgetClassPrivate;

// tag-_GtkWidgetPath
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 47
struct _GtkWidgetPath;

// tag-_GtkWidgetPrivate
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 66
struct _GtkWidgetPrivate;

// tag-_GtkWindow
// file /usr/include/gtk-3.0/gtk/gtktypes.h line 48
struct _GtkWindow;

// tag-_GtkWindowClass
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 47
struct _GtkWindowClass;

// tag-_GtkWindowPrivate
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 46
struct _GtkWindowPrivate;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_PangoFontDescription
// file /usr/include/pango-1.0/pango/pango-font.h line 40
struct _PangoFontDescription;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_cairo
// file /usr/include/cairo/cairo.h line 124
struct _cairo;

// tag-_cairo_pattern
// file /usr/include/cairo/cairo.h line 220
struct _cairo_pattern;

// tag-_cairo_rectangle_int
// file /usr/include/cairo/cairo.h line 475
struct _cairo_rectangle_int;

// tag-_cairo_region
// file /usr/include/cairo/cairo.h line 3049
struct _cairo_region;

// tag-error_map
// file ../avahi-common/dbus.c line 93
struct error_map;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __atomic_load_8
// file avahi-ui.c line 169 function aui_service_dialog_get_type
signed int __atomic_load_8(void);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// add_timeout
// file ../avahi-common/dbus-watch-glue.c line 254
static unsigned int add_timeout(struct DBusTimeout *dbus_timeout, void *userdata);
// add_timeout$link1
// file ../avahi-common/dbus-watch-glue.c line 254
static unsigned int add_timeout$link1(struct DBusTimeout *dbus_timeout$link1, void *userdata$link1);
// add_watch
// file ../avahi-common/dbus-watch-glue.c line 165
static unsigned int add_watch(struct DBusWatch *dbus_watch, void *userdata);
// add_watch$link1
// file ../avahi-common/dbus-watch-glue.c line 165
static unsigned int add_watch$link1(struct DBusWatch *dbus_watch$link1, void *userdata$link1);
// address_get_size
// file address.c line 35
static unsigned long int address_get_size(const struct AvahiAddress *a);
// address_get_size$link1
// file address.c line 35
static unsigned long int address_get_size$link1(const struct AvahiAddress *a$link1);
// address_get_size$link1$link1
// file address.c line 35
static unsigned long int address_get_size$link1$link1(const struct AvahiAddress *a$link1$link1);
// address_get_size$link2
// file address.c line 35
static unsigned long int address_get_size$link2(const struct AvahiAddress *a$link2);
// address_get_size$link3
// file address.c line 35
static unsigned long int address_get_size$link3(const struct AvahiAddress *a$link3);
// append_rdata
// file entrygroup.c line 348
static signed int append_rdata(struct DBusMessage *message, const void *rdata, unsigned long int size);
// append_rdata$link1
// file entrygroup.c line 348
static signed int append_rdata$link1(struct DBusMessage *message$link1, const void *rdata$link1, unsigned long int size$link1);
// append_string_list
// file entrygroup.c line 363
static signed int append_string_list(struct DBusMessage *message, struct AvahiStringList *txt);
// append_string_list$link1
// file entrygroup.c line 363
static signed int append_string_list$link1(struct DBusMessage *message$link1, struct AvahiStringList *txt$link1);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// aui_service_dialog_class_init
// file avahi-ui.c line 171
static void aui_service_dialog_class_init(struct _AuiServiceDialogClass *klass);
// aui_service_dialog_class_intern_init
// file avahi-ui.c line 169
static void aui_service_dialog_class_intern_init(void *klass);
// aui_service_dialog_finalize
// file avahi-ui.c line 788
static void aui_service_dialog_finalize(struct _GObject *object);
// aui_service_dialog_get_address
// file avahi-ui.h line 128
const struct AvahiAddress * aui_service_dialog_get_address(struct _AuiServiceDialog *d);
// aui_service_dialog_get_address_family
// file avahi-ui.c line 1397
signed int aui_service_dialog_get_address_family(struct _AuiServiceDialog *d);
// aui_service_dialog_get_browse_service_types
// file avahi-ui.c line 1262
const char * const * aui_service_dialog_get_browse_service_types(struct _AuiServiceDialog *d);
// aui_service_dialog_get_domain
// file avahi-ui.c line 1306
const char * aui_service_dialog_get_domain(struct _AuiServiceDialog *d);
// aui_service_dialog_get_host_name
// file avahi-ui.h line 134
const char * aui_service_dialog_get_host_name(struct _AuiServiceDialog *d);
// aui_service_dialog_get_port
// file avahi-ui.h line 131
unsigned short int aui_service_dialog_get_port(struct _AuiServiceDialog *d);
// aui_service_dialog_get_property
// file avahi-ui.c line 1441
static void aui_service_dialog_get_property(struct _GObject *object, unsigned int prop_id, struct _GValue *value, struct _GParamSpec *pspec);
// aui_service_dialog_get_resolve_host_name
// file avahi-ui.c line 1384
signed int aui_service_dialog_get_resolve_host_name(struct _AuiServiceDialog *d);
// aui_service_dialog_get_resolve_service
// file avahi-ui.c line 1372
signed int aui_service_dialog_get_resolve_service(struct _AuiServiceDialog *d);
// aui_service_dialog_get_service_name
// file avahi-ui.h line 121
const char * aui_service_dialog_get_service_name(struct _AuiServiceDialog *d);
// aui_service_dialog_get_service_type
// file avahi-ui.h line 115
const char * aui_service_dialog_get_service_type(struct _AuiServiceDialog *d);
// aui_service_dialog_get_txt_data
// file avahi-ui.h line 137
const struct AvahiStringList * aui_service_dialog_get_txt_data(struct _AuiServiceDialog *d);
// aui_service_dialog_get_type
// file avahi-ui.h line 59
unsigned long int aui_service_dialog_get_type(void);
// aui_service_dialog_init
// file avahi-ui.c line 1080
static void aui_service_dialog_init(struct _AuiServiceDialog *d);
// aui_service_dialog_new
// file avahi-ui.h line 72
struct _GtkWidget * aui_service_dialog_new(const char *title, struct _GtkWindow *parent, const char *first_button_text, ...);
// aui_service_dialog_new_valist
// file avahi-ui.c line 248
struct _GtkWidget * aui_service_dialog_new_valist(const char *title, struct _GtkWindow *parent, const char *first_button_text, __builtin_va_list varargs);
// aui_service_dialog_set_address_family
// file avahi-ui.c line 1390
void aui_service_dialog_set_address_family(struct _AuiServiceDialog *d, signed int proto);
// aui_service_dialog_set_browse_service_types
// file avahi-ui.h line 90
void aui_service_dialog_set_browse_service_types(struct _AuiServiceDialog *d, const char *type, ...);
// aui_service_dialog_set_browse_service_typesv
// file avahi-ui.c line 1245
void aui_service_dialog_set_browse_service_typesv(struct _AuiServiceDialog *d, const char * const *types);
// aui_service_dialog_set_domain
// file avahi-ui.h line 103
void aui_service_dialog_set_domain(struct _AuiServiceDialog *d, const char *domain);
// aui_service_dialog_set_property
// file avahi-ui.c line 1403
static void aui_service_dialog_set_property(struct _GObject *object, unsigned int prop_id, const struct _GValue *value, struct _GParamSpec *pspec);
// aui_service_dialog_set_resolve_host_name
// file avahi-ui.h line 160
void aui_service_dialog_set_resolve_host_name(struct _AuiServiceDialog *d, signed int resolve);
// aui_service_dialog_set_resolve_service
// file avahi-ui.h line 149
void aui_service_dialog_set_resolve_service(struct _AuiServiceDialog *d, signed int resolve);
// aui_service_dialog_set_service_name
// file avahi-ui.c line 1312
void aui_service_dialog_set_service_name(struct _AuiServiceDialog *d, const char *name);
// aui_service_dialog_set_service_type
// file avahi-ui.c line 1325
void aui_service_dialog_set_service_type(struct _AuiServiceDialog *d, const char *stype);
// aui_service_dialog_set_service_type_name
// file avahi-ui.h line 96
void aui_service_dialog_set_service_type_name(struct _AuiServiceDialog *d, const char *type, const char *name);
// avahi_address_cmp
// file address.c line 46
signed int avahi_address_cmp(const struct AvahiAddress *a, const struct AvahiAddress *b);
// avahi_address_parse
// file ../avahi-common/address.h line 95
struct AvahiAddress * avahi_address_parse(const char *s, signed int proto, struct AvahiAddress *ret_addr);
// avahi_address_resolver_event
// file internal.h line 166
enum anonymous$42 avahi_address_resolver_event(struct AvahiClient *client, enum anonymous$12 event, struct DBusMessage *message);
// avahi_address_resolver_free
// file lookup.h line 269
signed int avahi_address_resolver_free(struct AvahiAddressResolver *r);
// avahi_address_resolver_get_client
// file resolver.c line 755
struct AvahiClient * avahi_address_resolver_get_client(struct AvahiAddressResolver *r);
// avahi_address_resolver_new
// file resolver.c line 642
struct AvahiAddressResolver * avahi_address_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const struct AvahiAddress *a, enum anonymous$44 flags, void (*callback)(struct AvahiAddressResolver *, signed int, signed int, enum anonymous$12, const struct AvahiAddress *, const char *, enum anonymous$13, void *), void *userdata);
// avahi_address_resolver_new::callback$link1$object
// 
//void callback$link1$object(struct AvahiAddressResolver *, signed int, signed int, enum anonymous$12, const struct AvahiAddress *, const char *, enum anonymous$13, void *);
// avahi_address_resolver_new::callback$object
// 
//void callback$object(struct AvahiAddressResolver *, signed int, signed int, enum anonymous$12, const struct AvahiAddress *, const char *, enum anonymous$13, void *);
// avahi_address_snprint
// file ../avahi-common/address.h line 90
char * avahi_address_snprint(char *s, unsigned long int length, const struct AvahiAddress *a);
// avahi_af_to_proto
// file address.c line 137
signed int avahi_af_to_proto(signed int af);
// avahi_age
// file timeval.c line 76
signed long int avahi_age(struct timeval *a);
// avahi_alternative_host_name
// file alternative.c line 51
char * avahi_alternative_host_name(const char *s);
// avahi_alternative_service_name
// file alternative.c line 117
char * avahi_alternative_service_name(const char *s);
// avahi_client_errno
// file client.c line 790
signed int avahi_client_errno(struct AvahiClient *client);
// avahi_client_free
// file client.c line 625
void avahi_client_free(struct AvahiClient *client);
// avahi_client_get_domain_name
// file client.c line 742
const char * avahi_client_get_domain_name(struct AvahiClient *client);
// avahi_client_get_host_name
// file client.c line 756
const char * avahi_client_get_host_name(struct AvahiClient *client);
// avahi_client_get_host_name_fqdn
// file client.c line 770
const char * avahi_client_get_host_name_fqdn(struct AvahiClient *client);
// avahi_client_get_local_service_cookie
// file client.c line 846
unsigned int avahi_client_get_local_service_cookie(struct AvahiClient *client);
// avahi_client_get_state
// file client.c line 784
enum anonymous$11 avahi_client_get_state(struct AvahiClient *client);
// avahi_client_get_string_reply_and_block
// file client.c line 672
static char * avahi_client_get_string_reply_and_block(struct AvahiClient *client, const char *method, const char *param);
// avahi_client_get_string_reply_and_block$link1
// file client.c line 672
static char * avahi_client_get_string_reply_and_block$link1(struct AvahiClient *client$link1, const char *method$link1, const char *param$link1);
// avahi_client_get_version_string
// file client.c line 728
const char * avahi_client_get_version_string(struct AvahiClient *client);
// avahi_client_is_connected
// file client.c line 896
signed int avahi_client_is_connected(struct AvahiClient *client);
// avahi_client_new
// file client.c line 478
struct AvahiClient * avahi_client_new(const struct AvahiPoll$1 *poll_api, enum anonymous$39 flags, void (*callback)(struct AvahiClient *, enum anonymous$11, void *), void *userdata, signed int *ret_error);
// avahi_client_new::callback$link1$object
// 
//void callback$link1$object(struct AvahiClient *, enum anonymous$11, void *);
// avahi_client_new::callback$object
// 
//void callback$object(struct AvahiClient *, enum anonymous$11, void *);
// avahi_client_set_dbus_error
// file client.c line 51
signed int avahi_client_set_dbus_error(struct AvahiClient *client, struct DBusError *error);
// avahi_client_set_errno
// file client.c line 45
signed int avahi_client_set_errno(struct AvahiClient *client, signed int error);
// avahi_client_set_host_name
// file client.c line 905
signed int avahi_client_set_host_name(struct AvahiClient *client, const char *name);
// avahi_client_simple_method_call
// file client.c line 797
signed int avahi_client_simple_method_call(struct AvahiClient *client, const char *path, const char *interface, const char *method);
// avahi_dbus_bus_get
// file client.c line 445
static struct DBusConnection * avahi_dbus_bus_get(struct DBusError *error);
// avahi_dbus_bus_get$link1
// file client.c line 445
static struct DBusConnection * avahi_dbus_bus_get$link1(struct DBusError *error$link1);
// avahi_dbus_connection_glue
// file ../avahi-common/dbus-watch-glue.h line 29
signed int avahi_dbus_connection_glue(struct DBusConnection *c, const struct AvahiPoll$1 *poll_api);
// avahi_domain_browser_event
// file internal.h line 159
enum anonymous$42 avahi_domain_browser_event(struct AvahiClient *client, enum anonymous$14 event, struct DBusMessage *message);
// avahi_domain_browser_free
// file lookup.h line 71
signed int avahi_domain_browser_free(struct AvahiDomainBrowser *b);
// avahi_domain_browser_get_client
// file browser.c line 234
struct AvahiClient * avahi_domain_browser_get_client(struct AvahiDomainBrowser *b);
// avahi_domain_browser_new
// file browser.c line 104
struct AvahiDomainBrowser * avahi_domain_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous$43 btype, enum anonymous$44 flags, void (*callback)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous$14, const char *, enum anonymous$13, void *), void *userdata);
// avahi_domain_browser_new::callback$link1$object
// 
//void callback$link1$object(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous$14, const char *, enum anonymous$13, void *);
// avahi_domain_browser_new::callback$object
// 
//void callback$object(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous$14, const char *, enum anonymous$13, void *);
// avahi_domain_equal
// file ../avahi-common/domain.h line 62
signed int avahi_domain_equal(const char *a, const char *b);
// avahi_domain_hash
// file domain.c line 424
unsigned int avahi_domain_hash(const char *s);
// avahi_elapse_time
// file ../avahi-common/timeval.h line 50
struct timeval * avahi_elapse_time(struct timeval *tv, unsigned int msec, unsigned int jitter);
// avahi_entry_group_add_address
// file entrygroup.c line 721
signed int avahi_entry_group_add_address(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$41 flags, const char *name, const struct AvahiAddress *a);
// avahi_entry_group_add_record
// file entrygroup.c line 808
signed int avahi_entry_group_add_record(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$41 flags, const char *name, unsigned short int clazz, unsigned short int type, unsigned int ttl, const void *rdata, unsigned long int size);
// avahi_entry_group_add_service
// file entrygroup.c line 496
signed int avahi_entry_group_add_service(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$41 flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, ...);
// avahi_entry_group_add_service_strlst
// file entrygroup.c line 402
signed int avahi_entry_group_add_service_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$41 flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, struct AvahiStringList *txt);
// avahi_entry_group_add_service_subtype
// file entrygroup.c line 522
signed int avahi_entry_group_add_service_subtype(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$41 flags, const char *name, const char *type, const char *domain, const char *subtype);
// avahi_entry_group_commit
// file entrygroup.c line 253
signed int avahi_entry_group_commit(struct AvahiEntryGroup *group);
// avahi_entry_group_free
// file publish.h line 60
signed int avahi_entry_group_free(struct AvahiEntryGroup *group);
// avahi_entry_group_get_client
// file entrygroup.c line 290
struct AvahiClient * avahi_entry_group_get_client(struct AvahiEntryGroup *group);
// avahi_entry_group_get_state
// file entrygroup.c line 281
signed int avahi_entry_group_get_state(struct AvahiEntryGroup *group);
// avahi_entry_group_is_empty
// file entrygroup.c line 296
signed int avahi_entry_group_is_empty(struct AvahiEntryGroup *group);
// avahi_entry_group_new
// file entrygroup.c line 101
struct AvahiEntryGroup * avahi_entry_group_new(struct AvahiClient *client, void (*callback)(struct AvahiEntryGroup *, enum anonymous$40, void *), void *userdata);
// avahi_entry_group_new::callback$link1$object
// 
//void callback$link1$object(struct AvahiEntryGroup *, enum anonymous$40, void *);
// avahi_entry_group_new::callback$object
// 
//void callback$object(struct AvahiEntryGroup *, enum anonymous$40, void *);
// avahi_entry_group_reset
// file entrygroup.c line 267
signed int avahi_entry_group_reset(struct AvahiEntryGroup *group);
// avahi_entry_group_set_state
// file internal.h line 157
void avahi_entry_group_set_state(struct AvahiEntryGroup *group, enum anonymous$40 state);
// avahi_entry_group_update_service_txt
// file entrygroup.c line 611
signed int avahi_entry_group_update_service_txt(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$41 flags, const char *name, const char *type, const char *domain, ...);
// avahi_entry_group_update_service_txt_strlst
// file entrygroup.c line 633
signed int avahi_entry_group_update_service_txt_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$41 flags, const char *name, const char *type, const char *domain, struct AvahiStringList *txt);
// avahi_error_dbus_to_number
// file ../avahi-common/dbus.h line 112
signed int avahi_error_dbus_to_number(const char *s);
// avahi_error_number_to_dbus
// file ../avahi-common/dbus.c line 133
const char * avahi_error_number_to_dbus(signed int error);
// avahi_escape_label
// file domain.c line 116
char * avahi_escape_label(const char *src, unsigned long int src_length, char **ret_name, unsigned long int *ret_size);
// avahi_free
// file ../avahi-common/malloc.h line 42
void avahi_free(void *p);
// avahi_get_type_from_subtype
// file domain.c line 306
const char * avahi_get_type_from_subtype(const char *t);
// avahi_glib_allocator
// file glib-malloc.c line 41
const struct AvahiAllocator * avahi_glib_allocator(void);
// avahi_glib_poll_free
// file glib-watch.c line 386
void avahi_glib_poll_free(struct AvahiGLibPoll *g);
// avahi_glib_poll_get
// file glib-watch.c line 398
const struct AvahiPoll * avahi_glib_poll_get(struct AvahiGLibPoll *g);
// avahi_glib_poll_new
// file glib-watch.c line 347
struct AvahiGLibPoll * avahi_glib_poll_new(struct _GMainContext *context, signed int priority);
// avahi_host_name_resolver_event
// file internal.h line 165
enum anonymous$42 avahi_host_name_resolver_event(struct AvahiClient *client, enum anonymous$12 event, struct DBusMessage *message);
// avahi_host_name_resolver_free
// file lookup.h line 239
signed int avahi_host_name_resolver_free(struct AvahiHostNameResolver *r);
// avahi_host_name_resolver_get_client
// file resolver.c line 558
struct AvahiClient * avahi_host_name_resolver_get_client(struct AvahiHostNameResolver *r);
// avahi_host_name_resolver_new
// file resolver.c line 424
struct AvahiHostNameResolver * avahi_host_name_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, signed int aprotocol, enum anonymous$44 flags, void (*callback)(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous$12, const char *, const struct AvahiAddress *, enum anonymous$13, void *), void *userdata);
// avahi_host_name_resolver_new::callback$link1$object
// 
//void callback$link1$object(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous$12, const char *, const struct AvahiAddress *, enum anonymous$13, void *);
// avahi_host_name_resolver_new::callback$object
// 
//void callback$object(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous$12, const char *, const struct AvahiAddress *, enum anonymous$13, void *);
// avahi_init_i18n
// file ../avahi-common/i18n.h line 51
void avahi_init_i18n(void);
// avahi_is_valid_domain_name
// file domain.c line 369
signed int avahi_is_valid_domain_name(const char *t);
// avahi_is_valid_fqdn
// file domain.c line 575
signed int avahi_is_valid_fqdn(const char *t);
// avahi_is_valid_host_name
// file domain.h line 103
signed int avahi_is_valid_host_name(const char *t);
// avahi_is_valid_service_name
// file domain.h line 100
signed int avahi_is_valid_service_name(const char *t);
// avahi_is_valid_service_subtype
// file domain.c line 363
signed int avahi_is_valid_service_subtype(const char *t);
// avahi_is_valid_service_type_generic
// file domain.c line 254
signed int avahi_is_valid_service_type_generic(const char *t);
// avahi_is_valid_service_type_strict
// file domain.c line 274
signed int avahi_is_valid_service_type_strict(const char *t);
// avahi_malloc
// file ../avahi-common/malloc.h line 36
void * avahi_malloc(unsigned long int size);
// avahi_malloc0
// file malloc.c line 113
void * avahi_malloc0(unsigned long int size);
// avahi_memdup
// file malloc.c line 248
void * avahi_memdup(const void *s, unsigned long int l);
// avahi_new_internal
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal(unsigned int n, unsigned long int k);
// avahi_new_internal$link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link1(unsigned int n$link1, unsigned long int k$link1);
// avahi_new_internal$link1$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link1$link1(unsigned int n$link1$link1, unsigned long int k$link1$link1);
// avahi_new_internal$link1$link1$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link1$link1$link1(unsigned int n$link1$link1$link1, unsigned long int k$link1$link1$link1);
// avahi_new_internal$link1$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link1$link2(unsigned int n$link1$link2, unsigned long int k$link1$link2);
// avahi_new_internal$link1$link2$link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link1$link2$link1(unsigned int n$link1$link2$link1, unsigned long int k$link1$link2$link1);
// avahi_new_internal$link1$link3
// file malloc.h line 48
static inline void * avahi_new_internal$link1$link3(unsigned int n$link1$link3, unsigned long int k$link1$link3);
// avahi_new_internal$link1$link4
// file malloc.h line 48
static inline void * avahi_new_internal$link1$link4(unsigned int n$link1$link4, unsigned long int k$link1$link4);
// avahi_new_internal$link2
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link2(unsigned int n$link2, unsigned long int k$link2);
// avahi_new_internal$link2$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link2$link1(unsigned int n$link2$link1, unsigned long int k$link2$link1);
// avahi_new_internal$link2$link1$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link2$link1$link1(unsigned int n$link2$link1$link1, unsigned long int k$link2$link1$link1);
// avahi_new_internal$link2$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link2$link2(unsigned int n$link2$link2, unsigned long int k$link2$link2);
// avahi_new_internal$link2$link2$link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link2$link2$link1(unsigned int n$link2$link2$link1, unsigned long int k$link2$link2$link1);
// avahi_new_internal$link2$link3
// file malloc.h line 48
static inline void * avahi_new_internal$link2$link3(unsigned int n$link2$link3, unsigned long int k$link2$link3);
// avahi_new_internal$link2$link4
// file malloc.h line 48
static inline void * avahi_new_internal$link2$link4(unsigned int n$link2$link4, unsigned long int k$link2$link4);
// avahi_new_internal$link3
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link3(unsigned int n$link3, unsigned long int k$link3);
// avahi_new_internal$link3$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link3$link1(unsigned int n$link3$link1, unsigned long int k$link3$link1);
// avahi_new_internal$link3$link1$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link3$link1$link1(unsigned int n$link3$link1$link1, unsigned long int k$link3$link1$link1);
// avahi_new_internal$link3$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link3$link2(unsigned int n$link3$link2, unsigned long int k$link3$link2);
// avahi_new_internal$link3$link2$link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link3$link2$link1(unsigned int n$link3$link2$link1, unsigned long int k$link3$link2$link1);
// avahi_new_internal$link3$link3
// file malloc.h line 48
static inline void * avahi_new_internal$link3$link3(unsigned int n$link3$link3, unsigned long int k$link3$link3);
// avahi_new_internal$link3$link4
// file malloc.h line 48
static inline void * avahi_new_internal$link3$link4(unsigned int n$link3$link4, unsigned long int k$link3$link4);
// avahi_new_internal$link4
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link4(unsigned int n$link4, unsigned long int k$link4);
// avahi_new_internal$link4$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link4$link1(unsigned int n$link4$link1, unsigned long int k$link4$link1);
// avahi_new_internal$link4$link1$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link4$link1$link1(unsigned int n$link4$link1$link1, unsigned long int k$link4$link1$link1);
// avahi_new_internal$link4$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link4$link2(unsigned int n$link4$link2, unsigned long int k$link4$link2);
// avahi_new_internal$link4$link2$link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link4$link2$link1(unsigned int n$link4$link2$link1, unsigned long int k$link4$link2$link1);
// avahi_new_internal$link4$link3
// file malloc.h line 48
static inline void * avahi_new_internal$link4$link3(unsigned int n$link4$link3, unsigned long int k$link4$link3);
// avahi_new_internal$link4$link4
// file malloc.h line 48
static inline void * avahi_new_internal$link4$link4(unsigned int n$link4$link4, unsigned long int k$link4$link4);
// avahi_new_internal$link5
// file malloc.h line 48
static inline void * avahi_new_internal$link5(unsigned int n$link5, unsigned long int k$link5);
// avahi_new_internal$link5$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link5$link1(unsigned int n$link5$link1, unsigned long int k$link5$link1);
// avahi_new_internal$link5$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link5$link2(unsigned int n$link5$link2, unsigned long int k$link5$link2);
// avahi_new_internal$link6
// file malloc.h line 48
static inline void * avahi_new_internal$link6(unsigned int n$link6, unsigned long int k$link6);
// avahi_new_internal$link6$link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link6$link1(unsigned int n$link6$link1, unsigned long int k$link6$link1);
// avahi_new_internal$link7
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link7(unsigned int n$link7, unsigned long int k$link7);
// avahi_new_internal$link8
// file malloc.h line 48
static inline void * avahi_new_internal$link8(unsigned int n$link8, unsigned long int k$link8);
// avahi_normalize_name
// file ../avahi-common/domain.h line 50
char * avahi_normalize_name(const char *s, char *ret_s, unsigned long int size);
// avahi_normalize_name_strdup
// file domain.c line 219
char * avahi_normalize_name_strdup(const char *s);
// avahi_nss_support
// file ../avahi-client/client.h line 111
signed int avahi_nss_support(void);
// avahi_proto_to_af
// file address.c line 127
signed int avahi_proto_to_af(signed int proto);
// avahi_proto_to_string
// file address.c line 147
const char * avahi_proto_to_string(signed int proto);
// avahi_realloc
// file malloc.c line 146
void * avahi_realloc(void *p, unsigned long int size);
// avahi_record_browser_event
// file internal.h line 162
enum anonymous$42 avahi_record_browser_event(struct AvahiClient *client, enum anonymous$14 event, struct DBusMessage *message);
// avahi_record_browser_free
// file lookup.h line 308
signed int avahi_record_browser_free(struct AvahiRecordBrowser *b);
// avahi_record_browser_get_client
// file browser.c line 903
struct AvahiClient * avahi_record_browser_get_client(struct AvahiRecordBrowser *b);
// avahi_record_browser_new
// file browser.c line 786
struct AvahiRecordBrowser * avahi_record_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, unsigned short int clazz, unsigned short int type, enum anonymous$44 flags, void (*callback)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous$14, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous$13, void *), void *userdata);
// avahi_record_browser_new::callback$link1$object
// 
//void callback$link1$object(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous$14, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous$13, void *);
// avahi_record_browser_new::callback$object
// 
//void callback$object(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous$14, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous$13, void *);
// avahi_reverse_lookup_name
// file address.c line 67
char * avahi_reverse_lookup_name(const struct AvahiAddress *a, char *ret_s, unsigned long int length);
// avahi_rlist_prepend
// file rlist.c line 29
struct AvahiRList * avahi_rlist_prepend(struct AvahiRList *r, void *data);
// avahi_rlist_remove
// file rlist.c line 41
struct AvahiRList * avahi_rlist_remove(struct AvahiRList *r, void *data);
// avahi_rlist_remove_by_link
// file rlist.c line 55
struct AvahiRList * avahi_rlist_remove_by_link(struct AvahiRList *r, struct AvahiRList *n);
// avahi_service_browser_event
// file internal.h line 161
enum anonymous$42 avahi_service_browser_event(struct AvahiClient *client, enum anonymous$14 event, struct DBusMessage *message);
// avahi_service_browser_free
// file lookup.h line 117
signed int avahi_service_browser_free(struct AvahiServiceBrowser *b);
// avahi_service_browser_get_client
// file browser.c line 686
struct AvahiClient * avahi_service_browser_get_client(struct AvahiServiceBrowser *b);
// avahi_service_browser_new
// file browser.c line 564
struct AvahiServiceBrowser * avahi_service_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *type, const char *domain, enum anonymous$44 flags, void (*callback)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous$14, const char *, const char *, const char *, enum anonymous$13, void *), void *userdata);
// avahi_service_browser_new::callback$link1$object
// 
//void callback$link1$object(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous$14, const char *, const char *, const char *, enum anonymous$13, void *);
// avahi_service_browser_new::callback$object
// 
//void callback$object(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous$14, const char *, const char *, const char *, enum anonymous$13, void *);
// avahi_service_name_join
// file domain.c line 440
signed int avahi_service_name_join(char *p, unsigned long int size, const char *name, const char *type, const char *domain);
// avahi_service_name_split
// file domain.c line 496
signed int avahi_service_name_split(const char *p, char *name, unsigned long int name_size, char *type, unsigned long int type_size, char *domain, unsigned long int domain_size);
// avahi_service_resolver_event
// file internal.h line 164
enum anonymous$42 avahi_service_resolver_event(struct AvahiClient *client, enum anonymous$12 event, struct DBusMessage *message);
// avahi_service_resolver_free
// file lookup.h line 205
signed int avahi_service_resolver_free(struct AvahiServiceResolver *r);
// avahi_service_resolver_get_client
// file resolver.c line 318
struct AvahiClient * avahi_service_resolver_get_client(struct AvahiServiceResolver *r);
// avahi_service_resolver_new
// file resolver.c line 179
struct AvahiServiceResolver * avahi_service_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, const char *type, const char *domain, signed int aprotocol, enum anonymous$44 flags, void (*callback)(struct AvahiServiceResolver *, signed int, signed int, enum anonymous$12, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous$13, void *), void *userdata);
// avahi_service_resolver_new::callback$link1$object
// 
//void callback$link1$object(struct AvahiServiceResolver *, signed int, signed int, enum anonymous$12, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous$13, void *);
// avahi_service_resolver_new::callback$object
// 
//void callback$object(struct AvahiServiceResolver *, signed int, signed int, enum anonymous$12, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous$13, void *);
// avahi_service_type_browser_event
// file internal.h line 160
enum anonymous$42 avahi_service_type_browser_event(struct AvahiClient *client, enum anonymous$14 event, struct DBusMessage *message);
// avahi_service_type_browser_free
// file lookup.h line 150
signed int avahi_service_type_browser_free(struct AvahiServiceTypeBrowser *b);
// avahi_service_type_browser_get_client
// file browser.c line 465
struct AvahiClient * avahi_service_type_browser_get_client(struct AvahiServiceTypeBrowser *b);
// avahi_service_type_browser_new
// file browser.c line 350
struct AvahiServiceTypeBrowser * avahi_service_type_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous$44 flags, void (*callback)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous$14, const char *, const char *, enum anonymous$13, void *), void *userdata);
// avahi_service_type_browser_new::callback$link1$object
// 
//void callback$link1$object(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous$14, const char *, const char *, enum anonymous$13, void *);
// avahi_service_type_browser_new::callback$object
// 
//void callback$object(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous$14, const char *, const char *, enum anonymous$13, void *);
// avahi_set_allocator
// file malloc.c line 196
void avahi_set_allocator(const struct AvahiAllocator *a);
// avahi_simple_poll_dispatch
// file simple-watch.c line 547
signed int avahi_simple_poll_dispatch(struct AvahiSimplePoll$0 *s);
// avahi_simple_poll_free
// file simple-watch.c line 367
void avahi_simple_poll_free(struct AvahiSimplePoll$0 *s);
// avahi_simple_poll_get
// file simple-watch.c line 620
const struct AvahiPoll$1 * avahi_simple_poll_get(struct AvahiSimplePoll$0 *s);
// avahi_simple_poll_iterate
// file simple-watch.c line 596
signed int avahi_simple_poll_iterate(struct AvahiSimplePoll$0 *s, signed int timeout);
// avahi_simple_poll_loop
// file simple-watch.c line 640
signed int avahi_simple_poll_loop(struct AvahiSimplePoll$0 *s);
// avahi_simple_poll_new
// file simple-watch.c line 318
struct AvahiSimplePoll$0 * avahi_simple_poll_new(void);
// avahi_simple_poll_prepare
// file simple-watch.c line 450
signed int avahi_simple_poll_prepare(struct AvahiSimplePoll$0 *s, signed int timeout);
// avahi_simple_poll_quit
// file simple-watch.c line 611
void avahi_simple_poll_quit(struct AvahiSimplePoll$0 *s);
// avahi_simple_poll_run
// file simple-watch.c line 518
signed int avahi_simple_poll_run(struct AvahiSimplePoll$0 *s);
// avahi_simple_poll_set_func
// file simple-watch.c line 630
void avahi_simple_poll_set_func(struct AvahiSimplePoll$0 *s, signed int (*func)(struct pollfd *, unsigned int, signed int, void *), void *userdata);
// avahi_simple_poll_set_func::func$link1$link1$object
// 
signed int func$link1$link1$object(struct pollfd *, unsigned int, signed int, void *);
// avahi_simple_poll_set_func::func$link1$object
// 
signed int func$link1$object(struct pollfd *, unsigned int, signed int, void *);
// avahi_simple_poll_set_func::func$link2$object
// 
signed int func$link2$object(struct pollfd *, unsigned int, signed int, void *);
// avahi_simple_poll_set_func::func$link3$object
// 
signed int func$link3$object(struct pollfd *, unsigned int, signed int, void *);
// avahi_simple_poll_set_func::func$object
// 
signed int func$object(struct pollfd *, unsigned int, signed int, void *);
// avahi_simple_poll_wakeup
// file simple-watch.c line 97
void avahi_simple_poll_wakeup(struct AvahiSimplePoll$0 *s);
// avahi_strdup
// file ../avahi-common/malloc.h line 66
char * avahi_strdup(const char *s);
// avahi_strdup_printf
// file malloc.c line 235
char * avahi_strdup_printf(const char *fmt, ...);
// avahi_strdup_vprintf
// file malloc.c line 200
char * avahi_strdup_vprintf(const char *fmt, void **ap);
// avahi_strerror
// file error.c line 27
const char * avahi_strerror(signed int error);
// avahi_string_list_add
// file ../avahi-common/strlst.h line 73
struct AvahiStringList * avahi_string_list_add(struct AvahiStringList *l, const char *text);
// avahi_string_list_add_anonymous
// file strlst.c line 34
struct AvahiStringList * avahi_string_list_add_anonymous(struct AvahiStringList *l, unsigned long int size);
// avahi_string_list_add_arbitrary
// file ../avahi-common/strlst.h line 85
struct AvahiStringList * avahi_string_list_add_arbitrary(struct AvahiStringList *l, const unsigned char *text, unsigned long int size);
// avahi_string_list_add_many
// file strlst.c line 255
struct AvahiStringList * avahi_string_list_add_many(struct AvahiStringList *r, ...);
// avahi_string_list_add_many_va
// file strlst.c line 265
struct AvahiStringList * avahi_string_list_add_many_va(struct AvahiStringList *r, __builtin_va_list va);
// avahi_string_list_add_pair
// file strlst.c line 395
struct AvahiStringList * avahi_string_list_add_pair(struct AvahiStringList *l, const char *key, const char *value);
// avahi_string_list_add_pair_arbitrary
// file strlst.c line 404
struct AvahiStringList * avahi_string_list_add_pair_arbitrary(struct AvahiStringList *l, const char *key, const unsigned char *value, unsigned long int size);
// avahi_string_list_add_printf
// file strlst.c line 366
struct AvahiStringList * avahi_string_list_add_printf(struct AvahiStringList *l, const char *format, ...);
// avahi_string_list_add_vprintf
// file strlst.c line 326
struct AvahiStringList * avahi_string_list_add_vprintf(struct AvahiStringList *l, const char *format, void **va);
// avahi_string_list_copy
// file strlst.c line 293
struct AvahiStringList * avahi_string_list_copy(const struct AvahiStringList *l);
// avahi_string_list_equal
// file strlst.c line 235
signed int avahi_string_list_equal(const struct AvahiStringList *a, const struct AvahiStringList *b);
// avahi_string_list_find
// file strlst.c line 378
struct AvahiStringList * avahi_string_list_find(struct AvahiStringList *l, const char *key);
// avahi_string_list_free
// file ../avahi-common/strlst.h line 64
void avahi_string_list_free(struct AvahiStringList *l);
// avahi_string_list_get_next
// file strlst.c line 469
struct AvahiStringList * avahi_string_list_get_next(struct AvahiStringList *l);
// avahi_string_list_get_pair
// file ../avahi-common/strlst.h line 160
signed int avahi_string_list_get_pair(struct AvahiStringList *l, char **key, char **value, unsigned long int *size);
// avahi_string_list_get_service_cookie
// file strlst.c line 484
unsigned int avahi_string_list_get_service_cookie(struct AvahiStringList *l);
// avahi_string_list_get_size
// file strlst.c line 479
unsigned long int avahi_string_list_get_size(struct AvahiStringList *l);
// avahi_string_list_get_text
// file strlst.c line 474
unsigned char * avahi_string_list_get_text(struct AvahiStringList *l);
// avahi_string_list_length
// file strlst.c line 317
unsigned int avahi_string_list_length(const struct AvahiStringList *l);
// avahi_string_list_new
// file strlst.c line 274
struct AvahiStringList * avahi_string_list_new(const char *txt, ...);
// avahi_string_list_new_from_array
// file strlst.c line 305
struct AvahiStringList * avahi_string_list_new_from_array(const char **array, signed int length);
// avahi_string_list_new_va
// file ../avahi-common/strlst.h line 55
struct AvahiStringList * avahi_string_list_new_va(void **va);
// avahi_string_list_parse
// file strlst.c line 69
signed int avahi_string_list_parse(const void *data, unsigned long int size, struct AvahiStringList **ret);
// avahi_string_list_reverse
// file ../avahi-common/strlst.h line 130
struct AvahiStringList * avahi_string_list_reverse(struct AvahiStringList *l);
// avahi_string_list_serialize
// file strlst.c line 168
unsigned long int avahi_string_list_serialize(struct AvahiStringList *l, void *data, unsigned long int size);
// avahi_string_list_to_string
// file strlst.c line 131
char * avahi_string_list_to_string(struct AvahiStringList *l);
// avahi_strndup
// file malloc.c line 175
char * avahi_strndup(const char *s, unsigned long int max);
// avahi_threaded_poll_free
// file thread-watch.c line 107
void avahi_threaded_poll_free(struct AvahiThreadedPoll$0 *p);
// avahi_threaded_poll_get
// file thread-watch.c line 123
const struct AvahiPoll$1 * avahi_threaded_poll_get(struct AvahiThreadedPoll$0 *p);
// avahi_threaded_poll_lock
// file thread-watch.c line 170
void avahi_threaded_poll_lock(struct AvahiThreadedPoll$0 *p);
// avahi_threaded_poll_new
// file thread-watch.c line 77
struct AvahiThreadedPoll$0 * avahi_threaded_poll_new(void);
// avahi_threaded_poll_quit
// file thread-watch.c line 161
void avahi_threaded_poll_quit(struct AvahiThreadedPoll$0 *p);
// avahi_threaded_poll_start
// file thread-watch.c line 129
signed int avahi_threaded_poll_start(struct AvahiThreadedPoll$0 *p);
// avahi_threaded_poll_stop
// file thread-watch.c line 142
signed int avahi_threaded_poll_stop(struct AvahiThreadedPoll$0 *p);
// avahi_threaded_poll_unlock
// file thread-watch.c line 179
void avahi_threaded_poll_unlock(struct AvahiThreadedPoll$0 *p);
// avahi_timeval_add
// file timeval.c line 59
struct timeval * avahi_timeval_add(struct timeval *a, signed long int usec);
// avahi_timeval_compare
// file timeval.c line 30
signed int avahi_timeval_compare(struct timeval *a, struct timeval *b);
// avahi_timeval_diff
// file timeval.c line 49
signed long int avahi_timeval_diff(struct timeval *a, struct timeval *b);
// avahi_unescape_label
// file domain.c line 41
char * avahi_unescape_label(const char **name, char *dest, unsigned long int size);
// avahi_utf8_valid
// file utf8.h line 29
const char * avahi_utf8_valid(const char *str);
// avahi_xdg_config_open
// file xdg-config.h line 25
struct _IO_FILE * avahi_xdg_config_open(const char *filename);
// bind_textdomain_codeset
// file /usr/include/libintl.h line 91
extern char * bind_textdomain_codeset(const char *, const char *);
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// browse_callback
// file avahi-ui.c line 400
static void browse_callback(struct AvahiServiceBrowser *b, signed int interface, signed int protocol, enum anonymous$14 event, const char *name, const char *type, const char *domain, enum anonymous$13 flags, void *userdata);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// calloc_glue
// file glib-malloc.c line 37
static void * calloc_glue(unsigned long int nmemb, unsigned long int size);
// check_func
// file glib-watch.c line 291
static signed int check_func(struct _GSource *source);
// check_version
// file client.c line 351
static signed int check_version(struct AvahiClient *client, signed int *ret_error);
// check_version$link1
// file client.c line 351
static signed int check_version$link1(struct AvahiClient *client$link1, signed int *ret_error$link1);
// cleanup_timeouts
// file simple-watch.c line 304
static void cleanup_timeouts(struct AvahiSimplePoll$0 *s, signed int all);
// cleanup_timeouts$link1
// file simple-watch.c line 304
static void cleanup_timeouts$link1(struct AvahiSimplePoll$0 *s$link1, signed int all$link1);
// cleanup_timeouts$link1$link1
// file simple-watch.c line 304
static void cleanup_timeouts$link1$link1(struct AvahiSimplePoll *s$link2, signed int all$link1$link1);
// cleanup_timeouts$link1$link2
// file simple-watch.c line 304
static void cleanup_timeouts$link1$link2(struct AvahiSimplePoll$0 *s$link1$link1, signed int all$link1$link2);
// cleanup_timeouts$link2
// file glib-watch.c line 216
static void cleanup_timeouts$link2(struct AvahiGLibPoll *g, signed int all$link2);
// cleanup_timeouts$link3
// file simple-watch.c line 304
static void cleanup_timeouts$link3(struct AvahiSimplePoll$0 *s$link3, signed int all$link3);
// cleanup_watches
// file simple-watch.c line 230
static void cleanup_watches(struct AvahiSimplePoll$0 *s, signed int all);
// cleanup_watches$link1
// file simple-watch.c line 230
static void cleanup_watches$link1(struct AvahiSimplePoll$0 *s$link1, signed int all$link1);
// cleanup_watches$link1$link1
// file simple-watch.c line 230
static void cleanup_watches$link1$link1(struct AvahiSimplePoll *s$link2, signed int all$link1$link1);
// cleanup_watches$link1$link2
// file simple-watch.c line 230
static void cleanup_watches$link1$link2(struct AvahiSimplePoll$0 *s$link1$link1, signed int all$link1$link2);
// cleanup_watches$link2
// file glib-watch.c line 79
static void cleanup_watches$link2(struct AvahiGLibPoll *g, signed int all$link2);
// cleanup_watches$link3
// file simple-watch.c line 230
static void cleanup_watches$link3(struct AvahiSimplePoll$0 *s$link3, signed int all$link3);
// clear_wakeup
// file simple-watch.c line 105
static void clear_wakeup(struct AvahiSimplePoll$0 *s);
// clear_wakeup$link1
// file simple-watch.c line 105
static void clear_wakeup$link1(struct AvahiSimplePoll$0 *s$link1);
// clear_wakeup$link1$link1
// file simple-watch.c line 105
static void clear_wakeup$link1$link1(struct AvahiSimplePoll$0 *s$link1$link1);
// clear_wakeup$link2
// file simple-watch.c line 105
static void clear_wakeup$link2(struct AvahiSimplePoll *s$link2);
// clear_wakeup$link3
// file simple-watch.c line 105
static void clear_wakeup$link3(struct AvahiSimplePoll$0 *s$link3);
// client_callback
// file avahi-ui.c line 318
static void client_callback(struct AvahiClient *c, enum anonymous$11 state, void *userdata);
// client_set_state
// file client.c line 58
static void client_set_state(struct AvahiClient *client, enum anonymous$11 state);
// client_set_state$link1
// file client.c line 58
static void client_set_state$link1(struct AvahiClient *client$link1, enum anonymous$11 state$link1);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connection_data_ref
// file ../avahi-common/dbus-watch-glue.c line 68
static struct anonymous$28 * connection_data_ref(struct anonymous$28 *d);
// connection_data_ref$link1
// file ../avahi-common/dbus-watch-glue.c line 68
static struct anonymous$28 * connection_data_ref$link1(struct anonymous$28 *d$link1);
// connection_data_unref
// file ../avahi-common/dbus-watch-glue.c line 76
static void connection_data_unref(struct anonymous$28 *d);
// connection_data_unref$link1
// file ../avahi-common/dbus-watch-glue.c line 76
static void connection_data_unref$link1(struct anonymous$28 *d$link1);
// dbus_bus_add_match
// file /usr/include/dbus-1.0/dbus/dbus-bus.h line 83
void dbus_bus_add_match(struct DBusConnection *, const char *, struct DBusError *);
// dbus_bus_get_private
// file /usr/include/dbus-1.0/dbus/dbus-bus.h line 43
struct DBusConnection * dbus_bus_get_private(enum anonymous$45, struct DBusError *);
// dbus_connection_add_filter
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 295
unsigned int dbus_connection_add_filter(struct DBusConnection *, enum anonymous$42 (*)(struct DBusConnection *, struct DBusMessage *, void *), void *, void (*)(void *));
// dbus_connection_close
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 183
void dbus_connection_close(struct DBusConnection *);
// dbus_connection_dispatch
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 220
enum anonymous$27 dbus_connection_dispatch(struct DBusConnection *);
// dbus_connection_get_dispatch_status
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 218
enum anonymous$27 dbus_connection_get_dispatch_status(struct DBusConnection *);
// dbus_connection_get_is_connected
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 185
unsigned int dbus_connection_get_is_connected(struct DBusConnection *);
// dbus_connection_ref
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 179
struct DBusConnection * dbus_connection_ref(struct DBusConnection *);
// dbus_connection_send_with_reply_and_block
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 233
struct DBusMessage * dbus_connection_send_with_reply_and_block(struct DBusConnection *, struct DBusMessage *, signed int, struct DBusError *);
// dbus_connection_set_dispatch_status_function
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 257
void dbus_connection_set_dispatch_status_function(struct DBusConnection *, void (*)(struct DBusConnection *, enum anonymous$27, void *), void *, void (*)(void *));
// dbus_connection_set_exit_on_disconnect
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 197
void dbus_connection_set_exit_on_disconnect(struct DBusConnection *, unsigned int);
// dbus_connection_set_timeout_functions
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 245
unsigned int dbus_connection_set_timeout_functions(struct DBusConnection *, unsigned int (*)(struct DBusTimeout *, void *), void (*)(struct DBusTimeout *, void *), void (*)(struct DBusTimeout *, void *), void *, void (*)(void *));
// dbus_connection_set_watch_functions
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 238
unsigned int dbus_connection_set_watch_functions(struct DBusConnection *, unsigned int (*)(struct DBusWatch *, void *), void (*)(struct DBusWatch *, void *), void (*)(struct DBusWatch *, void *), void *, void (*)(void *));
// dbus_connection_unref
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 181
void dbus_connection_unref(struct DBusConnection *);
// dbus_error_free
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 67
void dbus_error_free(struct DBusError *);
// dbus_error_init
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 65
void dbus_error_init(struct DBusError *);
// dbus_error_is_set
// file /usr/include/dbus-1.0/dbus/dbus-errors.h line 84
unsigned int dbus_error_is_set(const struct DBusError *);
// dbus_message_append_args
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 189
unsigned int dbus_message_append_args(struct DBusMessage *, signed int, ...);
// dbus_message_get_args
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 197
unsigned int dbus_message_get_args(struct DBusMessage *, struct DBusError *, signed int, ...);
// dbus_message_get_interface
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 113
const char * dbus_message_get_interface(struct DBusMessage *);
// dbus_message_get_member
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 121
const char * dbus_message_get_member(struct DBusMessage *);
// dbus_message_get_path
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 105
const char * dbus_message_get_path(struct DBusMessage *);
// dbus_message_is_signal
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 152
unsigned int dbus_message_is_signal(struct DBusMessage *, const char *, const char *);
// dbus_message_iter_append_fixed_array
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 253
unsigned int dbus_message_iter_append_fixed_array(struct DBusMessageIter *, signed int, const void *, signed int);
// dbus_message_iter_close_container
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 263
unsigned int dbus_message_iter_close_container(struct DBusMessageIter *, struct DBusMessageIter *);
// dbus_message_iter_get_arg_type
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 220
signed int dbus_message_iter_get_arg_type(struct DBusMessageIter *);
// dbus_message_iter_get_basic
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 227
void dbus_message_iter_get_basic(struct DBusMessageIter *, void *);
// dbus_message_iter_get_element_type
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 222
signed int dbus_message_iter_get_element_type(struct DBusMessageIter *);
// dbus_message_iter_get_fixed_array
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 240
void dbus_message_iter_get_fixed_array(struct DBusMessageIter *, void *, signed int *);
// dbus_message_iter_init
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 211
unsigned int dbus_message_iter_init(struct DBusMessage *, struct DBusMessageIter *);
// dbus_message_iter_init_append
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 246
void dbus_message_iter_init_append(struct DBusMessage *, struct DBusMessageIter *);
// dbus_message_iter_next
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 216
unsigned int dbus_message_iter_next(struct DBusMessageIter *);
// dbus_message_iter_open_container
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 258
unsigned int dbus_message_iter_open_container(struct DBusMessageIter *, signed int, const char *, struct DBusMessageIter *);
// dbus_message_iter_recurse
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 224
void dbus_message_iter_recurse(struct DBusMessageIter *, struct DBusMessageIter *);
// dbus_message_new_method_call
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 72
struct DBusMessage * dbus_message_new_method_call(const char *, const char *, const char *, const char *);
// dbus_message_unref
// file /usr/include/dbus-1.0/dbus/dbus-message.h line 98
void dbus_message_unref(struct DBusMessage *);
// dbus_timeout_get_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 482
void * dbus_timeout_get_data(struct DBusTimeout *);
// dbus_timeout_get_enabled
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 490
unsigned int dbus_timeout_get_enabled(struct DBusTimeout *);
// dbus_timeout_get_interval
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 480
signed int dbus_timeout_get_interval(struct DBusTimeout *);
// dbus_timeout_handle
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 488
unsigned int dbus_timeout_handle(struct DBusTimeout *);
// dbus_timeout_set_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 484
void dbus_timeout_set_data(struct DBusTimeout *, void *, void (*)(void *));
// dbus_watch_get_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 461
void * dbus_watch_get_data(struct DBusWatch *);
// dbus_watch_get_enabled
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 470
unsigned int dbus_watch_get_enabled(struct DBusWatch *);
// dbus_watch_get_flags
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 459
unsigned int dbus_watch_get_flags(struct DBusWatch *);
// dbus_watch_get_unix_fd
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 455
signed int dbus_watch_get_unix_fd(struct DBusWatch *);
// dbus_watch_handle
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 467
unsigned int dbus_watch_handle(struct DBusWatch *, unsigned int);
// dbus_watch_set_data
// file /usr/include/dbus-1.0/dbus/dbus-connection.h line 463
void dbus_watch_set_data(struct DBusWatch *, void *, void (*)(void *));
// defer_timeout_callback
// file browser.c line 83
static void defer_timeout_callback(struct AvahiTimeout$1 *t, void *userdata);
// defer_timeout_callback$link1
// file browser.c line 83
static void defer_timeout_callback$link1(struct AvahiTimeout$1 *t$link1, void *userdata$link1);
// destroy_timeout
// file simple-watch.c line 296
static void destroy_timeout(struct AvahiTimeout$1 *t);
// destroy_timeout$link1
// file simple-watch.c line 296
static void destroy_timeout$link1(struct AvahiTimeout$1 *t$link1);
// destroy_timeout$link1$link1
// file simple-watch.c line 296
static void destroy_timeout$link1$link1(struct AvahiTimeout$0 *t$link1$link1);
// destroy_timeout$link1$link2
// file simple-watch.c line 296
static void destroy_timeout$link1$link2(struct AvahiTimeout$1 *t$link1$link2);
// destroy_timeout$link2
// file glib-watch.c line 209
static void destroy_timeout$link2(struct AvahiTimeout *t$link2);
// destroy_timeout$link3
// file simple-watch.c line 296
static void destroy_timeout$link3(struct AvahiTimeout$1 *t$link3);
// destroy_watch
// file simple-watch.c line 218
static void destroy_watch(struct AvahiWatch$1 *w);
// destroy_watch$link1
// file simple-watch.c line 218
static void destroy_watch$link1(struct AvahiWatch$1 *w$link1);
// destroy_watch$link1$link1
// file simple-watch.c line 218
static void destroy_watch$link1$link1(struct AvahiWatch *w$link1$link1);
// destroy_watch$link1$link2
// file simple-watch.c line 218
static void destroy_watch$link1$link2(struct AvahiWatch$1 *w$link1$link2);
// destroy_watch$link2
// file glib-watch.c line 68
static void destroy_watch$link2(struct AvahiWatch$0 *w$link2);
// destroy_watch$link3
// file simple-watch.c line 218
static void destroy_watch$link3(struct AvahiWatch$1 *w$link3);
// dgettext
// file /usr/include/libintl.h line 44
extern char * dgettext(const char *, const char *);
// dispatch_func
// file glib-watch.c line 316
static signed int dispatch_func(struct _GSource *source, signed int (*callback)(void *), void *userdata);
// dispatch_func::callback$object
// 
signed int callback$object(void *);
// dispatch_status
// file ../avahi-common/dbus-watch-glue.c line 310
static void dispatch_status(struct DBusConnection *connection, enum anonymous$27 new_status, void *userdata);
// dispatch_status$link1
// file ../avahi-common/dbus-watch-glue.c line 310
static void dispatch_status$link1(struct DBusConnection *connection$link1, enum anonymous$27 new_status$link1, void *userdata$link1);
// dispatch_timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 97
static void dispatch_timeout_callback(struct AvahiTimeout$1 *t, void *userdata);
// dispatch_timeout_callback$link1
// file ../avahi-common/dbus-watch-glue.c line 97
static void dispatch_timeout_callback$link1(struct AvahiTimeout$1 *t$link1, void *userdata$link1);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// domain_browse_callback
// file avahi-ui.c line 559
static void domain_browse_callback(struct AvahiDomainBrowser *b, signed int interface, signed int protocol, enum anonymous$14 event, const char *name, enum anonymous$13 flags, void *userdata);
// domain_browser_ref
// file browser.c line 77
static void domain_browser_ref(struct AvahiDomainBrowser *db);
// domain_browser_ref$link1
// file browser.c line 77
static void domain_browser_ref$link1(struct AvahiDomainBrowser *db$link1);
// domain_button_clicked
// file avahi-ui.c line 959
static void domain_button_clicked(struct _GtkButton *button, void *user_data);
// domain_entry_changed_callback
// file avahi-ui.c line 953
static void domain_entry_changed_callback(struct _GtkEditable *editable, void *user_data);
// domain_make_default_selection
// file avahi-ui.c line 540
static void domain_make_default_selection(struct _AuiServiceDialog *d, const char *name, struct _GtkTreeIter *iter);
// domain_pulse_callback
// file avahi-ui.c line 311
static signed int domain_pulse_callback(void *data);
// domain_row_activated_callback
// file avahi-ui.c line 933
static void domain_row_activated_callback(struct _GtkTreeView *tree_view, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data);
// domain_selection_changed_callback
// file avahi-ui.c line 940
static void domain_selection_changed_callback(struct _GtkTreeSelection *selection, void *user_data);
// drop_incomplete_utf8
// file alternative.c line 34
static void drop_incomplete_utf8(char *c);
// drop_incomplete_utf8$link1
// file alternative.c line 34
static void drop_incomplete_utf8$link1(char *c$link1);
// drop_incomplete_utf8$link1$link1
// file alternative.c line 34
static void drop_incomplete_utf8$link1$link1(char *c$link1$link1);
// drop_incomplete_utf8$link2
// file alternative.c line 34
static void drop_incomplete_utf8$link2(char *c$link2);
// drop_incomplete_utf8$link3
// file alternative.c line 34
static void drop_incomplete_utf8$link3(char *c$link3);
// entry_group_simple_method_call
// file entrygroup.c line 188
static signed int entry_group_simple_method_call(struct AvahiEntryGroup *group, const char *method);
// entry_group_simple_method_call$link1
// file entrygroup.c line 188
static signed int entry_group_simple_method_call$link1(struct AvahiEntryGroup *group$link1, const char *method$link1);
// execlp
// file /usr/include/unistd.h line 584
extern signed int execlp(const char *, const char *, ...);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// filter_func
// file client.c line 103
static enum anonymous$42 filter_func(struct DBusConnection *bus, struct DBusMessage *message, void *userdata);
// filter_func$link1
// file client.c line 103
static enum anonymous$42 filter_func$link1(struct DBusConnection *bus$link1, struct DBusMessage *message$link1, void *userdata$link1);
// find_next_timeout
// file simple-watch.c line 425
static struct AvahiTimeout$1 * find_next_timeout(struct AvahiSimplePoll$0 *s);
// find_next_timeout$link1
// file simple-watch.c line 425
static struct AvahiTimeout$1 * find_next_timeout$link1(struct AvahiSimplePoll$0 *s$link1);
// find_next_timeout$link1$link1
// file simple-watch.c line 425
static struct AvahiTimeout$0 * find_next_timeout$link1$link1(struct AvahiSimplePoll *s$link2);
// find_next_timeout$link1$link2
// file simple-watch.c line 425
static struct AvahiTimeout$1 * find_next_timeout$link1$link2(struct AvahiSimplePoll$0 *s$link1$link1);
// find_next_timeout$link2
// file glib-watch.c line 230
static struct AvahiTimeout * find_next_timeout$link2(struct AvahiGLibPoll *g);
// find_next_timeout$link3
// file simple-watch.c line 425
static struct AvahiTimeout$1 * find_next_timeout$link3(struct AvahiSimplePoll$0 *s$link3);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// g_assertion_message_expr
// file /usr/include/glib-2.0/glib/gtestutils.h line 302
extern void g_assertion_message_expr(const char *, const char *, signed int, const char *, const char *);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_hash_table_insert
// file /usr/include/glib-2.0/glib/ghash.h line 67
extern signed int g_hash_table_insert(struct _GHashTable *, void *, void *);
// g_hash_table_lookup
// file /usr/include/glib-2.0/glib/ghash.h line 88
extern void * g_hash_table_lookup(struct _GHashTable *, const void *);
// g_hash_table_new_full
// file /usr/include/glib-2.0/glib/ghash.h line 60
extern struct _GHashTable * g_hash_table_new_full(unsigned int (*)(const void *), signed int (*)(const void *, const void *), void (*)(void *), void (*)(void *));
// g_hash_table_unref
// file /usr/include/glib-2.0/glib/ghash.h line 144
extern void g_hash_table_unref(struct _GHashTable *);
// g_idle_add
// file /usr/include/glib-2.0/glib/gmain.h line 584
extern unsigned int g_idle_add(signed int (*)(void *), void *);
// g_intern_static_string
// file /usr/include/glib-2.0/glib/gquark.h line 64
extern const char * g_intern_static_string(const char *);
// g_list_free
// file /usr/include/glib-2.0/glib/glist.h line 51
extern void g_list_free(struct _GList *);
// g_log
// file /usr/include/glib-2.0/glib/gmessages.h line 101
extern void g_log(const char *, enum anonymous$10, const char *, ...);
// g_main_context_default
// file /usr/include/glib-2.0/glib/gmain.h line 312
extern struct _GMainContext * g_main_context_default(void);
// g_main_context_ref
// file /usr/include/glib-2.0/glib/gmain.h line 308
extern struct _GMainContext * g_main_context_ref(struct _GMainContext *);
// g_main_context_unref
// file /usr/include/glib-2.0/glib/gmain.h line 310
extern void g_main_context_unref(struct _GMainContext *);
// g_malloc
// file /usr/include/glib-2.0/glib/gmem.h line 78
extern void * g_malloc(unsigned long int);
// g_malloc0
// file /usr/include/glib-2.0/glib/gmem.h line 80
extern void * g_malloc0(unsigned long int);
// g_malloc0_n
// file /usr/include/glib-2.0/glib/gmem.h line 96
extern void * g_malloc0_n(unsigned long int, unsigned long int);
// g_malloc_n
// file /usr/include/glib-2.0/glib/gmem.h line 93
extern void * g_malloc_n(unsigned long int, unsigned long int);
// g_object_class_install_property
// file /usr/include/glib-2.0/gobject/gobject.h line 389
extern void g_object_class_install_property(struct _GObjectClass *, unsigned int, struct _GParamSpec *);
// g_object_new
// file /usr/include/glib-2.0/gobject/gobject.h line 420
extern void * g_object_new(unsigned long int, const char *, ...);
// g_object_unref
// file /usr/include/glib-2.0/gobject/gobject.h line 480
extern void g_object_unref(void *);
// g_once_init_enter
// file /usr/include/glib-2.0/glib/gthread.h line 232
extern signed int g_once_init_enter(volatile void *);
// g_once_init_leave
// file /usr/include/glib-2.0/glib/gthread.h line 234
extern void g_once_init_leave(volatile void *, unsigned long int);
// g_param_spec_boolean
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 995
extern struct _GParamSpec * g_param_spec_boolean(const char *, const char *, const char *, signed int, enum anonymous$35);
// g_param_spec_int
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 1001
extern struct _GParamSpec * g_param_spec_int(const char *, const char *, const char *, signed int, signed int, signed int, enum anonymous$35);
// g_param_spec_pointer
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 1103
extern struct _GParamSpec * g_param_spec_pointer(const char *, const char *, const char *, enum anonymous$35);
// g_param_spec_string
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 1085
extern struct _GParamSpec * g_param_spec_string(const char *, const char *, const char *, const char *, enum anonymous$35);
// g_param_spec_uint
// file /usr/include/glib-2.0/gobject/gparamspecs.h line 1009
extern struct _GParamSpec * g_param_spec_uint(const char *, const char *, const char *, unsigned int, unsigned int, unsigned int, enum anonymous$35);
// g_print
// file /usr/include/glib-2.0/glib/gmessages.h line 265
extern void g_print(const char *, ...);
// g_realloc
// file /usr/include/glib-2.0/glib/gmem.h line 82
extern void * g_realloc(void *, unsigned long int);
// g_return_if_fail_warning
// file /usr/include/glib-2.0/glib/gmessages.h line 124
extern void g_return_if_fail_warning(const char *, const char *, const char *);
// g_signal_connect_data
// file /usr/include/glib-2.0/gobject/gsignal.h line 388
extern unsigned long int g_signal_connect_data(void *, const char *, void (*)(void), void *, void (*)(void *, struct _GClosure *), enum anonymous$7);
// g_signal_lookup
// file /usr/include/glib-2.0/gobject/gsignal.h line 331
extern unsigned int g_signal_lookup(const char *, unsigned long int);
// g_signal_stop_emission
// file /usr/include/glib-2.0/gobject/gsignal.h line 353
extern void g_signal_stop_emission(void *, unsigned int, unsigned int);
// g_snprintf
// file /usr/include/glib-2.0/glib/gutils.h line 201
extern signed int g_snprintf(char *, unsigned long int, const char *, ...);
// g_source_add_poll
// file /usr/include/glib-2.0/glib/gmain.h line 498
extern void g_source_add_poll(struct _GSource *, struct _GPollFD *);
// g_source_attach
// file /usr/include/glib-2.0/glib/gmain.h line 426
extern unsigned int g_source_attach(struct _GSource *, struct _GMainContext *);
// g_source_destroy
// file /usr/include/glib-2.0/glib/gmain.h line 429
extern void g_source_destroy(struct _GSource *);
// g_source_get_current_time
// file /usr/include/glib-2.0/glib/gmain.h line 512
extern void g_source_get_current_time(struct _GSource *, struct _GTimeVal *);
// g_source_new
// file /usr/include/glib-2.0/glib/gmain.h line 418
extern struct _GSource * g_source_new(struct _GSourceFuncs *, unsigned int);
// g_source_remove
// file /usr/include/glib-2.0/glib/gmain.h line 545
extern signed int g_source_remove(unsigned int);
// g_source_remove_poll
// file /usr/include/glib-2.0/glib/gmain.h line 501
extern void g_source_remove_poll(struct _GSource *, struct _GPollFD *);
// g_source_set_can_recurse
// file /usr/include/glib-2.0/glib/gmain.h line 437
extern void g_source_set_can_recurse(struct _GSource *, signed int);
// g_source_set_priority
// file /usr/include/glib-2.0/glib/gmain.h line 432
extern void g_source_set_priority(struct _GSource *, signed int);
// g_source_unref
// file /usr/include/glib-2.0/glib/gmain.h line 423
extern void g_source_unref(struct _GSource *);
// g_str_equal
// file /usr/include/glib-2.0/glib/ghash.h line 154
extern signed int g_str_equal(const void *, const void *);
// g_str_has_suffix
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 137
extern signed int g_str_has_suffix(const char *, const char *);
// g_str_hash
// file /usr/include/glib-2.0/glib/ghash.h line 157
extern unsigned int g_str_hash(const void *);
// g_strdup
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 216
extern char * g_strdup(const char *);
// g_strdup_printf
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 218
extern char * g_strdup_printf(const char *, ...);
// g_strdupv
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 283
extern char ** g_strdupv(char **);
// g_strfreev
// file /usr/include/glib-2.0/glib/gstrfuncs.h line 281
extern void g_strfreev(char **);
// g_timeout_add
// file /usr/include/glib-2.0/glib/gmain.h line 560
extern unsigned int g_timeout_add(unsigned int, signed int (*)(void *), void *);
// g_type_check_class_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2177
extern struct _GTypeClass * g_type_check_class_cast(struct _GTypeClass *, unsigned long int);
// g_type_check_instance_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2168
extern struct _GTypeInstance * g_type_check_instance_cast(struct _GTypeInstance *, unsigned long int);
// g_type_check_instance_is_a
// file /usr/include/glib-2.0/gobject/gtype.h line 2171
extern signed int g_type_check_instance_is_a(struct _GTypeInstance *, unsigned long int);
// g_type_class_adjust_private_offset
// file /usr/include/glib-2.0/gobject/gtype.h line 1302
extern void g_type_class_adjust_private_offset(void *, signed int *);
// g_type_class_peek_parent
// file /usr/include/glib-2.0/gobject/gtype.h line 709
extern void * g_type_class_peek_parent(void *);
// g_type_name
// file /usr/include/glib-2.0/gobject/gtype.h line 685
extern const char * g_type_name(unsigned long int);
// g_type_register_static_simple
// file /usr/include/glib-2.0/gobject/gtype.h line 1259
extern unsigned long int g_type_register_static_simple(unsigned long int, const char *, unsigned int, void (*)(void *, void *), unsigned int, void (*)(struct _GTypeInstance *, void *), enum anonymous$3);
// g_value_get_boolean
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 197
extern signed int g_value_get_boolean(const struct _GValue *);
// g_value_get_int
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 202
extern signed int g_value_get_int(const struct _GValue *);
// g_value_get_pointer
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 252
extern void * g_value_get_pointer(const struct _GValue *);
// g_value_get_string
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 245
extern const char * g_value_get_string(const struct _GValue *);
// g_value_set_boolean
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 194
extern void g_value_set_boolean(struct _GValue *, signed int);
// g_value_set_int
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 199
extern void g_value_set_int(struct _GValue *, signed int);
// g_value_set_pointer
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 249
extern void g_value_set_pointer(struct _GValue *, void *);
// g_value_set_string
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 239
extern void g_value_set_string(struct _GValue *, const char *);
// g_value_set_uint
// file /usr/include/glib-2.0/gobject/gvaluetypes.h line 204
extern void g_value_set_uint(struct _GValue *, unsigned int);
// gdbm_close
// file /usr/include/gdbm.h line 86
extern void gdbm_close(struct anonymous$36 *);
// gdbm_fetch
// file /usr/include/gdbm.h line 88
extern struct anonymous$37 gdbm_fetch(struct anonymous$36 *, struct anonymous$37);
// gdbm_firstkey
// file /usr/include/gdbm.h line 90
extern struct anonymous$37 gdbm_firstkey(struct anonymous$36 *);
// gdbm_nextkey
// file /usr/include/gdbm.h line 91
extern struct anonymous$37 gdbm_nextkey(struct anonymous$36 *, struct anonymous$37);
// gdbm_open
// file /usr/include/gdbm.h line 85
extern struct anonymous$36 * gdbm_open(char *, signed int, signed int, signed int, void (*)());
// gdk_cursor_new
// file /usr/include/gtk-3.0/gdk/gdkcursor.h line 228
extern struct _GdkCursor * gdk_cursor_new(enum anonymous$34);
// gdk_window_set_cursor
// file /usr/include/gtk-3.0/gdk/gdkwindow.h line 784
extern void gdk_window_set_cursor(struct _GdkWindow *, struct _GdkCursor *);
// get_default_response
// file avahi-ui.c line 128
static signed int get_default_response(struct _GtkDialog *dlg);
// get_domain_name
// file avahi-ui.c line 670
static const char * get_domain_name(struct _AuiServiceDialog *d);
// get_server_state
// file client.c line 305
static signed int get_server_state(struct AvahiClient *client, signed int *ret_error);
// get_server_state$link1
// file client.c line 305
static signed int get_server_state$link1(struct AvahiClient *client$link1, signed int *ret_error$link1);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// gtk_box_get_type
// file /usr/include/gtk-3.0/gtk/gtkbox.h line 78
extern unsigned long int gtk_box_get_type(void);
// gtk_box_new
// file /usr/include/gtk-3.0/gtk/gtkbox.h line 80
extern struct _GtkWidget * gtk_box_new(enum anonymous$16, signed int);
// gtk_box_pack_end
// file /usr/include/gtk-3.0/gtk/gtkbox.h line 90
extern void gtk_box_pack_end(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_box_pack_start
// file /usr/include/gtk-3.0/gtk/gtkbox.h line 84
extern void gtk_box_pack_start(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_button_box_get_type
// file /usr/include/gtk-3.0/gtk/gtkbbox.h line 104
extern unsigned long int gtk_button_box_get_type(void);
// gtk_button_box_set_child_secondary
// file /usr/include/gtk-3.0/gtk/gtkbbox.h line 116
extern void gtk_button_box_set_child_secondary(struct _GtkButtonBox *, struct _GtkWidget *, signed int);
// gtk_button_get_type
// file /usr/include/gtk-3.0/gtk/gtkbutton.h line 94
extern unsigned long int gtk_button_get_type(void);
// gtk_button_new_with_mnemonic
// file /usr/include/gtk-3.0/gtk/gtkbutton.h line 105
extern struct _GtkWidget * gtk_button_new_with_mnemonic(const char *);
// gtk_button_set_image
// file /usr/include/gtk-3.0/gtk/gtkbutton.h line 151
extern void gtk_button_set_image(struct _GtkButton *, struct _GtkWidget *);
// gtk_cell_renderer_text_new
// file /usr/include/gtk-3.0/gtk/gtkcellrenderertext.h line 69
extern struct _GtkCellRenderer * gtk_cell_renderer_text_new(void);
// gtk_container_add
// file /usr/include/gtk-3.0/gtk/gtkcontainer.h line 149
extern void gtk_container_add(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_get_children
// file /usr/include/gtk-3.0/gtk/gtkcontainer.h line 169
extern struct _GList * gtk_container_get_children(struct _GtkContainer *);
// gtk_container_get_type
// file /usr/include/gtk-3.0/gtk/gtkcontainer.h line 142
extern unsigned long int gtk_container_get_type(void);
// gtk_container_set_border_width
// file /usr/include/gtk-3.0/gtk/gtkcontainer.h line 144
extern void gtk_container_set_border_width(struct _GtkContainer *, unsigned int);
// gtk_dialog_add_button
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 162
extern struct _GtkWidget * gtk_dialog_add_button(struct _GtkDialog *, const char *, signed int);
// gtk_dialog_get_action_area
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 205
extern struct _GtkWidget * gtk_dialog_get_action_area(struct _GtkDialog *);
// gtk_dialog_get_content_area
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 207
extern struct _GtkWidget * gtk_dialog_get_content_area(struct _GtkDialog *);
// gtk_dialog_get_response_for_widget
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 181
extern signed int gtk_dialog_get_response_for_widget(struct _GtkDialog *, struct _GtkWidget *);
// gtk_dialog_get_type
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 146
extern unsigned long int gtk_dialog_get_type(void);
// gtk_dialog_new
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 148
extern struct _GtkWidget * gtk_dialog_new(void);
// gtk_dialog_response
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 197
extern void gtk_dialog_response(struct _GtkDialog *, signed int);
// gtk_dialog_run
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 202
extern signed int gtk_dialog_run(struct _GtkDialog *);
// gtk_dialog_set_default_response
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 175
extern void gtk_dialog_set_default_response(struct _GtkDialog *, signed int);
// gtk_dialog_set_response_sensitive
// file /usr/include/gtk-3.0/gtk/gtkdialog.h line 171
extern void gtk_dialog_set_response_sensitive(struct _GtkDialog *, signed int, signed int);
// gtk_entry_get_text
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 257
extern const char * gtk_entry_get_text(struct _GtkEntry *);
// gtk_entry_get_type
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 175
extern unsigned long int gtk_entry_get_type(void);
// gtk_entry_new
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 177
extern struct _GtkWidget * gtk_entry_new(void);
// gtk_entry_set_activates_default
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 233
extern void gtk_entry_set_activates_default(struct _GtkEntry *, signed int);
// gtk_entry_set_max_length
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 225
extern void gtk_entry_set_max_length(struct _GtkEntry *, signed int);
// gtk_entry_set_text
// file /usr/include/gtk-3.0/gtk/gtkentry.h line 253
extern void gtk_entry_set_text(struct _GtkEntry *, const char *);
// gtk_image_new_from_icon_name
// file /usr/include/gtk-3.0/gtk/gtkimage.h line 130
extern struct _GtkWidget * gtk_image_new_from_icon_name(const char *, enum anonymous$32);
// gtk_init
// file /usr/include/gtk-3.0/gtk/gtkmain.h line 101
extern void gtk_init(signed int *, char ***);
// gtk_label_get_type
// file /usr/include/gtk-3.0/gtk/gtklabel.h line 91
extern unsigned long int gtk_label_get_type(void);
// gtk_label_new
// file /usr/include/gtk-3.0/gtk/gtklabel.h line 93
extern struct _GtkWidget * gtk_label_new(const char *);
// gtk_label_set_ellipsize
// file /usr/include/gtk-3.0/gtk/gtklabel.h line 144
extern void gtk_label_set_ellipsize(struct _GtkLabel *, enum anonymous$0);
// gtk_label_set_markup
// file /usr/include/gtk-3.0/gtk/gtklabel.h line 112
extern void gtk_label_set_markup(struct _GtkLabel *, const char *);
// gtk_list_store_append
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 129
extern void gtk_list_store_append(struct _GtkListStore *, struct _GtkTreeIter *);
// gtk_list_store_clear
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 132
extern void gtk_list_store_clear(struct _GtkListStore *);
// gtk_list_store_get_type
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 65
extern unsigned long int gtk_list_store_get_type(void);
// gtk_list_store_new
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 67
extern struct _GtkListStore * gtk_list_store_new(signed int, ...);
// gtk_list_store_remove
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 99
extern signed int gtk_list_store_remove(struct _GtkListStore *, struct _GtkTreeIter *);
// gtk_list_store_set
// file /usr/include/gtk-3.0/gtk/gtkliststore.h line 85
extern void gtk_list_store_set(struct _GtkListStore *, struct _GtkTreeIter *, ...);
// gtk_message_dialog_new
// file /usr/include/gtk-3.0/gtk/gtkmessagedialog.h line 99
extern struct _GtkWidget * gtk_message_dialog_new(struct _GtkWindow *, enum anonymous$30, enum anonymous$29, enum anonymous$17, const char *, ...);
// gtk_misc_get_type
// file /usr/include/gtk-3.0/gtk/deprecated/gtkmisc.h line 70
extern unsigned long int gtk_misc_get_type(void);
// gtk_misc_set_alignment
// file /usr/include/gtk-3.0/gtk/deprecated/gtkmisc.h line 72
extern void gtk_misc_set_alignment(struct _GtkMisc *, float, float);
// gtk_progress_bar_get_type
// file /usr/include/gtk-3.0/gtk/gtkprogressbar.h line 69
extern unsigned long int gtk_progress_bar_get_type(void);
// gtk_progress_bar_new
// file /usr/include/gtk-3.0/gtk/gtkprogressbar.h line 71
extern struct _GtkWidget * gtk_progress_bar_new(void);
// gtk_progress_bar_pulse
// file /usr/include/gtk-3.0/gtk/gtkprogressbar.h line 74
extern void gtk_progress_bar_pulse(struct _GtkProgressBar *);
// gtk_progress_bar_set_pulse_step
// file /usr/include/gtk-3.0/gtk/gtkprogressbar.h line 83
extern void gtk_progress_bar_set_pulse_step(struct _GtkProgressBar *, double);
// gtk_progress_bar_set_text
// file /usr/include/gtk-3.0/gtk/gtkprogressbar.h line 76
extern void gtk_progress_bar_set_text(struct _GtkProgressBar *, const char *);
// gtk_scrolled_window_get_type
// file /usr/include/gtk-3.0/gtk/gtkscrolledwindow.h line 146
extern unsigned long int gtk_scrolled_window_get_type(void);
// gtk_scrolled_window_new
// file /usr/include/gtk-3.0/gtk/gtkscrolledwindow.h line 148
extern struct _GtkWidget * gtk_scrolled_window_new(struct _GtkAdjustment *, struct _GtkAdjustment *);
// gtk_scrolled_window_set_policy
// file /usr/include/gtk-3.0/gtk/gtkscrolledwindow.h line 165
extern void gtk_scrolled_window_set_policy(struct _GtkScrolledWindow *, enum anonymous$2, enum anonymous$2);
// gtk_scrolled_window_set_shadow_type
// file /usr/include/gtk-3.0/gtk/gtkscrolledwindow.h line 181
extern void gtk_scrolled_window_set_shadow_type(struct _GtkScrolledWindow *, enum anonymous$5);
// gtk_tree_model_get
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 364
extern void gtk_tree_model_get(struct _GtkTreeModel *, struct _GtkTreeIter *, ...);
// gtk_tree_model_get_iter_first
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 322
extern signed int gtk_tree_model_get_iter_first(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_get_path
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 325
extern struct _GtkTreePath * gtk_tree_model_get_path(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_get_type
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 299
extern unsigned long int gtk_tree_model_get_type(void);
// gtk_tree_model_iter_next
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 336
extern signed int gtk_tree_model_iter_next(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_path_free
// file /usr/include/gtk-3.0/gtk/gtktreemodel.h line 225
extern void gtk_tree_path_free(struct _GtkTreePath *);
// gtk_tree_selection_get_selected
// file /usr/include/gtk-3.0/gtk/gtktreeselection.h line 130
extern signed int gtk_tree_selection_get_selected(struct _GtkTreeSelection *, struct _GtkTreeModel **, struct _GtkTreeIter *);
// gtk_tree_selection_select_iter
// file /usr/include/gtk-3.0/gtk/gtktreeselection.h line 149
extern void gtk_tree_selection_select_iter(struct _GtkTreeSelection *, struct _GtkTreeIter *);
// gtk_tree_selection_set_mode
// file /usr/include/gtk-3.0/gtk/gtktreeselection.h line 110
extern void gtk_tree_selection_set_mode(struct _GtkTreeSelection *, enum anonymous$1);
// gtk_tree_view_append_column
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 258
extern signed int gtk_tree_view_append_column(struct _GtkTreeView *, struct _GtkTreeViewColumn *);
// gtk_tree_view_column_new_with_attributes
// file /usr/include/gtk-3.0/gtk/gtktreeviewcolumn.h line 111
extern struct _GtkTreeViewColumn * gtk_tree_view_column_new_with_attributes(const char *, struct _GtkCellRenderer *, ...);
// gtk_tree_view_column_set_expand
// file /usr/include/gtk-3.0/gtk/gtktreeviewcolumn.h line 194
extern void gtk_tree_view_column_set_expand(struct _GtkTreeViewColumn *, signed int);
// gtk_tree_view_column_set_visible
// file /usr/include/gtk-3.0/gtk/gtktreeviewcolumn.h line 148
extern void gtk_tree_view_column_set_visible(struct _GtkTreeViewColumn *, signed int);
// gtk_tree_view_get_column
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 285
extern struct _GtkTreeViewColumn * gtk_tree_view_get_column(struct _GtkTreeView *, signed int);
// gtk_tree_view_get_selection
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 219
extern struct _GtkTreeSelection * gtk_tree_view_get_selection(struct _GtkTreeView *);
// gtk_tree_view_get_type
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 206
extern unsigned long int gtk_tree_view_get_type(void);
// gtk_tree_view_new_with_model
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 210
extern struct _GtkWidget * gtk_tree_view_new_with_model(struct _GtkTreeModel *);
// gtk_tree_view_set_cursor
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 347
extern void gtk_tree_view_set_cursor(struct _GtkTreeView *, struct _GtkTreePath *, struct _GtkTreeViewColumn *, signed int);
// gtk_tree_view_set_headers_visible
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 236
extern void gtk_tree_view_set_headers_visible(struct _GtkTreeView *, signed int);
// gtk_tree_view_set_search_column
// file /usr/include/gtk-3.0/gtk/gtktreeview.h line 446
extern void gtk_tree_view_set_search_column(struct _GtkTreeView *, signed int);
// gtk_widget_destroy
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 619
extern void gtk_widget_destroy(struct _GtkWidget *);
// gtk_widget_get_type
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 613
extern unsigned long int gtk_widget_get_type(void);
// gtk_widget_get_window
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 907
extern struct _GdkWindow * gtk_widget_get_window(struct _GtkWidget *);
// gtk_widget_grab_default
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 793
extern void gtk_widget_grab_default(struct _GtkWidget *);
// gtk_widget_grab_focus
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 783
extern void gtk_widget_grab_focus(struct _GtkWidget *);
// gtk_widget_hide
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 628
extern void gtk_widget_hide(struct _GtkWidget *);
// gtk_widget_set_sensitive
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 833
extern void gtk_widget_set_sensitive(struct _GtkWidget *, signed int);
// gtk_widget_show
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 626
extern void gtk_widget_show(struct _GtkWidget *);
// gtk_widget_show_all
// file /usr/include/gtk-3.0/gtk/gtkwidget.h line 632
extern void gtk_widget_show_all(struct _GtkWidget *);
// gtk_window_get_default_widget
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 185
extern struct _GtkWidget * gtk_window_get_default_widget(struct _GtkWindow *);
// gtk_window_get_type
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 145
extern unsigned long int gtk_window_get_type(void);
// gtk_window_present
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 370
extern void gtk_window_present(struct _GtkWindow *);
// gtk_window_set_default_size
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 419
extern void gtk_window_set_default_size(struct _GtkWindow *, signed int, signed int);
// gtk_window_set_title
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 149
extern void gtk_window_set_title(struct _GtkWindow *, const char *);
// gtk_window_set_transient_for
// file /usr/include/gtk-3.0/gtk/gtkwindow.h line 190
extern void gtk_window_set_transient_for(struct _GtkWindow *, struct _GtkWindow *);
// help
// file bssh.c line 53
static void help(struct _IO_FILE *f, const char *argv0);
// if_indextoname
// file /usr/include/net/if.h line 194
extern char * if_indextoname(unsigned int, char *);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// init
// file ../avahi-utils/stdb.c line 46
static signed int init(void);
// init_server
// file client.c line 431
static signed int init_server(struct AvahiClient *client, signed int *ret_error);
// init_server$link1
// file client.c line 431
static signed int init_server$link1(struct AvahiClient *client$link1, signed int *ret_error$link1);
// is_valid_domain_suffix
// file avahi-ui.c line 919
static signed int is_valid_domain_suffix(const char *n);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// malloc_glue
// file glib-malloc.c line 29
static void * malloc_glue(unsigned long int l);
// map_events_from_glib
// file glib-watch.c line 101
static enum anonymous map_events_from_glib(unsigned short int events);
// map_events_to_glib
// file glib-watch.c line 93
static unsigned short int map_events_to_glib(enum anonymous events);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// oom
// file malloc.c line 44
static void oom(void);
// oom$link1
// file malloc.c line 44
static void oom$link1(void);
// oom$link1$link1
// file malloc.c line 44
static void oom$link1$link1(void);
// oom$link2
// file malloc.c line 44
static void oom$link2(void);
// oom$link3
// file malloc.c line 44
static void oom$link3(void);
// parse_command_line
// file bssh.c line 64
static signed int parse_command_line(struct Config *c, signed int argc, char **argv);
// parse_domain_file
// file browser.c line 58
static void parse_domain_file(struct AvahiDomainBrowser *b);
// parse_domain_file$link1
// file browser.c line 58
static void parse_domain_file$link1(struct AvahiDomainBrowser *b$link1);
// parse_environment
// file browser.c line 41
static void parse_environment(struct AvahiDomainBrowser *b);
// parse_environment$link1
// file browser.c line 41
static void parse_environment$link1(struct AvahiDomainBrowser *b$link1);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// poll_func
// file thread-watch.c line 48
static signed int poll_func(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata);
// poll_func$link1
// file thread-watch.c line 48
static signed int poll_func$link1(struct pollfd *ufds$link1, unsigned int nfds$link1, signed int timeout$link1, void *userdata$link1);
// poll_func$link1$link1
// file thread-watch.c line 48
static signed int poll_func$link1$link1(struct pollfd *ufds$link1$link1, unsigned int nfds$link1$link1, signed int timeout$link1$link1, void *userdata$link1$link1);
// poll_func$link2
// file thread-watch.c line 48
static signed int poll_func$link2(struct pollfd *ufds$link2, unsigned int nfds$link2, signed int timeout$link2, void *userdata$link2);
// poll_func$link3
// file thread-watch.c line 48
static signed int poll_func$link3(struct pollfd *ufds$link3, unsigned int nfds$link3, signed int timeout$link3, void *userdata$link3);
// prepare_func
// file glib-watch.c line 255
static signed int prepare_func(struct _GSource *source, signed int *timeout);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_equal
// file /usr/include/pthread.h line 280
extern signed int pthread_equal(unsigned long int, unsigned long int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$6 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$6 *, const union anonymous$38 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$6 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$6 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$8 *, struct anonymous$8 *);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realloc_glue
// file glib-malloc.c line 33
static void * realloc_glue(void *p, unsigned long int l);
// rebuild
// file simple-watch.c line 385
static signed int rebuild(struct AvahiSimplePoll$0 *s);
// rebuild$link1
// file simple-watch.c line 385
static signed int rebuild$link1(struct AvahiSimplePoll$0 *s$link1);
// rebuild$link1$link1
// file simple-watch.c line 385
static signed int rebuild$link1$link1(struct AvahiSimplePoll$0 *s$link1$link1);
// rebuild$link2
// file simple-watch.c line 385
static signed int rebuild$link2(struct AvahiSimplePoll *s$link2);
// rebuild$link3
// file simple-watch.c line 385
static signed int rebuild$link3(struct AvahiSimplePoll$0 *s$link3);
// remove_pollfd
// file simple-watch.c line 194
static void remove_pollfd(struct AvahiWatch$1 *w);
// remove_pollfd$link1
// file simple-watch.c line 194
static void remove_pollfd$link1(struct AvahiWatch$1 *w$link1);
// remove_pollfd$link1$link1
// file simple-watch.c line 194
static void remove_pollfd$link1$link1(struct AvahiWatch$1 *w$link1$link1);
// remove_pollfd$link2
// file simple-watch.c line 194
static void remove_pollfd$link2(struct AvahiWatch *w$link2);
// remove_pollfd$link3
// file simple-watch.c line 194
static void remove_pollfd$link3(struct AvahiWatch$1 *w$link3);
// remove_timeout
// file ../avahi-common/dbus-watch-glue.c line 286
static void remove_timeout(struct DBusTimeout *dbus_timeout, void *userdata);
// remove_timeout$link1
// file ../avahi-common/dbus-watch-glue.c line 286
static void remove_timeout$link1(struct DBusTimeout *dbus_timeout$link1, void *userdata$link1);
// remove_watch
// file ../avahi-common/dbus-watch-glue.c line 174
static void remove_watch(struct DBusWatch *dbus_watch, void *userdata);
// remove_watch$link1
// file ../avahi-common/dbus-watch-glue.c line 174
static void remove_watch$link1(struct DBusWatch *dbus_watch$link1, void *userdata$link1);
// request_dispatch
// file ../avahi-common/dbus-watch-glue.c line 86
static void request_dispatch(struct anonymous$28 *d, signed int enable);
// request_dispatch$link1
// file ../avahi-common/dbus-watch-glue.c line 86
static void request_dispatch$link1(struct anonymous$28 *d$link1, signed int enable$link1);
// resolve_callback
// file avahi-ui.c line 335
static void resolve_callback(struct AvahiServiceResolver *r, signed int interface, signed int protocol, enum anonymous$12 event, const char *name, const char *type, const char *domain, const char *host_name, const struct AvahiAddress *a, unsigned short int port, struct AvahiStringList *txt, enum anonymous$13 flags, void *userdata);
// response_callback
// file avahi-ui.c line 859
static void response_callback(struct _GtkDialog *dialog, signed int response, void *user_data);
// restart_browsing
// file avahi-ui.c line 1207
static void restart_browsing(struct _AuiServiceDialog *d);
// retrieve_state
// file entrygroup.c line 52
static signed int retrieve_state(struct AvahiEntryGroup *group);
// retrieve_state$link1
// file entrygroup.c line 52
static signed int retrieve_state$link1(struct AvahiEntryGroup *group$link1);
// service_pulse_callback
// file avahi-ui.c line 304
static signed int service_pulse_callback(void *data);
// service_row_activated_callback
// file avahi-ui.c line 842
static void service_row_activated_callback(struct _GtkTreeView *tree_view, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data);
// service_selection_changed_callback
// file avahi-ui.c line 848
static void service_selection_changed_callback(struct _GtkTreeSelection *selection, void *user_data);
// set_nonblock
// file simple-watch.c line 118
static signed int set_nonblock(signed int fd);
// set_nonblock$link1
// file simple-watch.c line 118
static signed int set_nonblock$link1(signed int fd$link1);
// set_nonblock$link1$link1
// file simple-watch.c line 118
static signed int set_nonblock$link1$link1(signed int fd$link1$link1);
// set_nonblock$link2
// file simple-watch.c line 118
static signed int set_nonblock$link2(signed int fd$link2);
// set_nonblock$link3
// file simple-watch.c line 118
static signed int set_nonblock$link3(signed int fd$link3);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous$8 *);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// start_callback
// file avahi-ui.c line 695
static signed int start_callback(void *data);
// start_timeout_callback
// file glib-watch.c line 246
static void start_timeout_callback(struct AvahiTimeout *t);
// stdb_getent
// file ../avahi-utils/stdb.c line 168
char * stdb_getent(void);
// stdb_lookup
// file ../avahi-utils/stdb.h line 25
const char * stdb_lookup(const char *name);
// stdb_setent
// file ../avahi-utils/stdb.c line 209
void stdb_setent(void);
// stdb_shutdown
// file ../avahi-utils/stdb.c line 148
void stdb_shutdown(void);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlcpy
// file domain.c line 482
static unsigned long int strlcpy(char *dest, const char *src, unsigned long int n);
// strlcpy$link1
// file domain.c line 482
static unsigned long int strlcpy$link1(char *dest$link1, const char *src$link1, unsigned long int n$link1);
// strlcpy$link1$link1
// file domain.c line 482
static unsigned long int strlcpy$link1$link1(char *dest$link1$link1, const char *src$link1$link1, unsigned long int n$link1$link1);
// strlcpy$link2
// file domain.c line 482
static unsigned long int strlcpy$link2(char *dest$link2, const char *src$link2, unsigned long int n$link2);
// strlcpy$link3
// file domain.c line 482
static unsigned long int strlcpy$link3(char *dest$link3, const char *src$link3, unsigned long int n$link3);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok_r
// file /usr/include/string.h line 358
extern char * strtok_r(char *, const char *, char ** restrict );
// strtoll
// file /usr/include/stdlib.h line 209
extern signed long long int strtoll(const char *, char ** restrict , signed int);
// system_poll
// file simple-watch.c line 626
static signed int system_poll(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata);
// system_poll$link1
// file simple-watch.c line 626
static signed int system_poll$link1(struct pollfd *ufds$link1, unsigned int nfds$link1, signed int timeout$link1, void *userdata$link1);
// system_poll$link1$link1
// file simple-watch.c line 626
static signed int system_poll$link1$link1(struct pollfd *ufds$link1$link1, unsigned int nfds$link1$link1, signed int timeout$link1$link1, void *userdata$link1$link1);
// system_poll$link2
// file simple-watch.c line 626
static signed int system_poll$link2(struct pollfd *ufds$link2, unsigned int nfds$link2, signed int timeout$link2, void *userdata$link2);
// system_poll$link3
// file simple-watch.c line 626
static signed int system_poll$link3(struct pollfd *ufds$link3, unsigned int nfds$link3, signed int timeout$link3, void *userdata$link3);
// textdomain
// file /usr/include/libintl.h line 82
extern char * textdomain(const char *);
// thread
// file thread-watch.c line 62
static void * thread(void *userdata);
// thread$link1
// file thread-watch.c line 62
static void * thread$link1(void *userdata$link1);
// thread$link1$link1
// file thread-watch.c line 62
static void * thread$link1$link1(void *userdata$link1$link1);
// thread$link2
// file thread-watch.c line 62
static void * thread$link2(void *userdata$link2);
// thread$link3
// file thread-watch.c line 62
static void * thread$link3(void *userdata$link3);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 237
static void timeout_callback(struct AvahiTimeout$1 *avahi_timeout, void *userdata);
// timeout_callback$link1
// file simple-watch.c line 441
static void timeout_callback$link1(struct AvahiTimeout$1 *t);
// timeout_callback$link1$link1
// file simple-watch.c line 441
static void timeout_callback$link1$link1(struct AvahiTimeout$1 *t$link1$link1);
// timeout_callback$link2
// file simple-watch.c line 441
static void timeout_callback$link2(struct AvahiTimeout$1 *t$link1);
// timeout_callback$link2$link1
// file ../avahi-common/dbus-watch-glue.c line 237
static void timeout_callback$link2$link1(struct AvahiTimeout$1 *avahi_timeout$link1, void *userdata$link1);
// timeout_callback$link3
// file simple-watch.c line 441
static void timeout_callback$link3(struct AvahiTimeout$0 *t$link2);
// timeout_callback$link4
// file simple-watch.c line 441
static void timeout_callback$link4(struct AvahiTimeout$1 *t$link3);
// timeout_data_ref
// file ../avahi-common/dbus-watch-glue.c line 203
static struct TimeoutData * timeout_data_ref(struct TimeoutData *t);
// timeout_data_ref$link1
// file ../avahi-common/dbus-watch-glue.c line 203
static struct TimeoutData * timeout_data_ref$link1(struct TimeoutData *t$link1);
// timeout_data_unref
// file ../avahi-common/dbus-watch-glue.c line 211
static void timeout_data_unref(struct TimeoutData *t);
// timeout_data_unref$link1
// file ../avahi-common/dbus-watch-glue.c line 211
static void timeout_data_unref$link1(struct TimeoutData *t$link1);
// timeout_free
// file simple-watch.c line 284
static void timeout_free(struct AvahiTimeout$1 *t);
// timeout_free$link1
// file simple-watch.c line 284
static void timeout_free$link1(struct AvahiTimeout$1 *t$link1);
// timeout_free$link1$link1
// file simple-watch.c line 284
static void timeout_free$link1$link1(struct AvahiTimeout$0 *t$link1$link1);
// timeout_free$link1$link2
// file simple-watch.c line 284
static void timeout_free$link1$link2(struct AvahiTimeout$1 *t$link1$link2);
// timeout_free$link2
// file glib-watch.c line 201
static void timeout_free$link2(struct AvahiTimeout *t$link2);
// timeout_free$link3
// file simple-watch.c line 284
static void timeout_free$link3(struct AvahiTimeout$1 *t$link3);
// timeout_new
// file simple-watch.c line 244
static struct AvahiTimeout$1 * timeout_new(const struct AvahiPoll$1 *api, struct timeval *tv, void (*callback)(struct AvahiTimeout$1 *, void *), void *userdata);
// timeout_new$link1
// file simple-watch.c line 244
static struct AvahiTimeout$1 * timeout_new$link1(const struct AvahiPoll$1 *api$link1, struct timeval *tv$link1, void (*callback$link1)(struct AvahiTimeout$1 *, void *), void *userdata$link1);
// timeout_new$link1$link1
// file simple-watch.c line 244
static struct AvahiTimeout$0 * timeout_new$link1$link1(const struct AvahiPoll$0 *api$link1$link1, struct timeval *tv$link1$link1, void (*callback$link1$link1)(struct AvahiTimeout$0 *, void *), void *userdata$link1$link1);
// timeout_new$link1$link2
// file simple-watch.c line 244
static struct AvahiTimeout$1 * timeout_new$link1$link2(const struct AvahiPoll$1 *api$link1$link2, struct timeval *tv$link1$link2, void (*callback$link1$link2)(struct AvahiTimeout$1 *, void *), void *userdata$link1$link2);
// timeout_new$link2
// file glib-watch.c line 166
static struct AvahiTimeout * timeout_new$link2(const struct AvahiPoll *api$link2, struct timeval *tv$link2, void (*callback$link2)(struct AvahiTimeout *, void *), void *userdata$link2);
// timeout_new$link3
// file simple-watch.c line 244
static struct AvahiTimeout$1 * timeout_new$link3(const struct AvahiPoll$1 *api$link3, struct timeval *tv$link3, void (*callback$link3)(struct AvahiTimeout$1 *, void *), void *userdata$link3);
// timeout_new::callback$link1$link1$object
// 
//void callback$link1$link1$object(struct AvahiTimeout$0 *, void *);
// timeout_new::callback$link1$link2$object
// 
//void callback$link1$link2$object(struct AvahiTimeout$1 *, void *);
// timeout_new::callback$link1$object
// 
//void callback$link1$object(struct AvahiTimeout$1 *, void *);
// timeout_new::callback$link2$object
// 
//void callback$link2$object(struct AvahiTimeout *, void *);
// timeout_new::callback$link3$object
// 
//void callback$link3$object(struct AvahiTimeout$1 *, void *);
// timeout_new::callback$object
// 
//void callback$object(struct AvahiTimeout$1 *, void *);
// timeout_toggled
// file ../avahi-common/dbus-watch-glue.c line 300
static void timeout_toggled(struct DBusTimeout *dbus_timeout, void *userdata);
// timeout_toggled$link1
// file ../avahi-common/dbus-watch-glue.c line 300
static void timeout_toggled$link1(struct DBusTimeout *dbus_timeout$link1, void *userdata$link1);
// timeout_update
// file simple-watch.c line 273
static void timeout_update(struct AvahiTimeout$1 *t, struct timeval *tv);
// timeout_update$link1
// file simple-watch.c line 273
static void timeout_update$link1(struct AvahiTimeout$1 *t$link1, struct timeval *tv$link1);
// timeout_update$link1$link1
// file simple-watch.c line 273
static void timeout_update$link1$link1(struct AvahiTimeout$0 *t$link1$link1, struct timeval *tv$link1$link1);
// timeout_update$link1$link2
// file simple-watch.c line 273
static void timeout_update$link1$link2(struct AvahiTimeout$1 *t$link1$link2, struct timeval *tv$link1$link2);
// timeout_update$link2
// file glib-watch.c line 193
static void timeout_update$link2(struct AvahiTimeout *t$link2, struct timeval *tv$link2);
// timeout_update$link3
// file simple-watch.c line 273
static void timeout_update$link3(struct AvahiTimeout$1 *t$link3, struct timeval *tv$link3);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// translate_avahi_to_dbus
// file ../avahi-common/dbus-watch-glue.c line 46
static unsigned int translate_avahi_to_dbus(enum anonymous e);
// translate_avahi_to_dbus$link1
// file ../avahi-common/dbus-watch-glue.c line 46
static unsigned int translate_avahi_to_dbus$link1(enum anonymous e$link1);
// translate_dbus_to_avahi
// file ../avahi-common/dbus-watch-glue.c line 31
static enum anonymous translate_dbus_to_avahi(unsigned int f);
// translate_dbus_to_avahi$link1
// file ../avahi-common/dbus-watch-glue.c line 31
static enum anonymous translate_dbus_to_avahi$link1(unsigned int f$link1);
// update_timeout
// file ../avahi-common/dbus-watch-glue.c line 223
static void update_timeout(struct TimeoutData *timeout);
// update_timeout$link1
// file ../avahi-common/dbus-watch-glue.c line 223
static void update_timeout$link1(struct TimeoutData *timeout$link1);
// update_watch
// file ../avahi-common/dbus-watch-glue.c line 125
static unsigned int update_watch(const struct AvahiPoll$1 *poll_api, struct DBusWatch *dbus_watch);
// update_watch$link1
// file ../avahi-common/dbus-watch-glue.c line 125
static unsigned int update_watch$link1(const struct AvahiPoll$1 *poll_api$link1, struct DBusWatch *dbus_watch$link1);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// watch_callback
// file ../avahi-common/dbus-watch-glue.c line 115
static void watch_callback(struct AvahiWatch$1 *avahi_watch, signed int fd, enum anonymous events, void *userdata);
// watch_callback$link1
// file ../avahi-common/dbus-watch-glue.c line 115
static void watch_callback$link1(struct AvahiWatch$1 *avahi_watch$link1, signed int fd$link1, enum anonymous events$link1, void *userdata$link1);
// watch_free
// file simple-watch.c line 203
static void watch_free(struct AvahiWatch$1 *w);
// watch_free$link1
// file simple-watch.c line 203
static void watch_free$link1(struct AvahiWatch$1 *w$link1);
// watch_free$link1$link1
// file simple-watch.c line 203
static void watch_free$link1$link1(struct AvahiWatch *w$link1$link1);
// watch_free$link1$link2
// file simple-watch.c line 203
static void watch_free$link1$link2(struct AvahiWatch$1 *w$link1$link2);
// watch_free$link2
// file glib-watch.c line 153
static void watch_free$link2(struct AvahiWatch$0 *w$link2);
// watch_free$link3
// file simple-watch.c line 203
static void watch_free$link3(struct AvahiWatch$1 *w$link3);
// watch_get_events
// file simple-watch.c line 184
static enum anonymous watch_get_events(struct AvahiWatch$1 *w);
// watch_get_events$link1
// file simple-watch.c line 184
static enum anonymous watch_get_events$link1(struct AvahiWatch$1 *w$link1);
// watch_get_events$link1$link1
// file simple-watch.c line 184
static enum anonymous watch_get_events$link1$link1(struct AvahiWatch *w$link1$link1);
// watch_get_events$link1$link2
// file simple-watch.c line 184
static enum anonymous watch_get_events$link1$link2(struct AvahiWatch$1 *w$link1$link2);
// watch_get_events$link2
// file glib-watch.c line 146
static enum anonymous watch_get_events$link2(struct AvahiWatch$0 *w$link2);
// watch_get_events$link3
// file simple-watch.c line 184
static enum anonymous watch_get_events$link3(struct AvahiWatch$1 *w$link3);
// watch_new
// file simple-watch.c line 132
static struct AvahiWatch$1 * watch_new(const struct AvahiPoll$1 *api, signed int fd, enum anonymous event, void (*callback)(struct AvahiWatch$1 *, signed int, enum anonymous, void *), void *userdata);
// watch_new$link1
// file simple-watch.c line 132
static struct AvahiWatch$1 * watch_new$link1(const struct AvahiPoll$1 *api$link1, signed int fd$link1, enum anonymous event$link1, void (*callback$link1)(struct AvahiWatch$1 *, signed int, enum anonymous, void *), void *userdata$link1);
// watch_new$link1$link1
// file simple-watch.c line 132
static struct AvahiWatch * watch_new$link1$link1(const struct AvahiPoll$0 *api$link1$link1, signed int fd$link1$link1, enum anonymous event$link2, void (*callback$link1$link1)(struct AvahiWatch *, signed int, enum anonymous, void *), void *userdata$link1$link1);
// watch_new$link1$link2
// file simple-watch.c line 132
static struct AvahiWatch$1 * watch_new$link1$link2(const struct AvahiPoll$1 *api$link1$link2, signed int fd$link1$link2, enum anonymous event$link1$link1, void (*callback$link1$link2)(struct AvahiWatch$1 *, signed int, enum anonymous, void *), void *userdata$link1$link2);
// watch_new$link2
// file glib-watch.c line 109
static struct AvahiWatch$0 * watch_new$link2(const struct AvahiPoll *api$link2, signed int fd$link2, enum anonymous events, void (*callback$link2)(struct AvahiWatch$0 *, signed int, enum anonymous, void *), void *userdata$link2);
// watch_new$link3
// file simple-watch.c line 132
static struct AvahiWatch$1 * watch_new$link3(const struct AvahiPoll$1 *api$link3, signed int fd$link3, enum anonymous event$link3, void (*callback$link3)(struct AvahiWatch$1 *, signed int, enum anonymous, void *), void *userdata$link3);
// watch_new::callback$link1$link1$object
// 
//void callback$link1$link1$object(struct AvahiWatch *, signed int, enum anonymous, void *);
// watch_new::callback$link1$link2$object
// 
//void callback$link1$link2$object(struct AvahiWatch$1 *, signed int, enum anonymous, void *);
// watch_new::callback$link1$object
// 
//void callback$link1$object(struct AvahiWatch$1 *, signed int, enum anonymous, void *);
// watch_new::callback$link2$object
// 
//void callback$link2$object(struct AvahiWatch$0 *, signed int, enum anonymous, void *);
// watch_new::callback$link3$object
// 
//void callback$link3$object(struct AvahiWatch$1 *, signed int, enum anonymous, void *);
// watch_new::callback$object
// 
//void callback$object(struct AvahiWatch$1 *, signed int, enum anonymous, void *);
// watch_toggled
// file ../avahi-common/dbus-watch-glue.c line 187
static void watch_toggled(struct DBusWatch *dbus_watch, void *userdata);
// watch_toggled$link1
// file ../avahi-common/dbus-watch-glue.c line 187
static void watch_toggled$link1(struct DBusWatch *dbus_watch$link1, void *userdata$link1);
// watch_update
// file simple-watch.c line 168
static void watch_update(struct AvahiWatch$1 *w, enum anonymous events);
// watch_update$link1
// file simple-watch.c line 168
static void watch_update$link1(struct AvahiWatch$1 *w$link1, enum anonymous events$link1);
// watch_update$link1$link1
// file simple-watch.c line 168
static void watch_update$link1$link1(struct AvahiWatch *w$link1$link1, enum anonymous events$link1$link1);
// watch_update$link1$link2
// file simple-watch.c line 168
static void watch_update$link1$link2(struct AvahiWatch$1 *w$link1$link2, enum anonymous events$link1$link2);
// watch_update$link2
// file glib-watch.c line 139
static void watch_update$link2(struct AvahiWatch$0 *w$link2, enum anonymous events$link2);
// watch_update$link3
// file simple-watch.c line 168
static void watch_update$link3(struct AvahiWatch$1 *w$link3, enum anonymous events$link3);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// xcalloc
// file malloc.c line 89
static void * xcalloc(unsigned long int nmemb, unsigned long int size);
// xcalloc$link1
// file malloc.c line 89
static void * xcalloc$link1(unsigned long int nmemb$link1, unsigned long int size$link1);
// xcalloc$link1$link1
// file malloc.c line 89
static void * xcalloc$link1$link1(unsigned long int nmemb$link1$link1, unsigned long int size$link1$link1);
// xcalloc$link2
// file malloc.c line 89
static void * xcalloc$link2(unsigned long int nmemb$link2, unsigned long int size$link2);
// xcalloc$link3
// file malloc.c line 89
static void * xcalloc$link3(unsigned long int nmemb$link3, unsigned long int size$link3);
// xmalloc
// file malloc.c line 62
static void * xmalloc(unsigned long int size);
// xmalloc$link1
// file malloc.c line 62
static void * xmalloc$link1(unsigned long int size$link1);
// xmalloc$link1$link1
// file malloc.c line 62
static void * xmalloc$link1$link1(unsigned long int size$link1$link1);
// xmalloc$link2
// file malloc.c line 62
static void * xmalloc$link2(unsigned long int size$link2);
// xmalloc$link3
// file malloc.c line 62
static void * xmalloc$link3(unsigned long int size$link3);
// xrealloc
// file malloc.c line 75
static void * xrealloc(void *p, unsigned long int size);
// xrealloc$link1
// file malloc.c line 75
static void * xrealloc$link1(void *p$link1, unsigned long int size$link1);
// xrealloc$link1$link1
// file malloc.c line 75
static void * xrealloc$link1$link1(void *p$link1$link1, unsigned long int size$link1$link1);
// xrealloc$link2
// file malloc.c line 75
static void * xrealloc$link2(void *p$link2, unsigned long int size$link2);
// xrealloc$link3
// file malloc.c line 75
static void * xrealloc$link3(void *p$link3, unsigned long int size$link3);

struct anonymous$37
{
  // dptr
  char *dptr;
  // dsize
  signed int dsize;
};

struct anonymous$28
{
  // connection
  struct DBusConnection *connection;
  // poll_api
  const struct AvahiPoll$1 *poll_api;
  // dispatch_timeout
  struct AvahiTimeout$1 *dispatch_timeout;
  // ref
  signed int ref;
};

struct anonymous$36
{
  // dummy
  signed int dummy[10l];
};

struct anonymous$8
{
  // __val
  unsigned long int __val[16l];
};

union anonymous$38
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$54
{
  // v_int
  signed int v_int;
  // v_uint
  unsigned int v_uint;
  // v_long
  signed long int v_long;
  // v_ulong
  unsigned long int v_ulong;
  // v_int64
  signed long int v_int64;
  // v_uint64
  unsigned long int v_uint64;
  // v_float
  float v_float;
  // v_double
  double v_double;
  // v_pointer
  void *v_pointer;
};

struct AvahiIPv6Address
{
  // address
  unsigned char address[16l];
};

struct AvahiIPv4Address
{
  // address
  unsigned int address;
};

union anonymous$15
{
  // ipv6
  struct AvahiIPv6Address ipv6;
  // ipv4
  struct AvahiIPv4Address ipv4;
  // data
  unsigned char data[1l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$6
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct AvahiAddress
{
  // proto
  signed int proto;
  // data
  union anonymous$15 data;
};

struct AvahiAddressResolver
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiAddressResolver *, signed int, signed int, enum anonymous$12, const struct AvahiAddress *, const char *, enum anonymous$13, void *);
  // userdata
  void *userdata;
  // address_resolvers_next
  struct AvahiAddressResolver *address_resolvers_next;
  // address_resolvers_prev
  struct AvahiAddressResolver *address_resolvers_prev;
  // address
  struct AvahiAddress address;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiAllocator
{
  // malloc
  void * (*malloc)(unsigned long int);
  // free
  void (*free)(void *);
  // realloc
  void * (*realloc)(void *, unsigned long int);
  // calloc
  void * (*calloc)(unsigned long int, unsigned long int);
};

struct AvahiClient
{
  // poll_api
  const struct AvahiPoll$1 *poll_api;
  // bus
  struct DBusConnection *bus;
  // error
  signed int error;
  // state
  enum anonymous$11 state;
  // flags
  enum anonymous$39 flags;
  // version_string
  char *version_string;
  // host_name
  char *host_name;
  // host_name_fqdn
  char *host_name_fqdn;
  // domain_name
  char *domain_name;
  // local_service_cookie
  unsigned int local_service_cookie;
  // local_service_cookie_valid
  signed int local_service_cookie_valid;
  // callback
  void (*callback)(struct AvahiClient *, enum anonymous$11, void *);
  // userdata
  void *userdata;
  // groups
  struct AvahiEntryGroup *groups;
  // domain_browsers
  struct AvahiDomainBrowser *domain_browsers;
  // service_browsers
  struct AvahiServiceBrowser *service_browsers;
  // service_type_browsers
  struct AvahiServiceTypeBrowser *service_type_browsers;
  // service_resolvers
  struct AvahiServiceResolver *service_resolvers;
  // host_name_resolvers
  struct AvahiHostNameResolver *host_name_resolvers;
  // address_resolvers
  struct AvahiAddressResolver *address_resolvers;
  // record_browsers
  struct AvahiRecordBrowser *record_browsers;
};

struct AvahiDomainBrowser
{
  // ref
  signed int ref;
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous$14, const char *, enum anonymous$13, void *);
  // userdata
  void *userdata;
  // domain_browsers_next
  struct AvahiDomainBrowser *domain_browsers_next;
  // domain_browsers_prev
  struct AvahiDomainBrowser *domain_browsers_prev;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
  // defer_timeout
  struct AvahiTimeout$1 *defer_timeout;
  // static_browse_domains
  struct AvahiStringList *static_browse_domains;
};

struct AvahiEntryGroup
{
  // path
  char *path;
  // state
  enum anonymous$40 state;
  // state_valid
  signed int state_valid;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiEntryGroup *, enum anonymous$40, void *);
  // userdata
  void *userdata;
  // groups_next
  struct AvahiEntryGroup *groups_next;
  // groups_prev
  struct AvahiEntryGroup *groups_prev;
};

struct _GSource
{
  // callback_data
  void *callback_data;
  // callback_funcs
  struct _GSourceCallbackFuncs *callback_funcs;
  // source_funcs
  const struct _GSourceFuncs *source_funcs;
  // ref_count
  unsigned int ref_count;
  // context
  struct _GMainContext *context;
  // priority
  signed int priority;
  // flags
  unsigned int flags;
  // source_id
  unsigned int source_id;
  // poll_fds
  struct _GSList *poll_fds;
  // prev
  struct _GSource *prev;
  // next
  struct _GSource *next;
  // name
  char *name;
  // priv
  struct _GSourcePrivate *priv;
};

struct AvahiPoll
{
  // userdata
  void *userdata;
  // watch_new
  struct AvahiWatch$0 * (*watch_new)(const struct AvahiPoll *, signed int, enum anonymous, void (*)(struct AvahiWatch$0 *, signed int, enum anonymous, void *), void *);
  // watch_update
  void (*watch_update)(struct AvahiWatch$0 *, enum anonymous);
  // watch_get_events
  enum anonymous (*watch_get_events)(struct AvahiWatch$0 *);
  // watch_free
  void (*watch_free)(struct AvahiWatch$0 *);
  // timeout_new
  struct AvahiTimeout * (*timeout_new)(const struct AvahiPoll *, struct timeval *, void (*)(struct AvahiTimeout *, void *), void *);
  // timeout_update
  void (*timeout_update)(struct AvahiTimeout *, struct timeval *);
  // timeout_free
  void (*timeout_free)(struct AvahiTimeout *);
};

struct AvahiGLibPoll
{
  // source
  struct _GSource source;
  // api
  struct AvahiPoll api;
  // context
  struct _GMainContext *context;
  // timeout_req_cleanup
  signed int timeout_req_cleanup;
  // watch_req_cleanup
  signed int watch_req_cleanup;
  // watches
  struct AvahiWatch$0 *watches;
  // timeouts
  struct AvahiTimeout *timeouts;
};

struct AvahiHostNameResolver
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous$12, const char *, const struct AvahiAddress *, enum anonymous$13, void *);
  // userdata
  void *userdata;
  // host_name_resolvers_next
  struct AvahiHostNameResolver *host_name_resolvers_next;
  // host_name_resolvers_prev
  struct AvahiHostNameResolver *host_name_resolvers_prev;
  // host_name
  char *host_name;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiPoll$1
{
  // userdata
  void *userdata;
  // watch_new
  struct AvahiWatch$1 * (*watch_new)(const struct AvahiPoll$1 *, signed int, enum anonymous, void (*)(struct AvahiWatch$1 *, signed int, enum anonymous, void *), void *);
  // watch_update
  void (*watch_update)(struct AvahiWatch$1 *, enum anonymous);
  // watch_get_events
  enum anonymous (*watch_get_events)(struct AvahiWatch$1 *);
  // watch_free
  void (*watch_free)(struct AvahiWatch$1 *);
  // timeout_new
  struct AvahiTimeout$1 * (*timeout_new)(const struct AvahiPoll$1 *, struct timeval *, void (*)(struct AvahiTimeout$1 *, void *), void *);
  // timeout_update
  void (*timeout_update)(struct AvahiTimeout$1 *, struct timeval *);
  // timeout_free
  void (*timeout_free)(struct AvahiTimeout$1 *);
};

struct AvahiPoll$0
{
  // userdata
  void *userdata;
  // watch_new
  struct AvahiWatch * (*watch_new)(const struct AvahiPoll$0 *, signed int, enum anonymous, void (*)(struct AvahiWatch *, signed int, enum anonymous, void *), void *);
  // watch_update
  void (*watch_update)(struct AvahiWatch *, enum anonymous);
  // watch_get_events
  enum anonymous (*watch_get_events)(struct AvahiWatch *);
  // watch_free
  void (*watch_free)(struct AvahiWatch *);
  // timeout_new
  struct AvahiTimeout$0 * (*timeout_new)(const struct AvahiPoll$0 *, struct timeval *, void (*)(struct AvahiTimeout$0 *, void *), void *);
  // timeout_update
  void (*timeout_update)(struct AvahiTimeout$0 *, struct timeval *);
  // timeout_free
  void (*timeout_free)(struct AvahiTimeout$0 *);
};

struct AvahiRList
{
  // rlist_next
  struct AvahiRList *rlist_next;
  // rlist_prev
  struct AvahiRList *rlist_prev;
  // data
  void *data;
};

struct AvahiRecordBrowser
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous$14, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous$13, void *);
  // userdata
  void *userdata;
  // record_browsers_next
  struct AvahiRecordBrowser *record_browsers_next;
  // record_browsers_prev
  struct AvahiRecordBrowser *record_browsers_prev;
  // name
  char *name;
  // clazz
  unsigned short int clazz;
  // type
  unsigned short int type;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiServiceBrowser
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous$14, const char *, const char *, const char *, enum anonymous$13, void *);
  // userdata
  void *userdata;
  // service_browsers_next
  struct AvahiServiceBrowser *service_browsers_next;
  // service_browsers_prev
  struct AvahiServiceBrowser *service_browsers_prev;
  // type
  char *type;
  // domain
  char *domain;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiServiceResolver
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiServiceResolver *, signed int, signed int, enum anonymous$12, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous$13, void *);
  // userdata
  void *userdata;
  // service_resolvers_next
  struct AvahiServiceResolver *service_resolvers_next;
  // service_resolvers_prev
  struct AvahiServiceResolver *service_resolvers_prev;
  // name
  char *name;
  // type
  char *type;
  // domain
  char *domain;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiServiceTypeBrowser
{
  // path
  char *path;
  // client
  struct AvahiClient *client;
  // callback
  void (*callback)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous$14, const char *, const char *, enum anonymous$13, void *);
  // userdata
  void *userdata;
  // service_type_browsers_next
  struct AvahiServiceTypeBrowser *service_type_browsers_next;
  // service_type_browsers_prev
  struct AvahiServiceTypeBrowser *service_type_browsers_prev;
  // domain
  char *domain;
  // interface
  signed int interface;
  // protocol
  signed int protocol;
};

struct AvahiSimplePoll$0
{
  // api
  struct AvahiPoll$1 api;
  // poll_func
  signed int (*poll_func)(struct pollfd *, unsigned int, signed int, void *);
  // poll_func_userdata
  void *poll_func_userdata;
  // pollfds
  struct pollfd *pollfds;
  // n_pollfds
  signed int n_pollfds;
  // max_pollfds
  signed int max_pollfds;
  // rebuild_pollfds
  signed int rebuild_pollfds;
  // watch_req_cleanup
  signed int watch_req_cleanup;
  // timeout_req_cleanup
  signed int timeout_req_cleanup;
  // quit
  signed int quit;
  // events_valid
  signed int events_valid;
  // n_watches
  signed int n_watches;
  // watches
  struct AvahiWatch$1 *watches;
  // timeouts
  struct AvahiTimeout$1 *timeouts;
  // wakeup_pipe
  signed int wakeup_pipe[2l];
  // wakeup_issued
  signed int wakeup_issued;
  // prepared_timeout
  signed int prepared_timeout;
  // state
  enum anonymous$31 state;
};

struct AvahiSimplePoll
{
  // api
  struct AvahiPoll$0 api;
  // poll_func
  signed int (*poll_func)(struct pollfd *, unsigned int, signed int, void *);
  // poll_func_userdata
  void *poll_func_userdata;
  // pollfds
  struct pollfd *pollfds;
  // n_pollfds
  signed int n_pollfds;
  // max_pollfds
  signed int max_pollfds;
  // rebuild_pollfds
  signed int rebuild_pollfds;
  // watch_req_cleanup
  signed int watch_req_cleanup;
  // timeout_req_cleanup
  signed int timeout_req_cleanup;
  // quit
  signed int quit;
  // events_valid
  signed int events_valid;
  // n_watches
  signed int n_watches;
  // watches
  struct AvahiWatch *watches;
  // timeouts
  struct AvahiTimeout$0 *timeouts;
  // wakeup_pipe
  signed int wakeup_pipe[2l];
  // wakeup_issued
  signed int wakeup_issued;
  // prepared_timeout
  signed int prepared_timeout;
  // state
  enum anonymous$31 state;
};

struct AvahiStringList
{
  // next
  struct AvahiStringList *next;
  // size
  unsigned long int size;
  // text
  unsigned char text[1l];
};

struct AvahiThreadedPoll$0
{
  // simple_poll
  struct AvahiSimplePoll$0 *simple_poll;
  // thread_id
  unsigned long int thread_id;
  // mutex
  union anonymous$6 mutex;
  // thread_running
  signed int thread_running;
  // retval
  signed int retval;
};

struct AvahiThreadedPoll
{
  // simple_poll
  struct AvahiSimplePoll *simple_poll;
  // thread_id
  unsigned long int thread_id;
  // mutex
  union anonymous$6 mutex;
  // thread_running
  signed int thread_running;
  // retval
  signed int retval;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct AvahiTimeout$1
{
  // simple_poll
  struct AvahiSimplePoll$0 *simple_poll;
  // dead
  signed int dead;
  // enabled
  signed int enabled;
  // expiry
  struct timeval expiry;
  // callback
  void (*callback)(struct AvahiTimeout$1 *, void *);
  // userdata
  void *userdata;
  // timeouts_next
  struct AvahiTimeout$1 *timeouts_next;
  // timeouts_prev
  struct AvahiTimeout$1 *timeouts_prev;
};

struct AvahiTimeout$0
{
  // simple_poll
  struct AvahiSimplePoll *simple_poll;
  // dead
  signed int dead;
  // enabled
  signed int enabled;
  // expiry
  struct timeval expiry;
  // callback
  void (*callback)(struct AvahiTimeout$0 *, void *);
  // userdata
  void *userdata;
  // timeouts_next
  struct AvahiTimeout$0 *timeouts_next;
  // timeouts_prev
  struct AvahiTimeout$0 *timeouts_prev;
};

struct AvahiTimeout
{
  // glib_poll
  struct AvahiGLibPoll *glib_poll;
  // dead
  signed int dead;
  // enabled
  signed int enabled;
  // expiry
  struct timeval expiry;
  // callback
  void (*callback)(struct AvahiTimeout *, void *);
  // userdata
  void *userdata;
  // timeouts_next
  struct AvahiTimeout *timeouts_next;
  // timeouts_prev
  struct AvahiTimeout *timeouts_prev;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

struct AvahiWatch$1
{
  // simple_poll
  struct AvahiSimplePoll$0 *simple_poll;
  // dead
  signed int dead;
  // idx
  signed int idx;
  // pollfd
  struct pollfd pollfd;
  // callback
  void (*callback)(struct AvahiWatch$1 *, signed int, enum anonymous, void *);
  // userdata
  void *userdata;
  // watches_next
  struct AvahiWatch$1 *watches_next;
  // watches_prev
  struct AvahiWatch$1 *watches_prev;
};

struct AvahiWatch
{
  // simple_poll
  struct AvahiSimplePoll *simple_poll;
  // dead
  signed int dead;
  // idx
  signed int idx;
  // pollfd
  struct pollfd pollfd;
  // callback
  void (*callback)(struct AvahiWatch *, signed int, enum anonymous, void *);
  // userdata
  void *userdata;
  // watches_next
  struct AvahiWatch *watches_next;
  // watches_prev
  struct AvahiWatch *watches_prev;
};

struct _GPollFD
{
  // fd
  signed int fd;
  // events
  unsigned short int events;
  // revents
  unsigned short int revents;
};

struct AvahiWatch$0
{
  // glib_poll
  struct AvahiGLibPoll *glib_poll;
  // dead
  signed int dead;
  // pollfd
  struct _GPollFD pollfd;
  // pollfd_added
  signed int pollfd_added;
  // callback
  void (*callback)(struct AvahiWatch$0 *, signed int, enum anonymous, void *);
  // userdata
  void *userdata;
  // watches_next
  struct AvahiWatch$0 *watches_next;
  // watches_prev
  struct AvahiWatch$0 *watches_prev;
};

struct Config
{
  // domain
  char *domain;
  // command
  enum anonymous$9 command;
};

struct DBusError
{
  // name
  const char *name;
  // message
  const char *message;
  // dummy1
  unsigned int dummy1 : 1;
  // dummy2
  unsigned int dummy2 : 1;
  // dummy3
  unsigned int dummy3 : 1;
  // dummy4
  unsigned int dummy4 : 1;
  // dummy5
  unsigned int dummy5 : 1;
  // padding1
  void *padding1;
};

struct DBusMessageIter
{
  // dummy1
  void *dummy1;
  // dummy2
  void *dummy2;
  // dummy3
  unsigned int dummy3;
  // dummy4
  signed int dummy4;
  // dummy5
  signed int dummy5;
  // dummy6
  signed int dummy6;
  // dummy7
  signed int dummy7;
  // dummy8
  signed int dummy8;
  // dummy9
  signed int dummy9;
  // dummy10
  signed int dummy10;
  // dummy11
  signed int dummy11;
  // pad1
  signed int pad1;
  // pad2
  signed int pad2;
  // pad3
  void *pad3;
};

struct TimeoutData
{
  // poll_api
  const struct AvahiPoll$1 *poll_api;
  // avahi_timeout
  struct AvahiTimeout$1 *avahi_timeout;
  // dbus_timeout
  struct DBusTimeout *dbus_timeout;
  // ref
  signed int ref;
};

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _AtkObject
{
  // parent
  struct _GObject parent;
  // description
  char *description;
  // name
  char *name;
  // accessible_parent
  struct _AtkObject *accessible_parent;
  // role
  enum anonymous$24 role;
  // relation_set
  struct _AtkRelationSet *relation_set;
  // layer
  enum anonymous$25 layer;
};

struct _AtkRelationSet
{
  // parent
  struct _GObject parent;
  // relations
  struct _GPtrArray *relations;
};

struct _GtkWidget
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GtkWidgetPrivate *priv;
};

struct _GtkContainer
{
  // widget
  struct _GtkWidget widget;
  // priv
  struct _GtkContainerPrivate *priv;
};

struct _GtkBin
{
  // container
  struct _GtkContainer container;
  // priv
  struct _GtkBinPrivate *priv;
};

struct _GtkWindow
{
  // bin
  struct _GtkBin bin;
  // priv
  struct _GtkWindowPrivate *priv;
};

struct _GtkDialog
{
  // window
  struct _GtkWindow window;
  // priv
  struct _GtkDialogPrivate *priv;
};

struct _AuiServiceDialog
{
  // parent_instance
  struct _GtkDialog parent_instance;
  // priv
  struct _AuiServiceDialogPrivate *priv;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _GObjectClass
{
  // g_type_class
  struct _GTypeClass g_type_class;
  // construct_properties
  struct _GSList *construct_properties;
  // constructor
  struct _GObject * (*constructor)(unsigned long int, unsigned int, struct _GObjectConstructParam *);
  // set_property
  void (*set_property)(struct _GObject *, unsigned int, const struct _GValue *, struct _GParamSpec *);
  // get_property
  void (*get_property)(struct _GObject *, unsigned int, struct _GValue *, struct _GParamSpec *);
  // dispose
  void (*dispose)(struct _GObject *);
  // finalize
  void (*finalize)(struct _GObject *);
  // dispatch_properties_changed
  void (*dispatch_properties_changed)(struct _GObject *, unsigned int, struct _GParamSpec **);
  // notify
  void (*notify)(struct _GObject *, struct _GParamSpec *);
  // constructed
  void (*constructed)(struct _GObject *);
  // flags
  unsigned long int flags;
  // pdummy
  void *pdummy[6l];
};

struct _GtkWidgetClass
{
  // parent_class
  struct _GObjectClass parent_class;
  // activate_signal
  unsigned int activate_signal;
  // dispatch_child_properties_changed
  void (*dispatch_child_properties_changed)(struct _GtkWidget *, unsigned int, struct _GParamSpec **);
  // destroy
  void (*destroy)(struct _GtkWidget *);
  // show
  void (*show)(struct _GtkWidget *);
  // show_all
  void (*show_all)(struct _GtkWidget *);
  // hide
  void (*hide)(struct _GtkWidget *);
  // map
  void (*map)(struct _GtkWidget *);
  // unmap
  void (*unmap)(struct _GtkWidget *);
  // realize
  void (*realize)(struct _GtkWidget *);
  // unrealize
  void (*unrealize)(struct _GtkWidget *);
  // size_allocate
  void (*size_allocate)(struct _GtkWidget *, struct _cairo_rectangle_int *);
  // state_changed
  void (*state_changed)(struct _GtkWidget *, enum anonymous$18);
  // state_flags_changed
  void (*state_flags_changed)(struct _GtkWidget *, enum anonymous$19);
  // parent_set
  void (*parent_set)(struct _GtkWidget *, struct _GtkWidget *);
  // hierarchy_changed
  void (*hierarchy_changed)(struct _GtkWidget *, struct _GtkWidget *);
  // style_set
  void (*style_set)(struct _GtkWidget *, struct _GtkStyle *);
  // direction_changed
  void (*direction_changed)(struct _GtkWidget *, enum anonymous$20);
  // grab_notify
  void (*grab_notify)(struct _GtkWidget *, signed int);
  // child_notify
  void (*child_notify)(struct _GtkWidget *, struct _GParamSpec *);
  // draw
  signed int (*draw)(struct _GtkWidget *, struct _cairo *);
  // get_request_mode
  enum anonymous$21 (*get_request_mode)(struct _GtkWidget *);
  // get_preferred_height
  void (*get_preferred_height)(struct _GtkWidget *, signed int *, signed int *);
  // get_preferred_width_for_height
  void (*get_preferred_width_for_height)(struct _GtkWidget *, signed int, signed int *, signed int *);
  // get_preferred_width
  void (*get_preferred_width)(struct _GtkWidget *, signed int *, signed int *);
  // get_preferred_height_for_width
  void (*get_preferred_height_for_width)(struct _GtkWidget *, signed int, signed int *, signed int *);
  // mnemonic_activate
  signed int (*mnemonic_activate)(struct _GtkWidget *, signed int);
  // grab_focus
  void (*grab_focus)(struct _GtkWidget *);
  // focus
  signed int (*focus)(struct _GtkWidget *, enum anonymous$22);
  // move_focus
  void (*move_focus)(struct _GtkWidget *, enum anonymous$22);
  // keynav_failed
  signed int (*keynav_failed)(struct _GtkWidget *, enum anonymous$22);
  // event
  signed int (*event)(struct _GtkWidget *, union _GdkEvent *);
  // button_press_event
  signed int (*button_press_event)(struct _GtkWidget *, struct _GdkEventButton *);
  // button_release_event
  signed int (*button_release_event)(struct _GtkWidget *, struct _GdkEventButton *);
  // scroll_event
  signed int (*scroll_event)(struct _GtkWidget *, struct _GdkEventScroll *);
  // motion_notify_event
  signed int (*motion_notify_event)(struct _GtkWidget *, struct _GdkEventMotion *);
  // delete_event
  signed int (*delete_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // destroy_event
  signed int (*destroy_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // key_press_event
  signed int (*key_press_event)(struct _GtkWidget *, struct _GdkEventKey *);
  // key_release_event
  signed int (*key_release_event)(struct _GtkWidget *, struct _GdkEventKey *);
  // enter_notify_event
  signed int (*enter_notify_event)(struct _GtkWidget *, struct _GdkEventCrossing *);
  // leave_notify_event
  signed int (*leave_notify_event)(struct _GtkWidget *, struct _GdkEventCrossing *);
  // configure_event
  signed int (*configure_event)(struct _GtkWidget *, struct _GdkEventConfigure *);
  // focus_in_event
  signed int (*focus_in_event)(struct _GtkWidget *, struct _GdkEventFocus *);
  // focus_out_event
  signed int (*focus_out_event)(struct _GtkWidget *, struct _GdkEventFocus *);
  // map_event
  signed int (*map_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // unmap_event
  signed int (*unmap_event)(struct _GtkWidget *, struct _GdkEventAny *);
  // property_notify_event
  signed int (*property_notify_event)(struct _GtkWidget *, struct _GdkEventProperty *);
  // selection_clear_event
  signed int (*selection_clear_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // selection_request_event
  signed int (*selection_request_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // selection_notify_event
  signed int (*selection_notify_event)(struct _GtkWidget *, struct _GdkEventSelection *);
  // proximity_in_event
  signed int (*proximity_in_event)(struct _GtkWidget *, struct _GdkEventProximity *);
  // proximity_out_event
  signed int (*proximity_out_event)(struct _GtkWidget *, struct _GdkEventProximity *);
  // visibility_notify_event
  signed int (*visibility_notify_event)(struct _GtkWidget *, struct _GdkEventVisibility *);
  // window_state_event
  signed int (*window_state_event)(struct _GtkWidget *, struct _GdkEventWindowState *);
  // damage_event
  signed int (*damage_event)(struct _GtkWidget *, struct _GdkEventExpose *);
  // grab_broken_event
  signed int (*grab_broken_event)(struct _GtkWidget *, struct _GdkEventGrabBroken *);
  // selection_get
  void (*selection_get)(struct _GtkWidget *, struct _GtkSelectionData *, unsigned int, unsigned int);
  // selection_received
  void (*selection_received)(struct _GtkWidget *, struct _GtkSelectionData *, unsigned int);
  // drag_begin
  void (*drag_begin)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_end
  void (*drag_end)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_data_get
  void (*drag_data_get)(struct _GtkWidget *, struct _GdkDragContext *, struct _GtkSelectionData *, unsigned int, unsigned int);
  // drag_data_delete
  void (*drag_data_delete)(struct _GtkWidget *, struct _GdkDragContext *);
  // drag_leave
  void (*drag_leave)(struct _GtkWidget *, struct _GdkDragContext *, unsigned int);
  // drag_motion
  signed int (*drag_motion)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, unsigned int);
  // drag_drop
  signed int (*drag_drop)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, unsigned int);
  // drag_data_received
  void (*drag_data_received)(struct _GtkWidget *, struct _GdkDragContext *, signed int, signed int, struct _GtkSelectionData *, unsigned int, unsigned int);
  // drag_failed
  signed int (*drag_failed)(struct _GtkWidget *, struct _GdkDragContext *, enum anonymous$23);
  // popup_menu
  signed int (*popup_menu)(struct _GtkWidget *);
  // show_help
  signed int (*show_help)(struct _GtkWidget *, enum anonymous$26);
  // get_accessible
  struct _AtkObject * (*get_accessible)(struct _GtkWidget *);
  // screen_changed
  void (*screen_changed)(struct _GtkWidget *, struct _GdkScreen *);
  // can_activate_accel
  signed int (*can_activate_accel)(struct _GtkWidget *, unsigned int);
  // composited_changed
  void (*composited_changed)(struct _GtkWidget *);
  // query_tooltip
  signed int (*query_tooltip)(struct _GtkWidget *, signed int, signed int, signed int, struct _GtkTooltip *);
  // compute_expand
  void (*compute_expand)(struct _GtkWidget *, signed int *, signed int *);
  // adjust_size_request
  void (*adjust_size_request)(struct _GtkWidget *, enum anonymous$16, signed int *, signed int *);
  // adjust_size_allocation
  void (*adjust_size_allocation)(struct _GtkWidget *, enum anonymous$16, signed int *, signed int *, signed int *, signed int *);
  // style_updated
  void (*style_updated)(struct _GtkWidget *);
  // touch_event
  signed int (*touch_event)(struct _GtkWidget *, struct _GdkEventTouch *);
  // get_preferred_height_and_baseline_for_width
  void (*get_preferred_height_and_baseline_for_width)(struct _GtkWidget *, signed int, signed int *, signed int *, signed int *, signed int *);
  // adjust_baseline_request
  void (*adjust_baseline_request)(struct _GtkWidget *, signed int *, signed int *);
  // adjust_baseline_allocation
  void (*adjust_baseline_allocation)(struct _GtkWidget *, signed int *);
  // queue_draw_region
  void (*queue_draw_region)(struct _GtkWidget *, const struct _cairo_region *);
  // priv
  struct _GtkWidgetClassPrivate *priv;
  // _gtk_reserved6
  void (*_gtk_reserved6)(void);
  // _gtk_reserved7
  void (*_gtk_reserved7)(void);
};

struct _GtkContainerClass
{
  // parent_class
  struct _GtkWidgetClass parent_class;
  // add
  void (*add)(struct _GtkContainer *, struct _GtkWidget *);
  // remove
  void (*remove)(struct _GtkContainer *, struct _GtkWidget *);
  // check_resize
  void (*check_resize)(struct _GtkContainer *);
  // forall
  void (*forall)(struct _GtkContainer *, signed int, void (*)(struct _GtkWidget *, void *), void *);
  // set_focus_child
  void (*set_focus_child)(struct _GtkContainer *, struct _GtkWidget *);
  // child_type
  unsigned long int (*child_type)(struct _GtkContainer *);
  // composite_name
  char * (*composite_name)(struct _GtkContainer *, struct _GtkWidget *);
  // set_child_property
  void (*set_child_property)(struct _GtkContainer *, struct _GtkWidget *, unsigned int, const struct _GValue *, struct _GParamSpec *);
  // get_child_property
  void (*get_child_property)(struct _GtkContainer *, struct _GtkWidget *, unsigned int, struct _GValue *, struct _GParamSpec *);
  // get_path_for_child
  struct _GtkWidgetPath * (*get_path_for_child)(struct _GtkContainer *, struct _GtkWidget *);
  // _handle_border_width
  unsigned int _handle_border_width : 1;
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
  // _gtk_reserved5
  void (*_gtk_reserved5)(void);
  // _gtk_reserved6
  void (*_gtk_reserved6)(void);
  // _gtk_reserved7
  void (*_gtk_reserved7)(void);
  // _gtk_reserved8
  void (*_gtk_reserved8)(void);
};

struct _GtkBinClass
{
  // parent_class
  struct _GtkContainerClass parent_class;
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
};

struct _GtkWindowClass
{
  // parent_class
  struct _GtkBinClass parent_class;
  // set_focus
  void (*set_focus)(struct _GtkWindow *, struct _GtkWidget *);
  // activate_focus
  void (*activate_focus)(struct _GtkWindow *);
  // activate_default
  void (*activate_default)(struct _GtkWindow *);
  // keys_changed
  void (*keys_changed)(struct _GtkWindow *);
  // enable_debugging
  signed int (*enable_debugging)(struct _GtkWindow *, signed int);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
};

struct _GtkDialogClass
{
  // parent_class
  struct _GtkWindowClass parent_class;
  // response
  void (*response)(struct _GtkDialog *, signed int);
  // close
  void (*close)(struct _GtkDialog *);
  // _gtk_reserved1
  void (*_gtk_reserved1)(void);
  // _gtk_reserved2
  void (*_gtk_reserved2)(void);
  // _gtk_reserved3
  void (*_gtk_reserved3)(void);
  // _gtk_reserved4
  void (*_gtk_reserved4)(void);
};

struct _AuiServiceDialogClass
{
  // parent_class
  struct _GtkDialogClass parent_class;
  // _aui_reserved1
  void (*_aui_reserved1)(void);
  // _aui_reserved2
  void (*_aui_reserved2)(void);
  // _aui_reserved3
  void (*_aui_reserved3)(void);
  // _aui_reserved4
  void (*_aui_reserved4)(void);
};

struct _AuiServiceDialogPrivate
{
  // glib_poll
  struct AvahiGLibPoll *glib_poll;
  // client
  struct AvahiClient *client;
  // browsers
  struct AvahiServiceBrowser **browsers;
  // resolver
  struct AvahiServiceResolver *resolver;
  // domain_browser
  struct AvahiDomainBrowser *domain_browser;
  // browse_service_types
  char **browse_service_types;
  // service_type
  char *service_type;
  // domain
  char *domain;
  // service_name
  char *service_name;
  // address_family
  signed int address_family;
  // address
  struct AvahiAddress address;
  // host_name
  char *host_name;
  // txt_data
  struct AvahiStringList *txt_data;
  // port
  unsigned short int port;
  // resolve_service
  signed int resolve_service;
  // resolve_service_done
  signed int resolve_service_done;
  // resolve_host_name
  signed int resolve_host_name;
  // resolve_host_name_done
  signed int resolve_host_name_done;
  // domain_label
  struct _GtkWidget *domain_label;
  // domain_button
  struct _GtkWidget *domain_button;
  // service_tree_view
  struct _GtkWidget *service_tree_view;
  // service_progress_bar
  struct _GtkWidget *service_progress_bar;
  // service_list_store
  struct _GtkListStore *service_list_store;
  // domain_list_store
  struct _GtkListStore *domain_list_store;
  // service_type_names
  struct _GHashTable *service_type_names;
  // service_pulse_timeout
  unsigned int service_pulse_timeout;
  // domain_pulse_timeout
  unsigned int domain_pulse_timeout;
  // start_idle
  unsigned int start_idle;
  // common_interface
  signed int common_interface;
  // common_protocol
  signed int common_protocol;
  // domain_dialog
  struct _GtkWidget *domain_dialog;
  // domain_entry
  struct _GtkWidget *domain_entry;
  // domain_tree_view
  struct _GtkWidget *domain_tree_view;
  // domain_progress_bar
  struct _GtkWidget *domain_progress_bar;
  // domain_ok_button
  struct _GtkWidget *domain_ok_button;
  // forward_response_id
  signed int forward_response_id;
};

struct _GArray
{
  // data
  char *data;
  // len
  unsigned int len;
};

struct _GClosure
{
  // ref_count
  volatile unsigned int ref_count : 15;
  // meta_marshal_nouse
  volatile unsigned int meta_marshal_nouse : 1;
  // n_guards
  volatile unsigned int n_guards : 1;
  // n_fnotifiers
  volatile unsigned int n_fnotifiers : 2;
  // n_inotifiers
  volatile unsigned int n_inotifiers : 8;
  // in_inotify
  volatile unsigned int in_inotify : 1;
  // floating
  volatile unsigned int floating : 1;
  // derivative_flag
  volatile unsigned int derivative_flag : 1;
  // in_marshal
  volatile unsigned int in_marshal : 1;
  // is_invalid
  volatile unsigned int is_invalid : 1;
  // marshal
  void (*marshal)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
  // data
  void *data;
  // notifiers
  struct _GClosureNotifyData *notifiers;
};

struct _GClosureNotifyData
{
  // data
  void *data;
  // notify
  void (*notify)(void *, struct _GClosure *);
};

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

struct _GObjectConstructParam
{
  // pspec
  struct _GParamSpec *pspec;
  // value
  struct _GValue *value;
};

struct _GParamSpec
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // name
  const char *name;
  // flags
  enum anonymous$35 flags;
  // value_type
  unsigned long int value_type;
  // owner_type
  unsigned long int owner_type;
  // _nick
  char *_nick;
  // _blurb
  char *_blurb;
  // qdata
  struct _GData *qdata;
  // ref_count
  unsigned int ref_count;
  // param_id
  unsigned int param_id;
};

struct _GPtrArray
{
  // pdata
  void **pdata;
  // len
  unsigned int len;
};

struct _GSList
{
  // data
  void *data;
  // next
  struct _GSList *next;
};

struct _GSourceCallbackFuncs
{
  // ref
  void (*ref)(void *);
  // unref
  void (*unref)(void *);
  // get
  void (*get)(void *, struct _GSource *, signed int (**)(void *), void **);
};

struct _GSourceFuncs
{
  // prepare
  signed int (*prepare)(struct _GSource *, signed int *);
  // check
  signed int (*check)(struct _GSource *);
  // dispatch
  signed int (*dispatch)(struct _GSource *, signed int (*)(void *), void *);
  // finalize
  void (*finalize)(struct _GSource *);
  // closure_callback
  signed int (*closure_callback)(void *);
  // closure_marshal
  void (*closure_marshal)(void);
};

struct _GTimeVal
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct _GValue
{
  // g_type
  unsigned long int g_type;
  // data
  union anonymous$54 data[2l];
};

struct _GdkColor
{
  // pixel
  unsigned int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
};

struct _GdkEventAny
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
};

struct _cairo_rectangle_int
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventExpose
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // area
  struct _cairo_rectangle_int area;
  // region
  struct _cairo_region *region;
  // count
  signed int count;
};

struct _GdkEventVisibility
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // state
  enum anonymous$47 state;
};

struct _GdkEventMotion
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // is_hint
  signed short int is_hint;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventButton
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventTouch
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // sequence
  struct _GdkEventSequence *sequence;
  // emulating_pointer
  signed int emulating_pointer;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventScroll
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // state
  unsigned int state;
  // direction
  enum anonymous$48 direction;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // delta_x
  double delta_x;
  // delta_y
  double delta_y;
};

struct _GdkEventKey
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // state
  unsigned int state;
  // keyval
  unsigned int keyval;
  // length
  signed int length;
  // string
  char *string;
  // hardware_keycode
  unsigned short int hardware_keycode;
  // group
  unsigned char group;
  // is_modifier
  unsigned int is_modifier : 1;
};

struct _GdkEventCrossing
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // subwindow
  struct _GdkWindow *subwindow;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // mode
  enum anonymous$49 mode;
  // detail
  enum anonymous$50 detail;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct _GdkEventFocus
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // in
  signed short int in;
};

struct _GdkEventConfigure
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventProperty
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // atom
  struct _GdkAtom *atom;
  // time
  unsigned int time;
  // state
  unsigned int state;
};

struct _GdkEventSelection
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // property
  struct _GdkAtom *property;
  // time
  unsigned int time;
  // requestor
  struct _GdkWindow *requestor;
};

struct _GdkEventOwnerChange
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // owner
  struct _GdkWindow *owner;
  // reason
  enum anonymous$51 reason;
  // selection
  struct _GdkAtom *selection;
  // time
  unsigned int time;
  // selection_time
  unsigned int selection_time;
};

struct _GdkEventProximity
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // device
  struct _GdkDevice *device;
};

struct _GdkEventDND
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // context
  struct _GdkDragContext *context;
  // time
  unsigned int time;
  // x_root
  signed short int x_root;
  // y_root
  signed short int y_root;
};

struct _GdkEventWindowState
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // changed_mask
  enum anonymous$52 changed_mask;
  // new_window_state
  enum anonymous$52 new_window_state;
};

struct _GdkEventSetting
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // action
  enum anonymous$53 action;
  // name
  char *name;
};

struct _GdkEventGrabBroken
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // keyboard
  signed int keyboard;
  // implicit
  signed int implicit;
  // grab_window
  struct _GdkWindow *grab_window;
};

struct _GdkEventTouchpadSwipe
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // phase
  signed char phase;
  // n_fingers
  signed char n_fingers;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // dx
  double dx;
  // dy
  double dy;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // state
  unsigned int state;
};

struct _GdkEventTouchpadPinch
{
  // type
  enum anonymous$46 type;
  // window
  struct _GdkWindow *window;
  // send_event
  signed char send_event;
  // phase
  signed char phase;
  // n_fingers
  signed char n_fingers;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // dx
  double dx;
  // dy
  double dy;
  // angle_delta
  double angle_delta;
  // scale
  double scale;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // state
  unsigned int state;
};

union _GdkEvent
{
  // type
  enum anonymous$46 type;
  // any
  struct _GdkEventAny any;
  // expose
  struct _GdkEventExpose expose;
  // visibility
  struct _GdkEventVisibility visibility;
  // motion
  struct _GdkEventMotion motion;
  // button
  struct _GdkEventButton button;
  // touch
  struct _GdkEventTouch touch;
  // scroll
  struct _GdkEventScroll scroll;
  // key
  struct _GdkEventKey key;
  // crossing
  struct _GdkEventCrossing crossing;
  // focus_change
  struct _GdkEventFocus focus_change;
  // configure
  struct _GdkEventConfigure configure;
  // property
  struct _GdkEventProperty property;
  // selection
  struct _GdkEventSelection selection;
  // owner_change
  struct _GdkEventOwnerChange owner_change;
  // proximity
  struct _GdkEventProximity proximity;
  // dnd
  struct _GdkEventDND dnd;
  // window_state
  struct _GdkEventWindowState window_state;
  // setting
  struct _GdkEventSetting setting;
  // grab_broken
  struct _GdkEventGrabBroken grab_broken;
  // touchpad_swipe
  struct _GdkEventTouchpadSwipe touchpad_swipe;
  // touchpad_pinch
  struct _GdkEventTouchpadPinch touchpad_pinch;
};

struct _GtkAdjustment
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GtkAdjustmentPrivate *priv;
};

struct _GtkBox
{
  // container
  struct _GtkContainer container;
  // priv
  struct _GtkBoxPrivate *priv;
};

struct _GtkButton
{
  // bin
  struct _GtkBin bin;
  // priv
  struct _GtkButtonPrivate *priv;
};

struct _GtkButtonBox
{
  // box
  struct _GtkBox box;
  // priv
  struct _GtkButtonBoxPrivate *priv;
};

struct _GtkCellRenderer
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GtkCellRendererPrivate *priv;
};

struct _GtkEntry
{
  // parent_instance
  struct _GtkWidget parent_instance;
  // priv
  struct _GtkEntryPrivate *priv;
};

struct _GtkMisc
{
  // widget
  struct _GtkWidget widget;
  // priv
  struct _GtkMiscPrivate *priv;
};

struct _GtkLabel
{
  // misc
  struct _GtkMisc misc;
  // priv
  struct _GtkLabelPrivate *priv;
};

struct _GtkListStore
{
  // parent
  struct _GObject parent;
  // priv
  struct _GtkListStorePrivate *priv;
};

struct _GtkProgressBar
{
  // parent
  struct _GtkWidget parent;
  // priv
  struct _GtkProgressBarPrivate *priv;
};

struct _GtkRcStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // bg_pixmap_name
  char *bg_pixmap_name[5l];
  // font_desc
  struct _PangoFontDescription *font_desc;
  // color_flags
  enum anonymous$33 color_flags[5l];
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // rc_properties
  struct _GArray *rc_properties;
  // rc_style_lists
  struct _GSList *rc_style_lists;
  // icon_factories
  struct _GSList *icon_factories;
  // engine_specified
  unsigned int engine_specified : 1;
};

struct _GtkScrolledWindow
{
  // container
  struct _GtkBin container;
  // priv
  struct _GtkScrolledWindowPrivate *priv;
};

struct _GtkStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // light
  struct _GdkColor light[5l];
  // dark
  struct _GdkColor dark[5l];
  // mid
  struct _GdkColor mid[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // text_aa
  struct _GdkColor text_aa[5l];
  // black
  struct _GdkColor black;
  // white
  struct _GdkColor white;
  // font_desc
  struct _PangoFontDescription *font_desc;
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // background
  struct _cairo_pattern *background[5l];
  // attach_count
  signed int attach_count;
  // visual
  struct _GdkVisual *visual;
  // private_font_desc
  struct _PangoFontDescription *private_font_desc;
  // rc_style
  struct _GtkRcStyle *rc_style;
  // styles
  struct _GSList *styles;
  // property_cache
  struct _GArray *property_cache;
  // icon_factories
  struct _GSList *icon_factories;
};

struct _GtkTreeIter
{
  // stamp
  signed int stamp;
  // user_data
  void *user_data;
  // user_data2
  void *user_data2;
  // user_data3
  void *user_data3;
};

struct _GtkTreeSelection
{
  // parent
  struct _GObject parent;
  // priv
  struct _GtkTreeSelectionPrivate *priv;
};

struct _GtkTreeView
{
  // parent
  struct _GtkContainer parent;
  // priv
  struct _GtkTreeViewPrivate *priv;
};

struct _GtkTreeViewColumn
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GtkTreeViewColumnPrivate *priv;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct error_map
{
  // dbus_error
  const char *dbus_error;
  // avahi_error
  signed int avahi_error;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};


// AuiServiceDialog_private_offset
// file avahi-ui.c line 169
static signed int AuiServiceDialog_private_offset;
// allocator
// file malloc.c line 40
static const struct AvahiAllocator *allocator = (const struct AvahiAllocator *)(void *)0;
// allocator$link1
// file malloc.c line 40
static const struct AvahiAllocator *allocator$link1 = (const struct AvahiAllocator *)(void *)0;
// allocator$link1$link1
// file malloc.c line 40
static const struct AvahiAllocator *allocator$link1$link1 = (const struct AvahiAllocator *)(void *)0;
// allocator$link2
// file malloc.c line 40
static const struct AvahiAllocator *allocator$link2 = (const struct AvahiAllocator *)(void *)0;
// allocator$link3
// file malloc.c line 40
static const struct AvahiAllocator *allocator$link3 = (const struct AvahiAllocator *)(void *)0;
// aui_service_dialog_parent_class
// file avahi-ui.c line 169
static void *aui_service_dialog_parent_class = (void *)0;
// buffer
// file ../avahi-utils/stdb.c line 43
static char *buffer = (char *)(void *)0;
// enum_key
// file ../avahi-utils/stdb.c line 44
static char *enum_key = (char *)(void *)0;
// error_map
// file ../avahi-common/dbus.c line 98
static struct error_map error_map[15l] = { { .dbus_error="org.freedesktop.DBus.Error.Failed", .avahi_error=-1 }, 
    { .dbus_error="org.freedesktop.DBus.Error.NoMemory", .avahi_error=-24 }, 
    { .dbus_error="org.freedesktop.DBus.Error.ServiceUnknown", .avahi_error=-26 }, 
    { .dbus_error="org.freedesktop.DBus.Error.BadAddress", .avahi_error=-26 }, 
    { .dbus_error="org.freedesktop.DBus.Error.NotSupported", .avahi_error=-49 }, 
    { .dbus_error="org.freedesktop.DBus.Error.LimitsExceeded", .avahi_error=-17 }, 
    { .dbus_error="org.freedesktop.DBus.Error.AccessDenied", .avahi_error=-20 }, 
    { .dbus_error="org.freedesktop.DBus.Error.AuthFailed", .avahi_error=-20 }, 
    { .dbus_error="org.freedesktop.DBus.Error.NoServer", .avahi_error=-26 }, 
    { .dbus_error="org.freedesktop.DBus.Error.Timeout", .avahi_error=-15 }, 
    { .dbus_error="org.freedesktop.DBus.Error.NoNetwork", .avahi_error=-5 }, 
    { .dbus_error="org.freedesktop.DBus.Error.Disconnected", .avahi_error=-23 }, 
    { .dbus_error="org.freedesktop.DBus.Error.InvalidArgs", .avahi_error=-51 }, 
    { .dbus_error="org.freedesktop.DBus.Error.TimedOut", .avahi_error=-15 }, 
    { .dbus_error=(const char *)(void *)0, .avahi_error=0 } };
// error_map$link1
// file ../avahi-common/dbus.c line 98
static struct error_map error_map$link1[15l] = { { .dbus_error="org.freedesktop.DBus.Error.Failed", .avahi_error=-1 }, 
    { .dbus_error="org.freedesktop.DBus.Error.NoMemory", .avahi_error=-24 }, 
    { .dbus_error="org.freedesktop.DBus.Error.ServiceUnknown", .avahi_error=-26 }, 
    { .dbus_error="org.freedesktop.DBus.Error.BadAddress", .avahi_error=-26 }, 
    { .dbus_error="org.freedesktop.DBus.Error.NotSupported", .avahi_error=-49 }, 
    { .dbus_error="org.freedesktop.DBus.Error.LimitsExceeded", .avahi_error=-17 }, 
    { .dbus_error="org.freedesktop.DBus.Error.AccessDenied", .avahi_error=-20 }, 
    { .dbus_error="org.freedesktop.DBus.Error.AuthFailed", .avahi_error=-20 }, 
    { .dbus_error="org.freedesktop.DBus.Error.NoServer", .avahi_error=-26 }, 
    { .dbus_error="org.freedesktop.DBus.Error.Timeout", .avahi_error=-15 }, 
    { .dbus_error="org.freedesktop.DBus.Error.NoNetwork", .avahi_error=-5 }, 
    { .dbus_error="org.freedesktop.DBus.Error.Disconnected", .avahi_error=-23 }, 
    { .dbus_error="org.freedesktop.DBus.Error.InvalidArgs", .avahi_error=-51 }, 
    { .dbus_error="org.freedesktop.DBus.Error.TimedOut", .avahi_error=-15 }, 
    { .dbus_error=(const char *)(void *)0, .avahi_error=0 } };
// gdbm_file
// file ../avahi-utils/stdb.c line 38
static struct anonymous$36 *gdbm_file = (struct anonymous$36 *)(void *)0;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// table
// file ../avahi-common/dbus.c line 31
static const char * const table[54l] = { "org.freedesktop.Avahi.Success", "org.freedesktop.Avahi.Failure", "org.freedesktop.Avahi.BadStateError", "org.freedesktop.Avahi.InvalidHostNameError", 
    "org.freedesktop.Avahi.InvalidDomainNameError", 
    "org.freedesktop.Avahi.NoNetworkError", "org.freedesktop.Avahi.InvalidTTLError", 
    "org.freedesktop.Avahi.IsPatternError", "org.freedesktop.Avahi.CollisionError", "org.freedesktop.Avahi.InvalidRecordError", 
    "org.freedesktop.Avahi.InvalidServiceNameError", 
    "org.freedesktop.Avahi.InvalidServiceTypeError", 
    "org.freedesktop.Avahi.InvalidPortError", 
    "org.freedesktop.Avahi.InvalidKeyError", 
    "org.freedesktop.Avahi.InvalidAddressError", 
    "org.freedesktop.Avahi.TimeoutError", "org.freedesktop.Avahi.TooManyClientsError", 
    "org.freedesktop.Avahi.TooManyObjectsError", 
    "org.freedesktop.Avahi.TooManyEntriesError", 
    "org.freedesktop.Avahi.OSError", "org.freedesktop.DBus.Error.AccessDenied", 
    "org.freedesktop.Avahi.InvalidOperationError", 
    "org.freedesktop.Avahi.DBusError", "org.freedesktop.Avahi.DisconnectedError", 
    "org.freedesktop.Avahi.NoMemoryError", "org.freedesktop.Avahi.InvalidObjectError", 
    "org.freedesktop.Avahi.NoDaemonError", "org.freedesktop.Avahi.InvalidInterfaceError", 
    "org.freedesktop.Avahi.InvalidInterfaceProtocolError", 
    "org.freedesktop.Avahi.InvalidFlagsError", 
    "org.freedesktop.Avahi.NotFoundError", "org.freedesktop.Avahi.InvalidConfigurationError", 
    "org.freedesktop.Avahi.VersionMismatchError", 
    "org.freedesktop.Avahi.InvalidServiceSubtypeError", 
    "org.freedesktop.Avahi.InvalidPacketError", 
    "org.freedesktop.Avahi.InvalidDNSErrorError", 
    "org.freedesktop.Avahi.DNSFORMERR", "org.freedesktop.Avahi.DNSSERVFAIL", "org.freedesktop.Avahi.DNSNXDOMAIN", "org.freedesktop.Avahi.DNSNOTIMP", "org.freedesktop.Avahi.DNSREFUSED", "org.freedesktop.Avahi.DNSYXDOMAIN", "org.freedesktop.Avahi.DNSYXRRSET", "org.freedesktop.Avahi.DNSNXRRSET", "org.freedesktop.Avahi.DNSNOTAUTH", "org.freedesktop.Avahi.DNSNOTZONE", "org.freedesktop.Avahi.InvalidRDataError", 
    "org.freedesktop.Avahi.InvalidDNSClassError", 
    "org.freedesktop.Avahi.InvalidDNSTypeError", 
    "org.freedesktop.Avahi.NotSupportedError", 
    "org.freedesktop.Avahi.NotPermittedError", 
    "org.freedesktop.Avahi.InvalidArgumentError", 
    "org.freedesktop.Avahi.IsEmptyError", "org.freedesktop.Avahi.NoChangeError" };
// table$link1
// file ../avahi-common/dbus.c line 31
static const char * const table$link1[54l] = { "org.freedesktop.Avahi.Success", "org.freedesktop.Avahi.Failure", "org.freedesktop.Avahi.BadStateError", "org.freedesktop.Avahi.InvalidHostNameError", 
    "org.freedesktop.Avahi.InvalidDomainNameError", 
    "org.freedesktop.Avahi.NoNetworkError", "org.freedesktop.Avahi.InvalidTTLError", 
    "org.freedesktop.Avahi.IsPatternError", "org.freedesktop.Avahi.CollisionError", "org.freedesktop.Avahi.InvalidRecordError", 
    "org.freedesktop.Avahi.InvalidServiceNameError", 
    "org.freedesktop.Avahi.InvalidServiceTypeError", 
    "org.freedesktop.Avahi.InvalidPortError", 
    "org.freedesktop.Avahi.InvalidKeyError", 
    "org.freedesktop.Avahi.InvalidAddressError", 
    "org.freedesktop.Avahi.TimeoutError", "org.freedesktop.Avahi.TooManyClientsError", 
    "org.freedesktop.Avahi.TooManyObjectsError", 
    "org.freedesktop.Avahi.TooManyEntriesError", 
    "org.freedesktop.Avahi.OSError", "org.freedesktop.DBus.Error.AccessDenied", 
    "org.freedesktop.Avahi.InvalidOperationError", 
    "org.freedesktop.Avahi.DBusError", "org.freedesktop.Avahi.DisconnectedError", 
    "org.freedesktop.Avahi.NoMemoryError", "org.freedesktop.Avahi.InvalidObjectError", 
    "org.freedesktop.Avahi.NoDaemonError", "org.freedesktop.Avahi.InvalidInterfaceError", 
    "org.freedesktop.Avahi.InvalidInterfaceProtocolError", 
    "org.freedesktop.Avahi.InvalidFlagsError", 
    "org.freedesktop.Avahi.NotFoundError", "org.freedesktop.Avahi.InvalidConfigurationError", 
    "org.freedesktop.Avahi.VersionMismatchError", 
    "org.freedesktop.Avahi.InvalidServiceSubtypeError", 
    "org.freedesktop.Avahi.InvalidPacketError", 
    "org.freedesktop.Avahi.InvalidDNSErrorError", 
    "org.freedesktop.Avahi.DNSFORMERR", "org.freedesktop.Avahi.DNSSERVFAIL", "org.freedesktop.Avahi.DNSNXDOMAIN", "org.freedesktop.Avahi.DNSNOTIMP", "org.freedesktop.Avahi.DNSREFUSED", "org.freedesktop.Avahi.DNSYXDOMAIN", "org.freedesktop.Avahi.DNSYXRRSET", "org.freedesktop.Avahi.DNSNXRRSET", "org.freedesktop.Avahi.DNSNOTAUTH", "org.freedesktop.Avahi.DNSNOTZONE", "org.freedesktop.Avahi.InvalidRDataError", 
    "org.freedesktop.Avahi.InvalidDNSClassError", 
    "org.freedesktop.Avahi.InvalidDNSTypeError", 
    "org.freedesktop.Avahi.NotSupportedError", 
    "org.freedesktop.Avahi.NotPermittedError", 
    "org.freedesktop.Avahi.InvalidArgumentError", 
    "org.freedesktop.Avahi.IsEmptyError", "org.freedesktop.Avahi.NoChangeError" };

// add_timeout
// file ../avahi-common/dbus-watch-glue.c line 254
static unsigned int add_timeout(struct DBusTimeout *dbus_timeout, void *userdata)
{
  struct TimeoutData *timeout;
  struct anonymous$28 *d = (struct anonymous$28 *)userdata;
  struct timeval tv;
  unsigned int b;
  /* assertion dbus_timeout */
  assert(dbus_timeout != ((struct DBusTimeout *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous$28 *)NULL));
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link4((unsigned int)1, sizeof(struct TimeoutData) /*32ul*/ );
  timeout = (struct TimeoutData *)return_value_avahi_new_internal$1;
  signed int return_value_dbus_timeout_get_interval$2;
  if(timeout == ((struct TimeoutData *)NULL))
    return (unsigned int)0;

  else
  {
    timeout->dbus_timeout = dbus_timeout;
    timeout->poll_api = d->poll_api;
    timeout->ref = 1;
    b=dbus_timeout_get_enabled(dbus_timeout);
    if(!(b == 0u))
    {
      return_value_dbus_timeout_get_interval$2=dbus_timeout_get_interval(dbus_timeout);
      avahi_elapse_time(&tv, (unsigned int)return_value_dbus_timeout_get_interval$2, (unsigned int)0);
    }

    timeout->avahi_timeout=d->poll_api->timeout_new(d->poll_api, b != 0u ? &tv : (struct timeval *)(void *)0, timeout_callback, (void *)timeout);
    if(timeout->avahi_timeout == ((struct AvahiTimeout$1 *)NULL))
    {
      avahi_free((void *)timeout);
      return (unsigned int)0;
    }

    else
    {
      dbus_timeout_set_data(dbus_timeout, (void *)timeout, (void (*)(void *))timeout_data_unref);
      return (unsigned int)1;
    }
  }
}

// add_timeout$link1
// file ../avahi-common/dbus-watch-glue.c line 254
static unsigned int add_timeout$link1(struct DBusTimeout *dbus_timeout$link1, void *userdata$link1)
{
  struct TimeoutData *timeout$link1;
  struct anonymous$28 *d$link1 = (struct anonymous$28 *)userdata$link1;
  struct timeval tv$link1;
  unsigned int b$link1;
  /* assertion dbus_timeout */
  assert(dbus_timeout$link1 != ((struct DBusTimeout *)NULL));
  /* assertion d */
  assert(d$link1 != ((struct anonymous$28 *)NULL));
  void *return_value_avahi_new_internal$1$link1;
  return_value_avahi_new_internal$1$link1=avahi_new_internal$link4$link2$link1((unsigned int)1, sizeof(struct TimeoutData) /*32ul*/ );
  timeout$link1 = (struct TimeoutData *)return_value_avahi_new_internal$1$link1;
  signed int return_value_dbus_timeout_get_interval$2$link1;
  if(timeout$link1 == ((struct TimeoutData *)NULL))
    return (unsigned int)0;

  else
  {
    timeout$link1->dbus_timeout = dbus_timeout$link1;
    timeout$link1->poll_api = d$link1->poll_api;
    timeout$link1->ref = 1;
    b$link1=dbus_timeout_get_enabled(dbus_timeout$link1);
    if(!(b$link1 == 0u))
    {
      return_value_dbus_timeout_get_interval$2$link1=dbus_timeout_get_interval(dbus_timeout$link1);
      avahi_elapse_time(&tv$link1, (unsigned int)return_value_dbus_timeout_get_interval$2$link1, (unsigned int)0);
    }

    timeout$link1->avahi_timeout=d$link1->poll_api->timeout_new(d$link1->poll_api, b$link1 != 0u ? &tv$link1 : (struct timeval *)(void *)0, timeout_callback$link2$link1, (void *)timeout$link1);
    if(timeout$link1->avahi_timeout == ((struct AvahiTimeout$1 *)NULL))
    {
      avahi_free((void *)timeout$link1);
      return (unsigned int)0;
    }

    else
    {
      dbus_timeout_set_data(dbus_timeout$link1, (void *)timeout$link1, (void (*)(void *))timeout_data_unref$link1);
      return (unsigned int)1;
    }
  }
}

// add_watch
// file ../avahi-common/dbus-watch-glue.c line 165
static unsigned int add_watch(struct DBusWatch *dbus_watch, void *userdata)
{
  struct anonymous$28 *d = (struct anonymous$28 *)userdata;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous$28 *)NULL));
  unsigned int return_value_update_watch$1;
  return_value_update_watch$1=update_watch(d->poll_api, dbus_watch);
  return return_value_update_watch$1;
}

// add_watch$link1
// file ../avahi-common/dbus-watch-glue.c line 165
static unsigned int add_watch$link1(struct DBusWatch *dbus_watch$link1, void *userdata$link1)
{
  struct anonymous$28 *d$link1 = (struct anonymous$28 *)userdata$link1;
  /* assertion dbus_watch */
  assert(dbus_watch$link1 != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d$link1 != ((struct anonymous$28 *)NULL));
  unsigned int return_value_update_watch$1$link1;
  return_value_update_watch$1$link1=update_watch$link1(d$link1->poll_api, dbus_watch$link1);
  return return_value_update_watch$1$link1;
}

// address_get_size
// file address.c line 35
static unsigned long int address_get_size(const struct AvahiAddress *a)
{
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  if(a->proto == 0)
    return (unsigned long int)4;

  else
    if(a->proto == 1)
      return (unsigned long int)16;

  return (unsigned long int)0;
}

// address_get_size$link1
// file address.c line 35
static unsigned long int address_get_size$link1(const struct AvahiAddress *a$link1)
{
  /* assertion a */
  assert(a$link1 != ((const struct AvahiAddress *)NULL));
  if(a$link1->proto == 0)
    return (unsigned long int)4;

  else
    if(a$link1->proto == 1)
      return (unsigned long int)16;

  return (unsigned long int)0;
}

// address_get_size$link1$link1
// file address.c line 35
static unsigned long int address_get_size$link1$link1(const struct AvahiAddress *a$link1$link1)
{
  /* assertion a */
  assert(a$link1$link1 != ((const struct AvahiAddress *)NULL));
  if(a$link1$link1->proto == 0)
    return (unsigned long int)4;

  else
    if(a$link1$link1->proto == 1)
      return (unsigned long int)16;

  return (unsigned long int)0;
}

// address_get_size$link2
// file address.c line 35
static unsigned long int address_get_size$link2(const struct AvahiAddress *a$link2)
{
  /* assertion a */
  assert(a$link2 != ((const struct AvahiAddress *)NULL));
  if(a$link2->proto == 0)
    return (unsigned long int)4;

  else
    if(a$link2->proto == 1)
      return (unsigned long int)16;

  return (unsigned long int)0;
}

// address_get_size$link3
// file address.c line 35
static unsigned long int address_get_size$link3(const struct AvahiAddress *a$link3)
{
  /* assertion a */
  assert(a$link3 != ((const struct AvahiAddress *)NULL));
  if(a$link3->proto == 0)
    return (unsigned long int)4;

  else
    if(a$link3->proto == 1)
      return (unsigned long int)16;

  return (unsigned long int)0;
}

// append_rdata
// file entrygroup.c line 348
static signed int append_rdata(struct DBusMessage *message, const void *rdata, unsigned long int size)
{
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_message_iter_init_append(message, &iter);
  unsigned int return_value_dbus_message_iter_open_container$1;
  return_value_dbus_message_iter_open_container$1=dbus_message_iter_open_container(&iter, (signed int)97, "y", &sub);
  _Bool tmp_if_expr$3;
  unsigned int return_value_dbus_message_iter_append_fixed_array$2;
  if(return_value_dbus_message_iter_open_container$1 == 0u)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_dbus_message_iter_append_fixed_array$2=dbus_message_iter_append_fixed_array(&sub, (signed int)121, (const void *)&rdata, (signed int)size);
    tmp_if_expr$3 = !(return_value_dbus_message_iter_append_fixed_array$2 != 0u) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_message_iter_close_container$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_dbus_message_iter_close_container$4=dbus_message_iter_close_container(&iter, &sub);
    tmp_if_expr$5 = !(return_value_dbus_message_iter_close_container$4 != 0u) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
    return -1;

  else
    return 0;
}

// append_rdata$link1
// file entrygroup.c line 348
static signed int append_rdata$link1(struct DBusMessage *message$link1, const void *rdata$link1, unsigned long int size$link1)
{
  struct DBusMessageIter iter$link1;
  struct DBusMessageIter sub$link1;
  /* assertion message */
  assert(message$link1 != ((struct DBusMessage *)NULL));
  dbus_message_iter_init_append(message$link1, &iter$link1);
  unsigned int return_value_dbus_message_iter_open_container$1$link1;
  return_value_dbus_message_iter_open_container$1$link1=dbus_message_iter_open_container(&iter$link1, (signed int)97, "y", &sub$link1);
  _Bool tmp_if_expr$3$link1;
  unsigned int return_value_dbus_message_iter_append_fixed_array$2$link1;
  if(return_value_dbus_message_iter_open_container$1$link1 == 0u)
    tmp_if_expr$3$link1 = (_Bool)1;

  else
  {
    return_value_dbus_message_iter_append_fixed_array$2$link1=dbus_message_iter_append_fixed_array(&sub$link1, (signed int)121, (const void *)&rdata$link1, (signed int)size$link1);
    tmp_if_expr$3$link1 = !(return_value_dbus_message_iter_append_fixed_array$2$link1 != 0u) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5$link1;
  unsigned int return_value_dbus_message_iter_close_container$4$link1;
  if(tmp_if_expr$3$link1)
    tmp_if_expr$5$link1 = (_Bool)1;

  else
  {
    return_value_dbus_message_iter_close_container$4$link1=dbus_message_iter_close_container(&iter$link1, &sub$link1);
    tmp_if_expr$5$link1 = !(return_value_dbus_message_iter_close_container$4$link1 != 0u) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5$link1)
    return -1;

  else
    return 0;
}

// append_string_list
// file entrygroup.c line 363
static signed int append_string_list(struct DBusMessage *message, struct AvahiStringList *txt)
{
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  signed int r = -1;
  struct AvahiStringList *p;
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_message_iter_init_append(message, &iter);
  txt=avahi_string_list_reverse(txt);
  unsigned int return_value_dbus_message_iter_open_container$1;
  return_value_dbus_message_iter_open_container$1=dbus_message_iter_open_container(&iter, (signed int)97, "ay", &sub);
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_message_iter_append_fixed_array$3;
  _Bool tmp_if_expr$6;
  unsigned int return_value_dbus_message_iter_close_container$5;
  unsigned int return_value_dbus_message_iter_close_container$7;
  if(!(return_value_dbus_message_iter_open_container$1 == 0u))
  {
    p = txt;
    for( ; !(p == ((struct AvahiStringList *)NULL)); p = p->next)
    {
      struct DBusMessageIter sub2;
      const unsigned char *data = p->text;
      unsigned int return_value_dbus_message_iter_open_container$2;
      return_value_dbus_message_iter_open_container$2=dbus_message_iter_open_container(&sub, (signed int)97, "y", &sub2);
      if(return_value_dbus_message_iter_open_container$2 == 0u)
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        return_value_dbus_message_iter_append_fixed_array$3=dbus_message_iter_append_fixed_array(&sub2, (signed int)121, (const void *)&data, (signed int)p->size);
        tmp_if_expr$4 = !(return_value_dbus_message_iter_append_fixed_array$3 != 0u) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$4)
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        return_value_dbus_message_iter_close_container$5=dbus_message_iter_close_container(&sub, &sub2);
        tmp_if_expr$6 = !(return_value_dbus_message_iter_close_container$5 != 0u) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$6)
        goto fail;

    }
    return_value_dbus_message_iter_close_container$7=dbus_message_iter_close_container(&iter, &sub);
    if(!(return_value_dbus_message_iter_close_container$7 == 0u))
      r = 0;

  }


fail:
  ;
  txt=avahi_string_list_reverse(txt);
  return r;
}

// append_string_list$link1
// file entrygroup.c line 363
static signed int append_string_list$link1(struct DBusMessage *message$link1, struct AvahiStringList *txt$link1)
{
  struct DBusMessageIter iter$link1;
  struct DBusMessageIter sub$link1;
  signed int r$link1 = -1;
  struct AvahiStringList *p$link1;
  /* assertion message */
  assert(message$link1 != ((struct DBusMessage *)NULL));
  dbus_message_iter_init_append(message$link1, &iter$link1);
  txt$link1=avahi_string_list_reverse(txt$link1);
  unsigned int return_value_dbus_message_iter_open_container$1$link1;
  return_value_dbus_message_iter_open_container$1$link1=dbus_message_iter_open_container(&iter$link1, (signed int)97, "ay", &sub$link1);
  _Bool tmp_if_expr$4$link1;
  unsigned int return_value_dbus_message_iter_append_fixed_array$3$link1;
  _Bool tmp_if_expr$6$link1;
  unsigned int return_value_dbus_message_iter_close_container$5$link1;
  unsigned int return_value_dbus_message_iter_close_container$7$link1;
  if(!(return_value_dbus_message_iter_open_container$1$link1 == 0u))
  {
    p$link1 = txt$link1;
    for( ; !(p$link1 == ((struct AvahiStringList *)NULL)); p$link1 = p$link1->next)
    {
      struct DBusMessageIter sub2$link1;
      const unsigned char *data$link1 = p$link1->text;
      unsigned int return_value_dbus_message_iter_open_container$2$link1;
      return_value_dbus_message_iter_open_container$2$link1=dbus_message_iter_open_container(&sub$link1, (signed int)97, "y", &sub2$link1);
      if(return_value_dbus_message_iter_open_container$2$link1 == 0u)
        tmp_if_expr$4$link1 = (_Bool)1;

      else
      {
        return_value_dbus_message_iter_append_fixed_array$3$link1=dbus_message_iter_append_fixed_array(&sub2$link1, (signed int)121, (const void *)&data$link1, (signed int)p$link1->size);
        tmp_if_expr$4$link1 = !(return_value_dbus_message_iter_append_fixed_array$3$link1 != 0u) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$4$link1)
        tmp_if_expr$6$link1 = (_Bool)1;

      else
      {
        return_value_dbus_message_iter_close_container$5$link1=dbus_message_iter_close_container(&sub$link1, &sub2$link1);
        tmp_if_expr$6$link1 = !(return_value_dbus_message_iter_close_container$5$link1 != 0u) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$6$link1)
        goto fail;

    }
    return_value_dbus_message_iter_close_container$7$link1=dbus_message_iter_close_container(&iter$link1, &sub$link1);
    if(!(return_value_dbus_message_iter_close_container$7$link1 == 0u))
      r$link1 = 0;

  }


fail:
  ;
  txt$link1=avahi_string_list_reverse(txt$link1);
  return r$link1;
}

// aui_service_dialog_class_init
// file avahi-ui.c line 171
static void aui_service_dialog_class_init(struct _AuiServiceDialogClass *klass)
{
  struct _GObjectClass *object_class;
  avahi_init_i18n();
  object_class = (struct _GObjectClass *)klass;
  object_class->finalize = aui_service_dialog_finalize;
  object_class->set_property = aui_service_dialog_set_property;
  object_class->get_property = aui_service_dialog_get_property;
  char *return_value_dgettext$1;
  return_value_dgettext$1=dgettext("avahi", "Browse Service Types");
  char *return_value_dgettext$2;
  return_value_dgettext$2=dgettext("avahi", "A NULL terminated list of service types to browse for");
  struct _GParamSpec *return_value_g_param_spec_pointer$3;
  return_value_g_param_spec_pointer$3=g_param_spec_pointer("browse_service_types", return_value_dgettext$1, return_value_dgettext$2, (enum anonymous$35)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)1, return_value_g_param_spec_pointer$3);
  char *return_value_dgettext$4;
  return_value_dgettext$4=dgettext("avahi", "Domain");
  char *return_value_dgettext$5;
  return_value_dgettext$5=dgettext("avahi", "The domain to browse in, or NULL for the default domain");
  struct _GParamSpec *return_value_g_param_spec_string$6;
  return_value_g_param_spec_string$6=g_param_spec_string("domain", return_value_dgettext$4, return_value_dgettext$5, (const char *)(void *)0, (enum anonymous$35)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)2, return_value_g_param_spec_string$6);
  char *return_value_dgettext$7;
  return_value_dgettext$7=dgettext("avahi", "Service Type");
  char *return_value_dgettext$8;
  return_value_dgettext$8=dgettext("avahi", "The service type of the selected service");
  struct _GParamSpec *return_value_g_param_spec_string$9;
  return_value_g_param_spec_string$9=g_param_spec_string("service_type", return_value_dgettext$7, return_value_dgettext$8, (const char *)(void *)0, (enum anonymous$35)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)3, return_value_g_param_spec_string$9);
  char *return_value_dgettext$10;
  return_value_dgettext$10=dgettext("avahi", "Service Name");
  char *return_value_dgettext$11;
  return_value_dgettext$11=dgettext("avahi", "The service name of the selected service");
  struct _GParamSpec *return_value_g_param_spec_string$12;
  return_value_g_param_spec_string$12=g_param_spec_string("service_name", return_value_dgettext$10, return_value_dgettext$11, (const char *)(void *)0, (enum anonymous$35)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)4, return_value_g_param_spec_string$12);
  char *return_value_dgettext$13;
  return_value_dgettext$13=dgettext("avahi", "Address");
  char *return_value_dgettext$14;
  return_value_dgettext$14=dgettext("avahi", "The address of the resolved service");
  struct _GParamSpec *return_value_g_param_spec_pointer$15;
  return_value_g_param_spec_pointer$15=g_param_spec_pointer("address", return_value_dgettext$13, return_value_dgettext$14, (enum anonymous$35)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)5, return_value_g_param_spec_pointer$15);
  char *return_value_dgettext$16;
  return_value_dgettext$16=dgettext("avahi", "Port");
  char *return_value_dgettext$17;
  return_value_dgettext$17=dgettext("avahi", "The IP port number of the resolved service");
  struct _GParamSpec *return_value_g_param_spec_uint$18;
  return_value_g_param_spec_uint$18=g_param_spec_uint("port", return_value_dgettext$16, return_value_dgettext$17, (unsigned int)0, (unsigned int)0xFFFF, (unsigned int)0, (enum anonymous$35)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)6, return_value_g_param_spec_uint$18);
  char *return_value_dgettext$19;
  return_value_dgettext$19=dgettext("avahi", "Host Name");
  char *return_value_dgettext$20;
  return_value_dgettext$20=dgettext("avahi", "The host name of the resolved service");
  struct _GParamSpec *return_value_g_param_spec_string$21;
  return_value_g_param_spec_string$21=g_param_spec_string("host_name", return_value_dgettext$19, return_value_dgettext$20, (const char *)(void *)0, (enum anonymous$35)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)7, return_value_g_param_spec_string$21);
  char *return_value_dgettext$22;
  return_value_dgettext$22=dgettext("avahi", "TXT Data");
  char *return_value_dgettext$23;
  return_value_dgettext$23=dgettext("avahi", "The TXT data of the resolved service");
  struct _GParamSpec *return_value_g_param_spec_pointer$24;
  return_value_g_param_spec_pointer$24=g_param_spec_pointer("txt_data", return_value_dgettext$22, return_value_dgettext$23, (enum anonymous$35)G_PARAM_READABLE);
  g_object_class_install_property(object_class, (unsigned int)8, return_value_g_param_spec_pointer$24);
  char *return_value_dgettext$25;
  return_value_dgettext$25=dgettext("avahi", "Resolve Service");
  char *return_value_dgettext$26;
  return_value_dgettext$26=dgettext("avahi", "Resolve the selected service automatically before returning");
  struct _GParamSpec *return_value_g_param_spec_boolean$27;
  return_value_g_param_spec_boolean$27=g_param_spec_boolean("resolve_service", return_value_dgettext$25, return_value_dgettext$26, (signed int)!(0 != 0), (enum anonymous$35)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)9, return_value_g_param_spec_boolean$27);
  char *return_value_dgettext$28;
  return_value_dgettext$28=dgettext("avahi", "Resolve Service Host Name");
  char *return_value_dgettext$29;
  return_value_dgettext$29=dgettext("avahi", "Resolve the host name of the selected service automatically before returning");
  struct _GParamSpec *return_value_g_param_spec_boolean$30;
  return_value_g_param_spec_boolean$30=g_param_spec_boolean("resolve_host_name", return_value_dgettext$28, return_value_dgettext$29, (signed int)!(0 != 0), (enum anonymous$35)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)10, return_value_g_param_spec_boolean$30);
  char *return_value_dgettext$31;
  return_value_dgettext$31=dgettext("avahi", "Address family");
  char *return_value_dgettext$32;
  return_value_dgettext$32=dgettext("avahi", "The address family for host name resolution");
  struct _GParamSpec *return_value_g_param_spec_int$33;
  return_value_g_param_spec_int$33=g_param_spec_int("address_family", return_value_dgettext$31, return_value_dgettext$32, -1, 1, -1, (enum anonymous$35)(G_PARAM_READABLE | G_PARAM_WRITABLE));
  g_object_class_install_property(object_class, (unsigned int)11, return_value_g_param_spec_int$33);
}

// aui_service_dialog_class_intern_init
// file avahi-ui.c line 169
static void aui_service_dialog_class_intern_init(void *klass)
{
  aui_service_dialog_parent_class=g_type_class_peek_parent(klass);
  if(!(AuiServiceDialog_private_offset == 0))
    g_type_class_adjust_private_offset(klass, &AuiServiceDialog_private_offset);

  aui_service_dialog_class_init((struct _AuiServiceDialogClass *)klass);
}

// aui_service_dialog_finalize
// file avahi-ui.c line 788
static void aui_service_dialog_finalize(struct _GObject *object)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  if(d->priv->domain_pulse_timeout >= 1u)
    g_source_remove(d->priv->domain_pulse_timeout);

  if(d->priv->service_pulse_timeout >= 1u)
    g_source_remove(d->priv->service_pulse_timeout);

  if(d->priv->start_idle >= 1u)
    g_source_remove(d->priv->start_idle);

  g_free((void *)d->priv->host_name);
  g_free((void *)d->priv->domain);
  g_free((void *)d->priv->service_name);
  avahi_string_list_free(d->priv->txt_data);
  g_strfreev(d->priv->browse_service_types);
  if(!(d->priv->domain_browser == ((struct AvahiDomainBrowser *)NULL)))
    avahi_domain_browser_free(d->priv->domain_browser);

  if(!(d->priv->resolver == ((struct AvahiServiceResolver *)NULL)))
    avahi_service_resolver_free(d->priv->resolver);

  if(!(d->priv->browsers == ((struct AvahiServiceBrowser **)NULL)))
  {
    struct AvahiServiceBrowser **sb = d->priv->browsers;
    for( ; !(*sb == ((struct AvahiServiceBrowser *)NULL)); sb = sb + 1l)
      avahi_service_browser_free(*sb);
    g_free((void *)d->priv->browsers);
  }

  if(!(d->priv->client == ((struct AvahiClient *)NULL)))
    avahi_client_free(d->priv->client);

  if(!(d->priv->glib_poll == ((struct AvahiGLibPoll *)NULL)))
    avahi_glib_poll_free(d->priv->glib_poll);

  if(!(d->priv->service_list_store == ((struct _GtkListStore *)NULL)))
    g_object_unref((void *)d->priv->service_list_store);

  if(!(d->priv->domain_list_store == ((struct _GtkListStore *)NULL)))
    g_object_unref((void *)d->priv->domain_list_store);

  if(!(d->priv->service_type_names == ((struct _GHashTable *)NULL)))
    g_hash_table_unref(d->priv->service_type_names);

  g_free((void *)d->priv);
  d->priv = (struct _AuiServiceDialogPrivate *)(void *)0;
  struct _GTypeClass *return_value_g_type_check_class_cast$3;
  return_value_g_type_check_class_cast$3=g_type_check_class_cast((struct _GTypeClass *)aui_service_dialog_parent_class, (unsigned long int)(20 << 2));
  ((struct _GObjectClass *)return_value_g_type_check_class_cast$3)->finalize(object);
}

// aui_service_dialog_get_address
// file avahi-ui.h line 128
const struct AvahiAddress * aui_service_dialog_get_address(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_address", "AUI_IS_SERVICE_DIALOG(d)");
      return (const struct AvahiAddress *)(void *)0;
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr$3;
  do
  {
    if(!(d->priv->resolve_service_done == 0))
      tmp_if_expr$3 = d->priv->resolve_host_name_done != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_address", "d->priv->resolve_service_done && d->priv->resolve_host_name_done");
      return (const struct AvahiAddress *)(void *)0;
    }

  }
  while((_Bool)0);
  return &d->priv->address;
}

// aui_service_dialog_get_address_family
// file avahi-ui.c line 1397
signed int aui_service_dialog_get_address_family(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_address_family", "AUI_IS_SERVICE_DIALOG(d)");
      return -1;
    }

  }
  while((_Bool)0);
  return d->priv->address_family;
}

// aui_service_dialog_get_browse_service_types
// file avahi-ui.c line 1262
const char * const * aui_service_dialog_get_browse_service_types(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_browse_service_types", "AUI_IS_SERVICE_DIALOG(d)");
      return (const char * const *)(void *)0;
    }

  }
  while((_Bool)0);
  return (const char * const *)d->priv->browse_service_types;
}

// aui_service_dialog_get_domain
// file avahi-ui.c line 1306
const char * aui_service_dialog_get_domain(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_domain", "AUI_IS_SERVICE_DIALOG(d)");
      return (const char *)(void *)0;
    }

  }
  while((_Bool)0);
  return d->priv->domain;
}

// aui_service_dialog_get_host_name
// file avahi-ui.h line 134
const char * aui_service_dialog_get_host_name(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_host_name", "AUI_IS_SERVICE_DIALOG(d)");
      return (const char *)(void *)0;
    }

  }
  while((_Bool)0);
  do
    if(d->priv->resolve_service_done == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_host_name", "d->priv->resolve_service_done");
      return (const char *)(void *)0;
    }

  while((_Bool)0);
  return d->priv->host_name;
}

// aui_service_dialog_get_port
// file avahi-ui.h line 131
unsigned short int aui_service_dialog_get_port(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_port", "AUI_IS_SERVICE_DIALOG(d)");
      return (unsigned short int)0;
    }

  }
  while((_Bool)0);
  do
    if(d->priv->resolve_service_done == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_port", "d->priv->resolve_service_done");
      return (unsigned short int)0;
    }

  while((_Bool)0);
  return d->priv->port;
}

// aui_service_dialog_get_property
// file avahi-ui.c line 1441
static void aui_service_dialog_get_property(struct _GObject *object, unsigned int prop_id, struct _GValue *value, struct _GParamSpec *pspec)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  const char * const *return_value_aui_service_dialog_get_browse_service_types$3;
  const char *return_value_aui_service_dialog_get_domain$4;
  const char *return_value_aui_service_dialog_get_service_type$5;
  const char *return_value_aui_service_dialog_get_service_name$6;
  const struct AvahiAddress *return_value_aui_service_dialog_get_address$7;
  unsigned short int return_value_aui_service_dialog_get_port$8;
  const char *return_value_aui_service_dialog_get_host_name$9;
  const struct AvahiStringList *return_value_aui_service_dialog_get_txt_data$10;
  signed int return_value_aui_service_dialog_get_resolve_service$11;
  signed int return_value_aui_service_dialog_get_resolve_host_name$12;
  signed int return_value_aui_service_dialog_get_address_family$13;
  switch(prop_id)
  {
    case (unsigned int)1:
    {
      return_value_aui_service_dialog_get_browse_service_types$3=aui_service_dialog_get_browse_service_types(d);
      g_value_set_pointer(value, (void *)return_value_aui_service_dialog_get_browse_service_types$3);
      break;
    }
    case (unsigned int)2:
    {
      return_value_aui_service_dialog_get_domain$4=aui_service_dialog_get_domain(d);
      g_value_set_string(value, return_value_aui_service_dialog_get_domain$4);
      break;
    }
    case (unsigned int)3:
    {
      return_value_aui_service_dialog_get_service_type$5=aui_service_dialog_get_service_type(d);
      g_value_set_string(value, return_value_aui_service_dialog_get_service_type$5);
      break;
    }
    case (unsigned int)4:
    {
      return_value_aui_service_dialog_get_service_name$6=aui_service_dialog_get_service_name(d);
      g_value_set_string(value, return_value_aui_service_dialog_get_service_name$6);
      break;
    }
    case (unsigned int)5:
    {
      return_value_aui_service_dialog_get_address$7=aui_service_dialog_get_address(d);
      g_value_set_pointer(value, (void *)return_value_aui_service_dialog_get_address$7);
      break;
    }
    case (unsigned int)6:
    {
      return_value_aui_service_dialog_get_port$8=aui_service_dialog_get_port(d);
      g_value_set_uint(value, (unsigned int)return_value_aui_service_dialog_get_port$8);
      break;
    }
    case (unsigned int)7:
    {
      return_value_aui_service_dialog_get_host_name$9=aui_service_dialog_get_host_name(d);
      g_value_set_string(value, return_value_aui_service_dialog_get_host_name$9);
      break;
    }
    case (unsigned int)8:
    {
      return_value_aui_service_dialog_get_txt_data$10=aui_service_dialog_get_txt_data(d);
      g_value_set_pointer(value, (void *)return_value_aui_service_dialog_get_txt_data$10);
      break;
    }
    case (unsigned int)9:
    {
      return_value_aui_service_dialog_get_resolve_service$11=aui_service_dialog_get_resolve_service(d);
      g_value_set_boolean(value, return_value_aui_service_dialog_get_resolve_service$11);
      break;
    }
    case (unsigned int)10:
    {
      return_value_aui_service_dialog_get_resolve_host_name$12=aui_service_dialog_get_resolve_host_name(d);
      g_value_set_boolean(value, return_value_aui_service_dialog_get_resolve_host_name$12);
      break;
    }
    case (unsigned int)11:
    {
      return_value_aui_service_dialog_get_address_family$13=aui_service_dialog_get_address_family(d);
      g_value_set_int(value, return_value_aui_service_dialog_get_address_family$13);
      break;
    }
    default:
      do
      {
        struct _GObject *_glib__object = (struct _GObject *)object;
        struct _GParamSpec *_glib__pspec = (struct _GParamSpec *)pspec;
        unsigned int _glib__property_id = prop_id;
        const char *return_value_g_type_name$14;
        return_value_g_type_name$14=g_type_name(((struct _GTypeClass *)((struct _GTypeInstance *)_glib__pspec)->g_class)->g_type);
        const char *return_value_g_type_name$15;
        return_value_g_type_name$15=g_type_name(((struct _GTypeClass *)((struct _GTypeInstance *)_glib__object)->g_class)->g_type);
        g_log((char *)0, (enum anonymous$10)G_LOG_LEVEL_WARNING, "%s:%d: invalid %s id %u for \"%s\" of type '%s' in '%s'", (const void *)"avahi-ui.c", 1490, (const void *)"property", _glib__property_id, _glib__pspec->name, return_value_g_type_name$14, return_value_g_type_name$15);
      }
      while((_Bool)0);
  }
}

// aui_service_dialog_get_resolve_host_name
// file avahi-ui.c line 1384
signed int aui_service_dialog_get_resolve_host_name(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_resolve_host_name", "AUI_IS_SERVICE_DIALOG(d)");
      return 0;
    }

  }
  while((_Bool)0);
  return d->priv->resolve_host_name;
}

// aui_service_dialog_get_resolve_service
// file avahi-ui.c line 1372
signed int aui_service_dialog_get_resolve_service(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_resolve_service", "AUI_IS_SERVICE_DIALOG(d)");
      return 0;
    }

  }
  while((_Bool)0);
  return d->priv->resolve_service;
}

// aui_service_dialog_get_service_name
// file avahi-ui.h line 121
const char * aui_service_dialog_get_service_name(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_service_name", "AUI_IS_SERVICE_DIALOG(d)");
      return (const char *)(void *)0;
    }

  }
  while((_Bool)0);
  return d->priv->service_name;
}

// aui_service_dialog_get_service_type
// file avahi-ui.h line 115
const char * aui_service_dialog_get_service_type(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_service_type", "AUI_IS_SERVICE_DIALOG(d)");
      return (const char *)(void *)0;
    }

  }
  while((_Bool)0);
  return d->priv->service_type;
}

// aui_service_dialog_get_txt_data
// file avahi-ui.h line 137
const struct AvahiStringList * aui_service_dialog_get_txt_data(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_txt_data", "AUI_IS_SERVICE_DIALOG(d)");
      return (const struct AvahiStringList *)(void *)0;
    }

  }
  while((_Bool)0);
  do
    if(d->priv->resolve_service_done == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_get_txt_data", "d->priv->resolve_service_done");
      return (const struct AvahiStringList *)(void *)0;
    }

  while((_Bool)0);
  return d->priv->txt_data;
}

// aui_service_dialog_get_type
// file avahi-ui.h line 59
unsigned long int aui_service_dialog_get_type(void)
{
  _Bool tmp_statement_expression$3;
  void *tmp_statement_expression$4;
  signed int return_value___atomic_load_8$5;
  static volatile unsigned long int g_define_type_id__volatile = (volatile unsigned long int)0;
  //return_value___atomic_load_8$5=__atomic_load_8();
  tmp_statement_expression$4 = (void *)return_value___atomic_load_8$5;
  _Bool tmp_if_expr$7;
  signed int return_value_g_once_init_enter$6;
  if(tmp_statement_expression$4 == NULL)
  {
    return_value_g_once_init_enter$6=g_once_init_enter((volatile void *)&g_define_type_id__volatile);
    tmp_if_expr$7 = return_value_g_once_init_enter$6 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$7 = (_Bool)0;
  tmp_statement_expression$3 = tmp_if_expr$7;
  if(tmp_statement_expression$3)
  {
    unsigned long int g_define_type_id;
    unsigned long int return_value_gtk_dialog_get_type$1;
    return_value_gtk_dialog_get_type$1=gtk_dialog_get_type();
    const char *return_value_g_intern_static_string$2;
    return_value_g_intern_static_string$2=g_intern_static_string("AuiServiceDialog");
    g_define_type_id=g_type_register_static_simple(return_value_gtk_dialog_get_type$1, return_value_g_intern_static_string$2, (unsigned int)sizeof(struct _AuiServiceDialogClass) /*1152ul*/ , (void (*)(void *, void *))aui_service_dialog_class_intern_init, (unsigned int)sizeof(struct _AuiServiceDialog) /*72ul*/ , (void (*)(struct _GTypeInstance *, void *))aui_service_dialog_init, (enum anonymous$3)0);
    (void)(unsigned long int)0;
    g_once_init_leave((volatile void *)&g_define_type_id__volatile, (unsigned long int)g_define_type_id);
  }

  return g_define_type_id__volatile;
}

// aui_service_dialog_init
// file avahi-ui.c line 1080
static void aui_service_dialog_init(struct _AuiServiceDialog *d)
{
  struct _GtkWidget *vbox;
  struct _GtkWidget *vbox2;
  struct _GtkWidget *scrolled_window;
  struct _GtkCellRenderer *renderer;
  struct _GtkTreeViewColumn *column;
  struct _GtkTreeSelection *selection;
  struct _AuiServiceDialogPrivate *p;
  void *return_value_g_malloc_n$1;
  return_value_g_malloc_n$1=g_malloc_n((unsigned long int)1, sizeof(struct _AuiServiceDialogPrivate) /*264ul*/ );
  d->priv = (struct _AuiServiceDialogPrivate *)return_value_g_malloc_n$1;
  p = d->priv;
  p->host_name = (char *)(void *)0;
  p->domain = (char *)(void *)0;
  p->service_name = (char *)(void *)0;
  p->service_type = (char *)(void *)0;
  p->txt_data = (struct AvahiStringList *)(void *)0;
  p->browse_service_types = (char **)(void *)0;
  memset((void *)&p->address, 0, sizeof(struct AvahiAddress) /*20ul*/ );
  p->port = (unsigned short int)0;
  p->resolve_service = (signed int)!(0 != 0);
  p->resolve_host_name = p->resolve_service;
  p->resolve_service_done = 0;
  p->resolve_host_name_done = p->resolve_service_done;
  p->address_family = -1;
  p->glib_poll = (struct AvahiGLibPoll *)(void *)0;
  p->client = (struct AvahiClient *)(void *)0;
  p->browsers = (struct AvahiServiceBrowser **)(void *)0;
  p->resolver = (struct AvahiServiceResolver *)(void *)0;
  p->domain_browser = (struct AvahiDomainBrowser *)(void *)0;
  p->service_pulse_timeout = (unsigned int)0;
  p->domain_pulse_timeout = (unsigned int)0;
  p->start_idle = (unsigned int)0;
  p->common_interface = -1;
  p->common_protocol = -1;
  p->domain_dialog = (struct _GtkWidget *)(void *)0;
  p->domain_entry = (struct _GtkWidget *)(void *)0;
  p->domain_tree_view = (struct _GtkWidget *)(void *)0;
  p->domain_progress_bar = (struct _GtkWidget *)(void *)0;
  p->domain_ok_button = (struct _GtkWidget *)(void *)0;
  p->forward_response_id = -1;
  p->domain_list_store = (struct _GtkListStore *)(void *)0;
  p->service_list_store = p->domain_list_store;
  p->service_type_names = (struct _GHashTable *)(void *)0;
  unsigned long int return_value_gtk_container_get_type$2;
  return_value_gtk_container_get_type$2=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_container_get_type$2);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$3, (unsigned int)5);
  vbox=gtk_box_new((enum anonymous$16)GTK_ORIENTATION_VERTICAL, 8);
  unsigned long int return_value_gtk_container_get_type$4;
  return_value_gtk_container_get_type$4=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_container_get_type$4);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$5, (unsigned int)8);
  unsigned long int return_value_gtk_dialog_get_type$6;
  return_value_gtk_dialog_get_type$6=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$6);
  struct _GtkWidget *return_value_gtk_dialog_get_content_area$8;
  return_value_gtk_dialog_get_content_area$8=gtk_dialog_get_content_area((struct _GtkDialog *)return_value_g_type_check_instance_cast$7);
  unsigned long int return_value_gtk_box_get_type$9;
  return_value_gtk_box_get_type$9=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_dialog_get_content_area$8, return_value_gtk_box_get_type$9);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$10, vbox, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  char *return_value_dgettext$11;
  return_value_dgettext$11=dgettext("avahi", "Initializing...");
  p->domain_label=gtk_label_new(return_value_dgettext$11);
  unsigned long int return_value_gtk_label_get_type$12;
  return_value_gtk_label_get_type$12=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_label, return_value_gtk_label_get_type$12);
  gtk_label_set_ellipsize((struct _GtkLabel *)return_value_g_type_check_instance_cast$13, (enum anonymous$0)!(0 != 0));
  unsigned long int return_value_gtk_misc_get_type$14;
  return_value_gtk_misc_get_type$14=gtk_misc_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_label, return_value_gtk_misc_get_type$14);
  gtk_misc_set_alignment((struct _GtkMisc *)return_value_g_type_check_instance_cast$15, (float)0, (float)0.5);
  unsigned long int return_value_gtk_box_get_type$16;
  return_value_gtk_box_get_type$16=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type$16);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$17, p->domain_label, 0, 0, (unsigned int)0);
  vbox2=gtk_box_new((enum anonymous$16)GTK_ORIENTATION_VERTICAL, 8);
  unsigned long int return_value_gtk_box_get_type$18;
  return_value_gtk_box_get_type$18=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
  return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type$18);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$19, vbox2, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  scrolled_window=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
  unsigned long int return_value_gtk_scrolled_window_get_type$20;
  return_value_gtk_scrolled_window_get_type$20=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
  return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type$20);
  gtk_scrolled_window_set_policy((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$21, (enum anonymous$2)GTK_POLICY_AUTOMATIC, (enum anonymous$2)GTK_POLICY_AUTOMATIC);
  unsigned long int return_value_gtk_scrolled_window_get_type$22;
  return_value_gtk_scrolled_window_get_type$22=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
  return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type$22);
  gtk_scrolled_window_set_shadow_type((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$23, (enum anonymous$5)GTK_SHADOW_ETCHED_IN);
  unsigned long int return_value_gtk_box_get_type$24;
  return_value_gtk_box_get_type$24=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
  return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)vbox2, return_value_gtk_box_get_type$24);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$25, scrolled_window, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  p->service_list_store=gtk_list_store_new(6, (unsigned long int)(6 << 2), (unsigned long int)(6 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2));
  unsigned long int return_value_gtk_tree_model_get_type$26;
  return_value_gtk_tree_model_get_type$26=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
  return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)p->service_list_store, return_value_gtk_tree_model_get_type$26);
  p->service_tree_view=gtk_tree_view_new_with_model((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$27);
  unsigned long int return_value_gtk_tree_view_get_type$28;
  return_value_gtk_tree_view_get_type$28=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
  return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)p->service_tree_view, return_value_gtk_tree_view_get_type$28);
  gtk_tree_view_set_headers_visible((struct _GtkTreeView *)return_value_g_type_check_instance_cast$29, 0);
  g_signal_connect_data((void *)p->service_tree_view, "row-activated", (void (*)(void))service_row_activated_callback, (void *)d, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$7)0);
  unsigned long int return_value_gtk_tree_view_get_type$30;
  return_value_gtk_tree_view_get_type$30=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$31;
  return_value_g_type_check_instance_cast$31=g_type_check_instance_cast((struct _GTypeInstance *)p->service_tree_view, return_value_gtk_tree_view_get_type$30);
  selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$31);
  gtk_tree_selection_set_mode(selection, (enum anonymous$1)GTK_SELECTION_BROWSE);
  g_signal_connect_data((void *)selection, "changed", (void (*)(void))service_selection_changed_callback, (void *)d, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$7)0);
  renderer=gtk_cell_renderer_text_new();
  char *return_value_dgettext$32;
  return_value_dgettext$32=dgettext("avahi", "Location");
  column=gtk_tree_view_column_new_with_attributes(return_value_dgettext$32, renderer, (const void *)"text", 4, (void *)0);
  gtk_tree_view_column_set_visible(column, 0);
  unsigned long int return_value_gtk_tree_view_get_type$33;
  return_value_gtk_tree_view_get_type$33=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
  return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)p->service_tree_view, return_value_gtk_tree_view_get_type$33);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$34, column);
  renderer=gtk_cell_renderer_text_new();
  char *return_value_dgettext$35;
  return_value_dgettext$35=dgettext("avahi", "Name");
  column=gtk_tree_view_column_new_with_attributes(return_value_dgettext$35, renderer, (const void *)"text", 3, (void *)0);
  gtk_tree_view_column_set_expand(column, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_tree_view_get_type$36;
  return_value_gtk_tree_view_get_type$36=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$37;
  return_value_g_type_check_instance_cast$37=g_type_check_instance_cast((struct _GTypeInstance *)p->service_tree_view, return_value_gtk_tree_view_get_type$36);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$37, column);
  renderer=gtk_cell_renderer_text_new();
  char *return_value_dgettext$38;
  return_value_dgettext$38=dgettext("avahi", "Type");
  column=gtk_tree_view_column_new_with_attributes(return_value_dgettext$38, renderer, (const void *)"text", 5, (void *)0);
  gtk_tree_view_column_set_visible(column, 0);
  unsigned long int return_value_gtk_tree_view_get_type$39;
  return_value_gtk_tree_view_get_type$39=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$40;
  return_value_g_type_check_instance_cast$40=g_type_check_instance_cast((struct _GTypeInstance *)p->service_tree_view, return_value_gtk_tree_view_get_type$39);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$40, column);
  unsigned long int return_value_gtk_tree_view_get_type$41;
  return_value_gtk_tree_view_get_type$41=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$42;
  return_value_g_type_check_instance_cast$42=g_type_check_instance_cast((struct _GTypeInstance *)p->service_tree_view, return_value_gtk_tree_view_get_type$41);
  gtk_tree_view_set_search_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$42, 3);
  unsigned long int return_value_gtk_container_get_type$43;
  return_value_gtk_container_get_type$43=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$44;
  return_value_g_type_check_instance_cast$44=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_container_get_type$43);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$44, p->service_tree_view);
  p->service_progress_bar=gtk_progress_bar_new();
  unsigned long int return_value_gtk_progress_bar_get_type$45;
  return_value_gtk_progress_bar_get_type$45=gtk_progress_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$46;
  return_value_g_type_check_instance_cast$46=g_type_check_instance_cast((struct _GTypeInstance *)p->service_progress_bar, return_value_gtk_progress_bar_get_type$45);
  char *return_value_dgettext$47;
  return_value_dgettext$47=dgettext("avahi", "Browsing...");
  gtk_progress_bar_set_text((struct _GtkProgressBar *)return_value_g_type_check_instance_cast$46, return_value_dgettext$47);
  unsigned long int return_value_gtk_progress_bar_get_type$48;
  return_value_gtk_progress_bar_get_type$48=gtk_progress_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$49;
  return_value_g_type_check_instance_cast$49=g_type_check_instance_cast((struct _GTypeInstance *)p->service_progress_bar, return_value_gtk_progress_bar_get_type$48);
  gtk_progress_bar_set_pulse_step((struct _GtkProgressBar *)return_value_g_type_check_instance_cast$49, 0.1);
  unsigned long int return_value_gtk_box_get_type$50;
  return_value_gtk_box_get_type$50=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$51;
  return_value_g_type_check_instance_cast$51=g_type_check_instance_cast((struct _GTypeInstance *)vbox2, return_value_gtk_box_get_type$50);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast$51, p->service_progress_bar, 0, 0, (unsigned int)0);
  char *return_value_dgettext$52;
  return_value_dgettext$52=dgettext("avahi", "_Domain...");
  p->domain_button=gtk_button_new_with_mnemonic(return_value_dgettext$52);
  unsigned long int return_value_gtk_button_get_type$53;
  return_value_gtk_button_get_type$53=gtk_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$54;
  return_value_g_type_check_instance_cast$54=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_button, return_value_gtk_button_get_type$53);
  struct _GtkWidget *return_value_gtk_image_new_from_icon_name$55;
  return_value_gtk_image_new_from_icon_name$55=gtk_image_new_from_icon_name("network-workgroup", (enum anonymous$32)GTK_ICON_SIZE_BUTTON);
  gtk_button_set_image((struct _GtkButton *)return_value_g_type_check_instance_cast$54, return_value_gtk_image_new_from_icon_name$55);
  g_signal_connect_data((void *)p->domain_button, "clicked", (void (*)(void))domain_button_clicked, (void *)d, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$7)0);
  unsigned long int return_value_gtk_dialog_get_type$56;
  return_value_gtk_dialog_get_type$56=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$57;
  return_value_g_type_check_instance_cast$57=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$56);
  struct _GtkWidget *return_value_gtk_dialog_get_action_area$58;
  return_value_gtk_dialog_get_action_area$58=gtk_dialog_get_action_area((struct _GtkDialog *)return_value_g_type_check_instance_cast$57);
  unsigned long int return_value_gtk_box_get_type$59;
  return_value_gtk_box_get_type$59=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$60;
  return_value_g_type_check_instance_cast$60=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_dialog_get_action_area$58, return_value_gtk_box_get_type$59);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$60, p->domain_button, 0, (signed int)!(0 != 0), (unsigned int)0);
  unsigned long int return_value_gtk_dialog_get_type$61;
  return_value_gtk_dialog_get_type$61=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$62;
  return_value_g_type_check_instance_cast$62=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$61);
  struct _GtkWidget *return_value_gtk_dialog_get_action_area$63;
  return_value_gtk_dialog_get_action_area$63=gtk_dialog_get_action_area((struct _GtkDialog *)return_value_g_type_check_instance_cast$62);
  unsigned long int return_value_gtk_button_box_get_type$64;
  return_value_gtk_button_box_get_type$64=gtk_button_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$65;
  return_value_g_type_check_instance_cast$65=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_dialog_get_action_area$63, return_value_gtk_button_box_get_type$64);
  gtk_button_box_set_child_secondary((struct _GtkButtonBox *)return_value_g_type_check_instance_cast$65, p->domain_button, (signed int)!(0 != 0));
  gtk_widget_show(p->domain_button);
  unsigned long int return_value_gtk_dialog_get_type$66;
  return_value_gtk_dialog_get_type$66=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$67;
  return_value_g_type_check_instance_cast$67=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$66);
  gtk_dialog_set_default_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$67, -3);
  gtk_widget_grab_focus(p->service_tree_view);
  unsigned long int return_value_gtk_window_get_type$68;
  return_value_gtk_window_get_type$68=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$69;
  return_value_g_type_check_instance_cast$69=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type$68);
  gtk_window_set_default_size((struct _GtkWindow *)return_value_g_type_check_instance_cast$69, 400, 300);
  gtk_widget_show_all(vbox);
  p->glib_poll=avahi_glib_poll_new((struct _GMainContext *)(void *)0, 0);
  p->service_pulse_timeout=g_timeout_add((unsigned int)100, service_pulse_callback, (void *)d);
  p->start_idle=g_idle_add(start_callback, (void *)d);
  g_signal_connect_data((void *)d, "response", (void (*)(void))response_callback, (void *)d, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$7)0);
}

// aui_service_dialog_new
// file avahi-ui.h line 72
struct _GtkWidget * aui_service_dialog_new(const char *title, struct _GtkWindow *parent, const char *first_button_text, ...)
{
  struct _GtkWidget *w;
  void **varargs = (void **)&first_button_text;
  w=aui_service_dialog_new_valist(title, parent, first_button_text, varargs);
  varargs = ((void **)NULL);
  return w;
}

// aui_service_dialog_new_valist
// file avahi-ui.c line 248
struct _GtkWidget * aui_service_dialog_new_valist(const char *title, struct _GtkWindow *parent, const char *first_button_text, __builtin_va_list varargs)
{
  const char *button_text;
  signed int dr;
  struct _GtkWidget *w;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  void *return_value_g_object_new$2;
  return_value_g_object_new$2=g_object_new(return_value_aui_service_dialog_get_type$1, "title", title, (void *)0);
  w = (struct _GtkWidget *)return_value_g_object_new$2;
  unsigned long int return_value_gtk_window_get_type$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  if(!(parent == ((struct _GtkWindow *)NULL)))
  {
    return_value_gtk_window_get_type$3=gtk_window_get_type();
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_window_get_type$3);
    gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast$4, parent);
  }

  button_text = first_button_text;
  while(!(button_text == ((const char *)NULL)))
  {
    signed int response_id;
    response_id=va_arg(varargs, __typeof__(response_id));
    unsigned long int return_value_gtk_dialog_get_type$5;
    return_value_gtk_dialog_get_type$5=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_dialog_get_type$5);
    gtk_dialog_add_button((struct _GtkDialog *)return_value_g_type_check_instance_cast$6, button_text, response_id);
    button_text=va_arg(varargs, __typeof__(button_text));
  }
  unsigned long int return_value_gtk_dialog_get_type$7;
  return_value_gtk_dialog_get_type$7=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_dialog_get_type$7);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast$8, -3, 0);
  unsigned long int return_value_gtk_dialog_get_type$9;
  return_value_gtk_dialog_get_type$9=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_dialog_get_type$9);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast$10, -5, 0);
  unsigned long int return_value_gtk_dialog_get_type$11;
  return_value_gtk_dialog_get_type$11=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_dialog_get_type$11);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast$12, -8, 0);
  unsigned long int return_value_gtk_dialog_get_type$13;
  return_value_gtk_dialog_get_type$13=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_dialog_get_type$13);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast$14, -10, 0);
  unsigned long int return_value_gtk_dialog_get_type$17;
  return_value_gtk_dialog_get_type$17=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_dialog_get_type$17);
  dr=get_default_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$18);
  unsigned long int return_value_gtk_dialog_get_type$15;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  if(!(dr == -1))
  {
    return_value_gtk_dialog_get_type$15=gtk_dialog_get_type();
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)w, return_value_gtk_dialog_get_type$15);
    gtk_dialog_set_default_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$16, dr);
  }

  return w;
}

// aui_service_dialog_set_address_family
// file avahi-ui.c line 1390
void aui_service_dialog_set_address_family(struct _AuiServiceDialog *d, signed int proto)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_address_family", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L10;
    }

  }
  while((_Bool)0);
  do
    if(!(proto == 0) && !(proto == 1) && !(proto == -1))
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_address_family", "proto == AVAHI_PROTO_UNSPEC || proto == AVAHI_PROTO_INET || proto == AVAHI_PROTO_INET6");
      goto __CPROVER_DUMP_L10;
    }

  while((_Bool)0);
  d->priv->address_family = proto;

__CPROVER_DUMP_L10:
  ;
}

// aui_service_dialog_set_browse_service_types
// file avahi-ui.h line 90
void aui_service_dialog_set_browse_service_types(struct _AuiServiceDialog *d, const char *type, ...)
{
  __builtin_va_list ap;
  const char *t;
  unsigned int u;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_browse_service_types", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L15;
    }

  }
  while((_Bool)0);
  do
    if(type == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_browse_service_types", "type");
      goto __CPROVER_DUMP_L15;
    }

  while((_Bool)0);
  g_strfreev(d->priv->browse_service_types);
  va_start(ap, type);
  u = (unsigned int)1;
  const char *return_value_gcc_builtin_va_arg$3;
  do
  {
    return_value_gcc_builtin_va_arg$3=va_arg(ap, __typeof__(return_value_gcc_builtin_va_arg$3));
    if(return_value_gcc_builtin_va_arg$3 == ((const char *)NULL))
      break;

    u = u + 1u;
  }
  while((_Bool)1);
  va_end(ap);
  void *return_value_g_malloc0_n$4;
  return_value_g_malloc0_n$4=g_malloc0_n((unsigned long int)(u + (unsigned int)1), sizeof(char *) /*8ul*/ );
  d->priv->browse_service_types = (char **)return_value_g_malloc0_n$4;
  d->priv->browse_service_types[(signed long int)0]=g_strdup(type);
  va_start(ap, type);
  u = (unsigned int)1;
  do
  {
    t=va_arg(ap, __typeof__(t));
    if(t == ((const char *)NULL))
      break;

    d->priv->browse_service_types[(signed long int)u]=g_strdup(t);
    u = u + 1u;
  }
  while((_Bool)1);
  va_end(ap);
  if(!(*d->priv->browse_service_types == ((char *)NULL)))
  {
    if(!(d->priv->browse_service_types[1l] == ((char *)NULL)))
    {
      unsigned long int return_value_gtk_tree_view_get_type$5;
      return_value_gtk_tree_view_get_type$5=gtk_tree_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type$5);
      struct _GtkTreeViewColumn *return_value_gtk_tree_view_get_column$7;
      return_value_gtk_tree_view_get_column$7=gtk_tree_view_get_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$6, 2);
      gtk_tree_view_column_set_visible(return_value_gtk_tree_view_get_column$7, (signed int)!(0 != 0));
    }

  }

  restart_browsing(d);

__CPROVER_DUMP_L15:
  ;
}

// aui_service_dialog_set_browse_service_typesv
// file avahi-ui.c line 1245
void aui_service_dialog_set_browse_service_typesv(struct _AuiServiceDialog *d, const char * const *types)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_browse_service_typesv", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L13;
    }

  }
  while((_Bool)0);
  do
    if(types == ((const char * const *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_browse_service_typesv", "types");
      goto __CPROVER_DUMP_L13;
    }

  while((_Bool)0);
  do
    if(*types == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_browse_service_typesv", "*types");
      goto __CPROVER_DUMP_L13;
    }

  while((_Bool)0);
  g_strfreev(d->priv->browse_service_types);
  d->priv->browse_service_types=g_strdupv((char **)types);
  if(!(*d->priv->browse_service_types == ((char *)NULL)))
  {
    if(!(d->priv->browse_service_types[1l] == ((char *)NULL)))
    {
      unsigned long int return_value_gtk_tree_view_get_type$3;
      return_value_gtk_tree_view_get_type$3=gtk_tree_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type$3);
      struct _GtkTreeViewColumn *return_value_gtk_tree_view_get_column$5;
      return_value_gtk_tree_view_get_column$5=gtk_tree_view_get_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$4, 2);
      gtk_tree_view_column_set_visible(return_value_gtk_tree_view_get_column$5, (signed int)!(0 != 0));
    }

  }

  restart_browsing(d);

__CPROVER_DUMP_L13:
  ;
}

// aui_service_dialog_set_domain
// file avahi-ui.h line 103
void aui_service_dialog_set_domain(struct _AuiServiceDialog *d, const char *domain)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_domain", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L14;
    }

  }
  while((_Bool)0);
  _Bool tmp_if_expr$4;
  signed int return_value_is_valid_domain_suffix$3;
  do
  {
    if(domain == ((const char *)NULL))
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_is_valid_domain_suffix$3=is_valid_domain_suffix(domain);
      tmp_if_expr$4 = return_value_is_valid_domain_suffix$3 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$4)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_domain", "!domain || is_valid_domain_suffix(domain)");
      goto __CPROVER_DUMP_L14;
    }

  }
  while((_Bool)0);
  g_free((void *)d->priv->domain);
  char *tmp_if_expr$6;
  char *return_value_avahi_normalize_name_strdup$5;
  if(!(domain == ((const char *)NULL)))
  {
    return_value_avahi_normalize_name_strdup$5=avahi_normalize_name_strdup(domain);
    tmp_if_expr$6 = return_value_avahi_normalize_name_strdup$5;
  }

  else
    tmp_if_expr$6 = (char *)(void *)0;
  d->priv->domain = tmp_if_expr$6;
  restart_browsing(d);

__CPROVER_DUMP_L14:
  ;
}

// aui_service_dialog_set_property
// file avahi-ui.c line 1403
static void aui_service_dialog_set_property(struct _GObject *object, unsigned int prop_id, const struct _GValue *value, struct _GParamSpec *pspec)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)object, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  void *return_value_g_value_get_pointer$3;
  const char *return_value_g_value_get_string$4;
  const char *return_value_g_value_get_string$5;
  const char *return_value_g_value_get_string$6;
  signed int return_value_g_value_get_boolean$7;
  signed int return_value_g_value_get_boolean$8;
  signed int return_value_g_value_get_int$9;
  switch(prop_id)
  {
    case (unsigned int)1:
    {
      return_value_g_value_get_pointer$3=g_value_get_pointer(value);
      aui_service_dialog_set_browse_service_typesv(d, (const char * const *)return_value_g_value_get_pointer$3);
      break;
    }
    case (unsigned int)2:
    {
      return_value_g_value_get_string$4=g_value_get_string(value);
      aui_service_dialog_set_domain(d, return_value_g_value_get_string$4);
      break;
    }
    case (unsigned int)3:
    {
      return_value_g_value_get_string$5=g_value_get_string(value);
      aui_service_dialog_set_service_type(d, return_value_g_value_get_string$5);
      break;
    }
    case (unsigned int)4:
    {
      return_value_g_value_get_string$6=g_value_get_string(value);
      aui_service_dialog_set_service_name(d, return_value_g_value_get_string$6);
      break;
    }
    case (unsigned int)9:
    {
      return_value_g_value_get_boolean$7=g_value_get_boolean(value);
      aui_service_dialog_set_resolve_service(d, return_value_g_value_get_boolean$7);
      break;
    }
    case (unsigned int)10:
    {
      return_value_g_value_get_boolean$8=g_value_get_boolean(value);
      aui_service_dialog_set_resolve_host_name(d, return_value_g_value_get_boolean$8);
      break;
    }
    case (unsigned int)11:
    {
      return_value_g_value_get_int$9=g_value_get_int(value);
      aui_service_dialog_set_address_family(d, return_value_g_value_get_int$9);
      break;
    }
    default:
      do
      {
        struct _GObject *_glib__object = (struct _GObject *)object;
        struct _GParamSpec *_glib__pspec = (struct _GParamSpec *)pspec;
        unsigned int _glib__property_id = prop_id;
        const char *return_value_g_type_name$10;
        return_value_g_type_name$10=g_type_name(((struct _GTypeClass *)((struct _GTypeInstance *)_glib__pspec)->g_class)->g_type);
        const char *return_value_g_type_name$11;
        return_value_g_type_name$11=g_type_name(((struct _GTypeClass *)((struct _GTypeInstance *)_glib__object)->g_class)->g_type);
        g_log((char *)0, (enum anonymous$10)G_LOG_LEVEL_WARNING, "%s:%d: invalid %s id %u for \"%s\" of type '%s' in '%s'", (const void *)"avahi-ui.c", 1436, (const void *)"property", _glib__property_id, _glib__pspec->name, return_value_g_type_name$10, return_value_g_type_name$11);
      }
      while((_Bool)0);
  }
}

// aui_service_dialog_set_resolve_host_name
// file avahi-ui.h line 160
void aui_service_dialog_set_resolve_host_name(struct _AuiServiceDialog *d, signed int resolve)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_resolve_host_name", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  d->priv->resolve_host_name = resolve;

__CPROVER_DUMP_L8:
  ;
}

// aui_service_dialog_set_resolve_service
// file avahi-ui.h line 149
void aui_service_dialog_set_resolve_service(struct _AuiServiceDialog *d, signed int resolve)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_resolve_service", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  d->priv->resolve_service = resolve;

__CPROVER_DUMP_L8:
  ;
}

// aui_service_dialog_set_service_name
// file avahi-ui.c line 1312
void aui_service_dialog_set_service_name(struct _AuiServiceDialog *d, const char *name)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_service_name", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  g_free((void *)d->priv->service_name);
  d->priv->service_name=g_strdup(name);

__CPROVER_DUMP_L8:
  ;
}

// aui_service_dialog_set_service_type
// file avahi-ui.c line 1325
void aui_service_dialog_set_service_type(struct _AuiServiceDialog *d, const char *stype)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_service_type", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  g_free((void *)d->priv->service_type);
  d->priv->service_type=g_strdup(stype);

__CPROVER_DUMP_L8:
  ;
}

// aui_service_dialog_set_service_type_name
// file avahi-ui.h line 96
void aui_service_dialog_set_service_type_name(struct _AuiServiceDialog *d, const char *type, const char *name)
{
  struct _GtkTreeModel *m = (struct _GtkTreeModel *)(void *)0;
  struct _GtkTreeIter iter;
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_service_type_name", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L17;
    }

  }
  while((_Bool)0);
  do
    if(type == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_service_type_name", "NULL != type");
      goto __CPROVER_DUMP_L17;
    }

  while((_Bool)0);
  do
    if(name == ((const char *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"aui_service_dialog_set_service_type_name", "NULL != name");
      goto __CPROVER_DUMP_L17;
    }

  while((_Bool)0);
  if(d->priv->service_type_names == ((struct _GHashTable *)NULL))
    d->priv->service_type_names=g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);

  char *return_value_g_strdup$3;
  return_value_g_strdup$3=g_strdup(type);
  char *return_value_g_strdup$4;
  return_value_g_strdup$4=g_strdup(name);
  g_hash_table_insert(d->priv->service_type_names, (void *)return_value_g_strdup$3, (void *)return_value_g_strdup$4);
  unsigned long int return_value_gtk_tree_model_get_type$5;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  if(!(d->priv->service_list_store == ((struct _GtkListStore *)NULL)))
  {
    return_value_gtk_tree_model_get_type$5=gtk_tree_model_get_type();
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_list_store, return_value_gtk_tree_model_get_type$5);
    m = (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$6;
  }

  signed int return_value_gtk_tree_model_get_iter_first$9;
  signed int return_value_g_str_equal$8;
  signed int return_value_gtk_tree_model_iter_next$7;
  if(!(m == ((struct _GtkTreeModel *)NULL)))
  {
    return_value_gtk_tree_model_get_iter_first$9=gtk_tree_model_get_iter_first(m, &iter);
    if(!(return_value_gtk_tree_model_get_iter_first$9 == 0))
      do
      {
        char *stored_type = (char *)(void *)0;
        gtk_tree_model_get(m, &iter, 2, &stored_type, -1);
        if(!(stored_type == ((char *)NULL)))
        {
          return_value_g_str_equal$8=g_str_equal((const void *)stored_type, (const void *)type);
          if(!(return_value_g_str_equal$8 == 0))
            gtk_list_store_set(d->priv->service_list_store, &iter, 5, name, -1);

        }

        return_value_gtk_tree_model_iter_next$7=gtk_tree_model_iter_next(m, &iter);
      }
      while(!(return_value_gtk_tree_model_iter_next$7 == 0));

  }


__CPROVER_DUMP_L17:
  ;
}

// avahi_address_cmp
// file address.c line 46
signed int avahi_address_cmp(const struct AvahiAddress *a, const struct AvahiAddress *b)
{
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  /* assertion b */
  assert(b != ((const struct AvahiAddress *)NULL));
  if(!(a->proto == b->proto))
    return -1;

  else
  {
    unsigned long int return_value_address_get_size$1;
    return_value_address_get_size$1=address_get_size(a);
    signed int return_value_memcmp$2;
    return_value_memcmp$2=memcmp((const void *)a->data.data, (const void *)b->data.data, return_value_address_get_size$1);
    return return_value_memcmp$2;
  }
}

// avahi_address_parse
// file ../avahi-common/address.h line 95
struct AvahiAddress * avahi_address_parse(const char *s, signed int proto, struct AvahiAddress *ret_addr)
{
  /* assertion ret_addr */
  assert(ret_addr != ((struct AvahiAddress *)NULL));
  /* assertion s */
  assert(s != ((const char *)NULL));
  if(proto == -1)
  {
    signed int return_value_inet_pton$2;
    return_value_inet_pton$2=inet_pton(2, s, (void *)ret_addr->data.data);
    if(!(return_value_inet_pton$2 >= 1))
    {
      signed int return_value_inet_pton$1;
      return_value_inet_pton$1=inet_pton(10, s, (void *)ret_addr->data.data);
      if(!(return_value_inet_pton$1 >= 1))
        return (struct AvahiAddress *)(void *)0;

      else
        ret_addr->proto = 1;
    }

    else
      ret_addr->proto = 0;
  }

  else
  {
    signed int return_value_avahi_proto_to_af$3;
    return_value_avahi_proto_to_af$3=avahi_proto_to_af(proto);
    signed int return_value_inet_pton$4;
    return_value_inet_pton$4=inet_pton(return_value_avahi_proto_to_af$3, s, (void *)ret_addr->data.data);
    if(!(return_value_inet_pton$4 >= 1))
      return (struct AvahiAddress *)(void *)0;

    ret_addr->proto = proto;
  }
  return ret_addr;
}

// avahi_address_resolver_event
// file internal.h line 166
enum anonymous$42 avahi_address_resolver_event(struct AvahiClient *client, enum anonymous$12 event, struct DBusMessage *message)
{
  struct AvahiAddressResolver *r = (struct AvahiAddressResolver *)(void *)0;
  struct DBusError error;
  const char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp$1;
  signed int interface;
  signed int protocol;
  signed int aprotocol;
  unsigned int flags;
  char *name;
  char *address;
  struct AvahiAddress a;
  unsigned int return_value_dbus_message_get_args$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  struct AvahiAddress *return_value_avahi_address_parse$5;
  char *etxt;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  signed int return_value_avahi_error_dbus_to_number$9;
  if(!(path == ((const char *)NULL)))
  {
    r = client->address_resolvers;
    for( ; !(r == ((struct AvahiAddressResolver *)NULL)); r = r->address_resolvers_next)
    {
      return_value_strcmp$1=strcmp(r->path, path);
      if(return_value_strcmp$1 == 0)
        break;

    }
    if(r == ((struct AvahiAddressResolver *)NULL))
      goto fail;

    switch((signed int)event)
    {
      case AVAHI_RESOLVER_FOUND:
      {
        return_value_dbus_message_get_args$2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)105, &aprotocol, (signed int)115, &address, (signed int)115, &name, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args$2 == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        /* assertion address */
        assert(address != ((char *)NULL));
        return_value_avahi_address_parse$5=avahi_address_parse(address, (signed int)aprotocol, &a);
        if(return_value_avahi_address_parse$5 == ((struct AvahiAddress *)NULL))
        {
          fprintf(stderr, "Failed to parse address\n");
          goto fail;
        }

        r->callback(r, (signed int)interface, (signed int)protocol, (enum anonymous$12)AVAHI_RESOLVER_FOUND, &a, name, (enum anonymous$13)flags, r->userdata);
      }
      case AVAHI_RESOLVER_FAILURE:
      {
        return_value_dbus_message_get_args$6=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args$6 == 0u)
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
          tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number$9=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(r->client, return_value_avahi_error_dbus_to_number$9);
        r->callback(r, r->interface, r->protocol, event, &r->address, (const char *)(void *)0, (enum anonymous$13)0, r->userdata);
      }
    }
    return (enum anonymous$42)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous$42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_address_resolver_free
// file lookup.h line 269
signed int avahi_address_resolver_free(struct AvahiAddressResolver *r)
{
  struct AvahiClient *client;
  signed int ret = 0;
  /* assertion r */
  assert(r != ((struct AvahiAddressResolver *)NULL));
  client = r->client;
  signed int return_value_avahi_client_is_connected$1;
  if(!(r->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
    if(!(return_value_avahi_client_is_connected$1 == 0))
      ret=avahi_client_simple_method_call(client, r->path, "org.freedesktop.Avahi.AddressResolver", "Free");

  }

  do
  {
    struct AvahiAddressResolver **_head = &client->address_resolvers;
    struct AvahiAddressResolver *_item = r;
    /* assertion _item */
    assert(_item != ((struct AvahiAddressResolver *)NULL));
    if(!(_item->address_resolvers_next == ((struct AvahiAddressResolver *)NULL)))
      _item->address_resolvers_next->address_resolvers_prev = _item->address_resolvers_prev;

    if(!(_item->address_resolvers_prev == ((struct AvahiAddressResolver *)NULL)))
      _item->address_resolvers_prev->address_resolvers_next = _item->address_resolvers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->address_resolvers_next;
    }
    _item->address_resolvers_prev = (struct AvahiAddressResolver *)(void *)0;
    _item->address_resolvers_next = _item->address_resolvers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)r->path);
  avahi_free((void *)r);
  return ret;
}

// avahi_address_resolver_get_client
// file resolver.c line 755
struct AvahiClient * avahi_address_resolver_get_client(struct AvahiAddressResolver *r)
{
  /* assertion r */
  assert(r != ((struct AvahiAddressResolver *)NULL));
  return r->client;
}

// avahi_address_resolver_new
// file resolver.c line 642
struct AvahiAddressResolver * avahi_address_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const struct AvahiAddress *a, enum anonymous$44 flags, void (*callback)(struct AvahiAddressResolver *, signed int, signed int, enum anonymous$12, const struct AvahiAddress *, const char *, enum anonymous$13, void *), void *userdata)
{
  struct DBusError error;
  struct AvahiAddressResolver *r = (struct AvahiAddressResolver *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  char *path;
  char addr[40l];
  char *address = addr;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  dbus_error_init(&error);
  char *return_value_avahi_address_snprint$1;
  return_value_avahi_address_snprint$1=avahi_address_snprint(addr, sizeof(char [40l]) /*40ul*/ , a);
  void *return_value_avahi_new_internal$3;
  unsigned int return_value_dbus_message_append_args$4;
  _Bool tmp_if_expr$6;
  unsigned int return_value_dbus_error_is_set$5;
  unsigned int return_value_dbus_message_get_args$7;
  _Bool tmp_if_expr$9;
  unsigned int return_value_dbus_error_is_set$8;
  if(return_value_avahi_address_snprint$1 == ((char *)NULL))
  {
    avahi_client_set_errno(client, -14);
    return (struct AvahiAddressResolver *)(void *)0;
  }

  else
  {
    signed int return_value_avahi_client_is_connected$2;
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(client);
    if(return_value_avahi_client_is_connected$2 == 0)
      avahi_client_set_errno(client, -2);

    else
    {
      return_value_avahi_new_internal$3=avahi_new_internal$link3((unsigned int)1, sizeof(struct AvahiAddressResolver) /*80ul*/ );
      r = (struct AvahiAddressResolver *)return_value_avahi_new_internal$3;
      if(r == ((struct AvahiAddressResolver *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        r->client = client;
        r->callback = callback;
        r->userdata = userdata;
        r->path = (char *)(void *)0;
        r->interface = interface;
        r->protocol = protocol;
        r->address = *a;
        do
        {
          struct AvahiAddressResolver **_head = &client->address_resolvers;
          struct AvahiAddressResolver *_item = r;
          /* assertion _item */
          assert(_item != ((struct AvahiAddressResolver *)NULL));
          _item->address_resolvers_next = *_head;
          if(!(_item->address_resolvers_next == ((struct AvahiAddressResolver *)NULL)))
            _item->address_resolvers_next->address_resolvers_prev = _item;

          _item->address_resolvers_prev = (struct AvahiAddressResolver *)(void *)0;
          *_head = _item;
        }
        while((_Bool)0);
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "AddressResolverNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args$4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &address, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args$4 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr$6 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$5=dbus_error_is_set(&error);
              tmp_if_expr$6 = return_value_dbus_error_is_set$5 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$6)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args$7=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args$7 == 0u)
                tmp_if_expr$9 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set$8=dbus_error_is_set(&error);
                tmp_if_expr$9 = return_value_dbus_error_is_set$8 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr$9)
                avahi_client_set_errno(client, -22);

              else
              {
                r->path=avahi_strdup(path);
                if(r->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return r;
                }
              }
            }
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$10;
    return_value_dbus_error_is_set$10=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$10 == 0u))
    {
      avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(r == ((struct AvahiAddressResolver *)NULL)))
      avahi_address_resolver_free(r);

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return (struct AvahiAddressResolver *)(void *)0;
  }
}

// avahi_address_snprint
// file ../avahi-common/address.h line 90
char * avahi_address_snprint(char *s, unsigned long int length, const struct AvahiAddress *a)
{
  /* assertion s */
  assert(s != ((char *)NULL));
  /* assertion length */
  assert(length != 0ul);
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  signed int return_value_avahi_proto_to_af$1;
  return_value_avahi_proto_to_af$1=avahi_proto_to_af(a->proto);
  const char *return_value_inet_ntop$2;
  return_value_inet_ntop$2=inet_ntop(return_value_avahi_proto_to_af$1, (const void *)a->data.data, s, (unsigned int)length);
  if(return_value_inet_ntop$2 == ((const char *)NULL))
    return (char *)(void *)0;

  else
    return s;
}

// avahi_af_to_proto
// file address.c line 137
signed int avahi_af_to_proto(signed int af)
{
  if(af == 2)
    return 0;

  else
    if(af == 10)
      return 1;

    else
    {
      /* assertion af == 0 */
      assert(af == 0);
      return -1;
    }
}

// avahi_age
// file timeval.c line 76
signed long int avahi_age(struct timeval *a)
{
  struct timeval now;
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  gettimeofday(&now, (struct timezone *)(void *)0);
  signed long int return_value_avahi_timeval_diff$1;
  return_value_avahi_timeval_diff$1=avahi_timeval_diff(&now, a);
  return return_value_avahi_timeval_diff$1;
}

// avahi_alternative_host_name
// file alternative.c line 51
char * avahi_alternative_host_name(const char *s)
{
  const char *e;
  char *r;
  /* assertion s */
  assert(s != ((const char *)NULL));
  signed int return_value_avahi_is_valid_host_name$1;
  return_value_avahi_is_valid_host_name$1=avahi_is_valid_host_name(s);
  const unsigned short int **return_value___ctype_b_loc$2;
  _Bool tmp_if_expr$3;
  unsigned long int return_value_strlen$5;
  if(return_value_avahi_is_valid_host_name$1 == 0)
    return (char *)(void *)0;

  else
  {
    e=strrchr(s, 45);
    if(!(e == ((const char *)NULL)))
    {
      const char *p;
      e = e + 1l;
      p = e;
      for( ; !(*p == 0); p = p + 1l)
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*p]) == 0)
        {
          e = (const char *)(void *)0;
          break;
        }

      }
      if(!(e == ((const char *)NULL)))
      {
        if((signed int)*e == 48)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = (signed int)*e == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$3)
          e = (const char *)(void *)0;

      }

    }

    if(!(e == ((const char *)NULL)))
    {
      char *avahi_alternative_host_name$$1$$2$$c;
      char *m;
      unsigned long int l;
      signed int n;
      signed int return_value_atoi$4;
      return_value_atoi$4=atoi(e);
      n = return_value_atoi$4 + 1;
      m=avahi_strdup_printf("%i", n);
      if(m == ((char *)NULL))
        return (char *)(void *)0;

      l = (unsigned long int)((e - s) - (signed long int)1);
      unsigned long int return_value_strlen$6;
      return_value_strlen$6=strlen(m);
      if(l >= 63ul + -return_value_strlen$6 + 18446744073709551615ul)
      {
        return_value_strlen$5=strlen(m);
        l = ((unsigned long int)(64 - 1) - return_value_strlen$5) - (unsigned long int)1;
      }

      avahi_alternative_host_name$$1$$2$$c=avahi_strndup(s, l);
      if(avahi_alternative_host_name$$1$$2$$c == ((char *)NULL))
      {
        avahi_free((void *)m);
        return (char *)(void *)0;
      }

      drop_incomplete_utf8(avahi_alternative_host_name$$1$$2$$c);
      r=avahi_strdup_printf("%s-%s", avahi_alternative_host_name$$1$$2$$c, m);
      avahi_free((void *)avahi_alternative_host_name$$1$$2$$c);
      avahi_free((void *)m);
    }

    else
    {
      char *c;
      c=avahi_strndup(s, (unsigned long int)((64 - 1) - 2));
      if(c == ((char *)NULL))
        return (char *)(void *)0;

      drop_incomplete_utf8(c);
      r=avahi_strdup_printf("%s-2", c);
      avahi_free((void *)c);
    }
    signed int return_value_avahi_is_valid_host_name$7;
    return_value_avahi_is_valid_host_name$7=avahi_is_valid_host_name(r);
    /* assertion avahi_is_valid_host_name(r) */
    assert(return_value_avahi_is_valid_host_name$7 != 0);
    return r;
  }
}

// avahi_alternative_service_name
// file alternative.c line 117
char * avahi_alternative_service_name(const char *s)
{
  const char *e;
  char *r;
  /* assertion s */
  assert(s != ((const char *)NULL));
  signed int return_value_avahi_is_valid_service_name$1;
  return_value_avahi_is_valid_service_name$1=avahi_is_valid_service_name(s);
  const unsigned short int **return_value___ctype_b_loc$2;
  _Bool tmp_if_expr$3;
  unsigned long int return_value_strlen$5;
  if(return_value_avahi_is_valid_service_name$1 == 0)
    return (char *)(void *)0;

  else
  {
    e=strstr(s, " #");
    if(!(e == ((const char *)NULL)))
    {
      const char *n;
      const char *p;
      e = e + (signed long int)2;
      do
      {
        n=strstr(e, " #");
        if(n == ((const char *)NULL))
          break;

        e = n + (signed long int)2;
      }
      while((_Bool)1);
      p = e;
      for( ; !(*p == 0); p = p + 1l)
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*p]) == 0)
        {
          e = (const char *)(void *)0;
          break;
        }

      }
      if(!(e == ((const char *)NULL)))
      {
        if((signed int)*e == 48)
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = (signed int)*e == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$3)
          e = (const char *)(void *)0;

      }

    }

    if(!(e == ((const char *)NULL)))
    {
      char *c;
      char *m;
      unsigned long int l;
      signed int avahi_alternative_service_name$$1$$2$$n;
      signed int return_value_atoi$4;
      return_value_atoi$4=atoi(e);
      avahi_alternative_service_name$$1$$2$$n = return_value_atoi$4 + 1;
      m=avahi_strdup_printf("%i", avahi_alternative_service_name$$1$$2$$n);
      if(m == ((char *)NULL))
        return (char *)(void *)0;

      l = (unsigned long int)((e - s) - (signed long int)2);
      unsigned long int return_value_strlen$6;
      return_value_strlen$6=strlen(m);
      if(l >= 63ul + -return_value_strlen$6 + 18446744073709551614ul)
      {
        return_value_strlen$5=strlen(m);
        l = ((unsigned long int)(64 - 1) - return_value_strlen$5) - (unsigned long int)2;
      }

      c=avahi_strndup(s, l);
      if(c == ((char *)NULL))
      {
        avahi_free((void *)m);
        return (char *)(void *)0;
      }

      drop_incomplete_utf8(c);
      r=avahi_strdup_printf("%s #%s", c, m);
      avahi_free((void *)c);
      avahi_free((void *)m);
    }

    else
    {
      char *avahi_alternative_service_name$$1$$3$$c;
      avahi_alternative_service_name$$1$$3$$c=avahi_strndup(s, (unsigned long int)((64 - 1) - 3));
      if(avahi_alternative_service_name$$1$$3$$c == ((char *)NULL))
        return (char *)(void *)0;

      drop_incomplete_utf8(avahi_alternative_service_name$$1$$3$$c);
      r=avahi_strdup_printf("%s #2", avahi_alternative_service_name$$1$$3$$c);
      avahi_free((void *)avahi_alternative_service_name$$1$$3$$c);
    }
    signed int return_value_avahi_is_valid_service_name$7;
    return_value_avahi_is_valid_service_name$7=avahi_is_valid_service_name(r);
    /* assertion avahi_is_valid_service_name(r) */
    assert(return_value_avahi_is_valid_service_name$7 != 0);
    return r;
  }
}

// avahi_client_errno
// file client.c line 790
signed int avahi_client_errno(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  return client->error;
}

// avahi_client_free
// file client.c line 625
void avahi_client_free(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  if(!(client->bus == ((struct DBusConnection *)NULL)))
    dbus_connection_close(client->bus);

  while(!(client->groups == ((struct AvahiEntryGroup *)NULL)))
    avahi_entry_group_free(client->groups);
  while(!(client->domain_browsers == ((struct AvahiDomainBrowser *)NULL)))
    avahi_domain_browser_free(client->domain_browsers);
  while(!(client->service_browsers == ((struct AvahiServiceBrowser *)NULL)))
    avahi_service_browser_free(client->service_browsers);
  while(!(client->service_type_browsers == ((struct AvahiServiceTypeBrowser *)NULL)))
    avahi_service_type_browser_free(client->service_type_browsers);
  while(!(client->service_resolvers == ((struct AvahiServiceResolver *)NULL)))
    avahi_service_resolver_free(client->service_resolvers);
  while(!(client->host_name_resolvers == ((struct AvahiHostNameResolver *)NULL)))
    avahi_host_name_resolver_free(client->host_name_resolvers);
  while(!(client->address_resolvers == ((struct AvahiAddressResolver *)NULL)))
    avahi_address_resolver_free(client->address_resolvers);
  while(!(client->record_browsers == ((struct AvahiRecordBrowser *)NULL)))
    avahi_record_browser_free(client->record_browsers);
  if(!(client->bus == ((struct DBusConnection *)NULL)))
    dbus_connection_unref(client->bus);

  avahi_free((void *)client->version_string);
  avahi_free((void *)client->host_name);
  avahi_free((void *)client->host_name_fqdn);
  avahi_free((void *)client->domain_name);
  avahi_free((void *)client);
}

// avahi_client_get_domain_name
// file client.c line 742
const char * avahi_client_get_domain_name(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected$1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->domain_name == ((char *)NULL))
      client->domain_name=avahi_client_get_string_reply_and_block(client, "GetDomainName", (const char *)(void *)0);

    return client->domain_name;
  }
}

// avahi_client_get_host_name
// file client.c line 756
const char * avahi_client_get_host_name(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected$1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->host_name == ((char *)NULL))
      client->host_name=avahi_client_get_string_reply_and_block(client, "GetHostName", (const char *)(void *)0);

    return client->host_name;
  }
}

// avahi_client_get_host_name_fqdn
// file client.c line 770
const char * avahi_client_get_host_name_fqdn(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected$1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->host_name_fqdn == ((char *)NULL))
      client->host_name_fqdn=avahi_client_get_string_reply_and_block(client, "GetHostNameFqdn", (const char *)(void *)0);

    return client->host_name_fqdn;
  }
}

// avahi_client_get_local_service_cookie
// file client.c line 846
unsigned int avahi_client_get_local_service_cookie(struct AvahiClient *client)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  _Bool tmp_if_expr$3;
  unsigned int return_value_dbus_error_is_set$2;
  unsigned int return_value_dbus_message_get_args$4;
  _Bool tmp_if_expr$6;
  unsigned int return_value_dbus_error_is_set$5;
  if(return_value_avahi_client_is_connected$1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (unsigned int)0;
  }

  else
    if(!(client->local_service_cookie_valid == 0))
      return client->local_service_cookie;

    else
    {
      dbus_error_init(&error);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetLocalServiceCookie");
      if(message == ((struct DBusMessage *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$2=dbus_error_is_set(&error);
          tmp_if_expr$3 = return_value_dbus_error_is_set$2 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$3)
        {
          return_value_dbus_message_get_args$4=dbus_message_get_args(reply, &error, (signed int)117, &client->local_service_cookie, (signed int)0);
          if(return_value_dbus_message_get_args$4 == 0u)
            tmp_if_expr$6 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$5=dbus_error_is_set(&error);
            tmp_if_expr$6 = return_value_dbus_error_is_set$5 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr$6)
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            client->local_service_cookie_valid = 1;
            return client->local_service_cookie;
          }

        }

      }

    fail:
      ;
      if(!(message == ((struct DBusMessage *)NULL)))
        dbus_message_unref(message);

      if(!(reply == ((struct DBusMessage *)NULL)))
        dbus_message_unref(reply);

      unsigned int return_value_dbus_error_is_set$7;
      return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
      if(!(return_value_dbus_error_is_set$7 == 0u))
      {
        avahi_client_set_dbus_error(client, &error);
        dbus_error_free(&error);
      }

      return (unsigned int)0;
    }
}

// avahi_client_get_state
// file client.c line 784
enum anonymous$11 avahi_client_get_state(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  return client->state;
}

// avahi_client_get_string_reply_and_block
// file client.c line 672
static char * avahi_client_get_string_reply_and_block(struct AvahiClient *client, const char *method, const char *param)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *ret;
  char *n;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion method */
  assert(method != ((const char *)NULL));
  dbus_error_init(&error);
  message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", method);
  _Bool tmp_if_expr$3;
  unsigned int return_value_dbus_error_is_set$2;
  unsigned int return_value_dbus_message_get_args$4;
  _Bool tmp_if_expr$6;
  unsigned int return_value_dbus_error_is_set$5;
  if(message == ((struct DBusMessage *)NULL))
    avahi_client_set_errno(client, -24);

  else
  {
    if(!(param == ((const char *)NULL)))
    {
      unsigned int return_value_dbus_message_append_args$1;
      return_value_dbus_message_append_args$1=dbus_message_append_args(message, (signed int)115, &param, (signed int)0);
      if(return_value_dbus_message_append_args$1 == 0u)
      {
        avahi_client_set_errno(client, -24);
        goto fail;
      }

    }

    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$2=dbus_error_is_set(&error);
      tmp_if_expr$3 = return_value_dbus_error_is_set$2 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$3)
    {
      return_value_dbus_message_get_args$4=dbus_message_get_args(reply, &error, (signed int)115, &ret, (signed int)0);
      if(return_value_dbus_message_get_args$4 == 0u)
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$5=dbus_error_is_set(&error);
        tmp_if_expr$6 = return_value_dbus_error_is_set$5 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$6)
      {
        n=avahi_strdup(ret);
        if(n == ((char *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          dbus_message_unref(message);
          dbus_message_unref(reply);
          return n;
        }
      }

    }

  }

fail:
  ;
  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  unsigned int return_value_dbus_error_is_set$7;
  return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$7 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  return (char *)(void *)0;
}

// avahi_client_get_string_reply_and_block$link1
// file client.c line 672
static char * avahi_client_get_string_reply_and_block$link1(struct AvahiClient *client$link1, const char *method$link1, const char *param$link1)
{
  struct DBusMessage *message$link1 = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply$link1 = (struct DBusMessage *)(void *)0;
  struct DBusError error$link1;
  char *ret$link1;
  char *n$link1;
  /* assertion client */
  assert(client$link1 != ((struct AvahiClient *)NULL));
  /* assertion method */
  assert(method$link1 != ((const char *)NULL));
  dbus_error_init(&error$link1);
  message$link1=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", method$link1);
  _Bool tmp_if_expr$3$link1;
  unsigned int return_value_dbus_error_is_set$2$link1;
  unsigned int return_value_dbus_message_get_args$4$link1;
  _Bool tmp_if_expr$6$link1;
  unsigned int return_value_dbus_error_is_set$5$link1;
  if(message$link1 == ((struct DBusMessage *)NULL))
    avahi_client_set_errno(client$link1, -24);

  else
  {
    if(!(param$link1 == ((const char *)NULL)))
    {
      unsigned int return_value_dbus_message_append_args$1$link1;
      return_value_dbus_message_append_args$1$link1=dbus_message_append_args(message$link1, (signed int)115, &param$link1, (signed int)0);
      if(return_value_dbus_message_append_args$1$link1 == 0u)
      {
        avahi_client_set_errno(client$link1, -24);
        goto fail;
      }

    }

    reply$link1=dbus_connection_send_with_reply_and_block(client$link1->bus, message$link1, -1, &error$link1);
    if(reply$link1 == ((struct DBusMessage *)NULL))
      tmp_if_expr$3$link1 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$2$link1=dbus_error_is_set(&error$link1);
      tmp_if_expr$3$link1 = return_value_dbus_error_is_set$2$link1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$3$link1)
    {
      return_value_dbus_message_get_args$4$link1=dbus_message_get_args(reply$link1, &error$link1, (signed int)115, &ret$link1, (signed int)0);
      if(return_value_dbus_message_get_args$4$link1 == 0u)
        tmp_if_expr$6$link1 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$5$link1=dbus_error_is_set(&error$link1);
        tmp_if_expr$6$link1 = return_value_dbus_error_is_set$5$link1 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$6$link1)
      {
        n$link1=avahi_strdup(ret$link1);
        if(n$link1 == ((char *)NULL))
          avahi_client_set_errno(client$link1, -24);

        else
        {
          dbus_message_unref(message$link1);
          dbus_message_unref(reply$link1);
          return n$link1;
        }
      }

    }

  }

fail:
  ;
  if(!(message$link1 == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message$link1);

  if(!(reply$link1 == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply$link1);

  unsigned int return_value_dbus_error_is_set$7$link1;
  return_value_dbus_error_is_set$7$link1=dbus_error_is_set(&error$link1);
  if(!(return_value_dbus_error_is_set$7$link1 == 0u))
  {
    avahi_client_set_dbus_error(client$link1, &error$link1);
    dbus_error_free(&error$link1);
  }

  return (char *)(void *)0;
}

// avahi_client_get_version_string
// file client.c line 728
const char * avahi_client_get_version_string(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  if(return_value_avahi_client_is_connected$1 == 0)
  {
    avahi_client_set_errno(client, -2);
    return (const char *)(void *)0;
  }

  else
  {
    if(client->version_string == ((char *)NULL))
      client->version_string=avahi_client_get_string_reply_and_block(client, "GetVersionString", (const char *)(void *)0);

    return client->version_string;
  }
}

// avahi_client_is_connected
// file client.c line 896
signed int avahi_client_is_connected(struct AvahiClient *client)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  _Bool tmp_if_expr$2;
  unsigned int return_value_dbus_connection_get_is_connected$1;
  if(!(client->bus == ((struct DBusConnection *)NULL)))
  {
    return_value_dbus_connection_get_is_connected$1=dbus_connection_get_is_connected(client->bus);
    tmp_if_expr$2 = return_value_dbus_connection_get_is_connected$1 != 0u ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$2)
  {
    if((signed int)client->state == AVAHI_CLIENT_S_RUNNING)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)client->state == AVAHI_CLIENT_S_REGISTERING ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)client->state == AVAHI_CLIENT_S_COLLISION ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$5 = (_Bool)0;
  return (signed int)tmp_if_expr$5;
}

// avahi_client_new
// file client.c line 478
struct AvahiClient * avahi_client_new(const struct AvahiPoll$1 *poll_api, enum anonymous$39 flags, void (*callback)(struct AvahiClient *, enum anonymous$11, void *), void *userdata, signed int *ret_error)
{
  struct AvahiClient *client = (struct AvahiClient *)(void *)0;
  struct DBusError error;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  avahi_init_i18n();
  dbus_error_init(&error);
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal((unsigned int)1, sizeof(struct AvahiClient) /*152ul*/ );
  client = (struct AvahiClient *)return_value_avahi_new_internal$1;
  _Bool tmp_if_expr$3;
  unsigned int return_value_dbus_error_is_set$2;
  signed int return_value_avahi_dbus_connection_glue$4;
  unsigned int return_value_dbus_connection_add_filter$5;
  unsigned int return_value_dbus_error_is_set$6;
  unsigned int return_value_dbus_error_is_set$7;
  unsigned int return_value_dbus_error_is_set$8;
  _Bool tmp_if_expr$11;
  unsigned int return_value_dbus_error_is_set$10;
  if(client == ((struct AvahiClient *)NULL))
  {
    if(!(ret_error == ((signed int *)NULL)))
      *ret_error = -24;

  }

  else
  {
    client->poll_api = poll_api;
    client->error = 0;
    client->callback = callback;
    client->userdata = userdata;
    client->state = (enum anonymous$11)-1;
    client->flags = flags;
    client->host_name = (char *)(void *)0;
    client->host_name_fqdn = (char *)(void *)0;
    client->domain_name = (char *)(void *)0;
    client->version_string = (char *)(void *)0;
    client->local_service_cookie_valid = 0;
    do
      client->groups = (struct AvahiEntryGroup *)(void *)0;
    while((_Bool)0);
    do
      client->domain_browsers = (struct AvahiDomainBrowser *)(void *)0;
    while((_Bool)0);
    do
      client->service_browsers = (struct AvahiServiceBrowser *)(void *)0;
    while((_Bool)0);
    do
      client->service_type_browsers = (struct AvahiServiceTypeBrowser *)(void *)0;
    while((_Bool)0);
    do
      client->service_resolvers = (struct AvahiServiceResolver *)(void *)0;
    while((_Bool)0);
    do
      client->host_name_resolvers = (struct AvahiHostNameResolver *)(void *)0;
    while((_Bool)0);
    do
      client->address_resolvers = (struct AvahiAddressResolver *)(void *)0;
    while((_Bool)0);
    do
      client->record_browsers = (struct AvahiRecordBrowser *)(void *)0;
    while((_Bool)0);
    client->bus=avahi_dbus_bus_get(&error);
    if(client->bus == ((struct DBusConnection *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$2=dbus_error_is_set(&error);
      tmp_if_expr$3 = return_value_dbus_error_is_set$2 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
    {
      if(!(ret_error == ((signed int *)NULL)))
        *ret_error = -22;

    }

    else
    {
      return_value_avahi_dbus_connection_glue$4=avahi_dbus_connection_glue(client->bus, poll_api);
      if(!(return_value_avahi_dbus_connection_glue$4 >= 0))
      {
        if(!(ret_error == ((signed int *)NULL)))
          *ret_error = -24;

      }

      else
      {
        return_value_dbus_connection_add_filter$5=dbus_connection_add_filter(client->bus, filter_func, (void *)client, (void (*)(void *))(void *)0);
        if(return_value_dbus_connection_add_filter$5 == 0u)
        {
          if(!(ret_error == ((signed int *)NULL)))
            *ret_error = -24;

        }

        else
        {
          dbus_bus_add_match(client->bus, "type='signal', interface='org.freedesktop.Avahi.Server', sender='org.freedesktop.Avahi', path='/'", &error);
          return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
          if(return_value_dbus_error_is_set$6 == 0u)
          {
            dbus_bus_add_match(client->bus, "type='signal', interface='org.freedesktop.DBus', sender='org.freedesktop.DBus', path='/org/freedesktop/DBus'", &error);
            return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
            if(return_value_dbus_error_is_set$7 == 0u)
            {
              dbus_bus_add_match(client->bus, "type='signal', interface='org.freedesktop.DBus.Local'", &error);
              return_value_dbus_error_is_set$8=dbus_error_is_set(&error);
              if(return_value_dbus_error_is_set$8 == 0u)
              {
                message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.DBus.Peer", "Ping");
                if(!(message == ((struct DBusMessage *)NULL)))
                {
                  reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
                  if(reply == ((struct DBusMessage *)NULL))
                    tmp_if_expr$11 = (_Bool)1;

                  else
                  {
                    return_value_dbus_error_is_set$10=dbus_error_is_set(&error);
                    tmp_if_expr$11 = return_value_dbus_error_is_set$10 != 0u ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$11)
                  {
                    dbus_error_free(&error);
                    if((AVAHI_CLIENT_NO_FAIL & (signed int)flags) == 0)
                    {
                      if(!(ret_error == ((signed int *)NULL)))
                        *ret_error = -26;

                      goto fail;
                    }

                    client_set_state(client, (enum anonymous$11)AVAHI_CLIENT_CONNECTING);
                  }

                  else
                  {
                    signed int return_value_init_server$9;
                    return_value_init_server$9=init_server(client, ret_error);
                    if(!(return_value_init_server$9 >= 0))
                      goto fail;

                  }
                  dbus_message_unref(message);
                  if(!(reply == ((struct DBusMessage *)NULL)))
                    dbus_message_unref(reply);

                  return client;
                }

              }

            }

          }

        }
      }
    }
  }

fail:
  ;
  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  if(!(client == ((struct AvahiClient *)NULL)))
    avahi_client_free(client);

  unsigned int return_value_dbus_error_is_set$13;
  return_value_dbus_error_is_set$13=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$13 == 0u))
  {
    if(!(ret_error == ((signed int *)NULL)))
    {
      signed int return_value_strcmp$12;
      return_value_strcmp$12=strcmp(error.name, "org.freedesktop.DBus.Error.FileNotFound");
      if(return_value_strcmp$12 == 0)
        *ret_error = -26;

      else
        *ret_error=avahi_error_dbus_to_number(error.name);
    }

    dbus_error_free(&error);
  }

  return (struct AvahiClient *)(void *)0;
}

// avahi_client_set_dbus_error
// file client.c line 51
signed int avahi_client_set_dbus_error(struct AvahiClient *client, struct DBusError *error)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion error */
  assert(error != ((struct DBusError *)NULL));
  signed int return_value_avahi_error_dbus_to_number$1;
  return_value_avahi_error_dbus_to_number$1=avahi_error_dbus_to_number(error->name);
  signed int return_value_avahi_client_set_errno$2;
  return_value_avahi_client_set_errno$2=avahi_client_set_errno(client, return_value_avahi_error_dbus_to_number$1);
  return return_value_avahi_client_set_errno$2;
}

// avahi_client_set_errno
// file client.c line 45
signed int avahi_client_set_errno(struct AvahiClient *client, signed int error)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  client->error = error;
  return client->error;
}

// avahi_client_set_host_name
// file client.c line 905
signed int avahi_client_set_host_name(struct AvahiClient *client, const char *name)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  signed int return_value_avahi_client_is_connected$2;
  return_value_avahi_client_is_connected$2=avahi_client_is_connected(client);
  signed int return_value_avahi_client_set_errno$1;
  unsigned int return_value_dbus_message_append_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(return_value_avahi_client_is_connected$2 == 0)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "SetHostName");
    if(message == ((struct DBusMessage *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      return_value_dbus_message_append_args$3=dbus_message_append_args(message, (signed int)115, &name, (signed int)0);
      if(return_value_dbus_message_append_args$3 == 0u)
        avahi_client_set_errno(client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr$5 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
          tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(!tmp_if_expr$5)
        {
          return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args$6 == 0u)
            tmp_if_expr$8 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
            tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr$8)
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            avahi_free((void *)client->host_name);
            client->host_name = (char *)(void *)0;
            avahi_free((void *)client->host_name_fqdn);
            client->host_name_fqdn = (char *)(void *)0;
            return 0;
          }

        }

      }
    }

  fail:
    ;
    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    unsigned int return_value_dbus_error_is_set$9;
    return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$9 == 0u))
    {
      avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    return client->error;
  }
}

// avahi_client_simple_method_call
// file client.c line 797
signed int avahi_client_simple_method_call(struct AvahiClient *client, const char *path, const char *interface, const char *method)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  dbus_error_init(&error);
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion path */
  assert(path != ((const char *)NULL));
  /* assertion interface */
  assert(interface != ((const char *)NULL));
  /* assertion method */
  assert(method != ((const char *)NULL));
  message=dbus_message_new_method_call("org.freedesktop.Avahi", path, interface, method);
  _Bool tmp_if_expr$2;
  unsigned int return_value_dbus_error_is_set$1;
  unsigned int return_value_dbus_message_get_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  if(message == ((struct DBusMessage *)NULL))
    r=avahi_client_set_errno(client, -24);

  else
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$1=dbus_error_is_set(&error);
      tmp_if_expr$2 = return_value_dbus_error_is_set$1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      r=avahi_client_set_errno(client, -22);

    else
    {
      return_value_dbus_message_get_args$3=dbus_message_get_args(reply, &error, (signed int)0);
      if(return_value_dbus_message_get_args$3 == 0u)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
        tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        r=avahi_client_set_errno(client, -22);

      else
      {
        dbus_message_unref(message);
        dbus_message_unref(reply);
        return 0;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$6;
  return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$6 == 0u))
  {
    r=avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return r;
}

// avahi_dbus_bus_get
// file client.c line 445
static struct DBusConnection * avahi_dbus_bus_get(struct DBusError *error)
{
  struct DBusConnection *c;
  c=dbus_bus_get_private((enum anonymous$45)DBUS_BUS_SYSTEM, error);
  if(c == ((struct DBusConnection *)NULL))
    return (struct DBusConnection *)(void *)0;

  else
  {
    dbus_connection_set_exit_on_disconnect(c, (unsigned int)0);
    return c;
  }
}

// avahi_dbus_bus_get$link1
// file client.c line 445
static struct DBusConnection * avahi_dbus_bus_get$link1(struct DBusError *error$link1)
{
  struct DBusConnection *c$link1;
  c$link1=dbus_bus_get_private((enum anonymous$45)DBUS_BUS_SYSTEM, error$link1);
  if(c$link1 == ((struct DBusConnection *)NULL))
    return (struct DBusConnection *)(void *)0;

  else
  {
    dbus_connection_set_exit_on_disconnect(c$link1, (unsigned int)0);
    return c$link1;
  }
}

// avahi_dbus_connection_glue
// file ../avahi-common/dbus-watch-glue.h line 29
signed int avahi_dbus_connection_glue(struct DBusConnection *c, const struct AvahiPoll$1 *poll_api)
{
  struct anonymous$28 *d = (struct anonymous$28 *)(void *)0;
  /* assertion c */
  assert(c != ((struct DBusConnection *)NULL));
  /* assertion poll_api */
  assert(poll_api != ((const struct AvahiPoll$1 *)NULL));
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link4((unsigned int)1, sizeof(struct anonymous$28) /*32ul*/ );
  d = (struct anonymous$28 *)return_value_avahi_new_internal$1;
  struct anonymous$28 *return_value_connection_data_ref$2;
  unsigned int return_value_dbus_connection_set_watch_functions$3;
  struct anonymous$28 *return_value_connection_data_ref$4;
  unsigned int return_value_dbus_connection_set_timeout_functions$5;
  struct anonymous$28 *return_value_connection_data_ref$6;
  enum anonymous$27 return_value_dbus_connection_get_dispatch_status$7;
  if(!(d == ((struct anonymous$28 *)NULL)))
  {
    d->poll_api = poll_api;
    d->connection = c;
    d->ref = 1;
    d->dispatch_timeout=poll_api->timeout_new(poll_api, (struct timeval *)(void *)0, dispatch_timeout_callback, (void *)d);
    return_value_connection_data_ref$2=connection_data_ref(d);
    return_value_dbus_connection_set_watch_functions$3=dbus_connection_set_watch_functions(c, add_watch, remove_watch, watch_toggled, (void *)return_value_connection_data_ref$2, (void (*)(void *))connection_data_unref);
    return_value_connection_data_ref$4=connection_data_ref(d);
    return_value_dbus_connection_set_timeout_functions$5=dbus_connection_set_timeout_functions(c, add_timeout, remove_timeout, timeout_toggled, (void *)return_value_connection_data_ref$4, (void (*)(void *))connection_data_unref);
    return_value_connection_data_ref$6=connection_data_ref(d);
    dbus_connection_set_dispatch_status_function(c, dispatch_status, (void *)return_value_connection_data_ref$6, (void (*)(void *))connection_data_unref);
    return_value_dbus_connection_get_dispatch_status$7=dbus_connection_get_dispatch_status(c);
    if((signed int)return_value_dbus_connection_get_dispatch_status$7 == DBUS_DISPATCH_DATA_REMAINS)
      request_dispatch(d, 1);

    connection_data_unref(d);
    return 0;
  }

  else
  {

  fail:
    ;
    if(!(d == ((struct anonymous$28 *)NULL)))
    {
      d->poll_api->timeout_free(d->dispatch_timeout);
      avahi_free((void *)d);
    }

    return -1;
  }
}

// avahi_domain_browser_event
// file internal.h line 159
enum anonymous$42 avahi_domain_browser_event(struct AvahiClient *client, enum anonymous$14 event, struct DBusMessage *message)
{
  struct AvahiDomainBrowser *db = (struct AvahiDomainBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *domain = (char *)(void *)0;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  struct AvahiStringList *l;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp$1;
  unsigned int return_value_dbus_message_get_args$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  char *etxt;
  unsigned int return_value_dbus_message_get_args$5;
  _Bool tmp_if_expr$7;
  unsigned int return_value_dbus_error_is_set$6;
  signed int return_value_avahi_error_dbus_to_number$8;
  signed int return_value_avahi_domain_equal$9;
  if(!(path == ((const char *)NULL)))
  {
    db = client->domain_browsers;
    for( ; !(db == ((struct AvahiDomainBrowser *)NULL)); db = db->domain_browsers_next)
    {
      return_value_strcmp$1=strcmp(db->path, path);
      if(return_value_strcmp$1 == 0)
        break;

    }
    if(db == ((struct AvahiDomainBrowser *)NULL))
      goto fail;

    interface = db->interface;
    protocol = db->protocol;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args$2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &domain, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args$2 == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args$5=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args$5 == 0u)
          tmp_if_expr$7 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
          tmp_if_expr$7 = return_value_dbus_error_is_set$6 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$7)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number$8=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(db->client, return_value_avahi_error_dbus_to_number$8);
      }
    }
    if(!(domain == ((char *)NULL)))
    {
      l = db->static_browse_domains;
      for( ; !(l == ((struct AvahiStringList *)NULL)); l = l->next)
      {
        return_value_avahi_domain_equal$9=avahi_domain_equal((char *)l->text, domain);
        if(!(return_value_avahi_domain_equal$9 == 0))
          return (enum anonymous$42)DBUS_HANDLER_RESULT_HANDLED;

      }
    }

    db->callback(db, (signed int)interface, (signed int)protocol, event, domain, (enum anonymous$13)flags, db->userdata);
    return (enum anonymous$42)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous$42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_domain_browser_free
// file lookup.h line 71
signed int avahi_domain_browser_free(struct AvahiDomainBrowser *b)
{
  struct AvahiClient *client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  /* assertion b->ref >= 1 */
  assert(b->ref >= 1);
  b->ref = b->ref - 1;
  signed int return_value_avahi_client_is_connected$1;
  if(b->ref >= 1)
    return 0;

  else
  {
    client = b->client;
    if(!(b->path == ((char *)NULL)))
    {
      return_value_avahi_client_is_connected$1=avahi_client_is_connected(b->client);
      if(!(return_value_avahi_client_is_connected$1 == 0))
        r=avahi_client_simple_method_call(client, b->path, "org.freedesktop.Avahi.DomainBrowser", "Free");

    }

    do
    {
      struct AvahiDomainBrowser **_head = &client->domain_browsers;
      struct AvahiDomainBrowser *_item = b;
      /* assertion _item */
      assert(_item != ((struct AvahiDomainBrowser *)NULL));
      if(!(_item->domain_browsers_next == ((struct AvahiDomainBrowser *)NULL)))
        _item->domain_browsers_next->domain_browsers_prev = _item->domain_browsers_prev;

      if(!(_item->domain_browsers_prev == ((struct AvahiDomainBrowser *)NULL)))
        _item->domain_browsers_prev->domain_browsers_next = _item->domain_browsers_next;

      else
      {
        /* assertion *_head == _item */
        assert(*_head == _item);
        *_head = _item->domain_browsers_next;
      }
      _item->domain_browsers_prev = (struct AvahiDomainBrowser *)(void *)0;
      _item->domain_browsers_next = _item->domain_browsers_prev;
    }
    while((_Bool)0);
    if(!(b->defer_timeout == ((struct AvahiTimeout$1 *)NULL)))
      b->client->poll_api->timeout_free(b->defer_timeout);

    avahi_string_list_free(b->static_browse_domains);
    avahi_free((void *)b->path);
    avahi_free((void *)b);
    return r;
  }
}

// avahi_domain_browser_get_client
// file browser.c line 234
struct AvahiClient * avahi_domain_browser_get_client(struct AvahiDomainBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  return b->client;
}

// avahi_domain_browser_new
// file browser.c line 104
struct AvahiDomainBrowser * avahi_domain_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous$43 btype, enum anonymous$44 flags, void (*callback)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous$14, const char *, enum anonymous$13, void *), void *userdata)
{
  struct AvahiDomainBrowser *db = (struct AvahiDomainBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_interface;
  signed int i_protocol;
  signed int bt;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiDomainBrowser *, signed int, signed int, enum anonymous$14, const char *, enum anonymous$13, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal$2;
  unsigned int return_value_dbus_message_append_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(return_value_avahi_client_is_connected$1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    return_value_avahi_new_internal$2=avahi_new_internal$link2((unsigned int)1, sizeof(struct AvahiDomainBrowser) /*80ul*/ );
    db = (struct AvahiDomainBrowser *)return_value_avahi_new_internal$2;
    if(db == ((struct AvahiDomainBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      db->ref = 1;
      db->client = client;
      db->callback = callback;
      db->userdata = userdata;
      db->path = (char *)(void *)0;
      db->interface = interface;
      db->protocol = protocol;
      db->static_browse_domains = (struct AvahiStringList *)(void *)0;
      db->defer_timeout = (struct AvahiTimeout$1 *)(void *)0;
      do
      {
        struct AvahiDomainBrowser **_head = &client->domain_browsers;
        struct AvahiDomainBrowser *_item = db;
        /* assertion _item */
        assert(_item != ((struct AvahiDomainBrowser *)NULL));
        _item->domain_browsers_next = *_head;
        if(!(_item->domain_browsers_next == ((struct AvahiDomainBrowser *)NULL)))
          _item->domain_browsers_next->domain_browsers_prev = _item;

        _item->domain_browsers_prev = (struct AvahiDomainBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      if((AVAHI_CLIENT_IGNORE_USER_CONFIG & (signed int)client->flags) == 0)
      {
        parse_environment(db);
        parse_domain_file(db);
      }

      db->static_browse_domains=avahi_string_list_reverse(db->static_browse_domains);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "DomainBrowserNew");
      if(message == ((struct DBusMessage *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        i_interface = (signed int)interface;
        i_protocol = (signed int)protocol;
        u_flags = (unsigned int)flags;
        bt = (signed int)btype;
        return_value_dbus_message_append_args$3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &domain, (signed int)105, &bt, (signed int)117, &u_flags, (signed int)0);
        if(return_value_dbus_message_append_args$3 == 0u)
          avahi_client_set_errno(client, -24);

        else
        {
          reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
          if(reply == ((struct DBusMessage *)NULL))
            tmp_if_expr$5 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
            tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$5)
            avahi_client_set_errno(client, -22);

          else
          {
            return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
            if(return_value_dbus_message_get_args$6 == 0u)
              tmp_if_expr$8 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
              tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(path == ((char *)NULL) || tmp_if_expr$8)
              avahi_client_set_errno(client, -22);

            else
            {
              db->path=avahi_strdup(path);
              if(db->path == ((char *)NULL))
                avahi_client_set_errno(client, -24);

              else
              {
                if(!(db->static_browse_domains == ((struct AvahiStringList *)NULL)))
                {
                  if((signed int)btype == AVAHI_DOMAIN_BROWSER_BROWSE)
                  {
                    struct timeval tv = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
                    db->defer_timeout=client->poll_api->timeout_new(client->poll_api, &tv, defer_timeout_callback, (void *)db);
                    if(db->defer_timeout == ((struct AvahiTimeout$1 *)NULL))
                      avahi_client_set_errno(client, -24);

                  }

                }

                dbus_message_unref(message);
                dbus_message_unref(reply);
                return db;
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$9;
  return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(db == ((struct AvahiDomainBrowser *)NULL)))
    avahi_domain_browser_free(db);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiDomainBrowser *)(void *)0;
}

// avahi_domain_equal
// file ../avahi-common/domain.h line 62
signed int avahi_domain_equal(const char *a, const char *b)
{
  /* assertion a */
  assert(a != ((const char *)NULL));
  /* assertion b */
  assert(b != ((const char *)NULL));
  if(a == b)
    return 1;

  else
  {
    do
    {
      char ca[64l];
      char cb[64l];
      char *r;
      r=avahi_unescape_label(&a, ca, sizeof(char [64l]) /*64ul*/ );
      /* assertion r */
      assert(r != ((char *)NULL));
      r=avahi_unescape_label(&b, cb, sizeof(char [64l]) /*64ul*/ );
      /* assertion r */
      assert(r != ((char *)NULL));
      signed int return_value_strcasecmp$1;
      return_value_strcasecmp$1=strcasecmp(ca, cb);
      if(!(return_value_strcasecmp$1 == 0))
        return 0;

      if(*a == 0)
      {
        if(*b == 0)
          return 1;

      }

    }
    while((_Bool)1);
    return 1;
  }
}

// avahi_domain_hash
// file domain.c line 424
unsigned int avahi_domain_hash(const char *s)
{
  unsigned int hash = (unsigned int)0;
  signed int return_value_tolower$1;
  while(!(*s == 0))
  {
    char c[64l];
    char *p;
    char *r;
    r=avahi_unescape_label(&s, c, sizeof(char [64l]) /*64ul*/ );
    /* assertion r */
    assert(r != ((char *)NULL));
    p = c;
    for( ; !(*p == 0); p = p + 1l)
    {
      return_value_tolower$1=tolower((signed int)*p);
      hash = (unsigned int)31 * hash + (unsigned int)return_value_tolower$1;
    }
  }
  return hash;
}

// avahi_elapse_time
// file ../avahi-common/timeval.h line 50
struct timeval * avahi_elapse_time(struct timeval *tv, unsigned int msec, unsigned int jitter)
{
  /* assertion tv */
  assert(tv != ((struct timeval *)NULL));
  gettimeofday(tv, (struct timezone *)(void *)0);
  if(!(msec == 0u))
    avahi_timeval_add(tv, (signed long int)msec * (signed long int)1000);

  if(!(jitter == 0u))
  {
    signed long int now;
    signed int r;
    now=time((signed long int *)(void *)0);
    static union anonymous$6 mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
    pthread_mutex_lock(&mutex);
    static signed int last_rand;
    static signed long int timestamp = (signed long int)0;
    if(now >= 10l + timestamp)
    {
      timestamp = now;
      last_rand=rand();
    }

    r = last_rand;
    pthread_mutex_unlock(&mutex);
    avahi_timeval_add(tv, (signed long int)(((double)jitter * 1000.0 * (double)r) / ((double)2147483647 + 1.0)));
  }

  return tv;
}

// avahi_entry_group_add_address
// file entrygroup.c line 721
signed int avahi_entry_group_add_address(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$41 flags, const char *name, const struct AvahiAddress *a)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  char s_address[40l];
  char *p_address = s_address;
  /* assertion name */
  assert(name != ((const char *)NULL));
  client = group->client;
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  char *return_value_avahi_address_snprint$4;
  unsigned int return_value_dbus_message_append_args$5;
  _Bool tmp_if_expr$7;
  unsigned int return_value_dbus_error_is_set$6;
  unsigned int return_value_dbus_message_get_args$8;
  _Bool tmp_if_expr$10;
  unsigned int return_value_dbus_error_is_set$9;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddAddress");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_avahi_address_snprint$4=avahi_address_snprint(s_address, sizeof(char [40l]) /*40ul*/ , a);
      if(return_value_avahi_address_snprint$4 == ((char *)NULL))
        r=avahi_client_set_errno(client, -14);

      else
      {
        return_value_dbus_message_append_args$5=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &p_address, (signed int)0);
        if(return_value_dbus_message_append_args$5 == 0u)
          r=avahi_client_set_errno(group->client, -24);

        else
        {
          reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
          if(reply == ((struct DBusMessage *)NULL))
            tmp_if_expr$7 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
            tmp_if_expr$7 = return_value_dbus_error_is_set$6 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$7)
            r=avahi_client_set_errno(client, -22);

          else
          {
            return_value_dbus_message_get_args$8=dbus_message_get_args(reply, &error, (signed int)0);
            if(return_value_dbus_message_get_args$8 == 0u)
              tmp_if_expr$10 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
              tmp_if_expr$10 = return_value_dbus_error_is_set$9 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$10)
              r=avahi_client_set_errno(client, -22);

            else
            {
              dbus_message_unref(message);
              dbus_message_unref(reply);
              return 0;
            }
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$11;
    return_value_dbus_error_is_set$11=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$11 == 0u))
    {
      r=avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_add_record
// file entrygroup.c line 808
signed int avahi_entry_group_add_record(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$41 flags, const char *name, unsigned short int clazz, unsigned short int type, unsigned int ttl, const void *rdata, unsigned long int size)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion name */
  assert(name != ((const char *)NULL));
  client = group->client;
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  unsigned int return_value_dbus_message_append_args$4;
  _Bool tmp_if_expr$6;
  signed int return_value_append_rdata$5;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  unsigned int return_value_dbus_message_get_args$9;
  _Bool tmp_if_expr$11;
  unsigned int return_value_dbus_error_is_set$10;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddRecord");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args$4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)113, &clazz, (signed int)113, &type, (signed int)117, &ttl, (signed int)0);
      if(return_value_dbus_message_append_args$4 == 0u)
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        return_value_append_rdata$5=append_rdata(message, rdata, size);
        tmp_if_expr$6 = return_value_append_rdata$5 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$6)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
          tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
          r=avahi_client_set_errno(client, -22);

        else
        {
          return_value_dbus_message_get_args$9=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args$9 == 0u)
            tmp_if_expr$11 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$10=dbus_error_is_set(&error);
            tmp_if_expr$11 = return_value_dbus_error_is_set$10 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$11)
            r=avahi_client_set_errno(client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$12;
    return_value_dbus_error_is_set$12=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$12 == 0u))
    {
      r=avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_add_service
// file entrygroup.c line 496
signed int avahi_entry_group_add_service(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$41 flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, ...)
{
  void **va;
  signed int r;
  struct AvahiStringList *txt;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  va = (void **)&port;
  txt=avahi_string_list_new_va(va);
  r=avahi_entry_group_add_service_strlst(group, interface, protocol, flags, name, type, domain, host, port, txt);
  avahi_string_list_free(txt);
  va = ((void **)NULL);
  return r;
}

// avahi_entry_group_add_service_strlst
// file entrygroup.c line 402
signed int avahi_entry_group_add_service_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$41 flags, const char *name, const char *type, const char *domain, const char *host, unsigned short int port, struct AvahiStringList *txt)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  client = group->client;
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  unsigned int return_value_dbus_message_append_args$4;
  _Bool tmp_if_expr$6;
  signed int return_value_append_string_list$5;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  unsigned int return_value_dbus_message_get_args$9;
  _Bool tmp_if_expr$11;
  unsigned int return_value_dbus_error_is_set$10;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    if(host == ((const char *)NULL))
      host = "";

    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddService");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args$4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)115, &host, (signed int)113, &port, (signed int)0);
      if(return_value_dbus_message_append_args$4 == 0u)
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        return_value_append_string_list$5=append_string_list(message, txt);
        tmp_if_expr$6 = return_value_append_string_list$5 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$6)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
          tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
          r=avahi_client_set_errno(client, -22);

        else
        {
          return_value_dbus_message_get_args$9=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args$9 == 0u)
            tmp_if_expr$11 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$10=dbus_error_is_set(&error);
            tmp_if_expr$11 = return_value_dbus_error_is_set$10 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$11)
            r=avahi_client_set_errno(client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$12;
    return_value_dbus_error_is_set$12=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$12 == 0u))
    {
      r=avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_add_service_subtype
// file entrygroup.c line 522
signed int avahi_entry_group_add_service_subtype(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$41 flags, const char *name, const char *type, const char *domain, const char *subtype)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  /* assertion subtype */
  assert(subtype != ((const char *)NULL));
  client = group->client;
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  unsigned int return_value_dbus_message_append_args$4;
  _Bool tmp_if_expr$6;
  unsigned int return_value_dbus_error_is_set$5;
  unsigned int return_value_dbus_message_get_args$7;
  _Bool tmp_if_expr$9;
  unsigned int return_value_dbus_error_is_set$8;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "AddServiceSubtype");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args$4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)115, &subtype, (signed int)0);
      if(return_value_dbus_message_append_args$4 == 0u)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr$6 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$5=dbus_error_is_set(&error);
          tmp_if_expr$6 = return_value_dbus_error_is_set$5 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$6)
          r=avahi_client_set_errno(client, -22);

        else
        {
          return_value_dbus_message_get_args$7=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args$7 == 0u)
            tmp_if_expr$9 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$8=dbus_error_is_set(&error);
            tmp_if_expr$9 = return_value_dbus_error_is_set$8 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$9)
            r=avahi_client_set_errno(client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$10;
    return_value_dbus_error_is_set$10=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$10 == 0u))
    {
      r=avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_commit
// file entrygroup.c line 253
signed int avahi_entry_group_commit(struct AvahiEntryGroup *group)
{
  signed int ret;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    ret=entry_group_simple_method_call(group, "Commit");
    if(!(ret >= 0))
      return ret;

    else
    {
      group->state_valid = 0;
      return ret;
    }
  }
}

// avahi_entry_group_free
// file publish.h line 60
signed int avahi_entry_group_free(struct AvahiEntryGroup *group)
{
  struct AvahiClient *client = group->client;
  signed int r = 0;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  signed int return_value_avahi_client_is_connected$1;
  if(!(group->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
    if(!(return_value_avahi_client_is_connected$1 == 0))
      r=entry_group_simple_method_call(group, "Free");

  }

  do
  {
    struct AvahiEntryGroup **_head = &client->groups;
    struct AvahiEntryGroup *_item = group;
    /* assertion _item */
    assert(_item != ((struct AvahiEntryGroup *)NULL));
    if(!(_item->groups_next == ((struct AvahiEntryGroup *)NULL)))
      _item->groups_next->groups_prev = _item->groups_prev;

    if(!(_item->groups_prev == ((struct AvahiEntryGroup *)NULL)))
      _item->groups_prev->groups_next = _item->groups_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->groups_next;
    }
    _item->groups_prev = (struct AvahiEntryGroup *)(void *)0;
    _item->groups_next = _item->groups_prev;
  }
  while((_Bool)0);
  avahi_free((void *)group->path);
  avahi_free((void *)group);
  return r;
}

// avahi_entry_group_get_client
// file entrygroup.c line 290
struct AvahiClient * avahi_entry_group_get_client(struct AvahiEntryGroup *group)
{
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  return group->client;
}

// avahi_entry_group_get_state
// file entrygroup.c line 281
signed int avahi_entry_group_get_state(struct AvahiEntryGroup *group)
{
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  if(!(group->state_valid == 0))
    return (signed int)group->state;

  else
  {
    signed int return_value_retrieve_state$1;
    return_value_retrieve_state$1=retrieve_state(group);
    return return_value_retrieve_state$1;
  }
}

// avahi_entry_group_is_empty
// file entrygroup.c line 296
signed int avahi_entry_group_is_empty(struct AvahiEntryGroup *group)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  signed int b;
  struct AvahiClient *client;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  client = group->client;
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "IsEmpty");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(client, -24);

    else
    {
      reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
      if(reply == ((struct DBusMessage *)NULL))
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
        tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        r=avahi_client_set_errno(client, -22);

      else
      {
        return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)98, &b, (signed int)0);
        if(return_value_dbus_message_get_args$6 == 0u)
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
          tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
          r=avahi_client_set_errno(client, -22);

        else
        {
          dbus_message_unref(message);
          dbus_message_unref(reply);
          return (signed int)!(!(b != 0));
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$9;
    return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$9 == 0u))
    {
      r=avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_entry_group_new
// file entrygroup.c line 101
struct AvahiEntryGroup * avahi_entry_group_new(struct AvahiClient *client, void (*callback)(struct AvahiEntryGroup *, enum anonymous$40, void *), void *userdata)
{
  struct AvahiEntryGroup *group = (struct AvahiEntryGroup *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int state;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  unsigned int return_value_dbus_message_get_args$5;
  _Bool tmp_if_expr$7;
  unsigned int return_value_dbus_error_is_set$6;
  if(return_value_avahi_client_is_connected$1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal$2=avahi_new_internal$link1((unsigned int)1, sizeof(struct AvahiEntryGroup) /*56ul*/ );
    group = (struct AvahiEntryGroup *)return_value_avahi_new_internal$2;
    if(group == ((struct AvahiEntryGroup *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      group->client = client;
      group->callback = callback;
      group->userdata = userdata;
      group->state_valid = 0;
      group->path = (char *)(void *)0;
      do
      {
        struct AvahiEntryGroup **_head = &client->groups;
        struct AvahiEntryGroup *_item = group;
        /* assertion _item */
        assert(_item != ((struct AvahiEntryGroup *)NULL));
        _item->groups_next = *_head;
        if(!(_item->groups_next == ((struct AvahiEntryGroup *)NULL)))
          _item->groups_next->groups_prev = _item;

        _item->groups_prev = (struct AvahiEntryGroup *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "EntryGroupNew");
      if(message == ((struct DBusMessage *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
          avahi_client_set_errno(client, -22);

        else
        {
          return_value_dbus_message_get_args$5=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
          if(return_value_dbus_message_get_args$5 == 0u)
            tmp_if_expr$7 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
            tmp_if_expr$7 = return_value_dbus_error_is_set$6 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$7)
            avahi_client_set_errno(client, -22);

          else
          {
            group->path=avahi_strdup(path);
            if(group->path == ((char *)NULL))
              avahi_client_set_errno(client, -24);

            else
            {
              state=retrieve_state(group);
              if(!(state >= 0))
                avahi_client_set_errno(client, state);

              else
              {
                avahi_entry_group_set_state(group, (enum anonymous$40)state);
                dbus_message_unref(message);
                dbus_message_unref(reply);
                return group;
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$8;
  return_value_dbus_error_is_set$8=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$8 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(group == ((struct AvahiEntryGroup *)NULL)))
    avahi_entry_group_free(group);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiEntryGroup *)(void *)0;
}

// avahi_entry_group_reset
// file entrygroup.c line 267
signed int avahi_entry_group_reset(struct AvahiEntryGroup *group)
{
  signed int ret;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    ret=entry_group_simple_method_call(group, "Reset");
    if(!(ret >= 0))
      return ret;

    else
    {
      group->state_valid = 0;
      return ret;
    }
  }
}

// avahi_entry_group_set_state
// file internal.h line 157
void avahi_entry_group_set_state(struct AvahiEntryGroup *group, enum anonymous$40 state)
{
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  if(!(group->state_valid == 0))
  {
    if(group->state == state)
      goto __CPROVER_DUMP_L2;

  }

  group->state = state;
  group->state_valid = 1;
  if(!(group->callback == ((void (*)(struct AvahiEntryGroup *, enum anonymous$40, void *))NULL)))
    group->callback(group, state, group->userdata);


__CPROVER_DUMP_L2:
  ;
}

// avahi_entry_group_update_service_txt
// file entrygroup.c line 611
signed int avahi_entry_group_update_service_txt(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$41 flags, const char *name, const char *type, const char *domain, ...)
{
  void **va;
  signed int r;
  struct AvahiStringList *txt;
  va = (void **)&domain;
  txt=avahi_string_list_new_va(va);
  r=avahi_entry_group_update_service_txt_strlst(group, interface, protocol, flags, name, type, domain, txt);
  avahi_string_list_free(txt);
  va = ((void **)NULL);
  return r;
}

// avahi_entry_group_update_service_txt_strlst
// file entrygroup.c line 633
signed int avahi_entry_group_update_service_txt_strlst(struct AvahiEntryGroup *group, signed int interface, signed int protocol, enum anonymous$41 flags, const char *name, const char *type, const char *domain, struct AvahiStringList *txt)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int r = 0;
  struct DBusError error;
  struct AvahiClient *client;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  client = group->client;
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_client_is_connected$2;
  if(group->path == ((char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_avahi_client_is_connected$2=avahi_client_is_connected(group->client);
    tmp_if_expr$3 = !(return_value_avahi_client_is_connected$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_avahi_client_set_errno$1;
  unsigned int return_value_dbus_message_append_args$4;
  _Bool tmp_if_expr$6;
  signed int return_value_append_string_list$5;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  unsigned int return_value_dbus_message_get_args$9;
  _Bool tmp_if_expr$11;
  unsigned int return_value_dbus_error_is_set$10;
  if(tmp_if_expr$3)
  {
    return_value_avahi_client_set_errno$1=avahi_client_set_errno(group->client, -2);
    return return_value_avahi_client_set_errno$1;
  }

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    dbus_error_init(&error);
    message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "UpdateServiceTxt");
    if(message == ((struct DBusMessage *)NULL))
      r=avahi_client_set_errno(client, -24);

    else
    {
      i_interface = (signed int)interface;
      i_protocol = (signed int)protocol;
      u_flags = (unsigned int)flags;
      return_value_dbus_message_append_args$4=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)117, &u_flags, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)0);
      if(return_value_dbus_message_append_args$4 == 0u)
        tmp_if_expr$6 = (_Bool)1;

      else
      {
        return_value_append_string_list$5=append_string_list(message, txt);
        tmp_if_expr$6 = return_value_append_string_list$5 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$6)
        r=avahi_client_set_errno(group->client, -24);

      else
      {
        reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
        if(reply == ((struct DBusMessage *)NULL))
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
          tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
          r=avahi_client_set_errno(client, -22);

        else
        {
          return_value_dbus_message_get_args$9=dbus_message_get_args(reply, &error, (signed int)0);
          if(return_value_dbus_message_get_args$9 == 0u)
            tmp_if_expr$11 = (_Bool)1;

          else
          {
            return_value_dbus_error_is_set$10=dbus_error_is_set(&error);
            tmp_if_expr$11 = return_value_dbus_error_is_set$10 != 0u ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$11)
            r=avahi_client_set_errno(client, -22);

          else
          {
            dbus_message_unref(message);
            dbus_message_unref(reply);
            return 0;
          }
        }
      }
    }

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$12;
    return_value_dbus_error_is_set$12=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$12 == 0u))
    {
      r=avahi_client_set_dbus_error(client, &error);
      dbus_error_free(&error);
    }

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return r;
  }
}

// avahi_error_dbus_to_number
// file ../avahi-common/dbus.h line 112
signed int avahi_error_dbus_to_number(const char *s)
{
  signed int e;
  struct error_map *m;
  /* assertion s */
  assert(s != ((const char *)NULL));
  e = -1;
  signed int return_value_strcmp$1;
  for( ; e >= -53; e = e - 1)
  {
    return_value_strcmp$1=strcmp(s, table[(signed long int)-e]);
    if(return_value_strcmp$1 == 0)
      return e;

  }
  m = error_map;
  signed int return_value_strcmp$2;
  for( ; !(m->dbus_error == ((const char *)NULL)); m = m + 1l)
  {
    return_value_strcmp$2=strcmp(m->dbus_error, s);
    if(return_value_strcmp$2 == 0)
      return m->avahi_error;

  }
  return -22;
}

// avahi_error_number_to_dbus
// file ../avahi-common/dbus.c line 133
const char * avahi_error_number_to_dbus(signed int error)
{
  /* assertion error > AVAHI_ERR_MAX */
  assert(error > -54);
  /* assertion error < 1 */
  assert(error < 1);
  return table[(signed long int)-error];
}

// avahi_escape_label
// file domain.c line 116
char * avahi_escape_label(const char *src, unsigned long int src_length, char **ret_name, unsigned long int *ret_size)
{
  char *r;
  /* assertion src */
  assert(src != ((const char *)NULL));
  /* assertion ret_name */
  assert(ret_name != ((char **)NULL));
  /* assertion *ret_name */
  assert(*ret_name != ((char *)NULL));
  /* assertion ret_size */
  assert(ret_size != ((unsigned long int *)NULL));
  /* assertion *ret_size > 0 */
  assert(*ret_size > (unsigned long int)0);
  r = *ret_name;
  _Bool tmp_if_expr$15;
  char *tmp_post$1;
  char *tmp_post$2;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$13;
  char *tmp_post$3;
  char *tmp_post$4;
  char *tmp_post$5;
  char *tmp_post$6;
  char *tmp_post$7;
  for( ; src_length >= 1ul; src = src + 1l)
  {
    if((signed int)*src == 46)
      tmp_if_expr$15 = (_Bool)1;

    else
      tmp_if_expr$15 = (signed int)*src == 92 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$15)
    {
      if(!(*ret_size >= 3ul))
        return (char *)(void *)0;

      tmp_post$1 = *ret_name;
      *ret_name = *ret_name + 1l;
      *tmp_post$1 = (char)92;
      tmp_post$2 = *ret_name;
      *ret_name = *ret_name + 1l;
      *tmp_post$2 = *src;
      *ret_size = *ret_size - (unsigned long int)2;
    }

    else
    {
      if((signed int)*src == 95)
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = (signed int)*src == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
        tmp_if_expr$10 = (_Bool)1;

      else
      {
        if((signed int)*src >= 48)
          tmp_if_expr$9 = (signed int)*src <= 57 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$9 = (_Bool)0;
        tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$10)
        tmp_if_expr$12 = (_Bool)1;

      else
      {
        if((signed int)*src >= 97)
          tmp_if_expr$11 = (signed int)*src <= 122 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$11 = (_Bool)0;
        tmp_if_expr$12 = tmp_if_expr$11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$12)
        tmp_if_expr$14 = (_Bool)1;

      else
      {
        if((signed int)*src >= 65)
          tmp_if_expr$13 = (signed int)*src <= 90 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$13 = (_Bool)0;
        tmp_if_expr$14 = tmp_if_expr$13 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$14)
      {
        if(!(*ret_size >= 2ul))
          return (char *)(void *)0;

        tmp_post$3 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post$3 = *src;
        *ret_size = *ret_size - 1ul;
      }

      else
      {
        if(!(*ret_size >= 5ul))
          return (char *)(void *)0;

        tmp_post$4 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post$4 = (char)92;
        tmp_post$5 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post$5 = (char)(48 + (signed int)(char)((signed int)(unsigned char)*src / 100));
        tmp_post$6 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post$6 = (char)(48 + (signed int)(char)(((signed int)(unsigned char)*src / 10) % 10));
        tmp_post$7 = *ret_name;
        *ret_name = *ret_name + 1l;
        *tmp_post$7 = (char)(48 + (signed int)(char)((signed int)(unsigned char)*src % 10));
        *ret_size = *ret_size - (unsigned long int)4;
      }
    }
    src_length = src_length - 1ul;
  }
  *(*ret_name) = (char)0;
  return r;
}

// avahi_free
// file ../avahi-common/malloc.h line 42
void avahi_free(void *p)
{
  if(!(p == NULL))
  {
    if(allocator == ((const struct AvahiAllocator *)NULL))
      free(p);

    else
    {
      /* assertion allocator->free */
      assert(allocator->free != ((void (*)(void *))NULL));
      allocator->free(p);
    }
  }

}

// avahi_get_type_from_subtype
// file domain.c line 306
const char * avahi_get_type_from_subtype(const char *t)
{
  char label[64l];
  const char *ret;
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  _Bool tmp_if_expr$2;
  if(return_value_strlen$1 >= 1014ul)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$10;
  signed int return_value_strcasecmp$12;
  if(tmp_if_expr$2)
    return (const char *)(void *)0;

  else
  {
    char *return_value_avahi_unescape_label$3;
    return_value_avahi_unescape_label$3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label$3 == ((char *)NULL))
      return (const char *)(void *)0;

    else
    {
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(label);
      if(!(return_value_strlen$4 >= 3ul))
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        return (const char *)(void *)0;

      else
        if(*t == 0)
          return (const char *)(void *)0;

        else
        {
          char *return_value_avahi_unescape_label$6;
          return_value_avahi_unescape_label$6=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
          if(return_value_avahi_unescape_label$6 == ((char *)NULL))
            return (const char *)(void *)0;

          else
          {
            signed int return_value_strcasecmp$7;
            return_value_strcasecmp$7=strcasecmp(label, "_sub");
            if(!(return_value_strcasecmp$7 == 0))
              return (const char *)(void *)0;

            else
              if(*t == 0)
                return (const char *)(void *)0;

              else
              {
                ret = t;
                char *return_value_avahi_unescape_label$8;
                return_value_avahi_unescape_label$8=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
                if(return_value_avahi_unescape_label$8 == ((char *)NULL))
                  return (const char *)(void *)0;

                else
                {
                  unsigned long int return_value_strlen$9;
                  return_value_strlen$9=strlen(label);
                  if(!(return_value_strlen$9 >= 3ul))
                    tmp_if_expr$10 = (_Bool)1;

                  else
                    tmp_if_expr$10 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr$10)
                    return (const char *)(void *)0;

                  else
                    if(*t == 0)
                      return (const char *)(void *)0;

                    else
                    {
                      char *return_value_avahi_unescape_label$11;
                      return_value_avahi_unescape_label$11=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
                      if(return_value_avahi_unescape_label$11 == ((char *)NULL))
                        return (const char *)(void *)0;

                      else
                      {
                        signed int return_value_strcasecmp$13;
                        return_value_strcasecmp$13=strcasecmp(label, "_tcp");
                        if(!(return_value_strcasecmp$13 == 0))
                        {
                          return_value_strcasecmp$12=strcasecmp(label, "_udp");
                          if(return_value_strcasecmp$12 == 0)
                            goto __CPROVER_DUMP_L18;

                          return (const char *)(void *)0;
                        }

                        else
                        {

                        __CPROVER_DUMP_L18:
                          ;
                          if(!(*t == 0))
                            return (const char *)(void *)0;

                          else
                            return ret;
                        }
                      }
                    }
                }
              }
          }
        }
    }
  }
}

// avahi_glib_allocator
// file glib-malloc.c line 41
const struct AvahiAllocator * avahi_glib_allocator(void)
{
  static struct AvahiAllocator avahi_glib_allocator$$1$$allocator;
  static signed int allocator_initialized = 0;
  if(allocator_initialized == 0)
  {
    avahi_glib_allocator$$1$$allocator.malloc = malloc_glue;
    avahi_glib_allocator$$1$$allocator.free = g_free;
    avahi_glib_allocator$$1$$allocator.realloc = realloc_glue;
    avahi_glib_allocator$$1$$allocator.calloc = calloc_glue;
    allocator_initialized = 1;
  }

  return &avahi_glib_allocator$$1$$allocator;
}

// avahi_glib_poll_free
// file glib-watch.c line 386
void avahi_glib_poll_free(struct AvahiGLibPoll *g)
{
  struct _GSource *s = &g->source;
  /* assertion g */
  assert(g != ((struct AvahiGLibPoll *)NULL));
  cleanup_watches$link2(g, 1);
  cleanup_timeouts$link2(g, 1);
  g_main_context_unref(g->context);
  g_source_destroy(s);
  g_source_unref(s);
}

// avahi_glib_poll_get
// file glib-watch.c line 398
const struct AvahiPoll * avahi_glib_poll_get(struct AvahiGLibPoll *g)
{
  /* assertion g */
  assert(g != ((struct AvahiGLibPoll *)NULL));
  return &g->api;
}

// avahi_glib_poll_new
// file glib-watch.c line 347
struct AvahiGLibPoll * avahi_glib_poll_new(struct _GMainContext *context, signed int priority)
{
  struct AvahiGLibPoll *g;
  struct _GSource *return_value_g_source_new$1;
  static struct _GSourceFuncs source_funcs = { .prepare=prepare_func, .check=check_func, .dispatch=dispatch_func,
    .finalize=(void (*)(struct _GSource *))(void *)0, .closure_callback=(signed int (*)(void *))(void *)0,
    .closure_marshal=(void (*)(void))(void *)0 };
  return_value_g_source_new$1=g_source_new(&source_funcs, (unsigned int)sizeof(struct AvahiGLibPoll) /*192ul*/ );
  g = (struct AvahiGLibPoll *)return_value_g_source_new$1;
  struct _GMainContext *tmp_if_expr$3;
  struct _GMainContext *return_value_g_main_context_default$2;
  if(!(context == ((struct _GMainContext *)NULL)))
    tmp_if_expr$3 = context;

  else
  {
    return_value_g_main_context_default$2=g_main_context_default();
    tmp_if_expr$3 = return_value_g_main_context_default$2;
  }
  g->context = tmp_if_expr$3;
  g_main_context_ref(g->context);
  g->api.userdata = (void *)g;
  g->api.watch_new = watch_new$link2;
  g->api.watch_free = watch_free$link2;
  g->api.watch_update = watch_update$link2;
  g->api.watch_get_events = watch_get_events$link2;
  g->api.timeout_new = timeout_new$link2;
  g->api.timeout_free = timeout_free$link2;
  g->api.timeout_update = timeout_update$link2;
  g->watch_req_cleanup = 0;
  g->timeout_req_cleanup = 0;
  do
    g->watches = (struct AvahiWatch$0 *)(void *)0;
  while((_Bool)0);
  do
    g->timeouts = (struct AvahiTimeout *)(void *)0;
  while((_Bool)0);
  g_source_attach(&g->source, g->context);
  g_source_set_priority(&g->source, priority);
  g_source_set_can_recurse(&g->source, 0);
  return g;
}

// avahi_host_name_resolver_event
// file internal.h line 165
enum anonymous$42 avahi_host_name_resolver_event(struct AvahiClient *client, enum anonymous$12 event, struct DBusMessage *message)
{
  struct AvahiHostNameResolver *r = (struct AvahiHostNameResolver *)(void *)0;
  struct DBusError error;
  const char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp$1;
  signed int interface;
  signed int protocol;
  signed int aprotocol;
  unsigned int flags;
  char *name;
  char *address;
  struct AvahiAddress a;
  unsigned int return_value_dbus_message_get_args$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  struct AvahiAddress *return_value_avahi_address_parse$5;
  char *etxt;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  signed int return_value_avahi_error_dbus_to_number$9;
  if(!(path == ((const char *)NULL)))
  {
    r = client->host_name_resolvers;
    for( ; !(r == ((struct AvahiHostNameResolver *)NULL)); r = r->host_name_resolvers_next)
    {
      return_value_strcmp$1=strcmp(r->path, path);
      if(return_value_strcmp$1 == 0)
        break;

    }
    if(r == ((struct AvahiHostNameResolver *)NULL))
      goto fail;

    switch((signed int)event)
    {
      case AVAHI_RESOLVER_FOUND:
      {
        return_value_dbus_message_get_args$2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)105, &aprotocol, (signed int)115, &address, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args$2 == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        /* assertion address */
        assert(address != ((char *)NULL));
        return_value_avahi_address_parse$5=avahi_address_parse(address, (signed int)aprotocol, &a);
        if(return_value_avahi_address_parse$5 == ((struct AvahiAddress *)NULL))
        {
          fprintf(stderr, "Failed to parse address\n");
          goto fail;
        }

        r->callback(r, (signed int)interface, (signed int)protocol, (enum anonymous$12)AVAHI_RESOLVER_FOUND, name, &a, (enum anonymous$13)flags, r->userdata);
      }
      case AVAHI_RESOLVER_FAILURE:
      {
        return_value_dbus_message_get_args$6=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args$6 == 0u)
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
          tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number$9=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(r->client, return_value_avahi_error_dbus_to_number$9);
        r->callback(r, r->interface, r->protocol, event, r->host_name, (const struct AvahiAddress *)(void *)0, (enum anonymous$13)0, r->userdata);
      }
    }
    return (enum anonymous$42)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous$42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_host_name_resolver_free
// file lookup.h line 239
signed int avahi_host_name_resolver_free(struct AvahiHostNameResolver *r)
{
  signed int ret = 0;
  struct AvahiClient *client;
  /* assertion r */
  assert(r != ((struct AvahiHostNameResolver *)NULL));
  client = r->client;
  signed int return_value_avahi_client_is_connected$1;
  if(!(r->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
    if(!(return_value_avahi_client_is_connected$1 == 0))
      ret=avahi_client_simple_method_call(client, r->path, "org.freedesktop.Avahi.HostNameResolver", "Free");

  }

  do
  {
    struct AvahiHostNameResolver **_head = &client->host_name_resolvers;
    struct AvahiHostNameResolver *_item = r;
    /* assertion _item */
    assert(_item != ((struct AvahiHostNameResolver *)NULL));
    if(!(_item->host_name_resolvers_next == ((struct AvahiHostNameResolver *)NULL)))
      _item->host_name_resolvers_next->host_name_resolvers_prev = _item->host_name_resolvers_prev;

    if(!(_item->host_name_resolvers_prev == ((struct AvahiHostNameResolver *)NULL)))
      _item->host_name_resolvers_prev->host_name_resolvers_next = _item->host_name_resolvers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->host_name_resolvers_next;
    }
    _item->host_name_resolvers_prev = (struct AvahiHostNameResolver *)(void *)0;
    _item->host_name_resolvers_next = _item->host_name_resolvers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)r->path);
  avahi_free((void *)r->host_name);
  avahi_free((void *)r);
  return ret;
}

// avahi_host_name_resolver_get_client
// file resolver.c line 558
struct AvahiClient * avahi_host_name_resolver_get_client(struct AvahiHostNameResolver *r)
{
  /* assertion r */
  assert(r != ((struct AvahiHostNameResolver *)NULL));
  return r->client;
}

// avahi_host_name_resolver_new
// file resolver.c line 424
struct AvahiHostNameResolver * avahi_host_name_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, signed int aprotocol, enum anonymous$44 flags, void (*callback)(struct AvahiHostNameResolver *, signed int, signed int, enum anonymous$12, const char *, const struct AvahiAddress *, enum anonymous$13, void *), void *userdata)
{
  struct DBusError error;
  struct AvahiHostNameResolver *r = (struct AvahiHostNameResolver *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int i_interface;
  signed int i_protocol;
  signed int i_aprotocol;
  unsigned int u_flags;
  char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal$2;
  unsigned int return_value_dbus_message_append_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(return_value_avahi_client_is_connected$1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal$2=avahi_new_internal$link3((unsigned int)1, sizeof(struct AvahiHostNameResolver) /*64ul*/ );
    r = (struct AvahiHostNameResolver *)return_value_avahi_new_internal$2;
    if(r == ((struct AvahiHostNameResolver *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      r->client = client;
      r->callback = callback;
      r->userdata = userdata;
      r->path = (char *)(void *)0;
      r->interface = interface;
      r->protocol = protocol;
      r->host_name = (char *)(void *)0;
      do
      {
        struct AvahiHostNameResolver **_head = &client->host_name_resolvers;
        struct AvahiHostNameResolver *_item = r;
        /* assertion _item */
        assert(_item != ((struct AvahiHostNameResolver *)NULL));
        _item->host_name_resolvers_next = *_head;
        if(!(_item->host_name_resolvers_next == ((struct AvahiHostNameResolver *)NULL)))
          _item->host_name_resolvers_next->host_name_resolvers_prev = _item;

        _item->host_name_resolvers_prev = (struct AvahiHostNameResolver *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      r->host_name=avahi_strdup(name);
      if(r->host_name == ((char *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "HostNameResolverNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          i_aprotocol = (signed int)aprotocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args$3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &name, (signed int)105, &i_aprotocol, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args$3 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr$5 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
              tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$5)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args$6 == 0u)
                tmp_if_expr$8 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
                tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr$8)
                avahi_client_set_errno(client, -22);

              else
              {
                r->path=avahi_strdup(path);
                if(r->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return r;
                }
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$9;
  return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(r == ((struct AvahiHostNameResolver *)NULL)))
    avahi_host_name_resolver_free(r);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiHostNameResolver *)(void *)0;
}

// avahi_init_i18n
// file ../avahi-common/i18n.h line 51
void avahi_init_i18n(void)
{
  static signed int done = 0;
  if(done == 0)
  {
    bindtextdomain("avahi", "/usr/share/locale");
    bind_textdomain_codeset("avahi", "UTF-8");
    done = 1;
  }

}

// avahi_is_valid_domain_name
// file domain.c line 369
signed int avahi_is_valid_domain_name(const char *t)
{
  signed int is_first = 1;
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  if(return_value_strlen$1 >= 1014ul)
    return 0;

  else
  {
    do
    {
      char label[64l];
      char *return_value_avahi_unescape_label$2;
      return_value_avahi_unescape_label$2=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
      if(return_value_avahi_unescape_label$2 == ((char *)NULL))
        return 0;

      if(!(is_first == 0))
      {
        if((signed int)label[0l] == 0)
        {
          if((signed int)*t == 0)
            return 1;

        }

      }

      is_first = 0;
      if((signed int)label[0l] == 0)
        return 0;

    }
    while(!(*t == 0));
    return 1;
  }
}

// avahi_is_valid_fqdn
// file domain.c line 575
signed int avahi_is_valid_fqdn(const char *t)
{
  char label[64l];
  char normalized[1014l];
  const char *k = t;
  struct AvahiAddress a;
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  if(return_value_strlen$1 >= 1014ul)
    return 0;

  else
  {
    signed int return_value_avahi_is_valid_domain_name$2;
    return_value_avahi_is_valid_domain_name$2=avahi_is_valid_domain_name(t);
    if(return_value_avahi_is_valid_domain_name$2 == 0)
      return 0;

    else
    {
      char *return_value_avahi_unescape_label$3;
      return_value_avahi_unescape_label$3=avahi_unescape_label(&k, label, sizeof(char [64l]) /*64ul*/ );
      if(return_value_avahi_unescape_label$3 == ((char *)NULL))
        return 0;

      else
        if(k == ((const char *)NULL) || (signed int)label[0l] == 0)
          return 0;

        else
        {
          char *return_value_avahi_unescape_label$4;
          return_value_avahi_unescape_label$4=avahi_unescape_label(&k, label, sizeof(char [64l]) /*64ul*/ );
          if(return_value_avahi_unescape_label$4 == ((char *)NULL))
            return 0;

          else
            if(k == ((const char *)NULL) || (signed int)label[0l] == 0)
              return 0;

            else
            {
              char *return_value_avahi_normalize_name$5;
              return_value_avahi_normalize_name$5=avahi_normalize_name(t, normalized, sizeof(char [1014l]) /*1014ul*/ );
              if(return_value_avahi_normalize_name$5 == ((char *)NULL))
                return 0;

              else
              {
                struct AvahiAddress *return_value_avahi_address_parse$6;
                return_value_avahi_address_parse$6=avahi_address_parse(normalized, -1, &a);
                if(!(return_value_avahi_address_parse$6 == ((struct AvahiAddress *)NULL)))
                  return 0;

                else
                  return 1;
              }
            }
        }
    }
  }
}

// avahi_is_valid_host_name
// file domain.h line 103
signed int avahi_is_valid_host_name(const char *t)
{
  char label[64l];
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  _Bool tmp_if_expr$2;
  if(return_value_strlen$1 >= 1014ul)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return 0;

  else
  {
    char *return_value_avahi_unescape_label$3;
    return_value_avahi_unescape_label$3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label$3 == ((char *)NULL))
      return 0;

    else
    {
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(label);
      if(!(return_value_strlen$4 >= 1ul))
        return 0;

      else
        if(!(*t == 0))
          return 0;

        else
          return 1;
    }
  }
}

// avahi_is_valid_service_name
// file domain.h line 100
signed int avahi_is_valid_service_name(const char *t)
{
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  _Bool tmp_if_expr$2;
  if(return_value_strlen$1 >= 64ul)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return 0;

  else
    return 1;
}

// avahi_is_valid_service_subtype
// file domain.c line 363
signed int avahi_is_valid_service_subtype(const char *t)
{
  /* assertion t */
  assert(t != ((const char *)NULL));
  const char *return_value_avahi_get_type_from_subtype$1;
  return_value_avahi_get_type_from_subtype$1=avahi_get_type_from_subtype(t);
  return (signed int)!(!(return_value_avahi_get_type_from_subtype$1 != ((const char *)NULL)));
}

// avahi_is_valid_service_type_generic
// file domain.c line 254
signed int avahi_is_valid_service_type_generic(const char *t)
{
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  _Bool tmp_if_expr$2;
  if(return_value_strlen$1 >= 1014ul)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$2)
    return 0;

  else
  {
    do
    {
      char label[64l];
      char *return_value_avahi_unescape_label$3;
      return_value_avahi_unescape_label$3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
      if(return_value_avahi_unescape_label$3 == ((char *)NULL))
        return 0;

      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(label);
      if(!(return_value_strlen$4 >= 3ul))
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        return 0;

    }
    while(!(*t == 0));
    return 1;
  }
}

// avahi_is_valid_service_type_strict
// file domain.c line 274
signed int avahi_is_valid_service_type_strict(const char *t)
{
  char label[64l];
  /* assertion t */
  assert(t != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(t);
  _Bool tmp_if_expr$2;
  if(return_value_strlen$1 >= 1014ul)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(*t != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  signed int return_value_strcasecmp$7;
  if(tmp_if_expr$2)
    return 0;

  else
  {
    char *return_value_avahi_unescape_label$3;
    return_value_avahi_unescape_label$3=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label$3 == ((char *)NULL))
      return 0;

    else
    {
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(label);
      if(!(return_value_strlen$4 >= 3ul))
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)label[(signed long int)0] != 95 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        return 0;

      else
        if(*t == 0)
          return 0;

        else
        {
          char *return_value_avahi_unescape_label$6;
          return_value_avahi_unescape_label$6=avahi_unescape_label(&t, label, sizeof(char [64l]) /*64ul*/ );
          if(return_value_avahi_unescape_label$6 == ((char *)NULL))
            return 0;

          else
          {
            signed int return_value_strcasecmp$8;
            return_value_strcasecmp$8=strcasecmp(label, "_tcp");
            if(!(return_value_strcasecmp$8 == 0))
            {
              return_value_strcasecmp$7=strcasecmp(label, "_udp");
              if(return_value_strcasecmp$7 == 0)
                goto __CPROVER_DUMP_L10;

              return 0;
            }

            else
            {

            __CPROVER_DUMP_L10:
              ;
              if(!(*t == 0))
                return 0;

              else
                return 1;
            }
          }
        }
    }
  }
}

// avahi_malloc
// file ../avahi-common/malloc.h line 36
void * avahi_malloc(unsigned long int size)
{
  void *return_value_xmalloc$1;
  if(!(size >= 1ul))
    return (void *)0;

  else
    if(allocator == ((const struct AvahiAllocator *)NULL))
    {
      return_value_xmalloc$1=xmalloc(size);
      return return_value_xmalloc$1;
    }

    else
    {
      /* assertion allocator->malloc */
      assert(allocator->malloc != ((void * (*)(unsigned long int))NULL));
      void *return_value;
      return_value=allocator->malloc(size);
      return return_value;
    }
}

// avahi_malloc0
// file malloc.c line 113
void * avahi_malloc0(unsigned long int size)
{
  void *p;
  void *return_value_xcalloc$1;
  void *return_value;
  if(!(size >= 1ul))
    return (void *)0;

  else
    if(allocator == ((const struct AvahiAllocator *)NULL))
    {
      return_value_xcalloc$1=xcalloc((unsigned long int)1, size);
      return return_value_xcalloc$1;
    }

    else
      if(!(allocator->calloc == ((void * (*)(unsigned long int, unsigned long int))NULL)))
      {
        return_value=allocator->calloc((unsigned long int)1, size);
        return return_value;
      }

      else
      {
        /* assertion allocator->malloc */
        assert(allocator->malloc != ((void * (*)(unsigned long int))NULL));
        p=allocator->malloc(size);
        if(!(p == NULL))
          memset(p, 0, size);

        return p;
      }
}

// avahi_memdup
// file malloc.c line 248
void * avahi_memdup(const void *s, unsigned long int l)
{
  void *p;
  /* assertion s */
  assert(s != NULL);
  p=avahi_malloc(l);
  if(p == NULL)
    return (void *)0;

  else
  {
    memcpy(p, s, l);
    return p;
  }
}

// avahi_new_internal
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal(unsigned int n, unsigned long int k)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n < (unsigned long int)0x7fffffff / k);
  void *return_value_avahi_malloc$1;
  return_value_avahi_malloc$1=avahi_malloc((unsigned long int)n * k);
  return return_value_avahi_malloc$1;
}

// avahi_new_internal$link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link1(unsigned int n$link1, unsigned long int k$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link1 < (unsigned long int)0x7fffffff / k$link1);
  void *return_value_avahi_malloc$1$link1;
  return_value_avahi_malloc$1$link1=avahi_malloc((unsigned long int)n$link1 * k$link1);
  return return_value_avahi_malloc$1$link1;
}

// avahi_new_internal$link1$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link1$link1(unsigned int n$link1$link1, unsigned long int k$link1$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link1$link1 < (unsigned long int)0x7fffffff / k$link1$link1);
  void *return_value_avahi_malloc$1$link1$link1;
  return_value_avahi_malloc$1$link1$link1=avahi_malloc((unsigned long int)n$link1$link1 * k$link1$link1);
  return return_value_avahi_malloc$1$link1$link1;
}

// avahi_new_internal$link1$link1$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link1$link1$link1(unsigned int n$link1$link1$link1, unsigned long int k$link1$link1$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link1$link1$link1 < (unsigned long int)0x7fffffff / k$link1$link1$link1);
  void *return_value_avahi_malloc$1$link1$link1$link1;
  return_value_avahi_malloc$1$link1$link1$link1=avahi_malloc((unsigned long int)n$link1$link1$link1 * k$link1$link1$link1);
  return return_value_avahi_malloc$1$link1$link1$link1;
}

// avahi_new_internal$link1$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link1$link2(unsigned int n$link1$link2, unsigned long int k$link1$link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link1$link2 < (unsigned long int)0x7fffffff / k$link1$link2);
  void *return_value_avahi_malloc$1$link1$link2;
  return_value_avahi_malloc$1$link1$link2=avahi_malloc((unsigned long int)n$link1$link2 * k$link1$link2);
  return return_value_avahi_malloc$1$link1$link2;
}

// avahi_new_internal$link1$link2$link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link1$link2$link1(unsigned int n$link1$link2$link1, unsigned long int k$link1$link2$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link1$link2$link1 < (unsigned long int)0x7fffffff / k$link1$link2$link1);
  void *return_value_avahi_malloc$1$link1$link2$link1;
  return_value_avahi_malloc$1$link1$link2$link1=avahi_malloc((unsigned long int)n$link1$link2$link1 * k$link1$link2$link1);
  return return_value_avahi_malloc$1$link1$link2$link1;
}

// avahi_new_internal$link1$link3
// file malloc.h line 48
static inline void * avahi_new_internal$link1$link3(unsigned int n$link1$link3, unsigned long int k$link1$link3)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link1$link3 < (unsigned long int)0x7fffffff / k$link1$link3);
  void *return_value_avahi_malloc$1$link1$link3;
  return_value_avahi_malloc$1$link1$link3=avahi_malloc((unsigned long int)n$link1$link3 * k$link1$link3);
  return return_value_avahi_malloc$1$link1$link3;
}

// avahi_new_internal$link1$link4
// file malloc.h line 48
static inline void * avahi_new_internal$link1$link4(unsigned int n$link1$link4, unsigned long int k$link1$link4)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link1$link4 < (unsigned long int)0x7fffffff / k$link1$link4);
  void *return_value_avahi_malloc$1$link1$link4;
  return_value_avahi_malloc$1$link1$link4=avahi_malloc((unsigned long int)n$link1$link4 * k$link1$link4);
  return return_value_avahi_malloc$1$link1$link4;
}

// avahi_new_internal$link2
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link2(unsigned int n$link2, unsigned long int k$link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link2 < (unsigned long int)0x7fffffff / k$link2);
  void *return_value_avahi_malloc$1$link2;
  return_value_avahi_malloc$1$link2=avahi_malloc((unsigned long int)n$link2 * k$link2);
  return return_value_avahi_malloc$1$link2;
}

// avahi_new_internal$link2$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link2$link1(unsigned int n$link2$link1, unsigned long int k$link2$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link2$link1 < (unsigned long int)0x7fffffff / k$link2$link1);
  void *return_value_avahi_malloc$1$link2$link1;
  return_value_avahi_malloc$1$link2$link1=avahi_malloc((unsigned long int)n$link2$link1 * k$link2$link1);
  return return_value_avahi_malloc$1$link2$link1;
}

// avahi_new_internal$link2$link1$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link2$link1$link1(unsigned int n$link2$link1$link1, unsigned long int k$link2$link1$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link2$link1$link1 < (unsigned long int)0x7fffffff / k$link2$link1$link1);
  void *return_value_avahi_malloc$1$link2$link1$link1;
  return_value_avahi_malloc$1$link2$link1$link1=avahi_malloc((unsigned long int)n$link2$link1$link1 * k$link2$link1$link1);
  return return_value_avahi_malloc$1$link2$link1$link1;
}

// avahi_new_internal$link2$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link2$link2(unsigned int n$link2$link2, unsigned long int k$link2$link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link2$link2 < (unsigned long int)0x7fffffff / k$link2$link2);
  void *return_value_avahi_malloc$1$link2$link2;
  return_value_avahi_malloc$1$link2$link2=avahi_malloc((unsigned long int)n$link2$link2 * k$link2$link2);
  return return_value_avahi_malloc$1$link2$link2;
}

// avahi_new_internal$link2$link2$link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link2$link2$link1(unsigned int n$link2$link2$link1, unsigned long int k$link2$link2$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link2$link2$link1 < (unsigned long int)0x7fffffff / k$link2$link2$link1);
  void *return_value_avahi_malloc$1$link2$link2$link1;
  return_value_avahi_malloc$1$link2$link2$link1=avahi_malloc((unsigned long int)n$link2$link2$link1 * k$link2$link2$link1);
  return return_value_avahi_malloc$1$link2$link2$link1;
}

// avahi_new_internal$link2$link3
// file malloc.h line 48
static inline void * avahi_new_internal$link2$link3(unsigned int n$link2$link3, unsigned long int k$link2$link3)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link2$link3 < (unsigned long int)0x7fffffff / k$link2$link3);
  void *return_value_avahi_malloc$1$link2$link3;
  return_value_avahi_malloc$1$link2$link3=avahi_malloc((unsigned long int)n$link2$link3 * k$link2$link3);
  return return_value_avahi_malloc$1$link2$link3;
}

// avahi_new_internal$link2$link4
// file malloc.h line 48
static inline void * avahi_new_internal$link2$link4(unsigned int n$link2$link4, unsigned long int k$link2$link4)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link2$link4 < (unsigned long int)0x7fffffff / k$link2$link4);
  void *return_value_avahi_malloc$1$link2$link4;
  return_value_avahi_malloc$1$link2$link4=avahi_malloc((unsigned long int)n$link2$link4 * k$link2$link4);
  return return_value_avahi_malloc$1$link2$link4;
}

// avahi_new_internal$link3
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link3(unsigned int n$link3, unsigned long int k$link3)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link3 < (unsigned long int)0x7fffffff / k$link3);
  void *return_value_avahi_malloc$1$link3;
  return_value_avahi_malloc$1$link3=avahi_malloc((unsigned long int)n$link3 * k$link3);
  return return_value_avahi_malloc$1$link3;
}

// avahi_new_internal$link3$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link3$link1(unsigned int n$link3$link1, unsigned long int k$link3$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link3$link1 < (unsigned long int)0x7fffffff / k$link3$link1);
  void *return_value_avahi_malloc$1$link3$link1;
  return_value_avahi_malloc$1$link3$link1=avahi_malloc((unsigned long int)n$link3$link1 * k$link3$link1);
  return return_value_avahi_malloc$1$link3$link1;
}

// avahi_new_internal$link3$link1$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link3$link1$link1(unsigned int n$link3$link1$link1, unsigned long int k$link3$link1$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link3$link1$link1 < (unsigned long int)0x7fffffff / k$link3$link1$link1);
  void *return_value_avahi_malloc$1$link3$link1$link1;
  return_value_avahi_malloc$1$link3$link1$link1=avahi_malloc((unsigned long int)n$link3$link1$link1 * k$link3$link1$link1);
  return return_value_avahi_malloc$1$link3$link1$link1;
}

// avahi_new_internal$link3$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link3$link2(unsigned int n$link3$link2, unsigned long int k$link3$link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link3$link2 < (unsigned long int)0x7fffffff / k$link3$link2);
  void *return_value_avahi_malloc$1$link3$link2;
  return_value_avahi_malloc$1$link3$link2=avahi_malloc((unsigned long int)n$link3$link2 * k$link3$link2);
  return return_value_avahi_malloc$1$link3$link2;
}

// avahi_new_internal$link3$link2$link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link3$link2$link1(unsigned int n$link3$link2$link1, unsigned long int k$link3$link2$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link3$link2$link1 < (unsigned long int)0x7fffffff / k$link3$link2$link1);
  void *return_value_avahi_malloc$1$link3$link2$link1;
  return_value_avahi_malloc$1$link3$link2$link1=avahi_malloc((unsigned long int)n$link3$link2$link1 * k$link3$link2$link1);
  return return_value_avahi_malloc$1$link3$link2$link1;
}

// avahi_new_internal$link3$link3
// file malloc.h line 48
static inline void * avahi_new_internal$link3$link3(unsigned int n$link3$link3, unsigned long int k$link3$link3)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link3$link3 < (unsigned long int)0x7fffffff / k$link3$link3);
  void *return_value_avahi_malloc$1$link3$link3;
  return_value_avahi_malloc$1$link3$link3=avahi_malloc((unsigned long int)n$link3$link3 * k$link3$link3);
  return return_value_avahi_malloc$1$link3$link3;
}

// avahi_new_internal$link3$link4
// file malloc.h line 48
static inline void * avahi_new_internal$link3$link4(unsigned int n$link3$link4, unsigned long int k$link3$link4)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link3$link4 < (unsigned long int)0x7fffffff / k$link3$link4);
  void *return_value_avahi_malloc$1$link3$link4;
  return_value_avahi_malloc$1$link3$link4=avahi_malloc((unsigned long int)n$link3$link4 * k$link3$link4);
  return return_value_avahi_malloc$1$link3$link4;
}

// avahi_new_internal$link4
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link4(unsigned int n$link4, unsigned long int k$link4)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link4 < (unsigned long int)0x7fffffff / k$link4);
  void *return_value_avahi_malloc$1$link4;
  return_value_avahi_malloc$1$link4=avahi_malloc((unsigned long int)n$link4 * k$link4);
  return return_value_avahi_malloc$1$link4;
}

// avahi_new_internal$link4$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link4$link1(unsigned int n$link4$link1, unsigned long int k$link4$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link4$link1 < (unsigned long int)0x7fffffff / k$link4$link1);
  void *return_value_avahi_malloc$1$link4$link1;
  return_value_avahi_malloc$1$link4$link1=avahi_malloc((unsigned long int)n$link4$link1 * k$link4$link1);
  return return_value_avahi_malloc$1$link4$link1;
}

// avahi_new_internal$link4$link1$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link4$link1$link1(unsigned int n$link4$link1$link1, unsigned long int k$link4$link1$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link4$link1$link1 < (unsigned long int)0x7fffffff / k$link4$link1$link1);
  void *return_value_avahi_malloc$1$link4$link1$link1;
  return_value_avahi_malloc$1$link4$link1$link1=avahi_malloc((unsigned long int)n$link4$link1$link1 * k$link4$link1$link1);
  return return_value_avahi_malloc$1$link4$link1$link1;
}

// avahi_new_internal$link4$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link4$link2(unsigned int n$link4$link2, unsigned long int k$link4$link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link4$link2 < (unsigned long int)0x7fffffff / k$link4$link2);
  void *return_value_avahi_malloc$1$link4$link2;
  return_value_avahi_malloc$1$link4$link2=avahi_malloc((unsigned long int)n$link4$link2 * k$link4$link2);
  return return_value_avahi_malloc$1$link4$link2;
}

// avahi_new_internal$link4$link2$link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link4$link2$link1(unsigned int n$link4$link2$link1, unsigned long int k$link4$link2$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link4$link2$link1 < (unsigned long int)0x7fffffff / k$link4$link2$link1);
  void *return_value_avahi_malloc$1$link4$link2$link1;
  return_value_avahi_malloc$1$link4$link2$link1=avahi_malloc((unsigned long int)n$link4$link2$link1 * k$link4$link2$link1);
  return return_value_avahi_malloc$1$link4$link2$link1;
}

// avahi_new_internal$link4$link3
// file malloc.h line 48
static inline void * avahi_new_internal$link4$link3(unsigned int n$link4$link3, unsigned long int k$link4$link3)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link4$link3 < (unsigned long int)0x7fffffff / k$link4$link3);
  void *return_value_avahi_malloc$1$link4$link3;
  return_value_avahi_malloc$1$link4$link3=avahi_malloc((unsigned long int)n$link4$link3 * k$link4$link3);
  return return_value_avahi_malloc$1$link4$link3;
}

// avahi_new_internal$link4$link4
// file malloc.h line 48
static inline void * avahi_new_internal$link4$link4(unsigned int n$link4$link4, unsigned long int k$link4$link4)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link4$link4 < (unsigned long int)0x7fffffff / k$link4$link4);
  void *return_value_avahi_malloc$1$link4$link4;
  return_value_avahi_malloc$1$link4$link4=avahi_malloc((unsigned long int)n$link4$link4 * k$link4$link4);
  return return_value_avahi_malloc$1$link4$link4;
}

// avahi_new_internal$link5
// file malloc.h line 48
static inline void * avahi_new_internal$link5(unsigned int n$link5, unsigned long int k$link5)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link5 < (unsigned long int)0x7fffffff / k$link5);
  void *return_value_avahi_malloc$1$link5;
  return_value_avahi_malloc$1$link5=avahi_malloc((unsigned long int)n$link5 * k$link5);
  return return_value_avahi_malloc$1$link5;
}

// avahi_new_internal$link5$link1
// file malloc.h line 48
static inline void * avahi_new_internal$link5$link1(unsigned int n$link5$link1, unsigned long int k$link5$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link5$link1 < (unsigned long int)0x7fffffff / k$link5$link1);
  void *return_value_avahi_malloc$1$link5$link1;
  return_value_avahi_malloc$1$link5$link1=avahi_malloc((unsigned long int)n$link5$link1 * k$link5$link1);
  return return_value_avahi_malloc$1$link5$link1;
}

// avahi_new_internal$link5$link2
// file malloc.h line 48
static inline void * avahi_new_internal$link5$link2(unsigned int n$link5$link2, unsigned long int k$link5$link2)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link5$link2 < (unsigned long int)0x7fffffff / k$link5$link2);
  void *return_value_avahi_malloc$1$link5$link2;
  return_value_avahi_malloc$1$link5$link2=avahi_malloc((unsigned long int)n$link5$link2 * k$link5$link2);
  return return_value_avahi_malloc$1$link5$link2;
}

// avahi_new_internal$link6
// file malloc.h line 48
static inline void * avahi_new_internal$link6(unsigned int n$link6, unsigned long int k$link6)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link6 < (unsigned long int)0x7fffffff / k$link6);
  void *return_value_avahi_malloc$1$link6;
  return_value_avahi_malloc$1$link6=avahi_malloc((unsigned long int)n$link6 * k$link6);
  return return_value_avahi_malloc$1$link6;
}

// avahi_new_internal$link6$link1
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link6$link1(unsigned int n$link6$link1, unsigned long int k$link6$link1)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link6$link1 < (unsigned long int)0x7fffffff / k$link6$link1);
  void *return_value_avahi_malloc$1$link6$link1;
  return_value_avahi_malloc$1$link6$link1=avahi_malloc((unsigned long int)n$link6$link1 * k$link6$link1);
  return return_value_avahi_malloc$1$link6$link1;
}

// avahi_new_internal$link7
// file ../avahi-common/malloc.h line 48
static inline void * avahi_new_internal$link7(unsigned int n$link7, unsigned long int k$link7)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link7 < (unsigned long int)0x7fffffff / k$link7);
  void *return_value_avahi_malloc$1$link7;
  return_value_avahi_malloc$1$link7=avahi_malloc((unsigned long int)n$link7 * k$link7);
  return return_value_avahi_malloc$1$link7;
}

// avahi_new_internal$link8
// file malloc.h line 48
static inline void * avahi_new_internal$link8(unsigned int n$link8, unsigned long int k$link8)
{
  /* assertion n < 0x7fffffff/k */
  assert((unsigned long int)n$link8 < (unsigned long int)0x7fffffff / k$link8);
  void *return_value_avahi_malloc$1$link8;
  return_value_avahi_malloc$1$link8=avahi_malloc((unsigned long int)n$link8 * k$link8);
  return return_value_avahi_malloc$1$link8;
}

// avahi_normalize_name
// file ../avahi-common/domain.h line 50
char * avahi_normalize_name(const char *s, char *ret_s, unsigned long int size)
{
  signed int empty = 1;
  char *r;
  /* assertion s */
  assert(s != ((const char *)NULL));
  /* assertion ret_s */
  assert(ret_s != ((char *)NULL));
  /* assertion size > 0 */
  assert(size > (unsigned long int)0);
  r = ret_s;
  *ret_s = (char)0;
  char *tmp_post$2;
  while(!(*s == 0))
  {
    char label[64l];
    char *return_value_avahi_unescape_label$1;
    return_value_avahi_unescape_label$1=avahi_unescape_label(&s, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label$1 == ((char *)NULL))
      return (char *)(void *)0;

    if((signed int)label[0l] == 0)
    {
      if((signed int)*s == 0)
      {
        if(!(empty == 0))
          return ret_s;

      }

      return (char *)(void *)0;
    }

    if(empty == 0)
    {
      if(!(size >= 1ul))
        return (char *)(void *)0;

      tmp_post$2 = r;
      r = r + 1l;
      *tmp_post$2 = (char)46;
      size = size - 1ul;
    }

    else
      empty = 0;
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(label);
    avahi_escape_label(label, return_value_strlen$3, &r, &size);
  }
  return ret_s;
}

// avahi_normalize_name_strdup
// file domain.c line 219
char * avahi_normalize_name_strdup(const char *s)
{
  char t[1014l];
  /* assertion s */
  assert(s != ((const char *)NULL));
  char *return_value_avahi_normalize_name$1;
  return_value_avahi_normalize_name$1=avahi_normalize_name(s, t, sizeof(char [1014l]) /*1014ul*/ );
  if(return_value_avahi_normalize_name$1 == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    char *return_value_avahi_strdup$2;
    return_value_avahi_strdup$2=avahi_strdup(t);
    return return_value_avahi_strdup$2;
  }
}

// avahi_nss_support
// file ../avahi-client/client.h line 111
signed int avahi_nss_support(void)
{
  signed int b = 0;
  static const char * const libs[4l] = { "libnss_mdns.so.2", "libnss_mdns4.so.2", "libnss_mdns6.so.2", (const char *)(void *)0 };
  const char * const *l = libs;
  for( ; !(*l == ((const char *)NULL)); l = l + 1l)
  {
    void *dl;
    dl=dlopen(*l, 0x00001);
    if(!(dl == NULL))
    {
      b = 1;
      dlclose(dl);
      break;
    }

  }
  return b;
}

// avahi_proto_to_af
// file address.c line 127
signed int avahi_proto_to_af(signed int proto)
{
  if(proto == 0)
    return 2;

  else
    if(proto == 1)
      return 10;

    else
    {
      /* assertion proto == AVAHI_PROTO_UNSPEC */
      assert(proto == -1);
      return 0;
    }
}

// avahi_proto_to_string
// file address.c line 147
const char * avahi_proto_to_string(signed int proto)
{
  if(proto == 0)
    return "IPv4";

  else
    if(proto == 1)
      return "IPv6";

    else
    {
      /* assertion proto == AVAHI_PROTO_UNSPEC */
      assert(proto == -1);
      return "UNSPEC";
    }
}

// avahi_realloc
// file malloc.c line 146
void * avahi_realloc(void *p, unsigned long int size)
{
  void *return_value_xrealloc$1;
  if(size == 0ul)
  {
    avahi_free(p);
    return (void *)0;
  }

  else
    if(allocator == ((const struct AvahiAllocator *)NULL))
    {
      return_value_xrealloc$1=xrealloc(p, size);
      return return_value_xrealloc$1;
    }

    else
    {
      /* assertion allocator->realloc */
      assert(allocator->realloc != ((void * (*)(void *, unsigned long int))NULL));
      void *return_value;
      return_value=allocator->realloc(p, size);
      return return_value;
    }
}

// avahi_record_browser_event
// file internal.h line 162
enum anonymous$42 avahi_record_browser_event(struct AvahiClient *client, enum anonymous$14 event, struct DBusMessage *message)
{
  struct AvahiRecordBrowser *b = (struct AvahiRecordBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *name;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  unsigned short int clazz;
  unsigned short int type;
  void *rdata = (void *)0;
  signed int rdata_size = 0;
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp$1;
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  signed int j;
  unsigned int return_value_dbus_message_get_args$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  signed int return_value_dbus_message_iter_get_arg_type$5;
  _Bool tmp_if_expr$7;
  signed int return_value_dbus_message_iter_get_element_type$6;
  signed int return_value_dbus_message_iter_get_arg_type$8;
  char *etxt;
  unsigned int return_value_dbus_message_get_args$9;
  _Bool tmp_if_expr$11;
  unsigned int return_value_dbus_error_is_set$10;
  signed int return_value_avahi_error_dbus_to_number$12;
  if(!(path == ((const char *)NULL)))
  {
    b = client->record_browsers;
    for( ; !(b == ((struct AvahiRecordBrowser *)NULL)); b = b->record_browsers_next)
    {
      return_value_strcmp$1=strcmp(b->path, path);
      if(return_value_strcmp$1 == 0)
        break;

    }
    if(b == ((struct AvahiRecordBrowser *)NULL))
      goto fail;

    interface = b->interface;
    protocol = b->protocol;
    clazz = b->clazz;
    type = b->type;
    name = b->name;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args$2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)113, &clazz, (signed int)113, &type, (signed int)0);
        if(return_value_dbus_message_get_args$2 == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        dbus_message_iter_init(message, &iter);
        j = 0;
        for( ; !(j >= 5); j = j + 1)
          dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type$5=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type$5 == 97))
          tmp_if_expr$7 = (_Bool)1;

        else
        {
          return_value_dbus_message_iter_get_element_type$6=dbus_message_iter_get_element_type(&iter);
          tmp_if_expr$7 = return_value_dbus_message_iter_get_element_type$6 != (signed int)121 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$7)
          goto fail;

        dbus_message_iter_recurse(&iter, &sub);
        dbus_message_iter_get_fixed_array(&sub, (void *)&rdata, &rdata_size);
        dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type$8=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type$8 == 117))
          goto fail;

        dbus_message_iter_get_basic(&iter, (void *)&flags);
        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args$9=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args$9 == 0u)
          tmp_if_expr$11 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$10=dbus_error_is_set(&error);
          tmp_if_expr$11 = return_value_dbus_error_is_set$10 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$11)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number$12=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(b->client, return_value_avahi_error_dbus_to_number$12);
      }
    }
    b->callback(b, (signed int)interface, (signed int)protocol, event, name, clazz, type, rdata, (unsigned long int)rdata_size, (enum anonymous$13)flags, b->userdata);
    return (enum anonymous$42)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous$42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_record_browser_free
// file lookup.h line 308
signed int avahi_record_browser_free(struct AvahiRecordBrowser *b)
{
  struct AvahiClient *client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiRecordBrowser *)NULL));
  client = b->client;
  signed int return_value_avahi_client_is_connected$1;
  if(!(b->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected$1=avahi_client_is_connected(b->client);
    if(!(return_value_avahi_client_is_connected$1 == 0))
      r=avahi_client_simple_method_call(client, b->path, "org.freedesktop.Avahi.RecordBrowser", "Free");

  }

  do
  {
    struct AvahiRecordBrowser **_head = &b->client->record_browsers;
    struct AvahiRecordBrowser *_item = b;
    /* assertion _item */
    assert(_item != ((struct AvahiRecordBrowser *)NULL));
    if(!(_item->record_browsers_next == ((struct AvahiRecordBrowser *)NULL)))
      _item->record_browsers_next->record_browsers_prev = _item->record_browsers_prev;

    if(!(_item->record_browsers_prev == ((struct AvahiRecordBrowser *)NULL)))
      _item->record_browsers_prev->record_browsers_next = _item->record_browsers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->record_browsers_next;
    }
    _item->record_browsers_prev = (struct AvahiRecordBrowser *)(void *)0;
    _item->record_browsers_next = _item->record_browsers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)b->path);
  avahi_free((void *)b->name);
  avahi_free((void *)b);
  return r;
}

// avahi_record_browser_get_client
// file browser.c line 903
struct AvahiClient * avahi_record_browser_get_client(struct AvahiRecordBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiRecordBrowser *)NULL));
  return b->client;
}

// avahi_record_browser_new
// file browser.c line 786
struct AvahiRecordBrowser * avahi_record_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, unsigned short int clazz, unsigned short int type, enum anonymous$44 flags, void (*callback)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous$14, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous$13, void *), void *userdata)
{
  struct AvahiRecordBrowser *b = (struct AvahiRecordBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_protocol;
  signed int i_interface;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion name */
  assert(name != ((const char *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiRecordBrowser *, signed int, signed int, enum anonymous$14, const char *, unsigned short int, unsigned short int, const void *, unsigned long int, enum anonymous$13, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal$2;
  unsigned int return_value_dbus_message_append_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(return_value_avahi_client_is_connected$1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal$2=avahi_new_internal$link2((unsigned int)1, sizeof(struct AvahiRecordBrowser) /*72ul*/ );
    b = (struct AvahiRecordBrowser *)return_value_avahi_new_internal$2;
    if(b == ((struct AvahiRecordBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      b->client = client;
      b->callback = callback;
      b->userdata = userdata;
      b->path = (char *)(void *)0;
      b->name = (char *)(void *)0;
      b->clazz = clazz;
      b->type = type;
      b->interface = interface;
      b->protocol = protocol;
      do
      {
        struct AvahiRecordBrowser **_head = &client->record_browsers;
        struct AvahiRecordBrowser *_item = b;
        /* assertion _item */
        assert(_item != ((struct AvahiRecordBrowser *)NULL));
        _item->record_browsers_next = *_head;
        if(!(_item->record_browsers_next == ((struct AvahiRecordBrowser *)NULL)))
          _item->record_browsers_next->record_browsers_prev = _item;

        _item->record_browsers_prev = (struct AvahiRecordBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      b->name=avahi_strdup(name);
      if(b->name == ((char *)NULL))
        avahi_client_set_errno(client, -24);

      else
      {
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "RecordBrowserNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args$3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &name, (signed int)113, &clazz, (signed int)113, &type, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args$3 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr$5 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
              tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$5)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args$6 == 0u)
                tmp_if_expr$8 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
                tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr$8)
                avahi_client_set_errno(client, -22);

              else
              {
                b->path=avahi_strdup(path);
                if(b->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return b;
                }
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$9;
  return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(b == ((struct AvahiRecordBrowser *)NULL)))
    avahi_record_browser_free(b);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiRecordBrowser *)(void *)0;
}

// avahi_reverse_lookup_name
// file address.c line 67
char * avahi_reverse_lookup_name(const struct AvahiAddress *a, char *ret_s, unsigned long int length)
{
  /* assertion ret_s */
  assert(ret_s != ((char *)NULL));
  /* assertion length > 0 */
  assert(length > (unsigned long int)0);
  /* assertion a */
  assert(a != ((const struct AvahiAddress *)NULL));
  if(a->proto == 0)
  {
    unsigned int n;
    n=ntohl(a->data.ipv4.address);
    snprintf(ret_s, length, "%u.%u.%u.%u.in-addr.arpa", n & (unsigned int)0xFF, n >> 8 & (unsigned int)0xFF, n >> 16 & (unsigned int)0xFF, n >> 24);
  }

  else
  {
    /* assertion a->proto == AVAHI_PROTO_INET6 */
    assert(a->proto == 1);
    snprintf(ret_s, length, "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.ip6.arpa", (signed int)a->data.ipv6.address[(signed long int)15] & 0xF, (signed int)a->data.ipv6.address[(signed long int)15] >> 4, (signed int)a->data.ipv6.address[(signed long int)14] & 0xF, (signed int)a->data.ipv6.address[(signed long int)14] >> 4, (signed int)a->data.ipv6.address[(signed long int)13] & 0xF, (signed int)a->data.ipv6.address[(signed long int)13] >> 4, (signed int)a->data.ipv6.address[(signed long int)12] & 0xF, (signed int)a->data.ipv6.address[(signed long int)12] >> 4, (signed int)a->data.ipv6.address[(signed long int)11] & 0xF, (signed int)a->data.ipv6.address[(signed long int)11] >> 4, (signed int)a->data.ipv6.address[(signed long int)10] & 0xF, (signed int)a->data.ipv6.address[(signed long int)10] >> 4, (signed int)a->data.ipv6.address[(signed long int)9] & 0xF, (signed int)a->data.ipv6.address[(signed long int)9] >> 4, (signed int)a->data.ipv6.address[(signed long int)8] & 0xF, (signed int)a->data.ipv6.address[(signed long int)8] >> 4, (signed int)a->data.ipv6.address[(signed long int)7] & 0xF, (signed int)a->data.ipv6.address[(signed long int)7] >> 4, (signed int)a->data.ipv6.address[(signed long int)6] & 0xF, (signed int)a->data.ipv6.address[(signed long int)6] >> 4, (signed int)a->data.ipv6.address[(signed long int)5] & 0xF, (signed int)a->data.ipv6.address[(signed long int)5] >> 4, (signed int)a->data.ipv6.address[(signed long int)4] & 0xF, (signed int)a->data.ipv6.address[(signed long int)4] >> 4, (signed int)a->data.ipv6.address[(signed long int)3] & 0xF, (signed int)a->data.ipv6.address[(signed long int)3] >> 4, (signed int)a->data.ipv6.address[(signed long int)2] & 0xF, (signed int)a->data.ipv6.address[(signed long int)2] >> 4, (signed int)a->data.ipv6.address[(signed long int)1] & 0xF, (signed int)a->data.ipv6.address[(signed long int)1] >> 4, (signed int)a->data.ipv6.address[(signed long int)0] & 0xF, (signed int)a->data.ipv6.address[(signed long int)0] >> 4);
  }
  return ret_s;
}

// avahi_rlist_prepend
// file rlist.c line 29
struct AvahiRList * avahi_rlist_prepend(struct AvahiRList *r, void *data)
{
  struct AvahiRList *n;
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link4$link1((unsigned int)1, sizeof(struct AvahiRList) /*24ul*/ );
  n = (struct AvahiRList *)return_value_avahi_new_internal$1;
  if(n == ((struct AvahiRList *)NULL))
    return (struct AvahiRList *)(void *)0;

  else
  {
    n->data = data;
    do
    {
      struct AvahiRList **_head = &r;
      struct AvahiRList *_item = n;
      /* assertion _item */
      assert(_item != ((struct AvahiRList *)NULL));
      _item->rlist_next = *_head;
      if(!(_item->rlist_next == ((struct AvahiRList *)NULL)))
        _item->rlist_next->rlist_prev = _item;

      _item->rlist_prev = (struct AvahiRList *)(void *)0;
      *_head = _item;
    }
    while((_Bool)0);
    return r;
  }
}

// avahi_rlist_remove
// file rlist.c line 41
struct AvahiRList * avahi_rlist_remove(struct AvahiRList *r, void *data)
{
  struct AvahiRList *n = r;
  for( ; !(n == ((struct AvahiRList *)NULL)); n = n->rlist_next)
    if(n->data == data)
    {
      do
      {
        struct AvahiRList **_head = &r;
        struct AvahiRList *_item = n;
        /* assertion _item */
        assert(_item != ((struct AvahiRList *)NULL));
        if(!(_item->rlist_next == ((struct AvahiRList *)NULL)))
          _item->rlist_next->rlist_prev = _item->rlist_prev;

        if(!(_item->rlist_prev == ((struct AvahiRList *)NULL)))
          _item->rlist_prev->rlist_next = _item->rlist_next;

        else
        {
          /* assertion *_head == _item */
          assert(*_head == _item);
          *_head = _item->rlist_next;
        }
        _item->rlist_prev = (struct AvahiRList *)(void *)0;
        _item->rlist_next = _item->rlist_prev;
      }
      while((_Bool)0);
      avahi_free((void *)n);
      break;
    }

  return r;
}

// avahi_rlist_remove_by_link
// file rlist.c line 55
struct AvahiRList * avahi_rlist_remove_by_link(struct AvahiRList *r, struct AvahiRList *n)
{
  /* assertion n */
  assert(n != ((struct AvahiRList *)NULL));
  do
  {
    struct AvahiRList **_head = &r;
    struct AvahiRList *_item = n;
    /* assertion _item */
    assert(_item != ((struct AvahiRList *)NULL));
    if(!(_item->rlist_next == ((struct AvahiRList *)NULL)))
      _item->rlist_next->rlist_prev = _item->rlist_prev;

    if(!(_item->rlist_prev == ((struct AvahiRList *)NULL)))
      _item->rlist_prev->rlist_next = _item->rlist_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->rlist_next;
    }
    _item->rlist_prev = (struct AvahiRList *)(void *)0;
    _item->rlist_next = _item->rlist_prev;
  }
  while((_Bool)0);
  avahi_free((void *)n);
  return r;
}

// avahi_service_browser_event
// file internal.h line 161
enum anonymous$42 avahi_service_browser_event(struct AvahiClient *client, enum anonymous$14 event, struct DBusMessage *message)
{
  struct AvahiServiceBrowser *b = (struct AvahiServiceBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *name = (char *)(void *)0;
  char *type;
  char *domain;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp$1;
  unsigned int return_value_dbus_message_get_args$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  char *etxt;
  unsigned int return_value_dbus_message_get_args$5;
  _Bool tmp_if_expr$7;
  unsigned int return_value_dbus_error_is_set$6;
  signed int return_value_avahi_error_dbus_to_number$8;
  if(!(path == ((const char *)NULL)))
  {
    b = client->service_browsers;
    for( ; !(b == ((struct AvahiServiceBrowser *)NULL)); b = b->service_browsers_next)
    {
      return_value_strcmp$1=strcmp(b->path, path);
      if(return_value_strcmp$1 == 0)
        break;

    }
    if(b == ((struct AvahiServiceBrowser *)NULL))
      goto fail;

    type = b->type;
    domain = b->domain;
    interface = b->interface;
    protocol = b->protocol;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args$2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args$2 == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args$5=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args$5 == 0u)
          tmp_if_expr$7 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
          tmp_if_expr$7 = return_value_dbus_error_is_set$6 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$7)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number$8=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(b->client, return_value_avahi_error_dbus_to_number$8);
      }
    }
    b->callback(b, (signed int)interface, (signed int)protocol, event, name, type, domain, (enum anonymous$13)flags, b->userdata);
    return (enum anonymous$42)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous$42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_service_browser_free
// file lookup.h line 117
signed int avahi_service_browser_free(struct AvahiServiceBrowser *b)
{
  struct AvahiClient *client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiServiceBrowser *)NULL));
  client = b->client;
  signed int return_value_avahi_client_is_connected$1;
  if(!(b->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected$1=avahi_client_is_connected(b->client);
    if(!(return_value_avahi_client_is_connected$1 == 0))
      r=avahi_client_simple_method_call(client, b->path, "org.freedesktop.Avahi.ServiceBrowser", "Free");

  }

  do
  {
    struct AvahiServiceBrowser **_head = &b->client->service_browsers;
    struct AvahiServiceBrowser *_item = b;
    /* assertion _item */
    assert(_item != ((struct AvahiServiceBrowser *)NULL));
    if(!(_item->service_browsers_next == ((struct AvahiServiceBrowser *)NULL)))
      _item->service_browsers_next->service_browsers_prev = _item->service_browsers_prev;

    if(!(_item->service_browsers_prev == ((struct AvahiServiceBrowser *)NULL)))
      _item->service_browsers_prev->service_browsers_next = _item->service_browsers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->service_browsers_next;
    }
    _item->service_browsers_prev = (struct AvahiServiceBrowser *)(void *)0;
    _item->service_browsers_next = _item->service_browsers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)b->path);
  avahi_free((void *)b->type);
  avahi_free((void *)b->domain);
  avahi_free((void *)b);
  return r;
}

// avahi_service_browser_get_client
// file browser.c line 686
struct AvahiClient * avahi_service_browser_get_client(struct AvahiServiceBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiServiceBrowser *)NULL));
  return b->client;
}

// avahi_service_browser_new
// file browser.c line 564
struct AvahiServiceBrowser * avahi_service_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *type, const char *domain, enum anonymous$44 flags, void (*callback)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous$14, const char *, const char *, const char *, enum anonymous$13, void *), void *userdata)
{
  struct AvahiServiceBrowser *b = (struct AvahiServiceBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_protocol;
  signed int i_interface;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiServiceBrowser *, signed int, signed int, enum anonymous$14, const char *, const char *, const char *, enum anonymous$13, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal$2;
  unsigned int return_value_dbus_message_append_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(return_value_avahi_client_is_connected$1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    return_value_avahi_new_internal$2=avahi_new_internal$link2((unsigned int)1, sizeof(struct AvahiServiceBrowser) /*72ul*/ );
    b = (struct AvahiServiceBrowser *)return_value_avahi_new_internal$2;
    if(b == ((struct AvahiServiceBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      b->client = client;
      b->callback = callback;
      b->userdata = userdata;
      b->path = (char *)(void *)0;
      b->domain = (char *)(void *)0;
      b->type = b->domain;
      b->interface = interface;
      b->protocol = protocol;
      do
      {
        struct AvahiServiceBrowser **_head = &client->service_browsers;
        struct AvahiServiceBrowser *_item = b;
        /* assertion _item */
        assert(_item != ((struct AvahiServiceBrowser *)NULL));
        _item->service_browsers_next = *_head;
        if(!(_item->service_browsers_next == ((struct AvahiServiceBrowser *)NULL)))
          _item->service_browsers_next->service_browsers_prev = _item;

        _item->service_browsers_prev = (struct AvahiServiceBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      b->type=avahi_strdup(type);
      if(b->type == ((char *)NULL))
        avahi_client_set_errno(client, -24);

      else
        if(!(domain == ((const char *)NULL)))
        {
          if(*domain == 0)
            goto __CPROVER_DUMP_L7;

          b->domain=avahi_strdup(domain);
          if(!(b->domain == ((char *)NULL)))
            goto __CPROVER_DUMP_L7;

          avahi_client_set_errno(client, -24);
        }

        else
        {

        __CPROVER_DUMP_L7:
          ;
          message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "ServiceBrowserNew");
          if(message == ((struct DBusMessage *)NULL))
            avahi_client_set_errno(client, -24);

          else
          {
            i_interface = (signed int)interface;
            i_protocol = (signed int)protocol;
            u_flags = (unsigned int)flags;
            return_value_dbus_message_append_args$3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &type, (signed int)115, &domain, (signed int)117, &u_flags, (signed int)0);
            if(return_value_dbus_message_append_args$3 == 0u)
              avahi_client_set_errno(client, -24);

            else
            {
              reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
              if(reply == ((struct DBusMessage *)NULL))
                tmp_if_expr$5 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
                tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$5)
                avahi_client_set_errno(client, -22);

              else
              {
                return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
                if(return_value_dbus_message_get_args$6 == 0u)
                  tmp_if_expr$8 = (_Bool)1;

                else
                {
                  return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
                  tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
                }
                if(path == ((char *)NULL) || tmp_if_expr$8)
                  avahi_client_set_errno(client, -22);

                else
                {
                  b->path=avahi_strdup(path);
                  if(b->path == ((char *)NULL))
                    avahi_client_set_errno(client, -24);

                  else
                  {
                    dbus_message_unref(message);
                    dbus_message_unref(reply);
                    return b;
                  }
                }
              }
            }
          }
        }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$9;
  return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(b == ((struct AvahiServiceBrowser *)NULL)))
    avahi_service_browser_free(b);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiServiceBrowser *)(void *)0;
}

// avahi_service_name_join
// file domain.c line 440
signed int avahi_service_name_join(char *p, unsigned long int size, const char *name, const char *type, const char *domain)
{
  char escaped_name[256l];
  char normalized_type[1014l];
  char normalized_domain[1014l];
  /* assertion p */
  assert(p != ((char *)NULL));
  signed int return_value_avahi_is_valid_service_name$1;
  char *tmp_if_expr$7;
  if(!(name == ((const char *)NULL)))
  {
    return_value_avahi_is_valid_service_name$1=avahi_is_valid_service_name(name);
    if(!(return_value_avahi_is_valid_service_name$1 == 0))
      goto __CPROVER_DUMP_L1;

    return -10;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    signed int return_value_avahi_is_valid_service_type_generic$2;
    return_value_avahi_is_valid_service_type_generic$2=avahi_is_valid_service_type_generic(type);
    if(return_value_avahi_is_valid_service_type_generic$2 == 0)
      return -11;

    else
    {
      signed int return_value_avahi_is_valid_domain_name$3;
      return_value_avahi_is_valid_domain_name$3=avahi_is_valid_domain_name(domain);
      if(return_value_avahi_is_valid_domain_name$3 == 0)
        return -4;

      else
      {
        if(!(name == ((const char *)NULL)))
        {
          unsigned long int l = sizeof(char [256l]) /*256ul*/ ;
          char *e = escaped_name;
          char *r;
          unsigned long int return_value_strlen$4;
          return_value_strlen$4=strlen(name);
          r=avahi_escape_label(name, return_value_strlen$4, &e, &l);
          /* assertion r */
          assert(r != ((char *)NULL));
        }

        char *return_value_avahi_normalize_name$5;
        return_value_avahi_normalize_name$5=avahi_normalize_name(type, normalized_type, sizeof(char [1014l]) /*1014ul*/ );
        if(return_value_avahi_normalize_name$5 == ((char *)NULL))
          return -11;

        else
        {
          char *return_value_avahi_normalize_name$6;
          return_value_avahi_normalize_name$6=avahi_normalize_name(domain, normalized_domain, sizeof(char [1014l]) /*1014ul*/ );
          if(return_value_avahi_normalize_name$6 == ((char *)NULL))
            return -4;

          else
          {
            if(!(name == ((const char *)NULL)))
              tmp_if_expr$7 = escaped_name;

            else
              tmp_if_expr$7 = "";
            snprintf(p, size, "%s%s%s.%s", tmp_if_expr$7, name != ((const char *)NULL) ? "." : "", (const void *)normalized_type, (const void *)normalized_domain);
            return 0;
          }
        }
      }
    }
  }
}

// avahi_service_name_split
// file domain.c line 496
signed int avahi_service_name_split(const char *p, char *name, unsigned long int name_size, char *type, unsigned long int type_size, char *domain, unsigned long int domain_size)
{
  /* #anon_enum$NAME=0$TYPE=1$DOMAIN=2 */
enum anonymous$4 { NAME=0, TYPE=1, DOMAIN=2 };

/* */
  ;
  enum anonymous$4 state;
  signed int type_empty = 1;
  signed int domain_empty = 1;
  /* assertion p */
  assert(p != ((const char *)NULL));
  /* assertion type */
  assert(type != ((char *)NULL));
  /* assertion type_size > 0 */
  assert(type_size > (unsigned long int)0);
  /* assertion domain */
  assert(domain != ((char *)NULL));
  /* assertion domain_size > 0 */
  assert(domain_size > (unsigned long int)0);
  if(!(name == ((char *)NULL)))
  {
    /* assertion name_size > 0 */
    assert(name_size > (unsigned long int)0);
    *name = (char)0;
    state = (enum anonymous$4)NAME;
  }

  else
    state = (enum anonymous$4)TYPE;
  *domain = (char)0;
  *type = *domain;
  char *tmp_post$2;
  char *tmp_post$5;
  unsigned long int return_value_strlen$6;
  char *return_value_avahi_escape_label$7;
  while(!(*p == 0))
  {
    char buf[64l];
    char *return_value_avahi_unescape_label$1;
    return_value_avahi_unescape_label$1=avahi_unescape_label(&p, buf, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label$1 == ((char *)NULL))
      return -1;

    switch((signed int)state)
    {
      case NAME:
      {
        strlcpy(name, buf, name_size);
        state = (enum anonymous$4)TYPE;
        break;
      }
      case TYPE:
      {
        if((signed int)buf[0l] == 95)
        {
          if(type_empty == 0)
          {
            if(type_size == 0ul)
              return -24;

            tmp_post$2 = type;
            type = type + 1l;
            *tmp_post$2 = (char)46;
            type_size = type_size - 1ul;
          }

          else
            type_empty = 0;
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(buf);
          char *return_value_avahi_escape_label$4;
          return_value_avahi_escape_label$4=avahi_escape_label(buf, return_value_strlen$3, &type, &type_size);
          if(return_value_avahi_escape_label$4 == ((char *)NULL))
            return -24;

          break;
        }

        state = (enum anonymous$4)DOMAIN;
      }
      case DOMAIN:
      {
        if(domain_empty == 0)
        {
          if(domain_size == 0ul)
            return -24;

          tmp_post$5 = domain;
          domain = domain + 1l;
          *tmp_post$5 = (char)46;
          domain_size = domain_size - 1ul;
        }

        else
          domain_empty = 0;
        return_value_strlen$6=strlen(buf);
        return_value_avahi_escape_label$7=avahi_escape_label(buf, return_value_strlen$6, &domain, &domain_size);
        if(return_value_avahi_escape_label$7 == ((char *)NULL))
          return -24;

      }
    }
  }
  return 0;
}

// avahi_service_resolver_event
// file internal.h line 164
enum anonymous$42 avahi_service_resolver_event(struct AvahiClient *client, enum anonymous$12 event, struct DBusMessage *message)
{
  struct AvahiServiceResolver *r = (struct AvahiServiceResolver *)(void *)0;
  struct DBusError error;
  const char *path;
  struct AvahiStringList *strlst = (struct AvahiStringList *)(void *)0;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp$1;
  signed int j;
  signed int interface;
  signed int protocol;
  signed int aprotocol;
  unsigned int flags;
  char *name;
  char *type;
  char *domain;
  char *host;
  char *address;
  unsigned short int port;
  struct DBusMessageIter iter;
  struct DBusMessageIter sub;
  struct AvahiAddress a;
  unsigned int return_value_dbus_message_get_args$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  signed int return_value_dbus_message_iter_get_arg_type$5;
  _Bool tmp_if_expr$7;
  signed int return_value_dbus_message_iter_get_element_type$6;
  signed int return_value_dbus_message_iter_get_arg_type$9;
  char *etxt;
  unsigned int return_value_dbus_message_get_args$10;
  _Bool tmp_if_expr$12;
  unsigned int return_value_dbus_error_is_set$11;
  signed int return_value_avahi_error_dbus_to_number$13;
  if(!(path == ((const char *)NULL)))
  {
    r = client->service_resolvers;
    for( ; !(r == ((struct AvahiServiceResolver *)NULL)); r = r->service_resolvers_next)
    {
      return_value_strcmp$1=strcmp(r->path, path);
      if(return_value_strcmp$1 == 0)
        break;

    }
    if(r == ((struct AvahiServiceResolver *)NULL))
      goto fail;

    switch((signed int)event)
    {
      case AVAHI_RESOLVER_FOUND:
      {
        return_value_dbus_message_get_args$2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)115, &host, (signed int)105, &aprotocol, (signed int)115, &address, (signed int)113, &port, (signed int)0);
        if(return_value_dbus_message_get_args$2 == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        dbus_message_iter_init(message, &iter);
        j = 0;
        for( ; !(j >= 9); j = j + 1)
          dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type$5=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type$5 == 97))
          tmp_if_expr$7 = (_Bool)1;

        else
        {
          return_value_dbus_message_iter_get_element_type$6=dbus_message_iter_get_element_type(&iter);
          tmp_if_expr$7 = return_value_dbus_message_iter_get_element_type$6 != (signed int)97 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$7)
        {
          fprintf(stderr, "Error parsing service resolving message\n");
          goto fail;
        }

        strlst = (struct AvahiStringList *)(void *)0;
        dbus_message_iter_recurse(&iter, &sub);
        do
        {
          struct DBusMessageIter sub2;
          signed int at;
          const unsigned char *k;
          signed int n;
          at=dbus_message_iter_get_arg_type(&sub);
          if(at == 0)
            break;

          /* assertion at == ((int) 'a') */
          assert(at == (signed int)97);
          signed int return_value_dbus_message_iter_get_element_type$8;
          return_value_dbus_message_iter_get_element_type$8=dbus_message_iter_get_element_type(&sub);
          if(!(return_value_dbus_message_iter_get_element_type$8 == 121))
          {
            fprintf(stderr, "Error parsing service resolving message\n");
            goto fail;
          }

          dbus_message_iter_recurse(&sub, &sub2);
          k = (const unsigned char *)(void *)0;
          n = 0;
          dbus_message_iter_get_fixed_array(&sub2, (void *)&k, &n);
          if(n >= 1 && !(k == ((const unsigned char *)NULL)))
            strlst=avahi_string_list_add_arbitrary(strlst, k, (unsigned long int)n);

          dbus_message_iter_next(&sub);
        }
        while((_Bool)1);
        dbus_message_iter_next(&iter);
        return_value_dbus_message_iter_get_arg_type$9=dbus_message_iter_get_arg_type(&iter);
        if(!(return_value_dbus_message_iter_get_arg_type$9 == 117))
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        dbus_message_iter_get_basic(&iter, (void *)&flags);
        /* assertion address */
        assert(address != ((char *)NULL));
        if((signed int)*address == 0)
          address = (char *)(void *)0;

        else
          avahi_address_parse(address, (signed int)aprotocol, &a);
        r->callback(r, (signed int)interface, (signed int)protocol, (enum anonymous$12)AVAHI_RESOLVER_FOUND, name, type, domain, host, address != ((char *)NULL) ? &a : (struct AvahiAddress *)(void *)0, port, strlst, (enum anonymous$13)flags, r->userdata);
      }
      case AVAHI_RESOLVER_FAILURE:
      {
        return_value_dbus_message_get_args$10=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args$10 == 0u)
          tmp_if_expr$12 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$11=dbus_error_is_set(&error);
          tmp_if_expr$12 = return_value_dbus_error_is_set$11 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$12)
        {
          fprintf(stderr, "Failed to parse resolver event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number$13=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(r->client, return_value_avahi_error_dbus_to_number$13);
        r->callback(r, r->interface, r->protocol, event, r->name, r->type, r->domain, (const char *)(void *)0, (const struct AvahiAddress *)(void *)0, (unsigned short int)0, (struct AvahiStringList *)(void *)0, (enum anonymous$13)0, r->userdata);
      }
    }
    return (enum anonymous$42)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    avahi_string_list_free(strlst);
    return (enum anonymous$42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_service_resolver_free
// file lookup.h line 205
signed int avahi_service_resolver_free(struct AvahiServiceResolver *r)
{
  struct AvahiClient *client;
  signed int ret = 0;
  /* assertion r */
  assert(r != ((struct AvahiServiceResolver *)NULL));
  client = r->client;
  signed int return_value_avahi_client_is_connected$1;
  if(!(r->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
    if(!(return_value_avahi_client_is_connected$1 == 0))
      ret=avahi_client_simple_method_call(client, r->path, "org.freedesktop.Avahi.ServiceResolver", "Free");

  }

  do
  {
    struct AvahiServiceResolver **_head = &client->service_resolvers;
    struct AvahiServiceResolver *_item = r;
    /* assertion _item */
    assert(_item != ((struct AvahiServiceResolver *)NULL));
    if(!(_item->service_resolvers_next == ((struct AvahiServiceResolver *)NULL)))
      _item->service_resolvers_next->service_resolvers_prev = _item->service_resolvers_prev;

    if(!(_item->service_resolvers_prev == ((struct AvahiServiceResolver *)NULL)))
      _item->service_resolvers_prev->service_resolvers_next = _item->service_resolvers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->service_resolvers_next;
    }
    _item->service_resolvers_prev = (struct AvahiServiceResolver *)(void *)0;
    _item->service_resolvers_next = _item->service_resolvers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)r->path);
  avahi_free((void *)r->name);
  avahi_free((void *)r->type);
  avahi_free((void *)r->domain);
  avahi_free((void *)r);
  return ret;
}

// avahi_service_resolver_get_client
// file resolver.c line 318
struct AvahiClient * avahi_service_resolver_get_client(struct AvahiServiceResolver *r)
{
  /* assertion r */
  assert(r != ((struct AvahiServiceResolver *)NULL));
  return r->client;
}

// avahi_service_resolver_new
// file resolver.c line 179
struct AvahiServiceResolver * avahi_service_resolver_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *name, const char *type, const char *domain, signed int aprotocol, enum anonymous$44 flags, void (*callback)(struct AvahiServiceResolver *, signed int, signed int, enum anonymous$12, const char *, const char *, const char *, const char *, const struct AvahiAddress *, unsigned short int, struct AvahiStringList *, enum anonymous$13, void *), void *userdata)
{
  struct DBusError error;
  struct AvahiServiceResolver *r = (struct AvahiServiceResolver *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  signed int i_interface;
  signed int i_protocol;
  signed int i_aprotocol;
  unsigned int u_flags;
  char *path;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion type */
  assert(type != ((const char *)NULL));
  if(domain == ((const char *)NULL))
    domain = "";

  if(name == ((const char *)NULL))
    name = "";

  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal$2;
  unsigned int return_value_dbus_message_append_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(return_value_avahi_client_is_connected$1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    return_value_avahi_new_internal$2=avahi_new_internal$link3((unsigned int)1, sizeof(struct AvahiServiceResolver) /*80ul*/ );
    r = (struct AvahiServiceResolver *)return_value_avahi_new_internal$2;
    if(r == ((struct AvahiServiceResolver *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      r->client = client;
      r->callback = callback;
      r->userdata = userdata;
      r->path = (char *)(void *)0;
      r->domain = (char *)(void *)0;
      r->type = r->domain;
      r->name = r->type;
      r->interface = interface;
      r->protocol = protocol;
      do
      {
        struct AvahiServiceResolver **_head = &client->service_resolvers;
        struct AvahiServiceResolver *_item = r;
        /* assertion _item */
        assert(_item != ((struct AvahiServiceResolver *)NULL));
        _item->service_resolvers_next = *_head;
        if(!(_item->service_resolvers_next == ((struct AvahiServiceResolver *)NULL)))
          _item->service_resolvers_next->service_resolvers_prev = _item;

        _item->service_resolvers_prev = (struct AvahiServiceResolver *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      if(!(name == ((const char *)NULL)))
      {
        if(*name == 0)
          goto __CPROVER_DUMP_L7;

        r->name=avahi_strdup(name);
        if(!(r->name == ((char *)NULL)))
          goto __CPROVER_DUMP_L7;

        avahi_client_set_errno(client, -24);
      }

      else
      {

      __CPROVER_DUMP_L7:
        ;
        r->type=avahi_strdup(type);
        if(r->type == ((char *)NULL))
          avahi_client_set_errno(client, -24);

        else
          if(!(domain == ((const char *)NULL)))
          {
            if(*domain == 0)
              goto __CPROVER_DUMP_L9;

            r->domain=avahi_strdup(domain);
            if(!(r->domain == ((char *)NULL)))
              goto __CPROVER_DUMP_L9;

            avahi_client_set_errno(client, -24);
          }

          else
          {

          __CPROVER_DUMP_L9:
            ;
            message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "ServiceResolverNew");
            if(message == ((struct DBusMessage *)NULL))
              avahi_client_set_errno(client, -24);

            else
            {
              i_interface = (signed int)interface;
              i_protocol = (signed int)protocol;
              i_aprotocol = (signed int)aprotocol;
              u_flags = (unsigned int)flags;
              return_value_dbus_message_append_args$3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &name, (signed int)115, &type, (signed int)115, &domain, (signed int)105, &i_aprotocol, (signed int)117, &u_flags, (signed int)0);
              if(return_value_dbus_message_append_args$3 == 0u)
                avahi_client_set_errno(client, -24);

              else
              {
                reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
                if(reply == ((struct DBusMessage *)NULL))
                  tmp_if_expr$5 = (_Bool)1;

                else
                {
                  return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
                  tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$5)
                  avahi_client_set_errno(client, -22);

                else
                {
                  return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
                  if(return_value_dbus_message_get_args$6 == 0u)
                    tmp_if_expr$8 = (_Bool)1;

                  else
                  {
                    return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
                    tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
                  }
                  if(path == ((char *)NULL) || tmp_if_expr$8)
                    avahi_client_set_errno(client, -22);

                  else
                  {
                    r->path=avahi_strdup(path);
                    if(r->path == ((char *)NULL))
                      avahi_client_set_errno(client, -24);

                    else
                    {
                      dbus_message_unref(message);
                      dbus_message_unref(reply);
                      return r;
                    }
                  }
                }
              }
            }
          }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$9;
  return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(r == ((struct AvahiServiceResolver *)NULL)))
    avahi_service_resolver_free(r);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiServiceResolver *)(void *)0;
}

// avahi_service_type_browser_event
// file internal.h line 160
enum anonymous$42 avahi_service_type_browser_event(struct AvahiClient *client, enum anonymous$14 event, struct DBusMessage *message)
{
  struct AvahiServiceTypeBrowser *b = (struct AvahiServiceTypeBrowser *)(void *)0;
  struct DBusError error;
  const char *path;
  char *domain;
  char *type = (char *)(void *)0;
  signed int interface;
  signed int protocol;
  unsigned int flags = (unsigned int)0;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  path=dbus_message_get_path(message);
  signed int return_value_strcmp$1;
  unsigned int return_value_dbus_message_get_args$2;
  _Bool tmp_if_expr$4;
  unsigned int return_value_dbus_error_is_set$3;
  char *etxt;
  unsigned int return_value_dbus_message_get_args$5;
  _Bool tmp_if_expr$7;
  unsigned int return_value_dbus_error_is_set$6;
  signed int return_value_avahi_error_dbus_to_number$8;
  if(!(path == ((const char *)NULL)))
  {
    b = client->service_type_browsers;
    for( ; !(b == ((struct AvahiServiceTypeBrowser *)NULL)); b = b->service_type_browsers_next)
    {
      return_value_strcmp$1=strcmp(b->path, path);
      if(return_value_strcmp$1 == 0)
        break;

    }
    if(b == ((struct AvahiServiceTypeBrowser *)NULL))
      goto fail;

    domain = b->domain;
    interface = b->interface;
    protocol = b->protocol;
    switch((signed int)event)
    {
      case AVAHI_BROWSER_NEW:

      case AVAHI_BROWSER_REMOVE:
      {
        return_value_dbus_message_get_args$2=dbus_message_get_args(message, &error, (signed int)105, &interface, (signed int)105, &protocol, (signed int)115, &type, (signed int)115, &domain, (signed int)117, &flags, (signed int)0);
        if(return_value_dbus_message_get_args$2 == 0u)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$3=dbus_error_is_set(&error);
          tmp_if_expr$4 = return_value_dbus_error_is_set$3 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        break;
      }
      case AVAHI_BROWSER_CACHE_EXHAUSTED:

      case AVAHI_BROWSER_ALL_FOR_NOW:
        break;
      case AVAHI_BROWSER_FAILURE:
      {
        return_value_dbus_message_get_args$5=dbus_message_get_args(message, &error, (signed int)115, &etxt, (signed int)0);
        if(return_value_dbus_message_get_args$5 == 0u)
          tmp_if_expr$7 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
          tmp_if_expr$7 = return_value_dbus_error_is_set$6 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$7)
        {
          fprintf(stderr, "Failed to parse browser event.\n");
          goto fail;
        }

        return_value_avahi_error_dbus_to_number$8=avahi_error_dbus_to_number(etxt);
        avahi_client_set_errno(b->client, return_value_avahi_error_dbus_to_number$8);
      }
    }
    b->callback(b, (signed int)interface, (signed int)protocol, event, type, domain, (enum anonymous$13)flags, b->userdata);
    return (enum anonymous$42)DBUS_HANDLER_RESULT_HANDLED;
  }

  else
  {

  fail:
    ;
    dbus_error_free(&error);
    return (enum anonymous$42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
  }
}

// avahi_service_type_browser_free
// file lookup.h line 150
signed int avahi_service_type_browser_free(struct AvahiServiceTypeBrowser *b)
{
  struct AvahiClient *client;
  signed int r = 0;
  /* assertion b */
  assert(b != ((struct AvahiServiceTypeBrowser *)NULL));
  client = b->client;
  signed int return_value_avahi_client_is_connected$1;
  if(!(b->path == ((char *)NULL)))
  {
    return_value_avahi_client_is_connected$1=avahi_client_is_connected(b->client);
    if(!(return_value_avahi_client_is_connected$1 == 0))
      r=avahi_client_simple_method_call(client, b->path, "org.freedesktop.Avahi.ServiceTypeBrowser", "Free");

  }

  do
  {
    struct AvahiServiceTypeBrowser **_head = &b->client->service_type_browsers;
    struct AvahiServiceTypeBrowser *_item = b;
    /* assertion _item */
    assert(_item != ((struct AvahiServiceTypeBrowser *)NULL));
    if(!(_item->service_type_browsers_next == ((struct AvahiServiceTypeBrowser *)NULL)))
      _item->service_type_browsers_next->service_type_browsers_prev = _item->service_type_browsers_prev;

    if(!(_item->service_type_browsers_prev == ((struct AvahiServiceTypeBrowser *)NULL)))
      _item->service_type_browsers_prev->service_type_browsers_next = _item->service_type_browsers_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->service_type_browsers_next;
    }
    _item->service_type_browsers_prev = (struct AvahiServiceTypeBrowser *)(void *)0;
    _item->service_type_browsers_next = _item->service_type_browsers_prev;
  }
  while((_Bool)0);
  avahi_free((void *)b->path);
  avahi_free((void *)b->domain);
  avahi_free((void *)b);
  return r;
}

// avahi_service_type_browser_get_client
// file browser.c line 465
struct AvahiClient * avahi_service_type_browser_get_client(struct AvahiServiceTypeBrowser *b)
{
  /* assertion b */
  assert(b != ((struct AvahiServiceTypeBrowser *)NULL));
  return b->client;
}

// avahi_service_type_browser_new
// file browser.c line 350
struct AvahiServiceTypeBrowser * avahi_service_type_browser_new(struct AvahiClient *client, signed int interface, signed int protocol, const char *domain, enum anonymous$44 flags, void (*callback)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous$14, const char *, const char *, enum anonymous$13, void *), void *userdata)
{
  struct AvahiServiceTypeBrowser *b = (struct AvahiServiceTypeBrowser *)(void *)0;
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  char *path;
  signed int i_interface;
  signed int i_protocol;
  unsigned int u_flags;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiServiceTypeBrowser *, signed int, signed int, enum anonymous$14, const char *, const char *, enum anonymous$13, void *))NULL));
  dbus_error_init(&error);
  signed int return_value_avahi_client_is_connected$1;
  return_value_avahi_client_is_connected$1=avahi_client_is_connected(client);
  void *return_value_avahi_new_internal$2;
  unsigned int return_value_dbus_message_append_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  unsigned int return_value_dbus_message_get_args$6;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  if(return_value_avahi_client_is_connected$1 == 0)
    avahi_client_set_errno(client, -2);

  else
  {
    if(domain == ((const char *)NULL))
      domain = "";

    return_value_avahi_new_internal$2=avahi_new_internal$link2((unsigned int)1, sizeof(struct AvahiServiceTypeBrowser) /*64ul*/ );
    b = (struct AvahiServiceTypeBrowser *)return_value_avahi_new_internal$2;
    if(b == ((struct AvahiServiceTypeBrowser *)NULL))
      avahi_client_set_errno(client, -24);

    else
    {
      b->client = client;
      b->callback = callback;
      b->userdata = userdata;
      b->path = (char *)(void *)0;
      b->domain = (char *)(void *)0;
      b->interface = interface;
      b->protocol = protocol;
      do
      {
        struct AvahiServiceTypeBrowser **_head = &client->service_type_browsers;
        struct AvahiServiceTypeBrowser *_item = b;
        /* assertion _item */
        assert(_item != ((struct AvahiServiceTypeBrowser *)NULL));
        _item->service_type_browsers_next = *_head;
        if(!(_item->service_type_browsers_next == ((struct AvahiServiceTypeBrowser *)NULL)))
          _item->service_type_browsers_next->service_type_browsers_prev = _item;

        _item->service_type_browsers_prev = (struct AvahiServiceTypeBrowser *)(void *)0;
        *_head = _item;
      }
      while((_Bool)0);
      if(!(*domain == 0))
      {
        b->domain=avahi_strdup(domain);
        if(!(b->domain == ((char *)NULL)))
          goto __CPROVER_DUMP_L6;

        avahi_client_set_errno(client, -24);
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "ServiceTypeBrowserNew");
        if(message == ((struct DBusMessage *)NULL))
          avahi_client_set_errno(client, -24);

        else
        {
          i_interface = (signed int)interface;
          i_protocol = (signed int)protocol;
          u_flags = (unsigned int)flags;
          return_value_dbus_message_append_args$3=dbus_message_append_args(message, (signed int)105, &i_interface, (signed int)105, &i_protocol, (signed int)115, &domain, (signed int)117, &u_flags, (signed int)0);
          if(return_value_dbus_message_append_args$3 == 0u)
            avahi_client_set_errno(client, -24);

          else
          {
            reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
            if(reply == ((struct DBusMessage *)NULL))
              tmp_if_expr$5 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
              tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$5)
              avahi_client_set_errno(client, -22);

            else
            {
              return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)111, &path, (signed int)0);
              if(return_value_dbus_message_get_args$6 == 0u)
                tmp_if_expr$8 = (_Bool)1;

              else
              {
                return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
                tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
              }
              if(path == ((char *)NULL) || tmp_if_expr$8)
                avahi_client_set_errno(client, -22);

              else
              {
                b->path=avahi_strdup(path);
                if(b->path == ((char *)NULL))
                  avahi_client_set_errno(client, -24);

                else
                {
                  dbus_message_unref(message);
                  dbus_message_unref(reply);
                  return b;
                }
              }
            }
          }
        }
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$9;
  return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$9 == 0u))
  {
    avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(b == ((struct AvahiServiceTypeBrowser *)NULL)))
    avahi_service_type_browser_free(b);

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return (struct AvahiServiceTypeBrowser *)(void *)0;
}

// avahi_set_allocator
// file malloc.c line 196
void avahi_set_allocator(const struct AvahiAllocator *a)
{
  allocator = a;
}

// avahi_simple_poll_dispatch
// file simple-watch.c line 547
signed int avahi_simple_poll_dispatch(struct AvahiSimplePoll$0 *s)
{
  struct AvahiTimeout$1 *next_timeout;
  struct AvahiWatch$1 *w;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  /* assertion s->state == STATE_RAN */
  assert((signed int)s->state == STATE_RAN);
  s->state = (enum anonymous$31)STATE_DISPATCHING;
  next_timeout=find_next_timeout(s);
  if(!(next_timeout == ((struct AvahiTimeout$1 *)NULL)))
  {
    if(next_timeout->expiry.tv_sec == 0l)
    {
      if(next_timeout->expiry.tv_usec == 0l)
      {
        timeout_callback$link1(next_timeout);
        goto finish;
      }

    }

    signed long int return_value_avahi_age$1;
    return_value_avahi_age$1=avahi_age(&next_timeout->expiry);
    if(return_value_avahi_age$1 >= 0l)
    {
      timeout_callback$link1(next_timeout);
      goto finish;
    }

  }

  w = s->watches;
  for( ; !(w == ((struct AvahiWatch$1 *)NULL)); w = w->watches_next)
    if(w->dead == 0)
    {
      /* assertion w->idx >= 0 */
      assert(w->idx >= 0);
      /* assertion w->idx < s->n_pollfds */
      assert(w->idx < s->n_pollfds);
      if(!((signed int)(s->pollfds + (signed long int)w->idx)->revents == 0))
      {
        w->callback(w, w->pollfd.fd, (enum anonymous)(s->pollfds + (signed long int)w->idx)->revents, w->userdata);
        break;
      }

    }


finish:
  ;
  s->state = (enum anonymous$31)STATE_DISPATCHED;
  return 0;
}

// avahi_simple_poll_free
// file simple-watch.c line 367
void avahi_simple_poll_free(struct AvahiSimplePoll$0 *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  cleanup_timeouts(s, 1);
  cleanup_watches(s, 1);
  /* assertion s->n_watches == 0 */
  assert(s->n_watches == 0);
  avahi_free((void *)s->pollfds);
  if(s->wakeup_pipe[0l] >= 0)
    close(s->wakeup_pipe[(signed long int)0]);

  if(s->wakeup_pipe[1l] >= 0)
    close(s->wakeup_pipe[(signed long int)1]);

  avahi_free((void *)s);
}

// avahi_simple_poll_get
// file simple-watch.c line 620
const struct AvahiPoll$1 * avahi_simple_poll_get(struct AvahiSimplePoll$0 *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  return &s->api;
}

// avahi_simple_poll_iterate
// file simple-watch.c line 596
signed int avahi_simple_poll_iterate(struct AvahiSimplePoll$0 *s, signed int timeout)
{
  signed int r;
  r=avahi_simple_poll_prepare(s, timeout);
  if(!(r == 0))
    return r;

  else
  {
    r=avahi_simple_poll_run(s);
    if(!(r == 0))
      return r;

    else
    {
      r=avahi_simple_poll_dispatch(s);
      if(!(r == 0))
        return r;

      else
        return 0;
    }
  }
}

// avahi_simple_poll_loop
// file simple-watch.c line 640
signed int avahi_simple_poll_loop(struct AvahiSimplePoll$0 *s)
{
  signed int r;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    r=avahi_simple_poll_iterate(s, -1);
    if(!(r == 0))
    {
      if(r >= 0)
        tmp_if_expr$2 = (_Bool)1;

      else
      {
        return_value___errno_location$1=__errno_location();
        tmp_if_expr$2 = *return_value___errno_location$1 != 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$2)
        return r;

    }

  }
  while((_Bool)1);
}

// avahi_simple_poll_new
// file simple-watch.c line 318
struct AvahiSimplePoll$0 * avahi_simple_poll_new(void)
{
  struct AvahiSimplePoll$0 *s;
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link2$link1((unsigned int)1, sizeof(struct AvahiSimplePoll$0) /*160ul*/ );
  s = (struct AvahiSimplePoll$0 *)return_value_avahi_new_internal$1;
  if(s == ((struct AvahiSimplePoll$0 *)NULL))
    return (struct AvahiSimplePoll$0 *)(void *)0;

  else
  {
    signed int return_value_pipe$2;
    return_value_pipe$2=pipe(s->wakeup_pipe);
    if(!(return_value_pipe$2 >= 0))
    {
      avahi_free((void *)s);
      return (struct AvahiSimplePoll$0 *)(void *)0;
    }

    else
    {
      set_nonblock(s->wakeup_pipe[(signed long int)0]);
      set_nonblock(s->wakeup_pipe[(signed long int)1]);
      s->api.userdata = (void *)s;
      s->api.watch_new = watch_new;
      s->api.watch_free = watch_free;
      s->api.watch_update = watch_update;
      s->api.watch_get_events = watch_get_events;
      s->api.timeout_new = timeout_new;
      s->api.timeout_free = timeout_free;
      s->api.timeout_update = timeout_update;
      s->pollfds = (struct pollfd *)(void *)0;
      s->n_pollfds = 0;
      s->max_pollfds = s->n_pollfds;
      s->rebuild_pollfds = 1;
      s->quit = 0;
      s->n_watches = 0;
      s->events_valid = 0;
      s->watch_req_cleanup = 0;
      s->timeout_req_cleanup = 0;
      s->prepared_timeout = 0;
      s->state = (enum anonymous$31)STATE_INIT;
      s->wakeup_issued = 0;
      avahi_simple_poll_set_func(s, (signed int (*)(struct pollfd *, unsigned int, signed int, void *))(void *)0, (void *)0);
      do
        s->watches = (struct AvahiWatch$1 *)(void *)0;
      while((_Bool)0);
      do
        s->timeouts = (struct AvahiTimeout$1 *)(void *)0;
      while((_Bool)0);
      return s;
    }
  }
}

// avahi_simple_poll_prepare
// file simple-watch.c line 450
signed int avahi_simple_poll_prepare(struct AvahiSimplePoll$0 *s, signed int timeout)
{
  struct AvahiTimeout$1 *next_timeout;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  _Bool tmp_if_expr$1;
  if((signed int)s->state == STATE_INIT)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)s->state == STATE_DISPATCHED ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)s->state == STATE_FAILURE ? (_Bool)1 : (_Bool)0;
  /* assertion s->state == STATE_INIT || s->state == STATE_DISPATCHED || s->state == STATE_FAILURE */
  assert(tmp_if_expr$2);
  s->state = (enum anonymous$31)STATE_PREPARING;
  clear_wakeup(s);
  if(!(s->watch_req_cleanup == 0))
    cleanup_watches(s, 0);

  if(!(s->timeout_req_cleanup == 0))
    cleanup_timeouts(s, 0);

  signed int return_value_rebuild$3;
  if(!(s->quit == 0))
  {
    s->state = (enum anonymous$31)STATE_QUIT;
    return 1;
  }

  else
    if(!(s->rebuild_pollfds == 0))
    {
      return_value_rebuild$3=rebuild(s);
      if(return_value_rebuild$3 >= 0)
        goto __CPROVER_DUMP_L8;

      s->state = (enum anonymous$31)STATE_FAILURE;
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      next_timeout=find_next_timeout(s);
      if(!(next_timeout == ((struct AvahiTimeout$1 *)NULL)))
      {
        struct timeval now;
        signed int t;
        signed long int usec;
        if(next_timeout->expiry.tv_sec == 0l)
        {
          if(!(next_timeout->expiry.tv_usec == 0l))
            goto __CPROVER_DUMP_L9;

          timeout = 0;
        }

        else
        {

        __CPROVER_DUMP_L9:
          ;
          gettimeofday(&now, (struct timezone *)(void *)0);
          usec=avahi_timeval_diff(&next_timeout->expiry, &now);
          if(!(usec >= 1l))
            timeout = 0;

          else
          {
            t = (signed int)(usec / (signed long int)1000) + 1;
            if(!(t >= timeout) || !(timeout >= 0))
              timeout = t;

          }
        }
      }


    finish:
      ;
      s->prepared_timeout = timeout;
      s->state = (enum anonymous$31)STATE_PREPARED;
      return 0;
    }
}

// avahi_simple_poll_quit
// file simple-watch.c line 611
void avahi_simple_poll_quit(struct AvahiSimplePoll$0 *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  s->quit = 1;
  avahi_simple_poll_wakeup(s);
}

// avahi_simple_poll_run
// file simple-watch.c line 518
signed int avahi_simple_poll_run(struct AvahiSimplePoll$0 *s)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  _Bool tmp_if_expr$1;
  if((signed int)s->state == STATE_PREPARED)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)s->state == STATE_FAILURE ? (_Bool)1 : (_Bool)0;
  /* assertion s->state == STATE_PREPARED || s->state == STATE_FAILURE */
  assert(tmp_if_expr$1);
  s->state = (enum anonymous$31)STATE_RUNNING;
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = 0;
  signed int return_value;
  return_value=s->poll_func(s->pollfds, (unsigned int)s->n_pollfds, s->prepared_timeout, s->poll_func_userdata);
  if(!(return_value >= 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    s->state = (enum anonymous$31)STATE_FAILURE;
    return -1;
  }

  s->events_valid = 1;
  s->state = (enum anonymous$31)STATE_RAN;
  return 0;
}

// avahi_simple_poll_set_func
// file simple-watch.c line 630
void avahi_simple_poll_set_func(struct AvahiSimplePoll$0 *s, signed int (*func)(struct pollfd *, unsigned int, signed int, void *), void *userdata)
{
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  s->poll_func = func != ((signed int (*)(struct pollfd *, unsigned int, signed int, void *))NULL) ? func : system_poll;
  s->poll_func_userdata = func != ((signed int (*)(struct pollfd *, unsigned int, signed int, void *))NULL) ? userdata : (void *)0;
  avahi_simple_poll_wakeup(s);
}

// avahi_simple_poll_wakeup
// file simple-watch.c line 97
void avahi_simple_poll_wakeup(struct AvahiSimplePoll$0 *s)
{
  char c = (char)87;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  write(s->wakeup_pipe[(signed long int)1], (const void *)&c, sizeof(char) /*1ul*/ );
  s->wakeup_issued = 1;
}

// avahi_strdup
// file ../avahi-common/malloc.h line 66
char * avahi_strdup(const char *s)
{
  char *r;
  unsigned long int size;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    size=strlen(s);
    void *return_value_avahi_malloc$1;
    return_value_avahi_malloc$1=avahi_malloc(size + (unsigned long int)1);
    r = (char *)return_value_avahi_malloc$1;
    if(r == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      memcpy((void *)r, (const void *)s, size + (unsigned long int)1);
      return r;
    }
  }
}

// avahi_strdup_printf
// file malloc.c line 235
char * avahi_strdup_printf(const char *fmt, ...)
{
  char *s;
  void **ap;
  /* assertion fmt */
  assert(fmt != ((const char *)NULL));
  ap = (void **)&fmt;
  s=avahi_strdup_vprintf(fmt, ap);
  ap = ((void **)NULL);
  return s;
}

// avahi_strdup_vprintf
// file malloc.c line 200
char * avahi_strdup_vprintf(const char *fmt, void **ap)
{
  unsigned long int len = (unsigned long int)80;
  char *buf;
  /* assertion fmt */
  assert(fmt != ((const char *)NULL));
  void *return_value_avahi_malloc$1;
  return_value_avahi_malloc$1=avahi_malloc(len);
  buf = (char *)return_value_avahi_malloc$1;
  if(buf == ((char *)NULL))
    return (char *)(void *)0;

  else
    do
    {
      signed int n;
      char *nbuf;
      void **ap2 = (void **)ap;
      n=vsnprintf(buf, len, fmt, ap2);
      ap2 = ((void **)NULL);
      if(n >= 0 && !(n >= (signed int)len))
        return buf;

      if(n >= 0)
        len = (unsigned long int)(n + 1);

      else
        len = len * (unsigned long int)2;
      void *return_value_avahi_realloc$2;
      return_value_avahi_realloc$2=avahi_realloc((void *)buf, len);
      nbuf = (char *)return_value_avahi_realloc$2;
      if(nbuf == ((char *)NULL))
      {
        avahi_free((void *)buf);
        return (char *)(void *)0;
      }

      buf = nbuf;
    }
    while((_Bool)1);
}

// avahi_strerror
// file error.c line 27
const char * avahi_strerror(signed int error)
{
  const char * const msg[54l] = { "OK", "Operation failed", "Bad state", "Invalid host name", "Invalid domain name", "No suitable network protocol available", 
    "Invalid DNS TTL", "Resource record key is pattern", "Local name collision", "Invalid record", "Invalid service name", "Invalid service type", "Invalid port number", "Invalid record key", "Invalid address", "Timeout reached", "Too many clients", "Too many objects", "Too many entries", "OS Error", "Access denied", "Invalid operation", "An unexpected D-Bus error occurred", "Daemon connection failed", "Memory exhausted", "The object passed in was not valid", "Daemon not running", "Invalid interface index", "Invalid protocol specification", "Invalid flags", "Not found", "Invalid configuration", "Version mismatch", "Invalid service subtype", "Invalid packet", "Invalid DNS return code", "DNS failure: FORMERR", "DNS failure: SERVFAIL", "DNS failure: NXDOMAIN", "DNS failure: NOTIMP", "DNS failure: REFUSED", "DNS failure: YXDOMAIN", "DNS failure: YXRRSET", "DNS failure: NXRRSET", "DNS failure: NOTAUTH", "DNS failure: NOTZONE", "Invalid RDATA", "Invalid DNS type", "Invalid DNS class", "Not supported", "Not permitted", "Invalid argument", "Is empty", "The requested operation is invalid because redundant" };
  avahi_init_i18n();
  char *return_value_dgettext$1;
  if(-error >= 54 || !(-error >= 0))
  {
    return_value_dgettext$1=dgettext("avahi", "Invalid Error Code");
    return return_value_dgettext$1;
  }

  else
  {
    char *return_value_dgettext$2;
    return_value_dgettext$2=dgettext("avahi", msg[(signed long int)-error]);
    return return_value_dgettext$2;
  }
}

// avahi_string_list_add
// file ../avahi-common/strlst.h line 73
struct AvahiStringList * avahi_string_list_add(struct AvahiStringList *l, const char *text)
{
  /* assertion text */
  assert(text != ((const char *)NULL));
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(text);
  struct AvahiStringList *return_value_avahi_string_list_add_arbitrary$2;
  return_value_avahi_string_list_add_arbitrary$2=avahi_string_list_add_arbitrary(l, (const unsigned char *)text, return_value_strlen$1);
  return return_value_avahi_string_list_add_arbitrary$2;
}

// avahi_string_list_add_anonymous
// file strlst.c line 34
struct AvahiStringList * avahi_string_list_add_anonymous(struct AvahiStringList *l, unsigned long int size)
{
  struct AvahiStringList *n;
  void *return_value_avahi_malloc$1;
  return_value_avahi_malloc$1=avahi_malloc(sizeof(struct AvahiStringList) /*24ul*/  + size);
  n = (struct AvahiStringList *)return_value_avahi_malloc$1;
  if(n == ((struct AvahiStringList *)NULL))
    return (struct AvahiStringList *)(void *)0;

  else
  {
    n->next = l;
    n->size = size;
    n->text[(signed long int)size] = (unsigned char)0;
    return n;
  }
}

// avahi_string_list_add_arbitrary
// file ../avahi-common/strlst.h line 85
struct AvahiStringList * avahi_string_list_add_arbitrary(struct AvahiStringList *l, const unsigned char *text, unsigned long int size)
{
  struct AvahiStringList *n;
  /* assertion size == 0 || text */
  assert(size == (unsigned long int)0 || text != ((const unsigned char *)NULL));
  n=avahi_string_list_add_anonymous(l, size);
  if(n == ((struct AvahiStringList *)NULL))
    return (struct AvahiStringList *)(void *)0;

  else
  {
    if(size >= 1ul)
      memcpy((void *)n->text, (const void *)text, size);

    return n;
  }
}

// avahi_string_list_add_many
// file strlst.c line 255
struct AvahiStringList * avahi_string_list_add_many(struct AvahiStringList *r, ...)
{
  void **va = (void **)&r;
  r=avahi_string_list_add_many_va(r, va);
  va = ((void **)NULL);
  return r;
}

// avahi_string_list_add_many_va
// file strlst.c line 265
struct AvahiStringList * avahi_string_list_add_many_va(struct AvahiStringList *r, __builtin_va_list va)
{
  const char *txt;
  do
  {
    txt=va_arg(va, __typeof__(txt));
    if(txt == ((const char *)NULL))
      break;

    r=avahi_string_list_add(r, txt);
  }
  while((_Bool)1);
  return r;
}

// avahi_string_list_add_pair
// file strlst.c line 395
struct AvahiStringList * avahi_string_list_add_pair(struct AvahiStringList *l, const char *key, const char *value)
{
  /* assertion key */
  assert(key != ((const char *)NULL));
  struct AvahiStringList *return_value_avahi_string_list_add_printf$1;
  struct AvahiStringList *return_value_avahi_string_list_add$2;
  if(!(value == ((const char *)NULL)))
  {
    return_value_avahi_string_list_add_printf$1=avahi_string_list_add_printf(l, "%s=%s", key, value);
    return return_value_avahi_string_list_add_printf$1;
  }

  else
  {
    return_value_avahi_string_list_add$2=avahi_string_list_add(l, key);
    return return_value_avahi_string_list_add$2;
  }
}

// avahi_string_list_add_pair_arbitrary
// file strlst.c line 404
struct AvahiStringList * avahi_string_list_add_pair_arbitrary(struct AvahiStringList *l, const char *key, const unsigned char *value, unsigned long int size)
{
  unsigned long int n;
  /* assertion key */
  assert(key != ((const char *)NULL));
  struct AvahiStringList *return_value_avahi_string_list_add$1;
  if(value == ((const unsigned char *)NULL))
  {
    return_value_avahi_string_list_add$1=avahi_string_list_add(l, key);
    return return_value_avahi_string_list_add$1;
  }

  else
  {
    n=strlen(key);
    l=avahi_string_list_add_anonymous(l, n + (unsigned long int)1 + size);
    if(l == ((struct AvahiStringList *)NULL))
      return (struct AvahiStringList *)(void *)0;

    else
    {
      memcpy((void *)l->text, (const void *)key, n);
      l->text[(signed long int)n] = (unsigned char)61;
      memcpy((void *)(l->text + (signed long int)n + (signed long int)1), (const void *)value, size);
      return l;
    }
  }
}

// avahi_string_list_add_printf
// file strlst.c line 366
struct AvahiStringList * avahi_string_list_add_printf(struct AvahiStringList *l, const char *format, ...)
{
  void **va;
  /* assertion format */
  assert(format != ((const char *)NULL));
  va = (void **)&format;
  l=avahi_string_list_add_vprintf(l, format, va);
  va = ((void **)NULL);
  return l;
}

// avahi_string_list_add_vprintf
// file strlst.c line 326
struct AvahiStringList * avahi_string_list_add_vprintf(struct AvahiStringList *l, const char *format, void **va)
{
  unsigned long int len = (unsigned long int)80;
  struct AvahiStringList *r;
  /* assertion format */
  assert(format != ((const char *)NULL));
  void *return_value_avahi_malloc$1;
  return_value_avahi_malloc$1=avahi_malloc(sizeof(struct AvahiStringList) /*24ul*/  + len);
  r = (struct AvahiStringList *)return_value_avahi_malloc$1;
  if(r == ((struct AvahiStringList *)NULL))
    return (struct AvahiStringList *)(void *)0;

  else
  {
    do
    {
      signed int n;
      struct AvahiStringList *nr;
      void **va2 = (void **)va;
      n=vsnprintf((char *)r->text, len, format, va2);
      va2 = ((void **)NULL);
      if(n >= 0 && !(n >= (signed int)len))
        break;

      if(n >= 0)
        len = (unsigned long int)(n + 1);

      else
        len = len * (unsigned long int)2;
      void *return_value_avahi_realloc$2;
      return_value_avahi_realloc$2=avahi_realloc((void *)r, sizeof(struct AvahiStringList) /*24ul*/  + len);
      nr = (struct AvahiStringList *)return_value_avahi_realloc$2;
      if(nr == ((struct AvahiStringList *)NULL))
      {
        avahi_free((void *)r);
        return (struct AvahiStringList *)(void *)0;
      }

      r = nr;
    }
    while((_Bool)1);
    r->next = l;
    r->size=strlen((char *)r->text);
    return r;
  }
}

// avahi_string_list_copy
// file strlst.c line 293
struct AvahiStringList * avahi_string_list_copy(const struct AvahiStringList *l)
{
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  for( ; !(l == ((const struct AvahiStringList *)NULL)); l = l->next)
  {
    r=avahi_string_list_add_arbitrary(r, l->text, l->size);
    if(r == ((struct AvahiStringList *)NULL))
    {
      avahi_string_list_free(r);
      return (struct AvahiStringList *)(void *)0;
    }

  }
  struct AvahiStringList *return_value_avahi_string_list_reverse$1;
  return_value_avahi_string_list_reverse$1=avahi_string_list_reverse(r);
  return return_value_avahi_string_list_reverse$1;
}

// avahi_string_list_equal
// file strlst.c line 235
signed int avahi_string_list_equal(const struct AvahiStringList *a, const struct AvahiStringList *b)
{
  signed int return_value_memcmp$1;
  while((_Bool)1)
  {
    if(a == ((const struct AvahiStringList *)NULL) && b == ((const struct AvahiStringList *)NULL))
      return 1;

    if(a == ((const struct AvahiStringList *)NULL) || b == ((const struct AvahiStringList *)NULL))
      return 0;

    if(!(a->size == b->size))
      return 0;

    if(!(a->size == 0ul))
    {
      return_value_memcmp$1=memcmp((const void *)a->text, (const void *)b->text, a->size);
      if(!(return_value_memcmp$1 == 0))
        return 0;

    }

    a = a->next;
    b = b->next;
  }
}

// avahi_string_list_find
// file strlst.c line 378
struct AvahiStringList * avahi_string_list_find(struct AvahiStringList *l, const char *key)
{
  unsigned long int n;
  /* assertion key */
  assert(key != ((const char *)NULL));
  n=strlen(key);
  for( ; !(l == ((struct AvahiStringList *)NULL)); l = l->next)
  {
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp((char *)l->text, key);
    if(return_value_strcasecmp$1 == 0)
      return l;

    signed int return_value_strncasecmp$2;
    return_value_strncasecmp$2=strncasecmp((char *)l->text, key, n);
    if(return_value_strncasecmp$2 == 0)
    {
      if((signed int)l->text[(signed long int)n] == 61)
        return l;

    }

  }
  return (struct AvahiStringList *)(void *)0;
}

// avahi_string_list_free
// file ../avahi-common/strlst.h line 64
void avahi_string_list_free(struct AvahiStringList *l)
{
  struct AvahiStringList *n;
  for( ; !(l == ((struct AvahiStringList *)NULL)); l = n)
  {
    n = l->next;
    avahi_free((void *)l);
  }
}

// avahi_string_list_get_next
// file strlst.c line 469
struct AvahiStringList * avahi_string_list_get_next(struct AvahiStringList *l)
{
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  return l->next;
}

// avahi_string_list_get_pair
// file ../avahi-common/strlst.h line 160
signed int avahi_string_list_get_pair(struct AvahiStringList *l, char **key, char **value, unsigned long int *size)
{
  char *e;
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  void *return_value_memchr$2;
  return_value_memchr$2=memchr((const void *)l->text, 61, l->size);
  e = (char *)return_value_memchr$2;
  if(e == ((char *)NULL))
  {
    if(!(key == ((char **)NULL)))
    {
      *key=avahi_strdup((char *)l->text);
      if(*key == ((char *)NULL))
        return -1;

    }

    if(!(value == ((char **)NULL)))
      *value = (char *)(void *)0;

    if(!(size == ((unsigned long int *)NULL)))
      *size = (unsigned long int)0;

  }

  else
  {
    unsigned long int n;
    if(!(key == ((char **)NULL)))
    {
      *key=avahi_strndup((char *)l->text, (unsigned long int)(e - (char *)l->text));
      if(*key == ((char *)NULL))
        return -1;

    }

    e = e + 1l;
    n = l->size - (unsigned long int)(e - (char *)l->text);
    if(!(value == ((char **)NULL)))
    {
      void *return_value_avahi_memdup$1;
      return_value_avahi_memdup$1=avahi_memdup((const void *)e, n + (unsigned long int)1);
      *value = (char *)return_value_avahi_memdup$1;
      if(*value == ((char *)NULL))
      {
        if(!(key == ((char **)NULL)))
          avahi_free((void *)*key);

        return -1;
      }

      (*value)[(signed long int)n] = (char)0;
    }

    if(!(size == ((unsigned long int *)NULL)))
      *size = n;

  }
  return 0;
}

// avahi_string_list_get_service_cookie
// file strlst.c line 484
unsigned int avahi_string_list_get_service_cookie(struct AvahiStringList *l)
{
  struct AvahiStringList *f;
  char *value = (char *)(void *)0;
  char *end = (char *)(void *)0;
  unsigned int ret;
  f=avahi_string_list_find(l, "org.freedesktop.Avahi.cookie");
  if(f == ((struct AvahiStringList *)NULL))
    return (unsigned int)0;

  else
  {
    signed int return_value_avahi_string_list_get_pair$1;
    return_value_avahi_string_list_get_pair$1=avahi_string_list_get_pair(f, (char **)(void *)0, &value, (unsigned long int *)(void *)0);
    if(value == ((char *)NULL) || !(return_value_avahi_string_list_get_pair$1 >= 0))
      return (unsigned int)0;

    else
    {
      signed long long int return_value_strtoll$2;
      return_value_strtoll$2=strtoll(value, &end, 0);
      ret = (unsigned int)return_value_strtoll$2;
      if(!(*value == 0))
      {
        if(end == ((char *)NULL))
          goto __CPROVER_DUMP_L3;

        if((signed int)*end == 0)
          goto __CPROVER_DUMP_L3;

        avahi_free((void *)value);
        return (unsigned int)0;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        avahi_free((void *)value);
        return ret;
      }
    }
  }
}

// avahi_string_list_get_size
// file strlst.c line 479
unsigned long int avahi_string_list_get_size(struct AvahiStringList *l)
{
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  return l->size;
}

// avahi_string_list_get_text
// file strlst.c line 474
unsigned char * avahi_string_list_get_text(struct AvahiStringList *l)
{
  /* assertion l */
  assert(l != ((struct AvahiStringList *)NULL));
  return l->text;
}

// avahi_string_list_length
// file strlst.c line 317
unsigned int avahi_string_list_length(const struct AvahiStringList *l)
{
  unsigned int n = (unsigned int)0;
  for( ; !(l == ((const struct AvahiStringList *)NULL)); l = l->next)
    n = n + 1u;
  return n;
}

// avahi_string_list_new
// file strlst.c line 274
struct AvahiStringList * avahi_string_list_new(const char *txt, ...)
{
  void **va;
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  if(!(txt == ((const char *)NULL)))
  {
    r=avahi_string_list_add(r, txt);
    va = (void **)&txt;
    r=avahi_string_list_add_many_va(r, va);
    va = ((void **)NULL);
  }

  return r;
}

// avahi_string_list_new_from_array
// file strlst.c line 305
struct AvahiStringList * avahi_string_list_new_from_array(const char **array, signed int length)
{
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  signed int i;
  /* assertion array */
  assert(array != ((const char **)NULL));
  i = 0;
  signed int tmp_if_expr$1;
  do
  {
    if(length >= 0)
      tmp_if_expr$1 = (signed int)(i < length);

    else
      tmp_if_expr$1 = (signed int)!(!(array[(signed long int)i] != ((const char *)NULL)));
    if(tmp_if_expr$1 == 0)
      break;

    r=avahi_string_list_add(r, array[(signed long int)i]);
    i = i + 1;
  }
  while((_Bool)1);
  return r;
}

// avahi_string_list_new_va
// file ../avahi-common/strlst.h line 55
struct AvahiStringList * avahi_string_list_new_va(void **va)
{
  struct AvahiStringList *return_value_avahi_string_list_add_many_va$1;
  return_value_avahi_string_list_add_many_va$1=avahi_string_list_add_many_va((struct AvahiStringList *)(void *)0, va);
  return return_value_avahi_string_list_add_many_va$1;
}

// avahi_string_list_parse
// file strlst.c line 69
signed int avahi_string_list_parse(const void *data, unsigned long int size, struct AvahiStringList **ret)
{
  const unsigned char *c;
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  /* assertion data */
  assert(data != NULL);
  /* assertion ret */
  assert(ret != ((struct AvahiStringList **)NULL));
  c = (const unsigned char *)data;
  const unsigned char *tmp_post$1;
  while(size >= 1ul)
  {
    unsigned long int k;
    tmp_post$1 = c;
    c = c + 1l;
    k = (unsigned long int)*tmp_post$1;
    size = size - 1ul;
    if(!(size >= k))
      goto fail;

    if(k >= 1ul)
    {
      struct AvahiStringList *n;
      n=avahi_string_list_add_arbitrary(r, c, k);
      if(n == ((struct AvahiStringList *)NULL))
        goto fail;

      r = n;
    }

    c = c + (signed long int)k;
    size = size - k;
  }
  *ret = r;
  return 0;

fail:
  ;
  avahi_string_list_free(r);
  return -1;
}

// avahi_string_list_reverse
// file ../avahi-common/strlst.h line 130
struct AvahiStringList * avahi_string_list_reverse(struct AvahiStringList *l)
{
  struct AvahiStringList *r = (struct AvahiStringList *)(void *)0;
  struct AvahiStringList *n;
  for( ; !(l == ((struct AvahiStringList *)NULL)); l = n)
  {
    n = l->next;
    l->next = r;
    r = l;
  }
  return r;
}

// avahi_string_list_serialize
// file strlst.c line 168
unsigned long int avahi_string_list_serialize(struct AvahiStringList *l, void *data, unsigned long int size)
{
  unsigned long int used = (unsigned long int)0;
  unsigned char *tmp_post$1;
  if(!(data == NULL))
  {
    struct AvahiStringList *n;
    unsigned char *c;
    l=avahi_string_list_reverse(l);
    c = (unsigned char *)data;
    n = l;
    for( ; size >= 2ul && !(n == ((struct AvahiStringList *)NULL)); n = n->next)
    {
      unsigned long int k = n->size;
      if(!(k == 0ul))
      {
        if(k >= 256ul)
          k = (unsigned long int)255;

        if(!(size + 18446744073709551615ul >= k))
          k = size - (unsigned long int)1;

        tmp_post$1 = c;
        c = c + 1l;
        *tmp_post$1 = (unsigned char)k;
        memcpy((void *)c, (const void *)n->text, k);
        c = c + (signed long int)k;
        used = used + (unsigned long int)1 + k;
        size = size - ((unsigned long int)1 + k);
      }

    }
    l=avahi_string_list_reverse(l);
    if(used == 0ul && size >= 1ul)
    {
      *((unsigned char *)data) = (unsigned char)0;
      used = (unsigned long int)1;
    }

  }

  else
  {
    struct AvahiStringList *avahi_string_list_serialize$$1$$2$$n = l;
    for( ; !(avahi_string_list_serialize$$1$$2$$n == ((struct AvahiStringList *)NULL)); avahi_string_list_serialize$$1$$2$$n = avahi_string_list_serialize$$1$$2$$n->next)
    {
      unsigned long int avahi_string_list_serialize$$1$$2$$1$$1$$k = avahi_string_list_serialize$$1$$2$$n->size;
      if(!(avahi_string_list_serialize$$1$$2$$1$$1$$k == 0ul))
      {
        if(avahi_string_list_serialize$$1$$2$$1$$1$$k >= 256ul)
          avahi_string_list_serialize$$1$$2$$1$$1$$k = (unsigned long int)255;

        used = used + (unsigned long int)1 + avahi_string_list_serialize$$1$$2$$1$$1$$k;
      }

    }
    if(used == 0ul)
      used = (unsigned long int)1;

  }
  return used;
}

// avahi_string_list_to_string
// file strlst.c line 131
char * avahi_string_list_to_string(struct AvahiStringList *l)
{
  struct AvahiStringList *n;
  unsigned long int s = (unsigned long int)0;
  char *t;
  char *e;
  n = l;
  for( ; !(n == ((struct AvahiStringList *)NULL)); n = n->next)
  {
    if(!(n == l))
      s = s + 1ul;

    s = s + n->size + (unsigned long int)2;
  }
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link1$link1((unsigned int)(s + (unsigned long int)1), sizeof(char) /*1ul*/ );
  e = (char *)return_value_avahi_new_internal$1;
  t = e;
  char *tmp_post$2;
  char *tmp_post$3;
  char *tmp_post$4;
  if(t == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    l=avahi_string_list_reverse(l);
    n = l;
    for( ; !(n == ((struct AvahiStringList *)NULL)); n = n->next)
    {
      if(!(n == l))
      {
        tmp_post$2 = e;
        e = e + 1l;
        *tmp_post$2 = (char)32;
      }

      tmp_post$3 = e;
      e = e + 1l;
      *tmp_post$3 = (char)34;
      strncpy(e, (char *)n->text, n->size);
      e[(signed long int)n->size] = (char)0;
      e=strchr(e, 0);
      tmp_post$4 = e;
      e = e + 1l;
      *tmp_post$4 = (char)34;
      /* assertion e */
      assert(e != ((char *)NULL));
    }
    l=avahi_string_list_reverse(l);
    *e = (char)0;
    return t;
  }
}

// avahi_strndup
// file malloc.c line 175
char * avahi_strndup(const char *s, unsigned long int max)
{
  char *r;
  unsigned long int size;
  const char *p;
  _Bool tmp_if_expr$1;
  if(s == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    p = s;
    size = (unsigned long int)0;
    do
    {
      if(!(size >= max))
        tmp_if_expr$1 = *p != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      p = p + 1l;
      size = size + 1ul;
    }
    while((_Bool)1);
    void *return_value_avahi_new_internal$2;
    return_value_avahi_new_internal$2=avahi_new_internal$link5((unsigned int)(size + (unsigned long int)1), sizeof(char) /*1ul*/ );
    r = (char *)return_value_avahi_new_internal$2;
    if(r == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      memcpy((void *)r, (const void *)s, size);
      r[(signed long int)size] = (char)0;
      return r;
    }
  }
}

// avahi_threaded_poll_free
// file thread-watch.c line 107
void avahi_threaded_poll_free(struct AvahiThreadedPoll$0 *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll$0 *)NULL));
  _Bool tmp_if_expr$3;
  unsigned long int return_value_pthread_self$1;
  signed int return_value_pthread_equal$2;
  if(p->thread_running == 0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_pthread_self$1=pthread_self();
    return_value_pthread_equal$2=pthread_equal(return_value_pthread_self$1, p->thread_id);
    tmp_if_expr$3 = !(return_value_pthread_equal$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  /* assertion !p->thread_running || !pthread_equal(pthread_self(), p->thread_id) */
  assert(tmp_if_expr$3);
  if(!(p->thread_running == 0))
    avahi_threaded_poll_stop(p);

  if(!(p->simple_poll == ((struct AvahiSimplePoll$0 *)NULL)))
    avahi_simple_poll_free(p->simple_poll);

  pthread_mutex_destroy(&p->mutex);
  avahi_free((void *)p);
}

// avahi_threaded_poll_get
// file thread-watch.c line 123
const struct AvahiPoll$1 * avahi_threaded_poll_get(struct AvahiThreadedPoll$0 *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll$0 *)NULL));
  const struct AvahiPoll$1 *return_value_avahi_simple_poll_get$1;
  return_value_avahi_simple_poll_get$1=avahi_simple_poll_get(p->simple_poll);
  return return_value_avahi_simple_poll_get$1;
}

// avahi_threaded_poll_lock
// file thread-watch.c line 170
void avahi_threaded_poll_lock(struct AvahiThreadedPoll$0 *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll$0 *)NULL));
  _Bool tmp_if_expr$3;
  unsigned long int return_value_pthread_self$1;
  signed int return_value_pthread_equal$2;
  if(p->thread_running == 0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_pthread_self$1=pthread_self();
    return_value_pthread_equal$2=pthread_equal(return_value_pthread_self$1, p->thread_id);
    tmp_if_expr$3 = !(return_value_pthread_equal$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  /* assertion !p->thread_running || !pthread_equal(pthread_self(), p->thread_id) */
  assert(tmp_if_expr$3);
  pthread_mutex_lock(&p->mutex);
}

// avahi_threaded_poll_new
// file thread-watch.c line 77
struct AvahiThreadedPoll$0 * avahi_threaded_poll_new(void)
{
  struct AvahiThreadedPoll$0 *p;
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link3$link1((unsigned int)1, sizeof(struct AvahiThreadedPoll$0) /*64ul*/ );
  p = (struct AvahiThreadedPoll$0 *)return_value_avahi_new_internal$1;
  if(!(p == ((struct AvahiThreadedPoll$0 *)NULL)))
  {
    p->simple_poll=avahi_simple_poll_new();
    if(p->simple_poll == ((struct AvahiSimplePoll$0 *)NULL))
      goto fail;

    pthread_mutex_init(&p->mutex, (const union anonymous$38 *)(void *)0);
    avahi_simple_poll_set_func(p->simple_poll, poll_func, (void *)&p->mutex);
    p->thread_running = 0;
    return p;
  }

  else
  {

  fail:
    ;
    if(!(p == ((struct AvahiThreadedPoll$0 *)NULL)))
    {
      if(!(p->simple_poll == ((struct AvahiSimplePoll$0 *)NULL)))
      {
        avahi_simple_poll_free(p->simple_poll);
        pthread_mutex_destroy(&p->mutex);
      }

      avahi_free((void *)p);
    }

    return (struct AvahiThreadedPoll$0 *)(void *)0;
  }
}

// avahi_threaded_poll_quit
// file thread-watch.c line 161
void avahi_threaded_poll_quit(struct AvahiThreadedPoll$0 *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll$0 *)NULL));
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  signed int return_value_pthread_equal$2;
  return_value_pthread_equal$2=pthread_equal(return_value_pthread_self$1, p->thread_id);
  /* assertion pthread_equal(pthread_self(), p->thread_id) */
  assert(return_value_pthread_equal$2 != 0);
  avahi_simple_poll_quit(p->simple_poll);
}

// avahi_threaded_poll_start
// file thread-watch.c line 129
signed int avahi_threaded_poll_start(struct AvahiThreadedPoll$0 *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll$0 *)NULL));
  /* assertion !p->thread_running */
  assert(!(p->thread_running != 0));
  signed int return_value_pthread_create$1;
  return_value_pthread_create$1=pthread_create(&p->thread_id, (const union pthread_attr_t *)(void *)0, thread, (void *)p);
  if(!(return_value_pthread_create$1 >= 0))
    return -1;

  else
  {
    p->thread_running = 1;
    return 0;
  }
}

// avahi_threaded_poll_stop
// file thread-watch.c line 142
signed int avahi_threaded_poll_stop(struct AvahiThreadedPoll$0 *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll$0 *)NULL));
  if(p->thread_running == 0)
    return -1;

  else
  {
    unsigned long int return_value_pthread_self$1;
    return_value_pthread_self$1=pthread_self();
    signed int return_value_pthread_equal$2;
    return_value_pthread_equal$2=pthread_equal(return_value_pthread_self$1, p->thread_id);
    /* assertion !pthread_equal(pthread_self(), p->thread_id) */
    assert(!(return_value_pthread_equal$2 != 0));
    pthread_mutex_lock(&p->mutex);
    avahi_simple_poll_quit(p->simple_poll);
    pthread_mutex_unlock(&p->mutex);
    pthread_join(p->thread_id, (void **)(void *)0);
    p->thread_running = 0;
    return p->retval;
  }
}

// avahi_threaded_poll_unlock
// file thread-watch.c line 179
void avahi_threaded_poll_unlock(struct AvahiThreadedPoll$0 *p)
{
  /* assertion p */
  assert(p != ((struct AvahiThreadedPoll$0 *)NULL));
  _Bool tmp_if_expr$3;
  unsigned long int return_value_pthread_self$1;
  signed int return_value_pthread_equal$2;
  if(p->thread_running == 0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    return_value_pthread_self$1=pthread_self();
    return_value_pthread_equal$2=pthread_equal(return_value_pthread_self$1, p->thread_id);
    tmp_if_expr$3 = !(return_value_pthread_equal$2 != 0) ? (_Bool)1 : (_Bool)0;
  }
  /* assertion !p->thread_running || !pthread_equal(pthread_self(), p->thread_id) */
  assert(tmp_if_expr$3);
  pthread_mutex_unlock(&p->mutex);
}

// avahi_timeval_add
// file timeval.c line 59
struct timeval * avahi_timeval_add(struct timeval *a, signed long int usec)
{
  signed long int u;
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  u = usec + a->tv_usec;
  if(!(u >= 0l))
  {
    a->tv_usec = (signed long int)((signed long int)1000000 + u % (signed long int)1000000);
    a->tv_sec = a->tv_sec + (signed long int)((signed long int)-1 + u / (signed long int)1000000);
  }

  else
  {
    a->tv_usec = (signed long int)(u % (signed long int)1000000);
    a->tv_sec = a->tv_sec + (signed long int)(u / (signed long int)1000000);
  }
  return a;
}

// avahi_timeval_compare
// file timeval.c line 30
signed int avahi_timeval_compare(struct timeval *a, struct timeval *b)
{
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  /* assertion b */
  assert(b != ((struct timeval *)NULL));
  if(!(a->tv_sec >= b->tv_sec))
    return -1;

  else
    if(!(b->tv_sec >= a->tv_sec))
      return 1;

    else
      if(!(a->tv_usec >= b->tv_usec))
        return -1;

      else
        if(!(b->tv_usec >= a->tv_usec))
          return 1;

        else
          return 0;
}

// avahi_timeval_diff
// file timeval.c line 49
signed long int avahi_timeval_diff(struct timeval *a, struct timeval *b)
{
  /* assertion a */
  assert(a != ((struct timeval *)NULL));
  /* assertion b */
  assert(b != ((struct timeval *)NULL));
  signed int return_value_avahi_timeval_compare$2;
  return_value_avahi_timeval_compare$2=avahi_timeval_compare(a, b);
  signed long int return_value_avahi_timeval_diff$1;
  if(!(return_value_avahi_timeval_compare$2 >= 0))
  {
    return_value_avahi_timeval_diff$1=avahi_timeval_diff(b, a);
    return -return_value_avahi_timeval_diff$1;
  }

  else
    return (((signed long int)a->tv_sec - b->tv_sec) * (signed long int)1000000 + a->tv_usec) - b->tv_usec;
}

// avahi_unescape_label
// file domain.c line 41
char * avahi_unescape_label(const char **name, char *dest, unsigned long int size)
{
  unsigned int i = (unsigned int)0;
  char *d;
  /* assertion dest */
  assert(dest != ((char *)NULL));
  /* assertion size > 0 */
  assert(size > (unsigned long int)0);
  /* assertion name */
  assert(name != ((const char **)NULL));
  d = dest;
  _Bool tmp_if_expr$8;
  char *tmp_post$1;
  const char *tmp_post$2;
  const unsigned short int **return_value___ctype_b_loc$7;
  _Bool tmp_if_expr$5;
  const unsigned short int **return_value___ctype_b_loc$4;
  char *tmp_post$6;
  char *tmp_post$9;
  const char *tmp_post$10;
  while((_Bool)1)
  {
    if((unsigned long int)i >= size)
      return (char *)(void *)0;

    if((signed int)*(*name) == 46)
    {
      *name = *name + 1l;
      break;
    }

    if((signed int)*(*name) == 0)
      break;

    if((signed int)*(*name) == 92)
    {
      *name = *name + 1l;
      if((signed int)*(*name) == 0)
        return (char *)(void *)0;

      else
      {
        if((signed int)*(*name) == 92)
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = (signed int)*(*name) == 46 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$8)
        {
          tmp_post$1 = d;
          d = d + 1l;
          tmp_post$2 = *name;
          *name = *name + 1l;
          *tmp_post$1 = *tmp_post$2;
          i = i + 1u;
        }

        else
        {
          return_value___ctype_b_loc$7=__ctype_b_loc();
          if(!((2048 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*(*name)]) == 0))
          {
            signed int n;
            const unsigned short int **return_value___ctype_b_loc$3;
            return_value___ctype_b_loc$3=__ctype_b_loc();
            if((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)(*name)[1l]]) == 0)
              tmp_if_expr$5 = (_Bool)1;

            else
            {
              return_value___ctype_b_loc$4=__ctype_b_loc();
              tmp_if_expr$5 = !(((signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)(*name)[(signed long int)2]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$5)
              return (char *)(void *)0;

            n = (signed int)(unsigned char)((signed int)*(*name) - 48) * 100 + (signed int)(unsigned char)((signed int)(*name)[(signed long int)1] - 48) * 10 + (signed int)(unsigned char)((signed int)(*name)[(signed long int)2] - 48);
            if(n == 0 || n >= 256)
              return (char *)(void *)0;

            tmp_post$6 = d;
            d = d + 1l;
            *tmp_post$6 = (char)n;
            i = i + 1u;
            *name = *name + (signed long int)3;
          }

          else
            return (char *)(void *)0;
        }
      }
    }

    else
    {
      tmp_post$9 = d;
      d = d + 1l;
      tmp_post$10 = *name;
      *name = *name + 1l;
      *tmp_post$9 = *tmp_post$10;
      i = i + 1u;
    }
  }
  /* assertion i < size */
  assert((unsigned long int)i < size);
  *d = (char)0;
  const char *return_value_avahi_utf8_valid$11;
  return_value_avahi_utf8_valid$11=avahi_utf8_valid(dest);
  if(return_value_avahi_utf8_valid$11 == ((const char *)NULL))
    return (char *)(void *)0;

  else
    return dest;
}

// avahi_utf8_valid
// file utf8.h line 29
const char * avahi_utf8_valid(const char *str)
{
  unsigned int val = (unsigned int)0;
  unsigned int min = (unsigned int)0;
  const char *p = str;
  for( ; !(*p == 0); p = p + 1l)
  {
    if((signed int)*((const unsigned char *)p) >= 128)
    {
      if((0xe0 & (signed int)*((const unsigned char *)p)) == 0xc0)
      {
        if((0x1e & (signed int)*((const unsigned char *)p)) == 0)
          goto error;

        p = p + 1l;
        if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
          goto error;

      }

      else
      {
        if((0xf0 & (signed int)*((const unsigned char *)p)) == 0xe0)
        {
          min = (unsigned int)(1 << 11);
          val = (unsigned int)((signed int)*((const unsigned char *)p) & 0x0f);
          goto TWO_REMAINING;
        }

        else
          if((0xf8 & (signed int)*((const unsigned char *)p)) == 0xf0)
          {
            min = (unsigned int)(1 << 16);
            val = (unsigned int)((signed int)*((const unsigned char *)p) & 0x07);
          }

          else
            goto error;
        p = p + 1l;
        do
        {
          if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
            goto error;

          val = val << 6;
          val = val | (unsigned int)((signed int)*((const unsigned char *)p) & 0x3f);
        }
        while((_Bool)0);

      TWO_REMAINING:
        ;
        p = p + 1l;
        do
        {
          if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
            goto error;

          val = val << 6;
          val = val | (unsigned int)((signed int)*((const unsigned char *)p) & 0x3f);
        }
        while((_Bool)0);
        p = p + 1l;
        do
        {
          if(!((0xc0 & (signed int)*((const unsigned char *)p)) == 0x80))
            goto error;

          val = val << 6;
          val = val | (unsigned int)((signed int)*((const unsigned char *)p) & 0x3f);
        }
        while((_Bool)0);
        if(!(val >= min))
          goto error;

        if((65534u & val) == 65534u || (0xFFFFF800 & val) == 55296u || val >= 1114112u || !(val >= 65008u) && val >= 64976u)
          goto error;

      }
      goto __CPROVER_DUMP_L13;

    error:
      ;
      return (const char *)(void *)0;
    }


  __CPROVER_DUMP_L13:
    ;
  }
  return str;
}

// avahi_xdg_config_open
// file xdg-config.h line 25
struct _IO_FILE * avahi_xdg_config_open(const char *filename)
{
  struct _IO_FILE *f;
  const char *e;
  const char *d;
  char fn[4096l];
  char *p = (char *)(void *)0;
  char buf[2048l];
  char *s = (char *)(void *)0;
  /* assertion filename */
  assert(filename != ((const char *)NULL));
  e=getenv("XDG_CONFIG_HOME");
  _Bool tmp_if_expr$1;
  if(!(e == ((const char *)NULL)))
    tmp_if_expr$1 = *e != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    p = fn;
    snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", e, filename);
  }

  else
  {
    e=getenv("HOME");
    if(!(e == ((const char *)NULL)))
    {
      if(!(*e == 0))
      {
        p = fn;
        snprintf(p, sizeof(char [4096l]) /*4096ul*/ , "%s/.config/%s", e, filename);
      }

    }

  }
  signed int *return_value___errno_location$2;
  if(!(p == ((char *)NULL)))
  {
    f=fopen(p, "r");
    if(!(f == ((struct _IO_FILE *)NULL)))
      return f;

    else
    {
      return_value___errno_location$2=__errno_location();
      if(!(*return_value___errno_location$2 == 2))
        return (struct _IO_FILE *)(void *)0;

    }
  }

  d=getenv("XDG_CONFIG_DIRS");
  _Bool tmp_if_expr$3;
  if(d == ((const char *)NULL))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = !(*d != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
    d = "/etc/xdg";

  snprintf(buf, sizeof(char [2048l]) /*2048ul*/ , "%s", d);
  e=strtok_r(buf, ":", &s);
  while(!(e == ((const char *)NULL)))
  {
    snprintf(fn, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", e, filename);
    f=fopen(fn, "r");
    if(!(f == ((struct _IO_FILE *)NULL)))
      return f;

    e=strtok_r((char *)(void *)0, ":", &s);
  }
  return (struct _IO_FILE *)(void *)0;
}

// browse_callback
// file avahi-ui.c line 400
static void browse_callback(struct AvahiServiceBrowser *b, signed int interface, signed int protocol, enum anonymous$14 event, const char *name, const char *type, const char *domain, enum anonymous$13 flags, void *userdata)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)userdata, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  char *ifs;
  const char *pretty_type;
  char ifname[16l];
  struct _GtkTreeIter iter;
  struct _GtkTreeSelection *selection;
  char *return_value_if_indextoname$3;
  void *return_value_g_hash_table_lookup$4;
  _Bool tmp_if_expr$10;
  unsigned long int return_value_gtk_tree_view_get_type$11;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  signed int return_value_gtk_tree_selection_get_selected$22;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$21;
  signed int return_value_avahi_domain_equal$18;
  _Bool tmp_if_expr$20;
  signed int return_value_strcasecmp$19;
  struct _GtkTreeIter browse_callback$$1$$1$$2$$iter;
  signed int valid;
  unsigned long int return_value_gtk_tree_model_get_type$23;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  _Bool tmp_if_expr$28;
  signed int return_value_strcasecmp$27;
  _Bool tmp_if_expr$30;
  signed int return_value_avahi_domain_equal$29;
  const char *tmp_if_expr$37;
  char *return_value_dgettext$36;
  switch((signed int)event)
  {
    case AVAHI_BROWSER_NEW:
    {
      pretty_type = (const char *)(void *)0;
      return_value_if_indextoname$3=if_indextoname((unsigned int)interface, ifname);
      if(return_value_if_indextoname$3 == ((char *)NULL))
        g_snprintf(ifname, sizeof(char [16l]) /*16ul*/ , "%i", interface);

      ifs=g_strdup_printf("%s %s", (const void *)ifname, protocol == 0 ? "IPv4" : "IPv6");
      if(!(d->priv->service_type_names == ((struct _GHashTable *)NULL)))
      {
        return_value_g_hash_table_lookup$4=g_hash_table_lookup(d->priv->service_type_names, (const void *)type);
        pretty_type = (const char *)return_value_g_hash_table_lookup$4;
      }

      if(pretty_type == ((const char *)NULL))
        pretty_type=stdb_lookup(type);

      gtk_list_store_append(d->priv->service_list_store, &iter);
      gtk_list_store_set(d->priv->service_list_store, &iter, 0, interface, 1, protocol, 3, name, 2, type, 4, ifs, 5, pretty_type, -1);
      g_free((void *)ifs);
      if(d->priv->common_protocol == -1)
        d->priv->common_protocol = protocol;

      if(d->priv->common_interface == -1)
        d->priv->common_interface = interface;

      if(!(d->priv->common_interface == interface))
        tmp_if_expr$10 = (_Bool)1;

      else
        tmp_if_expr$10 = d->priv->common_protocol != protocol ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$10)
      {
        unsigned long int return_value_gtk_tree_view_get_type$5;
        return_value_gtk_tree_view_get_type$5=gtk_tree_view_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
        return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type$5);
        struct _GtkTreeViewColumn *return_value_gtk_tree_view_get_column$7;
        return_value_gtk_tree_view_get_column$7=gtk_tree_view_get_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$6, 0);
        gtk_tree_view_column_set_visible(return_value_gtk_tree_view_get_column$7, (signed int)!(0 != 0));
        unsigned long int return_value_gtk_tree_view_get_type$8;
        return_value_gtk_tree_view_get_type$8=gtk_tree_view_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
        return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type$8);
        gtk_tree_view_set_headers_visible((struct _GtkTreeView *)return_value_g_type_check_instance_cast$9, (signed int)!(0 != 0));
      }

      return_value_gtk_tree_view_get_type$11=gtk_tree_view_get_type();
      return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type$11);
      selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$12);
      return_value_gtk_tree_selection_get_selected$22=gtk_tree_selection_get_selected(selection, (struct _GtkTreeModel **)(void *)0, (struct _GtkTreeIter *)(void *)0);
      if(return_value_gtk_tree_selection_get_selected$22 == 0)
      {
        if(d->priv->service_type == ((char *)NULL))
          tmp_if_expr$17 = (_Bool)1;

        else
          tmp_if_expr$17 = !(d->priv->service_name != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$17)
          tmp_if_expr$21 = (_Bool)1;

        else
        {
          return_value_avahi_domain_equal$18=avahi_domain_equal(d->priv->service_type, type);
          if(!(return_value_avahi_domain_equal$18 == 0))
          {
            return_value_strcasecmp$19=strcasecmp(d->priv->service_name, name);
            tmp_if_expr$20 = return_value_strcasecmp$19 == 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$20 = (_Bool)0;
          tmp_if_expr$21 = tmp_if_expr$20 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$21)
        {
          struct _GtkTreePath *path;
          gtk_tree_selection_select_iter(selection, &iter);
          unsigned long int return_value_gtk_tree_model_get_type$13;
          return_value_gtk_tree_model_get_type$13=gtk_tree_model_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
          return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_list_store, return_value_gtk_tree_model_get_type$13);
          path=gtk_tree_model_get_path((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$14, &iter);
          unsigned long int return_value_gtk_tree_view_get_type$15;
          return_value_gtk_tree_view_get_type$15=gtk_tree_view_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
          return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type$15);
          gtk_tree_view_set_cursor((struct _GtkTreeView *)return_value_g_type_check_instance_cast$16, path, (struct _GtkTreeViewColumn *)(void *)0, 0);
          gtk_tree_path_free(path);
        }

      }

      goto __CPROVER_DUMP_L30;
    }
    case AVAHI_BROWSER_REMOVE:
    {
      return_value_gtk_tree_model_get_type$23=gtk_tree_model_get_type();
      return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_list_store, return_value_gtk_tree_model_get_type$23);
      valid=gtk_tree_model_get_iter_first((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$24, &browse_callback$$1$$1$$2$$iter);
      while(!(valid == 0))
      {
        signed int _interface;
        signed int _protocol;
        char *_name;
        char *_type;
        signed int found;
        unsigned long int return_value_gtk_tree_model_get_type$25;
        return_value_gtk_tree_model_get_type$25=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
        return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_list_store, return_value_gtk_tree_model_get_type$25);
        gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$26, &browse_callback$$1$$1$$2$$iter, 0, &_interface, 1, &_protocol, 3, &_name, 2, &_type, -1);
        if(_interface == interface && _protocol == protocol)
        {
          return_value_strcasecmp$27=strcasecmp(_name, name);
          tmp_if_expr$28 = return_value_strcasecmp$27 == 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$28 = (_Bool)0;
        if(tmp_if_expr$28)
        {
          return_value_avahi_domain_equal$29=avahi_domain_equal(_type, type);
          tmp_if_expr$30 = return_value_avahi_domain_equal$29 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$30 = (_Bool)0;
        found = (signed int)tmp_if_expr$30;
        g_free((void *)_name);
        if(!(found == 0))
        {
          gtk_list_store_remove(d->priv->service_list_store, &browse_callback$$1$$1$$2$$iter);
          break;
        }

        unsigned long int return_value_gtk_tree_model_get_type$31;
        return_value_gtk_tree_model_get_type$31=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
        return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_list_store, return_value_gtk_tree_model_get_type$31);
        valid=gtk_tree_model_iter_next((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$32, &browse_callback$$1$$1$$2$$iter);
      }
      goto __CPROVER_DUMP_L30;
    }
    case AVAHI_BROWSER_FAILURE:
    {
      struct _GtkWidget *m;
      unsigned long int return_value_gtk_window_get_type$33;
      return_value_gtk_window_get_type$33=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
      return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type$33);
      char *return_value_dgettext$35;
      return_value_dgettext$35=dgettext("avahi", "Browsing for service type %s in domain %s failed: %s");
      if(!(domain == ((const char *)NULL)))
        tmp_if_expr$37 = domain;

      else
      {
        return_value_dgettext$36=dgettext("avahi", "n/a");
        tmp_if_expr$37 = return_value_dgettext$36;
      }
      signed int return_value_avahi_client_errno$38;
      return_value_avahi_client_errno$38=avahi_client_errno(d->priv->client);
      const char *return_value_avahi_strerror$39;
      return_value_avahi_strerror$39=avahi_strerror(return_value_avahi_client_errno$38);
      m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$34, (enum anonymous$30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$29)GTK_MESSAGE_ERROR, (enum anonymous$17)GTK_BUTTONS_CLOSE, return_value_dgettext$35, type, tmp_if_expr$37, return_value_avahi_strerror$39);
      unsigned long int return_value_gtk_dialog_get_type$40;
      return_value_gtk_dialog_get_type$40=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$41;
      return_value_g_type_check_instance_cast$41=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type$40);
      gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$41);
      gtk_widget_destroy(m);
    }
    case AVAHI_BROWSER_ALL_FOR_NOW:
      if(d->priv->service_pulse_timeout >= 1u)
      {
        g_source_remove(d->priv->service_pulse_timeout);
        d->priv->service_pulse_timeout = (unsigned int)0;
        gtk_widget_hide(d->priv->service_progress_bar);
      }

    case AVAHI_BROWSER_CACHE_EXHAUSTED:

    default:

      __CPROVER_DUMP_L30:
        ;
  }
}

// calloc_glue
// file glib-malloc.c line 37
static void * calloc_glue(unsigned long int nmemb, unsigned long int size)
{
  void *return_value_g_malloc0$1;
  return_value_g_malloc0$1=g_malloc0(nmemb * size);
  return return_value_g_malloc0$1;
}

// check_func
// file glib-watch.c line 291
static signed int check_func(struct _GSource *source)
{
  struct AvahiGLibPoll *g = (struct AvahiGLibPoll *)source;
  struct AvahiWatch$0 *w;
  struct AvahiTimeout *next_timeout;
  do
    if(g == ((struct AvahiGLibPoll *)NULL))
      g_assertion_message_expr((char *)0, "glib-watch.c", 296, (const char *)"check_func", "g");

  while((_Bool)0);
  next_timeout=find_next_timeout$link2(g);
  if(!(next_timeout == ((struct AvahiTimeout *)NULL)))
  {
    struct _GTimeVal now;
    struct timeval tvnow;
    g_source_get_current_time(source, &now);
    tvnow.tv_sec = now.tv_sec;
    tvnow.tv_usec = now.tv_usec;
    signed int return_value_avahi_timeval_compare$1;
    return_value_avahi_timeval_compare$1=avahi_timeval_compare(&next_timeout->expiry, &tvnow);
    if(!(return_value_avahi_timeval_compare$1 >= 1))
      return (signed int)!(0 != 0);

  }

  w = g->watches;
  for( ; !(w == ((struct AvahiWatch$0 *)NULL)); w = w->watches_next)
    if((signed int)w->pollfd.revents >= 1)
      return (signed int)!(0 != 0);

  return 0;
}

// check_version
// file client.c line 351
static signed int check_version(struct AvahiClient *client, signed int *ret_error)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  unsigned int version;
  signed int e = -24;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  dbus_error_init(&error);
  message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetAPIVersion");
  _Bool tmp_if_expr$14;
  unsigned int return_value_dbus_error_is_set$13;
  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$2;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  _Bool tmp_if_expr$8;
  unsigned int return_value_dbus_error_is_set$7;
  _Bool tmp_if_expr$12;
  unsigned int return_value_dbus_error_is_set$11;
  if(!(message == ((struct DBusMessage *)NULL)))
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr$14 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$13=dbus_error_is_set(&error);
      tmp_if_expr$14 = return_value_dbus_error_is_set$13 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$14)
    {
      char *version_str;
      unsigned int return_value_dbus_error_is_set$1;
      return_value_dbus_error_is_set$1=dbus_error_is_set(&error);
      if(return_value_dbus_error_is_set$1 == 0u)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value_strcmp$2=strcmp(error.name, "org.freedesktop.DBus.Error.UnknownMethod");
        tmp_if_expr$3 = return_value_strcmp$2 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        goto fail;

      dbus_message_unref(message);
      if(!(reply == ((struct DBusMessage *)NULL)))
        dbus_message_unref(reply);

      dbus_error_free(&error);
      message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetVersionString");
      if(message == ((struct DBusMessage *)NULL))
        goto fail;

      reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
      if(reply == ((struct DBusMessage *)NULL))
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
        tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        goto fail;

      unsigned int return_value_dbus_message_get_args$6;
      return_value_dbus_message_get_args$6=dbus_message_get_args(reply, &error, (signed int)115, &version_str, (signed int)0);
      if(return_value_dbus_message_get_args$6 == 0u)
        tmp_if_expr$8 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$7=dbus_error_is_set(&error);
        tmp_if_expr$8 = return_value_dbus_error_is_set$7 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$8)
        goto fail;

      signed int return_value_strcmp$9;
      return_value_strcmp$9=strcmp(version_str, "avahi 0.6");
      version = (unsigned int)(return_value_strcmp$9 == 0 ? 0x0201 : 0x0000);
    }

    else
    {
      unsigned int return_value_dbus_message_get_args$10;
      return_value_dbus_message_get_args$10=dbus_message_get_args(reply, &error, (signed int)117, &version, (signed int)0);
      if(return_value_dbus_message_get_args$10 == 0u)
        tmp_if_expr$12 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$11=dbus_error_is_set(&error);
        tmp_if_expr$12 = return_value_dbus_error_is_set$11 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$12)
        goto fail;

    }
    if(!((65280u & version) == 512u) || !((255u & version) >= 1u))
    {
      e = -32;
      goto fail;
    }

    dbus_message_unref(message);
    dbus_message_unref(reply);
    return 0;
  }

  else
  {

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$15;
    return_value_dbus_error_is_set$15=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$15 == 0u))
    {
      e=avahi_error_dbus_to_number(error.name);
      dbus_error_free(&error);
    }

    if(!(ret_error == ((signed int *)NULL)))
      *ret_error = e;

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return e;
  }
}

// check_version$link1
// file client.c line 351
static signed int check_version$link1(struct AvahiClient *client$link1, signed int *ret_error$link1)
{
  struct DBusMessage *message$link1 = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply$link1 = (struct DBusMessage *)(void *)0;
  struct DBusError error$link1;
  unsigned int version$link1;
  signed int e$link1 = -24;
  /* assertion client */
  assert(client$link1 != ((struct AvahiClient *)NULL));
  dbus_error_init(&error$link1);
  message$link1=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetAPIVersion");
  _Bool tmp_if_expr$14$link1;
  unsigned int return_value_dbus_error_is_set$13$link1;
  _Bool tmp_if_expr$3$link1;
  signed int return_value_strcmp$2$link1;
  _Bool tmp_if_expr$5$link1;
  unsigned int return_value_dbus_error_is_set$4$link1;
  _Bool tmp_if_expr$8$link1;
  unsigned int return_value_dbus_error_is_set$7$link1;
  _Bool tmp_if_expr$12$link1;
  unsigned int return_value_dbus_error_is_set$11$link1;
  if(!(message$link1 == ((struct DBusMessage *)NULL)))
  {
    reply$link1=dbus_connection_send_with_reply_and_block(client$link1->bus, message$link1, -1, &error$link1);
    if(reply$link1 == ((struct DBusMessage *)NULL))
      tmp_if_expr$14$link1 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$13$link1=dbus_error_is_set(&error$link1);
      tmp_if_expr$14$link1 = return_value_dbus_error_is_set$13$link1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$14$link1)
    {
      char *version_str$link1;
      unsigned int return_value_dbus_error_is_set$1$link1;
      return_value_dbus_error_is_set$1$link1=dbus_error_is_set(&error$link1);
      if(return_value_dbus_error_is_set$1$link1 == 0u)
        tmp_if_expr$3$link1 = (_Bool)1;

      else
      {
        return_value_strcmp$2$link1=strcmp(error$link1.name, "org.freedesktop.DBus.Error.UnknownMethod");
        tmp_if_expr$3$link1 = return_value_strcmp$2$link1 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3$link1)
        goto fail;

      dbus_message_unref(message$link1);
      if(!(reply$link1 == ((struct DBusMessage *)NULL)))
        dbus_message_unref(reply$link1);

      dbus_error_free(&error$link1);
      message$link1=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetVersionString");
      if(message$link1 == ((struct DBusMessage *)NULL))
        goto fail;

      reply$link1=dbus_connection_send_with_reply_and_block(client$link1->bus, message$link1, -1, &error$link1);
      if(reply$link1 == ((struct DBusMessage *)NULL))
        tmp_if_expr$5$link1 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$4$link1=dbus_error_is_set(&error$link1);
        tmp_if_expr$5$link1 = return_value_dbus_error_is_set$4$link1 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5$link1)
        goto fail;

      unsigned int return_value_dbus_message_get_args$6$link1;
      return_value_dbus_message_get_args$6$link1=dbus_message_get_args(reply$link1, &error$link1, (signed int)115, &version_str$link1, (signed int)0);
      if(return_value_dbus_message_get_args$6$link1 == 0u)
        tmp_if_expr$8$link1 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$7$link1=dbus_error_is_set(&error$link1);
        tmp_if_expr$8$link1 = return_value_dbus_error_is_set$7$link1 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$8$link1)
        goto fail;

      signed int return_value_strcmp$9$link1;
      return_value_strcmp$9$link1=strcmp(version_str$link1, "avahi 0.6");
      version$link1 = (unsigned int)(return_value_strcmp$9$link1 == 0 ? 0x0201 : 0x0000);
    }

    else
    {
      unsigned int return_value_dbus_message_get_args$10$link1;
      return_value_dbus_message_get_args$10$link1=dbus_message_get_args(reply$link1, &error$link1, (signed int)117, &version$link1, (signed int)0);
      if(return_value_dbus_message_get_args$10$link1 == 0u)
        tmp_if_expr$12$link1 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$11$link1=dbus_error_is_set(&error$link1);
        tmp_if_expr$12$link1 = return_value_dbus_error_is_set$11$link1 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$12$link1)
        goto fail;

    }
    if(!((65280u & version$link1) == 512u) || !((255u & version$link1) >= 1u))
    {
      e$link1 = -32;
      goto fail;
    }

    dbus_message_unref(message$link1);
    dbus_message_unref(reply$link1);
    return 0;
  }

  else
  {

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$15$link1;
    return_value_dbus_error_is_set$15$link1=dbus_error_is_set(&error$link1);
    if(!(return_value_dbus_error_is_set$15$link1 == 0u))
    {
      e$link1=avahi_error_dbus_to_number(error$link1.name);
      dbus_error_free(&error$link1);
    }

    if(!(ret_error$link1 == ((signed int *)NULL)))
      *ret_error$link1 = e$link1;

    if(!(message$link1 == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message$link1);

    if(!(reply$link1 == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply$link1);

    return e$link1;
  }
}

// cleanup_timeouts
// file simple-watch.c line 304
static void cleanup_timeouts(struct AvahiSimplePoll$0 *s, signed int all)
{
  struct AvahiTimeout$1 *t;
  struct AvahiTimeout$1 *next;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  t = s->timeouts;
  _Bool tmp_if_expr$1;
  for( ; !(t == ((struct AvahiTimeout$1 *)NULL)); t = next)
  {
    next = t->timeouts_next;
    if(!(all == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = t->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      destroy_timeout(t);

  }
  s->timeout_req_cleanup = 0;
}

// cleanup_timeouts$link1
// file simple-watch.c line 304
static void cleanup_timeouts$link1(struct AvahiSimplePoll$0 *s$link1, signed int all$link1)
{
  struct AvahiTimeout$1 *t$link1;
  struct AvahiTimeout$1 *next$link1;
  /* assertion s */
  assert(s$link1 != ((struct AvahiSimplePoll$0 *)NULL));
  t$link1 = s$link1->timeouts;
  _Bool tmp_if_expr$1$link1;
  for( ; !(t$link1 == ((struct AvahiTimeout$1 *)NULL)); t$link1 = next$link1)
  {
    next$link1 = t$link1->timeouts_next;
    if(!(all$link1 == 0))
      tmp_if_expr$1$link1 = (_Bool)1;

    else
      tmp_if_expr$1$link1 = t$link1->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1$link1)
      destroy_timeout$link1(t$link1);

  }
  s$link1->timeout_req_cleanup = 0;
}

// cleanup_timeouts$link1$link1
// file simple-watch.c line 304
static void cleanup_timeouts$link1$link1(struct AvahiSimplePoll *s$link2, signed int all$link1$link1)
{
  struct AvahiTimeout$0 *t$link1$link1;
  struct AvahiTimeout$0 *next$link1$link1;
  /* assertion s */
  assert(s$link2 != ((struct AvahiSimplePoll *)NULL));
  t$link1$link1 = s$link2->timeouts;
  _Bool tmp_if_expr$1$link1$link1;
  for( ; !(t$link1$link1 == ((struct AvahiTimeout$0 *)NULL)); t$link1$link1 = next$link1$link1)
  {
    next$link1$link1 = t$link1$link1->timeouts_next;
    if(!(all$link1$link1 == 0))
      tmp_if_expr$1$link1$link1 = (_Bool)1;

    else
      tmp_if_expr$1$link1$link1 = t$link1$link1->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1$link1$link1)
      destroy_timeout$link1$link1(t$link1$link1);

  }
  s$link2->timeout_req_cleanup = 0;
}

// cleanup_timeouts$link1$link2
// file simple-watch.c line 304
static void cleanup_timeouts$link1$link2(struct AvahiSimplePoll$0 *s$link1$link1, signed int all$link1$link2)
{
  struct AvahiTimeout$1 *t$link1$link2;
  struct AvahiTimeout$1 *next$link1$link2;
  /* assertion s */
  assert(s$link1$link1 != ((struct AvahiSimplePoll$0 *)NULL));
  t$link1$link2 = s$link1$link1->timeouts;
  _Bool tmp_if_expr$1$link1$link2;
  for( ; !(t$link1$link2 == ((struct AvahiTimeout$1 *)NULL)); t$link1$link2 = next$link1$link2)
  {
    next$link1$link2 = t$link1$link2->timeouts_next;
    if(!(all$link1$link2 == 0))
      tmp_if_expr$1$link1$link2 = (_Bool)1;

    else
      tmp_if_expr$1$link1$link2 = t$link1$link2->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1$link1$link2)
      destroy_timeout$link1$link2(t$link1$link2);

  }
  s$link1$link1->timeout_req_cleanup = 0;
}

// cleanup_timeouts$link2
// file glib-watch.c line 216
static void cleanup_timeouts$link2(struct AvahiGLibPoll *g, signed int all$link2)
{
  struct AvahiTimeout *t$link2;
  struct AvahiTimeout *next$link2;
  /* assertion g */
  assert(g != ((struct AvahiGLibPoll *)NULL));
  t$link2 = g->timeouts;
  _Bool tmp_if_expr$1$link2;
  for( ; !(t$link2 == ((struct AvahiTimeout *)NULL)); t$link2 = next$link2)
  {
    next$link2 = t$link2->timeouts_next;
    if(!(all$link2 == 0))
      tmp_if_expr$1$link2 = (_Bool)1;

    else
      tmp_if_expr$1$link2 = t$link2->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1$link2)
      destroy_timeout$link2(t$link2);

  }
  g->timeout_req_cleanup = 0;
}

// cleanup_timeouts$link3
// file simple-watch.c line 304
static void cleanup_timeouts$link3(struct AvahiSimplePoll$0 *s$link3, signed int all$link3)
{
  struct AvahiTimeout$1 *t$link3;
  struct AvahiTimeout$1 *next$link3;
  /* assertion s */
  assert(s$link3 != ((struct AvahiSimplePoll$0 *)NULL));
  t$link3 = s$link3->timeouts;
  _Bool tmp_if_expr$1$link3;
  for( ; !(t$link3 == ((struct AvahiTimeout$1 *)NULL)); t$link3 = next$link3)
  {
    next$link3 = t$link3->timeouts_next;
    if(!(all$link3 == 0))
      tmp_if_expr$1$link3 = (_Bool)1;

    else
      tmp_if_expr$1$link3 = t$link3->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1$link3)
      destroy_timeout$link3(t$link3);

  }
  s$link3->timeout_req_cleanup = 0;
}

// cleanup_watches
// file simple-watch.c line 230
static void cleanup_watches(struct AvahiSimplePoll$0 *s, signed int all)
{
  struct AvahiWatch$1 *w;
  struct AvahiWatch$1 *next;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  w = s->watches;
  _Bool tmp_if_expr$1;
  for( ; !(w == ((struct AvahiWatch$1 *)NULL)); w = next)
  {
    next = w->watches_next;
    if(!(all == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = w->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      destroy_watch(w);

  }
  s->timeout_req_cleanup = 0;
}

// cleanup_watches$link1
// file simple-watch.c line 230
static void cleanup_watches$link1(struct AvahiSimplePoll$0 *s$link1, signed int all$link1)
{
  struct AvahiWatch$1 *w$link1;
  struct AvahiWatch$1 *next$link1;
  /* assertion s */
  assert(s$link1 != ((struct AvahiSimplePoll$0 *)NULL));
  w$link1 = s$link1->watches;
  _Bool tmp_if_expr$1$link1;
  for( ; !(w$link1 == ((struct AvahiWatch$1 *)NULL)); w$link1 = next$link1)
  {
    next$link1 = w$link1->watches_next;
    if(!(all$link1 == 0))
      tmp_if_expr$1$link1 = (_Bool)1;

    else
      tmp_if_expr$1$link1 = w$link1->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1$link1)
      destroy_watch$link1(w$link1);

  }
  s$link1->timeout_req_cleanup = 0;
}

// cleanup_watches$link1$link1
// file simple-watch.c line 230
static void cleanup_watches$link1$link1(struct AvahiSimplePoll *s$link2, signed int all$link1$link1)
{
  struct AvahiWatch *w$link1$link1;
  struct AvahiWatch *next$link1$link1;
  /* assertion s */
  assert(s$link2 != ((struct AvahiSimplePoll *)NULL));
  w$link1$link1 = s$link2->watches;
  _Bool tmp_if_expr$1$link1$link1;
  for( ; !(w$link1$link1 == ((struct AvahiWatch *)NULL)); w$link1$link1 = next$link1$link1)
  {
    next$link1$link1 = w$link1$link1->watches_next;
    if(!(all$link1$link1 == 0))
      tmp_if_expr$1$link1$link1 = (_Bool)1;

    else
      tmp_if_expr$1$link1$link1 = w$link1$link1->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1$link1$link1)
      destroy_watch$link1$link1(w$link1$link1);

  }
  s$link2->timeout_req_cleanup = 0;
}

// cleanup_watches$link1$link2
// file simple-watch.c line 230
static void cleanup_watches$link1$link2(struct AvahiSimplePoll$0 *s$link1$link1, signed int all$link1$link2)
{
  struct AvahiWatch$1 *w$link1$link2;
  struct AvahiWatch$1 *next$link1$link2;
  /* assertion s */
  assert(s$link1$link1 != ((struct AvahiSimplePoll$0 *)NULL));
  w$link1$link2 = s$link1$link1->watches;
  _Bool tmp_if_expr$1$link1$link2;
  for( ; !(w$link1$link2 == ((struct AvahiWatch$1 *)NULL)); w$link1$link2 = next$link1$link2)
  {
    next$link1$link2 = w$link1$link2->watches_next;
    if(!(all$link1$link2 == 0))
      tmp_if_expr$1$link1$link2 = (_Bool)1;

    else
      tmp_if_expr$1$link1$link2 = w$link1$link2->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1$link1$link2)
      destroy_watch$link1$link2(w$link1$link2);

  }
  s$link1$link1->timeout_req_cleanup = 0;
}

// cleanup_watches$link2
// file glib-watch.c line 79
static void cleanup_watches$link2(struct AvahiGLibPoll *g, signed int all$link2)
{
  struct AvahiWatch$0 *w$link2;
  struct AvahiWatch$0 *next$link2;
  /* assertion g */
  assert(g != ((struct AvahiGLibPoll *)NULL));
  w$link2 = g->watches;
  _Bool tmp_if_expr$1$link2;
  for( ; !(w$link2 == ((struct AvahiWatch$0 *)NULL)); w$link2 = next$link2)
  {
    next$link2 = w$link2->watches_next;
    if(!(all$link2 == 0))
      tmp_if_expr$1$link2 = (_Bool)1;

    else
      tmp_if_expr$1$link2 = w$link2->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1$link2)
      destroy_watch$link2(w$link2);

  }
  g->watch_req_cleanup = 0;
}

// cleanup_watches$link3
// file simple-watch.c line 230
static void cleanup_watches$link3(struct AvahiSimplePoll$0 *s$link3, signed int all$link3)
{
  struct AvahiWatch$1 *w$link3;
  struct AvahiWatch$1 *next$link3;
  /* assertion s */
  assert(s$link3 != ((struct AvahiSimplePoll$0 *)NULL));
  w$link3 = s$link3->watches;
  _Bool tmp_if_expr$1$link3;
  for( ; !(w$link3 == ((struct AvahiWatch$1 *)NULL)); w$link3 = next$link3)
  {
    next$link3 = w$link3->watches_next;
    if(!(all$link3 == 0))
      tmp_if_expr$1$link3 = (_Bool)1;

    else
      tmp_if_expr$1$link3 = w$link3->dead != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1$link3)
      destroy_watch$link3(w$link3);

  }
  s$link3->timeout_req_cleanup = 0;
}

// clear_wakeup
// file simple-watch.c line 105
static void clear_wakeup(struct AvahiSimplePoll$0 *s)
{
  char c[10l];
  signed long int return_value_read$1;
  if(!(s->wakeup_issued == 0))
  {
    s->wakeup_issued = 0;
    do
    {
      return_value_read$1=read(s->wakeup_pipe[(signed long int)0], (void *)&c, sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)return_value_read$1 == sizeof(char [10l]) /*10ul*/ ))
        break;

    }
    while((_Bool)1);
  }

}

// clear_wakeup$link1
// file simple-watch.c line 105
static void clear_wakeup$link1(struct AvahiSimplePoll$0 *s$link1)
{
  char c$link1[10l];
  signed long int return_value_read$1$link1;
  if(!(s$link1->wakeup_issued == 0))
  {
    s$link1->wakeup_issued = 0;
    do
    {
      return_value_read$1$link1=read(s$link1->wakeup_pipe[(signed long int)0], (void *)&c$link1, sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)return_value_read$1$link1 == sizeof(char [10l]) /*10ul*/ ))
        break;

    }
    while((_Bool)1);
  }

}

// clear_wakeup$link1$link1
// file simple-watch.c line 105
static void clear_wakeup$link1$link1(struct AvahiSimplePoll$0 *s$link1$link1)
{
  char c$link1$link1[10l];
  signed long int return_value_read$1$link1$link1;
  if(!(s$link1$link1->wakeup_issued == 0))
  {
    s$link1$link1->wakeup_issued = 0;
    do
    {
      return_value_read$1$link1$link1=read(s$link1$link1->wakeup_pipe[(signed long int)0], (void *)&c$link1$link1, sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)return_value_read$1$link1$link1 == sizeof(char [10l]) /*10ul*/ ))
        break;

    }
    while((_Bool)1);
  }

}

// clear_wakeup$link2
// file simple-watch.c line 105
static void clear_wakeup$link2(struct AvahiSimplePoll *s$link2)
{
  char c$link2[10l];
  signed long int return_value_read$1$link2;
  if(!(s$link2->wakeup_issued == 0))
  {
    s$link2->wakeup_issued = 0;
    do
    {
      return_value_read$1$link2=read(s$link2->wakeup_pipe[(signed long int)0], (void *)&c$link2, sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)return_value_read$1$link2 == sizeof(char [10l]) /*10ul*/ ))
        break;

    }
    while((_Bool)1);
  }

}

// clear_wakeup$link3
// file simple-watch.c line 105
static void clear_wakeup$link3(struct AvahiSimplePoll$0 *s$link3)
{
  char c$link3[10l];
  signed long int return_value_read$1$link3;
  if(!(s$link3->wakeup_issued == 0))
  {
    s$link3->wakeup_issued = 0;
    do
    {
      return_value_read$1$link3=read(s$link3->wakeup_pipe[(signed long int)0], (void *)&c$link3, sizeof(char [10l]) /*10ul*/ );
      if(!((unsigned long int)return_value_read$1$link3 == sizeof(char [10l]) /*10ul*/ ))
        break;

    }
    while((_Bool)1);
  }

}

// client_callback
// file avahi-ui.c line 318
static void client_callback(struct AvahiClient *c, enum anonymous$11 state, void *userdata)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)userdata, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  if((signed int)state == AVAHI_CLIENT_FAILURE)
  {
    struct _GtkWidget *m;
    unsigned long int return_value_gtk_window_get_type$3;
    return_value_gtk_window_get_type$3=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type$3);
    char *return_value_dgettext$5;
    return_value_dgettext$5=dgettext("avahi", "Avahi client failure: %s");
    signed int return_value_avahi_client_errno$6;
    return_value_avahi_client_errno$6=avahi_client_errno(c);
    const char *return_value_avahi_strerror$7;
    return_value_avahi_strerror$7=avahi_strerror(return_value_avahi_client_errno$6);
    m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$4, (enum anonymous$30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$29)GTK_MESSAGE_ERROR, (enum anonymous$17)GTK_BUTTONS_CLOSE, return_value_dgettext$5, return_value_avahi_strerror$7);
    unsigned long int return_value_gtk_dialog_get_type$8;
    return_value_gtk_dialog_get_type$8=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type$8);
    gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$9);
    gtk_widget_destroy(m);
    unsigned long int return_value_gtk_dialog_get_type$10;
    return_value_gtk_dialog_get_type$10=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
    return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$10);
    gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$11, -6);
  }

}

// client_set_state
// file client.c line 58
static void client_set_state(struct AvahiClient *client, enum anonymous$11 state)
{
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  if(!(client->state == state))
  {
    client->state = state;
    switch((signed int)client->state)
    {
      case AVAHI_CLIENT_FAILURE:
        if(!(client->bus == ((struct DBusConnection *)NULL)))
        {
          dbus_connection_close(client->bus);
          dbus_connection_unref(client->bus);
          client->bus = (struct DBusConnection *)(void *)0;
        }

      case AVAHI_CLIENT_S_COLLISION:

      case AVAHI_CLIENT_S_REGISTERING:
      {
        avahi_free((void *)client->host_name);
        avahi_free((void *)client->host_name_fqdn);
        avahi_free((void *)client->domain_name);
        client->host_name = (char *)(void *)0;
        client->host_name_fqdn = (char *)(void *)0;
        client->domain_name = (char *)(void *)0;
      }
      case AVAHI_CLIENT_S_RUNNING:

      case AVAHI_CLIENT_CONNECTING:

      default:
        if(!(client->callback == ((void (*)(struct AvahiClient *, enum anonymous$11, void *))NULL)))
          client->callback(client, state, client->userdata);

    }
  }

}

// client_set_state$link1
// file client.c line 58
static void client_set_state$link1(struct AvahiClient *client$link1, enum anonymous$11 state$link1)
{
  /* assertion client */
  assert(client$link1 != ((struct AvahiClient *)NULL));
  if(!(client$link1->state == state$link1))
  {
    client$link1->state = state$link1;
    switch((signed int)client$link1->state)
    {
      case AVAHI_CLIENT_FAILURE:
        if(!(client$link1->bus == ((struct DBusConnection *)NULL)))
        {
          dbus_connection_close(client$link1->bus);
          dbus_connection_unref(client$link1->bus);
          client$link1->bus = (struct DBusConnection *)(void *)0;
        }

      case AVAHI_CLIENT_S_COLLISION:

      case AVAHI_CLIENT_S_REGISTERING:
      {
        avahi_free((void *)client$link1->host_name);
        avahi_free((void *)client$link1->host_name_fqdn);
        avahi_free((void *)client$link1->domain_name);
        client$link1->host_name = (char *)(void *)0;
        client$link1->host_name_fqdn = (char *)(void *)0;
        client$link1->domain_name = (char *)(void *)0;
      }
      case AVAHI_CLIENT_S_RUNNING:

      case AVAHI_CLIENT_CONNECTING:

      default:
        if(!(client$link1->callback == ((void (*)(struct AvahiClient *, enum anonymous$11, void *))NULL)))
          client$link1->callback(client$link1, state$link1, client$link1->userdata);

    }
  }

}

// connection_data_ref
// file ../avahi-common/dbus-watch-glue.c line 68
static struct anonymous$28 * connection_data_ref(struct anonymous$28 *d)
{
  /* assertion d */
  assert(d != ((struct anonymous$28 *)NULL));
  /* assertion d->ref >= 1 */
  assert(d->ref >= 1);
  d->ref = d->ref + 1;
  return d;
}

// connection_data_ref$link1
// file ../avahi-common/dbus-watch-glue.c line 68
static struct anonymous$28 * connection_data_ref$link1(struct anonymous$28 *d$link1)
{
  /* assertion d */
  assert(d$link1 != ((struct anonymous$28 *)NULL));
  /* assertion d->ref >= 1 */
  assert(d$link1->ref >= 1);
  d$link1->ref = d$link1->ref + 1;
  return d$link1;
}

// connection_data_unref
// file ../avahi-common/dbus-watch-glue.c line 76
static void connection_data_unref(struct anonymous$28 *d)
{
  /* assertion d */
  assert(d != ((struct anonymous$28 *)NULL));
  /* assertion d->ref >= 1 */
  assert(d->ref >= 1);
  d->ref = d->ref - 1;
  if(!(d->ref >= 1))
  {
    d->poll_api->timeout_free(d->dispatch_timeout);
    avahi_free((void *)d);
  }

}

// connection_data_unref$link1
// file ../avahi-common/dbus-watch-glue.c line 76
static void connection_data_unref$link1(struct anonymous$28 *d$link1)
{
  /* assertion d */
  assert(d$link1 != ((struct anonymous$28 *)NULL));
  /* assertion d->ref >= 1 */
  assert(d$link1->ref >= 1);
  d$link1->ref = d$link1->ref - 1;
  if(!(d$link1->ref >= 1))
  {
    d$link1->poll_api->timeout_free(d$link1->dispatch_timeout);
    avahi_free((void *)d$link1);
  }

}

// defer_timeout_callback
// file browser.c line 83
static void defer_timeout_callback(struct AvahiTimeout$1 *t, void *userdata)
{
  struct AvahiDomainBrowser *db = (struct AvahiDomainBrowser *)userdata;
  struct AvahiStringList *l;
  /* assertion t */
  assert(t != ((struct AvahiTimeout$1 *)NULL));
  db->client->poll_api->timeout_free(db->defer_timeout);
  db->defer_timeout = (struct AvahiTimeout$1 *)(void *)0;
  domain_browser_ref(db);
  l = db->static_browse_domains;
  if(!(l == ((struct AvahiStringList *)NULL)))
  {
    if(db->ref >= 2)
    {
      db->callback(db, -1, -1, (enum anonymous$14)AVAHI_BROWSER_NEW, (char *)l->text, (enum anonymous$13)AVAHI_LOOKUP_RESULT_STATIC, db->userdata);
      l = l->next;
    }

  }

  avahi_domain_browser_free(db);
}

// defer_timeout_callback$link1
// file browser.c line 83
static void defer_timeout_callback$link1(struct AvahiTimeout$1 *t$link1, void *userdata$link1)
{
  struct AvahiDomainBrowser *db$link1 = (struct AvahiDomainBrowser *)userdata$link1;
  struct AvahiStringList *l$link1;
  /* assertion t */
  assert(t$link1 != ((struct AvahiTimeout$1 *)NULL));
  db$link1->client->poll_api->timeout_free(db$link1->defer_timeout);
  db$link1->defer_timeout = (struct AvahiTimeout$1 *)(void *)0;
  domain_browser_ref$link1(db$link1);
  l$link1 = db$link1->static_browse_domains;
  if(!(l$link1 == ((struct AvahiStringList *)NULL)))
  {
    if(db$link1->ref >= 2)
    {
      db$link1->callback(db$link1, -1, -1, (enum anonymous$14)AVAHI_BROWSER_NEW, (char *)l$link1->text, (enum anonymous$13)AVAHI_LOOKUP_RESULT_STATIC, db$link1->userdata);
      l$link1 = l$link1->next;
    }

  }

  avahi_domain_browser_free(db$link1);
}

// destroy_timeout
// file simple-watch.c line 296
static void destroy_timeout(struct AvahiTimeout$1 *t)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout$1 *)NULL));
  do
  {
    struct AvahiTimeout$1 **_head = &t->simple_poll->timeouts;
    struct AvahiTimeout$1 *_item = t;
    /* assertion _item */
    assert(_item != ((struct AvahiTimeout$1 *)NULL));
    if(!(_item->timeouts_next == ((struct AvahiTimeout$1 *)NULL)))
      _item->timeouts_next->timeouts_prev = _item->timeouts_prev;

    if(!(_item->timeouts_prev == ((struct AvahiTimeout$1 *)NULL)))
      _item->timeouts_prev->timeouts_next = _item->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->timeouts_next;
    }
    _item->timeouts_prev = (struct AvahiTimeout$1 *)(void *)0;
    _item->timeouts_next = _item->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t);
}

// destroy_timeout$link1
// file simple-watch.c line 296
static void destroy_timeout$link1(struct AvahiTimeout$1 *t$link1)
{
  /* assertion t */
  assert(t$link1 != ((struct AvahiTimeout$1 *)NULL));
  do
  {
    struct AvahiTimeout$1 **_head$link1 = &t$link1->simple_poll->timeouts;
    struct AvahiTimeout$1 *_item$link1 = t$link1;
    /* assertion _item */
    assert(_item$link1 != ((struct AvahiTimeout$1 *)NULL));
    if(!(_item$link1->timeouts_next == ((struct AvahiTimeout$1 *)NULL)))
      _item$link1->timeouts_next->timeouts_prev = _item$link1->timeouts_prev;

    if(!(_item$link1->timeouts_prev == ((struct AvahiTimeout$1 *)NULL)))
      _item$link1->timeouts_prev->timeouts_next = _item$link1->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head$link1 == _item$link1);
      *_head$link1 = _item$link1->timeouts_next;
    }
    _item$link1->timeouts_prev = (struct AvahiTimeout$1 *)(void *)0;
    _item$link1->timeouts_next = _item$link1->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t$link1);
}

// destroy_timeout$link1$link1
// file simple-watch.c line 296
static void destroy_timeout$link1$link1(struct AvahiTimeout$0 *t$link1$link1)
{
  /* assertion t */
  assert(t$link1$link1 != ((struct AvahiTimeout$0 *)NULL));
  do
  {
    struct AvahiTimeout$0 **_head$link1$link1 = &t$link1$link1->simple_poll->timeouts;
    struct AvahiTimeout$0 *_item$link1$link1 = t$link1$link1;
    /* assertion _item */
    assert(_item$link1$link1 != ((struct AvahiTimeout$0 *)NULL));
    if(!(_item$link1$link1->timeouts_next == ((struct AvahiTimeout$0 *)NULL)))
      _item$link1$link1->timeouts_next->timeouts_prev = _item$link1$link1->timeouts_prev;

    if(!(_item$link1$link1->timeouts_prev == ((struct AvahiTimeout$0 *)NULL)))
      _item$link1$link1->timeouts_prev->timeouts_next = _item$link1$link1->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head$link1$link1 == _item$link1$link1);
      *_head$link1$link1 = _item$link1$link1->timeouts_next;
    }
    _item$link1$link1->timeouts_prev = (struct AvahiTimeout$0 *)(void *)0;
    _item$link1$link1->timeouts_next = _item$link1$link1->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t$link1$link1);
}

// destroy_timeout$link1$link2
// file simple-watch.c line 296
static void destroy_timeout$link1$link2(struct AvahiTimeout$1 *t$link1$link2)
{
  /* assertion t */
  assert(t$link1$link2 != ((struct AvahiTimeout$1 *)NULL));
  do
  {
    struct AvahiTimeout$1 **_head$link1$link2 = &t$link1$link2->simple_poll->timeouts;
    struct AvahiTimeout$1 *_item$link1$link2 = t$link1$link2;
    /* assertion _item */
    assert(_item$link1$link2 != ((struct AvahiTimeout$1 *)NULL));
    if(!(_item$link1$link2->timeouts_next == ((struct AvahiTimeout$1 *)NULL)))
      _item$link1$link2->timeouts_next->timeouts_prev = _item$link1$link2->timeouts_prev;

    if(!(_item$link1$link2->timeouts_prev == ((struct AvahiTimeout$1 *)NULL)))
      _item$link1$link2->timeouts_prev->timeouts_next = _item$link1$link2->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head$link1$link2 == _item$link1$link2);
      *_head$link1$link2 = _item$link1$link2->timeouts_next;
    }
    _item$link1$link2->timeouts_prev = (struct AvahiTimeout$1 *)(void *)0;
    _item$link1$link2->timeouts_next = _item$link1$link2->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t$link1$link2);
}

// destroy_timeout$link2
// file glib-watch.c line 209
static void destroy_timeout$link2(struct AvahiTimeout *t$link2)
{
  /* assertion t */
  assert(t$link2 != ((struct AvahiTimeout *)NULL));
  do
  {
    struct AvahiTimeout **_head$link2 = &t$link2->glib_poll->timeouts;
    struct AvahiTimeout *_item$link2 = t$link2;
    /* assertion _item */
    assert(_item$link2 != ((struct AvahiTimeout *)NULL));
    if(!(_item$link2->timeouts_next == ((struct AvahiTimeout *)NULL)))
      _item$link2->timeouts_next->timeouts_prev = _item$link2->timeouts_prev;

    if(!(_item$link2->timeouts_prev == ((struct AvahiTimeout *)NULL)))
      _item$link2->timeouts_prev->timeouts_next = _item$link2->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head$link2 == _item$link2);
      *_head$link2 = _item$link2->timeouts_next;
    }
    _item$link2->timeouts_prev = (struct AvahiTimeout *)(void *)0;
    _item$link2->timeouts_next = _item$link2->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t$link2);
}

// destroy_timeout$link3
// file simple-watch.c line 296
static void destroy_timeout$link3(struct AvahiTimeout$1 *t$link3)
{
  /* assertion t */
  assert(t$link3 != ((struct AvahiTimeout$1 *)NULL));
  do
  {
    struct AvahiTimeout$1 **_head$link3 = &t$link3->simple_poll->timeouts;
    struct AvahiTimeout$1 *_item$link3 = t$link3;
    /* assertion _item */
    assert(_item$link3 != ((struct AvahiTimeout$1 *)NULL));
    if(!(_item$link3->timeouts_next == ((struct AvahiTimeout$1 *)NULL)))
      _item$link3->timeouts_next->timeouts_prev = _item$link3->timeouts_prev;

    if(!(_item$link3->timeouts_prev == ((struct AvahiTimeout$1 *)NULL)))
      _item$link3->timeouts_prev->timeouts_next = _item$link3->timeouts_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head$link3 == _item$link3);
      *_head$link3 = _item$link3->timeouts_next;
    }
    _item$link3->timeouts_prev = (struct AvahiTimeout$1 *)(void *)0;
    _item$link3->timeouts_next = _item$link3->timeouts_prev;
  }
  while((_Bool)0);
  avahi_free((void *)t$link3);
}

// destroy_watch
// file simple-watch.c line 218
static void destroy_watch(struct AvahiWatch$1 *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch$1 *)NULL));
  remove_pollfd(w);
  do
  {
    struct AvahiWatch$1 **_head = &w->simple_poll->watches;
    struct AvahiWatch$1 *_item = w;
    /* assertion _item */
    assert(_item != ((struct AvahiWatch$1 *)NULL));
    if(!(_item->watches_next == ((struct AvahiWatch$1 *)NULL)))
      _item->watches_next->watches_prev = _item->watches_prev;

    if(!(_item->watches_prev == ((struct AvahiWatch$1 *)NULL)))
      _item->watches_prev->watches_next = _item->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head == _item);
      *_head = _item->watches_next;
    }
    _item->watches_prev = (struct AvahiWatch$1 *)(void *)0;
    _item->watches_next = _item->watches_prev;
  }
  while((_Bool)0);
  if(w->dead == 0)
    w->simple_poll->n_watches = w->simple_poll->n_watches - 1;

  avahi_free((void *)w);
}

// destroy_watch$link1
// file simple-watch.c line 218
static void destroy_watch$link1(struct AvahiWatch$1 *w$link1)
{
  /* assertion w */
  assert(w$link1 != ((struct AvahiWatch$1 *)NULL));
  remove_pollfd$link1(w$link1);
  do
  {
    struct AvahiWatch$1 **_head$link1 = &w$link1->simple_poll->watches;
    struct AvahiWatch$1 *_item$link1 = w$link1;
    /* assertion _item */
    assert(_item$link1 != ((struct AvahiWatch$1 *)NULL));
    if(!(_item$link1->watches_next == ((struct AvahiWatch$1 *)NULL)))
      _item$link1->watches_next->watches_prev = _item$link1->watches_prev;

    if(!(_item$link1->watches_prev == ((struct AvahiWatch$1 *)NULL)))
      _item$link1->watches_prev->watches_next = _item$link1->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head$link1 == _item$link1);
      *_head$link1 = _item$link1->watches_next;
    }
    _item$link1->watches_prev = (struct AvahiWatch$1 *)(void *)0;
    _item$link1->watches_next = _item$link1->watches_prev;
  }
  while((_Bool)0);
  if(w$link1->dead == 0)
    w$link1->simple_poll->n_watches = w$link1->simple_poll->n_watches - 1;

  avahi_free((void *)w$link1);
}

// destroy_watch$link1$link1
// file simple-watch.c line 218
static void destroy_watch$link1$link1(struct AvahiWatch *w$link1$link1)
{
  /* assertion w */
  assert(w$link1$link1 != ((struct AvahiWatch *)NULL));
  remove_pollfd$link2(w$link1$link1);
  do
  {
    struct AvahiWatch **_head$link1$link1 = &w$link1$link1->simple_poll->watches;
    struct AvahiWatch *_item$link1$link1 = w$link1$link1;
    /* assertion _item */
    assert(_item$link1$link1 != ((struct AvahiWatch *)NULL));
    if(!(_item$link1$link1->watches_next == ((struct AvahiWatch *)NULL)))
      _item$link1$link1->watches_next->watches_prev = _item$link1$link1->watches_prev;

    if(!(_item$link1$link1->watches_prev == ((struct AvahiWatch *)NULL)))
      _item$link1$link1->watches_prev->watches_next = _item$link1$link1->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head$link1$link1 == _item$link1$link1);
      *_head$link1$link1 = _item$link1$link1->watches_next;
    }
    _item$link1$link1->watches_prev = (struct AvahiWatch *)(void *)0;
    _item$link1$link1->watches_next = _item$link1$link1->watches_prev;
  }
  while((_Bool)0);
  if(w$link1$link1->dead == 0)
    w$link1$link1->simple_poll->n_watches = w$link1$link1->simple_poll->n_watches - 1;

  avahi_free((void *)w$link1$link1);
}

// destroy_watch$link1$link2
// file simple-watch.c line 218
static void destroy_watch$link1$link2(struct AvahiWatch$1 *w$link1$link2)
{
  /* assertion w */
  assert(w$link1$link2 != ((struct AvahiWatch$1 *)NULL));
  remove_pollfd$link1$link1(w$link1$link2);
  do
  {
    struct AvahiWatch$1 **_head$link1$link2 = &w$link1$link2->simple_poll->watches;
    struct AvahiWatch$1 *_item$link1$link2 = w$link1$link2;
    /* assertion _item */
    assert(_item$link1$link2 != ((struct AvahiWatch$1 *)NULL));
    if(!(_item$link1$link2->watches_next == ((struct AvahiWatch$1 *)NULL)))
      _item$link1$link2->watches_next->watches_prev = _item$link1$link2->watches_prev;

    if(!(_item$link1$link2->watches_prev == ((struct AvahiWatch$1 *)NULL)))
      _item$link1$link2->watches_prev->watches_next = _item$link1$link2->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head$link1$link2 == _item$link1$link2);
      *_head$link1$link2 = _item$link1$link2->watches_next;
    }
    _item$link1$link2->watches_prev = (struct AvahiWatch$1 *)(void *)0;
    _item$link1$link2->watches_next = _item$link1$link2->watches_prev;
  }
  while((_Bool)0);
  if(w$link1$link2->dead == 0)
    w$link1$link2->simple_poll->n_watches = w$link1$link2->simple_poll->n_watches - 1;

  avahi_free((void *)w$link1$link2);
}

// destroy_watch$link2
// file glib-watch.c line 68
static void destroy_watch$link2(struct AvahiWatch$0 *w$link2)
{
  /* assertion w */
  assert(w$link2 != ((struct AvahiWatch$0 *)NULL));
  if(!(w$link2->pollfd_added == 0))
    g_source_remove_poll(&w$link2->glib_poll->source, &w$link2->pollfd);

  do
  {
    struct AvahiWatch$0 **_head$link2 = &w$link2->glib_poll->watches;
    struct AvahiWatch$0 *_item$link2 = w$link2;
    /* assertion _item */
    assert(_item$link2 != ((struct AvahiWatch$0 *)NULL));
    if(!(_item$link2->watches_next == ((struct AvahiWatch$0 *)NULL)))
      _item$link2->watches_next->watches_prev = _item$link2->watches_prev;

    if(!(_item$link2->watches_prev == ((struct AvahiWatch$0 *)NULL)))
      _item$link2->watches_prev->watches_next = _item$link2->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head$link2 == _item$link2);
      *_head$link2 = _item$link2->watches_next;
    }
    _item$link2->watches_prev = (struct AvahiWatch$0 *)(void *)0;
    _item$link2->watches_next = _item$link2->watches_prev;
  }
  while((_Bool)0);
  avahi_free((void *)w$link2);
}

// destroy_watch$link3
// file simple-watch.c line 218
static void destroy_watch$link3(struct AvahiWatch$1 *w$link3)
{
  /* assertion w */
  assert(w$link3 != ((struct AvahiWatch$1 *)NULL));
  remove_pollfd$link3(w$link3);
  do
  {
    struct AvahiWatch$1 **_head$link3 = &w$link3->simple_poll->watches;
    struct AvahiWatch$1 *_item$link3 = w$link3;
    /* assertion _item */
    assert(_item$link3 != ((struct AvahiWatch$1 *)NULL));
    if(!(_item$link3->watches_next == ((struct AvahiWatch$1 *)NULL)))
      _item$link3->watches_next->watches_prev = _item$link3->watches_prev;

    if(!(_item$link3->watches_prev == ((struct AvahiWatch$1 *)NULL)))
      _item$link3->watches_prev->watches_next = _item$link3->watches_next;

    else
    {
      /* assertion *_head == _item */
      assert(*_head$link3 == _item$link3);
      *_head$link3 = _item$link3->watches_next;
    }
    _item$link3->watches_prev = (struct AvahiWatch$1 *)(void *)0;
    _item$link3->watches_next = _item$link3->watches_prev;
  }
  while((_Bool)0);
  if(w$link3->dead == 0)
    w$link3->simple_poll->n_watches = w$link3->simple_poll->n_watches - 1;

  avahi_free((void *)w$link3);
}

// dispatch_func
// file glib-watch.c line 316
static signed int dispatch_func(struct _GSource *source, signed int (*callback)(void *), void *userdata)
{
  struct AvahiGLibPoll *g = (struct AvahiGLibPoll *)source;
  struct AvahiWatch$0 *w;
  struct AvahiTimeout *next_timeout;
  do
    if(g == ((struct AvahiGLibPoll *)NULL))
      g_assertion_message_expr((char *)0, "glib-watch.c", 321, (const char *)"dispatch_func", "g");

  while((_Bool)0);
  next_timeout=find_next_timeout$link2(g);
  if(!(next_timeout == ((struct AvahiTimeout *)NULL)))
  {
    struct _GTimeVal now;
    struct timeval tvnow;
    g_source_get_current_time(source, &now);
    tvnow.tv_sec = now.tv_sec;
    tvnow.tv_usec = now.tv_usec;
    signed int return_value_avahi_timeval_compare$1;
    return_value_avahi_timeval_compare$1=avahi_timeval_compare(&next_timeout->expiry, &tvnow);
    if(!(return_value_avahi_timeval_compare$1 >= 0))
    {
      start_timeout_callback(next_timeout);
      return (signed int)!(0 != 0);
    }

  }

  w = g->watches;
  for( ; !(w == ((struct AvahiWatch$0 *)NULL)); w = w->watches_next)
    if((signed int)w->pollfd.revents >= 1)
    {
      /* assertion w->callback */
      assert(w->callback != ((void (*)(struct AvahiWatch$0 *, signed int, enum anonymous, void *))NULL));
      enum anonymous return_value_map_events_from_glib$2;
      return_value_map_events_from_glib$2=map_events_from_glib(w->pollfd.revents);
      w->callback(w, w->pollfd.fd, return_value_map_events_from_glib$2, w->userdata);
      w->pollfd.revents = (unsigned short int)0;
      return (signed int)!(0 != 0);
    }

  return (signed int)!(0 != 0);
}

// dispatch_status
// file ../avahi-common/dbus-watch-glue.c line 310
static void dispatch_status(struct DBusConnection *connection, enum anonymous$27 new_status, void *userdata)
{
  struct anonymous$28 *d = (struct anonymous$28 *)userdata;
  if((signed int)new_status == DBUS_DISPATCH_DATA_REMAINS)
    request_dispatch(d, 1);

}

// dispatch_status$link1
// file ../avahi-common/dbus-watch-glue.c line 310
static void dispatch_status$link1(struct DBusConnection *connection$link1, enum anonymous$27 new_status$link1, void *userdata$link1)
{
  struct anonymous$28 *d$link1 = (struct anonymous$28 *)userdata$link1;
  if((signed int)new_status$link1 == DBUS_DISPATCH_DATA_REMAINS)
    request_dispatch$link1(d$link1, 1);

}

// dispatch_timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 97
static void dispatch_timeout_callback(struct AvahiTimeout$1 *t, void *userdata)
{
  struct anonymous$28 *d = (struct anonymous$28 *)userdata;
  /* assertion t */
  assert(t != ((struct AvahiTimeout$1 *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous$28 *)NULL));
  connection_data_ref(d);
  dbus_connection_ref(d->connection);
  enum anonymous$27 return_value_dbus_connection_dispatch$1;
  return_value_dbus_connection_dispatch$1=dbus_connection_dispatch(d->connection);
  if((signed int)return_value_dbus_connection_dispatch$1 == DBUS_DISPATCH_DATA_REMAINS)
    request_dispatch(d, 1);

  else
    request_dispatch(d, 0);
  dbus_connection_unref(d->connection);
  connection_data_unref(d);
}

// dispatch_timeout_callback$link1
// file ../avahi-common/dbus-watch-glue.c line 97
static void dispatch_timeout_callback$link1(struct AvahiTimeout$1 *t$link1, void *userdata$link1)
{
  struct anonymous$28 *d$link1 = (struct anonymous$28 *)userdata$link1;
  /* assertion t */
  assert(t$link1 != ((struct AvahiTimeout$1 *)NULL));
  /* assertion d */
  assert(d$link1 != ((struct anonymous$28 *)NULL));
  connection_data_ref$link1(d$link1);
  dbus_connection_ref(d$link1->connection);
  enum anonymous$27 return_value_dbus_connection_dispatch$1$link1;
  return_value_dbus_connection_dispatch$1$link1=dbus_connection_dispatch(d$link1->connection);
  if((signed int)return_value_dbus_connection_dispatch$1$link1 == DBUS_DISPATCH_DATA_REMAINS)
    request_dispatch$link1(d$link1, 1);

  else
    request_dispatch$link1(d$link1, 0);
  dbus_connection_unref(d$link1->connection);
  connection_data_unref$link1(d$link1);
}

// domain_browse_callback
// file avahi-ui.c line 559
static void domain_browse_callback(struct AvahiDomainBrowser *b, signed int interface, signed int protocol, enum anonymous$14 event, const char *name, enum anonymous$13 flags, void *userdata)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)userdata, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  struct _GtkTreeIter iter;
  signed int found;
  signed int valid;
  signed int ref;
  unsigned long int return_value_gtk_tree_model_get_type$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  signed int domain_browse_callback$$1$$1$$2$$valid;
  struct _GtkTreeIter domain_browse_callback$$1$$1$$2$$iter;
  unsigned long int return_value_gtk_tree_model_get_type$9;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  switch((signed int)event)
  {
    case AVAHI_BROWSER_NEW:
    {
      found = 0;
      return_value_gtk_tree_model_get_type$3=gtk_tree_model_get_type();
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type$3);
      valid=gtk_tree_model_get_iter_first((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$4, &iter);
      while(!(valid == 0))
      {
        char *_name;
        unsigned long int return_value_gtk_tree_model_get_type$5;
        return_value_gtk_tree_model_get_type$5=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
        return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type$5);
        gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$6, &iter, 0, &_name, 1, &ref, -1);
        found=avahi_domain_equal(_name, name);
        g_free((void *)_name);
        if(!(found == 0))
          break;

        unsigned long int return_value_gtk_tree_model_get_type$7;
        return_value_gtk_tree_model_get_type$7=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
        return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type$7);
        valid=gtk_tree_model_iter_next((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$8, &iter);
      }
      if(!(found == 0))
        gtk_list_store_set(d->priv->domain_list_store, &iter, 1, ref + 1, -1);

      else
      {
        gtk_list_store_append(d->priv->domain_list_store, &iter);
        gtk_list_store_set(d->priv->domain_list_store, &iter, 0, name, 1, 1, -1);
      }
      domain_make_default_selection(d, name, &iter);
      goto __CPROVER_DUMP_L15;
    }
    case AVAHI_BROWSER_REMOVE:
    {
      return_value_gtk_tree_model_get_type$9=gtk_tree_model_get_type();
      return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type$9);
      domain_browse_callback$$1$$1$$2$$valid=gtk_tree_model_get_iter_first((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$10, &domain_browse_callback$$1$$1$$2$$iter);
      while(!(domain_browse_callback$$1$$1$$2$$valid == 0))
      {
        signed int domain_browse_callback$$1$$1$$2$$1$$ref;
        char *domain_browse_callback$$1$$1$$2$$1$$_name;
        signed int domain_browse_callback$$1$$1$$2$$1$$found;
        unsigned long int return_value_gtk_tree_model_get_type$11;
        return_value_gtk_tree_model_get_type$11=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
        return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type$11);
        gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$12, &domain_browse_callback$$1$$1$$2$$iter, 0, &domain_browse_callback$$1$$1$$2$$1$$_name, 1, &domain_browse_callback$$1$$1$$2$$1$$ref, -1);
        domain_browse_callback$$1$$1$$2$$1$$found=avahi_domain_equal(domain_browse_callback$$1$$1$$2$$1$$_name, name);
        g_free((void *)domain_browse_callback$$1$$1$$2$$1$$_name);
        if(!(domain_browse_callback$$1$$1$$2$$1$$found == 0))
        {
          if(!(domain_browse_callback$$1$$1$$2$$1$$ref >= 2))
            gtk_list_store_remove(d->priv->service_list_store, &domain_browse_callback$$1$$1$$2$$iter);

          else
            gtk_list_store_set(d->priv->domain_list_store, &domain_browse_callback$$1$$1$$2$$iter, 1, domain_browse_callback$$1$$1$$2$$1$$ref - 1, -1);
          break;
        }

        unsigned long int return_value_gtk_tree_model_get_type$13;
        return_value_gtk_tree_model_get_type$13=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
        return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type$13);
        domain_browse_callback$$1$$1$$2$$valid=gtk_tree_model_iter_next((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$14, &domain_browse_callback$$1$$1$$2$$iter);
      }
      goto __CPROVER_DUMP_L15;
    }
    case AVAHI_BROWSER_FAILURE:
    {
      struct _GtkWidget *m;
      unsigned long int return_value_gtk_window_get_type$15;
      return_value_gtk_window_get_type$15=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
      return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type$15);
      char *return_value_dgettext$17;
      return_value_dgettext$17=dgettext("avahi", "Avahi domain browser failure: %s");
      signed int return_value_avahi_client_errno$18;
      return_value_avahi_client_errno$18=avahi_client_errno(d->priv->client);
      const char *return_value_avahi_strerror$19;
      return_value_avahi_strerror$19=avahi_strerror(return_value_avahi_client_errno$18);
      m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$16, (enum anonymous$30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$29)GTK_MESSAGE_ERROR, (enum anonymous$17)GTK_BUTTONS_CLOSE, return_value_dgettext$17, return_value_avahi_strerror$19);
      unsigned long int return_value_gtk_dialog_get_type$20;
      return_value_gtk_dialog_get_type$20=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
      return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type$20);
      gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$21);
      gtk_widget_destroy(m);
    }
    case AVAHI_BROWSER_ALL_FOR_NOW:
      if(d->priv->domain_pulse_timeout >= 1u)
      {
        g_source_remove(d->priv->domain_pulse_timeout);
        d->priv->domain_pulse_timeout = (unsigned int)0;
        gtk_widget_hide(d->priv->domain_progress_bar);
      }

    case AVAHI_BROWSER_CACHE_EXHAUSTED:

    default:

      __CPROVER_DUMP_L15:
        ;
  }
}

// domain_browser_ref
// file browser.c line 77
static void domain_browser_ref(struct AvahiDomainBrowser *db)
{
  /* assertion db */
  assert(db != ((struct AvahiDomainBrowser *)NULL));
  /* assertion db->ref >= 1 */
  assert(db->ref >= 1);
  db->ref = db->ref + 1;
}

// domain_browser_ref$link1
// file browser.c line 77
static void domain_browser_ref$link1(struct AvahiDomainBrowser *db$link1)
{
  /* assertion db */
  assert(db$link1 != ((struct AvahiDomainBrowser *)NULL));
  /* assertion db->ref >= 1 */
  assert(db$link1->ref >= 1);
  db$link1->ref = db$link1->ref + 1;
}

// domain_button_clicked
// file avahi-ui.c line 959
static void domain_button_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GtkWidget *vbox;
  struct _GtkWidget *vbox2;
  struct _GtkWidget *scrolled_window;
  struct _GtkTreeSelection *selection;
  struct _GtkCellRenderer *renderer;
  struct _GtkTreeViewColumn *column;
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  struct _AuiServiceDialogPrivate *p = d->priv;
  const char *domain;
  struct _GtkTreeIter iter;
  do
    if(!(p->domain_dialog == ((struct _GtkWidget *)NULL)))
    {
      g_return_if_fail_warning((char *)0, (const char *)"domain_button_clicked", "!p->domain_dialog");
      goto __CPROVER_DUMP_L9;
    }

  while((_Bool)0);
  do
    if(!(p->domain_browser == ((struct AvahiDomainBrowser *)NULL)))
    {
      g_return_if_fail_warning((char *)0, (const char *)"domain_button_clicked", "!p->domain_browser");
      goto __CPROVER_DUMP_L9;
    }

  while((_Bool)0);
  domain=get_domain_name(d);
  if(domain == ((const char *)NULL))
  {
    unsigned long int return_value_gtk_dialog_get_type$3;
    return_value_gtk_dialog_get_type$3=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$3);
    gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$4, -6);
    goto __CPROVER_DUMP_L9;
  }

  p->domain_browser=avahi_domain_browser_new(p->client, -1, -1, (const char *)(void *)0, (enum anonymous$43)AVAHI_DOMAIN_BROWSER_BROWSE, (enum anonymous$44)0, domain_browse_callback, (void *)d);
  if(p->domain_browser == ((struct AvahiDomainBrowser *)NULL))
  {
    struct _GtkWidget *m;
    unsigned long int return_value_gtk_window_get_type$5;
    return_value_gtk_window_get_type$5=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type$5);
    char *return_value_dgettext$7;
    return_value_dgettext$7=dgettext("avahi", "Failed to create domain browser: %s");
    signed int return_value_avahi_client_errno$8;
    return_value_avahi_client_errno$8=avahi_client_errno(p->client);
    const char *return_value_avahi_strerror$9;
    return_value_avahi_strerror$9=avahi_strerror(return_value_avahi_client_errno$8);
    m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$6, (enum anonymous$30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$29)GTK_MESSAGE_ERROR, (enum anonymous$17)GTK_BUTTONS_CLOSE, return_value_dgettext$7, return_value_avahi_strerror$9);
    unsigned long int return_value_gtk_dialog_get_type$10;
    return_value_gtk_dialog_get_type$10=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
    return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type$10);
    gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$11);
    gtk_widget_destroy(m);
    unsigned long int return_value_gtk_dialog_get_type$12;
    return_value_gtk_dialog_get_type$12=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$12);
    gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$13, -6);
    goto __CPROVER_DUMP_L9;
  }

  p->domain_dialog=gtk_dialog_new();
  unsigned long int return_value_gtk_container_get_type$14;
  return_value_gtk_container_get_type$14=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_container_get_type$14);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$15, (unsigned int)5);
  unsigned long int return_value_gtk_window_get_type$16;
  return_value_gtk_window_get_type$16=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_window_get_type$16);
  char *return_value_dgettext$18;
  return_value_dgettext$18=dgettext("avahi", "Change domain");
  gtk_window_set_title((struct _GtkWindow *)return_value_g_type_check_instance_cast$17, return_value_dgettext$18);
  vbox=gtk_box_new((enum anonymous$16)GTK_ORIENTATION_VERTICAL, 8);
  unsigned long int return_value_gtk_container_get_type$19;
  return_value_gtk_container_get_type$19=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_container_get_type$19);
  gtk_container_set_border_width((struct _GtkContainer *)return_value_g_type_check_instance_cast$20, (unsigned int)8);
  unsigned long int return_value_gtk_dialog_get_type$21;
  return_value_gtk_dialog_get_type$21=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_dialog_get_type$21);
  struct _GtkWidget *return_value_gtk_dialog_get_content_area$23;
  return_value_gtk_dialog_get_content_area$23=gtk_dialog_get_content_area((struct _GtkDialog *)return_value_g_type_check_instance_cast$22);
  unsigned long int return_value_gtk_box_get_type$24;
  return_value_gtk_box_get_type$24=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
  return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_dialog_get_content_area$23, return_value_gtk_box_get_type$24);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$25, vbox, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  p->domain_entry=gtk_entry_new();
  unsigned long int return_value_gtk_entry_get_type$26;
  return_value_gtk_entry_get_type$26=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
  return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_entry, return_value_gtk_entry_get_type$26);
  gtk_entry_set_max_length((struct _GtkEntry *)return_value_g_type_check_instance_cast$27, 1014);
  unsigned long int return_value_gtk_entry_get_type$28;
  return_value_gtk_entry_get_type$28=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
  return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_entry, return_value_gtk_entry_get_type$28);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$29, domain);
  unsigned long int return_value_gtk_entry_get_type$30;
  return_value_gtk_entry_get_type$30=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$31;
  return_value_g_type_check_instance_cast$31=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_entry, return_value_gtk_entry_get_type$30);
  gtk_entry_set_activates_default((struct _GtkEntry *)return_value_g_type_check_instance_cast$31, (signed int)!(0 != 0));
  g_signal_connect_data((void *)p->domain_entry, "changed", (void (*)(void))domain_entry_changed_callback, (void *)d, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$7)0);
  unsigned long int return_value_gtk_box_get_type$32;
  return_value_gtk_box_get_type$32=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
  return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type$32);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$33, p->domain_entry, 0, 0, (unsigned int)0);
  vbox2=gtk_box_new((enum anonymous$16)GTK_ORIENTATION_VERTICAL, 8);
  unsigned long int return_value_gtk_box_get_type$34;
  return_value_gtk_box_get_type$34=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$35;
  return_value_g_type_check_instance_cast$35=g_type_check_instance_cast((struct _GTypeInstance *)vbox, return_value_gtk_box_get_type$34);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$35, vbox2, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  scrolled_window=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
  unsigned long int return_value_gtk_scrolled_window_get_type$36;
  return_value_gtk_scrolled_window_get_type$36=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$37;
  return_value_g_type_check_instance_cast$37=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type$36);
  gtk_scrolled_window_set_policy((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$37, (enum anonymous$2)GTK_POLICY_AUTOMATIC, (enum anonymous$2)GTK_POLICY_AUTOMATIC);
  unsigned long int return_value_gtk_scrolled_window_get_type$38;
  return_value_gtk_scrolled_window_get_type$38=gtk_scrolled_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$39;
  return_value_g_type_check_instance_cast$39=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_scrolled_window_get_type$38);
  gtk_scrolled_window_set_shadow_type((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$39, (enum anonymous$5)GTK_SHADOW_ETCHED_IN);
  unsigned long int return_value_gtk_box_get_type$40;
  return_value_gtk_box_get_type$40=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$41;
  return_value_g_type_check_instance_cast$41=g_type_check_instance_cast((struct _GTypeInstance *)vbox2, return_value_gtk_box_get_type$40);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$41, scrolled_window, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  p->domain_list_store=gtk_list_store_new(2, (unsigned long int)(16 << 2), (unsigned long int)(6 << 2));
  unsigned long int return_value_gtk_tree_model_get_type$42;
  return_value_gtk_tree_model_get_type$42=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$43;
  return_value_g_type_check_instance_cast$43=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_list_store, return_value_gtk_tree_model_get_type$42);
  p->domain_tree_view=gtk_tree_view_new_with_model((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$43);
  unsigned long int return_value_gtk_tree_view_get_type$44;
  return_value_gtk_tree_view_get_type$44=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$45;
  return_value_g_type_check_instance_cast$45=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_tree_view, return_value_gtk_tree_view_get_type$44);
  gtk_tree_view_set_headers_visible((struct _GtkTreeView *)return_value_g_type_check_instance_cast$45, 0);
  g_signal_connect_data((void *)p->domain_tree_view, "row-activated", (void (*)(void))domain_row_activated_callback, (void *)d, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$7)0);
  unsigned long int return_value_gtk_tree_view_get_type$46;
  return_value_gtk_tree_view_get_type$46=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$47;
  return_value_g_type_check_instance_cast$47=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_tree_view, return_value_gtk_tree_view_get_type$46);
  selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$47);
  gtk_tree_selection_set_mode(selection, (enum anonymous$1)GTK_SELECTION_BROWSE);
  g_signal_connect_data((void *)selection, "changed", (void (*)(void))domain_selection_changed_callback, (void *)d, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$7)0);
  renderer=gtk_cell_renderer_text_new();
  char *return_value_dgettext$48;
  return_value_dgettext$48=dgettext("avahi", "Service Name");
  column=gtk_tree_view_column_new_with_attributes(return_value_dgettext$48, renderer, (const void *)"text", 0, (void *)0);
  gtk_tree_view_column_set_expand(column, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_tree_view_get_type$49;
  return_value_gtk_tree_view_get_type$49=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$50;
  return_value_g_type_check_instance_cast$50=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_tree_view, return_value_gtk_tree_view_get_type$49);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$50, column);
  unsigned long int return_value_gtk_tree_view_get_type$51;
  return_value_gtk_tree_view_get_type$51=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$52;
  return_value_g_type_check_instance_cast$52=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_tree_view, return_value_gtk_tree_view_get_type$51);
  gtk_tree_view_set_search_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$52, 0);
  unsigned long int return_value_gtk_container_get_type$53;
  return_value_gtk_container_get_type$53=gtk_container_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$54;
  return_value_g_type_check_instance_cast$54=g_type_check_instance_cast((struct _GTypeInstance *)scrolled_window, return_value_gtk_container_get_type$53);
  gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$54, p->domain_tree_view);
  p->domain_progress_bar=gtk_progress_bar_new();
  unsigned long int return_value_gtk_progress_bar_get_type$55;
  return_value_gtk_progress_bar_get_type$55=gtk_progress_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$56;
  return_value_g_type_check_instance_cast$56=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_progress_bar, return_value_gtk_progress_bar_get_type$55);
  char *return_value_dgettext$57;
  return_value_dgettext$57=dgettext("avahi", "Browsing...");
  gtk_progress_bar_set_text((struct _GtkProgressBar *)return_value_g_type_check_instance_cast$56, return_value_dgettext$57);
  unsigned long int return_value_gtk_progress_bar_get_type$58;
  return_value_gtk_progress_bar_get_type$58=gtk_progress_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$59;
  return_value_g_type_check_instance_cast$59=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_progress_bar, return_value_gtk_progress_bar_get_type$58);
  gtk_progress_bar_set_pulse_step((struct _GtkProgressBar *)return_value_g_type_check_instance_cast$59, 0.1);
  unsigned long int return_value_gtk_box_get_type$60;
  return_value_gtk_box_get_type$60=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$61;
  return_value_g_type_check_instance_cast$61=g_type_check_instance_cast((struct _GTypeInstance *)vbox2, return_value_gtk_box_get_type$60);
  gtk_box_pack_end((struct _GtkBox *)return_value_g_type_check_instance_cast$61, p->domain_progress_bar, 0, 0, (unsigned int)0);
  unsigned long int return_value_gtk_dialog_get_type$62;
  return_value_gtk_dialog_get_type$62=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$63;
  return_value_g_type_check_instance_cast$63=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_dialog_get_type$62);
  char *return_value_dgettext$64;
  return_value_dgettext$64=dgettext("avahi", "_Cancel");
  gtk_dialog_add_button((struct _GtkDialog *)return_value_g_type_check_instance_cast$63, return_value_dgettext$64, -6);
  unsigned long int return_value_gtk_dialog_get_type$65;
  return_value_gtk_dialog_get_type$65=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$66;
  return_value_g_type_check_instance_cast$66=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_dialog_get_type$65);
  char *return_value_dgettext$67;
  return_value_dgettext$67=dgettext("avahi", "_OK");
  struct _GtkWidget *return_value_gtk_dialog_add_button$68;
  return_value_gtk_dialog_add_button$68=gtk_dialog_add_button((struct _GtkDialog *)return_value_g_type_check_instance_cast$66, return_value_dgettext$67, -3);
  unsigned long int return_value_gtk_widget_get_type$69;
  return_value_gtk_widget_get_type$69=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$70;
  return_value_g_type_check_instance_cast$70=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_dialog_add_button$68, return_value_gtk_widget_get_type$69);
  p->domain_ok_button = (struct _GtkWidget *)return_value_g_type_check_instance_cast$70;
  unsigned long int return_value_gtk_dialog_get_type$71;
  return_value_gtk_dialog_get_type$71=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$72;
  return_value_g_type_check_instance_cast$72=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_dialog_get_type$71);
  gtk_dialog_set_default_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$72, -3);
  unsigned long int return_value_gtk_entry_get_type$73;
  return_value_gtk_entry_get_type$73=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$74;
  return_value_g_type_check_instance_cast$74=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_entry, return_value_gtk_entry_get_type$73);
  const char *return_value_gtk_entry_get_text$75;
  return_value_gtk_entry_get_text$75=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$74);
  signed int return_value_is_valid_domain_suffix$76;
  return_value_is_valid_domain_suffix$76=is_valid_domain_suffix(return_value_gtk_entry_get_text$75);
  gtk_widget_set_sensitive(p->domain_ok_button, return_value_is_valid_domain_suffix$76);
  gtk_widget_grab_default(p->domain_ok_button);
  gtk_widget_grab_focus(p->domain_entry);
  unsigned long int return_value_gtk_window_get_type$77;
  return_value_gtk_window_get_type$77=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$78;
  return_value_g_type_check_instance_cast$78=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_window_get_type$77);
  gtk_window_set_default_size((struct _GtkWindow *)return_value_g_type_check_instance_cast$78, 300, 300);
  gtk_widget_show_all(vbox);
  gtk_list_store_append(p->domain_list_store, &iter);
  gtk_list_store_set(p->domain_list_store, &iter, 0, (const void *)"local", 1, 1, -1);
  domain_make_default_selection(d, "local", &iter);
  p->domain_pulse_timeout=g_timeout_add((unsigned int)100, domain_pulse_callback, (void *)d);
  unsigned long int return_value_gtk_dialog_get_type$82;
  return_value_gtk_dialog_get_type$82=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$83;
  return_value_g_type_check_instance_cast$83=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_dialog, return_value_gtk_dialog_get_type$82);
  signed int return_value_gtk_dialog_run$84;
  return_value_gtk_dialog_run$84=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$83);
  unsigned long int return_value_gtk_entry_get_type$79;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$80;
  const char *return_value_gtk_entry_get_text$81;
  if(return_value_gtk_dialog_run$84 == -3)
  {
    return_value_gtk_entry_get_type$79=gtk_entry_get_type();
    return_value_g_type_check_instance_cast$80=g_type_check_instance_cast((struct _GTypeInstance *)p->domain_entry, return_value_gtk_entry_get_type$79);
    return_value_gtk_entry_get_text$81=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$80);
    aui_service_dialog_set_domain(d, return_value_gtk_entry_get_text$81);
  }

  gtk_widget_destroy(p->domain_dialog);
  p->domain_dialog = (struct _GtkWidget *)(void *)0;
  if(p->domain_pulse_timeout >= 1u)
  {
    g_source_remove(p->domain_pulse_timeout);
    p->domain_pulse_timeout = (unsigned int)0;
  }

  avahi_domain_browser_free(p->domain_browser);
  p->domain_browser = (struct AvahiDomainBrowser *)(void *)0;

__CPROVER_DUMP_L9:
  ;
}

// domain_entry_changed_callback
// file avahi-ui.c line 953
static void domain_entry_changed_callback(struct _GtkEditable *editable, void *user_data)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_entry_get_type$3;
  return_value_gtk_entry_get_type$3=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_entry, return_value_gtk_entry_get_type$3);
  const char *return_value_gtk_entry_get_text$5;
  return_value_gtk_entry_get_text$5=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4);
  signed int return_value_is_valid_domain_suffix$6;
  return_value_is_valid_domain_suffix$6=is_valid_domain_suffix(return_value_gtk_entry_get_text$5);
  gtk_widget_set_sensitive(d->priv->domain_ok_button, return_value_is_valid_domain_suffix$6);
}

// domain_make_default_selection
// file avahi-ui.c line 540
static void domain_make_default_selection(struct _AuiServiceDialog *d, const char *name, struct _GtkTreeIter *iter)
{
  struct _GtkTreeSelection *selection;
  unsigned long int return_value_gtk_tree_view_get_type$1;
  return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_tree_view, return_value_gtk_tree_view_get_type$1);
  selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$2);
  signed int return_value_gtk_tree_selection_get_selected$11;
  return_value_gtk_tree_selection_get_selected$11=gtk_tree_selection_get_selected(selection, (struct _GtkTreeModel **)(void *)0, (struct _GtkTreeIter *)(void *)0);
  if(return_value_gtk_tree_selection_get_selected$11 == 0)
  {
    unsigned long int return_value_gtk_entry_get_type$7;
    return_value_gtk_entry_get_type$7=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_entry, return_value_gtk_entry_get_type$7);
    const char *return_value_gtk_entry_get_text$9;
    return_value_gtk_entry_get_text$9=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$8);
    signed int return_value_avahi_domain_equal$10;
    return_value_avahi_domain_equal$10=avahi_domain_equal(return_value_gtk_entry_get_text$9, name);
    if(!(return_value_avahi_domain_equal$10 == 0))
    {
      struct _GtkTreePath *path;
      gtk_tree_selection_select_iter(selection, iter);
      unsigned long int return_value_gtk_tree_model_get_type$3;
      return_value_gtk_tree_model_get_type$3=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type$3);
      path=gtk_tree_model_get_path((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$4, iter);
      unsigned long int return_value_gtk_tree_view_get_type$5;
      return_value_gtk_tree_view_get_type$5=gtk_tree_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_tree_view, return_value_gtk_tree_view_get_type$5);
      gtk_tree_view_set_cursor((struct _GtkTreeView *)return_value_g_type_check_instance_cast$6, path, (struct _GtkTreeViewColumn *)(void *)0, 0);
      gtk_tree_path_free(path);
    }

  }

}

// domain_pulse_callback
// file avahi-ui.c line 311
static signed int domain_pulse_callback(void *data)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)data, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_progress_bar_get_type$3;
  return_value_gtk_progress_bar_get_type$3=gtk_progress_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_progress_bar, return_value_gtk_progress_bar_get_type$3);
  gtk_progress_bar_pulse((struct _GtkProgressBar *)return_value_g_type_check_instance_cast$4);
  return (signed int)!(0 != 0);
}

// domain_row_activated_callback
// file avahi-ui.c line 933
static void domain_row_activated_callback(struct _GtkTreeView *tree_view, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_entry_get_type$5;
  return_value_gtk_entry_get_type$5=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_entry, return_value_gtk_entry_get_type$5);
  const char *return_value_gtk_entry_get_text$7;
  return_value_gtk_entry_get_text$7=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$6);
  signed int return_value_is_valid_domain_suffix$8;
  return_value_is_valid_domain_suffix$8=is_valid_domain_suffix(return_value_gtk_entry_get_text$7);
  unsigned long int return_value_gtk_dialog_get_type$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  if(!(return_value_is_valid_domain_suffix$8 == 0))
  {
    return_value_gtk_dialog_get_type$3=gtk_dialog_get_type();
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_dialog, return_value_gtk_dialog_get_type$3);
    gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$4, -3);
  }

}

// domain_selection_changed_callback
// file avahi-ui.c line 940
static void domain_selection_changed_callback(struct _GtkTreeSelection *selection, void *user_data)
{
  struct _GtkTreeIter iter;
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  char *name;
  do
  {
    unsigned long int return_value_gtk_tree_view_get_type$3;
    return_value_gtk_tree_view_get_type$3=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_tree_view, return_value_gtk_tree_view_get_type$3);
    struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection$5;
    return_value_gtk_tree_view_get_selection$5=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$4);
    signed int return_value_gtk_tree_selection_get_selected$6;
    return_value_gtk_tree_selection_get_selected$6=gtk_tree_selection_get_selected(return_value_gtk_tree_view_get_selection$5, (struct _GtkTreeModel **)(void *)0, &iter);
    if(return_value_gtk_tree_selection_get_selected$6 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"domain_selection_changed_callback", "gtk_tree_selection_get_selected(gtk_tree_view_get_selection(GTK_TREE_VIEW(d->priv->domain_tree_view)), NULL, &iter)");
      goto __CPROVER_DUMP_L3;
    }

  }
  while((_Bool)0);
  unsigned long int return_value_gtk_tree_model_get_type$7;
  return_value_gtk_tree_model_get_type$7=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_list_store, return_value_gtk_tree_model_get_type$7);
  gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$8, &iter, 0, &name, -1);
  unsigned long int return_value_gtk_entry_get_type$9;
  return_value_gtk_entry_get_type$9=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_entry, return_value_gtk_entry_get_type$9);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$10, name);

__CPROVER_DUMP_L3:
  ;
}

// drop_incomplete_utf8
// file alternative.c line 34
static void drop_incomplete_utf8(char *c)
{
  char *e;
  char *return_value_strchr$1;
  return_value_strchr$1=strchr(c, 0);
  e = return_value_strchr$1 - (signed long int)1;
  while(e >= c)
  {
    const char *return_value_avahi_utf8_valid$2;
    return_value_avahi_utf8_valid$2=avahi_utf8_valid(c);
    if(!(return_value_avahi_utf8_valid$2 == ((const char *)NULL)))
      break;

    /* assertion *e & 128 */
    assert(((signed int)*e & 128) != 0);
    *e = (char)0;
    e = e - 1l;
  }
}

// drop_incomplete_utf8$link1
// file alternative.c line 34
static void drop_incomplete_utf8$link1(char *c$link1)
{
  char *e$link1;
  char *return_value_strchr$1$link1;
  return_value_strchr$1$link1=strchr(c$link1, 0);
  e$link1 = return_value_strchr$1$link1 - (signed long int)1;
  while(e$link1 >= c$link1)
  {
    const char *return_value_avahi_utf8_valid$2$link1;
    return_value_avahi_utf8_valid$2$link1=avahi_utf8_valid(c$link1);
    if(!(return_value_avahi_utf8_valid$2$link1 == ((const char *)NULL)))
      break;

    /* assertion *e & 128 */
    assert(((signed int)*e$link1 & 128) != 0);
    *e$link1 = (char)0;
    e$link1 = e$link1 - 1l;
  }
}

// drop_incomplete_utf8$link1$link1
// file alternative.c line 34
static void drop_incomplete_utf8$link1$link1(char *c$link1$link1)
{
  char *e$link1$link1;
  char *return_value_strchr$1$link1$link1;
  return_value_strchr$1$link1$link1=strchr(c$link1$link1, 0);
  e$link1$link1 = return_value_strchr$1$link1$link1 - (signed long int)1;
  while(e$link1$link1 >= c$link1$link1)
  {
    const char *return_value_avahi_utf8_valid$2$link1$link1;
    return_value_avahi_utf8_valid$2$link1$link1=avahi_utf8_valid(c$link1$link1);
    if(!(return_value_avahi_utf8_valid$2$link1$link1 == ((const char *)NULL)))
      break;

    /* assertion *e & 128 */
    assert(((signed int)*e$link1$link1 & 128) != 0);
    *e$link1$link1 = (char)0;
    e$link1$link1 = e$link1$link1 - 1l;
  }
}

// drop_incomplete_utf8$link2
// file alternative.c line 34
static void drop_incomplete_utf8$link2(char *c$link2)
{
  char *e$link2;
  char *return_value_strchr$1$link2;
  return_value_strchr$1$link2=strchr(c$link2, 0);
  e$link2 = return_value_strchr$1$link2 - (signed long int)1;
  while(e$link2 >= c$link2)
  {
    const char *return_value_avahi_utf8_valid$2$link2;
    return_value_avahi_utf8_valid$2$link2=avahi_utf8_valid(c$link2);
    if(!(return_value_avahi_utf8_valid$2$link2 == ((const char *)NULL)))
      break;

    /* assertion *e & 128 */
    assert(((signed int)*e$link2 & 128) != 0);
    *e$link2 = (char)0;
    e$link2 = e$link2 - 1l;
  }
}

// drop_incomplete_utf8$link3
// file alternative.c line 34
static void drop_incomplete_utf8$link3(char *c$link3)
{
  char *e$link3;
  char *return_value_strchr$1$link3;
  return_value_strchr$1$link3=strchr(c$link3, 0);
  e$link3 = return_value_strchr$1$link3 - (signed long int)1;
  while(e$link3 >= c$link3)
  {
    const char *return_value_avahi_utf8_valid$2$link3;
    return_value_avahi_utf8_valid$2$link3=avahi_utf8_valid(c$link3);
    if(!(return_value_avahi_utf8_valid$2$link3 == ((const char *)NULL)))
      break;

    /* assertion *e & 128 */
    assert(((signed int)*e$link3 & 128) != 0);
    *e$link3 = (char)0;
    e$link3 = e$link3 - 1l;
  }
}

// entry_group_simple_method_call
// file entrygroup.c line 188
static signed int entry_group_simple_method_call(struct AvahiEntryGroup *group, const char *method)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  struct AvahiClient *client;
  dbus_error_init(&error);
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  client = group->client;
  message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", method);
  _Bool tmp_if_expr$2;
  unsigned int return_value_dbus_error_is_set$1;
  unsigned int return_value_dbus_message_get_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  if(message == ((struct DBusMessage *)NULL))
    r=avahi_client_set_errno(client, -24);

  else
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$1=dbus_error_is_set(&error);
      tmp_if_expr$2 = return_value_dbus_error_is_set$1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      r=avahi_client_set_errno(client, -22);

    else
    {
      return_value_dbus_message_get_args$3=dbus_message_get_args(reply, &error, (signed int)0);
      if(return_value_dbus_message_get_args$3 == 0u)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
        tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        r=avahi_client_set_errno(client, -22);

      else
      {
        dbus_message_unref(message);
        dbus_message_unref(reply);
        return 0;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$6;
  return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$6 == 0u))
  {
    r=avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return r;
}

// entry_group_simple_method_call$link1
// file entrygroup.c line 188
static signed int entry_group_simple_method_call$link1(struct AvahiEntryGroup *group$link1, const char *method$link1)
{
  struct DBusMessage *message$link1 = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply$link1 = (struct DBusMessage *)(void *)0;
  struct DBusError error$link1;
  signed int r$link1 = 0;
  struct AvahiClient *client$link1;
  dbus_error_init(&error$link1);
  /* assertion group */
  assert(group$link1 != ((struct AvahiEntryGroup *)NULL));
  client$link1 = group$link1->client;
  message$link1=dbus_message_new_method_call("org.freedesktop.Avahi", group$link1->path, "org.freedesktop.Avahi.EntryGroup", method$link1);
  _Bool tmp_if_expr$2$link1;
  unsigned int return_value_dbus_error_is_set$1$link1;
  unsigned int return_value_dbus_message_get_args$3$link1;
  _Bool tmp_if_expr$5$link1;
  unsigned int return_value_dbus_error_is_set$4$link1;
  if(message$link1 == ((struct DBusMessage *)NULL))
    r$link1=avahi_client_set_errno(client$link1, -24);

  else
  {
    reply$link1=dbus_connection_send_with_reply_and_block(client$link1->bus, message$link1, -1, &error$link1);
    if(reply$link1 == ((struct DBusMessage *)NULL))
      tmp_if_expr$2$link1 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$1$link1=dbus_error_is_set(&error$link1);
      tmp_if_expr$2$link1 = return_value_dbus_error_is_set$1$link1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2$link1)
      r$link1=avahi_client_set_errno(client$link1, -22);

    else
    {
      return_value_dbus_message_get_args$3$link1=dbus_message_get_args(reply$link1, &error$link1, (signed int)0);
      if(return_value_dbus_message_get_args$3$link1 == 0u)
        tmp_if_expr$5$link1 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$4$link1=dbus_error_is_set(&error$link1);
        tmp_if_expr$5$link1 = return_value_dbus_error_is_set$4$link1 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5$link1)
        r$link1=avahi_client_set_errno(client$link1, -22);

      else
      {
        dbus_message_unref(message$link1);
        dbus_message_unref(reply$link1);
        return 0;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$6$link1;
  return_value_dbus_error_is_set$6$link1=dbus_error_is_set(&error$link1);
  if(!(return_value_dbus_error_is_set$6$link1 == 0u))
  {
    r$link1=avahi_client_set_dbus_error(client$link1, &error$link1);
    dbus_error_free(&error$link1);
  }

  if(!(message$link1 == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message$link1);

  if(!(reply$link1 == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply$link1);

  return r$link1;
}

// filter_func
// file client.c line 103
static enum anonymous$42 filter_func(struct DBusConnection *bus, struct DBusMessage *message, void *userdata)
{
  struct AvahiClient *client = (struct AvahiClient *)userdata;
  struct DBusError error;
  /* assertion bus */
  assert(bus != ((struct DBusConnection *)NULL));
  /* assertion message */
  assert(message != ((struct DBusMessage *)NULL));
  dbus_error_init(&error);
  unsigned int return_value_dbus_message_is_signal$75;
  return_value_dbus_message_is_signal$75=dbus_message_is_signal(message, "org.freedesktop.DBus.Local", "Disconnected");
  unsigned int return_value_dbus_message_is_signal$74;
  unsigned int return_value_dbus_message_is_signal$73;
  _Bool tmp_if_expr$3;
  unsigned int return_value_dbus_error_is_set$2;
  _Bool tmp_if_expr$6;
  signed int return_value_avahi_client_is_connected$5;
  _Bool tmp_if_expr$4;
  signed int return_value_avahi_client_is_connected$72;
  unsigned int return_value_dbus_message_is_signal$71;
  _Bool tmp_if_expr$10;
  unsigned int return_value_dbus_error_is_set$9;
  unsigned int return_value_dbus_message_is_signal$70;
  signed int return_value_strcmp$11;
  _Bool tmp_if_expr$14;
  unsigned int return_value_dbus_error_is_set$13;
  unsigned int return_value_dbus_message_is_signal$69;
  enum anonymous$42 return_value_avahi_domain_browser_event$15;
  unsigned int return_value_dbus_message_is_signal$68;
  enum anonymous$42 return_value_avahi_domain_browser_event$16;
  unsigned int return_value_dbus_message_is_signal$67;
  enum anonymous$42 return_value_avahi_domain_browser_event$17;
  unsigned int return_value_dbus_message_is_signal$66;
  enum anonymous$42 return_value_avahi_domain_browser_event$18;
  unsigned int return_value_dbus_message_is_signal$65;
  enum anonymous$42 return_value_avahi_domain_browser_event$19;
  unsigned int return_value_dbus_message_is_signal$64;
  enum anonymous$42 return_value_avahi_service_type_browser_event$20;
  unsigned int return_value_dbus_message_is_signal$63;
  enum anonymous$42 return_value_avahi_service_type_browser_event$21;
  unsigned int return_value_dbus_message_is_signal$62;
  enum anonymous$42 return_value_avahi_service_type_browser_event$22;
  unsigned int return_value_dbus_message_is_signal$61;
  enum anonymous$42 return_value_avahi_service_type_browser_event$23;
  unsigned int return_value_dbus_message_is_signal$60;
  enum anonymous$42 return_value_avahi_service_type_browser_event$24;
  unsigned int return_value_dbus_message_is_signal$59;
  enum anonymous$42 return_value_avahi_service_browser_event$25;
  unsigned int return_value_dbus_message_is_signal$58;
  enum anonymous$42 return_value_avahi_service_browser_event$26;
  unsigned int return_value_dbus_message_is_signal$57;
  enum anonymous$42 return_value_avahi_service_browser_event$27;
  unsigned int return_value_dbus_message_is_signal$56;
  enum anonymous$42 return_value_avahi_service_browser_event$28;
  unsigned int return_value_dbus_message_is_signal$55;
  enum anonymous$42 return_value_avahi_service_browser_event$29;
  unsigned int return_value_dbus_message_is_signal$54;
  enum anonymous$42 return_value_avahi_service_resolver_event$30;
  unsigned int return_value_dbus_message_is_signal$53;
  enum anonymous$42 return_value_avahi_service_resolver_event$31;
  unsigned int return_value_dbus_message_is_signal$52;
  enum anonymous$42 return_value_avahi_host_name_resolver_event$32;
  unsigned int return_value_dbus_message_is_signal$51;
  enum anonymous$42 return_value_avahi_host_name_resolver_event$33;
  unsigned int return_value_dbus_message_is_signal$50;
  enum anonymous$42 return_value_avahi_address_resolver_event$34;
  unsigned int return_value_dbus_message_is_signal$49;
  enum anonymous$42 return_value_avahi_address_resolver_event$35;
  unsigned int return_value_dbus_message_is_signal$48;
  enum anonymous$42 return_value_avahi_record_browser_event$36;
  unsigned int return_value_dbus_message_is_signal$47;
  enum anonymous$42 return_value_avahi_record_browser_event$37;
  unsigned int return_value_dbus_message_is_signal$46;
  enum anonymous$42 return_value_avahi_record_browser_event$38;
  unsigned int return_value_dbus_message_is_signal$45;
  enum anonymous$42 return_value_avahi_record_browser_event$39;
  unsigned int return_value_dbus_message_is_signal$44;
  enum anonymous$42 return_value_avahi_record_browser_event$40;
  if(!(return_value_dbus_message_is_signal$75 == 0u))
  {
    avahi_client_set_errno(client, -23);
    goto fail;
  }

  else
  {
    return_value_dbus_message_is_signal$74=dbus_message_is_signal(message, "org.freedesktop.DBus", "NameAcquired");
    if(return_value_dbus_message_is_signal$74 == 0u)
    {
      return_value_dbus_message_is_signal$73=dbus_message_is_signal(message, "org.freedesktop.DBus", "NameOwnerChanged");
      if(!(return_value_dbus_message_is_signal$73 == 0u))
      {
        char *name;
        char *old;
        char *new;
        unsigned int return_value_dbus_message_get_args$1;
        return_value_dbus_message_get_args$1=dbus_message_get_args(message, &error, (signed int)115, &name, (signed int)115, &old, (signed int)115, &new, (signed int)0);
        if(return_value_dbus_message_get_args$1 == 0u)
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$2=dbus_error_is_set(&error);
          tmp_if_expr$3 = return_value_dbus_error_is_set$2 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$3)
        {
          fprintf(stderr, "WARNING: Failed to parse NameOwnerChanged signal: %s\n", error.message);
          avahi_client_set_errno(client, -22);
          goto fail;
        }

        signed int return_value_strcmp$7;
        return_value_strcmp$7=strcmp(name, "org.freedesktop.Avahi");
        if(return_value_strcmp$7 == 0)
        {
          if(!(*old == 0))
          {
            return_value_avahi_client_is_connected$5=avahi_client_is_connected(client);
            tmp_if_expr$6 = return_value_avahi_client_is_connected$5 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$6 = (_Bool)0;
          if(tmp_if_expr$6)
          {
            avahi_client_set_errno(client, -23);
            goto fail;
          }

          else
            if((signed int)client->state == AVAHI_CLIENT_CONNECTING)
            {
              if(old == ((char *)NULL))
                tmp_if_expr$4 = (_Bool)1;

              else
                tmp_if_expr$4 = (signed int)*old == 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$4)
              {
                signed int ret;
                ret=init_server(client, (signed int *)(void *)0);
                if(!(ret >= 0))
                {
                  avahi_client_set_errno(client, ret);
                  goto fail;
                }

              }

            }

        }

      }

      else
      {
        return_value_avahi_client_is_connected$72=avahi_client_is_connected(client);
        if(!(return_value_avahi_client_is_connected$72 == 0))
        {
          return_value_dbus_message_is_signal$71=dbus_message_is_signal(message, "org.freedesktop.Avahi.Server", "StateChanged");
          if(!(return_value_dbus_message_is_signal$71 == 0u))
          {
            signed int state;
            char *e = (char *)(void *)0;
            signed int c;
            unsigned int return_value_dbus_message_get_args$8;
            return_value_dbus_message_get_args$8=dbus_message_get_args(message, &error, (signed int)105, &state, (signed int)115, &e, (signed int)0);
            if(return_value_dbus_message_get_args$8 == 0u)
              tmp_if_expr$10 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$9=dbus_error_is_set(&error);
              tmp_if_expr$10 = return_value_dbus_error_is_set$9 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$10)
            {
              fprintf(stderr, "WARNING: Failed to parse Server.StateChanged signal: %s\n", error.message);
              avahi_client_set_errno(client, -22);
              goto fail;
            }

            c=avahi_error_dbus_to_number(e);
            if(!(c == 0))
              avahi_client_set_errno(client, c);

            client_set_state(client, (enum anonymous$11)state);
          }

          else
          {
            return_value_dbus_message_is_signal$70=dbus_message_is_signal(message, "org.freedesktop.Avahi.EntryGroup", "StateChanged");
            if(!(return_value_dbus_message_is_signal$70 == 0u))
            {
              const char *path;
              struct AvahiEntryGroup *g;
              path=dbus_message_get_path(message);
              g = client->groups;
              for( ; !(g == ((struct AvahiEntryGroup *)NULL)); g = g->groups_next)
              {
                return_value_strcmp$11=strcmp(g->path, path);
                if(return_value_strcmp$11 == 0)
                  break;

              }
              if(!(g == ((struct AvahiEntryGroup *)NULL)))
              {
                signed int filter_func$$1$$6$$2$$state;
                char *filter_func$$1$$6$$2$$e;
                signed int filter_func$$1$$6$$2$$c;
                unsigned int return_value_dbus_message_get_args$12;
                return_value_dbus_message_get_args$12=dbus_message_get_args(message, &error, (signed int)105, &filter_func$$1$$6$$2$$state, (signed int)115, &filter_func$$1$$6$$2$$e, (signed int)0);
                if(return_value_dbus_message_get_args$12 == 0u)
                  tmp_if_expr$14 = (_Bool)1;

                else
                {
                  return_value_dbus_error_is_set$13=dbus_error_is_set(&error);
                  tmp_if_expr$14 = return_value_dbus_error_is_set$13 != 0u ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$14)
                {
                  fprintf(stderr, "WARNING: Failed to parse EntryGroup.StateChanged signal: %s\n", error.message);
                  avahi_client_set_errno(client, -22);
                  goto fail;
                }

                filter_func$$1$$6$$2$$c=avahi_error_dbus_to_number(filter_func$$1$$6$$2$$e);
                if(!(filter_func$$1$$6$$2$$c == 0))
                  avahi_client_set_errno(client, filter_func$$1$$6$$2$$c);

                avahi_entry_group_set_state(g, (enum anonymous$40)filter_func$$1$$6$$2$$state);
              }

            }

            else
            {
              return_value_dbus_message_is_signal$69=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "ItemNew");
              if(!(return_value_dbus_message_is_signal$69 == 0u))
              {
                return_value_avahi_domain_browser_event$15=avahi_domain_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_NEW, message);
                return return_value_avahi_domain_browser_event$15;
              }

              else
              {
                return_value_dbus_message_is_signal$68=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "ItemRemove");
                if(!(return_value_dbus_message_is_signal$68 == 0u))
                {
                  return_value_avahi_domain_browser_event$16=avahi_domain_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_REMOVE, message);
                  return return_value_avahi_domain_browser_event$16;
                }

                else
                {
                  return_value_dbus_message_is_signal$67=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "CacheExhausted");
                  if(!(return_value_dbus_message_is_signal$67 == 0u))
                  {
                    return_value_avahi_domain_browser_event$17=avahi_domain_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                    return return_value_avahi_domain_browser_event$17;
                  }

                  else
                  {
                    return_value_dbus_message_is_signal$66=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "AllForNow");
                    if(!(return_value_dbus_message_is_signal$66 == 0u))
                    {
                      return_value_avahi_domain_browser_event$18=avahi_domain_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_ALL_FOR_NOW, message);
                      return return_value_avahi_domain_browser_event$18;
                    }

                    else
                    {
                      return_value_dbus_message_is_signal$65=dbus_message_is_signal(message, "org.freedesktop.Avahi.DomainBrowser", "Failure");
                      if(!(return_value_dbus_message_is_signal$65 == 0u))
                      {
                        return_value_avahi_domain_browser_event$19=avahi_domain_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_FAILURE, message);
                        return return_value_avahi_domain_browser_event$19;
                      }

                      else
                      {
                        return_value_dbus_message_is_signal$64=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "ItemNew");
                        if(!(return_value_dbus_message_is_signal$64 == 0u))
                        {
                          return_value_avahi_service_type_browser_event$20=avahi_service_type_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_NEW, message);
                          return return_value_avahi_service_type_browser_event$20;
                        }

                        else
                        {
                          return_value_dbus_message_is_signal$63=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "ItemRemove");
                          if(!(return_value_dbus_message_is_signal$63 == 0u))
                          {
                            return_value_avahi_service_type_browser_event$21=avahi_service_type_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_REMOVE, message);
                            return return_value_avahi_service_type_browser_event$21;
                          }

                          else
                          {
                            return_value_dbus_message_is_signal$62=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "CacheExhausted");
                            if(!(return_value_dbus_message_is_signal$62 == 0u))
                            {
                              return_value_avahi_service_type_browser_event$22=avahi_service_type_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                              return return_value_avahi_service_type_browser_event$22;
                            }

                            else
                            {
                              return_value_dbus_message_is_signal$61=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "AllForNow");
                              if(!(return_value_dbus_message_is_signal$61 == 0u))
                              {
                                return_value_avahi_service_type_browser_event$23=avahi_service_type_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_ALL_FOR_NOW, message);
                                return return_value_avahi_service_type_browser_event$23;
                              }

                              else
                              {
                                return_value_dbus_message_is_signal$60=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceTypeBrowser", "Failure");
                                if(!(return_value_dbus_message_is_signal$60 == 0u))
                                {
                                  return_value_avahi_service_type_browser_event$24=avahi_service_type_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_FAILURE, message);
                                  return return_value_avahi_service_type_browser_event$24;
                                }

                                else
                                {
                                  return_value_dbus_message_is_signal$59=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "ItemNew");
                                  if(!(return_value_dbus_message_is_signal$59 == 0u))
                                  {
                                    return_value_avahi_service_browser_event$25=avahi_service_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_NEW, message);
                                    return return_value_avahi_service_browser_event$25;
                                  }

                                  else
                                  {
                                    return_value_dbus_message_is_signal$58=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "ItemRemove");
                                    if(!(return_value_dbus_message_is_signal$58 == 0u))
                                    {
                                      return_value_avahi_service_browser_event$26=avahi_service_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_REMOVE, message);
                                      return return_value_avahi_service_browser_event$26;
                                    }

                                    else
                                    {
                                      return_value_dbus_message_is_signal$57=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "CacheExhausted");
                                      if(!(return_value_dbus_message_is_signal$57 == 0u))
                                      {
                                        return_value_avahi_service_browser_event$27=avahi_service_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                                        return return_value_avahi_service_browser_event$27;
                                      }

                                      else
                                      {
                                        return_value_dbus_message_is_signal$56=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "AllForNow");
                                        if(!(return_value_dbus_message_is_signal$56 == 0u))
                                        {
                                          return_value_avahi_service_browser_event$28=avahi_service_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_ALL_FOR_NOW, message);
                                          return return_value_avahi_service_browser_event$28;
                                        }

                                        else
                                        {
                                          return_value_dbus_message_is_signal$55=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceBrowser", "Failure");
                                          if(!(return_value_dbus_message_is_signal$55 == 0u))
                                          {
                                            return_value_avahi_service_browser_event$29=avahi_service_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_FAILURE, message);
                                            return return_value_avahi_service_browser_event$29;
                                          }

                                          else
                                          {
                                            return_value_dbus_message_is_signal$54=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceResolver", "Found");
                                            if(!(return_value_dbus_message_is_signal$54 == 0u))
                                            {
                                              return_value_avahi_service_resolver_event$30=avahi_service_resolver_event(client, (enum anonymous$12)AVAHI_RESOLVER_FOUND, message);
                                              return return_value_avahi_service_resolver_event$30;
                                            }

                                            else
                                            {
                                              return_value_dbus_message_is_signal$53=dbus_message_is_signal(message, "org.freedesktop.Avahi.ServiceResolver", "Failure");
                                              if(!(return_value_dbus_message_is_signal$53 == 0u))
                                              {
                                                return_value_avahi_service_resolver_event$31=avahi_service_resolver_event(client, (enum anonymous$12)AVAHI_RESOLVER_FAILURE, message);
                                                return return_value_avahi_service_resolver_event$31;
                                              }

                                              else
                                              {
                                                return_value_dbus_message_is_signal$52=dbus_message_is_signal(message, "org.freedesktop.Avahi.HostNameResolver", "Found");
                                                if(!(return_value_dbus_message_is_signal$52 == 0u))
                                                {
                                                  return_value_avahi_host_name_resolver_event$32=avahi_host_name_resolver_event(client, (enum anonymous$12)AVAHI_RESOLVER_FOUND, message);
                                                  return return_value_avahi_host_name_resolver_event$32;
                                                }

                                                else
                                                {
                                                  return_value_dbus_message_is_signal$51=dbus_message_is_signal(message, "org.freedesktop.Avahi.HostNameResolver", "Failure");
                                                  if(!(return_value_dbus_message_is_signal$51 == 0u))
                                                  {
                                                    return_value_avahi_host_name_resolver_event$33=avahi_host_name_resolver_event(client, (enum anonymous$12)AVAHI_RESOLVER_FAILURE, message);
                                                    return return_value_avahi_host_name_resolver_event$33;
                                                  }

                                                  else
                                                  {
                                                    return_value_dbus_message_is_signal$50=dbus_message_is_signal(message, "org.freedesktop.Avahi.AddressResolver", "Found");
                                                    if(!(return_value_dbus_message_is_signal$50 == 0u))
                                                    {
                                                      return_value_avahi_address_resolver_event$34=avahi_address_resolver_event(client, (enum anonymous$12)AVAHI_RESOLVER_FOUND, message);
                                                      return return_value_avahi_address_resolver_event$34;
                                                    }

                                                    else
                                                    {
                                                      return_value_dbus_message_is_signal$49=dbus_message_is_signal(message, "org.freedesktop.Avahi.AddressResolver", "Failure");
                                                      if(!(return_value_dbus_message_is_signal$49 == 0u))
                                                      {
                                                        return_value_avahi_address_resolver_event$35=avahi_address_resolver_event(client, (enum anonymous$12)AVAHI_RESOLVER_FAILURE, message);
                                                        return return_value_avahi_address_resolver_event$35;
                                                      }

                                                      else
                                                      {
                                                        return_value_dbus_message_is_signal$48=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "ItemNew");
                                                        if(!(return_value_dbus_message_is_signal$48 == 0u))
                                                        {
                                                          return_value_avahi_record_browser_event$36=avahi_record_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_NEW, message);
                                                          return return_value_avahi_record_browser_event$36;
                                                        }

                                                        else
                                                        {
                                                          return_value_dbus_message_is_signal$47=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "ItemRemove");
                                                          if(!(return_value_dbus_message_is_signal$47 == 0u))
                                                          {
                                                            return_value_avahi_record_browser_event$37=avahi_record_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_REMOVE, message);
                                                            return return_value_avahi_record_browser_event$37;
                                                          }

                                                          else
                                                          {
                                                            return_value_dbus_message_is_signal$46=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "CacheExhausted");
                                                            if(!(return_value_dbus_message_is_signal$46 == 0u))
                                                            {
                                                              return_value_avahi_record_browser_event$38=avahi_record_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_CACHE_EXHAUSTED, message);
                                                              return return_value_avahi_record_browser_event$38;
                                                            }

                                                            else
                                                            {
                                                              return_value_dbus_message_is_signal$45=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "AllForNow");
                                                              if(!(return_value_dbus_message_is_signal$45 == 0u))
                                                              {
                                                                return_value_avahi_record_browser_event$39=avahi_record_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_ALL_FOR_NOW, message);
                                                                return return_value_avahi_record_browser_event$39;
                                                              }

                                                              else
                                                              {
                                                                return_value_dbus_message_is_signal$44=dbus_message_is_signal(message, "org.freedesktop.Avahi.RecordBrowser", "Failure");
                                                                if(!(return_value_dbus_message_is_signal$44 == 0u))
                                                                {
                                                                  return_value_avahi_record_browser_event$40=avahi_record_browser_event(client, (enum anonymous$14)AVAHI_BROWSER_FAILURE, message);
                                                                  return return_value_avahi_record_browser_event$40;
                                                                }

                                                                else
                                                                {
                                                                  const char *return_value_dbus_message_get_interface$41;
                                                                  return_value_dbus_message_get_interface$41=dbus_message_get_interface(message);
                                                                  const char *return_value_dbus_message_get_path$42;
                                                                  return_value_dbus_message_get_path$42=dbus_message_get_path(message);
                                                                  const char *return_value_dbus_message_get_member$43;
                                                                  return_value_dbus_message_get_member$43=dbus_message_get_member(message);
                                                                  fprintf(stderr, "WARNING: Unhandled message: interface=%s, path=%s, member=%s\n", return_value_dbus_message_get_interface$41, return_value_dbus_message_get_path$42, return_value_dbus_message_get_member$43);
                                                                  return (enum anonymous$42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

      }
    }

  }
  return (enum anonymous$42)DBUS_HANDLER_RESULT_HANDLED;

fail:
  ;
  unsigned int return_value_dbus_error_is_set$77;
  return_value_dbus_error_is_set$77=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$77 == 0u))
  {
    signed int return_value_avahi_error_dbus_to_number$76;
    return_value_avahi_error_dbus_to_number$76=avahi_error_dbus_to_number(error.name);
    avahi_client_set_errno(client, return_value_avahi_error_dbus_to_number$76);
    dbus_error_free(&error);
  }

  client_set_state(client, (enum anonymous$11)AVAHI_CLIENT_FAILURE);
  return (enum anonymous$42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}

// filter_func$link1
// file client.c line 103
static enum anonymous$42 filter_func$link1(struct DBusConnection *bus$link1, struct DBusMessage *message$link1, void *userdata$link1)
{
  struct AvahiClient *client$link1 = (struct AvahiClient *)userdata$link1;
  struct DBusError error$link1;
  /* assertion bus */
  assert(bus$link1 != ((struct DBusConnection *)NULL));
  /* assertion message */
  assert(message$link1 != ((struct DBusMessage *)NULL));
  dbus_error_init(&error$link1);
  unsigned int return_value_dbus_message_is_signal$75$link1;
  return_value_dbus_message_is_signal$75$link1=dbus_message_is_signal(message$link1, "org.freedesktop.DBus.Local", "Disconnected");
  unsigned int return_value_dbus_message_is_signal$74$link1;
  unsigned int return_value_dbus_message_is_signal$73$link1;
  _Bool tmp_if_expr$3$link1;
  unsigned int return_value_dbus_error_is_set$2$link1;
  _Bool tmp_if_expr$6$link1;
  signed int return_value_avahi_client_is_connected$5$link1;
  _Bool tmp_if_expr$4$link1;
  signed int return_value_avahi_client_is_connected$72$link1;
  unsigned int return_value_dbus_message_is_signal$71$link1;
  _Bool tmp_if_expr$10$link1;
  unsigned int return_value_dbus_error_is_set$9$link1;
  unsigned int return_value_dbus_message_is_signal$70$link1;
  signed int return_value_strcmp$11$link1;
  _Bool tmp_if_expr$14$link1;
  unsigned int return_value_dbus_error_is_set$13$link1;
  unsigned int return_value_dbus_message_is_signal$69$link1;
  enum anonymous$42 return_value_avahi_domain_browser_event$15$link1;
  unsigned int return_value_dbus_message_is_signal$68$link1;
  enum anonymous$42 return_value_avahi_domain_browser_event$16$link1;
  unsigned int return_value_dbus_message_is_signal$67$link1;
  enum anonymous$42 return_value_avahi_domain_browser_event$17$link1;
  unsigned int return_value_dbus_message_is_signal$66$link1;
  enum anonymous$42 return_value_avahi_domain_browser_event$18$link1;
  unsigned int return_value_dbus_message_is_signal$65$link1;
  enum anonymous$42 return_value_avahi_domain_browser_event$19$link1;
  unsigned int return_value_dbus_message_is_signal$64$link1;
  enum anonymous$42 return_value_avahi_service_type_browser_event$20$link1;
  unsigned int return_value_dbus_message_is_signal$63$link1;
  enum anonymous$42 return_value_avahi_service_type_browser_event$21$link1;
  unsigned int return_value_dbus_message_is_signal$62$link1;
  enum anonymous$42 return_value_avahi_service_type_browser_event$22$link1;
  unsigned int return_value_dbus_message_is_signal$61$link1;
  enum anonymous$42 return_value_avahi_service_type_browser_event$23$link1;
  unsigned int return_value_dbus_message_is_signal$60$link1;
  enum anonymous$42 return_value_avahi_service_type_browser_event$24$link1;
  unsigned int return_value_dbus_message_is_signal$59$link1;
  enum anonymous$42 return_value_avahi_service_browser_event$25$link1;
  unsigned int return_value_dbus_message_is_signal$58$link1;
  enum anonymous$42 return_value_avahi_service_browser_event$26$link1;
  unsigned int return_value_dbus_message_is_signal$57$link1;
  enum anonymous$42 return_value_avahi_service_browser_event$27$link1;
  unsigned int return_value_dbus_message_is_signal$56$link1;
  enum anonymous$42 return_value_avahi_service_browser_event$28$link1;
  unsigned int return_value_dbus_message_is_signal$55$link1;
  enum anonymous$42 return_value_avahi_service_browser_event$29$link1;
  unsigned int return_value_dbus_message_is_signal$54$link1;
  enum anonymous$42 return_value_avahi_service_resolver_event$30$link1;
  unsigned int return_value_dbus_message_is_signal$53$link1;
  enum anonymous$42 return_value_avahi_service_resolver_event$31$link1;
  unsigned int return_value_dbus_message_is_signal$52$link1;
  enum anonymous$42 return_value_avahi_host_name_resolver_event$32$link1;
  unsigned int return_value_dbus_message_is_signal$51$link1;
  enum anonymous$42 return_value_avahi_host_name_resolver_event$33$link1;
  unsigned int return_value_dbus_message_is_signal$50$link1;
  enum anonymous$42 return_value_avahi_address_resolver_event$34$link1;
  unsigned int return_value_dbus_message_is_signal$49$link1;
  enum anonymous$42 return_value_avahi_address_resolver_event$35$link1;
  unsigned int return_value_dbus_message_is_signal$48$link1;
  enum anonymous$42 return_value_avahi_record_browser_event$36$link1;
  unsigned int return_value_dbus_message_is_signal$47$link1;
  enum anonymous$42 return_value_avahi_record_browser_event$37$link1;
  unsigned int return_value_dbus_message_is_signal$46$link1;
  enum anonymous$42 return_value_avahi_record_browser_event$38$link1;
  unsigned int return_value_dbus_message_is_signal$45$link1;
  enum anonymous$42 return_value_avahi_record_browser_event$39$link1;
  unsigned int return_value_dbus_message_is_signal$44$link1;
  enum anonymous$42 return_value_avahi_record_browser_event$40$link1;
  if(!(return_value_dbus_message_is_signal$75$link1 == 0u))
  {
    avahi_client_set_errno(client$link1, -23);
    goto fail;
  }

  else
  {
    return_value_dbus_message_is_signal$74$link1=dbus_message_is_signal(message$link1, "org.freedesktop.DBus", "NameAcquired");
    if(return_value_dbus_message_is_signal$74$link1 == 0u)
    {
      return_value_dbus_message_is_signal$73$link1=dbus_message_is_signal(message$link1, "org.freedesktop.DBus", "NameOwnerChanged");
      if(!(return_value_dbus_message_is_signal$73$link1 == 0u))
      {
        char *name$link1;
        char *old$link1;
        char *new$link1;
        unsigned int return_value_dbus_message_get_args$1$link1;
        return_value_dbus_message_get_args$1$link1=dbus_message_get_args(message$link1, &error$link1, (signed int)115, &name$link1, (signed int)115, &old$link1, (signed int)115, &new$link1, (signed int)0);
        if(return_value_dbus_message_get_args$1$link1 == 0u)
          tmp_if_expr$3$link1 = (_Bool)1;

        else
        {
          return_value_dbus_error_is_set$2$link1=dbus_error_is_set(&error$link1);
          tmp_if_expr$3$link1 = return_value_dbus_error_is_set$2$link1 != 0u ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$3$link1)
        {
          fprintf(stderr, "WARNING: Failed to parse NameOwnerChanged signal: %s\n", error$link1.message);
          avahi_client_set_errno(client$link1, -22);
          goto fail;
        }

        signed int return_value_strcmp$7$link1;
        return_value_strcmp$7$link1=strcmp(name$link1, "org.freedesktop.Avahi");
        if(return_value_strcmp$7$link1 == 0)
        {
          if(!(*old$link1 == 0))
          {
            return_value_avahi_client_is_connected$5$link1=avahi_client_is_connected(client$link1);
            tmp_if_expr$6$link1 = return_value_avahi_client_is_connected$5$link1 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$6$link1 = (_Bool)0;
          if(tmp_if_expr$6$link1)
          {
            avahi_client_set_errno(client$link1, -23);
            goto fail;
          }

          else
            if((signed int)client$link1->state == AVAHI_CLIENT_CONNECTING)
            {
              if(old$link1 == ((char *)NULL))
                tmp_if_expr$4$link1 = (_Bool)1;

              else
                tmp_if_expr$4$link1 = (signed int)*old$link1 == 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$4$link1)
              {
                signed int ret$link1;
                ret$link1=init_server$link1(client$link1, (signed int *)(void *)0);
                if(!(ret$link1 >= 0))
                {
                  avahi_client_set_errno(client$link1, ret$link1);
                  goto fail;
                }

              }

            }

        }

      }

      else
      {
        return_value_avahi_client_is_connected$72$link1=avahi_client_is_connected(client$link1);
        if(!(return_value_avahi_client_is_connected$72$link1 == 0))
        {
          return_value_dbus_message_is_signal$71$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.Server", "StateChanged");
          if(!(return_value_dbus_message_is_signal$71$link1 == 0u))
          {
            signed int state$link1;
            char *e$link1 = (char *)(void *)0;
            signed int c$link1;
            unsigned int return_value_dbus_message_get_args$8$link1;
            return_value_dbus_message_get_args$8$link1=dbus_message_get_args(message$link1, &error$link1, (signed int)105, &state$link1, (signed int)115, &e$link1, (signed int)0);
            if(return_value_dbus_message_get_args$8$link1 == 0u)
              tmp_if_expr$10$link1 = (_Bool)1;

            else
            {
              return_value_dbus_error_is_set$9$link1=dbus_error_is_set(&error$link1);
              tmp_if_expr$10$link1 = return_value_dbus_error_is_set$9$link1 != 0u ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$10$link1)
            {
              fprintf(stderr, "WARNING: Failed to parse Server.StateChanged signal: %s\n", error$link1.message);
              avahi_client_set_errno(client$link1, -22);
              goto fail;
            }

            c$link1=avahi_error_dbus_to_number(e$link1);
            if(!(c$link1 == 0))
              avahi_client_set_errno(client$link1, c$link1);

            client_set_state$link1(client$link1, (enum anonymous$11)state$link1);
          }

          else
          {
            return_value_dbus_message_is_signal$70$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.EntryGroup", "StateChanged");
            if(!(return_value_dbus_message_is_signal$70$link1 == 0u))
            {
              const char *path$link1;
              struct AvahiEntryGroup *g$link1;
              path$link1=dbus_message_get_path(message$link1);
              g$link1 = client$link1->groups;
              for( ; !(g$link1 == ((struct AvahiEntryGroup *)NULL)); g$link1 = g$link1->groups_next)
              {
                return_value_strcmp$11$link1=strcmp(g$link1->path, path$link1);
                if(return_value_strcmp$11$link1 == 0)
                  break;

              }
              if(!(g$link1 == ((struct AvahiEntryGroup *)NULL)))
              {
                signed int filter_func$$1$$6$$2$$state$link1;
                char *filter_func$$1$$6$$2$$e$link1;
                signed int filter_func$$1$$6$$2$$c$link1;
                unsigned int return_value_dbus_message_get_args$12$link1;
                return_value_dbus_message_get_args$12$link1=dbus_message_get_args(message$link1, &error$link1, (signed int)105, &filter_func$$1$$6$$2$$state$link1, (signed int)115, &filter_func$$1$$6$$2$$e$link1, (signed int)0);
                if(return_value_dbus_message_get_args$12$link1 == 0u)
                  tmp_if_expr$14$link1 = (_Bool)1;

                else
                {
                  return_value_dbus_error_is_set$13$link1=dbus_error_is_set(&error$link1);
                  tmp_if_expr$14$link1 = return_value_dbus_error_is_set$13$link1 != 0u ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$14$link1)
                {
                  fprintf(stderr, "WARNING: Failed to parse EntryGroup.StateChanged signal: %s\n", error$link1.message);
                  avahi_client_set_errno(client$link1, -22);
                  goto fail;
                }

                filter_func$$1$$6$$2$$c$link1=avahi_error_dbus_to_number(filter_func$$1$$6$$2$$e$link1);
                if(!(filter_func$$1$$6$$2$$c$link1 == 0))
                  avahi_client_set_errno(client$link1, filter_func$$1$$6$$2$$c$link1);

                avahi_entry_group_set_state(g$link1, (enum anonymous$40)filter_func$$1$$6$$2$$state$link1);
              }

            }

            else
            {
              return_value_dbus_message_is_signal$69$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.DomainBrowser", "ItemNew");
              if(!(return_value_dbus_message_is_signal$69$link1 == 0u))
              {
                return_value_avahi_domain_browser_event$15$link1=avahi_domain_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_NEW, message$link1);
                return return_value_avahi_domain_browser_event$15$link1;
              }

              else
              {
                return_value_dbus_message_is_signal$68$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.DomainBrowser", "ItemRemove");
                if(!(return_value_dbus_message_is_signal$68$link1 == 0u))
                {
                  return_value_avahi_domain_browser_event$16$link1=avahi_domain_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_REMOVE, message$link1);
                  return return_value_avahi_domain_browser_event$16$link1;
                }

                else
                {
                  return_value_dbus_message_is_signal$67$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.DomainBrowser", "CacheExhausted");
                  if(!(return_value_dbus_message_is_signal$67$link1 == 0u))
                  {
                    return_value_avahi_domain_browser_event$17$link1=avahi_domain_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_CACHE_EXHAUSTED, message$link1);
                    return return_value_avahi_domain_browser_event$17$link1;
                  }

                  else
                  {
                    return_value_dbus_message_is_signal$66$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.DomainBrowser", "AllForNow");
                    if(!(return_value_dbus_message_is_signal$66$link1 == 0u))
                    {
                      return_value_avahi_domain_browser_event$18$link1=avahi_domain_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_ALL_FOR_NOW, message$link1);
                      return return_value_avahi_domain_browser_event$18$link1;
                    }

                    else
                    {
                      return_value_dbus_message_is_signal$65$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.DomainBrowser", "Failure");
                      if(!(return_value_dbus_message_is_signal$65$link1 == 0u))
                      {
                        return_value_avahi_domain_browser_event$19$link1=avahi_domain_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_FAILURE, message$link1);
                        return return_value_avahi_domain_browser_event$19$link1;
                      }

                      else
                      {
                        return_value_dbus_message_is_signal$64$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.ServiceTypeBrowser", "ItemNew");
                        if(!(return_value_dbus_message_is_signal$64$link1 == 0u))
                        {
                          return_value_avahi_service_type_browser_event$20$link1=avahi_service_type_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_NEW, message$link1);
                          return return_value_avahi_service_type_browser_event$20$link1;
                        }

                        else
                        {
                          return_value_dbus_message_is_signal$63$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.ServiceTypeBrowser", "ItemRemove");
                          if(!(return_value_dbus_message_is_signal$63$link1 == 0u))
                          {
                            return_value_avahi_service_type_browser_event$21$link1=avahi_service_type_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_REMOVE, message$link1);
                            return return_value_avahi_service_type_browser_event$21$link1;
                          }

                          else
                          {
                            return_value_dbus_message_is_signal$62$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.ServiceTypeBrowser", "CacheExhausted");
                            if(!(return_value_dbus_message_is_signal$62$link1 == 0u))
                            {
                              return_value_avahi_service_type_browser_event$22$link1=avahi_service_type_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_CACHE_EXHAUSTED, message$link1);
                              return return_value_avahi_service_type_browser_event$22$link1;
                            }

                            else
                            {
                              return_value_dbus_message_is_signal$61$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.ServiceTypeBrowser", "AllForNow");
                              if(!(return_value_dbus_message_is_signal$61$link1 == 0u))
                              {
                                return_value_avahi_service_type_browser_event$23$link1=avahi_service_type_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_ALL_FOR_NOW, message$link1);
                                return return_value_avahi_service_type_browser_event$23$link1;
                              }

                              else
                              {
                                return_value_dbus_message_is_signal$60$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.ServiceTypeBrowser", "Failure");
                                if(!(return_value_dbus_message_is_signal$60$link1 == 0u))
                                {
                                  return_value_avahi_service_type_browser_event$24$link1=avahi_service_type_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_FAILURE, message$link1);
                                  return return_value_avahi_service_type_browser_event$24$link1;
                                }

                                else
                                {
                                  return_value_dbus_message_is_signal$59$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.ServiceBrowser", "ItemNew");
                                  if(!(return_value_dbus_message_is_signal$59$link1 == 0u))
                                  {
                                    return_value_avahi_service_browser_event$25$link1=avahi_service_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_NEW, message$link1);
                                    return return_value_avahi_service_browser_event$25$link1;
                                  }

                                  else
                                  {
                                    return_value_dbus_message_is_signal$58$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.ServiceBrowser", "ItemRemove");
                                    if(!(return_value_dbus_message_is_signal$58$link1 == 0u))
                                    {
                                      return_value_avahi_service_browser_event$26$link1=avahi_service_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_REMOVE, message$link1);
                                      return return_value_avahi_service_browser_event$26$link1;
                                    }

                                    else
                                    {
                                      return_value_dbus_message_is_signal$57$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.ServiceBrowser", "CacheExhausted");
                                      if(!(return_value_dbus_message_is_signal$57$link1 == 0u))
                                      {
                                        return_value_avahi_service_browser_event$27$link1=avahi_service_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_CACHE_EXHAUSTED, message$link1);
                                        return return_value_avahi_service_browser_event$27$link1;
                                      }

                                      else
                                      {
                                        return_value_dbus_message_is_signal$56$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.ServiceBrowser", "AllForNow");
                                        if(!(return_value_dbus_message_is_signal$56$link1 == 0u))
                                        {
                                          return_value_avahi_service_browser_event$28$link1=avahi_service_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_ALL_FOR_NOW, message$link1);
                                          return return_value_avahi_service_browser_event$28$link1;
                                        }

                                        else
                                        {
                                          return_value_dbus_message_is_signal$55$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.ServiceBrowser", "Failure");
                                          if(!(return_value_dbus_message_is_signal$55$link1 == 0u))
                                          {
                                            return_value_avahi_service_browser_event$29$link1=avahi_service_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_FAILURE, message$link1);
                                            return return_value_avahi_service_browser_event$29$link1;
                                          }

                                          else
                                          {
                                            return_value_dbus_message_is_signal$54$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.ServiceResolver", "Found");
                                            if(!(return_value_dbus_message_is_signal$54$link1 == 0u))
                                            {
                                              return_value_avahi_service_resolver_event$30$link1=avahi_service_resolver_event(client$link1, (enum anonymous$12)AVAHI_RESOLVER_FOUND, message$link1);
                                              return return_value_avahi_service_resolver_event$30$link1;
                                            }

                                            else
                                            {
                                              return_value_dbus_message_is_signal$53$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.ServiceResolver", "Failure");
                                              if(!(return_value_dbus_message_is_signal$53$link1 == 0u))
                                              {
                                                return_value_avahi_service_resolver_event$31$link1=avahi_service_resolver_event(client$link1, (enum anonymous$12)AVAHI_RESOLVER_FAILURE, message$link1);
                                                return return_value_avahi_service_resolver_event$31$link1;
                                              }

                                              else
                                              {
                                                return_value_dbus_message_is_signal$52$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.HostNameResolver", "Found");
                                                if(!(return_value_dbus_message_is_signal$52$link1 == 0u))
                                                {
                                                  return_value_avahi_host_name_resolver_event$32$link1=avahi_host_name_resolver_event(client$link1, (enum anonymous$12)AVAHI_RESOLVER_FOUND, message$link1);
                                                  return return_value_avahi_host_name_resolver_event$32$link1;
                                                }

                                                else
                                                {
                                                  return_value_dbus_message_is_signal$51$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.HostNameResolver", "Failure");
                                                  if(!(return_value_dbus_message_is_signal$51$link1 == 0u))
                                                  {
                                                    return_value_avahi_host_name_resolver_event$33$link1=avahi_host_name_resolver_event(client$link1, (enum anonymous$12)AVAHI_RESOLVER_FAILURE, message$link1);
                                                    return return_value_avahi_host_name_resolver_event$33$link1;
                                                  }

                                                  else
                                                  {
                                                    return_value_dbus_message_is_signal$50$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.AddressResolver", "Found");
                                                    if(!(return_value_dbus_message_is_signal$50$link1 == 0u))
                                                    {
                                                      return_value_avahi_address_resolver_event$34$link1=avahi_address_resolver_event(client$link1, (enum anonymous$12)AVAHI_RESOLVER_FOUND, message$link1);
                                                      return return_value_avahi_address_resolver_event$34$link1;
                                                    }

                                                    else
                                                    {
                                                      return_value_dbus_message_is_signal$49$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.AddressResolver", "Failure");
                                                      if(!(return_value_dbus_message_is_signal$49$link1 == 0u))
                                                      {
                                                        return_value_avahi_address_resolver_event$35$link1=avahi_address_resolver_event(client$link1, (enum anonymous$12)AVAHI_RESOLVER_FAILURE, message$link1);
                                                        return return_value_avahi_address_resolver_event$35$link1;
                                                      }

                                                      else
                                                      {
                                                        return_value_dbus_message_is_signal$48$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.RecordBrowser", "ItemNew");
                                                        if(!(return_value_dbus_message_is_signal$48$link1 == 0u))
                                                        {
                                                          return_value_avahi_record_browser_event$36$link1=avahi_record_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_NEW, message$link1);
                                                          return return_value_avahi_record_browser_event$36$link1;
                                                        }

                                                        else
                                                        {
                                                          return_value_dbus_message_is_signal$47$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.RecordBrowser", "ItemRemove");
                                                          if(!(return_value_dbus_message_is_signal$47$link1 == 0u))
                                                          {
                                                            return_value_avahi_record_browser_event$37$link1=avahi_record_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_REMOVE, message$link1);
                                                            return return_value_avahi_record_browser_event$37$link1;
                                                          }

                                                          else
                                                          {
                                                            return_value_dbus_message_is_signal$46$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.RecordBrowser", "CacheExhausted");
                                                            if(!(return_value_dbus_message_is_signal$46$link1 == 0u))
                                                            {
                                                              return_value_avahi_record_browser_event$38$link1=avahi_record_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_CACHE_EXHAUSTED, message$link1);
                                                              return return_value_avahi_record_browser_event$38$link1;
                                                            }

                                                            else
                                                            {
                                                              return_value_dbus_message_is_signal$45$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.RecordBrowser", "AllForNow");
                                                              if(!(return_value_dbus_message_is_signal$45$link1 == 0u))
                                                              {
                                                                return_value_avahi_record_browser_event$39$link1=avahi_record_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_ALL_FOR_NOW, message$link1);
                                                                return return_value_avahi_record_browser_event$39$link1;
                                                              }

                                                              else
                                                              {
                                                                return_value_dbus_message_is_signal$44$link1=dbus_message_is_signal(message$link1, "org.freedesktop.Avahi.RecordBrowser", "Failure");
                                                                if(!(return_value_dbus_message_is_signal$44$link1 == 0u))
                                                                {
                                                                  return_value_avahi_record_browser_event$40$link1=avahi_record_browser_event(client$link1, (enum anonymous$14)AVAHI_BROWSER_FAILURE, message$link1);
                                                                  return return_value_avahi_record_browser_event$40$link1;
                                                                }

                                                                else
                                                                {
                                                                  const char *return_value_dbus_message_get_interface$41$link1;
                                                                  return_value_dbus_message_get_interface$41$link1=dbus_message_get_interface(message$link1);
                                                                  const char *return_value_dbus_message_get_path$42$link1;
                                                                  return_value_dbus_message_get_path$42$link1=dbus_message_get_path(message$link1);
                                                                  const char *return_value_dbus_message_get_member$43$link1;
                                                                  return_value_dbus_message_get_member$43$link1=dbus_message_get_member(message$link1);
                                                                  fprintf(stderr, "WARNING: Unhandled message: interface=%s, path=%s, member=%s\n", return_value_dbus_message_get_interface$41$link1, return_value_dbus_message_get_path$42$link1, return_value_dbus_message_get_member$43$link1);
                                                                  return (enum anonymous$42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

      }
    }

  }
  return (enum anonymous$42)DBUS_HANDLER_RESULT_HANDLED;

fail:
  ;
  unsigned int return_value_dbus_error_is_set$77$link1;
  return_value_dbus_error_is_set$77$link1=dbus_error_is_set(&error$link1);
  if(!(return_value_dbus_error_is_set$77$link1 == 0u))
  {
    signed int return_value_avahi_error_dbus_to_number$76$link1;
    return_value_avahi_error_dbus_to_number$76$link1=avahi_error_dbus_to_number(error$link1.name);
    avahi_client_set_errno(client$link1, return_value_avahi_error_dbus_to_number$76$link1);
    dbus_error_free(&error$link1);
  }

  client_set_state$link1(client$link1, (enum anonymous$11)AVAHI_CLIENT_FAILURE);
  return (enum anonymous$42)DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
}

// find_next_timeout
// file simple-watch.c line 425
static struct AvahiTimeout$1 * find_next_timeout(struct AvahiSimplePoll$0 *s)
{
  struct AvahiTimeout$1 *t;
  struct AvahiTimeout$1 *n = (struct AvahiTimeout$1 *)(void *)0;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  t = s->timeouts;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  signed int return_value_avahi_timeval_compare$2;
  for( ; !(t == ((struct AvahiTimeout$1 *)NULL)); t = t->timeouts_next)
  {
    if(!(t->dead == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = !(t->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1)
    {
      if(n == ((struct AvahiTimeout$1 *)NULL))
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare$2=avahi_timeval_compare(&t->expiry, &n->expiry);
        tmp_if_expr$3 = return_value_avahi_timeval_compare$2 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        n = t;

    }

  }
  return n;
}

// find_next_timeout$link1
// file simple-watch.c line 425
static struct AvahiTimeout$1 * find_next_timeout$link1(struct AvahiSimplePoll$0 *s$link1)
{
  struct AvahiTimeout$1 *t$link1;
  struct AvahiTimeout$1 *n$link1 = (struct AvahiTimeout$1 *)(void *)0;
  /* assertion s */
  assert(s$link1 != ((struct AvahiSimplePoll$0 *)NULL));
  t$link1 = s$link1->timeouts;
  _Bool tmp_if_expr$1$link1;
  _Bool tmp_if_expr$3$link1;
  signed int return_value_avahi_timeval_compare$2$link1;
  for( ; !(t$link1 == ((struct AvahiTimeout$1 *)NULL)); t$link1 = t$link1->timeouts_next)
  {
    if(!(t$link1->dead == 0))
      tmp_if_expr$1$link1 = (_Bool)1;

    else
      tmp_if_expr$1$link1 = !(t$link1->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1$link1)
    {
      if(n$link1 == ((struct AvahiTimeout$1 *)NULL))
        tmp_if_expr$3$link1 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare$2$link1=avahi_timeval_compare(&t$link1->expiry, &n$link1->expiry);
        tmp_if_expr$3$link1 = return_value_avahi_timeval_compare$2$link1 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3$link1)
        n$link1 = t$link1;

    }

  }
  return n$link1;
}

// find_next_timeout$link1$link1
// file simple-watch.c line 425
static struct AvahiTimeout$0 * find_next_timeout$link1$link1(struct AvahiSimplePoll *s$link2)
{
  struct AvahiTimeout$0 *t$link1$link1;
  struct AvahiTimeout$0 *n$link1$link1 = (struct AvahiTimeout$0 *)(void *)0;
  /* assertion s */
  assert(s$link2 != ((struct AvahiSimplePoll *)NULL));
  t$link1$link1 = s$link2->timeouts;
  _Bool tmp_if_expr$1$link1$link1;
  _Bool tmp_if_expr$3$link1$link1;
  signed int return_value_avahi_timeval_compare$2$link1$link1;
  for( ; !(t$link1$link1 == ((struct AvahiTimeout$0 *)NULL)); t$link1$link1 = t$link1$link1->timeouts_next)
  {
    if(!(t$link1$link1->dead == 0))
      tmp_if_expr$1$link1$link1 = (_Bool)1;

    else
      tmp_if_expr$1$link1$link1 = !(t$link1$link1->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1$link1$link1)
    {
      if(n$link1$link1 == ((struct AvahiTimeout$0 *)NULL))
        tmp_if_expr$3$link1$link1 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare$2$link1$link1=avahi_timeval_compare(&t$link1$link1->expiry, &n$link1$link1->expiry);
        tmp_if_expr$3$link1$link1 = return_value_avahi_timeval_compare$2$link1$link1 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3$link1$link1)
        n$link1$link1 = t$link1$link1;

    }

  }
  return n$link1$link1;
}

// find_next_timeout$link1$link2
// file simple-watch.c line 425
static struct AvahiTimeout$1 * find_next_timeout$link1$link2(struct AvahiSimplePoll$0 *s$link1$link1)
{
  struct AvahiTimeout$1 *t$link1$link2;
  struct AvahiTimeout$1 *n$link1$link2 = (struct AvahiTimeout$1 *)(void *)0;
  /* assertion s */
  assert(s$link1$link1 != ((struct AvahiSimplePoll$0 *)NULL));
  t$link1$link2 = s$link1$link1->timeouts;
  _Bool tmp_if_expr$1$link1$link2;
  _Bool tmp_if_expr$3$link1$link2;
  signed int return_value_avahi_timeval_compare$2$link1$link2;
  for( ; !(t$link1$link2 == ((struct AvahiTimeout$1 *)NULL)); t$link1$link2 = t$link1$link2->timeouts_next)
  {
    if(!(t$link1$link2->dead == 0))
      tmp_if_expr$1$link1$link2 = (_Bool)1;

    else
      tmp_if_expr$1$link1$link2 = !(t$link1$link2->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1$link1$link2)
    {
      if(n$link1$link2 == ((struct AvahiTimeout$1 *)NULL))
        tmp_if_expr$3$link1$link2 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare$2$link1$link2=avahi_timeval_compare(&t$link1$link2->expiry, &n$link1$link2->expiry);
        tmp_if_expr$3$link1$link2 = return_value_avahi_timeval_compare$2$link1$link2 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3$link1$link2)
        n$link1$link2 = t$link1$link2;

    }

  }
  return n$link1$link2;
}

// find_next_timeout$link2
// file glib-watch.c line 230
static struct AvahiTimeout * find_next_timeout$link2(struct AvahiGLibPoll *g)
{
  struct AvahiTimeout *t$link2;
  struct AvahiTimeout *n$link2 = (struct AvahiTimeout *)(void *)0;
  /* assertion g */
  assert(g != ((struct AvahiGLibPoll *)NULL));
  t$link2 = g->timeouts;
  _Bool tmp_if_expr$1$link2;
  _Bool tmp_if_expr$3$link2;
  signed int return_value_avahi_timeval_compare$2$link2;
  for( ; !(t$link2 == ((struct AvahiTimeout *)NULL)); t$link2 = t$link2->timeouts_next)
  {
    if(!(t$link2->dead == 0))
      tmp_if_expr$1$link2 = (_Bool)1;

    else
      tmp_if_expr$1$link2 = !(t$link2->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1$link2)
    {
      if(n$link2 == ((struct AvahiTimeout *)NULL))
        tmp_if_expr$3$link2 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare$2$link2=avahi_timeval_compare(&t$link2->expiry, &n$link2->expiry);
        tmp_if_expr$3$link2 = return_value_avahi_timeval_compare$2$link2 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3$link2)
        n$link2 = t$link2;

    }

  }
  return n$link2;
}

// find_next_timeout$link3
// file simple-watch.c line 425
static struct AvahiTimeout$1 * find_next_timeout$link3(struct AvahiSimplePoll$0 *s$link3)
{
  struct AvahiTimeout$1 *t$link3;
  struct AvahiTimeout$1 *n$link3 = (struct AvahiTimeout$1 *)(void *)0;
  /* assertion s */
  assert(s$link3 != ((struct AvahiSimplePoll$0 *)NULL));
  t$link3 = s$link3->timeouts;
  _Bool tmp_if_expr$1$link3;
  _Bool tmp_if_expr$3$link3;
  signed int return_value_avahi_timeval_compare$2$link3;
  for( ; !(t$link3 == ((struct AvahiTimeout$1 *)NULL)); t$link3 = t$link3->timeouts_next)
  {
    if(!(t$link3->dead == 0))
      tmp_if_expr$1$link3 = (_Bool)1;

    else
      tmp_if_expr$1$link3 = !(t$link3->enabled != 0) ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1$link3)
    {
      if(n$link3 == ((struct AvahiTimeout$1 *)NULL))
        tmp_if_expr$3$link3 = (_Bool)1;

      else
      {
        return_value_avahi_timeval_compare$2$link3=avahi_timeval_compare(&t$link3->expiry, &n$link3->expiry);
        tmp_if_expr$3$link3 = return_value_avahi_timeval_compare$2$link3 < 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3$link3)
        n$link3 = t$link3;

    }

  }
  return n$link3;
}

// get_default_response
// file avahi-ui.c line 128
static signed int get_default_response(struct _GtkDialog *dlg)
{
  signed int ret = -1;
  unsigned long int return_value_gtk_window_get_type$4;
  return_value_gtk_window_get_type$4=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)dlg, return_value_gtk_window_get_type$4);
  struct _GtkWidget *return_value_gtk_window_get_default_widget$6;
  return_value_gtk_window_get_default_widget$6=gtk_window_get_default_widget((struct _GtkWindow *)return_value_g_type_check_instance_cast$5);
  unsigned long int return_value_gtk_window_get_type$1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  struct _GtkWidget *return_value_gtk_window_get_default_widget$3;
  if(!(return_value_gtk_window_get_default_widget$6 == ((struct _GtkWidget *)NULL)))
  {
    return_value_gtk_window_get_type$1=gtk_window_get_type();
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)dlg, return_value_gtk_window_get_type$1);
    return_value_gtk_window_get_default_widget$3=gtk_window_get_default_widget((struct _GtkWindow *)return_value_g_type_check_instance_cast$2);
    ret=gtk_dialog_get_response_for_widget(dlg, return_value_gtk_window_get_default_widget$3);
  }

  if(ret == -1)
  {
    struct _GList *children;
    struct _GList *t;
    signed int bad = -1;
    struct _GtkWidget *return_value_gtk_dialog_get_action_area$7;
    return_value_gtk_dialog_get_action_area$7=gtk_dialog_get_action_area(dlg);
    unsigned long int return_value_gtk_container_get_type$8;
    return_value_gtk_container_get_type$8=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_dialog_get_action_area$7, return_value_gtk_container_get_type$8);
    children=gtk_container_get_children((struct _GtkContainer *)return_value_g_type_check_instance_cast$9);
    t = children;
    while(!(t == ((struct _GList *)NULL)))
    {
      struct _GtkWidget *child = (struct _GtkWidget *)t->data;
      ret=gtk_dialog_get_response_for_widget(dlg, child);
      if(ret == -10 || ret == -8 || ret == -5 || ret == -3)
        break;

      if(bad == -1 && !(ret == -1))
        bad = ret;

      t = t->next;
    }
    g_list_free(children);
    if(ret == -1)
      ret = bad;

  }

  return ret;
}

// get_domain_name
// file avahi-ui.c line 670
static const char * get_domain_name(struct _AuiServiceDialog *d)
{
  const char *domain;
  do
    if(d == ((struct _AuiServiceDialog *)NULL))
    {
      g_return_if_fail_warning((char *)0, (const char *)"get_domain_name", "d");
      return (const char *)(void *)0;
    }

  while((_Bool)0);
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"get_domain_name", "AUI_IS_SERVICE_DIALOG(d)");
      return (const char *)(void *)0;
    }

  }
  while((_Bool)0);
  if(!(d->priv->domain == ((char *)NULL)))
    return d->priv->domain;

  else
  {
    domain=avahi_client_get_domain_name(d->priv->client);
    if(domain == ((const char *)NULL))
    {
      struct _GtkWidget *m;
      unsigned long int return_value_gtk_window_get_type$3;
      return_value_gtk_window_get_type$3=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type$3);
      char *return_value_dgettext$5;
      return_value_dgettext$5=dgettext("avahi", "Failed to read Avahi domain: %s");
      signed int return_value_avahi_client_errno$6;
      return_value_avahi_client_errno$6=avahi_client_errno(d->priv->client);
      const char *return_value_avahi_strerror$7;
      return_value_avahi_strerror$7=avahi_strerror(return_value_avahi_client_errno$6);
      m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$4, (enum anonymous$30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$29)GTK_MESSAGE_ERROR, (enum anonymous$17)GTK_BUTTONS_CLOSE, return_value_dgettext$5, return_value_avahi_strerror$7);
      unsigned long int return_value_gtk_dialog_get_type$8;
      return_value_gtk_dialog_get_type$8=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
      return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type$8);
      gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$9);
      gtk_widget_destroy(m);
      return (const char *)(void *)0;
    }

    return domain;
  }
}

// get_server_state
// file client.c line 305
static signed int get_server_state(struct AvahiClient *client, signed int *ret_error)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int state;
  signed int e = -24;
  /* assertion client */
  assert(client != ((struct AvahiClient *)NULL));
  dbus_error_init(&error);
  message=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetState");
  _Bool tmp_if_expr$2;
  unsigned int return_value_dbus_error_is_set$1;
  unsigned int return_value_dbus_message_get_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  if(!(message == ((struct DBusMessage *)NULL)))
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$1=dbus_error_is_set(&error);
      tmp_if_expr$2 = return_value_dbus_error_is_set$1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      goto fail;

    return_value_dbus_message_get_args$3=dbus_message_get_args(reply, &error, (signed int)105, &state, (signed int)0);
    if(return_value_dbus_message_get_args$3 == 0u)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
      tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      goto fail;

    client_set_state(client, (enum anonymous$11)state);
    dbus_message_unref(message);
    dbus_message_unref(reply);
    return 0;
  }

  else
  {

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$6;
    return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
    if(!(return_value_dbus_error_is_set$6 == 0u))
    {
      e=avahi_error_dbus_to_number(error.name);
      dbus_error_free(&error);
    }

    if(!(ret_error == ((signed int *)NULL)))
      *ret_error = e;

    if(!(message == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message);

    if(!(reply == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply);

    return e;
  }
}

// get_server_state$link1
// file client.c line 305
static signed int get_server_state$link1(struct AvahiClient *client$link1, signed int *ret_error$link1)
{
  struct DBusMessage *message$link1 = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply$link1 = (struct DBusMessage *)(void *)0;
  struct DBusError error$link1;
  signed int state$link1;
  signed int e$link1 = -24;
  /* assertion client */
  assert(client$link1 != ((struct AvahiClient *)NULL));
  dbus_error_init(&error$link1);
  message$link1=dbus_message_new_method_call("org.freedesktop.Avahi", "/", "org.freedesktop.Avahi.Server", "GetState");
  _Bool tmp_if_expr$2$link1;
  unsigned int return_value_dbus_error_is_set$1$link1;
  unsigned int return_value_dbus_message_get_args$3$link1;
  _Bool tmp_if_expr$5$link1;
  unsigned int return_value_dbus_error_is_set$4$link1;
  if(!(message$link1 == ((struct DBusMessage *)NULL)))
  {
    reply$link1=dbus_connection_send_with_reply_and_block(client$link1->bus, message$link1, -1, &error$link1);
    if(reply$link1 == ((struct DBusMessage *)NULL))
      tmp_if_expr$2$link1 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$1$link1=dbus_error_is_set(&error$link1);
      tmp_if_expr$2$link1 = return_value_dbus_error_is_set$1$link1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2$link1)
      goto fail;

    return_value_dbus_message_get_args$3$link1=dbus_message_get_args(reply$link1, &error$link1, (signed int)105, &state$link1, (signed int)0);
    if(return_value_dbus_message_get_args$3$link1 == 0u)
      tmp_if_expr$5$link1 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$4$link1=dbus_error_is_set(&error$link1);
      tmp_if_expr$5$link1 = return_value_dbus_error_is_set$4$link1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5$link1)
      goto fail;

    client_set_state$link1(client$link1, (enum anonymous$11)state$link1);
    dbus_message_unref(message$link1);
    dbus_message_unref(reply$link1);
    return 0;
  }

  else
  {

  fail:
    ;
    unsigned int return_value_dbus_error_is_set$6$link1;
    return_value_dbus_error_is_set$6$link1=dbus_error_is_set(&error$link1);
    if(!(return_value_dbus_error_is_set$6$link1 == 0u))
    {
      e$link1=avahi_error_dbus_to_number(error$link1.name);
      dbus_error_free(&error$link1);
    }

    if(!(ret_error$link1 == ((signed int *)NULL)))
      *ret_error$link1 = e$link1;

    if(!(message$link1 == ((struct DBusMessage *)NULL)))
      dbus_message_unref(message$link1);

    if(!(reply$link1 == ((struct DBusMessage *)NULL)))
      dbus_message_unref(reply$link1);

    return e$link1;
  }
}

// help
// file bssh.c line 53
static void help(struct _IO_FILE *f, const char *argv0)
{
  char *return_value_dgettext$1;
  return_value_dgettext$1=dgettext("avahi", "%s [options]\n\n    -h --help            Show this help\n    -s --ssh             Browse SSH servers\n    -v --vnc             Browse VNC servers\n    -S --shell           Browse both SSH and VNC\n    -d --domain=DOMAIN   The domain to browse in\n");
  fprintf(f, return_value_dgettext$1, argv0);
}

// init
// file ../avahi-utils/stdb.c line 46
static signed int init(void)
{
  if(!(gdbm_file == ((struct anonymous$36 *)NULL)))
    return 0;

  else
  {
    gdbm_file=gdbm_open((char *)"/usr/lib/x86_64-linux-gnu/avahi/service-types.db", 0, 0, 0, (void (*)())(void *)0);
    if(gdbm_file == ((struct anonymous$36 *)NULL))
      return -1;

    else
      return 0;
  }
}

// init_server
// file client.c line 431
static signed int init_server(struct AvahiClient *client, signed int *ret_error)
{
  signed int r;
  r=check_version(client, ret_error);
  if(!(r >= 0))
    return r;

  else
  {
    r=get_server_state(client, ret_error);
    if(!(r >= 0))
      return r;

    else
      return 0;
  }
}

// init_server$link1
// file client.c line 431
static signed int init_server$link1(struct AvahiClient *client$link1, signed int *ret_error$link1)
{
  signed int r$link1;
  r$link1=check_version$link1(client$link1, ret_error$link1);
  if(!(r$link1 >= 0))
    return r$link1;

  else
  {
    r$link1=get_server_state$link1(client$link1, ret_error$link1);
    if(!(r$link1 >= 0))
      return r$link1;

    else
      return 0;
  }
}

// is_valid_domain_suffix
// file avahi-ui.c line 919
static signed int is_valid_domain_suffix(const char *n)
{
  char label[64l];
  signed int return_value_avahi_is_valid_domain_name$1;
  return_value_avahi_is_valid_domain_name$1=avahi_is_valid_domain_name(n);
  if(return_value_avahi_is_valid_domain_name$1 == 0)
    return 0;

  else
  {
    char *return_value_avahi_unescape_label$2;
    return_value_avahi_unescape_label$2=avahi_unescape_label(&n, label, sizeof(char [64l]) /*64ul*/ );
    if(return_value_avahi_unescape_label$2 == ((char *)NULL))
      return 0;

    else
      return (signed int)!(!(label[(signed long int)0] != 0));
  }
}

// main
// file bssh.c line 108
signed int main(signed int argc, char **argv)
{
  struct _GtkWidget *d;
  struct Config config;
  const char *argv0;
  avahi_init_i18n();
  setlocale(6, "");
  argv0=strrchr(argv[(signed long int)0], 47);
  if(!(argv0 == ((const char *)NULL)))
    argv0 = argv0 + 1l;

  else
    argv0 = argv[(signed long int)0];
  signed int return_value_g_str_has_suffix$2;
  return_value_g_str_has_suffix$2=g_str_has_suffix(argv[(signed long int)0], "bshell");
  signed int return_value_g_str_has_suffix$1;
  if(!(return_value_g_str_has_suffix$2 == 0))
    config.command = (enum anonymous$9)COMMAND_SHELL;

  else
  {
    return_value_g_str_has_suffix$1=g_str_has_suffix(argv[(signed long int)0], "bvnc");
    if(!(return_value_g_str_has_suffix$1 == 0))
      config.command = (enum anonymous$9)COMMAND_VNC;

    else
      config.command = (enum anonymous$9)COMMAND_SSH;
  }
  config.domain = (char *)(void *)0;
  signed int return_value_parse_command_line$3;
  return_value_parse_command_line$3=parse_command_line(&config, argc, argv);
  char *return_value_dgettext$4;
  char *return_value_dgettext$5;
  char *return_value_dgettext$6;
  unsigned long int return_value_aui_service_dialog_get_type$7;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  unsigned long int return_value_aui_service_dialog_get_type$9;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  char *return_value_dgettext$11;
  unsigned long int return_value_aui_service_dialog_get_type$12;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  char *return_value_dgettext$14;
  char *return_value_dgettext$15;
  char *return_value_dgettext$16;
  char *return_value_dgettext$17;
  unsigned long int return_value_aui_service_dialog_get_type$18;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
  char *return_value_dgettext$20;
  char *return_value_dgettext$21;
  char *return_value_dgettext$22;
  unsigned long int return_value_aui_service_dialog_get_type$23;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  unsigned long int return_value_aui_service_dialog_get_type$25;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  unsigned long int return_value_aui_service_dialog_get_type$27;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
  unsigned long int return_value_aui_service_dialog_get_type$29;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  signed int return_value_avahi_nss_support$31;
  unsigned long int return_value_gtk_window_get_type$32;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
  unsigned long int return_value_gtk_dialog_get_type$70;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$71;
  signed int return_value_gtk_dialog_run$72;
  unsigned long int return_value_aui_service_dialog_get_type$40;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$41;
  const char *return_value_aui_service_dialog_get_host_name$42;
  unsigned long int return_value_aui_service_dialog_get_type$43;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$44;
  const struct AvahiAddress *return_value_aui_service_dialog_get_address$45;
  char *return_value_avahi_address_snprint$46;
  _Bool tmp_if_expr$61;
  char *return_value_getenv$60;
  _Bool tmp_if_expr$64;
  char *return_value_getenv$63;
  if(!(return_value_parse_command_line$3 >= 0))
  {
    help(stderr, argv0);
    return 1;
  }

  else
  {
    bindtextdomain("avahi", "/usr/share/locale");
    bind_textdomain_codeset("avahi", "UTF-8");
    textdomain("avahi");
    gtk_init(&argc, &argv);
    switch((signed int)config.command)
    {
      case COMMAND_HELP:
      {
        help(stdout, argv0);
        return 0;
      }
      case COMMAND_SHELL:
      {
        return_value_dgettext$4=dgettext("avahi", "Choose Shell Server");
        return_value_dgettext$5=dgettext("avahi", "_Cancel");
        return_value_dgettext$6=dgettext("avahi", "C_onnect");
        d=aui_service_dialog_new(return_value_dgettext$4, (struct _GtkWindow *)(void *)0, return_value_dgettext$5, -6, return_value_dgettext$6, -3, (void *)0);
        return_value_aui_service_dialog_get_type$7=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$7);
        aui_service_dialog_set_browse_service_types((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$8, "_rfb._tcp", (const void *)"_ssh._tcp", (void *)0);
        return_value_aui_service_dialog_get_type$9=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$9);
        return_value_dgettext$11=dgettext("avahi", "Desktop");
        aui_service_dialog_set_service_type_name((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$10, "_rfb._tcp", return_value_dgettext$11);
        return_value_aui_service_dialog_get_type$12=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$12);
        return_value_dgettext$14=dgettext("avahi", "Terminal");
        aui_service_dialog_set_service_type_name((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$13, "_ssh._tcp", return_value_dgettext$14);
        goto __CPROVER_DUMP_L11;
      }
      case COMMAND_VNC:
      {
        return_value_dgettext$15=dgettext("avahi", "Choose VNC server");
        return_value_dgettext$16=dgettext("avahi", "_Cancel");
        return_value_dgettext$17=dgettext("avahi", "C_onnect");
        d=aui_service_dialog_new(return_value_dgettext$15, (struct _GtkWindow *)(void *)0, return_value_dgettext$16, -6, return_value_dgettext$17, -3, (void *)0);
        return_value_aui_service_dialog_get_type$18=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$18);
        aui_service_dialog_set_browse_service_types((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$19, "_rfb._tcp", (void *)0);
        goto __CPROVER_DUMP_L11;
      }
      case COMMAND_SSH:
      {
        return_value_dgettext$20=dgettext("avahi", "Choose SSH server");
        return_value_dgettext$21=dgettext("avahi", "_Cancel");
        return_value_dgettext$22=dgettext("avahi", "C_onnect");
        d=aui_service_dialog_new(return_value_dgettext$20, (struct _GtkWindow *)(void *)0, return_value_dgettext$21, -6, return_value_dgettext$22, -3, (void *)0);
        return_value_aui_service_dialog_get_type$23=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$23);
        aui_service_dialog_set_browse_service_types((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$24, "_ssh._tcp", (void *)0);
      }
      default:
      {

      __CPROVER_DUMP_L11:
        ;
        return_value_aui_service_dialog_get_type$25=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$25);
        aui_service_dialog_set_domain((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$26, config.domain);
        return_value_aui_service_dialog_get_type$27=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$27);
        aui_service_dialog_set_resolve_service((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$28, (signed int)!(0 != 0));
        return_value_aui_service_dialog_get_type$29=aui_service_dialog_get_type();
        return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$29);
        return_value_avahi_nss_support$31=avahi_nss_support();
        aui_service_dialog_set_resolve_host_name((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$30, (signed int)!(return_value_avahi_nss_support$31 != 0));
        return_value_gtk_window_get_type$32=gtk_window_get_type();
        return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type$32);
        gtk_window_present((struct _GtkWindow *)return_value_g_type_check_instance_cast$33);
        return_value_gtk_dialog_get_type$70=gtk_dialog_get_type();
        return_value_g_type_check_instance_cast$71=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$70);
        return_value_gtk_dialog_run$72=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$71);
        if(return_value_gtk_dialog_run$72 == -3)
        {
          char a[40l];
          char *u = (char *)(void *)0;
          char *n = (char *)(void *)0;
          char *h = (char *)(void *)0;
          char *t = (char *)(void *)0;
          const struct AvahiStringList *txt;
          unsigned long int return_value_aui_service_dialog_get_type$34;
          return_value_aui_service_dialog_get_type$34=aui_service_dialog_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$35;
          return_value_g_type_check_instance_cast$35=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$34);
          const char *return_value_aui_service_dialog_get_service_type$36;
          return_value_aui_service_dialog_get_service_type$36=aui_service_dialog_get_service_type((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$35);
          t=g_strdup(return_value_aui_service_dialog_get_service_type$36);
          unsigned long int return_value_aui_service_dialog_get_type$37;
          return_value_aui_service_dialog_get_type$37=aui_service_dialog_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$38;
          return_value_g_type_check_instance_cast$38=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$37);
          const char *return_value_aui_service_dialog_get_service_name$39;
          return_value_aui_service_dialog_get_service_name$39=aui_service_dialog_get_service_name((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$38);
          n=g_strdup(return_value_aui_service_dialog_get_service_name$39);
          signed int return_value_avahi_nss_support$47;
          return_value_avahi_nss_support$47=avahi_nss_support();
          if(!(return_value_avahi_nss_support$47 == 0))
          {
            return_value_aui_service_dialog_get_type$40=aui_service_dialog_get_type();
            return_value_g_type_check_instance_cast$41=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$40);
            return_value_aui_service_dialog_get_host_name$42=aui_service_dialog_get_host_name((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$41);
            h=g_strdup(return_value_aui_service_dialog_get_host_name$42);
          }

          else
          {
            return_value_aui_service_dialog_get_type$43=aui_service_dialog_get_type();
            return_value_g_type_check_instance_cast$44=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$43);
            return_value_aui_service_dialog_get_address$45=aui_service_dialog_get_address((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$44);
            return_value_avahi_address_snprint$46=avahi_address_snprint(a, sizeof(char [40l]) /*40ul*/ , return_value_aui_service_dialog_get_address$45);
            h=g_strdup(return_value_avahi_address_snprint$46);
          }
          char *return_value_dgettext$48;
          return_value_dgettext$48=dgettext("avahi", "Connecting to '%s' ...\n");
          g_print(return_value_dgettext$48, n);
          signed int return_value_avahi_domain_equal$65;
          return_value_avahi_domain_equal$65=avahi_domain_equal(t, "_rfb._tcp");
          if(!(return_value_avahi_domain_equal$65 == 0))
          {
            char p[1030l];
            unsigned long int return_value_aui_service_dialog_get_type$49;
            return_value_aui_service_dialog_get_type$49=aui_service_dialog_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast$50;
            return_value_g_type_check_instance_cast$50=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$49);
            unsigned short int return_value_aui_service_dialog_get_port$51;
            return_value_aui_service_dialog_get_port$51=aui_service_dialog_get_port((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$50);
            snprintf(p, sizeof(char [1030l]) /*1030ul*/ , "%s:%u", h, (signed int)return_value_aui_service_dialog_get_port$51 - 5900);
            gtk_widget_destroy(d);
            g_print("vncviewer %s\n", (const void *)p);
            execlp("xvncviewer", "xvncviewer", (const void *)p, (void *)0);
            execlp("vncviewer", "vncviewer", (const void *)p, (void *)0);
          }

          else
          {
            char main$$1$$3$$2$$p[16l];
            unsigned long int return_value_aui_service_dialog_get_type$52;
            return_value_aui_service_dialog_get_type$52=aui_service_dialog_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast$53;
            return_value_g_type_check_instance_cast$53=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$52);
            unsigned short int return_value_aui_service_dialog_get_port$54;
            return_value_aui_service_dialog_get_port$54=aui_service_dialog_get_port((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$53);
            snprintf(main$$1$$3$$2$$p, sizeof(char [16l]) /*16ul*/ , "%u", return_value_aui_service_dialog_get_port$54);
            unsigned long int return_value_aui_service_dialog_get_type$55;
            return_value_aui_service_dialog_get_type$55=aui_service_dialog_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast$56;
            return_value_g_type_check_instance_cast$56=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_aui_service_dialog_get_type$55);
            txt=aui_service_dialog_get_txt_data((struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$56);
            for( ; !(txt == ((const struct AvahiStringList *)NULL)); txt = txt->next)
            {
              char *key;
              char *value;
              signed int return_value_avahi_string_list_get_pair$57;
              return_value_avahi_string_list_get_pair$57=avahi_string_list_get_pair((struct AvahiStringList *)txt, &key, &value, (unsigned long int *)(void *)0);
              if(!(return_value_avahi_string_list_get_pair$57 >= 0))
                break;

              signed int return_value_strcmp$58;
              return_value_strcmp$58=strcmp(key, "u");
              if(return_value_strcmp$58 == 0)
                u=g_strdup(value);

              avahi_free((void *)key);
              avahi_free((void *)value);
            }
            gtk_widget_destroy(d);
            if(!(u == ((char *)NULL)))
            {
              g_print("ssh -p %s -l %s %s\n", (const void *)main$$1$$3$$2$$p, u, h);
              signed int return_value_isatty$59;
              return_value_isatty$59=isatty(0);
              if(!(return_value_isatty$59 == 0))
                tmp_if_expr$61 = (_Bool)1;

              else
              {
                return_value_getenv$60=getenv("DISPLAY");
                tmp_if_expr$61 = !(return_value_getenv$60 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$61)
                execlp("ssh", "ssh", (const void *)"-p", (const void *)main$$1$$3$$2$$p, (const void *)"-l", u, h, (void *)0);

              else
              {
                execlp("x-terminal-emulator", "x-terminal-emulator", (const void *)"-T", n, (const void *)"-e", (const void *)"ssh", (const void *)"-p", (const void *)main$$1$$3$$2$$p, (const void *)"-l", u, h, (void *)0);
                execlp("gnome-terminal", "gnome-terminal", (const void *)"-t", n, (const void *)"-x", (const void *)"ssh", (const void *)"-p", (const void *)main$$1$$3$$2$$p, (const void *)"-l", u, h, (void *)0);
                execlp("xterm", "xterm", (const void *)"-T", n, (const void *)"-e", (const void *)"ssh", (const void *)"-p", (const void *)main$$1$$3$$2$$p, (const void *)"-l", u, h, (void *)0);
              }
            }

            else
            {
              g_print("ssh -p %s %s\n", (const void *)main$$1$$3$$2$$p, h);
              signed int return_value_isatty$62;
              return_value_isatty$62=isatty(0);
              if(!(return_value_isatty$62 == 0))
                tmp_if_expr$64 = (_Bool)1;

              else
              {
                return_value_getenv$63=getenv("DISPLAY");
                tmp_if_expr$64 = !(return_value_getenv$63 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$64)
                execlp("ssh", "ssh", (const void *)"-p", (const void *)main$$1$$3$$2$$p, h, (void *)0);

              else
              {
                execlp("x-terminal-emulator", "x-terminal-emulator", (const void *)"-T", n, (const void *)"-e", (const void *)"ssh", (const void *)"-p", (const void *)main$$1$$3$$2$$p, h, (void *)0);
                execlp("gnome-terminal", "gnome-terminal", (const void *)"-t", n, (const void *)"-x", (const void *)"ssh", (const void *)"-p", (const void *)main$$1$$3$$2$$p, h, (void *)0);
                execlp("xterm", "xterm", (const void *)"-T", n, (const void *)"-e", (const void *)"ssh", (const void *)"-p", (const void *)main$$1$$3$$2$$p, h, (void *)0);
              }
            }
          }
          char *return_value_dgettext$66;
          return_value_dgettext$66=dgettext("avahi", "execlp() failed: %s\n");
          signed int *return_value___errno_location$67;
          return_value___errno_location$67=__errno_location();
          char *return_value_strerror$68;
          return_value_strerror$68=strerror(*return_value___errno_location$67);
          g_log((char *)0, (enum anonymous$10)G_LOG_LEVEL_WARNING, return_value_dgettext$66, return_value_strerror$68);
          g_free((void *)h);
          g_free((void *)u);
          g_free((void *)t);
          g_free((void *)n);
        }

        else
        {
          gtk_widget_destroy(d);
          char *return_value_dgettext$69;
          return_value_dgettext$69=dgettext("avahi", "Canceled.\n");
          g_print(return_value_dgettext$69);
        }
        g_free((void *)config.domain);
        return 1;
      }
    }
  }
}

// malloc_glue
// file glib-malloc.c line 29
static void * malloc_glue(unsigned long int l)
{
  void *return_value_g_malloc$1;
  return_value_g_malloc$1=g_malloc(l);
  return return_value_g_malloc$1;
}

// map_events_from_glib
// file glib-watch.c line 101
static enum anonymous map_events_from_glib(unsigned short int events)
{
  return (enum anonymous)((((signed int)events & 1) != 0 ? AVAHI_WATCH_IN : 0) | (((signed int)events & 4) != 0 ? AVAHI_WATCH_OUT : 0) | (((signed int)events & 8) != 0 ? AVAHI_WATCH_ERR : 0) | (((signed int)events & 16) != 0 ? AVAHI_WATCH_HUP : 0));
}

// map_events_to_glib
// file glib-watch.c line 93
static unsigned short int map_events_to_glib(enum anonymous events)
{
  return (unsigned short int)((((signed int)events & AVAHI_WATCH_IN) != 0 ? 1 : 0) | (((signed int)events & AVAHI_WATCH_OUT) != 0 ? 4 : 0) | (((signed int)events & AVAHI_WATCH_ERR) != 0 ? 8 : 0) | (((signed int)events & AVAHI_WATCH_HUP) != 0 ? 16 : 0));
}

// oom
// file malloc.c line 44
static void oom(void)
{
  static const char msg[29l] = { 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ',', ' ', 'a', 'b', 'o', 'r', 't', 'i', 'n', 'g', ' ', '.', '.', '.', '\n', 0 };
  const char *n = msg;
  unsigned long int return_value_strlen$1;
  do
  {
    return_value_strlen$1=strlen(n);
    if(!(return_value_strlen$1 >= 1ul))
      break;

    signed long int r;
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(n);
    r=write(2, (const void *)n, return_value_strlen$2);
    if(!(r >= 0l))
      break;

    n = n + r;
  }
  while((_Bool)1);
  abort();
}

// oom$link1
// file malloc.c line 44
static void oom$link1(void)
{
  static const char msg$link1[29l] = { 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ',', ' ', 'a', 'b', 'o', 'r', 't', 'i', 'n', 'g', ' ', '.', '.', '.', '\n', 0 };
  const char *n$link1 = msg$link1;
  unsigned long int return_value_strlen$1$link1;
  do
  {
    return_value_strlen$1$link1=strlen(n$link1);
    if(!(return_value_strlen$1$link1 >= 1ul))
      break;

    signed long int r$link1;
    unsigned long int return_value_strlen$2$link1;
    return_value_strlen$2$link1=strlen(n$link1);
    r$link1=write(2, (const void *)n$link1, return_value_strlen$2$link1);
    if(!(r$link1 >= 0l))
      break;

    n$link1 = n$link1 + r$link1;
  }
  while((_Bool)1);
  abort();
}

// oom$link1$link1
// file malloc.c line 44
static void oom$link1$link1(void)
{
  static const char msg$link1$link1[29l] = { 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ',', ' ', 'a', 'b', 'o', 'r', 't', 'i', 'n', 'g', ' ', '.', '.', '.', '\n', 0 };
  const char *n$link1$link1 = msg$link1$link1;
  unsigned long int return_value_strlen$1$link1$link1;
  do
  {
    return_value_strlen$1$link1$link1=strlen(n$link1$link1);
    if(!(return_value_strlen$1$link1$link1 >= 1ul))
      break;

    signed long int r$link1$link1;
    unsigned long int return_value_strlen$2$link1$link1;
    return_value_strlen$2$link1$link1=strlen(n$link1$link1);
    r$link1$link1=write(2, (const void *)n$link1$link1, return_value_strlen$2$link1$link1);
    if(!(r$link1$link1 >= 0l))
      break;

    n$link1$link1 = n$link1$link1 + r$link1$link1;
  }
  while((_Bool)1);
  abort();
}

// oom$link2
// file malloc.c line 44
static void oom$link2(void)
{
  static const char msg$link2[29l] = { 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ',', ' ', 'a', 'b', 'o', 'r', 't', 'i', 'n', 'g', ' ', '.', '.', '.', '\n', 0 };
  const char *n$link2 = msg$link2;
  unsigned long int return_value_strlen$1$link2;
  do
  {
    return_value_strlen$1$link2=strlen(n$link2);
    if(!(return_value_strlen$1$link2 >= 1ul))
      break;

    signed long int r$link2;
    unsigned long int return_value_strlen$2$link2;
    return_value_strlen$2$link2=strlen(n$link2);
    r$link2=write(2, (const void *)n$link2, return_value_strlen$2$link2);
    if(!(r$link2 >= 0l))
      break;

    n$link2 = n$link2 + r$link2;
  }
  while((_Bool)1);
  abort();
}

// oom$link3
// file malloc.c line 44
static void oom$link3(void)
{
  static const char msg$link3[29l] = { 'O', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ',', ' ', 'a', 'b', 'o', 'r', 't', 'i', 'n', 'g', ' ', '.', '.', '.', '\n', 0 };
  const char *n$link3 = msg$link3;
  unsigned long int return_value_strlen$1$link3;
  do
  {
    return_value_strlen$1$link3=strlen(n$link3);
    if(!(return_value_strlen$1$link3 >= 1ul))
      break;

    signed long int r$link3;
    unsigned long int return_value_strlen$2$link3;
    return_value_strlen$2$link3=strlen(n$link3);
    r$link3=write(2, (const void *)n$link3, return_value_strlen$2$link3);
    if(!(r$link3 >= 0l))
      break;

    n$link3 = n$link3 + r$link3;
  }
  while((_Bool)1);
  abort();
}

// parse_command_line
// file bssh.c line 64
static signed int parse_command_line(struct Config *c, signed int argc, char **argv)
{
  signed int o;
  do
  {
    static struct option long_options[6l] = { { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 }, 
    { .name="ssh", .has_arg=0, .flag=(signed int *)(void *)0, .val=115 }, 
    { .name="vnc", .has_arg=0, .flag=(signed int *)(void *)0, .val=118 }, 
    { .name="shell", .has_arg=0, .flag=(signed int *)(void *)0, .val=83 }, 
    { .name="domain", .has_arg=1, .flag=(signed int *)(void *)0, .val=100 }, 
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
    o=getopt_long(argc, argv, "hVd:svS", long_options, (signed int *)(void *)0);
    if(!(o >= 0))
      break;

    switch(o)
    {
      case 104:
      {
        c->command = (enum anonymous$9)COMMAND_HELP;
        break;
      }
      case 115:
      {
        c->command = (enum anonymous$9)COMMAND_SSH;
        break;
      }
      case 118:
      {
        c->command = (enum anonymous$9)COMMAND_VNC;
        break;
      }
      case 83:
      {
        c->command = (enum anonymous$9)COMMAND_SHELL;
        break;
      }
      case 100:
      {
        avahi_free((void *)c->domain);
        c->domain=avahi_strdup(optarg);
        break;
      }
      default:
        return -1;
    }
  }
  while((_Bool)1);
  if(!(optind >= argc))
  {
    char *return_value_dgettext$1;
    return_value_dgettext$1=dgettext("avahi", "Too many arguments\n");
    fprintf(stderr, return_value_dgettext$1);
    return -1;
  }

  return 0;
}

// parse_domain_file
// file browser.c line 58
static void parse_domain_file(struct AvahiDomainBrowser *b)
{
  struct _IO_FILE *f;
  char buf[1014l];
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  f=avahi_xdg_config_open("avahi/browse-domains");
  char *return_value_fgets$1;
  if(!(f == ((struct _IO_FILE *)NULL)))
    do
    {
      return_value_fgets$1=fgets(buf, (signed int)(sizeof(char [1014l]) /*1014ul*/  - (unsigned long int)1), f);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      char domain[1014l];
      unsigned long int return_value_strcspn$2;
      return_value_strcspn$2=strcspn(buf, "\n\r");
      buf[(signed long int)return_value_strcspn$2] = (char)0;
      char *return_value_avahi_normalize_name$3;
      return_value_avahi_normalize_name$3=avahi_normalize_name(buf, domain, sizeof(char [1014l]) /*1014ul*/ );
      if(!(return_value_avahi_normalize_name$3 == ((char *)NULL)))
        b->static_browse_domains=avahi_string_list_add(b->static_browse_domains, domain);

    }
    while((_Bool)1);

}

// parse_domain_file$link1
// file browser.c line 58
static void parse_domain_file$link1(struct AvahiDomainBrowser *b$link1)
{
  struct _IO_FILE *f$link1;
  char buf$link1[1014l];
  /* assertion b */
  assert(b$link1 != ((struct AvahiDomainBrowser *)NULL));
  f$link1=avahi_xdg_config_open("avahi/browse-domains");
  char *return_value_fgets$1$link1;
  if(!(f$link1 == ((struct _IO_FILE *)NULL)))
    do
    {
      return_value_fgets$1$link1=fgets(buf$link1, (signed int)(sizeof(char [1014l]) /*1014ul*/  - (unsigned long int)1), f$link1);
      if(return_value_fgets$1$link1 == ((char *)NULL))
        break;

      char domain$link1[1014l];
      unsigned long int return_value_strcspn$2$link1;
      return_value_strcspn$2$link1=strcspn(buf$link1, "\n\r");
      buf$link1[(signed long int)return_value_strcspn$2$link1] = (char)0;
      char *return_value_avahi_normalize_name$3$link1;
      return_value_avahi_normalize_name$3$link1=avahi_normalize_name(buf$link1, domain$link1, sizeof(char [1014l]) /*1014ul*/ );
      if(!(return_value_avahi_normalize_name$3$link1 == ((char *)NULL)))
        b$link1->static_browse_domains=avahi_string_list_add(b$link1->static_browse_domains, domain$link1);

    }
    while((_Bool)1);

}

// parse_environment
// file browser.c line 41
static void parse_environment(struct AvahiDomainBrowser *b)
{
  char buf[3042l];
  char *e;
  char *t;
  char *p;
  /* assertion b */
  assert(b != ((struct AvahiDomainBrowser *)NULL));
  e=getenv("AVAHI_BROWSE_DOMAINS");
  if(!(e == ((char *)NULL)))
  {
    snprintf(buf, sizeof(char [3042l]) /*3042ul*/ , "%s", e);
    t=strtok_r(buf, ":", &p);
    while(!(t == ((char *)NULL)))
    {
      char domain[1014l];
      char *return_value_avahi_normalize_name$1;
      return_value_avahi_normalize_name$1=avahi_normalize_name(t, domain, sizeof(char [1014l]) /*1014ul*/ );
      if(!(return_value_avahi_normalize_name$1 == ((char *)NULL)))
        b->static_browse_domains=avahi_string_list_add(b->static_browse_domains, domain);

      t=strtok_r((char *)(void *)0, ":", &p);
    }
  }

}

// parse_environment$link1
// file browser.c line 41
static void parse_environment$link1(struct AvahiDomainBrowser *b$link1)
{
  char buf$link1[3042l];
  char *e$link1;
  char *t$link1;
  char *p$link1;
  /* assertion b */
  assert(b$link1 != ((struct AvahiDomainBrowser *)NULL));
  e$link1=getenv("AVAHI_BROWSE_DOMAINS");
  if(!(e$link1 == ((char *)NULL)))
  {
    snprintf(buf$link1, sizeof(char [3042l]) /*3042ul*/ , "%s", e$link1);
    t$link1=strtok_r(buf$link1, ":", &p$link1);
    while(!(t$link1 == ((char *)NULL)))
    {
      char domain$link1[1014l];
      char *return_value_avahi_normalize_name$1$link1;
      return_value_avahi_normalize_name$1$link1=avahi_normalize_name(t$link1, domain$link1, sizeof(char [1014l]) /*1014ul*/ );
      if(!(return_value_avahi_normalize_name$1$link1 == ((char *)NULL)))
        b$link1->static_browse_domains=avahi_string_list_add(b$link1->static_browse_domains, domain$link1);

      t$link1=strtok_r((char *)(void *)0, ":", &p$link1);
    }
  }

}

// poll_func
// file thread-watch.c line 48
static signed int poll_func(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata)
{
  union anonymous$6 *mutex = (union anonymous$6 *)userdata;
  signed int r;
  pthread_mutex_unlock(mutex);
  r=poll(ufds, (unsigned long int)nfds, timeout);
  pthread_mutex_lock(mutex);
  return r;
}

// poll_func$link1
// file thread-watch.c line 48
static signed int poll_func$link1(struct pollfd *ufds$link1, unsigned int nfds$link1, signed int timeout$link1, void *userdata$link1)
{
  union anonymous$6 *mutex$link1 = (union anonymous$6 *)userdata$link1;
  signed int r$link1;
  pthread_mutex_unlock(mutex$link1);
  r$link1=poll(ufds$link1, (unsigned long int)nfds$link1, timeout$link1);
  pthread_mutex_lock(mutex$link1);
  return r$link1;
}

// poll_func$link1$link1
// file thread-watch.c line 48
static signed int poll_func$link1$link1(struct pollfd *ufds$link1$link1, unsigned int nfds$link1$link1, signed int timeout$link1$link1, void *userdata$link1$link1)
{
  union anonymous$6 *mutex$link1$link1 = (union anonymous$6 *)userdata$link1$link1;
  signed int r$link1$link1;
  pthread_mutex_unlock(mutex$link1$link1);
  r$link1$link1=poll(ufds$link1$link1, (unsigned long int)nfds$link1$link1, timeout$link1$link1);
  pthread_mutex_lock(mutex$link1$link1);
  return r$link1$link1;
}

// poll_func$link2
// file thread-watch.c line 48
static signed int poll_func$link2(struct pollfd *ufds$link2, unsigned int nfds$link2, signed int timeout$link2, void *userdata$link2)
{
  union anonymous$6 *mutex$link2 = (union anonymous$6 *)userdata$link2;
  signed int r$link2;
  pthread_mutex_unlock(mutex$link2);
  r$link2=poll(ufds$link2, (unsigned long int)nfds$link2, timeout$link2);
  pthread_mutex_lock(mutex$link2);
  return r$link2;
}

// poll_func$link3
// file thread-watch.c line 48
static signed int poll_func$link3(struct pollfd *ufds$link3, unsigned int nfds$link3, signed int timeout$link3, void *userdata$link3)
{
  union anonymous$6 *mutex$link3 = (union anonymous$6 *)userdata$link3;
  signed int r$link3;
  pthread_mutex_unlock(mutex$link3);
  r$link3=poll(ufds$link3, (unsigned long int)nfds$link3, timeout$link3);
  pthread_mutex_lock(mutex$link3);
  return r$link3;
}

// prepare_func
// file glib-watch.c line 255
static signed int prepare_func(struct _GSource *source, signed int *timeout)
{
  struct AvahiGLibPoll *g = (struct AvahiGLibPoll *)source;
  struct AvahiTimeout *next_timeout;
  do
    if(g == ((struct AvahiGLibPoll *)NULL))
      g_assertion_message_expr((char *)0, "glib-watch.c", 259, (const char *)"prepare_func", "g");

  while((_Bool)0);
  do
    if(timeout == ((signed int *)NULL))
      g_assertion_message_expr((char *)0, "glib-watch.c", 260, (const char *)"prepare_func", "timeout");

  while((_Bool)0);
  if(!(g->watch_req_cleanup == 0))
    cleanup_watches$link2(g, 0);

  if(!(g->timeout_req_cleanup == 0))
    cleanup_timeouts$link2(g, 0);

  next_timeout=find_next_timeout$link2(g);
  if(!(next_timeout == ((struct AvahiTimeout *)NULL)))
  {
    struct _GTimeVal now;
    struct timeval tvnow;
    signed long int usec;
    g_source_get_current_time(source, &now);
    tvnow.tv_sec = now.tv_sec;
    tvnow.tv_usec = now.tv_usec;
    usec=avahi_timeval_diff(&next_timeout->expiry, &tvnow);
    if(!(usec >= 1l))
    {
      *timeout = 0;
      return (signed int)!(0 != 0);
    }

    *timeout = (signed int)(usec / (signed long int)1000);
  }

  else
    *timeout = -1;
  return 0;
}

// realloc_glue
// file glib-malloc.c line 33
static void * realloc_glue(void *p, unsigned long int l)
{
  void *return_value_g_realloc$1;
  return_value_g_realloc$1=g_realloc(p, l);
  return return_value_g_realloc$1;
}

// rebuild
// file simple-watch.c line 385
static signed int rebuild(struct AvahiSimplePoll$0 *s)
{
  struct AvahiWatch$1 *w;
  signed int idx;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  if(!(s->max_pollfds >= 1 + s->n_watches))
  {
    struct pollfd *n;
    s->max_pollfds = s->n_watches + 10;
    void *return_value_avahi_realloc$1;
    return_value_avahi_realloc$1=avahi_realloc((void *)s->pollfds, sizeof(struct pollfd) /*8ul*/  * (unsigned long int)s->max_pollfds);
    n = (struct pollfd *)return_value_avahi_realloc$1;
    if(n == ((struct pollfd *)NULL))
      return -1;

    s->pollfds = n;
  }

  (s->pollfds + (signed long int)0)->fd = s->wakeup_pipe[(signed long int)0];
  (s->pollfds + (signed long int)0)->events = (signed short int)0x001;
  (s->pollfds + (signed long int)0)->revents = (signed short int)0;
  idx = 1;
  w = s->watches;
  signed int tmp_post$2;
  for( ; !(w == ((struct AvahiWatch$1 *)NULL)); w = w->watches_next)
    if(w->dead == 0)
    {
      /* assertion w->idx < s->max_pollfds */
      assert(w->idx < s->max_pollfds);
      tmp_post$2 = idx;
      idx = idx + 1;
      w->idx = tmp_post$2;
      s->pollfds[(signed long int)w->idx] = w->pollfd;
    }

  s->n_pollfds = idx;
  s->events_valid = 0;
  s->rebuild_pollfds = 0;
  return 0;
}

// rebuild$link1
// file simple-watch.c line 385
static signed int rebuild$link1(struct AvahiSimplePoll$0 *s$link1)
{
  struct AvahiWatch$1 *w$link1;
  signed int idx$link1;
  /* assertion s */
  assert(s$link1 != ((struct AvahiSimplePoll$0 *)NULL));
  if(!(s$link1->max_pollfds >= 1 + s$link1->n_watches))
  {
    struct pollfd *n$link1;
    s$link1->max_pollfds = s$link1->n_watches + 10;
    void *return_value_avahi_realloc$1$link1;
    return_value_avahi_realloc$1$link1=avahi_realloc((void *)s$link1->pollfds, sizeof(struct pollfd) /*8ul*/  * (unsigned long int)s$link1->max_pollfds);
    n$link1 = (struct pollfd *)return_value_avahi_realloc$1$link1;
    if(n$link1 == ((struct pollfd *)NULL))
      return -1;

    s$link1->pollfds = n$link1;
  }

  (s$link1->pollfds + (signed long int)0)->fd = s$link1->wakeup_pipe[(signed long int)0];
  (s$link1->pollfds + (signed long int)0)->events = (signed short int)0x001;
  (s$link1->pollfds + (signed long int)0)->revents = (signed short int)0;
  idx$link1 = 1;
  w$link1 = s$link1->watches;
  signed int tmp_post$2$link1;
  for( ; !(w$link1 == ((struct AvahiWatch$1 *)NULL)); w$link1 = w$link1->watches_next)
    if(w$link1->dead == 0)
    {
      /* assertion w->idx < s->max_pollfds */
      assert(w$link1->idx < s$link1->max_pollfds);
      tmp_post$2$link1 = idx$link1;
      idx$link1 = idx$link1 + 1;
      w$link1->idx = tmp_post$2$link1;
      s$link1->pollfds[(signed long int)w$link1->idx] = w$link1->pollfd;
    }

  s$link1->n_pollfds = idx$link1;
  s$link1->events_valid = 0;
  s$link1->rebuild_pollfds = 0;
  return 0;
}

// rebuild$link1$link1
// file simple-watch.c line 385
static signed int rebuild$link1$link1(struct AvahiSimplePoll$0 *s$link1$link1)
{
  struct AvahiWatch$1 *w$link1$link1;
  signed int idx$link1$link1;
  /* assertion s */
  assert(s$link1$link1 != ((struct AvahiSimplePoll$0 *)NULL));
  if(!(s$link1$link1->max_pollfds >= 1 + s$link1$link1->n_watches))
  {
    struct pollfd *n$link1$link1;
    s$link1$link1->max_pollfds = s$link1$link1->n_watches + 10;
    void *return_value_avahi_realloc$1$link1$link1;
    return_value_avahi_realloc$1$link1$link1=avahi_realloc((void *)s$link1$link1->pollfds, sizeof(struct pollfd) /*8ul*/  * (unsigned long int)s$link1$link1->max_pollfds);
    n$link1$link1 = (struct pollfd *)return_value_avahi_realloc$1$link1$link1;
    if(n$link1$link1 == ((struct pollfd *)NULL))
      return -1;

    s$link1$link1->pollfds = n$link1$link1;
  }

  (s$link1$link1->pollfds + (signed long int)0)->fd = s$link1$link1->wakeup_pipe[(signed long int)0];
  (s$link1$link1->pollfds + (signed long int)0)->events = (signed short int)0x001;
  (s$link1$link1->pollfds + (signed long int)0)->revents = (signed short int)0;
  idx$link1$link1 = 1;
  w$link1$link1 = s$link1$link1->watches;
  signed int tmp_post$2$link1$link1;
  for( ; !(w$link1$link1 == ((struct AvahiWatch$1 *)NULL)); w$link1$link1 = w$link1$link1->watches_next)
    if(w$link1$link1->dead == 0)
    {
      /* assertion w->idx < s->max_pollfds */
      assert(w$link1$link1->idx < s$link1$link1->max_pollfds);
      tmp_post$2$link1$link1 = idx$link1$link1;
      idx$link1$link1 = idx$link1$link1 + 1;
      w$link1$link1->idx = tmp_post$2$link1$link1;
      s$link1$link1->pollfds[(signed long int)w$link1$link1->idx] = w$link1$link1->pollfd;
    }

  s$link1$link1->n_pollfds = idx$link1$link1;
  s$link1$link1->events_valid = 0;
  s$link1$link1->rebuild_pollfds = 0;
  return 0;
}

// rebuild$link2
// file simple-watch.c line 385
static signed int rebuild$link2(struct AvahiSimplePoll *s$link2)
{
  struct AvahiWatch *w$link2;
  signed int idx$link2;
  /* assertion s */
  assert(s$link2 != ((struct AvahiSimplePoll *)NULL));
  if(!(s$link2->max_pollfds >= 1 + s$link2->n_watches))
  {
    struct pollfd *n$link2;
    s$link2->max_pollfds = s$link2->n_watches + 10;
    void *return_value_avahi_realloc$1$link2;
    return_value_avahi_realloc$1$link2=avahi_realloc((void *)s$link2->pollfds, sizeof(struct pollfd) /*8ul*/  * (unsigned long int)s$link2->max_pollfds);
    n$link2 = (struct pollfd *)return_value_avahi_realloc$1$link2;
    if(n$link2 == ((struct pollfd *)NULL))
      return -1;

    s$link2->pollfds = n$link2;
  }

  (s$link2->pollfds + (signed long int)0)->fd = s$link2->wakeup_pipe[(signed long int)0];
  (s$link2->pollfds + (signed long int)0)->events = (signed short int)0x001;
  (s$link2->pollfds + (signed long int)0)->revents = (signed short int)0;
  idx$link2 = 1;
  w$link2 = s$link2->watches;
  signed int tmp_post$2$link2;
  for( ; !(w$link2 == ((struct AvahiWatch *)NULL)); w$link2 = w$link2->watches_next)
    if(w$link2->dead == 0)
    {
      /* assertion w->idx < s->max_pollfds */
      assert(w$link2->idx < s$link2->max_pollfds);
      tmp_post$2$link2 = idx$link2;
      idx$link2 = idx$link2 + 1;
      w$link2->idx = tmp_post$2$link2;
      s$link2->pollfds[(signed long int)w$link2->idx] = w$link2->pollfd;
    }

  s$link2->n_pollfds = idx$link2;
  s$link2->events_valid = 0;
  s$link2->rebuild_pollfds = 0;
  return 0;
}

// rebuild$link3
// file simple-watch.c line 385
static signed int rebuild$link3(struct AvahiSimplePoll$0 *s$link3)
{
  struct AvahiWatch$1 *w$link3;
  signed int idx$link3;
  /* assertion s */
  assert(s$link3 != ((struct AvahiSimplePoll$0 *)NULL));
  if(!(s$link3->max_pollfds >= 1 + s$link3->n_watches))
  {
    struct pollfd *n$link3;
    s$link3->max_pollfds = s$link3->n_watches + 10;
    void *return_value_avahi_realloc$1$link3;
    return_value_avahi_realloc$1$link3=avahi_realloc((void *)s$link3->pollfds, sizeof(struct pollfd) /*8ul*/  * (unsigned long int)s$link3->max_pollfds);
    n$link3 = (struct pollfd *)return_value_avahi_realloc$1$link3;
    if(n$link3 == ((struct pollfd *)NULL))
      return -1;

    s$link3->pollfds = n$link3;
  }

  (s$link3->pollfds + (signed long int)0)->fd = s$link3->wakeup_pipe[(signed long int)0];
  (s$link3->pollfds + (signed long int)0)->events = (signed short int)0x001;
  (s$link3->pollfds + (signed long int)0)->revents = (signed short int)0;
  idx$link3 = 1;
  w$link3 = s$link3->watches;
  signed int tmp_post$2$link3;
  for( ; !(w$link3 == ((struct AvahiWatch$1 *)NULL)); w$link3 = w$link3->watches_next)
    if(w$link3->dead == 0)
    {
      /* assertion w->idx < s->max_pollfds */
      assert(w$link3->idx < s$link3->max_pollfds);
      tmp_post$2$link3 = idx$link3;
      idx$link3 = idx$link3 + 1;
      w$link3->idx = tmp_post$2$link3;
      s$link3->pollfds[(signed long int)w$link3->idx] = w$link3->pollfd;
    }

  s$link3->n_pollfds = idx$link3;
  s$link3->events_valid = 0;
  s$link3->rebuild_pollfds = 0;
  return 0;
}

// remove_pollfd
// file simple-watch.c line 194
static void remove_pollfd(struct AvahiWatch$1 *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch$1 *)NULL));
  if(!(w->idx == -1))
    w->simple_poll->rebuild_pollfds = 1;

}

// remove_pollfd$link1
// file simple-watch.c line 194
static void remove_pollfd$link1(struct AvahiWatch$1 *w$link1)
{
  /* assertion w */
  assert(w$link1 != ((struct AvahiWatch$1 *)NULL));
  if(!(w$link1->idx == -1))
    w$link1->simple_poll->rebuild_pollfds = 1;

}

// remove_pollfd$link1$link1
// file simple-watch.c line 194
static void remove_pollfd$link1$link1(struct AvahiWatch$1 *w$link1$link1)
{
  /* assertion w */
  assert(w$link1$link1 != ((struct AvahiWatch$1 *)NULL));
  if(!(w$link1$link1->idx == -1))
    w$link1$link1->simple_poll->rebuild_pollfds = 1;

}

// remove_pollfd$link2
// file simple-watch.c line 194
static void remove_pollfd$link2(struct AvahiWatch *w$link2)
{
  /* assertion w */
  assert(w$link2 != ((struct AvahiWatch *)NULL));
  if(!(w$link2->idx == -1))
    w$link2->simple_poll->rebuild_pollfds = 1;

}

// remove_pollfd$link3
// file simple-watch.c line 194
static void remove_pollfd$link3(struct AvahiWatch$1 *w$link3)
{
  /* assertion w */
  assert(w$link3 != ((struct AvahiWatch$1 *)NULL));
  if(!(w$link3->idx == -1))
    w$link3->simple_poll->rebuild_pollfds = 1;

}

// remove_timeout
// file ../avahi-common/dbus-watch-glue.c line 286
static void remove_timeout(struct DBusTimeout *dbus_timeout, void *userdata)
{
  struct anonymous$28 *d = (struct anonymous$28 *)userdata;
  struct TimeoutData *timeout;
  /* assertion dbus_timeout */
  assert(dbus_timeout != ((struct DBusTimeout *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous$28 *)NULL));
  void *return_value_dbus_timeout_get_data$1;
  return_value_dbus_timeout_get_data$1=dbus_timeout_get_data(dbus_timeout);
  timeout = (struct TimeoutData *)return_value_dbus_timeout_get_data$1;
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  d->poll_api->timeout_free(timeout->avahi_timeout);
  timeout->avahi_timeout = (struct AvahiTimeout$1 *)(void *)0;
}

// remove_timeout$link1
// file ../avahi-common/dbus-watch-glue.c line 286
static void remove_timeout$link1(struct DBusTimeout *dbus_timeout$link1, void *userdata$link1)
{
  struct anonymous$28 *d$link1 = (struct anonymous$28 *)userdata$link1;
  struct TimeoutData *timeout$link1;
  /* assertion dbus_timeout */
  assert(dbus_timeout$link1 != ((struct DBusTimeout *)NULL));
  /* assertion d */
  assert(d$link1 != ((struct anonymous$28 *)NULL));
  void *return_value_dbus_timeout_get_data$1$link1;
  return_value_dbus_timeout_get_data$1$link1=dbus_timeout_get_data(dbus_timeout$link1);
  timeout$link1 = (struct TimeoutData *)return_value_dbus_timeout_get_data$1$link1;
  /* assertion timeout */
  assert(timeout$link1 != ((struct TimeoutData *)NULL));
  d$link1->poll_api->timeout_free(timeout$link1->avahi_timeout);
  timeout$link1->avahi_timeout = (struct AvahiTimeout$1 *)(void *)0;
}

// remove_watch
// file ../avahi-common/dbus-watch-glue.c line 174
static void remove_watch(struct DBusWatch *dbus_watch, void *userdata)
{
  struct anonymous$28 *d = (struct anonymous$28 *)userdata;
  struct AvahiWatch$1 *avahi_watch;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous$28 *)NULL));
  void *return_value_dbus_watch_get_data$1;
  return_value_dbus_watch_get_data$1=dbus_watch_get_data(dbus_watch);
  avahi_watch = (struct AvahiWatch$1 *)return_value_dbus_watch_get_data$1;
  if(!(avahi_watch == ((struct AvahiWatch$1 *)NULL)))
  {
    d->poll_api->watch_free(avahi_watch);
    dbus_watch_set_data(dbus_watch, (void *)0, (void (*)(void *))(void *)0);
  }

}

// remove_watch$link1
// file ../avahi-common/dbus-watch-glue.c line 174
static void remove_watch$link1(struct DBusWatch *dbus_watch$link1, void *userdata$link1)
{
  struct anonymous$28 *d$link1 = (struct anonymous$28 *)userdata$link1;
  struct AvahiWatch$1 *avahi_watch$link1;
  /* assertion dbus_watch */
  assert(dbus_watch$link1 != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d$link1 != ((struct anonymous$28 *)NULL));
  void *return_value_dbus_watch_get_data$1$link1;
  return_value_dbus_watch_get_data$1$link1=dbus_watch_get_data(dbus_watch$link1);
  avahi_watch$link1 = (struct AvahiWatch$1 *)return_value_dbus_watch_get_data$1$link1;
  if(!(avahi_watch$link1 == ((struct AvahiWatch$1 *)NULL)))
  {
    d$link1->poll_api->watch_free(avahi_watch$link1);
    dbus_watch_set_data(dbus_watch$link1, (void *)0, (void (*)(void *))(void *)0);
  }

}

// request_dispatch
// file ../avahi-common/dbus-watch-glue.c line 86
static void request_dispatch(struct anonymous$28 *d, signed int enable)
{
  /* assertion d */
  assert(d != ((struct anonymous$28 *)NULL));
  if(!(enable == 0))
  {
    enum anonymous$27 return_value_dbus_connection_get_dispatch_status$1;
    return_value_dbus_connection_get_dispatch_status$1=dbus_connection_get_dispatch_status(d->connection);
    /* assertion dbus_connection_get_dispatch_status(d->connection) == DBUS_DISPATCH_DATA_REMAINS */
    assert((signed int)return_value_dbus_connection_get_dispatch_status$1 == DBUS_DISPATCH_DATA_REMAINS);
    static struct timeval tv = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
    d->poll_api->timeout_update(d->dispatch_timeout, &tv);
  }

  else
    d->poll_api->timeout_update(d->dispatch_timeout, (struct timeval *)(void *)0);
}

// request_dispatch$link1
// file ../avahi-common/dbus-watch-glue.c line 86
static void request_dispatch$link1(struct anonymous$28 *d$link1, signed int enable$link1)
{
  /* assertion d */
  assert(d$link1 != ((struct anonymous$28 *)NULL));
  if(!(enable$link1 == 0))
  {
    enum anonymous$27 return_value_dbus_connection_get_dispatch_status$1$link1;
    return_value_dbus_connection_get_dispatch_status$1$link1=dbus_connection_get_dispatch_status(d$link1->connection);
    /* assertion dbus_connection_get_dispatch_status(d->connection) == DBUS_DISPATCH_DATA_REMAINS */
    assert((signed int)return_value_dbus_connection_get_dispatch_status$1$link1 == DBUS_DISPATCH_DATA_REMAINS);
    static struct timeval tv$link1 = { .tv_sec=(signed long int)0, .tv_usec=(signed long int)0 };
    d$link1->poll_api->timeout_update(d$link1->dispatch_timeout, &tv$link1);
  }

  else
    d$link1->poll_api->timeout_update(d$link1->dispatch_timeout, (struct timeval *)(void *)0);
}

// resolve_callback
// file avahi-ui.c line 335
static void resolve_callback(struct AvahiServiceResolver *r, signed int interface, signed int protocol, enum anonymous$12 event, const char *name, const char *type, const char *domain, const char *host_name, const struct AvahiAddress *a, unsigned short int port, struct AvahiStringList *txt, enum anonymous$13 flags, void *userdata)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)userdata, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_dialog_get_type$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  struct _GtkWidget *m;
  unsigned long int return_value_gtk_window_get_type$5;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  char *return_value_dgettext$7;
  signed int return_value_avahi_client_errno$8;
  const char *return_value_avahi_strerror$9;
  unsigned long int return_value_gtk_dialog_get_type$10;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  unsigned long int return_value_gtk_dialog_get_type$12;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  switch((signed int)event)
  {
    case AVAHI_RESOLVER_FOUND:
    {
      d->priv->resolve_service_done = 1;
      g_free((void *)d->priv->service_name);
      d->priv->service_name=g_strdup(name);
      g_free((void *)d->priv->service_type);
      d->priv->service_type=g_strdup(type);
      g_free((void *)d->priv->domain);
      d->priv->domain=g_strdup(domain);
      g_free((void *)d->priv->host_name);
      d->priv->host_name=g_strdup(host_name);
      d->priv->port = port;
      avahi_string_list_free(d->priv->txt_data);
      d->priv->txt_data=avahi_string_list_copy(txt);
      if(!(a == ((const struct AvahiAddress *)NULL)))
      {
        d->priv->resolve_host_name_done = 1;
        d->priv->address = *a;
      }

      return_value_gtk_dialog_get_type$3=gtk_dialog_get_type();
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$3);
      gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$4, d->priv->forward_response_id);
      break;
    }
    case AVAHI_RESOLVER_FAILURE:
    {
      return_value_gtk_window_get_type$5=gtk_window_get_type();
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type$5);
      return_value_dgettext$7=dgettext("avahi", "Avahi resolver failure: %s");
      return_value_avahi_client_errno$8=avahi_client_errno(d->priv->client);
      return_value_avahi_strerror$9=avahi_strerror(return_value_avahi_client_errno$8);
      m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$6, (enum anonymous$30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$29)GTK_MESSAGE_ERROR, (enum anonymous$17)GTK_BUTTONS_CLOSE, return_value_dgettext$7, return_value_avahi_strerror$9);
      return_value_gtk_dialog_get_type$10=gtk_dialog_get_type();
      return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type$10);
      gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$11);
      gtk_widget_destroy(m);
      return_value_gtk_dialog_get_type$12=gtk_dialog_get_type();
      return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$12);
      gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$13, -6);
    }
  }
}

// response_callback
// file avahi-ui.c line 859
static void response_callback(struct _GtkDialog *dialog, signed int response, void *user_data)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  _Bool tmp_if_expr$25;
  _Bool tmp_if_expr$27;
  _Bool tmp_if_expr$26;
  if(response == -10 || response == -8 || response == -5 || response == -3)
  {
    if(!(d->priv->resolve_service == 0))
      tmp_if_expr$25 = !(d->priv->resolve_service_done != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$25 = (_Bool)0;
    if(tmp_if_expr$25)
      tmp_if_expr$27 = (_Bool)1;

    else
    {
      if(!(d->priv->resolve_host_name == 0))
        tmp_if_expr$26 = !(d->priv->resolve_host_name_done != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$26 = (_Bool)0;
      tmp_if_expr$27 = tmp_if_expr$26 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$27)
    {
      struct _GtkTreeIter iter;
      signed int interface;
      signed int protocol;
      char *name;
      char *type;
      struct _GdkCursor *cursor;
      unsigned long int return_value_gtk_dialog_get_type$3;
      return_value_gtk_dialog_get_type$3=gtk_dialog_get_type();
      unsigned int return_value_g_signal_lookup$4;
      return_value_g_signal_lookup$4=g_signal_lookup("response", return_value_gtk_dialog_get_type$3);
      g_signal_stop_emission((void *)dialog, return_value_g_signal_lookup$4, (unsigned int)0);
      d->priv->forward_response_id = response;
      if(!(d->priv->resolver == ((struct AvahiServiceResolver *)NULL)))
        goto __CPROVER_DUMP_L13;

      do
      {
        unsigned long int return_value_gtk_tree_view_get_type$5;
        return_value_gtk_tree_view_get_type$5=gtk_tree_view_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
        return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type$5);
        struct _GtkTreeSelection *return_value_gtk_tree_view_get_selection$7;
        return_value_gtk_tree_view_get_selection$7=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$6);
        signed int return_value_gtk_tree_selection_get_selected$8;
        return_value_gtk_tree_selection_get_selected$8=gtk_tree_selection_get_selected(return_value_gtk_tree_view_get_selection$7, (struct _GtkTreeModel **)(void *)0, &iter);
        if(return_value_gtk_tree_selection_get_selected$8 == 0)
        {
          g_return_if_fail_warning((char *)0, (const char *)"response_callback", "gtk_tree_selection_get_selected(gtk_tree_view_get_selection(GTK_TREE_VIEW(d->priv->service_tree_view)), NULL, &iter)");
          goto __CPROVER_DUMP_L13;
        }

      }
      while((_Bool)0);
      unsigned long int return_value_gtk_tree_model_get_type$9;
      return_value_gtk_tree_model_get_type$9=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
      return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_list_store, return_value_gtk_tree_model_get_type$9);
      gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$10, &iter, 0, &interface, 1, &protocol, 3, &name, 2, &type, -1);
      do
        if(d->priv->client == ((struct AvahiClient *)NULL))
        {
          g_return_if_fail_warning((char *)0, (const char *)"response_callback", "d->priv->client");
          goto __CPROVER_DUMP_L13;
        }

      while((_Bool)0);
      unsigned long int return_value_gtk_widget_get_type$11;
      return_value_gtk_widget_get_type$11=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
      return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_widget_get_type$11);
      gtk_widget_set_sensitive((struct _GtkWidget *)return_value_g_type_check_instance_cast$12, 0);
      cursor=gdk_cursor_new((enum anonymous$34)GDK_WATCH);
      unsigned long int return_value_gtk_widget_get_type$13;
      return_value_gtk_widget_get_type$13=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
      return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_widget_get_type$13);
      struct _GdkWindow *return_value_gtk_widget_get_window$15;
      return_value_gtk_widget_get_window$15=gtk_widget_get_window((struct _GtkWidget *)return_value_g_type_check_instance_cast$14);
      gdk_window_set_cursor(return_value_gtk_widget_get_window$15, cursor);
      g_object_unref((void *)cursor);
      d->priv->resolver=avahi_service_resolver_new(d->priv->client, interface, protocol, name, type, d->priv->domain, d->priv->address_family, (enum anonymous$44)(!(d->priv->resolve_host_name != 0) ? AVAHI_LOOKUP_NO_ADDRESS : 0), resolve_callback, (void *)d);
      if(d->priv->resolver == ((struct AvahiServiceResolver *)NULL))
      {
        struct _GtkWidget *m;
        unsigned long int return_value_gtk_window_get_type$16;
        return_value_gtk_window_get_type$16=gtk_window_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
        return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type$16);
        char *return_value_dgettext$18;
        return_value_dgettext$18=dgettext("avahi", "Failed to create resolver for %s of type %s in domain %s: %s");
        signed int return_value_avahi_client_errno$19;
        return_value_avahi_client_errno$19=avahi_client_errno(d->priv->client);
        const char *return_value_avahi_strerror$20;
        return_value_avahi_strerror$20=avahi_strerror(return_value_avahi_client_errno$19);
        m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$17, (enum anonymous$30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$29)GTK_MESSAGE_ERROR, (enum anonymous$17)GTK_BUTTONS_CLOSE, return_value_dgettext$18, name, type, d->priv->domain, return_value_avahi_strerror$20);
        unsigned long int return_value_gtk_dialog_get_type$21;
        return_value_gtk_dialog_get_type$21=gtk_dialog_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
        return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type$21);
        gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$22);
        gtk_widget_destroy(m);
        unsigned long int return_value_gtk_dialog_get_type$23;
        return_value_gtk_dialog_get_type$23=gtk_dialog_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
        return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$23);
        gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$24, -6);
        goto __CPROVER_DUMP_L13;
      }

    }

  }


__CPROVER_DUMP_L13:
  ;
}

// restart_browsing
// file avahi-ui.c line 1207
static void restart_browsing(struct _AuiServiceDialog *d)
{
  signed int tmp_statement_expression$1;
  _Bool tmp_if_expr$2;
  do
  {
    struct _GTypeInstance *__inst = (struct _GTypeInstance *)d;
    unsigned long int __t;
    __t=aui_service_dialog_get_type();
    signed int __r;
    if(__inst == ((struct _GTypeInstance *)NULL))
      __r = 0;

    else
    {
      if(!(__inst->g_class == ((struct _GTypeClass *)NULL)))
        tmp_if_expr$2 = __inst->g_class->g_type == __t ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        __r = (signed int)!(0 != 0);

      else
        __r=g_type_check_instance_is_a(__inst, __t);
    }
    tmp_statement_expression$1 = __r;
    if(tmp_statement_expression$1 == 0)
    {
      g_return_if_fail_warning((char *)0, (const char *)"restart_browsing", "AUI_IS_SERVICE_DIALOG(d)");
      goto __CPROVER_DUMP_L8;
    }

  }
  while((_Bool)0);
  if(!(d->priv->start_idle >= 1u))
    d->priv->start_idle=g_idle_add(start_callback, (void *)d);


__CPROVER_DUMP_L8:
  ;
}

// retrieve_state
// file entrygroup.c line 52
static signed int retrieve_state(struct AvahiEntryGroup *group)
{
  struct DBusMessage *message = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply = (struct DBusMessage *)(void *)0;
  struct DBusError error;
  signed int r = 0;
  signed int state;
  struct AvahiClient *client;
  dbus_error_init(&error);
  /* assertion group */
  assert(group != ((struct AvahiEntryGroup *)NULL));
  client = group->client;
  message=dbus_message_new_method_call("org.freedesktop.Avahi", group->path, "org.freedesktop.Avahi.EntryGroup", "GetState");
  _Bool tmp_if_expr$2;
  unsigned int return_value_dbus_error_is_set$1;
  unsigned int return_value_dbus_message_get_args$3;
  _Bool tmp_if_expr$5;
  unsigned int return_value_dbus_error_is_set$4;
  if(message == ((struct DBusMessage *)NULL))
    r=avahi_client_set_errno(client, -24);

  else
  {
    reply=dbus_connection_send_with_reply_and_block(client->bus, message, -1, &error);
    if(reply == ((struct DBusMessage *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$1=dbus_error_is_set(&error);
      tmp_if_expr$2 = return_value_dbus_error_is_set$1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      r=avahi_client_set_errno(client, -22);

    else
    {
      return_value_dbus_message_get_args$3=dbus_message_get_args(reply, &error, (signed int)105, &state, (signed int)0);
      if(return_value_dbus_message_get_args$3 == 0u)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$4=dbus_error_is_set(&error);
        tmp_if_expr$5 = return_value_dbus_error_is_set$4 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        r=avahi_client_set_errno(client, -22);

      else
      {
        dbus_message_unref(message);
        dbus_message_unref(reply);
        return state;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$6;
  return_value_dbus_error_is_set$6=dbus_error_is_set(&error);
  if(!(return_value_dbus_error_is_set$6 == 0u))
  {
    r=avahi_client_set_dbus_error(client, &error);
    dbus_error_free(&error);
  }

  if(!(message == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message);

  if(!(reply == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply);

  return r;
}

// retrieve_state$link1
// file entrygroup.c line 52
static signed int retrieve_state$link1(struct AvahiEntryGroup *group$link1)
{
  struct DBusMessage *message$link1 = (struct DBusMessage *)(void *)0;
  struct DBusMessage *reply$link1 = (struct DBusMessage *)(void *)0;
  struct DBusError error$link1;
  signed int r$link1 = 0;
  signed int state$link1;
  struct AvahiClient *client$link1;
  dbus_error_init(&error$link1);
  /* assertion group */
  assert(group$link1 != ((struct AvahiEntryGroup *)NULL));
  client$link1 = group$link1->client;
  message$link1=dbus_message_new_method_call("org.freedesktop.Avahi", group$link1->path, "org.freedesktop.Avahi.EntryGroup", "GetState");
  _Bool tmp_if_expr$2$link1;
  unsigned int return_value_dbus_error_is_set$1$link1;
  unsigned int return_value_dbus_message_get_args$3$link1;
  _Bool tmp_if_expr$5$link1;
  unsigned int return_value_dbus_error_is_set$4$link1;
  if(message$link1 == ((struct DBusMessage *)NULL))
    r$link1=avahi_client_set_errno(client$link1, -24);

  else
  {
    reply$link1=dbus_connection_send_with_reply_and_block(client$link1->bus, message$link1, -1, &error$link1);
    if(reply$link1 == ((struct DBusMessage *)NULL))
      tmp_if_expr$2$link1 = (_Bool)1;

    else
    {
      return_value_dbus_error_is_set$1$link1=dbus_error_is_set(&error$link1);
      tmp_if_expr$2$link1 = return_value_dbus_error_is_set$1$link1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2$link1)
      r$link1=avahi_client_set_errno(client$link1, -22);

    else
    {
      return_value_dbus_message_get_args$3$link1=dbus_message_get_args(reply$link1, &error$link1, (signed int)105, &state$link1, (signed int)0);
      if(return_value_dbus_message_get_args$3$link1 == 0u)
        tmp_if_expr$5$link1 = (_Bool)1;

      else
      {
        return_value_dbus_error_is_set$4$link1=dbus_error_is_set(&error$link1);
        tmp_if_expr$5$link1 = return_value_dbus_error_is_set$4$link1 != 0u ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5$link1)
        r$link1=avahi_client_set_errno(client$link1, -22);

      else
      {
        dbus_message_unref(message$link1);
        dbus_message_unref(reply$link1);
        return state$link1;
      }
    }
  }

fail:
  ;
  unsigned int return_value_dbus_error_is_set$6$link1;
  return_value_dbus_error_is_set$6$link1=dbus_error_is_set(&error$link1);
  if(!(return_value_dbus_error_is_set$6$link1 == 0u))
  {
    r$link1=avahi_client_set_dbus_error(client$link1, &error$link1);
    dbus_error_free(&error$link1);
  }

  if(!(message$link1 == ((struct DBusMessage *)NULL)))
    dbus_message_unref(message$link1);

  if(!(reply$link1 == ((struct DBusMessage *)NULL)))
    dbus_message_unref(reply$link1);

  return r$link1;
}

// service_pulse_callback
// file avahi-ui.c line 304
static signed int service_pulse_callback(void *data)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)data, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_progress_bar_get_type$3;
  return_value_gtk_progress_bar_get_type$3=gtk_progress_bar_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_progress_bar, return_value_gtk_progress_bar_get_type$3);
  gtk_progress_bar_pulse((struct _GtkProgressBar *)return_value_g_type_check_instance_cast$4);
  return (signed int)!(0 != 0);
}

// service_row_activated_callback
// file avahi-ui.c line 842
static void service_row_activated_callback(struct _GtkTreeView *tree_view, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_dialog_get_type$3;
  return_value_gtk_dialog_get_type$3=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$3);
  unsigned long int return_value_gtk_dialog_get_type$5;
  return_value_gtk_dialog_get_type$5=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$5);
  signed int return_value_get_default_response$7;
  return_value_get_default_response$7=get_default_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$6);
  gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$4, return_value_get_default_response$7);
}

// service_selection_changed_callback
// file avahi-ui.c line 848
static void service_selection_changed_callback(struct _GtkTreeSelection *selection, void *user_data)
{
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)user_data, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  signed int b;
  b=gtk_tree_selection_get_selected(selection, (struct _GtkTreeModel **)(void *)0, (struct _GtkTreeIter *)(void *)0);
  unsigned long int return_value_gtk_dialog_get_type$3;
  return_value_gtk_dialog_get_type$3=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$3);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast$4, -3, b);
  unsigned long int return_value_gtk_dialog_get_type$5;
  return_value_gtk_dialog_get_type$5=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$5);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast$6, -5, b);
  unsigned long int return_value_gtk_dialog_get_type$7;
  return_value_gtk_dialog_get_type$7=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$7);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast$8, -8, b);
  unsigned long int return_value_gtk_dialog_get_type$9;
  return_value_gtk_dialog_get_type$9=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$9);
  gtk_dialog_set_response_sensitive((struct _GtkDialog *)return_value_g_type_check_instance_cast$10, -10, b);
}

// set_nonblock
// file simple-watch.c line 118
static signed int set_nonblock(signed int fd)
{
  signed int n;
  /* assertion fd >= 0 */
  assert(fd >= 0);
  n=fcntl(fd, 3);
  if(!(n >= 0))
    return -1;

  else
    if(!((04000 & n) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl$1;
      return_value_fcntl$1=fcntl(fd, 4, n | 04000);
      return return_value_fcntl$1;
    }
}

// set_nonblock$link1
// file simple-watch.c line 118
static signed int set_nonblock$link1(signed int fd$link1)
{
  signed int n$link1;
  /* assertion fd >= 0 */
  assert(fd$link1 >= 0);
  n$link1=fcntl(fd$link1, 3);
  if(!(n$link1 >= 0))
    return -1;

  else
    if(!((04000 & n$link1) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl$1$link1;
      return_value_fcntl$1$link1=fcntl(fd$link1, 4, n$link1 | 04000);
      return return_value_fcntl$1$link1;
    }
}

// set_nonblock$link1$link1
// file simple-watch.c line 118
static signed int set_nonblock$link1$link1(signed int fd$link1$link1)
{
  signed int n$link1$link1;
  /* assertion fd >= 0 */
  assert(fd$link1$link1 >= 0);
  n$link1$link1=fcntl(fd$link1$link1, 3);
  if(!(n$link1$link1 >= 0))
    return -1;

  else
    if(!((04000 & n$link1$link1) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl$1$link1$link1;
      return_value_fcntl$1$link1$link1=fcntl(fd$link1$link1, 4, n$link1$link1 | 04000);
      return return_value_fcntl$1$link1$link1;
    }
}

// set_nonblock$link2
// file simple-watch.c line 118
static signed int set_nonblock$link2(signed int fd$link2)
{
  signed int n$link2;
  /* assertion fd >= 0 */
  assert(fd$link2 >= 0);
  n$link2=fcntl(fd$link2, 3);
  if(!(n$link2 >= 0))
    return -1;

  else
    if(!((04000 & n$link2) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl$1$link2;
      return_value_fcntl$1$link2=fcntl(fd$link2, 4, n$link2 | 04000);
      return return_value_fcntl$1$link2;
    }
}

// set_nonblock$link3
// file simple-watch.c line 118
static signed int set_nonblock$link3(signed int fd$link3)
{
  signed int n$link3;
  /* assertion fd >= 0 */
  assert(fd$link3 >= 0);
  n$link3=fcntl(fd$link3, 3);
  if(!(n$link3 >= 0))
    return -1;

  else
    if(!((04000 & n$link3) == 0))
      return 0;

    else
    {
      signed int return_value_fcntl$1$link3;
      return_value_fcntl$1$link3=fcntl(fd$link3, 4, n$link3 | 04000);
      return return_value_fcntl$1$link3;
    }
}

// start_callback
// file avahi-ui.c line 695
static signed int start_callback(void *data)
{
  signed int error;
  struct _AuiServiceDialog *d;
  unsigned long int return_value_aui_service_dialog_get_type$1;
  return_value_aui_service_dialog_get_type$1=aui_service_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)data, return_value_aui_service_dialog_get_type$1);
  d = (struct _AuiServiceDialog *)return_value_g_type_check_instance_cast$2;
  char **st;
  struct AvahiServiceBrowser **sb;
  unsigned int i;
  const char *domain;
  d->priv->start_idle = (unsigned int)0;
  _Bool tmp_if_expr$4;
  if(d->priv->browse_service_types == ((char **)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = !(*d->priv->browse_service_types != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$4)
  {
    char *return_value_dgettext$3;
    return_value_dgettext$3=dgettext("avahi", "Browse service type list is empty!");
    g_log((char *)0, (enum anonymous$10)G_LOG_LEVEL_WARNING, return_value_dgettext$3);
    return 0;
  }

  if(d->priv->client == ((struct AvahiClient *)NULL))
  {
    const struct AvahiPoll$1 *return_value_avahi_glib_poll_get$13;
    return_value_avahi_glib_poll_get$13=avahi_glib_poll_get(d->priv->glib_poll);
    d->priv->client=avahi_client_new(return_value_avahi_glib_poll_get$13, (enum anonymous$39)0, client_callback, (void *)d, &error);
    if(d->priv->client == ((struct AvahiClient *)NULL))
    {
      struct _GtkWidget *m;
      unsigned long int return_value_gtk_window_get_type$5;
      return_value_gtk_window_get_type$5=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type$5);
      char *return_value_dgettext$7;
      return_value_dgettext$7=dgettext("avahi", "Failed to connect to Avahi server: %s");
      const char *return_value_avahi_strerror$8;
      return_value_avahi_strerror$8=avahi_strerror(error);
      m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$6, (enum anonymous$30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$29)GTK_MESSAGE_ERROR, (enum anonymous$17)GTK_BUTTONS_CLOSE, return_value_dgettext$7, return_value_avahi_strerror$8);
      unsigned long int return_value_gtk_dialog_get_type$9;
      return_value_gtk_dialog_get_type$9=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
      return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)m, return_value_gtk_dialog_get_type$9);
      gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$10);
      gtk_widget_destroy(m);
      unsigned long int return_value_gtk_dialog_get_type$11;
      return_value_gtk_dialog_get_type$11=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
      return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$11);
      gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$12, -6);
      return 0;
    }

  }

  domain=get_domain_name(d);
  if(domain == ((const char *)NULL))
  {
    unsigned long int return_value_gtk_dialog_get_type$14;
    return_value_gtk_dialog_get_type$14=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$14);
    gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$15, -6);
    return 0;
  }

  do
    if(domain == ((const char *)NULL))
      g_assertion_message_expr((char *)0, "avahi-ui.c", 732, (const char *)"start_callback", "domain");

  while((_Bool)0);
  signed int return_value_avahi_domain_equal$22;
  return_value_avahi_domain_equal$22=avahi_domain_equal(domain, "local.");
  unsigned long int return_value_gtk_label_get_type$16;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  char *return_value_dgettext$18;
  if(!(return_value_avahi_domain_equal$22 == 0))
  {
    return_value_gtk_label_get_type$16=gtk_label_get_type();
    return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_label, return_value_gtk_label_get_type$16);
    return_value_dgettext$18=dgettext("avahi", "Browsing for services on <b>local network</b>:");
    gtk_label_set_markup((struct _GtkLabel *)return_value_g_type_check_instance_cast$17, return_value_dgettext$18);
  }

  else
  {
    char *t;
    char *return_value_dgettext$19;
    return_value_dgettext$19=dgettext("avahi", "Browsing for services in domain <b>%s</b>:");
    t=g_strdup_printf(return_value_dgettext$19, domain);
    unsigned long int return_value_gtk_label_get_type$20;
    return_value_gtk_label_get_type$20=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
    return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->domain_label, return_value_gtk_label_get_type$20);
    gtk_label_set_markup((struct _GtkLabel *)return_value_g_type_check_instance_cast$21, t);
    g_free((void *)t);
  }
  if(!(d->priv->browsers == ((struct AvahiServiceBrowser **)NULL)))
  {
    sb = d->priv->browsers;
    for( ; !(*sb == ((struct AvahiServiceBrowser *)NULL)); sb = sb + 1l)
      avahi_service_browser_free(*sb);
    g_free((void *)d->priv->browsers);
    d->priv->browsers = (struct AvahiServiceBrowser **)(void *)0;
  }

  unsigned long int return_value_gtk_list_store_get_type$23;
  return_value_gtk_list_store_get_type$23=gtk_list_store_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_list_store, return_value_gtk_list_store_get_type$23);
  gtk_list_store_clear((struct _GtkListStore *)return_value_g_type_check_instance_cast$24);
  d->priv->common_interface = -1;
  d->priv->common_protocol = -1;
  unsigned long int return_value_gtk_tree_view_get_type$25;
  return_value_gtk_tree_view_get_type$25=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type$25);
  struct _GtkTreeViewColumn *return_value_gtk_tree_view_get_column$27;
  return_value_gtk_tree_view_get_column$27=gtk_tree_view_get_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$26, 0);
  gtk_tree_view_column_set_visible(return_value_gtk_tree_view_get_column$27, 0);
  unsigned long int return_value_gtk_tree_view_get_type$28;
  return_value_gtk_tree_view_get_type$28=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
  return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)d->priv->service_tree_view, return_value_gtk_tree_view_get_type$28);
  gtk_tree_view_set_headers_visible((struct _GtkTreeView *)return_value_g_type_check_instance_cast$29, 0);
  gtk_widget_show(d->priv->service_progress_bar);
  if(!(d->priv->service_pulse_timeout >= 1u))
    d->priv->service_pulse_timeout=g_timeout_add((unsigned int)100, service_pulse_callback, (void *)d);

  i = (unsigned int)0;
  for( ; !(d->priv->browse_service_types[(signed long int)i] == ((char *)NULL)); i = i + 1u)
    ;
  do
    if(!(i >= 1u))
      g_assertion_message_expr((char *)0, "avahi-ui.c", 763, (const char *)"start_callback", "i > 0");

  while((_Bool)0);
  void *return_value_g_malloc0_n$30;
  return_value_g_malloc0_n$30=g_malloc0_n((unsigned long int)(i + (unsigned int)1), sizeof(struct AvahiServiceBrowser *) /*8ul*/ );
  d->priv->browsers = (struct AvahiServiceBrowser **)return_value_g_malloc0_n$30;
  st = d->priv->browse_service_types;
  sb = d->priv->browsers;
  for( ; !(*st == ((char *)NULL)); sb = sb + 1l)
  {
    *sb=avahi_service_browser_new(d->priv->client, -1, -1, *st, d->priv->domain, (enum anonymous$44)0, browse_callback, (void *)d);
    if(*sb == ((struct AvahiServiceBrowser *)NULL))
    {
      struct _GtkWidget *start_callback$$1$$9$$1$$1$$m;
      unsigned long int return_value_gtk_window_get_type$31;
      return_value_gtk_window_get_type$31=gtk_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
      return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_window_get_type$31);
      char *return_value_dgettext$33;
      return_value_dgettext$33=dgettext("avahi", "Failed to create browser for %s: %s");
      signed int return_value_avahi_client_errno$34;
      return_value_avahi_client_errno$34=avahi_client_errno(d->priv->client);
      const char *return_value_avahi_strerror$35;
      return_value_avahi_strerror$35=avahi_strerror(return_value_avahi_client_errno$34);
      start_callback$$1$$9$$1$$1$$m=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$32, (enum anonymous$30)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$29)GTK_MESSAGE_ERROR, (enum anonymous$17)GTK_BUTTONS_CLOSE, return_value_dgettext$33, *st, return_value_avahi_strerror$35);
      unsigned long int return_value_gtk_dialog_get_type$36;
      return_value_gtk_dialog_get_type$36=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$37;
      return_value_g_type_check_instance_cast$37=g_type_check_instance_cast((struct _GTypeInstance *)start_callback$$1$$9$$1$$1$$m, return_value_gtk_dialog_get_type$36);
      gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$37);
      gtk_widget_destroy(start_callback$$1$$9$$1$$1$$m);
      unsigned long int return_value_gtk_dialog_get_type$38;
      return_value_gtk_dialog_get_type$38=gtk_dialog_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$39;
      return_value_g_type_check_instance_cast$39=g_type_check_instance_cast((struct _GTypeInstance *)d, return_value_gtk_dialog_get_type$38);
      gtk_dialog_response((struct _GtkDialog *)return_value_g_type_check_instance_cast$39, -6);
      return 0;
    }

    st = st + 1l;
  }
  return 0;
}

// start_timeout_callback
// file glib-watch.c line 246
static void start_timeout_callback(struct AvahiTimeout *t)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t->dead != 0));
  /* assertion t->enabled */
  assert(t->enabled != 0);
  t->enabled = 0;
  t->callback(t, t->userdata);
}

// stdb_getent
// file ../avahi-utils/stdb.c line 168
char * stdb_getent(void)
{
  struct anonymous$37 key;
  signed int return_value_init$1;
  return_value_init$1=init();
  if(!(return_value_init$1 >= 0))
    return (char *)(void *)0;

  else
    while((_Bool)1)
    {
      if(enum_key == ((char *)NULL))
        key=gdbm_firstkey(gdbm_file);

      else
      {
        key.dptr = enum_key;
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(enum_key);
        key.dsize = (signed int)return_value_strlen$2;
        key=gdbm_nextkey(gdbm_file, key);
      }
      avahi_free((void *)enum_key);
      enum_key = (char *)(void *)0;
      if(key.dptr == ((char *)NULL))
        return (char *)(void *)0;

      enum_key=avahi_strndup(key.dptr, (unsigned long int)key.dsize);
      free((void *)key.dptr);
      char *return_value_strchr$3;
      return_value_strchr$3=strchr(enum_key, 91);
      if(return_value_strchr$3 == ((char *)NULL))
        return enum_key;

    }
}

// stdb_lookup
// file ../avahi-utils/stdb.h line 25
const char * stdb_lookup(const char *name)
{
  struct anonymous$37 key;
  struct anonymous$37 data;
  const char *loc;
  signed int return_value_init$1;
  return_value_init$1=init();
  if(return_value_init$1 >= 0)
  {
    data.dptr = (char *)(void *)0;
    data.dsize = 0;
    loc=setlocale(5, (const char *)(void *)0);
    if(!(loc == ((const char *)NULL)))
    {
      char k[256l];
      snprintf(k, sizeof(char [256l]) /*256ul*/ , "%s[%s]", name, loc);
      key.dptr = k;
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(k);
      key.dsize = (signed int)return_value_strlen$2;
      data=gdbm_fetch(gdbm_file, key);
      if(data.dptr == ((char *)NULL))
      {
        char l[32l];
        char *e;
        snprintf(l, sizeof(char [32l]) /*32ul*/ , "%s", loc);
        e=strchr(l, 64);
        if(!(e == ((char *)NULL)))
        {
          *e = (char)0;
          snprintf(k, sizeof(char [256l]) /*256ul*/ , "%s[%s]", name, (const void *)l);
          key.dptr = k;
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(k);
          key.dsize = (signed int)return_value_strlen$3;
          data=gdbm_fetch(gdbm_file, key);
        }

        if(data.dptr == ((char *)NULL))
        {
          e=strchr(l, 95);
          if(!(e == ((char *)NULL)))
          {
            *e = (char)0;
            snprintf(k, sizeof(char [256l]) /*256ul*/ , "%s[%s]", name, (const void *)l);
            key.dptr = k;
            unsigned long int return_value_strlen$4;
            return_value_strlen$4=strlen(k);
            key.dsize = (signed int)return_value_strlen$4;
            data=gdbm_fetch(gdbm_file, key);
          }

        }

      }

    }

    if(data.dptr == ((char *)NULL))
    {
      key.dptr = (char *)name;
      unsigned long int return_value_strlen$5;
      return_value_strlen$5=strlen(name);
      key.dsize = (signed int)return_value_strlen$5;
      data=gdbm_fetch(gdbm_file, key);
    }

    if(data.dptr == ((char *)NULL))
      goto fail;

    avahi_free((void *)buffer);
    buffer=avahi_strndup(data.dptr, (unsigned long int)data.dsize);
    free((void *)data.dptr);
    return buffer;
  }

  else
  {

  fail:
    ;
    return name;
  }
}

// stdb_setent
// file ../avahi-utils/stdb.c line 209
void stdb_setent(void)
{
  avahi_free((void *)enum_key);
  enum_key = (char *)(void *)0;
}

// stdb_shutdown
// file ../avahi-utils/stdb.c line 148
void stdb_shutdown(void)
{
  if(!(gdbm_file == ((struct anonymous$36 *)NULL)))
    gdbm_close(gdbm_file);

  gdbm_file = (struct anonymous$36 *)(void *)0;
  avahi_free((void *)buffer);
  avahi_free((void *)enum_key);
  enum_key = (char *)(void *)0;
  buffer = enum_key;
}

// strlcpy
// file domain.c line 482
static unsigned long int strlcpy(char *dest, const char *src, unsigned long int n)
{
  /* assertion dest */
  assert(dest != ((char *)NULL));
  /* assertion src */
  assert(src != ((const char *)NULL));
  if(n >= 1ul)
  {
    strncpy(dest, src, n - (unsigned long int)1);
    dest[(signed long int)(n - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(src);
  return return_value_strlen$1;
}

// strlcpy$link1
// file domain.c line 482
static unsigned long int strlcpy$link1(char *dest$link1, const char *src$link1, unsigned long int n$link1)
{
  /* assertion dest */
  assert(dest$link1 != ((char *)NULL));
  /* assertion src */
  assert(src$link1 != ((const char *)NULL));
  if(n$link1 >= 1ul)
  {
    strncpy(dest$link1, src$link1, n$link1 - (unsigned long int)1);
    dest$link1[(signed long int)(n$link1 - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen$1$link1;
  return_value_strlen$1$link1=strlen(src$link1);
  return return_value_strlen$1$link1;
}

// strlcpy$link1$link1
// file domain.c line 482
static unsigned long int strlcpy$link1$link1(char *dest$link1$link1, const char *src$link1$link1, unsigned long int n$link1$link1)
{
  /* assertion dest */
  assert(dest$link1$link1 != ((char *)NULL));
  /* assertion src */
  assert(src$link1$link1 != ((const char *)NULL));
  if(n$link1$link1 >= 1ul)
  {
    strncpy(dest$link1$link1, src$link1$link1, n$link1$link1 - (unsigned long int)1);
    dest$link1$link1[(signed long int)(n$link1$link1 - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen$1$link1$link1;
  return_value_strlen$1$link1$link1=strlen(src$link1$link1);
  return return_value_strlen$1$link1$link1;
}

// strlcpy$link2
// file domain.c line 482
static unsigned long int strlcpy$link2(char *dest$link2, const char *src$link2, unsigned long int n$link2)
{
  /* assertion dest */
  assert(dest$link2 != ((char *)NULL));
  /* assertion src */
  assert(src$link2 != ((const char *)NULL));
  if(n$link2 >= 1ul)
  {
    strncpy(dest$link2, src$link2, n$link2 - (unsigned long int)1);
    dest$link2[(signed long int)(n$link2 - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen$1$link2;
  return_value_strlen$1$link2=strlen(src$link2);
  return return_value_strlen$1$link2;
}

// strlcpy$link3
// file domain.c line 482
static unsigned long int strlcpy$link3(char *dest$link3, const char *src$link3, unsigned long int n$link3)
{
  /* assertion dest */
  assert(dest$link3 != ((char *)NULL));
  /* assertion src */
  assert(src$link3 != ((const char *)NULL));
  if(n$link3 >= 1ul)
  {
    strncpy(dest$link3, src$link3, n$link3 - (unsigned long int)1);
    dest$link3[(signed long int)(n$link3 - (unsigned long int)1)] = (char)0;
  }

  unsigned long int return_value_strlen$1$link3;
  return_value_strlen$1$link3=strlen(src$link3);
  return return_value_strlen$1$link3;
}

// system_poll
// file simple-watch.c line 626
static signed int system_poll(struct pollfd *ufds, unsigned int nfds, signed int timeout, void *userdata)
{
  signed int return_value_poll$1;
  return_value_poll$1=poll(ufds, (unsigned long int)nfds, timeout);
  return return_value_poll$1;
}

// system_poll$link1
// file simple-watch.c line 626
static signed int system_poll$link1(struct pollfd *ufds$link1, unsigned int nfds$link1, signed int timeout$link1, void *userdata$link1)
{
  signed int return_value_poll$1$link1;
  return_value_poll$1$link1=poll(ufds$link1, (unsigned long int)nfds$link1, timeout$link1);
  return return_value_poll$1$link1;
}

// system_poll$link1$link1
// file simple-watch.c line 626
static signed int system_poll$link1$link1(struct pollfd *ufds$link1$link1, unsigned int nfds$link1$link1, signed int timeout$link1$link1, void *userdata$link1$link1)
{
  signed int return_value_poll$1$link1$link1;
  return_value_poll$1$link1$link1=poll(ufds$link1$link1, (unsigned long int)nfds$link1$link1, timeout$link1$link1);
  return return_value_poll$1$link1$link1;
}

// system_poll$link2
// file simple-watch.c line 626
static signed int system_poll$link2(struct pollfd *ufds$link2, unsigned int nfds$link2, signed int timeout$link2, void *userdata$link2)
{
  signed int return_value_poll$1$link2;
  return_value_poll$1$link2=poll(ufds$link2, (unsigned long int)nfds$link2, timeout$link2);
  return return_value_poll$1$link2;
}

// system_poll$link3
// file simple-watch.c line 626
static signed int system_poll$link3(struct pollfd *ufds$link3, unsigned int nfds$link3, signed int timeout$link3, void *userdata$link3)
{
  signed int return_value_poll$1$link3;
  return_value_poll$1$link3=poll(ufds$link3, (unsigned long int)nfds$link3, timeout$link3);
  return return_value_poll$1$link3;
}

// thread
// file thread-watch.c line 62
static void * thread(void *userdata)
{
  struct AvahiThreadedPoll$0 *p = (struct AvahiThreadedPoll$0 *)userdata;
  struct anonymous$8 mask;
  sigfillset(&mask);
  pthread_sigmask(0, &mask, (struct anonymous$8 *)(void *)0);
  pthread_mutex_lock(&p->mutex);
  p->retval=avahi_simple_poll_loop(p->simple_poll);
  pthread_mutex_unlock(&p->mutex);
  return (void *)0;
}

// thread$link1
// file thread-watch.c line 62
static void * thread$link1(void *userdata$link1)
{
  struct AvahiThreadedPoll$0 *p$link1 = (struct AvahiThreadedPoll$0 *)userdata$link1;
  struct anonymous$8 mask$link1;
  sigfillset(&mask$link1);
  pthread_sigmask(0, &mask$link1, (struct anonymous$8 *)(void *)0);
  pthread_mutex_lock(&p$link1->mutex);
  p$link1->retval=avahi_simple_poll_loop(p$link1->simple_poll);
  pthread_mutex_unlock(&p$link1->mutex);
  return (void *)0;
}

// thread$link1$link1
// file thread-watch.c line 62
static void * thread$link1$link1(void *userdata$link1$link1)
{
  struct AvahiThreadedPoll$0 *p$link1$link1 = (struct AvahiThreadedPoll$0 *)userdata$link1$link1;
  struct anonymous$8 mask$link1$link1;
  sigfillset(&mask$link1$link1);
  pthread_sigmask(0, &mask$link1$link1, (struct anonymous$8 *)(void *)0);
  pthread_mutex_lock(&p$link1$link1->mutex);
  p$link1$link1->retval=avahi_simple_poll_loop(p$link1$link1->simple_poll);
  pthread_mutex_unlock(&p$link1$link1->mutex);
  return (void *)0;
}

// thread$link2
// file thread-watch.c line 62
static void * thread$link2(void *userdata$link2)
{
  struct AvahiThreadedPoll *p$link2 = (struct AvahiThreadedPoll *)userdata$link2;
  struct anonymous$8 mask$link2;
  sigfillset(&mask$link2);
  pthread_sigmask(0, &mask$link2, (struct anonymous$8 *)(void *)0);
  pthread_mutex_lock(&p$link2->mutex);
  p$link2->retval=avahi_simple_poll_loop(p$link2->simple_poll);
  pthread_mutex_unlock(&p$link2->mutex);
  return (void *)0;
}

// thread$link3
// file thread-watch.c line 62
static void * thread$link3(void *userdata$link3)
{
  struct AvahiThreadedPoll$0 *p$link3 = (struct AvahiThreadedPoll$0 *)userdata$link3;
  struct anonymous$8 mask$link3;
  sigfillset(&mask$link3);
  pthread_sigmask(0, &mask$link3, (struct anonymous$8 *)(void *)0);
  pthread_mutex_lock(&p$link3->mutex);
  p$link3->retval=avahi_simple_poll_loop(p$link3->simple_poll);
  pthread_mutex_unlock(&p$link3->mutex);
  return (void *)0;
}

// timeout_callback
// file ../avahi-common/dbus-watch-glue.c line 237
static void timeout_callback(struct AvahiTimeout$1 *avahi_timeout, void *userdata)
{
  struct TimeoutData *timeout = (struct TimeoutData *)userdata;
  /* assertion avahi_timeout */
  assert(avahi_timeout != ((struct AvahiTimeout$1 *)NULL));
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  timeout_data_ref(timeout);
  dbus_timeout_handle(timeout->dbus_timeout);
  if(!(timeout->avahi_timeout == ((struct AvahiTimeout$1 *)NULL)))
    update_timeout(timeout);

  timeout_data_unref(timeout);
}

// timeout_callback$link1
// file simple-watch.c line 441
static void timeout_callback$link1(struct AvahiTimeout$1 *t)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout$1 *)NULL));
  /* assertion !t->dead */
  assert(!(t->dead != 0));
  /* assertion t->enabled */
  assert(t->enabled != 0);
  t->enabled = 0;
  t->callback(t, t->userdata);
}

// timeout_callback$link1$link1
// file simple-watch.c line 441
static void timeout_callback$link1$link1(struct AvahiTimeout$1 *t$link1$link1)
{
  /* assertion t */
  assert(t$link1$link1 != ((struct AvahiTimeout$1 *)NULL));
  /* assertion !t->dead */
  assert(!(t$link1$link1->dead != 0));
  /* assertion t->enabled */
  assert(t$link1$link1->enabled != 0);
  t$link1$link1->enabled = 0;
  t$link1$link1->callback(t$link1$link1, t$link1$link1->userdata);
}

// timeout_callback$link2
// file simple-watch.c line 441
static void timeout_callback$link2(struct AvahiTimeout$1 *t$link1)
{
  /* assertion t */
  assert(t$link1 != ((struct AvahiTimeout$1 *)NULL));
  /* assertion !t->dead */
  assert(!(t$link1->dead != 0));
  /* assertion t->enabled */
  assert(t$link1->enabled != 0);
  t$link1->enabled = 0;
  t$link1->callback(t$link1, t$link1->userdata);
}

// timeout_callback$link2$link1
// file ../avahi-common/dbus-watch-glue.c line 237
static void timeout_callback$link2$link1(struct AvahiTimeout$1 *avahi_timeout$link1, void *userdata$link1)
{
  struct TimeoutData *timeout$link1 = (struct TimeoutData *)userdata$link1;
  /* assertion avahi_timeout */
  assert(avahi_timeout$link1 != ((struct AvahiTimeout$1 *)NULL));
  /* assertion timeout */
  assert(timeout$link1 != ((struct TimeoutData *)NULL));
  timeout_data_ref$link1(timeout$link1);
  dbus_timeout_handle(timeout$link1->dbus_timeout);
  if(!(timeout$link1->avahi_timeout == ((struct AvahiTimeout$1 *)NULL)))
    update_timeout$link1(timeout$link1);

  timeout_data_unref$link1(timeout$link1);
}

// timeout_callback$link3
// file simple-watch.c line 441
static void timeout_callback$link3(struct AvahiTimeout$0 *t$link2)
{
  /* assertion t */
  assert(t$link2 != ((struct AvahiTimeout$0 *)NULL));
  /* assertion !t->dead */
  assert(!(t$link2->dead != 0));
  /* assertion t->enabled */
  assert(t$link2->enabled != 0);
  t$link2->enabled = 0;
  t$link2->callback(t$link2, t$link2->userdata);
}

// timeout_callback$link4
// file simple-watch.c line 441
static void timeout_callback$link4(struct AvahiTimeout$1 *t$link3)
{
  /* assertion t */
  assert(t$link3 != ((struct AvahiTimeout$1 *)NULL));
  /* assertion !t->dead */
  assert(!(t$link3->dead != 0));
  /* assertion t->enabled */
  assert(t$link3->enabled != 0);
  t$link3->enabled = 0;
  t$link3->callback(t$link3, t$link3->userdata);
}

// timeout_data_ref
// file ../avahi-common/dbus-watch-glue.c line 203
static struct TimeoutData * timeout_data_ref(struct TimeoutData *t)
{
  /* assertion t */
  assert(t != ((struct TimeoutData *)NULL));
  /* assertion t->ref >= 1 */
  assert(t->ref >= 1);
  t->ref = t->ref + 1;
  return t;
}

// timeout_data_ref$link1
// file ../avahi-common/dbus-watch-glue.c line 203
static struct TimeoutData * timeout_data_ref$link1(struct TimeoutData *t$link1)
{
  /* assertion t */
  assert(t$link1 != ((struct TimeoutData *)NULL));
  /* assertion t->ref >= 1 */
  assert(t$link1->ref >= 1);
  t$link1->ref = t$link1->ref + 1;
  return t$link1;
}

// timeout_data_unref
// file ../avahi-common/dbus-watch-glue.c line 211
static void timeout_data_unref(struct TimeoutData *t)
{
  /* assertion t */
  assert(t != ((struct TimeoutData *)NULL));
  /* assertion t->ref >= 1 */
  assert(t->ref >= 1);
  t->ref = t->ref - 1;
  if(!(t->ref >= 1))
  {
    if(!(t->avahi_timeout == ((struct AvahiTimeout$1 *)NULL)))
      t->poll_api->timeout_free(t->avahi_timeout);

    avahi_free((void *)t);
  }

}

// timeout_data_unref$link1
// file ../avahi-common/dbus-watch-glue.c line 211
static void timeout_data_unref$link1(struct TimeoutData *t$link1)
{
  /* assertion t */
  assert(t$link1 != ((struct TimeoutData *)NULL));
  /* assertion t->ref >= 1 */
  assert(t$link1->ref >= 1);
  t$link1->ref = t$link1->ref - 1;
  if(!(t$link1->ref >= 1))
  {
    if(!(t$link1->avahi_timeout == ((struct AvahiTimeout$1 *)NULL)))
      t$link1->poll_api->timeout_free(t$link1->avahi_timeout);

    avahi_free((void *)t$link1);
  }

}

// timeout_free
// file simple-watch.c line 284
static void timeout_free(struct AvahiTimeout$1 *t)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout$1 *)NULL));
  /* assertion !t->dead */
  assert(!(t->dead != 0));
  avahi_simple_poll_wakeup(t->simple_poll);
  t->dead = 1;
  t->simple_poll->timeout_req_cleanup = 1;
}

// timeout_free$link1
// file simple-watch.c line 284
static void timeout_free$link1(struct AvahiTimeout$1 *t$link1)
{
  /* assertion t */
  assert(t$link1 != ((struct AvahiTimeout$1 *)NULL));
  /* assertion !t->dead */
  assert(!(t$link1->dead != 0));
  avahi_simple_poll_wakeup(t$link1->simple_poll);
  t$link1->dead = 1;
  t$link1->simple_poll->timeout_req_cleanup = 1;
}

// timeout_free$link1$link1
// file simple-watch.c line 284
static void timeout_free$link1$link1(struct AvahiTimeout$0 *t$link1$link1)
{
  /* assertion t */
  assert(t$link1$link1 != ((struct AvahiTimeout$0 *)NULL));
  /* assertion !t->dead */
  assert(!(t$link1$link1->dead != 0));
  avahi_simple_poll_wakeup(t$link1$link1->simple_poll);
  t$link1$link1->dead = 1;
  t$link1$link1->simple_poll->timeout_req_cleanup = 1;
}

// timeout_free$link1$link2
// file simple-watch.c line 284
static void timeout_free$link1$link2(struct AvahiTimeout$1 *t$link1$link2)
{
  /* assertion t */
  assert(t$link1$link2 != ((struct AvahiTimeout$1 *)NULL));
  /* assertion !t->dead */
  assert(!(t$link1$link2->dead != 0));
  avahi_simple_poll_wakeup(t$link1$link2->simple_poll);
  t$link1$link2->dead = 1;
  t$link1$link2->simple_poll->timeout_req_cleanup = 1;
}

// timeout_free$link2
// file glib-watch.c line 201
static void timeout_free$link2(struct AvahiTimeout *t$link2)
{
  /* assertion t */
  assert(t$link2 != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t$link2->dead != 0));
  t$link2->dead = (signed int)!(0 != 0);
  t$link2->glib_poll->timeout_req_cleanup = (signed int)!(0 != 0);
}

// timeout_free$link3
// file simple-watch.c line 284
static void timeout_free$link3(struct AvahiTimeout$1 *t$link3)
{
  /* assertion t */
  assert(t$link3 != ((struct AvahiTimeout$1 *)NULL));
  /* assertion !t->dead */
  assert(!(t$link3->dead != 0));
  avahi_simple_poll_wakeup(t$link3->simple_poll);
  t$link3->dead = 1;
  t$link3->simple_poll->timeout_req_cleanup = 1;
}

// timeout_new
// file simple-watch.c line 244
static struct AvahiTimeout$1 * timeout_new(const struct AvahiPoll$1 *api, struct timeval *tv, void (*callback)(struct AvahiTimeout$1 *, void *), void *userdata)
{
  struct AvahiTimeout$1 *t;
  struct AvahiSimplePoll$0 *s;
  /* assertion api */
  assert(api != ((const struct AvahiPoll$1 *)NULL));
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiTimeout$1 *, void *))NULL));
  s = (struct AvahiSimplePoll$0 *)api->userdata;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link2$link1((unsigned int)1, sizeof(struct AvahiTimeout$1) /*64ul*/ );
  t = (struct AvahiTimeout$1 *)return_value_avahi_new_internal$1;
  if(t == ((struct AvahiTimeout$1 *)NULL))
    return (struct AvahiTimeout$1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s);
    t->simple_poll = s;
    t->dead = 0;
    t->enabled = (signed int)!(!(tv != ((struct timeval *)NULL)));
    if(!(t->enabled == 0))
      t->expiry = *tv;

    t->callback = callback;
    t->userdata = userdata;
    do
    {
      struct AvahiTimeout$1 **_head = &s->timeouts;
      struct AvahiTimeout$1 *_item = t;
      /* assertion _item */
      assert(_item != ((struct AvahiTimeout$1 *)NULL));
      _item->timeouts_next = *_head;
      if(!(_item->timeouts_next == ((struct AvahiTimeout$1 *)NULL)))
        _item->timeouts_next->timeouts_prev = _item;

      _item->timeouts_prev = (struct AvahiTimeout$1 *)(void *)0;
      *_head = _item;
    }
    while((_Bool)0);
    return t;
  }
}

// timeout_new$link1
// file simple-watch.c line 244
static struct AvahiTimeout$1 * timeout_new$link1(const struct AvahiPoll$1 *api$link1, struct timeval *tv$link1, void (*callback$link1)(struct AvahiTimeout$1 *, void *), void *userdata$link1)
{
  struct AvahiTimeout$1 *t$link1;
  struct AvahiSimplePoll$0 *s$link1;
  /* assertion api */
  assert(api$link1 != ((const struct AvahiPoll$1 *)NULL));
  /* assertion callback */
  assert(callback$link1 != ((void (*)(struct AvahiTimeout$1 *, void *))NULL));
  s$link1 = (struct AvahiSimplePoll$0 *)api$link1->userdata;
  /* assertion s */
  assert(s$link1 != ((struct AvahiSimplePoll$0 *)NULL));
  void *return_value_avahi_new_internal$1$link1;
  return_value_avahi_new_internal$1$link1=avahi_new_internal$link2$link2((unsigned int)1, sizeof(struct AvahiTimeout$1) /*64ul*/ );
  t$link1 = (struct AvahiTimeout$1 *)return_value_avahi_new_internal$1$link1;
  if(t$link1 == ((struct AvahiTimeout$1 *)NULL))
    return (struct AvahiTimeout$1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s$link1);
    t$link1->simple_poll = s$link1;
    t$link1->dead = 0;
    t$link1->enabled = (signed int)!(!(tv$link1 != ((struct timeval *)NULL)));
    if(!(t$link1->enabled == 0))
      t$link1->expiry = *tv$link1;

    t$link1->callback = callback$link1;
    t$link1->userdata = userdata$link1;
    do
    {
      struct AvahiTimeout$1 **_head$link1 = &s$link1->timeouts;
      struct AvahiTimeout$1 *_item$link1 = t$link1;
      /* assertion _item */
      assert(_item$link1 != ((struct AvahiTimeout$1 *)NULL));
      _item$link1->timeouts_next = *_head$link1;
      if(!(_item$link1->timeouts_next == ((struct AvahiTimeout$1 *)NULL)))
        _item$link1->timeouts_next->timeouts_prev = _item$link1;

      _item$link1->timeouts_prev = (struct AvahiTimeout$1 *)(void *)0;
      *_head$link1 = _item$link1;
    }
    while((_Bool)0);
    return t$link1;
  }
}

// timeout_new$link1$link1
// file simple-watch.c line 244
static struct AvahiTimeout$0 * timeout_new$link1$link1(const struct AvahiPoll$0 *api$link1$link1, struct timeval *tv$link1$link1, void (*callback$link1$link1)(struct AvahiTimeout$0 *, void *), void *userdata$link1$link1)
{
  struct AvahiTimeout$0 *t$link1$link1;
  struct AvahiSimplePoll *s$link2;
  /* assertion api */
  assert(api$link1$link1 != ((const struct AvahiPoll$0 *)NULL));
  /* assertion callback */
  assert(callback$link1$link1 != ((void (*)(struct AvahiTimeout$0 *, void *))NULL));
  s$link2 = (struct AvahiSimplePoll *)api$link1$link1->userdata;
  /* assertion s */
  assert(s$link2 != ((struct AvahiSimplePoll *)NULL));
  void *return_value_avahi_new_internal$1$link1$link1;
  return_value_avahi_new_internal$1$link1$link1=avahi_new_internal$link2$link3((unsigned int)1, sizeof(struct AvahiTimeout$0) /*64ul*/ );
  t$link1$link1 = (struct AvahiTimeout$0 *)return_value_avahi_new_internal$1$link1$link1;
  if(t$link1$link1 == ((struct AvahiTimeout$0 *)NULL))
    return (struct AvahiTimeout$0 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s$link2);
    t$link1$link1->simple_poll = s$link2;
    t$link1$link1->dead = 0;
    t$link1$link1->enabled = (signed int)!(!(tv$link1$link1 != ((struct timeval *)NULL)));
    if(!(t$link1$link1->enabled == 0))
      t$link1$link1->expiry = *tv$link1$link1;

    t$link1$link1->callback = callback$link1$link1;
    t$link1$link1->userdata = userdata$link1$link1;
    do
    {
      struct AvahiTimeout$0 **_head$link1$link1 = &s$link2->timeouts;
      struct AvahiTimeout$0 *_item$link1$link1 = t$link1$link1;
      /* assertion _item */
      assert(_item$link1$link1 != ((struct AvahiTimeout$0 *)NULL));
      _item$link1$link1->timeouts_next = *_head$link1$link1;
      if(!(_item$link1$link1->timeouts_next == ((struct AvahiTimeout$0 *)NULL)))
        _item$link1$link1->timeouts_next->timeouts_prev = _item$link1$link1;

      _item$link1$link1->timeouts_prev = (struct AvahiTimeout$0 *)(void *)0;
      *_head$link1$link1 = _item$link1$link1;
    }
    while((_Bool)0);
    return t$link1$link1;
  }
}

// timeout_new$link1$link2
// file simple-watch.c line 244
static struct AvahiTimeout$1 * timeout_new$link1$link2(const struct AvahiPoll$1 *api$link1$link2, struct timeval *tv$link1$link2, void (*callback$link1$link2)(struct AvahiTimeout$1 *, void *), void *userdata$link1$link2)
{
  struct AvahiTimeout$1 *t$link1$link2;
  struct AvahiSimplePoll$0 *s$link1$link1;
  /* assertion api */
  assert(api$link1$link2 != ((const struct AvahiPoll$1 *)NULL));
  /* assertion callback */
  assert(callback$link1$link2 != ((void (*)(struct AvahiTimeout$1 *, void *))NULL));
  s$link1$link1 = (struct AvahiSimplePoll$0 *)api$link1$link2->userdata;
  /* assertion s */
  assert(s$link1$link1 != ((struct AvahiSimplePoll$0 *)NULL));
  void *return_value_avahi_new_internal$1$link1$link2;
  return_value_avahi_new_internal$1$link1$link2=avahi_new_internal$link2$link1$link1((unsigned int)1, sizeof(struct AvahiTimeout$1) /*64ul*/ );
  t$link1$link2 = (struct AvahiTimeout$1 *)return_value_avahi_new_internal$1$link1$link2;
  if(t$link1$link2 == ((struct AvahiTimeout$1 *)NULL))
    return (struct AvahiTimeout$1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s$link1$link1);
    t$link1$link2->simple_poll = s$link1$link1;
    t$link1$link2->dead = 0;
    t$link1$link2->enabled = (signed int)!(!(tv$link1$link2 != ((struct timeval *)NULL)));
    if(!(t$link1$link2->enabled == 0))
      t$link1$link2->expiry = *tv$link1$link2;

    t$link1$link2->callback = callback$link1$link2;
    t$link1$link2->userdata = userdata$link1$link2;
    do
    {
      struct AvahiTimeout$1 **_head$link1$link2 = &s$link1$link1->timeouts;
      struct AvahiTimeout$1 *_item$link1$link2 = t$link1$link2;
      /* assertion _item */
      assert(_item$link1$link2 != ((struct AvahiTimeout$1 *)NULL));
      _item$link1$link2->timeouts_next = *_head$link1$link2;
      if(!(_item$link1$link2->timeouts_next == ((struct AvahiTimeout$1 *)NULL)))
        _item$link1$link2->timeouts_next->timeouts_prev = _item$link1$link2;

      _item$link1$link2->timeouts_prev = (struct AvahiTimeout$1 *)(void *)0;
      *_head$link1$link2 = _item$link1$link2;
    }
    while((_Bool)0);
    return t$link1$link2;
  }
}

// timeout_new$link2
// file glib-watch.c line 166
static struct AvahiTimeout * timeout_new$link2(const struct AvahiPoll *api$link2, struct timeval *tv$link2, void (*callback$link2)(struct AvahiTimeout *, void *), void *userdata$link2)
{
  struct AvahiTimeout *t$link2;
  struct AvahiGLibPoll *g;
  /* assertion api */
  assert(api$link2 != ((const struct AvahiPoll *)NULL));
  /* assertion callback */
  assert(callback$link2 != ((void (*)(struct AvahiTimeout *, void *))NULL));
  g = (struct AvahiGLibPoll *)api$link2->userdata;
  /* assertion g */
  assert(g != ((struct AvahiGLibPoll *)NULL));
  void *return_value_avahi_new_internal$1$link2;
  return_value_avahi_new_internal$1$link2=avahi_new_internal$link7((unsigned int)1, sizeof(struct AvahiTimeout) /*64ul*/ );
  t$link2 = (struct AvahiTimeout *)return_value_avahi_new_internal$1$link2;
  if(t$link2 == ((struct AvahiTimeout *)NULL))
    return (struct AvahiTimeout *)(void *)0;

  else
  {
    t$link2->glib_poll = g;
    t$link2->dead = 0;
    t$link2->enabled = (signed int)!(!(tv$link2 != ((struct timeval *)NULL)));
    if(!(t$link2->enabled == 0))
      t$link2->expiry = *tv$link2;

    t$link2->callback = callback$link2;
    t$link2->userdata = userdata$link2;
    do
    {
      struct AvahiTimeout **_head$link2 = &g->timeouts;
      struct AvahiTimeout *_item$link2 = t$link2;
      /* assertion _item */
      assert(_item$link2 != ((struct AvahiTimeout *)NULL));
      _item$link2->timeouts_next = *_head$link2;
      if(!(_item$link2->timeouts_next == ((struct AvahiTimeout *)NULL)))
        _item$link2->timeouts_next->timeouts_prev = _item$link2;

      _item$link2->timeouts_prev = (struct AvahiTimeout *)(void *)0;
      *_head$link2 = _item$link2;
    }
    while((_Bool)0);
    return t$link2;
  }
}

// timeout_new$link3
// file simple-watch.c line 244
static struct AvahiTimeout$1 * timeout_new$link3(const struct AvahiPoll$1 *api$link3, struct timeval *tv$link3, void (*callback$link3)(struct AvahiTimeout$1 *, void *), void *userdata$link3)
{
  struct AvahiTimeout$1 *t$link3;
  struct AvahiSimplePoll$0 *s$link3;
  /* assertion api */
  assert(api$link3 != ((const struct AvahiPoll$1 *)NULL));
  /* assertion callback */
  assert(callback$link3 != ((void (*)(struct AvahiTimeout$1 *, void *))NULL));
  s$link3 = (struct AvahiSimplePoll$0 *)api$link3->userdata;
  /* assertion s */
  assert(s$link3 != ((struct AvahiSimplePoll$0 *)NULL));
  void *return_value_avahi_new_internal$1$link3;
  return_value_avahi_new_internal$1$link3=avahi_new_internal$link2$link4((unsigned int)1, sizeof(struct AvahiTimeout$1) /*64ul*/ );
  t$link3 = (struct AvahiTimeout$1 *)return_value_avahi_new_internal$1$link3;
  if(t$link3 == ((struct AvahiTimeout$1 *)NULL))
    return (struct AvahiTimeout$1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s$link3);
    t$link3->simple_poll = s$link3;
    t$link3->dead = 0;
    t$link3->enabled = (signed int)!(!(tv$link3 != ((struct timeval *)NULL)));
    if(!(t$link3->enabled == 0))
      t$link3->expiry = *tv$link3;

    t$link3->callback = callback$link3;
    t$link3->userdata = userdata$link3;
    do
    {
      struct AvahiTimeout$1 **_head$link3 = &s$link3->timeouts;
      struct AvahiTimeout$1 *_item$link3 = t$link3;
      /* assertion _item */
      assert(_item$link3 != ((struct AvahiTimeout$1 *)NULL));
      _item$link3->timeouts_next = *_head$link3;
      if(!(_item$link3->timeouts_next == ((struct AvahiTimeout$1 *)NULL)))
        _item$link3->timeouts_next->timeouts_prev = _item$link3;

      _item$link3->timeouts_prev = (struct AvahiTimeout$1 *)(void *)0;
      *_head$link3 = _item$link3;
    }
    while((_Bool)0);
    return t$link3;
  }
}

// timeout_toggled
// file ../avahi-common/dbus-watch-glue.c line 300
static void timeout_toggled(struct DBusTimeout *dbus_timeout, void *userdata)
{
  struct TimeoutData *timeout;
  /* assertion dbus_timeout */
  assert(dbus_timeout != ((struct DBusTimeout *)NULL));
  void *return_value_dbus_timeout_get_data$1;
  return_value_dbus_timeout_get_data$1=dbus_timeout_get_data(dbus_timeout);
  timeout = (struct TimeoutData *)return_value_dbus_timeout_get_data$1;
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  update_timeout(timeout);
}

// timeout_toggled$link1
// file ../avahi-common/dbus-watch-glue.c line 300
static void timeout_toggled$link1(struct DBusTimeout *dbus_timeout$link1, void *userdata$link1)
{
  struct TimeoutData *timeout$link1;
  /* assertion dbus_timeout */
  assert(dbus_timeout$link1 != ((struct DBusTimeout *)NULL));
  void *return_value_dbus_timeout_get_data$1$link1;
  return_value_dbus_timeout_get_data$1$link1=dbus_timeout_get_data(dbus_timeout$link1);
  timeout$link1 = (struct TimeoutData *)return_value_dbus_timeout_get_data$1$link1;
  /* assertion timeout */
  assert(timeout$link1 != ((struct TimeoutData *)NULL));
  update_timeout$link1(timeout$link1);
}

// timeout_update
// file simple-watch.c line 273
static void timeout_update(struct AvahiTimeout$1 *t, struct timeval *tv)
{
  /* assertion t */
  assert(t != ((struct AvahiTimeout$1 *)NULL));
  /* assertion !t->dead */
  assert(!(t->dead != 0));
  avahi_simple_poll_wakeup(t->simple_poll);
  t->enabled = (signed int)!(!(tv != ((struct timeval *)NULL)));
  if(!(t->enabled == 0))
    t->expiry = *tv;

}

// timeout_update$link1
// file simple-watch.c line 273
static void timeout_update$link1(struct AvahiTimeout$1 *t$link1, struct timeval *tv$link1)
{
  /* assertion t */
  assert(t$link1 != ((struct AvahiTimeout$1 *)NULL));
  /* assertion !t->dead */
  assert(!(t$link1->dead != 0));
  avahi_simple_poll_wakeup(t$link1->simple_poll);
  t$link1->enabled = (signed int)!(!(tv$link1 != ((struct timeval *)NULL)));
  if(!(t$link1->enabled == 0))
    t$link1->expiry = *tv$link1;

}

// timeout_update$link1$link1
// file simple-watch.c line 273
static void timeout_update$link1$link1(struct AvahiTimeout$0 *t$link1$link1, struct timeval *tv$link1$link1)
{
  /* assertion t */
  assert(t$link1$link1 != ((struct AvahiTimeout$0 *)NULL));
  /* assertion !t->dead */
  assert(!(t$link1$link1->dead != 0));
  avahi_simple_poll_wakeup(t$link1$link1->simple_poll);
  t$link1$link1->enabled = (signed int)!(!(tv$link1$link1 != ((struct timeval *)NULL)));
  if(!(t$link1$link1->enabled == 0))
    t$link1$link1->expiry = *tv$link1$link1;

}

// timeout_update$link1$link2
// file simple-watch.c line 273
static void timeout_update$link1$link2(struct AvahiTimeout$1 *t$link1$link2, struct timeval *tv$link1$link2)
{
  /* assertion t */
  assert(t$link1$link2 != ((struct AvahiTimeout$1 *)NULL));
  /* assertion !t->dead */
  assert(!(t$link1$link2->dead != 0));
  avahi_simple_poll_wakeup(t$link1$link2->simple_poll);
  t$link1$link2->enabled = (signed int)!(!(tv$link1$link2 != ((struct timeval *)NULL)));
  if(!(t$link1$link2->enabled == 0))
    t$link1$link2->expiry = *tv$link1$link2;

}

// timeout_update$link2
// file glib-watch.c line 193
static void timeout_update$link2(struct AvahiTimeout *t$link2, struct timeval *tv$link2)
{
  /* assertion t */
  assert(t$link2 != ((struct AvahiTimeout *)NULL));
  /* assertion !t->dead */
  assert(!(t$link2->dead != 0));
  t$link2->enabled = (signed int)!(!(tv$link2 != ((struct timeval *)NULL)));
  if(!(t$link2->enabled == 0))
    t$link2->expiry = *tv$link2;

}

// timeout_update$link3
// file simple-watch.c line 273
static void timeout_update$link3(struct AvahiTimeout$1 *t$link3, struct timeval *tv$link3)
{
  /* assertion t */
  assert(t$link3 != ((struct AvahiTimeout$1 *)NULL));
  /* assertion !t->dead */
  assert(!(t$link3->dead != 0));
  avahi_simple_poll_wakeup(t$link3->simple_poll);
  t$link3->enabled = (signed int)!(!(tv$link3 != ((struct timeval *)NULL)));
  if(!(t$link3->enabled == 0))
    t$link3->expiry = *tv$link3;

}

// translate_avahi_to_dbus
// file ../avahi-common/dbus-watch-glue.c line 46
static unsigned int translate_avahi_to_dbus(enum anonymous e)
{
  unsigned int f = (unsigned int)0;
  if(!((AVAHI_WATCH_IN & (signed int)e) == 0))
    f = f | (unsigned int)1;

  if(!((AVAHI_WATCH_OUT & (signed int)e) == 0))
    f = f | (unsigned int)2;

  if(!((AVAHI_WATCH_ERR & (signed int)e) == 0))
    f = f | (unsigned int)4;

  if(!((AVAHI_WATCH_HUP & (signed int)e) == 0))
    f = f | (unsigned int)8;

  return f;
}

// translate_avahi_to_dbus$link1
// file ../avahi-common/dbus-watch-glue.c line 46
static unsigned int translate_avahi_to_dbus$link1(enum anonymous e$link1)
{
  unsigned int f$link1 = (unsigned int)0;
  if(!((AVAHI_WATCH_IN & (signed int)e$link1) == 0))
    f$link1 = f$link1 | (unsigned int)1;

  if(!((AVAHI_WATCH_OUT & (signed int)e$link1) == 0))
    f$link1 = f$link1 | (unsigned int)2;

  if(!((AVAHI_WATCH_ERR & (signed int)e$link1) == 0))
    f$link1 = f$link1 | (unsigned int)4;

  if(!((AVAHI_WATCH_HUP & (signed int)e$link1) == 0))
    f$link1 = f$link1 | (unsigned int)8;

  return f$link1;
}

// translate_dbus_to_avahi
// file ../avahi-common/dbus-watch-glue.c line 31
static enum anonymous translate_dbus_to_avahi(unsigned int f)
{
  enum anonymous e = (enum anonymous)0;
  if(!((1u & f) == 0u))
    e = e | (enum anonymous)AVAHI_WATCH_IN;

  if(!((2u & f) == 0u))
    e = e | (enum anonymous)AVAHI_WATCH_OUT;

  if(!((4u & f) == 0u))
    e = e | (enum anonymous)AVAHI_WATCH_ERR;

  if(!((8u & f) == 0u))
    e = e | (enum anonymous)AVAHI_WATCH_HUP;

  return e;
}

// translate_dbus_to_avahi$link1
// file ../avahi-common/dbus-watch-glue.c line 31
static enum anonymous translate_dbus_to_avahi$link1(unsigned int f$link1)
{
  enum anonymous e$link1 = (enum anonymous)0;
  if(!((1u & f$link1) == 0u))
    e$link1 = e$link1 | (enum anonymous)AVAHI_WATCH_IN;

  if(!((2u & f$link1) == 0u))
    e$link1 = e$link1 | (enum anonymous)AVAHI_WATCH_OUT;

  if(!((4u & f$link1) == 0u))
    e$link1 = e$link1 | (enum anonymous)AVAHI_WATCH_ERR;

  if(!((8u & f$link1) == 0u))
    e$link1 = e$link1 | (enum anonymous)AVAHI_WATCH_HUP;

  return e$link1;
}

// update_timeout
// file ../avahi-common/dbus-watch-glue.c line 223
static void update_timeout(struct TimeoutData *timeout)
{
  /* assertion timeout */
  assert(timeout != ((struct TimeoutData *)NULL));
  /* assertion timeout->ref >= 1 */
  assert(timeout->ref >= 1);
  unsigned int return_value_dbus_timeout_get_enabled$2;
  return_value_dbus_timeout_get_enabled$2=dbus_timeout_get_enabled(timeout->dbus_timeout);
  if(!(return_value_dbus_timeout_get_enabled$2 == 0u))
  {
    struct timeval tv;
    signed int return_value_dbus_timeout_get_interval$1;
    return_value_dbus_timeout_get_interval$1=dbus_timeout_get_interval(timeout->dbus_timeout);
    avahi_elapse_time(&tv, (unsigned int)return_value_dbus_timeout_get_interval$1, (unsigned int)0);
    timeout->poll_api->timeout_update(timeout->avahi_timeout, &tv);
  }

  else
    timeout->poll_api->timeout_update(timeout->avahi_timeout, (struct timeval *)(void *)0);
}

// update_timeout$link1
// file ../avahi-common/dbus-watch-glue.c line 223
static void update_timeout$link1(struct TimeoutData *timeout$link1)
{
  /* assertion timeout */
  assert(timeout$link1 != ((struct TimeoutData *)NULL));
  /* assertion timeout->ref >= 1 */
  assert(timeout$link1->ref >= 1);
  unsigned int return_value_dbus_timeout_get_enabled$2$link1;
  return_value_dbus_timeout_get_enabled$2$link1=dbus_timeout_get_enabled(timeout$link1->dbus_timeout);
  if(!(return_value_dbus_timeout_get_enabled$2$link1 == 0u))
  {
    struct timeval tv$link1;
    signed int return_value_dbus_timeout_get_interval$1$link1;
    return_value_dbus_timeout_get_interval$1$link1=dbus_timeout_get_interval(timeout$link1->dbus_timeout);
    avahi_elapse_time(&tv$link1, (unsigned int)return_value_dbus_timeout_get_interval$1$link1, (unsigned int)0);
    timeout$link1->poll_api->timeout_update(timeout$link1->avahi_timeout, &tv$link1);
  }

  else
    timeout$link1->poll_api->timeout_update(timeout$link1->avahi_timeout, (struct timeval *)(void *)0);
}

// update_watch
// file ../avahi-common/dbus-watch-glue.c line 125
static unsigned int update_watch(const struct AvahiPoll$1 *poll_api, struct DBusWatch *dbus_watch)
{
  struct AvahiWatch$1 *avahi_watch;
  unsigned int b;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  void *return_value_dbus_watch_get_data$1;
  return_value_dbus_watch_get_data$1=dbus_watch_get_data(dbus_watch);
  avahi_watch = (struct AvahiWatch$1 *)return_value_dbus_watch_get_data$1;
  b=dbus_watch_get_enabled(dbus_watch);
  if(avahi_watch == ((struct AvahiWatch$1 *)NULL) && !(b == 0u))
  {
    signed int return_value_dbus_watch_get_unix_fd$2;
    return_value_dbus_watch_get_unix_fd$2=dbus_watch_get_unix_fd(dbus_watch);
    unsigned int return_value_dbus_watch_get_flags$3;
    return_value_dbus_watch_get_flags$3=dbus_watch_get_flags(dbus_watch);
    enum anonymous return_value_translate_dbus_to_avahi$4;
    return_value_translate_dbus_to_avahi$4=translate_dbus_to_avahi(return_value_dbus_watch_get_flags$3);
    avahi_watch=poll_api->watch_new(poll_api, return_value_dbus_watch_get_unix_fd$2, return_value_translate_dbus_to_avahi$4, watch_callback, (void *)dbus_watch);
    if(avahi_watch == ((struct AvahiWatch$1 *)NULL))
      return (unsigned int)0;

    dbus_watch_set_data(dbus_watch, (void *)avahi_watch, (void (*)(void *))(void *)0);
  }

  else
    if(b == 0u && !(avahi_watch == ((struct AvahiWatch$1 *)NULL)))
    {
      poll_api->watch_free(avahi_watch);
      dbus_watch_set_data(dbus_watch, (void *)0, (void (*)(void *))(void *)0);
    }

    else
      if(!(avahi_watch == ((struct AvahiWatch$1 *)NULL)))
      {
        unsigned int return_value_dbus_watch_get_flags$5;
        return_value_dbus_watch_get_flags$5=dbus_watch_get_flags(dbus_watch);
        poll_api->watch_update(avahi_watch, (enum anonymous)return_value_dbus_watch_get_flags$5);
      }

  return (unsigned int)1;
}

// update_watch$link1
// file ../avahi-common/dbus-watch-glue.c line 125
static unsigned int update_watch$link1(const struct AvahiPoll$1 *poll_api$link1, struct DBusWatch *dbus_watch$link1)
{
  struct AvahiWatch$1 *avahi_watch$link1;
  unsigned int b$link1;
  /* assertion dbus_watch */
  assert(dbus_watch$link1 != ((struct DBusWatch *)NULL));
  void *return_value_dbus_watch_get_data$1$link1;
  return_value_dbus_watch_get_data$1$link1=dbus_watch_get_data(dbus_watch$link1);
  avahi_watch$link1 = (struct AvahiWatch$1 *)return_value_dbus_watch_get_data$1$link1;
  b$link1=dbus_watch_get_enabled(dbus_watch$link1);
  if(avahi_watch$link1 == ((struct AvahiWatch$1 *)NULL) && !(b$link1 == 0u))
  {
    signed int return_value_dbus_watch_get_unix_fd$2$link1;
    return_value_dbus_watch_get_unix_fd$2$link1=dbus_watch_get_unix_fd(dbus_watch$link1);
    unsigned int return_value_dbus_watch_get_flags$3$link1;
    return_value_dbus_watch_get_flags$3$link1=dbus_watch_get_flags(dbus_watch$link1);
    enum anonymous return_value_translate_dbus_to_avahi$4$link1;
    return_value_translate_dbus_to_avahi$4$link1=translate_dbus_to_avahi$link1(return_value_dbus_watch_get_flags$3$link1);
    avahi_watch$link1=poll_api$link1->watch_new(poll_api$link1, return_value_dbus_watch_get_unix_fd$2$link1, return_value_translate_dbus_to_avahi$4$link1, watch_callback$link1, (void *)dbus_watch$link1);
    if(avahi_watch$link1 == ((struct AvahiWatch$1 *)NULL))
      return (unsigned int)0;

    dbus_watch_set_data(dbus_watch$link1, (void *)avahi_watch$link1, (void (*)(void *))(void *)0);
  }

  else
    if(b$link1 == 0u && !(avahi_watch$link1 == ((struct AvahiWatch$1 *)NULL)))
    {
      poll_api$link1->watch_free(avahi_watch$link1);
      dbus_watch_set_data(dbus_watch$link1, (void *)0, (void (*)(void *))(void *)0);
    }

    else
      if(!(avahi_watch$link1 == ((struct AvahiWatch$1 *)NULL)))
      {
        unsigned int return_value_dbus_watch_get_flags$5$link1;
        return_value_dbus_watch_get_flags$5$link1=dbus_watch_get_flags(dbus_watch$link1);
        poll_api$link1->watch_update(avahi_watch$link1, (enum anonymous)return_value_dbus_watch_get_flags$5$link1);
      }

  return (unsigned int)1;
}

// watch_callback
// file ../avahi-common/dbus-watch-glue.c line 115
static void watch_callback(struct AvahiWatch$1 *avahi_watch, signed int fd, enum anonymous events, void *userdata)
{
  struct DBusWatch *dbus_watch = (struct DBusWatch *)userdata;
  /* assertion avahi_watch */
  assert(avahi_watch != ((struct AvahiWatch$1 *)NULL));
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  unsigned int return_value_translate_avahi_to_dbus$1;
  return_value_translate_avahi_to_dbus$1=translate_avahi_to_dbus(events);
  dbus_watch_handle(dbus_watch, return_value_translate_avahi_to_dbus$1);
}

// watch_callback$link1
// file ../avahi-common/dbus-watch-glue.c line 115
static void watch_callback$link1(struct AvahiWatch$1 *avahi_watch$link1, signed int fd$link1, enum anonymous events$link1, void *userdata$link1)
{
  struct DBusWatch *dbus_watch$link1 = (struct DBusWatch *)userdata$link1;
  /* assertion avahi_watch */
  assert(avahi_watch$link1 != ((struct AvahiWatch$1 *)NULL));
  /* assertion dbus_watch */
  assert(dbus_watch$link1 != ((struct DBusWatch *)NULL));
  unsigned int return_value_translate_avahi_to_dbus$1$link1;
  return_value_translate_avahi_to_dbus$1$link1=translate_avahi_to_dbus$link1(events$link1);
  dbus_watch_handle(dbus_watch$link1, return_value_translate_avahi_to_dbus$1$link1);
}

// watch_free
// file simple-watch.c line 203
static void watch_free(struct AvahiWatch$1 *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch$1 *)NULL));
  /* assertion !w->dead */
  assert(!(w->dead != 0));
  avahi_simple_poll_wakeup(w->simple_poll);
  remove_pollfd(w);
  w->dead = 1;
  w->simple_poll->n_watches = w->simple_poll->n_watches - 1;
  w->simple_poll->watch_req_cleanup = 1;
}

// watch_free$link1
// file simple-watch.c line 203
static void watch_free$link1(struct AvahiWatch$1 *w$link1)
{
  /* assertion w */
  assert(w$link1 != ((struct AvahiWatch$1 *)NULL));
  /* assertion !w->dead */
  assert(!(w$link1->dead != 0));
  avahi_simple_poll_wakeup(w$link1->simple_poll);
  remove_pollfd$link1(w$link1);
  w$link1->dead = 1;
  w$link1->simple_poll->n_watches = w$link1->simple_poll->n_watches - 1;
  w$link1->simple_poll->watch_req_cleanup = 1;
}

// watch_free$link1$link1
// file simple-watch.c line 203
static void watch_free$link1$link1(struct AvahiWatch *w$link1$link1)
{
  /* assertion w */
  assert(w$link1$link1 != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w$link1$link1->dead != 0));
  avahi_simple_poll_wakeup(w$link1$link1->simple_poll);
  remove_pollfd$link2(w$link1$link1);
  w$link1$link1->dead = 1;
  w$link1$link1->simple_poll->n_watches = w$link1$link1->simple_poll->n_watches - 1;
  w$link1$link1->simple_poll->watch_req_cleanup = 1;
}

// watch_free$link1$link2
// file simple-watch.c line 203
static void watch_free$link1$link2(struct AvahiWatch$1 *w$link1$link2)
{
  /* assertion w */
  assert(w$link1$link2 != ((struct AvahiWatch$1 *)NULL));
  /* assertion !w->dead */
  assert(!(w$link1$link2->dead != 0));
  avahi_simple_poll_wakeup(w$link1$link2->simple_poll);
  remove_pollfd$link1$link1(w$link1$link2);
  w$link1$link2->dead = 1;
  w$link1$link2->simple_poll->n_watches = w$link1$link2->simple_poll->n_watches - 1;
  w$link1$link2->simple_poll->watch_req_cleanup = 1;
}

// watch_free$link2
// file glib-watch.c line 153
static void watch_free$link2(struct AvahiWatch$0 *w$link2)
{
  /* assertion w */
  assert(w$link2 != ((struct AvahiWatch$0 *)NULL));
  /* assertion !w->dead */
  assert(!(w$link2->dead != 0));
  if(!(w$link2->pollfd_added == 0))
  {
    g_source_remove_poll(&w$link2->glib_poll->source, &w$link2->pollfd);
    w$link2->pollfd_added = 0;
  }

  w$link2->dead = (signed int)!(0 != 0);
  w$link2->glib_poll->timeout_req_cleanup = (signed int)!(0 != 0);
}

// watch_free$link3
// file simple-watch.c line 203
static void watch_free$link3(struct AvahiWatch$1 *w$link3)
{
  /* assertion w */
  assert(w$link3 != ((struct AvahiWatch$1 *)NULL));
  /* assertion !w->dead */
  assert(!(w$link3->dead != 0));
  avahi_simple_poll_wakeup(w$link3->simple_poll);
  remove_pollfd$link3(w$link3);
  w$link3->dead = 1;
  w$link3->simple_poll->n_watches = w$link3->simple_poll->n_watches - 1;
  w$link3->simple_poll->watch_req_cleanup = 1;
}

// watch_get_events
// file simple-watch.c line 184
static enum anonymous watch_get_events(struct AvahiWatch$1 *w)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch$1 *)NULL));
  /* assertion !w->dead */
  assert(!(w->dead != 0));
  if(!(w->idx == -1))
  {
    if(w->simple_poll->events_valid == 0)
      goto __CPROVER_DUMP_L1;

    return (enum anonymous)(w->simple_poll->pollfds + (signed long int)w->idx)->revents;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (enum anonymous)0;
  }
}

// watch_get_events$link1
// file simple-watch.c line 184
static enum anonymous watch_get_events$link1(struct AvahiWatch$1 *w$link1)
{
  /* assertion w */
  assert(w$link1 != ((struct AvahiWatch$1 *)NULL));
  /* assertion !w->dead */
  assert(!(w$link1->dead != 0));
  if(!(w$link1->idx == -1))
  {
    if(w$link1->simple_poll->events_valid == 0)
      goto __CPROVER_DUMP_L1;

    return (enum anonymous)(w$link1->simple_poll->pollfds + (signed long int)w$link1->idx)->revents;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (enum anonymous)0;
  }
}

// watch_get_events$link1$link1
// file simple-watch.c line 184
static enum anonymous watch_get_events$link1$link1(struct AvahiWatch *w$link1$link1)
{
  /* assertion w */
  assert(w$link1$link1 != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w$link1$link1->dead != 0));
  if(!(w$link1$link1->idx == -1))
  {
    if(w$link1$link1->simple_poll->events_valid == 0)
      goto __CPROVER_DUMP_L1;

    return (enum anonymous)(w$link1$link1->simple_poll->pollfds + (signed long int)w$link1$link1->idx)->revents;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (enum anonymous)0;
  }
}

// watch_get_events$link1$link2
// file simple-watch.c line 184
static enum anonymous watch_get_events$link1$link2(struct AvahiWatch$1 *w$link1$link2)
{
  /* assertion w */
  assert(w$link1$link2 != ((struct AvahiWatch$1 *)NULL));
  /* assertion !w->dead */
  assert(!(w$link1$link2->dead != 0));
  if(!(w$link1$link2->idx == -1))
  {
    if(w$link1$link2->simple_poll->events_valid == 0)
      goto __CPROVER_DUMP_L1;

    return (enum anonymous)(w$link1$link2->simple_poll->pollfds + (signed long int)w$link1$link2->idx)->revents;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (enum anonymous)0;
  }
}

// watch_get_events$link2
// file glib-watch.c line 146
static enum anonymous watch_get_events$link2(struct AvahiWatch$0 *w$link2)
{
  /* assertion w */
  assert(w$link2 != ((struct AvahiWatch$0 *)NULL));
  /* assertion !w->dead */
  assert(!(w$link2->dead != 0));
  enum anonymous return_value_map_events_from_glib$1;
  return_value_map_events_from_glib$1=map_events_from_glib(w$link2->pollfd.revents);
  return return_value_map_events_from_glib$1;
}

// watch_get_events$link3
// file simple-watch.c line 184
static enum anonymous watch_get_events$link3(struct AvahiWatch$1 *w$link3)
{
  /* assertion w */
  assert(w$link3 != ((struct AvahiWatch$1 *)NULL));
  /* assertion !w->dead */
  assert(!(w$link3->dead != 0));
  if(!(w$link3->idx == -1))
  {
    if(w$link3->simple_poll->events_valid == 0)
      goto __CPROVER_DUMP_L1;

    return (enum anonymous)(w$link3->simple_poll->pollfds + (signed long int)w$link3->idx)->revents;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (enum anonymous)0;
  }
}

// watch_new
// file simple-watch.c line 132
static struct AvahiWatch$1 * watch_new(const struct AvahiPoll$1 *api, signed int fd, enum anonymous event, void (*callback)(struct AvahiWatch$1 *, signed int, enum anonymous, void *), void *userdata)
{
  struct AvahiWatch$1 *w;
  struct AvahiSimplePoll$0 *s;
  /* assertion api */
  assert(api != ((const struct AvahiPoll$1 *)NULL));
  /* assertion fd >= 0 */
  assert(fd >= 0);
  /* assertion callback */
  assert(callback != ((void (*)(struct AvahiWatch$1 *, signed int, enum anonymous, void *))NULL));
  s = (struct AvahiSimplePoll$0 *)api->userdata;
  /* assertion s */
  assert(s != ((struct AvahiSimplePoll$0 *)NULL));
  void *return_value_avahi_new_internal$1;
  return_value_avahi_new_internal$1=avahi_new_internal$link2$link1((unsigned int)1, sizeof(struct AvahiWatch$1) /*56ul*/ );
  w = (struct AvahiWatch$1 *)return_value_avahi_new_internal$1;
  if(w == ((struct AvahiWatch$1 *)NULL))
    return (struct AvahiWatch$1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s);
    w->simple_poll = s;
    w->dead = 0;
    w->pollfd.fd = fd;
    w->pollfd.events = (signed short int)event;
    w->pollfd.revents = (signed short int)0;
    w->callback = callback;
    w->userdata = userdata;
    w->idx = -1;
    s->rebuild_pollfds = 1;
    do
    {
      struct AvahiWatch$1 **_head = &s->watches;
      struct AvahiWatch$1 *_item = w;
      /* assertion _item */
      assert(_item != ((struct AvahiWatch$1 *)NULL));
      _item->watches_next = *_head;
      if(!(_item->watches_next == ((struct AvahiWatch$1 *)NULL)))
        _item->watches_next->watches_prev = _item;

      _item->watches_prev = (struct AvahiWatch$1 *)(void *)0;
      *_head = _item;
    }
    while((_Bool)0);
    s->n_watches = s->n_watches + 1;
    return w;
  }
}

// watch_new$link1
// file simple-watch.c line 132
static struct AvahiWatch$1 * watch_new$link1(const struct AvahiPoll$1 *api$link1, signed int fd$link1, enum anonymous event$link1, void (*callback$link1)(struct AvahiWatch$1 *, signed int, enum anonymous, void *), void *userdata$link1)
{
  struct AvahiWatch$1 *w$link1;
  struct AvahiSimplePoll$0 *s$link1;
  /* assertion api */
  assert(api$link1 != ((const struct AvahiPoll$1 *)NULL));
  /* assertion fd >= 0 */
  assert(fd$link1 >= 0);
  /* assertion callback */
  assert(callback$link1 != ((void (*)(struct AvahiWatch$1 *, signed int, enum anonymous, void *))NULL));
  s$link1 = (struct AvahiSimplePoll$0 *)api$link1->userdata;
  /* assertion s */
  assert(s$link1 != ((struct AvahiSimplePoll$0 *)NULL));
  void *return_value_avahi_new_internal$1$link1;
  return_value_avahi_new_internal$1$link1=avahi_new_internal$link2$link2((unsigned int)1, sizeof(struct AvahiWatch$1) /*56ul*/ );
  w$link1 = (struct AvahiWatch$1 *)return_value_avahi_new_internal$1$link1;
  if(w$link1 == ((struct AvahiWatch$1 *)NULL))
    return (struct AvahiWatch$1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s$link1);
    w$link1->simple_poll = s$link1;
    w$link1->dead = 0;
    w$link1->pollfd.fd = fd$link1;
    w$link1->pollfd.events = (signed short int)event$link1;
    w$link1->pollfd.revents = (signed short int)0;
    w$link1->callback = callback$link1;
    w$link1->userdata = userdata$link1;
    w$link1->idx = -1;
    s$link1->rebuild_pollfds = 1;
    do
    {
      struct AvahiWatch$1 **_head$link1 = &s$link1->watches;
      struct AvahiWatch$1 *_item$link1 = w$link1;
      /* assertion _item */
      assert(_item$link1 != ((struct AvahiWatch$1 *)NULL));
      _item$link1->watches_next = *_head$link1;
      if(!(_item$link1->watches_next == ((struct AvahiWatch$1 *)NULL)))
        _item$link1->watches_next->watches_prev = _item$link1;

      _item$link1->watches_prev = (struct AvahiWatch$1 *)(void *)0;
      *_head$link1 = _item$link1;
    }
    while((_Bool)0);
    s$link1->n_watches = s$link1->n_watches + 1;
    return w$link1;
  }
}

// watch_new$link1$link1
// file simple-watch.c line 132
static struct AvahiWatch * watch_new$link1$link1(const struct AvahiPoll$0 *api$link1$link1, signed int fd$link1$link1, enum anonymous event$link2, void (*callback$link1$link1)(struct AvahiWatch *, signed int, enum anonymous, void *), void *userdata$link1$link1)
{
  struct AvahiWatch *w$link1$link1;
  struct AvahiSimplePoll *s$link2;
  /* assertion api */
  assert(api$link1$link1 != ((const struct AvahiPoll$0 *)NULL));
  /* assertion fd >= 0 */
  assert(fd$link1$link1 >= 0);
  /* assertion callback */
  assert(callback$link1$link1 != ((void (*)(struct AvahiWatch *, signed int, enum anonymous, void *))NULL));
  s$link2 = (struct AvahiSimplePoll *)api$link1$link1->userdata;
  /* assertion s */
  assert(s$link2 != ((struct AvahiSimplePoll *)NULL));
  void *return_value_avahi_new_internal$1$link1$link1;
  return_value_avahi_new_internal$1$link1$link1=avahi_new_internal$link2$link3((unsigned int)1, sizeof(struct AvahiWatch) /*56ul*/ );
  w$link1$link1 = (struct AvahiWatch *)return_value_avahi_new_internal$1$link1$link1;
  if(w$link1$link1 == ((struct AvahiWatch *)NULL))
    return (struct AvahiWatch *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s$link2);
    w$link1$link1->simple_poll = s$link2;
    w$link1$link1->dead = 0;
    w$link1$link1->pollfd.fd = fd$link1$link1;
    w$link1$link1->pollfd.events = (signed short int)event$link2;
    w$link1$link1->pollfd.revents = (signed short int)0;
    w$link1$link1->callback = callback$link1$link1;
    w$link1$link1->userdata = userdata$link1$link1;
    w$link1$link1->idx = -1;
    s$link2->rebuild_pollfds = 1;
    do
    {
      struct AvahiWatch **_head$link1$link1 = &s$link2->watches;
      struct AvahiWatch *_item$link1$link1 = w$link1$link1;
      /* assertion _item */
      assert(_item$link1$link1 != ((struct AvahiWatch *)NULL));
      _item$link1$link1->watches_next = *_head$link1$link1;
      if(!(_item$link1$link1->watches_next == ((struct AvahiWatch *)NULL)))
        _item$link1$link1->watches_next->watches_prev = _item$link1$link1;

      _item$link1$link1->watches_prev = (struct AvahiWatch *)(void *)0;
      *_head$link1$link1 = _item$link1$link1;
    }
    while((_Bool)0);
    s$link2->n_watches = s$link2->n_watches + 1;
    return w$link1$link1;
  }
}

// watch_new$link1$link2
// file simple-watch.c line 132
static struct AvahiWatch$1 * watch_new$link1$link2(const struct AvahiPoll$1 *api$link1$link2, signed int fd$link1$link2, enum anonymous event$link1$link1, void (*callback$link1$link2)(struct AvahiWatch$1 *, signed int, enum anonymous, void *), void *userdata$link1$link2)
{
  struct AvahiWatch$1 *w$link1$link2;
  struct AvahiSimplePoll$0 *s$link1$link1;
  /* assertion api */
  assert(api$link1$link2 != ((const struct AvahiPoll$1 *)NULL));
  /* assertion fd >= 0 */
  assert(fd$link1$link2 >= 0);
  /* assertion callback */
  assert(callback$link1$link2 != ((void (*)(struct AvahiWatch$1 *, signed int, enum anonymous, void *))NULL));
  s$link1$link1 = (struct AvahiSimplePoll$0 *)api$link1$link2->userdata;
  /* assertion s */
  assert(s$link1$link1 != ((struct AvahiSimplePoll$0 *)NULL));
  void *return_value_avahi_new_internal$1$link1$link2;
  return_value_avahi_new_internal$1$link1$link2=avahi_new_internal$link2$link1$link1((unsigned int)1, sizeof(struct AvahiWatch$1) /*56ul*/ );
  w$link1$link2 = (struct AvahiWatch$1 *)return_value_avahi_new_internal$1$link1$link2;
  if(w$link1$link2 == ((struct AvahiWatch$1 *)NULL))
    return (struct AvahiWatch$1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s$link1$link1);
    w$link1$link2->simple_poll = s$link1$link1;
    w$link1$link2->dead = 0;
    w$link1$link2->pollfd.fd = fd$link1$link2;
    w$link1$link2->pollfd.events = (signed short int)event$link1$link1;
    w$link1$link2->pollfd.revents = (signed short int)0;
    w$link1$link2->callback = callback$link1$link2;
    w$link1$link2->userdata = userdata$link1$link2;
    w$link1$link2->idx = -1;
    s$link1$link1->rebuild_pollfds = 1;
    do
    {
      struct AvahiWatch$1 **_head$link1$link2 = &s$link1$link1->watches;
      struct AvahiWatch$1 *_item$link1$link2 = w$link1$link2;
      /* assertion _item */
      assert(_item$link1$link2 != ((struct AvahiWatch$1 *)NULL));
      _item$link1$link2->watches_next = *_head$link1$link2;
      if(!(_item$link1$link2->watches_next == ((struct AvahiWatch$1 *)NULL)))
        _item$link1$link2->watches_next->watches_prev = _item$link1$link2;

      _item$link1$link2->watches_prev = (struct AvahiWatch$1 *)(void *)0;
      *_head$link1$link2 = _item$link1$link2;
    }
    while((_Bool)0);
    s$link1$link1->n_watches = s$link1$link1->n_watches + 1;
    return w$link1$link2;
  }
}

// watch_new$link2
// file glib-watch.c line 109
static struct AvahiWatch$0 * watch_new$link2(const struct AvahiPoll *api$link2, signed int fd$link2, enum anonymous events, void (*callback$link2)(struct AvahiWatch$0 *, signed int, enum anonymous, void *), void *userdata$link2)
{
  struct AvahiWatch$0 *w$link2;
  struct AvahiGLibPoll *g;
  /* assertion api */
  assert(api$link2 != ((const struct AvahiPoll *)NULL));
  /* assertion fd >= 0 */
  assert(fd$link2 >= 0);
  /* assertion callback */
  assert(callback$link2 != ((void (*)(struct AvahiWatch$0 *, signed int, enum anonymous, void *))NULL));
  g = (struct AvahiGLibPoll *)api$link2->userdata;
  /* assertion g */
  assert(g != ((struct AvahiGLibPoll *)NULL));
  void *return_value_avahi_new_internal$1$link2;
  return_value_avahi_new_internal$1$link2=avahi_new_internal$link7((unsigned int)1, sizeof(struct AvahiWatch$0) /*56ul*/ );
  w$link2 = (struct AvahiWatch$0 *)return_value_avahi_new_internal$1$link2;
  if(w$link2 == ((struct AvahiWatch$0 *)NULL))
    return (struct AvahiWatch$0 *)(void *)0;

  else
  {
    w$link2->glib_poll = g;
    w$link2->pollfd.fd = fd$link2;
    w$link2->pollfd.events=map_events_to_glib(events);
    w$link2->pollfd.revents = (unsigned short int)0;
    w$link2->callback = callback$link2;
    w$link2->userdata = userdata$link2;
    w$link2->dead = 0;
    g_source_add_poll(&g->source, &w$link2->pollfd);
    w$link2->pollfd_added = (signed int)!(0 != 0);
    do
    {
      struct AvahiWatch$0 **_head$link2 = &g->watches;
      struct AvahiWatch$0 *_item$link2 = w$link2;
      /* assertion _item */
      assert(_item$link2 != ((struct AvahiWatch$0 *)NULL));
      _item$link2->watches_next = *_head$link2;
      if(!(_item$link2->watches_next == ((struct AvahiWatch$0 *)NULL)))
        _item$link2->watches_next->watches_prev = _item$link2;

      _item$link2->watches_prev = (struct AvahiWatch$0 *)(void *)0;
      *_head$link2 = _item$link2;
    }
    while((_Bool)0);
    return w$link2;
  }
}

// watch_new$link3
// file simple-watch.c line 132
static struct AvahiWatch$1 * watch_new$link3(const struct AvahiPoll$1 *api$link3, signed int fd$link3, enum anonymous event$link3, void (*callback$link3)(struct AvahiWatch$1 *, signed int, enum anonymous, void *), void *userdata$link3)
{
  struct AvahiWatch$1 *w$link3;
  struct AvahiSimplePoll$0 *s$link3;
  /* assertion api */
  assert(api$link3 != ((const struct AvahiPoll$1 *)NULL));
  /* assertion fd >= 0 */
  assert(fd$link3 >= 0);
  /* assertion callback */
  assert(callback$link3 != ((void (*)(struct AvahiWatch$1 *, signed int, enum anonymous, void *))NULL));
  s$link3 = (struct AvahiSimplePoll$0 *)api$link3->userdata;
  /* assertion s */
  assert(s$link3 != ((struct AvahiSimplePoll$0 *)NULL));
  void *return_value_avahi_new_internal$1$link3;
  return_value_avahi_new_internal$1$link3=avahi_new_internal$link2$link4((unsigned int)1, sizeof(struct AvahiWatch$1) /*56ul*/ );
  w$link3 = (struct AvahiWatch$1 *)return_value_avahi_new_internal$1$link3;
  if(w$link3 == ((struct AvahiWatch$1 *)NULL))
    return (struct AvahiWatch$1 *)(void *)0;

  else
  {
    avahi_simple_poll_wakeup(s$link3);
    w$link3->simple_poll = s$link3;
    w$link3->dead = 0;
    w$link3->pollfd.fd = fd$link3;
    w$link3->pollfd.events = (signed short int)event$link3;
    w$link3->pollfd.revents = (signed short int)0;
    w$link3->callback = callback$link3;
    w$link3->userdata = userdata$link3;
    w$link3->idx = -1;
    s$link3->rebuild_pollfds = 1;
    do
    {
      struct AvahiWatch$1 **_head$link3 = &s$link3->watches;
      struct AvahiWatch$1 *_item$link3 = w$link3;
      /* assertion _item */
      assert(_item$link3 != ((struct AvahiWatch$1 *)NULL));
      _item$link3->watches_next = *_head$link3;
      if(!(_item$link3->watches_next == ((struct AvahiWatch$1 *)NULL)))
        _item$link3->watches_next->watches_prev = _item$link3;

      _item$link3->watches_prev = (struct AvahiWatch$1 *)(void *)0;
      *_head$link3 = _item$link3;
    }
    while((_Bool)0);
    s$link3->n_watches = s$link3->n_watches + 1;
    return w$link3;
  }
}

// watch_toggled
// file ../avahi-common/dbus-watch-glue.c line 187
static void watch_toggled(struct DBusWatch *dbus_watch, void *userdata)
{
  struct anonymous$28 *d = (struct anonymous$28 *)userdata;
  /* assertion dbus_watch */
  assert(dbus_watch != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d != ((struct anonymous$28 *)NULL));
  update_watch(d->poll_api, dbus_watch);
}

// watch_toggled$link1
// file ../avahi-common/dbus-watch-glue.c line 187
static void watch_toggled$link1(struct DBusWatch *dbus_watch$link1, void *userdata$link1)
{
  struct anonymous$28 *d$link1 = (struct anonymous$28 *)userdata$link1;
  /* assertion dbus_watch */
  assert(dbus_watch$link1 != ((struct DBusWatch *)NULL));
  /* assertion d */
  assert(d$link1 != ((struct anonymous$28 *)NULL));
  update_watch$link1(d$link1->poll_api, dbus_watch$link1);
}

// watch_update
// file simple-watch.c line 168
static void watch_update(struct AvahiWatch$1 *w, enum anonymous events)
{
  /* assertion w */
  assert(w != ((struct AvahiWatch$1 *)NULL));
  /* assertion !w->dead */
  assert(!(w->dead != 0));
  avahi_simple_poll_wakeup(w->simple_poll);
  w->pollfd.events = (signed short int)events;
  if(!(w->idx == -1))
  {
    /* assertion w->simple_poll */
    assert(w->simple_poll != ((struct AvahiSimplePoll$0 *)NULL));
    w->simple_poll->pollfds[(signed long int)w->idx] = w->pollfd;
  }

  else
    w->simple_poll->rebuild_pollfds = 1;
}

// watch_update$link1
// file simple-watch.c line 168
static void watch_update$link1(struct AvahiWatch$1 *w$link1, enum anonymous events$link1)
{
  /* assertion w */
  assert(w$link1 != ((struct AvahiWatch$1 *)NULL));
  /* assertion !w->dead */
  assert(!(w$link1->dead != 0));
  avahi_simple_poll_wakeup(w$link1->simple_poll);
  w$link1->pollfd.events = (signed short int)events$link1;
  if(!(w$link1->idx == -1))
  {
    /* assertion w->simple_poll */
    assert(w$link1->simple_poll != ((struct AvahiSimplePoll$0 *)NULL));
    w$link1->simple_poll->pollfds[(signed long int)w$link1->idx] = w$link1->pollfd;
  }

  else
    w$link1->simple_poll->rebuild_pollfds = 1;
}

// watch_update$link1$link1
// file simple-watch.c line 168
static void watch_update$link1$link1(struct AvahiWatch *w$link1$link1, enum anonymous events$link1$link1)
{
  /* assertion w */
  assert(w$link1$link1 != ((struct AvahiWatch *)NULL));
  /* assertion !w->dead */
  assert(!(w$link1$link1->dead != 0));
  avahi_simple_poll_wakeup(w$link1$link1->simple_poll);
  w$link1$link1->pollfd.events = (signed short int)events$link1$link1;
  if(!(w$link1$link1->idx == -1))
  {
    /* assertion w->simple_poll */
    assert(w$link1$link1->simple_poll != ((struct AvahiSimplePoll *)NULL));
    w$link1$link1->simple_poll->pollfds[(signed long int)w$link1$link1->idx] = w$link1$link1->pollfd;
  }

  else
    w$link1$link1->simple_poll->rebuild_pollfds = 1;
}

// watch_update$link1$link2
// file simple-watch.c line 168
static void watch_update$link1$link2(struct AvahiWatch$1 *w$link1$link2, enum anonymous events$link1$link2)
{
  /* assertion w */
  assert(w$link1$link2 != ((struct AvahiWatch$1 *)NULL));
  /* assertion !w->dead */
  assert(!(w$link1$link2->dead != 0));
  avahi_simple_poll_wakeup(w$link1$link2->simple_poll);
  w$link1$link2->pollfd.events = (signed short int)events$link1$link2;
  if(!(w$link1$link2->idx == -1))
  {
    /* assertion w->simple_poll */
    assert(w$link1$link2->simple_poll != ((struct AvahiSimplePoll$0 *)NULL));
    w$link1$link2->simple_poll->pollfds[(signed long int)w$link1$link2->idx] = w$link1$link2->pollfd;
  }

  else
    w$link1$link2->simple_poll->rebuild_pollfds = 1;
}

// watch_update$link2
// file glib-watch.c line 139
static void watch_update$link2(struct AvahiWatch$0 *w$link2, enum anonymous events$link2)
{
  /* assertion w */
  assert(w$link2 != ((struct AvahiWatch$0 *)NULL));
  /* assertion !w->dead */
  assert(!(w$link2->dead != 0));
  w$link2->pollfd.events=map_events_to_glib(events$link2);
}

// watch_update$link3
// file simple-watch.c line 168
static void watch_update$link3(struct AvahiWatch$1 *w$link3, enum anonymous events$link3)
{
  /* assertion w */
  assert(w$link3 != ((struct AvahiWatch$1 *)NULL));
  /* assertion !w->dead */
  assert(!(w$link3->dead != 0));
  avahi_simple_poll_wakeup(w$link3->simple_poll);
  w$link3->pollfd.events = (signed short int)events$link3;
  if(!(w$link3->idx == -1))
  {
    /* assertion w->simple_poll */
    assert(w$link3->simple_poll != ((struct AvahiSimplePoll$0 *)NULL));
    w$link3->simple_poll->pollfds[(signed long int)w$link3->idx] = w$link3->pollfd;
  }

  else
    w$link3->simple_poll->rebuild_pollfds = 1;
}

// xcalloc
// file malloc.c line 89
static void * xcalloc(unsigned long int nmemb, unsigned long int size)
{
  void *p;
  if(nmemb == 0ul || size == 0ul)
    return (void *)0;

  else
  {
    p=calloc(nmemb, size);
    if(p == NULL)
      oom();

    return p;
  }
}

// xcalloc$link1
// file malloc.c line 89
static void * xcalloc$link1(unsigned long int nmemb$link1, unsigned long int size$link1)
{
  void *p$link1;
  if(nmemb$link1 == 0ul || size$link1 == 0ul)
    return (void *)0;

  else
  {
    p$link1=calloc(nmemb$link1, size$link1);
    if(p$link1 == NULL)
      oom$link1();

    return p$link1;
  }
}

// xcalloc$link1$link1
// file malloc.c line 89
static void * xcalloc$link1$link1(unsigned long int nmemb$link1$link1, unsigned long int size$link1$link1)
{
  void *p$link1$link1;
  if(nmemb$link1$link1 == 0ul || size$link1$link1 == 0ul)
    return (void *)0;

  else
  {
    p$link1$link1=calloc(nmemb$link1$link1, size$link1$link1);
    if(p$link1$link1 == NULL)
      oom$link1$link1();

    return p$link1$link1;
  }
}

// xcalloc$link2
// file malloc.c line 89
static void * xcalloc$link2(unsigned long int nmemb$link2, unsigned long int size$link2)
{
  void *p$link2;
  if(nmemb$link2 == 0ul || size$link2 == 0ul)
    return (void *)0;

  else
  {
    p$link2=calloc(nmemb$link2, size$link2);
    if(p$link2 == NULL)
      oom$link2();

    return p$link2;
  }
}

// xcalloc$link3
// file malloc.c line 89
static void * xcalloc$link3(unsigned long int nmemb$link3, unsigned long int size$link3)
{
  void *p$link3;
  if(nmemb$link3 == 0ul || size$link3 == 0ul)
    return (void *)0;

  else
  {
    p$link3=calloc(nmemb$link3, size$link3);
    if(p$link3 == NULL)
      oom$link3();

    return p$link3;
  }
}

// xmalloc
// file malloc.c line 62
static void * xmalloc(unsigned long int size)
{
  void *p;
  if(size == 0ul)
    return (void *)0;

  else
  {
    p=malloc(size);
    if(p == NULL)
      oom();

    return p;
  }
}

// xmalloc$link1
// file malloc.c line 62
static void * xmalloc$link1(unsigned long int size$link1)
{
  void *p$link1;
  if(size$link1 == 0ul)
    return (void *)0;

  else
  {
    p$link1=malloc(size$link1);
    if(p$link1 == NULL)
      oom$link1();

    return p$link1;
  }
}

// xmalloc$link1$link1
// file malloc.c line 62
static void * xmalloc$link1$link1(unsigned long int size$link1$link1)
{
  void *p$link1$link1;
  if(size$link1$link1 == 0ul)
    return (void *)0;

  else
  {
    p$link1$link1=malloc(size$link1$link1);
    if(p$link1$link1 == NULL)
      oom$link1$link1();

    return p$link1$link1;
  }
}

// xmalloc$link2
// file malloc.c line 62
static void * xmalloc$link2(unsigned long int size$link2)
{
  void *p$link2;
  if(size$link2 == 0ul)
    return (void *)0;

  else
  {
    p$link2=malloc(size$link2);
    if(p$link2 == NULL)
      oom$link2();

    return p$link2;
  }
}

// xmalloc$link3
// file malloc.c line 62
static void * xmalloc$link3(unsigned long int size$link3)
{
  void *p$link3;
  if(size$link3 == 0ul)
    return (void *)0;

  else
  {
    p$link3=malloc(size$link3);
    if(p$link3 == NULL)
      oom$link3();

    return p$link3;
  }
}

// xrealloc
// file malloc.c line 75
static void * xrealloc(void *p, unsigned long int size)
{
  if(size == 0ul)
  {
    free(p);
    return (void *)0;
  }

  else
  {
    p=realloc(p, size);
    if(p == NULL)
      oom();

    return p;
  }
}

// xrealloc$link1
// file malloc.c line 75
static void * xrealloc$link1(void *p$link1, unsigned long int size$link1)
{
  if(size$link1 == 0ul)
  {
    free(p$link1);
    return (void *)0;
  }

  else
  {
    p$link1=realloc(p$link1, size$link1);
    if(p$link1 == NULL)
      oom$link1();

    return p$link1;
  }
}

// xrealloc$link1$link1
// file malloc.c line 75
static void * xrealloc$link1$link1(void *p$link1$link1, unsigned long int size$link1$link1)
{
  if(size$link1$link1 == 0ul)
  {
    free(p$link1$link1);
    return (void *)0;
  }

  else
  {
    p$link1$link1=realloc(p$link1$link1, size$link1$link1);
    if(p$link1$link1 == NULL)
      oom$link1$link1();

    return p$link1$link1;
  }
}

// xrealloc$link2
// file malloc.c line 75
static void * xrealloc$link2(void *p$link2, unsigned long int size$link2)
{
  if(size$link2 == 0ul)
  {
    free(p$link2);
    return (void *)0;
  }

  else
  {
    p$link2=realloc(p$link2, size$link2);
    if(p$link2 == NULL)
      oom$link2();

    return p$link2;
  }
}

// xrealloc$link3
// file malloc.c line 75
static void * xrealloc$link3(void *p$link3, unsigned long int size$link3)
{
  if(size$link3 == 0ul)
  {
    free(p$link3);
    return (void *)0;
  }

  else
  {
    p$link3=realloc(p$link3, size$link3);
    if(p$link3 == NULL)
      oom$link3();

    return p$link3;
  }
}

