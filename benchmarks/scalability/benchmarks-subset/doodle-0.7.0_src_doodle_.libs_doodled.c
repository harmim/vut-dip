// tag-#anon#ST[*{S8}$S8$'filename'||U32'mod_time'||U32'$pad0'|]
// file doodle.h line 67
struct anonymous;

// tag-#anon#ST[*{SYM#tag-EXTRACT_Process#}$SYM#tag-EXTRACT_Process#$'elist'||*{SYM#tag-DOODLE_SuffixTree#}$SYM#tag-DOODLE_SuffixTree#$'tree'||SYM#tag-FAMConnection#'fc'||*{SYM#tag-FAMRequest#}$SYM#tag-FAMRequest#$'fr'||*{*{S8}$S8$}$*{S8}$S8$$'frNames'||U32'frPos'||U32'frSize'||*{V(*{V}$V$|U32|*{cS8}$cS8$|...)->V}$V(*{V}$V$|U32|*{cS8}$cS8$|...)->V$'log'||*{V}$V$'logContext'||*{S8}$S8$'ename'||U32'treePresent'||U32'argc'||*{*{S8}$S8$}$*{S8}$S8$$'argv'||SYM#tag-Mutex#'lock'||U32'eventCount'||U32'$pad0'||*{*{S8}$S8$}$*{S8}$S8$$'events'||S32'continueRunning'||U32'deferredCount'||*{*{S8}$S8$}$*{S8}$S8$$'deferredTruncations'||*{SYM#tag-Semaphore#}$SYM#tag-Semaphore#$'signal'|]
// file doodled.c line 146
struct anonymous$17;

// tag-#anon#ST[*{V(*{V}$V$|U32|*{cS8}$cS8$|...)->V}$V(*{V}$V$|U32|*{cS8}$cS8$|...)->V$'log'||*{V}$V$'context'||S32'fd'||U32'$pad0'||U64'off'||U64'fsize'||U64'bstart'||U64'bsize'||*{S8}$S8$'buffer'||U64'dirty'|]
// file tree.c line 159
struct anonymous$0;

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$16;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$14;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$18;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$6;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$2;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$10;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$13;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$12;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$8;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$11;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$15;

// tag-#anon#ST[S8'shortArg'||U56'$pad0'||*{S8}$S8$'longArg'||*{S8}$S8$'mandatoryArg'||*{S8}$S8$'description'|]
// file helper2.h line 48
struct anonymous$1;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$9;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$7;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$4;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$3;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$5;

// tag-AccuCtx
// file index.c line 120
struct AccuCtx;

// tag-DOODLE_Node
// file tree.c line 723
struct DOODLE_Node;

// tag-DOODLE_SuffixTree
// file doodle.h line 58
struct DOODLE_SuffixTree;

// tag-EXTRACTOR_MetaFormat
// file /usr/include/extractor.h line 81
enum EXTRACTOR_MetaFormat { EXTRACTOR_METAFORMAT_UNKNOWN=0, EXTRACTOR_METAFORMAT_UTF8=1, EXTRACTOR_METAFORMAT_BINARY=2, EXTRACTOR_METAFORMAT_C_STRING=3 };

// tag-EXTRACTOR_MetaType
// file /usr/include/extractor.h line 115
enum EXTRACTOR_MetaType { EXTRACTOR_METATYPE_RESERVED=0, EXTRACTOR_METATYPE_MIMETYPE=1, EXTRACTOR_METATYPE_FILENAME=2, EXTRACTOR_METATYPE_COMMENT=3, EXTRACTOR_METATYPE_TITLE=4, EXTRACTOR_METATYPE_BOOK_TITLE=5, EXTRACTOR_METATYPE_BOOK_EDITION=6, EXTRACTOR_METATYPE_BOOK_CHAPTER_NUMBER=7, EXTRACTOR_METATYPE_JOURNAL_NAME=8, EXTRACTOR_METATYPE_JOURNAL_VOLUME=9, EXTRACTOR_METATYPE_JOURNAL_NUMBER=10, EXTRACTOR_METATYPE_PAGE_COUNT=11, EXTRACTOR_METATYPE_PAGE_RANGE=12, EXTRACTOR_METATYPE_AUTHOR_NAME=13, EXTRACTOR_METATYPE_AUTHOR_EMAIL=14, EXTRACTOR_METATYPE_AUTHOR_INSTITUTION=15, EXTRACTOR_METATYPE_PUBLISHER=16, EXTRACTOR_METATYPE_PUBLISHER_ADDRESS=17, EXTRACTOR_METATYPE_PUBLISHER_INSTITUTION=18, EXTRACTOR_METATYPE_PUBLISHER_SERIES=19, EXTRACTOR_METATYPE_PUBLICATION_TYPE=20, EXTRACTOR_METATYPE_PUBLICATION_YEAR=21, EXTRACTOR_METATYPE_PUBLICATION_MONTH=22, EXTRACTOR_METATYPE_PUBLICATION_DAY=23, EXTRACTOR_METATYPE_PUBLICATION_DATE=24, EXTRACTOR_METATYPE_BIBTEX_EPRINT=25, EXTRACTOR_METATYPE_BIBTEX_ENTRY_TYPE=26, EXTRACTOR_METATYPE_LANGUAGE=27, EXTRACTOR_METATYPE_CREATION_TIME=28, EXTRACTOR_METATYPE_URL=29, EXTRACTOR_METATYPE_URI=30, EXTRACTOR_METATYPE_ISRC=31, EXTRACTOR_METATYPE_HASH_MD4=32, EXTRACTOR_METATYPE_HASH_MD5=33, EXTRACTOR_METATYPE_HASH_SHA0=34, EXTRACTOR_METATYPE_HASH_SHA1=35, EXTRACTOR_METATYPE_HASH_RMD160=36, EXTRACTOR_METATYPE_GPS_LATITUDE_REF=37, EXTRACTOR_METATYPE_GPS_LATITUDE=38, EXTRACTOR_METATYPE_GPS_LONGITUDE_REF=39, EXTRACTOR_METATYPE_GPS_LONGITUDE=40, EXTRACTOR_METATYPE_LOCATION_CITY=41, EXTRACTOR_METATYPE_LOCATION_SUBLOCATION=42, EXTRACTOR_METATYPE_LOCATION_COUNTRY=43, EXTRACTOR_METATYPE_LOCATION_COUNTRY_CODE=44, EXTRACTOR_METATYPE_UNKNOWN=45, EXTRACTOR_METATYPE_DESCRIPTION=46, EXTRACTOR_METATYPE_COPYRIGHT=47, EXTRACTOR_METATYPE_RIGHTS=48, EXTRACTOR_METATYPE_KEYWORDS=49, EXTRACTOR_METATYPE_ABSTRACT=50, EXTRACTOR_METATYPE_SUMMARY=51, EXTRACTOR_METATYPE_SUBJECT=52, EXTRACTOR_METATYPE_CREATOR=53, EXTRACTOR_METATYPE_FORMAT=54, EXTRACTOR_METATYPE_FORMAT_VERSION=55, EXTRACTOR_METATYPE_CREATED_BY_SOFTWARE=56, EXTRACTOR_METATYPE_UNKNOWN_DATE=57, EXTRACTOR_METATYPE_CREATION_DATE=58, EXTRACTOR_METATYPE_MODIFICATION_DATE=59, EXTRACTOR_METATYPE_LAST_PRINTED=60, EXTRACTOR_METATYPE_LAST_SAVED_BY=61, EXTRACTOR_METATYPE_TOTAL_EDITING_TIME=62, EXTRACTOR_METATYPE_EDITING_CYCLES=63, EXTRACTOR_METATYPE_MODIFIED_BY_SOFTWARE=64, EXTRACTOR_METATYPE_REVISION_HISTORY=65, EXTRACTOR_METATYPE_EMBEDDED_FILE_SIZE=66, EXTRACTOR_METATYPE_FINDER_FILE_TYPE=67, EXTRACTOR_METATYPE_FINDER_FILE_CREATOR=68, EXTRACTOR_METATYPE_PACKAGE_NAME=69, EXTRACTOR_METATYPE_PACKAGE_VERSION=70, EXTRACTOR_METATYPE_SECTION=71, EXTRACTOR_METATYPE_UPLOAD_PRIORITY=72, EXTRACTOR_METATYPE_PACKAGE_DEPENDENCY=73, EXTRACTOR_METATYPE_PACKAGE_CONFLICTS=74, EXTRACTOR_METATYPE_PACKAGE_REPLACES=75, EXTRACTOR_METATYPE_PACKAGE_PROVIDES=76, EXTRACTOR_METATYPE_PACKAGE_RECOMMENDS=77, EXTRACTOR_METATYPE_PACKAGE_SUGGESTS=78, EXTRACTOR_METATYPE_PACKAGE_MAINTAINER=79, EXTRACTOR_METATYPE_PACKAGE_INSTALLED_SIZE=80, EXTRACTOR_METATYPE_PACKAGE_SOURCE=81, EXTRACTOR_METATYPE_PACKAGE_ESSENTIAL=82, EXTRACTOR_METATYPE_TARGET_ARCHITECTURE=83, EXTRACTOR_METATYPE_PACKAGE_PRE_DEPENDENCY=84, EXTRACTOR_METATYPE_LICENSE=85, EXTRACTOR_METATYPE_PACKAGE_DISTRIBUTION=86, EXTRACTOR_METATYPE_BUILDHOST=87, EXTRACTOR_METATYPE_VENDOR=88, EXTRACTOR_METATYPE_TARGET_OS=89, EXTRACTOR_METATYPE_SOFTWARE_VERSION=90, EXTRACTOR_METATYPE_TARGET_PLATFORM=91, EXTRACTOR_METATYPE_RESOURCE_TYPE=92, EXTRACTOR_METATYPE_LIBRARY_SEARCH_PATH=93, EXTRACTOR_METATYPE_LIBRARY_DEPENDENCY=94, EXTRACTOR_METATYPE_CAMERA_MAKE=95, EXTRACTOR_METATYPE_CAMERA_MODEL=96, EXTRACTOR_METATYPE_EXPOSURE=97, EXTRACTOR_METATYPE_APERTURE=98, EXTRACTOR_METATYPE_EXPOSURE_BIAS=99, EXTRACTOR_METATYPE_FLASH=100, EXTRACTOR_METATYPE_FLASH_BIAS=101, EXTRACTOR_METATYPE_FOCAL_LENGTH=102, EXTRACTOR_METATYPE_FOCAL_LENGTH_35MM=103, EXTRACTOR_METATYPE_ISO_SPEED=104, EXTRACTOR_METATYPE_EXPOSURE_MODE=105, EXTRACTOR_METATYPE_METERING_MODE=106, EXTRACTOR_METATYPE_MACRO_MODE=107, EXTRACTOR_METATYPE_IMAGE_QUALITY=108, EXTRACTOR_METATYPE_WHITE_BALANCE=109, EXTRACTOR_METATYPE_ORIENTATION=110, EXTRACTOR_METATYPE_MAGNIFICATION=111, EXTRACTOR_METATYPE_IMAGE_DIMENSIONS=112, EXTRACTOR_METATYPE_PRODUCED_BY_SOFTWARE=113, EXTRACTOR_METATYPE_THUMBNAIL=114, EXTRACTOR_METATYPE_IMAGE_RESOLUTION=115, EXTRACTOR_METATYPE_SOURCE=116, EXTRACTOR_METATYPE_CHARACTER_SET=117, EXTRACTOR_METATYPE_LINE_COUNT=118, EXTRACTOR_METATYPE_PARAGRAPH_COUNT=119, EXTRACTOR_METATYPE_WORD_COUNT=120, EXTRACTOR_METATYPE_CHARACTER_COUNT=121, EXTRACTOR_METATYPE_PAGE_ORIENTATION=122, EXTRACTOR_METATYPE_PAPER_SIZE=123, EXTRACTOR_METATYPE_TEMPLATE=124, EXTRACTOR_METATYPE_COMPANY=125, EXTRACTOR_METATYPE_MANAGER=126, EXTRACTOR_METATYPE_REVISION_NUMBER=127, EXTRACTOR_METATYPE_DURATION=128, EXTRACTOR_METATYPE_ALBUM=129, EXTRACTOR_METATYPE_ARTIST=130, EXTRACTOR_METATYPE_GENRE=131, EXTRACTOR_METATYPE_TRACK_NUMBER=132, EXTRACTOR_METATYPE_DISC_NUMBER=133, EXTRACTOR_METATYPE_PERFORMER=134, EXTRACTOR_METATYPE_CONTACT_INFORMATION=135, EXTRACTOR_METATYPE_SONG_VERSION=136, EXTRACTOR_METATYPE_PICTURE=137, EXTRACTOR_METATYPE_COVER_PICTURE=138, EXTRACTOR_METATYPE_CONTRIBUTOR_PICTURE=139, EXTRACTOR_METATYPE_EVENT_PICTURE=140, EXTRACTOR_METATYPE_LOGO=141, EXTRACTOR_METATYPE_BROADCAST_TELEVISION_SYSTEM=142, EXTRACTOR_METATYPE_SOURCE_DEVICE=143, EXTRACTOR_METATYPE_DISCLAIMER=144, EXTRACTOR_METATYPE_WARNING=145, EXTRACTOR_METATYPE_PAGE_ORDER=146, EXTRACTOR_METATYPE_WRITER=147, EXTRACTOR_METATYPE_PRODUCT_VERSION=148, EXTRACTOR_METATYPE_CONTRIBUTOR_NAME=149, EXTRACTOR_METATYPE_MOVIE_DIRECTOR=150, EXTRACTOR_METATYPE_NETWORK_NAME=151, EXTRACTOR_METATYPE_SHOW_NAME=152, EXTRACTOR_METATYPE_CHAPTER_NAME=153, EXTRACTOR_METATYPE_SONG_COUNT=154, EXTRACTOR_METATYPE_STARTING_SONG=155, EXTRACTOR_METATYPE_PLAY_COUNTER=156, EXTRACTOR_METATYPE_CONDUCTOR=157, EXTRACTOR_METATYPE_INTERPRETATION=158, EXTRACTOR_METATYPE_COMPOSER=159, EXTRACTOR_METATYPE_BEATS_PER_MINUTE=160, EXTRACTOR_METATYPE_ENCODED_BY=161, EXTRACTOR_METATYPE_ORIGINAL_TITLE=162, EXTRACTOR_METATYPE_ORIGINAL_ARTIST=163, EXTRACTOR_METATYPE_ORIGINAL_WRITER=164, EXTRACTOR_METATYPE_ORIGINAL_RELEASE_YEAR=165, EXTRACTOR_METATYPE_ORIGINAL_PERFORMER=166, EXTRACTOR_METATYPE_LYRICS=167, EXTRACTOR_METATYPE_POPULARITY_METER=168, EXTRACTOR_METATYPE_LICENSEE=169, EXTRACTOR_METATYPE_MUSICIAN_CREDITS_LIST=170, EXTRACTOR_METATYPE_MOOD=171, EXTRACTOR_METATYPE_SUBTITLE=172, EXTRACTOR_METATYPE_GNUNET_DISPLAY_TYPE=173, EXTRACTOR_METATYPE_GNUNET_FULL_DATA=174, EXTRACTOR_METATYPE_RATING=175, EXTRACTOR_METATYPE_ORGANIZATION=176, EXTRACTOR_METATYPE_RIPPER=177, EXTRACTOR_METATYPE_PRODUCER=178, EXTRACTOR_METATYPE_GROUP=179, EXTRACTOR_METATYPE_GNUNET_ORIGINAL_FILENAME=180, EXTRACTOR_METATYPE_DISC_COUNT=181, EXTRACTOR_METATYPE_CODEC=182, EXTRACTOR_METATYPE_VIDEO_CODEC=183, EXTRACTOR_METATYPE_AUDIO_CODEC=184, EXTRACTOR_METATYPE_SUBTITLE_CODEC=185, EXTRACTOR_METATYPE_CONTAINER_FORMAT=186, EXTRACTOR_METATYPE_BITRATE=187, EXTRACTOR_METATYPE_NOMINAL_BITRATE=188, EXTRACTOR_METATYPE_MINIMUM_BITRATE=189, EXTRACTOR_METATYPE_MAXIMUM_BITRATE=190, EXTRACTOR_METATYPE_SERIAL=191, EXTRACTOR_METATYPE_ENCODER=192, EXTRACTOR_METATYPE_ENCODER_VERSION=193, EXTRACTOR_METATYPE_TRACK_GAIN=194, EXTRACTOR_METATYPE_TRACK_PEAK=195, EXTRACTOR_METATYPE_ALBUM_GAIN=196, EXTRACTOR_METATYPE_ALBUM_PEAK=197, EXTRACTOR_METATYPE_REFERENCE_LEVEL=198, EXTRACTOR_METATYPE_LOCATION_NAME=199, EXTRACTOR_METATYPE_LOCATION_ELEVATION=200, EXTRACTOR_METATYPE_LOCATION_HORIZONTAL_ERROR=201, EXTRACTOR_METATYPE_LOCATION_MOVEMENT_SPEED=202, EXTRACTOR_METATYPE_LOCATION_MOVEMENT_DIRECTION=203, EXTRACTOR_METATYPE_LOCATION_CAPTURE_DIRECTION=204, EXTRACTOR_METATYPE_SHOW_EPISODE_NUMBER=205, EXTRACTOR_METATYPE_SHOW_SEASON_NUMBER=206, EXTRACTOR_METATYPE_GROUPING=207, EXTRACTOR_METATYPE_DEVICE_MANUFACTURER=208, EXTRACTOR_METATYPE_DEVICE_MODEL=209, EXTRACTOR_METATYPE_AUDIO_LANGUAGE=210, EXTRACTOR_METATYPE_CHANNELS=211, EXTRACTOR_METATYPE_SAMPLE_RATE=212, EXTRACTOR_METATYPE_AUDIO_DEPTH=213, EXTRACTOR_METATYPE_AUDIO_BITRATE=214, EXTRACTOR_METATYPE_MAXIMUM_AUDIO_BITRATE=215, EXTRACTOR_METATYPE_VIDEO_DIMENSIONS=216, EXTRACTOR_METATYPE_VIDEO_DEPTH=217, EXTRACTOR_METATYPE_FRAME_RATE=218, EXTRACTOR_METATYPE_PIXEL_ASPECT_RATIO=219, EXTRACTOR_METATYPE_VIDEO_BITRATE=220, EXTRACTOR_METATYPE_MAXIMUM_VIDEO_BITRATE=221, EXTRACTOR_METATYPE_SUBTITLE_LANGUAGE=222, EXTRACTOR_METATYPE_VIDEO_LANGUAGE=223, EXTRACTOR_METATYPE_TOC=224, EXTRACTOR_METATYPE_VIDEO_DURATION=225, EXTRACTOR_METATYPE_AUDIO_DURATION=226, EXTRACTOR_METATYPE_SUBTITLE_DURATION=227, EXTRACTOR_METATYPE_AUDIO_PREVIEW=228, EXTRACTOR_METATYPE_LAST=229 };

// tag-EXTRACTOR_Options
// file /usr/include/extractor.h line 46
enum EXTRACTOR_Options { EXTRACTOR_OPTION_DEFAULT_POLICY=0, EXTRACTOR_OPTION_OUT_OF_PROCESS_NO_RESTART=1, EXTRACTOR_OPTION_IN_PROCESS=2, EXTRACTOR_OPTION_DISABLED=3 };

// tag-EXTRACTOR_PluginList
// file /usr/include/extractor.h line 531
struct EXTRACTOR_PluginList;

// tag-EXTRACT_Process
// file helper2.h line 99
struct EXTRACT_Process;

// tag-FAMCodes
// file /usr/include/fam.h line 88
enum FAMCodes { FAMChanged=1, FAMDeleted=2, FAMStartExecuting=3, FAMStopExecuting=4, FAMCreated=5, FAMMoved=6, FAMAcknowledge=7, FAMExists=8, FAMEndExist=9 };

// tag-FAMConnection
// file /usr/include/fam.h line 44
struct FAMConnection;

// tag-FAMEvent
// file /usr/include/fam.h line 100
struct FAMEvent;

// tag-FAMRequest
// file /usr/include/fam.h line 67
struct FAMRequest;

// tag-KeywordList
// file index.c line 290
struct KeywordList;

// tag-Mutex
// file semaphore.h line 53
struct Mutex;

// tag-PTHREAD_T
// file semaphore.h line 43
struct PTHREAD_T;

// tag-Semaphore
// file semaphore.h line 60
struct Semaphore;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-option
// file ./getopt.h line 83
struct option;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

#ifndef NULL
#define NULL ((void*)0)
#endif

// DOODLE_getFileAt
// file doodle.h line 80
const struct anonymous * DOODLE_getFileAt(struct DOODLE_SuffixTree *tree, unsigned int index);
// DOODLE_getFileCount
// file doodle.h line 75
unsigned int DOODLE_getFileCount(struct DOODLE_SuffixTree *tree);
// DOODLE_tree_create
// file doodle.h line 89
struct DOODLE_SuffixTree * DOODLE_tree_create(void (*log)(void *, unsigned int, const char *, ...), void *context, const char *database);
// DOODLE_tree_create::log$object
// 
void log$object(void *, unsigned int, const char *, ...);
// DOODLE_tree_create_internal
// file tree.c line 1553
struct DOODLE_SuffixTree * DOODLE_tree_create_internal(void (*log)(void *, unsigned int, const char *, ...), void *context, const char *database, signed int flags);
// DOODLE_tree_create_internal::log$object
// 
void log$object(void *, unsigned int, const char *, ...);
// DOODLE_tree_destroy
// file doodle.h line 104
void DOODLE_tree_destroy(struct DOODLE_SuffixTree *tree);
// DOODLE_tree_dump
// file tree.c line 3362
signed int DOODLE_tree_dump(struct _IO_FILE *stream, struct DOODLE_SuffixTree *tree);
// DOODLE_tree_expand
// file tree.c line 2261
signed int DOODLE_tree_expand(struct DOODLE_SuffixTree *tree, const char *searchString, const char *fileName);
// DOODLE_tree_open_RDONLY
// file tree.c line 1864
struct DOODLE_SuffixTree * DOODLE_tree_open_RDONLY(void (*log)(void *, unsigned int, const char *, ...), void *context, const char *database);
// DOODLE_tree_open_RDONLY::log$object
// 
void log$object(void *, unsigned int, const char *, ...);
// DOODLE_tree_search
// file tree.c line 3150
signed int DOODLE_tree_search(struct DOODLE_SuffixTree *tree, const char *substring, void (*callback)(const struct anonymous *, void *), void *arg);
// DOODLE_tree_search::callback$object
// 
//void callback$object(const struct anonymous *, void *);
// DOODLE_tree_search_approx
// file tree.c line 3304
signed int DOODLE_tree_search_approx(struct DOODLE_SuffixTree *tree, const unsigned int approx, const signed int ignore_case, const char *ss, void (*callback)(const struct anonymous *, void *), void *arg);
// DOODLE_tree_search_approx::callback$object
// 
//void callback$object(const struct anonymous *, void *);
// DOODLE_tree_set_memory_limit
// file doodle.h line 195
void DOODLE_tree_set_memory_limit(struct DOODLE_SuffixTree *tree, unsigned long int limit);
// DOODLE_tree_truncate
// file tree.c line 2962
signed int DOODLE_tree_truncate(struct DOODLE_SuffixTree *tree, const char *fileName);
// DOODLE_tree_truncate_deleted
// file tree.c line 2975
void DOODLE_tree_truncate_deleted(struct DOODLE_SuffixTree *tree, void (*log)(void *, unsigned int, const char *, ...), void *logContext);
// DOODLE_tree_truncate_deleted::log$object
// 
void log$object(void *, unsigned int, const char *, ...);
// DOODLE_tree_truncate_modified
// file tree.c line 3036
void DOODLE_tree_truncate_modified(struct DOODLE_SuffixTree *tree, void (*log)(void *, unsigned int, const char *, ...), void *logContext);
// DOODLE_tree_truncate_modified::log$object
// 
void log$object(void *, unsigned int, const char *, ...);
// DOODLE_tree_truncate_multiple
// file doodle.h line 124
signed int DOODLE_tree_truncate_multiple(struct DOODLE_SuffixTree *tree, const char **fileNames);
// EXTRACTOR_extract
// file /usr/include/extractor.h line 629
void EXTRACTOR_extract(struct EXTRACTOR_PluginList *, const char *, const void *, unsigned long int, signed int (*)(void *, const char *, enum EXTRACTOR_MetaType, enum EXTRACTOR_MetaFormat, const char *, const char *, unsigned long int), void *);
// EXTRACTOR_plugin_add_config
// file /usr/include/extractor.h line 591
struct EXTRACTOR_PluginList * EXTRACTOR_plugin_add_config(struct EXTRACTOR_PluginList *, const char *, enum EXTRACTOR_Options);
// EXTRACTOR_plugin_add_defaults
// file /usr/include/extractor.h line 556
struct EXTRACTOR_PluginList * EXTRACTOR_plugin_add_defaults(enum EXTRACTOR_Options);
// EXTRACTOR_plugin_remove_all
// file /usr/include/extractor.h line 614
void EXTRACTOR_plugin_remove_all(struct EXTRACTOR_PluginList *);
// FAMCancelMonitor
// file /usr/include/fam.h line 167
extern signed int FAMCancelMonitor(struct FAMConnection *, const struct FAMRequest *);
// FAMClose
// file /usr/include/fam.h line 115
extern signed int FAMClose(struct FAMConnection *);
// FAMMonitorDirectory
// file /usr/include/fam.h line 123
extern signed int FAMMonitorDirectory(struct FAMConnection *, const char *, struct FAMRequest *, void *);
// FAMNextEvent
// file /usr/include/fam.h line 180
extern signed int FAMNextEvent(struct FAMConnection *, struct FAMEvent *);
// FAMOpen2
// file /usr/include/fam.h line 114
extern signed int FAMOpen2(struct FAMConnection *, const char *);
// FAMPending
// file /usr/include/fam.h line 182
extern signed int FAMPending(struct FAMConnection *);
// IO_FREE
// file tree.c line 398
static void IO_FREE(struct anonymous$0 *bio);
// IO_WRAP
// file tree.c line 232
static struct anonymous$0 * IO_WRAP(void (*log)(void *, unsigned int, const char *, ...), void *context, signed int fd);
// IO_WRAP::log$object
// 
void log$object(void *, unsigned int, const char *, ...);
// LSEEK
// file tree.c line 380
static unsigned long long int LSEEK(struct anonymous$0 *bio, unsigned long long int off, signed int whence);
// MALLOC
// file helper1.h line 39
void * MALLOC(unsigned long int size);
// PTHREAD_CREATE
// file semaphore.h line 147
signed int PTHREAD_CREATE(struct PTHREAD_T *pt, void * (*main)(void *), void *arg, unsigned long int stackSize);
// PTHREAD_CREATE::main$object
// 
void * main$object(void *);
// PTHREAD_DETACH
// file semaphore.c line 431
void PTHREAD_DETACH(struct PTHREAD_T *pt);
// PTHREAD_GET_SELF
// file semaphore.c line 353
void PTHREAD_GET_SELF(struct PTHREAD_T *pt);
// PTHREAD_JOIN
// file semaphore.h line 152
void PTHREAD_JOIN(struct PTHREAD_T *pt, void **ret);
// PTHREAD_KILL
// file semaphore.h line 155
void PTHREAD_KILL(struct PTHREAD_T *pt, signed int signal);
// PTHREAD_REL_SELF
// file semaphore.c line 361
void PTHREAD_REL_SELF(struct PTHREAD_T *pt);
// PTHREAD_SELF_TEST
// file semaphore.c line 334
signed int PTHREAD_SELF_TEST(struct PTHREAD_T *pt);
// READALL
// file tree.c line 295
static signed int READALL(struct anonymous$0 *bio, void *buf, unsigned long long int len);
// READUINT
// file tree.c line 405
static signed int READUINT(struct anonymous$0 *fd, unsigned int *val);
// READUINTPAIR
// file tree.c line 461
static signed int READUINTPAIR(struct anonymous$0 *fd, unsigned int *val1, unsigned int *val2);
// READULONG
// file tree.c line 427
static signed int READULONG(struct anonymous$0 *fd, unsigned long long int *val);
// READULONGFULL
// file tree.c line 449
static signed int READULONGFULL(struct anonymous$0 *fd, unsigned long long int *val);
// READULONGPAIR
// file tree.c line 490
static signed int READULONGPAIR(struct anonymous$0 *fd, unsigned long long int *val1, unsigned long long int *val2);
// STRDUP
// file helper1.h line 41
char * STRDUP(const char *str);
// WRITEALL
// file tree.c line 340
static void WRITEALL(struct anonymous$0 *bio, const void *buf, unsigned long long int len);
// WRITEUINT
// file tree.c line 577
static void WRITEUINT(struct anonymous$0 *fd, unsigned int val);
// WRITEUINTPAIR
// file tree.c line 519
static void WRITEUINTPAIR(struct anonymous$0 *fd, unsigned int val1, unsigned int val2);
// WRITEULONG
// file tree.c line 596
static void WRITEULONG(struct anonymous$0 *fd, unsigned long long int val);
// WRITEULONGFULL
// file tree.c line 615
static void WRITEULONGFULL(struct anonymous$0 *fd, unsigned long long int val);
// WRITEULONGPAIR
// file tree.c line 548
static void WRITEULONGPAIR(struct anonymous$0 *fd, unsigned long long int val1, unsigned long long int val2);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accumulator
// file index.c line 130
static signed int accumulator(void *cls, const char *plugin_name, enum EXTRACTOR_MetaType type, enum EXTRACTOR_MetaFormat format, const char *data_mime_type, const char *data, unsigned long int data_len);
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// build
// file doodled.c line 561
static signed int build(const char *libraries, const char *dbName, unsigned long int mem_limit, const char *log, signed int argc, char **argv);
// buildIndex
// file helper2.h line 114
signed int buildIndex(struct EXTRACT_Process *eproc, struct _IO_FILE *logFile, const char *filename, struct DOODLE_SuffixTree *tree, signed int do_filenames);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// create_mutex_
// file semaphore.h line 165
void create_mutex_(struct Mutex *mutex);
// create_recursive_mutex_
// file semaphore.c line 153
void create_recursive_mutex_(struct Mutex *mutex);
// destroy_mutex_
// file semaphore.h line 168
void destroy_mutex_(struct Mutex *mutex);
// detachFromTerminal
// file doodled.c line 719
static void detachFromTerminal(signed int *filedes);
// detachFromTerminalComplete
// file doodled.c line 777
static void detachFromTerminalComplete(signed int *filedes);
// do_fork
// file index.c line 159
static signed int do_fork(struct EXTRACT_Process *proc);
// do_index
// file doodled.c line 280
static signed int do_index(const char *filename, struct anonymous$17 *dic);
// do_read
// file index.c line 91
static signed int do_read(signed int fd, void *d, unsigned long int len);
// doneShutdownHandlers
// file shutdown.h line 54
void doneShutdownHandlers();
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// expandFileName
// file helper2.h line 70
char * expandFileName(const char *fil);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fdatasync
// file /usr/include/unistd.h line 1112
extern signed int fdatasync(signed int);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// flock
// file /usr/include/x86_64-linux-gnu/sys/file.h line 51
extern signed int flock(signed int, signed int);
// flush_buffer
// file tree.c line 257
static void flush_buffer(struct anonymous$0 *bio);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// forkExtractor
// file helper2.h line 101
struct EXTRACT_Process * forkExtractor(signed int do_default, const char *libraries, void (*logger)(void *, unsigned int, const char *, ...), void *log_ct);
// forkExtractor::logger$object
// 
void logger$object(void *, unsigned int, const char *, ...);
// formatHelp
// file helper2.h line 55
void formatHelp(const char *general, const char *description, const struct anonymous$1 *opt);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeKeywords
// file index.c line 301
static void freeKeywords(struct KeywordList *keywords);
// freeNode
// file tree.c line 877
static void freeNode(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *node);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// getKeywords
// file index.c line 316
static struct KeywordList * getKeywords(struct EXTRACT_Process *eproc, const char *filename);
// getcwd
// file /usr/include/unistd.h line 511
extern char * getcwd(char *, unsigned long int);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file ./getopt.h line 112
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// gettext
// file /usr/include/libintl.h line 39
extern char * gettext(const char *);
// initializeShutdownHandlers
// file shutdown.h line 47
void initializeShutdownHandlers();
// isPruned
// file doodled.c line 96
static signed int isPruned(const char *filename);
// joinExtractor
// file helper2.h line 106
void joinExtractor(struct EXTRACT_Process *proc);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// lazyReadNode
// file tree.c line 1094
static struct DOODLE_Node * lazyReadNode(struct DOODLE_SuffixTree *tree, unsigned long long int off);
// loadChild
// file tree.c line 1286
static signed int loadChild(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *node);
// loadLink
// file tree.c line 1310
static signed int loadLink(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *node);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 262
extern signed int lstat(const char *, struct stat *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// markModified
// file tree.c line 2054
static void markModified(struct DOODLE_Node *pos);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mutex_lock_
// file semaphore.h line 169
void mutex_lock_(struct Mutex *mutex, const char *filename, const signed int line);
// mutex_unlock_
// file semaphore.h line 172
void mutex_unlock_(struct Mutex *mutex, const char *filename, const signed int line);
// my_log
// file doodled.c line 119
static void my_log(void *ctx, unsigned int level, const char *msg, ...);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// printHelp
// file doodled.c line 58
static void printHelp();
// print_internal
// file tree.c line 3320
static signed int print_internal(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *node, struct _IO_FILE *stream, signed int ident);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// processEvents
// file doodled.c line 175
static void * processEvents(void *arg);
// processShrink
// file tree.c line 914
static void processShrink(struct DOODLE_SuffixTree *tree, struct DOODLE_Node **keepThese, signed int ktC, signed int ktP, struct DOODLE_Node *pos, unsigned int *kept);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 377
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$3 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$3 *, const union anonymous$4 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$3 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$3 *, union anonymous$5 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$5 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$5 *, const union anonymous$4 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$5 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$5 *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 808
extern signed int pthread_mutexattr_init(union anonymous$4 *);
// pthread_mutexattr_setkind_np
// file semaphore.c line 126
extern signed int pthread_mutexattr_setkind_np(union anonymous$4 *, signed int);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readFN
// file tree.c line 649
static char * readFN(struct anonymous$0 *fd, char * const *pathTab, const unsigned int ptc);
// readZT
// file tree.c line 625
static char * readZT(struct anonymous$0 *fd);
// read_buf
// file tree.c line 171
static signed int read_buf(void (*log)(void *, unsigned int, const char *, ...), void *context, signed int fd, unsigned long long int off, char *buf, unsigned long long int cnt);
// read_buf::log$object
// 
void log$object(void *, unsigned int, const char *, ...);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// retarget_buffer
// file tree.c line 269
static signed int retarget_buffer(struct anonymous$0 *bio, unsigned long long int off, unsigned long long int len);
// run_shutdown
// file shutdown.h line 36
void run_shutdown(signed int signum);
// scanDirectory
// file files.c line 54
signed int scanDirectory(char *dirName, void (*logger)(void *, unsigned int, const char *, ...), void *context, signed int (*pruner)(const char *, void *), void *pr_arg, signed int (*callback)(const char *, void *), void *cb_arg);
// scanDirectory::callback$object
// 
signed int callback$object(const char *, void *);
// scanDirectory::logger$object
// 
void logger$object(void *, unsigned int, const char *, ...);
// scanDirectory::pruner$object
// 
signed int pruner$object(const char *, void *);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$18 *, struct anonymous$18 *, struct anonymous$18 *, struct timeval *);
// semaphore_down_
// file semaphore.h line 181
signed int semaphore_down_(struct Semaphore *s, const char *filename, const signed int linenumber);
// semaphore_down_nonblocking_
// file semaphore.c line 318
signed int semaphore_down_nonblocking_(struct Semaphore *s, const char *filename, const signed int linenumber);
// semaphore_free_
// file semaphore.h line 178
void semaphore_free_(struct Semaphore *s, const char *filename, const signed int linenumber);
// semaphore_new_
// file semaphore.h line 175
struct Semaphore * semaphore_new_(signed int value, const char *filename, const signed int linenumber);
// semaphore_up_
// file semaphore.h line 187
signed int semaphore_up_(struct Semaphore *s, const char *filename, const signed int linenumber);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// shrinkMemoryFootprint
// file tree.c line 1027
static void shrinkMemoryFootprint(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *keep);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$6 *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// testShutdown
// file shutdown.h line 42
signed int testShutdown();
// textdomain
// file /usr/include/libintl.h line 82
extern char * textdomain(const char *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// tree_iterate_internal
// file tree.c line 3104
static signed int tree_iterate_internal(signed int do_links, struct DOODLE_SuffixTree *tree, struct DOODLE_Node *node, void (*callback)(const struct anonymous *, void *), void *arg);
// tree_iterate_internal::callback$object
// 
//void callback$object(const struct anonymous *, void *);
// tree_normalize
// file tree.c line 2071
static void tree_normalize(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *pos);
// tree_search_approx_internal
// file tree.c line 3175
static signed int tree_search_approx_internal(struct DOODLE_Node *pos, const unsigned int approx, const signed int ignore_case, struct DOODLE_SuffixTree *tree, const char *ss, void (*callback)(const struct anonymous *, void *), void *arg);
// tree_search_approx_internal::callback$object
// 
//void callback$object(const struct anonymous *, void *);
// tree_search_internal
// file tree.c line 2180
static struct DOODLE_Node * tree_search_internal(struct DOODLE_SuffixTree *tree, const char *substring);
// tree_split
// file tree.c line 2128
static void tree_split(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *pos, unsigned int at);
// truncate_internal
// file tree.c line 2812
static signed int truncate_internal(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *node, unsigned int *fileNameIndex, signed int max);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// wait_for_shutdown
// file shutdown.h line 52
void wait_for_shutdown();
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// worker
// file doodled.c line 442
static void * worker(void *arg);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// writeFN
// file tree.c line 684
static void writeFN(struct anonymous$0 *fd, char * const *pathTab, const unsigned int ptc, const char *fn);
// writeNode
// file tree.c line 1337
static unsigned long long int writeNode(struct anonymous$0 *fd, struct DOODLE_SuffixTree *tree, struct DOODLE_Node *node);
// writeZT
// file tree.c line 640
static void writeZT(struct anonymous$0 *fd, const char *buf);
// write_buf
// file tree.c line 202
static void write_buf(void (*log)(void *, unsigned int, const char *, ...), void *context, signed int fd, unsigned long long int off, const void *buf, unsigned long long int cnt);
// write_buf::log$object
// 
void log$object(void *, unsigned int, const char *, ...);
// xgrow_
// file helper1.h line 43
void xgrow_(void **old, unsigned long int elementSize, unsigned int *oldCount, unsigned int newCount, const char *filename, const signed int linenumber);

struct anonymous
{
  // filename
  char *filename;
  // mod_time
  unsigned int mod_time;
};

struct FAMConnection
{
  // fd
  signed int fd;
  // client
  void *client;
};

struct Mutex
{
  // internal
  void *internal;
};

struct anonymous$17
{
  // elist
  struct EXTRACT_Process *elist;
  // tree
  struct DOODLE_SuffixTree *tree;
  // fc
  struct FAMConnection fc;
  // fr
  struct FAMRequest *fr;
  // frNames
  char **frNames;
  // frPos
  unsigned int frPos;
  // frSize
  unsigned int frSize;
  // log
  void (*log)(void *, unsigned int, const char *, ...);
  // logContext
  void *logContext;
  // ename
  char *ename;
  // treePresent
  unsigned int treePresent;
  // argc
  unsigned int argc;
  // argv
  char **argv;
  // lock
  struct Mutex lock;
  // eventCount
  unsigned int eventCount;
  // events
  char **events;
  // continueRunning
  signed int continueRunning;
  // deferredCount
  unsigned int deferredCount;
  // deferredTruncations
  char **deferredTruncations;
  // signal
  struct Semaphore *signal;
};

struct anonymous$0
{
  // log
  void (*log)(void *, unsigned int, const char *, ...);
  // context
  void *context;
  // fd
  signed int fd;
  // off
  unsigned long long int off;
  // fsize
  unsigned long long int fsize;
  // bstart
  unsigned long long int bstart;
  // bsize
  unsigned long long int bsize;
  // buffer
  char *buffer;
  // dirty
  unsigned long long int dirty;
};

struct anonymous$16
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$14
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$18
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$6
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$2
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$10
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$13
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$12
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$11
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$15
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$7
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$10 _kill;
  // _timer
  struct anonymous$11 _timer;
  // _rt
  struct anonymous$12 _rt;
  // _sigchld
  struct anonymous$13 _sigchld;
  // _sigfault
  struct anonymous$14 _sigfault;
  // _sigpoll
  struct anonymous$15 _sigpoll;
  // _sigsys
  struct anonymous$16 _sigsys;
};

struct anonymous$8
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$7 _sifields;
};

struct anonymous$1
{
  // shortArg
  char shortArg;
  // longArg
  char *longArg;
  // mandatoryArg
  char *mandatoryArg;
  // description
  char *description;
};

union anonymous$9
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$8 *, void *);
};

union anonymous$4
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$3
{
  // __data
  struct anonymous$2 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$5
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct AccuCtx
{
  // count
  unsigned int count;
  // size
  unsigned int size;
  // types
  enum EXTRACTOR_MetaType *types;
  // keywords
  char **keywords;
};

struct DOODLE_Node
{
  // link_off
  unsigned long long int link_off;
  // next_off
  unsigned long long int next_off;
  // pos
  unsigned long long int pos;
  // link
  struct DOODLE_Node *link;
  // child
  struct DOODLE_Node *child;
  // parent
  struct DOODLE_Node *parent;
  // c
  char *c;
  // matches
  unsigned int *matches;
  // matchCount
  unsigned int matchCount;
  // cix
  signed int cix;
  // useCounter
  unsigned int useCounter;
  // clength
  unsigned char clength;
  // mls_size
  unsigned char mls_size;
  // modified
  unsigned char modified;
};

struct DOODLE_SuffixTree
{
  // log
  void (*log)(void *, unsigned int, const char *, ...);
  // context
  void *context;
  // database
  char *database;
  // fd
  struct anonymous$0 *fd;
  // fns
  unsigned int fns;
  // fnc
  unsigned int fnc;
  // filenames
  struct anonymous *filenames;
  // root
  struct DOODLE_Node *root;
  // cis
  char **cis;
  // cisPos
  unsigned int cisPos;
  // cisLen
  unsigned int cisLen;
  // modified
  signed int modified;
  // force_dump
  signed int force_dump;
  // used_memory
  unsigned long int used_memory;
  // memory_limit
  unsigned long int memory_limit;
  // swapLimit
  unsigned int swapLimit;
  // mutationCount
  unsigned int mutationCount;
  // read_only
  signed int read_only;
};

struct EXTRACT_Process
{
  // libs
  char *libs;
  // log_ctx
  void *log_ctx;
  // send_pipe
  signed int send_pipe;
  // read_pipe
  signed int read_pipe;
  // pid
  signed int pid;
  // do_default
  signed int do_default;
  // my_log
  void (*my_log)(void *, unsigned int, const char *, ...);
};

struct FAMRequest
{
  // reqnum
  signed int reqnum;
};

struct FAMEvent
{
  // fc
  struct FAMConnection *fc;
  // fr
  struct FAMRequest fr;
  // hostname
  char *hostname;
  // filename
  char filename[4096l];
  // userdata
  void *userdata;
  // code
  enum FAMCodes code;
};

struct KeywordList
{
  // keyword
  char *keyword;
  // keywordType
  enum EXTRACTOR_MetaType keywordType;
  // next
  struct KeywordList *next;
};

struct PTHREAD_T
{
  // internal
  void *internal;
};

struct Semaphore
{
  // v
  signed int v;
  // mutex
  struct Mutex mutex;
  // cond
  void *cond;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$9 __sigaction_handler;
  // sa_mask
  struct anonymous$6 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};


// CIS
// file tree.c line 814
static char CIS[256l] = { (char)0, (char)1, (char)2, (char)3, (char)4, (char)5, (char)6, (char)7, (char)8, (char)9, (char)10, (char)11, (char)12, (char)13, (char)14, (char)15, (char)16, (char)17, (char)18, (char)19, (char)20, (char)21, (char)22, (char)23, (char)24, (char)25, (char)26, (char)27, (char)28, (char)29, (char)30, (char)31, (char)32, (char)33, (char)34, (char)35, (char)36, (char)37, (char)38, (char)39, (char)40, (char)41, (char)42, (char)43, (char)44, (char)45, (char)46, (char)47, (char)48, (char)49, (char)50, (char)51, (char)52, (char)53, (char)54, (char)55, (char)56, (char)57, (char)58, (char)59, (char)60, (char)61, (char)62, (char)63, (char)64, (char)65, (char)66, (char)67, (char)68, (char)69, (char)70, (char)71, (char)72, (char)73, (char)74, (char)75, (char)76, (char)77, (char)78, (char)79, (char)80, (char)81, (char)82, (char)83, (char)84, (char)85, (char)86, (char)87, (char)88, (char)89, (char)90, (char)91, (char)92, (char)93, (char)94, (char)95, (char)96, (char)97, (char)98, (char)99, (char)100, (char)101, (char)102, (char)103, (char)104, (char)105, (char)106, (char)107, (char)108, (char)109, (char)110, (char)111, (char)112, (char)113, (char)114, (char)115, (char)116, (char)117, (char)118, (char)119, (char)120, (char)121, (char)122, (char)123, (char)124, (char)125, (char)126, (char)127, (char)128, (char)129, (char)130, (char)131, (char)132, (char)133, (char)134, (char)135, (char)136, (char)137, (char)138, (char)139, (char)140, (char)141, (char)142, (char)143, (char)144, (char)145, (char)146, (char)147, (char)148, (char)149, (char)150, (char)151, (char)152, (char)153, (char)154, (char)155, (char)156, (char)157, (char)158, (char)159, (char)160, (char)161, (char)162, (char)163, (char)164, (char)165, (char)166, (char)167, (char)168, (char)169, (char)170, (char)171, (char)172, (char)173, (char)174, (char)175, (char)176, (char)177, (char)178, (char)179, (char)180, (char)181, (char)182, (char)183, (char)184, (char)185, (char)186, (char)187, (char)188, (char)189, (char)190, (char)191, (char)192, (char)193, (char)194, (char)195, (char)196, (char)197, (char)198, (char)199, (char)200, (char)201, (char)202, (char)203, (char)204, (char)205, (char)206, (char)207, (char)208, (char)209, (char)210, (char)211, (char)212, (char)213, (char)214, (char)215, (char)216, (char)217, (char)218, (char)219, (char)220, (char)221, (char)222, (char)223, (char)224, (char)225, (char)226, (char)227, (char)228, (char)229, (char)230, (char)231, (char)232, (char)233, (char)234, (char)235, (char)236, (char)237, (char)238, (char)239, (char)240, (char)241, (char)242, (char)243, (char)244, (char)245, (char)246, (char)247, (char)248, (char)249, (char)250, (char)251, (char)252, (char)253, (char)254, (char)255 };
// FAMErrno
// file /usr/include/fam.h line 190
extern signed int FAMErrno;
// FamErrlist
// file /usr/include/fam.h line 224
extern const char *FamErrlist[];
// MAGIC
// file tree.c line 1541
static char *MAGIC = "DOO\a";
// TRAGIC
// file tree.c line 1548
static char *TRAGIC = "XOO\001";
// do_debug
// file doodled.c line 89
static signed int do_debug = 0;
// do_default
// file doodled.c line 90
static signed int do_default = 1;
// do_filenames
// file doodled.c line 91
static signed int do_filenames = 0;
// optarg
// file ./getopt.h line 37
extern char *optarg;
// optind
// file ./getopt.h line 51
extern signed int optind;
// prunepaths
// file doodled.c line 92
static char *prunepaths = "/tmp /usr/tmp /var/tmp /dev /proc /sys";
// shutdown_active
// file shutdown.c line 40
static signed int shutdown_active;
// shutdown_signal
// file shutdown.c line 39
static struct Semaphore *shutdown_signal = (struct Semaphore *)(void *)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// verbose
// file doodled.c line 52
static signed int verbose = 0;
// very_verbose
// file doodled.c line 53
static signed int very_verbose = 0;

// DOODLE_getFileAt
// file doodle.h line 80
const struct anonymous * DOODLE_getFileAt(struct DOODLE_SuffixTree *tree, unsigned int index)
{
  return &tree->filenames[(signed long int)index];
}

// DOODLE_getFileCount
// file doodle.h line 75
unsigned int DOODLE_getFileCount(struct DOODLE_SuffixTree *tree)
{
  return tree->fnc;
}

// DOODLE_tree_create
// file doodle.h line 89
struct DOODLE_SuffixTree * DOODLE_tree_create(void (*log)(void *, unsigned int, const char *, ...), void *context, const char *database)
{
  struct DOODLE_SuffixTree *return_value_DOODLE_tree_create_internal$1;
  return_value_DOODLE_tree_create_internal$1=DOODLE_tree_create_internal(log, context, database, 02);
  return return_value_DOODLE_tree_create_internal$1;
}

// DOODLE_tree_create_internal
// file tree.c line 1553
struct DOODLE_SuffixTree * DOODLE_tree_create_internal(void (*log)(void *, unsigned int, const char *, ...), void *context, const char *database, signed int flags)
{
  signed int ifd;
  struct anonymous$0 *fd;
  struct DOODLE_SuffixTree *ret;
  struct stat buf;
  signed int i;
  unsigned long long int off;
  char **pathTab;
  unsigned int ptc;
  signed char magic[8l];
  void *return_value_MALLOC$1;
  return_value_MALLOC$1=MALLOC(sizeof(struct DOODLE_SuffixTree) /*112ul*/ );
  ret = (struct DOODLE_SuffixTree *)return_value_MALLOC$1;
  ret->log = log;
  ret->context = context;
  ret->database=STRDUP(database);
  ret->modified = 0;
  ret->used_memory = (unsigned long int)0;
  ret->memory_limit = (unsigned long int)(8 * 1024 * 1024);
  ret->swapLimit = (unsigned int)65536;
  ret->mutationCount = (unsigned int)0;
  ret->force_dump = 0;
  ret->read_only = (signed int)(flags == 00);
  signed int return_value_stat$34;
  return_value_stat$34=stat(database, &buf);
  char *return_value_gettext$11;
  signed int *return_value___errno_location$12;
  char *return_value_strerror$13;
  void *return_value_MALLOC$24;
  if(return_value_stat$34 == 0)
  {
    ifd=open(database, flags | 0, 0400 | 0200 | 0400 >> 3);
    if(ifd == -1)
    {
      char *return_value_gettext$2;
      return_value_gettext$2=gettext("Could not open '%s': %s\n");
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      log(context, (unsigned int)0, return_value_gettext$2, database, return_value_strerror$4);
      free((void *)ret->database);
      free((void *)ret);
      return (struct DOODLE_SuffixTree *)(void *)0;
    }

    signed int return_value_flock$8;
    return_value_flock$8=flock(ifd, flags == 02 ? 2 : 1);
    if(!(return_value_flock$8 == 0))
    {
      char *return_value_gettext$5;
      return_value_gettext$5=gettext("Could not lock database '%s': %s\n");
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      log(context, (unsigned int)0, return_value_gettext$5, database, return_value_strerror$7);
      free((void *)ret->database);
      free((void *)ret);
      return (struct DOODLE_SuffixTree *)(void *)0;
    }

    fd=IO_WRAP(log, context, ifd);
    signed int return_value_READALL$9;
    return_value_READALL$9=READALL(fd, (void *)magic, (unsigned long long int)8);
    if(return_value_READALL$9 == -1)
      memcpy((void *)magic, (const void *)"garbage!", (unsigned long int)8);

    signed int return_value_memcmp$17;
    return_value_memcmp$17=memcmp((const void *)magic, (const void *)MAGIC, (unsigned long int)8);
    if(!(return_value_memcmp$17 == 0))
    {
      signed int return_value_memcmp$16;
      return_value_memcmp$16=memcmp((const void *)magic, (const void *)TRAGIC, (unsigned long int)8);
      if(return_value_memcmp$16 == 0)
      {
        char *return_value_gettext$10;
        return_value_gettext$10=gettext("Database file '%s' is from incomplete database build.  I will remove it and rebuild the database.\n");
        log(context, (unsigned int)0, return_value_gettext$10, database);
        IO_FREE(fd);
        signed int return_value_unlink$14;
        return_value_unlink$14=unlink(database);
        if(!(return_value_unlink$14 == 0))
        {
          return_value_gettext$11=gettext("Could not unlink '%s': %s\n");
          return_value___errno_location$12=__errno_location();
          return_value_strerror$13=strerror(*return_value___errno_location$12);
          log(context, (unsigned int)0, return_value_gettext$11, database, return_value_strerror$13);
        }

        fd = (struct anonymous$0 *)(void *)0;
      }

      else
      {
        char *return_value_gettext$15;
        return_value_gettext$15=gettext("Database file '%s' has wrong magic code.\n");
        log(context, (unsigned int)0, return_value_gettext$15, database);
        IO_FREE(fd);
        free((void *)ret->database);
        free((void *)ret);
        return (struct DOODLE_SuffixTree *)(void *)0;
      }
    }

    signed int return_value_READUINT$18;
    return_value_READUINT$18=READUINT(fd, &ptc);
    if(return_value_READUINT$18 == -1)
    {
      free((void *)ret->database);
      free((void *)ret);
      IO_FREE(fd);
      return (struct DOODLE_SuffixTree *)(void *)0;
    }

    if(!(ptc == 0u))
    {
      void *return_value_MALLOC$19;
      return_value_MALLOC$19=MALLOC((unsigned long int)ptc * sizeof(char *) /*8ul*/ );
      pathTab = (char **)return_value_MALLOC$19;
      i = (signed int)(ptc - (unsigned int)1);
      for( ; i >= 0; i = i - 1)
      {
        pathTab[(signed long int)i]=readZT(fd);
        if(pathTab[(signed long int)i] == ((char *)NULL))
        {
          while(!((unsigned int)i >= ptc + 4294967295u))
          {
            i = i + 1;
            free((void *)pathTab[(signed long int)i]);
          }
          free((void *)pathTab);
          free((void *)ret->database);
          free((void *)ret);
          IO_FREE(fd);
          return (struct DOODLE_SuffixTree *)(void *)0;
        }

      }
    }

    else
      pathTab = (char **)(void *)0;
    ret->fns = (unsigned int)0;
    ret->filenames = (struct anonymous *)(void *)0;
    signed int return_value_READUINT$20;
    return_value_READUINT$20=READUINT(fd, &ret->fnc);
    if(return_value_READUINT$20 == -1)
    {
      i = (signed int)(ptc - (unsigned int)1);
      for( ; i >= 0; i = i - 1)
        free((void *)pathTab[(signed long int)i]);
      free((void *)ret->database);
      free((void *)ret);
      IO_FREE(fd);
      return (struct DOODLE_SuffixTree *)(void *)0;
    }

    if(!(ret->fnc == 0u))
    {
      xgrow_((void **)&ret->filenames, sizeof(struct anonymous) /*16ul*/ , &ret->fns, ret->fnc, "tree.c", 1689);
      i = (signed int)(ret->fnc - (unsigned int)1);
      for( ; i >= 0; i = i - 1)
      {
        (ret->filenames + (signed long int)i)->filename=readFN(fd, pathTab, ptc);
        if((ret->filenames + (signed long int)i)->filename == ((char *)NULL))
        {
          while(!((unsigned int)i >= ret->fnc + 4294967295u))
          {
            i = i + 1;
            free((void *)(ret->filenames + (signed long int)i)->filename);
          }
          xgrow_((void **)&ret->filenames, sizeof(struct anonymous) /*16ul*/ , &ret->fns, (unsigned int)0, "tree.c", 1699);
          i = (signed int)(ptc - (unsigned int)1);
          for( ; i >= 0; i = i - 1)
            free((void *)pathTab[(signed long int)i]);
          free((void *)pathTab);
          free((void *)ret->database);
          free((void *)ret);
          IO_FREE(fd);
          char *return_value_gettext$21;
          return_value_gettext$21=gettext("Error reading database '%s' at %s.%d.\n");
          log(context, (unsigned int)0, return_value_gettext$21, database, (const void *)"tree.c", 1710);
          return (struct DOODLE_SuffixTree *)(void *)0;
        }

        signed int return_value_READUINT$22;
        return_value_READUINT$22=READUINT(fd, &(ret->filenames + (signed long int)i)->mod_time);
        if(return_value_READUINT$22 == -1)
        {
          while(!((unsigned int)i >= ret->fnc + 4294967295u))
          {
            i = i + 1;
            free((void *)(ret->filenames + (signed long int)i)->filename);
          }
          xgrow_((void **)&ret->filenames, sizeof(struct anonymous) /*16ul*/ , &ret->fns, (unsigned int)0, "tree.c", 1719);
          i = (signed int)(ptc - (unsigned int)1);
          for( ; i >= 0; i = i - 1)
            free((void *)pathTab[(signed long int)i]);
          free((void *)pathTab);
          free((void *)ret->database);
          free((void *)ret);
          IO_FREE(fd);
          return (struct DOODLE_SuffixTree *)(void *)0;
        }

      }
    }

    if(!(ptc == 0u))
    {
      i = (signed int)(ptc - (unsigned int)1);
      for( ; i >= 0; i = i - 1)
        free((void *)pathTab[(signed long int)i]);
      free((void *)pathTab);
    }

    signed int return_value_READUINT$23;
    return_value_READUINT$23=READUINT(fd, &ret->cisPos);
    if(return_value_READUINT$23 == -1)
    {
      xgrow_((void **)&ret->filenames, sizeof(struct anonymous) /*16ul*/ , &ret->fns, (unsigned int)0, "tree.c", 1739);
      free((void *)ret->database);
      free((void *)ret);
      IO_FREE(fd);
    }

    ret->cisLen = ret->cisPos;
    if(ret->cisLen >= 1u)
    {
      return_value_MALLOC$24=MALLOC((unsigned long int)ret->cisLen * sizeof(signed char *) /*8ul*/ );
      ret->cis = (char **)return_value_MALLOC$24;
    }

    else
      ret->cis = (char **)(void *)0;
    i = (signed int)(ret->cisPos - (unsigned int)1);
    for( ; i >= 0; i = i - 1)
    {
      ret->cis[(signed long int)i]=readZT(fd);
      if(ret->cis[(signed long int)i] == ((char *)NULL))
      {
        while(!((unsigned int)i >= ret->cisPos + 4294967295u))
        {
          i = i + 1;
          free((void *)ret->cis[(signed long int)i]);
        }
        free((void *)ret->cis);
        xgrow_((void **)&ret->filenames, sizeof(struct anonymous) /*16ul*/ , &ret->fns, (unsigned int)0, "tree.c", 1757);
        free((void *)ret->database);
        free((void *)ret);
        IO_FREE(fd);
        return (struct DOODLE_SuffixTree *)(void *)0;
      }

    }
    signed int return_value_READULONGFULL$25;
    return_value_READULONGFULL$25=READULONGFULL(fd, &off);
    if(return_value_READULONGFULL$25 == -1)
    {
      i = (signed int)(ret->cisPos - (unsigned int)1);
      for( ; i >= 0; i = i - 1)
      {
        i = i + 1;
        free((void *)ret->cis[(signed long int)i]);
      }
      free((void *)ret->cis);
      xgrow_((void **)&ret->filenames, sizeof(struct anonymous) /*16ul*/ , &ret->fns, (unsigned int)0, "tree.c", 1770);
      free((void *)ret->database);
      free((void *)ret);
      IO_FREE(fd);
      return (struct DOODLE_SuffixTree *)(void *)0;
    }

    ret->fd = fd;
    ret->root=lazyReadNode(ret, off);
  }

  else
  {

  FRESH_START:
    ;
    if(flags == 00)
    {
      char *return_value_gettext$26;
      return_value_gettext$26=gettext("Database '%s' does not exist.\n");
      log(context, (unsigned int)0, return_value_gettext$26, database);
      free((void *)ret->database);
      free((void *)ret);
      return (struct DOODLE_SuffixTree *)(void *)0;
    }

    ifd=open(database, 0100 | flags | 0, 0400 | 0200 | 0400 >> 3);
    if(ifd == -1)
    {
      char *return_value_gettext$27;
      return_value_gettext$27=gettext("Error creating database '%s' at %s:%d: %s\n");
      signed int *return_value___errno_location$28;
      return_value___errno_location$28=__errno_location();
      char *return_value_strerror$29;
      return_value_strerror$29=strerror(*return_value___errno_location$28);
      log(context, (unsigned int)0, return_value_gettext$27, database, (const void *)"tree.c", 1803, return_value_strerror$29);
      free((void *)ret->database);
      free((void *)ret);
      return (struct DOODLE_SuffixTree *)(void *)0;
    }

    signed int return_value_flock$33;
    return_value_flock$33=flock(ifd, flags == 02 ? 2 : 1);
    if(!(return_value_flock$33 == 0))
    {
      char *return_value_gettext$30;
      return_value_gettext$30=gettext("Could not lock database '%s': %s\n");
      signed int *return_value___errno_location$31;
      return_value___errno_location$31=__errno_location();
      char *return_value_strerror$32;
      return_value_strerror$32=strerror(*return_value___errno_location$31);
      log(context, (unsigned int)0, return_value_gettext$30, database, return_value_strerror$32);
      free((void *)ret->database);
      free((void *)ret);
      return (struct DOODLE_SuffixTree *)(void *)0;
    }

    ret->root = (struct DOODLE_Node *)(void *)0;
    ret->fnc = (unsigned int)0;
    ret->fns = (unsigned int)0;
    ret->filenames = (struct anonymous *)(void *)0;
    ret->fd=IO_WRAP(log, context, ifd);
    ret->cis = (char **)(void *)0;
    ret->cisLen = (unsigned int)0;
    ret->cisPos = (unsigned int)0;
    WRITEALL(ret->fd, (const void *)TRAGIC, (unsigned long long int)8);
    flush_buffer(ret->fd);
    fdatasync(ret->fd->fd);
    ret->modified = 1;
  }
  while((_Bool)0)
    ;
  return ret;
}

// DOODLE_tree_destroy
// file doodle.h line 104
void DOODLE_tree_destroy(struct DOODLE_SuffixTree *tree)
{
  struct anonymous$0 *fd;
  signed int i;
  signed int j;
  unsigned long long int off;
  signed long int wpos;
  char **pathTab;
  unsigned int ptc;
  struct DOODLE_Node *tmp;
  while((_Bool)0)
    ;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$20;
  signed int return_value_strncmp$9;
  unsigned long int return_value_strlen$8;
  char *return_value_gettext$12;
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  char *return_value_gettext$16;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  if(tree->read_only == 0)
  {
    if(!(tree->modified == 0))
      tmp_if_expr$21 = (_Bool)1;

    else
    {
      if(!(tree->root == ((struct DOODLE_Node *)NULL)))
        tmp_if_expr$20 = (signed int)tree->root->modified != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$20 = (_Bool)0;
      tmp_if_expr$21 = tmp_if_expr$20 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$21)
    {
      signed int fdt;
      char *tdatabase;
      tree->force_dump = 1;
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(tree->database);
      void *return_value_MALLOC$2;
      return_value_MALLOC$2=MALLOC(return_value_strlen$1 + (unsigned long int)2);
      tdatabase = (char *)return_value_MALLOC$2;
      strcpy(tdatabase, tree->database);
      strcat(tdatabase, "~");
      fdt=open(tdatabase, 0100 | 01000 | 02 | 0, 0400 | 0200 | 0400 >> 3);
      if(fdt == -1)
      {
        char *return_value_gettext$3;
        return_value_gettext$3=gettext("Could not open temporary file '%s': %s\n");
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        char *return_value_strerror$5;
        return_value_strerror$5=strerror(*return_value___errno_location$4);
        tree->log(tree->context, (unsigned int)0, return_value_gettext$3, tdatabase, return_value_strerror$5);
        free((void *)tdatabase);
      }

      fd=IO_WRAP(tree->log, tree->context, fdt);
      WRITEALL(fd, (const void *)MAGIC, (unsigned long long int)8);
      char *return_value_gettext$6;
      return_value_gettext$6=gettext("Writing doodle database to temporary file '%s'.\n");
      tree->log(tree->context, (unsigned int)2, return_value_gettext$6, tdatabase);
      ptc = (unsigned int)0;
      pathTab = (char **)(void *)0;
      i = (signed int)(tree->fnc - (unsigned int)1);
      if(i >= 0)
      {
        char *fn;
        signed int slen;
        signed int xslen;
        fn = (tree->filenames + (signed long int)i)->filename;
        unsigned long int return_value_strlen$7;
        return_value_strlen$7=strlen(fn);
        slen = (signed int)return_value_strlen$7;
        xslen = slen;
        if(!((signed int)fn[(signed long int)slen] == 47))
        {
          if(slen >= 1)
            slen = slen - 1;

        }

        j = (signed int)(ptc - (unsigned int)1);
        if(j >= 0)
        {
          return_value_strncmp$9=strncmp(fn, pathTab[(signed long int)j], (unsigned long int)slen);
          if(return_value_strncmp$9 == 0)
            return_value_strlen$8=strlen(pathTab[(signed long int)j]);

          j = j - 1;
        }

        if(!(j >= 0))
        {
          xgrow_((void **)&pathTab, sizeof(char *) /*8ul*/ , &ptc, ptc + (unsigned int)1, "tree.c", 1966);
          void *return_value_MALLOC$10;
          return_value_MALLOC$10=MALLOC((unsigned long int)(slen + 1));
          pathTab[(signed long int)(ptc - (unsigned int)1)] = (char *)return_value_MALLOC$10;
          memcpy((void *)pathTab[(signed long int)(ptc - (unsigned int)1)], (const void *)fn, (unsigned long int)slen);
          pathTab[(signed long int)(ptc - (unsigned int)1)][(signed long int)slen] = (char)0;
        }

        i = i - 1;
      }

      WRITEUINT(fd, ptc);
      i = (signed int)(ptc - (unsigned int)1);
      if(i >= 0)
      {
        writeZT(fd, pathTab[(signed long int)i]);
        i = i - 1;
      }

      WRITEUINT(fd, tree->fnc);
      i = (signed int)(tree->fnc - (unsigned int)1);
      if(i >= 0)
      {
        writeFN(fd, pathTab, ptc, (tree->filenames + (signed long int)i)->filename);
        WRITEUINT(fd, (tree->filenames + (signed long int)i)->mod_time);
        i = i - 1;
      }

      if(!(ptc == 0u))
      {
        i = (signed int)(ptc - (unsigned int)1);
        if(i >= 0)
        {
          free((void *)pathTab[(signed long int)i]);
          i = i - 1;
        }

        free((void *)pathTab);
      }

      WRITEUINT(fd, tree->cisPos);
      i = (signed int)(tree->cisPos - (unsigned int)1);
      if(i >= 0)
      {
        writeZT(fd, tree->cis[(signed long int)i]);
        i = i - 1;
      }

      unsigned long long int return_value_LSEEK$11;
      return_value_LSEEK$11=LSEEK(fd, (unsigned long long int)0, 1);
      wpos = (signed long int)return_value_LSEEK$11;
      off = (unsigned long long int)0;
      WRITEULONGFULL(fd, off);
      off=writeNode(fd, tree, tree->root);
      LSEEK(fd, (unsigned long long int)wpos, 0);
      WRITEULONGFULL(fd, off);
      IO_FREE(tree->fd);
      tree->fd = (struct anonymous$0 *)(void *)0;
      IO_FREE(fd);
      signed int return_value_unlink$15;
      return_value_unlink$15=unlink(tree->database);
      if(!(return_value_unlink$15 == 0))
      {
        return_value_gettext$12=gettext("Could not remove old database '%s': %s\n");
        return_value___errno_location$13=__errno_location();
        return_value_strerror$14=strerror(*return_value___errno_location$13);
        tree->log(tree->context, (unsigned int)1, return_value_gettext$12, tree->database, return_value_strerror$14);
      }

      signed int return_value_rename$19;
      return_value_rename$19=rename(tdatabase, tree->database);
      if(!(return_value_rename$19 == 0))
      {
        return_value_gettext$16=gettext("Could not rename temporary file '%s' to '%s: %s\n");
        return_value___errno_location$17=__errno_location();
        return_value_strerror$18=strerror(*return_value___errno_location$17);
        tree->log(tree->context, (unsigned int)0, return_value_gettext$16, tdatabase, tree->database, return_value_strerror$18);
      }

      free((void *)tdatabase);
    }

  }


CLEANUP:
  ;
  if(!(tree->fd == ((struct anonymous$0 *)NULL)))
  {
    IO_FREE(tree->fd);
    tree->fd = (struct anonymous$0 *)(void *)0;
  }

  i = (signed int)(tree->cisPos - (unsigned int)1);
  for( ; i >= 0; i = i - 1)
    free((void *)tree->cis[(signed long int)i]);
  if(!(tree->cis == ((char **)NULL)))
    free((void *)tree->cis);

  i = (signed int)(tree->fnc - (unsigned int)1);
  for( ; i >= 0; i = i - 1)
    free((void *)(tree->filenames + (signed long int)i)->filename);
  xgrow_((void **)&tree->filenames, sizeof(struct anonymous) /*16ul*/ , &tree->fns, (unsigned int)0, "tree.c", 2046);
  tmp = tree->root;
  tree->root = (struct DOODLE_Node *)(void *)0;
  freeNode(tree, tmp);
  free((void *)tree->database);
  free((void *)tree);
}

// DOODLE_tree_dump
// file tree.c line 3362
signed int DOODLE_tree_dump(struct _IO_FILE *stream, struct DOODLE_SuffixTree *tree)
{
  while((_Bool)0)
    ;
  if(tree == ((struct DOODLE_SuffixTree *)NULL) || stream == ((struct _IO_FILE *)NULL))
    return 1;

  else
  {
    signed int return_value_print_internal$1;
    return_value_print_internal$1=print_internal(tree, tree->root, stream, 2);
    return return_value_print_internal$1;
  }
}

// DOODLE_tree_expand
// file tree.c line 2261
signed int DOODLE_tree_expand(struct DOODLE_SuffixTree *tree, const char *searchString, const char *fileName)
{
  struct DOODLE_Node *pos;
  struct DOODLE_Node *spos;
  char *cisp;
  const char *cisp0;
  char *sharedName;
  signed int i;
  signed int cix;
  struct stat sbuf;
  unsigned int sharedNameIndex;
  _Bool tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(searchString == ((const char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_strlen$1=strlen(searchString);
    tmp_if_expr$2 = return_value_strlen$1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$10;
  signed int return_value_strcmp$9;
  unsigned long int return_value_strlen$11;
  unsigned long int return_value_strlen$12;
  unsigned long int return_value_strlen$21;
  _Bool tmp_if_expr$22;
  if(tmp_if_expr$2)
    return 1;

  else
  {
    while((_Bool)0)
      ;
    signed int return_value_stat$6;
    return_value_stat$6=stat(fileName, &sbuf);
    if(!(return_value_stat$6 == 0))
    {
      char *return_value_gettext$3;
      return_value_gettext$3=gettext("Call to '%s' for file '%s' failed: %s\n");
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(*return_value___errno_location$4);
      tree->log(tree->context, (unsigned int)0, return_value_gettext$3, (const void *)"stat", fileName, return_value_strerror$5);
      return 1;
    }

    tree->mutationCount = tree->mutationCount + 1u;
    char *return_value_gettext$7;
    return_value_gettext$7=gettext("Adding keyword '%s' for file '%s'.\n");
    tree->log(tree->context, (unsigned int)3, return_value_gettext$7, searchString, fileName);
    if(tree->fnc >= 1u)
    {
      return_value_strcmp$9=strcmp(fileName, (tree->filenames + (signed long int)(tree->fnc - (unsigned int)1))->filename);
      tmp_if_expr$10 = 0 == return_value_strcmp$9 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$10 = (_Bool)0;
    if(tmp_if_expr$10)
    {
      sharedName = (tree->filenames + (signed long int)(tree->fnc - (unsigned int)1))->filename;
      sharedNameIndex = tree->fnc - (unsigned int)1;
    }

    else
    {
      sharedNameIndex = (unsigned int)-1;
      i = (signed int)(tree->fnc - (unsigned int)2);
      if(i >= 0)
      {
        signed int return_value_strcmp$8;
        return_value_strcmp$8=strcmp(fileName, (tree->filenames + (signed long int)i)->filename);
        if(return_value_strcmp$8 == 0)
        {
          sharedName = (tree->filenames + (signed long int)i)->filename;
          sharedNameIndex = (unsigned int)i;
        }

        else
          i = i - 1;
      }

      if(sharedNameIndex == 4294967295u)
      {
        tree->modified = 1;
        if(tree->fnc == tree->fns)
          xgrow_((void **)&tree->filenames, sizeof(struct anonymous) /*16ul*/ , &tree->fns, tree->fns * (unsigned int)2 + (unsigned int)1, "tree.c", 2315);

        sharedName=STRDUP(fileName);
        (tree->filenames + (signed long int)tree->fnc)->mod_time = (unsigned int)sbuf.st_mtim.tv_sec;
        (tree->filenames + (signed long int)tree->fnc)->filename = sharedName;
        sharedNameIndex = tree->fnc;
        tree->fnc = tree->fnc + 1u;
      }

    }
    cisp = "";
    if(tree->cisPos >= 1u)
    {
      cisp = tree->cis[(signed long int)(tree->cisPos - (unsigned int)1)];
      unsigned long int return_value_strlen$13;
      return_value_strlen$13=strlen(cisp);
      unsigned long int return_value_strlen$14;
      return_value_strlen$14=strlen(searchString);
      if(!(return_value_strlen$14 >= return_value_strlen$13))
      {
        return_value_strlen$11=strlen(cisp);
        return_value_strlen$12=strlen(searchString);
        cisp = &cisp[(signed long int)(return_value_strlen$11 - return_value_strlen$12)];
      }

      else
        cisp = "";
    }

    signed int return_value_strcmp$15;
    return_value_strcmp$15=strcmp(cisp, searchString);
    if(!(return_value_strcmp$15 == 0))
    {
      cix = -1;
      spos=tree_search_internal(tree, searchString);
      pos = spos;
      if(!(pos == ((struct DOODLE_Node *)NULL)))
      {
        if(pos->cix == -1)
          pos = pos->child;

      }

      if(!(pos == ((struct DOODLE_Node *)NULL)))
      {
        cix = pos->cix;
        cisp=strstr(tree->cis[(signed long int)cix], searchString);
      }

      if(cix == -1)
      {
        if(tree->cisLen == tree->cisPos)
          xgrow_((void **)&tree->cis, sizeof(char *) /*8ul*/ , &tree->cisLen, (unsigned int)2 + tree->cisLen * (unsigned int)2, "tree.c", 2370);

        tree->cis[(signed long int)tree->cisPos]=STRDUP(searchString);
        cisp = tree->cis[(signed long int)tree->cisPos];
        tree->cisPos = tree->cisPos + 1u;
        cix = (signed int)(tree->cisPos - (unsigned int)1);
      }

    }

    else
      cix = (signed int)(tree->cisPos - (unsigned int)1);
    unsigned long int return_value_strlen$17;
    return_value_strlen$17=strlen(cisp);
    if(return_value_strlen$17 == 0ul)
    {
      char *return_value_gettext$16;
      return_value_gettext$16=gettext("Assertion failed at %s:%d.\n");
      tree->log(tree->context, (unsigned int)0, return_value_gettext$16, (const void *)"tree.c", 2386);
      return 1;
    }

    cisp0 = searchString;
    pos = tree->root;
    if(pos == ((struct DOODLE_Node *)NULL))
    {
      void *return_value_MALLOC$18;
      return_value_MALLOC$18=MALLOC(sizeof(struct DOODLE_Node) /*80ul*/ );
      pos = (struct DOODLE_Node *)return_value_MALLOC$18;
      pos->mls_size = (unsigned char)1;
      pos->useCounter = (unsigned int)0;
      tree->used_memory = tree->used_memory + sizeof(struct DOODLE_Node) /*80ul*/ ;
      pos->parent = (struct DOODLE_Node *)(void *)0;
      pos->c = cisp;
      pos->cix = cix;
      unsigned long int return_value_strlen$19;
      return_value_strlen$19=strlen(cisp0);
      pos->clength = (unsigned char)return_value_strlen$19;
      tree->root = pos;
      cisp0 = "";
      markModified(pos);
    }


  MORE:
    ;
    if(!((signed int)*cisp0 == 0))
    {
      pos->useCounter = pos->useCounter + 1u;
      if(!((signed int)*cisp0 >= (signed int)*pos->c))
      {
        struct DOODLE_Node *insert;
        void *return_value_MALLOC$20;
        return_value_MALLOC$20=MALLOC(sizeof(struct DOODLE_Node) /*80ul*/ );
        insert = (struct DOODLE_Node *)return_value_MALLOC$20;
        insert->mls_size = (unsigned char)1;
        insert->useCounter = (unsigned int)0;
        insert->link = pos;
        insert->link_off = pos->pos;
        if(!(pos->parent == ((struct DOODLE_Node *)NULL)))
        {
          insert->parent = pos->parent;
          if(pos->parent->link == pos)
            pos->parent->link = insert;

          else
            pos->parent->child = insert;
        }

        else
        {
          tree->root = insert;
          insert->parent = (struct DOODLE_Node *)(void *)0;
        }
        insert->c = &CIS[(signed long int)(unsigned char)cisp[(signed long int)0]];
        insert->clength = (unsigned char)1;
        pos->parent = insert;
        tree->modified = 1;
        tree->used_memory = tree->used_memory + sizeof(struct DOODLE_Node) /*80ul*/ ;
        pos = insert;
        markModified(insert);
      }

      else
        if(*pos->c == *cisp0)
        {
          i = 1;
          if(!(i >= (signed int)pos->clength))
          {
            return_value_strlen$21=strlen(cisp0);
            if(!((unsigned long int)i >= return_value_strlen$21))
            {
              if(pos->c[(signed long int)i] == cisp0[(signed long int)i])
                i = i + 1;

            }

          }

          if(i >= 2)
            tmp_if_expr$22 = i < (signed int)pos->clength ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$22 = (_Bool)0;
          if(tmp_if_expr$22)
          {
            tree_split(tree, pos, (unsigned int)i);
            cisp0 = &cisp0[(signed long int)i];
            cisp = &cisp[(signed long int)i];
          }

          else
            if(i == (signed int)pos->clength)
            {
              cisp0 = &cisp0[(signed long int)i];
              cisp = &cisp[(signed long int)i];
            }

            else
            {
              tree_normalize(tree, pos);
              cisp = cisp + 1l;
              cisp0 = cisp0 + 1l;
            }
          if(pos->child == ((struct DOODLE_Node *)NULL))
          {
            if(!(pos->next_off == 0ul))
            {
              signed int return_value_loadChild$23;
              return_value_loadChild$23=loadChild(tree, pos);
              if(return_value_loadChild$23 == -1)
                return 1;

            }

            else
            {
              tree->modified = 1;
              void *return_value_MALLOC$24;
              return_value_MALLOC$24=MALLOC(sizeof(struct DOODLE_Node) /*80ul*/ );
              pos->child = (struct DOODLE_Node *)return_value_MALLOC$24;
              pos->child->mls_size = (unsigned char)1;
              pos->child->useCounter = (unsigned int)0;
              tree->used_memory = tree->used_memory + sizeof(struct DOODLE_Node) /*80ul*/ ;
              pos->child->parent = pos;
              pos = pos->child;
              pos->c = &CIS[(signed long int)(unsigned char)cisp[(signed long int)0]];
              pos->clength = (unsigned char)1;
              markModified(pos);
            }
          }

          pos = pos->child;
        }

        else
        {
          if(pos->link == ((struct DOODLE_Node *)NULL))
          {
            if(!(pos->link_off == 0ul))
            {
              signed int return_value_loadLink$25;
              return_value_loadLink$25=loadLink(tree, pos);
              if(return_value_loadLink$25 == -1)
                return 1;

            }

            else
            {
              tree->modified = 1;
              void *return_value_MALLOC$26;
              return_value_MALLOC$26=MALLOC(sizeof(struct DOODLE_Node) /*80ul*/ );
              pos->link = (struct DOODLE_Node *)return_value_MALLOC$26;
              pos->link->mls_size = (unsigned char)1;
              pos->link->useCounter = (unsigned int)0;
              tree->used_memory = tree->used_memory + sizeof(struct DOODLE_Node) /*80ul*/ ;
              pos->link->parent = pos;
              pos = pos->link;
              pos->c = &CIS[(signed long int)(unsigned char)cisp[(signed long int)0]];
              pos->clength = (unsigned char)1;
              markModified(pos);
            }
          }

          else
            if((signed int)pos->clength == 1)
            {
              if(!((signed int)*cisp0 + -((signed int)*pos->c) >= (signed int)pos->mls_size))
                pos = &pos[(signed long int)((signed int)cisp0[(signed long int)0] - (signed int)pos->c[(signed long int)0])];

            }

          if(!((signed int)*cisp0 >= (signed int)*pos->link->c))
          {
            if((signed int)pos->mls_size == (signed int)*cisp0 + -((signed int)*pos->c))
            {
              struct DOODLE_Node *mlsroot;
              struct DOODLE_Node *mlsnew;
              signed int mls;
              if(!((signed int)pos->clength == 1))
                tree_split(tree, pos, (unsigned int)1);

              mlsroot = pos;
              if(!(mlsroot->parent == ((struct DOODLE_Node *)NULL)))
              {
                if(mlsroot->parent->link == mlsroot)
                {
                  if((signed int)mlsroot->parent->mls_size >= 2)
                    mlsroot = mlsroot->parent;

                }

              }

              if((signed int)*pos->link->c == 1 + (signed int)*cisp0)
              {
                if(!((signed int)pos->link->clength == 1))
                  tree_split(tree, pos->link, (unsigned int)1);

                void *return_value_MALLOC$27;
                return_value_MALLOC$27=MALLOC(sizeof(struct DOODLE_Node) /*80ul*/  * (unsigned long int)((signed int)mlsroot->mls_size + (signed int)pos->link->mls_size + 1));
                mlsnew = (struct DOODLE_Node *)return_value_MALLOC$27;
                memcpy((void *)mlsnew, (const void *)mlsroot, sizeof(struct DOODLE_Node) /*80ul*/  * (unsigned long int)mlsroot->mls_size);
                (mlsnew + (signed long int)mlsroot->mls_size)->clength = (unsigned char)1;
                memcpy((void *)&mlsnew[(signed long int)((signed int)mlsroot->mls_size + 1)], (const void *)pos->link, sizeof(struct DOODLE_Node) /*80ul*/  * (unsigned long int)pos->link->mls_size);
                (mlsnew + (signed long int)0)->mls_size = (unsigned char)((signed int)mlsroot->mls_size + (signed int)pos->link->mls_size + 1);
                mls = 1;
                if(!(mls >= (signed int)mlsnew->mls_size))
                {
                  (mlsnew + (signed long int)mls)->mls_size = (unsigned char)((signed int)mlsnew->mls_size - mls);
                  (mlsnew + (signed long int)mls)->parent = &mlsnew[(signed long int)(mls - 1)];
                  (mlsnew + (signed long int)(mls - 1))->link = &mlsnew[(signed long int)mls];
                  mls = mls + 1;
                }

                mls = 0;
                if(!(mls >= (signed int)mlsnew->mls_size))
                {
                  if(!((mlsnew + (signed long int)mls)->child == ((struct DOODLE_Node *)NULL)))
                    (mlsnew + (signed long int)mls)->child->parent = &mlsnew[(signed long int)mls];

                  mls = mls + 1;
                }

                (mlsnew + (signed long int)((signed int)mlsnew->mls_size - 1))->link = (pos->link + (signed long int)((signed int)pos->link->mls_size - 1))->link;
                (mlsnew + (signed long int)((signed int)mlsnew->mls_size - 1))->link_off = (pos->link + (signed long int)((signed int)pos->link->mls_size - 1))->link_off;
                if(!((pos->link + (signed long int)((signed int)pos->link->mls_size + -1))->link == ((struct DOODLE_Node *)NULL)))
                  (pos->link + (signed long int)((signed int)pos->link->mls_size - 1))->link->parent = &mlsnew[(signed long int)((signed int)mlsnew->mls_size - 1)];

                (mlsnew + (signed long int)mlsroot->mls_size)->c = (signed long int)1 + &CIS[(signed long int)(unsigned char)(mlsnew + (signed long int)((signed int)mlsroot->mls_size - 1))->c[(signed long int)0]];
                if(!(mlsroot->parent == ((struct DOODLE_Node *)NULL)))
                {
                  (mlsnew + (signed long int)0)->parent = mlsroot->parent;
                  if(mlsroot->parent->link == mlsroot)
                    mlsroot->parent->link = mlsnew;

                  else
                    mlsroot->parent->child = mlsnew;
                }

                else
                  tree->root = mlsnew;
                free((void *)pos->link);
                pos = &mlsnew[(signed long int)mlsroot->mls_size];
              }

              else
              {
                void *return_value_MALLOC$28;
                return_value_MALLOC$28=MALLOC(sizeof(struct DOODLE_Node) /*80ul*/  * (unsigned long int)((signed int)mlsroot->mls_size + 1));
                mlsnew = (struct DOODLE_Node *)return_value_MALLOC$28;
                memcpy((void *)mlsnew, (const void *)mlsroot, sizeof(struct DOODLE_Node) /*80ul*/  * (unsigned long int)mlsroot->mls_size);
                (mlsnew + (signed long int)mlsroot->mls_size)->clength = (unsigned char)1;
                (mlsnew + (signed long int)0)->mls_size = (unsigned char)((signed int)mlsroot->mls_size + 1);
                mls = 1;
                if(!(mls >= (signed int)mlsnew->mls_size))
                {
                  (mlsnew + (signed long int)mls)->mls_size = (unsigned char)((signed int)mlsnew->mls_size - mls);
                  (mlsnew + (signed long int)mls)->parent = &mlsnew[(signed long int)(mls - 1)];
                  (mlsnew + (signed long int)(mls - 1))->link = &mlsnew[(signed long int)mls];
                  mls = mls + 1;
                }

                mls = 0;
                if(!(mls >= (signed int)mlsnew->mls_size))
                {
                  if(!((mlsnew + (signed long int)mls)->child == ((struct DOODLE_Node *)NULL)))
                    (mlsnew + (signed long int)mls)->child->parent = &mlsnew[(signed long int)mls];

                  mls = mls + 1;
                }

                (mlsnew + (signed long int)((signed int)mlsnew->mls_size - 1))->link = pos->link;
                (mlsnew + (signed long int)((signed int)mlsnew->mls_size - 1))->link_off = pos->link_off;
                if(!(pos->link == ((struct DOODLE_Node *)NULL)))
                  pos->link->parent = &mlsnew[(signed long int)((signed int)mlsnew->mls_size - 1)];

                (mlsnew + (signed long int)mlsroot->mls_size)->c = (signed long int)1 + &CIS[(signed long int)(unsigned char)(mlsnew + (signed long int)((signed int)mlsroot->mls_size - 1))->c[(signed long int)0]];
                if(!(mlsroot->parent == ((struct DOODLE_Node *)NULL)))
                {
                  (mlsnew + (signed long int)0)->parent = mlsroot->parent;
                  if(mlsroot->parent->link == mlsroot)
                    mlsroot->parent->link = mlsnew;

                  else
                    mlsroot->parent->child = mlsnew;
                }

                else
                  tree->root = mlsnew;
                pos = &mlsnew[(signed long int)mlsroot->mls_size];
              }
              free((void *)mlsroot);
              tree->used_memory = tree->used_memory + sizeof(struct DOODLE_Node) /*80ul*/ ;
              tree->modified = 1;
              mls = 0;
              if(!(mls >= (signed int)mlsnew->mls_size))
              {
                markModified(&mlsnew[(signed long int)mls]);
                mls = mls + 1;
              }

            }

            else
            {
              struct DOODLE_Node *DOODLE_tree_expand$$1$$10$$2$$2$$3$$2$$insert;
              void *return_value_MALLOC$29;
              return_value_MALLOC$29=MALLOC(sizeof(struct DOODLE_Node) /*80ul*/ );
              DOODLE_tree_expand$$1$$10$$2$$2$$3$$2$$insert = (struct DOODLE_Node *)return_value_MALLOC$29;
              DOODLE_tree_expand$$1$$10$$2$$2$$3$$2$$insert->mls_size = (unsigned char)1;
              DOODLE_tree_expand$$1$$10$$2$$2$$3$$2$$insert->useCounter = (unsigned int)0;
              DOODLE_tree_expand$$1$$10$$2$$2$$3$$2$$insert->link = pos->link;
              DOODLE_tree_expand$$1$$10$$2$$2$$3$$2$$insert->link_off = pos->link_off;
              pos->link = DOODLE_tree_expand$$1$$10$$2$$2$$3$$2$$insert;
              pos->link_off = (unsigned long long int)0;
              DOODLE_tree_expand$$1$$10$$2$$2$$3$$2$$insert->parent = pos;
              DOODLE_tree_expand$$1$$10$$2$$2$$3$$2$$insert->link->parent = DOODLE_tree_expand$$1$$10$$2$$2$$3$$2$$insert;
              tree->modified = 1;
              tree->used_memory = tree->used_memory + sizeof(struct DOODLE_Node) /*80ul*/ ;
              pos = DOODLE_tree_expand$$1$$10$$2$$2$$3$$2$$insert;
              pos->c = &CIS[(signed long int)(unsigned char)cisp[(signed long int)0]];
              pos->clength = (unsigned char)1;
              markModified(pos);
            }
          }

          else
            pos = pos->link;
        }
    }

    unsigned long int return_value_strlen$33;
    return_value_strlen$33=strlen(cisp0);
    if(return_value_strlen$33 >= 1ul)
    {
      unsigned long int return_value_strlen$32;
      return_value_strlen$32=strlen(cisp0);
      if(return_value_strlen$32 == 1ul)
      {
        pos->c = &CIS[(signed long int)(unsigned char)cisp[(signed long int)0]];
        pos->clength = (unsigned char)1;
      }

      else
      {
        unsigned long int return_value_strlen$31;
        return_value_strlen$31=strlen(cisp0);
        if(return_value_strlen$31 >= 256ul)
        {
          pos->c = cisp;
          pos->cix = cix;
          pos->clength = (unsigned char)255;
          cisp = &cisp[(signed long int)255];
          cisp0 = &cisp0[(signed long int)255];
        }

        else
        {
          pos->c = cisp;
          pos->cix = cix;
          unsigned long int return_value_strlen$30;
          return_value_strlen$30=strlen(cisp0);
          pos->clength = (unsigned char)return_value_strlen$30;
        }
      }
    }

    i = (signed int)(pos->matchCount - (unsigned int)1);
    if(i >= 0)
      i = i - 1;

    xgrow_((void **)&pos->matches, sizeof(unsigned int) /*4ul*/ , &pos->matchCount, pos->matchCount + (unsigned int)1, "tree.c", 2801);
    pos->matches[(signed long int)(pos->matchCount - (unsigned int)1)] = sharedNameIndex;
    markModified(pos);

  CLEANUP_SUCCESS:
    ;
    if(!(tree->memory_limit >= tree->used_memory))
      shrinkMemoryFootprint(tree, tree->root);

    return 0;
  }
}

// DOODLE_tree_open_RDONLY
// file tree.c line 1864
struct DOODLE_SuffixTree * DOODLE_tree_open_RDONLY(void (*log)(void *, unsigned int, const char *, ...), void *context, const char *database)
{
  struct DOODLE_SuffixTree *return_value_DOODLE_tree_create_internal$1;
  return_value_DOODLE_tree_create_internal$1=DOODLE_tree_create_internal(log, context, database, 00);
  return return_value_DOODLE_tree_create_internal$1;
}

// DOODLE_tree_search
// file tree.c line 3150
signed int DOODLE_tree_search(struct DOODLE_SuffixTree *tree, const char *substring, void (*callback)(const struct anonymous *, void *), void *arg)
{
  struct DOODLE_Node *pos;
  pos=tree_search_internal(tree, substring);
  signed int return_value_tree_iterate_internal$1;
  return_value_tree_iterate_internal$1=tree_iterate_internal(0, tree, pos, callback, arg);
  return return_value_tree_iterate_internal$1;
}

// DOODLE_tree_search_approx
// file tree.c line 3304
signed int DOODLE_tree_search_approx(struct DOODLE_SuffixTree *tree, const unsigned int approx, const signed int ignore_case, const char *ss, void (*callback)(const struct anonymous *, void *), void *arg)
{
  signed int return_value_tree_search_approx_internal$1;
  return_value_tree_search_approx_internal$1=tree_search_approx_internal(tree->root, approx, ignore_case, tree, ss, callback, arg);
  return return_value_tree_search_approx_internal$1;
}

// DOODLE_tree_set_memory_limit
// file doodle.h line 195
void DOODLE_tree_set_memory_limit(struct DOODLE_SuffixTree *tree, unsigned long int limit)
{
  tree->memory_limit = limit;
  if(!(tree->memory_limit >= tree->used_memory))
    shrinkMemoryFootprint(tree, tree->root);

}

// DOODLE_tree_truncate
// file tree.c line 2962
signed int DOODLE_tree_truncate(struct DOODLE_SuffixTree *tree, const char *fileName)
{
  const char *filenames[2l];
  filenames[(signed long int)0] = fileName;
  filenames[(signed long int)1] = (const char *)(void *)0;
  signed int return_value_DOODLE_tree_truncate_multiple$1;
  return_value_DOODLE_tree_truncate_multiple$1=DOODLE_tree_truncate_multiple(tree, filenames);
  return return_value_DOODLE_tree_truncate_multiple$1;
}

// DOODLE_tree_truncate_deleted
// file tree.c line 2975
void DOODLE_tree_truncate_deleted(struct DOODLE_SuffixTree *tree, void (*log)(void *, unsigned int, const char *, ...), void *logContext)
{
  signed int i;
  unsigned int killCount;
  const char **killNames;
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Scanning filesystem in order to remove obsolete entries from existing database.\n");
  log(logContext, (unsigned int)1, return_value_gettext$1);
  killCount = (unsigned int)0;
  killNames = (const char **)(void *)0;
  unsigned int return_value_DOODLE_getFileCount$2;
  return_value_DOODLE_getFileCount$2=DOODLE_getFileCount(tree);
  i = (signed int)(return_value_DOODLE_getFileCount$2 - (unsigned int)1);
  _Bool tmp_if_expr$16;
  signed int *return_value___errno_location$9;
  _Bool tmp_if_expr$11;
  signed int *return_value___errno_location$10;
  _Bool tmp_if_expr$13;
  signed int *return_value___errno_location$12;
  _Bool tmp_if_expr$15;
  signed int *return_value___errno_location$14;
  if(i >= 0)
  {
    struct stat sbuf;
    char *fn;
    signed int keep = 1;
    const struct anonymous *return_value_DOODLE_getFileAt$3;
    return_value_DOODLE_getFileAt$3=DOODLE_getFileAt(tree, (unsigned int)i);
    fn = return_value_DOODLE_getFileAt$3->filename;
    signed int return_value_lstat$8;
    return_value_lstat$8=lstat(fn, &sbuf);
    if(!(return_value_lstat$8 == 0))
    {
      return_value___errno_location$9=__errno_location();
      if(*return_value___errno_location$9 == 2)
        tmp_if_expr$11 = (_Bool)1;

      else
      {
        return_value___errno_location$10=__errno_location();
        tmp_if_expr$11 = *return_value___errno_location$10 == 20 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$11)
        tmp_if_expr$13 = (_Bool)1;

      else
      {
        return_value___errno_location$12=__errno_location();
        tmp_if_expr$13 = *return_value___errno_location$12 == 40 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$13)
        tmp_if_expr$15 = (_Bool)1;

      else
      {
        return_value___errno_location$14=__errno_location();
        tmp_if_expr$15 = *return_value___errno_location$14 == 13 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr$16 = tmp_if_expr$15 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$16 = (_Bool)0;
    if(tmp_if_expr$16)
    {
      char *return_value_gettext$4;
      return_value_gettext$4=gettext("File '%s' could not be accessed: %s. Removing file from index.\n");
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      char *return_value_strerror$6;
      return_value_strerror$6=strerror(*return_value___errno_location$5);
      log(logContext, (unsigned int)1, return_value_gettext$4, fn, return_value_strerror$6);
      keep = 0;
    }

    else
      if(!((61440u & sbuf.st_mode) == 32768u))
      {
        char *return_value_gettext$7;
        return_value_gettext$7=gettext("File '%s' is not a regular file. Removing file from index.\n");
        log(logContext, (unsigned int)2, return_value_gettext$7, fn);
        keep = 0;
      }

    if(keep == 0)
    {
      xgrow_((void **)&killNames, sizeof(const char *) /*8ul*/ , &killCount, killCount + (unsigned int)1, "tree.c", 3017);
      killNames[(signed long int)(killCount - (unsigned int)1)] = fn;
    }

    i = i - 1;
  }

  xgrow_((void **)&killNames, sizeof(const char *) /*8ul*/ , &killCount, killCount + (unsigned int)1, "tree.c", 3023);
  DOODLE_tree_truncate_multiple(tree, killNames);
  xgrow_((void **)&killNames, sizeof(const char *) /*8ul*/ , &killCount, (unsigned int)0, "tree.c", 3028);
}

// DOODLE_tree_truncate_modified
// file tree.c line 3036
void DOODLE_tree_truncate_modified(struct DOODLE_SuffixTree *tree, void (*log)(void *, unsigned int, const char *, ...), void *logContext)
{
  signed int i;
  unsigned int killCount;
  const char **killNames;
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Scanning filesystem in order to remove obsolete entries from existing database.\n");
  log(logContext, (unsigned int)1, return_value_gettext$1);
  killCount = (unsigned int)0;
  killNames = (const char **)(void *)0;
  unsigned int return_value_DOODLE_getFileCount$2;
  return_value_DOODLE_getFileCount$2=DOODLE_getFileCount(tree);
  i = (signed int)(return_value_DOODLE_getFileCount$2 - (unsigned int)1);
  _Bool tmp_if_expr$17;
  signed int *return_value___errno_location$10;
  _Bool tmp_if_expr$12;
  signed int *return_value___errno_location$11;
  _Bool tmp_if_expr$14;
  signed int *return_value___errno_location$13;
  _Bool tmp_if_expr$16;
  signed int *return_value___errno_location$15;
  const struct anonymous *return_value_DOODLE_getFileAt$8;
  if(i >= 0)
  {
    struct stat sbuf;
    char *fn;
    signed int keep = 1;
    const struct anonymous *return_value_DOODLE_getFileAt$3;
    return_value_DOODLE_getFileAt$3=DOODLE_getFileAt(tree, (unsigned int)i);
    fn = return_value_DOODLE_getFileAt$3->filename;
    signed int return_value_lstat$9;
    return_value_lstat$9=lstat(fn, &sbuf);
    if(!(return_value_lstat$9 == 0))
    {
      return_value___errno_location$10=__errno_location();
      if(*return_value___errno_location$10 == 2)
        tmp_if_expr$12 = (_Bool)1;

      else
      {
        return_value___errno_location$11=__errno_location();
        tmp_if_expr$12 = *return_value___errno_location$11 == 20 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$12)
        tmp_if_expr$14 = (_Bool)1;

      else
      {
        return_value___errno_location$13=__errno_location();
        tmp_if_expr$14 = *return_value___errno_location$13 == 40 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$14)
        tmp_if_expr$16 = (_Bool)1;

      else
      {
        return_value___errno_location$15=__errno_location();
        tmp_if_expr$16 = *return_value___errno_location$15 == 13 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr$17 = tmp_if_expr$16 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$17 = (_Bool)0;
    if(tmp_if_expr$17)
    {
      char *return_value_gettext$4;
      return_value_gettext$4=gettext("File '%s' could not be accessed: %s. Removing file from index.\n");
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      char *return_value_strerror$6;
      return_value_strerror$6=strerror(*return_value___errno_location$5);
      log(logContext, (unsigned int)1, return_value_gettext$4, fn, return_value_strerror$6);
      keep = 0;
    }

    else
      if(!((61440u & sbuf.st_mode) == 32768u))
      {
        char *return_value_gettext$7;
        return_value_gettext$7=gettext("File '%s' is not a regular file. Removing file from index.\n");
        log(logContext, (unsigned int)2, return_value_gettext$7, fn);
        keep = 0;
      }

      else
      {
        return_value_DOODLE_getFileAt$8=DOODLE_getFileAt(tree, (unsigned int)i);
        if(!(return_value_DOODLE_getFileAt$8->mod_time == (unsigned int)sbuf.st_mtim.tv_sec))
          keep = 0;

      }
    if(keep == 0)
    {
      xgrow_((void **)&killNames, sizeof(const char *) /*8ul*/ , &killCount, killCount + (unsigned int)1, "tree.c", 3081);
      killNames[(signed long int)(killCount - (unsigned int)1)] = fn;
    }

    i = i - 1;
  }

  xgrow_((void **)&killNames, sizeof(const char *) /*8ul*/ , &killCount, killCount + (unsigned int)1, "tree.c", 3087);
  DOODLE_tree_truncate_multiple(tree, killNames);
  xgrow_((void **)&killNames, sizeof(const char *) /*8ul*/ , &killCount, (unsigned int)0, "tree.c", 3092);
}

// DOODLE_tree_truncate_multiple
// file doodle.h line 124
signed int DOODLE_tree_truncate_multiple(struct DOODLE_SuffixTree *tree, const char **fileNames)
{
  unsigned int *delOff;
  signed int off;
  signed int rep;
  signed int err;
  signed int max;
  signed int i;
  signed int pos;
  while((_Bool)0)
    ;
  max = 0;
  signed int tmp_post$2;
  if(!(fileNames[(signed long int)max] == ((const char *)NULL)))
  {
    char *return_value_gettext$1;
    return_value_gettext$1=gettext("Removing the keywords for file '%s'.\n");
    tmp_post$2 = max;
    max = max + 1;
    tree->log(tree->context, (unsigned int)1, return_value_gettext$1, fileNames[(signed long int)tmp_post$2]);
  }

  signed int tmp_post$4;
  if(max == 0)
    return 0;

  else
  {
    void *return_value_MALLOC$3;
    return_value_MALLOC$3=MALLOC(sizeof(signed int) /*4ul*/  * (unsigned long int)max);
    delOff = (unsigned int *)return_value_MALLOC$3;
    rep = (signed int)tree->fnc;
    err = 0;
    pos = 0;
    off = rep - 1;
    for( ; off >= 0; off = off - 1)
    {
      i = 0;
      for( ; !(i >= max); i = i + 1)
      {
        signed int return_value_strcmp$5;
        return_value_strcmp$5=strcmp((tree->filenames + (signed long int)off)->filename, fileNames[(signed long int)i]);
        if(return_value_strcmp$5 == 0)
        {
          tree->modified = 1;
          tmp_post$4 = pos;
          pos = pos + 1;
          delOff[(signed long int)tmp_post$4] = (unsigned int)off;
        }

      }
    }
    max = pos;
    if(max == 0)
    {
      free((void *)delOff);
      return 0;
    }

    else
    {
      err=truncate_internal(tree, tree->root, delOff, max);
      i = 0;
      for( ; !(i >= max); i = i + 1)
      {
        free((void *)(tree->filenames + (signed long int)delOff[(signed long int)i])->filename);
        rep = rep - 1;
        tree->filenames[(signed long int)delOff[(signed long int)i]] = tree->filenames[(signed long int)rep];
      }
      free((void *)delOff);
      while((_Bool)0)
        ;
      tree->fnc = (unsigned int)rep;
      if(tree->fns / 2u >= tree->fnc)
        xgrow_((void **)&tree->filenames, sizeof(struct anonymous) /*16ul*/ , &tree->fns, tree->fnc, "tree.c", 2954);

      return err;
    }
  }
}

// IO_FREE
// file tree.c line 398
static void IO_FREE(struct anonymous$0 *bio)
{
  flush_buffer(bio);
  close(bio->fd);
  free((void *)bio->buffer);
  free((void *)bio);
}

// IO_WRAP
// file tree.c line 232
static struct anonymous$0 * IO_WRAP(void (*log)(void *, unsigned int, const char *, ...), void *context, signed int fd)
{
  struct anonymous$0 *bio;
  struct stat buf;
  signed int return_value_fstat$4;
  return_value_fstat$4=fstat(fd, &buf);
  char *return_value_gettext$1;
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  if(!(return_value_fstat$4 == 0))
  {
    return_value_gettext$1=gettext("Call to '%s' failed: %s\n");
    return_value___errno_location$2=__errno_location();
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    log(context, (unsigned int)0, return_value_gettext$1, (const void *)"fstat", return_value_strerror$3);
  }

  void *return_value_MALLOC$5;
  return_value_MALLOC$5=MALLOC(sizeof(struct anonymous$0) /*72ul*/ );
  bio = (struct anonymous$0 *)return_value_MALLOC$5;
  bio->log = log;
  bio->context = context;
  bio->fd = fd;
  bio->off = (unsigned long long int)0;
  void *return_value_MALLOC$6;
  return_value_MALLOC$6=MALLOC((unsigned long int)4096);
  bio->buffer = (char *)return_value_MALLOC$6;
  bio->bsize = (unsigned long long int)0;
  bio->bstart = (unsigned long long int)0;
  bio->fsize = (unsigned long long int)buf.st_size;
  bio->dirty = (unsigned long long int)0;
  return bio;
}

// LSEEK
// file tree.c line 380
static unsigned long long int LSEEK(struct anonymous$0 *bio, unsigned long long int off, signed int whence)
{
  switch(whence)
  {
    case 0:
    {
      bio->off = off;
      return off;
    }
    case 2:
    {
      bio->off = bio->fsize;
      return bio->fsize;
    }
    case 1:
    {
      bio->off = bio->off + off;
      return bio->off;
    }
    default:
      return (unsigned long long int)-1;
  }
}

// MALLOC
// file helper1.h line 39
void * MALLOC(unsigned long int size)
{
  void *ret;
  if(size == 0ul)
  {
    char *return_value_gettext$1;
    return_value_gettext$1=gettext("FATAL: MALLOC called with size 0!\n");
    fprintf(stderr, return_value_gettext$1);
    abort();
  }

  ret=malloc(size);
  if(ret == NULL)
  {
    char *return_value_gettext$3;
    return_value_gettext$3=gettext("FATAL: %s\n");
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    fprintf(stderr, return_value_gettext$3, return_value_strerror$5);
    abort();
  }

  memset(ret, 0, size);
  return ret;
}

// PTHREAD_CREATE
// file semaphore.h line 147
signed int PTHREAD_CREATE(struct PTHREAD_T *pt, void * (*main)(void *), void *arg, unsigned long int stackSize)
{
  unsigned long int *handle;
  union pthread_attr_t stack_size_custom_attr;
  signed int ret;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(unsigned long int) /*8ul*/ );
  handle = (unsigned long int *)return_value_malloc$1;
  pthread_attr_init(&stack_size_custom_attr);
  pthread_attr_setstacksize(&stack_size_custom_attr, stackSize);
  ret=pthread_create(handle, &stack_size_custom_attr, main, arg);
  if(!(ret == 0))
  {
    free((void *)handle);
    pt->internal = (void *)0;
    return ret;
  }

  else
  {
    pt->internal = (void *)handle;
    return ret;
  }
}

// PTHREAD_DETACH
// file semaphore.c line 431
void PTHREAD_DETACH(struct PTHREAD_T *pt)
{
  unsigned long int *handle = (unsigned long int *)pt->internal;
  do
    if(handle == ((unsigned long int *)NULL))
      abort();

  while((_Bool)0);
  pthread_detach(*handle);
  pt->internal = (void *)0;
  free((void *)handle);
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// PTHREAD_GET_SELF
// file semaphore.c line 353
void PTHREAD_GET_SELF(struct PTHREAD_T *pt)
{
  pt->internal=malloc(sizeof(unsigned long int) /*8ul*/ );
  *((unsigned long int *)pt->internal)=pthread_self();
}

// PTHREAD_JOIN
// file semaphore.h line 152
void PTHREAD_JOIN(struct PTHREAD_T *pt, void **ret)
{
  signed int k;
  unsigned long int *handle = (unsigned long int *)pt->internal;
  do
    if(handle == ((unsigned long int *)NULL))
      abort();

  while((_Bool)0);
  k=pthread_join(*handle, ret);
  switch(k)
  {
    case 0:
    {
      free((void *)handle);
      pt->internal = (void *)0;
      break;
    }
    case 3:
      abort();
    case 22:
      abort();
    case 35:
      abort();
    default:
      abort();
  }
}

// PTHREAD_KILL
// file semaphore.h line 155
void PTHREAD_KILL(struct PTHREAD_T *pt, signed int signal)
{
  unsigned long int *handle = (unsigned long int *)pt->internal;
  if(handle == ((unsigned long int *)NULL))
    abort();

  else
    pthread_kill(*handle, signal);
}

// PTHREAD_REL_SELF
// file semaphore.c line 361
void PTHREAD_REL_SELF(struct PTHREAD_T *pt)
{
  if(!(pt->internal == NULL))
    free(pt->internal);

  pt->internal = (void *)0;
}

// PTHREAD_SELF_TEST
// file semaphore.c line 334
signed int PTHREAD_SELF_TEST(struct PTHREAD_T *pt)
{
  unsigned long int *handle = (unsigned long int *)pt->internal;
  if(handle == ((unsigned long int *)NULL))
    return 0;

  else
  {
    unsigned long int return_value_pthread_self$1;
    return_value_pthread_self$1=pthread_self();
    if(*handle == return_value_pthread_self$1)
      return 1;

    else
      return 0;
  }
}

// READALL
// file tree.c line 295
static signed int READALL(struct anonymous$0 *bio, void *buf, unsigned long long int len)
{
  signed int ret;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  if(len >= 4097ul)
  {
    flush_buffer(bio);
    ret=read_buf(bio->log, bio->context, bio->fd, bio->off, (char *)buf, len);
    bio->off = bio->off + len;
    return ret;
  }

  else
  {
    ret = 0;
    if(!(bio->off >= bio->bstart))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = bio->off + len > bio->bstart + bio->bsize ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      ret=retarget_buffer(bio, bio->off, len);

    if(!(bio->off >= bio->bstart))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = bio->off + len > bio->bstart + bio->bsize ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      char *return_value_gettext$2;
      return_value_gettext$2=gettext("Assertion failed at %s:%d.\n");
      bio->log(bio->context, (unsigned int)0, return_value_gettext$2, (const void *)"tree.c", 329);
      return -1;
    }

    memcpy(buf, (const void *)&bio->buffer[(signed long int)(bio->off - bio->bstart)], len);
    bio->off = bio->off + len;
    return ret;
  }
}

// READUINT
// file tree.c line 405
static signed int READUINT(struct anonymous$0 *fd, unsigned int *val)
{
  signed char c;
  signed char d;
  unsigned char v[4l];
  signed int return_value_READALL$1;
  return_value_READALL$1=READALL(fd, (void *)&c, sizeof(signed char) /*1ul*/ );
  if(return_value_READALL$1 == -1)
    return -1;

  else
  {
    if((signed int)c >= 5 || !((signed int)c >= 0))
    {
      char *return_value_gettext$2;
      return_value_gettext$2=gettext("Assertion failed at %s:%d.\nDatabase format error!\n");
      fd->log(fd->context, (unsigned int)0, return_value_gettext$2, (const void *)"tree.c", 416);
      return -1;
    }

    *val = (unsigned int)0;
    signed int return_value_READALL$3;
    return_value_READALL$3=READALL(fd, (void *)&v[(signed long int)0], (unsigned long long int)(signed int)c);
    if(return_value_READALL$3 == -1)
      return -1;

    else
    {
      d = (signed char)((signed int)c - 1);
      for( ; (signed int)d >= 0; d = d - 1)
        *val = *val + (unsigned int)((signed int)v[(signed long int)(unsigned char)d] << 8 * (signed int)d);
      return 0;
    }
  }
}

// READUINTPAIR
// file tree.c line 461
static signed int READUINTPAIR(struct anonymous$0 *fd, unsigned int *val1, unsigned int *val2)
{
  unsigned char c;
  signed char d;
  unsigned char v[4l];
  signed int return_value_READALL$1;
  return_value_READALL$1=READALL(fd, (void *)&c, sizeof(unsigned char) /*1ul*/ );
  if(return_value_READALL$1 == -1)
    return -1;

  else
  {
    if((signed int)c >> 4 >= 5 || (15 & (signed int)c) >= 5)
    {
      char *return_value_gettext$2;
      return_value_gettext$2=gettext("Assertion failed at %s:%d.\nDatabase format error!\n");
      fd->log(fd->context, (unsigned int)0, return_value_gettext$2, (const void *)"tree.c", 474);
      return -1;
    }

    *val1 = (unsigned int)0;
    *val2 = (unsigned int)0;
    signed int return_value_READALL$3;
    return_value_READALL$3=READALL(fd, (void *)&v[(signed long int)0], (unsigned long long int)((signed int)(unsigned char)c & 15));
    if(return_value_READALL$3 == -1)
      return -1;

    else
    {
      d = (signed char)(((signed int)c & 15) - 1);
      for( ; (signed int)d >= 0; d = d - 1)
        *val2 = *val2 + (unsigned int)((signed int)v[(signed long int)(unsigned char)d] << 8 * (signed int)d);
      signed int return_value_READALL$4;
      return_value_READALL$4=READALL(fd, (void *)&v[(signed long int)0], (unsigned long long int)((signed int)(unsigned char)c >> 4));
      if(return_value_READALL$4 == -1)
        return -1;

      else
      {
        d = (signed char)(((signed int)c >> 4) - 1);
        for( ; (signed int)d >= 0; d = d - 1)
          *val1 = *val1 + (unsigned int)((signed int)v[(signed long int)(unsigned char)d] << 8 * (signed int)d);
        return 0;
      }
    }
  }
}

// READULONG
// file tree.c line 427
static signed int READULONG(struct anonymous$0 *fd, unsigned long long int *val)
{
  signed char c;
  signed char d;
  unsigned char v[8l];
  signed int return_value_READALL$1;
  return_value_READALL$1=READALL(fd, (void *)&c, sizeof(signed char) /*1ul*/ );
  if(return_value_READALL$1 == -1)
    return -1;

  else
  {
    if((signed int)c >= 9 || !((signed int)c >= 0))
    {
      char *return_value_gettext$2;
      return_value_gettext$2=gettext("Assertion failed at %s:%d.\nDatabase format error!\n");
      fd->log(fd->context, (unsigned int)0, return_value_gettext$2, (const void *)"tree.c", 438);
      return -1;
    }

    *val = (unsigned long long int)0;
    signed int return_value_READALL$3;
    return_value_READALL$3=READALL(fd, (void *)&v[(signed long int)0], (unsigned long long int)(signed int)c);
    if(return_value_READALL$3 == -1)
      return -1;

    else
    {
      d = (signed char)((signed int)c - 1);
      for( ; (signed int)d >= 0; d = d - 1)
        *val = *val + ((unsigned long long int)v[(signed long int)(unsigned char)d] << 8 * (signed int)d);
      return 0;
    }
  }
}

// READULONGFULL
// file tree.c line 449
static signed int READULONGFULL(struct anonymous$0 *fd, unsigned long long int *val)
{
  unsigned int d;
  unsigned int e;
  unsigned char v[8l];
  *val = (unsigned long long int)0;
  signed int return_value_READALL$1;
  return_value_READALL$1=READALL(fd, (void *)&v[(signed long int)0], (unsigned long long int)8);
  if(return_value_READALL$1 == -1)
    return -1;

  else
  {
    d = (unsigned int)0;
    e = (unsigned int)7;
    for( ; !(d >= 8u); e = e - 1u)
    {
      *val = *val + ((unsigned long long int)v[(signed long int)d] << (unsigned int)8 * e);
      d = d + 1u;
    }
    return 0;
  }
}

// READULONGPAIR
// file tree.c line 490
static signed int READULONGPAIR(struct anonymous$0 *fd, unsigned long long int *val1, unsigned long long int *val2)
{
  unsigned char c;
  signed char d;
  unsigned char v[8l];
  signed int return_value_READALL$1;
  return_value_READALL$1=READALL(fd, (void *)&c, sizeof(unsigned char) /*1ul*/ );
  if(return_value_READALL$1 == -1)
    return -1;

  else
  {
    if((signed int)c >> 4 >= 9 || (15 & (signed int)c) >= 9)
    {
      char *return_value_gettext$2;
      return_value_gettext$2=gettext("Assertion failed at %s:%d.\nDatabase format error!\n");
      fd->log(fd->context, (unsigned int)0, return_value_gettext$2, (const void *)"tree.c", 503);
      return -1;
    }

    *val1 = (unsigned long long int)0;
    *val2 = (unsigned long long int)0;
    signed int return_value_READALL$3;
    return_value_READALL$3=READALL(fd, (void *)&v[(signed long int)0], (unsigned long long int)((signed int)(unsigned char)c & 15));
    if(return_value_READALL$3 == -1)
      return -1;

    else
    {
      d = (signed char)(((signed int)c & 15) - 1);
      for( ; (signed int)d >= 0; d = d - 1)
        *val2 = *val2 + ((unsigned long long int)v[(signed long int)(unsigned char)d] << 8 * (signed int)d);
      signed int return_value_READALL$4;
      return_value_READALL$4=READALL(fd, (void *)&v[(signed long int)0], (unsigned long long int)((signed int)(unsigned char)c >> 4));
      if(return_value_READALL$4 == -1)
        return -1;

      else
      {
        d = (signed char)(((signed int)c >> 4) - 1);
        for( ; (signed int)d >= 0; d = d - 1)
          *val1 = *val1 + ((unsigned long long int)v[(signed long int)(unsigned char)d] << 8 * (signed int)d);
        return 0;
      }
    }
  }
}

// STRDUP
// file helper1.h line 41
char * STRDUP(const char *str)
{
  char *ret;
  if(str == ((const char *)NULL))
  {
    char *return_value_gettext$1;
    return_value_gettext$1=gettext("FATAL: STRDUP called with str NULL!\n");
    fprintf(stderr, return_value_gettext$1);
    abort();
  }

  ret=strdup(str);
  if(ret == ((char *)NULL))
  {
    char *return_value_gettext$2;
    return_value_gettext$2=gettext("FATAL: %s\n");
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(*return_value___errno_location$3);
    fprintf(stderr, return_value_gettext$2, return_value_strerror$4);
    abort();
  }

  return ret;
}

// WRITEALL
// file tree.c line 340
static void WRITEALL(struct anonymous$0 *bio, const void *buf, unsigned long long int len)
{
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(len >= 4097ul)
  {
    flush_buffer(bio);
    write_buf(bio->log, bio->context, bio->fd, bio->off, buf, len);
    bio->off = bio->off + len;
  }

  else
  {
    if(!(bio->off >= bio->bstart))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = bio->off != bio->bstart + bio->dirty ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = bio->off + len > bio->bstart + (unsigned long int)4096 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      flush_buffer(bio);
      bio->bsize = len;
      bio->bstart = bio->off;
    }

    memcpy((void *)&bio->buffer[(signed long int)(bio->off - bio->bstart)], buf, len);
    bio->dirty = bio->dirty + len;
    bio->off = bio->off + len;
    if(!(bio->fsize >= bio->off))
      bio->fsize = bio->off;

  }
}

// WRITEUINT
// file tree.c line 577
static void WRITEUINT(struct anonymous$0 *fd, unsigned int val)
{
  signed char c;
  signed char d;
  unsigned char v[4l];
  unsigned int xval = val;
  c = (signed char)0;
  for( ; val >= 1u; c = c + 1)
    val = val >> 8;
  WRITEALL(fd, (const void *)&c, sizeof(signed char) /*1ul*/ );
  d = (signed char)((signed int)c - 1);
  for( ; (signed int)d >= 0; d = d - 1)
    v[(signed long int)(unsigned char)d] = (unsigned char)(xval >> 8 * (signed int)d);
  WRITEALL(fd, (const void *)&v[(signed long int)0], (unsigned long long int)(signed int)c);
}

// WRITEUINTPAIR
// file tree.c line 519
static void WRITEUINTPAIR(struct anonymous$0 *fd, unsigned int val1, unsigned int val2)
{
  unsigned char c;
  signed char d;
  unsigned char v[4l];
  unsigned int xval = val1;
  c = (unsigned char)0;
  for( ; xval >= 1u; c = c + 1)
    xval = xval >> 8;
  c = (unsigned char)((signed int)c << 4);
  xval = val2;
  for( ; xval >= 1u; c = c + 1)
    xval = xval >> 8;
  WRITEALL(fd, (const void *)&c, sizeof(unsigned char) /*1ul*/ );
  d = (signed char)(((signed int)c & 15) - 1);
  for( ; (signed int)d >= 0; d = d - 1)
    v[(signed long int)(unsigned char)d] = (unsigned char)(val2 >> 8 * (signed int)d);
  WRITEALL(fd, (const void *)&v[(signed long int)0], (unsigned long long int)((signed int)(unsigned char)c & 15));
  d = (signed char)(((signed int)c >> 4) - 1);
  for( ; (signed int)d >= 0; d = d - 1)
    v[(signed long int)(unsigned char)d] = (unsigned char)(val1 >> 8 * (signed int)d);
  WRITEALL(fd, (const void *)&v[(signed long int)0], (unsigned long long int)((signed int)(unsigned char)c >> 4));
}

// WRITEULONG
// file tree.c line 596
static void WRITEULONG(struct anonymous$0 *fd, unsigned long long int val)
{
  signed char c;
  signed char d;
  unsigned char v[8l];
  unsigned long long int xval = val;
  c = (signed char)0;
  for( ; val >= 1ul; c = c + 1)
    val = val >> 8;
  WRITEALL(fd, (const void *)&c, sizeof(signed char) /*1ul*/ );
  d = (signed char)((signed int)c - 1);
  for( ; (signed int)d >= 0; d = d - 1)
    v[(signed long int)(unsigned char)d] = (unsigned char)(xval >> 8 * (signed int)d);
  WRITEALL(fd, (const void *)&v[(signed long int)0], (unsigned long long int)(signed int)c);
}

// WRITEULONGFULL
// file tree.c line 615
static void WRITEULONGFULL(struct anonymous$0 *fd, unsigned long long int val)
{
  unsigned int d;
  unsigned int e;
  unsigned char v[8l];
  d = (unsigned int)0;
  e = (unsigned int)7;
  for( ; !(d >= 8u); e = e - 1u)
  {
    v[(signed long int)d] = (unsigned char)(val >> (unsigned int)8 * e);
    d = d + 1u;
  }
  WRITEALL(fd, (const void *)&v[(signed long int)0], (unsigned long long int)8);
}

// WRITEULONGPAIR
// file tree.c line 548
static void WRITEULONGPAIR(struct anonymous$0 *fd, unsigned long long int val1, unsigned long long int val2)
{
  unsigned char c;
  signed char d;
  unsigned char v[8l];
  unsigned long long int xval = val1;
  c = (unsigned char)0;
  for( ; xval >= 1ul; c = c + 1)
    xval = xval >> 8;
  c = (unsigned char)((signed int)c << 4);
  xval = val2;
  for( ; xval >= 1ul; c = c + 1)
    xval = xval >> 8;
  WRITEALL(fd, (const void *)&c, sizeof(unsigned char) /*1ul*/ );
  d = (signed char)(((signed int)c & 15) - 1);
  for( ; (signed int)d >= 0; d = d - 1)
    v[(signed long int)(unsigned char)d] = (unsigned char)(val2 >> 8 * (signed int)d);
  WRITEALL(fd, (const void *)&v[(signed long int)0], (unsigned long long int)((signed int)(unsigned char)c & 15));
  d = (signed char)(((signed int)c >> 4) - 1);
  for( ; (signed int)d >= 0; d = d - 1)
    v[(signed long int)(unsigned char)d] = (unsigned char)(val1 >> 8 * (signed int)d);
  WRITEALL(fd, (const void *)&v[(signed long int)0], (unsigned long long int)((signed int)(unsigned char)c >> 4));
}

// accumulator
// file index.c line 130
static signed int accumulator(void *cls, const char *plugin_name, enum EXTRACTOR_MetaType type, enum EXTRACTOR_MetaFormat format, const char *data_mime_type, const char *data, unsigned long int data_len)
{
  struct AccuCtx *ac = (struct AccuCtx *)cls;
  unsigned int nsize;
  unsigned int tmp_post$3;
  if(!((signed int)format == EXTRACTOR_METAFORMAT_UTF8) && !((signed int)format == EXTRACTOR_METAFORMAT_C_STRING))
    return 0;

  else
  {
    if(ac->size == ac->count)
    {
      nsize = (unsigned int)4 + (unsigned int)2 * ac->size;
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)ac->types, (unsigned long int)nsize * sizeof(enum EXTRACTOR_MetaType) /*4ul*/ );
      ac->types = (enum EXTRACTOR_MetaType *)return_value_realloc$1;
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)ac->keywords, (unsigned long int)nsize * sizeof(char *) /*8ul*/ );
      ac->keywords = (char **)return_value_realloc$2;
      ac->size = nsize;
    }

    ac->types[(signed long int)ac->count] = type;
    tmp_post$3 = ac->count;
    ac->count = ac->count + 1u;
    ac->keywords[(signed long int)tmp_post$3]=strdup(data);
    return 0;
  }
}

// build
// file doodled.c line 561
static signed int build(const char *libraries, const char *dbName, unsigned long int mem_limit, const char *log, signed int argc, char **argv)
{
  signed int i;
  unsigned int ret;
  struct anonymous$17 cls;
  char *ename;
  struct _IO_FILE *logfile;
  struct PTHREAD_T workerThread;
  void *unused;
  cls.argc = (unsigned int)argc;
  cls.argv = argv;
  cls.deferredCount = (unsigned int)0;
  cls.deferredTruncations = (char **)(void *)0;
  logfile = (struct _IO_FILE *)(void *)0;
  char *return_value_gettext$1;
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  if(!(log == ((const char *)NULL)))
  {
    logfile=fopen(log, "w+");
    if(logfile == ((struct _IO_FILE *)NULL))
    {
      return_value_gettext$1=gettext("Could not open '%s' for logging: %s.\n");
      return_value___errno_location$2=__errno_location();
      return_value_strerror$3=strerror(*return_value___errno_location$2);
      my_log((void *)stderr, (unsigned int)0, return_value_gettext$1, log, return_value_strerror$3);
    }

  }

  cls.logContext = (void *)logfile;
  cls.log = my_log;
  if(dbName == ((const char *)NULL))
  {
    char *return_value_gettext$4;
    return_value_gettext$4=gettext("No database specified.  Aborting.\n");
    my_log((void *)logfile, (unsigned int)0, return_value_gettext$4);
    return -1;
  }

  unsigned long int return_value_strlen$5;
  return_value_strlen$5=strlen(dbName);
  i = (signed int)return_value_strlen$5;
  for( ; i >= 0; i = i - 1)
    if((signed int)dbName[(signed long int)i] == 58)
    {
      char *return_value_gettext$6;
      return_value_gettext$6=gettext("'%s' is an invalid database filename (has a colon) for building database (option '%s').\n");
      my_log((void *)logfile, (unsigned int)0, return_value_gettext$6, dbName, (const void *)"-b");
      return -1;
    }

  ename=expandFileName(dbName);
  if(ename == ((char *)NULL))
    return -1;

  else
  {
    cls.ename = ename;
    cls.tree=DOODLE_tree_create(my_log, (void *)logfile, ename);
    cls.treePresent = (unsigned int)1;
    if(cls.tree == ((struct DOODLE_SuffixTree *)NULL))
      return -1;

    else
    {
      if(!(mem_limit == 0ul))
        DOODLE_tree_set_memory_limit(cls.tree, mem_limit);

      cls.elist=forkExtractor(do_default, libraries, my_log, (void *)logfile);
      if(cls.elist == ((struct EXTRACT_Process *)NULL))
      {
        DOODLE_tree_destroy(cls.tree);
        return -1;
      }

      else
      {
        signed int return_value_FAMOpen2$8;
        return_value_FAMOpen2$8=FAMOpen2(&cls.fc, "doodled");
        if(!(return_value_FAMOpen2$8 == 0))
        {
          char *return_value_gettext$7;
          return_value_gettext$7=gettext("Failed to connect to fam.  Aborting.\n");
          my_log((void *)logfile, (unsigned int)0, return_value_gettext$7);
          DOODLE_tree_destroy(cls.tree);
          return -1;
        }

        cls.fr = (struct FAMRequest *)(void *)0;
        cls.frPos = (unsigned int)0;
        cls.frSize = (unsigned int)0;
        xgrow_((void **)&cls.fr, sizeof(struct FAMRequest) /*4ul*/ , &cls.frSize, (unsigned int)128, "doodled.c", 642);
        cls.frNames = (char **)(void *)0;
        ret = (unsigned int)0;
        xgrow_((void **)&cls.frNames, sizeof(char *) /*8ul*/ , &ret, (unsigned int)128, "doodled.c", 647);
        ret = (unsigned int)0;
        create_mutex_(&cls.lock);
        signed int return_value_PTHREAD_CREATE$12;
        return_value_PTHREAD_CREATE$12=PTHREAD_CREATE(&workerThread, worker, (void *)&cls, (unsigned long int)(64 * 1024));
        if(!(return_value_PTHREAD_CREATE$12 == 0))
        {
          char *return_value_gettext$9;
          return_value_gettext$9=gettext("Failed to create worker thread: %s");
          signed int *return_value___errno_location$10;
          return_value___errno_location$10=__errno_location();
          char *return_value_strerror$11;
          return_value_strerror$11=strerror(*return_value___errno_location$10);
          my_log((void *)logfile, (unsigned int)0, return_value_gettext$9, return_value_strerror$11);
          ret = (unsigned int)-1;
        }

        else
        {
          wait_for_shutdown();
          cls.continueRunning = 0;
          semaphore_up_(cls.signal, "doodled.c", 664);
          PTHREAD_JOIN(&workerThread, &unused);
        }
        destroy_mutex_(&cls.lock);
        char *return_value_gettext$13;
        return_value_gettext$13=gettext("doodled is shutting down.\n");
        my_log((void *)logfile, (unsigned int)1, return_value_gettext$13);
        if(cls.frPos == 0u)
        {
          char *return_value_gettext$14;
          return_value_gettext$14=gettext("No files exist that doodled would monitor for changes.  Exiting.\n");
          my_log((void *)logfile, (unsigned int)0, return_value_gettext$14);
        }

        i = 0;
        for( ; !((unsigned int)i >= cls.frSize); i = i + 1)
          if(!(cls.frNames[(signed long int)i] == ((char *)NULL)))
          {
            char *return_value_gettext$15;
            return_value_gettext$15=gettext("Cancelling fam monitor '%s'.\n");
            my_log((void *)logfile, (unsigned int)1, return_value_gettext$15, cls.frNames[(signed long int)i]);
            free((void *)cls.frNames[(signed long int)i]);
          }

        i = (signed int)(cls.deferredCount - (unsigned int)1);
        for( ; i >= 0; i = i - 1)
          free((void *)cls.deferredTruncations[(signed long int)i]);
        xgrow_((void **)&cls.deferredTruncations, sizeof(char *) /*8ul*/ , &cls.deferredCount, (unsigned int)0, "doodled.c", 693);
        i = (signed int)cls.frSize;
        xgrow_((void **)&cls.fr, sizeof(struct FAMRequest) /*4ul*/ , &cls.frSize, (unsigned int)0, "doodled.c", 697);
        cls.frSize = (unsigned int)i;
        xgrow_((void **)&cls.frNames, sizeof(char *) /*8ul*/ , &cls.frSize, (unsigned int)0, "doodled.c", 701);
        char *return_value_gettext$16;
        return_value_gettext$16=gettext("Unloading libextractor plugins.\n");
        my_log((void *)logfile, (unsigned int)1, return_value_gettext$16);
        joinExtractor(cls.elist);
        free((void *)ename);
        if(!(logfile == ((struct _IO_FILE *)NULL)))
          fclose(logfile);

        return (signed int)ret;
      }
    }
  }
}

// buildIndex
// file helper2.h line 114
signed int buildIndex(struct EXTRACT_Process *eproc, struct _IO_FILE *logFile, const char *filename, struct DOODLE_SuffixTree *tree, signed int do_filenames)
{
  struct KeywordList *head;
  struct KeywordList *pos;
  head=getKeywords(eproc, filename);
  pos = head;
  while(!(pos == ((struct KeywordList *)NULL)))
  {
    char *buildIndex$$1$$1$$cpos;
    unsigned long int slen;
    buildIndex$$1$$1$$cpos = pos->keyword;
    if(!(logFile == ((struct _IO_FILE *)NULL)))
      fprintf(logFile, "%s\n", buildIndex$$1$$1$$cpos);

    slen=strlen(buildIndex$$1$$1$$cpos);
    if(slen >= 129ul)
    {
      char section[129l];
      char *xpos;
      signed int j;
      section[(signed long int)128] = (char)0;
      j = 0;
      for( ; !((unsigned long int)j >= slen); j = j + 128 / 2)
      {
        strncpy(section, &buildIndex$$1$$1$$cpos[(signed long int)j], (unsigned long int)128);
        xpos = &section[(signed long int)0];
        while(!((signed int)*xpos == 0))
        {
          signed int return_value_DOODLE_tree_expand$1;
          return_value_DOODLE_tree_expand$1=DOODLE_tree_expand(tree, xpos, filename);
          if(!(return_value_DOODLE_tree_expand$1 == 0))
          {
            freeKeywords(head);
            return 0;
          }

          xpos = xpos + 1l;
        }
      }
    }

    else
      while(!((signed int)*buildIndex$$1$$1$$cpos == 0))
      {
        signed int return_value_DOODLE_tree_expand$2;
        return_value_DOODLE_tree_expand$2=DOODLE_tree_expand(tree, buildIndex$$1$$1$$cpos, filename);
        if(!(return_value_DOODLE_tree_expand$2 == 0))
        {
          freeKeywords(head);
          return 0;
        }

        buildIndex$$1$$1$$cpos = buildIndex$$1$$1$$cpos + 1l;
      }
    pos = pos->next;
  }
  freeKeywords(head);
  if(!(do_filenames == 0))
  {
    const char *cpos = filename;
    while(!((signed int)*cpos == 0))
    {
      signed int return_value_DOODLE_tree_expand$3;
      return_value_DOODLE_tree_expand$3=DOODLE_tree_expand(tree, cpos, filename);
      if(!(return_value_DOODLE_tree_expand$3 == 0))
        return 0;

      cpos = cpos + 1l;
    }
  }

  return 1;
}

// create_mutex_
// file semaphore.h line 165
void create_mutex_(struct Mutex *mutex)
{
  union anonymous$4 attr;
  union anonymous$5 *mut;
  pthread_mutexattr_init(&attr);
  pthread_mutexattr_setkind_np(&attr, 2);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(union anonymous$5) /*40ul*/ );
  mut = (union anonymous$5 *)return_value_malloc$1;
  mutex->internal = (void *)mut;
  do
  {
    signed int return_value_pthread_mutex_init$2;
    return_value_pthread_mutex_init$2=pthread_mutex_init(mut, &attr);
    if(!(return_value_pthread_mutex_init$2 == 0))
      abort();

  }
  while((_Bool)0);
}

// create_recursive_mutex_
// file semaphore.c line 153
void create_recursive_mutex_(struct Mutex *mutex)
{
  union anonymous$4 attr;
  union anonymous$5 *mut;
  pthread_mutexattr_init(&attr);
  do
  {
    signed int return_value_pthread_mutexattr_setkind_np$1;
    return_value_pthread_mutexattr_setkind_np$1=pthread_mutexattr_setkind_np(&attr, 1);
    if(!(return_value_pthread_mutexattr_setkind_np$1 == 0))
      abort();

  }
  while((_Bool)0);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(union anonymous$5) /*40ul*/ );
  mut = (union anonymous$5 *)return_value_malloc$2;
  mutex->internal = (void *)mut;
  do
  {
    signed int return_value_pthread_mutex_init$3;
    return_value_pthread_mutex_init$3=pthread_mutex_init(mut, &attr);
    if(!(return_value_pthread_mutex_init$3 == 0))
      abort();

  }
  while((_Bool)0);
}

// destroy_mutex_
// file semaphore.h line 168
void destroy_mutex_(struct Mutex *mutex)
{
  union anonymous$5 *mut = (union anonymous$5 *)mutex->internal;
  if(mut == ((union anonymous$5 *)NULL))
    abort();

  else
  {
    mutex->internal = (void *)0;
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 0;
    do
    {
      signed int return_value_pthread_mutex_destroy$2;
      return_value_pthread_mutex_destroy$2=pthread_mutex_destroy(mut);
      if(!(return_value_pthread_mutex_destroy$2 == 0))
        abort();

    }
    while((_Bool)0);
    free((void *)mut);
  }
}

// detachFromTerminal
// file doodled.c line 719
static void detachFromTerminal(signed int *filedes)
{
  signed int pid;
  signed int nullfd;
  signed int return_value_chdir$1;
  return_value_chdir$1=chdir("/");
  if(!(return_value_chdir$1 >= 0))
  {
    perror("chdir");
    exit(1);
  }

  pipe(filedes);
  pid=fork();
  if(!(pid >= 0))
  {
    perror("fork");
    exit(1);
  }

  signed long int return_value_read$2;
  if(!(pid == 0))
  {
    signed int ok;
    char c;
    close(filedes[(signed long int)1]);
    ok = -1;
    do
    {
      return_value_read$2=read(filedes[(signed long int)0], (void *)&c, sizeof(char) /*1ul*/ );
      if(!(return_value_read$2 >= 1l))
        break;

      if((signed int)c == 46)
        ok = 0;

    }
    while((_Bool)1);
    fflush(stdout);
    if(ok == 0)
      exit(0);

    else
      exit(1);
  }

  close(filedes[(signed long int)0]);
  nullfd=open("/dev/null", 0100 | 02 | 02000, 0200 | 0400);
  if(!(nullfd >= 0))
  {
    perror("/dev/null");
    exit(1);
  }

  signed int return_value_dup2$3;
  return_value_dup2$3=dup2(nullfd, 0);
  _Bool tmp_if_expr$5;
  signed int return_value_dup2$4;
  if(!(return_value_dup2$3 >= 0))
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_dup2$4=dup2(nullfd, 1);
    tmp_if_expr$5 = return_value_dup2$4 < 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$7;
  signed int return_value_dup2$6;
  if(tmp_if_expr$5)
    tmp_if_expr$7 = (_Bool)1;

  else
  {
    return_value_dup2$6=dup2(nullfd, 2);
    tmp_if_expr$7 = return_value_dup2$6 < 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$7)
  {
    perror("dup2");
    exit(1);
  }

  pid=setsid();
}

// detachFromTerminalComplete
// file doodled.c line 777
static void detachFromTerminalComplete(signed int *filedes)
{
  char c = (char)46;
  write(filedes[(signed long int)1], (const void *)&c, sizeof(char) /*1ul*/ );
  close(filedes[(signed long int)1]);
}

// do_fork
// file index.c line 159
static signed int do_fork(struct EXTRACT_Process *proc)
{
  signed int filedes1[2l];
  signed int filedes2[2l];
  char buffer[4098l];
  unsigned long int pos;
  signed long int ret;
  unsigned long int slen;
  struct EXTRACTOR_PluginList *list;
  char *filename;
  struct AccuCtx acc_ctx;
  signed int return_value_pipe$4;
  return_value_pipe$4=pipe(filedes1);
  if(!(return_value_pipe$4 == 0))
  {
    char *return_value_gettext$1;
    return_value_gettext$1=gettext("Call to '%s' failed: %s\n");
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    proc->my_log(proc->log_ctx, (unsigned int)0, return_value_gettext$1, (const void *)"pipe", return_value_strerror$3);
    return 1;
  }

  signed int return_value_pipe$8;
  return_value_pipe$8=pipe(filedes2);
  if(!(return_value_pipe$8 == 0))
  {
    char *return_value_gettext$5;
    return_value_gettext$5=gettext("Call to '%s' failed: %s\n");
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    char *return_value_strerror$7;
    return_value_strerror$7=strerror(*return_value___errno_location$6);
    proc->my_log(proc->log_ctx, (unsigned int)0, return_value_gettext$5, (const void *)"pipe", return_value_strerror$7);
    close(filedes1[(signed long int)0]);
    close(filedes1[(signed long int)1]);
    return 1;
  }

  char *return_value_gettext$9;
  if(!(proc->do_default == 0))
  {
    return_value_gettext$9=gettext("Loading default set of libextractor plugins.\n");
    proc->my_log(proc->log_ctx, (unsigned int)2, return_value_gettext$9);
  }

  char *return_value_gettext$10;
  if(!(proc->libs == ((char *)NULL)))
  {
    return_value_gettext$10=gettext("Loading libextractor plugins: '%s'\n");
    proc->my_log(proc->log_ctx, (unsigned int)2, return_value_gettext$10, proc->libs);
  }

  proc->pid=fork();
  if(proc->pid == -1)
  {
    char *return_value_gettext$11;
    return_value_gettext$11=gettext("Call to '%s' failed: %s\n");
    signed int *return_value___errno_location$12;
    return_value___errno_location$12=__errno_location();
    char *return_value_strerror$13;
    return_value_strerror$13=strerror(*return_value___errno_location$12);
    proc->my_log(proc->log_ctx, (unsigned int)0, return_value_gettext$11, (const void *)"fork", return_value_strerror$13);
    close(filedes1[(signed long int)0]);
    close(filedes1[(signed long int)1]);
    close(filedes2[(signed long int)0]);
    close(filedes2[(signed long int)1]);
    return 1;
  }

  unsigned int tmp_post$16;
  if(!(proc->pid == 0))
  {
    close(filedes1[(signed long int)1]);
    close(filedes2[(signed long int)0]);
    proc->send_pipe = filedes2[(signed long int)1];
    proc->read_pipe = filedes1[(signed long int)0];
    return 0;
  }

  else
  {
    close(filedes1[(signed long int)0]);
    close(filedes2[(signed long int)1]);
    list = (struct EXTRACTOR_PluginList *)(void *)0;
    if(!(proc->do_default == 0))
      list=EXTRACTOR_plugin_add_defaults((enum EXTRACTOR_Options)EXTRACTOR_OPTION_DEFAULT_POLICY);

    if(!(proc->libs == ((char *)NULL)))
      list=EXTRACTOR_plugin_add_config(list, proc->libs, (enum EXTRACTOR_Options)EXTRACTOR_OPTION_DEFAULT_POLICY);

    pos = (unsigned long int)0;
    buffer[(signed long int)(4096 + 1)] = (char)0;
    ret=read(filedes2[(signed long int)0], (void *)&buffer[(signed long int)pos], (unsigned long int)(4096 + 1) - pos);
    while(!(ret == 0l) && !(ret == -1l))
    {
      pos = pos + (unsigned long int)ret;
      unsigned long int return_value_strlen$14;
      return_value_strlen$14=strlen(buffer);
      slen = return_value_strlen$14 + (unsigned long int)1;
      if(pos >= slen)
      {
        filename=strdup(buffer);
        memmove((void *)buffer, (const void *)&buffer[(signed long int)slen], pos - slen);
        pos = pos - slen;
        acc_ctx.count = (unsigned int)0;
        acc_ctx.size = (unsigned int)0;
        acc_ctx.keywords = (char **)(void *)0;
        acc_ctx.types = (enum EXTRACTOR_MetaType *)(void *)0;
        EXTRACTOR_extract(list, filename, (void *)0, (unsigned long int)0, accumulator, (void *)&acc_ctx);
        signed long int return_value_write$15;
        return_value_write$15=write(filedes1[(signed long int)1], (const void *)&acc_ctx.count, sizeof(unsigned int) /*4ul*/ );
        if(!((unsigned long int)return_value_write$15 == sizeof(unsigned int) /*4ul*/ ))
          break;

        do
        {
          tmp_post$16 = acc_ctx.count;
          acc_ctx.count = acc_ctx.count - 1u;
          if(tmp_post$16 == 0u)
            break;

          signed long int return_value_write$17;
          return_value_write$17=write(filedes1[(signed long int)1], (const void *)&acc_ctx.types[(signed long int)acc_ctx.count], sizeof(enum EXTRACTOR_MetaType) /*4ul*/ );
          if(!((unsigned long int)return_value_write$17 == sizeof(enum EXTRACTOR_MetaType) /*4ul*/ ))
            goto ERROR;

          slen=strlen(acc_ctx.keywords[(signed long int)acc_ctx.count]);
          if(slen >= 16777217ul)
            slen = (unsigned long int)(16 * 1024 * 1024);

          signed long int return_value_write$18;
          return_value_write$18=write(filedes1[(signed long int)1], (const void *)&slen, sizeof(unsigned long int) /*8ul*/ );
          if(!((unsigned long int)return_value_write$18 == sizeof(unsigned long int) /*8ul*/ ))
            goto ERROR;

          signed long int return_value_write$19;
          return_value_write$19=write(filedes1[(signed long int)1], (const void *)acc_ctx.keywords[(signed long int)acc_ctx.count], slen);
          if(!(slen == (unsigned long int)return_value_write$19))
            goto ERROR;

          free((void *)acc_ctx.keywords[(signed long int)acc_ctx.count]);
        }
        while((_Bool)1);
        free((void *)acc_ctx.keywords);
        free((void *)acc_ctx.types);
        acc_ctx.keywords = (char **)(void *)0;
        acc_ctx.types = (enum EXTRACTOR_MetaType *)(void *)0;
        acc_ctx.size = (unsigned int)0;
      }

      ret=read(filedes2[(signed long int)0], (void *)&buffer[(signed long int)pos], (unsigned long int)(4096 + 1) - pos);
    }

  ERROR:
    ;
    free((void *)acc_ctx.keywords);
    free((void *)acc_ctx.types);
    EXTRACTOR_plugin_remove_all(list);
    close(filedes2[(signed long int)0]);
    close(filedes1[(signed long int)1]);
    exit(0);
    return 1;
  }
}

// do_index
// file doodled.c line 280
static signed int do_index(const char *filename, struct anonymous$17 *dic)
{
  signed int i;
  signed int j;
  signed int k;
  struct stat sbuf;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(dic->ename);
  signed int return_value_strncmp$2;
  return_value_strncmp$2=strncmp(filename, dic->ename, return_value_strlen$1);
  if(return_value_strncmp$2 == 0)
    return 0;

  else
  {
    signed int return_value_isPruned$3;
    return_value_isPruned$3=isPruned(filename);
    if(!(return_value_isPruned$3 == 0))
      return 0;

    else
    {
      i = (signed int)(dic->deferredCount - (unsigned int)1);
      for( ; i >= 0; i = i - 1)
      {
        signed int return_value_strcmp$4;
        return_value_strcmp$4=strcmp(filename, dic->deferredTruncations[(signed long int)i]);
        if(return_value_strcmp$4 == 0)
        {
          free((void *)dic->deferredTruncations[(signed long int)i]);
          dic->deferredTruncations[(signed long int)i] = dic->deferredTruncations[(signed long int)(dic->deferredCount - (unsigned int)1)];
          xgrow_((void **)&dic->deferredTruncations, sizeof(char *) /*8ul*/ , &dic->deferredCount, dic->deferredCount - (unsigned int)1, "doodled.c", 302);
        }

      }
      j = -1;
      unsigned int return_value_DOODLE_getFileCount$5;
      return_value_DOODLE_getFileCount$5=DOODLE_getFileCount(dic->tree);
      i = (signed int)(return_value_DOODLE_getFileCount$5 - (unsigned int)1);
      for( ; i >= 0; i = i - 1)
      {
        const struct anonymous *return_value_DOODLE_getFileAt$6;
        return_value_DOODLE_getFileAt$6=DOODLE_getFileAt(dic->tree, (unsigned int)i);
        signed int return_value_strcmp$7;
        return_value_strcmp$7=strcmp(filename, return_value_DOODLE_getFileAt$6->filename);
        if(return_value_strcmp$7 == 0)
        {
          j = i;
          break;
        }

      }
      k = -1;
      i = 0;
      for( ; !((unsigned int)i >= dic->frPos); i = i + 1)
      {
        signed int return_value_strcmp$8;
        return_value_strcmp$8=strcmp(filename, dic->frNames[(signed long int)i]);
        if(return_value_strcmp$8 == 0)
        {
          k = i;
          break;
        }

      }
      signed int return_value_lstat$14;
      return_value_lstat$14=lstat(filename, &sbuf);
      if(!(return_value_lstat$14 == 0))
      {
        char *return_value_gettext$9;
        return_value_gettext$9=gettext("Call to '%s' for file '%s' failed: %s\n");
        signed int *return_value___errno_location$10;
        return_value___errno_location$10=__errno_location();
        char *return_value_strerror$11;
        return_value_strerror$11=strerror(*return_value___errno_location$10);
        dic->log(dic->logContext, (unsigned int)2, return_value_gettext$9, (const void *)"stat", filename, return_value_strerror$11);
        if(!(j == -1))
        {
          xgrow_((void **)&dic->deferredTruncations, sizeof(char *) /*8ul*/ , &dic->deferredCount, dic->deferredCount + (unsigned int)1, "doodled.c", 336);
          dic->deferredTruncations[(signed long int)(dic->deferredCount - (unsigned int)1)]=strdup(filename);
        }

        if(!(k == -1))
        {
          signed int return_value_FAMCancelMonitor$13;
          return_value_FAMCancelMonitor$13=FAMCancelMonitor(&dic->fc, &dic->fr[(signed long int)k]);
          if(return_value_FAMCancelMonitor$13 == -1)
          {
            char *return_value_gettext$12;
            return_value_gettext$12=gettext("Call to '%s' for file '%s' failed: %s\n");
            dic->log(dic->logContext, (unsigned int)0, return_value_gettext$12, (const void *)"FAMCancelMonitor", filename, FamErrlist[(signed long int)FAMErrno]);
          }

          free((void *)dic->frNames[(signed long int)k]);
          dic->fr[(signed long int)k] = dic->fr[(signed long int)(dic->frPos - (unsigned int)1)];
          dic->frNames[(signed long int)k] = dic->frNames[(signed long int)(dic->frPos - (unsigned int)1)];
          dic->frNames[(signed long int)(dic->frPos - (unsigned int)1)] = (char *)(void *)0;
          dic->frPos = dic->frPos - 1u;
        }

        return 0;
      }

      if((61440u & sbuf.st_mode) == 16384u && k == -1 && !((61440u & sbuf.st_mode) == 40960u) && !((61440u & sbuf.st_mode) == 49152u))
      {
        char *fn;
        if(dic->frPos == dic->frSize)
        {
          unsigned int s = dic->frSize;
          xgrow_((void **)&dic->fr, sizeof(struct FAMRequest) /*4ul*/ , &dic->frSize, dic->frSize * (unsigned int)2, "doodled.c", 372);
          xgrow_((void **)&dic->frNames, sizeof(char *) /*8ul*/ , &s, s * (unsigned int)2, "doodled.c", 375);
        }

        char *return_value_gettext$15;
        return_value_gettext$15=gettext("Will monitor directory '%s' for changes.\n");
        dic->log(dic->logContext, (unsigned int)2, return_value_gettext$15, filename);
        fn=STRDUP(filename);
        signed int return_value_FAMMonitorDirectory$17;
        return_value_FAMMonitorDirectory$17=FAMMonitorDirectory(&dic->fc, filename, &dic->fr[(signed long int)dic->frPos], (void *)fn);
        if(return_value_FAMMonitorDirectory$17 == 0)
        {
          dic->frNames[(signed long int)dic->frPos] = fn;
          dic->frPos = dic->frPos + 1u;
        }

        else
        {
          char *return_value_gettext$16;
          return_value_gettext$16=gettext("Call to '%s' for file '%s' failed: %s\n");
          dic->log(dic->logContext, (unsigned int)0, return_value_gettext$16, (const void *)"FAMMonitorDirectory", filename, FamErrlist[(signed long int)FAMErrno]);
          free((void *)fn);
        }
      }

      if(!(j == -1))
      {
        const struct anonymous *return_value_DOODLE_getFileAt$18;
        return_value_DOODLE_getFileAt$18=DOODLE_getFileAt(dic->tree, (unsigned int)j);
        if(return_value_DOODLE_getFileAt$18->mod_time == (unsigned int)sbuf.st_mtim.tv_sec)
          return 0;

        else
        {
          xgrow_((void **)&dic->deferredTruncations, sizeof(char *) /*8ul*/ , &dic->deferredCount, dic->deferredCount + (unsigned int)2, "doodled.c", 409);
          dic->deferredTruncations[(signed long int)(dic->deferredCount - (unsigned int)2)]=strdup(filename);
          DOODLE_tree_truncate_multiple(dic->tree, (const char **)dic->deferredTruncations);
          i = (signed int)(dic->deferredCount - (unsigned int)2);
          for( ; i >= 0; i = i - 1)
            free((void *)dic->deferredTruncations[(signed long int)i]);
          xgrow_((void **)&dic->deferredTruncations, sizeof(char *) /*8ul*/ , &dic->deferredCount, (unsigned int)0, "doodled.c", 419);
        }
      }

      if((61440u & sbuf.st_mode) == 32768u)
      {
        char *return_value_gettext$19;
        return_value_gettext$19=gettext("Processing file '%s'.\n");
        dic->log(dic->logContext, (unsigned int)2, return_value_gettext$19, filename);
        signed int return_value_buildIndex$20;
        return_value_buildIndex$20=buildIndex(dic->elist, (struct _IO_FILE *)(void *)0, filename, dic->tree, do_filenames);
        return return_value_buildIndex$20;
      }

      return 0;
    }
  }
}

// do_read
// file index.c line 91
static signed int do_read(signed int fd, void *d, unsigned long int len)
{
  unsigned long int pos;
  signed long int ret;
  char *data = (char *)d;
  pos = (unsigned long int)0;
  ret=read(fd, (void *)&data[(signed long int)pos], len - pos);
  while(ret >= 1l && !(ret == -1l))
  {
    pos = pos + (unsigned long int)ret;
    if(pos == len)
      return 0;

    ret=read(fd, (void *)&data[(signed long int)pos], len - pos);
  }
  if(ret == 0l)
    close(fd);

  return 1;
}

// doneShutdownHandlers
// file shutdown.h line 54
void doneShutdownHandlers()
{
  struct sigaction sig;
  struct sigaction oldsig;
  sig.__sigaction_handler.sa_handler = (void (*)(signed int))0;
  sigemptyset(&sig.sa_mask);
  sig.sa_flags = 0x20000000;
  sigaction(2, &sig, &oldsig);
  sigaction(15, &sig, &oldsig);
  sigaction(3, &sig, &oldsig);
  semaphore_free_(shutdown_signal, "shutdown.c", 137);
  shutdown_signal = (struct Semaphore *)(void *)0;
}

// expandFileName
// file helper2.h line 70
char * expandFileName(const char *fil)
{
  char buffer[512l];
  char *fn;
  char *fm;
  const char *fil_ptr;
  if(fil == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    if((signed int)*fil == 47)
    {
      char *return_value_STRDUP$1;
      return_value_STRDUP$1=STRDUP(fil);
      return return_value_STRDUP$1;
    }

    if((signed int)*fil == 126)
    {
      fm=getenv("HOME");
      if(fm == ((char *)NULL))
        fm = "$HOME";

      fil_ptr = fil + (signed long int)1;
      if((signed int)*fil_ptr == 47)
        fil_ptr = fil_ptr + 1l;

    }

    else
    {
      fil_ptr = fil;
      char *return_value_getcwd$2;
      return_value_getcwd$2=getcwd(buffer, (unsigned long int)512);
      if(!(return_value_getcwd$2 == ((char *)NULL)))
        fm = buffer;

      else
        fm = "$PWD";
    }
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(fm);
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(fil_ptr);
    void *return_value_MALLOC$5;
    return_value_MALLOC$5=MALLOC(return_value_strlen$3 + (unsigned long int)1 + return_value_strlen$4 + (unsigned long int)1);
    fn = (char *)return_value_MALLOC$5;
    sprintf(fn, "%s/%s", fm, fil_ptr);
    return fn;
  }
}

// flush_buffer
// file tree.c line 257
static void flush_buffer(struct anonymous$0 *bio)
{
  if(!(bio->dirty == 0ull))
  {
    write_buf(bio->log, bio->context, bio->fd, bio->bstart, (const void *)bio->buffer, bio->dirty);
    bio->dirty = (unsigned long long int)0;
  }

}

// forkExtractor
// file helper2.h line 101
struct EXTRACT_Process * forkExtractor(signed int do_default, const char *libraries, void (*logger)(void *, unsigned int, const char *, ...), void *log_ct)
{
  struct EXTRACT_Process *ret;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct EXTRACT_Process) /*40ul*/ );
  ret = (struct EXTRACT_Process *)return_value_malloc$1;
  if(!(libraries == ((const char *)NULL)))
    ret->libs=strdup(libraries);

  else
    ret->libs = (char *)(void *)0;
  ret->do_default = do_default;
  ret->pid = -1;
  ret->send_pipe = -1;
  ret->read_pipe = -1;
  ret->my_log = logger;
  ret->log_ctx = log_ct;
  return ret;
}

// formatHelp
// file helper2.h line 55
void formatHelp(const char *general, const char *description, const struct anonymous$1 *opt)
{
  signed int slen;
  signed int i;
  signed int j;
  signed int ml;
  signed int p;
  char *scp;
  const char *trans;
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Usage: %s\n%s\n\n");
  char *return_value_gettext$2;
  return_value_gettext$2=gettext(general);
  char *return_value_gettext$3;
  return_value_gettext$3=gettext(description);
  printf(return_value_gettext$1, return_value_gettext$2, return_value_gettext$3);
  char *return_value_gettext$4;
  return_value_gettext$4=gettext("Arguments mandatory for long options are also mandatory for short options.\n");
  printf(return_value_gettext$4);
  slen = 0;
  i = 0;
  while(!((opt + (signed long int)i)->description == ((char *)NULL)))
  {
    if((signed int)(opt + (signed long int)i)->shortArg == 0)
      printf("      ");

    else
      printf("  -%c, ", (opt + (signed long int)i)->shortArg);
    printf("--%s", (opt + (signed long int)i)->longArg);
    unsigned long int return_value_strlen$5;
    return_value_strlen$5=strlen((opt + (signed long int)i)->longArg);
    slen = (signed int)((unsigned long int)8 + return_value_strlen$5);
    if(!((opt + (signed long int)i)->mandatoryArg == ((char *)NULL)))
    {
      printf("=%s", (opt + (signed long int)i)->mandatoryArg);
      unsigned long int return_value_strlen$6;
      return_value_strlen$6=strlen((opt + (signed long int)i)->mandatoryArg);
      slen = slen + (signed int)((unsigned long int)1 + return_value_strlen$6);
    }

    if(slen >= 30)
    {
      printf("\n%*s", 29, (const void *)"");
      slen = 29;
    }

    if(!(slen >= 29))
    {
      printf("%*s", 29 - slen, (const void *)"");
      slen = 29;
    }

    trans=gettext((opt + (signed long int)i)->description);
    unsigned long int return_value_strlen$7;
    return_value_strlen$7=strlen(trans);
    ml = (signed int)return_value_strlen$7;
    p = 0;

  OUTER:
    ;
    while(!(78 + -slen >= ml + -p))
    {
      j = (p + 78) - slen;
      for( ; !(p >= j); j = j - 1)
      {
        const unsigned short int **return_value___ctype_b_loc$9;
        return_value___ctype_b_loc$9=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)trans[(signed long int)j]]) == 0))
        {
          void *return_value_MALLOC$8;
          return_value_MALLOC$8=MALLOC((unsigned long int)((j - p) + 1));
          scp = (char *)return_value_MALLOC$8;
          memcpy((void *)scp, (const void *)&trans[(signed long int)p], (unsigned long int)(j - p));
          scp[(signed long int)(j - p)] = (char)0;
          printf("%s\n%*s", scp, 29 + 2, (const void *)"");
          free((void *)scp);
          p = j + 1;
          slen = 29 + 2;
          goto OUTER;
        }

      }
      void *return_value_MALLOC$10;
      return_value_MALLOC$10=MALLOC((unsigned long int)((78 - slen) + 1));
      scp = (char *)return_value_MALLOC$10;
      memcpy((void *)scp, (const void *)&trans[(signed long int)p], (unsigned long int)(78 - slen));
      scp[(signed long int)(78 - slen)] = (char)0;
      printf("%s\n%*s", scp, 29 + 2, (const void *)"");
      free((void *)scp);
      slen = 29 + 2;
      p = (p + 78) - slen;
    }
    if(!(p >= ml))
      printf("%s\n", &trans[(signed long int)p]);

    i = i + 1;
  }
}

// freeKeywords
// file index.c line 301
static void freeKeywords(struct KeywordList *keywords)
{
  struct KeywordList *prev;
  while(!(keywords == ((struct KeywordList *)NULL)))
  {
    prev = keywords;
    keywords = keywords->next;
    free((void *)prev->keyword);
    free((void *)prev);
  }
}

// freeNode
// file tree.c line 877
static void freeNode(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *node)
{
  struct DOODLE_Node *last;
  struct DOODLE_Node *tmp;
  signed int mls;
  while(!(node == ((struct DOODLE_Node *)NULL)))
  {
    mls = 0;
    for( ; !(mls >= (signed int)node->mls_size); mls = mls + 1)
    {
      if(!((node + (signed long int)mls)->child == ((struct DOODLE_Node *)NULL)))
      {
        tmp = (node + (signed long int)mls)->child;
        (node + (signed long int)mls)->child = (struct DOODLE_Node *)(void *)0;
        freeNode(tree, tmp);
      }

      if(!((node + (signed long int)mls)->matches == ((unsigned int *)NULL)))
        free((void *)(node + (signed long int)mls)->matches);

    }
    last = node;
    node = (node + (signed long int)((signed int)last->mls_size - 1))->link;
    tree->used_memory = tree->used_memory - sizeof(struct DOODLE_Node) /*80ul*/  * (unsigned long int)last->mls_size;
    free((void *)last);
  }
}

// getKeywords
// file index.c line 316
static struct KeywordList * getKeywords(struct EXTRACT_Process *eproc, const char *filename)
{
  struct KeywordList *pos;
  struct KeywordList *next;
  struct KeywordList *head;
  unsigned int count;
  unsigned long int slen;
  signed int status;
  signed int return_value_do_fork$1;
  signed int return_value_do_read$5;
  unsigned int tmp_post$6;
  if(eproc->pid == -1)
  {
    return_value_do_fork$1=do_fork(eproc);
    if(return_value_do_fork$1 == 0)
      goto __CPROVER_DUMP_L1;

    return (struct KeywordList *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(eproc->pid == -1)
      return (struct KeywordList *)(void *)0;

    else
    {
      fprintf(stderr, "Processing file %s\n", filename);
      head = (struct KeywordList *)(void *)0;
      pos = (struct KeywordList *)(void *)0;
      next = (struct KeywordList *)(void *)0;
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(filename);
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(filename);
      signed long int return_value_write$4;
      return_value_write$4=write(eproc->send_pipe, (const void *)filename, return_value_strlen$3 + (unsigned long int)1);
      if(1ul + return_value_strlen$2 == (unsigned long int)return_value_write$4)
      {
        return_value_do_read$5=do_read(eproc->read_pipe, (void *)&count, sizeof(unsigned int) /*4ul*/ );
        if(!(return_value_do_read$5 == 0))
          goto ERROR;

        do
        {
          tmp_post$6 = count;
          count = count - 1u;
          if(!(tmp_post$6 >= 1u))
            break;

          void *return_value_malloc$7;
          return_value_malloc$7=malloc(sizeof(struct KeywordList) /*24ul*/ );
          next = (struct KeywordList *)return_value_malloc$7;
          signed int return_value_do_read$8;
          return_value_do_read$8=do_read(eproc->read_pipe, (void *)&next->keywordType, sizeof(enum EXTRACTOR_MetaType) /*4ul*/ );
          if(!(return_value_do_read$8 == 0))
            goto ERROR;

          signed int return_value_do_read$9;
          return_value_do_read$9=do_read(eproc->read_pipe, (void *)&slen, sizeof(unsigned long int) /*8ul*/ );
          if(!(return_value_do_read$9 == 0))
            goto ERROR;

          if(slen == 0ul)
          {
            free((void *)next);
            next = (struct KeywordList *)(void *)0;
          }

          else
          {
            if(slen >= 16777217ul)
              goto ERROR;

            if(pos == ((struct KeywordList *)NULL))
            {
              pos = next;
              next = (struct KeywordList *)(void *)0;
              head = pos;
            }

            else
            {
              pos->next = next;
              next = (struct KeywordList *)(void *)0;
              pos = pos->next;
            }
            pos->next = (struct KeywordList *)(void *)0;
            void *return_value_malloc$10;
            return_value_malloc$10=malloc(slen + (unsigned long int)1);
            pos->keyword = (char *)return_value_malloc$10;
            pos->keyword[(signed long int)slen] = (char)0;
            signed int return_value_do_read$11;
            return_value_do_read$11=do_read(eproc->read_pipe, (void *)pos->keyword, slen);
            if(!(return_value_do_read$11 == 0))
              goto ERROR;

          }
        }
        while((_Bool)1);
        return head;
      }

      else
      {

      ERROR:
        ;
        if(!(next == ((struct KeywordList *)NULL)))
          free((void *)next);

        freeKeywords(head);
        if(!(eproc->send_pipe == -1))
          close(eproc->send_pipe);

        eproc->send_pipe = -1;
        if(!(eproc->read_pipe == -1))
          close(eproc->read_pipe);

        eproc->read_pipe = -1;
        if(!(eproc->pid == -1))
        {
          kill(eproc->pid, 15);
          waitpid(eproc->pid, &status, 0);
        }

        eproc->pid = -1;
        return (struct KeywordList *)(void *)0;
      }
    }
  }
}

// initializeShutdownHandlers
// file shutdown.h line 47
void initializeShutdownHandlers()
{
  struct sigaction sig;
  struct sigaction oldsig;
  if(!(shutdown_signal == ((struct Semaphore *)NULL)))
    abort();

  shutdown_signal=semaphore_new_(0, "shutdown.c", 93);
  shutdown_active = 0;
  sig.__sigaction_handler.sa_handler = run_shutdown;
  sigemptyset(&sig.sa_mask);
  sig.sa_flags = 0x20000000;
  sigaction(2, &sig, &oldsig);
  sigaction(15, &sig, &oldsig);
  sigaction(3, &sig, &oldsig);
}

// isPruned
// file doodled.c line 96
static signed int isPruned(const char *filename)
{
  signed int i;
  signed int last;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(prunepaths);
  i = (signed int)return_value_strlen$1;
  last = i;
  while(i >= 1)
  {
    for( ; !((signed int)prunepaths[(signed long int)i] == 32); i = i - 1)
      if(!(i >= 0))
        break;

    signed int return_value_strncmp$2;
    return_value_strncmp$2=strncmp(&prunepaths[(signed long int)(i + 1)], filename, (unsigned long int)(last - (i + 1)));
    if(return_value_strncmp$2 == 0)
      return 1;

    last = i;
    i = i - 1;
  }
  return 0;
}

// joinExtractor
// file helper2.h line 106
void joinExtractor(struct EXTRACT_Process *proc)
{
  signed int status;
  if(!(proc->send_pipe == -1))
    close(proc->send_pipe);

  if(!(proc->read_pipe == -1))
    close(proc->read_pipe);

  if(!(proc->pid == -1))
  {
    kill(proc->pid, 15);
    waitpid(proc->pid, &status, 0);
  }

  if(!(proc->libs == ((char *)NULL)))
    free((void *)proc->libs);

  free((void *)proc);
}

// lazyReadNode
// file tree.c line 1094
static struct DOODLE_Node * lazyReadNode(struct DOODLE_SuffixTree *tree, unsigned long long int off)
{
  struct DOODLE_Node *ret;
  signed int i;
  unsigned long long int off_link;
  unsigned long long int off_child;
  unsigned char c_length;
  unsigned char mls_size;
  signed int mls;
  _Bool tmp_if_expr$9;
  unsigned long int return_value_strlen$8;
  _Bool tmp_if_expr$15;
  if(off == 0ul)
    return (struct DOODLE_Node *)(void *)0;

  else
  {
    LSEEK(tree->fd, off, 0);
    signed int return_value_READALL$1;
    return_value_READALL$1=READALL(tree->fd, (void *)&c_length, sizeof(signed char) /*1ul*/ );
    if(return_value_READALL$1 == -1)
      return (struct DOODLE_Node *)(void *)0;

    else
    {
      if((signed int)c_length == 0)
      {
        signed int return_value_READALL$2;
        return_value_READALL$2=READALL(tree->fd, (void *)&mls_size, sizeof(signed char) /*1ul*/ );
        if(return_value_READALL$2 == -1)
          return (struct DOODLE_Node *)(void *)0;

        if((signed int)mls_size == 0)
        {
          char *return_value_gettext$3;
          return_value_gettext$3=gettext("Assertion failed at %s:%d.\nDatabase format error!\n");
          tree->log(tree->context, (unsigned int)0, return_value_gettext$3, (const void *)"tree.c", 1120);
          return (struct DOODLE_Node *)(void *)0;
        }

      }

      else
        mls_size = (unsigned char)1;
      void *return_value_MALLOC$4;
      return_value_MALLOC$4=MALLOC(sizeof(struct DOODLE_Node) /*80ul*/  * (unsigned long int)mls_size);
      ret = (struct DOODLE_Node *)return_value_MALLOC$4;
      (ret + (signed long int)0)->pos = off;
      mls = 0;
      for( ; !(mls >= (signed int)mls_size); mls = mls + 1)
      {
        (ret + (signed long int)mls)->clength = c_length;
        (ret + (signed long int)mls)->mls_size = (unsigned char)((signed int)mls_size - mls);
        if(mls >= 1)
        {
          (ret + (signed long int)(mls - 1))->link_off = (unsigned long long int)0;
          (ret + (signed long int)(mls - 1))->link = &ret[(signed long int)mls];
          (ret + (signed long int)mls)->parent = &ret[(signed long int)(mls - 1)];
        }

        if((signed int)(ret + (signed long int)mls)->clength == 0)
        {
          char c;
          if(mls == 0)
          {
            signed int return_value_READALL$5;
            return_value_READALL$5=READALL(tree->fd, (void *)&c, sizeof(unsigned char) /*1ul*/ );
            if(return_value_READALL$5 == -1)
              goto ERROR_ABORT;

          }

          else
            c = (char)((signed int)(ret + (signed long int)(mls - 1))->c[(signed long int)0] + 1);
          (ret + (signed long int)mls)->c = &CIS[(signed long int)(unsigned char)c];
          (ret + (signed long int)mls)->clength = (unsigned char)1;
        }

        else
        {
          unsigned int cix;
          unsigned int ciy;
          signed int return_value_READUINTPAIR$6;
          return_value_READUINTPAIR$6=READUINTPAIR(tree->fd, &cix, &ciy);
          if(return_value_READUINTPAIR$6 == -1)
            goto ERROR_ABORT;

          if(cix >= tree->cisLen)
            tmp_if_expr$9 = (_Bool)1;

          else
          {
            return_value_strlen$8=strlen(tree->cis[(signed long int)cix]);
            tmp_if_expr$9 = (unsigned long int)ciy >= return_value_strlen$8 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$9)
          {
            char *return_value_gettext$7;
            return_value_gettext$7=gettext("Assertion failed at %s:%d.\nDatabase format error!\n");
            tree->log(tree->context, (unsigned int)0, return_value_gettext$7, (const void *)"tree.c", 1161);
          }

          (ret + (signed long int)mls)->c = &tree->cis[(signed long int)cix][(signed long int)ciy];
          (ret + (signed long int)mls)->cix = (signed int)cix;
        }
        if(mls == (signed int)mls_size + -1)
        {
          signed int return_value_READULONGPAIR$10;
          return_value_READULONGPAIR$10=READULONGPAIR(tree->fd, &off_link, &off_child);
          if(return_value_READULONGPAIR$10 == -1)
            goto ERROR_ABORT;

          if(!(off >= off_child) || !(off >= off_link))
          {
            char *return_value_gettext$11;
            return_value_gettext$11=gettext("Assertion failed at %s:%d.\nDatabase format error!\n");
            tree->log(tree->context, (unsigned int)0, return_value_gettext$11, (const void *)"tree.c", 1182);
          }

          if(!(off_link == 0ul))
            off_link = off - off_link;

          if(!(off_child == 0ul))
            off_child = off - off_child;

        }

        else
        {
          off_link = (unsigned long long int)0;
          signed int return_value_READULONG$12;
          return_value_READULONG$12=READULONG(tree->fd, &off_child);
          if(return_value_READULONG$12 == -1)
            goto ERROR_ABORT;

          if(!(off >= off_child))
          {
            char *return_value_gettext$13;
            return_value_gettext$13=gettext("Assertion failed at %s:%d.\nDatabase format error!\n");
            tree->log(tree->context, (unsigned int)0, return_value_gettext$13, (const void *)"tree.c", 1201);
          }

          off_child = off - off_child;
        }
        (ret + (signed long int)mls)->link_off = off_link;
        (ret + (signed long int)mls)->next_off = off_child;
        if(!(tree->fd->fsize >= (ret + (signed long int)mls)->link_off))
          tmp_if_expr$15 = (_Bool)1;

        else
          tmp_if_expr$15 = (ret + (signed long int)mls)->next_off > tree->fd->fsize ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$15)
        {
          char *return_value_gettext$14;
          return_value_gettext$14=gettext("Assertion failed at %s:%d.\nDatabase format error!\n");
          tree->log(tree->context, (unsigned int)0, return_value_gettext$14, (const void *)"tree.c", 1214);
        }

        signed int return_value_READUINT$16;
        return_value_READUINT$16=READUINT(tree->fd, &(ret + (signed long int)mls)->matchCount);
        if(return_value_READUINT$16 == -1)
          goto ERROR_ABORT;

        if((ret + (signed long int)mls)->matchCount == 0u)
          (ret + (signed long int)mls)->matches = (unsigned int *)(void *)0;

        else
        {
          void *return_value_MALLOC$17;
          return_value_MALLOC$17=MALLOC((unsigned long int)(ret + (signed long int)mls)->matchCount * sizeof(unsigned int) /*4ul*/ );
          (ret + (signed long int)mls)->matches = (unsigned int *)return_value_MALLOC$17;
          i = (signed int)((ret + (signed long int)mls)->matchCount / (unsigned int)2 - (unsigned int)1);
          for( ; i >= 0; i = i - 1)
          {
            unsigned int idx1;
            unsigned int idx2;
            signed int return_value_READUINTPAIR$18;
            return_value_READUINTPAIR$18=READUINTPAIR(tree->fd, &idx1, &idx2);
            if(return_value_READUINTPAIR$18 == -1)
              goto ERROR_ABORT;

            if(idx1 >= tree->fnc)
            {
              char *return_value_gettext$19;
              return_value_gettext$19=gettext("Assertion failed at %s:%d.\nDatabase format error!\n");
              tree->log(tree->context, (unsigned int)0, return_value_gettext$19, (const void *)"tree.c", 1236);
            }

            if(idx2 >= tree->fnc)
            {
              char *return_value_gettext$20;
              return_value_gettext$20=gettext("Assertion failed at %s:%d.\nDatabase format error!\n");
              tree->log(tree->context, (unsigned int)0, return_value_gettext$20, (const void *)"tree.c", 1243);
            }

            (ret + (signed long int)mls)->matches[(signed long int)(i * 2 + 1)] = idx1;
            (ret + (signed long int)mls)->matches[(signed long int)(i * 2)] = idx2;
          }
          if((1u & (ret + (signed long int)mls)->matchCount) == 1u)
          {
            unsigned int idx;
            signed int return_value_READUINT$21;
            return_value_READUINT$21=READUINT(tree->fd, &idx);
            if(return_value_READUINT$21 == -1)
              goto ERROR_ABORT;

            if(idx >= tree->fnc)
            {
              char *return_value_gettext$22;
              return_value_gettext$22=gettext("Assertion failed at %s:%d.\nDatabase format error!\n");
              tree->log(tree->context, (unsigned int)0, return_value_gettext$22, (const void *)"tree.c", 1257);
            }

            (ret + (signed long int)mls)->matches[(signed long int)((ret + (signed long int)mls)->matchCount - (unsigned int)1)] = idx;
          }

        }
      }
      tree->used_memory = tree->used_memory + sizeof(struct DOODLE_Node) /*80ul*/  * (unsigned long int)mls_size;
      return ret;

    ERROR_ABORT:
      ;
      mls = 0;
      for( ; !(mls >= (signed int)mls_size); mls = mls + 1)
        if(!((ret + (signed long int)mls)->matches == ((unsigned int *)NULL)))
          free((void *)(ret + (signed long int)mls)->matches);

      free((void *)ret);
      return (struct DOODLE_Node *)(void *)0;
    }
  }
}

// loadChild
// file tree.c line 1286
static signed int loadChild(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *node)
{
  while((_Bool)0)
    ;
  if(node->next_off == 0ul)
    return -1;

  else
  {
    if(!(tree->memory_limit >= tree->used_memory))
      shrinkMemoryFootprint(tree, node);

    node->child=lazyReadNode(tree, node->next_off);
    if(node->child == ((struct DOODLE_Node *)NULL))
      return -1;

    else
    {
      node->child->parent = node;
      while((_Bool)0)
        ;
      return 0;
    }
  }
}

// loadLink
// file tree.c line 1310
static signed int loadLink(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *node)
{
  if(node->link_off == 0ul)
    return -1;

  else
  {
    if(!(tree->memory_limit >= tree->used_memory))
      shrinkMemoryFootprint(tree, node);

    node->link=lazyReadNode(tree, node->link_off);
    if(node->link == ((struct DOODLE_Node *)NULL))
      return -1;

    else
    {
      node->link->parent = node;
      while((_Bool)0)
        ;
      return 0;
    }
  }
}

// main
// file doodled.c line 785
signed int main(signed int argc, char **argv)
{
  signed int c;
  signed int option_index;
  char *libraries = (char *)(void *)0;
  unsigned long int mem_limit = (unsigned long int)0;
  char *dbName;
  char *tmp;
  char *log = (char *)(void *)0;
  signed int ret;
  signed int filedes[2l];
  setlocale(6, "");
  bindtextdomain("doodle", "/usr/share/locale");
  textdomain("doodle");
  dbName=getenv("DOODLE_PATH");
  if(dbName == ((char *)NULL))
    dbName = "/var/lib/doodle/doodle.db";

  tmp=getenv("PRUNEPATHS");
  if(!(tmp == ((char *)NULL)))
    prunepaths = tmp;

  signed int return_value_sscanf$2;
  char *return_value_gettext$4;
  char *return_value_gettext$5;
  while((_Bool)1)
  {
    option_index = 0;
    static struct option long_options[12l] = { { .name="database", .has_arg=1, .flag=((signed int *)NULL), .val=100 }, 
    { .name="debug", .has_arg=0, .flag=((signed int *)NULL), .val=68 }, 
    { .name="filenames", .has_arg=0, .flag=((signed int *)NULL), .val=102 }, 
    { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 }, 
    { .name="library", .has_arg=1, .flag=((signed int *)NULL), .val=108 }, 
    { .name="log", .has_arg=1, .flag=((signed int *)NULL), .val=76 }, 
    { .name="memory", .has_arg=1, .flag=((signed int *)NULL), .val=109 }, 
    { .name="nodefault", .has_arg=0, .flag=((signed int *)NULL), .val=110 }, 
    { .name="prunepaths", .has_arg=1, .flag=((signed int *)NULL), .val=80 }, 
    { .name="version", .has_arg=0, .flag=((signed int *)NULL), .val=118 }, 
    { .name="verbose", .has_arg=0, .flag=((signed int *)NULL), .val=86 }, 
    { .name=(const char *)(void *)0, .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
    c=getopt_long(argc, argv, "d:Dfhl:L:m:nP:vV", long_options, &option_index);
    if(c == -1)
      break;

    switch(c)
    {
      case 100:
      {
        dbName = optarg;
        break;
      }
      case 68:
      {
        do_debug = 1;
        break;
      }
      case 102:
      {
        do_filenames = 1;
        break;
      }
      case 104:
      {
        printHelp();
        return 0;
      }
      case 108:
      {
        libraries = optarg;
        break;
      }
      case 76:
      {
        log = optarg;
        break;
      }
      case 109:
      {
        return_value_sscanf$2=sscanf(optarg, "%ud", &mem_limit);
        if(!(return_value_sscanf$2 == 1))
        {
          char *return_value_gettext$1;
          return_value_gettext$1=gettext("You must pass a number to the '%s' option.\n");
          printf(return_value_gettext$1, (const void *)"-m");
          return -1;
        }

        if(mem_limit >= 4096ul)
        {
          char *return_value_gettext$3;
          return_value_gettext$3=gettext("Specified memory limit is too high.\n");
          printf(return_value_gettext$3);
          return -1;
        }

        mem_limit = mem_limit * (unsigned long int)(1024 * 1024);
        break;
      }
      case 110:
      {
        do_default = 0;
        break;
      }
      case 80:
      {
        prunepaths = optarg;
        break;
      }
      case 86:
      {
        if(verbose == 1)
          very_verbose = 1;

        verbose = 1;
        break;
      }
      case 118:
      {
        return_value_gettext$4=gettext("Version %s\n");
        printf(return_value_gettext$4, (const void *)"0.7.0");
        return 0;
      }
      default:
      {
        return_value_gettext$5=gettext("Use '--help' to get a list of options.\n");
        fprintf(stderr, return_value_gettext$5);
        return -1;
      }
    }
  }
  if(!(argc + -optind >= 1))
  {
    char *return_value_gettext$6;
    return_value_gettext$6=gettext("Invoke with filenames or directories to monitor!\n");
    fprintf(stderr, return_value_gettext$6);
    return -1;
  }

  if(!(libraries == ((char *)NULL)))
    libraries=strdup(libraries);

  if(do_debug == 0)
    detachFromTerminal(filedes);

  initializeShutdownHandlers();
  if(do_debug == 0)
    detachFromTerminalComplete(filedes);

  ret=build(libraries, dbName, mem_limit, log, argc - optind, &argv[(signed long int)optind]);
  doneShutdownHandlers();
  if(!(libraries == ((char *)NULL)))
    free((void *)libraries);

  return ret;
}

// markModified
// file tree.c line 2054
static void markModified(struct DOODLE_Node *pos)
{
  for( ; !(pos == ((struct DOODLE_Node *)NULL)); pos = pos->parent)
  {
    if((signed int)pos->modified == 1)
      break;

    pos->modified = (unsigned char)1;
  }
}

// mutex_lock_
// file semaphore.h line 169
void mutex_lock_(struct Mutex *mutex, const char *filename, const signed int line)
{
  union anonymous$5 *mut;
  signed int ret;
  mut = (union anonymous$5 *)mutex->internal;
  if(mut == ((union anonymous$5 *)NULL))
    abort();

  else
  {
    ret=pthread_mutex_lock(mut);
    if(!(ret == 0))
    {
      if(ret == 22)
        abort();

      if(ret == 35)
        abort();

      do
        abort();
      while((_Bool)0);
    }

  }
}

// mutex_unlock_
// file semaphore.h line 172
void mutex_unlock_(struct Mutex *mutex, const char *filename, const signed int line)
{
  union anonymous$5 *mut;
  signed int ret;
  mut = (union anonymous$5 *)mutex->internal;
  if(mut == ((union anonymous$5 *)NULL))
    abort();

  else
  {
    ret=pthread_mutex_unlock(mut);
    if(!(ret == 0))
    {
      if(ret == 22)
        abort();

      if(ret == 1)
        abort();

    }

  }
}

// my_log
// file doodled.c line 119
static void my_log(void *ctx, unsigned int level, const char *msg, ...)
{
  struct _IO_FILE *logfile = (struct _IO_FILE *)ctx;
  void **args;
  if(logfile == ((struct _IO_FILE *)NULL))
  {
    if(!(do_debug == 0))
    {
      logfile = stderr;
      goto __CPROVER_DUMP_L2;
    }

  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(level == 0u || level == 1u && !(verbose == 0) || level == 2u && !(very_verbose == 0))
    {
      args = (void **)&msg;
      vfprintf(logfile, msg, args);
      args = ((void **)NULL);
    }

  }
}

// printHelp
// file doodled.c line 58
static void printHelp()
{
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("doodled [OPTIONS] [FILENAMES]");
  char *return_value_gettext$2;
  return_value_gettext$2=gettext("Continuously index files in the background.");
  static struct anonymous$1 help[12l] = { { .shortArg=(char)100, .longArg="database", .mandatoryArg="FILENAME",
    .description="use location FILENAME to store doodle database" }, 
    { .shortArg=(char)68, .longArg="debug", .mandatoryArg=(char *)(void *)0, .description="run in debug mode, do not daemonize" }, 
    { .shortArg=(char)102, .longArg="filenames", .mandatoryArg=(char *)(void *)0,
    .description="add the filename to the list of keywords" }, 
    { .shortArg=(char)104, .longArg="help", .mandatoryArg=(char *)(void *)0, .description="print this help page" }, 
    { .shortArg=(char)108, .longArg="library", .mandatoryArg="LIBRARY",
    .description="load an extractor plugin named LIBRARY" }, 
    { .shortArg=(char)76, .longArg="log", .mandatoryArg="FILENAME", .description="log activity to a file named FILENAME" }, 
    { .shortArg=(char)110, .longArg="nodefault", .mandatoryArg=(char *)(void *)0,
    .description="do not load default set of extractor plugins" }, 
    { .shortArg=(char)109, .longArg="memory", .mandatoryArg="SIZE",
    .description="set the memory limit to SIZE MB (for the tree)." }, 
    { .shortArg=(char)80, .longArg="prunepaths", .mandatoryArg=(char *)(void *)0,
    .description="exclude given paths from building or searching" }, 
    { .shortArg=(char)118, .longArg="version", .mandatoryArg=(char *)(void *)0,
    .description="print the version number" }, 
    { .shortArg=(char)86, .longArg="verbose", .mandatoryArg=(char *)(void *)0,
    .description="be verbose" }, 
    { .shortArg=(char)0, .longArg=(char *)(void *)0, .mandatoryArg=(char *)(void *)0,
    .description=(char *)(void *)0 } };
  formatHelp(return_value_gettext$1, return_value_gettext$2, help);
}

// print_internal
// file tree.c line 3320
static signed int print_internal(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *node, struct _IO_FILE *stream, signed int ident)
{
  signed int i;
  while((_Bool)0)
    ;
  signed int return_value_loadChild$1;
  signed int return_value_loadLink$2;
  while(!(node == ((struct DOODLE_Node *)NULL)))
  {
    fprintf(stream, "%*c%.*s:\n", ident, 32, (signed int)node->clength, node->c);
    i = (signed int)(node->matchCount - (unsigned int)1);
    for( ; i >= 0; i = i - 1)
      fprintf(stream, "%*c  %s\n", ident, 32, (tree->filenames + (signed long int)node->matches[(signed long int)i])->filename);
    if(node->child == ((struct DOODLE_Node *)NULL))
    {
      if(!(node->next_off == 0ul))
      {
        return_value_loadChild$1=loadChild(tree, node);
        if(return_value_loadChild$1 == -1)
          return -1;

      }

    }

    print_internal(tree, node->child, stream, ident + 2);
    if(node->link == ((struct DOODLE_Node *)NULL))
    {
      if(!(node->link_off == 0ul))
      {
        return_value_loadLink$2=loadLink(tree, node);
        if(return_value_loadLink$2 == -1)
          return -1;

      }

    }

    node = node->link;
  }
  return 0;
}

// processEvents
// file doodled.c line 175
static void * processEvents(void *arg)
{
  struct anonymous$17 *cls = (struct anonymous$17 *)arg;
  struct FAMEvent fe;
  struct anonymous$18 r;
  struct anonymous$18 w;
  struct anonymous$18 e;
  signed int fd = cls->fc.fd;
  signed int i;
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Event processing thread created.\n");
  cls->log(cls->logContext, (unsigned int)2, return_value_gettext$1);
  signed int return_value_testShutdown$2;
  return_value_testShutdown$2=testShutdown();
  unsigned long int return_value_strlen$13;
  if(return_value_testShutdown$2 == 0)
  {
    if(!(cls->continueRunning == 0))
    {
      char *name;
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$18) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&r)->fds_bits[(signed long int)0]) : "memory");
      signed int processEvents$$1$$1$$2$$__d0;
      signed int processEvents$$1$$1$$2$$__d1;
      asm("cld; rep; stosq" : "=c"(processEvents$$1$$1$$2$$__d0), "=D"(processEvents$$1$$1$$2$$__d1) : "a"(0), "0"(sizeof(struct anonymous$18) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&w)->fds_bits[(signed long int)0]) : "memory");
      signed int processEvents$$1$$1$$3$$__d0;
      signed int processEvents$$1$$1$$3$$__d1;
      asm("cld; rep; stosq" : "=c"(processEvents$$1$$1$$3$$__d0), "=D"(processEvents$$1$$1$$3$$__d1) : "a"(0), "0"(sizeof(struct anonymous$18) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&e)->fds_bits[(signed long int)0]) : "memory");
      (&r)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&r)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      i=select(fd + 1, &r, &w, &e, (struct timeval *)(void *)0);
      if(i == -1)
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        char *return_value_gettext$4;
        return_value_gettext$4=gettext("Call to '%s' failed: %s\n");
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        cls->log(cls->logContext, (unsigned int)0, return_value_gettext$4, (const void *)"select", return_value_strerror$6);
      }

      if(!((r.fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
      {
        signed int return_value_FAMPending$7;
        return_value_FAMPending$7=FAMPending(&cls->fc);
        if(return_value_FAMPending$7 == 0)
          sleep((unsigned int)1);

        else
        {
          mutex_lock_(&cls->lock, "doodled.c", 216);
          signed int return_value_FAMNextEvent$9;
          return_value_FAMNextEvent$9=FAMNextEvent(&cls->fc, &fe);
          if(return_value_FAMNextEvent$9 == -1)
          {
            char *return_value_gettext$8;
            return_value_gettext$8=gettext("Call to '%s' failed: %s\n");
            cls->log(cls->logContext, (unsigned int)0, return_value_gettext$8, (const void *)"FAMNextEvent", FamErrlist[(signed long int)FAMErrno]);
            sleep((unsigned int)1);
          }

          unsigned long int return_value_strlen$10;
          return_value_strlen$10=strlen(fe.filename);
          unsigned long int return_value_strlen$11;
          return_value_strlen$11=strlen((char *)fe.userdata);
          void *return_value_malloc$12;
          return_value_malloc$12=malloc(return_value_strlen$10 + return_value_strlen$11 + (unsigned long int)2);
          name = (char *)return_value_malloc$12;
          if((signed int)fe.filename[0l] == 47)
            strcpy(name, fe.filename);

          else
          {
            strcpy(name, (char *)fe.userdata);
            unsigned long int return_value_strlen$14;
            return_value_strlen$14=strlen((char *)fe.userdata);
            if(return_value_strlen$14 >= 1ul)
            {
              return_value_strlen$13=strlen((const char *)fe.userdata);
              if(!((signed int)((char *)fe.userdata)[-1l + (signed long int)return_value_strlen$13] == 47))
                strcat(name, "/");

            }

            strcat(name, fe.filename);
          }
          unsigned long int return_value_strlen$15;
          return_value_strlen$15=strlen(cls->ename);
          signed int return_value_strncmp$16;
          return_value_strncmp$16=strncmp(name, cls->ename, return_value_strlen$15);
          if(return_value_strncmp$16 == 0)
          {
            free((void *)name);
            mutex_unlock_(&cls->lock, "doodled.c", 242);
          }

          else
          {
            cls->log(cls->logContext, (unsigned int)3, "FAM EVENT (%d,%s,%s) on file '%s'.\n", fe.code, fe.userdata, (const void *)fe.filename, name);
            if((signed int)fe.code == FAMChanged || (signed int)fe.code == FAMDeleted || (signed int)fe.code == FAMCreated || (signed int)fe.code == FAMMoved || (signed int)fe.code == FAMAcknowledge || (signed int)fe.code == FAMExists || (signed int)fe.code == FAMEndExist)
            {
              xgrow_((void **)&cls->events, sizeof(char *) /*8ul*/ , &cls->eventCount, cls->eventCount + (unsigned int)1, "doodled.c", 264);
              cls->events[(signed long int)(cls->eventCount - (unsigned int)1)]=strdup(name);
              semaphore_up_(cls->signal, "doodled.c", 266);
            }

            free((void *)name);
            mutex_unlock_(&cls->lock, "doodled.c", 272);
          }
        }
      }

    }

  }

  cls->continueRunning = 0;
  semaphore_up_(cls->signal, "doodled.c", 275);
  return (void *)0;
}

// processShrink
// file tree.c line 914
static void processShrink(struct DOODLE_SuffixTree *tree, struct DOODLE_Node **keepThese, signed int ktC, signed int ktP, struct DOODLE_Node *pos, unsigned int *kept)
{
  signed int mark;
  struct DOODLE_Node *next;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$7;
  while(!(pos == ((struct DOODLE_Node *)NULL)))
  {
    *kept = *kept + 1u;
    next = (struct DOODLE_Node *)(void *)0;
    mark = 0;
    if(ktP >= 0)
    {
      if(pos->link == keepThese[(signed long int)ktP])
        mark = mark | 1;

      if(pos->child == keepThese[(signed long int)ktP])
        mark = mark | 2;

    }

    if((1 & mark) == 0)
      tmp_if_expr$4 = pos->link != (struct DOODLE_Node *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
      tmp_if_expr$5 = (signed int)pos->link->mls_size == 1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (signed int)pos->mls_size == 1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
    {
      if(tree->swapLimit >= pos->link->useCounter)
      {
        if(tree->read_only == 0)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = (signed int)pos->link->modified == 0 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
      {
        if(!(tree->force_dump == 0))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (signed int)pos->link->modified != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
          pos->link_off=writeNode(tree->fd, tree, pos->link);

        freeNode(tree, pos->link);
        pos->link = (struct DOODLE_Node *)(void *)0;
        while((_Bool)0)
          ;
      }

      else
      {
        pos->link->useCounter = (unsigned int)0;
        processShrink(tree, keepThese, ktC, ktP, pos->link, kept);
      }
    }

    else
    {
      ktP = ktP - 1;
      processShrink(tree, keepThese, ktC, ktP, pos->child, kept);
      pos = pos->link;
      continue;
    }
    if((2 & mark) == 0)
      tmp_if_expr$10 = pos->child != (struct DOODLE_Node *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$10 = (_Bool)0;
    if(tmp_if_expr$10)
    {
      if(tree->swapLimit >= pos->child->useCounter)
      {
        if(tree->read_only == 0)
          tmp_if_expr$8 = (_Bool)1;

        else
          tmp_if_expr$8 = (signed int)pos->child->modified == 0 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
      {
        if(!(tree->force_dump == 0))
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = (signed int)pos->child->modified != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$7)
          pos->next_off=writeNode(tree->fd, tree, pos->child);

        freeNode(tree, pos->child);
        pos->child = (struct DOODLE_Node *)(void *)0;
        while((_Bool)0)
          ;
        pos = (struct DOODLE_Node *)(void *)0;
      }

      else
      {
        pos->child->useCounter = (unsigned int)0;
        pos = pos->child;
      }
    }

    else
    {
      ktP = ktP - 1;
      pos = pos->child;
    }
  }
  while((_Bool)0)
    ;
}

// readFN
// file tree.c line 649
static char * readFN(struct anonymous$0 *fd, char * const *pathTab, const unsigned int ptc)
{
  unsigned int pid;
  unsigned int fnl;
  signed int slen;
  char *buf;
  signed int return_value_READUINT$1;
  return_value_READUINT$1=READUINT(fd, &pid);
  if(return_value_READUINT$1 == -1)
    return (char *)(void *)0;

  else
  {
    signed int return_value_READUINT$2;
    return_value_READUINT$2=READUINT(fd, &fnl);
    if(return_value_READUINT$2 == -1)
      return (char *)(void *)0;

    else
    {
      if(pid >= ptc)
      {
        char *return_value_gettext$3;
        return_value_gettext$3=gettext("Assertion failed at %s:%d.\nDatabase format error!\n");
        fd->log(fd->context, (unsigned int)0, return_value_gettext$3, pid, ptc);
        return (char *)(void *)0;
      }

      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(pathTab[(signed long int)pid]);
      slen = (signed int)return_value_strlen$4;
      void *return_value_MALLOC$5;
      return_value_MALLOC$5=MALLOC((unsigned long int)(fnl + (unsigned int)slen + (unsigned int)2));
      buf = (char *)return_value_MALLOC$5;
      strcpy(buf, pathTab[(signed long int)pid]);
      strcat(buf, "/");
      signed int return_value_READALL$6;
      return_value_READALL$6=READALL(fd, (void *)&buf[(signed long int)(slen + 1)], (unsigned long long int)fnl);
      if(return_value_READALL$6 == -1)
      {
        free((void *)buf);
        return (char *)(void *)0;
      }

      else
      {
        buf[(signed long int)((unsigned int)slen + fnl + (unsigned int)1)] = (char)0;
        return buf;
      }
    }
  }
}

// readZT
// file tree.c line 625
static char * readZT(struct anonymous$0 *fd)
{
  unsigned int len;
  char *buf;
  signed int return_value_READUINT$1;
  return_value_READUINT$1=READUINT(fd, &len);
  if(return_value_READUINT$1 == -1)
    return (char *)(void *)0;

  else
  {
    void *return_value_MALLOC$2;
    return_value_MALLOC$2=MALLOC((unsigned long int)(len + (unsigned int)1));
    buf = (char *)return_value_MALLOC$2;
    signed int return_value_READALL$3;
    return_value_READALL$3=READALL(fd, (void *)buf, (unsigned long long int)len);
    if(return_value_READALL$3 == -1)
    {
      free((void *)buf);
      return (char *)(void *)0;
    }

    else
    {
      buf[(signed long int)len] = (char)0;
      return buf;
    }
  }
}

// read_buf
// file tree.c line 171
static signed int read_buf(void (*log)(void *, unsigned int, const char *, ...), void *context, signed int fd, unsigned long long int off, char *buf, unsigned long long int cnt)
{
  signed int ret;
  signed long int return_value_lseek$4;
  return_value_lseek$4=lseek(fd, (signed long int)off, 0);
  if(!(off == (unsigned long int)return_value_lseek$4))
  {
    char *return_value_gettext$1;
    return_value_gettext$1=gettext("Call to '%s' failed: %s\n");
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    log(context, (unsigned int)0, return_value_gettext$1, (const void *)"lseek", return_value_strerror$3);
  }

  signed long int return_value_read$5;
  return_value_read$5=read(fd, (void *)buf, cnt);
  ret = (signed int)return_value_read$5;
  if(!(cnt == (unsigned long int)ret))
  {
    if(ret == -1)
    {
      char *return_value_gettext$6;
      return_value_gettext$6=gettext("Call to '%s' failed: %s\n");
      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      char *return_value_strerror$8;
      return_value_strerror$8=strerror(*return_value___errno_location$7);
      log(context, (unsigned int)0, return_value_gettext$6, (const void *)"read", return_value_strerror$8);
    }

    else
    {
      char *return_value_gettext$9;
      return_value_gettext$9=gettext("Short read at offset %llu (attempted to read %llu bytes).\n");
      log(context, (unsigned int)0, return_value_gettext$9, off, cnt);
    }
    return -1;
  }

  else
    return 0;
}

// retarget_buffer
// file tree.c line 269
static signed int retarget_buffer(struct anonymous$0 *bio, unsigned long long int off, unsigned long long int len)
{
  unsigned long long int min;
  signed int ret;
  unsigned int opt_off = (unsigned int)((off / (unsigned long int)(4096 / 2)) * (unsigned long int)(4096 / 2));
  if((unsigned long int)(4096u + opt_off) >= len + off)
    off = (unsigned long long int)opt_off;

  flush_buffer(bio);
  unsigned long int tmp_if_expr$1;
  if(bio->fsize + -off >= 4097ul)
    tmp_if_expr$1 = (unsigned long int)4096;

  else
    tmp_if_expr$1 = bio->fsize - off;
  min = tmp_if_expr$1;
  bio->bsize = min;
  bio->bstart = off;
  ret=read_buf(bio->log, bio->context, bio->fd, bio->bstart, bio->buffer, min);
  return ret;
}

// run_shutdown
// file shutdown.h line 36
void run_shutdown(signed int signum)
{
  if(!(shutdown_signal == ((struct Semaphore *)NULL)))
  {
    shutdown_active = 1;
    semaphore_up_(shutdown_signal, "shutdown.c", 49);
  }

}

// scanDirectory
// file files.c line 54
signed int scanDirectory(char *dirName, void (*logger)(void *, unsigned int, const char *, ...), void *context, signed int (*pruner)(const char *, void *), void *pr_arg, signed int (*callback)(const char *, void *), void *cb_arg)
{
  struct __dirstream *dinfo;
  struct dirent *finfo;
  struct stat istat;
  signed int count = 0;
  char *return_value_gettext$1;
  if(dirName == ((char *)NULL))
  {
    if(!(logger == ((void (*)(void *, unsigned int, const char *, ...))NULL)))
    {
      return_value_gettext$1=gettext("Assertion failed at %s:%d.\n");
      logger(context, (unsigned int)0, return_value_gettext$1, (const void *)"files.c", 72);
    }

    return -1;
  }

  signed int return_value_lstat$5;
  return_value_lstat$5=lstat(dirName, &istat);
  char *return_value_gettext$2;
  signed int *return_value___errno_location$3;
  char *return_value_strerror$4;
  if(!(return_value_lstat$5 == 0))
  {
    if(!(logger == ((void (*)(void *, unsigned int, const char *, ...))NULL)))
    {
      return_value_gettext$2=gettext("Call to '%s' for file '%s' failed: %s\n");
      return_value___errno_location$3=__errno_location();
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      logger(context, (unsigned int)1, return_value_gettext$2, (const void *)"lstat", dirName, return_value_strerror$4);
    }

    return 0;
  }

  signed int return_value;
  char *return_value_gettext$6;
  char *return_value_gettext$8;
  if((61440u & istat.st_mode) == 40960u)
    return 0;

  else
    if((61440u & istat.st_mode) == 49152u)
      return 0;

    else
      if((61440u & istat.st_mode) == 4096u || (61440u & istat.st_mode) == 8192u || (61440u & istat.st_mode) == 24576u)
        return 0;

      else
        if((61440u & istat.st_mode) == 16384u || (61440u & istat.st_mode) == 32768u)
        {
          return_value=callback(dirName, cb_arg);
          return -1;
        }

        else
          if(!((61440u & istat.st_mode) == 16384u))
            return 0;

          else
          {
            if(!(logger == ((void (*)(void *, unsigned int, const char *, ...))NULL)))
            {
              return_value_gettext$6=gettext("Scanning '%s'\n");
              logger(context, (unsigned int)1, return_value_gettext$6, dirName);
            }

            signed int *return_value___errno_location$7;
            return_value___errno_location$7=__errno_location();
            *return_value___errno_location$7 = 0;
            dinfo=opendir(dirName);
            signed int *return_value___errno_location$10;
            return_value___errno_location$10=__errno_location();
            if(*return_value___errno_location$10 == 13 || dinfo == ((struct __dirstream *)NULL))
            {
              signed int *return_value___errno_location$9;
              return_value___errno_location$9=__errno_location();
              if(*return_value___errno_location$9 == 13)
              {
                if(!(logger == ((void (*)(void *, unsigned int, const char *, ...))NULL)))
                {
                  return_value_gettext$8=gettext("Access to directory '%s' was denied.\n");
                  logger(context, (unsigned int)1, return_value_gettext$8, dirName);
                }

              }

              return 0;
            }

            do
            {
              finfo=readdir(dinfo);
              if(finfo == ((struct dirent *)NULL))
                break;

              char *dn;
              signed int ret;
              if(!((signed int)finfo->d_name[0l] == 46))
              {
                unsigned long int return_value_strlen$11;
                return_value_strlen$11=strlen(dirName);
                unsigned long int return_value_strlen$12;
                return_value_strlen$12=strlen(finfo->d_name);
                void *return_value_MALLOC$13;
                return_value_MALLOC$13=MALLOC(return_value_strlen$11 + return_value_strlen$12 + (unsigned long int)2);
                dn = (char *)return_value_MALLOC$13;
                strcpy(dn, dirName);
                unsigned long int return_value_strlen$14;
                return_value_strlen$14=strlen(dirName);
                if(!((signed int)dirName[-1l + (signed long int)return_value_strlen$14] == 47))
                  strcat(dn, "/");

                strcat(dn, finfo->d_name);
                signed int return_value_1;
                return_value_1=pruner(dn, pr_arg);
                if(return_value_1 == 0)
                  ret=scanDirectory(dn, logger, context, pruner, pr_arg, callback, cb_arg);

                else
                  ret = 0;
                free((void *)dn);
                if(ret >= 0)
                  count = count + ret;

                else
                  return -1;
              }

            }
            while((_Bool)1);
            closedir(dinfo);
            return count;
          }
}

// semaphore_down_
// file semaphore.h line 181
signed int semaphore_down_(struct Semaphore *s, const char *filename, const signed int linenumber)
{
  signed int value_after_op;
  signed int return_value;
  union anonymous$3 *cond = (union anonymous$3 *)s->cond;
  mutex_lock_(&s->mutex, "semaphore.c", 301);
  while(!(s->v >= 1))
  {
    return_value=pthread_cond_wait(cond, (union anonymous$5 *)s->mutex.internal);
    if(!(return_value == 0))
      abort();

  }
  s->v = s->v - 1;
  value_after_op = s->v;
  mutex_unlock_(&s->mutex, "semaphore.c", 309);
  return value_after_op;
}

// semaphore_down_nonblocking_
// file semaphore.c line 318
signed int semaphore_down_nonblocking_(struct Semaphore *s, const char *filename, const signed int linenumber)
{
  mutex_lock_(&s->mutex, "semaphore.c", 321);
  if(!(s->v >= 1))
  {
    mutex_unlock_(&s->mutex, "semaphore.c", 323);
    return -1;
  }

  else
  {
    s->v = s->v - 1;
    mutex_unlock_(&s->mutex, "semaphore.c", 327);
    return 1;
  }
}

// semaphore_free_
// file semaphore.h line 178
void semaphore_free_(struct Semaphore *s, const char *filename, const signed int linenumber)
{
  union anonymous$3 *cond;
  destroy_mutex_(&s->mutex);
  cond = (union anonymous$3 *)s->cond;
  do
  {
    signed int return_value_pthread_cond_destroy$1;
    return_value_pthread_cond_destroy$1=pthread_cond_destroy(cond);
    if(!(return_value_pthread_cond_destroy$1 == 0))
      abort();

  }
  while((_Bool)0);
  free((void *)cond);
  free((void *)s);
}

// semaphore_new_
// file semaphore.h line 175
struct Semaphore * semaphore_new_(signed int value, const char *filename, const signed int linenumber)
{
  union anonymous$3 *cond;
  struct Semaphore *s;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct Semaphore) /*24ul*/ );
  s = (struct Semaphore *)return_value_malloc$1;
  s->v = value;
  create_mutex_(&s->mutex);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(union anonymous$3) /*48ul*/ );
  cond = (union anonymous$3 *)return_value_malloc$2;
  s->cond = (void *)cond;
  pthread_cond_init(cond, (const union anonymous$4 *)(void *)0);
  return s;
}

// semaphore_up_
// file semaphore.h line 187
signed int semaphore_up_(struct Semaphore *s, const char *filename, const signed int linenumber)
{
  signed int value_after_op;
  union anonymous$3 *cond = (union anonymous$3 *)s->cond;
  mutex_lock_(&s->mutex, "semaphore.c", 281);
  s->v = s->v + 1;
  value_after_op = s->v;
  do
  {
    signed int return_value_pthread_cond_signal$1;
    return_value_pthread_cond_signal$1=pthread_cond_signal(cond);
    if(!(return_value_pthread_cond_signal$1 == 0))
      abort();

  }
  while((_Bool)0);
  mutex_unlock_(&s->mutex, "semaphore.c", 285);
  return value_after_op;
}

// shrinkMemoryFootprint
// file tree.c line 1027
static void shrinkMemoryFootprint(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *keep)
{
  struct DOODLE_Node **keepThese;
  unsigned int ktC;
  struct DOODLE_Node *pos;
  unsigned int kept;
  signed int force_dump = tree->force_dump;
  tree->force_dump = 0;
  while((_Bool)0)
    ;
  tree->swapLimit = tree->mutationCount / (unsigned int)2 + (unsigned int)1;
  tree->mutationCount = (unsigned int)0;
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Memory limit (%u bytes) hit, serializing some data.\n");
  tree->log(tree->context, (unsigned int)2, return_value_gettext$1, tree->used_memory);
  pos = keep;
  keepThese = (struct DOODLE_Node **)(void *)0;
  ktC = (unsigned int)0;
  if(!(pos == ((struct DOODLE_Node *)NULL)))
  {
    xgrow_((void **)&keepThese, sizeof(struct DOODLE_Node *) /*8ul*/ , &ktC, ktC + (unsigned int)1, "tree.c", 1052);
    keepThese[(signed long int)(ktC - (unsigned int)1)] = pos;
    pos = pos->parent;
  }

  kept = (unsigned int)0;
  processShrink(tree, keepThese, (signed int)ktC, (signed int)(ktC - (unsigned int)2), tree->root, &kept);
  xgrow_((void **)&keepThese, sizeof(struct DOODLE_Node *) /*8ul*/ , &ktC, (unsigned int)0, "tree.c", 1081);
  char *return_value_gettext$2;
  return_value_gettext$2=gettext("Reduced memory consumption for suffix tree to %u bytes.\n");
  tree->log(tree->context, (unsigned int)2, return_value_gettext$2, tree->used_memory);
  tree->force_dump = force_dump;
}

// testShutdown
// file shutdown.h line 42
signed int testShutdown()
{
  return shutdown_active;
}

// tree_iterate_internal
// file tree.c line 3104
static signed int tree_iterate_internal(signed int do_links, struct DOODLE_SuffixTree *tree, struct DOODLE_Node *node, void (*callback)(const struct anonymous *, void *), void *arg)
{
  signed int i;
  signed int ret = 0;
  while(!(node == ((struct DOODLE_Node *)NULL)))
  {
    i = (signed int)(node->matchCount - (unsigned int)1);
    for( ; i >= 0; i = i - 1)
    {
      if(!(callback == ((void (*)(const struct anonymous *, void *))NULL)))
        callback(&tree->filenames[(signed long int)node->matches[(signed long int)i]], arg);

      ret = ret + 1;
    }
    if(node->child == ((struct DOODLE_Node *)NULL))
    {
      if(!(node->next_off == 0ul))
      {
        signed int return_value_loadChild$1;
        return_value_loadChild$1=loadChild(tree, node);
        if(return_value_loadChild$1 == -1)
          return -1;

      }

    }

    signed int return_value_tree_iterate_internal$2;
    return_value_tree_iterate_internal$2=tree_iterate_internal(1, tree, node->child, callback, arg);
    ret = ret + return_value_tree_iterate_internal$2;
    if(do_links == 0)
      return ret;

    if(node->link == ((struct DOODLE_Node *)NULL))
    {
      if(!(node->link_off == 0ul))
      {
        signed int return_value_loadLink$3;
        return_value_loadLink$3=loadLink(tree, node);
        if(return_value_loadLink$3 == -1)
          return -1;

      }

    }

    node = node->link;
  }
  while((_Bool)0)
    ;
  return ret;
}

// tree_normalize
// file tree.c line 2071
static void tree_normalize(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *pos)
{
  struct DOODLE_Node *insert;
  struct DOODLE_Node *grandchild;
  if(!((signed int)pos->clength == 1))
  {
    grandchild = pos->child;
    void *return_value_MALLOC$1;
    return_value_MALLOC$1=MALLOC(sizeof(struct DOODLE_Node) /*80ul*/ );
    insert = (struct DOODLE_Node *)return_value_MALLOC$1;
    insert->mls_size = (unsigned char)1;
    insert->useCounter = (unsigned int)0;
    tree->used_memory = tree->used_memory + sizeof(struct DOODLE_Node) /*80ul*/ ;
    pos->child = insert;
    insert->parent = pos;
    insert->child = grandchild;
    if(!(grandchild == ((struct DOODLE_Node *)NULL)))
      grandchild->parent = insert;

    insert->next_off = pos->next_off;
    pos->next_off = (unsigned long long int)0;
    if((signed int)pos->clength == 2)
    {
      insert->c = &CIS[(signed long int)(unsigned char)pos->c[(signed long int)1]];
      insert->clength = (unsigned char)1;
      insert->cix = -1;
    }

    else
    {
      insert->c = &pos->c[(signed long int)1];
      insert->clength = (unsigned char)((signed int)pos->clength - 1);
      insert->cix = pos->cix;
    }
    insert->matches = pos->matches;
    pos->matches = (unsigned int *)(void *)0;
    insert->matchCount = pos->matchCount;
    pos->matchCount = (unsigned int)0;
    pos->clength = (unsigned char)1;
    pos->c = &CIS[(signed long int)(unsigned char)pos->c[(signed long int)0]];
    pos->next_off = (unsigned long long int)0;
    while((_Bool)0)
      ;
    markModified(insert);
  }

}

// tree_search_approx_internal
// file tree.c line 3175
static signed int tree_search_approx_internal(struct DOODLE_Node *pos, const unsigned int approx, const signed int ignore_case, struct DOODLE_SuffixTree *tree, const char *ss, void (*callback)(const struct anonymous *, void *), void *arg)
{
  signed int ret;
  signed int iret;
  ret = 0;
  while((_Bool)0)
    ;
  if((signed int)*ss == 0)
  {
    char *return_value_gettext$1;
    return_value_gettext$1=gettext("Assertion failed at %s:%d!\n");
    tree->log(tree->context, (unsigned int)0, return_value_gettext$1, (const void *)"tree.c", 3192);
    return -1;
  }

  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$7;
  signed int return_value_tolower$5;
  signed int return_value_tolower$6;
  signed int return_value_loadChild$2;
  signed int return_value_loadChild$4;
  signed int return_value_loadLink$9;
  if(pos == ((struct DOODLE_Node *)NULL))
    return 0;

  else
  {
    if((signed int)pos->clength >= 2)
      tree_normalize(tree, pos);

    while(!(pos == ((struct DOODLE_Node *)NULL)))
    {
      if(*pos->c == *ss)
        tmp_if_expr$8 = (_Bool)1;

      else
      {
        if(ignore_case == 1)
        {
          return_value_tolower$5=tolower((signed int)pos->c[(signed long int)0]);
          return_value_tolower$6=tolower((signed int)ss[(signed long int)0]);
          tmp_if_expr$7 = return_value_tolower$5 == return_value_tolower$6 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$7 = (_Bool)0;
        tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$8)
      {
        tree_normalize(tree, pos);
        if((signed int)ss[1l] == 0)
        {
          iret=tree_iterate_internal(0, tree, pos, callback, arg);
          if(iret == -1)
            return -1;

          ret = ret + iret;
        }

        else
        {
          if(pos->child == ((struct DOODLE_Node *)NULL))
          {
            if(!(pos->next_off == 0ul))
            {
              return_value_loadChild$2=loadChild(tree, pos);
              if(return_value_loadChild$2 == -1)
                return -1;

            }

          }

          iret=tree_search_approx_internal(pos->child, approx, ignore_case, tree, ss + (signed long int)1, callback, arg);
          if(iret == -1)
            return -1;

          ret = ret + iret;
        }
      }

      else
        if(approx >= 1u)
        {
          if((signed int)ss[1l] == 0)
          {
            signed int return_value_tree_iterate_internal$3;
            return_value_tree_iterate_internal$3=tree_iterate_internal(0, tree, pos, callback, arg);
            ret = ret + return_value_tree_iterate_internal$3;
            return ret;
          }

          tree_normalize(tree, pos);
          if(pos->child == ((struct DOODLE_Node *)NULL))
          {
            if(!(pos->next_off == 0ul))
            {
              return_value_loadChild$4=loadChild(tree, pos);
              if(return_value_loadChild$4 == -1)
                return -1;

            }

          }

          iret=tree_search_approx_internal(pos->child, approx - (unsigned int)1, ignore_case, tree, ss, callback, arg);
          if(iret == -1)
            return -1;

          ret = ret + iret;
          iret=tree_search_approx_internal(pos->child, approx - (unsigned int)1, ignore_case, tree, ss + (signed long int)1, callback, arg);
          if(iret == -1)
            return -1;

          ret = ret + iret;
          iret=tree_search_approx_internal(pos, approx - (unsigned int)1, ignore_case, tree, ss + (signed long int)1, callback, arg);
          if(iret == -1)
            return -1;

          ret = ret + iret;
        }

      if(pos->link == ((struct DOODLE_Node *)NULL))
      {
        if(!(pos->link_off == 0ul))
        {
          return_value_loadLink$9=loadLink(tree, pos);
          if(return_value_loadLink$9 == -1)
            return -1;

        }

      }

      pos = pos->link;
    }
    while((_Bool)0)
      ;
    return ret;
  }
}

// tree_search_internal
// file tree.c line 2180
static struct DOODLE_Node * tree_search_internal(struct DOODLE_SuffixTree *tree, const char *substring)
{
  struct DOODLE_Node *pos;
  const char *ss;
  signed int i;
  while((_Bool)0)
    ;
  ss = substring;
  pos = tree->root;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$4;
  while(!((signed int)*ss == 0))
  {
    if(pos == ((struct DOODLE_Node *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = pos->c == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      return (struct DOODLE_Node *)(void *)0;

    if(!((signed int)*ss >= (signed int)*pos->c))
      return (struct DOODLE_Node *)(void *)0;

    if(*pos->c == *ss)
    {
      ss = ss + 1l;
      i = 1;
      for( ; !(i >= (signed int)pos->clength); i = i + 1)
      {
        if((signed int)*ss == 0)
          break;

        if(!(pos->c[(signed long int)i] == *ss))
          return (struct DOODLE_Node *)(void *)0;

        ss = ss + 1l;
      }
      if((signed int)*ss == 0)
        break;

      if(pos->child == ((struct DOODLE_Node *)NULL))
      {
        if(!(pos->next_off == 0ul))
        {
          signed int return_value_loadChild$2;
          return_value_loadChild$2=loadChild(tree, pos);
          if(return_value_loadChild$2 == -1)
            return (struct DOODLE_Node *)(void *)0;

        }

        else
          return (struct DOODLE_Node *)(void *)0;
      }

      pos = pos->child;
    }

    else
    {
      if((signed int)pos->clength == 1)
        tmp_if_expr$4 = (signed int)pos->mls_size > (signed int)ss[(signed long int)0] - (signed int)pos->c[(signed long int)0] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        pos = &pos[(signed long int)((signed int)ss[(signed long int)0] - (signed int)pos->c[(signed long int)0])];

      else
      {
        if(pos->link == ((struct DOODLE_Node *)NULL))
        {
          if(!(pos->link_off == 0ul))
          {
            signed int return_value_loadLink$3;
            return_value_loadLink$3=loadLink(tree, pos);
            if(return_value_loadLink$3 == -1)
              return (struct DOODLE_Node *)(void *)0;

          }

          else
            return (struct DOODLE_Node *)(void *)0;
        }

        pos = pos->link;
      }
    }
  }
  return pos;
}

// tree_split
// file tree.c line 2128
static void tree_split(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *pos, unsigned int at)
{
  struct DOODLE_Node *insert;
  struct DOODLE_Node *grandchild = pos->child;
  void *return_value_MALLOC$1;
  return_value_MALLOC$1=MALLOC(sizeof(struct DOODLE_Node) /*80ul*/ );
  insert = (struct DOODLE_Node *)return_value_MALLOC$1;
  insert->mls_size = (unsigned char)1;
  insert->useCounter = (unsigned int)0;
  tree->used_memory = tree->used_memory + sizeof(struct DOODLE_Node) /*80ul*/ ;
  pos->child = insert;
  insert->parent = pos;
  insert->child = grandchild;
  if(!(grandchild == ((struct DOODLE_Node *)NULL)))
    grandchild->parent = insert;

  insert->next_off = pos->next_off;
  pos->next_off = (unsigned long long int)0;
  if((unsigned int)pos->clength + -at == 1u)
  {
    insert->c = &CIS[(signed long int)(unsigned char)pos->c[(signed long int)at]];
    insert->clength = (unsigned char)1;
    insert->cix = -1;
  }

  else
  {
    insert->c = &pos->c[(signed long int)at];
    insert->clength = (unsigned char)((unsigned int)pos->clength - at);
    insert->cix = pos->cix;
  }
  insert->matches = pos->matches;
  pos->matches = (unsigned int *)(void *)0;
  insert->matchCount = pos->matchCount;
  pos->matchCount = (unsigned int)0;
  pos->clength = (unsigned char)at;
  if(at == 1u)
    pos->c = &CIS[(signed long int)(unsigned char)pos->c[(signed long int)0]];

  while((_Bool)0)
    ;
  markModified(insert);
}

// truncate_internal
// file tree.c line 2812
static signed int truncate_internal(struct DOODLE_SuffixTree *tree, struct DOODLE_Node *node, unsigned int *fileNameIndex, signed int max)
{
  struct DOODLE_Node *next;
  struct DOODLE_Node *parent;
  signed int i;
  signed int j;
  signed int k;
  signed int return_value_loadChild$1;
  signed int return_value_loadLink$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  if(node == ((struct DOODLE_Node *)NULL))
    return 0;

  else
  {
    parent = node->parent;
    while(!(node == ((struct DOODLE_Node *)NULL)))
    {
      k = 0;
      for( ; !(k >= max); k = k + 1)
      {
        j = -1;
        i = (signed int)(node->matchCount - (unsigned int)1);
        for( ; i >= 0; i = i - 1)
          if(node->matches[(signed long int)i] == fileNameIndex[(signed long int)k])
            j = i;

        if(!(j == -1))
        {
          node->matches[(signed long int)j] = node->matches[(signed long int)(node->matchCount - (unsigned int)1)];
          xgrow_((void **)&node->matches, sizeof(unsigned int) /*4ul*/ , &node->matchCount, node->matchCount - (unsigned int)1, "tree.c", 2836);
          markModified(node);
        }

      }
      k = 0;
      for( ; !(k >= max); k = k + 1)
      {
        i = (signed int)(node->matchCount - (unsigned int)1);
        for( ; i >= 0; i = i - 1)
          if(node->matches[(signed long int)i] == tree->fnc + -((unsigned int)k) + 4294967295u)
          {
            node->matches[(signed long int)i] = fileNameIndex[(signed long int)k];
            markModified(node);
          }

      }
      if(node->child == ((struct DOODLE_Node *)NULL))
      {
        if(!(node->next_off == 0ul))
        {
          return_value_loadChild$1=loadChild(tree, node);
          if(return_value_loadChild$1 == -1)
            return -1;

        }

      }

      signed int return_value_truncate_internal$2;
      return_value_truncate_internal$2=truncate_internal(tree, node->child, fileNameIndex, max);
      if(!(return_value_truncate_internal$2 == 0))
        return -1;

      if(node->link == ((struct DOODLE_Node *)NULL))
      {
        if(!(node->link_off == 0ul))
        {
          return_value_loadLink$3=loadLink(tree, node);
          if(return_value_loadLink$3 == -1)
            return -1;

        }

      }

      while((_Bool)0)
        ;
      next = node->link;
      if(node->matchCount == 0u)
        tmp_if_expr$4 = node->child == (struct DOODLE_Node *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (signed int)node->mls_size == 1 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
      {
        if(node->parent == ((struct DOODLE_Node *)NULL))
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = (signed int)node->parent->mls_size == 1 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
          tmp_if_expr$7 = (_Bool)1;

        else
          tmp_if_expr$7 = node->parent->link != node ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$8 = tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$8 = (_Bool)0;
      if(tmp_if_expr$8)
      {
        tree->used_memory = tree->used_memory - sizeof(struct DOODLE_Node) /*80ul*/ ;
        if(!(parent == ((struct DOODLE_Node *)NULL)))
        {
          if(parent->link == node)
          {
            parent->link = next;
            parent->link_off = node->link_off;
          }

          else
          {
            parent->child = next;
            parent->next_off = node->next_off;
          }
        }

        if(!(next == ((struct DOODLE_Node *)NULL)))
          next->parent = parent;

        if(parent == ((struct DOODLE_Node *)NULL))
          tree->root = next;

        markModified(parent);
        free((void *)node);
        markModified(next);
      }

      else
        parent = node;
      while((_Bool)0)
        ;
      node = next;
    }
    return 0;
  }
}

// wait_for_shutdown
// file shutdown.h line 52
void wait_for_shutdown()
{
  semaphore_down_(shutdown_signal, "shutdown.c", 115);
}

// worker
// file doodled.c line 442
static void * worker(void *arg)
{
  struct anonymous$17 *cls = (struct anonymous$17 *)arg;
  signed int i;
  signed int more;
  signed int wasMore;
  signed int ret;
  void *unused;
  char *fn;
  struct PTHREAD_T helperThread;
  char *return_value_gettext$1;
  return_value_gettext$1=gettext("Main worker thread created.\n");
  cls->log(cls->logContext, (unsigned int)2, return_value_gettext$1);
  cls->eventCount = (unsigned int)0;
  cls->continueRunning = 1;
  cls->events = (char **)(void *)0;
  cls->signal=semaphore_new_(0, "doodled.c", 458);
  signed int return_value_PTHREAD_CREATE$3;
  return_value_PTHREAD_CREATE$3=PTHREAD_CREATE(&helperThread, processEvents, (void *)cls, (unsigned long int)(64 * 1024));
  if(!(return_value_PTHREAD_CREATE$3 == 0))
  {
    char *return_value_gettext$2;
    return_value_gettext$2=gettext("Failed to spawn event processing thread.\n");
    cls->log(cls->logContext, (unsigned int)0, return_value_gettext$2);
    run_shutdown(0);
    return (void *)0;
  }

  char *return_value_gettext$4;
  return_value_gettext$4=gettext("Registering with FAM for file system events.\n");
  cls->log(cls->logContext, (unsigned int)1, return_value_gettext$4);
  i = 0;
  if(!((unsigned int)i >= cls->argc))
  {
    char *exp;
    char *return_value_gettext$5;
    return_value_gettext$5=gettext("Indexing '%s'\n");
    cls->log(cls->logContext, (unsigned int)2, return_value_gettext$5, cls->argv[(signed long int)i]);
    exp=expandFileName(cls->argv[(signed long int)i]);
    signed int return_value_do_index$6;
    return_value_do_index$6=do_index(exp, cls);
    if(return_value_do_index$6 == -1)
    {
      ret = -1;
      free((void *)exp);
    }

    else
    {
      free((void *)exp);
      i = i + 1;
    }
  }

  DOODLE_tree_destroy(cls->tree);
  cls->treePresent = (unsigned int)0;
  cls->tree = (struct DOODLE_SuffixTree *)(void *)0;
  char *return_value_gettext$7;
  return_value_gettext$7=gettext("doodled startup complete.  Now waiting for FAM events.\n");
  cls->log(cls->logContext, (unsigned int)1, return_value_gettext$7);
  wasMore = 0;
  signed int return_value_testShutdown$8;
  if(!(cls->continueRunning == 0))
  {
    return_value_testShutdown$8=testShutdown();
    if(return_value_testShutdown$8 == 0)
    {
      semaphore_down_(cls->signal, "doodled.c", 500);
      cls->log(cls->logContext, (unsigned int)3, "Received signal to process fam event.\n");
      mutex_lock_(&cls->lock, "doodled.c", 504);
      if(cls->eventCount >= 1u)
      {
        fn = cls->events[(signed long int)(cls->eventCount - (unsigned int)1)];
        xgrow_((void **)&cls->events, sizeof(char *) /*8ul*/ , &cls->eventCount, cls->eventCount - (unsigned int)1, "doodled.c", 509);
        more = (signed int)(cls->eventCount > (unsigned int)0);
        cls->log(cls->logContext, (unsigned int)3, "Processing fam event '%s'.\n", fn);
      }

      else
      {
        fn = (char *)(void *)0;
        more = 0;
      }
      if(wasMore == 0)
      {
        cls->treePresent = cls->treePresent + 1u;
        if(cls->treePresent == 1u)
          cls->tree=DOODLE_tree_create((void (*)(void *, unsigned int, const char *, ...))cls->log, cls->logContext, cls->ename);

      }

      mutex_unlock_(&cls->lock, "doodled.c", 526);
      if(!(fn == ((char *)NULL)))
      {
        do_index(fn, cls);
        free((void *)fn);
      }

      mutex_lock_(&cls->lock, "doodled.c", 531);
      if(more == 0)
      {
        cls->treePresent = cls->treePresent - 1u;
        if(cls->treePresent == 0u)
          DOODLE_tree_destroy(cls->tree);

      }

      mutex_unlock_(&cls->lock, "doodled.c", 537);
      wasMore = more;
    }

  }

  cls->continueRunning = 0;
  signed int return_value_FAMClose$10;
  return_value_FAMClose$10=FAMClose(&cls->fc);
  if(!(return_value_FAMClose$10 == 0))
  {
    char *return_value_gettext$9;
    return_value_gettext$9=gettext("Error disconnecting from fam.\n");
    cls->log(cls->logContext, (unsigned int)0, return_value_gettext$9);
  }

  PTHREAD_KILL(&helperThread, 15);
  PTHREAD_JOIN(&helperThread, &unused);
  semaphore_free_(cls->signal, "doodled.c", 549);
  if(cls->treePresent >= 1u)
    DOODLE_tree_destroy(cls->tree);

  return (void *)0;
}

// writeFN
// file tree.c line 684
static void writeFN(struct anonymous$0 *fd, char * const *pathTab, const unsigned int ptc, const char *fn)
{
  signed int i;
  signed int slen;
  signed int xslen;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(fn);
  slen = (signed int)return_value_strlen$1;
  xslen = slen;
  for( ; !((signed int)fn[(signed long int)slen] == 47); slen = slen - 1)
    if(!(slen >= 1))
      break;

  i = (signed int)(ptc - (unsigned int)1);
  unsigned long int return_value_strlen$2;
  for( ; i >= 0; i = i - 1)
  {
    signed int return_value_strncmp$3;
    return_value_strncmp$3=strncmp(fn, pathTab[(signed long int)i], (unsigned long int)slen);
    if(return_value_strncmp$3 == 0)
    {
      return_value_strlen$2=strlen(pathTab[(signed long int)i]);
      if((unsigned long int)slen == return_value_strlen$2)
      {
        WRITEUINT(fd, (unsigned int)i);
        WRITEUINT(fd, (unsigned int)((xslen - slen) - 1));
        WRITEALL(fd, (const void *)&fn[(signed long int)(slen + 1)], (unsigned long long int)((xslen - slen) - 1));
        goto __CPROVER_DUMP_L6;
      }

    }

  }
  char *return_value_gettext$4;
  return_value_gettext$4=gettext("Assertion failed at %s:%d.\n");
  fd->log(fd->context, (unsigned int)0, return_value_gettext$4);

__CPROVER_DUMP_L6:
  ;
}

// writeNode
// file tree.c line 1337
static unsigned long long int writeNode(struct anonymous$0 *fd, struct DOODLE_SuffixTree *tree, struct DOODLE_Node *node)
{
  unsigned long long int ret;
  unsigned long long int linkRel;
  unsigned long long int nextRel;
  signed int i;
  signed int mls;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$5;
  if(node == ((struct DOODLE_Node *)NULL))
    return (unsigned long long int)0;

  else
  {
    if(!(tree->read_only == 0))
      abort();

    node->modified = (unsigned char)0;
    mls = 0;
    for( ; !(mls >= (signed int)node->mls_size); mls = mls + 1)
    {
      if((node + (signed long int)mls)->child == ((struct DOODLE_Node *)NULL))
      {
        if(!((node + (signed long int)mls)->next_off == 0ul))
        {
          if(!(tree->force_dump == 0))
            loadChild(tree, &node[(signed long int)mls]);

        }

      }

      if(!((node + (signed long int)mls)->child == ((struct DOODLE_Node *)NULL)))
      {
        if(!((signed int)(node + (signed long int)mls)->child->modified == 0))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = tree->force_dump != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
          (node + (signed long int)mls)->next_off=writeNode(fd, tree, (node + (signed long int)mls)->child);

      }

    }
    if((node + (signed long int)((signed int)node->mls_size + -1))->link == ((struct DOODLE_Node *)NULL))
    {
      if(!((node + (signed long int)((signed int)node->mls_size + -1))->link_off == 0ul))
      {
        if(!(tree->force_dump == 0))
          loadLink(tree, &node[(signed long int)((signed int)node->mls_size - 1)]);

      }

    }

    if(!((node + (signed long int)((signed int)node->mls_size + -1))->link == ((struct DOODLE_Node *)NULL)))
    {
      if(!((signed int)(node + (signed long int)((signed int)node->mls_size + -1))->link->modified == 0))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = tree->force_dump != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        (node + (signed long int)((signed int)node->mls_size - 1))->link_off=writeNode(fd, tree, (node + (signed long int)((signed int)node->mls_size - 1))->link);

    }

    ret=LSEEK(fd, (unsigned long long int)0, 2);
    if(!(fd->fsize >= (node + (signed long int)((signed int)node->mls_size + -1))->link_off))
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = node->next_off > fd->fsize ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
    {
      char *return_value_gettext$3;
      return_value_gettext$3=gettext("Assertion failed at %s:%d: %llu > %llu or %llu > %llu.\n");
      tree->log(tree->context, (unsigned int)0, return_value_gettext$3, (const void *)"tree.c", 1395, (node + (signed long int)((signed int)node->mls_size - 1))->link_off, fd->fsize, node->next_off, fd->fsize);
      char *return_value_gettext$4;
      return_value_gettext$4=gettext("Assertion failed at %s:%d.\n");
      tree->log(tree->context, (unsigned int)0, return_value_gettext$4, (const void *)"tree.c", 1401);
      abort();
      return (unsigned long long int)0;
    }

    if((signed int)node->clength == 1)
    {
      unsigned char o = (unsigned char)0;
      WRITEALL(fd, (const void *)&o, sizeof(unsigned char) /*1ul*/ );
      WRITEALL(fd, (const void *)&node->mls_size, sizeof(unsigned char) /*1ul*/ );
      WRITEALL(fd, (const void *)node->c, sizeof(unsigned char) /*1ul*/ );
    }

    else
    {
      signed int cix;
      signed int ciy;
      WRITEALL(fd, (const void *)&node->clength, sizeof(unsigned char) /*1ul*/ );
      cix = node->cix;
      ciy = (signed int)(node->c - tree->cis[(signed long int)node->cix]);
      WRITEUINTPAIR(fd, (unsigned int)cix, (unsigned int)ciy);
    }
    mls = 0;
    for( ; !(mls >= (signed int)node->mls_size); mls = mls + 1)
    {
      if(mls == (signed int)node->mls_size + -1)
      {
        if(!((node + (signed long int)mls)->link_off == 0ul))
          linkRel = ret - (node + (signed long int)mls)->link_off;

        else
          linkRel = (unsigned long long int)0;
        if(!((node + (signed long int)mls)->next_off == 0ul))
          nextRel = ret - (node + (signed long int)mls)->next_off;

        else
          nextRel = (unsigned long long int)0;
        WRITEULONGPAIR(fd, linkRel, nextRel);
      }

      else
      {
        nextRel = ret - (node + (signed long int)mls)->next_off;
        WRITEULONG(fd, nextRel);
      }
      WRITEUINT(fd, (node + (signed long int)mls)->matchCount);
      i = (signed int)((node + (signed long int)mls)->matchCount / (unsigned int)2 - (unsigned int)1);
      for( ; i >= 0; i = i - 1)
      {
        unsigned int idx1;
        unsigned int idx2;
        idx1 = (node + (signed long int)mls)->matches[(signed long int)(i * 2 + 1)];
        idx2 = (node + (signed long int)mls)->matches[(signed long int)(i * 2)];
        WRITEUINTPAIR(fd, idx1, idx2);
      }
      if((1u & (node + (signed long int)mls)->matchCount) == 1u)
      {
        unsigned int idx = (node + (signed long int)mls)->matches[(signed long int)((node + (signed long int)mls)->matchCount - (unsigned int)1)];
        WRITEUINT(fd, idx);
      }

    }
    if(!(fd->fsize >= ret))
    {
      char *return_value_gettext$6;
      return_value_gettext$6=gettext("Assertion failed at %s:%d: %llu > %llu.\n");
      tree->log(tree->context, (unsigned int)0, return_value_gettext$6, (const void *)"tree.c", 1515, ret, fd->fsize);
    }

    return ret;
  }
}

// writeZT
// file tree.c line 640
static void writeZT(struct anonymous$0 *fd, const char *buf)
{
  unsigned int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(buf);
  len = (unsigned int)return_value_strlen$1;
  WRITEUINT(fd, len);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(buf);
  WRITEALL(fd, (const void *)buf, return_value_strlen$2);
}

// write_buf
// file tree.c line 202
static void write_buf(void (*log)(void *, unsigned int, const char *, ...), void *context, signed int fd, unsigned long long int off, const void *buf, unsigned long long int cnt)
{
  signed int ret;
  signed long int return_value_lseek$4;
  return_value_lseek$4=lseek(fd, (signed long int)off, 0);
  if(!(off == (unsigned long int)return_value_lseek$4))
  {
    char *return_value_gettext$1;
    return_value_gettext$1=gettext("'%s' failed: %s\n");
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    log(context, (unsigned int)0, return_value_gettext$1, (const void *)"lseek", return_value_strerror$3);
  }

  signed long int return_value_write$5;
  return_value_write$5=write(fd, buf, cnt);
  ret = (signed int)return_value_write$5;
  if(!(cnt == (unsigned long int)ret))
  {
    if(ret == -1)
    {
      char *return_value_gettext$6;
      return_value_gettext$6=gettext("Call to '%s' failed: %s\n");
      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      char *return_value_strerror$8;
      return_value_strerror$8=strerror(*return_value___errno_location$7);
      log(context, (unsigned int)0, return_value_gettext$6, (const void *)"write", return_value_strerror$8);
    }

    else
    {
      char *return_value_gettext$9;
      return_value_gettext$9=gettext("Short write at offset %llu (wanted to write %llu bytes).\n");
      log(context, (unsigned int)0, return_value_gettext$9, off, cnt);
    }
  }

}

// xgrow_
// file helper1.h line 43
void xgrow_(void **old, unsigned long int elementSize, unsigned int *oldCount, unsigned int newCount, const char *filename, const signed int linenumber)
{
  void *tmp;
  unsigned long int size;
  if((unsigned long int)newCount >= 2147483647ul / elementSize)
  {
    char *return_value_gettext$1;
    return_value_gettext$1=gettext("FATAL: can not allocate %u * %d elements (number too large) at %s:%d.\n");
    fprintf(stderr, return_value_gettext$1, (unsigned int)elementSize, (signed int)newCount, filename, linenumber);
    abort();
  }

  size = (unsigned long int)newCount * elementSize;
  if(size == 0ul)
    tmp = (void *)0;

  else
  {
    tmp=MALLOC(size);
    memset(tmp, 0, size);
    if(!(newCount >= *oldCount))
      *oldCount = newCount;

    memcpy(tmp, *old, elementSize * (unsigned long int)*oldCount);
  }
  if(!(*old == NULL))
    free(*old);

  *old = tmp;
  *oldCount = newCount;
}

