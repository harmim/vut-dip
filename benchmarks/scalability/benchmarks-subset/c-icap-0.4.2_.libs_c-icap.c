// tag-#anon#ST[*{S8}$S8$'TEMPLATE_NAME'|*{S8}$S8$'SERVICE_NAME'|*{S8}$S8$'LANGUAGE'|*{SYM#tag-ci_membuf#}$SYM#tag-ci_membuf#$'data'|S64'last_used'|S64'loaded'|S64'modified'|S32'locked'|S32'must_free'|S32'non_cached'|U32'$pad0']
// file txtTemplate.c line 42
struct anonymous$7;

// tag-#anon#ST[*{SYM#tag-#anon#UN[ARR32{S8}$S8$'__size'|S64'__align']#}$SYM#tag-#anon#UN[ARR32{S8}$S8$'__size'|S64'__align']#$'sem']
// file include/proc_mutex.h line 74
struct anonymous$12;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$19;

// tag-#anon#ST[ARR16{U64}$U64$'__val']
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$18;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$8;

// tag-#anon#ST[S32'__lock'|U32'__nr_readers'|U32'__readers_wakeup'|U32'__writer_wakeup'|U32'__nr_readers_queued'|U32'__nr_writers_queued'|S32'__writer'|S32'__shared'|S8'__rwelision'|ARR7{U8}$U8$'__pad1'|U64'__pad2'|U32'__flags'|U32'$pad0']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous$2;

// tag-#anon#ST[S32'fd']
// file include/proc_mutex.h line 79
struct anonymous$13;

// tag-#anon#ST[S32'id']
// file include/proc_mutex.h line 69
struct anonymous$11;

// tag-#anon#UN[*{SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#}$SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#$'mutex'|*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__nr_readers'|U32'__readers_wakeup'|U32'__writer_wakeup'|U32'__nr_readers_queued'|U32'__nr_writers_queued'|S32'__writer'|S32'__shared'|S8'__rwelision'|ARR7{U8}$U8$'__pad1'|U64'__pad2'|U32'__flags'|U32'$pad0']#'__data'|ARR56{S8}$S8$'__size'|S64'__align']#}$SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__nr_readers'|U32'__readers_wakeup'|U32'__writer_wakeup'|U32'__nr_readers_queued'|U32'__nr_writers_queued'|S32'__writer'|S32'__shared'|S8'__rwelision'|ARR7{U8}$U8$'__pad1'|U64'__pad2'|U32'__flags'|U32'$pad0']#'__data'|ARR56{S8}$S8$'__size'|S64'__align']#$'rwlock']
// file os/unix/threads.c line 30
union anonymous$23;

// tag-#anon#UN[*{V(*{cS8}$cS8$|S32|*{*{cS8}$cS8$}$*{cS8}$cS8$$)->V}$V(*{cS8}$cS8$|S32|*{*{cS8}$cS8$}$*{cS8}$cS8$$)->V$'command_action'|*{V(*{cS8}$cS8$|S32|*{V}$V$)->V}$V(*{cS8}$cS8$|S32|*{V}$V$)->V$'command_action_extend']
// file include/commands.h line 46
union anonymous$16;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'|ARR8{U16}$U16$'__u6_addr16'|ARR4{U32}$U32$'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous$17;

// tag-#anon#UN[ARR32{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous$10;

// tag-#anon#UN[ARR4{S8}$S8$'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$21;

// tag-#anon#UN[ARR8{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 224
union anonymous$22;

// tag-#anon#UN[F64'__align'|ARR1{S8}$S8$'ptr']
// file mem.c line 100
union anonymous$4;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$9;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__nr_readers'|U32'__readers_wakeup'|U32'__writer_wakeup'|U32'__nr_readers_queued'|U32'__nr_writers_queued'|S32'__writer'|S32'__shared'|S8'__rwelision'|ARR7{U8}$U8$'__pad1'|U64'__pad2'|U32'__flags'|U32'$pad0']#'__data'|ARR56{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous$1;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'id']#'sysv'|SYM#tag-#anon#ST[*{SYM#tag-#anon#UN[ARR32{S8}$S8$'__size'|S64'__align']#}$SYM#tag-#anon#UN[ARR32{S8}$S8$'__size'|S64'__align']#$'sem']#'posix'|SYM#tag-#anon#ST[S32'fd']#'file']
// file include/proc_mutex.h line 67
union anonymous$14;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$3;

// tag-#anon#UN[SYM#tag-ci_proc_mutex#'proc_mutex'|SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']#'thread_mutex']
// file cache.c line 90
union anonymous$5;

// tag-#anon#UN[SYM#tag-posix#'posix'|SYM#tag-sysv#'sysv'|S32'id_']
// file include/shared_mem.h line 58
union anonymous$15;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'|r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$0;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'|r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__']$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_ci_align_test
// file include/c-icap.h line 131
struct _ci_align_test;

// tag-access_control_module
// file include/module.h line 76
struct access_control_module;

// tag-acl_cmp_uint64_data
// file acl.c line 175
struct acl_cmp_uint64_data;

// tag-acl_time_data
// file acl.c line 264
struct acl_time_data;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-auth_hash
// file module.c line 424
struct auth_hash;

// tag-authenticator_module
// file include/module.h line 100
struct authenticator_module;

// tag-cfg_default_value
// file include/cfg_param.h line 118
struct cfg_default_value;

// tag-check_reg_data
// file registry.c line 102
struct check_reg_data;

// tag-child_shared_data
// file include/proc_threads_queues.h line 56
struct child_shared_data;

// tag-childs_queue
// file include/proc_threads_queues.h line 76
struct childs_queue;

// tag-ci_MD5Context
// file include/md5.h line 6
struct ci_MD5Context;

// tag-ci_access_entry
// file include/acl.h line 143
struct ci_access_entry;

// tag-ci_acl_data
// file include/acl.h line 96
struct ci_acl_data;

// tag-ci_acl_regex
// file types_ops.c line 227
struct ci_acl_regex;

// tag-ci_acl_spec
// file include/acl.h line 111
struct ci_acl_spec;

// tag-ci_acl_type
// file include/acl.h line 47
struct ci_acl_type;

// tag-ci_acl_type_list
// file include/acl.h line 81
struct ci_acl_type_list;

// tag-ci_array
// file include/array.h line 54
struct ci_array;

// tag-ci_array_item
// file include/array.h line 37
struct ci_array_item;

// tag-ci_buf
// file include/request.h line 60
struct ci_buf;

// tag-ci_cache
// file include/cache.h line 35
struct ci_cache;

// tag-ci_cache_entry
// file cache.c line 78
struct ci_cache_entry;

// tag-ci_cache_type
// file include/cache.h line 42
struct ci_cache_type;

// tag-ci_cached_file
// file include/body.h line 78
struct ci_cached_file;

// tag-ci_command
// file include/commands.h line 42
struct ci_command;

// tag-ci_conf_entry
// file include/cfg_param.h line 85
struct ci_conf_entry;

// tag-ci_connection
// file include/net_io.h line 107
struct ci_connection;

// tag-ci_data_group
// file include/filetype.h line 49
struct ci_data_group;

// tag-ci_data_type
// file include/filetype.h line 43
struct ci_data_type;

// tag-ci_dyn_array
// file include/array.h line 309
struct ci_dyn_array;

// tag-ci_encaps_entity
// file include/header.h line 82
struct ci_encaps_entity;

// tag-ci_error_code
// file include/c-icap.h line 153
struct ci_error_code;

// tag-ci_fmt_entry
// file include/txt_format.h line 41
struct ci_fmt_entry;

// tag-ci_hash_entry
// file include/hash.h line 32
struct ci_hash_entry;

// tag-ci_hash_table
// file include/hash.h line 40
struct ci_hash_table;

// tag-ci_headers_list
// file include/header.h line 71
struct ci_headers_list;

// tag-ci_ip
// file include/net_io.h line 101
struct ci_ip;

// tag-ci_list
// file include/array.h line 598
struct ci_list;

// tag-ci_list_item
// file include/array.h line 585
struct ci_list_item;

// tag-ci_local_cache_data
// file cache.c line 96
struct ci_local_cache_data;

// tag-ci_lookup_table
// file include/lookup_table.h line 43
struct ci_lookup_table;

// tag-ci_lookup_table_type
// file include/lookup_table.h line 44
struct ci_lookup_table_type;

// tag-ci_magic
// file include/filetype.h line 55
struct ci_magic;

// tag-ci_magic_record
// file filetype.c line 57
struct ci_magic_record;

// tag-ci_magics_db
// file include/cfg_param.h line 30
struct ci_magics_db;

// tag-ci_mem_allocator
// file include/mem.h line 32
struct ci_mem_allocator;

// tag-ci_membuf
// file include/body.h line 44
struct ci_membuf;

// tag-ci_options_entry
// file include/cfg_param.h line 109
struct ci_options_entry;

// tag-ci_proc_mutex
// file include/proc_mutex.h line 44
struct ci_proc_mutex;

// tag-ci_proc_mutex_scheme
// file include/proc_mutex.h line 46
struct ci_proc_mutex_scheme;

// tag-ci_regex_match
// file include/ci_regex.h line 32
struct ci_regex_match;

// tag-ci_regex_replace_part
// file include/ci_regex.h line 37
struct ci_regex_replace_part;

// tag-ci_request
// file include/service.h line 62
struct ci_request;

// tag-ci_ring_buf
// file include/body.h line 161
struct ci_ring_buf;

// tag-ci_server_conf
// file include/cfg_param.h line 46
struct ci_server_conf;

// tag-ci_service_module
// file include/service.h line 64
struct ci_service_module;

// tag-ci_service_xdata
// file include/service.h line 76
struct ci_service_xdata;

// tag-ci_shared_mem_id
// file include/shared_mem.h line 35
struct ci_shared_mem_id;

// tag-ci_shared_mem_scheme
// file include/shared_mem.h line 37
struct ci_shared_mem_scheme;

// tag-ci_simple_file
// file include/body.h line 114
struct ci_simple_file;

// tag-ci_sockaddr
// file include/net_io.h line 50
struct ci_sockaddr;

// tag-ci_specs_list
// file include/acl.h line 121
struct ci_specs_list;

// tag-ci_type_ops
// file include/types_ops.h line 31
struct ci_type_ops;

// tag-ci_vector
// file include/array.h line 448
struct ci_vector;

// tag-common_module
// file include/module.h line 58
struct common_module;

// tag-common_mutex
// file cache.c line 88
struct common_mutex;

// tag-connections_queue
// file include/proc_threads_queues.h line 46
struct connections_queue;

// tag-dlib_entry
// file dlib.c line 25
struct dlib_entry;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-group_source
// file http_auth.c line 127
struct group_source;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-http_auth_method
// file include/module.h line 87
struct http_auth_method;

// tag-http_basic_auth_data
// file include/access.h line 46
struct http_basic_auth_data;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-info_req_data
// file info.c line 58
struct info_req_data;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-kbs
// file include/stats.h line 31
struct kbs;

// tag-linger
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 383
struct linger;

// tag-logfile
// file log.c line 190
struct logfile;

// tag-logformat
// file log.c line 107
struct logformat;

// tag-logger_module
// file include/module.h line 66
struct logger_module;

// tag-mem_block_item
// file mem.c line 760
struct mem_block_item;

// tag-mem_buffer_block
// file mem.c line 97
struct mem_buffer_block;

// tag-module_tmp_struct
// file module.c line 345
struct module_tmp_struct;

// tag-module_type
// file include/module.h line 37
enum module_type { UNKNOWN=0, SERVICE_HANDLER=1, LOGGER=2, ACCESS_CONTROLLER=3, AUTH_METHOD=4, AUTHENTICATOR=5, COMMON=6, MODS_TABLE_END=7 };

// tag-modules_list
// file module.c line 32
struct modules_list;

// tag-mutex_itm
// file os/unix/threads.c line 23
struct mutex_itm;

// tag-pack_allocator
// file mem.c line 573
struct pack_allocator;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pcre_extra
// file /usr/include/pcre.h line 376
struct pcre_extra;

// tag-pool_allocator
// file mem.c line 765
struct pool_allocator;

// tag-posix
// file include/shared_mem.h line 60
struct posix;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-real_pcre
// file /usr/include/pcre.h line 324
struct real_pcre;

// tag-schedule_data
// file commands.c line 30
struct schedule_data;

// tag-sembuf
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 41
struct sembuf;

// tag-semid_ds
// file /usr/include/x86_64-linux-gnu/bits/sem.h line 38
struct semid_ds;

// tag-seminfo
// file /usr/include/x86_64-linux-gnu/bits/sem.h line 72
struct seminfo;

// tag-semun
// file os/unix/proc_mutex.c line 47
union semun;

// tag-serial_allocator
// file mem.c line 445
struct serial_allocator;

// tag-server_decl
// file mpmt_server.c line 54
struct server_decl;

// tag-server_statistics
// file include/proc_threads_queues.h line 70
struct server_statistics;

// tag-service_alias
// file include/service.h line 262
struct service_alias;

// tag-service_handler_module
// file include/module.h line 48
struct service_handler_module;

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 153
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-stat_area
// file include/stats.h line 45
struct stat_area;

// tag-stat_entry
// file include/stats.h line 52
struct stat_entry;

// tag-stat_entry_list
// file include/stats.h line 58
struct stat_entry_list;

// tag-stat_groups_list
// file include/stats.h line 64
struct stat_groups_list;

// tag-stat_memblock
// file include/stats.h line 37
struct stat_memblock;

// tag-stats_tmpl
// file info.c line 235
struct stats_tmpl;

// tag-sub_table
// file cfg_param.c line 135
struct sub_table;

// tag-sysv
// file include/shared_mem.h line 65
struct sysv;

// tag-text_table
// file lookup_file_table.c line 49
struct text_table;

// tag-text_table_entry
// file lookup_file_table.c line 43
struct text_table_entry;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// MD5Transform
// file md5.c line 168
static void MD5Transform(unsigned int *buf, unsigned int *in);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __intl_free$object
// 
void __intl_free$object(void *);
// __intl_malloc$object
// 
void * __intl_malloc$object(signed int);
// __log_error$object
// 
void __log_error$object(void *, const char *, ...);
// _os_free
// file request_common.c line 35
static void _os_free(void *ptr);
// _os_malloc
// file request_common.c line 30
static void * _os_malloc(signed int size);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous, unsigned int *);
// access_check_client
// file include/access.h line 55
signed int access_check_client(struct ci_request *req);
// access_check_request
// file include/access.h line 56
signed int access_check_request(struct ci_request *req);
// access_reset
// file access.c line 43
signed int access_reset();
// acl_cmp_uint64_dup
// file acl.c line 182
void * acl_cmp_uint64_dup(const char *str, struct ci_mem_allocator *allocator);
// acl_cmp_uint64_equal
// file acl.c line 187
signed int acl_cmp_uint64_equal(const void *key1, const void *key2);
// acl_cmp_uint64_free
// file acl.c line 202
void acl_cmp_uint64_free(void *key, struct ci_mem_allocator *allocator);
// acl_load_defaults
// file acl.c line 776
static signed int acl_load_defaults();
// acl_time_dup
// file acl.c line 270
void * acl_time_dup(const char *str, struct ci_mem_allocator *allocator);
// acl_time_equal
// file acl.c line 373
signed int acl_time_equal(const void *key1, const void *key2);
// acl_time_free
// file acl.c line 389
void acl_time_free(void *tmd, struct ci_mem_allocator *allocator);
// add_mutex
// file os/unix/threads.c line 66
static struct mutex_itm * add_mutex(void *pmutex, signed int type);
// add_service
// file service.c line 339
struct ci_service_module * add_service(struct ci_service_module *service);
// add_service_alias
// file include/service.h line 272
struct service_alias * add_service_alias(const char *service_alias, const char *service_name, const char *args);
// add_to_modules_list
// file module.c line 95
void * add_to_modules_list(struct modules_list *mod_list, void *module);
// alloc_a_buffer
// file decode.c line 198
static void * alloc_a_buffer(void *op, unsigned int items, unsigned int size);
// alloc_mem_allocator_struct
// file mem.c line 79
static struct ci_mem_allocator * alloc_mem_allocator_struct();
// alloc_text_table_entry
// file lookup_file_table.c line 55
struct text_table_entry * alloc_text_table_entry(signed int val_num, struct ci_mem_allocator *allocator);
// announce_child
// file proc_threads_queues.c line 278
void announce_child(struct childs_queue *q, signed int pid);
// asctime_r
// file /usr/include/time.h line 272
extern char * asctime_r(struct tm *, char *);
// attach_childs_queue
// file proc_threads_queues.c line 170
signed int attach_childs_queue(struct childs_queue *q);
// basic_authentication_header
// file http_auth.c line 448
char * basic_authentication_header();
// basic_close
// file http_auth.c line 409
void basic_close();
// basic_create_auth_data
// file http_auth.c line 417
struct http_basic_auth_data * basic_create_auth_data(const char *auth_line, const char **username);
// basic_post_init
// file http_auth.c line 397
signed int basic_post_init(struct ci_server_conf *server_conf);
// basic_release_auth_data
// file http_auth.c line 443
void basic_release_auth_data(struct http_basic_auth_data *data);
// basic_simple_db_athenticate
// file http_auth.c line 507
signed int basic_simple_db_athenticate(struct http_basic_auth_data *data, const char *usedb);
// basic_simple_db_close
// file http_auth.c line 495
void basic_simple_db_close();
// basic_simple_db_post_init
// file http_auth.c line 483
signed int basic_simple_db_post_init(struct ci_server_conf *server_conf);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous, unsigned int);
// build_statistics
// file info.c line 294
signed int build_statistics(struct info_req_data *info_data);
// byteReverse
// file md5.c line 28
static void byteReverse(unsigned char *buf, unsigned int longs);
// call_authenticators
// file http_auth.c line 44
signed int call_authenticators(struct authenticator_module **authenticators, void *method_data);
// cancel_all_threads
// file mpmt_server.c line 198
static void cancel_all_threads();
// cb_check_command
// file commands.c line 109
signed int cb_check_command(void *data, const void *obj);
// cb_check_queue
// file commands.c line 235
static signed int cb_check_queue(void *data, const void *item);
// cfg_acl_add
// file cfg_param.c line 598
signed int cfg_acl_add(const char *directive, const char **argv, void *setdata);
// cfg_default_acl_access
// file cfg_param.c line 132
signed int cfg_default_acl_access(const char *directive, const char **argv, void *setdata);
// cfg_default_acl_add
// file default_acl.c line 97
signed int cfg_default_acl_add(const char *directive, const char **argv, void *setdata);
// cfg_default_value_replace
// file cfg_param.c line 1038
struct cfg_default_value * cfg_default_value_replace(void *param, void *value);
// cfg_default_value_restore
// file cfg_param.c line 1062
void * cfg_default_value_restore(void *param);
// cfg_default_value_restore_all
// file cfg_param.c line 1077
void cfg_default_value_restore_all();
// cfg_default_value_search
// file cfg_param.c line 1052
struct cfg_default_value * cfg_default_value_search(void *param);
// cfg_default_value_store
// file cfg_param.c line 1009
struct cfg_default_value * cfg_default_value_store(void *param, void *value, signed int size);
// cfg_group_source_by_group
// file cfg_param.c line 639
signed int cfg_group_source_by_group(const char *directive, const char **argv, void *setdata);
// cfg_group_source_by_user
// file cfg_param.c line 649
signed int cfg_group_source_by_user(const char *directive, const char **argv, void *setdata);
// cfg_include_config_file
// file cfg_param.c line 617
signed int cfg_include_config_file(const char *directive, const char **argv, void *setdata);
// cfg_load_magicfile
// file cfg_param.c line 453
signed int cfg_load_magicfile(const char *directive, const char **argv, void *setdata);
// cfg_load_module
// file cfg_param.c line 438
signed int cfg_load_module(const char *directive, const char **argv, void *setdata);
// cfg_load_service
// file cfg_param.c line 404
signed int cfg_load_service(const char *directive, const char **argv, void *setdata);
// cfg_proc_lock_scheme
// file cfg_param.c line 667
signed int cfg_proc_lock_scheme(const char *directive, const char **argv, void *setdata);
// cfg_service_alias
// file cfg_param.c line 421
signed int cfg_service_alias(const char *directive, const char **argv, void *setdata);
// cfg_set_accesslog
// file cfg_param.c line 490
signed int cfg_set_accesslog(const char *directive, const char **argv, void *setdata);
// cfg_set_acl_controllers
// file cfg_param.c line 550
signed int cfg_set_acl_controllers(const char *directive, const char **argv, void *setdata);
// cfg_set_auth_method
// file cfg_param.c line 584
signed int cfg_set_auth_method(const char *directive, const char **argv, void *setdata);
// cfg_set_body_maxmem
// file cfg_param.c line 399
signed int cfg_set_body_maxmem(const char *directive, const char **argv, void *setdata);
// cfg_set_debug_level
// file cfg_param.c line 380
signed int cfg_set_debug_level(const char *directive, const char **argv, void *setdata);
// cfg_set_debug_level_cmd
// file cfg_param.c line 388
signed int cfg_set_debug_level_cmd(const char *directive, const char **argv, void *setdata);
// cfg_set_debug_stdout
// file cfg_param.c line 394
signed int cfg_set_debug_stdout(const char *directive, const char **argv, void *setdata);
// cfg_set_logformat
// file cfg_param.c line 479
signed int cfg_set_logformat(const char *directive, const char **argv, void *setdata);
// cfg_set_logger
// file cfg_param.c line 506
signed int cfg_set_logger(const char *directive, const char **argv, void *setdata);
// cfg_set_tmp_dir
// file cfg_param.c line 521
signed int cfg_set_tmp_dir(const char *directive, const char **argv, void *setdata);
// cfg_shared_mem_scheme
// file cfg_param.c line 659
signed int cfg_shared_mem_scheme(const char *directive, const char **argv, void *setdata);
// cfg_srv_allow206
// file service.c line 202
signed int cfg_srv_allow206(const char *directive, const char **argv, void *setdata);
// cfg_srv_max_connections
// file service.c line 135
signed int cfg_srv_max_connections(const char *directive, const char **argv, void *setdata);
// cfg_srv_options_ttl
// file service.c line 155
signed int cfg_srv_options_ttl(const char *directive, const char **argv, void *setdata);
// cfg_srv_preview_size
// file service.c line 109
signed int cfg_srv_preview_size(const char *directive, const char **argv, void *setdata);
// cfg_srv_transfer_complete
// file service.c line 97
signed int cfg_srv_transfer_complete(const char *directive, const char **argv, void *setdata);
// cfg_srv_transfer_ignore
// file service.c line 85
signed int cfg_srv_transfer_ignore(const char *directive, const char **argv, void *setdata);
// cfg_srv_transfer_preview
// file service.c line 73
signed int cfg_srv_transfer_preview(const char *directive, const char **argv, void *setdata);
// chdir
// file /usr/include/unistd.h line 500
extern signed int chdir(const char *);
// check_ascii
// file filetype.c line 419
signed int check_ascii(unsigned char *buf, signed int buflen);
// check_directive
// file txt_format.c line 200
signed int check_directive(const char *var, const char *directive, signed int *directive_len);
// check_for_exited_childs
// file mpmt_server.c line 351
static void check_for_exited_childs();
// check_magics
// file filetype.c line 368
signed int check_magics(struct ci_magics_db *db, const char *buf, signed int buflen);
// check_realloc
// file request_common.c line 874
static signed int check_realloc(char **buf, signed int *size, signed int used, signed int mustadded);
// check_reg
// file registry.c line 108
static signed int check_reg(void *data, const char *name, const void *val);
// check_request
// file request.c line 427
static signed int check_request(struct ci_request *req);
// check_request$link1
// file access.c line 69
signed int check_request$link1(struct ci_request *req$link1);
// check_tables
// file txt_format.c line 218
struct ci_fmt_entry * check_tables(const char *var, struct ci_fmt_entry *u_table, signed int *directive_len, unsigned int *width, signed int *left_align, char *parameter);
// check_to_add_method_id
// file module.c line 465
signed int check_to_add_method_id(struct auth_hash *hash, signed int method_id);
// check_unicode
// file filetype.c line 495
signed int check_unicode(unsigned char *buf, signed int buflen);
// check_user_group
// file http_auth.c line 211
signed int check_user_group(const char *user, const char *group);
// child_main
// file mpmt_server.c line 848
void child_main(signed int sockfd, signed int pipefd);
// child_signals
// file mpmt_server.c line 140
void child_signals();
// childs_queue_is_empty
// file proc_threads_queues.c line 219
signed int childs_queue_is_empty(struct childs_queue *q);
// childs_queue_stats
// file proc_threads_queues.c line 376
signed int childs_queue_stats(struct childs_queue *q, signed int *childs, signed int *freeservers, signed int *used, signed int *maxrequests);
// ci_MD5Final
// file md5.c line 107
void ci_MD5Final(unsigned char *digest, struct ci_MD5Context *ctx);
// ci_MD5Init
// file md5.c line 44
void ci_MD5Init(struct ci_MD5Context *ctx);
// ci_MD5Update
// file md5.c line 59
void ci_MD5Update(struct ci_MD5Context *ctx, const unsigned char *buf, unsigned long int len);
// ci_access_entry_add_acl
// file acl.c line 468
const struct ci_acl_spec * ci_access_entry_add_acl(struct ci_access_entry *access_entry, const struct ci_acl_spec *acl, signed int negate);
// ci_access_entry_add_acl_by_name
// file include/acl.h line 178
signed int ci_access_entry_add_acl_by_name(struct ci_access_entry *access_entry, const char *acl_name);
// ci_access_entry_match_request
// file include/acl.h line 188
signed int ci_access_entry_match_request(struct ci_access_entry *access_entry, struct ci_request *req);
// ci_access_entry_new
// file include/acl.h line 158
struct ci_access_entry * ci_access_entry_new(struct ci_access_entry **list, signed int type);
// ci_access_entry_release
// file include/acl.h line 166
void ci_access_entry_release(struct ci_access_entry *list);
// ci_acl_add_data
// file include/acl.h line 206
signed int ci_acl_add_data(const char *name, const char *type, const char *data);
// ci_acl_init
// file include/acl.h line 197
void ci_acl_init();
// ci_acl_reset
// file include/acl.h line 203
void ci_acl_reset();
// ci_acl_search
// file include/acl.h line 205
const struct ci_acl_spec * ci_acl_search(const char *name);
// ci_acl_spec_list_release
// file acl.c line 615
void ci_acl_spec_list_release(struct ci_acl_spec *spec);
// ci_acl_spec_new
// file acl.c line 514
struct ci_acl_spec * ci_acl_spec_new(const char *name, const char *type, const char *param, struct ci_acl_type_list *list, struct ci_acl_spec **spec_list);
// ci_acl_spec_new_data
// file acl.c line 552
struct ci_acl_data * ci_acl_spec_new_data(struct ci_acl_spec *spec, const char *val);
// ci_acl_spec_release
// file acl.c line 601
void ci_acl_spec_release(struct ci_acl_spec *cur);
// ci_acl_spec_search
// file acl.c line 583
struct ci_acl_spec * ci_acl_spec_search(struct ci_acl_spec *list, const char *name);
// ci_acl_type_add
// file include/acl.h line 224
signed int ci_acl_type_add(const struct ci_acl_type *type);
// ci_acl_type_search
// file acl.c line 815
const struct ci_acl_type * ci_acl_type_search(const char *name);
// ci_acl_typelist_add
// file acl.c line 638
signed int ci_acl_typelist_add(struct ci_acl_type_list *list, const struct ci_acl_type *type);
// ci_acl_typelist_init
// file acl.c line 630
signed int ci_acl_typelist_init(struct ci_acl_type_list *list);
// ci_acl_typelist_release
// file acl.c line 681
signed int ci_acl_typelist_release(struct ci_acl_type_list *list);
// ci_acl_typelist_reset
// file acl.c line 689
signed int ci_acl_typelist_reset(struct ci_acl_type_list *list);
// ci_acl_typelist_search
// file acl.c line 671
const struct ci_acl_type * ci_acl_typelist_search(struct ci_acl_type_list *list, const char *name);
// ci_args_apply
// file include/cfg_param.h line 200
signed int ci_args_apply(signed int argc, char **argv, struct ci_options_entry *options);
// ci_args_usage
// file include/cfg_param.h line 199
void ci_args_usage(const char *progname, struct ci_options_entry *options);
// ci_array_add
// file include/array.h line 118
const struct ci_array_item * ci_array_add(struct ci_array *array, const char *name, const void *value, unsigned long int size);
// ci_array_destroy
// file include/array.h line 107
void ci_array_destroy(struct ci_array *array);
// ci_array_get_item
// file array.c line 144
const struct ci_array_item * ci_array_get_item(struct ci_array *array, signed int pos);
// ci_array_iterate
// file array.c line 116
void ci_array_iterate(const struct ci_array *array, void *data, signed int (*fn)(void *, const char *, const void *));
// ci_array_iterate::fn$object
// 
//signed int fn$object(void *, const char *, const void *);
// ci_array_new
// file include/array.h line 90
struct ci_array * ci_array_new(unsigned long int size);
// ci_array_new2
// file array.c line 60
struct ci_array * ci_array_new2(unsigned long int items, unsigned long int item_size);
// ci_array_pop
// file array.c line 125
const struct ci_array_item * ci_array_pop(struct ci_array *array);
// ci_array_search
// file include/array.h line 135
const void * ci_array_search(struct ci_array *array, const char *name);
// ci_atol_ext
// file util.c line 78
signed long int ci_atol_ext(const char *str, const char **error);
// ci_base64_decode
// file include/simple_api.h line 139
signed int ci_base64_decode(const char *encoded, char *decoded, signed int len);
// ci_base64_decode_dup
// file decode.c line 88
char * ci_base64_decode_dup(const char *encoded);
// ci_base64_encode
// file decode.c line 111
signed int ci_base64_encode(const unsigned char *data, unsigned long int len, char *out, unsigned long int outlen);
// ci_belongs_to_group
// file filetype.c line 153
signed int ci_belongs_to_group(struct ci_magics_db *db, signed int type, signed int group);
// ci_buf_init
// file request_common.c line 45
void ci_buf_init(struct ci_buf *buf);
// ci_buf_mem_alloc
// file request_common.c line 56
signed int ci_buf_mem_alloc(struct ci_buf *buf, signed int size);
// ci_buf_mem_free
// file request_common.c line 65
void ci_buf_mem_free(struct ci_buf *buf);
// ci_buf_reset
// file request_common.c line 52
void ci_buf_reset(struct ci_buf *buf);
// ci_buf_reset_size
// file include/request.h line 161
signed int ci_buf_reset_size(struct ci_buf *buf, signed int req_size);
// ci_buf_write
// file include/request.h line 160
signed int ci_buf_write(struct ci_buf *buf, char *data, signed int len);
// ci_buffer_alloc
// file include/mem.h line 66
void * ci_buffer_alloc(signed int block_size);
// ci_buffer_blocksize
// file mem.c line 204
unsigned long int ci_buffer_blocksize(const void *data);
// ci_buffer_free
// file include/mem.h line 68
void ci_buffer_free(void *data);
// ci_buffer_realloc
// file include/mem.h line 67
void * ci_buffer_realloc(void *data, signed int block_size);
// ci_buffers_destroy
// file mem.c line 166
void ci_buffers_destroy();
// ci_buffers_init
// file mem.c line 112
signed int ci_buffers_init();
// ci_cache_build
// file cache.c line 387
struct ci_cache * ci_cache_build(const char *name, const char *cache_type, unsigned int cache_size, unsigned int max_object_size, signed int ttl, const struct ci_type_ops *key_ops);
// ci_cache_destroy
// file cache.c line 47
void ci_cache_destroy(struct ci_cache *cache);
// ci_cache_read_vector_val
// file cache.c line 492
void * ci_cache_read_vector_val(const void *val, unsigned long int val_size, void *o);
// ci_cache_search
// file cache.c line 53
const void * ci_cache_search(struct ci_cache *cache, const void *key, void **val, void *data, void * (*dup_from_cache)(const void *, unsigned long int, void *));
// ci_cache_search::dup_from_cache$object
// 
void * dup_from_cache$object(const void *, unsigned long int, void *);
// ci_cache_store_vector_size
// file cache.c line 432
unsigned long int ci_cache_store_vector_size(struct ci_vector *v);
// ci_cache_store_vector_val
// file cache.c line 453
void * ci_cache_store_vector_val(void *buf, const void *val, unsigned long int buf_size);
// ci_cache_type_get
// file cache.c line 42
static const struct ci_cache_type * ci_cache_type_get(const char *name);
// ci_cache_type_register
// file cache.c line 37
void ci_cache_type_register(struct ci_cache_type *type);
// ci_cache_update
// file cache.c line 58
signed int ci_cache_update(struct ci_cache *cache, const void *key, const void *val, unsigned long int val_size, void * (*copy_to_cache)(void *, const void *, unsigned long int));
// ci_cache_update::copy_to_cache$object
// 
void * copy_to_cache$object(void *, const void *, unsigned long int);
// ci_cached_file_destroy
// file body.c line 423
void ci_cached_file_destroy(struct ci_cached_file *body);
// ci_cached_file_new
// file body.c line 360
struct ci_cached_file * ci_cached_file_new(signed int size);
// ci_cached_file_read
// file body.c line 520
signed int ci_cached_file_read(struct ci_cached_file *body, char *buf, signed int len);
// ci_cached_file_release
// file body.c line 442
void ci_cached_file_release(struct ci_cached_file *body);
// ci_cached_file_reset
// file body.c line 398
void ci_cached_file_reset(struct ci_cached_file *body, signed int new_size);
// ci_cached_file_write
// file body.c line 461
signed int ci_cached_file_write(struct ci_cached_file *body, const char *buf, signed int len, signed int iseof);
// ci_cfg_alloc_mem
// file include/cfg_param.h line 152
void * ci_cfg_alloc_mem(signed int size);
// ci_cfg_disable
// file include/cfg_param.h line 178
signed int ci_cfg_disable(const char *directive, const char **argv, void *setdata);
// ci_cfg_enable
// file include/cfg_param.h line 185
signed int ci_cfg_enable(const char *directive, const char **argv, void *setdata);
// ci_cfg_lib_init
// file include/cfg_param.h line 150
void ci_cfg_lib_init();
// ci_cfg_lib_reset
// file include/cfg_param.h line 151
void ci_cfg_lib_reset();
// ci_cfg_onoff
// file include/cfg_param.h line 171
signed int ci_cfg_onoff(const char *directive, const char **argv, void *setdata);
// ci_cfg_set_int
// file include/cfg_param.h line 164
signed int ci_cfg_set_int(const char *directive, const char **argv, void *setdata);
// ci_cfg_set_str
// file include/cfg_param.h line 158
signed int ci_cfg_set_str(const char *directive, const char **argv, void *setdata);
// ci_cfg_size_long
// file include/cfg_param.h line 197
signed int ci_cfg_size_long(const char *directive, const char **argv, void *setdata);
// ci_cfg_size_off
// file include/cfg_param.h line 191
signed int ci_cfg_size_off(const char *directive, const char **argv, void *setdata);
// ci_client_connect_to
// file request_common.c line 984
struct ci_connection * ci_client_connect_to(char *servername, signed int port, signed int proto);
// ci_client_get_server_options
// file request_common.c line 962
signed int ci_client_get_server_options(struct ci_request *req, signed int timeout);
// ci_client_http_headers_completed
// file request_common.c line 1422
signed int ci_client_http_headers_completed(struct ci_request *req);
// ci_client_icapfilter
// file request_common.c line 1303
signed int ci_client_icapfilter(struct ci_request *req, signed int timeout, struct ci_headers_list *req_headers, struct ci_headers_list *resp_headers, void *data_source, signed int (*source_read)(void *, char *, signed int), void *data_dest, signed int (*dest_write)(void *, char *, signed int));
// ci_client_icapfilter::dest_write$object
// 
signed int dest_write$object(void *, char *, signed int);
// ci_client_icapfilter::source_read$object
// 
signed int source_read$object(void *, char *, signed int);
// ci_client_request
// file request_common.c line 662
struct ci_request * ci_client_request(struct ci_connection *conn, char *server, char *service);
// ci_client_request_reuse
// file request_common.c line 679
void ci_client_request_reuse(struct ci_request *req);
// ci_command_register_action
// file commands.c line 203
void ci_command_register_action(const char *name, signed int type, void *data, void (*command_action)(const char *, signed int, void *));
// ci_command_register_action::command_action$object
// 
//void command_action$object(const char *, signed int, void *);
// ci_command_register_ctl_cmd
// file commands.c line 198
void ci_command_register_ctl_cmd(const char *name, signed int type, void (*command_action)(const char *, signed int, const char **));
// ci_command_register_ctl_cmd::command_action$object
// 
//void command_action$object(const char *, signed int, const char **);
// ci_command_schedule
// file commands.c line 227
void ci_command_schedule(const char *name, void *data, signed long int afterSecs);
// ci_command_schedule_on
// file commands.c line 209
void ci_command_schedule_on(const char *name, void *data, signed long int time);
// ci_connection_destroy
// file net_io.c line 191
void ci_connection_destroy(struct ci_connection *connection);
// ci_copy_connection
// file include/net_io.h line 138
void ci_copy_connection(struct ci_connection *dest, struct ci_connection *src);
// ci_copy_sockaddr
// file net_io.c line 68
void ci_copy_sockaddr(struct ci_sockaddr *dest, struct ci_sockaddr *src);
// ci_create_os_allocator
// file mem.c line 424
struct ci_mem_allocator * ci_create_os_allocator();
// ci_create_pack_allocator
// file mem.c line 687
struct ci_mem_allocator * ci_create_pack_allocator(char *memblock, unsigned long int size);
// ci_create_pack_allocator_on_memblock
// file mem.c line 704
struct ci_mem_allocator * ci_create_pack_allocator_on_memblock(char *memblock, unsigned long int size);
// ci_create_pool_allocator
// file mem.c line 888
struct ci_mem_allocator * ci_create_pool_allocator(signed int items_size);
// ci_create_serial_allocator
// file include/mem.h line 48
struct ci_mem_allocator * ci_create_serial_allocator(signed int size);
// ci_dlib_closeall
// file dlib.c line 72
signed int ci_dlib_closeall();
// ci_dlib_entry
// file include/dlib.h line 45
signed int ci_dlib_entry(const char *name, const char *file, void *handle);
// ci_dyn_array_add
// file array.c line 269
const struct ci_array_item * ci_dyn_array_add(struct ci_dyn_array *array, const char *name, const void *value, unsigned long int size);
// ci_dyn_array_destroy
// file array.c line 260
void ci_dyn_array_destroy(struct ci_dyn_array *array);
// ci_dyn_array_iterate
// file array.c line 329
void ci_dyn_array_iterate(const struct ci_dyn_array *array, void *data, signed int (*fn)(void *, const char *, const void *));
// ci_dyn_array_iterate::fn$object
// 
//signed int fn$object(void *, const char *, const void *);
// ci_dyn_array_new
// file array.c line 212
struct ci_dyn_array * ci_dyn_array_new(unsigned long int size);
// ci_dyn_array_new2
// file array.c line 225
struct ci_dyn_array * ci_dyn_array_new2(unsigned long int items, unsigned long int item_size);
// ci_dyn_array_search
// file array.c line 317
const void * ci_dyn_array_search(struct ci_dyn_array *array, const char *name);
// ci_extend_filetype
// file filetype.c line 661
signed int ci_extend_filetype(struct ci_magics_db *db, struct ci_request *req, const char *buf, signed int len, signed int *iscompressed);
// ci_filetype
// file filetype.c line 541
signed int ci_filetype(struct ci_magics_db *db, const char *buf, signed int buflen);
// ci_fill_ip_t
// file net_io.c line 75
void ci_fill_ip_t(struct ci_ip *ip_dest, struct ci_sockaddr *src);
// ci_fill_sockaddr
// file include/net_io.h line 115
void ci_fill_sockaddr(struct ci_sockaddr *addr);
// ci_format_text
// file include/txt_format.h line 75
signed int ci_format_text(struct ci_request *req_data, const char *fmt, char *buffer, signed int len, struct ci_fmt_entry *user_table);
// ci_get_data_group_id
// file filetype.c line 143
signed int ci_get_data_group_id(struct ci_magics_db *db, const char *group);
// ci_get_data_type_id
// file filetype.c line 133
signed int ci_get_data_type_id(struct ci_magics_db *db, const char *name);
// ci_hard_close
// file include/net_io.h line 156
signed int ci_hard_close(signed int fd);
// ci_hash_add
// file include/hash.h line 54
void * ci_hash_add(struct ci_hash_table *htable, const void *key, const void *val);
// ci_hash_build
// file include/hash.h line 49
struct ci_hash_table * ci_hash_build(unsigned int hash_size, const struct ci_type_ops *ops, struct ci_mem_allocator *allocator);
// ci_hash_compute
// file include/hash.h line 48
unsigned int ci_hash_compute(unsigned long int hash_max_value, const void *key, signed int len);
// ci_hash_destroy
// file include/hash.h line 52
void ci_hash_destroy(struct ci_hash_table *htable);
// ci_hash_search
// file include/hash.h line 53
const void * ci_hash_search(struct ci_hash_table *htable, const void *key);
// ci_headers_add
// file include/header.h line 136
const char * ci_headers_add(struct ci_headers_list *h, const char *line);
// ci_headers_addheaders
// file include/header.h line 145
signed int ci_headers_addheaders(struct ci_headers_list *h, const struct ci_headers_list *headers);
// ci_headers_copy_value
// file header.c line 343
const char * ci_headers_copy_value(struct ci_headers_list *h, const char *header, char *buf, unsigned long int len);
// ci_headers_create
// file header.c line 156
struct ci_headers_list * ci_headers_create();
// ci_headers_destroy
// file header.c line 186
void ci_headers_destroy(struct ci_headers_list *h);
// ci_headers_iterate
// file header.c line 424
signed int ci_headers_iterate(struct ci_headers_list *h, void *data, void (*fn)(void *, const char *, const char *));
// ci_headers_iterate::fn$object
// 
//void fn$object(void *, const char *, const char *);
// ci_headers_pack
// file include/header.h line 230
void ci_headers_pack(struct ci_headers_list *h);
// ci_headers_remove
// file header.c line 369
signed int ci_headers_remove(struct ci_headers_list *h, const char *header);
// ci_headers_replace
// file header.c line 414
const char * ci_headers_replace(struct ci_headers_list *h, const char *header, const char *newval);
// ci_headers_reset
// file include/header.h line 119
void ci_headers_reset(struct ci_headers_list *h);
// ci_headers_search
// file header.c line 318
const char * ci_headers_search(struct ci_headers_list *h, const char *header);
// ci_headers_setsize
// file include/header.h line 121
signed int ci_headers_setsize(struct ci_headers_list *h, signed int size);
// ci_headers_unpack
// file include/header.h line 231
signed int ci_headers_unpack(struct ci_headers_list *h);
// ci_headers_value
// file include/header.h line 195
const char * ci_headers_value(struct ci_headers_list *h, const char *header);
// ci_host_to_sockaddr_t
// file include/net_io.h line 136
signed int ci_host_to_sockaddr_t(const char *servername, struct ci_sockaddr *addr, signed int proto);
// ci_http_client_ip
// file simple_api.c line 301
const struct ci_ip * ci_http_client_ip(struct ci_request *req);
// ci_http_content_length
// file simple_api.c line 207
signed long int ci_http_content_length(struct ci_request *req);
// ci_http_request
// file simple_api.c line 234
const char * ci_http_request(struct ci_request *req);
// ci_http_request_add_header
// file include/simple_api.h line 231
const char * ci_http_request_add_header(struct ci_request *req, const char *header);
// ci_http_request_create
// file simple_api.c line 119
signed int ci_http_request_create(struct ci_request *req, signed int has_body);
// ci_http_request_get_header
// file simple_api.c line 195
const char * ci_http_request_get_header(struct ci_request *req, const char *head_name);
// ci_http_request_headers
// file simple_api.c line 52
struct ci_headers_list * ci_http_request_headers(struct ci_request *req);
// ci_http_request_remove_header
// file simple_api.c line 173
signed int ci_http_request_remove_header(struct ci_request *req, const char *header);
// ci_http_request_reset_headers
// file simple_api.c line 79
signed int ci_http_request_reset_headers(struct ci_request *req);
// ci_http_request_url
// file simple_api.c line 257
signed int ci_http_request_url(struct ci_request *req, char *buf, signed int buf_size);
// ci_http_response_add_header
// file include/simple_api.h line 219
const char * ci_http_response_add_header(struct ci_request *req, const char *header);
// ci_http_response_create
// file include/simple_api.h line 321
signed int ci_http_response_create(struct ci_request *req, signed int has_reshdr, signed int has_body);
// ci_http_response_get_header
// file simple_api.c line 184
const char * ci_http_response_get_header(struct ci_request *req, const char *head_name);
// ci_http_response_headers
// file simple_api.c line 39
struct ci_headers_list * ci_http_response_headers(struct ci_request *req);
// ci_http_response_remove_header
// file simple_api.c line 162
signed int ci_http_response_remove_header(struct ci_request *req, const char *header);
// ci_http_response_reset_headers
// file simple_api.c line 70
signed int ci_http_response_reset_headers(struct ci_request *req);
// ci_icap_add_xheader
// file simple_api.c line 246
const char * ci_icap_add_xheader(struct ci_request *req, const char *header);
// ci_icap_append_xheaders
// file simple_api.c line 251
signed int ci_icap_append_xheaders(struct ci_request *req, struct ci_headers_list *headers);
// ci_inet_aton
// file include/net_io.h line 119
signed int ci_inet_aton(signed int af, const char *cp, void *addr);
// ci_inet_ntoa
// file include/net_io.h line 120
const char * ci_inet_ntoa(signed int af, const void *src, char *dst, signed int cnt);
// ci_internal_time
// file cache.c line 32
signed long int ci_internal_time();
// ci_linger_close
// file include/net_io.h line 155
signed int ci_linger_close(signed int fd, signed int timeout);
// ci_list_cmp_handler
// file array.c line 536
void ci_list_cmp_handler(struct ci_list *list, signed int (*cmp_func)(const void *, const void *, unsigned long int));
// ci_list_cmp_handler::cmp_func$object
// 
signed int cmp_func$object(const void *, const void *, unsigned long int);
// ci_list_copy_handler
// file array.c line 546
void ci_list_copy_handler(struct ci_list *list, signed int (*copy_func)(void *, const void *));
// ci_list_copy_handler::copy_func$object
// 
signed int copy_func$object(void *, const void *);
// ci_list_create
// file include/array.h line 619
struct ci_list * ci_list_create(unsigned long int init_size, unsigned long int obj_size);
// ci_list_destroy
// file include/array.h line 662
void ci_list_destroy(struct ci_list *list);
// ci_list_free_handler
// file array.c line 541
void ci_list_free_handler(struct ci_list *list, void (*free_func)(void *));
// ci_list_free_handler::free_func$object
// 
void free_func$object(void *);
// ci_list_iterate
// file include/array.h line 671
void ci_list_iterate(struct ci_list *list, void *data, signed int (*fn)(void *, const void *));
// ci_list_iterate::fn$object
// 
//signed int fn$object(void *, const void *);
// ci_list_pop
// file array.c line 617
void * ci_list_pop(struct ci_list *list, void *data);
// ci_list_pop_back
// file array.c line 647
void * ci_list_pop_back(struct ci_list *list, void *data);
// ci_list_push
// file include/array.h line 680
const void * ci_list_push(struct ci_list *list, const void *data);
// ci_list_push_back
// file array.c line 603
const void * ci_list_push_back(struct ci_list *list, const void *data);
// ci_list_remove
// file include/array.h line 716
signed int ci_list_remove(struct ci_list *list, const void *obj);
// ci_list_remove::1::cmp_func$object
// 
signed int cmp_func$object(const void *, const void *, unsigned long int);
// ci_list_search
// file include/array.h line 725
const void * ci_list_search(struct ci_list *list, const void *data);
// ci_list_search2
// file array.c line 742
const void * ci_list_search2(struct ci_list *list, const void *data, signed int (*cmp_func)(const void *, const void *, unsigned long int));
// ci_list_search2::cmp_func$object
// 
signed int cmp_func$object(const void *, const void *, unsigned long int);
// ci_list_search::1::cmp_func$object
// 
signed int cmp_func$object(const void *, const void *, unsigned long int);
// ci_list_sort
// file array.c line 752
void ci_list_sort(struct ci_list *list);
// ci_list_sort2
// file array.c line 766
void ci_list_sort2(struct ci_list *list, signed int (*cmp_func)(const void *, const void *, unsigned long int));
// ci_list_sort2::cmp_func$object
// 
signed int cmp_func$object(const void *, const void *, unsigned long int);
// ci_list_sort::1::cmp_func$object
// 
signed int cmp_func$object(const void *, const void *, unsigned long int);
// ci_local_cache_destroy
// file cache.c line 217
void ci_local_cache_destroy(struct ci_cache *cache);
// ci_local_cache_init
// file cache.c line 135
signed int ci_local_cache_init(struct ci_cache *cache, const char *name);
// ci_local_cache_search
// file cache.c line 238
const void * ci_local_cache_search(struct ci_cache *cache, const void *key, void **val, void *data, void * (*dup_from_cache)(const void *, unsigned long int, void *));
// ci_local_cache_search::dup_from_cache$object
// 
void * dup_from_cache$object(const void *, unsigned long int, void *);
// ci_local_cache_update
// file cache.c line 277
signed int ci_local_cache_update(struct ci_cache *cache, const void *key, const void *val, unsigned long int val_size, void * (*copy_to_cache)(void *, const void *, unsigned long int));
// ci_local_cache_update::copy_to_cache$object
// 
void * copy_to_cache$object(void *, const void *, unsigned long int);
// ci_lookup_table_create
// file include/lookup_table.h line 86
struct ci_lookup_table * ci_lookup_table_create(const char *table);
// ci_lookup_table_create_ext
// file lookup_table.c line 69
struct ci_lookup_table * ci_lookup_table_create_ext(const char *table, const struct ci_type_ops *key_ops, const struct ci_type_ops *val_ops, struct ci_mem_allocator *allocator);
// ci_lookup_table_destroy
// file include/lookup_table.h line 94
void ci_lookup_table_destroy(struct ci_lookup_table *lt);
// ci_lookup_table_get_row
// file lookup_table.c line 228
const char * ci_lookup_table_get_row(struct ci_lookup_table *table, const char *key, const char **columns, char ***vals);
// ci_lookup_table_open
// file lookup_table.c line 172
void * ci_lookup_table_open(struct ci_lookup_table *table);
// ci_lookup_table_release_result
// file lookup_table.c line 196
void ci_lookup_table_release_result(struct ci_lookup_table *table, void **val);
// ci_lookup_table_search
// file lookup_table.c line 181
const char * ci_lookup_table_search(struct ci_lookup_table *table, const char *key, char ***vals);
// ci_lookup_table_type_register
// file lookup_table.c line 36
struct ci_lookup_table_type * ci_lookup_table_type_register(struct ci_lookup_table_type *lt_type);
// ci_lookup_table_type_search
// file lookup_table.c line 58
struct ci_lookup_table_type * ci_lookup_table_type_search(const char *type);
// ci_lookup_table_type_unregister
// file lookup_table.c line 46
void ci_lookup_table_type_unregister(struct ci_lookup_table_type *lt_type);
// ci_magic_data_type
// file filetype.c line 711
signed int ci_magic_data_type(const char *buf, signed int len);
// ci_magic_data_type_ext
// file filetype.c line 720
signed int ci_magic_data_type_ext(struct ci_headers_list *headers, const char *buf, signed int len, signed int *iscompressed);
// ci_magic_db_free
// file include/filetype.h line 106
void ci_magic_db_free();
// ci_magic_db_load
// file include/filetype.h line 104
struct ci_magics_db * ci_magic_db_load(const char *filename);
// ci_magic_group_check
// file filetype.c line 745
signed int ci_magic_group_check(signed int type, signed int group);
// ci_magic_group_id
// file filetype.c line 737
signed int ci_magic_group_id(const char *group);
// ci_magic_group_name
// file filetype.c line 783
char * ci_magic_group_name(signed int group);
// ci_magic_groups_count
// file filetype.c line 760
signed int ci_magic_groups_count();
// ci_magic_req_data_type
// file filetype.c line 694
signed int ci_magic_req_data_type(struct ci_request *req, signed int *isencoded);
// ci_magic_type_descr
// file filetype.c line 774
char * ci_magic_type_descr(signed int type);
// ci_magic_type_id
// file filetype.c line 729
signed int ci_magic_type_id(const char *name);
// ci_magic_type_name
// file filetype.c line 765
char * ci_magic_type_name(signed int type);
// ci_magic_types_count
// file filetype.c line 754
signed int ci_magic_types_count();
// ci_magics_db_build
// file filetype.c line 358
struct ci_magics_db * ci_magics_db_build(const char *filename);
// ci_magics_db_file_add
// file filetype.c line 302
signed int ci_magics_db_file_add(struct ci_magics_db *db, const char *filename);
// ci_magics_db_init
// file filetype.c line 267
struct ci_magics_db * ci_magics_db_init();
// ci_magics_db_release
// file filetype.c line 294
void ci_magics_db_release(struct ci_magics_db *db);
// ci_mem_allocator_destroy
// file mem.c line 62
void ci_mem_allocator_destroy(struct ci_mem_allocator *allocator);
// ci_membuf_attr_add
// file body.c line 244
signed int ci_membuf_attr_add(struct ci_membuf *body, const char *attr, const void *val, unsigned long int val_size);
// ci_membuf_attr_get
// file body.c line 256
const void * ci_membuf_attr_get(struct ci_membuf *body, const char *attr);
// ci_membuf_free
// file include/body.h line 57
void ci_membuf_free(struct ci_membuf *b);
// ci_membuf_from_content
// file body.c line 108
struct ci_membuf * ci_membuf_from_content(char *buf, unsigned long int buf_size, unsigned long int content_size, unsigned int flags);
// ci_membuf_new
// file include/body.h line 54
struct ci_membuf * ci_membuf_new();
// ci_membuf_new_sized
// file body.c line 87
struct ci_membuf * ci_membuf_new_sized(signed int size);
// ci_membuf_read
// file include/body.h line 59
signed int ci_membuf_read(struct ci_membuf *b, char *data, signed int len);
// ci_membuf_set_flag
// file body.c line 158
unsigned int ci_membuf_set_flag(struct ci_membuf *body, unsigned int flag);
// ci_membuf_truncate
// file body.c line 263
signed int ci_membuf_truncate(struct ci_membuf *body, signed int new_size);
// ci_membuf_write
// file include/body.h line 58
signed int ci_membuf_write(struct ci_membuf *b, const char *data, signed int len, signed int iseof);
// ci_mktemp_file
// file include/util.h line 34
signed int ci_mktemp_file(char *dir, char *template, char *filename);
// ci_module_load
// file include/dlib.h line 40
void * ci_module_load(const char *module_file, const char *default_path);
// ci_module_sym
// file include/dlib.h line 41
void * ci_module_sym(void *handle, const char *symbol);
// ci_module_unload
// file include/dlib.h line 42
signed int ci_module_unload(void *handle, const char *name);
// ci_named_pipe_close
// file mpmt_server.c line 460
void ci_named_pipe_close(signed int pipe_fd);
// ci_named_pipe_create
// file mpmt_server.c line 442
signed int ci_named_pipe_create(char *name);
// ci_named_pipe_open
// file mpmt_server.c line 453
signed int ci_named_pipe_open(char *name);
// ci_netio_init
// file include/net_io.h line 149
signed int ci_netio_init(signed int fd);
// ci_object_pool_alloc
// file include/mem.h line 73
void * ci_object_pool_alloc(signed int id);
// ci_object_pool_free
// file include/mem.h line 74
void ci_object_pool_free(void *ptr);
// ci_object_pool_register
// file include/mem.h line 71
signed int ci_object_pool_register(const char *name, signed int size);
// ci_object_pool_unregister
// file include/mem.h line 72
void ci_object_pool_unregister(signed int id);
// ci_object_pools_destroy
// file mem.c line 310
void ci_object_pools_destroy();
// ci_object_pools_init
// file mem.c line 305
signed int ci_object_pools_init();
// ci_pack_allocator_alloc
// file mem.c line 604
void * ci_pack_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size);
// ci_pack_allocator_alloc_from_rear
// file mem.c line 610
void * ci_pack_allocator_alloc_from_rear(struct ci_mem_allocator *allocator, signed int size);
// ci_pack_allocator_alloc_unaligned
// file mem.c line 582
void * ci_pack_allocator_alloc_unaligned(struct ci_mem_allocator *allocator, unsigned long int size);
// ci_pack_allocator_data_size
// file mem.c line 722
signed int ci_pack_allocator_data_size(struct ci_mem_allocator *allocator);
// ci_pack_allocator_destroy
// file mem.c line 647
void ci_pack_allocator_destroy(struct ci_mem_allocator *allocator);
// ci_pack_allocator_free
// file mem.c line 633
void ci_pack_allocator_free(struct ci_mem_allocator *allocator, void *p);
// ci_pack_allocator_required_size
// file mem.c line 730
unsigned long int ci_pack_allocator_required_size();
// ci_pack_allocator_reset
// file mem.c line 638
void ci_pack_allocator_reset(struct ci_mem_allocator *allocator);
// ci_pack_allocator_set_end_pos
// file mem.c line 746
void ci_pack_allocator_set_end_pos(struct ci_mem_allocator *allocator, void *p);
// ci_pack_allocator_set_start_pos
// file mem.c line 737
void ci_pack_allocator_set_start_pos(struct ci_mem_allocator *allocator, void *p);
// ci_parse_key_value_list
// file util.c line 163
struct ci_dyn_array * ci_parse_key_value_list(const char *str, char sep);
// ci_proc_mutex_default_scheme
// file os/unix/proc_mutex.c line 254
const struct ci_proc_mutex_scheme * ci_proc_mutex_default_scheme();
// ci_proc_mutex_destroy
// file include/proc_mutex.h line 91
signed int ci_proc_mutex_destroy(struct ci_proc_mutex *mutex);
// ci_proc_mutex_init
// file include/proc_mutex.h line 88
signed int ci_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name);
// ci_proc_mutex_lock
// file include/proc_mutex.h line 89
signed int ci_proc_mutex_lock(struct ci_proc_mutex *mutex);
// ci_proc_mutex_set_scheme
// file include/proc_mutex.h line 93
signed int ci_proc_mutex_set_scheme(const char *scheme);
// ci_proc_mutex_unlock
// file include/proc_mutex.h line 90
signed int ci_proc_mutex_unlock(struct ci_proc_mutex *mutex);
// ci_ptr_array_add
// file array.c line 165
const struct ci_array_item * ci_ptr_array_add(struct ci_array *ptr_array, const char *name, void *value);
// ci_ptr_array_new2
// file array.c line 151
struct ci_array * ci_ptr_array_new2(unsigned long int items);
// ci_ptr_array_pop
// file array.c line 189
const struct ci_array_item * ci_ptr_array_pop(struct ci_array *ptr_array);
// ci_ptr_array_pop_value
// file array.c line 200
void * ci_ptr_array_pop_value(struct ci_array *ptr_array, char *name, unsigned long int name_size);
// ci_ptr_array_search
// file array.c line 160
void * ci_ptr_array_search(struct ci_array *array, const char *name);
// ci_ptr_dyn_array_add
// file array.c line 336
const struct ci_array_item * ci_ptr_dyn_array_add(struct ci_dyn_array *array, const char *name, void *value);
// ci_ptr_vector_add
// file array.c line 479
void * ci_ptr_vector_add(struct ci_vector *vector, void *value);
// ci_read
// file os/unix/net_io.c line 253
signed int ci_read(signed int fd, void *buf, unsigned long int count, signed int timeout);
// ci_read_icap_header
// file request.c line 186
static signed int ci_read_icap_header(struct ci_request *req, struct ci_headers_list *h, signed int timeout);
// ci_read_nonblock
// file include/net_io.h line 152
signed int ci_read_nonblock(signed int fd, void *buf, unsigned long int count);
// ci_regex_apply
// file include/ci_regex.h line 46
signed int ci_regex_apply(void * const regex, const char *str, signed int len, signed int recurs, struct ci_list *matches, const void *user_data);
// ci_regex_build
// file include/ci_regex.h line 44
void * ci_regex_build(const char *regex_str, signed int regex_flags);
// ci_regex_free
// file include/ci_regex.h line 45
void ci_regex_free(void *regex);
// ci_regex_parse
// file include/ci_regex.h line 43
char * ci_regex_parse(const char *str, signed int *flags, signed int *recursive);
// ci_registry_add_item
// file include/registry.h line 34
signed int ci_registry_add_item(const char *name, const char *label, const void *obj);
// ci_registry_clean
// file include/registry.h line 31
void ci_registry_clean();
// ci_registry_create
// file registry.c line 29
signed int ci_registry_create(const char *name);
// ci_registry_get_id
// file registry.c line 119
signed int ci_registry_get_id(const char *name);
// ci_registry_get_item
// file include/registry.h line 35
const void * ci_registry_get_item(const char *name, const char *label);
// ci_registry_id_get_item
// file registry.c line 147
const void * ci_registry_id_get_item(signed int reg_id, const char *label);
// ci_registry_id_iterate
// file registry.c line 135
signed int ci_registry_id_iterate(signed int reg_id, void *data, signed int (*fn)(void *, const char *, const void *));
// ci_registry_id_iterate::fn$object
// 
//signed int fn$object(void *, const char *, const void *);
// ci_registry_iterate
// file registry.c line 65
signed int ci_registry_iterate(const char *name, void *data, signed int (*fn)(void *, const char *, const void *));
// ci_registry_iterate::fn$object
// 
//signed int fn$object(void *, const char *, const void *);
// ci_request_206_origin_body
// file request_common.c line 436
signed int ci_request_206_origin_body(struct ci_request *req, unsigned long int offset);
// ci_request_alloc
// file include/request.h line 169
struct ci_request * ci_request_alloc(struct ci_connection *connection);
// ci_request_alloc_entity
// file include/request.h line 174
struct ci_encaps_entity * ci_request_alloc_entity(struct ci_request *req, signed int type, signed int val);
// ci_request_destroy
// file include/request.h line 171
void ci_request_destroy(struct ci_request *req);
// ci_request_pack
// file request_common.c line 152
void ci_request_pack(struct ci_request *req);
// ci_request_release_entity
// file include/request.h line 175
signed int ci_request_release_entity(struct ci_request *req, signed int pos);
// ci_request_reset
// file include/request.h line 170
void ci_request_reset(struct ci_request *req);
// ci_request_set_log_str
// file request_common.c line 405
char * ci_request_set_log_str(struct ci_request *req, char *logstr);
// ci_request_set_str_attribute
// file request_common.c line 419
signed int ci_request_set_str_attribute(struct ci_request *req, const char *name, const char *value);
// ci_request_t_pack
// file request_common.c line 92
void ci_request_t_pack(struct ci_request *req, signed int is_request);
// ci_response_pack
// file include/request.h line 173
void ci_response_pack(struct ci_request *req);
// ci_ring_buf_consume
// file body.c line 931
void ci_ring_buf_consume(struct ci_ring_buf *buf, signed int len);
// ci_ring_buf_destroy
// file body.c line 882
void ci_ring_buf_destroy(struct ci_ring_buf *buf);
// ci_ring_buf_is_empty
// file body.c line 888
signed int ci_ring_buf_is_empty(struct ci_ring_buf *buf);
// ci_ring_buf_new
// file body.c line 863
struct ci_ring_buf * ci_ring_buf_new(signed int size);
// ci_ring_buf_produce
// file body.c line 942
void ci_ring_buf_produce(struct ci_ring_buf *buf, signed int len);
// ci_ring_buf_read
// file body.c line 975
signed int ci_ring_buf_read(struct ci_ring_buf *buf, char *data, signed int size);
// ci_ring_buf_read_block
// file body.c line 912
signed int ci_ring_buf_read_block(struct ci_ring_buf *buf, char **rb, signed int *len);
// ci_ring_buf_write
// file body.c line 955
signed int ci_ring_buf_write(struct ci_ring_buf *buf, const char *data, signed int size);
// ci_ring_buf_write_block
// file body.c line 893
signed int ci_ring_buf_write_block(struct ci_ring_buf *buf, char **wb, signed int *len);
// ci_service_add_xincludes
// file service_lib.c line 125
void ci_service_add_xincludes(struct ci_service_xdata *srv_xdata, char **xincludes);
// ci_service_add_xopts
// file service_lib.c line 118
void ci_service_add_xopts(struct ci_service_xdata *srv_xdata, unsigned long int xopts);
// ci_service_data_read_lock
// file include/service.h line 282
void ci_service_data_read_lock(struct ci_service_xdata *srv_xdata);
// ci_service_data_read_unlock
// file include/service.h line 283
void ci_service_data_read_unlock(struct ci_service_xdata *srv_xdata);
// ci_service_enable_204
// file service_lib.c line 82
void ci_service_enable_204(struct ci_service_xdata *srv_xdata);
// ci_service_enable_206
// file service_lib.c line 89
void ci_service_enable_206(struct ci_service_xdata *srv_xdata);
// ci_service_set_istag
// file service_lib.c line 35
void ci_service_set_istag(struct ci_service_xdata *srv_xdata, const char *istag);
// ci_service_set_max_connections
// file include/service.h line 419
void ci_service_set_max_connections(struct ci_service_xdata *srv_xdata, signed int max_connections);
// ci_service_set_options_ttl
// file include/service.h line 428
void ci_service_set_options_ttl(struct ci_service_xdata *srv_xdata, signed int ttl);
// ci_service_set_preview
// file include/service.h line 391
void ci_service_set_preview(struct ci_service_xdata *srv_xdata, signed int preview);
// ci_service_set_transfer_complete
// file include/service.h line 382
void ci_service_set_transfer_complete(struct ci_service_xdata *srv_xdata, const char *complete);
// ci_service_set_transfer_ignore
// file include/service.h line 366
void ci_service_set_transfer_ignore(struct ci_service_xdata *srv_xdata, const char *ignore);
// ci_service_set_transfer_preview
// file include/service.h line 350
void ci_service_set_transfer_preview(struct ci_service_xdata *srv_xdata, const char *preview);
// ci_service_set_xopts
// file include/service.h line 325
void ci_service_set_xopts(struct ci_service_xdata *srv_xdata, unsigned long int xopts);
// ci_shared_mem_attach
// file include/shared_mem.h line 75
void * ci_shared_mem_attach(struct ci_shared_mem_id *id);
// ci_shared_mem_create
// file include/shared_mem.h line 74
void * ci_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size);
// ci_shared_mem_destroy
// file include/shared_mem.h line 77
signed int ci_shared_mem_destroy(struct ci_shared_mem_id *id);
// ci_shared_mem_detach
// file include/shared_mem.h line 76
signed int ci_shared_mem_detach(struct ci_shared_mem_id *id);
// ci_shared_mem_set_scheme
// file include/shared_mem.h line 80
signed int ci_shared_mem_set_scheme(const char *name);
// ci_simple_file_destroy
// file body.c line 643
void ci_simple_file_destroy(struct ci_simple_file *body);
// ci_simple_file_named_new
// file body.c line 601
struct ci_simple_file * ci_simple_file_named_new(char *dir, char *filename, signed long int maxsize);
// ci_simple_file_new
// file body.c line 571
struct ci_simple_file * ci_simple_file_new(signed long int maxsize);
// ci_simple_file_read
// file body.c line 750
signed int ci_simple_file_read(struct ci_simple_file *body, char *buf, signed int len);
// ci_simple_file_release
// file body.c line 665
void ci_simple_file_release(struct ci_simple_file *body);
// ci_simple_file_to_const_string
// file body.c line 824
const char * ci_simple_file_to_const_string(struct ci_simple_file *body);
// ci_simple_file_to_membuf
// file body.c line 848
struct ci_membuf * ci_simple_file_to_membuf(struct ci_simple_file *body, unsigned int flags);
// ci_simple_file_truncate
// file body.c line 797
signed int ci_simple_file_truncate(struct ci_simple_file *body, signed long int new_size);
// ci_simple_file_write
// file body.c line 686
signed int ci_simple_file_write(struct ci_simple_file *body, const char *buf, signed int len, signed int iseof);
// ci_sockaddr_set_port
// file include/net_io.h line 131
void ci_sockaddr_set_port(struct ci_sockaddr *addr, signed int port);
// ci_sockaddr_t_to_host
// file include/net_io.h line 135
const char * ci_sockaddr_t_to_host(struct ci_sockaddr *addr, char *hname, signed int maxhostlen);
// ci_sockaddr_t_to_ip
// file include/net_io.h line 123
const char * ci_sockaddr_t_to_ip(struct ci_sockaddr *addr, char *ip, signed int maxlen);
// ci_stat_area_construct
// file stats.c line 198
struct stat_area * ci_stat_area_construct(void *mem_block, signed int size, void (*release_mem)(void *));
// ci_stat_area_construct::release_mem$object
// 
void release_mem$object(void *);
// ci_stat_area_destroy
// file stats.c line 236
void ci_stat_area_destroy(struct stat_area *area);
// ci_stat_area_kbs_inc
// file stats.c line 257
void ci_stat_area_kbs_inc(struct stat_area *area, signed int ID, signed int count);
// ci_stat_area_merge
// file stats.c line 322
void ci_stat_area_merge(struct stat_area *dest, struct stat_area *src);
// ci_stat_area_reset
// file stats.c line 221
void ci_stat_area_reset(struct stat_area *area);
// ci_stat_area_uint64_inc
// file stats.c line 245
void ci_stat_area_uint64_inc(struct stat_area *area, signed int ID, signed int count);
// ci_stat_attach_mem
// file include/stats.h line 81
void ci_stat_attach_mem(void *mem_block, signed int size, void (*release_mem)(void *));
// ci_stat_attach_mem::release_mem$object
// 
void release_mem$object(void *);
// ci_stat_entry_register
// file include/stats.h line 78
signed int ci_stat_entry_register(char *label, signed int type, char *group);
// ci_stat_entry_release_lists
// file stats.c line 146
void ci_stat_entry_release_lists();
// ci_stat_kbs_inc
// file stats.c line 179
void ci_stat_kbs_inc(signed int ID, signed int count);
// ci_stat_memblock_merge
// file include/stats.h line 94
void ci_stat_memblock_merge(struct stat_memblock *dest_block, struct stat_memblock *mem_block);
// ci_stat_memblock_reset
// file include/stats.h line 95
void ci_stat_memblock_reset(struct stat_memblock *block);
// ci_stat_memblock_size
// file include/stats.h line 77
signed int ci_stat_memblock_size(void);
// ci_stat_release
// file stats.c line 160
void ci_stat_release();
// ci_stat_uint64_inc
// file stats.c line 168
void ci_stat_uint64_inc(signed int ID, signed int count);
// ci_str_trim
// file util.c line 108
void ci_str_trim(char *str);
// ci_str_trim2
// file util.c line 131
char * ci_str_trim2(char *s);
// ci_str_vector_iterate
// file array.c line 461
void ci_str_vector_iterate(const struct ci_vector *vector, void *data, signed int (*fn)(void *, const char *));
// ci_str_vector_iterate::fn$object
// 
//signed int fn$object(void *, const char *);
// ci_str_vector_search
// file include/array.h line 549
const char * ci_str_vector_search(struct ci_vector *vector, const char *item);
// ci_strcasestr
// file util.c line 43
const char * ci_strcasestr(const char *str, const char *find);
// ci_strerror
// file include/util.h line 57
char * ci_strerror(signed int error, char *buf, unsigned long int buflen);
// ci_strncasestr
// file util.c line 59
const char * ci_strncasestr(const char *s, const char *find, unsigned long int slen);
// ci_strnstr
// file include/util.h line 44
const char * ci_strnstr(const char *s, const char *find, unsigned long int slen);
// ci_strtime
// file include/util.h line 32
void ci_strtime(char *buf);
// ci_strtime_rfc822
// file include/util.h line 33
void ci_strtime_rfc822(char *buf);
// ci_thread_cond_destroy
// file include/ci_threads.h line 62
signed int ci_thread_cond_destroy(union anonymous$9 *pcond);
// ci_thread_cond_init
// file include/ci_threads.h line 61
signed int ci_thread_cond_init(union anonymous$9 *pcond);
// ci_thread_create
// file include/ci_threads.h line 67
signed int ci_thread_create(unsigned long int *pthread_id, void * (*pfunc)(void *), void *parg);
// ci_thread_create::pfunc$object
// 
void * pfunc$object(void *);
// ci_thread_join
// file include/ci_threads.h line 68
signed int ci_thread_join(unsigned long int thread_id);
// ci_thread_mutex_destroy
// file include/ci_threads.h line 40
signed int ci_thread_mutex_destroy(union anonymous$3 *pmutex);
// ci_thread_mutex_init
// file include/ci_threads.h line 39
signed int ci_thread_mutex_init(union anonymous$3 *pmutex);
// ci_thread_rwlock_destroy
// file include/ci_threads.h line 48
signed int ci_thread_rwlock_destroy(union anonymous$1 *rwlock);
// ci_thread_rwlock_init
// file include/ci_threads.h line 47
signed int ci_thread_rwlock_init(union anonymous$1 *rwlock);
// ci_txt_template_build_content
// file txtTemplate.c line 396
struct ci_membuf * ci_txt_template_build_content(const struct ci_request *req, const char *SERVICE_NAME, const char *TEMPLATE_NAME, struct ci_fmt_entry *user_table);
// ci_txt_template_close
// file include/txtTemplate.h line 40
void ci_txt_template_close(void);
// ci_txt_template_init
// file include/txtTemplate.h line 39
signed int ci_txt_template_init(void);
// ci_txt_template_reset
// file txtTemplate.c line 181
void ci_txt_template_reset(void);
// ci_txt_template_set_default_lang
// file txtTemplate.c line 104
void ci_txt_template_set_default_lang(const char *lang);
// ci_txt_template_set_dir
// file include/txtTemplate.h line 41
void ci_txt_template_set_dir(const char *dir);
// ci_uncompress_preview
// file decode.c line 313
signed int ci_uncompress_preview(signed int compress_method, const char *buf, signed int len, char *unzipped_buf, signed int *unzipped_buf_len);
// ci_usleep
// file include/util.h line 35
signed int ci_usleep(unsigned long int usec);
// ci_vector_add
// file include/array.h line 480
void * ci_vector_add(struct ci_vector *vector, const void *value, unsigned long int size);
// ci_vector_cast_from_voidvoid
// file array.c line 386
struct ci_vector * ci_vector_cast_from_voidvoid(const void **p);
// ci_vector_cast_to_voidvoid
// file array.c line 381
const void ** ci_vector_cast_to_voidvoid(struct ci_vector *vector);
// ci_vector_create
// file include/array.h line 463
struct ci_vector * ci_vector_create(unsigned long int max_size);
// ci_vector_destroy
// file array.c line 398
void ci_vector_destroy(struct ci_vector *vector);
// ci_vector_iterate
// file array.c line 452
void ci_vector_iterate(const struct ci_vector *vector, void *data, signed int (*fn)(void *, const void *));
// ci_vector_iterate::fn$object
// 
//signed int fn$object(void *, const void *);
// ci_vector_pop
// file array.c line 427
void * ci_vector_pop(struct ci_vector *vector);
// ci_wait_for_data
// file include/net_io.h line 144
signed int ci_wait_for_data(signed int fd, signed int secs, signed int what_wait);
// ci_write
// file include/net_io.h line 151
signed int ci_write(signed int fd, const void *buf, unsigned long int count, signed int timeout);
// ci_write_nonblock
// file include/net_io.h line 153
signed int ci_write_nonblock(signed int fd, const void *buf, unsigned long int count);
// ci_writen
// file request_common.c line 801
static signed int ci_writen(signed int fd, char *buf, signed int len, signed int timeout);
// clear_pid
// file aserver.c line 50
signed int clear_pid(char *pidfile);
// client_build_headers
// file request_common.c line 1281
static signed int client_build_headers(struct ci_request *req, signed int has_reqhdr, signed int has_reshdr, signed int has_body);
// client_create_request
// file request_common.c line 724
static signed int client_create_request(struct ci_request *req, char *servername, char *service, signed int reqtype);
// client_parse_encaps_header
// file request_common.c line 921
static signed int client_parse_encaps_header(struct ci_request *req, struct ci_headers_list *h, signed int size);
// client_parse_icap_header
// file request_common.c line 891
static signed int client_parse_icap_header(struct ci_request *req, struct ci_headers_list *h);
// client_parse_incoming_data
// file request_common.c line 1082
static signed int client_parse_incoming_data(struct ci_request *req, void *data_dest, signed int (*dest_write)(void *, char *, signed int));
// client_parse_incoming_data::dest_write$object
// 
signed int dest_write$object(void *, char *, signed int);
// client_prepere_body_chunk
// file request_common.c line 1052
static signed int client_prepere_body_chunk(struct ci_request *req, void *data, signed int (*readdata)(void *, char *, signed int));
// client_prepere_body_chunk::readdata$object
// 
signed int readdata$object(void *, char *, signed int);
// client_send_get_data
// file request_common.c line 1200
static signed int client_send_get_data(struct ci_request *req, signed int timeout, void *data_source, signed int (*source_read)(void *, char *, signed int), void *data_dest, signed int (*dest_write)(void *, char *, signed int));
// client_send_get_data::dest_write$object
// 
signed int dest_write$object(void *, char *, signed int);
// client_send_get_data::source_read$object
// 
signed int source_read$object(void *, char *, signed int);
// client_send_request_headers
// file request_common.c line 816
static signed int client_send_request_headers(struct ci_request *req, signed int has_eof, signed int timeout);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// commands_exec_scheduled
// file commands.c line 252
void commands_exec_scheduled();
// commands_execute_start_child
// file commands.c line 188
signed int commands_execute_start_child();
// commands_execute_stop_child
// file commands.c line 193
signed int commands_execute_stop_child();
// commands_init
// file include/commands.h line 66
void commands_init();
// commands_reset
// file include/commands.h line 67
void commands_reset();
// common_mutex_destroy
// file cache.c line 114
signed int common_mutex_destroy(struct common_mutex *mtx);
// common_mutex_init
// file cache.c line 105
signed int common_mutex_init(struct common_mutex *mtx, signed int proc_mtx);
// common_mutex_lock
// file cache.c line 121
signed int common_mutex_lock(struct common_mutex *mtx);
// common_mutex_unlock
// file cache.c line 128
signed int common_mutex_unlock(struct common_mutex *mtx);
// compute_my_hostname
// file aserver.c line 58
void compute_my_hostname();
// config
// file include/cfg_param.h line 138
signed int config(signed int argc, char **argv);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous, unsigned int);
// create_childs_queue
// file proc_threads_queues.c line 119
signed int create_childs_queue(struct childs_queue *q, signed int size);
// create_service
// file service.c line 264
struct ci_service_module * create_service(const char *service_file);
// create_service_conf_table
// file service.c line 220
struct ci_conf_entry * create_service_conf_table(struct ci_service_xdata *srv_xdata, struct ci_conf_entry *user_table);
// datatype_cmp
// file types_ops.c line 330
signed int datatype_cmp(const void *key1, const void *key2);
// datatype_dup
// file types_ops.c line 311
void * datatype_dup(const char *str, struct ci_mem_allocator *allocator);
// datatype_equal
// file types_ops.c line 348
signed int datatype_equal(const void *key1, const void *key2);
// datatype_free
// file types_ops.c line 371
void datatype_free(void *key, struct ci_mem_allocator *allocator);
// datatype_len
// file types_ops.c line 366
unsigned long int datatype_len(const void *key);
// default_acl_client_match
// file default_acl.c line 86
signed int default_acl_client_match(struct ci_request *req);
// default_acl_init
// file default_acl.c line 67
signed int default_acl_init(struct ci_server_conf *server_conf);
// default_acl_post_init
// file default_acl.c line 73
signed int default_acl_post_init(struct ci_server_conf *server_conf);
// default_acl_release
// file default_acl.c line 78
void default_acl_release();
// default_acl_request_match
// file default_acl.c line 91
signed int default_acl_request_match(struct ci_request *req);
// default_cmp
// file array.c line 680
static signed int default_cmp(const void *obj1, const void *obj2, unsigned long int size);
// del_mutex
// file os/unix/threads.c line 105
static void del_mutex(void *pmutex);
// destroy_childs_queue
// file proc_threads_queues.c line 202
signed int destroy_childs_queue(struct childs_queue *q);
// destroy_encaps_entity
// file header.c line 563
void destroy_encaps_entity(struct ci_encaps_entity *e);
// destroy_queue
// file proc_threads_queues.c line 60
void destroy_queue(struct connections_queue *q);
// dettach_childs_queue
// file proc_threads_queues.c line 187
signed int dettach_childs_queue(struct childs_queue *q);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// do_close
// file body.c line 318
void do_close(signed int fd);
// do_end_of_data
// file request.c line 1433
static signed int do_end_of_data(struct ci_request *req);
// do_fake_preview
// file request.c line 1369
static signed int do_fake_preview(struct ci_request *req);
// do_open
// file body.c line 308
signed int do_open(const char *pathname, signed int flags);
// do_read
// file body.c line 292
signed int do_read(signed int fd, void *buf, unsigned long int count);
// do_request
// file request.c line 1475
static signed int do_request(struct ci_request *req);
// do_request_preview
// file request.c line 1296
static signed int do_request_preview(struct ci_request *req);
// do_write
// file body.c line 282
signed int do_write(signed int fd, const void *buf, unsigned long int count);
// dump_queue_statistics
// file proc_threads_queues.c line 402
void dump_queue_statistics(struct childs_queue *q);
// dump_statistics_command
// file mpmt_server.c line 1006
void dump_statistics_command(const char *name, signed int type, const char **argv);
// dup2
// file /usr/include/unistd.h line 537
extern signed int dup2(signed int, signed int);
// ec_responce
// file request.c line 623
static signed int ec_responce(struct ci_request *req, signed int ec);
// ec_responce_simple
// file request.c line 610
static void ec_responce_simple(struct ci_request *req, signed int ec);
// empty
// file mpmt_server.c line 114
static void empty(signed int sig);
// exec_cmd_step
// file commands.c line 164
static signed int exec_cmd_step(void *data, const void *cmd);
// execute_child_commands
// file commands.c line 177
static signed int execute_child_commands(signed int cmd_type);
// execute_command
// file commands.c line 152
signed int execute_command(struct ci_command *command, char *cmdline, signed int exec_type);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_normaly
// file mpmt_server.c line 180
static void exit_normaly();
// extend_object_type
// file filetype.c line 559
signed int extend_object_type(struct ci_magics_db *db, struct ci_headers_list *headers, const char *buf, signed int len, signed int *iscompressed);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 146
extern signed int fcntl(signed int, signed int, ...);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// file_log_access
// file log.c line 308
void file_log_access(struct ci_request *req);
// file_log_addlogfile
// file cfg_param.c line 489
signed int file_log_addlogfile(const char *file, const char *format, const char **acls);
// file_log_close
// file log.c line 260
void file_log_close();
// file_log_open
// file log.c line 225
signed int file_log_open();
// file_log_relog
// file log.c line 284
void file_log_relog(const char *name, signed int type, const char **argv);
// file_log_server
// file log.c line 329
void file_log_server(const char *server, const char *format, void **ap);
// file_proc_mutex_destroy
// file os/unix/proc_mutex.c line 195
static signed int file_proc_mutex_destroy(struct ci_proc_mutex *mutex);
// file_proc_mutex_init
// file os/unix/proc_mutex.c line 185
static signed int file_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name);
// file_proc_mutex_lock
// file os/unix/proc_mutex.c line 203
static signed int file_proc_mutex_lock(struct ci_proc_mutex *mutex);
// file_proc_mutex_print_info
// file os/unix/proc_mutex.c line 228
static signed int file_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size);
// file_proc_mutex_unlock
// file os/unix/proc_mutex.c line 216
static signed int file_proc_mutex_unlock(struct ci_proc_mutex *mutex);
// file_table_close
// file lookup_file_table.c line 264
void file_table_close(struct ci_lookup_table *table);
// file_table_open
// file lookup_file_table.c line 247
void * file_table_open(struct ci_lookup_table *table);
// file_table_release_result
// file lookup_file_table.c line 316
void file_table_release_result(struct ci_lookup_table *table_data, void **val);
// file_table_search
// file lookup_file_table.c line 294
void * file_table_search(struct ci_lookup_table *table, void *key, void ***vals);
// fill_queue_statistics
// file info.c line 182
void fill_queue_statistics(struct childs_queue *q, struct info_req_data *info_data);
// find_a_child_nrequests
// file proc_threads_queues.c line 331
signed int find_a_child_nrequests(struct childs_queue *q, signed int max_requests);
// find_a_child_to_be_killed
// file proc_threads_queues.c line 315
signed int find_a_child_to_be_killed(struct childs_queue *q);
// find_access_controller
// file include/module.h line 117
struct access_control_module * find_access_controller(const char *name);
// find_action
// file cfg_param.c line 699
struct ci_conf_entry * find_action(char *str, char **arg);
// find_an_idle_child
// file proc_threads_queues.c line 353
signed int find_an_idle_child(struct childs_queue *q);
// find_auth_method
// file module.c line 252
struct http_auth_method * find_auth_method(const char *method);
// find_auth_method_id
// file module.c line 270
struct http_auth_method * find_auth_method_id(const char *method, signed int *method_id);
// find_authenticator
// file module.c line 286
struct authenticator_module * find_authenticator(const char *name);
// find_command
// file commands.c line 121
struct ci_command * find_command(const char *cmd_line);
// find_common
// file module.c line 234
struct common_module * find_common(const char *name);
// find_logger
// file include/module.h line 116
struct logger_module * find_logger(const char *name);
// find_module
// file module.c line 313
void * find_module(const char *name, signed int *type);
// find_service
// file include/service.h line 273
struct ci_service_module * find_service(const char *service_name);
// find_service_alias
// file include/service.h line 274
struct service_alias * find_service_alias(const char *service_name);
// find_service_by_alias
// file service.c line 567
struct ci_service_module * find_service_by_alias(const char *service_name);
// find_servicehandler
// file module.c line 301
struct service_handler_module * find_servicehandler(const char *name);
// find_servicehandler_by_ext
// file include/module.h line 119
struct service_handler_module * find_servicehandler_by_ext(const char *extension);
// fmt_gmttime
// file txt_format.c line 399
signed int fmt_gmttime(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_http_req_head_o
// file txt_format.c line 474
signed int fmt_http_req_head_o(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_http_req_url_o
// file txt_format.c line 466
signed int fmt_http_req_url_o(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_http_res_head_o
// file txt_format.c line 497
signed int fmt_http_res_head_o(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_httpclientip
// file txt_format.c line 429
signed int fmt_httpclientip(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_httpserverip
// file txt_format.c line 448
signed int fmt_httpserverip(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_icap_req_head
// file txt_format.c line 525
signed int fmt_icap_req_head(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_icap_res_head
// file txt_format.c line 549
signed int fmt_icap_res_head(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_icapmethod
// file txt_format.c line 338
signed int fmt_icapmethod(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_icapstatus
// file txt_format.c line 416
signed int fmt_icapstatus(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_localip
// file txt_format.c line 327
signed int fmt_localip(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_localtime
// file txt_format.c line 382
signed int fmt_localtime(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_logstr
// file txt_format.c line 645
signed int fmt_logstr(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_none
// file txt_format.c line 142
signed int fmt_none(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_percent
// file txt_format.c line 151
signed int fmt_percent(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_remoteip
// file txt_format.c line 316
signed int fmt_remoteip(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_attribute
// file txt_format.c line 659
signed int fmt_req_attribute(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_body_bytes_rcv
// file txt_format.c line 593
signed int fmt_req_body_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_body_bytes_sent
// file txt_format.c line 597
signed int fmt_req_body_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_bytes_rcv
// file txt_format.c line 577
signed int fmt_req_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_bytes_sent
// file txt_format.c line 581
signed int fmt_req_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_http_bytes_rcv
// file txt_format.c line 585
signed int fmt_req_http_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_http_bytes_sent
// file txt_format.c line 589
signed int fmt_req_http_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_preview_hex
// file txt_format.c line 601
signed int fmt_req_preview_hex(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_preview_len
// file txt_format.c line 633
signed int fmt_req_preview_len(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_request
// file txt_format.c line 365
signed int fmt_request(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_seconds
// file txt_format.c line 422
signed int fmt_seconds(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_service
// file txt_format.c line 347
signed int fmt_service(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_username
// file txt_format.c line 356
signed int fmt_username(struct ci_request *req, char *buf, signed int len, const char *param);
// fopen64
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen64(const char *, const char *);
// fork
// file /usr/include/unistd.h line 759
extern signed int fork(void);
// format_body_chunk
// file request.c line 767
static signed int format_body_chunk(struct ci_request *req);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread_line
// file cfg_param.c line 678
signed int fread_line(struct _IO_FILE *f_conf, char *line);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_a_buffer
// file decode.c line 203
static void free_a_buffer(void *op, void *ptr);
// free_args
// file cfg_param.c line 775
void free_args(char **argv);
// free_auth
// file http_auth.c line 346
void free_auth(struct ci_request *req, void *data);
// free_cmp_uint64_data
// file acl.c line 997
void free_cmp_uint64_data(struct ci_request *req, void *param);
// free_data_type
// file acl.c line 976
void free_data_type(struct ci_request *req, void *param);
// free_http_req_header
// file acl.c line 938
void free_http_req_header(struct ci_request *req, void *param);
// free_http_resp_header
// file acl.c line 952
void free_http_resp_header(struct ci_request *req, void *param);
// free_icap_header
// file acl.c line 911
void free_icap_header(struct ci_request *req, void *param);
// free_icap_response_header
// file acl.c line 925
void free_icap_response_header(struct ci_request *req, void *param);
// free_records_group
// file filetype.c line 167
void free_records_group(struct ci_magic_record *record);
// free_time_data
// file acl.c line 394
void free_time_data(struct ci_request *req, void *param);
// free_user
// file http_auth.c line 306
void free_user(struct ci_request *req, void *data);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fstat64
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 219
extern signed int fstat64(signed int, struct stat *);
// ftruncate64
// file /usr/include/unistd.h line 1022
extern signed int ftruncate64(signed int, signed long int);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_auth
// file http_auth.c line 335
void * get_auth(struct ci_request *req, char *param);
// get_authentication_schema
// file include/module.h line 121
struct http_auth_method * get_authentication_schema(const char *method_name, struct authenticator_module ***authenticators);
// get_authenticators_list
// file module.c line 457
struct authenticator_module ** get_authenticators_list(struct auth_hash *hash, signed int method_id);
// get_child_data
// file proc_threads_queues.c line 230
struct child_shared_data * get_child_data(struct childs_queue *q, signed int pid);
// get_client_ip
// file acl.c line 60
void * get_client_ip(struct ci_request *req, char *param);
// get_content_length
// file acl.c line 980
void * get_content_length(struct ci_request *req, char *param);
// get_data_type
// file acl.c line 961
void * get_data_type(struct ci_request *req, char *param);
// get_encaps_type
// file header.c line 573
signed int get_encaps_type(const char *buf, signed int *val, char **endpoint);
// get_from_queue
// file proc_threads_queues.c line 86
signed int get_from_queue(struct connections_queue *q, struct ci_connection *con);
// get_header
// file acl.c line 872
const char * get_header(struct ci_headers_list *headers, char *head);
// get_http_client_ip
// file acl.c line 68
void * get_http_client_ip(struct ci_request *req, char *param);
// get_http_req_header
// file acl.c line 932
void * get_http_req_header(struct ci_request *req, char *param);
// get_http_resp_header
// file acl.c line 945
void * get_http_resp_header(struct ci_request *req, char *param);
// get_icap_header
// file acl.c line 904
void * get_icap_header(struct ci_request *req, char *param);
// get_icap_response_header
// file acl.c line 918
void * get_icap_response_header(struct ci_request *req, char *param);
// get_method
// file request.c line 304
static signed int get_method(char *buf, char **end);
// get_port
// file acl.c line 56
void * get_port(struct ci_request *req, char *param);
// get_reqtype
// file acl.c line 52
void * get_reqtype(struct ci_request *req, char *param);
// get_request_options
// file request_common.c line 757
static signed int get_request_options(struct ci_request *req, struct ci_headers_list *h);
// get_send_body
// file request.c line 907
static signed int get_send_body(struct ci_request *req, signed int parse_only);
// get_send_body::1::service_io$object
// 
signed int service_io$object(char *, signed int *, char *, signed int *, signed int, struct ci_request *);
// get_service
// file acl.c line 48
void * get_service(struct ci_request *req, char *param);
// get_srv_ip
// file acl.c line 64
void * get_srv_ip(struct ci_request *req, char *param);
// get_time_data
// file acl.c line 401
void * get_time_data(struct ci_request *req, char *param);
// get_user
// file acl.c line 44
void * get_user(struct ci_request *req, char *param);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getgrgid
// file /usr/include/grp.h line 102
extern struct group * getgrgid(unsigned int);
// getgrnam
// file /usr/include/grp.h line 108
extern struct group * getgrnam(const char *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// gethostname
// file /usr/include/unistd.h line 882
extern signed int gethostname(char *, unsigned long int);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getpid
// file /usr/include/unistd.h line 631
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, union anonymous, unsigned int *);
// gmtime_r
// file /usr/include/time.h line 249
extern struct tm * gmtime_r(const signed long int *, struct tm *);
// group_cmp
// file http_auth.c line 276
signed int group_cmp(const void *key1, const void *key2);
// group_dup
// file http_auth.c line 258
static void * group_dup(const char *str, struct ci_mem_allocator *allocator);
// group_equal
// file http_auth.c line 286
signed int group_equal(const void *key1, const void *key2);
// group_free
// file http_auth.c line 266
static void group_free(void *key, struct ci_mem_allocator *allocator);
// group_len
// file http_auth.c line 271
static unsigned long int group_len(const void *key);
// group_source_add
// file http_auth.c line 136
signed int group_source_add(const char *table_name, signed int type);
// group_source_add_by_group
// file cfg_param.c line 636
signed int group_source_add_by_group(const char *table_name);
// group_source_add_by_user
// file cfg_param.c line 637
signed int group_source_add_by_user(const char *table_name);
// group_source_release
// file http_auth.c line 195
void group_source_release();
// groups_add
// file filetype.c line 104
signed int groups_add(struct ci_magics_db *db, const char *name, const char *descr);
// groups_init
// file filetype.c line 82
signed int groups_init(struct ci_magics_db *db);
// handle_child_process_commands
// file mpmt_server.c line 524
void handle_child_process_commands(char *cmd_line);
// handle_monitor_process_commands
// file mpmt_server.c line 506
void handle_monitor_process_commands(char *cmd_line);
// hash_table_close
// file lookup_file_table.c line 365
void hash_table_close(struct ci_lookup_table *table);
// hash_table_open
// file lookup_file_table.c line 339
void * hash_table_open(struct ci_lookup_table *table);
// hash_table_release_result
// file lookup_file_table.c line 396
void hash_table_release_result(struct ci_lookup_table *table_data, void **val);
// hash_table_search
// file lookup_file_table.c line 377
void * hash_table_search(struct ci_lookup_table *table, void *key, void ***vals);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// http_authenticate
// file http_auth.c line 59
signed int http_authenticate(struct ci_request *req, char *use_method);
// http_authorize
// file http_auth.c line 36
signed int http_authorize(struct ci_request *req, char *method);
// icap_header_check_realloc
// file request.c line 169
static signed int icap_header_check_realloc(char **buf, signed int *size, signed int used, signed int mustadded);
// icap_init_server
// file include/net_io.h line 141
signed int icap_init_server(char *address, signed int port, signed int *protocol_family, signed int secs_to_linger);
// icap_socket_opts
// file include/net_io.h line 140
signed int icap_socket_opts(signed int fd, signed int secs_to_linger);
// index
// file /usr/include/strings.h line 72
extern char * index(const char *, signed int);
// inet_aton
// file /usr/include/arpa/inet.h line 73
extern signed int inet_aton(const char *, struct in_addr *);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// inflate
// file /usr/include/zlib.h line 392
extern signed int inflate(struct z_stream_s *, signed int);
// inflateEnd
// file /usr/include/zlib.h line 508
extern signed int inflateEnd(struct z_stream_s *);
// inflateInit2_
// file /usr/include/zlib.h line 1641
extern signed int inflateInit2_(struct z_stream_s *, signed int, const char *, signed int);
// info_check_preview_handler
// file info.c line 134
signed int info_check_preview_handler(char *preview_data, signed int preview_data_len, struct ci_request *req);
// info_close_service
// file info.c line 85
void info_close_service();
// info_end_of_data_handler
// file info.c line 158
signed int info_end_of_data_handler(struct ci_request *req);
// info_init_request_data
// file info.c line 90
void * info_init_request_data(struct ci_request *req);
// info_init_service
// file info.c line 78
signed int info_init_service(struct ci_service_xdata *srv_xdata, struct ci_server_conf *server_conf);
// info_io
// file info.c line 163
signed int info_io(char *wbuf, signed int *wlen, char *rbuf, signed int *rlen, signed int iseof, struct ci_request *req);
// info_release_request_data
// file info.c line 120
void info_release_request_data(void *data);
// init_auth_hash
// file module.c line 432
signed int init_auth_hash(struct auth_hash *hash);
// init_body_system
// file aserver.c line 45
signed int init_body_system();
// init_child_mutexes
// file os/unix/threads.c line 46
static void init_child_mutexes();
// init_commands
// file mpmt_server.c line 1036
void init_commands();
// init_conf_tables
// file aserver.c line 44
void init_conf_tables();
// init_extra_data
// file service.c line 277
void init_extra_data(struct ci_service_xdata *srv_xdata, const char *service);
// init_http_auth
// file aserver.c line 56
void init_http_auth();
// init_internal_lookup_tables
// file aserver.c line 53
void init_internal_lookup_tables();
// init_module
// file module.c line 141
static signed int init_module(void *module, enum module_type type);
// init_modules
// file include/module.h line 112
signed int init_modules();
// init_pack_allocator
// file mem.c line 661
struct ci_mem_allocator * init_pack_allocator(struct ci_mem_allocator *allocator, struct pack_allocator *pack_alloc, char *memblock, unsigned long int size, signed int free);
// init_queue
// file proc_threads_queues.c line 31
struct connections_queue * init_queue(signed int size);
// init_server
// file aserver.c line 47
signed int init_server(char *address, signed int port, signed int *family);
// init_services
// file include/service.h line 276
signed int init_services();
// int32_cmp
// file types_ops.c line 125
signed int int32_cmp(const void *key1, const void *key2);
// int32_dup
// file types_ops.c line 107
void * int32_dup(const char *str, struct ci_mem_allocator *allocator);
// int32_equal
// file types_ops.c line 138
signed int int32_equal(const void *key1, const void *key2);
// int32_free
// file types_ops.c line 151
void int32_free(void *key, struct ci_mem_allocator *allocator);
// int32_len
// file types_ops.c line 146
unsigned long int int32_len(const void *key);
// intl_cfg_disable
// file cfg_param.c line 1115
signed int intl_cfg_disable(const char *directive, const char **argv, void *setdata);
// intl_cfg_enable
// file cfg_param.c line 1123
signed int intl_cfg_enable(const char *directive, const char **argv, void *setdata);
// intl_cfg_onoff
// file cfg_param.c line 1107
signed int intl_cfg_onoff(const char *directive, const char **argv, void *setdata);
// intl_cfg_set_int
// file cfg_param.c line 1099
signed int intl_cfg_set_int(const char *directive, const char **argv, void *setdata);
// intl_cfg_set_str
// file cfg_param.c line 1090
signed int intl_cfg_set_str(const char *directive, const char **argv, void *setdata);
// intl_cfg_size_long
// file cfg_param.c line 1139
signed int intl_cfg_size_long(const char *directive, const char **argv, void *setdata);
// intl_cfg_size_off
// file cfg_param.c line 1131
signed int intl_cfg_size_off(const char *directive, const char **argv, void *setdata);
// ip_cmp
// file types_ops.c line 520
signed int ip_cmp(const void *ref_key, const void *key_check);
// ip_dup
// file types_ops.c line 448
void * ip_dup(const char *value, struct ci_mem_allocator *allocator);
// ip_equal
// file types_ops.c line 525
signed int ip_equal(const void *ref_key, const void *key_check);
// ip_free
// file types_ops.c line 511
void ip_free(void *data, struct ci_mem_allocator *allocator);
// ip_len
// file types_ops.c line 515
unsigned long int ip_len(const void *key);
// ip_sockaddr_cmp
// file types_ops.c line 556
signed int ip_sockaddr_cmp(const void *ref_key, const void *key_check);
// ip_sockaddr_equal
// file types_ops.c line 561
signed int ip_sockaddr_equal(const void *ref_key, const void *key_check);
// isUTF8
// file filetype.c line 439
signed int isUTF8(unsigned char *c, signed int size);
// is_icap_running
// file aserver.c line 51
signed int is_icap_running(char *pidfile);
// keepalive_request
// file request.c line 144
signed int keepalive_request(struct ci_request *req);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// kill_all_childs
// file mpmt_server.c line 321
static void kill_all_childs();
// list_alloc_item
// file array.c line 562
static struct ci_list_item * list_alloc_item(struct ci_list *list, const void *data);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// listener_thread
// file mpmt_server.c line 685
void listener_thread(signed int *fd);
// load_c_service
// file service.c line 606
struct ci_service_module * load_c_service(const char *service_file);
// load_module
// file module.c line 69
void * load_module(const char *module_file);
// load_text_table
// file lookup_file_table.c line 205
signed int load_text_table(char *filename, struct ci_lookup_table *table);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// log_access
// file log.c line 64
void log_access(struct ci_request *req, signed int status);
// log_close
// file log.c line 51
void log_close();
// log_open
// file include/log.h line 31
signed int log_open();
// log_reset
// file log.c line 58
void log_reset();
// log_server
// file include/log.h line 37
void log_server(struct ci_request *req, const char *format, ...);
// logfile_open
// file log.c line 217
struct _IO_FILE * logfile_open(const char *fname);
// logformat_add
// file cfg_param.c line 478
signed int logformat_add(const char *name, const char *format);
// logformat_fmt
// file log.c line 161
char * logformat_fmt(const char *name);
// logformat_release
// file log.c line 144
void logformat_release();
// lookup_table_get_row
// file lookup_table.c line 205
static const void * lookup_table_get_row(struct ci_lookup_table *table, const void *key, const char **columns, void ***vals);
// lseek64
// file /usr/include/unistd.h line 340
extern signed long int lseek64(signed int, signed long int, signed int);
// magics_add
// file filetype.c line 116
signed int magics_add(struct ci_magics_db *db, signed int offset, unsigned char *magic, unsigned long int len, signed int type);
// magics_init
// file filetype.c line 83
signed int magics_init(struct ci_magics_db *db);
// main_signals
// file mpmt_server.c line 154
void main_signals();
// makeTemplatePathFileName
// file txtTemplate.c line 70
static void makeTemplatePathFileName(char *path, signed int path_len, const char *service_name, const char *page_name, const char *lang);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mem_init
// file aserver.c line 55
signed int mem_init();
// mem_reset
// file mem.c line 58
void mem_reset();
// memcmp
// file /usr/include/string.h line 65
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 46
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// methods_authenticators
// file module.c line 490
signed int methods_authenticators(struct auth_hash *hash, const char *method_name, signed int method_id, const char **argv);
// mk_encaps_entity
// file header.c line 547
struct ci_encaps_entity * mk_encaps_entity(signed int type, signed int val);
// mk_responce_header
// file request.c line 680
static signed int mk_responce_header(struct ci_request *req);
// mkfifo
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 349
extern signed int mkfifo(const char *, unsigned int);
// mkstemp64
// file /usr/include/stdlib.h line 622
extern signed int mkstemp64(char *);
// mmap64
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 61
extern void * mmap64(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// mmap_shared_mem_attach
// file os/unix/shared_mem.c line 118
void * mmap_shared_mem_attach(struct ci_shared_mem_id *id);
// mmap_shared_mem_create
// file os/unix/shared_mem.c line 103
void * mmap_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size);
// mmap_shared_mem_destroy
// file os/unix/shared_mem.c line 131
signed int mmap_shared_mem_destroy(struct ci_shared_mem_id *id);
// mmap_shared_mem_detach
// file os/unix/shared_mem.c line 124
signed int mmap_shared_mem_detach(struct ci_shared_mem_id *id);
// mmap_shared_mem_print_info
// file os/unix/shared_mem.c line 137
signed int mmap_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size);
// mod_null_io
// file request.c line 896
static signed int mod_null_io(char *rbuf, signed int *rlen, char *wbuf, signed int *wlen, signed int iseof, struct ci_request *req);
// module_type
// file module.c line 115
static signed int module_type(const char *type);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// net_data_read
// file include/request.h line 151
signed int net_data_read(struct ci_request *req);
// newrequest
// file request.c line 102
struct ci_request * newrequest(struct ci_connection *connection);
// newthread
// file mpmt_server.c line 537
struct server_decl * newthread(struct connections_queue *con_queue);
// open64
// file /usr/include/fcntl.h line 159
extern signed int open64(const char *, signed int, ...);
// options_responce
// file request.c line 1123
static void options_responce(struct ci_request *req);
// os_allocator_alloc
// file mem.c line 404
static void * os_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size);
// os_allocator_destroy
// file mem.c line 419
static void os_allocator_destroy(struct ci_mem_allocator *allocator);
// os_allocator_free
// file mem.c line 409
static void os_allocator_free(struct ci_mem_allocator *allocator, void *p);
// os_allocator_reset
// file mem.c line 414
static void os_allocator_reset(struct ci_mem_allocator *allocator);
// parse_chunk_data
// file include/request.h line 150
signed int parse_chunk_data(struct ci_request *req, char **wdata);
// parse_directive
// file txt_format.c line 160
unsigned int parse_directive(const char *var, unsigned int *width, signed int *left_align, char *parameter);
// parse_encaps_headers
// file request.c line 531
static signed int parse_encaps_headers(struct ci_request *req);
// parse_file
// file cfg_param.c line 821
signed int parse_file(const char *conf_file);
// parse_header
// file request.c line 478
static signed int parse_header(struct ci_request *req);
// parse_record
// file filetype.c line 179
static signed int parse_record(char *line, struct ci_magic_record *record);
// parse_request
// file request.c line 324
static signed int parse_request(struct ci_request *req, char *buf);
// pcre_compile
// file /usr/include/pcre.h line 540
extern struct real_pcre * pcre_compile(const char *, signed int, const char **, signed int *, const unsigned char *);
// pcre_exec
// file /usr/include/pcre.h line 573
extern signed int pcre_exec(const struct real_pcre *, const struct pcre_extra *, const char *, signed int, signed int, signed int, signed int *, signed int);
// pcre_free$object
// 
void pcre_free$object(void *);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 420
extern signed int pipe(signed int *);
// pointers_cmp
// file array.c line 685
static signed int pointers_cmp(const void *obj1, const void *obj2, unsigned long int size);
// pool_allocator_alloc
// file mem.c line 796
static void * pool_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size);
// pool_allocator_build
// file mem.c line 775
static struct pool_allocator * pool_allocator_build(signed int items_size, signed int strict);
// pool_allocator_destroy
// file mem.c line 880
static void pool_allocator_destroy(struct ci_mem_allocator *allocator);
// pool_allocator_free
// file mem.c line 829
static void pool_allocator_free(struct ci_mem_allocator *allocator, void *p);
// pool_allocator_reset
// file mem.c line 850
static void pool_allocator_reset(struct ci_mem_allocator *allocator);
// posix_proc_mutex_destroy
// file os/unix/proc_mutex.c line 139
static signed int posix_proc_mutex_destroy(struct ci_proc_mutex *mutex);
// posix_proc_mutex_init
// file os/unix/proc_mutex.c line 118
static signed int posix_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name);
// posix_proc_mutex_lock
// file os/unix/proc_mutex.c line 147
static signed int posix_proc_mutex_lock(struct ci_proc_mutex *mutex);
// posix_proc_mutex_print_info
// file os/unix/proc_mutex.c line 165
static signed int posix_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size);
// posix_proc_mutex_unlock
// file os/unix/proc_mutex.c line 156
static signed int posix_proc_mutex_unlock(struct ci_proc_mutex *mutex);
// posix_shared_mem_attach
// file os/unix/shared_mem.c line 179
void * posix_shared_mem_attach(struct ci_shared_mem_id *id);
// posix_shared_mem_create
// file os/unix/shared_mem.c line 157
void * posix_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size);
// posix_shared_mem_destroy
// file os/unix/shared_mem.c line 192
signed int posix_shared_mem_destroy(struct ci_shared_mem_id *id);
// posix_shared_mem_detach
// file os/unix/shared_mem.c line 184
signed int posix_shared_mem_detach(struct ci_shared_mem_id *id);
// posix_shared_mem_print_info
// file os/unix/shared_mem.c line 201
signed int posix_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size);
// post_init_modules
// file include/module.h line 113
signed int post_init_modules();
// post_init_services
// file include/service.h line 277
signed int post_init_services();
// print_conf_variables
// file cfg_param.c line 314
void print_conf_variables(struct ci_conf_entry *table);
// print_variables
// file cfg_param.c line 355
signed int print_variables();
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_encapsulated
// file include/request.h line 152
signed int process_encapsulated(struct ci_request *req, const char *buf);
// process_line
// file cfg_param.c line 787
signed int process_line(char *orig_line);
// process_request
// file request.c line 1618
signed int process_request(struct ci_request *req);
// pthread_atfork
// file /usr/include/pthread.h line 1145
extern signed int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
// pthread_cond_broadcast
// file /usr/include/pthread.h line 981
extern signed int pthread_cond_broadcast(union anonymous$9 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 973
extern signed int pthread_cond_destroy(union anonymous$9 *);
// pthread_cond_init
// file /usr/include/pthread.h line 968
extern signed int pthread_cond_init(union anonymous$9 *, const union anonymous$21 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 977
extern signed int pthread_cond_signal(union anonymous$9 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 989
extern signed int pthread_cond_wait(union anonymous$9 *, union anonymous$3 *);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 250
extern signed int pthread_join(unsigned long int, void **);
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 754
extern signed int pthread_mutex_destroy(union anonymous$3 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 749
extern signed int pthread_mutex_init(union anonymous$3 *, const union anonymous$21 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous$3 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous$3 *);
// pthread_rwlock_destroy
// file /usr/include/pthread.h line 893
extern signed int pthread_rwlock_destroy(union anonymous$1 *);
// pthread_rwlock_init
// file /usr/include/pthread.h line 888
extern signed int pthread_rwlock_init(union anonymous$1 *, const union anonymous$22 *);
// pthread_rwlock_rdlock
// file /usr/include/pthread.h line 897
extern signed int pthread_rwlock_rdlock(union anonymous$1 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 927
extern signed int pthread_rwlock_unlock(union anonymous$1 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 912
extern signed int pthread_rwlock_wrlock(union anonymous$1 *);
// pthread_self
// file /usr/include/pthread.h line 275
extern unsigned long int pthread_self(void);
// pthread_setcancelstate
// file /usr/include/pthread.h line 506
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_setcanceltype
// file /usr/include/pthread.h line 510
extern signed int pthread_setcanceltype(signed int, signed int *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$18 *, struct anonymous$18 *);
// put_to_queue
// file proc_threads_queues.c line 68
signed int put_to_queue(struct connections_queue *q, struct ci_connection *con);
// read
// file /usr/include/unistd.h line 363
extern signed long int read(signed int, void *, unsigned long int);
// read_encaps_header
// file request.c line 253
static signed int read_encaps_header(struct ci_request *req, struct ci_headers_list *h, signed int size);
// read_preview_data
// file request.c line 560
static signed int read_preview_data(struct ci_request *req);
// read_row
// file lookup_file_table.c line 102
signed int read_row(struct _IO_FILE *f, signed int cols, struct text_table_entry **e, struct ci_lookup_table *table);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// reconfig
// file cfg_param.c line 899
signed int reconfig();
// reconfigure_command
// file mpmt_server.c line 999
void reconfigure_command(const char *name, signed int type, const char **argv);
// recycle_request
// file request.c line 127
signed int recycle_request(struct ci_request *req, struct ci_connection *connection);
// regex_cmp
// file types_ops.c line 271
signed int regex_cmp(const void *key1, const void *key2);
// regex_dup
// file types_ops.c line 238
void * regex_dup(const char *str, struct ci_mem_allocator *allocator);
// regex_equal
// file types_ops.c line 279
signed int regex_equal(const void *key1, const void *key2);
// regex_free
// file types_ops.c line 292
void regex_free(void *key, struct ci_mem_allocator *allocator);
// regex_len
// file types_ops.c line 287
unsigned long int regex_len(const void *key);
// regex_table_close
// file lookup_file_table.c line 440
void regex_table_close(struct ci_lookup_table *table);
// regex_table_open
// file lookup_file_table.c line 419
void * regex_table_open(struct ci_lookup_table *table);
// regex_table_release_result
// file lookup_file_table.c line 461
void regex_table_release_result(struct ci_lookup_table *table_data, void **val);
// regex_table_search
// file lookup_file_table.c line 451
void * regex_table_search(struct ci_lookup_table *table, void *key, void ***vals);
// register_child
// file proc_threads_queues.c line 243
struct child_shared_data * register_child(struct childs_queue *q, signed int pid, signed int maxservers, signed int pipe);
// register_command
// file include/commands.h line 54
void register_command(const char *name, signed int type, void (*command_action)(const char *, signed int, const char **));
// register_command::command_action$object
// 
//void command_action$object(const char *, signed int, const char **);
// register_command_extend
// file commands.c line 70
void register_command_extend(const char *name, signed int type, void *data, void (*command_action)(const char *, signed int, void *));
// register_command_extend::command_action$object
// 
//void command_action$object(const char *, signed int, void *);
// register_conf_table
// file cfg_param.c line 231
signed int register_conf_table(const char *name, struct ci_conf_entry *table, signed int type);
// register_module
// file include/module.h line 114
void * register_module(const char *module_file, const char *type);
// register_service
// file include/service.h line 270
struct ci_service_module * register_service(const char *service_file);
// release_auth_hash
// file module.c line 444
void release_auth_hash(struct auth_hash *hash);
// release_body_system
// file body.c line 74
void release_body_system();
// release_c_handler
// file service.c line 626
void release_c_handler();
// release_header_value
// file acl.c line 898
void release_header_value(struct ci_headers_list *headers, char *head);
// release_modules
// file module.c line 659
signed int release_modules();
// release_services
// file include/service.h line 278
signed int release_services();
// release_text_table_entry
// file lookup_file_table.c line 81
void release_text_table_entry(struct text_table_entry *e, struct ci_lookup_table *table);
// release_thread_i
// file mpmt_server.c line 189
static void release_thread_i(signed int i);
// remove
// file /usr/include/stdio.h line 178
extern signed int remove(const char *);
// remove_child
// file proc_threads_queues.c line 284
signed int remove_child(struct childs_queue *q, signed int pid, signed int status);
// request_match_specslist
// file acl.c line 716
signed int request_match_specslist(struct ci_request *req, struct ci_specs_list *spec_list);
// request_stats_init
// file aserver.c line 54
void request_stats_init();
// reset_conf_tables
// file cfg_param.c line 226
void reset_conf_tables();
// reset_http_auth
// file cfg_param.c line 925
void reset_http_auth();
// resize_buffer
// file body.c line 343
signed int resize_buffer(struct ci_cached_file *body, signed int new_size);
// resp_check_body
// file request.c line 814
static signed int resp_check_body(struct ci_request *req);
// run_as_daemon
// file aserver.c line 78
void run_as_daemon();
// search_conf_table
// file cfg_param.c line 206
struct ci_conf_entry * search_conf_table(struct ci_conf_entry *table, char *varname);
// search_options_table
// file cfg_lib.c line 76
struct ci_options_entry * search_options_table(const char *directive, struct ci_options_entry *options);
// search_variables
// file cfg_param.c line 292
struct ci_conf_entry * search_variables(char *table, char *varname);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$19 *, struct anonymous$19 *, struct anonymous$19 *, struct timeval *);
// sem_open
// file /usr/include/semaphore.h line 42
extern union anonymous$10 * sem_open(const char *, signed int, ...);
// sem_post
// file /usr/include/semaphore.h line 69
extern signed int sem_post(union anonymous$10 *);
// sem_unlink
// file /usr/include/semaphore.h line 48
extern signed int sem_unlink(const char *);
// sem_wait
// file /usr/include/semaphore.h line 54
extern signed int sem_wait(union anonymous$10 *);
// semctl
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 52
extern signed int semctl(signed int, signed int, signed int, ...);
// semget
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 55
extern signed int semget(signed int, signed int, signed int);
// semop
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 58
extern signed int semop(signed int, struct sembuf *, unsigned long int);
// send_current_block_data
// file request.c line 741
static signed int send_current_block_data(struct ci_request *req);
// send_remaining_response
// file request.c line 1070
static signed int send_remaining_response(struct ci_request *req);
// send_remaining_response::1::service_io$object
// 
signed int service_io$object(char *, signed int *, char *, signed int *, signed int, struct ci_request *);
// send_term_to_childs
// file mpmt_server.c line 283
static void send_term_to_childs(struct childs_queue *q);
// serial_allocation
// file mem.c line 476
static void * serial_allocation(struct serial_allocator *serial_alloc, unsigned long int size);
// serial_allocator_alloc
// file mem.c line 499
static void * serial_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size);
// serial_allocator_build
// file mem.c line 453
static struct serial_allocator * serial_allocator_build(signed int size);
// serial_allocator_destroy
// file mem.c line 530
static void serial_allocator_destroy(struct ci_mem_allocator *allocator);
// serial_allocator_free
// file mem.c line 508
static void serial_allocator_free(struct ci_mem_allocator *allocator, void *p);
// serial_allocator_reset
// file mem.c line 513
static void serial_allocator_reset(struct ci_mem_allocator *allocator);
// server_reconfigure
// file mpmt_server.c line 382
static signed int server_reconfigure();
// service_data
// file include/service.h line 275
struct ci_service_xdata * service_data(struct ci_service_module *srv);
// set_method_authenticators
// file include/module.h line 125
signed int set_method_authenticators(const char *method_name, const char **argv);
// set_running_permissions
// file aserver.c line 52
signed int set_running_permissions(char *user, char *group);
// setgid
// file /usr/include/unistd.h line 720
extern signed int setgid(unsigned int);
// setsid
// file /usr/include/unistd.h line 670
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 703
extern signed int setuid(unsigned int);
// setvbuf
// file /usr/include/stdio.h line 336
extern signed int setvbuf(struct _IO_FILE *, char *, signed int, unsigned long int);
// shm_open
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 144
extern signed int shm_open(const char *, signed int, unsigned int);
// shm_unlink
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 147
extern signed int shm_unlink(const char *);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// sigaddset
// file /usr/include/signal.h line 219
extern signed int sigaddset(struct anonymous$18 *, signed int);
// sigchld_handler_main
// file mpmt_server.c line 130
static void sigchld_handler_main(signed int sig);
// sigemptyset
// file /usr/include/signal.h line 213
extern signed int sigemptyset(struct anonymous$18 *);
// sighup_handler_main
// file mpmt_server.c line 135
static void sighup_handler_main();
// sigint_handler_main
// file mpmt_server.c line 118
static void sigint_handler_main(signed int sig);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sigpipe_handler
// file mpmt_server.c line 110
static void sigpipe_handler(signed int sig);
// sizeof_pack_allocator
// file mem.c line 735
static unsigned long int sizeof_pack_allocator();
// sizeofencaps
// file header.c line 613
signed int sizeofencaps(struct ci_encaps_entity *e);
// sizeofheader
// file header.c line 600
signed int sizeofheader(struct ci_headers_list *h);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// spec_data_check
// file acl.c line 699
signed int spec_data_check(const struct ci_acl_spec *spec, const void *req_raw_data);
// split_args
// file cfg_param.c line 724
char ** split_args(char *args);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_child
// file mpmt_server.c line 947
signed int start_child(signed int fd);
// start_server
// file aserver.c line 48
signed int start_server();
// stat64
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat64(const char *, struct stat *);
// stat_entry_add
// file stats.c line 40
signed int stat_entry_add(struct stat_entry_list *list, const char *label, signed int type, signed int gid);
// stat_entry_by_name
// file stats.c line 88
signed int stat_entry_by_name(struct stat_entry_list *list, const char *label);
// stat_entry_release_list
// file stats.c line 75
void stat_entry_release_list(struct stat_entry_list *list);
// stat_group_add
// file stats.c line 100
signed int stat_group_add(char *group);
// stat_memblock_fix
// file include/stats.h line 97
void stat_memblock_fix(struct stat_memblock *mem_block);
// stat_memblock_reconstruct
// file include/stats.h line 98
void stat_memblock_reconstruct(struct stat_memblock *mem_block);
// stop_command
// file mpmt_server.c line 994
void stop_command(const char *name, signed int type, const char **argv);
// store_pid
// file aserver.c line 49
signed int store_pid(char *pidfile);
// strcasecmp
// file /usr/include/strings.h line 112
extern signed int strcasecmp(const char *, const char *);
// strcasestr
// file /usr/include/string.h line 368
extern char * strcasestr(const char *, const char *);
// strcat
// file /usr/include/string.h line 133
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 231
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 125
extern char * strcpy(char *, const char *);
// strcspn
// file /usr/include/string.h line 280
extern unsigned long int strcspn(const char *, const char *);
// strdup
// file /usr/include/string.h line 171
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 408
extern char * strerror(signed int);
// strerror_r
// file /usr/include/string.h line 433
extern char * strerror_r(signed int, char *, unsigned long int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// string_ext_cmp
// file types_ops.c line 73
signed int string_ext_cmp(const void *key1, const void *key2);
// string_ext_equal
// file types_ops.c line 84
signed int string_ext_equal(const void *key1, const void *key2);
// stringcmp
// file types_ops.c line 41
signed int stringcmp(const void *key1, const void *key2);
// stringdup
// file types_ops.c line 33
void * stringdup(const char *str, struct ci_mem_allocator *allocator);
// stringequal
// file types_ops.c line 48
signed int stringequal(const void *key1, const void *key2);
// stringfree
// file types_ops.c line 60
void stringfree(void *key, struct ci_mem_allocator *allocator);
// stringlen
// file types_ops.c line 55
unsigned long int stringlen(const void *key);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/strings.h line 116
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 136
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 143
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 128
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 258
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 337
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoll
// file /usr/include/stdlib.h line 209
extern signed long long int strtoll(const char *, char ** restrict , signed int);
// system_reconfigure
// file cfg_param.c line 954
signed int system_reconfigure();
// system_shutdown
// file cfg_param.c line 927
void system_shutdown();
// sysv_proc_mutex_destroy
// file os/unix/proc_mutex.c line 74
static signed int sysv_proc_mutex_destroy(struct ci_proc_mutex *mutex);
// sysv_proc_mutex_init
// file os/unix/proc_mutex.c line 56
static signed int sysv_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name);
// sysv_proc_mutex_lock
// file os/unix/proc_mutex.c line 83
static signed int sysv_proc_mutex_lock(struct ci_proc_mutex *mutex);
// sysv_proc_mutex_print_info
// file os/unix/proc_mutex.c line 99
static signed int sysv_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size);
// sysv_proc_mutex_unlock
// file os/unix/proc_mutex.c line 91
static signed int sysv_proc_mutex_unlock(struct ci_proc_mutex *mutex);
// sysv_shared_mem_attach
// file os/unix/shared_mem.c line 56
void * sysv_shared_mem_attach(struct ci_shared_mem_id *id);
// sysv_shared_mem_create
// file os/unix/shared_mem.c line 40
void * sysv_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size);
// sysv_shared_mem_destroy
// file os/unix/shared_mem.c line 73
signed int sysv_shared_mem_destroy(struct ci_shared_mem_id *id);
// sysv_shared_mem_detach
// file os/unix/shared_mem.c line 64
signed int sysv_shared_mem_detach(struct ci_shared_mem_id *id);
// sysv_shared_mem_print_info
// file os/unix/shared_mem.c line 84
signed int sysv_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size);
// templateExpired
// file txtTemplate.c line 109
static signed int templateExpired(struct anonymous$7 *template);
// templateFind
// file txtTemplate.c line 208
static struct anonymous$7 * templateFind(const char *SERVICE_NAME, const char *TEMPLATE_NAME, const char *LANGUAGE);
// templateFindFree
// file txtTemplate.c line 228
static struct anonymous$7 * templateFindFree(void);
// templateFree
// file txtTemplate.c line 136
static void templateFree(struct anonymous$7 *template);
// templateLoadText
// file txtTemplate.c line 347
static struct anonymous$7 * templateLoadText(const struct ci_request *req, const char *service_name, const char *page_name);
// templateTryLoadText
// file txtTemplate.c line 251
static struct anonymous$7 * templateTryLoadText(const struct ci_request *req, const char *service_name, const char *page_name, const char *lang);
// template_release
// file txtTemplate.c line 152
static void template_release(struct anonymous$7 *template);
// term_handler_child
// file mpmt_server.c line 99
static void term_handler_child(signed int sig);
// test_command
// file mpmt_server.c line 1012
void test_command(const char *name, signed int type, const char **argv);
// thread_main
// file mpmt_server.c line 551
signed int thread_main(struct server_decl *srv);
// thread_signals
// file mpmt_server.c line 164
void thread_signals(signed int islistener);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// types_add
// file filetype.c line 86
signed int types_add(struct ci_magics_db *db, const char *name, const char *descr, signed int *groups);
// types_init
// file filetype.c line 81
signed int types_init(struct ci_magics_db *db);
// uint64_cmp
// file types_ops.c line 183
signed int uint64_cmp(const void *key1, const void *key2);
// uint64_dup
// file types_ops.c line 166
void * uint64_dup(const char *str, struct ci_mem_allocator *allocator);
// uint64_equal
// file types_ops.c line 196
signed int uint64_equal(const void *key1, const void *key2);
// uint64_free
// file types_ops.c line 204
void uint64_free(void *key, struct ci_mem_allocator *allocator);
// uint64_len
// file types_ops.c line 209
unsigned long int uint64_len(const void *key);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// unlink
// file /usr/include/unistd.h line 829
extern signed int unlink(const char *);
// unregister_conf_table
// file cfg_param.c line 272
struct ci_conf_entry * unregister_conf_table(const char *name);
// update_send_status
// file request.c line 832
static signed int update_send_status(struct ci_request *req);
// url_decoder
// file decode.c line 131
signed int url_decoder(const char *input, char *output, signed int output_len);
// url_decoder2
// file decode.c line 164
signed int url_decoder2(char *input);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vlog_server
// file log.c line 90
void vlog_server(struct ci_request *req, const char *format, void **ap);
// wait_childs_to_exit
// file mpmt_server.c line 297
static void wait_childs_to_exit(struct childs_queue *q);
// wait_for_commands
// file mpmt_server.c line 465
signed int wait_for_commands(signed int ctl_fd, char *command_buffer, signed int secs);
// wait_for_data
// file request.c line 83
static signed int wait_for_data(signed int fd, signed int secs, signed int what_wait);
// wait_for_queue
// file proc_threads_queues.c line 100
signed int wait_for_queue(struct connections_queue *q);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 369
extern signed long int write(signed int, const void *, unsigned long int);
// zlib_inflate
// file decode.c line 208
static signed int zlib_inflate(const char *buf, signed int len, char *unzipped_buf, signed int *unzipped_buf_len);

struct anonymous$7
{
  // TEMPLATE_NAME
  char *TEMPLATE_NAME;
  // SERVICE_NAME
  char *SERVICE_NAME;
  // LANGUAGE
  char *LANGUAGE;
  // data
  struct ci_membuf *data;
  // last_used
  signed long int last_used;
  // loaded
  signed long int loaded;
  // modified
  signed long int modified;
  // locked
  signed int locked;
  // must_free
  signed int must_free;
  // non_cached
  signed int non_cached;
};

struct anonymous$12
{
  // sem
  union anonymous$10 *sem;
};

struct anonymous$19
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$18
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$8
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$2
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

struct anonymous$13
{
  // fd
  signed int fd;
};

struct anonymous$11
{
  // id
  signed int id;
};

union anonymous$23
{
  // mutex
  union anonymous$3 *mutex;
  // rwlock
  union anonymous$1 *rwlock;
};

union anonymous$16
{
  // command_action
  void (*command_action)(const char *, signed int, const char **);
  // command_action_extend
  void (*command_action_extend)(const char *, signed int, void *);
};

union anonymous$17
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$10
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

union anonymous$21
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$22
{
  // __size
  char __size[8l];
  // __align
  signed long int __align;
};

union anonymous$4
{
  // __align
  double __align;
  // ptr
  char ptr[1l];
};

union anonymous$9
{
  // __data
  struct anonymous$8 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous$1
{
  // __data
  struct anonymous$2 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

union anonymous$14
{
  // sysv
  struct anonymous$11 sysv;
  // posix
  struct anonymous$12 posix;
  // file
  struct anonymous$13 file;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$3
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ci_proc_mutex
{
  // name
  char name[64l];
  // scheme
  const struct ci_proc_mutex_scheme *scheme;
  // $anon0
  union anonymous$14 $anon0;
};

union anonymous$5
{
  // proc_mutex
  struct ci_proc_mutex proc_mutex;
  // thread_mutex
  union anonymous$3 thread_mutex;
};

struct posix
{
  // fd
  signed int fd;
};

struct sysv
{
  // id
  signed int id;
};

union anonymous$15
{
  // posix
  struct posix posix;
  // sysv
  struct sysv sysv;
  // id_
  signed int id_;
};

union anonymous$0
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _ci_align_test
{
  // n
  char n[1l];
  // d
  double d;
};

struct access_control_module
{
  // name
  const char *name;
  // init_access_controller
  signed int (*init_access_controller)(struct ci_server_conf *);
  // post_init_access_controller
  signed int (*post_init_access_controller)(struct ci_server_conf *);
  // release_access_controller
  void (*release_access_controller)();
  // client_access
  signed int (*client_access)(struct ci_request *);
  // request_access
  signed int (*request_access)(struct ci_request *);
  // conf_table
  struct ci_conf_entry *conf_table;
};

struct acl_cmp_uint64_data
{
  // data
  unsigned long int data;
  // operator
  signed int operator;
};

struct acl_time_data
{
  // days
  unsigned int days;
  // start_time
  unsigned int start_time;
  // end_time
  unsigned int end_time;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct auth_hash
{
  // hash
  struct authenticator_module ***hash;
  // usedsize
  signed int usedsize;
  // hash_size
  signed int hash_size;
};

struct authenticator_module
{
  // name
  const char *name;
  // method
  const char *method;
  // init_authenticator
  signed int (*init_authenticator)(struct ci_server_conf *);
  // post_init_authenticator
  signed int (*post_init_authenticator)(struct ci_server_conf *);
  // close_authenticator
  void (*close_authenticator)();
  // authenticate
  signed int (*authenticate)(void *, const char *);
  // conf_table
  struct ci_conf_entry *conf_table;
};

struct cfg_default_value
{
  // param
  void *param;
  // value
  void *value;
  // size
  signed int size;
  // next
  struct cfg_default_value *next;
};

struct check_reg_data
{
  // name
  const char *name;
  // found
  signed int found;
  // count
  signed int count;
};

struct child_shared_data
{
  // freeservers
  signed int freeservers;
  // usedservers
  signed int usedservers;
  // requests
  signed int requests;
  // connections
  signed int connections;
  // pid
  signed int pid;
  // idle
  signed int idle;
  // to_be_killed
  signed int to_be_killed;
  // father_said
  signed int father_said;
  // pipe
  signed int pipe;
  // stats
  struct stat_memblock *stats;
  // stats_size
  signed int stats_size;
};

struct ci_shared_mem_id
{
  // name
  char name[64l];
  // mem
  void *mem;
  // size
  unsigned long int size;
  // scheme
  const struct ci_shared_mem_scheme *scheme;
  // $anon0
  union anonymous$15 $anon0;
};

struct childs_queue
{
  // childs
  struct child_shared_data *childs;
  // size
  signed int size;
  // shared_mem_size
  signed int shared_mem_size;
  // stats_block_size
  signed int stats_block_size;
  // stats_area
  void *stats_area;
  // stats_history
  struct stat_memblock *stats_history;
  // shmid
  struct ci_shared_mem_id shmid;
  // queue_mtx
  struct ci_proc_mutex queue_mtx;
  // srv_stats
  struct server_statistics *srv_stats;
};

struct ci_MD5Context
{
  // buf
  unsigned int buf[4l];
  // bits
  unsigned int bits[2l];
  // in
  unsigned char in[64l];
};

struct ci_access_entry
{
  // type
  signed int type;
  // spec_list
  struct ci_specs_list *spec_list;
  // next
  struct ci_access_entry *next;
};

struct ci_acl_data
{
  // data
  void *data;
  // next
  struct ci_acl_data *next;
};

struct ci_acl_regex
{
  // str
  char *str;
  // flags
  signed int flags;
  // preg
  void *preg;
};

struct ci_acl_spec
{
  // name
  char name[32l];
  // type
  const struct ci_acl_type *type;
  // parameter
  char *parameter;
  // data
  struct ci_acl_data *data;
  // next
  struct ci_acl_spec *next;
};

struct ci_acl_type
{
  // name
  char name[32l];
  // get_test_data
  void * (*get_test_data)(struct ci_request *, char *);
  // free_test_data
  void (*free_test_data)(struct ci_request *, void *);
  // type
  const struct ci_type_ops *type;
};

struct ci_acl_type_list
{
  // acl_type_list
  struct ci_acl_type *acl_type_list;
  // acl_type_list_size
  signed int acl_type_list_size;
  // acl_type_list_num
  signed int acl_type_list_num;
};

struct ci_array
{
  // items
  struct ci_array_item *items;
  // mem
  char *mem;
  // max_size
  unsigned long int max_size;
  // count
  unsigned int count;
  // alloc
  struct ci_mem_allocator *alloc;
};

struct ci_array_item
{
  // name
  char *name;
  // value
  void *value;
};

struct ci_buf
{
  // buf
  char *buf;
  // size
  signed int size;
  // used
  signed int used;
};

struct ci_cache
{
  // init
  signed int (*init)(struct ci_cache *, const char *);
  // search
  const void * (*search)(struct ci_cache *, const void *, void **, void *, void * (*)(const void *, unsigned long int, void *));
  // update
  signed int (*update)(struct ci_cache *, const void *, const void *, unsigned long int, void * (*)(void *, const void *, unsigned long int));
  // destroy
  void (*destroy)(struct ci_cache *);
  // ttl
  signed long int ttl;
  // mem_size
  unsigned int mem_size;
  // max_object_size
  unsigned int max_object_size;
  // flags
  unsigned int flags;
  // key_ops
  const struct ci_type_ops *key_ops;
  // _cache_type
  const struct ci_cache_type *_cache_type;
  // cache_data
  void *cache_data;
};

struct ci_cache_entry
{
  // hash
  unsigned int hash;
  // time
  signed long int time;
  // key
  void *key;
  // val
  void *val;
  // val_size
  signed int val_size;
  // qnext
  struct ci_cache_entry *qnext;
  // hnext
  struct ci_cache_entry *hnext;
};

struct ci_cache_type
{
  // init
  signed int (*init)(struct ci_cache *, const char *);
  // search
  const void * (*search)(struct ci_cache *, const void *, void **, void *, void * (*)(const void *, unsigned long int, void *));
  // update
  signed int (*update)(struct ci_cache *, const void *, const void *, unsigned long int, void * (*)(void *, const void *, unsigned long int));
  // destroy
  void (*destroy)(struct ci_cache *);
  // name
  const char *name;
};

struct ci_cached_file
{
  // endpos
  signed long int endpos;
  // readpos
  signed long int readpos;
  // bufsize
  signed int bufsize;
  // flags
  signed int flags;
  // unlocked
  signed long int unlocked;
  // buf
  char *buf;
  // fd
  signed int fd;
  // filename
  char filename[4097l];
  // attributes
  struct ci_array *attributes;
};

struct ci_command
{
  // name
  char name[128l];
  // type
  signed int type;
  // data
  void *data;
  // $anon0
  union anonymous$16 $anon0;
};

struct ci_conf_entry
{
  // name
  const char *name;
  // data
  void *data;
  // action
  signed int (*action)(const char *, const char **, void *);
  // msg
  const char *msg;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct ci_sockaddr
{
  // sockaddr
  struct sockaddr_in sockaddr;
  // ci_sin_family
  signed int ci_sin_family;
  // ci_sin_port
  signed int ci_sin_port;
  // ci_sin_addr
  void *ci_sin_addr;
  // ci_inaddr_len
  signed int ci_inaddr_len;
};

struct ci_connection
{
  // fd
  signed int fd;
  // claddr
  struct ci_sockaddr claddr;
  // srvaddr
  struct ci_sockaddr srvaddr;
};

struct ci_data_group
{
  // name
  char name[16l];
  // descr
  char descr[51l];
};

struct ci_data_type
{
  // name
  char name[16l];
  // descr
  char descr[51l];
  // groups
  signed int groups[64l];
};

struct ci_dyn_array
{
  // items
  struct ci_array_item **items;
  // count
  signed int count;
  // max_items
  signed int max_items;
  // alloc
  struct ci_mem_allocator *alloc;
};

struct ci_encaps_entity
{
  // start
  signed int start;
  // type
  signed int type;
  // entity
  void *entity;
};

struct ci_error_code
{
  // code
  signed int code;
  // str
  char *str;
};

struct ci_fmt_entry
{
  // directive
  const char *directive;
  // description
  const char *description;
  // format
  signed int (*format)(struct ci_request *, char *, signed int, const char *);
};

struct ci_hash_entry
{
  // hash
  unsigned int hash;
  // key
  const void *key;
  // val
  const void *val;
  // hnext
  struct ci_hash_entry *hnext;
};

struct ci_hash_table
{
  // hash_table
  struct ci_hash_entry **hash_table;
  // hash_table_size
  unsigned int hash_table_size;
  // ops
  const struct ci_type_ops *ops;
  // allocator
  struct ci_mem_allocator *allocator;
};

struct ci_headers_list
{
  // size
  signed int size;
  // used
  signed int used;
  // headers
  char **headers;
  // bufsize
  signed int bufsize;
  // bufused
  signed int bufused;
  // buf
  char *buf;
  // packed
  signed int packed;
};

struct ci_ip
{
  // address
  struct in_addr address;
  // netmask
  struct in_addr netmask;
  // family
  signed int family;
};

struct ci_list
{
  // items
  struct ci_list_item *items;
  // last
  struct ci_list_item *last;
  // trash
  struct ci_list_item *trash;
  // cursor
  struct ci_list_item *cursor;
  // tmp
  struct ci_list_item *tmp;
  // obj_size
  unsigned long int obj_size;
  // alloc
  struct ci_mem_allocator *alloc;
  // cmp_func
  signed int (*cmp_func)(const void *, const void *, unsigned long int);
  // copy_func
  signed int (*copy_func)(void *, const void *);
  // free_func
  void (*free_func)(void *);
};

struct ci_list_item
{
  // item
  void *item;
  // next
  struct ci_list_item *next;
};

struct common_mutex
{
  // isproc
  signed int isproc;
  // mtx
  union anonymous$5 mtx;
};

struct ci_local_cache_data
{
  // first_queue_entry
  struct ci_cache_entry *first_queue_entry;
  // last_queue_entry
  struct ci_cache_entry *last_queue_entry;
  // hash_table
  struct ci_cache_entry **hash_table;
  // hash_table_size
  unsigned int hash_table_size;
  // allocator
  struct ci_mem_allocator *allocator;
  // mtx
  struct common_mutex mtx;
};

struct ci_lookup_table
{
  // open
  void * (*open)(struct ci_lookup_table *);
  // close
  void (*close)(struct ci_lookup_table *);
  // search
  void * (*search)(struct ci_lookup_table *, void *, void ***);
  // release_result
  void (*release_result)(struct ci_lookup_table *, void **);
  // get_row
  const void * (*get_row)(struct ci_lookup_table *, const void *, const char **, void ***);
  // type
  char *type;
  // path
  char *path;
  // args
  char *args;
  // cols
  signed int cols;
  // col_names
  struct ci_vector *col_names;
  // key_ops
  const struct ci_type_ops *key_ops;
  // val_ops
  const struct ci_type_ops *val_ops;
  // allocator
  struct ci_mem_allocator *allocator;
  // _lt_type
  struct ci_lookup_table_type *_lt_type;
  // data
  void *data;
};

struct ci_lookup_table_type
{
  // open
  void * (*open)(struct ci_lookup_table *);
  // close
  void (*close)(struct ci_lookup_table *);
  // search
  void * (*search)(struct ci_lookup_table *, void *, void ***);
  // release_result
  void (*release_result)(struct ci_lookup_table *, void **);
  // get_row
  const void * (*get_row)(struct ci_lookup_table *, const void *, const char **, void ***);
  // type
  char *type;
};

struct ci_magic
{
  // offset
  signed int offset;
  // magic
  unsigned char magic[51l];
  // len
  unsigned long int len;
  // type
  unsigned int type;
};

struct ci_magic_record
{
  // offset
  signed int offset;
  // magic
  unsigned char magic[51l];
  // len
  unsigned long int len;
  // type
  char type[16l];
  // groups
  char *groups[65l];
  // descr
  char descr[51l];
};

struct ci_magics_db
{
  // types
  struct ci_data_type *types;
  // types_num
  signed int types_num;
  // types_size
  signed int types_size;
  // groups
  struct ci_data_group *groups;
  // groups_num
  signed int groups_num;
  // groups_size
  signed int groups_size;
  // magics
  struct ci_magic *magics;
  // magics_num
  signed int magics_num;
  // magics_size
  signed int magics_size;
};

struct ci_mem_allocator
{
  // alloc
  void * (*alloc)(struct ci_mem_allocator *, unsigned long int);
  // free
  void (*free)(struct ci_mem_allocator *, void *);
  // reset
  void (*reset)(struct ci_mem_allocator *);
  // destroy
  void (*destroy)(struct ci_mem_allocator *);
  // data
  void *data;
  // name
  char *name;
  // type
  signed int type;
  // must_free
  signed int must_free;
};

struct ci_membuf
{
  // endpos
  signed int endpos;
  // readpos
  signed int readpos;
  // bufsize
  signed int bufsize;
  // unlocked
  signed int unlocked;
  // flags
  unsigned int flags;
  // buf
  char *buf;
  // attributes
  struct ci_array *attributes;
};

struct ci_options_entry
{
  // name
  const char *name;
  // parameter
  const char *parameter;
  // data
  void *data;
  // action
  signed int (*action)(const char *, const char **, void *);
  // msg
  const char *msg;
};

struct ci_proc_mutex_scheme
{
  // proc_mutex_init
  signed int (*proc_mutex_init)(struct ci_proc_mutex *, const char *);
  // proc_mutex_destroy
  signed int (*proc_mutex_destroy)(struct ci_proc_mutex *);
  // proc_mutex_lock
  signed int (*proc_mutex_lock)(struct ci_proc_mutex *);
  // proc_mutex_unlock
  signed int (*proc_mutex_unlock)(struct ci_proc_mutex *);
  // proc_mutex_print_info
  signed int (*proc_mutex_print_info)(struct ci_proc_mutex *, char *, unsigned long int);
  // name
  const char *name;
};

struct ci_regex_match
{
  // s
  unsigned long int s;
  // e
  unsigned long int e;
};

struct ci_regex_replace_part
{
  // user_data
  const void *user_data;
  // matches
  struct ci_regex_match matches[10l];
};

struct ci_request
{
  // connection
  struct ci_connection *connection;
  // packed
  signed int packed;
  // type
  signed int type;
  // req_server
  char req_server[257l];
  // access_type
  signed int access_type;
  // user
  char user[256l];
  // service
  char service[64l];
  // args
  char args[255l];
  // preview
  signed int preview;
  // keepalive
  signed int keepalive;
  // allow204
  signed int allow204;
  // hasbody
  signed int hasbody;
  // responce_hasbody
  signed int responce_hasbody;
  // preview_data
  struct ci_buf preview_data;
  // current_service_mod
  struct ci_service_module *current_service_mod;
  // request_header
  struct ci_headers_list *request_header;
  // response_header
  struct ci_headers_list *response_header;
  // entities
  struct ci_encaps_entity *entities[5l];
  // trash_entities
  struct ci_encaps_entity *trash_entities[7l];
  // xheaders
  struct ci_headers_list *xheaders;
  // service_data
  void *service_data;
  // rbuf
  char rbuf[4096l];
  // wbuf
  char wbuf[4096l];
  // eof_received
  signed int eof_received;
  // data_locked
  signed int data_locked;
  // pstrblock_read
  char *pstrblock_read;
  // pstrblock_read_len
  signed int pstrblock_read_len;
  // current_chunk_len
  unsigned int current_chunk_len;
  // chunk_bytes_read
  unsigned int chunk_bytes_read;
  // write_to_module_pending
  unsigned int write_to_module_pending;
  // status
  signed int status;
  // return_code
  signed int return_code;
  // pstrblock_responce
  char *pstrblock_responce;
  // remain_send_block_bytes
  signed int remain_send_block_bytes;
  // preview_data_type
  signed int preview_data_type;
  // auth_required
  signed int auth_required;
  // log_str
  char *log_str;
  // attributes
  struct ci_array *attributes;
  // bytes_in
  unsigned long int bytes_in;
  // bytes_out
  unsigned long int bytes_out;
  // request_bytes_in
  unsigned long int request_bytes_in;
  // http_bytes_in
  unsigned long int http_bytes_in;
  // http_bytes_out
  unsigned long int http_bytes_out;
  // body_bytes_in
  unsigned long int body_bytes_in;
  // body_bytes_out
  unsigned long int body_bytes_out;
  // allow206
  signed int allow206;
  // i206_use_original_body
  signed long int i206_use_original_body;
  // xclient_ip
  struct ci_ip xclient_ip;
};

struct ci_ring_buf
{
  // buf
  char *buf;
  // end_buf
  char *end_buf;
  // read_pos
  char *read_pos;
  // write_pos
  char *write_pos;
  // full
  signed int full;
};

struct ci_server_conf
{
  // ADDRESS
  char *ADDRESS;
  // PORT
  signed int PORT;
  // PROTOCOL_FAMILY
  signed int PROTOCOL_FAMILY;
  // TMPDIR
  char *TMPDIR;
  // PIDFILE
  char *PIDFILE;
  // COMMANDS_SOCKET
  char *COMMANDS_SOCKET;
  // RUN_USER
  char *RUN_USER;
  // RUN_GROUP
  char *RUN_GROUP;
  // cfg_file
  char *cfg_file;
  // magics_file
  char *magics_file;
  // MAGIC_DB
  struct ci_magics_db *MAGIC_DB;
  // SERVICES_DIR
  char *SERVICES_DIR;
  // MODULES_DIR
  char *MODULES_DIR;
  // SERVER_ADMIN
  char *SERVER_ADMIN;
  // SERVER_NAME
  char *SERVER_NAME;
  // START_SERVERS
  signed int START_SERVERS;
  // MAX_SERVERS
  signed int MAX_SERVERS;
  // THREADS_PER_CHILD
  signed int THREADS_PER_CHILD;
  // MIN_SPARE_THREADS
  signed int MIN_SPARE_THREADS;
  // MAX_SPARE_THREADS
  signed int MAX_SPARE_THREADS;
};

struct ci_service_module
{
  // mod_name
  const char *mod_name;
  // mod_short_descr
  const char *mod_short_descr;
  // mod_type
  signed int mod_type;
  // mod_init_service
  signed int (*mod_init_service)(struct ci_service_xdata *, struct ci_server_conf *);
  // mod_post_init_service
  signed int (*mod_post_init_service)(struct ci_service_xdata *, struct ci_server_conf *);
  // mod_close_service
  void (*mod_close_service)();
  // mod_init_request_data
  void * (*mod_init_request_data)(struct ci_request *);
  // mod_release_request_data
  void (*mod_release_request_data)(void *);
  // mod_check_preview_handler
  signed int (*mod_check_preview_handler)(char *, signed int, struct ci_request *);
  // mod_end_of_data_handler
  signed int (*mod_end_of_data_handler)(struct ci_request *);
  // mod_service_io
  signed int (*mod_service_io)(char *, signed int *, char *, signed int *, signed int, struct ci_request *);
  // mod_conf_table
  struct ci_conf_entry *mod_conf_table;
  // mod_data
  void *mod_data;
};

struct ci_service_xdata
{
  // lock
  union anonymous$1 lock;
  // status
  signed int status;
  // intl_srv_conf_table
  struct ci_conf_entry *intl_srv_conf_table;
  // xopts
  unsigned long int xopts;
  // ISTag
  char ISTag[40l];
  // xincludes
  char xincludes[512l];
  // TransferPreview
  char TransferPreview[1024l];
  // TransferIgnore
  char TransferIgnore[1024l];
  // TransferComplete
  char TransferComplete[1024l];
  // preview_size
  signed int preview_size;
  // max_connections
  signed int max_connections;
  // options_ttl
  signed int options_ttl;
  // allow_204
  signed int allow_204;
  // allow_206
  signed int allow_206;
  // disable_206
  signed int disable_206;
  // stat_bytes_in
  signed int stat_bytes_in;
  // stat_bytes_out
  signed int stat_bytes_out;
  // stat_http_bytes_in
  signed int stat_http_bytes_in;
  // stat_http_bytes_out
  signed int stat_http_bytes_out;
  // stat_body_bytes_in
  signed int stat_body_bytes_in;
  // stat_body_bytes_out
  signed int stat_body_bytes_out;
  // stat_reqmods
  signed int stat_reqmods;
  // stat_respmods
  signed int stat_respmods;
  // stat_options
  signed int stat_options;
  // stat_allow204
  signed int stat_allow204;
};

struct ci_shared_mem_scheme
{
  // shared_mem_create
  void * (*shared_mem_create)(struct ci_shared_mem_id *, const char *, signed int);
  // shared_mem_attach
  void * (*shared_mem_attach)(struct ci_shared_mem_id *);
  // shared_mem_detach
  signed int (*shared_mem_detach)(struct ci_shared_mem_id *);
  // shared_mem_destroy
  signed int (*shared_mem_destroy)(struct ci_shared_mem_id *);
  // shared_mem_print_info
  signed int (*shared_mem_print_info)(struct ci_shared_mem_id *, char *, unsigned long int);
  // name
  const char *name;
};

struct ci_simple_file
{
  // endpos
  signed long int endpos;
  // readpos
  signed long int readpos;
  // max_store_size
  signed long int max_store_size;
  // bytes_in
  signed long int bytes_in;
  // bytes_out
  signed long int bytes_out;
  // flags
  unsigned int flags;
  // unlocked
  signed long int unlocked;
  // fd
  signed int fd;
  // filename
  char filename[4097l];
  // attributes
  struct ci_array *attributes;
  // mmap_addr
  char *mmap_addr;
  // mmap_size
  signed long int mmap_size;
};

struct ci_specs_list
{
  // spec
  const struct ci_acl_spec *spec;
  // negate
  signed int negate;
  // next
  struct ci_specs_list *next;
};

struct ci_type_ops
{
  // dup
  void * (*dup)(const char *, struct ci_mem_allocator *);
  // free
  void (*free)(void *, struct ci_mem_allocator *);
  // compare
  signed int (*compare)(const void *, const void *);
  // size
  unsigned long int (*size)(const void *);
  // equal
  signed int (*equal)(const void *, const void *);
};

struct ci_vector
{
  // items
  void **items;
  // last
  void **last;
  // mem
  char *mem;
  // max_size
  unsigned long int max_size;
  // count
  signed int count;
  // alloc
  struct ci_mem_allocator *alloc;
};

struct common_module
{
  // name
  const char *name;
  // init_module
  signed int (*init_module)(struct ci_server_conf *);
  // post_init_module
  signed int (*post_init_module)(struct ci_server_conf *);
  // close_module
  void (*close_module)();
  // conf_table
  struct ci_conf_entry *conf_table;
};

struct connections_queue
{
  // connections
  struct ci_connection *connections;
  // used
  signed int used;
  // size
  signed int size;
  // queue_mtx
  union anonymous$3 queue_mtx;
  // cond_mtx
  union anonymous$3 cond_mtx;
  // queue_cond
  union anonymous$9 queue_cond;
};

struct dlib_entry
{
  // file
  char *file;
  // name
  char *name;
  // handle
  void *handle;
  // next
  struct dlib_entry *next;
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct group_source
{
  // name
  char *name;
  // type
  signed int type;
  // db
  struct ci_lookup_table *db;
  // next
  struct group_source *next;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct http_auth_method
{
  // name
  const char *name;
  // init_auth_method
  signed int (*init_auth_method)(struct ci_server_conf *);
  // post_init_auth_method
  signed int (*post_init_auth_method)(struct ci_server_conf *);
  // close_auth_method
  void (*close_auth_method)();
  // create_auth_data
  void * (*create_auth_data)(const char *, const char **);
  // release_auth_data
  void (*release_auth_data)(void *);
  // authentication_header
  char * (*authentication_header)();
  // release_authentication_header
  void (*release_authentication_header)();
  // conf_table
  struct ci_conf_entry *conf_table;
};

struct http_basic_auth_data
{
  // http_user
  char http_user[256l];
  // http_pass
  char http_pass[257l];
};

struct in6_addr
{
  // __in6_u
  union anonymous$17 __in6_u;
};

struct info_req_data
{
  // body
  struct ci_membuf *body;
  // txt_mode
  signed int txt_mode;
  // childs
  signed int childs;
  // child_pids
  signed int *child_pids;
  // free_servers
  signed int free_servers;
  // used_servers
  signed int used_servers;
  // closing_childs
  unsigned int closing_childs;
  // closing_child_pids
  signed int *closing_child_pids;
  // started_childs
  unsigned int started_childs;
  // closed_childs
  unsigned int closed_childs;
  // crashed_childs
  unsigned int crashed_childs;
  // collect_stats
  struct stat_memblock *collect_stats;
};

struct internal_state
{
  // dummy
  signed int dummy;
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

struct kbs
{
  // kb
  unsigned long int kb;
  // bytes
  unsigned int bytes;
};

struct linger
{
  // l_onoff
  signed int l_onoff;
  // l_linger
  signed int l_linger;
};

struct logfile
{
  // file
  char *file;
  // access_log
  struct _IO_FILE *access_log;
  // log_fmt
  const char *log_fmt;
  // access_list
  struct ci_access_entry *access_list;
  // rwlock
  union anonymous$1 rwlock;
  // next
  struct logfile *next;
};

struct logformat
{
  // name
  char *name;
  // fmt
  char *fmt;
  // next
  struct logformat *next;
};

struct logger_module
{
  // name
  const char *name;
  // init_logger
  signed int (*init_logger)(struct ci_server_conf *);
  // log_open
  signed int (*log_open)();
  // log_close
  void (*log_close)();
  // log_access
  void (*log_access)(struct ci_request *);
  // log_server
  void (*log_server)(const char *, const char *, void **);
  // conf_table
  struct ci_conf_entry *conf_table;
};

struct mem_block_item
{
  // data
  void *data;
  // next
  struct mem_block_item *next;
};

struct mem_buffer_block
{
  // sig
  unsigned short int sig;
  // ID
  signed int ID;
  // data
  union anonymous$4 data;
};

struct module_tmp_struct
{
  // name
  char *name;
  // other_data
  void *other_data;
};

struct modules_list
{
  // modules
  void **modules;
  // modules_num
  signed int modules_num;
  // list_size
  signed int list_size;
};

struct mutex_itm
{
  // mtx
  union anonymous$23 mtx;
  // type
  signed int type;
  // next
  struct mutex_itm *next;
};

struct pack_allocator
{
  // memchunk
  void *memchunk;
  // curpos
  void *curpos;
  // endpos
  void *endpos;
  // end
  void *end;
  // must_free
  signed int must_free;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pcre_extra
{
  // flags
  unsigned long int flags;
  // study_data
  void *study_data;
  // match_limit
  unsigned long int match_limit;
  // callout_data
  void *callout_data;
  // tables
  const unsigned char *tables;
  // match_limit_recursion
  unsigned long int match_limit_recursion;
  // mark
  unsigned char **mark;
  // executable_jit
  void *executable_jit;
};

struct pool_allocator
{
  // items_size
  signed int items_size;
  // strict
  signed int strict;
  // alloc_count
  signed int alloc_count;
  // hits_count
  signed int hits_count;
  // mutex
  union anonymous$3 mutex;
  // free
  struct mem_block_item *free;
  // allocated
  struct mem_block_item *allocated;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct schedule_data
{
  // name
  char name[128l];
  // when
  signed long int when;
  // data
  void *data;
};

struct sembuf
{
  // sem_num
  unsigned short int sem_num;
  // sem_op
  signed short int sem_op;
  // sem_flg
  signed short int sem_flg;
};

struct semid_ds
{
  // sem_perm
  struct ipc_perm sem_perm;
  // sem_otime
  signed long int sem_otime;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // sem_ctime
  signed long int sem_ctime;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
  // sem_nsems
  unsigned long int sem_nsems;
  // __glibc_reserved3
  unsigned long int __glibc_reserved3;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
};

struct seminfo
{
  // semmap
  signed int semmap;
  // semmni
  signed int semmni;
  // semmns
  signed int semmns;
  // semmnu
  signed int semmnu;
  // semmsl
  signed int semmsl;
  // semopm
  signed int semopm;
  // semume
  signed int semume;
  // semusz
  signed int semusz;
  // semvmx
  signed int semvmx;
  // semaem
  signed int semaem;
};

union semun
{
  // val
  signed int val;
  // buf
  struct semid_ds *buf;
  // array
  unsigned short int *array;
  // __buf
  struct seminfo *__buf;
};

struct serial_allocator
{
  // memchunk
  void *memchunk;
  // curpos
  void *curpos;
  // endpos
  void *endpos;
  // next
  struct serial_allocator *next;
};

struct server_decl
{
  // srv_id
  signed int srv_id;
  // srv_pthread
  unsigned long int srv_pthread;
  // con_queue
  struct connections_queue *con_queue;
  // current_req
  struct ci_request *current_req;
  // served_requests
  signed int served_requests;
  // served_requests_no_reallocation
  signed int served_requests_no_reallocation;
  // running
  signed int running;
};

struct server_statistics
{
  // started_childs
  unsigned int started_childs;
  // closed_childs
  unsigned int closed_childs;
  // crashed_childs
  unsigned int crashed_childs;
};

struct service_alias
{
  // alias
  char alias[64l];
  // args
  char args[256l];
  // service
  struct ci_service_module *service;
};

struct service_handler_module
{
  // name
  const char *name;
  // extensions
  const char *extensions;
  // init_service_handler
  signed int (*init_service_handler)(struct ci_server_conf *);
  // post_init_service_handler
  signed int (*post_init_service_handler)(struct ci_server_conf *);
  // release_service_handler
  void (*release_service_handler)();
  // create_service
  struct ci_service_module * (*create_service)(const char *);
  // conf_table
  struct ci_conf_entry *conf_table;
};

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct stat_area
{
  // mtx
  union anonymous$3 mtx;
  // release_mem
  void (*release_mem)(void *);
  // mem_block
  struct stat_memblock *mem_block;
};

struct stat_entry
{
  // label
  char *label;
  // type
  signed int type;
  // gid
  signed int gid;
};

struct stat_entry_list
{
  // entries
  struct stat_entry *entries;
  // size
  signed int size;
  // entries_num
  signed int entries_num;
};

struct stat_groups_list
{
  // groups
  char **groups;
  // size
  signed int size;
  // entries_num
  signed int entries_num;
};

struct stat_memblock
{
  // sig
  unsigned int sig;
  // counters64_size
  signed int counters64_size;
  // counterskbs_size
  signed int counterskbs_size;
  // counters64
  unsigned long int *counters64;
  // counterskbs
  struct kbs *counterskbs;
};

struct stats_tmpl
{
  // gen_template
  char *gen_template;
  // statsHeader
  char *statsHeader;
  // statsEnd
  char *statsEnd;
  // childsHeader
  char *childsHeader;
  // childs_tmpl
  char *childs_tmpl;
  // childsEnd
  char *childsEnd;
  // closingChildsHeader
  char *closingChildsHeader;
  // d1TableHeader_tmpl
  char *d1TableHeader_tmpl;
  // d1TableEntry_tmpl
  char *d1TableEntry_tmpl;
  // d1TableEnd_tmpl
  char *d1TableEnd_tmpl;
  // statline_tmpl_int
  char *statline_tmpl_int;
  // statline_tmpl_kbs
  char *statline_tmpl_kbs;
};

struct sub_table
{
  // name
  const char *name;
  // type
  signed int type;
  // conf_table
  struct ci_conf_entry *conf_table;
};

struct text_table
{
  // entries
  struct text_table_entry *entries;
  // hash_table
  struct ci_hash_table *hash_table;
  // rows
  signed int rows;
};

struct text_table_entry
{
  // key
  void *key;
  // vals
  void **vals;
  // next
  struct text_table_entry *next;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct z_stream_s
{
  // next_in
  unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};


// ACCESS_LOG_FILES
// file log.c line 198
struct logfile *ACCESS_LOG_FILES = (struct logfile *)(void *)0;
// ALLOW204_AS_200OK_ZERO_ENCAPS
// file cfg_param.c line 85
signed int ALLOW204_AS_200OK_ZERO_ENCAPS = 0;
// ALLOW_REMOTE_PROXY_USERS
// file http_auth.c line 32
signed int ALLOW_REMOTE_PROXY_USERS = 0;
// ARGC
// file cfg_param.c line 42
signed int ARGC;
// ARGV
// file cfg_param.c line 43
char **ARGV;
// CACHED_FILE_POOL
// file body.c line 45
static signed int CACHED_FILE_POOL = -1;
// CHECK_FOR_BUGGY_CLIENT
// file cfg_param.c line 84
signed int CHECK_FOR_BUGGY_CLIENT = 0;
// CHILD_HALT
// file mpmt_server.c line 80
signed int CHILD_HALT = 0;
// CHILD_SHUTDOWN_TIMEOUT
// file mpmt_server.c line 79
const signed int CHILD_SHUTDOWN_TIMEOUT = 10;
// CI_BODY_MAX_MEM
// file body.c line 334
signed int CI_BODY_MAX_MEM = 131072;
// CI_CONF
// file cfg_param.c line 45
struct ci_server_conf CI_CONF = { .ADDRESS=(char *)(void *)0, .PORT=1344, .PROTOCOL_FAMILY=2,
    .TMPDIR="/var/tmp/", .PIDFILE="/var/run/c-icap/c-icap.pid",
    .COMMANDS_SOCKET="/var/run/c-icap/c-icap.ctl",
    .RUN_USER=(char *)(void *)0,
    .RUN_GROUP=(char *)(void *)0, .cfg_file="/etc/c-icap/c-icap.conf",
    .magics_file="/etc/c-icap/c-icap.magic",
    .MAGIC_DB=(struct ci_magics_db *)(void *)0,
    .SERVICES_DIR="/usr/lib/x86_64-linux-gnu/c_icap/",
    .MODULES_DIR="/usr/lib/x86_64-linux-gnu/c_icap/",
    .SERVER_ADMIN=(char *)(void *)0,
    .SERVER_NAME=(char *)(void *)0, .START_SERVERS=5,
    .MAX_SERVERS=10, .THREADS_PER_CHILD=30, .MIN_SPARE_THREADS=30,
    .MAX_SPARE_THREADS=60 };
// CI_DEBUG_LEVEL
// file debug.c line 26
signed int CI_DEBUG_LEVEL = 1;
// CI_DEBUG_STDOUT
// file debug.c line 27
signed int CI_DEBUG_STDOUT = 0;
// CI_TMPDIR
// file body.c line 335
char *CI_TMPDIR = "/var/tmp/";
// COMMANDS_LIST
// file commands.c line 37
static struct ci_list *COMMANDS_LIST = (struct ci_list *)(void *)0;
// COMMANDS_MTX
// file commands.c line 40
union anonymous$3 COMMANDS_MTX;
// COMMANDS_QUEUE
// file commands.c line 39
static struct ci_list *COMMANDS_QUEUE = (struct ci_list *)(void *)0;
// DAEMON_MODE
// file cfg_param.c line 80
signed int DAEMON_MODE = 1;
// DEFAULT_AUTH_METHOD
// file http_auth.c line 30
char *DEFAULT_AUTH_METHOD = "basic";
// DEFAULT_LOG_FORMAT
// file log.c line 215
const char *DEFAULT_LOG_FORMAT = "%tl, %la %a %im %iu %is";
// DEFAULT_SERVICE
// file cfg_param.c line 82
const char *DEFAULT_SERVICE = (const char *)(void *)0;
// DebugLevelSetFromCmd
// file cfg_param.c line 81
signed int DebugLevelSetFromCmd = 0;
// GROUPS_SOURCE
// file http_auth.c line 134
struct group_source *GROUPS_SOURCE = (struct group_source *)(void *)0;
// GlobalTable
// file txt_format.c line 100
struct ci_fmt_entry GlobalTable[35l];
// GlobalTable
// file txt_format.c line 100
struct ci_fmt_entry GlobalTable[35l] = { { .directive="%a", .description="Remote IP-Address", .format=fmt_remoteip }, 
    { .directive="%la", .description="Local IP Address", .format=fmt_localip }, 
    { .directive="%lp", .description="Local port", .format=fmt_none }, 
    { .directive="%>a", .description="Http Client IP Address", .format=fmt_httpclientip }, 
    { .directive="%<A", .description="Http Server IP Address", .format=fmt_httpserverip }, 
    { .directive="%ts", .description="Seconds since epoch", .format=fmt_seconds }, 
    { .directive="%tl", .description="Local time", .format=fmt_localtime }, 
    { .directive="%tg", .description="GMT time", .format=fmt_gmttime }, 
    { .directive="%tr", .description="Response time", .format=fmt_none }, 
    { .directive="%>hi", .description="Http request header", .format=fmt_none }, 
    { .directive="%>ho", .description="Modified Http request header", .format=fmt_http_req_head_o }, 
    { .directive="%huo", .description="Modified Http request url", .format=fmt_http_req_url_o }, 
    { .directive="%hu", .description="Http request url", .format=fmt_none }, 
    { .directive="%<hi", .description="Http reply header", .format=fmt_none }, 
    { .directive="%<ho", .description="Modified Http reply header", .format=fmt_http_res_head_o }, 
    { .directive="%Hs", .description="Http reply status", .format=fmt_none }, 
    { .directive="%Hso", .description="Modified Http reply status", .format=fmt_none }, 
    { .directive="%iu", .description="Icap request url", .format=fmt_request }, 
    { .directive="%im", .description="Icap method", .format=fmt_icapmethod }, 
    { .directive="%is", .description="Icap status code", .format=fmt_icapstatus }, 
    { .directive="%>ih", .description="Icap request header", .format=fmt_icap_req_head }, 
    { .directive="%<ih", .description="Icap response header", .format=fmt_icap_res_head }, 
    { .directive="%ipl", .description="Icap preview length", .format=fmt_req_preview_len }, 
    { .directive="%Ih", .description="Http bytes received", .format=fmt_req_http_bytes_rcv }, 
    { .directive="%Oh", .description="Http bytes sent", .format=fmt_req_http_bytes_sent }, 
    { .directive="%Ib", .description="Http body bytes received", .format=fmt_req_body_bytes_rcv }, 
    { .directive="%Ob", .description="Http body bytes sent", .format=fmt_req_body_bytes_sent }, 
    { .directive="%I", .description="Bytes received", .format=fmt_req_bytes_rcv }, 
    { .directive="%O", .description="Bytes sent", .format=fmt_req_bytes_sent }, 
    { .directive="%bph", .description="Body data preview", .format=fmt_req_preview_hex }, 
    { .directive="%un", .description="Username", .format=fmt_username }, 
    { .directive="%Sl", .description="Service log string", .format=fmt_logstr }, 
    { .directive="%Sa", .description="Attribute set by service", .format=fmt_req_attribute }, 
    { .directive="%%", .description="% sign", .format=fmt_percent }, 
    { .directive=(const char *)(void *)0, .description=(const char *)(void *)0, .format=(signed int (*)(struct ci_request *, char *, signed int, const char *))(void *)0 } };
// KEEPALIVE_TIMEOUT
// file cfg_param.c line 75
signed int KEEPALIVE_TIMEOUT = 15;
// LISTEN_SOCKET
// file mpmt_server.c line 86
signed int LISTEN_SOCKET = -1;
// LOGFORMATS
// file log.c line 113
struct logformat *LOGFORMATS = (struct logformat *)(void *)0;
// MAX_KEEPALIVE_REQUESTS
// file cfg_param.c line 76
signed int MAX_KEEPALIVE_REQUESTS = 100;
// MAX_REQUESTS_BEFORE_REALLOCATE_MEM
// file cfg_param.c line 78
signed int MAX_REQUESTS_BEFORE_REALLOCATE_MEM = 100;
// MAX_REQUESTS_PER_CHILD
// file cfg_param.c line 79
signed int MAX_REQUESTS_PER_CHILD = 0;
// MAX_SECS_TO_LINGER
// file cfg_param.c line 77
signed int MAX_SECS_TO_LINGER = 5;
// MEMBUF_POOL
// file body.c line 44
static signed int MEMBUF_POOL = -1;
// MEM_ALLOCATOR_POOL
// file mem.c line 34
signed int MEM_ALLOCATOR_POOL = -1;
// MY_HOSTNAME
// file aserver.c line 42
char MY_HOSTNAME[257l];
// MY_PROC_PID
// file mpmt_server.c line 77
signed int MY_PROC_PID = 0;
// PACK_ALLOCATOR_POOL
// file mem.c line 35
signed int PACK_ALLOCATOR_POOL = -1;
// PARSE_LEVEL
// file cfg_param.c line 819
static signed int PARSE_LEVEL = 0;
// PASSWORDS_ENCRYPTED
// file http_auth.c line 457
signed int PASSWORDS_ENCRYPTED = 1;
// PIPELINING
// file cfg_param.c line 83
signed int PIPELINING = 1;
// REGISTRIES
// file registry.c line 26
static struct ci_array *REGISTRIES = (struct ci_array *)(void *)0;
// REG_ITEMS_COUNT
// file registry.c line 27
static signed int REG_ITEMS_COUNT = 0;
// REMOTE_PROXY_USER_HEADER
// file http_auth.c line 31
char *REMOTE_PROXY_USER_HEADER = "X-Authenticated-User";
// REMOTE_PROXY_USER_HEADER_ENCODED
// file http_auth.c line 33
signed int REMOTE_PROXY_USER_HEADER_ENCODED = 1;
// RING_BUF_POOL
// file body.c line 47
static signed int RING_BUF_POOL = -1;
// SERVER_LOG_FILE
// file log.c line 187
char *SERVER_LOG_FILE = "/var/log//cicap-server.log";
// SIMPLE_FILE_POOL
// file body.c line 46
static signed int SIMPLE_FILE_POOL = -1;
// STATS
// file stats.c line 29
struct stat_area *STATS = (struct stat_area *)(void *)0;
// STAT_ALLOW204
// file request.c line 65
static signed int STAT_ALLOW204 = -1;
// STAT_BODY_BYTES_IN
// file request.c line 60
static signed int STAT_BODY_BYTES_IN = -1;
// STAT_BODY_BYTES_OUT
// file request.c line 61
static signed int STAT_BODY_BYTES_OUT = -1;
// STAT_BYTES_IN
// file request.c line 56
static signed int STAT_BYTES_IN = -1;
// STAT_BYTES_OUT
// file request.c line 57
static signed int STAT_BYTES_OUT = -1;
// STAT_FAILED_REQUESTS
// file request.c line 55
static signed int STAT_FAILED_REQUESTS = -1;
// STAT_GROUPS
// file stats.c line 27
struct stat_groups_list STAT_GROUPS = { .groups=(char **)(void *)0, .size=0, .entries_num=0 };
// STAT_HTTP_BYTES_IN
// file request.c line 58
static signed int STAT_HTTP_BYTES_IN = -1;
// STAT_HTTP_BYTES_OUT
// file request.c line 59
static signed int STAT_HTTP_BYTES_OUT = -1;
// STAT_INT64
// file stats.c line 25
struct stat_entry_list STAT_INT64 = { .entries=(struct stat_entry *)(void *)0, .size=0,
    .entries_num=0 };
// STAT_KBS
// file stats.c line 26
struct stat_entry_list STAT_KBS = { .entries=(struct stat_entry *)(void *)0, .size=0,
    .entries_num=0 };
// STAT_OPTIONS
// file request.c line 64
static signed int STAT_OPTIONS = -1;
// STAT_REQMODS
// file request.c line 62
static signed int STAT_REQMODS = -1;
// STAT_REQUESTS
// file request.c line 54
static signed int STAT_REQUESTS = -1;
// STAT_RESPMODS
// file request.c line 63
static signed int STAT_RESPMODS = -1;
// TEMPLATE_CACHE_SIZE
// file txtTemplate.c line 63
signed int TEMPLATE_CACHE_SIZE = 20;
// TEMPLATE_DEF_LANG
// file txtTemplate.c line 57
const char *TEMPLATE_DEF_LANG = "en";
// TEMPLATE_DIR
// file txtTemplate.c line 56
const char *TEMPLATE_DIR = (const char *)(void *)0;
// TEMPLATE_MEMBUF_SIZE
// file txtTemplate.c line 64
signed int TEMPLATE_MEMBUF_SIZE = 8192;
// TEMPLATE_RELOAD_TIME
// file txtTemplate.c line 58
signed int TEMPLATE_RELOAD_TIME = 360;
// TIMEOUT
// file cfg_param.c line 74
signed int TIMEOUT = 300;
// USERS_DB_PATH
// file http_auth.c line 456
char *USERS_DB_PATH = (char *)(void *)0;
// _MAGIC_DB
// file filetype.c line 39
static struct ci_magics_db *_MAGIC_DB = (struct ci_magics_db *)(void *)0;
// __intl_free
// file request_common.c line 41
void (*__intl_free)(void *);
// __intl_free
// file request_common.c line 41
void (*__intl_free)(void *) = _os_free;
// __intl_malloc
// file request_common.c line 40
void * (*__intl_malloc)(signed int);
// __intl_malloc
// file request_common.c line 40
void * (*__intl_malloc)(signed int) = _os_malloc;
// __log_error
// file debug.c line 31
void (*__log_error)(void *, const char *, ...) = (void (*)(void *, const char *, ...))(void *)0;
// accept_mutex
// file mpmt_server.c line 83
struct ci_proc_mutex accept_mutex;
// access_controllers
// file module.c line 51
static struct modules_list access_controllers = { .modules=(void **)(void *)0, .modules_num=0, .list_size=0 };
// acl_access_list
// file default_acl.c line 46
struct ci_access_entry *acl_access_list = (struct ci_access_entry *)(void *)0;
// acl_auth
// file http_auth.c line 327
struct ci_acl_type acl_auth;
// ci_str_ext_ops
// file types_ops.c line 96
const struct ci_type_ops ci_str_ext_ops;
// ci_str_ext_ops
// file types_ops.c line 96
const struct ci_type_ops ci_str_ext_ops = { .dup=stringdup, .free=stringfree, .compare=string_ext_cmp, .size=stringlen,
    .equal=string_ext_equal };
// acl_auth
// file http_auth.c line 327
struct ci_acl_type acl_auth = { .name={ 'a', 'u', 't', 'h', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_auth,
    .free_test_data=free_auth, .type=&ci_str_ext_ops };
// acl_cmp_uint64_ops
// file acl.c line 207
static const struct ci_type_ops acl_cmp_uint64_ops;
// acl_cmp_uint64_ops
// file acl.c line 207
static const struct ci_type_ops acl_cmp_uint64_ops = { .dup=acl_cmp_uint64_dup, .free=acl_cmp_uint64_free, .compare=(signed int (*)(const void *, const void *))(void *)0,
    .size=(unsigned long int (*)(const void *))(void *)0,
    .equal=acl_cmp_uint64_equal };
// acl_conf_variables
// file default_acl.c line 49
static struct ci_conf_entry acl_conf_variables[4l];
// acl_conf_variables
// file default_acl.c line 49
static struct ci_conf_entry acl_conf_variables[4l] = { { .name="acl", .data=(void *)0, .action=cfg_default_acl_add, .msg=(const char *)(void *)0 }, 
    { .name="client_access", .data=(void *)0, .action=cfg_default_acl_access,
    .msg=(const char *)(void *)0 }, 
    { .name="icap_access", .data=(void *)0, .action=cfg_default_acl_access, .msg=(const char *)(void *)0 }, 
    { .name=(const char *)(void *)0, .data=(void *)0, .action=(signed int (*)(const char *, const char **, void *))(void *)0,
    .msg=(const char *)(void *)0 } };
// acl_connection_access_list
// file default_acl.c line 45
struct ci_access_entry *acl_connection_access_list = (struct ci_access_entry *)(void *)0;
// acl_content_length
// file acl.c line 217
static struct ci_acl_type acl_content_length;
// acl_content_length
// file acl.c line 217
static struct ci_acl_type acl_content_length = { .name={ 'c', 'o', 'n', 't', 'e', 'n', 't', '_', 'l', 'e', 'n', 'g', 't', 'h', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_content_length,
    .free_test_data=free_cmp_uint64_data, .type=&acl_cmp_uint64_ops };
// acl_data_type
// file acl.c line 168
struct ci_acl_type acl_data_type;
// ci_datatype_ops
// file types_ops.c line 377
const struct ci_type_ops ci_datatype_ops;
// ci_datatype_ops
// file types_ops.c line 377
const struct ci_type_ops ci_datatype_ops = { .dup=datatype_dup, .free=datatype_free, .compare=datatype_cmp,
    .size=datatype_len, .equal=datatype_equal };
// acl_data_type
// file acl.c line 168
struct ci_acl_type acl_data_type = { .name={ 'd', 'a', 't', 'a', '_', 't', 'y', 'p', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_data_type,
    .free_test_data=free_data_type, .type=&ci_datatype_ops };
// acl_group
// file http_auth.c line 312
struct ci_acl_type acl_group;
// ci_group_ops
// file http_auth.c line 297
struct ci_type_ops ci_group_ops;
// ci_group_ops
// file http_auth.c line 297
struct ci_type_ops ci_group_ops = { .dup=group_dup, .free=group_free, .compare=group_cmp, .size=group_len,
    .equal=group_equal };
// acl_group
// file http_auth.c line 312
struct ci_acl_type acl_group = { .name={ 'g', 'r', 'o', 'u', 'p', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_auth,
    .free_test_data=free_user, .type=&ci_group_ops };
// acl_http_req_header
// file acl.c line 153
struct ci_acl_type acl_http_req_header;
// ci_regex_ops
// file types_ops.c line 301
const struct ci_type_ops ci_regex_ops;
// ci_regex_ops
// file types_ops.c line 301
const struct ci_type_ops ci_regex_ops = { .dup=regex_dup, .free=regex_free, .compare=regex_cmp, .size=regex_len,
    .equal=regex_equal };
// acl_http_req_header
// file acl.c line 153
struct ci_acl_type acl_http_req_header = { .name={ 'h', 't', 't', 'p', '_', 'r', 'e', 'q', '_', 'h', 'e', 'a', 'd', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_http_req_header,
    .free_test_data=free_http_req_header, .type=&ci_regex_ops };
// acl_http_resp_header
// file acl.c line 160
struct ci_acl_type acl_http_resp_header;
// acl_http_resp_header
// file acl.c line 160
struct ci_acl_type acl_http_resp_header = { .name={ 'h', 't', 't', 'p', '_', 'r', 'e', 's', 'p', '_', 'h', 'e', 'a', 'd', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_http_resp_header,
    .free_test_data=free_http_resp_header,
    .type=&ci_regex_ops };
// acl_icap_header
// file acl.c line 139
struct ci_acl_type acl_icap_header;
// acl_icap_header
// file acl.c line 139
struct ci_acl_type acl_icap_header = { .name={ 'i', 'c', 'a', 'p', '_', 'h', 'e', 'a', 'd', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_icap_header,
    .free_test_data=free_icap_header, .type=&ci_regex_ops };
// acl_icap_resp_header
// file acl.c line 146
struct ci_acl_type acl_icap_resp_header;
// acl_icap_resp_header
// file acl.c line 146
struct ci_acl_type acl_icap_resp_header = { .name={ 'i', 'c', 'a', 'p', '_', 'r', 'e', 's', 'p', '_', 'h', 'e', 'a', 'd', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_icap_response_header,
    .free_test_data=free_icap_response_header,
    .type=&ci_regex_ops };
// acl_req_type
// file acl.c line 103
struct ci_acl_type acl_req_type;
// ci_str_ops
// file types_ops.c line 65
const struct ci_type_ops ci_str_ops;
// ci_str_ops
// file types_ops.c line 65
const struct ci_type_ops ci_str_ops = { .dup=stringdup, .free=stringfree, .compare=stringcmp, .size=stringlen,
    .equal=stringequal };
// acl_req_type
// file acl.c line 103
struct ci_acl_type acl_req_type = { .name={ 't', 'y', 'p', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_reqtype,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_str_ops };
// acl_service
// file acl.c line 96
struct ci_acl_type acl_service;
// acl_service
// file acl.c line 96
struct ci_acl_type acl_service = { .name={ 's', 'e', 'r', 'v', 'i', 'c', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_service,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_str_ops };
// acl_tcp_port
// file acl.c line 110
struct ci_acl_type acl_tcp_port;
// ci_int32_ops
// file types_ops.c line 157
const struct ci_type_ops ci_int32_ops;
// ci_int32_ops
// file types_ops.c line 157
const struct ci_type_ops ci_int32_ops = { .dup=int32_dup, .free=int32_free, .compare=int32_cmp, .size=int32_len,
    .equal=int32_equal };
// acl_tcp_port
// file acl.c line 110
struct ci_acl_type acl_tcp_port = { .name={ 'p', 'o', 'r', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_port,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_int32_ops };
// acl_tcp_src
// file acl.c line 117
struct ci_acl_type acl_tcp_src;
// ci_ip_sockaddr_ops
// file types_ops.c line 604
const struct ci_type_ops ci_ip_sockaddr_ops;
// ci_ip_sockaddr_ops
// file types_ops.c line 604
const struct ci_type_ops ci_ip_sockaddr_ops = { .dup=ip_dup, .free=ip_free, .compare=ip_sockaddr_cmp, .size=ip_len,
    .equal=ip_sockaddr_equal };
// acl_tcp_src
// file acl.c line 117
struct ci_acl_type acl_tcp_src = { .name={ 's', 'r', 'c', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_client_ip,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_ip_sockaddr_ops };
// acl_tcp_srvip
// file acl.c line 124
struct ci_acl_type acl_tcp_srvip;
// acl_tcp_srvip
// file acl.c line 124
struct ci_acl_type acl_tcp_srvip = { .name={ 's', 'r', 'v', 'i', 'p', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_srv_ip,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_ip_sockaddr_ops };
// acl_tcp_xclientip
// file acl.c line 131
struct ci_acl_type acl_tcp_xclientip;
// ci_ip_ops
// file types_ops.c line 594
const struct ci_type_ops ci_ip_ops;
// ci_ip_ops
// file types_ops.c line 594
const struct ci_type_ops ci_ip_ops = { .dup=ip_dup, .free=ip_free, .compare=ip_cmp, .size=ip_len,
    .equal=ip_equal };
// acl_tcp_xclientip
// file acl.c line 131
struct ci_acl_type acl_tcp_xclientip = { .name={ 'h', 't', 't', 'p', '_', 'c', 'l', 'i', 'e', 'n', 't', '_', 'i', 'p', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_http_client_ip,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_ip_ops };
// acl_time
// file acl.c line 257
static struct ci_acl_type acl_time;
// acl_time_ops
// file acl.c line 246
static const struct ci_type_ops acl_time_ops;
// acl_time_ops
// file acl.c line 246
static const struct ci_type_ops acl_time_ops = { .dup=acl_time_dup, .free=acl_time_free, .compare=(signed int (*)(const void *, const void *))(void *)0,
    .size=(unsigned long int (*)(const void *))(void *)0,
    .equal=acl_time_equal };
// acl_time
// file acl.c line 257
static struct ci_acl_type acl_time = { .name={ 't', 'i', 'm', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_time_data,
    .free_test_data=free_time_data, .type=&acl_time_ops };
// acl_user
// file acl.c line 89
struct ci_acl_type acl_user;
// acl_user
// file acl.c line 89
struct ci_acl_type acl_user = { .name={ 'u', 's', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_user,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_str_ops };
// atol_err_conversion
// file util.c line 75
static const char *atol_err_conversion = "CONVERSION_ERROR";
// atol_err_erange
// file util.c line 74
static const char *atol_err_erange = "ERANGE";
// atol_err_nonumber
// file util.c line 76
static const char *atol_err_nonumber = "NO_DIGITS_ERROR";
// auth_methods
// file module.c line 52
static struct modules_list auth_methods = { .modules=(void **)(void *)0, .modules_num=0, .list_size=0 };
// authenticators
// file module.c line 53
static struct modules_list authenticators = { .modules=(void **)(void *)0, .modules_num=0, .list_size=0 };
// authenticators_hash
// file module.c line 430
struct auth_hash authenticators_hash;
// base64_table
// file decode.c line 34
unsigned char base64_table[256l] = { (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)62, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)63, (unsigned char)52, (unsigned char)53, (unsigned char)54, (unsigned char)55, (unsigned char)56, (unsigned char)57, (unsigned char)58, (unsigned char)59, (unsigned char)60, (unsigned char)61, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)0, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)3, (unsigned char)4, (unsigned char)5, (unsigned char)6, (unsigned char)7, (unsigned char)8, (unsigned char)9, (unsigned char)10, (unsigned char)11, (unsigned char)12, (unsigned char)13, (unsigned char)14, (unsigned char)15, (unsigned char)16, (unsigned char)17, (unsigned char)18, (unsigned char)19, (unsigned char)20, (unsigned char)21, (unsigned char)22, (unsigned char)23, (unsigned char)24, (unsigned char)25, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)26, (unsigned char)27, (unsigned char)28, (unsigned char)29, (unsigned char)30, (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34, (unsigned char)35, (unsigned char)36, (unsigned char)37, (unsigned char)38, (unsigned char)39, (unsigned char)40, (unsigned char)41, (unsigned char)42, (unsigned char)43, (unsigned char)44, (unsigned char)45, (unsigned char)46, (unsigned char)47, (unsigned char)48, (unsigned char)49, (unsigned char)50, (unsigned char)51, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255 };
// basic_auth
// file http_auth.c line 384
struct http_auth_method basic_auth;
// basic_conf_params
// file http_auth.c line 372
static struct ci_conf_entry basic_conf_params[2l];
// basic_realm
// file http_auth.c line 368
static char *basic_realm = "Basic authentication";
// basic_conf_params
// file http_auth.c line 372
static struct ci_conf_entry basic_conf_params[2l] = { { .name="Realm", .data=(void *)&basic_realm, .action=ci_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name=(const char *)(void *)0, .data=(void *)0, .action=(signed int (*)(const char *, const char **, void *))(void *)0,
    .msg=(const char *)(void *)0 } };
// basic_auth
// file http_auth.c line 384
struct http_auth_method basic_auth = { .name="basic", .init_auth_method=(signed int (*)(struct ci_server_conf *))(void *)0, .post_init_auth_method=basic_post_init,
    .close_auth_method=basic_close,
    .create_auth_data=(void * (*)(const char *, const char **))basic_create_auth_data, .release_auth_data=(void (*)(void *))basic_release_auth_data,
    .authentication_header=basic_authentication_header,
    .release_authentication_header=(void (*)())(void *)0,
    .conf_table=basic_conf_params };
// basic_authentication
// file http_auth.c line 369
static char *basic_authentication = (char *)(void *)0;
// basic_simple_db
// file http_auth.c line 472
struct authenticator_module basic_simple_db;
// basic_simple_db_conf_variables
// file http_auth.c line 462
static struct ci_conf_entry basic_simple_db_conf_variables[2l];
// basic_simple_db_conf_variables
// file http_auth.c line 462
static struct ci_conf_entry basic_simple_db_conf_variables[2l] = { { .name="UsersDB", .data=(void *)&USERS_DB_PATH, .action=ci_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name=(const char *)(void *)0, .data=(void *)0, .action=(signed int (*)(const char *, const char **, void *))(void *)0,
    .msg=(const char *)(void *)0 } };
// basic_simple_db
// file http_auth.c line 472
struct authenticator_module basic_simple_db = { .name="basic_simple_db", .method="basic", .init_authenticator=(signed int (*)(struct ci_server_conf *))(void *)0,
    .post_init_authenticator=basic_simple_db_post_init,
    .close_authenticator=basic_simple_db_close,
    .authenticate=(signed int (*)(void *, const char *))basic_simple_db_athenticate,
    .conf_table=basic_simple_db_conf_variables };
// c_icap_going_to_term
// file mpmt_server.c line 87
signed int c_icap_going_to_term = 0;
// c_icap_reconfigure
// file mpmt_server.c line 88
signed int c_icap_reconfigure = 0;
// c_service_handler
// file service.c line 596
struct service_handler_module c_service_handler;
// c_service_handler
// file service.c line 596
struct service_handler_module c_service_handler = { .name="C_handler", .extensions=".so,.sa,.a", .init_service_handler=(signed int (*)(struct ci_server_conf *))(void *)0,
    .post_init_service_handler=(signed int (*)(struct ci_server_conf *))(void *)0,
    .release_service_handler=release_c_handler,
    .create_service=load_c_service,
    .conf_table=(struct ci_conf_entry *)(void *)0 };
// cfg_params_allocator
// file cfg_lib.c line 32
struct ci_mem_allocator *cfg_params_allocator = (struct ci_mem_allocator *)(void *)0;
// child_data
// file mpmt_server.c line 75
struct child_shared_data *child_data = (struct child_shared_data *)(void *)0;
// childs_queue
// file mpmt_server.c line 73
struct childs_queue *childs_queue = (struct childs_queue *)(void *)0;
// ci_common_headers
// file header.c line 29
const char *ci_common_headers[8l] = { "Cache-Control", "Connection", "Date", "Expires", "Pragma", "Trailer", "Upgrade", "Encapsulated" };
// ci_encaps_entities
// file header.c line 128
const char *ci_encaps_entities[6l] = { "req-hdr", "res-hdr", "req-body", "res-body", "null-body", "opt-body" };
// ci_error_codes
// file header.c line 87
struct ci_error_code ci_error_codes[16l] = { { .code=100, .str="Continue" }, { .code=200, .str="OK" }, { .code=204, .str="Unmodified" }, { .code=206, .str="Partial Content" }, { .code=400, .str="Bad request" }, { .code=401, .str="Unauthorized" }, { .code=403, .str="Forbidden" }, { .code=404, .str="Service not found" }, 
    { .code=405, .str="Not allowed" }, { .code=407, .str="Authentication Required" }, 
    { .code=408, .str="Request timeout" }, { .code=500, .str="Server error" }, { .code=501, .str="Not implemented" }, { .code=502, .str="Bad Gateway" }, { .code=503, .str="Service overloaded" }, 
    { .code=505, .str="Unsupported version" } };
// ci_local_cache
// file cache.c line 70
struct ci_cache_type ci_local_cache;
// ci_local_cache
// file cache.c line 70
struct ci_cache_type ci_local_cache = { .init=ci_local_cache_init, .search=ci_local_cache_search, .update=ci_local_cache_update,
    .destroy=ci_local_cache_destroy, .name="local" };
// ci_methods
// file header.c line 43
const char *ci_methods[5l] = { "", "OPTIONS", "REQMOD", "", "RESPMOD" };
// ci_options_headers
// file header.c line 69
const char *ci_options_headers[14l] = { "Methods", "Service", "ISTag", "Encapsulated", "Opt-body-type", "Max-Connections", "Options-TTL", "Date", "Service-ID", "Allow", "Preview", "Transfer-Preview", "Transfer-Ignore", "Transfer-Complete" };
// ci_request_headers
// file header.c line 52
const char *ci_request_headers[7l] = { "Authorization", "Allow", "From", "Host", "Referer", "User-Agent", "Preview" };
// ci_responce_headers
// file header.c line 63
const char *ci_responce_headers[2l] = { "Server", "ISTag" };
// ci_uint64_ops
// file types_ops.c line 214
const struct ci_type_ops ci_uint64_ops;
// ci_uint64_ops
// file types_ops.c line 214
const struct ci_type_ops ci_uint64_ops = { .dup=uint64_dup, .free=uint64_free, .compare=uint64_cmp, .size=uint64_len,
    .equal=uint64_equal };
// common_modules
// file module.c line 54
static struct modules_list common_modules = { .modules=(void **)(void *)0, .modules_num=0, .list_size=0 };
// con_queue
// file mpmt_server.c line 76
struct connections_queue *con_queue;
// conf_tables_list_size
// file cfg_param.c line 202
signed int conf_tables_list_size = 0;
// conf_tables_num
// file cfg_param.c line 203
signed int conf_tables_num = 0;
// conf_variables
// file cfg_param.c line 141
static struct ci_conf_entry conf_variables[55l];
// default_logger
// file log.c line 38
struct logger_module *default_logger = (struct logger_module *)(void *)0;
// conf_variables
// file cfg_param.c line 141
static struct ci_conf_entry conf_variables[55l] = { { .name="ListenAddress", .data=(void *)&CI_CONF.ADDRESS, .action=intl_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name="PidFile", .data=(void *)&CI_CONF.PIDFILE, .action=intl_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name="CommandsSocket", .data=(void *)&CI_CONF.COMMANDS_SOCKET, .action=intl_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name="Timeout", .data=(void *)&TIMEOUT, .action=intl_cfg_set_int,
    .msg=(const char *)(void *)0 }, 
    { .name="KeepAlive", .data=(void *)0, .action=(signed int (*)(const char *, const char **, void *))(void *)0, .msg=(const char *)(void *)0 }, 
    { .name="MaxKeepAliveRequests", .data=(void *)&MAX_KEEPALIVE_REQUESTS, .action=intl_cfg_set_int,
    .msg=(const char *)(void *)0 }, 
    { .name="KeepAliveTimeout", .data=(void *)&KEEPALIVE_TIMEOUT, .action=intl_cfg_set_int,
    .msg=(const char *)(void *)0 }, 
    { .name="StartServers", .data=(void *)&CI_CONF.START_SERVERS, .action=intl_cfg_set_int,
    .msg=(const char *)(void *)0 }, 
    { .name="MaxServers", .data=(void *)&CI_CONF.MAX_SERVERS, .action=intl_cfg_set_int,
    .msg=(const char *)(void *)0 }, 
    { .name="MinSpareThreads", .data=(void *)&CI_CONF.MIN_SPARE_THREADS, .action=intl_cfg_set_int,
    .msg=(const char *)(void *)0 }, 
    { .name="MaxSpareThreads", .data=(void *)&CI_CONF.MAX_SPARE_THREADS, .action=intl_cfg_set_int,
    .msg=(const char *)(void *)0 }, 
    { .name="ThreadsPerChild", .data=(void *)&CI_CONF.THREADS_PER_CHILD, .action=intl_cfg_set_int,
    .msg=(const char *)(void *)0 }, 
    { .name="MaxRequestsPerChild", .data=(void *)&MAX_REQUESTS_PER_CHILD, .action=intl_cfg_set_int,
    .msg=(const char *)(void *)0 }, 
    { .name="MaxRequestsReallocateMem", .data=(void *)&MAX_REQUESTS_BEFORE_REALLOCATE_MEM, .action=intl_cfg_set_int,
    .msg=(const char *)(void *)0 }, 
    { .name="Port", .data=(void *)&CI_CONF.PORT, .action=intl_cfg_set_int,
    .msg=(const char *)(void *)0 }, 
    { .name="User", .data=(void *)&CI_CONF.RUN_USER, .action=intl_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name="Group", .data=(void *)&CI_CONF.RUN_GROUP, .action=intl_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name="ServerAdmin", .data=(void *)&CI_CONF.SERVER_ADMIN, .action=intl_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name="ServerName", .data=(void *)&CI_CONF.SERVER_NAME, .action=intl_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name="LoadMagicFile", .data=(void *)0, .action=cfg_load_magicfile,
    .msg=(const char *)(void *)0 }, 
    { .name="Logger", .data=(void *)&default_logger, .action=cfg_set_logger,
    .msg=(const char *)(void *)0 }, 
    { .name="ServerLog", .data=(void *)&SERVER_LOG_FILE, .action=intl_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name="AccessLog", .data=(void *)0, .action=cfg_set_accesslog, .msg=(const char *)(void *)0 }, 
    { .name="LogFormat", .data=(void *)0, .action=cfg_set_logformat, .msg=(const char *)(void *)0 }, 
    { .name="DebugLevel", .data=(void *)0, .action=cfg_set_debug_level, .msg=(const char *)(void *)0 }, 
    { .name="ServicesDir", .data=(void *)&CI_CONF.SERVICES_DIR, .action=intl_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name="ModulesDir", .data=(void *)&CI_CONF.MODULES_DIR, .action=intl_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name="Service", .data=(void *)0, .action=cfg_load_service, .msg=(const char *)(void *)0 }, 
    { .name="ServiceAlias", .data=(void *)0, .action=cfg_service_alias,
    .msg=(const char *)(void *)0 }, 
    { .name="Module", .data=(void *)0, .action=cfg_load_module, .msg=(const char *)(void *)0 }, 
    { .name="TmpDir", .data=(void *)0, .action=cfg_set_tmp_dir, .msg=(const char *)(void *)0 }, 
    { .name="MaxMemObject", .data=(void *)0, .action=cfg_set_body_maxmem,
    .msg=(const char *)(void *)0 }, 
    { .name="AclControllers", .data=(void *)0, .action=cfg_set_acl_controllers,
    .msg=(const char *)(void *)0 }, 
    { .name="acl", .data=(void *)0, .action=cfg_acl_add, .msg=(const char *)(void *)0 }, 
    { .name="icap_access", .data=(void *)0, .action=cfg_default_acl_access, .msg=(const char *)(void *)0 }, 
    { .name="client_access", .data=(void *)0, .action=cfg_default_acl_access,
    .msg=(const char *)(void *)0 }, 
    { .name="AuthMethod", .data=(void *)0, .action=cfg_set_auth_method, .msg=(const char *)(void *)0 }, 
    { .name="Include", .data=(void *)0, .action=cfg_include_config_file, .msg=(const char *)(void *)0 }, 
    { .name="RemoteProxyUserHeader", .data=(void *)&REMOTE_PROXY_USER_HEADER, .action=intl_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name="RemoteProxyUserHeaderEncoded", .data=(void *)&REMOTE_PROXY_USER_HEADER_ENCODED, .action=intl_cfg_onoff,
    .msg=(const char *)(void *)0 }, 
    { .name="RemoteProxyUsers", .data=(void *)&ALLOW_REMOTE_PROXY_USERS, .action=intl_cfg_onoff,
    .msg=(const char *)(void *)0 }, 
    { .name="TemplateDir", .data=(void *)&TEMPLATE_DIR, .action=intl_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name="TemplateDefaultLanguage", .data=(void *)&TEMPLATE_DEF_LANG, .action=intl_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name="TemplateReloadTime", .data=(void *)&TEMPLATE_RELOAD_TIME, .action=intl_cfg_set_int,
    .msg=(const char *)(void *)0 }, 
    { .name="TemplateCacheSize", .data=(void *)&TEMPLATE_CACHE_SIZE, .action=intl_cfg_set_int,
    .msg=(const char *)(void *)0 }, 
    { .name="TemplateMemBufSize", .data=(void *)&TEMPLATE_MEMBUF_SIZE, .action=intl_cfg_set_int,
    .msg=(const char *)(void *)0 }, 
    { .name="GroupSourceByGroup", .data=(void *)0, .action=cfg_group_source_by_group,
    .msg=(const char *)(void *)0 }, 
    { .name="GroupSourceByUser", .data=(void *)0, .action=cfg_group_source_by_user,
    .msg=(const char *)(void *)0 }, 
    { .name="InterProcessSharedMemScheme", .data=(void *)0, .action=cfg_shared_mem_scheme,
    .msg=(const char *)(void *)0 }, 
    { .name="InterProcessLockingScheme", .data=(void *)0, .action=cfg_proc_lock_scheme,
    .msg=(const char *)(void *)0 }, 
    { .name="DefaultService", .data=(void *)&DEFAULT_SERVICE, .action=intl_cfg_set_str,
    .msg=(const char *)(void *)0 }, 
    { .name="Pipelining", .data=(void *)&PIPELINING, .action=intl_cfg_onoff,
    .msg=(const char *)(void *)0 }, 
    { .name="SupportBuggyClients", .data=(void *)&CHECK_FOR_BUGGY_CLIENT, .action=intl_cfg_onoff,
    .msg=(const char *)(void *)0 }, 
    { .name="Allow204As200okZeroEncaps", .data=(void *)&ALLOW204_AS_200OK_ZERO_ENCAPS, .action=intl_cfg_enable,
    .msg=(const char *)(void *)0 }, 
    { .name=(const char *)(void *)0, .data=(void *)0, .action=(signed int (*)(const char *, const char **, void *))(void *)0,
    .msg=(const char *)(void *)0 } };
// counters_mtx
// file mpmt_server.c line 71
union anonymous$3 counters_mtx;
// days
// file os/unix/utilfunc.c line 26
static const char *days[7l] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
// default_access_controllers
// file access.c line 35
struct access_control_module *default_access_controllers[2l];
// default_acl
// file default_acl.c line 57
struct access_control_module default_acl;
// default_acl
// file default_acl.c line 57
struct access_control_module default_acl = { .name="default_acl", .init_access_controller=default_acl_init, .post_init_access_controller=default_acl_post_init,
    .release_access_controller=default_acl_release,
    .client_access=default_acl_client_match,
    .request_access=default_acl_request_match,
    .conf_table=acl_conf_variables };
// default_access_controllers
// file access.c line 35
struct access_control_module *default_access_controllers[2l] = { &default_acl, (struct access_control_module *)(void *)0 };
// default_allocator
// file mem.c line 33
struct ci_mem_allocator *default_allocator = (struct ci_mem_allocator *)(void *)0;
// default_mutex_scheme
// file os/unix/proc_mutex.c line 245
const struct ci_proc_mutex_scheme *default_mutex_scheme;
// file_mutex_scheme
// file os/unix/proc_mutex.c line 233
static struct ci_proc_mutex_scheme file_mutex_scheme;
// file_mutex_scheme
// file os/unix/proc_mutex.c line 233
static struct ci_proc_mutex_scheme file_mutex_scheme = { .proc_mutex_init=file_proc_mutex_init, .proc_mutex_destroy=file_proc_mutex_destroy,
    .proc_mutex_lock=file_proc_mutex_lock,
    .proc_mutex_unlock=file_proc_mutex_unlock,
    .proc_mutex_print_info=file_proc_mutex_print_info,
    .name="file" };
// default_mutex_scheme
// file os/unix/proc_mutex.c line 245
const struct ci_proc_mutex_scheme *default_mutex_scheme = &file_mutex_scheme;
// default_scheme
// file os/unix/shared_mem.c line 218
const struct ci_shared_mem_scheme *default_scheme;
// posix_scheme
// file os/unix/shared_mem.c line 206
const struct ci_shared_mem_scheme posix_scheme;
// posix_scheme
// file os/unix/shared_mem.c line 206
const struct ci_shared_mem_scheme posix_scheme = { .shared_mem_create=posix_shared_mem_create, .shared_mem_attach=posix_shared_mem_attach,
    .shared_mem_detach=posix_shared_mem_detach,
    .shared_mem_destroy=posix_shared_mem_destroy,
    .shared_mem_print_info=posix_shared_mem_print_info,
    .name="posix" };
// default_scheme
// file os/unix/shared_mem.c line 218
const struct ci_shared_mem_scheme *default_scheme = &posix_scheme;
// default_service_handler
// file module.c line 48
struct service_handler_module *default_service_handler;
// default_values
// file cfg_param.c line 1004
struct cfg_default_value *default_values = (struct cfg_default_value *)(void *)0;
// dlib_list
// file dlib.c line 32
struct dlib_entry *dlib_list = (struct dlib_entry *)(void *)0;
// eof_str
// file request.c line 738
const char *eof_str = "0\r\n\r\n";
// eof_str$link1
// file request_common.c line 1198
static const char *eof_str$link1 = "0\r\n\r\n";
// eol_str
// file request.c line 737
const char *eol_str = "\r\n";
// extra_conf_tables
// file cfg_param.c line 201
static struct sub_table *extra_conf_tables = (struct sub_table *)(void *)0;
// file_logger
// file log.c line 202
struct logger_module file_logger;
// file_logger
// file log.c line 202
struct logger_module file_logger = { .name="file_logger", .init_logger=(signed int (*)(struct ci_server_conf *))(void *)0, .log_open=file_log_open,
    .log_close=file_log_close, .log_access=file_log_access,
    .log_server=file_log_server, .conf_table=(struct ci_conf_entry *)(void *)0 };
// file_table_type
// file lookup_file_table.c line 34
struct ci_lookup_table_type file_table_type;
// file_table_type
// file lookup_file_table.c line 34
struct ci_lookup_table_type file_table_type = { .open=file_table_open, .close=file_table_close, .search=file_table_search,
    .release_result=file_table_release_result, .get_row=(const void * (*)(struct ci_lookup_table *, const void *, const char **, void ***))(void *)0,
    .type="file" };
// free_server_cond
// file mpmt_server.c line 70
union anonymous$9 free_server_cond;
// hash_table_type
// file lookup_file_table.c line 329
struct ci_lookup_table_type hash_table_type;
// hash_table_type
// file lookup_file_table.c line 329
struct ci_lookup_table_type hash_table_type = { .open=hash_table_open, .close=hash_table_close, .search=hash_table_search,
    .release_result=hash_table_release_result, .get_row=(const void * (*)(struct ci_lookup_table *, const void *, const char **, void ***))(void *)0,
    .type="hash" };
// html_tmpl
// file info.c line 269
struct stats_tmpl html_tmpl = { .gen_template="<H1>Running Servers Statistics</H1>\n<TABLE><TR><TH>Children number:</TH><TD> %d<TD><TR><TH>Free Servers:</TH><TD> %d<TD><TR><TH>Used Servers:</TH><TD> %d<TD><TR><TH>Started Processes :</TH><TD> %u<TD><TR><TH>Closed Processes: </TH><TD>%u<TD><TR><TH>Crashed Processes: </TH><TD>%u<TD><TR><TH>Closing Processes: </TH><TD>%u<TD></TABLE>\n", .statsHeader="<H1>%s Statistics</H1>\n<TABLE>",
    .statsEnd="</TABLE>",
    .childsHeader="<TABLE> <TR><TH>Child pids:</TH>", .childs_tmpl="<TD> %d</TD>",
    .childsEnd="</TR></TABLE>\n", .closingChildsHeader="<TABLE> <TR><TH>Closing children pids:</TH>",
    .d1TableHeader_tmpl="<TABLE> <TR><TH>%s</TH></TR>\n",
    .d1TableEntry_tmpl="<TR><TD>%s</TD></TR>\n",
    .d1TableEnd_tmpl="</TABLE>\n",
    .statline_tmpl_int="<TR><TH>%s:</TH><TD>  %lld</TD>\n", .statline_tmpl_kbs="<TR><TH>%s:</TH><TD>  %lld Kbs %d bytes</TD>\n" };
// info_service
// file info.c line 41
struct ci_service_module info_service;
// info_service
// file info.c line 41
struct ci_service_module info_service = { .mod_name="info", .mod_short_descr="C-icap run-time information", .mod_type=0x02,
    .mod_init_service=info_init_service, .mod_post_init_service=(signed int (*)(struct ci_service_xdata *, struct ci_server_conf *))(void *)0,
    .mod_close_service=info_close_service,
    .mod_init_request_data=info_init_request_data,
    .mod_release_request_data=info_release_request_data,
    .mod_check_preview_handler=info_check_preview_handler,
    .mod_end_of_data_handler=info_end_of_data_handler,
    .mod_service_io=info_io,
    .mod_conf_table=(struct ci_conf_entry *)(void *)0, .mod_data=(void *)0 };
// init_child_mutexes_scheduled
// file os/unix/threads.c line 44
static signed int init_child_mutexes_scheduled = 0;
// last
// file os/unix/threads.c line 42
static struct mutex_itm *last = (struct mutex_itm *)(void *)0;
// listener_running
// file mpmt_server.c line 68
signed int listener_running = 0;
// listener_thread_id
// file mpmt_server.c line 67
unsigned long int listener_thread_id = (unsigned long int)-1;
// loggers
// file module.c line 50
static struct modules_list loggers = { .modules=(void **)(void *)0, .modules_num=0, .list_size=0 };
// long_buffer_sizes
// file mem.c line 158
signed int long_buffer_sizes[16l] = { 2048, 4096, 8192, 8192, 16384, 16384, 16384, 16384, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768 };
// long_buffers
// file mem.c line 110
struct ci_mem_allocator *long_buffers[16l];
// lookup_tables_types
// file lookup_table.c line 30
struct ci_lookup_table_type *lookup_tables_types[128l];
// lookup_tables_types_num
// file lookup_table.c line 31
signed int lookup_tables_types_num = 0;
// mmap_scheme
// file os/unix/shared_mem.c line 142
const struct ci_shared_mem_scheme mmap_scheme;
// mmap_scheme
// file os/unix/shared_mem.c line 142
const struct ci_shared_mem_scheme mmap_scheme = { .shared_mem_create=mmap_shared_mem_create, .shared_mem_attach=mmap_shared_mem_attach,
    .shared_mem_detach=mmap_shared_mem_detach,
    .shared_mem_destroy=mmap_shared_mem_destroy,
    .shared_mem_print_info=mmap_shared_mem_print_info,
    .name="mmap" };
// modules_lists_table
// file module.c line 57
static struct modules_list *modules_lists_table[7l];
// service_handlers
// file module.c line 47
static struct modules_list service_handlers;
// modules_lists_table
// file module.c line 57
static struct modules_list *modules_lists_table[7l] = { (struct modules_list *)(void *)0, &service_handlers, &loggers, &access_controllers, &auth_methods, &authenticators, &common_modules };
// months
// file os/unix/utilfunc.c line 36
static const char *months[12l] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
// mutexes
// file os/unix/threads.c line 41
static struct mutex_itm *mutexes = (struct mutex_itm *)(void *)0;
// mutexes_lock
// file os/unix/threads.c line 40
union anonymous$3 mutexes_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// object_pools
// file mem.c line 301
struct ci_mem_allocator **object_pools = (struct ci_mem_allocator **)(void *)0;
// object_pools_size
// file mem.c line 302
signed int object_pools_size = 0;
// object_pools_used
// file mem.c line 303
signed int object_pools_used = 0;
// old_childs_queue
// file mpmt_server.c line 74
struct childs_queue *old_childs_queue = (struct childs_queue *)(void *)0;
// old_requests
// file proc_threads_queues.c line 29
static signed int old_requests = 0;
// op_lock
// file os/unix/proc_mutex.c line 37
static struct sembuf op_lock[2l] = { { .sem_num=(unsigned short int)0, .sem_op=(signed short int)0, .sem_flg=(signed short int)0 }, 
    { .sem_num=(unsigned short int)0, .sem_op=(signed short int)1, .sem_flg=(signed short int)0x1000 } };
// op_unlock
// file os/unix/proc_mutex.c line 42
static struct sembuf op_unlock[1l] = { { .sem_num=(unsigned short int)0, .sem_op=(signed short int)-1, .sem_flg=(signed short int)(04000 | 0x1000) } };
// options
// file cfg_param.c line 868
static struct ci_options_entry options[5l];
// options
// file cfg_param.c line 868
static struct ci_options_entry options[5l] = { { .name="-f", .parameter="filename", .data=(void *)&CI_CONF.cfg_file, .action=ci_cfg_set_str,
    .msg="Specify the configuration file" }, 
    { .name="-N", .parameter=(const char *)(void *)0, .data=(void *)&DAEMON_MODE,
    .action=ci_cfg_disable, .msg="Do not run as daemon" }, 
    { .name="-d", .parameter="level", .data=(void *)0, .action=cfg_set_debug_level_cmd,
    .msg="Specify the debug level" }, 
    { .name="-D", .parameter=(const char *)(void *)0, .data=(void *)0,
    .action=cfg_set_debug_stdout, .msg="Print debug info to stdout" }, 
    { .name=(const char *)(void *)0, .parameter=(const char *)(void *)0, .data=(void *)0,
    .action=(signed int (*)(const char *, const char **, void *))(void *)0, .msg=((const char *)NULL) } };
// pcre_free
// file /usr/include/pcre.h line 490
extern void (*pcre_free)(void *);
// posix_mutex_scheme
// file os/unix/proc_mutex.c line 170
static struct ci_proc_mutex_scheme posix_mutex_scheme;
// posix_mutex_scheme
// file os/unix/proc_mutex.c line 170
static struct ci_proc_mutex_scheme posix_mutex_scheme = { .proc_mutex_init=posix_proc_mutex_init, .proc_mutex_destroy=posix_proc_mutex_destroy,
    .proc_mutex_lock=posix_proc_mutex_lock,
    .proc_mutex_unlock=posix_proc_mutex_unlock,
    .proc_mutex_print_info=posix_proc_mutex_print_info,
    .name="posix" };
// predefined_groups
// file filetype.c line 51
struct ci_data_group predefined_groups[3l] = { { .name={ 'T', 'E', 'X', 'T', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'A', 'l', 'l', ' ', 't', 'e', 'x', 't', 's', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .name={ 'D', 'A', 'T', 'A', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'U', 'n', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'd', 'a', 't', 'a', ' ', 't', 'y', 'p', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .name={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } };
// predefined_types
// file filetype.c line 41
struct ci_data_type predefined_types[7l] = { { .name={ 'A', 'S', 'C', 'I', 'I', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'A', 'S', 'C', 'I', 'I', ' ', 't', 'e', 'x', 't', ' ', 'f', 'i', 'l', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .name={ 'I', 'S', 'O', '-', '8', '8', '5', '9', 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'I', 'S', 'O', '-', '8', '8', '5', '9', ' ', 't', 'e', 'x', 't', ' ', 'f', 'i', 'l', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .name={ 'E', 'X', 'T', '-', 'A', 'S', 'C', 'I', 'I', 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'E', 'x', 't', 'e', 'n', 'd', 'e', 'd', ' ', 'A', 'S', 'C', 'I', 'I', ' ', '(', 'M', 'a', 'c', ',', 'I', 'B', 'M', ' ', 'P', 'C', ' ', 'e', 't', 'c', '.', ')', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .name={ 'U', 'T', 'F', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'U', 'n', 'i', 'c', 'o', 'd', 'e', ' ', 't', 'e', 'x', 't', ' ', 'f', 'i', 'l', 'e', ' ', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .name={ 'H', 'T', 'M', 'L', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'H', 'T', 'M', 'L', ' ', 't', 'e', 'x', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .name={ 'B', 'I', 'N', 'A', 'R', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'd', 'a', 't', 'a', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }, 
    { .name={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } };
// regex_table_type
// file lookup_file_table.c line 409
struct ci_lookup_table_type regex_table_type;
// regex_table_type
// file lookup_file_table.c line 409
struct ci_lookup_table_type regex_table_type = { .open=regex_table_open, .close=regex_table_close, .search=regex_table_search,
    .release_result=regex_table_release_result, .get_row=(const void * (*)(struct ci_lookup_table *, const void *, const char **, void ***))(void *)0,
    .type="regex" };
// server_log
// file log.c line 213
struct _IO_FILE *server_log = (struct _IO_FILE *)(void *)0;
// service_aliases
// file service.c line 45
static struct service_alias *service_aliases = (struct service_alias *)(void *)0;
// service_aliases_num
// file service.c line 47
static signed int service_aliases_num = 0;
// service_aliases_size
// file service.c line 46
static signed int service_aliases_size;
// service_extra_data_list
// file service.c line 40
static struct ci_service_xdata *service_extra_data_list = (struct ci_service_xdata *)(void *)0;
// service_list
// file service.c line 39
static struct ci_service_module **service_list = (struct ci_service_module **)(void *)0;
// service_list_size
// file service.c line 41
static signed int service_list_size;
// services_global_conf_table
// file service.c line 62
static struct ci_conf_entry services_global_conf_table[8l];
// services_global_conf_table
// file service.c line 62
static struct ci_conf_entry services_global_conf_table[8l] = { { .name="TransferPreview", .data=(void *)0, .action=cfg_srv_transfer_preview,
    .msg=(const char *)(void *)0 }, 
    { .name="TransferIgnore", .data=(void *)0, .action=cfg_srv_transfer_ignore,
    .msg=(const char *)(void *)0 }, 
    { .name="TransferComplete", .data=(void *)0, .action=cfg_srv_transfer_complete,
    .msg=(const char *)(void *)0 }, 
    { .name="PreviewSize", .data=(void *)0, .action=cfg_srv_preview_size, .msg=(const char *)(void *)0 }, 
    { .name="MaxConnections", .data=(void *)0, .action=cfg_srv_max_connections,
    .msg=(const char *)(void *)0 }, 
    { .name="OptionsTTL", .data=(void *)0, .action=cfg_srv_options_ttl, .msg=(const char *)(void *)0 }, 
    { .name="Allow206", .data=(void *)0, .action=cfg_srv_allow206, .msg=(const char *)(void *)0 }, 
    { .name=(const char *)(void *)0, .data=(void *)0, .action=(signed int (*)(const char *, const char **, void *))(void *)0,
    .msg=(const char *)(void *)0 } };
// services_num
// file service.c line 42
static signed int services_num = 0;
// short_buffer_sizes
// file mem.c line 150
signed int short_buffer_sizes[16l] = { 64, 128, 256, 256, 512, 512, 512, 512, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };
// short_buffers
// file mem.c line 109
struct ci_mem_allocator *short_buffers[16l];
// specs_list
// file acl.c line 774
static struct ci_acl_spec *specs_list;
// systemlog_rwlock
// file log.c line 199
static union anonymous$1 systemlog_rwlock;
// sysv_mutex_scheme
// file os/unix/proc_mutex.c line 104
static struct ci_proc_mutex_scheme sysv_mutex_scheme;
// sysv_mutex_scheme
// file os/unix/proc_mutex.c line 104
static struct ci_proc_mutex_scheme sysv_mutex_scheme = { .proc_mutex_init=sysv_proc_mutex_init, .proc_mutex_destroy=sysv_proc_mutex_destroy,
    .proc_mutex_lock=sysv_proc_mutex_lock,
    .proc_mutex_unlock=sysv_proc_mutex_unlock,
    .proc_mutex_print_info=sysv_proc_mutex_print_info,
    .name="sysv" };
// sysv_scheme
// file os/unix/shared_mem.c line 89
const struct ci_shared_mem_scheme sysv_scheme;
// sysv_scheme
// file os/unix/shared_mem.c line 89
const struct ci_shared_mem_scheme sysv_scheme = { .shared_mem_create=sysv_shared_mem_create, .shared_mem_attach=sysv_shared_mem_attach,
    .shared_mem_detach=sysv_shared_mem_detach,
    .shared_mem_destroy=sysv_shared_mem_destroy,
    .shared_mem_print_info=sysv_shared_mem_print_info,
    .name="sysv" };
// templates
// file txtTemplate.c line 60
struct anonymous$7 *templates = (struct anonymous$7 *)(void *)0;
// templates_mutex
// file txtTemplate.c line 66
static union anonymous$3 templates_mutex;
// text_chars
// file filetype.c line 390
static const char text_chars[256l] = { (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)1, (const char)1, (const char)1, (const char)1, (const char)0, (const char)1, (const char)1, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)1, (const char)0, (const char)0, (const char)0, (const char)0, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)0, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)1, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2 };
// threads_list
// file mpmt_server.c line 66
struct server_decl **threads_list = (struct server_decl **)(void *)0;
// threads_list_mtx
// file mpmt_server.c line 65
union anonymous$3 threads_list_mtx;
// txtTemplateInited
// file txtTemplate.c line 61
signed int txtTemplateInited = 0;
// txt_tmpl
// file info.c line 250
struct stats_tmpl txt_tmpl = { .gen_template="Running Servers Statistics\n===========================\nChildren number: %d\nFree Servers: %d\nUsed Servers: %d\nStarted Processes: %u\nClosed Processes: %u\nCrashed Processes: %u\nClosing Processes: %u\n\n", .statsHeader="\n%s Statistics\n==================\n",
    .statsEnd="",
    .childsHeader="Child pids:", .childs_tmpl=" %d",
    .childsEnd="\n", .closingChildsHeader="Closing children pids:",
    .d1TableHeader_tmpl="%s\n",
    .d1TableEntry_tmpl="\t %s\n", .d1TableEnd_tmpl="\n\n",
    .statline_tmpl_int="%s : %lld\n", .statline_tmpl_kbs="%s : %lld Kbs %d bytes\n" };
// types_list
// file acl.c line 773
static struct ci_acl_type_list types_list;
// used_access_controllers
// file access.c line 41
struct access_control_module **used_access_controllers;
// used_access_controllers
// file access.c line 41
struct access_control_module **used_access_controllers = default_access_controllers;
// users_db
// file http_auth.c line 459
struct ci_lookup_table *users_db = (struct ci_lookup_table *)(void *)0;
// utf_boundaries
// file filetype.c line 436
static unsigned int utf_boundaries[7l] = { (unsigned int)0x0, (unsigned int)0x0, (unsigned int)0x07F, (unsigned int)0x7FF, (unsigned int)0xFFFF, (unsigned int)0x1FFFFF, (unsigned int)0x3FFFFFF };

// MD5Transform
// file md5.c line 168
static void MD5Transform(unsigned int *buf, unsigned int *in)
{
  unsigned int a;
  unsigned int b;
  unsigned int c;
  unsigned int d;
  a = buf[(signed long int)0];
  b = buf[(signed long int)1];
  c = buf[(signed long int)2];
  d = buf[(signed long int)3];
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)0] + 0xd76aa478;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)1] + 0xe8c7b756;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)2] + (unsigned int)0x242070db;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)3] + 0xc1bdceee;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)4] + 0xf57c0faf;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)5] + (unsigned int)0x4787c62a;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)6] + 0xa8304613;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)7] + 0xfd469501;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)8] + (unsigned int)0x698098d8;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)9] + 0x8b44f7af;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)10] + 0xffff5bb1;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)11] + 0x895cd7be;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)12] + (unsigned int)0x6b901122;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)13] + 0xfd987193;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)14] + 0xa679438e;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)15] + (unsigned int)0x49b40821;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)1] + 0xf61e2562;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)6] + 0xc040b340;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)11] + (unsigned int)0x265e5a51;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)0] + 0xe9b6c7aa;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)5] + 0xd62f105d;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)10] + (unsigned int)0x02441453;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)15] + 0xd8a1e681;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)4] + 0xe7d3fbc8;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)9] + (unsigned int)0x21e1cde6;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)14] + 0xc33707d6;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)3] + 0xf4d50d87;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)8] + (unsigned int)0x455a14ed;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)13] + 0xa9e3e905;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)2] + 0xfcefa3f8;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)7] + (unsigned int)0x676f02d9;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)12] + 0x8d2a4c8a;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)5] + 0xfffa3942;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)8] + 0x8771f681;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)11] + (unsigned int)0x6d9d6122;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)14] + 0xfde5380c;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)1] + 0xa4beea44;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)4] + (unsigned int)0x4bdecfa9;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)7] + 0xf6bb4b60;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)10] + 0xbebfbc70;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)13] + (unsigned int)0x289b7ec6;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)0] + 0xeaa127fa;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)3] + 0xd4ef3085;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)6] + (unsigned int)0x04881d05;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)9] + 0xd9d4d039;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)12] + 0xe6db99e5;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)15] + (unsigned int)0x1fa27cf8;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)2] + 0xc4ac5665;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)0] + 0xf4292244;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)7] + (unsigned int)0x432aff97;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)14] + 0xab9423a7;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)5] + 0xfc93a039;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)12] + (unsigned int)0x655b59c3;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)3] + 0x8f0ccc92;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)10] + 0xffeff47d;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)1] + 0x85845dd1;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)8] + (unsigned int)0x6fa87e4f;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)15] + 0xfe2ce6e0;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)6] + 0xa3014314;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)13] + (unsigned int)0x4e0811a1;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)4] + 0xf7537e82;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)11] + 0xbd3af235;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)2] + (unsigned int)0x2ad7d2bb;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)9] + 0xeb86d391;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  buf[(signed long int)0] = buf[(signed long int)0] + a;
  buf[(signed long int)1] = buf[(signed long int)1] + b;
  buf[(signed long int)2] = buf[(signed long int)2] + c;
  buf[(signed long int)3] = buf[(signed long int)3] + d;
}

// _os_free
// file request_common.c line 35
static void _os_free(void *ptr)
{
  free(ptr);
}

// _os_malloc
// file request_common.c line 30
static void * _os_malloc(signed int size)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)size);
  return return_value_malloc$1;
}

// access_check_client
// file include/access.h line 55
signed int access_check_client(struct ci_request *req)
{
  signed int i = 0;
  signed int res;
  if(used_access_controllers == ((struct access_control_module **)NULL))
    return 1;

  else
  {
    i = 0;
    for( ; !(used_access_controllers[(signed long int)i] == ((struct access_control_module *)NULL)); i = i + 1)
      if(!(used_access_controllers[(signed long int)i]->client_access == ((signed int (*)(struct ci_request *))NULL)))
      {
        res=used_access_controllers[(signed long int)i]->client_access(req);
        if(!(res == 0))
          return res;

      }

    return 1;
  }
}

// access_check_request
// file include/access.h line 56
signed int access_check_request(struct ci_request *req)
{
  signed int res;
  if(used_access_controllers == ((struct access_control_module **)NULL))
    return 1;

  else
  {
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Going to check request for access control restrictions\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Going to check request for access control restrictions\n");

    }

    res=check_request$link1(req);
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Access control: %s\n", res == 1 ? "ALLOW" : (res == -1 ? "DENY" : "UNKNOWN"));

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Access control: %s\n", res == 1 ? "ALLOW" : (res == -1 ? "DENY" : "UNKNOWN"));

    }

    return res;
  }
}

// access_reset
// file access.c line 43
signed int access_reset()
{
  used_access_controllers = default_access_controllers;
  return 1;
}

// acl_cmp_uint64_dup
// file acl.c line 182
void * acl_cmp_uint64_dup(const char *str, struct ci_mem_allocator *allocator)
{
  void *return_value;
  return_value=ci_uint64_ops.dup(str, allocator);
  return return_value;
}

// acl_cmp_uint64_equal
// file acl.c line 187
signed int acl_cmp_uint64_equal(const void *key1, const void *key2)
{
  unsigned long int k1 = *((unsigned long int *)key1);
  struct acl_cmp_uint64_data *data = (struct acl_cmp_uint64_data *)key2;
  if(CI_DEBUG_LEVEL >= 8)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
    {
      signed int tmp_if_expr$1;
      if(data->operator == 1)
        tmp_if_expr$1 = 62;

      else
        tmp_if_expr$1 = data->operator == 2 ? 60 : 61;
      __log_error((void *)0, "Acl content length check %llu %c %llu\n", (signed long long int)data->data, tmp_if_expr$1, (signed long long int)k1);
    }

    if(!(CI_DEBUG_STDOUT == 0))
    {
      signed int tmp_if_expr$2;
      if(data->operator == 1)
        tmp_if_expr$2 = 62;

      else
        tmp_if_expr$2 = data->operator == 2 ? 60 : 61;
      printf("Acl content length check %llu %c %llu\n", (signed long long int)data->data, tmp_if_expr$2, (signed long long int)k1);
    }

  }

  if(data->operator == 1)
    return (signed int)(data->data > k1);

  else
    if(data->operator == 2)
      return (signed int)(data->data < k1);

    else
      return (signed int)(k1 == data->data);
}

// acl_cmp_uint64_free
// file acl.c line 202
void acl_cmp_uint64_free(void *key, struct ci_mem_allocator *allocator)
{
  ci_uint64_ops.free(key, allocator);
}

// acl_load_defaults
// file acl.c line 776
static signed int acl_load_defaults()
{
  ci_acl_typelist_add(&types_list, &acl_tcp_port);
  ci_acl_typelist_add(&types_list, &acl_service);
  ci_acl_typelist_add(&types_list, &acl_req_type);
  ci_acl_typelist_add(&types_list, &acl_user);
  ci_acl_typelist_add(&types_list, &acl_tcp_src);
  ci_acl_typelist_add(&types_list, &acl_tcp_srvip);
  ci_acl_typelist_add(&types_list, &acl_icap_header);
  ci_acl_typelist_add(&types_list, &acl_icap_resp_header);
  ci_acl_typelist_add(&types_list, &acl_http_req_header);
  ci_acl_typelist_add(&types_list, &acl_http_resp_header);
  ci_acl_typelist_add(&types_list, &acl_data_type);
  ci_acl_typelist_add(&types_list, &acl_content_length);
  ci_acl_typelist_add(&types_list, &acl_time);
  ci_acl_typelist_add(&types_list, &acl_tcp_xclientip);
  return 1;
}

// acl_time_dup
// file acl.c line 270
void * acl_time_dup(const char *str, struct ci_mem_allocator *allocator)
{
  /* tag-#anon#lST[l*{cS8}$cS8$'day'|S32'id'|U32'$pad0'] */
struct anonymous$6
{
  // day
  const char *day;
  // id
  signed int id;
};

/* */
  ;
  struct anonymous$6 acl_time_dup$$1$$days[15l] = { { .day="Sunday", .id=0 }, { .day="Monday", .id=1 }, { .day="Tuesday", .id=2 }, { .day="Wednesday", .id=3 }, { .day="Thursday", .id=4 }, { .day="Friday", .id=5 }, { .day="Saturday", .id=6 }, { .day="S", .id=0 }, { .day="M", .id=1 }, { .day="T", .id=2 }, { .day="W", .id=3 }, { .day="H", .id=4 }, { .day="F", .id=5 }, { .day="A", .id=6 }, { .day=(const char *)(void *)0, .id=-1 } };
  signed int h1;
  signed int m1;
  signed int h2;
  signed int m2;
  signed int i;
  char *s;
  char *e;
  const char *error;
  char buf[1024l];
  struct acl_time_data *tmd;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(struct acl_time_data) /*12ul*/ );
  tmd = (struct acl_time_data *)return_value;
  tmd->days = (unsigned int)0;
  strncpy(buf, str, sizeof(char [1024l]) /*1024ul*/ );
  buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
  s = buf;
  const unsigned short int **return_value___ctype_b_loc$4;
  return_value___ctype_b_loc$4=__ctype_b_loc();
  if((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*s]) == 0)
  {
    if((signed int)*s == 44)
      s = s + 1l;

    i = 0;
    if(!(acl_time_dup$$1$$days[(signed long int)i].day == ((const char *)NULL)))
    {
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(acl_time_dup$$1$$days[(signed long int)i].day);
      signed int return_value_strncasecmp$2;
      return_value_strncasecmp$2=strncasecmp(s, acl_time_dup$$1$$days[(signed long int)i].day, return_value_strlen$1);
      if(return_value_strncasecmp$2 == 0)
        tmd->days = tmd->days | (unsigned int)(1 << acl_time_dup$$1$$days[(signed long int)i].id);

      else
        i = i + 1;
    }

    if(acl_time_dup$$1$$days[(signed long int)i].day == ((const char *)NULL))
      error = s;

    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(acl_time_dup$$1$$days[(signed long int)i].day);
    s = s + (signed long int)return_value_strlen$3;
    if(!((signed int)*s == 47))
      error = s;

    if(!(*s == 0))
      s = s + 1l;

  }

  const unsigned short int **return_value___ctype_b_loc$5;
  return_value___ctype_b_loc$5=__ctype_b_loc();
  signed long int return_value_strtol$6;
  const unsigned short int **return_value___ctype_b_loc$7;
  signed long int return_value_strtol$9;
  const unsigned short int **return_value___ctype_b_loc$10;
  signed long int return_value_strtol$12;
  const unsigned short int **return_value___ctype_b_loc$13;
  signed long int return_value_strtol$15;
  if((2048 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)*s]) == 0)
    error = s;

  else
  {
    return_value_strtol$6=strtol(s, &e, 10);
    h1 = (signed int)return_value_strtol$6;
    if(h1 >= 25 || !(h1 >= 0))
      error = s;

    else
    {
      _Bool tmp_if_expr$8;
      if(!((signed int)*e == 58))
        tmp_if_expr$8 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc$7=__ctype_b_loc();
        tmp_if_expr$8 = !(((signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)e[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$8)
        error = e;

      else
      {
        s = e + (signed long int)1;
        return_value_strtol$9=strtol(s, &e, 10);
        m1 = (signed int)return_value_strtol$9;
        if(m1 >= 60 || !(m1 >= 0))
          error = s;

        else
        {
          _Bool tmp_if_expr$11;
          if(!((signed int)*e == 45))
            tmp_if_expr$11 = (_Bool)1;

          else
          {
            return_value___ctype_b_loc$10=__ctype_b_loc();
            tmp_if_expr$11 = !(((signed int)(*return_value___ctype_b_loc$10)[(signed long int)(signed int)e[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$11)
            error = e;

          else
          {
            s = e + (signed long int)1;
            return_value_strtol$12=strtol(s, &e, 10);
            h2 = (signed int)return_value_strtol$12;
            if(h2 >= 25 || !(h2 >= 0))
              error = s;

            else
            {
              _Bool tmp_if_expr$14;
              if(!((signed int)*e == 58))
                tmp_if_expr$14 = (_Bool)1;

              else
              {
                return_value___ctype_b_loc$13=__ctype_b_loc();
                tmp_if_expr$14 = !(((signed int)(*return_value___ctype_b_loc$13)[(signed long int)(signed int)e[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$14)
                error = e;

              else
              {
                s = e + (signed long int)1;
                return_value_strtol$15=strtol(s, &e, 10);
                m2 = (signed int)return_value_strtol$15;
                if(m2 >= 60 || !(m2 >= 0))
                  error = s;

                else
                {
                  tmd->start_time = (unsigned int)(h1 * 60 + m1);
                  tmd->end_time = (unsigned int)(h2 * 60 + m2);
                  if(tmd->end_time >= tmd->start_time)
                  {
                    if(CI_DEBUG_LEVEL >= 5)
                    {
                      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                        __log_error((void *)0, "Acl time, adding days: %x,  start time %d, end time: %d!\n", tmd->days, tmd->start_time, tmd->end_time);

                      if(!(CI_DEBUG_STDOUT == 0))
                        printf("Acl time, adding days: %x,  start time %d, end time: %d!\n", tmd->days, tmd->start_time, tmd->end_time);

                    }

                    return (void *)tmd;
                  }

                  if(CI_DEBUG_LEVEL >= 1)
                  {
                    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                      __log_error((void *)0, "Acl '%s': end time is smaller than the start time!\n", str);

                    if(!(CI_DEBUG_STDOUT == 0))
                      printf("Acl '%s': end time is smaller than the start time!\n", str);

                  }

                  error = str;
                }
              }
            }
          }
        }
      }
    }
  }

acl_time_dup_fail:
  ;
  if(CI_DEBUG_LEVEL >= 1)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Failed to parse acl time: %s (error on pos '...%s')\n", str, error);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Failed to parse acl time: %s (error on pos '...%s')\n", str, error);

  }

  allocator->free(allocator, (void *)tmd);
  return (void *)0;
}

// acl_time_equal
// file acl.c line 373
signed int acl_time_equal(const void *key1, const void *key2)
{
  struct acl_time_data *tmd_acl = (struct acl_time_data *)key1;
  struct acl_time_data *tmd_request = (struct acl_time_data *)key2;
  if(CI_DEBUG_LEVEL >= 9)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "acl_time_equal(key1=%p, key2=%p)\n", key1, key2);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("acl_time_equal(key1=%p, key2=%p)\n", key1, key2);

  }

  signed int matches;
  _Bool tmp_if_expr$1;
  if(!((tmd_acl->days & tmd_request->days) == 0u))
    tmp_if_expr$1 = tmd_request->start_time >= tmd_acl->start_time ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = tmd_request->start_time <= tmd_acl->end_time ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  matches = (signed int)tmp_if_expr$2;
  if(CI_DEBUG_LEVEL >= 8)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "acl_time_equal: %x/%d-%d <> %x/%d-%d -> %d\n", tmd_acl->days, tmd_acl->start_time, tmd_acl->end_time, tmd_request->days, tmd_request->start_time, tmd_request->end_time, matches);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("acl_time_equal: %x/%d-%d <> %x/%d-%d -> %d\n", tmd_acl->days, tmd_acl->start_time, tmd_acl->end_time, tmd_request->days, tmd_request->start_time, tmd_request->end_time, matches);

  }

  return matches;
}

// acl_time_free
// file acl.c line 389
void acl_time_free(void *tmd, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, (void *)tmd);
}

// add_mutex
// file os/unix/threads.c line 66
static struct mutex_itm * add_mutex(void *pmutex, signed int type)
{
  struct mutex_itm *m;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct mutex_itm) /*24ul*/ );
  m = (struct mutex_itm *)return_value_malloc$1;
  if(m == ((struct mutex_itm *)NULL))
    return (struct mutex_itm *)(void *)0;

  else
  {
    switch(type)
    {
      case 0:
      {
        m->mtx.mutex = (union anonymous$3 *)pmutex;
        break;
      }
      case 1:
      {
        m->mtx.rwlock = (union anonymous$1 *)pmutex;
        break;
      }
      default:
      {
        free((void *)m);
        return (struct mutex_itm *)(void *)0;
      }
    }
    m->type = type;
    m->next = (struct mutex_itm *)(void *)0;
    pthread_mutex_lock(&mutexes_lock);
    if(mutexes == ((struct mutex_itm *)NULL))
    {
      mutexes = m;
      last = m;
    }

    else
    {
      last->next = m;
      last = last->next;
    }
    if(init_child_mutexes_scheduled == 0)
    {
      pthread_atfork((void (*)(void))(void *)0, (void (*)(void))(void *)0, (void (*)(void))init_child_mutexes);
      init_child_mutexes_scheduled = 1;
    }

    pthread_mutex_unlock(&mutexes_lock);
    return m;
  }
}

// add_service
// file service.c line 339
struct ci_service_module * add_service(struct ci_service_module *service)
{
  struct ci_service_xdata *xdata = (struct ci_service_xdata *)(void *)0;
  struct ci_conf_entry *cfg_table;
  signed int ret;
  if(service_list == ((struct ci_service_module **)NULL))
  {
    service_list_size = 32;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)service_list_size * sizeof(struct ci_service_module *) /*8ul*/ );
    service_list = (struct ci_service_module **)return_value_malloc$1;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)service_list_size * sizeof(struct ci_service_xdata) /*3768ul*/ );
    service_extra_data_list = (struct ci_service_xdata *)return_value_malloc$2;
  }

  else
    if(services_num == service_list_size)
    {
      service_list_size = service_list_size + 32;
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)service_list, (unsigned long int)service_list_size * sizeof(struct ci_service_module *) /*8ul*/ );
      service_list = (struct ci_service_module **)return_value_realloc$3;
      void *return_value_realloc$4;
      return_value_realloc$4=realloc((void *)service_extra_data_list, (unsigned long int)service_list_size * sizeof(struct ci_service_xdata) /*3768ul*/ );
      service_extra_data_list = (struct ci_service_xdata *)return_value_realloc$4;
    }

  if(service_list == ((struct ci_service_module **)NULL) || service_extra_data_list == ((struct ci_service_xdata *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Fatal error: Cannot allocate memory! Exiting immediately!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Fatal error: Cannot allocate memory! Exiting immediately!\n");

    }

    exit(-1);
  }

  xdata = &service_extra_data_list[(signed long int)services_num];
  init_extra_data(xdata, service->mod_name);
  if(!(service->mod_init_service == ((signed int (*)(struct ci_service_xdata *, struct ci_server_conf *))NULL)))
  {
    ret=service->mod_init_service(xdata, &CI_CONF);
    if(!(ret == 1))
      xdata->status = 1;

    else
      xdata->status = 0;
  }

  else
    xdata->status = 0;
  signed int tmp_post$5 = services_num;
  services_num = services_num + 1;
  service_list[(signed long int)tmp_post$5] = service;
  cfg_table=create_service_conf_table(xdata, service->mod_conf_table);
  xdata->intl_srv_conf_table = cfg_table;
  if(!(cfg_table == ((struct ci_conf_entry *)NULL)))
    register_conf_table(service->mod_name, cfg_table, 1);

  return service;
}

// add_service_alias
// file include/service.h line 272
struct service_alias * add_service_alias(const char *service_alias, const char *service_name, const char *args)
{
  struct ci_service_module *service = (struct ci_service_module *)(void *)0;
  struct service_alias *salias = (struct service_alias *)(void *)0;
  struct ci_service_xdata *xdata = (struct ci_service_xdata *)(void *)0;
  signed int len = 0;
  signed int alias_indx = 0;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(service_alias, service_name);
  if(return_value_strcmp$1 == 0)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Warning, alias is the same as service_name, not adding\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Warning, alias is the same as service_name, not adding\n");

    }

    return (struct service_alias *)(void *)0;
  }

  else
  {
    if(service_aliases == ((struct service_alias *)NULL))
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc((unsigned long int)32 * sizeof(struct service_alias) /*328ul*/ );
      service_aliases = (struct service_alias *)return_value_malloc$2;
      service_aliases_size = 32;
    }

    else
      if(service_aliases_num == service_aliases_size)
      {
        service_aliases_size = service_aliases_size + 32;
        void *return_value_realloc$3;
        return_value_realloc$3=realloc((void *)service_aliases, (unsigned long int)service_aliases_size * sizeof(struct service_alias) /*328ul*/ );
        service_aliases = (struct service_alias *)return_value_realloc$3;
      }

    if(service_aliases == ((struct service_alias *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "add_service_alias: Error allocating memory. Exiting...\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("add_service_alias: Error allocating memory. Exiting...\n");

      }

      exit(-1);
    }

    service=find_service(service_name);
    if(service == ((struct ci_service_module *)NULL))
    {
      salias=find_service_alias(service_name);
      if(salias == ((struct service_alias *)NULL))
        return (struct service_alias *)(void *)0;

      service = salias->service;
    }

    xdata=service_data(service);
    alias_indx = service_aliases_num;
    service_aliases_num = service_aliases_num + 1;
    (service_aliases + (signed long int)alias_indx)->service = service;
    strncpy((service_aliases + (signed long int)alias_indx)->alias, service_alias, (unsigned long int)63);
    (service_aliases + (signed long int)alias_indx)->alias[(signed long int)63] = (char)0;
    (service_aliases + (signed long int)alias_indx)->args[(signed long int)0] = (char)0;
    if(!(salias == ((struct service_alias *)NULL)))
    {
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(salias->args);
      len = (signed int)return_value_strlen$4;
      strcpy((service_aliases + (signed long int)alias_indx)->args, salias->args);
    }

    if(!(args == ((const char *)NULL)) && !(len == 0))
    {
      (service_aliases + (signed long int)alias_indx)->args[(signed long int)len] = (char)38;
      len = len + 1;
    }

    if(255 + -len >= 1 && !(args == ((const char *)NULL)))
      strcpy((service_aliases + (signed long int)alias_indx)->args + (signed long int)len, args);

    (service_aliases + (signed long int)alias_indx)->args[(signed long int)255] = (char)0;
    if(!(xdata->intl_srv_conf_table == ((struct ci_conf_entry *)NULL)))
      register_conf_table((service_aliases + (signed long int)alias_indx)->alias, xdata->intl_srv_conf_table, 2);

    return &service_aliases[(signed long int)alias_indx];
  }
}

// add_to_modules_list
// file module.c line 95
void * add_to_modules_list(struct modules_list *mod_list, void *module)
{
  if(mod_list->modules == ((void **)NULL))
  {
    mod_list->list_size = 20;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)mod_list->list_size * sizeof(void *) /*8ul*/ );
    mod_list->modules = (void **)return_value_malloc$1;
  }

  else
    if(mod_list->modules_num == mod_list->list_size)
    {
      mod_list->list_size = mod_list->list_size + 20;
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)mod_list->modules, (unsigned long int)mod_list->list_size * sizeof(void *) /*8ul*/ );
      mod_list->modules = (void **)return_value_realloc$2;
    }

  if(mod_list->modules == ((void **)NULL))
    exit(-1);

  signed int tmp_post$3 = mod_list->modules_num;
  mod_list->modules_num = mod_list->modules_num + 1;
  mod_list->modules[(signed long int)tmp_post$3] = module;
  return module;
}

// alloc_a_buffer
// file decode.c line 198
static void * alloc_a_buffer(void *op, unsigned int items, unsigned int size)
{
  void *return_value_ci_buffer_alloc$1;
  return_value_ci_buffer_alloc$1=ci_buffer_alloc((signed int)(items * size));
  return return_value_ci_buffer_alloc$1;
}

// alloc_mem_allocator_struct
// file mem.c line 79
static struct ci_mem_allocator * alloc_mem_allocator_struct()
{
  struct ci_mem_allocator *alc;
  if(!(MEM_ALLOCATOR_POOL >= 0))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct ci_mem_allocator) /*56ul*/ );
    alc = (struct ci_mem_allocator *)return_value_malloc$1;
    alc->must_free = 1;
  }

  else
  {
    void *return_value_ci_object_pool_alloc$2;
    return_value_ci_object_pool_alloc$2=ci_object_pool_alloc(MEM_ALLOCATOR_POOL);
    alc = (struct ci_mem_allocator *)return_value_ci_object_pool_alloc$2;
    alc->must_free = 2;
  }
  return alc;
}

// alloc_text_table_entry
// file lookup_file_table.c line 55
struct text_table_entry * alloc_text_table_entry(signed int val_num, struct ci_mem_allocator *allocator)
{
  struct text_table_entry *e;
  signed int i;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(struct text_table_entry) /*24ul*/ );
  e = (struct text_table_entry *)return_value;
  e->key = (void *)0;
  e->next = (struct text_table_entry *)(void *)0;
  if(e == ((struct text_table_entry *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocating memory for table entry \n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocating memory for table entry \n");

    }

    return (struct text_table_entry *)(void *)0;
  }

  else
  {
    if(val_num >= 1)
    {
      void *return_value_1;
      return_value_1=allocator->alloc(allocator, (unsigned long int)(val_num + 1) * sizeof(void *) /*8ul*/ );
      e->vals = (void **)return_value_1;
      if(e->vals == ((void **)NULL))
      {
        allocator->free(allocator, (void *)e);
        e = (struct text_table_entry *)(void *)0;
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error allocating memory for values of  table entry.\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error allocating memory for values of  table entry.\n");

        }

        return (struct text_table_entry *)(void *)0;
      }

      i = 0;
      if(!(i >= 1 + val_num))
      {
        e->vals[(signed long int)i] = (void *)0;
        i = i + 1;
      }

    }

    else
      e->vals = (void **)(void *)0;
    return e;
  }
}

// announce_child
// file proc_threads_queues.c line 278
void announce_child(struct childs_queue *q, signed int pid)
{
  if(!(q->childs == ((struct child_shared_data *)NULL)))
  {
    if(!(pid == 0))
      q->srv_stats->started_childs = q->srv_stats->started_childs + 1u;

  }

}

// attach_childs_queue
// file proc_threads_queues.c line 170
signed int attach_childs_queue(struct childs_queue *q)
{
  struct child_shared_data *c;
  ci_proc_mutex_lock(&q->queue_mtx);
  void *return_value_ci_shared_mem_attach$1;
  return_value_ci_shared_mem_attach$1=ci_shared_mem_attach(&q->shmid);
  c = (struct child_shared_data *)return_value_ci_shared_mem_attach$1;
  if(c == ((struct child_shared_data *)NULL))
  {
    log_server((struct ci_request *)(void *)0, "can't attach shared memory!");
    ci_proc_mutex_unlock(&q->queue_mtx);
    return 0;
  }

  else
  {
    q->childs = c;
    ci_proc_mutex_unlock(&q->queue_mtx);
    return 1;
  }
}

// basic_authentication_header
// file http_auth.c line 448
char * basic_authentication_header()
{
  return basic_authentication;
}

// basic_close
// file http_auth.c line 409
void basic_close()
{
  if(!(basic_authentication == ((char *)NULL)))
  {
    free((void *)basic_authentication);
    basic_authentication = (char *)(void *)0;
  }

}

// basic_create_auth_data
// file http_auth.c line 417
struct http_basic_auth_data * basic_create_auth_data(const char *auth_line, const char **username)
{
  struct http_basic_auth_data *data;
  char dec_http_user[513l];
  char *str;
  signed int max_decode_len = 255 + 256 + 2;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct http_basic_auth_data) /*513ul*/ );
  data = (struct http_basic_auth_data *)return_value_malloc$1;
  ci_base64_decode(auth_line, dec_http_user, max_decode_len);
  if(CI_DEBUG_LEVEL >= 5)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "The proxy user is:%s (basic method) \n", (const void *)dec_http_user);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("The proxy user is:%s (basic method) \n", (const void *)dec_http_user);

  }

  str=strchr(dec_http_user, 58);
  if(!(str == ((char *)NULL)))
  {
    *str = (char)0;
    str = str + 1l;
    strncpy(data->http_pass, str, (unsigned long int)256);
    data->http_pass[(signed long int)(256 - 1)] = (char)0;
  }

  strncpy(data->http_user, dec_http_user, (unsigned long int)255);
  data->http_user[(signed long int)255] = (char)0;
  if(!(username == ((const char **)NULL)))
    *username = data->http_user;

  return data;
}

// basic_post_init
// file http_auth.c line 397
signed int basic_post_init(struct ci_server_conf *server_conf)
{
  signed int size;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen("Proxy-Authenticate: Basic realm=");
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(basic_realm);
  size = (signed int)(return_value_strlen$1 + return_value_strlen$2 + (unsigned long int)3);
  void *return_value_malloc$3;
  return_value_malloc$3=malloc((unsigned long int)(size + 1) * sizeof(char) /*1ul*/ );
  basic_authentication = (char *)return_value_malloc$3;
  if(basic_authentication == ((char *)NULL))
    return 0;

  else
  {
    snprintf(basic_authentication, (unsigned long int)size, "%s\"%s\"", (const void *)"Proxy-Authenticate: Basic realm=", basic_realm);
    return 1;
  }
}

// basic_release_auth_data
// file http_auth.c line 443
void basic_release_auth_data(struct http_basic_auth_data *data)
{
  free((void *)data);
}

// basic_simple_db_athenticate
// file http_auth.c line 507
signed int basic_simple_db_athenticate(struct http_basic_auth_data *data, const char *usedb)
{
  char **pass = (char **)(void *)0;
  void *user_ret;
  signed int ret = 1;
  if(CI_DEBUG_LEVEL >= 1)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Going to authenticate user %s:%s\n", (const void *)data->http_user, (const void *)data->http_pass);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Going to authenticate user %s:%s\n", (const void *)data->http_user, (const void *)data->http_pass);

  }

  if(users_db == ((struct ci_lookup_table *)NULL))
    return -1;

  else
  {
    user_ret=users_db->search(users_db, (void *)data->http_user, (void ***)&pass);
    if(user_ret == NULL)
      return -1;

    else
    {
      _Bool tmp_if_expr$2;
      if(pass == ((char **)NULL))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = pass[(signed long int)0] == ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
      {
        if(!((signed int)data->http_pass[0l] == 0))
          ret = -1;

        else
          ret = 1;
      }

      else
      {
        signed int return_value_strcmp$1;
        return_value_strcmp$1=strcmp(data->http_pass, pass[(signed long int)0]);
        if(!(return_value_strcmp$1 == 0))
          ret = -1;

      }
      users_db->release_result(users_db, (void **)pass);
      if(CI_DEBUG_LEVEL >= 4)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "User %s, %s\n", (const void *)data->http_user, ret == 1 ? "authenticated" : "authentication/authorization fails");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("User %s, %s\n", (const void *)data->http_user, ret == 1 ? "authenticated" : "authentication/authorization fails");

      }

      return ret;
      return 1;
    }
  }
}

// basic_simple_db_close
// file http_auth.c line 495
void basic_simple_db_close()
{
  if(!(users_db == ((struct ci_lookup_table *)NULL)))
  {
    ci_lookup_table_destroy(users_db);
    users_db = (struct ci_lookup_table *)(void *)0;
  }

}

// basic_simple_db_post_init
// file http_auth.c line 483
signed int basic_simple_db_post_init(struct ci_server_conf *server_conf)
{
  if(!(USERS_DB_PATH == ((char *)NULL)))
  {
    users_db=ci_lookup_table_create(USERS_DB_PATH);
    void *return_value;
    return_value=users_db->open(users_db);
    if(return_value == NULL)
    {
      ci_lookup_table_destroy(users_db);
      users_db = (struct ci_lookup_table *)(void *)0;
    }

  }

  return 1;
}

// build_statistics
// file info.c line 294
signed int build_statistics(struct info_req_data *info_data)
{
  char buf[1024l];
  char buf2[1024l];
  signed int sz;
  signed int gid;
  signed int k;
  char *stat_group;
  struct stats_tmpl *tmpl;
  if(!(info_data->txt_mode == 0))
    tmpl = &txt_tmpl;

  else
    tmpl = &html_tmpl;
  if(info_data->body == ((struct ci_membuf *)NULL))
    return 0;

  else
  {
    fill_queue_statistics(childs_queue, info_data);
    sz=snprintf(buf, (unsigned long int)1024, tmpl->gen_template, info_data->childs, info_data->free_servers, info_data->used_servers, info_data->started_childs, info_data->closed_childs, info_data->crashed_childs, info_data->closing_childs);
    if(sz >= 1025)
      sz = 1024;

    ci_membuf_write(info_data->body, buf, sz, 0);
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(tmpl->childsHeader);
    ci_membuf_write(info_data->body, tmpl->childsHeader, (signed int)return_value_strlen$1, 0);
    k = 0;
    for( ; !(k >= info_data->childs); k = k + 1)
    {
      sz=snprintf(buf, (unsigned long int)1024, tmpl->childs_tmpl, info_data->child_pids[(signed long int)k]);
      if(sz >= 1025)
        sz = 1024;

      ci_membuf_write(info_data->body, buf, sz, 0);
    }
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(tmpl->childsEnd);
    ci_membuf_write(info_data->body, tmpl->childsEnd, (signed int)return_value_strlen$2, 0);
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(tmpl->closingChildsHeader);
    ci_membuf_write(info_data->body, tmpl->closingChildsHeader, (signed int)return_value_strlen$3, 0);
    k = 0;
    for( ; !((unsigned int)k >= info_data->closing_childs); k = k + 1)
    {
      sz=snprintf(buf, (unsigned long int)1024, tmpl->childs_tmpl, info_data->closing_child_pids[(signed long int)k]);
      if(sz >= 1025)
        sz = 1024;

      ci_membuf_write(info_data->body, buf, sz, 0);
    }
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(tmpl->childsEnd);
    ci_membuf_write(info_data->body, tmpl->childsEnd, (signed int)return_value_strlen$4, 0);
    sz=snprintf(buf, (unsigned long int)1024, tmpl->d1TableHeader_tmpl, (const void *)"Semaphores in use");
    if(sz >= 1025)
      sz = 1024;

    ci_membuf_write(info_data->body, buf, sz, 0);
    accept_mutex.scheme->proc_mutex_print_info(&accept_mutex, buf2, (unsigned long int)1024);
    sz=snprintf(buf, (unsigned long int)1024, tmpl->d1TableEntry_tmpl, (const void *)buf2);
    ci_membuf_write(info_data->body, buf, sz, 0);
    childs_queue->queue_mtx.scheme->proc_mutex_print_info(&childs_queue->queue_mtx, buf2, (unsigned long int)1024);
    sz=snprintf(buf, (unsigned long int)1024, tmpl->d1TableEntry_tmpl, (const void *)buf2);
    ci_membuf_write(info_data->body, buf, sz, 0);
    unsigned long int return_value_strlen$5;
    return_value_strlen$5=strlen(tmpl->d1TableEnd_tmpl);
    ci_membuf_write(info_data->body, tmpl->d1TableEnd_tmpl, (signed int)return_value_strlen$5, 0);
    sz=snprintf(buf, (unsigned long int)1024, tmpl->d1TableHeader_tmpl, (const void *)"Shared mem blocks in use");
    if(sz >= 1025)
      sz = 1024;

    ci_membuf_write(info_data->body, buf, sz, 0);
    if(!(childs_queue->shmid.scheme == ((const struct ci_shared_mem_scheme *)NULL)))
    {
      childs_queue->shmid.scheme->shared_mem_print_info(&childs_queue->shmid, buf2, (unsigned long int)1024);
      sz=snprintf(buf, (unsigned long int)1024, tmpl->d1TableEntry_tmpl, (const void *)buf2);
      ci_membuf_write(info_data->body, buf, sz, 0);
    }

    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(tmpl->d1TableEnd_tmpl);
    ci_membuf_write(info_data->body, tmpl->d1TableEnd_tmpl, (signed int)return_value_strlen$6, 0);
    gid = 0;
    if(!(gid >= STAT_GROUPS.entries_num))
    {
      stat_group = STAT_GROUPS.groups[(signed long int)gid];
      sz=snprintf(buf, (unsigned long int)1024, tmpl->statsHeader, stat_group);
      if(sz >= 1025)
        sz = 1024;

      ci_membuf_write(info_data->body, buf, sz, 0);
      k = 0;
      if(!(k >= info_data->collect_stats->counters64_size) && !(k >= STAT_INT64.entries_num))
      {
        if(gid == (STAT_INT64.entries + (signed long int)k)->gid)
        {
          sz=snprintf(buf, (unsigned long int)1024, tmpl->statline_tmpl_int, (STAT_INT64.entries + (signed long int)k)->label, info_data->collect_stats->counters64[(signed long int)k]);
          if(sz >= 1025)
            sz = 1024;

          ci_membuf_write(info_data->body, buf, sz, 0);
        }

        k = k + 1;
      }

      k = 0;
      if(!(k >= info_data->collect_stats->counterskbs_size) && !(k >= STAT_KBS.entries_num))
      {
        if(gid == (STAT_KBS.entries + (signed long int)k)->gid)
        {
          sz=snprintf(buf, (unsigned long int)1024, tmpl->statline_tmpl_kbs, (STAT_KBS.entries + (signed long int)k)->label, info_data->collect_stats->counterskbs[(signed long int)k]);
          if(sz >= 1025)
            sz = 1024;

          ci_membuf_write(info_data->body, buf, sz, 0);
        }

        k = k + 1;
      }

      unsigned long int return_value_strlen$7;
      return_value_strlen$7=strlen(tmpl->statsEnd);
      ci_membuf_write(info_data->body, tmpl->statsEnd, (signed int)return_value_strlen$7, 1);
      gid = gid + 1;
    }

    return 1;
  }
}

// byteReverse
// file md5.c line 28
static void byteReverse(unsigned char *buf, unsigned int longs)
{
  unsigned int t;
  do
  {
    t = (unsigned int)((unsigned int)buf[(signed long int)3] << 8 | (unsigned int)buf[(signed long int)2]) << 16 | (unsigned int)buf[(signed long int)1] << 8 | (unsigned int)buf[(signed long int)0];
    *((unsigned int *)buf) = t;
    buf = buf + (signed long int)4;
    longs = longs - 1u;
  }
  while(!(longs == 0u));
}

// call_authenticators
// file http_auth.c line 44
signed int call_authenticators(struct authenticator_module **authenticators, void *method_data)
{
  signed int i;
  signed int res;
  i = 0;
  if(!(authenticators[(signed long int)i] == ((struct authenticator_module *)NULL)))
  {
    res=authenticators[(signed long int)i]->authenticate(method_data, (const char *)(void *)0);
    if(!(res == 0))
      return res;

    i = i + 1;
  }

  return -1;
}

// cancel_all_threads
// file mpmt_server.c line 198
static void cancel_all_threads()
{
  signed int i = 0;
  signed int wait_listener_time = 10000;
  signed int wait_for_workers = CHILD_SHUTDOWN_TIMEOUT > 5 ? CHILD_SHUTDOWN_TIMEOUT : 5;
  signed int servers_running;
  for( ; wait_listener_time >= 1 && !(listener_running == 0); wait_listener_time = wait_listener_time - 10)
  {
    pthread_kill(listener_thread_id, 1);
    pthread_cond_signal(&free_server_cond);
    ci_usleep((unsigned long int)1000);
  }
  if(listener_running == 0)
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Going to wait for the listener thread (pid: %d) to exit!\n", threads_list[(signed long int)0]->srv_id);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Going to wait for the listener thread (pid: %d) to exit!\n", threads_list[(signed long int)0]->srv_id);

    }

    ci_thread_join(listener_thread_id);
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "OK, cancelling the listener thread (pid: %d)!\n", threads_list[(signed long int)0]->srv_id);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("OK, cancelling the listener thread (pid: %d)!\n", threads_list[(signed long int)0]->srv_id);

    }

  }

  pthread_cond_broadcast(&con_queue->queue_cond);
  ci_usleep((unsigned long int)1000);
  servers_running = CI_CONF.THREADS_PER_CHILD;
  while(wait_for_workers >= 0 && !(servers_running == 0))
  {
    if(child_data->to_be_killed == 2)
      CHILD_HALT = 1;

    i = 0;
    for( ; !(i >= CI_CONF.THREADS_PER_CHILD); i = i + 1)
      if(!(threads_list[(signed long int)i] == ((struct server_decl *)NULL)))
      {
        if(threads_list[(signed long int)i]->running == 0)
        {
          if(CI_DEBUG_LEVEL >= 5)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Cancel server %d, thread_id %lu (%d)\n", threads_list[(signed long int)i]->srv_id, threads_list[(signed long int)i]->srv_pthread, i);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Cancel server %d, thread_id %lu (%d)\n", threads_list[(signed long int)i]->srv_id, threads_list[(signed long int)i]->srv_pthread, i);

          }

          ci_thread_join(threads_list[(signed long int)i]->srv_pthread);
          release_thread_i(i);
          servers_running = servers_running - 1;
        }

        else
          if(child_data->to_be_killed == 2)
          {
            if(!(wait_for_workers >= 3))
            {
              if(CI_DEBUG_LEVEL >= 5)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "Thread %ld still running near the timeout. Try to kill it\n", threads_list[(signed long int)i]->srv_pthread);

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("Thread %ld still running near the timeout. Try to kill it\n", threads_list[(signed long int)i]->srv_pthread);

              }

              pthread_kill(threads_list[(signed long int)i]->srv_pthread, 15);
            }

          }

      }

    ci_usleep((unsigned long int)999999);
    if(child_data->to_be_killed == 2)
      wait_for_workers = wait_for_workers - 1;

  }
  if(!(servers_running == 0))
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not all the servers canceled. Anyway exiting....\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not all the servers canceled. Anyway exiting....\n");

    }

  }

  else
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "All servers canceled\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("All servers canceled\n");

    }

    free((void *)threads_list);
  }
}

// cb_check_command
// file commands.c line 109
signed int cb_check_command(void *data, const void *obj)
{
  const struct ci_command **rcommand = (const struct ci_command **)data;
  const struct ci_command *cur_item = (const struct ci_command *)obj;
  signed int return_value_strcmp$1;
  if(!(*rcommand == ((const struct ci_command *)NULL)))
  {
    return_value_strcmp$1=strcmp((*rcommand)->name, cur_item->name);
    if(return_value_strcmp$1 == 0)
    {
      *rcommand = cur_item;
      return 1;
    }

  }

  return 0;
}

// cb_check_queue
// file commands.c line 235
static signed int cb_check_queue(void *data, const void *item)
{
  struct schedule_data *sch = (struct schedule_data *)item;
  signed long int tm = *((signed long int *)data);
  if(!(sch->when >= tm))
  {
    struct ci_command *cmd;
    cmd=find_command(sch->name);
    if(!(cmd == ((struct ci_command *)NULL)))
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Execute command:%s \n", (const void *)cmd->name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Execute command:%s \n", (const void *)cmd->name);

      }

      void *tmp_if_expr$1;
      if(!(sch->data == NULL))
        tmp_if_expr$1 = sch->data;

      else
        tmp_if_expr$1 = cmd->data;
      cmd->$anon0.command_action_extend(cmd->name, cmd->type, tmp_if_expr$1);
    }

    pthread_mutex_lock(&COMMANDS_MTX);
    ci_list_remove(COMMANDS_QUEUE, (const void *)sch);
    pthread_mutex_unlock(&COMMANDS_MTX);
  }

  return 0;
}

// cfg_acl_add
// file cfg_param.c line 598
signed int cfg_acl_add(const char *directive, const char **argv, void *setdata)
{
  const char *acl_name;
  const char *acl_type;
  signed int argc;
  signed int ok;
  _Bool tmp_if_expr$1;
  if(*argv == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(argv[(signed long int)1] != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(argv[(signed long int)2] != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return 0;

  else
  {
    acl_name = argv[(signed long int)0];
    acl_type = argv[(signed long int)1];
    argc = 2;
    ok = 1;
    for( ; !(argv[(signed long int)argc] == ((const char *)NULL)) && !(ok == 0); argc = argc + 1)
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Adding to acl %s the data %s\n", acl_name, argv[(signed long int)argc]);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Adding to acl %s the data %s\n", acl_name, argv[(signed long int)argc]);

      }

      ok=ci_acl_add_data(acl_name, acl_type, argv[(signed long int)argc]);
    }
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "New ACL with name:%s and  ACL Type: %s\n", argv[(signed long int)0], argv[(signed long int)1]);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("New ACL with name:%s and  ACL Type: %s\n", argv[(signed long int)0], argv[(signed long int)1]);

    }

    return ok;
  }
}

// cfg_default_acl_access
// file cfg_param.c line 132
signed int cfg_default_acl_access(const char *directive, const char **argv, void *setdata)
{
  signed int type;
  signed int argc;
  signed int error = 0;
  signed int only_connection = 0;
  const char *acl_spec_name;
  struct ci_access_entry **tolist;
  struct ci_access_entry *access_entry;
  const struct ci_acl_spec *acl_spec;
  const struct ci_acl_type *spec_type;
  _Bool tmp_if_expr$1;
  if(*argv == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)1] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$10;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Parse error in directive %s \n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Parse error in directive %s \n", directive);

    }

    return 0;
  }

  else
  {
    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp("client_access", directive);
    if(return_value_strcmp$3 == 0)
    {
      tolist = &acl_connection_access_list;
      only_connection = 1;
    }

    else
    {
      return_value_strcmp$2=strcmp("icap_access", directive);
      if(return_value_strcmp$2 == 0)
        tolist = &acl_access_list;

      else
        return 0;
    }
    signed int return_value_strcmp$5;
    return_value_strcmp$5=strcmp(argv[(signed long int)0], "allow");
    if(return_value_strcmp$5 == 0)
      type = 1;

    else
    {
      return_value_strcmp$4=strcmp(argv[(signed long int)0], "deny");
      if(return_value_strcmp$4 == 0)
        type = -1;

      else
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Invalid directive :%s. Disabling %s acl rule \n", argv[(signed long int)0], argv[(signed long int)1]);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Invalid directive :%s. Disabling %s acl rule \n", argv[(signed long int)0], argv[(signed long int)1]);

        }

        return 0;
      }
    }
    access_entry=ci_access_entry_new(tolist, type);
    if(access_entry == ((struct ci_access_entry *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error creating new access entry as %s access list\n", argv[(signed long int)0]);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error creating new access entry as %s access list\n", argv[(signed long int)0]);

      }

      return 0;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Creating new access entry as %s with specs:\n", argv[(signed long int)0]);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Creating new access entry as %s with specs:\n", argv[(signed long int)0]);

      }

      argc = 1;
      for( ; !(argv[(signed long int)argc] == ((const char *)NULL)); argc = argc + 1)
      {
        acl_spec_name = argv[(signed long int)argc];
        acl_spec=ci_acl_search(acl_spec_name);
        if(!(acl_spec == ((const struct ci_acl_spec *)NULL)))
          spec_type = acl_spec->type;

        else
          spec_type = (const struct ci_acl_type *)(void *)0;
        _Bool tmp_if_expr$7;
        if(!(spec_type == ((const struct ci_acl_type *)NULL)) && !(only_connection == 0))
        {
          return_value_strcmp$6=strcmp(spec_type->name, "port");
          tmp_if_expr$7 = return_value_strcmp$6 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$7 = (_Bool)0;
        _Bool tmp_if_expr$9;
        if(tmp_if_expr$7)
        {
          return_value_strcmp$8=strcmp(spec_type->name, "src");
          tmp_if_expr$9 = return_value_strcmp$8 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$9 = (_Bool)0;
        _Bool tmp_if_expr$11;
        if(tmp_if_expr$9)
        {
          return_value_strcmp$10=strcmp(spec_type->name, "srvip");
          tmp_if_expr$11 = return_value_strcmp$10 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$11 = (_Bool)0;
        if(tmp_if_expr$11)
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Only \"port\", \"src\" and \"srvip\" acl types allowed in client_access access list (given :%s)\n", acl_spec_name);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Only \"port\", \"src\" and \"srvip\" acl types allowed in client_access access list (given :%s)\n", acl_spec_name);

          }

          error = 1;
        }

        else
        {
          ci_access_entry_add_acl_by_name(access_entry, acl_spec_name);
          if(CI_DEBUG_LEVEL >= 2)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "\tAdding acl spec: %s\n", acl_spec_name);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("\tAdding acl spec: %s\n", acl_spec_name);

          }

        }
      }
      if(!(error == 0))
        return 0;

      else
        return 1;
    }
  }
}

// cfg_default_acl_add
// file default_acl.c line 97
signed int cfg_default_acl_add(const char *directive, const char **argv, void *setdata)
{
  return 1;
}

// cfg_default_value_replace
// file cfg_param.c line 1038
struct cfg_default_value * cfg_default_value_replace(void *param, void *value)
{
  struct cfg_default_value *dval = default_values;
  for( ; !(dval == ((struct cfg_default_value *)NULL)); dval = dval->next)
    if(dval->param == param)
      break;

  if(dval == ((struct cfg_default_value *)NULL))
    return (struct cfg_default_value *)(void *)0;

  else
  {
    memcpy(dval->value, value, (unsigned long int)dval->size);
    return dval;
  }
}

// cfg_default_value_restore
// file cfg_param.c line 1062
void * cfg_default_value_restore(void *param)
{
  struct cfg_default_value *dval = default_values;
  if(CI_DEBUG_LEVEL >= 8)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Geting default value for %p\n", param);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Geting default value for %p\n", param);

  }

  for( ; !(dval == ((struct cfg_default_value *)NULL)); dval = dval->next)
    if(dval->param == param)
      break;

  if(dval == ((struct cfg_default_value *)NULL))
    return (void *)0;

  else
  {
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Found: %p\n", dval->value);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Found: %p\n", dval->value);

    }

    memcpy(param, dval->value, (unsigned long int)dval->size);
    return param;
  }
}

// cfg_default_value_restore_all
// file cfg_param.c line 1077
void cfg_default_value_restore_all()
{
  struct cfg_default_value *dval = default_values;
  for( ; !(dval == ((struct cfg_default_value *)NULL)); dval = dval->next)
    memcpy(dval->param, dval->value, (unsigned long int)dval->size);
}

// cfg_default_value_search
// file cfg_param.c line 1052
struct cfg_default_value * cfg_default_value_search(void *param)
{
  struct cfg_default_value *dval = default_values;
  if(CI_DEBUG_LEVEL >= 8)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Searching %p for default value\n", param);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Searching %p for default value\n", param);

  }

  for( ; !(dval == ((struct cfg_default_value *)NULL)); dval = dval->next)
    if(dval->param == param)
      break;

  return dval;
}

// cfg_default_value_store
// file cfg_param.c line 1009
struct cfg_default_value * cfg_default_value_store(void *param, void *value, signed int size)
{
  struct cfg_default_value *dval;
  struct cfg_default_value *dval_search;
  dval=cfg_default_value_search(param);
  if(!(dval == ((struct cfg_default_value *)NULL)))
    return dval;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct cfg_default_value) /*32ul*/ );
    dval = (struct cfg_default_value *)return_value_malloc$1;
    if(dval == ((struct cfg_default_value *)NULL))
      return ((struct cfg_default_value *)NULL);

    else
    {
      dval->param = param;
      dval->size = size;
      dval->value=malloc((unsigned long int)size);
      if(dval->value == NULL)
      {
        free((void *)dval);
        return (struct cfg_default_value *)(void *)0;
      }

      else
      {
        memcpy(dval->value, value, (unsigned long int)size);
        dval->next = (struct cfg_default_value *)(void *)0;
        if(default_values == ((struct cfg_default_value *)NULL))
        {
          default_values = dval;
          return dval;
        }

        else
        {
          dval_search = default_values;
          for( ; !(dval_search->next == ((struct cfg_default_value *)NULL)); dval_search = dval_search->next)
            ;
          dval_search->next = dval;
          return dval;
        }
      }
    }
  }
}

// cfg_group_source_by_group
// file cfg_param.c line 639
signed int cfg_group_source_by_group(const char *directive, const char **argv, void *setdata)
{
  const char *group_table = (const char *)(void *)0;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    group_table = argv[(signed long int)0];
    signed int return_value_group_source_add_by_group$2;
    return_value_group_source_add_by_group$2=group_source_add_by_group(group_table);
    return return_value_group_source_add_by_group$2;
  }
}

// cfg_group_source_by_user
// file cfg_param.c line 649
signed int cfg_group_source_by_user(const char *directive, const char **argv, void *setdata)
{
  const char *group_table = (const char *)(void *)0;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    group_table = argv[(signed long int)0];
    signed int return_value_group_source_add_by_user$2;
    return_value_group_source_add_by_user$2=group_source_add_by_user(group_table);
    return return_value_group_source_add_by_user$2;
  }
}

// cfg_include_config_file
// file cfg_param.c line 617
signed int cfg_include_config_file(const char *directive, const char **argv, void *setdata)
{
  char path[4096l];
  const char *cfg_file;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    cfg_file = argv[(signed long int)0];
    if(!((signed int)*cfg_file == 47))
    {
      snprintf(path, (unsigned long int)4096, "/etc/c-icap/%s", cfg_file);
      path[(signed long int)(4096 - 1)] = (char)0;
      cfg_file = path;
    }

    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "\n*** Going to open config file %s ***\n", cfg_file);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("\n*** Going to open config file %s ***\n", cfg_file);

    }

    signed int return_value_parse_file$2;
    return_value_parse_file$2=parse_file(cfg_file);
    return return_value_parse_file$2;
  }
}

// cfg_load_magicfile
// file cfg_param.c line 453
signed int cfg_load_magicfile(const char *directive, const char **argv, void *setdata)
{
  const char *db_file;
  struct ci_magics_db *ndb;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    db_file = argv[(signed long int)0];
    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(CI_CONF.magics_file, db_file);
    if(return_value_strcmp$2 == 0)
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "The db file %s is the same as default. Ignoring...\n", db_file);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("The db file %s is the same as default. Ignoring...\n", db_file);

      }

      return 1;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Going to load magic file %s\n", db_file);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Going to load magic file %s\n", db_file);

      }

      ndb=ci_magic_db_load(db_file);
      if(ndb == ((struct ci_magics_db *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Can not load magic file %s!!!\n", db_file);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Can not load magic file %s!!!\n", db_file);

        }

        return 0;
      }

      else
      {
        if(CI_CONF.MAGIC_DB == ((struct ci_magics_db *)NULL))
          CI_CONF.MAGIC_DB = ndb;

        return 1;
      }
    }
  }
}

// cfg_load_module
// file cfg_param.c line 438
signed int cfg_load_module(const char *directive, const char **argv, void *setdata)
{
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = argv[(signed long int)1] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Missing arguments in LoadModule directive\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Missing arguments in LoadModule directive\n");

    }

    return 0;
  }

  else
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Loading service :%s path %s\n", argv[(signed long int)0], argv[(signed long int)1]);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Loading service :%s path %s\n", argv[(signed long int)0], argv[(signed long int)1]);

    }

    void *return_value_register_module$3;
    return_value_register_module$3=register_module(argv[(signed long int)1], argv[(signed long int)0]);
    if(return_value_register_module$3 == NULL)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error loading module %s, module path %s\n", argv[(signed long int)1], argv[(signed long int)0]);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error loading module %s, module path %s\n", argv[(signed long int)1], argv[(signed long int)0]);

      }

      return 0;
    }

    else
      return 1;
  }
}

// cfg_load_service
// file cfg_param.c line 404
signed int cfg_load_service(const char *directive, const char **argv, void *setdata)
{
  struct ci_service_module *service = (struct ci_service_module *)(void *)0;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = argv[(signed long int)1] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Missing arguments in LoadService directive\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Missing arguments in LoadService directive\n");

    }

    return 0;
  }

  else
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Loading service :%s path %s\n", argv[(signed long int)0], argv[(signed long int)1]);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Loading service :%s path %s\n", argv[(signed long int)0], argv[(signed long int)1]);

    }

    service=register_service(argv[(signed long int)1]);
    if(service == ((struct ci_service_module *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error loading service %s\n", argv[(signed long int)1]);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error loading service %s\n", argv[(signed long int)1]);

      }

      return 0;
    }

    else
    {
      add_service_alias(argv[(signed long int)0], service->mod_name, (const char *)(void *)0);
      return 1;
    }
  }
}

// cfg_proc_lock_scheme
// file cfg_param.c line 667
signed int cfg_proc_lock_scheme(const char *directive, const char **argv, void *setdata)
{
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    signed int return_value_ci_proc_mutex_set_scheme$2;
    return_value_ci_proc_mutex_set_scheme$2=ci_proc_mutex_set_scheme(argv[(signed long int)0]);
    return return_value_ci_proc_mutex_set_scheme$2;
  }
}

// cfg_service_alias
// file cfg_param.c line 421
signed int cfg_service_alias(const char *directive, const char **argv, void *setdata)
{
  char *service_args = (char *)(void *)0;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = argv[(signed long int)1] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Missing arguments in ServiceAlias directive\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Missing arguments in ServiceAlias directive\n");

    }

    return 0;
  }

  else
  {
    service_args=strchr(argv[(signed long int)1], 63);
    if(!(service_args == ((char *)NULL)))
    {
      *service_args = (char)0;
      service_args = service_args + 1l;
    }

    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Alias:%s of service %s\n", argv[(signed long int)0], argv[(signed long int)1]);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Alias:%s of service %s\n", argv[(signed long int)0], argv[(signed long int)1]);

    }

    add_service_alias(argv[(signed long int)0], argv[(signed long int)1], service_args);
    return 1;
  }
}

// cfg_set_accesslog
// file cfg_param.c line 490
signed int cfg_set_accesslog(const char *directive, const char **argv, void *setdata)
{
  const char **acls = (const char **)(void *)0;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Missing arguments in directive %s\n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Missing arguments in directive %s\n", directive);

    }

    return 0;
  }

  else
  {
    if(!(argv[1l] == ((const char *)NULL)))
    {
      if(!(argv[2l] == ((const char *)NULL)))
        acls = argv + (signed long int)2;

    }

    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Adding the access logfile %s\n", argv[(signed long int)0]);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Adding the access logfile %s\n", argv[(signed long int)0]);

    }

    signed int return_value_file_log_addlogfile$2;
    return_value_file_log_addlogfile$2=file_log_addlogfile(argv[(signed long int)0], argv[(signed long int)1], acls);
    return return_value_file_log_addlogfile$2;
  }
}

// cfg_set_acl_controllers
// file cfg_param.c line 550
signed int cfg_set_acl_controllers(const char *directive, const char **argv, void *setdata)
{
  signed int i;
  signed int k;
  signed int argc;
  signed int ret;
  struct access_control_module *acl_mod;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    signed int return_value_strncasecmp$2;
    return_value_strncasecmp$2=strncasecmp(argv[(signed long int)0], "none", (unsigned long int)4);
    if(return_value_strncasecmp$2 == 0)
    {
      used_access_controllers = (struct access_control_module **)(void *)0;
      return 1;
    }

    else
    {
      argc = 0;
      for( ; !(argv[(signed long int)argc] == ((const char *)NULL)); argc = argc + 1)
        ;
      void *return_value_ci_cfg_alloc_mem$3;
      return_value_ci_cfg_alloc_mem$3=ci_cfg_alloc_mem((signed int)((unsigned long int)(argc + 1) * sizeof(struct access_control_module *) /*8ul*/ ));
      used_access_controllers = (struct access_control_module **)return_value_ci_cfg_alloc_mem$3;
      k = 0;
      ret = 1;
      i = 0;
      for( ; !(i >= argc); i = i + 1)
      {
        acl_mod=find_access_controller(argv[(signed long int)i]);
        if(!(acl_mod == ((struct access_control_module *)NULL)))
        {
          signed int tmp_post$4 = k;
          k = k + 1;
          used_access_controllers[(signed long int)tmp_post$4] = acl_mod;
        }

        else
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "No access controller with name :%s\n", argv[(signed long int)i]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("No access controller with name :%s\n", argv[(signed long int)i]);

          }

          ret = 0;
        }
      }
      used_access_controllers[(signed long int)k] = (struct access_control_module *)(void *)0;
      return ret;
    }
  }
}

// cfg_set_auth_method
// file cfg_param.c line 584
signed int cfg_set_auth_method(const char *directive, const char **argv, void *setdata)
{
  const char *method = (const char *)(void *)0;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = argv[(signed long int)1] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return 0;

  else
  {
    method = argv[(signed long int)0];
    signed int return_value_strncasecmp$4;
    return_value_strncasecmp$4=strncasecmp(argv[(signed long int)1], "none", (unsigned long int)4);
    if(return_value_strncasecmp$4 == 0)
    {
      signed int return_value_set_method_authenticators$3;
      return_value_set_method_authenticators$3=set_method_authenticators(method, (const char **)(void *)0);
      return return_value_set_method_authenticators$3;
    }

    signed int return_value_set_method_authenticators$5;
    return_value_set_method_authenticators$5=set_method_authenticators(method, (const char **)argv + (signed long int)1);
    return return_value_set_method_authenticators$5;
  }
}

// cfg_set_body_maxmem
// file cfg_param.c line 399
signed int cfg_set_body_maxmem(const char *directive, const char **argv, void *setdata)
{
  signed int return_value_intl_cfg_size_long$1;
  return_value_intl_cfg_size_long$1=intl_cfg_size_long(directive, argv, (void *)&CI_BODY_MAX_MEM);
  return return_value_intl_cfg_size_long$1;
}

// cfg_set_debug_level
// file cfg_param.c line 380
signed int cfg_set_debug_level(const char *directive, const char **argv, void *setdata)
{
  signed int return_value_intl_cfg_set_int$1;
  if(DebugLevelSetFromCmd == 0)
  {
    return_value_intl_cfg_set_int$1=intl_cfg_set_int(directive, argv, (void *)&CI_DEBUG_LEVEL);
    return return_value_intl_cfg_set_int$1;
  }

  return 1;
}

// cfg_set_debug_level_cmd
// file cfg_param.c line 388
signed int cfg_set_debug_level_cmd(const char *directive, const char **argv, void *setdata)
{
  DebugLevelSetFromCmd = 1;
  signed int return_value_intl_cfg_set_int$1;
  return_value_intl_cfg_set_int$1=intl_cfg_set_int(directive, argv, (void *)&CI_DEBUG_LEVEL);
  return return_value_intl_cfg_set_int$1;
}

// cfg_set_debug_stdout
// file cfg_param.c line 394
signed int cfg_set_debug_stdout(const char *directive, const char **argv, void *setdata)
{
  signed int return_value_intl_cfg_enable$1;
  return_value_intl_cfg_enable$1=intl_cfg_enable(directive, argv, (void *)&CI_DEBUG_STDOUT);
  return return_value_intl_cfg_enable$1;
}

// cfg_set_logformat
// file cfg_param.c line 479
signed int cfg_set_logformat(const char *directive, const char **argv, void *setdata)
{
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = argv[(signed long int)1] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Missing arguments in directive %s\n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Missing arguments in directive %s\n", directive);

    }

    return 0;
  }

  else
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Adding the logformat %s: %s\n", argv[(signed long int)0], argv[(signed long int)1]);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Adding the logformat %s: %s\n", argv[(signed long int)0], argv[(signed long int)1]);

    }

    signed int return_value_logformat_add$3;
    return_value_logformat_add$3=logformat_add(argv[(signed long int)0], argv[(signed long int)1]);
    return return_value_logformat_add$3;
  }
}

// cfg_set_logger
// file cfg_param.c line 506
signed int cfg_set_logger(const char *directive, const char **argv, void *setdata)
{
  struct logger_module *logger;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Missing arguments in directive\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Missing arguments in directive\n");

    }

    return 0;
  }

  else
  {
    logger=find_logger(argv[(signed long int)0]);
    if(logger == ((struct logger_module *)NULL))
      return 0;

    else
    {
      default_logger = logger;
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

      }

      return 1;
    }
  }
}

// cfg_set_tmp_dir
// file cfg_param.c line 521
signed int cfg_set_tmp_dir(const char *directive, const char **argv, void *setdata)
{
  signed int len;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    cfg_default_value_store((void *)&CI_CONF.TMPDIR, (void *)&CI_CONF.TMPDIR, (signed int)sizeof(char *) /*8ul*/ );
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(argv[(signed long int)0]);
    len = (signed int)return_value_strlen$2;
    void *return_value_ci_cfg_alloc_mem$3;
    return_value_ci_cfg_alloc_mem$3=ci_cfg_alloc_mem((signed int)((unsigned long int)(len + 2) * sizeof(char) /*1ul*/ ));
    CI_CONF.TMPDIR = (char *)return_value_ci_cfg_alloc_mem$3;
    strcpy(CI_CONF.TMPDIR, argv[(signed long int)0]);
    if(!((signed int)CI_CONF.TMPDIR[(signed long int)len] == 47))
    {
      CI_CONF.TMPDIR[(signed long int)len] = (char)47;
      CI_CONF.TMPDIR[(signed long int)(len + 1)] = (char)0;
    }

    CI_TMPDIR = CI_CONF.TMPDIR;
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

    }

    return 1;
  }
}

// cfg_shared_mem_scheme
// file cfg_param.c line 659
signed int cfg_shared_mem_scheme(const char *directive, const char **argv, void *setdata)
{
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
  {
    signed int return_value_ci_shared_mem_set_scheme$2;
    return_value_ci_shared_mem_set_scheme$2=ci_shared_mem_set_scheme(argv[(signed long int)0]);
    return return_value_ci_shared_mem_set_scheme$2;
  }
}

// cfg_srv_allow206
// file service.c line 202
signed int cfg_srv_allow206(const char *directive, const char **argv, void *setdata)
{
  struct ci_service_xdata *srv_xdata = (struct ci_service_xdata *)setdata;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Missing arguments in directive %s \n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Missing arguments in directive %s \n", directive);

    }

    return 0;
  }

  else
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

    }

    signed int return_value_strcasecmp$2;
    return_value_strcasecmp$2=strcasecmp(argv[(signed long int)0], "off");
    if(!(return_value_strcasecmp$2 == 0))
    {
      pthread_rwlock_wrlock(&srv_xdata->lock);
      srv_xdata->disable_206 = 1;
      pthread_rwlock_unlock(&srv_xdata->lock);
    }

    return 1;
  }
}

// cfg_srv_max_connections
// file service.c line 135
signed int cfg_srv_max_connections(const char *directive, const char **argv, void *setdata)
{
  signed int max_connections;
  char *end;
  struct ci_service_xdata *srv_xdata = (struct ci_service_xdata *)setdata;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Missing arguments in directive %s \n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Missing arguments in directive %s \n", directive);

    }

    return 0;
  }

  else
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 0;
    signed long long int return_value_strtoll$3;
    return_value_strtoll$3=strtoll(argv[(signed long int)0], &end, 10);
    max_connections = (signed int)return_value_strtoll$3;
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    if(!(*return_value___errno_location$4 == 0) || !(max_connections >= 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Invalid argument in directive %s \n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Invalid argument in directive %s \n", directive);

      }

      return 0;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Setting parameter :%s=%d\n", directive, max_connections);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Setting parameter :%s=%d\n", directive, max_connections);

      }

      ci_service_set_max_connections(srv_xdata, max_connections);
      return 1;
    }
  }
}

// cfg_srv_options_ttl
// file service.c line 155
signed int cfg_srv_options_ttl(const char *directive, const char **argv, void *setdata)
{
  signed int ttl;
  signed int u;
  char *end = (char *)(void *)0;
  const char *units;
  struct ci_service_xdata *srv_xdata = (struct ci_service_xdata *)setdata;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_strcasecmp$13;
  signed int return_value_strcasecmp$9;
  signed int return_value_strcasecmp$10;
  signed int return_value_strcasecmp$6;
  signed int return_value_strcasecmp$7;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Missing arguments in directive %s \n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Missing arguments in directive %s \n", directive);

    }

    return 0;
  }

  else
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 0;
    signed long long int return_value_strtoll$3;
    return_value_strtoll$3=strtoll(argv[(signed long int)0], &end, 10);
    ttl = (signed int)return_value_strtoll$3;
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    if(!(*return_value___errno_location$4 == 0) || !(ttl >= 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Invalid argument in directive %s \n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Invalid argument in directive %s \n", directive);

      }

      return 0;
    }

    else
    {
      _Bool tmp_if_expr$5;
      if(!(end == ((char *)NULL)))
        tmp_if_expr$5 = (signed int)*end != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(tmp_if_expr$5)
        units = end;

      else
        if(!(argv[1l] == ((const char *)NULL)))
          units = argv[(signed long int)1];

        else
          units = (const char *)(void *)0;
      if(!(units == ((const char *)NULL)))
      {
        signed int return_value_strcasecmp$12;
        return_value_strcasecmp$12=strcasecmp(units, "sec");
        _Bool tmp_if_expr$14;
        if(return_value_strcasecmp$12 == 0)
          tmp_if_expr$14 = (_Bool)1;

        else
        {
          return_value_strcasecmp$13=strcasecmp(units, "secs");
          tmp_if_expr$14 = return_value_strcasecmp$13 == 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$14)
          u = 1;

        else
        {
          return_value_strcasecmp$9=strcasecmp(units, "min");
          _Bool tmp_if_expr$11;
          if(return_value_strcasecmp$9 == 0)
            tmp_if_expr$11 = (_Bool)1;

          else
          {
            return_value_strcasecmp$10=strcasecmp(units, "mins");
            tmp_if_expr$11 = return_value_strcasecmp$10 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$11)
            u = 60;

          else
          {
            return_value_strcasecmp$6=strcasecmp(units, "hour");
            _Bool tmp_if_expr$8;
            if(return_value_strcasecmp$6 == 0)
              tmp_if_expr$8 = (_Bool)1;

            else
            {
              return_value_strcasecmp$7=strcasecmp(units, "hours");
              tmp_if_expr$8 = return_value_strcasecmp$7 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$8)
              u = 60 * 60;

            else
            {
              if(CI_DEBUG_LEVEL >= 1)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "Invalid units %s,  in directive %s \n", units, directive);

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("Invalid units %s,  in directive %s \n", units, directive);

              }

              return 0;
            }
          }
        }
      }

      else
        u = 1;
      ttl = ttl * u;
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Setting parameter :%s=%d\n", directive, ttl);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Setting parameter :%s=%d\n", directive, ttl);

      }

      ci_service_set_options_ttl(srv_xdata, ttl);
      return 1;
    }
  }
}

// cfg_srv_preview_size
// file service.c line 109
signed int cfg_srv_preview_size(const char *directive, const char **argv, void *setdata)
{
  signed int preview;
  char *end;
  struct ci_service_xdata *srv_xdata = (struct ci_service_xdata *)setdata;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Missing arguments in directive %s \n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Missing arguments in directive %s \n", directive);

    }

    return 0;
  }

  else
  {
    signed int return_value_strcmp$5;
    return_value_strcmp$5=strcmp(argv[(signed long int)0], "-");
    if(return_value_strcmp$5 == 0)
    {
      preview = -1;
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Setting parameter :%s=\"disable\"\n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Setting parameter :%s=\"disable\"\n", directive);

      }

    }

    else
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 0;
      signed long long int return_value_strtoll$3;
      return_value_strtoll$3=strtoll(argv[(signed long int)0], &end, 10);
      preview = (signed int)return_value_strtoll$3;
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      if(!(*return_value___errno_location$4 == 0) || !(preview >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Invalid argument in directive %s \n", directive);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Invalid argument in directive %s \n", directive);

        }

        return 0;
      }

      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Setting parameter :%s=%d\n", directive, preview);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Setting parameter :%s=%d\n", directive, preview);

      }

    }
    ci_service_set_preview(srv_xdata, preview);
    return 1;
  }
}

// cfg_srv_transfer_complete
// file service.c line 97
signed int cfg_srv_transfer_complete(const char *directive, const char **argv, void *setdata)
{
  struct ci_service_xdata *srv_xdata = (struct ci_service_xdata *)setdata;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Missing arguments in directive %s \n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Missing arguments in directive %s \n", directive);

    }

    return 0;
  }

  else
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

    }

    ci_service_set_transfer_complete(srv_xdata, argv[(signed long int)0]);
    return 1;
  }
}

// cfg_srv_transfer_ignore
// file service.c line 85
signed int cfg_srv_transfer_ignore(const char *directive, const char **argv, void *setdata)
{
  struct ci_service_xdata *srv_xdata = (struct ci_service_xdata *)setdata;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Missing arguments in directive %s \n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Missing arguments in directive %s \n", directive);

    }

    return 0;
  }

  else
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

    }

    ci_service_set_transfer_ignore(srv_xdata, argv[(signed long int)0]);
    return 1;
  }
}

// cfg_srv_transfer_preview
// file service.c line 73
signed int cfg_srv_transfer_preview(const char *directive, const char **argv, void *setdata)
{
  struct ci_service_xdata *srv_xdata = (struct ci_service_xdata *)setdata;
  _Bool tmp_if_expr$1;
  if(argv == ((const char **)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Missing arguments in directive %s \n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Missing arguments in directive %s \n", directive);

    }

    return 0;
  }

  else
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

    }

    ci_service_set_transfer_preview(srv_xdata, argv[(signed long int)0]);
    return 1;
  }
}

// check_ascii
// file filetype.c line 419
signed int check_ascii(unsigned char *buf, signed int buflen)
{
  unsigned int i;
  unsigned int res = (unsigned int)0;
  unsigned int type;
  i = (unsigned int)0;
  for( ; !(i >= (unsigned int)buflen); i = i + 1u)
  {
    type = (unsigned int)text_chars[(signed long int)buf[(signed long int)i]];
    if(type == 0u)
      return -1;

    res = res | type;
  }
  if(!(res >= 2u))
    return 0;

  else
    if(!(res >= 4u))
      return 1;

    else
      return 2;
}

// check_directive
// file txt_format.c line 200
signed int check_directive(const char *var, const char *directive, signed int *directive_len)
{
  const char *s1;
  const char *s2;
  s1 = var;
  s2 = directive + (signed long int)1;
  *directive_len = 0;
  for( ; !(*s2 == 0); s2 = s2 + 1l)
  {
    if(s1 == ((const char *)NULL))
      return 0;

    if(!(*s1 == *s2))
      return 0;

    s1 = s1 + 1l;
  }
  *directive_len = (signed int)(s1 - var);
  return 1;
}

// check_for_exited_childs
// file mpmt_server.c line 351
static void check_for_exited_childs()
{
  signed int status;
  signed int pid;
  signed int ret;
  signed int exit_status = 0;
  do
  {
    pid=waitpid(-1, &status, 1);
    if(!(pid >= 1))
      break;

    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Child %d died ...\n", pid);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Child %d died ...\n", pid);

    }

    if(!((0x7f & status) == 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Child %d did not exit normally.", pid);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Child %d did not exit normally.", pid);

      }

      exit_status = 1;
      if((signed int)((127 & (signed char)status) + 1) >> 1 >= 1)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          /* tag-#anon#lUN[lS32'__in'|S32'__i'] */
union anonymous$20
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
          ;
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "signaled with signal:%d\n", ((union anonymous$20){ .__in=status }).__i & 0x7f);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("signaled with signal:%d\n", ((union anonymous$20){ .__in=status }).__i & 0x7f);

        }

      }

    }

    ret=remove_child(childs_queue, pid, exit_status);
    if(ret == 0 && !(old_childs_queue == ((struct childs_queue *)NULL)))
    {
      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Child %d will be removed from the old list ...\n", pid);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Child %d will be removed from the old list ...\n", pid);

      }

      remove_child(old_childs_queue, pid, exit_status);
      signed int return_value_childs_queue_is_empty$1;
      return_value_childs_queue_is_empty$1=childs_queue_is_empty(old_childs_queue);
      if(!(return_value_childs_queue_is_empty$1 == 0))
      {
        ret=destroy_childs_queue(old_childs_queue);
        old_childs_queue = (struct childs_queue *)(void *)0;
      }

    }

  }
  while((_Bool)1);
  if(!(pid >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Fatal error waiting for a child to exit .....\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Fatal error waiting for a child to exit .....\n");

    }

  }

}

// check_magics
// file filetype.c line 368
signed int check_magics(struct ci_magics_db *db, const char *buf, signed int buflen)
{
  signed int i = 0;
  for( ; !(i >= db->magics_num); i = i + 1)
    if((unsigned long int)buflen >= (db->magics + (signed long int)i)->len + (unsigned long int)(db->magics + (signed long int)i)->offset)
    {
      signed int return_value_memcmp$1;
      return_value_memcmp$1=memcmp((const void *)(buf + (signed long int)(db->magics + (signed long int)i)->offset), (const void *)(db->magics + (signed long int)i)->magic, (db->magics + (signed long int)i)->len);
      if(return_value_memcmp$1 == 0)
        return (signed int)(db->magics + (signed long int)i)->type;

    }

  return -1;
}

// check_realloc
// file request_common.c line 874
static signed int check_realloc(char **buf, signed int *size, signed int used, signed int mustadded)
{
  char *newbuf;
  signed int len;
  while(!(*size + -used >= mustadded))
  {
    len = *size + 4096;
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)*buf, (unsigned long int)len);
    newbuf = (char *)return_value_realloc$1;
    if(newbuf == ((char *)NULL))
      return 11;

    *buf = newbuf;
    *size = *size + 4096;
  }
  return 1;
}

// check_reg
// file registry.c line 108
static signed int check_reg(void *data, const char *name, const void *val)
{
  struct check_reg_data *rdata = (struct check_reg_data *)data;
  rdata->count = rdata->count + 1;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(rdata->name, name);
  if(return_value_strcmp$1 == 0)
  {
    rdata->found = 1;
    return 1;
  }

  else
    return 0;
}

// check_request
// file request.c line 427
static signed int check_request(struct ci_request *req)
{
  if(req->entities[0l] == ((struct ci_encaps_entity *)NULL))
  {
    if(!((signed int)(req->type == 0) == 0x01))
      goto __CPROVER_DUMP_L1;

    return 4;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(CI_DEBUG_LEVEL >= 6)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        signed int tmp_if_expr$1;
        if(!(req->entities[0l] == ((struct ci_encaps_entity *)NULL)))
          tmp_if_expr$1 = req->entities[(signed long int)0]->type;

        else
          tmp_if_expr$1 = -1;
        signed int tmp_if_expr$2;
        if(!(req->entities[1l] == ((struct ci_encaps_entity *)NULL)))
          tmp_if_expr$2 = req->entities[(signed long int)1]->type;

        else
          tmp_if_expr$2 = -1;
        signed int tmp_if_expr$3;
        if(!(req->entities[2l] == ((struct ci_encaps_entity *)NULL)))
          tmp_if_expr$3 = req->entities[(signed long int)2]->type;

        else
          tmp_if_expr$3 = -1;
        signed int tmp_if_expr$4;
        if(!(req->entities[3l] == ((struct ci_encaps_entity *)NULL)))
          tmp_if_expr$4 = req->entities[(signed long int)3]->type;

        else
          tmp_if_expr$4 = -1;
        __log_error((void *)0, "\n type:%d Entities: %d %d %d %d \n", req->type, tmp_if_expr$1, tmp_if_expr$2, tmp_if_expr$3, tmp_if_expr$4);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        signed int tmp_if_expr$5;
        if(!(req->entities[0l] == ((struct ci_encaps_entity *)NULL)))
          tmp_if_expr$5 = req->entities[(signed long int)0]->type;

        else
          tmp_if_expr$5 = -1;
        signed int tmp_if_expr$6;
        if(!(req->entities[1l] == ((struct ci_encaps_entity *)NULL)))
          tmp_if_expr$6 = req->entities[(signed long int)1]->type;

        else
          tmp_if_expr$6 = -1;
        signed int tmp_if_expr$7;
        if(!(req->entities[2l] == ((struct ci_encaps_entity *)NULL)))
          tmp_if_expr$7 = req->entities[(signed long int)2]->type;

        else
          tmp_if_expr$7 = -1;
        signed int tmp_if_expr$8;
        if(!(req->entities[3l] == ((struct ci_encaps_entity *)NULL)))
          tmp_if_expr$8 = req->entities[(signed long int)3]->type;

        else
          tmp_if_expr$8 = -1;
        printf("\n type:%d Entities: %d %d %d %d \n", req->type, tmp_if_expr$5, tmp_if_expr$6, tmp_if_expr$7, tmp_if_expr$8);
      }

    }

    if(req->type == 0x02)
    {
      if(!(req->entities[2l] == ((struct ci_encaps_entity *)NULL)))
        return 4;

      else
        if(!(req->entities[1l] == ((struct ci_encaps_entity *)NULL)))
        {
          if(!(req->entities[0l]->type == 0))
            return 4;

          if(!(req->entities[1l]->type == 2))
          {
            if(!(req->entities[1l]->type == 4))
              return 4;

          }

        }

        else
          if(!(req->entities[0l]->type == 2))
            return 4;

    }

    else
      if(req->type == 0x04)
      {
        if(!(req->entities[3l] == ((struct ci_encaps_entity *)NULL)))
          return 4;

        else
          if(!(req->entities[2l] == ((struct ci_encaps_entity *)NULL)))
          {
            if(!(req->entities[0l]->type == 0))
              return 4;

            if(!(req->entities[1l]->type == 1))
              return 4;

            if(!(req->entities[2l]->type == 3))
            {
              if(!(req->entities[2l]->type == 4))
                return 4;

            }

          }

          else
            if(!(req->entities[1l] == ((struct ci_encaps_entity *)NULL)))
            {
              if(!(req->entities[0l]->type == 1))
              {
                if(!(req->entities[0l]->type == 0))
                  return 4;

              }

              if(!(req->entities[1l]->type == 3))
              {
                if(!(req->entities[1l]->type == 4))
                  return 4;

              }

            }

            else
              if(!(req->entities[0l]->type == 3))
                return 4;

      }

    return 0;
  }
}

// check_request$link1
// file access.c line 69
signed int check_request$link1(struct ci_request *req$link1)
{
  signed int res;
  signed int i = 0;
  for( ; !(used_access_controllers[(signed long int)i] == ((struct access_control_module *)NULL)); i = i + 1)
    if(!(used_access_controllers[(signed long int)i]->request_access == ((signed int (*)(struct ci_request *))NULL)))
    {
      res=used_access_controllers[(signed long int)i]->request_access(req$link1);
      if(!(res == 0))
        return res;

    }

  return 1;
}

// check_tables
// file txt_format.c line 218
struct ci_fmt_entry * check_tables(const char *var, struct ci_fmt_entry *u_table, signed int *directive_len, unsigned int *width, signed int *left_align, char *parameter)
{
  signed int i;
  unsigned int params_len;
  params_len=parse_directive(var, width, left_align, parameter);
  i = 0;
  for( ; !(GlobalTable[(signed long int)i].directive == ((const char *)NULL)); i = i + 1)
  {
    signed int return_value_check_directive$1;
    return_value_check_directive$1=check_directive(var + (signed long int)params_len, GlobalTable[(signed long int)i].directive, directive_len);
    if(!(return_value_check_directive$1 == 0))
    {
      *directive_len = *directive_len + (signed int)params_len;
      return &GlobalTable[(signed long int)i];
    }

  }
  if(!(u_table == ((struct ci_fmt_entry *)NULL)))
  {
    i = 0;
    for( ; !((u_table + (signed long int)i)->directive == ((const char *)NULL)); i = i + 1)
    {
      signed int return_value_check_directive$2;
      return_value_check_directive$2=check_directive(var + (signed long int)params_len, (u_table + (signed long int)i)->directive, directive_len);
      if(!(return_value_check_directive$2 == 0))
      {
        *directive_len = *directive_len + (signed int)params_len;
        return &u_table[(signed long int)i];
      }

    }
  }

  return (struct ci_fmt_entry *)(void *)0;
}

// check_to_add_method_id
// file module.c line 465
signed int check_to_add_method_id(struct auth_hash *hash, signed int method_id)
{
  struct authenticator_module ***new_mem;
  if(method_id >= 257 || !(method_id >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Method id is %d. Possible bug, please report it to developers!!!!!!\n", method_id);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Method id is %d. Possible bug, please report it to developers!!!!!!\n", method_id);

    }

    return 0;
  }

  else
  {
    while(!(hash->hash_size >= method_id))
    {
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)hash->hash, (unsigned long int)(hash->hash_size + 20));
      new_mem = (struct authenticator_module ***)return_value_realloc$1;
      if(new_mem == ((struct authenticator_module ***)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error allocating memory for authenticator hash!!!!!!\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error allocating memory for authenticator hash!!!!!!\n");

        }

        return 0;
      }

      memset((void *)(hash->hash + (signed long int)hash->hash_size), 0, (unsigned long int)20);
      hash->hash = new_mem;
      hash->hash_size = hash->hash_size + 20;
    }
    return 1;
  }
}

// check_unicode
// file filetype.c line 495
signed int check_unicode(unsigned char *buf, signed int buflen)
{
  signed int i;
  signed int ret = 0;
  signed int endian = 0;
  i = 0;
  for( ; !(i >= buflen); i = i + ret)
  {
    ret=isUTF8(buf + (signed long int)i, buflen - i);
    if(!(ret >= 1))
      break;

  }
  if(i == 0 && !(ret >= 0))
    ret = 0;

  if(!(ret == 0))
    return 3;

  else
    if(!(buflen >= 2))
      return -1;

    else
    {
      _Bool tmp_if_expr$2;
      if((signed int)*buf == 0xff)
        tmp_if_expr$2 = (signed int)buf[(signed long int)1] == 0xfe ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        endian = 0;

      else
      {
        _Bool tmp_if_expr$1;
        if((signed int)*buf == 0xfe)
          tmp_if_expr$1 = (signed int)buf[(signed long int)1] == 0xff ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
          endian = 1;

        else
          return -1;
      }
      i = 2;
      for( ; !(i >= buflen); i = i + 2)
        if(!(endian == 0))
        {
          if((signed int)buf[(signed long int)i] == 0)
          {
            if(!((signed int)buf[(signed long int)(1 + i)] >= 128))
            {
              if(!((signed int)text_chars[(signed long int)buf[(signed long int)(1 + i)]] == 1))
                return -1;

            }

          }

        }

        else
          if((signed int)buf[(signed long int)(1 + i)] == 0)
          {
            if(!((signed int)buf[(signed long int)i] >= 128))
            {
              if(!((signed int)text_chars[(signed long int)buf[(signed long int)i]] == 1))
                return -1;

            }

          }

      return 3;
    }
}

// check_user_group
// file http_auth.c line 211
signed int check_user_group(const char *user, const char *group)
{
  struct group_source *gsrc;
  char **users;
  char **groups;
  void *ret;
  signed int i;
  gsrc = GROUPS_SOURCE;
  if(!(gsrc == ((struct group_source *)NULL)))
  {
    if(gsrc->db == ((struct ci_lookup_table *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "The lookup-table in group source %s is not open!", gsrc->name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("The lookup-table in group source %s is not open!", gsrc->name);

      }

      return 0;
    }

    if(gsrc->type == 1)
    {
      ret=gsrc->db->search(gsrc->db, (void *)(char *)user, (void ***)&groups);
      if(!(ret == NULL))
      {
        i = 0;
        if(!(groups[(signed long int)i] == ((char *)NULL)))
        {
          signed int return_value_strcmp$1;
          return_value_strcmp$1=strcmp(group, groups[(signed long int)i]);
          if(return_value_strcmp$1 == 0)
          {
            gsrc->db->release_result(gsrc->db, (void **)groups);
            return 1;
          }

          i = i + 1;
        }

        gsrc->db->release_result(gsrc->db, (void **)groups);
        return 0;
      }

    }

    else
    {
      ret=gsrc->db->search(gsrc->db, (void *)(char *)group, (void ***)&users);
      if(!(ret == NULL))
      {
        i = 0;
        if(!(users[(signed long int)i] == ((char *)NULL)))
        {
          signed int return_value_strcmp$2;
          return_value_strcmp$2=strcmp(user, users[(signed long int)i]);
          if(return_value_strcmp$2 == 0)
          {
            gsrc->db->release_result(gsrc->db, (void **)users);
            return 1;
          }

          i = i + 1;
        }

        gsrc->db->release_result(gsrc->db, (void **)users);
        return 0;
      }

    }
    gsrc = gsrc->next;
  }

  return 0;
}

// child_main
// file mpmt_server.c line 848
void child_main(signed int sockfd, signed int pipefd)
{
  unsigned long int thread;
  signed int i;
  signed int ret;
  signal(15, (void (*)(signed int))1);
  ci_thread_mutex_init(&threads_list_mtx);
  ci_thread_mutex_init(&counters_mtx);
  ci_thread_cond_init(&free_server_cond);
  ci_stat_attach_mem((void *)child_data->stats, child_data->stats_size, (void (*)(void *))(void *)0);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(CI_CONF.THREADS_PER_CHILD + 1) * sizeof(struct server_decl *) /*8ul*/ );
  threads_list = (struct server_decl **)return_value_malloc$1;
  con_queue=init_queue(CI_CONF.THREADS_PER_CHILD);
  i = 0;
  for( ; !(i >= CI_CONF.THREADS_PER_CHILD); i = i + 1)
  {
    threads_list[(signed long int)i]=newthread(con_queue);
    if(threads_list[(signed long int)i] == ((struct server_decl *)NULL))
      exit(-1);

    ret=ci_thread_create(&thread, (void * (*)(void *))thread_main, (void *)threads_list[(signed long int)i]);
    threads_list[(signed long int)i]->srv_pthread = thread;
  }
  threads_list[(signed long int)CI_CONF.THREADS_PER_CHILD] = (struct server_decl *)(void *)0;
  ret=ci_thread_create(&thread, (void * (*)(void *))listener_thread, (void *)&sockfd);
  listener_thread_id = thread;
  signed long int return_value_time$2;
  return_value_time$2=time((signed long int *)(void *)0);
  signed int return_value_getpid$3;
  return_value_getpid$3=getpid();
  srand((unsigned int)return_value_time$2 + (unsigned int)return_value_getpid$3);
  child_signals();
  if(!(child_data->father_said == 0))
    child_data->to_be_killed = 2;

  commands_execute_start_child();
  signed int doStart = 0;
  do
  {
    pthread_mutex_lock(&counters_mtx);
    doStart = listener_running;
    pthread_mutex_unlock(&counters_mtx);
    if(doStart == 0)
      ci_usleep((unsigned long int)5);

  }
  while(doStart == 0);
  pthread_cond_signal(&free_server_cond);
  while(child_data->to_be_killed == 0)
  {
    char buf[512l];
    signed int bytes;
    ret=ci_wait_for_data(pipefd, 1, 0x1);
    if(ret >= 1)
    {
      bytes=ci_read_nonblock(pipefd, (void *)buf, (unsigned long int)511);
      if(bytes == 0)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Parent closed the pipe connection! Going to term immediately!\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Parent closed the pipe connection! Going to term immediately!\n");

        }

        child_data->to_be_killed = 2;
      }

      else
      {
        buf[(signed long int)bytes] = (char)0;
        handle_child_process_commands(buf);
      }
    }

    else
      if(!(ret >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "An error occured while waiting for commands from parent. Terminating!\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("An error occured while waiting for commands from parent. Terminating!\n");

        }

        child_data->to_be_killed = 2;
      }

    if(listener_running == 0)
    {
      if(child_data->to_be_killed == 0)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Ohh!! something happened to listener thread! Terminating\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Ohh!! something happened to listener thread! Terminating\n");

        }

        child_data->to_be_killed = 1;
      }

    }

    commands_exec_scheduled();
  }
  signed int return_value_getpid$4;
  signed int return_value_getpid$5;
  if(CI_DEBUG_LEVEL >= 5)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
    {
      return_value_getpid$4=getpid();
      __log_error((void *)0, "Child :%d going down :%s\n", return_value_getpid$4, child_data->to_be_killed == 2 ? "IMMEDIATELY" : "GRACEFULLY");
    }

    if(!(CI_DEBUG_STDOUT == 0))
    {
      return_value_getpid$5=getpid();
      printf("Child :%d going down :%s\n", return_value_getpid$5, child_data->to_be_killed == 2 ? "IMMEDIATELY" : "GRACEFULLY");
    }

  }

  cancel_all_threads();
  commands_execute_stop_child();
  exit_normaly();
}

// child_signals
// file mpmt_server.c line 140
void child_signals()
{
  signal(13, sigpipe_handler);
  signal(2, (void (*)(signed int))1);
  signal(15, term_handler_child);
  signal(1, empty);
}

// childs_queue_is_empty
// file proc_threads_queues.c line 219
signed int childs_queue_is_empty(struct childs_queue *q)
{
  signed int i = 0;
  for( ; !(i >= q->size); i = i + 1)
    if(!((q->childs + (signed long int)i)->pid == 0))
      return 0;

  return 1;
}

// childs_queue_stats
// file proc_threads_queues.c line 376
signed int childs_queue_stats(struct childs_queue *q, signed int *childs, signed int *freeservers, signed int *used, signed int *maxrequests)
{
  signed int i;
  *childs = 0;
  *freeservers = 0;
  *used = 0;
  *maxrequests = 0;
  if(q->childs == ((struct child_shared_data *)NULL))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= q->size); i = i + 1)
      if(!((q->childs + (signed long int)i)->pid == 0))
      {
        if((q->childs + (signed long int)i)->to_be_killed == 0)
        {
          *childs = *childs + 1;
          *freeservers = *freeservers + (q->childs + (signed long int)i)->freeservers;
          *used = *used + (q->childs + (signed long int)i)->usedservers;
          *maxrequests = *maxrequests + (q->childs + (signed long int)i)->requests;
        }

      }

    *maxrequests = *maxrequests + old_requests;
    return 1;
  }
}

// ci_MD5Final
// file md5.c line 107
void ci_MD5Final(unsigned char *digest, struct ci_MD5Context *ctx)
{
  unsigned int count;
  unsigned char *p;
  unsigned int *uin;
  count = ctx->bits[(signed long int)0] >> 3 & (unsigned int)0x3F;
  p = ctx->in + (signed long int)count;
  unsigned char *tmp_post$1 = p;
  p = p + 1l;
  *tmp_post$1 = (unsigned char)0x80;
  count = (unsigned int)(64 - 1) - count;
  if(!(count >= 8u))
  {
    memset((void *)p, 0, (unsigned long int)count);
    byteReverse(ctx->in, (unsigned int)16);
    MD5Transform(ctx->buf, (unsigned int *)ctx->in);
    memset((void *)ctx->in, 0, (unsigned long int)56);
  }

  else
    memset((void *)p, 0, (unsigned long int)(count - (unsigned int)8));
  byteReverse(ctx->in, (unsigned int)14);
  uin = (unsigned int *)ctx->in;
  uin[(signed long int)14] = ctx->bits[(signed long int)0];
  uin[(signed long int)15] = ctx->bits[(signed long int)1];
  MD5Transform(ctx->buf, (unsigned int *)ctx->in);
  byteReverse((unsigned char *)ctx->buf, (unsigned int)4);
  memcpy((void *)digest, (const void *)ctx->buf, (unsigned long int)16);
  memset((void *)ctx, 0, sizeof(struct ci_MD5Context) /*88ul*/ );
}

// ci_MD5Init
// file md5.c line 44
void ci_MD5Init(struct ci_MD5Context *ctx)
{
  ctx->buf[(signed long int)0] = (unsigned int)0x67452301;
  ctx->buf[(signed long int)1] = 0xefcdab89;
  ctx->buf[(signed long int)2] = 0x98badcfe;
  ctx->buf[(signed long int)3] = (unsigned int)0x10325476;
  ctx->bits[(signed long int)0] = (unsigned int)0;
  ctx->bits[(signed long int)1] = (unsigned int)0;
}

// ci_MD5Update
// file md5.c line 59
void ci_MD5Update(struct ci_MD5Context *ctx, const unsigned char *buf, unsigned long int len)
{
  unsigned int t = ctx->bits[(signed long int)0];
  ctx->bits[(signed long int)0] = t + ((unsigned int)len << 3);
  if(!(ctx->bits[0l] >= t))
    ctx->bits[(signed long int)1] = ctx->bits[(signed long int)1] + 1u;

  ctx->bits[(signed long int)1] = ctx->bits[(signed long int)1] + (unsigned int)(len >> 29);
  t = t >> 3 & (unsigned int)0x3f;
  if(!(t == 0u))
  {
    unsigned char *p = (unsigned char *)ctx->in + (signed long int)t;
    t = (unsigned int)64 - t;
    if(!(len >= (unsigned long int)t))
    {
      memcpy((void *)p, (const void *)buf, len);
      goto __CPROVER_DUMP_L5;
    }

    memcpy((void *)p, (const void *)buf, (unsigned long int)t);
    byteReverse(ctx->in, (unsigned int)16);
    MD5Transform(ctx->buf, (unsigned int *)ctx->in);
    buf = buf + (signed long int)t;
    len = len - (unsigned long int)t;
  }

  for( ; len >= 64ul; len = len - (unsigned long int)64)
  {
    memcpy((void *)ctx->in, (const void *)buf, (unsigned long int)64);
    byteReverse(ctx->in, (unsigned int)16);
    MD5Transform(ctx->buf, (unsigned int *)ctx->in);
    buf = buf + (signed long int)64;
  }
  memcpy((void *)ctx->in, (const void *)buf, len);

__CPROVER_DUMP_L5:
  ;
}

// ci_access_entry_add_acl
// file acl.c line 468
const struct ci_acl_spec * ci_access_entry_add_acl(struct ci_access_entry *access_entry, const struct ci_acl_spec *acl, signed int negate)
{
  struct ci_specs_list *spec_list;
  struct ci_specs_list *spec_entry;
  if(access_entry == ((struct ci_access_entry *)NULL))
    return (const struct ci_acl_spec *)(void *)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct ci_specs_list) /*24ul*/ );
    spec_entry = (struct ci_specs_list *)return_value_malloc$1;
    if(spec_entry == ((struct ci_specs_list *)NULL))
      return (const struct ci_acl_spec *)(void *)0;

    else
    {
      spec_entry->next = (struct ci_specs_list *)(void *)0;
      spec_entry->negate = negate;
      spec_entry->spec = acl;
      if(access_entry->spec_list == ((struct ci_specs_list *)NULL))
        access_entry->spec_list = spec_entry;

      else
      {
        spec_list = access_entry->spec_list;
        for( ; !(spec_list->next == ((struct ci_specs_list *)NULL)); spec_list = spec_list->next)
          ;
        spec_list->next = spec_entry;
      }
      return acl;
    }
  }
}

// ci_access_entry_add_acl_by_name
// file include/acl.h line 178
signed int ci_access_entry_add_acl_by_name(struct ci_access_entry *access_entry, const char *acl_name)
{
  const struct ci_acl_spec *acl;
  signed int negate = 0;
  if((signed int)*acl_name == 33)
  {
    negate = 1;
    acl_name = acl_name + (signed long int)1;
  }

  acl=ci_acl_search(acl_name);
  if(acl == ((const struct ci_acl_spec *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "The acl spec %s does not exists!\n", acl_name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("The acl spec %s does not exists!\n", acl_name);

    }

    return 0;
  }

  else
  {
    const struct ci_acl_spec *return_value_ci_access_entry_add_acl$1;
    return_value_ci_access_entry_add_acl$1=ci_access_entry_add_acl(access_entry, acl, negate);
    if(return_value_ci_access_entry_add_acl$1 == ((const struct ci_acl_spec *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error adding acl spec %s to the access list!\n", acl_name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error adding acl spec %s to the access list!\n", acl_name);

      }

      return 0;
    }

    else
      return 1;
  }
}

// ci_access_entry_match_request
// file include/acl.h line 188
signed int ci_access_entry_match_request(struct ci_access_entry *access_entry, struct ci_request *req)
{
  struct ci_specs_list *spec_list;
  signed int return_value_request_match_specslist$1;
  if(access_entry == ((struct ci_access_entry *)NULL))
    return 1;

  else
  {
    while(!(access_entry == ((struct ci_access_entry *)NULL)))
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Check request with an access entry\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Check request with an access entry\n");

      }

      spec_list = access_entry->spec_list;
      if(!(spec_list == ((struct ci_specs_list *)NULL)))
      {
        if(!(spec_list->spec == ((const struct ci_acl_spec *)NULL)))
        {
          return_value_request_match_specslist$1=request_match_specslist(req, spec_list);
          if(!(return_value_request_match_specslist$1 == 0))
            return access_entry->type;

        }

      }

      access_entry = access_entry->next;
    }
    return 0;
  }
}

// ci_access_entry_new
// file include/acl.h line 158
struct ci_access_entry * ci_access_entry_new(struct ci_access_entry **list, signed int type)
{
  struct ci_access_entry *access_entry;
  struct ci_access_entry *cur;
  if(list == ((struct ci_access_entry **)NULL))
    return (struct ci_access_entry *)(void *)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct ci_access_entry) /*24ul*/ );
    access_entry = (struct ci_access_entry *)return_value_malloc$1;
    if(access_entry == ((struct ci_access_entry *)NULL))
      return (struct ci_access_entry *)(void *)0;

    else
    {
      access_entry->type = type;
      access_entry->spec_list = (struct ci_specs_list *)(void *)0;
      access_entry->next = (struct ci_access_entry *)(void *)0;
      if(*list == ((struct ci_access_entry *)NULL))
        *list = access_entry;

      else
      {
        cur = *list;
        for( ; !(cur->next == ((struct ci_access_entry *)NULL)); cur = cur->next)
          ;
        cur->next = access_entry;
      }
      return access_entry;
    }
  }
}

// ci_access_entry_release
// file include/acl.h line 166
void ci_access_entry_release(struct ci_access_entry *list)
{
  struct ci_access_entry *access_entry;
  struct ci_specs_list *spec_list;
  struct ci_specs_list *cur;
  if(!(list == ((struct ci_access_entry *)NULL)))
  {
    access_entry = list;
    while(!(list == ((struct ci_access_entry *)NULL)))
    {
      access_entry = list;
      list = list->next;
      spec_list = access_entry->spec_list;
      while(!(spec_list == ((struct ci_specs_list *)NULL)))
      {
        cur = spec_list;
        spec_list = spec_list->next;
        free((void *)cur);
      }
      free((void *)access_entry);
    }
  }

}

// ci_acl_add_data
// file include/acl.h line 206
signed int ci_acl_add_data(const char *name, const char *type, const char *data)
{
  struct ci_acl_spec *spec;
  const struct ci_acl_type *spec_type;
  char *s;
  char *param = (char *)(void *)0;
  char *acl_type;
  acl_type=strdup(type);
  if(acl_type == ((char *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "cfg_acl_add: error strduping!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("cfg_acl_add: error strduping!\n");

    }

    return 0;
  }

  else
  {
    s = acl_type;
    s=strchr(s, 123);
    if(!(s == ((char *)NULL)))
    {
      *s = (char)0;
      param = s + (signed long int)1;
      s=strchr(param, 125);
      if(!(s == ((char *)NULL)))
        *s = (char)0;

    }

    spec=ci_acl_spec_search(specs_list, name);
    if(!(spec == ((struct ci_acl_spec *)NULL)))
    {
      spec_type=ci_acl_type_search(acl_type);
      if(!(spec_type == spec->type))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "The acl type:%s does not match with type of existing acl \"%s\"", acl_type, name);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("The acl type:%s does not match with type of existing acl \"%s\"", acl_type, name);

        }

        free((void *)acl_type);
        return 0;
      }

    }

    else
      spec=ci_acl_spec_new(name, acl_type, param, &types_list, &specs_list);
    free((void *)acl_type);
    if(spec == ((struct ci_acl_spec *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error in acl:%s! Maybe the acl type \"%s\" does not exists!\n", name, acl_type);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error in acl:%s! Maybe the acl type \"%s\" does not exists!\n", name, acl_type);

      }

      return 0;
    }

    else
    {
      ci_acl_spec_new_data(spec, data);
      return 1;
    }
  }
}

// ci_acl_init
// file include/acl.h line 197
void ci_acl_init()
{
  ci_acl_typelist_init(&types_list);
  acl_load_defaults();
  specs_list = (struct ci_acl_spec *)(void *)0;
}

// ci_acl_reset
// file include/acl.h line 203
void ci_acl_reset()
{
  ci_acl_spec_list_release(specs_list);
  specs_list = (struct ci_acl_spec *)(void *)0;
  ci_acl_typelist_reset(&types_list);
  acl_load_defaults();
}

// ci_acl_search
// file include/acl.h line 205
const struct ci_acl_spec * ci_acl_search(const char *name)
{
  struct ci_acl_spec *return_value_ci_acl_spec_search$1;
  return_value_ci_acl_spec_search$1=ci_acl_spec_search(specs_list, name);
  return (const struct ci_acl_spec *)return_value_ci_acl_spec_search$1;
}

// ci_acl_spec_list_release
// file acl.c line 615
void ci_acl_spec_list_release(struct ci_acl_spec *spec)
{
  struct ci_acl_spec *cur;
  while(!(spec == ((struct ci_acl_spec *)NULL)))
  {
    cur = spec;
    spec = spec->next;
    ci_acl_spec_release(cur);
  }
}

// ci_acl_spec_new
// file acl.c line 514
struct ci_acl_spec * ci_acl_spec_new(const char *name, const char *type, const char *param, struct ci_acl_type_list *list, struct ci_acl_spec **spec_list)
{
  struct ci_acl_spec *spec;
  struct ci_acl_spec *cur;
  const struct ci_acl_type *acl_type;
  acl_type=ci_acl_typelist_search(list, type);
  if(acl_type == ((const struct ci_acl_type *)NULL))
    return (struct ci_acl_spec *)(void *)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct ci_acl_spec) /*64ul*/ );
    spec = (struct ci_acl_spec *)return_value_malloc$1;
    if(spec == ((struct ci_acl_spec *)NULL))
      return (struct ci_acl_spec *)(void *)0;

    else
    {
      strncpy(spec->name, name, (unsigned long int)31);
      spec->name[(signed long int)31] = (char)0;
      if(!(param == ((const char *)NULL)))
      {
        spec->parameter=strdup(param);
        if(spec->parameter == ((char *)NULL))
        {
          free((void *)spec);
          return (struct ci_acl_spec *)(void *)0;
        }

      }

      else
        spec->parameter = (char *)(void *)0;
      spec->type = acl_type;
      spec->data = (struct ci_acl_data *)(void *)0;
      spec->next = (struct ci_acl_spec *)(void *)0;
      if(!(spec_list == ((struct ci_acl_spec **)NULL)))
      {
        if(!(*spec_list == ((struct ci_acl_spec *)NULL)))
        {
          cur = *spec_list;
          for( ; !(cur->next == ((struct ci_acl_spec *)NULL)); cur = cur->next)
            ;
          cur->next = spec;
        }

        else
          *spec_list = spec;
      }

      return spec;
    }
  }
}

// ci_acl_spec_new_data
// file acl.c line 552
struct ci_acl_data * ci_acl_spec_new_data(struct ci_acl_spec *spec, const char *val)
{
  struct ci_acl_data *new_data;
  struct ci_acl_data *list;
  const struct ci_type_ops *ops;
  void *data;
  if(spec == ((struct ci_acl_spec *)NULL))
    return (struct ci_acl_data *)(void *)0;

  else
  {
    ops = spec->type->type;
    data=ops->dup(val, default_allocator);
    if(data == NULL)
      return (struct ci_acl_data *)(void *)0;

    else
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(struct ci_acl_data) /*16ul*/ );
      new_data = (struct ci_acl_data *)return_value_malloc$1;
      if(new_data == ((struct ci_acl_data *)NULL))
      {
        ops->free(data, default_allocator);
        return (struct ci_acl_data *)(void *)0;
      }

      else
      {
        new_data->data = data;
        new_data->next = (struct ci_acl_data *)(void *)0;
        list = spec->data;
        if(!(list == ((struct ci_acl_data *)NULL)))
        {
          if(!(list->next == ((struct ci_acl_data *)NULL)))
            list = list->next;

          list->next = new_data;
        }

        else
          spec->data = new_data;
        return new_data;
      }
    }
  }
}

// ci_acl_spec_release
// file acl.c line 601
void ci_acl_spec_release(struct ci_acl_spec *cur)
{
  struct ci_acl_data *dhead;
  struct ci_acl_data *dtmp;
  const struct ci_type_ops *ops;
  dhead = cur->data;
  ops = cur->type->type;
  if(!(dhead == ((struct ci_acl_data *)NULL)))
  {
    dtmp = dhead;
    dhead = dhead->next;
    ops->free(dtmp->data, default_allocator);
    free((void *)dtmp);
  }

}

// ci_acl_spec_search
// file acl.c line 583
struct ci_acl_spec * ci_acl_spec_search(struct ci_acl_spec *list, const char *name)
{
  struct ci_acl_spec *spec;
  if(CI_DEBUG_LEVEL >= 9)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "In search specs list %p,name %s\n", list, name);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("In search specs list %p,name %s\n", list, name);

  }

  if(name == ((const char *)NULL) || list == ((struct ci_acl_spec *)NULL))
    return (struct ci_acl_spec *)(void *)0;

  else
  {
    spec = list;
    while(!(spec == ((struct ci_acl_spec *)NULL)))
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Checking name:%s with specname %s\n", name, (const void *)spec->name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Checking name:%s with specname %s\n", name, (const void *)spec->name);

      }

      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(spec->name, name);
      if(return_value_strcmp$1 == 0)
        return spec;

      spec = spec->next;
    }
    return (struct ci_acl_spec *)(void *)0;
  }
}

// ci_acl_type_add
// file include/acl.h line 224
signed int ci_acl_type_add(const struct ci_acl_type *type)
{
  signed int return_value_ci_acl_typelist_add$1;
  return_value_ci_acl_typelist_add$1=ci_acl_typelist_add(&types_list, type);
  return return_value_ci_acl_typelist_add$1;
}

// ci_acl_type_search
// file acl.c line 815
const struct ci_acl_type * ci_acl_type_search(const char *name)
{
  const struct ci_acl_type *return_value_ci_acl_typelist_search$1;
  return_value_ci_acl_typelist_search$1=ci_acl_typelist_search(&types_list, name);
  return return_value_ci_acl_typelist_search$1;
}

// ci_acl_typelist_add
// file acl.c line 638
signed int ci_acl_typelist_add(struct ci_acl_type_list *list, const struct ci_acl_type *type)
{
  struct ci_acl_type *cur;
  struct ci_acl_type *nl = (struct ci_acl_type *)(void *)0;
  {
    const struct ci_acl_type *return_value_ci_acl_typelist_search$1;
    return_value_ci_acl_typelist_search$1=ci_acl_typelist_search(list, type->name);
    if(!(return_value_ci_acl_typelist_search$1 == ((const struct ci_acl_type *)NULL)))
    {
      if(CI_DEBUG_LEVEL >= 3)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "The acl type %s already defined\n", (const void *)type->name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("The acl type %s already defined\n", (const void *)type->name);

      }

      return 0;
    }

    else
    {
      if(list->acl_type_list_num == list->acl_type_list_size)
      {
        list->acl_type_list_size = list->acl_type_list_size + 32;
        void *return_value_realloc$2;
        return_value_realloc$2=realloc((void *)list->acl_type_list, (unsigned long int)list->acl_type_list_size * sizeof(struct ci_acl_type) /*56ul*/ );
        nl = (struct ci_acl_type *)return_value_realloc$2;
        if(nl == ((struct ci_acl_type *)NULL))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Failed to allocate more space for new ci_acl_typr_t\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Failed to allocate more space for new ci_acl_typr_t\n");

          }

          return 0;
        }

        list->acl_type_list = nl;
      }

      cur = &list->acl_type_list[(signed long int)list->acl_type_list_num];
      strncpy(cur->name, type->name, (unsigned long int)31);
      cur->name[(signed long int)31] = (char)0;
      cur->type = type->type;
      cur->get_test_data = type->get_test_data;
      list->acl_type_list_num = list->acl_type_list_num + 1;
      return 1;
    }
  }
}

// ci_acl_typelist_init
// file acl.c line 630
signed int ci_acl_typelist_init(struct ci_acl_type_list *list)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)32 * sizeof(struct ci_acl_type) /*56ul*/ );
  list->acl_type_list = (struct ci_acl_type *)return_value_malloc$1;
  list->acl_type_list_size = 32;
  list->acl_type_list_num = 0;
  return 1;
}

// ci_acl_typelist_release
// file acl.c line 681
signed int ci_acl_typelist_release(struct ci_acl_type_list *list)
{
  free((void *)list->acl_type_list);
  list->acl_type_list_size = 0;
  list->acl_type_list_num = 0;
  return 1;
}

// ci_acl_typelist_reset
// file acl.c line 689
signed int ci_acl_typelist_reset(struct ci_acl_type_list *list)
{
  list->acl_type_list_num = 0;
  return 1;
}

// ci_acl_typelist_search
// file acl.c line 671
const struct ci_acl_type * ci_acl_typelist_search(struct ci_acl_type_list *list, const char *name)
{
  signed int i = 0;
  for( ; !(i >= list->acl_type_list_num); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((list->acl_type_list + (signed long int)i)->name, name);
    if(return_value_strcmp$1 == 0)
      return (const struct ci_acl_type *)&list->acl_type_list[(signed long int)i];

  }
  return (const struct ci_acl_type *)(void *)0;
}

// ci_args_apply
// file include/cfg_param.h line 200
signed int ci_args_apply(signed int argc, char **argv, struct ci_options_entry *options)
{
  signed int i;
  struct ci_options_entry *entry;
  const char *act_args[2l];
  act_args[(signed long int)1] = (const char *)(void *)0;
  i = 1;
  if(!(i >= argc))
  {
    entry=search_options_table(argv[(signed long int)i], options);
    if(entry == ((struct ci_options_entry *)NULL))
      return 0;

    if(!(entry->parameter == ((const char *)NULL)))
    {
      i = i + 1;
      if(i >= argc)
        return 0;

      act_args[(signed long int)0] = argv[(signed long int)i];
      entry->action(entry->name, act_args, entry->data);
    }

    else
    {
      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(entry->name, "$$");
      if(return_value_strcmp$1 == 0)
      {
        act_args[(signed long int)0] = argv[(signed long int)i];
        entry->action(entry->name, act_args, entry->data);
      }

      else
        entry->action(entry->name, (const char **)(void *)0, entry->data);
    }
    i = i + 1;
  }

  return 1;
}

// ci_args_usage
// file include/cfg_param.h line 199
void ci_args_usage(const char *progname, struct ci_options_entry *options)
{
  signed int i;
  printf("Usage : \n");
  printf("%s", progname);
  i = 0;
  for( ; !((options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
    if((signed int)*(options + (signed long int)i)->name == 36)
      printf(" [file1] [file2] ...");

    else
    {
      char *tmp_if_expr$1;
      if((options + (signed long int)i)->parameter == ((const char *)NULL))
        tmp_if_expr$1 = "";

      else
        tmp_if_expr$1 = (options + (signed long int)i)->parameter;
      printf(" [%s %s]", (options + (signed long int)i)->name, tmp_if_expr$1);
    }
  printf("\n\n");
  i = 0;
  for( ; !((options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
    if((signed int)*(options + (signed long int)i)->name == 36)
      printf(" [file1] [file2] ...\t: %s\n", (options + (signed long int)i)->msg);

    else
    {
      char *tmp_if_expr$2;
      if((options + (signed long int)i)->parameter == ((const char *)NULL))
        tmp_if_expr$2 = "\t";

      else
        tmp_if_expr$2 = (options + (signed long int)i)->parameter;
      printf("%s %s\t\t: %s\n", (options + (signed long int)i)->name, tmp_if_expr$2, (options + (signed long int)i)->msg);
    }
}

// ci_array_add
// file include/array.h line 118
const struct ci_array_item * ci_array_add(struct ci_array *array, const char *name, const void *value, unsigned long int size)
{
  struct ci_array_item *item;
  struct ci_mem_allocator *packer = array->alloc;
  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  void *return_value_ci_pack_allocator_alloc_unaligned$1;
  return_value_ci_pack_allocator_alloc_unaligned$1=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((struct ci_array_item *)0)[(signed long int)1]);
  item = (struct ci_array_item *)return_value_ci_pack_allocator_alloc_unaligned$1;
  if(!(item == ((struct ci_array_item *)NULL)))
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(name);
    void *return_value_ci_pack_allocator_alloc_from_rear$3;
    return_value_ci_pack_allocator_alloc_from_rear$3=ci_pack_allocator_alloc_from_rear(packer, (signed int)(return_value_strlen$2 + (unsigned long int)1));
    item->name = (char *)return_value_ci_pack_allocator_alloc_from_rear$3;
    item->value=ci_pack_allocator_alloc_from_rear(packer, (signed int)size);
  }

  _Bool tmp_if_expr$4;
  if(item == ((struct ci_array_item *)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = !(item->name != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = !(item->value != NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$5)
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to add the new item to array!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to add the new item to array!\n");

    }

    return (const struct ci_array_item *)(void *)0;
  }

  else
  {
    strcpy(item->name, name);
    memcpy(item->value, value, size);
    if(array->items == ((struct ci_array_item *)NULL))
      array->items = item;

    array->count = array->count + 1u;
    return item;
  }
}

// ci_array_destroy
// file include/array.h line 107
void ci_array_destroy(struct ci_array *array)
{
  void *buffer = (void *)array->mem;
  /* assertion buffer */
  assert(buffer != NULL);
  if(!(array->alloc == ((struct ci_mem_allocator *)NULL)))
    ci_mem_allocator_destroy(array->alloc);

  ci_buffer_free(buffer);
}

// ci_array_get_item
// file array.c line 144
const struct ci_array_item * ci_array_get_item(struct ci_array *array, signed int pos)
{
  if((unsigned int)pos >= array->count)
    return (const struct ci_array_item *)(void *)0;

  else
    return &array->items[(signed long int)pos];
}

// ci_array_iterate
// file array.c line 116
void ci_array_iterate(const struct ci_array *array, void *data, signed int (*fn)(void *, const char *, const void *))
{
  signed int i;
  signed int ret = 0;
  i = 0;
  if(ret == 0 && !((unsigned int)i >= array->count))
  {
    ret=fn(data, (array->items + (signed long int)i)->name, (array->items + (signed long int)i)->value);
    i = i + 1;
  }

}

// ci_array_new
// file include/array.h line 90
struct ci_array * ci_array_new(unsigned long int size)
{
  struct ci_array *array;
  struct ci_mem_allocator *packer;
  void *buffer;
  buffer=ci_buffer_alloc((signed int)size);
  if(buffer == NULL)
    return (struct ci_array *)(void *)0;

  else
  {
    packer=ci_create_pack_allocator_on_memblock((char *)buffer, size);
    if(packer == ((struct ci_mem_allocator *)NULL))
    {
      ci_buffer_free(buffer);
      return (struct ci_array *)(void *)0;
    }

    else
    {
      void *return_value_ci_pack_allocator_alloc$1;
      return_value_ci_pack_allocator_alloc$1=ci_pack_allocator_alloc(packer, sizeof(struct ci_array) /*40ul*/ );
      array = (struct ci_array *)return_value_ci_pack_allocator_alloc$1;
      if(array == ((struct ci_array *)NULL))
      {
        ci_buffer_free(buffer);
        ci_mem_allocator_destroy(packer);
        return (struct ci_array *)(void *)0;
      }

      else
      {
        array->max_size = size;
        array->count = (unsigned int)0;
        array->items = (struct ci_array_item *)(void *)0;
        array->mem = (char *)buffer;
        array->alloc = packer;
        return array;
      }
    }
  }
}

// ci_array_new2
// file array.c line 60
struct ci_array * ci_array_new2(unsigned long int items, unsigned long int item_size)
{
  unsigned long int array_size;
  unsigned long int return_value_ci_pack_allocator_required_size$1;
  return_value_ci_pack_allocator_required_size$1=ci_pack_allocator_required_size();
  array_size = return_value_ci_pack_allocator_required_size$1 + (sizeof(struct ci_array) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + items * ((item_size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (sizeof(struct ci_array_item) /*16ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  struct ci_array *return_value_ci_array_new$2;
  return_value_ci_array_new$2=ci_array_new(array_size);
  return return_value_ci_array_new$2;
}

// ci_array_pop
// file array.c line 125
const struct ci_array_item * ci_array_pop(struct ci_array *array)
{
  struct ci_array_item *item;
  if(array->count == 0u)
    return (const struct ci_array_item *)(void *)0;

  else
  {
    item = &array->items[(signed long int)(array->count - (unsigned int)1)];
    ci_pack_allocator_set_start_pos(array->alloc, (void *)item);
    array->count = array->count - 1u;
    if(array->count == 0u)
      ci_pack_allocator_set_end_pos(array->alloc, (void *)0);

    else
    {
      void *tmp_if_expr$1;
      if(!((void *)(array->items + (signed long int)(array->count + 4294967295u))->name >= (array->items + (signed long int)(array->count + 4294967295u))->value))
        tmp_if_expr$1 = (void *)(array->items + (signed long int)(array->count - (unsigned int)1))->name;

      else
        tmp_if_expr$1 = (void *)(array->items + (signed long int)(array->count - (unsigned int)1))->value;
      ci_pack_allocator_set_end_pos(array->alloc, tmp_if_expr$1);
    }
    return item;
  }
}

// ci_array_search
// file include/array.h line 135
const void * ci_array_search(struct ci_array *array, const char *name)
{
  signed int i = 0;
  for( ; !((unsigned int)i >= array->count); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((array->items + (signed long int)i)->name, name);
    if(return_value_strcmp$1 == 0)
      return (array->items + (signed long int)i)->value;

  }
  return (void *)0;
}

// ci_atol_ext
// file util.c line 78
signed long int ci_atol_ext(const char *str, const char **error)
{
  char *e;
  signed long int val;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  val=strtol(str, &e, 10);
  if(!(error == ((const char **)NULL)))
  {
    *error = (const char *)(void *)0;
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    if((val == 0x7fffffffffffffffL || val == -9223372036854775808l) && *return_value___errno_location$3 == 34)
    {
      *error = atol_err_erange;
      goto __CPROVER_DUMP_L5;
    }

    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(val == 0l && !(*return_value___errno_location$2 == 0))
      *error = atol_err_conversion;

    else
      if(e == str)
        *error = atol_err_nonumber;


  __CPROVER_DUMP_L5:
    ;
    if(!(*error == ((const char *)NULL)))
      return (signed long int)0;

  }

  if(!(val == 0l))
  {
    _Bool tmp_if_expr$5;
    if((signed int)*e == 107)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = (signed int)*e == 75 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      val = val * (signed long int)1024;

    else
    {
      _Bool tmp_if_expr$4;
      if((signed int)*e == 109)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)*e == 77 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        val = val * (signed long int)1024 * (signed long int)1024;

    }
  }

  return val;
}

// ci_base64_decode
// file include/simple_api.h line 139
signed int ci_base64_decode(const char *encoded, char *decoded, signed int len)
{
  signed int i;
  unsigned char *str;
  unsigned char *result;
  if(decoded == ((char *)NULL) || encoded == ((const char *)NULL) || len == 0)
    return 0;

  else
  {
    str = (unsigned char *)encoded;
    result = (unsigned char *)decoded;
    i = len;
    for( ; i >= 4; i = i - 3)
    {
      _Bool tmp_if_expr$1;
      if((signed int)base64_table[(signed long int)*str] >= 64)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)base64_table[(signed long int)str[(signed long int)1]] > 63 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$2;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)base64_table[(signed long int)str[(signed long int)2]] > 63 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$3;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)base64_table[(signed long int)str[(signed long int)3]] > 63 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        break;

      unsigned char *tmp_post$4 = result;
      result = result + 1l;
      *tmp_post$4 = (unsigned char)((signed int)base64_table[(signed long int)*str] << 2 | (signed int)base64_table[(signed long int)str[(signed long int)1]] >> 4);
      unsigned char *tmp_post$5 = result;
      result = result + 1l;
      *tmp_post$5 = (unsigned char)((signed int)base64_table[(signed long int)str[(signed long int)1]] << 4 | (signed int)base64_table[(signed long int)str[(signed long int)2]] >> 2);
      unsigned char *tmp_post$6 = result;
      result = result + 1l;
      *tmp_post$6 = (unsigned char)((signed int)base64_table[(signed long int)str[(signed long int)2]] << 6 | (signed int)base64_table[(signed long int)str[(signed long int)3]]);
      str = str + (signed long int)4;
    }
    *result = (unsigned char)0;
    return len - i;
  }
}

// ci_base64_decode_dup
// file decode.c line 88
char * ci_base64_decode_dup(const char *encoded)
{
  signed int len;
  char *result;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(encoded);
  len = (signed int)return_value_strlen$1;
  len = ((len + 3) / 4) * 3 + 1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)len * sizeof(char) /*1ul*/ );
  result = (char *)return_value_malloc$2;
  if(result == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    ci_base64_decode(encoded, result, len);
    return result;
  }
}

// ci_base64_encode
// file decode.c line 111
signed int ci_base64_encode(const unsigned char *data, unsigned long int len, char *out, unsigned long int outlen)
{
  signed int i;
  signed int k;
  const char *base64_set = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  i = 0;
  k = 0;
  for( ; !((unsigned long int)i >= len + 18446744073709551613ul) && !((unsigned long int)k >= outlen + 18446744073709551612ul); i = i + 3)
  {
    signed int tmp_post$1 = k;
    k = k + 1;
    out[(signed long int)tmp_post$1] = base64_set[(signed long int)((signed int)data[(signed long int)i] >> 2 & 0x3F)];
    signed int tmp_post$2 = k;
    k = k + 1;
    out[(signed long int)tmp_post$2] = base64_set[(signed long int)(((signed int)data[(signed long int)i] << 4 | (signed int)data[(signed long int)(i + 1)] >> 4) & 0x3F)];
    signed int tmp_post$3 = k;
    k = k + 1;
    out[(signed long int)tmp_post$3] = base64_set[(signed long int)(((signed int)data[(signed long int)(i + 1)] << 2 | (signed int)data[(signed long int)(i + 2)] >> 6) & 0x3F)];
    signed int tmp_post$4 = k;
    k = k + 1;
    out[(signed long int)tmp_post$4] = base64_set[(signed long int)((signed int)data[(signed long int)(i + 2)] & 0x3F)];
  }
  if(!((unsigned long int)i >= len) && !((unsigned long int)k >= outlen + 18446744073709551612ul))
  {
    signed int tmp_post$5 = k;
    k = k + 1;
    signed int tmp_if_expr$6;
    if(!((unsigned long int)i >= len))
      tmp_if_expr$6 = (signed int)data[(signed long int)i];

    else
      tmp_if_expr$6 = 0;
    out[(signed long int)tmp_post$5] = base64_set[(signed long int)(tmp_if_expr$6 >> 2 & 0x3F)];
    signed int tmp_post$7 = k;
    k = k + 1;
    signed int tmp_if_expr$8;
    if(!((unsigned long int)i >= len))
      tmp_if_expr$8 = (signed int)data[(signed long int)i];

    else
      tmp_if_expr$8 = 0;
    signed int tmp_if_expr$9;
    if(!((unsigned long int)(1 + i) >= len))
      tmp_if_expr$9 = (signed int)data[(signed long int)(i + 1)];

    else
      tmp_if_expr$9 = 0;
    out[(signed long int)tmp_post$7] = base64_set[(signed long int)((tmp_if_expr$8 << 4 | tmp_if_expr$9 >> 4) & 0x3F)];
    signed int tmp_post$10 = k;
    k = k + 1;
    signed int tmp_if_expr$11;
    if(!((unsigned long int)(1 + i) >= len))
      tmp_if_expr$11 = (signed int)data[(signed long int)(i + 1)];

    else
      tmp_if_expr$11 = 0;
    signed int tmp_if_expr$12;
    if(!((unsigned long int)(2 + i) >= len))
      tmp_if_expr$12 = (signed int)data[(signed long int)(i + 2)];

    else
      tmp_if_expr$12 = 0;
    out[(signed long int)tmp_post$10] = base64_set[(signed long int)((tmp_if_expr$11 << 2 | tmp_if_expr$12 >> 6) & 0x3F)];
    signed int tmp_post$13 = k;
    k = k + 1;
    signed int tmp_if_expr$14;
    if(!((unsigned long int)(2 + i) >= len))
      tmp_if_expr$14 = (signed int)data[(signed long int)(i + 2)];

    else
      tmp_if_expr$14 = 0;
    out[(signed long int)tmp_post$13] = base64_set[(signed long int)(tmp_if_expr$14 & 0x3F)];
  }

  out[(signed long int)k] = (char)0;
  return k;
}

// ci_belongs_to_group
// file filetype.c line 153
signed int ci_belongs_to_group(struct ci_magics_db *db, signed int type, signed int group)
{
  signed int i;
  if(!(db->types_num >= type))
    return 0;

  else
  {
    i = 0;
    for( ; (db->types + (signed long int)type)->groups[(signed long int)i] >= 0; i = i + 1)
    {
      if(i >= 64)
        break;

      if((db->types + (signed long int)type)->groups[(signed long int)i] == group)
        return 1;

    }
    return 0;
  }
}

// ci_buf_init
// file request_common.c line 45
void ci_buf_init(struct ci_buf *buf)
{
  buf->buf = (char *)(void *)0;
  buf->size = 0;
  buf->used = 0;
}

// ci_buf_mem_alloc
// file request_common.c line 56
signed int ci_buf_mem_alloc(struct ci_buf *buf, signed int size)
{
  void *return_value;
  return_value=__intl_malloc((signed int)((unsigned long int)size * sizeof(char) /*1ul*/ ));
  buf->buf = (char *)return_value;
  if(buf->buf == ((char *)NULL))
    return 0;

  else
  {
    buf->size = size;
    buf->used = 0;
    return size;
  }
}

// ci_buf_mem_free
// file request_common.c line 65
void ci_buf_mem_free(struct ci_buf *buf)
{
  __intl_free((void *)buf->buf);
  buf->buf = (char *)(void *)0;
  buf->size = 0;
  buf->used = 0;
}

// ci_buf_reset
// file request_common.c line 52
void ci_buf_reset(struct ci_buf *buf)
{
  buf->used = 0;
}

// ci_buf_reset_size
// file include/request.h line 161
signed int ci_buf_reset_size(struct ci_buf *buf, signed int req_size)
{
  if(!(req_size >= buf->size))
    return req_size;

  else
  {
    if(!(buf->buf == ((char *)NULL)))
      __intl_free((void *)buf->buf);

    signed int return_value_ci_buf_mem_alloc$1;
    return_value_ci_buf_mem_alloc$1=ci_buf_mem_alloc(buf, req_size);
    return return_value_ci_buf_mem_alloc$1;
  }
}

// ci_buf_write
// file include/request.h line 160
signed int ci_buf_write(struct ci_buf *buf, char *data, signed int len)
{
  if(!(buf->size + -buf->used >= len))
    return -1;

  else
  {
    memcpy((void *)(buf->buf + (signed long int)buf->used), (const void *)data, (unsigned long int)len);
    buf->used = buf->used + len;
    return len;
  }
}

// ci_buffer_alloc
// file include/mem.h line 66
void * ci_buffer_alloc(signed int block_size)
{
  signed int type;
  signed int size;
  struct mem_buffer_block *block = (struct mem_buffer_block *)(void *)0;
  size = (signed int)((unsigned long int)block_size + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
  type = block_size - 1 >> 6;
  _Bool tmp_if_expr$1;
  if(!(type >= 16))
    tmp_if_expr$1 = short_buffers[(signed long int)type] != (struct ci_mem_allocator *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    void *return_value;
    return_value=short_buffers[(signed long int)type]->alloc(short_buffers[(signed long int)type], (unsigned long int)size);
    block = (struct mem_buffer_block *)return_value;
  }

  else
    if(!(type >= 512))
    {
      type = type >> 5;
      if(!(long_buffers[(signed long int)type] == ((struct ci_mem_allocator *)NULL)))
      {
        void *return_value_1;
        return_value_1=long_buffers[(signed long int)type]->alloc(long_buffers[(signed long int)type], (unsigned long int)size);
        block = (struct mem_buffer_block *)return_value_1;
      }

    }

  void *return_value_malloc$2;
  if(block == ((struct mem_buffer_block *)NULL))
  {
    return_value_malloc$2=malloc((unsigned long int)size);
    block = (struct mem_buffer_block *)return_value_malloc$2;
  }

  if(block == ((struct mem_buffer_block *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Failed to allocate space for buffer of size:%d\n", block_size);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Failed to allocate space for buffer of size:%d\n", block_size);

    }

    return (void *)0;
  }

  else
  {
    block->sig = (unsigned short int)0xAA55;
    block->ID = block_size;
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Geting buffer from pool %d:%d\n", block_size, type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Geting buffer from pool %d:%d\n", block_size, type);

    }

    return (void *)block->data.ptr;
  }
}

// ci_buffer_blocksize
// file mem.c line 204
unsigned long int ci_buffer_blocksize(const void *data)
{
  struct mem_buffer_block *block;
  signed int type;
  unsigned long int buffer_block_size = (unsigned long int)0;
  block = (struct mem_buffer_block *)(data - (signed long int)(unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
  if(!((signed int)block->sig == 0xAA55))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_buffer_blocksize: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_buffer_blocksize: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

    }

    return (unsigned long int)0;
  }

  else
  {
    type = block->ID - 1 >> 6;
    _Bool tmp_if_expr$1;
    if(!(type >= 16))
      tmp_if_expr$1 = short_buffers[(signed long int)type] != (struct ci_mem_allocator *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      buffer_block_size = (unsigned long int)short_buffer_sizes[(signed long int)type];

    else
      if(!(type >= 512))
      {
        type = type >> 5;
        if(!(long_buffers[(signed long int)type] == ((struct ci_mem_allocator *)NULL)))
          buffer_block_size = (unsigned long int)long_buffer_sizes[(signed long int)type];

      }

    if(buffer_block_size == 0ul)
      buffer_block_size = (unsigned long int)block->ID;

    return buffer_block_size;
  }
}

// ci_buffer_free
// file include/mem.h line 68
void ci_buffer_free(void *data)
{
  signed int block_size;
  signed int type;
  struct mem_buffer_block *block;
  if(!(data == NULL))
  {
    block = (struct mem_buffer_block *)(data - (signed long int)(unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
    if(!((signed int)block->sig == 0xAA55))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_buffer_free: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_buffer_free: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

      }

    }

    else
    {
      block_size = block->ID;
      type = block_size - 1 >> 6;
      _Bool tmp_if_expr$1;
      if(!(type >= 16))
        tmp_if_expr$1 = short_buffers[(signed long int)type] != (struct ci_mem_allocator *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
      {
        short_buffers[(signed long int)type]->free(short_buffers[(signed long int)type], (void *)block);
        if(CI_DEBUG_LEVEL >= 8)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Store buffer to short pool %d:%d\n", block_size, type);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Store buffer to short pool %d:%d\n", block_size, type);

        }

      }

      else
        if(!(type >= 512))
        {
          type = type >> 5;
          if(!(long_buffers[(signed long int)type] == ((struct ci_mem_allocator *)NULL)))
            long_buffers[(signed long int)type]->free(long_buffers[(signed long int)type], (void *)block);

          else
            free((void *)block);
          if(CI_DEBUG_LEVEL >= 8)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Store buffer to long pool %d:%d\n", block_size, type);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Store buffer to long pool %d:%d\n", block_size, type);

          }

        }

        else
          free((void *)block);
    }
  }

}

// ci_buffer_realloc
// file include/mem.h line 67
void * ci_buffer_realloc(void *data, signed int block_size)
{
  signed int buffer_size = 0;
  struct mem_buffer_block *block;
  void *return_value_ci_buffer_alloc$1;
  if(data == NULL)
  {
    return_value_ci_buffer_alloc$1=ci_buffer_alloc(block_size);
    return return_value_ci_buffer_alloc$1;
  }

  block = (struct mem_buffer_block *)(data - (signed long int)(unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
  if(!((signed int)block->sig == 0xAA55))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_buffer_realloc: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_buffer_realloc: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

    }

    return (void *)0;
  }

  else
  {
    unsigned long int return_value_ci_buffer_blocksize$2;
    return_value_ci_buffer_blocksize$2=ci_buffer_blocksize(data);
    buffer_size = (signed int)return_value_ci_buffer_blocksize$2;
    /* assertion buffer_size > 0 */
    assert(buffer_size > 0);
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Current block size for realloc: %d, requested block size: %d. The initial size: %d\n", buffer_size, block_size, block->ID);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Current block size for realloc: %d, requested block size: %d. The initial size: %d\n", buffer_size, block_size, block->ID);

    }

    if(!(buffer_size >= block_size))
    {
      if(CI_DEBUG_LEVEL >= 10)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "We are going to allocate a bigger block of size: %d\n", block_size);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("We are going to allocate a bigger block of size: %d\n", block_size);

      }

      data=ci_buffer_alloc(block_size);
      if(data == NULL)
        return (void *)0;

      if(CI_DEBUG_LEVEL >= 10)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Preserve data of size: %d\n", block->ID);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Preserve data of size: %d\n", block->ID);

      }

      memcpy(data, (const void *)block->data.ptr, (unsigned long int)block->ID);
      ci_buffer_free((void *)block->data.ptr);
    }

    else
      block->ID = block_size;
    return data;
  }
}

// ci_buffers_destroy
// file mem.c line 166
void ci_buffers_destroy()
{
  signed int i = 0;
  for( ; !(i >= 16); i = i + 1)
    if(!(short_buffers[(signed long int)i] == ((struct ci_mem_allocator *)NULL)))
      ci_mem_allocator_destroy(short_buffers[(signed long int)i]);

}

// ci_buffers_init
// file mem.c line 112
signed int ci_buffers_init()
{
  signed int i;
  struct ci_mem_allocator *buf64_pool;
  struct ci_mem_allocator *buf128_pool;
  struct ci_mem_allocator *buf256_pool;
  struct ci_mem_allocator *buf512_pool;
  struct ci_mem_allocator *buf1024_pool;
  struct ci_mem_allocator *buf2048_pool;
  struct ci_mem_allocator *buf4096_pool;
  struct ci_mem_allocator *buf8192_pool;
  struct ci_mem_allocator *buf16384_pool;
  struct ci_mem_allocator *buf32768_pool;
  buf64_pool=ci_create_pool_allocator((signed int)((unsigned long int)64 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf128_pool=ci_create_pool_allocator((signed int)((unsigned long int)128 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf256_pool=ci_create_pool_allocator((signed int)((unsigned long int)256 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf512_pool=ci_create_pool_allocator((signed int)((unsigned long int)512 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf1024_pool=ci_create_pool_allocator((signed int)((unsigned long int)1024 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf2048_pool=ci_create_pool_allocator((signed int)((unsigned long int)2048 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf4096_pool=ci_create_pool_allocator((signed int)((unsigned long int)4096 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf8192_pool=ci_create_pool_allocator((signed int)((unsigned long int)8192 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf16384_pool=ci_create_pool_allocator((signed int)((unsigned long int)16384 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf32768_pool=ci_create_pool_allocator((signed int)((unsigned long int)32768 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  short_buffers[(signed long int)0] = buf64_pool;
  short_buffers[(signed long int)1] = buf128_pool;
  short_buffers[(signed long int)3] = buf256_pool;
  short_buffers[(signed long int)2] = short_buffers[(signed long int)3];
  short_buffers[(signed long int)7] = buf512_pool;
  short_buffers[(signed long int)6] = short_buffers[(signed long int)7];
  short_buffers[(signed long int)5] = short_buffers[(signed long int)6];
  short_buffers[(signed long int)4] = short_buffers[(signed long int)5];
  i = 8;
  for( ; !(i >= 16); i = i + 1)
    short_buffers[(signed long int)i] = buf1024_pool;
  long_buffers[(signed long int)0] = buf2048_pool;
  long_buffers[(signed long int)1] = buf4096_pool;
  long_buffers[(signed long int)3] = buf8192_pool;
  long_buffers[(signed long int)2] = long_buffers[(signed long int)3];
  long_buffers[(signed long int)7] = buf16384_pool;
  long_buffers[(signed long int)6] = long_buffers[(signed long int)7];
  long_buffers[(signed long int)5] = long_buffers[(signed long int)6];
  long_buffers[(signed long int)4] = long_buffers[(signed long int)5];
  i = 8;
  for( ; !(i >= 16); i = i + 1)
    long_buffers[(signed long int)i] = buf32768_pool;
  return 1;
}

// ci_cache_build
// file cache.c line 387
struct ci_cache * ci_cache_build(const char *name, const char *cache_type, unsigned int cache_size, unsigned int max_object_size, signed int ttl, const struct ci_type_ops *key_ops)
{
  struct ci_cache *cache;
  const struct ci_cache_type *type;
  if(!(cache_size >= 1u))
    return (struct ci_cache *)(void *)0;

  else
  {
    type=ci_cache_type_get(cache_type);
    if(type == ((const struct ci_cache_type *)NULL))
    {
      type = &ci_local_cache;
      signed int return_value_strcasecmp$1;
      return_value_strcasecmp$1=strcasecmp(cache_type, ci_local_cache.name);
      if(!(return_value_strcasecmp$1 == 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "WARNING: Cache type '%s' not found. Creating a local cache\n", cache_type);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("WARNING: Cache type '%s' not found. Creating a local cache\n", cache_type);

        }

      }

    }

    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct ci_cache) /*80ul*/ );
    cache = (struct ci_cache *)return_value_malloc$2;
    if(cache == ((struct ci_cache *)NULL))
      return (struct ci_cache *)(void *)0;

    else
    {
      if(!(key_ops == ((const struct ci_type_ops *)NULL)))
        cache->key_ops = key_ops;

      else
        cache->key_ops = &ci_str_ops;
      cache->mem_size = cache_size;
      cache->max_object_size = max_object_size;
      cache->ttl = (signed long int)ttl;
      cache->init = type->init;
      cache->destroy = type->destroy;
      cache->search = type->search;
      cache->update = type->update;
      cache->_cache_type = type;
      signed int return_value;
      return_value=cache->init(cache, name);
      if(return_value == 0)
      {
        free((void *)cache);
        return (struct ci_cache *)(void *)0;
      }

      else
        return cache;
    }
  }
}

// ci_cache_destroy
// file cache.c line 47
void ci_cache_destroy(struct ci_cache *cache)
{
  cache->destroy(cache);
  free((void *)cache);
}

// ci_cache_read_vector_val
// file cache.c line 492
void * ci_cache_read_vector_val(const void *val, unsigned long int val_size, void *o)
{
  unsigned long int vector_size;
  unsigned long int item_size;
  signed int i;
  struct ci_vector *v;
  const void **data_indx;
  if(val == NULL)
    return (void *)0;

  else
  {
    data_indx = (const void **)(val + (signed long int)sizeof(unsigned long int) /*8ul*/ );
    vector_size = *((unsigned long int *)val);
    v=ci_vector_create(vector_size);
    item_size = (val_size - sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)data_indx[(signed long int)0];
    i = 0;
    for( ; !(data_indx[(signed long int)i] == NULL); i = i + 1)
    {
      ci_vector_add(v, (const void *)((const void *)data_indx + (signed long int)(unsigned long int)data_indx[(signed long int)i]), item_size);
      item_size = (unsigned long int)(data_indx[(signed long int)i] - data_indx[(signed long int)(i + 1)]);
    }
    return (void *)v;
  }
}

// ci_cache_search
// file cache.c line 53
const void * ci_cache_search(struct ci_cache *cache, const void *key, void **val, void *data, void * (*dup_from_cache)(const void *, unsigned long int, void *))
{
  const void *return_value;
  return_value=cache->search(cache, key, val, data, dup_from_cache);
  return return_value;
}

// ci_cache_store_vector_size
// file cache.c line 432
unsigned long int ci_cache_store_vector_size(struct ci_vector *v)
{
  signed int vector_data_size;
  signed int vector_indx_size;
  void *vector_data_start;
  void *vector_data_end;
  if(v == ((struct ci_vector *)NULL))
    return (unsigned long int)0;

  else
  {
    vector_data_start = (void *)v->items[(signed long int)(v->count - 1)];
    vector_data_end = (void *)(v->mem + (signed long int)v->max_size);
    _Bool tmp_if_expr$1;
    if(!(vector_data_start >= vector_data_end))
      tmp_if_expr$1 = vector_data_start > (void *)v->mem ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    /* assertion vector_data_start < vector_data_end && vector_data_start > (void *)v->mem */
    assert(tmp_if_expr$1);
    vector_data_size = (signed int)(vector_data_end - vector_data_start);
    vector_indx_size = (signed int)((unsigned long int)(v->count + 1) * sizeof(void *) /*8ul*/ );
    return sizeof(unsigned long int) /*8ul*/  + (unsigned long int)vector_indx_size + (unsigned long int)vector_data_size;
  }
}

// ci_cache_store_vector_val
// file cache.c line 453
void * ci_cache_store_vector_val(void *buf, const void *val, unsigned long int buf_size)
{
  signed int vector_data_size;
  signed int vector_indx_size;
  signed int i;
  const void *vector_data_start;
  const void *vector_data_end;
  void *data;
  void **data_indx;
  struct ci_vector *v = (struct ci_vector *)val;
  if(buf == NULL || val == NULL)
    return (void *)0;

  else
  {
    vector_data_start = (void *)v->items[(signed long int)(v->count - 1)];
    vector_data_end = (const void *)(v->mem + (signed long int)v->max_size);
    _Bool tmp_if_expr$1;
    if(!(vector_data_start >= vector_data_end))
      tmp_if_expr$1 = vector_data_start > (void *)v->mem ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    /* assertion vector_data_start < vector_data_end && vector_data_start > (void *)v->mem */
    assert(tmp_if_expr$1);
    vector_data_size = (signed int)(vector_data_end - vector_data_start);
    vector_indx_size = (signed int)((unsigned long int)(v->count + 1) * sizeof(void *) /*8ul*/ );
    /* assertion buf_size >= sizeof(size_t) + vector_indx_size + vector_data_size */
    assert(buf_size >= sizeof(unsigned long int) /*8ul*/  + (unsigned long int)vector_indx_size + (unsigned long int)vector_data_size);
    data = buf;
    memcpy(data, (const void *)&v->max_size, sizeof(unsigned long int) /*8ul*/ );
    data_indx = (void **)(data + (signed long int)sizeof(unsigned long int) /*8ul*/ );
    memcpy((void *)data_indx + (signed long int)vector_indx_size, vector_data_start, (unsigned long int)vector_data_size);
    i = 0;
    for( ; !(v->items[(signed long int)i] == NULL); i = i + 1)
      data_indx[(signed long int)i] = (void *)((v->items[(signed long int)i] - vector_data_start) + (signed long int)vector_indx_size);
    data_indx[(signed long int)i] = (void *)0;
    return data;
  }
}

// ci_cache_type_get
// file cache.c line 42
static const struct ci_cache_type * ci_cache_type_get(const char *name)
{
  const void *return_value_ci_registry_get_item$1;
  return_value_ci_registry_get_item$1=ci_registry_get_item("c-icap::ci_cache_type", name);
  return (const struct ci_cache_type *)return_value_ci_registry_get_item$1;
}

// ci_cache_type_register
// file cache.c line 37
void ci_cache_type_register(struct ci_cache_type *type)
{
  ci_registry_add_item("c-icap::ci_cache_type", type->name, (const void *)type);
}

// ci_cache_update
// file cache.c line 58
signed int ci_cache_update(struct ci_cache *cache, const void *key, const void *val, unsigned long int val_size, void * (*copy_to_cache)(void *, const void *, unsigned long int))
{
  signed int return_value;
  return_value=cache->update(cache, key, val, val_size, copy_to_cache);
  return return_value;
}

// ci_cached_file_destroy
// file body.c line 423
void ci_cached_file_destroy(struct ci_cached_file *body)
{
  if(!(body == ((struct ci_cached_file *)NULL)))
  {
    if(!(body->buf == ((char *)NULL)))
      ci_buffer_free((void *)body->buf);

    if(body->fd >= 0)
    {
      do_close(body->fd);
      unlink(body->filename);
    }

    if(!(body->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(body->attributes);

    ci_object_pool_free((void *)body);
  }

}

// ci_cached_file_new
// file body.c line 360
struct ci_cached_file * ci_cached_file_new(signed int size)
{
  struct ci_cached_file *body;
  void *return_value_ci_object_pool_alloc$1;
  return_value_ci_object_pool_alloc$1=ci_object_pool_alloc(CACHED_FILE_POOL);
  body = (struct ci_cached_file *)return_value_ci_object_pool_alloc$1;
  if(body == ((struct ci_cached_file *)NULL))
    return (struct ci_cached_file *)(void *)0;

  else
  {
    if(size == 0)
      size = CI_BODY_MAX_MEM;

    if(CI_BODY_MAX_MEM >= size && size >= 1)
    {
      void *return_value_ci_buffer_alloc$2;
      return_value_ci_buffer_alloc$2=ci_buffer_alloc((signed int)((unsigned long int)size * sizeof(char) /*1ul*/ ));
      body->buf = (char *)return_value_ci_buffer_alloc$2;
    }

    else
      body->buf = (char *)(void *)0;
    if(body->buf == ((char *)NULL))
    {
      body->bufsize = 0;
      body->fd=ci_mktemp_file(CI_TMPDIR, "CI_TMP_XXXXXX", body->filename);
      if(!(body->fd >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Can not open temporary filename in directory:%s\n", CI_TMPDIR);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Can not open temporary filename in directory:%s\n", CI_TMPDIR);

        }

        ci_object_pool_free((void *)body);
        return (struct ci_cached_file *)(void *)0;
      }

    }

    else
    {
      body->bufsize = size;
      body->fd = -1;
    }
    body->endpos = (signed long int)0;
    body->readpos = (signed long int)0;
    body->flags = 0;
    body->unlocked = (signed long int)0;
    body->attributes = (struct ci_array *)(void *)0;
    return body;
  }
}

// ci_cached_file_read
// file body.c line 520
signed int ci_cached_file_read(struct ci_cached_file *body, char *buf, signed int len)
{
  signed int remains;
  signed int bytes;
  if(body->readpos == body->endpos)
  {
    if((0x02 & body->flags) == 0)
      goto __CPROVER_DUMP_L1;

    return -2;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(len == 0)
      return 0;

    else
      if(body->fd >= 1)
      {
        _Bool tmp_if_expr$1;
        if(!((0x01 & body->flags) == 0))
          tmp_if_expr$1 = body->unlocked >= (signed long int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
          remains = (signed int)(body->unlocked - body->readpos);

        else
          remains = len;
        bytes = remains > len ? len : remains;
        lseek64(body->fd, body->readpos, 0);
        bytes=do_read(body->fd, (void *)buf, (unsigned long int)bytes);
        if(bytes >= 1)
          body->readpos = body->readpos + (signed long int)bytes;

        return bytes;
      }

      else
      {
        _Bool tmp_if_expr$2;
        if(!((0x01 & body->flags) == 0))
          tmp_if_expr$2 = body->unlocked >= (signed long int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          remains = (signed int)(body->unlocked - body->readpos);

        else
          remains = (signed int)(body->endpos - body->readpos);
        bytes = len <= remains ? len : remains;
        if(bytes >= 1)
        {
          memcpy((void *)buf, (const void *)(body->buf + body->readpos), (unsigned long int)bytes);
          body->readpos = body->readpos + (signed long int)bytes;
        }

        else
        {
          bytes = 0;
          if(CI_DEBUG_LEVEL >= 10)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Read 0, %lld %lld\n", (signed long long int)body->readpos, (signed long long int)body->endpos);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Read 0, %lld %lld\n", (signed long long int)body->readpos, (signed long long int)body->endpos);

          }

        }
        return bytes;
      }
  }
}

// ci_cached_file_release
// file body.c line 442
void ci_cached_file_release(struct ci_cached_file *body)
{
  if(!(body == ((struct ci_cached_file *)NULL)))
  {
    if(!(body->buf == ((char *)NULL)))
      ci_buffer_free((void *)body->buf);

    if(body->fd >= 0)
      do_close(body->fd);

    if(!(body->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(body->attributes);

    ci_object_pool_free((void *)body);
  }

}

// ci_cached_file_reset
// file body.c line 398
void ci_cached_file_reset(struct ci_cached_file *body, signed int new_size)
{
  if(body->fd >= 1)
  {
    do_close(body->fd);
    unlink(body->filename);
  }

  body->endpos = (signed long int)0;
  body->readpos = (signed long int)0;
  body->flags = 0;
  body->unlocked = (signed long int)0;
  body->fd = -1;
  if(!(body->attributes == ((struct ci_array *)NULL)))
    ci_array_destroy(body->attributes);

  body->attributes = (struct ci_array *)(void *)0;
  signed int return_value_resize_buffer$1;
  return_value_resize_buffer$1=resize_buffer(body, new_size);
}

// ci_cached_file_write
// file body.c line 461
signed int ci_cached_file_write(struct ci_cached_file *body, const char *buf, signed int len, signed int iseof)
{
  signed int remains;
  signed int ret;
  if(!(iseof == 0))
  {
    body->flags = body->flags | 0x02;
    if(CI_DEBUG_LEVEL >= 10)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Buffer size=%d, Data size=%lld\n ", ((struct ci_cached_file *)body)->bufsize, (signed long long int)((struct ci_cached_file *)body)->endpos);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Buffer size=%d, Data size=%lld\n ", ((struct ci_cached_file *)body)->bufsize, (signed long long int)((struct ci_cached_file *)body)->endpos);

    }

  }

  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  signed int return_value_do_write$7;
  signed int *return_value___errno_location$3;
  char *return_value_strerror$4;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  if(len == 0)
    return 0;

  else
    if(body->fd >= 1)
    {
      lseek64(body->fd, (signed long int)0, 2);
      ret=do_write(body->fd, (const void *)buf, (unsigned long int)len);
      if(!(ret >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value___errno_location$1=__errno_location();
            __log_error((void *)0, "Cannot write to file!!! (errno=%d)\n", *return_value___errno_location$1);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value___errno_location$2=__errno_location();
            printf("Cannot write to file!!! (errno=%d)\n", *return_value___errno_location$2);
          }

        }

      }

      body->endpos = body->endpos + (signed long int)len;
      return len;
    }

    else
    {
      remains = (signed int)((signed long int)body->bufsize - body->endpos);
      /* assertion remains >= 0 */
      assert(remains >= 0);
      if(!(remains >= len))
      {
        body->fd=ci_mktemp_file(CI_TMPDIR, "CI_TMP_XXXXXX", body->filename);
        if(!(body->fd >= 0))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "I cannot create the temporary file: %s!!!!!!\n", (const void *)body->filename);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("I cannot create the temporary file: %s!!!!!!\n", (const void *)body->filename);

          }

          return -1;
        }

        ret=do_write(body->fd, (const void *)body->buf, (unsigned long int)body->endpos);
        _Bool tmp_if_expr$8;
        if(ret >= 0)
        {
          return_value_do_write$7=do_write(body->fd, (const void *)buf, (unsigned long int)len);
          tmp_if_expr$8 = return_value_do_write$7 >= 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$8 = (_Bool)0;
        if(tmp_if_expr$8)
        {
          body->endpos = body->endpos + (signed long int)len;
          return len;
        }

        else
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            {
              return_value___errno_location$3=__errno_location();
              return_value_strerror$4=strerror(*return_value___errno_location$3);
              __log_error((void *)0, "Cannot write to cachefile: %s\n", return_value_strerror$4);
            }

            if(!(CI_DEBUG_STDOUT == 0))
            {
              return_value___errno_location$5=__errno_location();
              return_value_strerror$6=strerror(*return_value___errno_location$5);
              printf("Cannot write to cachefile: %s\n", return_value_strerror$6);
            }

          }

          return -1;
        }
      }

      if(len >= 1)
      {
        memcpy((void *)(body->buf + body->endpos), (const void *)buf, (unsigned long int)len);
        body->endpos = body->endpos + (signed long int)len;
      }

      return len;
    }
}

// ci_cfg_alloc_mem
// file include/cfg_param.h line 152
void * ci_cfg_alloc_mem(signed int size)
{
  void *return_value;
  return_value=cfg_params_allocator->alloc(cfg_params_allocator, (unsigned long int)size);
  return return_value;
}

// ci_cfg_disable
// file include/cfg_param.h line 178
signed int ci_cfg_disable(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    *((signed int *)setdata) = 0;
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Disabling parameter %s\n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Disabling parameter %s\n", directive);

    }

    return 1;
  }
}

// ci_cfg_enable
// file include/cfg_param.h line 185
signed int ci_cfg_enable(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    *((signed int *)setdata) = 1;
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Enabling parameter %s\n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Enabling parameter %s\n", directive);

    }

    return 1;
  }
}

// ci_cfg_lib_init
// file include/cfg_param.h line 150
void ci_cfg_lib_init()
{
  cfg_params_allocator=ci_create_serial_allocator(65536);
}

// ci_cfg_lib_reset
// file include/cfg_param.h line 151
void ci_cfg_lib_reset()
{
  cfg_params_allocator->reset(cfg_params_allocator);
}

// ci_cfg_onoff
// file include/cfg_param.h line 171
signed int ci_cfg_onoff(const char *directive, const char **argv, void *setdata)
{
  signed int return_value_strcasecmp$2;
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(argv == ((const char **)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Missing arguments in directive:%s\n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Missing arguments in directive:%s\n", directive);

      }

      return 0;
    }

    else
    {
      signed int return_value_strcasecmp$3;
      return_value_strcasecmp$3=strcasecmp(argv[(signed long int)0], "on");
      if(return_value_strcasecmp$3 == 0)
        *((signed int *)setdata) = 1;

      else
      {
        return_value_strcasecmp$2=strcasecmp(argv[(signed long int)0], "off");
        if(return_value_strcasecmp$2 == 0)
          *((signed int *)setdata) = 0;

        else
          return 0;
      }
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Setting parameter :%s=%d\n", directive, *((signed int *)setdata));

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Setting parameter :%s=%d\n", directive, *((signed int *)setdata));

      }

      return 1;
    }
  }
}

// ci_cfg_set_int
// file include/cfg_param.h line 164
signed int ci_cfg_set_int(const char *directive, const char **argv, void *setdata)
{
  signed int val = 0;
  char *end;
  signed int *return_value___errno_location$4;
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(argv == ((const char **)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Missing arguments in directive:%s\n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Missing arguments in directive:%s\n", directive);

      }

      return 0;
    }

    else
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 0;
      signed long long int return_value_strtoll$3;
      return_value_strtoll$3=strtoll(argv[(signed long int)0], &end, 10);
      val = (signed int)return_value_strtoll$3;
      if(val == 0)
      {
        return_value___errno_location$4=__errno_location();
        if(!(*return_value___errno_location$4 == 0))
          return 0;

      }

      *((signed int *)setdata) = val;
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Setting parameter :%s=%d\n", directive, val);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Setting parameter :%s=%d\n", directive, val);

      }

      return 1;
    }
  }
}

// ci_cfg_set_str
// file include/cfg_param.h line 158
signed int ci_cfg_set_str(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(argv == ((const char **)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      return 0;

    else
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(argv[(signed long int)0]);
      void *return_value_ci_cfg_alloc_mem$3;
      return_value_ci_cfg_alloc_mem$3=ci_cfg_alloc_mem((signed int)(return_value_strlen$2 + (unsigned long int)1));
      *((char **)setdata) = (char *)return_value_ci_cfg_alloc_mem$3;
      if(*((char **)setdata) == ((char *)NULL))
        return 0;

      else
      {
        strcpy(*((char **)setdata), argv[(signed long int)0]);
        if(CI_DEBUG_LEVEL >= 2)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

        }

        return 1;
      }
    }
  }
}

// ci_cfg_size_long
// file include/cfg_param.h line 197
signed int ci_cfg_size_long(const char *directive, const char **argv, void *setdata)
{
  signed long int val = (signed long int)0;
  char *end;
  signed int *return_value___errno_location$3;
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(argv == ((const char **)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Missing arguments in directive: %s\n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Missing arguments in directive: %s\n", directive);

      }

      return 0;
    }

    else
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 0;
      val=strtol(argv[(signed long int)0], &end, 10);
      _Bool tmp_if_expr$4;
      if(val == 0l)
      {
        return_value___errno_location$3=__errno_location();
        tmp_if_expr$4 = *return_value___errno_location$3 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(!(val >= 0l) || tmp_if_expr$4)
        return 0;

      else
      {
        _Bool tmp_if_expr$6;
        if((signed int)*end == 107)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = (signed int)*end == 75 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
          val = val * (signed long int)1024;

        else
        {
          _Bool tmp_if_expr$5;
          if((signed int)*end == 109)
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = (signed int)*end == 77 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$5)
            val = val * (signed long int)1024 * (signed long int)1024;

        }
        if(val >= 1l)
          *((signed long int *)setdata) = val;

        if(CI_DEBUG_LEVEL >= 2)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Setting parameter :%s=%ld\n", directive, val);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Setting parameter :%s=%ld\n", directive, val);

        }

        return 1;
      }
    }
  }
}

// ci_cfg_size_off
// file include/cfg_param.h line 191
signed int ci_cfg_size_off(const char *directive, const char **argv, void *setdata)
{
  signed long int val = (signed long int)0;
  char *end;
  signed int *return_value___errno_location$3;
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(argv == ((const char **)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Missing arguments in directive:%s\n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Missing arguments in directive:%s\n", directive);

      }

      return 0;
    }

    else
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 0;
      val=strtoll(argv[(signed long int)0], &end, 10);
      _Bool tmp_if_expr$4;
      if(val == 0l)
      {
        return_value___errno_location$3=__errno_location();
        tmp_if_expr$4 = *return_value___errno_location$3 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(!(val >= 0l) || tmp_if_expr$4)
        return 0;

      else
      {
        _Bool tmp_if_expr$6;
        if((signed int)*end == 107)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = (signed int)*end == 75 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
          val = val * (signed long int)1024;

        else
        {
          _Bool tmp_if_expr$5;
          if((signed int)*end == 109)
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = (signed int)*end == 77 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$5)
            val = val * (signed long int)1024 * (signed long int)1024;

        }
        if(val >= 1l)
          *((signed long int *)setdata) = val;

        if(CI_DEBUG_LEVEL >= 2)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Setting parameter :%s=%lld\n", directive, (signed long long int)val);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Setting parameter :%s=%lld\n", directive, (signed long long int)val);

        }

        return 1;
      }
    }
  }
}

// ci_client_connect_to
// file request_common.c line 984
struct ci_connection * ci_client_connect_to(char *servername, signed int port, signed int proto)
{
  struct ci_connection *connection;
  void *return_value;
  return_value=__intl_malloc((signed int)sizeof(struct ci_connection) /*88ul*/ );
  connection = (struct ci_connection *)return_value;
  char hostname[257l];
  unsigned int addrlen = (unsigned int)0;
  char errBuf[512l];
  signed int errNo;
  signed int *return_value___errno_location$1;
  char *return_value_ci_strerror$2;
  signed int *return_value___errno_location$3;
  char *return_value_ci_strerror$4;
  signed int *return_value___errno_location$6;
  signed int *return_value___errno_location$7;
  char *return_value_ci_strerror$8;
  signed int *return_value___errno_location$9;
  signed int *return_value___errno_location$10;
  char *return_value_ci_strerror$11;
  char *return_value_ci_strerror$13;
  char *return_value_ci_strerror$14;
  signed int *return_value___errno_location$16;
  char *return_value_ci_strerror$17;
  signed int *return_value___errno_location$18;
  char *return_value_ci_strerror$19;
  if(connection == ((struct ci_connection *)NULL))
    return (struct ci_connection *)(void *)0;

  else
  {
    signed int return_value_ci_host_to_sockaddr_t$5;
    return_value_ci_host_to_sockaddr_t$5=ci_host_to_sockaddr_t(servername, &connection->srvaddr, proto);
    if(return_value_ci_host_to_sockaddr_t$5 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value___errno_location$1=__errno_location();
          return_value_ci_strerror$2=ci_strerror(*return_value___errno_location$1, errBuf, sizeof(char [512l]) /*512ul*/ );
          __log_error((void *)0, "Error getting address info for host '%s': %s\n", servername, return_value_ci_strerror$2);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value___errno_location$3=__errno_location();
          return_value_ci_strerror$4=ci_strerror(*return_value___errno_location$3, errBuf, sizeof(char [512l]) /*512ul*/ );
          printf("Error getting address info for host '%s': %s\n", servername, return_value_ci_strerror$4);
        }

      }

      close(connection->fd);
      __intl_free((void *)connection);
      return (struct ci_connection *)(void *)0;
    }

    else
    {
      ci_sockaddr_set_port(&connection->srvaddr, port);
      connection->fd=socket(connection->srvaddr.ci_sin_family, 1, 0);
      if(connection->fd == -1)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value___errno_location$6=__errno_location();
            return_value___errno_location$7=__errno_location();
            return_value_ci_strerror$8=ci_strerror(*return_value___errno_location$7, errBuf, sizeof(char [512l]) /*512ul*/ );
            __log_error((void *)0, "Error opening socket :%d:%s....\n", *return_value___errno_location$6, return_value_ci_strerror$8);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value___errno_location$9=__errno_location();
            return_value___errno_location$10=__errno_location();
            return_value_ci_strerror$11=ci_strerror(*return_value___errno_location$10, errBuf, sizeof(char [512l]) /*512ul*/ );
            printf("Error opening socket :%d:%s....\n", *return_value___errno_location$9, return_value_ci_strerror$11);
          }

        }

        __intl_free((void *)connection);
        return (struct ci_connection *)(void *)0;
      }

      else
      {
        addrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        signed int return_value_connect$15;
        return_value_connect$15=connect(connection->fd, (struct sockaddr *)&connection->srvaddr.sockaddr, addrlen);
        if(!(return_value_connect$15 == 0))
        {
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          errNo = *return_value___errno_location$12;
          ci_sockaddr_t_to_host(&connection->srvaddr, hostname, 256);
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            {
              return_value_ci_strerror$13=ci_strerror(errNo, errBuf, sizeof(char [512l]) /*512ul*/ );
              __log_error((void *)0, "Error connecting to host  '%s': %s \n", (const void *)hostname, return_value_ci_strerror$13);
            }

            if(!(CI_DEBUG_STDOUT == 0))
            {
              return_value_ci_strerror$14=ci_strerror(errNo, errBuf, sizeof(char [512l]) /*512ul*/ );
              printf("Error connecting to host  '%s': %s \n", (const void *)hostname, return_value_ci_strerror$14);
            }

          }

          close(connection->fd);
          __intl_free((void *)connection);
          return (struct ci_connection *)(void *)0;
        }

        addrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        signed int return_value_getsockname$20;
        return_value_getsockname$20=getsockname(connection->fd, (struct sockaddr *)&connection->claddr.sockaddr, &addrlen);
        if(!(return_value_getsockname$20 == 0))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            {
              return_value___errno_location$16=__errno_location();
              return_value_ci_strerror$17=ci_strerror(*return_value___errno_location$16, errBuf, sizeof(char [512l]) /*512ul*/ );
              __log_error((void *)0, "Error getting client sockname: %s\n", return_value_ci_strerror$17);
            }

            if(!(CI_DEBUG_STDOUT == 0))
            {
              return_value___errno_location$18=__errno_location();
              return_value_ci_strerror$19=ci_strerror(*return_value___errno_location$18, errBuf, sizeof(char [512l]) /*512ul*/ );
              printf("Error getting client sockname: %s\n", return_value_ci_strerror$19);
            }

          }

          close(connection->fd);
          __intl_free((void *)connection);
          return (struct ci_connection *)(void *)0;
        }

        else
        {
          ci_fill_sockaddr(&connection->claddr);
          ci_fill_sockaddr(&connection->srvaddr);
          ci_netio_init(connection->fd);
          return connection;
        }
      }
    }
  }
}

// ci_client_get_server_options
// file request_common.c line 962
signed int ci_client_get_server_options(struct ci_request *req, signed int timeout)
{
  signed int return_value_client_create_request$1;
  return_value_client_create_request$1=client_create_request(req, req->req_server, req->service, 0x01);
  signed int return_value_client_parse_icap_header$2;
  if(!(return_value_client_create_request$1 == 1))
    return -1;

  else
  {
    client_send_request_headers(req, 0, timeout);
    do
    {
      ci_wait_for_data(req->connection->fd, timeout, 0x1);
      signed int return_value_net_data_read$3;
      return_value_net_data_read$3=net_data_read(req);
      if(return_value_net_data_read$3 == -1)
        return -1;

      return_value_client_parse_icap_header$2=client_parse_icap_header(req, req->response_header);
    }
    while(return_value_client_parse_icap_header$2 == 2);
    ci_headers_unpack(req->response_header);
    get_request_options(req, req->response_header);
    return 1;
  }
}

// ci_client_http_headers_completed
// file request_common.c line 1422
signed int ci_client_http_headers_completed(struct ci_request *req)
{
  return (signed int)(req->status >= 2);
}

// ci_client_icapfilter
// file request_common.c line 1303
signed int ci_client_icapfilter(struct ci_request *req, signed int timeout, struct ci_headers_list *req_headers, struct ci_headers_list *resp_headers, void *data_source, signed int (*source_read)(void *, char *, signed int), void *data_dest, signed int (*dest_write)(void *, char *, signed int))
{
  signed int i;
  signed int ret;
  signed int v1;
  signed int v2;
  signed int remains;
  signed int pre_eof = 0;
  signed int preview_status;
  char *buf;
  const char *val;
  signed int return_value_client_create_request$1;
  return_value_client_create_request$1=client_create_request(req, req->req_server, req->service, req->type);
  signed int return_value_client_parse_icap_header$3;
  if(!(return_value_client_create_request$1 == 1))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error making respmod request ....\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error making respmod request ....\n");

    }

    return -1;
  }

  else
  {
    if(data_source == NULL)
      req->preview = -1;

    if(req->preview >= 1)
    {
      ci_buf_mem_alloc(&req->preview_data, req->preview);
      buf = req->preview_data.buf;
      remains = req->preview;
      if(pre_eof == 0 && !(remains == 0))
      {
        ret=source_read(data_source, buf, remains);
        if(!(ret >= 1))
          pre_eof = 1;

        else
          remains = remains - ret;
      }

      req->preview = req->preview - remains;
      req->preview_data.used = req->preview;
    }

    if(!(pre_eof == 0))
      req->eof_received = 1;

    signed int return_value_client_build_headers$2;
    return_value_client_build_headers$2=client_build_headers(req, (signed int)(req_headers != (struct ci_headers_list *)(void *)0), (signed int)(resp_headers != (struct ci_headers_list *)(void *)0), (signed int)(data_source != (void *)0));
    if(return_value_client_build_headers$2 == 0)
      return -1;

    else
    {
      if(!(req_headers == ((struct ci_headers_list *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Going to add %d request headers\n", req_headers->used);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Going to add %d request headers\n", req_headers->used);

        }

        i = 0;
        for( ; !(i >= req_headers->used); i = i + 1)
        {
          if(CI_DEBUG_LEVEL >= 8)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Add request header: %s\n", req_headers->headers[(signed long int)i]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Add request header: %s\n", req_headers->headers[(signed long int)i]);

          }

          ci_http_request_add_header(req, req_headers->headers[(signed long int)i]);
        }
      }

      if(!(resp_headers == ((struct ci_headers_list *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Going to add %d response headers\n", resp_headers->used);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Going to add %d response headers\n", resp_headers->used);

        }

        i = 0;
        for( ; !(i >= resp_headers->used); i = i + 1)
        {
          if(CI_DEBUG_LEVEL >= 8)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Add resp header: %s\n", resp_headers->headers[(signed long int)i]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Add resp header: %s\n", resp_headers->headers[(signed long int)i]);

          }

          ci_http_response_add_header(req, resp_headers->headers[(signed long int)i]);
        }
      }

      ret=client_send_request_headers(req, pre_eof, timeout);
      if(!(ret >= 0))
        return -1;

      else
      {
        i = 0;
        for( ; !(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)); i = i + 1)
          ci_request_release_entity(req, i);
        preview_status = 100;
        if(req->preview >= 0)
        {
          do
          {
            ci_wait_for_data(req->connection->fd, timeout, 0x1);
            signed int return_value_net_data_read$4;
            return_value_net_data_read$4=net_data_read(req);
            if(return_value_net_data_read$4 == -1)
              return -1;

            return_value_client_parse_icap_header$3=client_parse_icap_header(req, req->response_header);
          }
          while(return_value_client_parse_icap_header$3 == 2);
          sscanf(req->response_header->buf, "ICAP/%d.%d %d", &v1, &v2, &preview_status);
          if(CI_DEBUG_LEVEL >= 3)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Preview response was with status: %d \n", preview_status);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Preview response was with status: %d \n", preview_status);

          }

          if(preview_status == 204)
            ci_headers_unpack(req->response_header);

          else
            if(preview_status == 206 || preview_status == 200 && !(req->eof_received == 0))
            {
              ci_headers_unpack(req->response_header);
              val=ci_headers_search(req->response_header, "Encapsulated");
              if(val == ((const char *)NULL))
              {
                if(CI_DEBUG_LEVEL >= 1)
                {
                  if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                    __log_error((void *)0, "No encapsulated entities!\n");

                  if(!(CI_DEBUG_STDOUT == 0))
                    printf("No encapsulated entities!\n");

                }

                return -1;
              }

              process_encapsulated(req, val);
              if(req->entities[1l] == ((struct ci_encaps_entity *)NULL))
                req->status = 3;

              else
                req->status = 1;
            }

            else
              ci_headers_reset(req->response_header);
        }

        if(preview_status == 204 || preview_status == 206)
          return preview_status;

        else
        {
          ret=client_send_get_data(req, timeout, data_source, source_read, data_dest, dest_write);
          if(preview_status == 206 && ret == 1)
            return 206;

          else
            return ret;
        }
      }
    }
  }
}

// ci_client_request
// file request_common.c line 662
struct ci_request * ci_client_request(struct ci_connection *conn, char *server, char *service)
{
  struct ci_request *req;
  req=ci_request_alloc(conn);
  if(req == ((struct ci_request *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocation ci_request_t object(ci_client_request())\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocation ci_request_t object(ci_client_request())\n");

    }

    return (struct ci_request *)(void *)0;
  }

  else
  {
    strncpy(req->req_server, server, (unsigned long int)256);
    req->req_server[(signed long int)256] = (char)0;
    strncpy(req->service, service, (unsigned long int)63);
    req->service[(signed long int)63] = (char)0;
    return req;
  }
}

// ci_client_request_reuse
// file request_common.c line 679
void ci_client_request_reuse(struct ci_request *req)
{
  signed int i;
  req->packed = 0;
  req->args[(signed long int)0] = (char)0;
  req->type = -1;
  ci_buf_reset(&req->preview_data);
  req->hasbody = 0;
  req->responce_hasbody = 0;
  ci_headers_reset(req->request_header);
  ci_headers_reset(req->response_header);
  ci_headers_reset(req->xheaders);
  req->eof_received = 0;
  req->status = 0;
  req->pstrblock_read = (char *)(void *)0;
  req->pstrblock_read_len = 0;
  req->current_chunk_len = (unsigned int)0;
  req->chunk_bytes_read = (unsigned int)0;
  req->pstrblock_responce = (char *)(void *)0;
  req->remain_send_block_bytes = 0;
  req->write_to_module_pending = (unsigned int)0;
  req->data_locked = 1;
  req->allow204 = 0;
  req->allow206 = 0;
  req->i206_use_original_body = (signed long int)-1;
  req->bytes_in = (unsigned long int)0;
  req->bytes_out = (unsigned long int)0;
  req->http_bytes_in = (unsigned long int)0;
  req->http_bytes_out = (unsigned long int)0;
  req->body_bytes_in = (unsigned long int)0;
  req->body_bytes_out = (unsigned long int)0;
  i = 0;
  for( ; !(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)); i = i + 1)
    ci_request_release_entity(req, i);
}

// ci_command_register_action
// file commands.c line 203
void ci_command_register_action(const char *name, signed int type, void *data, void (*command_action)(const char *, signed int, void *))
{
  register_command_extend(name, type, data, command_action);
}

// ci_command_register_ctl_cmd
// file commands.c line 198
void ci_command_register_ctl_cmd(const char *name, signed int type, void (*command_action)(const char *, signed int, const char **))
{
  register_command(name, type, command_action);
}

// ci_command_schedule
// file commands.c line 227
void ci_command_schedule(const char *name, void *data, signed long int afterSecs)
{
  signed long int tm;
  time(&tm);
  tm = tm + afterSecs;
  ci_command_schedule_on(name, data, tm);
}

// ci_command_schedule_on
// file commands.c line 209
void ci_command_schedule_on(const char *name, void *data, signed long int time)
{
  struct schedule_data sch;
  memset((void *)&sch, 0, sizeof(struct schedule_data) /*144ul*/ );
  strncpy(sch.name, name, (unsigned long int)128);
  sch.name[(signed long int)(128 - 1)] = (char)0;
  sch.when = time;
  sch.data = data;
  const void *return_value_ci_list_search$1;
  return_value_ci_list_search$1=ci_list_search(COMMANDS_QUEUE, (const void *)&sch);
  if(!(return_value_ci_list_search$1 == NULL))
  {
    if(CI_DEBUG_LEVEL >= 7)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "command %s already scheduled for execution on %ld, ignore\n", name, time);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("command %s already scheduled for execution on %ld, ignore\n", name, time);

    }

  }

  else
  {
    pthread_mutex_lock(&COMMANDS_MTX);
    ci_list_push(COMMANDS_QUEUE, (const void *)&sch);
    pthread_mutex_unlock(&COMMANDS_MTX);
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "command %s scheduled for execution\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("command %s scheduled for execution\n", name);

    }

  }
}

// ci_connection_destroy
// file net_io.c line 191
void ci_connection_destroy(struct ci_connection *connection)
{
  if(!(connection == ((struct ci_connection *)NULL)))
  {
    if(connection->fd >= 0)
      close(connection->fd);

    free((void *)connection);
  }

}

// ci_copy_connection
// file include/net_io.h line 138
void ci_copy_connection(struct ci_connection *dest, struct ci_connection *src)
{
  dest->fd = src->fd;
  ci_copy_sockaddr(&dest->claddr, &src->claddr);
  ci_copy_sockaddr(&dest->srvaddr, &src->srvaddr);
}

// ci_copy_sockaddr
// file net_io.c line 68
void ci_copy_sockaddr(struct ci_sockaddr *dest, struct ci_sockaddr *src)
{
  memcpy((void *)dest, (const void *)src, sizeof(struct ci_sockaddr) /*40ul*/ );
  dest->ci_sin_addr = (void *)&dest->sockaddr.sin_addr;
}

// ci_create_os_allocator
// file mem.c line 424
struct ci_mem_allocator * ci_create_os_allocator()
{
  struct ci_mem_allocator *allocator;
  allocator=alloc_mem_allocator_struct();
  if(allocator == ((struct ci_mem_allocator *)NULL))
    return (struct ci_mem_allocator *)(void *)0;

  else
  {
    allocator->alloc = os_allocator_alloc;
    allocator->free = os_allocator_free;
    allocator->reset = os_allocator_reset;
    allocator->destroy = os_allocator_destroy;
    allocator->data = (void *)0;
    allocator->name = (char *)(void *)0;
    allocator->type = 0;
    return allocator;
  }
}

// ci_create_pack_allocator
// file mem.c line 687
struct ci_mem_allocator * ci_create_pack_allocator(char *memblock, unsigned long int size)
{
  struct ci_mem_allocator *allocator;
  struct pack_allocator *pack_alloc;
  void *return_value_ci_object_pool_alloc$1;
  return_value_ci_object_pool_alloc$1=ci_object_pool_alloc(PACK_ALLOCATOR_POOL);
  pack_alloc = (struct pack_allocator *)return_value_ci_object_pool_alloc$1;
  if(pack_alloc == ((struct pack_allocator *)NULL))
    return (struct ci_mem_allocator *)(void *)0;

  else
  {
    allocator=alloc_mem_allocator_struct();
    if(allocator == ((struct ci_mem_allocator *)NULL))
    {
      ci_object_pool_free((void *)pack_alloc);
      return (struct ci_mem_allocator *)(void *)0;
    }

    else
    {
      struct ci_mem_allocator *return_value_init_pack_allocator$2;
      return_value_init_pack_allocator$2=init_pack_allocator(allocator, pack_alloc, memblock, size, 2);
      return return_value_init_pack_allocator$2;
    }
  }
}

// ci_create_pack_allocator_on_memblock
// file mem.c line 704
struct ci_mem_allocator * ci_create_pack_allocator_on_memblock(char *memblock, unsigned long int size)
{
  struct ci_mem_allocator *allocator;
  if(!(size >= 97ul))
    return (struct ci_mem_allocator *)(void *)0;

  else
  {
    struct pack_allocator *pack_alloc = (struct pack_allocator *)memblock;
    memblock = memblock + (signed long int)(sizeof(struct pack_allocator) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    size = size - (sizeof(struct pack_allocator) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    allocator = (struct ci_mem_allocator *)memblock;
    memblock = memblock + (signed long int)(sizeof(struct ci_mem_allocator) /*56ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    size = size - (sizeof(struct ci_mem_allocator) /*56ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    struct ci_mem_allocator *return_value_init_pack_allocator$1;
    return_value_init_pack_allocator$1=init_pack_allocator(allocator, pack_alloc, memblock, size, 0);
    return return_value_init_pack_allocator$1;
  }
}

// ci_create_pool_allocator
// file mem.c line 888
struct ci_mem_allocator * ci_create_pool_allocator(signed int items_size)
{
  struct pool_allocator *palloc;
  struct ci_mem_allocator *allocator;
  palloc=pool_allocator_build(items_size, 0);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ci_mem_allocator) /*56ul*/ );
  allocator = (struct ci_mem_allocator *)return_value_malloc$1;
  if(allocator == ((struct ci_mem_allocator *)NULL))
    return (struct ci_mem_allocator *)(void *)0;

  else
  {
    allocator->alloc = pool_allocator_alloc;
    allocator->free = pool_allocator_free;
    allocator->reset = pool_allocator_reset;
    allocator->destroy = pool_allocator_destroy;
    allocator->data = (void *)palloc;
    allocator->name = (char *)(void *)0;
    allocator->type = 2;
    allocator->must_free = 1;
    return allocator;
  }
}

// ci_create_serial_allocator
// file include/mem.h line 48
struct ci_mem_allocator * ci_create_serial_allocator(signed int size)
{
  struct ci_mem_allocator *allocator;
  struct serial_allocator *sdata;
  sdata=serial_allocator_build(size);
  void *return_value_serial_allocation$1;
  return_value_serial_allocation$1=serial_allocation(sdata, sizeof(struct ci_mem_allocator) /*56ul*/ );
  allocator = (struct ci_mem_allocator *)return_value_serial_allocation$1;
  if(allocator == ((struct ci_mem_allocator *)NULL))
  {
    ci_buffer_free((void *)sdata);
    return (struct ci_mem_allocator *)(void *)0;
  }

  else
  {
    allocator->alloc = serial_allocator_alloc;
    allocator->free = serial_allocator_free;
    allocator->reset = serial_allocator_reset;
    allocator->destroy = serial_allocator_destroy;
    allocator->data = (void *)sdata;
    allocator->name = (char *)(void *)0;
    allocator->type = 1;
    allocator->must_free = 0;
    return allocator;
  }
}

// ci_dlib_closeall
// file dlib.c line 72
signed int ci_dlib_closeall()
{
  struct dlib_entry *dl_e;
  struct dlib_entry *dl_cur;
  signed int ret;
  signed int error = 0;
  dl_cur = dlib_list;
  while(!(dl_cur == ((struct dlib_entry *)NULL)))
  {
    dl_e = dl_cur;
    dl_cur = dl_cur->next;
    ret=ci_module_unload(dl_e->handle, dl_e->name);
    if(ret == 0)
      error = 1;

    if(!(dl_e->name == ((char *)NULL)))
      free((void *)dl_e->name);

    if(!(dl_e->file == ((char *)NULL)))
      free((void *)dl_e->file);

    free((void *)dl_e);
  }
  dlib_list = (struct dlib_entry *)(void *)0;
  if(!(error == 0))
    return 0;

  else
    return 1;
}

// ci_dlib_entry
// file include/dlib.h line 45
signed int ci_dlib_entry(const char *name, const char *file, void *handle)
{
  struct dlib_entry *dl_e;
  struct dlib_entry *dl_cur;
  if(handle == NULL || file == ((const char *)NULL) || name == ((const char *)NULL))
    return 0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct dlib_entry) /*32ul*/ );
    dl_e = (struct dlib_entry *)return_value_malloc$1;
    if(dl_e == ((struct dlib_entry *)NULL))
      return 0;

    else
    {
      dl_e->file=strdup(file);
      if(dl_e->file == ((char *)NULL))
      {
        free((void *)dl_e);
        return 0;
      }

      else
      {
        dl_e->name=strdup(name);
        if(dl_e->name == ((char *)NULL))
        {
          free((void *)dl_e->file);
          free((void *)dl_e);
          return 0;
        }

        else
        {
          dl_e->handle = handle;
          dl_e->next = (struct dlib_entry *)(void *)0;
          if(dlib_list == ((struct dlib_entry *)NULL))
          {
            dlib_list = dl_e;
            return 1;
          }

          else
          {
            dl_cur = dlib_list;
            for( ; !(dl_cur->next == ((struct dlib_entry *)NULL)); dl_cur = dl_cur->next)
              ;
            dl_cur->next = dl_e;
            return 1;
          }
        }
      }
    }
  }
}

// ci_dyn_array_add
// file array.c line 269
const struct ci_array_item * ci_dyn_array_add(struct ci_dyn_array *array, const char *name, const void *value, unsigned long int size)
{
  struct ci_array_item *item;
  struct ci_array_item **items_space;
  struct ci_mem_allocator *packer = array->alloc;
  signed int name_size;
  if(array->count == array->max_items)
  {
    void *return_value_ci_buffer_realloc$1;
    return_value_ci_buffer_realloc$1=ci_buffer_realloc((void *)array->items, (signed int)((unsigned long int)(array->max_items + 32) * sizeof(struct ci_array_item *) /*8ul*/ ));
    items_space = (struct ci_array_item **)return_value_ci_buffer_realloc$1;
    if(items_space == ((struct ci_array_item **)NULL))
      return (const struct ci_array_item *)(void *)0;

    array->items = items_space;
    array->max_items = array->max_items + 32;
  }

  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  void *return_value;
  return_value=packer->alloc(packer, sizeof(struct ci_array_item) /*16ul*/ );
  item = (struct ci_array_item *)return_value;
  if(item == ((struct ci_array_item *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to add the new item %s to array!\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to add the new item %s to array!\n", name);

    }

    return (const struct ci_array_item *)(void *)0;
  }

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(name);
    name_size = (signed int)(return_value_strlen$2 + (unsigned long int)1);
    void *return_value_1;
    return_value_1=packer->alloc(packer, (unsigned long int)name_size);
    item->name = (char *)return_value_1;
    if(size >= 1ul)
      item->value=packer->alloc(packer, size);

    else
      item->value = (void *)0;
    _Bool tmp_if_expr$3;
    if(item->name == ((char *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (!(item->value != NULL) ? (size > (unsigned long int)0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Not enough space to add the new item %s to array!\n", name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Not enough space to add the new item %s to array!\n", name);

      }

      if(!(item->name == ((char *)NULL)))
        packer->free(packer, (void *)item->name);

      if(!(item->value == NULL))
        packer->free(packer, item->value);

      packer->free(packer, (void *)item);
      return (const struct ci_array_item *)(void *)0;
    }

    else
    {
      memcpy((void *)item->name, (const void *)name, (unsigned long int)name_size);
      if(size >= 1ul)
        memcpy(item->value, value, size);

      else
        item->value = (void *)value;
      signed int tmp_post$4 = array->count;
      array->count = array->count + 1;
      array->items[(signed long int)tmp_post$4] = item;
      return item;
    }
  }
}

// ci_dyn_array_destroy
// file array.c line 260
void ci_dyn_array_destroy(struct ci_dyn_array *array)
{
  if(!(array->items == ((struct ci_array_item **)NULL)))
    ci_buffer_free((void *)array->items);

  if(!(array->alloc == ((struct ci_mem_allocator *)NULL)))
    ci_mem_allocator_destroy(array->alloc);

}

// ci_dyn_array_iterate
// file array.c line 329
void ci_dyn_array_iterate(const struct ci_dyn_array *array, void *data, signed int (*fn)(void *, const char *, const void *))
{
  signed int i;
  signed int ret = 0;
  i = 0;
  if(ret == 0 && !(i >= array->count))
  {
    ret=fn(data, array->items[(signed long int)i]->name, array->items[(signed long int)i]->value);
    i = i + 1;
  }

}

// ci_dyn_array_new
// file array.c line 212
struct ci_dyn_array * ci_dyn_array_new(unsigned long int size)
{
  unsigned long int index_memory = size / (unsigned long int)4;
  unsigned long int items_memory = size - index_memory;
  unsigned long int items_count = index_memory / sizeof(struct ci_array_item *) /*8ul*/ ;
  unsigned long int item_size = items_memory / items_count;
  if(!(item_size >= sizeof(struct ci_array_item) /*16ul*/ ))
    item_size = sizeof(struct ci_array_item) /*16ul*/ ;

  struct ci_dyn_array *return_value_ci_dyn_array_new2$1;
  return_value_ci_dyn_array_new2$1=ci_dyn_array_new2(items_count, item_size);
  return return_value_ci_dyn_array_new2$1;
}

// ci_dyn_array_new2
// file array.c line 225
struct ci_dyn_array * ci_dyn_array_new2(unsigned long int items, unsigned long int item_size)
{
  struct ci_dyn_array *array;
  struct ci_mem_allocator *packer;
  unsigned long int array_size = (sizeof(struct ci_dyn_array) /*24ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + items * ((item_size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (sizeof(struct ci_array_item) /*16ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + ((unsigned long int)16 + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  packer=ci_create_serial_allocator((signed int)array_size);
  if(packer == ((struct ci_mem_allocator *)NULL))
    return (struct ci_dyn_array *)(void *)0;

  else
  {
    void *return_value;
    return_value=packer->alloc(packer, sizeof(struct ci_dyn_array) /*24ul*/ );
    array = (struct ci_dyn_array *)return_value;
    if(array == ((struct ci_dyn_array *)NULL))
    {
      ci_mem_allocator_destroy(packer);
      return (struct ci_dyn_array *)(void *)0;
    }

    else
    {
      if(!(items >= 32ul))
        items = (unsigned long int)32;

      array->max_items = (signed int)items;
      void *return_value_ci_buffer_alloc$1;
      return_value_ci_buffer_alloc$1=ci_buffer_alloc((signed int)(items * sizeof(struct ci_array_item *) /*8ul*/ ));
      array->items = (struct ci_array_item **)return_value_ci_buffer_alloc$1;
      array->count = 0;
      array->alloc = packer;
      return array;
    }
  }
}

// ci_dyn_array_search
// file array.c line 317
const void * ci_dyn_array_search(struct ci_dyn_array *array, const char *name)
{
  struct ci_array_item *item;
  signed int i = 0;
  signed int return_value_strcmp$1;
  for( ; !(i >= array->count); i = i + 1)
  {
    return_value_strcmp$1=strcmp(array->items[(signed long int)i]->name, name);
    if(return_value_strcmp$1 == 0)
      return array->items[(signed long int)i]->value;

  }
  return (void *)0;
}

// ci_extend_filetype
// file filetype.c line 661
signed int ci_extend_filetype(struct ci_magics_db *db, struct ci_request *req, const char *buf, signed int len, signed int *iscompressed)
{
  struct ci_headers_list *heads;
  if(req->type == 0x04)
    heads=ci_http_response_headers(req);

  else
    heads = (struct ci_headers_list *)(void *)0;
  signed int return_value_extend_object_type$1;
  return_value_extend_object_type$1=extend_object_type(db, heads, buf, len, iscompressed);
  return return_value_extend_object_type$1;
}

// ci_filetype
// file filetype.c line 541
signed int ci_filetype(struct ci_magics_db *db, const char *buf, signed int buflen)
{
  signed int ret;
  ret=check_magics(db, buf, buflen);
  if(ret >= 0)
    return ret;

  else
  {
    ret=check_ascii((unsigned char *)buf, buflen);
    if(ret >= 0)
      return ret;

    else
    {
      ret=check_unicode((unsigned char *)buf, buflen);
      if(ret >= 0)
        return 3;

      else
        return 5;
    }
  }
}

// ci_fill_ip_t
// file net_io.c line 75
void ci_fill_ip_t(struct ci_ip *ip_dest, struct ci_sockaddr *src)
{
  ip_dest->family = src->ci_sin_family;
  memcpy((void *)&ip_dest->address, src->ci_sin_addr, sizeof(struct in_addr) /*4ul*/ );
  ip_dest->netmask.s_addr=htonl(0xFFFFFFFF);
}

// ci_fill_sockaddr
// file include/net_io.h line 115
void ci_fill_sockaddr(struct ci_sockaddr *addr)
{
  addr->ci_sin_family = (signed int)addr->sockaddr.sin_family;
  addr->ci_sin_port = (signed int)addr->sockaddr.sin_port;
  addr->ci_sin_addr = (void *)&addr->sockaddr.sin_addr;
  addr->ci_inaddr_len = (signed int)sizeof(struct in_addr) /*4ul*/ ;
}

// ci_format_text
// file include/txt_format.h line 75
signed int ci_format_text(struct ci_request *req_data, const char *fmt, char *buffer, signed int len, struct ci_fmt_entry *user_table)
{
  const char *s;
  char *b;
  char *lb;
  struct ci_fmt_entry *fmte;
  signed int directive_len;
  signed int val_len;
  signed int remains;
  signed int left_align;
  signed int i;
  unsigned int width;
  unsigned int space = (unsigned int)0;
  char parameter[256l];
  lb = (char *)(void *)0;
  s = fmt;
  b = buffer;
  remains = len - 1;
  void *return_value_malloc$1;
  while(!(*s == 0))
  {
    if(!(remains >= 1))
      break;

    if((signed int)*s == 37)
    {
      fmte=check_tables(s, user_table, &directive_len, &width, &left_align, parameter);
      if(CI_DEBUG_LEVEL >= 7)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Width: %d, Parameter:%s\n", width, (const void *)parameter);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Width: %d, Parameter:%s\n", width, (const void *)parameter);

      }

      if(!(width == 0u))
      {
        width = (unsigned int)remains < width ? (unsigned int)remains : width;
        space = width;
      }

      else
        space = (unsigned int)remains;
      if(!(fmte == ((struct ci_fmt_entry *)NULL)))
      {
        if(!(width == 0u))
        {
          if(!(left_align == 0))
          {
            val_len=fmte->format(req_data, b, (signed int)space, parameter);
            if(!(val_len >= 1))
              val_len=fmt_none(req_data, b, (signed int)space, parameter);

            if(!(space >= (unsigned int)val_len))
              val_len = (signed int)space;

            b = b + (signed long int)val_len;
            i = 0;
            if(!((unsigned int)i >= width + -((unsigned int)val_len)))
            {
              b[(signed long int)i] = (char)32;
              i = i + 1;
            }

            b = b + (signed long int)(width - (unsigned int)val_len);
          }

          else
          {
            return_value_malloc$1=malloc((unsigned long int)(space + (unsigned int)1) * sizeof(char) /*1ul*/ );
            lb = (char *)return_value_malloc$1;
            if(!(lb == ((char *)NULL)))
            {
              val_len=fmte->format(req_data, lb, (signed int)space, parameter);
              if(!(val_len >= 1))
                val_len=fmt_none(req_data, lb, (signed int)space, parameter);

              if(!(space >= (unsigned int)val_len))
                val_len = (signed int)space;

              i = 0;
              if(!((unsigned int)i >= width + -((unsigned int)val_len)))
              {
                b[(signed long int)i] = (char)32;
                i = i + 1;
              }

              b = b + (signed long int)(width - (unsigned int)val_len);
              i = 0;
              if(!(i >= val_len))
              {
                b[(signed long int)i] = lb[(signed long int)i];
                i = i + 1;
              }

              b = b + (signed long int)val_len;
              free((void *)lb);
              lb = (char *)(void *)0;
            }

          }
          remains = remains - (signed int)width;
        }

        else
        {
          val_len=fmte->format(req_data, b, (signed int)space, parameter);
          if(!(val_len >= 1))
            val_len=fmt_none(req_data, b, (signed int)space, parameter);

          if(!(space >= (unsigned int)val_len))
            val_len = (signed int)space;

          b = b + (signed long int)val_len;
          remains = remains - val_len;
        }
        s = s + (signed long int)directive_len;
      }

      else
      {
        char *tmp_post$2 = b;
        b = b + 1l;
        const char *tmp_post$3 = s;
        s = s + 1l;
        *tmp_post$2 = *tmp_post$3;
        remains = remains - 1;
      }
    }

    else
    {
      char *tmp_post$4 = b;
      b = b + 1l;
      const char *tmp_post$5 = s;
      s = s + 1l;
      *tmp_post$4 = *tmp_post$5;
      remains = remains - 1;
    }
  }
  *b = (char)0;
  return len - remains;
}

// ci_get_data_group_id
// file filetype.c line 143
signed int ci_get_data_group_id(struct ci_magics_db *db, const char *group)
{
  signed int i = 0;
  i = 0;
  for( ; !(i >= db->groups_num); i = i + 1)
  {
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(group, (db->groups + (signed long int)i)->name);
    if(return_value_strcasecmp$1 == 0)
      return i;

  }
  return -1;
}

// ci_get_data_type_id
// file filetype.c line 133
signed int ci_get_data_type_id(struct ci_magics_db *db, const char *name)
{
  signed int i = 0;
  i = 0;
  for( ; !(i >= db->types_num); i = i + 1)
  {
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(name, (db->types + (signed long int)i)->name);
    if(return_value_strcasecmp$1 == 0)
      return i;

  }
  return -1;
}

// ci_hard_close
// file include/net_io.h line 156
signed int ci_hard_close(signed int fd)
{
  close(fd);
  return 1;
}

// ci_hash_add
// file include/hash.h line 54
void * ci_hash_add(struct ci_hash_table *htable, const void *key, const void *val)
{
  struct ci_hash_entry *e;
  unsigned int hash;
  unsigned long int return_value;
  return_value=htable->ops->size(key);
  hash=ci_hash_compute((unsigned long int)htable->hash_table_size, key, (signed int)return_value);
  /* assertion hash <= htable->hash_table_size */
  assert(hash <= htable->hash_table_size);
  void *return_value_1;
  return_value_1=htable->allocator->alloc(htable->allocator, sizeof(struct ci_hash_entry) /*32ul*/ );
  e = (struct ci_hash_entry *)return_value_1;
  if(e == ((struct ci_hash_entry *)NULL))
    return (void *)0;

  else
  {
    e->hnext = (struct ci_hash_entry *)(void *)0;
    e->key = key;
    e->val = val;
    e->hash = hash;
    e->hnext = htable->hash_table[(signed long int)hash];
    htable->hash_table[(signed long int)hash] = e;
    return (void *)e;
  }
}

// ci_hash_build
// file include/hash.h line 49
struct ci_hash_table * ci_hash_build(unsigned int hash_size, const struct ci_type_ops *ops, struct ci_mem_allocator *allocator)
{
  struct ci_hash_table *htable;
  unsigned int new_hash_size;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(struct ci_hash_table) /*32ul*/ );
  htable = (struct ci_hash_table *)return_value;
  if(htable == ((struct ci_hash_table *)NULL))
    return (struct ci_hash_table *)(void *)0;

  else
  {
    new_hash_size = (unsigned int)63;
    if(hash_size >= 64u)
    {
      if(!(new_hash_size >= 16777215u) && !(new_hash_size >= hash_size))
      {
        new_hash_size = new_hash_size + 1u;
        new_hash_size = (new_hash_size << 1) - (unsigned int)1;
      }

    }

    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Build hash table of size: %d, memallocated:%d\n", new_hash_size, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_hash_entry *) /*8ul*/ );

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Build hash table of size: %d, memallocated:%d\n", new_hash_size, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_hash_entry *) /*8ul*/ );

    }

    void *return_value_1;
    return_value_1=allocator->alloc(allocator, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_hash_entry *) /*8ul*/ );
    htable->hash_table = (struct ci_hash_entry **)return_value_1;
    if(htable->hash_table == ((struct ci_hash_entry **)NULL))
    {
      allocator->free(allocator, (void *)htable);
      return (struct ci_hash_table *)(void *)0;
    }

    else
    {
      memset((void *)htable->hash_table, 0, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_hash_entry *) /*8ul*/ );
      htable->hash_table_size = new_hash_size;
      htable->ops = ops;
      htable->allocator = allocator;
      return htable;
    }
  }
}

// ci_hash_compute
// file include/hash.h line 48
unsigned int ci_hash_compute(unsigned long int hash_max_value, const void *key, signed int len)
{
  unsigned long int hash = (unsigned long int)5381;
  const unsigned char *s = (const unsigned char *)key;
  signed int i;
  if(!(len == 0))
  {
    i = 0;
    for( ; !(i >= len); s = s + 1l)
    {
      hash = (hash << 5) + hash + (unsigned long int)*s;
      i = i + 1;
    }
  }

  else
    for( ; !(*s == 0); s = s + 1l)
      hash = (hash << 5) + hash + (unsigned long int)*s;
  if(hash == 0ul)
    hash = hash + 1ul;

  hash = hash & hash_max_value;
  return (unsigned int)hash;
}

// ci_hash_destroy
// file include/hash.h line 52
void ci_hash_destroy(struct ci_hash_table *htable)
{
  signed int i;
  struct ci_hash_entry *e;
  struct ci_mem_allocator *allocator = htable->allocator;
  i = 0;
  for( ; htable->hash_table_size >= (unsigned int)i; i = i + 1)
    if(!(htable->hash_table[(signed long int)i] == ((struct ci_hash_entry *)NULL)))
    {
      e = htable->hash_table[(signed long int)i];
      htable->hash_table[(signed long int)i] = htable->hash_table[(signed long int)i]->hnext;
      allocator->free(allocator, (void *)e);
    }

  htable->allocator->free(allocator, (void *)htable->hash_table);
  allocator->free(allocator, (void *)htable);
}

// ci_hash_search
// file include/hash.h line 53
const void * ci_hash_search(struct ci_hash_table *htable, const void *key)
{
  struct ci_hash_entry *e;
  unsigned int hash;
  unsigned long int return_value;
  return_value=htable->ops->size(key);
  hash=ci_hash_compute((unsigned long int)htable->hash_table_size, key, (signed int)return_value);
  /* assertion hash <= htable->hash_table_size */
  assert(hash <= htable->hash_table_size);
  e = htable->hash_table[(signed long int)hash];
  if(!(e == ((struct ci_hash_entry *)NULL)))
  {
    signed int return_value_1;
    return_value_1=htable->ops->compare(e->key, key);
    if(return_value_1 == 0)
      return e->val;

    e = e->hnext;
  }

  return (void *)0;
}

// ci_headers_add
// file include/header.h line 136
const char * ci_headers_add(struct ci_headers_list *h, const char *line)
{
  char *newhead;
  char **newspace;
  char *newbuf;
  signed int len;
  signed int linelen;
  signed int i = 0;
  unsigned long int return_value_strlen$4;
  if(!(h->packed == 0))
    return (const char *)(void *)0;

  else
  {
    if(h->used == h->size)
    {
      len = h->size + 64;
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)h->headers, (unsigned long int)len * sizeof(char *) /*8ul*/ );
      newspace = (char **)return_value_realloc$1;
      if(newspace == ((char **)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Server Error:Error allocation memory \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Server Error:Error allocation memory \n");

        }

        return (const char *)(void *)0;
      }

      h->headers = newspace;
      h->size = len;
    }

    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(line);
    linelen = (signed int)return_value_strlen$2;
    len = h->bufsize;
    for( ; !(len + -h->bufused >= 4 + linelen); len = len + 4096)
      ;
    if(!(h->bufsize >= len))
    {
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)h->buf, (unsigned long int)len * sizeof(char) /*1ul*/ );
      newbuf = (char *)return_value_realloc$3;
      if(newbuf == ((char *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Server Error:Error allocation memory \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Server Error:Error allocation memory \n");

        }

        return (const char *)(void *)0;
      }

      h->buf = newbuf;
      h->bufsize = len;
      h->headers[(signed long int)0] = h->buf;
      i = 1;
      for( ; !(i >= h->used); i = i + 1)
      {
        return_value_strlen$4=strlen(h->headers[(signed long int)(i - 1)]);
        h->headers[(signed long int)i] = h->headers[(signed long int)(i - 1)] + (signed long int)return_value_strlen$4 + (signed long int)2;
      }
    }

    newhead = h->buf + (signed long int)h->bufused;
    strcpy(newhead, line);
    h->bufused = h->bufused + linelen + 2;
    (newhead + (signed long int)linelen)[(signed long int)1] = (char)10;
    (newhead + (signed long int)linelen)[(signed long int)3] = (char)10;
    if(!(newhead == ((char *)NULL)))
    {
      signed int tmp_post$5 = h->used;
      h->used = h->used + 1;
      h->headers[(signed long int)tmp_post$5] = newhead;
    }

    return newhead;
  }
}

// ci_headers_addheaders
// file include/header.h line 145
signed int ci_headers_addheaders(struct ci_headers_list *h, const struct ci_headers_list *headers)
{
  signed int len;
  signed int i;
  char *newbuf;
  char **newspace;
  unsigned long int return_value_strlen$3;
  if(!(h->packed == 0))
    return 0;

  else
  {
    len = h->size;
    for( ; !(len + -h->used >= headers->used); len = len + 64)
      ;
    if(!(h->size >= len))
    {
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)h->headers, (unsigned long int)len * sizeof(char *) /*8ul*/ );
      newspace = (char **)return_value_realloc$1;
      if(newspace == ((char **)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Server Error: Error allocating memory \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Server Error: Error allocating memory \n");

        }

        return 0;
      }

      h->headers = newspace;
      h->size = len;
    }

    len = h->bufsize;
    for( ; !(len + -h->bufused >= 2 + headers->bufused); len = len + 4096)
      ;
    if(!(h->bufsize >= len))
    {
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)h->buf, (unsigned long int)len * sizeof(char) /*1ul*/ );
      newbuf = (char *)return_value_realloc$2;
      if(newbuf == ((char *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Server Error: Error allocating memory \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Server Error: Error allocating memory \n");

        }

        return 0;
      }

      h->buf = newbuf;
      h->bufsize = len;
    }

    memcpy((void *)(h->buf + (signed long int)h->bufused), (const void *)headers->buf, (unsigned long int)(headers->bufused + 2));
    h->bufused = h->bufused + headers->bufused;
    h->used = h->used + headers->used;
    h->headers[(signed long int)0] = h->buf;
    i = 1;
    for( ; !(i >= h->used); i = i + 1)
    {
      return_value_strlen$3=strlen(h->headers[(signed long int)(i - 1)]);
      h->headers[(signed long int)i] = h->headers[(signed long int)(i - 1)] + (signed long int)return_value_strlen$3 + (signed long int)2;
    }
    return 1;
  }
}

// ci_headers_copy_value
// file header.c line 343
const char * ci_headers_copy_value(struct ci_headers_list *h, const char *header, char *buf, unsigned long int len)
{
  const char *phead;
  signed int i;
  phead=ci_headers_search(h, header);
  const unsigned short int **return_value___ctype_b_loc$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(phead == ((const char *)NULL))
    return (const char *)(void *)0;

  else
  {
    if(!(h->packed == 0))
      for( ; !((signed int)*phead == 0); phead = phead + 1l)
      {
        if((signed int)*phead == 58)
          break;

        if((signed int)*phead == 13)
          break;

        if((signed int)*phead == 10)
          break;

      }

    else
      for( ; !((signed int)*phead == 0); phead = phead + 1l)
        if((signed int)*phead == 58)
          break;

    if(!((signed int)*phead == 58))
      return (const char *)(void *)0;

    else
    {
      phead = phead + 1l;
      do
      {
        return_value___ctype_b_loc$1=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*phead]) == 0)
          break;

        if((signed int)*phead == 0)
          break;

        phead = phead + 1l;
      }
      while((_Bool)1);
      i = 0;
      do
      {
        if(!((unsigned long int)i >= len + 18446744073709551615ul))
          tmp_if_expr$2 = (signed int)*phead != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*phead != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (signed int)*phead != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          break;

        buf[(signed long int)i] = *phead;
        i = i + 1;
        phead = phead + 1l;
      }
      while((_Bool)1);
      buf[(signed long int)i] = (char)0;
      return buf;
    }
  }
}

// ci_headers_create
// file header.c line 156
struct ci_headers_list * ci_headers_create()
{
  struct ci_headers_list *h;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ci_headers_list) /*40ul*/ );
  h = (struct ci_headers_list *)return_value_malloc$1;
  void *return_value_malloc$3;
  if(h == ((struct ci_headers_list *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocation memory for ci_headers_list_t (header.c: ci_headers_create)\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocation memory for ci_headers_list_t (header.c: ci_headers_create)\n");

    }

    return (struct ci_headers_list *)(void *)0;
  }

  else
  {
    h->headers = (char **)(void *)0;
    h->buf = (char *)(void *)0;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)64 * sizeof(char *) /*8ul*/ );
    h->headers = (char **)return_value_malloc$2;
    _Bool tmp_if_expr$4;
    if(h->headers == ((char **)NULL))
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_malloc$3=malloc((unsigned long int)4096 * sizeof(char) /*1ul*/ );
      h->buf = (char *)return_value_malloc$3;
      tmp_if_expr$4 = !(h->buf != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Server Error: Error allocation memory \n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Server Error: Error allocation memory \n");

      }

      if(!(h->headers == ((char **)NULL)))
        free((void *)h->headers);

      if(!(h->buf == ((char *)NULL)))
        free((void *)h->buf);

      free((void *)h);
      return (struct ci_headers_list *)(void *)0;
    }

    else
    {
      h->size = 64;
      h->used = 0;
      h->bufsize = 4096;
      h->bufused = 0;
      h->packed = 0;
      return h;
    }
  }
}

// ci_headers_destroy
// file header.c line 186
void ci_headers_destroy(struct ci_headers_list *h)
{
  free((void *)h->headers);
  free((void *)h->buf);
  free((void *)h);
}

// ci_headers_iterate
// file header.c line 424
signed int ci_headers_iterate(struct ci_headers_list *h, void *data, void (*fn)(void *, const char *, const char *))
{
  char header[256l];
  char value[8196l];
  char *s;
  signed int i;
  signed int j;
  i = 0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  if(!(i >= h->used))
  {
    s = h->headers[(signed long int)i];
    j = 0;
    do
    {
      if(!((unsigned long int)j >= 255ul))
        tmp_if_expr$1 = (signed int)*s != 58 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (signed int)*s != 32 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$5 = (_Bool)0;
      if(!tmp_if_expr$5)
        break;

      header[(signed long int)j] = *s;
      s = s + 1l;
      j = j + 1;
    }
    while((_Bool)1);
    header[(signed long int)j] = (char)0;
    j = 0;
    if((signed int)*s == 58)
      s = s + 1l;

    else
    {
      header[(signed long int)0] = (char)0;
      s = h->headers[(signed long int)i];
    }
    for( ; (signed int)*s == 32; s = s + 1l)
      ;
    j = 0;
    do
    {
      if(!((unsigned long int)j >= 8195ul))
        tmp_if_expr$6 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
      {
        if((signed int)*s == 13)
          tmp_if_expr$7 = (signed int)s[(signed long int)1] == 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$7 = (_Bool)0;
        if(tmp_if_expr$7)
          tmp_if_expr$8 = (signed int)s[(signed long int)2] != 9 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        if(tmp_if_expr$8)
          tmp_if_expr$9 = (signed int)s[(signed long int)2] != 32 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$9 = (_Bool)0;
        if(tmp_if_expr$9)
          tmp_if_expr$12 = (_Bool)1;

        else
        {
          if((signed int)*s == 10)
            tmp_if_expr$10 = (signed int)s[(signed long int)1] != 9 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$10 = (_Bool)0;
          if(tmp_if_expr$10)
            tmp_if_expr$11 = (signed int)s[(signed long int)1] != 32 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$11 = (_Bool)0;
          tmp_if_expr$12 = tmp_if_expr$11 ? (_Bool)1 : (_Bool)0;
        }
        tmp_if_expr$13 = !tmp_if_expr$12 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$13 = (_Bool)0;
      if(!tmp_if_expr$13)
        break;

      value[(signed long int)j] = *s;
      s = s + 1l;
      j = j + 1;
    }
    while((_Bool)1);
    value[(signed long int)j] = (char)0;
    fn(data, header, value);
    i = i + 1;
  }

  return 1;
}

// ci_headers_pack
// file include/header.h line 230
void ci_headers_pack(struct ci_headers_list *h)
{
  signed int i = 0;
  signed int len = 0;
  i = 0;
  for( ; !(i >= h->used); i = i + 1)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(h->headers[(signed long int)i]);
    len = (signed int)return_value_strlen$1;
    if((signed int)h->headers[(signed long int)i][(signed long int)(1 + len)] == 10)
      h->headers[(signed long int)i][(signed long int)len] = (char)13;

    else
      h->headers[(signed long int)i][(signed long int)len] = (char)10;
  }
  if((signed int)h->buf[(signed long int)(1 + h->bufused)] == 10)
  {
    h->buf[(signed long int)h->bufused] = (char)13;
    h->bufused = h->bufused + 2;
  }

  else
  {
    h->buf[(signed long int)h->bufused] = (char)10;
    h->bufused = h->bufused + 1;
  }
  h->packed = 1;
}

// ci_headers_remove
// file header.c line 369
signed int ci_headers_remove(struct ci_headers_list *h, const char *header)
{
  char *phead;
  signed int i;
  signed int j;
  signed int header_len;
  signed int rest_len;
  if(!(h->packed == 0))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= h->used); i = i + 1)
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(header);
      signed int return_value_strncasecmp$3;
      return_value_strncasecmp$3=strncasecmp(h->headers[(signed long int)i], header, return_value_strlen$2);
      if(return_value_strncasecmp$3 == 0)
      {
        phead = h->headers[(signed long int)i];
        if(i == h->used + -1)
        {
          phead = h->headers[(signed long int)i];
          *phead = (char)13;
          phead[(signed long int)1] = (char)10;
          h->bufused = (signed int)(phead - h->buf);
          h->used = h->used - 1;
          return 1;
        }

        else
        {
          header_len = (signed int)(h->headers[(signed long int)(i + 1)] - h->headers[(signed long int)i]);
          rest_len = (signed int)(((signed long int)h->bufused - (h->headers[(signed long int)i] - h->buf)) - (signed long int)header_len);
          if(CI_DEBUG_LEVEL >= 5)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "remove_header : remain len %d\n", rest_len);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("remove_header : remain len %d\n", rest_len);

          }

          memmove((void *)phead, (const void *)h->headers[(signed long int)(i + 1)], (unsigned long int)rest_len);
          h->bufused = h->bufused - header_len;
          h->used = h->used - 1;
          j = i + 1;
          for( ; !(j >= h->used); j = j + 1)
          {
            unsigned long int return_value_strlen$1;
            return_value_strlen$1=strlen(h->headers[(signed long int)(j - 1)]);
            header_len = (signed int)return_value_strlen$1;
            h->headers[(signed long int)j] = h->headers[(signed long int)(j - 1)] + (signed long int)header_len + (signed long int)1;
            if((signed int)*h->headers[(signed long int)j] == 10)
              h->headers[(signed long int)j] = h->headers[(signed long int)j] + 1l;

          }
          return 1;
        }
      }

    }
    return 0;
  }
}

// ci_headers_replace
// file header.c line 414
const char * ci_headers_replace(struct ci_headers_list *h, const char *header, const char *newval)
{
  if(!(h->packed == 0))
    return (const char *)(void *)0;

  else
    return (const char *)(void *)0;
}

// ci_headers_reset
// file include/header.h line 119
void ci_headers_reset(struct ci_headers_list *h)
{
  h->packed = 0;
  h->used = 0;
  h->bufused = 0;
}

// ci_headers_search
// file header.c line 318
const char * ci_headers_search(struct ci_headers_list *h, const char *header)
{
  signed int i = 0;
  for( ; !(i >= h->used); i = i + 1)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(header);
    signed int return_value_strncasecmp$2;
    return_value_strncasecmp$2=strncasecmp(h->headers[(signed long int)i], header, return_value_strlen$1);
    if(return_value_strncasecmp$2 == 0)
      return h->headers[(signed long int)i];

  }
  return (const char *)(void *)0;
}

// ci_headers_setsize
// file include/header.h line 121
signed int ci_headers_setsize(struct ci_headers_list *h, signed int size)
{
  char *newbuf;
  signed int new_size;
  if(!(size >= h->bufsize))
    return 1;

  else
  {
    new_size = (size / 4096 + 1) * 4096;
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)h->buf, (unsigned long int)new_size * sizeof(char) /*1ul*/ );
    newbuf = (char *)return_value_realloc$1;
    if(newbuf == ((char *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Server Error:Error allocation memory \n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Server Error:Error allocation memory \n");

      }

      return 0;
    }

    else
    {
      h->buf = newbuf;
      h->bufsize = new_size;
      return 1;
    }
  }
}

// ci_headers_unpack
// file include/header.h line 231
signed int ci_headers_unpack(struct ci_headers_list *h)
{
  signed int len;
  signed int eoh;
  char **newspace;
  char *shead;
  char *ebuf;
  char *str;
  _Bool tmp_if_expr$1;
  if(!(h->bufused >= 2))
    return 4;

  else
  {
    ebuf = (h->buf + (signed long int)h->bufused) - (signed long int)2;
    if(!((signed int)*ebuf == 13))
    {
      if((signed int)*ebuf == 10)
        goto __CPROVER_DUMP_L4;

      if(CI_DEBUG_LEVEL >= 3)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Parse error. The end chars are %c %c (%d %d) not the \\r \n", *ebuf, ebuf[(signed long int)1], (unsigned int)*ebuf, (unsigned int)ebuf[(signed long int)1]);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Parse error. The end chars are %c %c (%d %d) not the \\r \n", *ebuf, ebuf[(signed long int)1], (unsigned int)*ebuf, (unsigned int)ebuf[(signed long int)1]);

      }

      return 4;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      *ebuf = (char)0;
      shead = h->buf;
      h->headers[(signed long int)0] = h->buf;
      h->used = 1;
      str = h->buf;
      for( ; !(str >= ebuf); str = str + 1l)
      {
        eoh = 0;
        _Bool tmp_if_expr$5;
        if((signed int)*str == 13)
          tmp_if_expr$5 = (signed int)str[(signed long int)1] == 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        if(tmp_if_expr$5)
        {
          _Bool tmp_if_expr$2;
          if(str + 2l >= ebuf)
            tmp_if_expr$2 = (_Bool)1;

          else
          {
            if(!((signed int)str[2l] == 9))
              tmp_if_expr$1 = (signed int)str[(signed long int)2] != 32 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$1 = (_Bool)0;
            tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$2)
            eoh = 1;

        }

        else
        {
          _Bool tmp_if_expr$3;
          if((signed int)*str == 10)
            tmp_if_expr$3 = (signed int)str[(signed long int)1] != 9 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          _Bool tmp_if_expr$4;
          if(tmp_if_expr$3)
            tmp_if_expr$4 = (signed int)str[(signed long int)1] != 32 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(tmp_if_expr$4)
            eoh = 1;

          else
            if((signed int)*str == 0)
              *str = (char)32;

        }
        if(!(eoh == 0))
        {
          *str = (char)0;
          if(h->used >= h->size)
          {
            len = h->size + 64;
            void *return_value_realloc$6;
            return_value_realloc$6=realloc((void *)h->headers, (unsigned long int)len * sizeof(char *) /*8ul*/ );
            newspace = (char **)return_value_realloc$6;
            if(newspace == ((char **)NULL))
            {
              if(CI_DEBUG_LEVEL >= 1)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "Server Error: Error allocating memory \n");

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("Server Error: Error allocating memory \n");

              }

              return 11;
            }

            h->headers = newspace;
            h->size = len;
          }

          str = str + 1l;
          if((signed int)*str == 10)
            str = str + 1l;

          h->headers[(signed long int)h->used] = str;
          h->used = h->used + 1;
        }

      }
      h->packed = 0;
      return 0;
    }
  }
}

// ci_headers_value
// file include/header.h line 195
const char * ci_headers_value(struct ci_headers_list *h, const char *header)
{
  const char *phead;
  phead=ci_headers_search(h, header);
  const unsigned short int **return_value___ctype_b_loc$1;
  if(phead == ((const char *)NULL))
    return (const char *)(void *)0;

  else
  {
    for( ; !((signed int)*phead == 0); phead = phead + 1l)
      if((signed int)*phead == 58)
        break;

    if(!((signed int)*phead == 58))
      return (const char *)(void *)0;

    else
    {
      phead = phead + 1l;
      do
      {
        return_value___ctype_b_loc$1=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*phead]) == 0)
          break;

        if((signed int)*phead == 0)
          break;

        phead = phead + 1l;
      }
      while((_Bool)1);
      return phead;
    }
  }
}

// ci_host_to_sockaddr_t
// file include/net_io.h line 136
signed int ci_host_to_sockaddr_t(const char *servername, struct ci_sockaddr *addr, signed int proto)
{
  signed int ret = 0;
  struct addrinfo hints;
  struct addrinfo *res;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = proto;
  hints.ai_socktype = 1;
  hints.ai_protocol = 0;
  ret=getaddrinfo(servername, (const char *)(void *)0, &hints, &res);
  const char *return_value_gai_strerror$1;
  const char *return_value_gai_strerror$2;
  if(!(ret == 0))
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value_gai_strerror$1=gai_strerror(ret);
        __log_error((void *)0, "Error geting addrinfo:%s\n", return_value_gai_strerror$1);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value_gai_strerror$2=gai_strerror(ret);
        printf("Error geting addrinfo:%s\n", return_value_gai_strerror$2);
      }

    }

    return 0;
  }

  else
  {
    memcpy((void *)&addr->sockaddr, (const void *)res->ai_addr, sizeof(struct sockaddr_in) /*16ul*/ );
    freeaddrinfo(res);
    ci_fill_sockaddr(addr);
    return 1;
  }
}

// ci_http_client_ip
// file simple_api.c line 301
const struct ci_ip * ci_http_client_ip(struct ci_request *req)
{
  const char *ip;
  if(req == ((struct ci_request *)NULL))
    return (const struct ci_ip *)(void *)0;

  else
    if(req->xclient_ip.family == -1)
      return (const struct ci_ip *)(void *)0;

    else
      if(!(req->xclient_ip.family == 0))
        return &req->xclient_ip;

      else
      {
        ip=ci_headers_value(req->request_header, "X-Client-IP");
        if(ip == ((const char *)NULL))
          return (const struct ci_ip *)(void *)0;

        else
        {
          signed int return_value_ci_inet_aton$1;
          return_value_ci_inet_aton$1=ci_inet_aton(2, ip, (void *)&req->xclient_ip.address);
          if(!(return_value_ci_inet_aton$1 == 0))
          {
            req->xclient_ip.family = 2;
            req->xclient_ip.netmask.s_addr=htonl(0xFFFFFFFF);
          }

          else
            req->xclient_ip.family = -1;
          if(req->xclient_ip.family == -1)
            return (const struct ci_ip *)(void *)0;

          else
            return &req->xclient_ip;
        }
      }
}

// ci_http_content_length
// file simple_api.c line 207
signed long int ci_http_content_length(struct ci_request *req)
{
  struct ci_headers_list *heads;
  const char *val;
  signed long int res = (signed long int)0;
  char *e;
  heads=ci_http_response_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
  {
    heads=ci_http_request_headers(req);
    if(!(heads == ((struct ci_headers_list *)NULL)))
      goto __CPROVER_DUMP_L1;

    return (signed long int)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    val=ci_headers_value(heads, "Content-Length");
    if(val == ((const char *)NULL))
      return (signed long int)-1;

    else
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 0;
      res=strtoll(val, &e, 10);
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      if(*return_value___errno_location$2 == 34)
      {
        if(!(res == 0x7fffffffffffffffLL) && !(res == -9223372036854775808ll))
          goto __CPROVER_DUMP_L5;

        if(CI_DEBUG_LEVEL >= 4)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Content-Length: overflow\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Content-Length: overflow\n");

        }

        return (signed long int)-2;
      }

      else
      {

      __CPROVER_DUMP_L5:
        ;
        if(val == e)
        {
          if(CI_DEBUG_LEVEL >= 4)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Content-Length: not valid value: '%s' \n", val);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Content-Length: not valid value: '%s' \n", val);

          }

          return (signed long int)-2;
        }

        else
          return res;
      }
    }
  }
}

// ci_http_request
// file simple_api.c line 234
const char * ci_http_request(struct ci_request *req)
{
  struct ci_headers_list *heads;
  heads=ci_http_request_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return (const char *)(void *)0;

  else
    if(heads->used == 0)
      return (const char *)(void *)0;

    else
      return heads->headers[(signed long int)0];
}

// ci_http_request_add_header
// file include/simple_api.h line 231
const char * ci_http_request_add_header(struct ci_request *req, const char *header)
{
  struct ci_headers_list *heads;
  if(!(req->packed == 0))
    return (const char *)(void *)0;

  else
  {
    heads=ci_http_request_headers(req);
    if(heads == ((struct ci_headers_list *)NULL))
      return (const char *)(void *)0;

    else
    {
      const char *return_value_ci_headers_add$1;
      return_value_ci_headers_add$1=ci_headers_add(heads, header);
      return return_value_ci_headers_add$1;
    }
  }
}

// ci_http_request_create
// file simple_api.c line 119
signed int ci_http_request_create(struct ci_request *req, signed int has_body)
{
  signed int i = 0;
  struct ci_encaps_entity **e_list = req->entities;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    if(!(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)))
      ci_request_release_entity(req, i);

  i = 0;
  signed int tmp_post$1 = i;
  i = i + 1;
  req->entities[(signed long int)tmp_post$1]=ci_request_alloc_entity(req, 0, 0);
  if(!(has_body == 0))
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 2, 0);

  else
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 4, 0);
  return 1;
}

// ci_http_request_get_header
// file simple_api.c line 195
const char * ci_http_request_get_header(struct ci_request *req, const char *head_name)
{
  struct ci_headers_list *heads;
  const char *val;
  heads=ci_http_request_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return (const char *)(void *)0;

  else
  {
    val=ci_headers_value(heads, head_name);
    if(val == ((const char *)NULL))
      return (const char *)(void *)0;

    else
      return val;
  }
}

// ci_http_request_headers
// file simple_api.c line 52
struct ci_headers_list * ci_http_request_headers(struct ci_request *req)
{
  struct ci_encaps_entity **e_list = req->entities;
  if(!(*e_list == ((struct ci_encaps_entity *)NULL)))
  {
    if(!((*e_list)->type == 0))
      goto __CPROVER_DUMP_L1;

    return (struct ci_headers_list *)e_list[(signed long int)0]->entity;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(req->trash_entities[0l] == ((struct ci_encaps_entity *)NULL)))
    {
      if(req->trash_entities[0l]->entity == NULL)
        goto __CPROVER_DUMP_L2;

      if(((struct ci_headers_list *)req->trash_entities[0l]->entity)->used == 0)
        goto __CPROVER_DUMP_L2;

      return (struct ci_headers_list *)req->trash_entities[(signed long int)0]->entity;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      return (struct ci_headers_list *)(void *)0;
    }
  }
}

// ci_http_request_remove_header
// file simple_api.c line 173
signed int ci_http_request_remove_header(struct ci_request *req, const char *header)
{
  struct ci_headers_list *heads;
  if(!(req->packed == 0))
    return 0;

  else
  {
    heads=ci_http_request_headers(req);
    if(heads == ((struct ci_headers_list *)NULL))
      return 0;

    else
    {
      signed int return_value_ci_headers_remove$1;
      return_value_ci_headers_remove$1=ci_headers_remove(heads, header);
      return return_value_ci_headers_remove$1;
    }
  }
}

// ci_http_request_reset_headers
// file simple_api.c line 79
signed int ci_http_request_reset_headers(struct ci_request *req)
{
  struct ci_headers_list *heads;
  heads=ci_http_request_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return 0;

  else
  {
    ci_headers_reset(heads);
    return 1;
  }
}

// ci_http_request_url
// file simple_api.c line 257
signed int ci_http_request_url(struct ci_request *req, char *buf, signed int buf_size)
{
  struct ci_headers_list *heads;
  const char *str;
  const char *host;
  signed int i;
  signed int bytes;
  heads=ci_http_request_headers(req);
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$5;
  const unsigned short int **return_value___ctype_b_loc$4;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$10;
  const unsigned short int **return_value___ctype_b_loc$9;
  _Bool tmp_if_expr$11;
  if(heads == ((struct ci_headers_list *)NULL))
    return 0;

  else
    if(heads->used == 0)
      return 0;

    else
    {
      str = heads->headers[(signed long int)0];
      str=strchr(str, 32);
      if(str == ((const char *)NULL))
        return 0;

      else
      {
        for( ; (signed int)*str == 32; str = str + 1l)
          ;
        bytes = 0;
        if((signed int)*str == 47)
        {
          host=ci_headers_value(heads, "Host");
          if(!(host == ((const char *)NULL)))
          {
            i = 0;
            do
            {
              if(!(i >= buf_size + -1))
              {
                if((signed int)host[(signed long int)i] == 0)
                  tmp_if_expr$1 = (_Bool)1;

                else
                  tmp_if_expr$1 = (signed int)host[(signed long int)i] == 10 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$1)
                  tmp_if_expr$2 = (_Bool)1;

                else
                  tmp_if_expr$2 = (signed int)host[(signed long int)i] == 13 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr$3 = !tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$3 = (_Bool)0;
              if(tmp_if_expr$3)
              {
                return_value___ctype_b_loc$4=__ctype_b_loc();
                tmp_if_expr$5 = !(((signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)host[(signed long int)i]] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$5 = (_Bool)0;
              if(!tmp_if_expr$5)
                break;

              buf[(signed long int)i] = host[(signed long int)i];
              i = i + 1;
            }
            while((_Bool)1);
            buf = buf + (signed long int)i;
            buf_size = buf_size - i;
            bytes = i;
          }

        }

        i = 0;
        do
        {
          if(!(i >= buf_size + -1))
          {
            if((signed int)str[(signed long int)i] == 0)
              tmp_if_expr$6 = (_Bool)1;

            else
              tmp_if_expr$6 = (signed int)str[(signed long int)i] == 10 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$6)
              tmp_if_expr$7 = (_Bool)1;

            else
              tmp_if_expr$7 = (signed int)str[(signed long int)i] == 13 ? (_Bool)1 : (_Bool)0;
            tmp_if_expr$8 = !tmp_if_expr$7 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$8 = (_Bool)0;
          if(tmp_if_expr$8)
          {
            return_value___ctype_b_loc$9=__ctype_b_loc();
            tmp_if_expr$10 = !(((signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)str[(signed long int)i]] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$10 = (_Bool)0;
          if(tmp_if_expr$10)
            tmp_if_expr$11 = (signed int)str[(signed long int)i] != 63 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$11 = (_Bool)0;
          if(!tmp_if_expr$11)
            break;

          buf[(signed long int)i] = str[(signed long int)i];
          i = i + 1;
        }
        while((_Bool)1);
        buf[(signed long int)i] = (char)0;
        bytes = bytes + i;
        return bytes;
      }
    }
}

// ci_http_response_add_header
// file include/simple_api.h line 219
const char * ci_http_response_add_header(struct ci_request *req, const char *header)
{
  struct ci_headers_list *heads;
  if(!(req->packed == 0))
    return (const char *)(void *)0;

  else
  {
    heads=ci_http_response_headers(req);
    if(heads == ((struct ci_headers_list *)NULL))
      return (const char *)(void *)0;

    else
    {
      const char *return_value_ci_headers_add$1;
      return_value_ci_headers_add$1=ci_headers_add(heads, header);
      return return_value_ci_headers_add$1;
    }
  }
}

// ci_http_response_create
// file include/simple_api.h line 321
signed int ci_http_response_create(struct ci_request *req, signed int has_reshdr, signed int has_body)
{
  signed int i = 0;
  struct ci_encaps_entity **e_list = req->entities;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    if(!(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)))
      ci_request_release_entity(req, i);

  i = 0;
  if(!(has_reshdr == 0))
  {
    signed int tmp_post$1 = i;
    i = i + 1;
    req->entities[(signed long int)tmp_post$1]=ci_request_alloc_entity(req, 1, 0);
  }

  if(!(has_body == 0))
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 3, 0);

  else
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 4, 0);
  return 1;
}

// ci_http_response_get_header
// file simple_api.c line 184
const char * ci_http_response_get_header(struct ci_request *req, const char *head_name)
{
  struct ci_headers_list *heads;
  const char *val;
  heads=ci_http_response_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return (const char *)(void *)0;

  else
  {
    val=ci_headers_value(heads, head_name);
    if(val == ((const char *)NULL))
      return (const char *)(void *)0;

    else
      return val;
  }
}

// ci_http_response_headers
// file simple_api.c line 39
struct ci_headers_list * ci_http_response_headers(struct ci_request *req)
{
  signed int i;
  struct ci_encaps_entity **e_list = req->entities;
  i = 0;
  for( ; !(e_list[(signed long int)i] == ((struct ci_encaps_entity *)NULL)) && !(i >= 3); i = i + 1)
    if(e_list[(signed long int)i]->type == 1)
      return (struct ci_headers_list *)e_list[(signed long int)i]->entity;

  return (struct ci_headers_list *)(void *)0;
}

// ci_http_response_remove_header
// file simple_api.c line 162
signed int ci_http_response_remove_header(struct ci_request *req, const char *header)
{
  struct ci_headers_list *heads;
  if(!(req->packed == 0))
    return 0;

  else
  {
    heads=ci_http_response_headers(req);
    if(heads == ((struct ci_headers_list *)NULL))
      return 0;

    else
    {
      signed int return_value_ci_headers_remove$1;
      return_value_ci_headers_remove$1=ci_headers_remove(heads, header);
      return return_value_ci_headers_remove$1;
    }
  }
}

// ci_http_response_reset_headers
// file simple_api.c line 70
signed int ci_http_response_reset_headers(struct ci_request *req)
{
  struct ci_headers_list *heads;
  heads=ci_http_response_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return 0;

  else
  {
    ci_headers_reset(heads);
    return 1;
  }
}

// ci_icap_add_xheader
// file simple_api.c line 246
const char * ci_icap_add_xheader(struct ci_request *req, const char *header)
{
  const char *return_value_ci_headers_add$1;
  return_value_ci_headers_add$1=ci_headers_add(req->xheaders, header);
  return return_value_ci_headers_add$1;
}

// ci_icap_append_xheaders
// file simple_api.c line 251
signed int ci_icap_append_xheaders(struct ci_request *req, struct ci_headers_list *headers)
{
  signed int return_value_ci_headers_addheaders$1;
  return_value_ci_headers_addheaders$1=ci_headers_addheaders(req->xheaders, headers);
  return return_value_ci_headers_addheaders$1;
}

// ci_inet_aton
// file include/net_io.h line 119
signed int ci_inet_aton(signed int af, const char *cp, void *addr)
{
  signed int return_value_inet_aton$1;
  return_value_inet_aton$1=inet_aton(cp, (struct in_addr *)addr);
  return return_value_inet_aton$1;
}

// ci_inet_ntoa
// file include/net_io.h line 120
const char * ci_inet_ntoa(signed int af, const void *src, char *dst, signed int cnt)
{
  unsigned char *addr_bytes = (unsigned char *)src;
  snprintf(dst, (unsigned long int)cnt, "%d.%d.%d.%d", addr_bytes[(signed long int)0], addr_bytes[(signed long int)1], addr_bytes[(signed long int)2], addr_bytes[(signed long int)3]);
  dst[(signed long int)(cnt - 1)] = (char)0;
  return (const char *)dst;
}

// ci_internal_time
// file cache.c line 32
signed long int ci_internal_time()
{
  signed long int return_value_time$1;
  return_value_time$1=time((signed long int *)(void *)0);
  return return_value_time$1;
}

// ci_linger_close
// file include/net_io.h line 155
signed int ci_linger_close(signed int fd, signed int timeout)
{
  char buf[10l];
  signed int ret;
  if(CI_DEBUG_LEVEL >= 8)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Waiting to close connection\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Waiting to close connection\n");

  }

  signed int return_value_shutdown$1;
  return_value_shutdown$1=shutdown(fd, 1);
  signed int return_value_ci_wait_for_data$2;
  if(!(return_value_shutdown$1 == 0))
  {
    close(fd);
    return 1;
  }

  else
  {
    do
    {
      return_value_ci_wait_for_data$2=ci_wait_for_data(fd, timeout, 0x1);
      if(return_value_ci_wait_for_data$2 == 0)
        break;

      ret=ci_read_nonblock(fd, (void *)buf, (unsigned long int)10);
      if(!(ret >= 1))
        break;

      if(CI_DEBUG_LEVEL >= 10)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "OK I linger %d bytes.....\n", ret);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("OK I linger %d bytes.....\n", ret);

      }

    }
    while((_Bool)1);
    close(fd);
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Connection closed ...\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Connection closed ...\n");

    }

    return 1;
  }
}

// ci_list_cmp_handler
// file array.c line 536
void ci_list_cmp_handler(struct ci_list *list, signed int (*cmp_func)(const void *, const void *, unsigned long int))
{
  list->cmp_func = cmp_func;
}

// ci_list_copy_handler
// file array.c line 546
void ci_list_copy_handler(struct ci_list *list, signed int (*copy_func)(void *, const void *))
{
  list->copy_func = copy_func;
}

// ci_list_create
// file include/array.h line 619
struct ci_list * ci_list_create(unsigned long int init_size, unsigned long int obj_size)
{
  struct ci_list *list = (struct ci_list *)(void *)0;
  struct ci_mem_allocator *alloc = (struct ci_mem_allocator *)(void *)0;
  if(!(init_size >= 1024ul))
    init_size = (unsigned long int)1024;

  alloc=ci_create_serial_allocator((signed int)init_size);
  void *return_value;
  return_value=alloc->alloc(alloc, sizeof(struct ci_list) /*80ul*/ );
  list = (struct ci_list *)return_value;
  list->alloc = alloc;
  list->items = (struct ci_list_item *)(void *)0;
  list->last = (struct ci_list_item *)(void *)0;
  list->trash = (struct ci_list_item *)(void *)0;
  list->cursor = (struct ci_list_item *)(void *)0;
  list->obj_size = obj_size;
  list->cmp_func = (signed int (*)(const void *, const void *, unsigned long int))(void *)0;
  list->copy_func = (signed int (*)(void *, const void *))(void *)0;
  list->free_func = (void (*)(void *))(void *)0;
  return list;
}

// ci_list_destroy
// file include/array.h line 662
void ci_list_destroy(struct ci_list *list)
{
  struct ci_mem_allocator *alloc = list->alloc;
  ci_mem_allocator_destroy(alloc);
}

// ci_list_free_handler
// file array.c line 541
void ci_list_free_handler(struct ci_list *list, void (*free_func)(void *))
{
  list->free_func = free_func;
}

// ci_list_iterate
// file include/array.h line 671
void ci_list_iterate(struct ci_list *list, void *data, signed int (*fn)(void *, const void *))
{
  struct ci_list_item *it;
  list->cursor = list->items;
  if(!(list->cursor == ((struct ci_list_item *)NULL)))
  {
    it = list->cursor;
    list->cursor = list->cursor->next;
    signed int return_value;
    return_value=fn(data, it->item);
  }

}

// ci_list_pop
// file array.c line 617
void * ci_list_pop(struct ci_list *list, void *data)
{
  struct ci_list_item *it = list->items;
  if(list->items == ((struct ci_list_item *)NULL))
    return (void *)0;

  else
  {
    if(list->last == list->items)
    {
      list->last = (struct ci_list_item *)(void *)0;
      list->items = (struct ci_list_item *)(void *)0;
      list->cursor = (struct ci_list_item *)(void *)0;
    }

    else
    {
      if(list->cursor == list->items)
        list->cursor = list->items->next;

      list->items = list->items->next;
    }
    it->next = list->trash;
    list->trash = it;
    if(!(list->obj_size == 0ul))
    {
      memcpy(data, it->item, list->obj_size);
      if(!(list->copy_func == ((signed int (*)(void *, const void *))NULL)))
        list->copy_func(data, it->item);

      if(!(list->free_func == ((void (*)(void *))NULL)))
        list->free_func(it->item);

      return data;
    }

    else
    {
      *((void **)data) = it->item;
      return *((void **)data);
    }
  }
}

// ci_list_pop_back
// file array.c line 647
void * ci_list_pop_back(struct ci_list *list, void *data)
{
  struct ci_list_item *tmp;
  struct ci_list_item *it = list->last;
  _Bool tmp_if_expr$1;
  if(list->items == ((struct ci_list_item *)NULL))
    return (void *)0;

  else
  {
    if(list->last == list->items)
    {
      list->last = (struct ci_list_item *)(void *)0;
      list->items = (struct ci_list_item *)(void *)0;
      list->cursor = (struct ci_list_item *)(void *)0;
    }

    else
    {
      if(list->cursor == list->last)
        list->cursor = (struct ci_list_item *)(void *)0;

      tmp = list->items;
      do
      {
        if(!(tmp == ((struct ci_list_item *)NULL)))
          tmp_if_expr$1 = tmp->next != list->last ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(!tmp_if_expr$1)
          break;

        tmp = tmp->next;
      }
      while((_Bool)1);
      /* assertion tmp != ((void *)0) */
      assert(tmp != (struct ci_list_item *)(void *)0);
      list->last = tmp;
      list->last->next = (struct ci_list_item *)(void *)0;
    }
    it->next = list->trash;
    list->trash = it;
    if(!(list->obj_size == 0ul))
    {
      memcpy(data, it->item, list->obj_size);
      if(!(list->copy_func == ((signed int (*)(void *, const void *))NULL)))
        list->copy_func(data, it->item);

      if(!(list->free_func == ((void (*)(void *))NULL)))
        list->free_func(it->item);

      return data;
    }

    else
    {
      *((void **)data) = it->item;
      return *((void **)data);
    }
  }
}

// ci_list_push
// file include/array.h line 680
const void * ci_list_push(struct ci_list *list, const void *data)
{
  struct ci_list_item *it;
  it=list_alloc_item(list, data);
  if(it == ((struct ci_list_item *)NULL))
    return (void *)0;

  else
  {
    if(!(list->items == ((struct ci_list_item *)NULL)))
    {
      it->next = list->items;
      list->items = it;
    }

    else
    {
      list->last = it;
      list->items = list->last;
    }
    return it->item;
  }
}

// ci_list_push_back
// file array.c line 603
const void * ci_list_push_back(struct ci_list *list, const void *data)
{
  struct ci_list_item *it;
  it=list_alloc_item(list, data);
  if(it == ((struct ci_list_item *)NULL))
    return (void *)0;

  else
  {
    if(!(list->last == ((struct ci_list_item *)NULL)))
    {
      list->last->next = it;
      list->last = it;
    }

    else
    {
      list->last = it;
      list->items = list->last;
    }
    return it->item;
  }
}

// ci_list_remove
// file include/array.h line 716
signed int ci_list_remove(struct ci_list *list, const void *obj)
{
  struct ci_list_item *it;
  struct ci_list_item *prev;
  signed int (*cmp_func)(const void *, const void *, unsigned long int);
  if(!(list->cmp_func == ((signed int (*)(const void *, const void *, unsigned long int))NULL)))
    cmp_func = list->cmp_func;

  else
    if(!(list->obj_size == 0ul))
      cmp_func = default_cmp;

    else
      cmp_func = pointers_cmp;
  prev = (struct ci_list_item *)(void *)0;
  it = list->items;
  if(!(it == ((struct ci_list_item *)NULL)))
  {
    signed int return_value;
    return_value=cmp_func(it->item, obj, list->obj_size);
    if(return_value == 0)
    {
      if(!(prev == ((struct ci_list_item *)NULL)))
        prev->next = it->next;

      else
        list->items = it->next;
      if(list->cursor == it)
        list->cursor = list->cursor->next;

      it->next = list->trash;
      list->trash = it;
      if(!(list->free_func == ((void (*)(void *))NULL)))
      {
        if(!(list->obj_size == 0ul))
          list->free_func(it->item);

      }

      return 1;
    }

    prev = it;
    it = it->next;
  }

  return 0;
}

// ci_list_search
// file include/array.h line 725
const void * ci_list_search(struct ci_list *list, const void *data)
{
  struct ci_list_item *it;
  signed int (*cmp_func)(const void *, const void *, unsigned long int);
  if(!(list->cmp_func == ((signed int (*)(const void *, const void *, unsigned long int))NULL)))
    cmp_func = list->cmp_func;

  else
    if(!(list->obj_size == 0ul))
      cmp_func = default_cmp;

    else
      cmp_func = pointers_cmp;
  it = list->items;
  if(!(it == ((struct ci_list_item *)NULL)))
  {
    signed int return_value;
    return_value=cmp_func(it->item, data, list->obj_size);
    if(return_value == 0)
      return it->item;

    it = it->next;
  }

  return (void *)0;
}

// ci_list_search2
// file array.c line 742
const void * ci_list_search2(struct ci_list *list, const void *data, signed int (*cmp_func)(const void *, const void *, unsigned long int))
{
  struct ci_list_item *it = list->items;
  if(!(it == ((struct ci_list_item *)NULL)))
  {
    signed int return_value;
    return_value=cmp_func(it->item, data, list->obj_size);
    if(return_value == 0)
      return it->item;

    it = it->next;
  }

  return (void *)0;
}

// ci_list_sort
// file array.c line 752
void ci_list_sort(struct ci_list *list)
{
  signed int (*cmp_func)(const void *, const void *, unsigned long int);
  if(!(list->cmp_func == ((signed int (*)(const void *, const void *, unsigned long int))NULL)))
    cmp_func = list->cmp_func;

  else
    if(!(list->obj_size == 0ul))
      cmp_func = default_cmp;

    else
      cmp_func = pointers_cmp;
  ci_list_sort2(list, cmp_func);
}

// ci_list_sort2
// file array.c line 766
void ci_list_sort2(struct ci_list *list, signed int (*cmp_func)(const void *, const void *, unsigned long int))
{
  struct ci_list_item *it;
  struct ci_list_item *sortedHead = (struct ci_list_item *)(void *)0;
  struct ci_list_item *sortedTail = (struct ci_list_item *)(void *)0;
  struct ci_list_item **currentSorted;
  struct ci_list_item *currentHead;
  _Bool tmp_if_expr$1;
  if(list->items == ((struct ci_list_item *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(list->items->next != ((struct ci_list_item *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int return_value;
  if(!tmp_if_expr$1)
  {
    it = list->items;
    while(!(it == ((struct ci_list_item *)NULL)))
    {
      currentHead = it;
      it = it->next;
      currentSorted = &sortedHead;
      if(!(*currentSorted == ((struct ci_list_item *)NULL)))
      {
        return_value=cmp_func(currentHead->item, (*currentSorted)->item, list->obj_size);
        if(return_value >= 0)
          currentSorted = &(*currentSorted)->next;

      }

      currentHead->next = *currentSorted;
      *currentSorted = currentHead;
      if((*currentSorted)->next == ((struct ci_list_item *)NULL))
        sortedTail = *currentSorted;

    }
    list->items = sortedHead;
    list->last = sortedTail;
  }

}

// ci_local_cache_destroy
// file cache.c line 217
void ci_local_cache_destroy(struct ci_cache *cache)
{
  struct ci_cache_entry *e;
  struct ci_local_cache_data *cache_data = (struct ci_local_cache_data *)cache->cache_data;
  e = cache_data->first_queue_entry;
  if(!(e == ((struct ci_cache_entry *)NULL)))
  {
    cache_data->first_queue_entry = cache_data->first_queue_entry->qnext;
    if(!(e->key == NULL))
      cache->key_ops->free(e->key, cache_data->allocator);

    if(!(e->val == NULL))
    {
      if(e->val_size >= 1)
        cache_data->allocator->free(cache_data->allocator, e->val);

    }

    cache_data->allocator->free(cache_data->allocator, (void *)e);
    e = cache_data->first_queue_entry;
  }

  cache_data->allocator->free(cache_data->allocator, (void *)cache_data->hash_table);
  common_mutex_destroy(&cache_data->mtx);
  ci_mem_allocator_destroy(cache_data->allocator);
  free((void *)cache_data);
}

// ci_local_cache_init
// file cache.c line 135
signed int ci_local_cache_init(struct ci_cache *cache, const char *name)
{
  struct ci_local_cache_data *cache_data;
  signed int i;
  unsigned int new_hash_size;
  struct ci_mem_allocator *allocator;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ci_local_cache_data) /*128ul*/ );
  cache_data = (struct ci_local_cache_data *)return_value_malloc$1;
  if(cache_data == ((struct ci_local_cache_data *)NULL))
    return 0;

  else
  {
    cache->cache_data = (void *)cache_data;
    allocator=ci_create_os_allocator();
    if(allocator == ((struct ci_mem_allocator *)NULL))
    {
      free((void *)cache_data);
      return 0;
    }

    else
    {
      cache_data->allocator = allocator;
      void *return_value;
      return_value=allocator->alloc(allocator, sizeof(struct ci_cache_entry) /*56ul*/ );
      cache_data->first_queue_entry = (struct ci_cache_entry *)return_value;
      if(cache_data->first_queue_entry == ((struct ci_cache_entry *)NULL))
      {
        ci_mem_allocator_destroy(allocator);
        free((void *)cache_data);
        return 0;
      }

      else
      {
        cache_data->last_queue_entry = cache_data->first_queue_entry;
        cache_data->last_queue_entry->hnext = (struct ci_cache_entry *)(void *)0;
        cache_data->last_queue_entry->qnext = (struct ci_cache_entry *)(void *)0;
        cache_data->last_queue_entry->key = (void *)0;
        cache_data->last_queue_entry->val = (void *)0;
        cache_data->last_queue_entry->time = (signed long int)0;
        cache_data->last_queue_entry->hash = (unsigned int)0;
        unsigned int cache_items = (unsigned int)((unsigned long int)cache->mem_size / ((unsigned long int)cache->max_object_size + sizeof(struct ci_cache_entry) /*56ul*/ ));
        if(cache_items == 0u)
        {
          ci_mem_allocator_destroy(allocator);
          free((void *)cache_data);
          return 0;
        }

        else
        {
          i = 0;
          if(!((unsigned int)i >= cache_items + 4294967295u))
          {
            void *return_value_1;
            return_value_1=allocator->alloc(allocator, sizeof(struct ci_cache_entry) /*56ul*/ );
            cache_data->last_queue_entry->qnext = (struct ci_cache_entry *)return_value_1;
            if(cache_data->last_queue_entry->qnext == ((struct ci_cache_entry *)NULL))
            {
              ci_mem_allocator_destroy(allocator);
              return 0;
            }

            cache_data->last_queue_entry = cache_data->last_queue_entry->qnext;
            cache_data->last_queue_entry->hnext = (struct ci_cache_entry *)(void *)0;
            cache_data->last_queue_entry->qnext = (struct ci_cache_entry *)(void *)0;
            cache_data->last_queue_entry->key = (void *)0;
            cache_data->last_queue_entry->val = (void *)0;
            cache_data->last_queue_entry->time = (signed long int)0;
            cache_data->last_queue_entry->hash = (unsigned int)0;
            i = i + 1;
          }

          new_hash_size = (unsigned int)63;
          if(cache_items >= 64u)
          {
            if(!(new_hash_size >= 16777215u) && !(new_hash_size >= cache_items))
            {
              new_hash_size = new_hash_size + 1u;
              new_hash_size = (new_hash_size << 1) - (unsigned int)1;
            }

          }

          if(CI_DEBUG_LEVEL >= 7)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Hash size: %d\n", new_hash_size);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Hash size: %d\n", new_hash_size);

          }

          void *return_value_2;
          return_value_2=allocator->alloc(allocator, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_cache_entry *) /*8ul*/ );
          cache_data->hash_table = (struct ci_cache_entry **)return_value_2;
          if(cache_data->hash_table == ((struct ci_cache_entry **)NULL))
          {
            ci_mem_allocator_destroy(allocator);
            free((void *)cache);
            free((void *)cache_data);
            return 0;
          }

          else
          {
            memset((void *)cache_data->hash_table, 0, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_cache_entry *) /*8ul*/ );
            cache_data->hash_table_size = new_hash_size;
            common_mutex_init(&cache_data->mtx, 0);
            return 1;
          }
        }
      }
    }
  }
}

// ci_local_cache_search
// file cache.c line 238
const void * ci_local_cache_search(struct ci_cache *cache, const void *key, void **val, void *data, void * (*dup_from_cache)(const void *, unsigned long int, void *))
{
  struct ci_cache_entry *e;
  struct ci_local_cache_data *cache_data;
  signed long int current_time;
  cache_data = (struct ci_local_cache_data *)cache->cache_data;
  unsigned int hash;
  unsigned long int return_value;
  return_value=cache->key_ops->size(key);
  hash=ci_hash_compute((unsigned long int)cache_data->hash_table_size, key, (signed int)return_value);
  /* assertion hash <= cache_data->hash_table_size */
  assert(hash <= cache_data->hash_table_size);
  common_mutex_lock(&cache_data->mtx);
  e = cache_data->hash_table[(signed long int)hash];
  *val = (void *)0;
  if(!(e == ((struct ci_cache_entry *)NULL)))
  {
    if(CI_DEBUG_LEVEL >= 10)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, " \t\t->>>>Val %s\n", (char *)e->val);

      if(!(CI_DEBUG_STDOUT == 0))
        printf(" \t\t->>>>Val %s\n", (char *)e->val);

    }

    if(CI_DEBUG_LEVEL >= 10)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, " \t\t->>>>compare %s ~ %s\n", (char *)e->key, (char *)key);

      if(!(CI_DEBUG_STDOUT == 0))
        printf(" \t\t->>>>compare %s ~ %s\n", (char *)e->key, (char *)key);

    }

    signed int return_value_1;
    return_value_1=cache->key_ops->compare(e->key, key);
    if(return_value_1 == 0)
    {
      current_time=ci_internal_time();
      if(!(cache->ttl >= current_time + -e->time))
        key = (void *)0;

      else
        if(!(e->val_size == 0))
        {
          if(!(dup_from_cache == ((void * (*)(const void *, unsigned long int, void *))NULL)))
            *val=dup_from_cache(e->val, (unsigned long int)e->val_size, data);

          else
          {
            *val=ci_buffer_alloc(e->val_size);
            memcpy(*val, e->val, (unsigned long int)e->val_size);
          }
        }

      common_mutex_unlock(&cache_data->mtx);
      return key;
    }

    /* assertion e != e->hnext */
    assert(e != e->hnext);
    e = e->hnext;
  }

  common_mutex_unlock(&cache_data->mtx);
  return (void *)0;
}

// ci_local_cache_update
// file cache.c line 277
signed int ci_local_cache_update(struct ci_cache *cache, const void *key, const void *val, unsigned long int val_size, void * (*copy_to_cache)(void *, const void *, unsigned long int))
{
  struct ci_cache_entry *e;
  struct ci_cache_entry *tmp;
  signed int key_size;
  signed long int current_time;
  struct ci_local_cache_data *cache_data;
  unsigned int hash;
  cache_data = (struct ci_local_cache_data *)cache->cache_data;
  unsigned long int return_value;
  return_value=cache->key_ops->size(key);
  hash=ci_hash_compute((unsigned long int)cache_data->hash_table_size, key, (signed int)return_value);
  /* assertion hash <= cache_data->hash_table_size */
  assert(hash <= cache_data->hash_table_size);
  if(CI_DEBUG_LEVEL >= 10)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Adding :%s:%p\n", (char *)key, (char *)val);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Adding :%s:%p\n", (char *)key, (char *)val);

  }

  current_time=ci_internal_time();
  common_mutex_lock(&cache_data->mtx);
  e = cache_data->first_queue_entry;
  if(!(current_time + -e->time >= cache->ttl))
  {
    if(CI_DEBUG_LEVEL >= 6)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_cache_update: not available slot (%d-%d %d).\n", (unsigned int)current_time, (unsigned int)e->time, (unsigned int)cache->ttl);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_cache_update: not available slot (%d-%d %d).\n", (unsigned int)current_time, (unsigned int)e->time, (unsigned int)cache->ttl);

    }

    common_mutex_unlock(&cache_data->mtx);
    return 0;
  }

  else
  {
    if(!(e->key == NULL))
    {
      cache->key_ops->free(e->key, cache_data->allocator);
      e->key = (void *)0;
    }

    if(!(e->val == NULL))
    {
      if(e->val_size >= 1)
      {
        cache_data->allocator->free(cache_data->allocator, e->val);
        e->val = (void *)0;
      }

    }

    /* assertion e->hash <= cache_data->hash_table_size */
    assert(e->hash <= cache_data->hash_table_size);
    tmp = cache_data->hash_table[(signed long int)e->hash];
    if(tmp == e)
      cache_data->hash_table[(signed long int)e->hash] = tmp->hnext;

    else
      if(!(tmp == ((struct ci_cache_entry *)NULL)))
      {
        if(!(tmp->hnext == ((struct ci_cache_entry *)NULL)))
        {
          if(!(e == tmp->hnext))
            tmp = tmp->hnext;

        }

        if(!(tmp->hnext == ((struct ci_cache_entry *)NULL)))
          tmp->hnext = tmp->hnext->hnext;

      }

    e->hnext = (struct ci_cache_entry *)(void *)0;
    e->time = (signed long int)0;
    e->hash = (unsigned int)0;
    unsigned long int return_value_1;
    return_value_1=cache->key_ops->size(key);
    key_size = (signed int)return_value_1;
    e->key=cache_data->allocator->alloc(cache_data->allocator, (unsigned long int)key_size);
    if(e->key == NULL)
    {
      common_mutex_unlock(&cache_data->mtx);
      if(CI_DEBUG_LEVEL >= 6)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_cache_update: failed to allocate memory for key.\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_cache_update: failed to allocate memory for key.\n");

      }

      return 0;
    }

    else
    {
      memcpy(e->key, key, (unsigned long int)key_size);
      if(val_size >= 1ul && !(val == NULL))
      {
        e->val=cache_data->allocator->alloc(cache_data->allocator, val_size);
        e->val_size = (signed int)val_size;
        if(!(e->val == NULL))
        {
          if(!(copy_to_cache == ((void * (*)(void *, const void *, unsigned long int))NULL)))
          {
            void *return_value_2;
            return_value_2=copy_to_cache(e->val, val, (unsigned long int)e->val_size);
            if(return_value_2 == NULL)
            {
              cache_data->allocator->free(cache_data->allocator, e->val);
              e->val = (void *)0;
            }

          }

          else
            memcpy(e->val, val, (unsigned long int)e->val_size);
        }

        if(e->val == NULL)
        {
          cache_data->allocator->free(cache_data->allocator, e->key);
          e->key = (void *)0;
          common_mutex_unlock(&cache_data->mtx);
          if(CI_DEBUG_LEVEL >= 6)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "ci_cache_update: failed to allocate memory for cache data.\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("ci_cache_update: failed to allocate memory for cache data.\n");

          }

          return 0;
        }

      }

      else
      {
        e->val = (void *)0;
        e->val_size = 0;
      }
      e->hash = hash;
      e->time = current_time;
      cache_data->first_queue_entry = cache_data->first_queue_entry->qnext;
      cache_data->last_queue_entry->qnext = e;
      cache_data->last_queue_entry = e;
      e->qnext = (struct ci_cache_entry *)(void *)0;
      if(!(cache_data->hash_table[(signed long int)hash] == ((struct ci_cache_entry *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 10)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "\t\t:::Found %s\n", (char *)cache_data->hash_table[(signed long int)hash]->val);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("\t\t:::Found %s\n", (char *)cache_data->hash_table[(signed long int)hash]->val);

        }

      }

      e->hnext = cache_data->hash_table[(signed long int)hash];
      cache_data->hash_table[(signed long int)hash] = e;
      common_mutex_unlock(&cache_data->mtx);
      return 1;
    }
  }
}

// ci_lookup_table_create
// file include/lookup_table.h line 86
struct ci_lookup_table * ci_lookup_table_create(const char *table)
{
  struct ci_mem_allocator *allocator;
  struct ci_lookup_table *lt;
  allocator=ci_create_os_allocator();
  if(allocator == ((struct ci_mem_allocator *)NULL))
    return (struct ci_lookup_table *)(void *)0;

  else
  {
    lt=ci_lookup_table_create_ext(table, &ci_str_ops, &ci_str_ops, allocator);
    if(lt == ((struct ci_lookup_table *)NULL))
      ci_mem_allocator_destroy(allocator);

    return lt;
  }
}

// ci_lookup_table_create_ext
// file lookup_table.c line 69
struct ci_lookup_table * ci_lookup_table_create_ext(const char *table, const struct ci_type_ops *key_ops, const struct ci_type_ops *val_ops, struct ci_mem_allocator *allocator)
{
  char *ttype;
  char *path;
  char *args;
  char *s;
  struct ci_lookup_table_type *lt_type;
  struct ci_lookup_table *lt;
  char *stable;
  stable=strdup(table);
  if(stable == ((char *)NULL))
    return (struct ci_lookup_table *)(void *)0;

  else
  {
    s=index(stable, 58);
    if(s == ((char *)NULL))
    {
      ttype = "file";
      path = stable;
      args = (char *)(void *)0;
    }

    else
    {
      ttype = stable;
      path = s + (signed long int)1;
      *s = (char)0;
      s=index(path, 123);
      if(!(s == ((char *)NULL)))
      {
        *s = (char)0;
        args = s + (signed long int)1;
        s=index(args, 125);
        if(!(s == ((char *)NULL)))
          *s = (char)0;

      }

      else
        args = (char *)(void *)0;
    }
    lt_type=ci_lookup_table_type_search(ttype);
    _Bool tmp_if_expr$1;
    if(lt_type == ((struct ci_lookup_table_type *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = !(lt_type->open != ((void * (*)(struct ci_lookup_table *))NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Not lookuptable of type :%s!!!\n", ttype);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Not lookuptable of type :%s!!!\n", ttype);

      }

      free((void *)stable);
      return (struct ci_lookup_table *)(void *)0;
    }

    else
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(struct ci_lookup_table) /*120ul*/ );
      lt = (struct ci_lookup_table *)return_value_malloc$2;
      if(lt == ((struct ci_lookup_table *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "memory allocation error!!");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("memory allocation error!!");

        }

        free((void *)stable);
        return (struct ci_lookup_table *)(void *)0;
      }

      else
      {
        lt->path=strdup(path);
        if(!(args == ((char *)NULL)))
          lt->args=strdup(args);

        else
          lt->args = (char *)(void *)0;
        free((void *)stable);
        lt->cols = -1;
        lt->key_ops = key_ops;
        lt->val_ops = val_ops;
        lt->type = lt_type->type;
        lt->open = lt_type->open;
        lt->close = lt_type->close;
        lt->search = lt_type->search;
        lt->get_row = lookup_table_get_row;
        lt->release_result = lt_type->release_result;
        lt->allocator = allocator;
        lt->_lt_type = lt_type;
        lt->data = (void *)0;
        return lt;
      }
    }
  }
}

// ci_lookup_table_destroy
// file include/lookup_table.h line 94
void ci_lookup_table_destroy(struct ci_lookup_table *lt)
{
  if(!(lt == ((struct ci_lookup_table *)NULL)))
  {
    lt->close(lt);
    free((void *)lt->path);
    if(!(lt->args == ((char *)NULL)))
      free((void *)lt->args);

    if(!(lt->allocator == ((struct ci_mem_allocator *)NULL)))
      ci_mem_allocator_destroy(lt->allocator);

    free((void *)lt);
  }

}

// ci_lookup_table_get_row
// file lookup_table.c line 228
const char * ci_lookup_table_get_row(struct ci_lookup_table *table, const char *key, const char **columns, char ***vals)
{
  _Bool tmp_if_expr$1;
  if(table->key_ops == &ci_str_ops)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = table->key_ops == &ci_str_ext_ops ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = table->key_ops == &ci_regex_ops ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!tmp_if_expr$2)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    if(table->val_ops == &ci_str_ops)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = table->val_ops == &ci_str_ext_ops ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = table->val_ops == &ci_regex_ops ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$5 = !tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s does not support search with string like keys!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s does not support search with string like keys!\n", table->type);

    }

    return (const char *)(void *)0;
  }

  else
  {
    const void *return_value_lookup_table_get_row$6;
    return_value_lookup_table_get_row$6=lookup_table_get_row(table, (const void *)key, columns, (void ***)vals);
    return (const char *)return_value_lookup_table_get_row$6;
  }
}

// ci_lookup_table_open
// file lookup_table.c line 172
void * ci_lookup_table_open(struct ci_lookup_table *table)
{
  _Bool tmp_if_expr$1;
  if(table->_lt_type == ((struct ci_lookup_table_type *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(table->open != ((void * (*)(struct ci_lookup_table *))NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s is corrupted (\"open\" method missing)!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s is corrupted (\"open\" method missing)!\n", table->type);

    }

    return (void *)0;
  }

  else
  {
    void *return_value;
    return_value=table->open(table);
    return return_value;
  }
}

// ci_lookup_table_release_result
// file lookup_table.c line 196
void ci_lookup_table_release_result(struct ci_lookup_table *table, void **val)
{
  _Bool tmp_if_expr$1;
  if(table->_lt_type == ((struct ci_lookup_table_type *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(table->release_result != ((void (*)(struct ci_lookup_table *, void **))NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s is corrupted (\"release_result\" method missing)!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s is corrupted (\"release_result\" method missing)!\n", table->type);

    }

  }

  else
    table->release_result(table, (void **)val);
}

// ci_lookup_table_search
// file lookup_table.c line 181
const char * ci_lookup_table_search(struct ci_lookup_table *table, const char *key, char ***vals)
{
  _Bool tmp_if_expr$1;
  if(table->_lt_type == ((struct ci_lookup_table_type *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(table->search != ((void * (*)(struct ci_lookup_table *, void *, void ***))NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s is corrupted (\"search\" method missing)!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s is corrupted (\"search\" method missing)!\n", table->type);

    }

    return (const char *)(void *)0;
  }

  else
  {
    _Bool tmp_if_expr$2;
    if(table->key_ops == &ci_str_ops)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = table->key_ops == &ci_str_ext_ops ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$3;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = table->key_ops == &ci_regex_ops ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$6;
    if(!tmp_if_expr$3)
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      if(table->val_ops == &ci_str_ops)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = table->val_ops == &ci_str_ext_ops ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = table->val_ops == &ci_regex_ops ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$6 = !tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "lookup_table of type  %s does not support search with string like keys!\n", table->type);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("lookup_table of type  %s does not support search with string like keys!\n", table->type);

      }

      return (const char *)(void *)0;
    }

    else
    {
      void *return_value;
      return_value=table->search(table, (void *)key, (void ***)vals);
      return (const char *)return_value;
    }
  }
}

// ci_lookup_table_type_register
// file lookup_table.c line 36
struct ci_lookup_table_type * ci_lookup_table_type_register(struct ci_lookup_table_type *lt_type)
{
  if(lookup_tables_types_num >= 128)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "c-icap does not support more than 128 loookup table types");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("c-icap does not support more than 128 loookup table types");

    }

    return (struct ci_lookup_table_type *)(void *)0;
  }

  else
  {
    signed int tmp_post$1 = lookup_tables_types_num;
    lookup_tables_types_num = lookup_tables_types_num + 1;
    lookup_tables_types[(signed long int)tmp_post$1] = lt_type;
    return lt_type;
  }
}

// ci_lookup_table_type_search
// file lookup_table.c line 58
struct ci_lookup_table_type * ci_lookup_table_type_search(const char *type)
{
  signed int i = 0;
  for( ; !(i >= lookup_tables_types_num); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(type, lookup_tables_types[(signed long int)i]->type);
    if(return_value_strcmp$1 == 0)
      return lookup_tables_types[(signed long int)i];

  }
  return (struct ci_lookup_table_type *)(void *)0;
}

// ci_lookup_table_type_unregister
// file lookup_table.c line 46
void ci_lookup_table_type_unregister(struct ci_lookup_table_type *lt_type)
{
  signed int i = 0;
  for( ; !(lookup_tables_types[(signed long int)i] == lt_type) && !(i >= lookup_tables_types_num); i = i + 1)
    ;
  if(!(i >= lookup_tables_types_num))
  {
    lookup_tables_types_num = lookup_tables_types_num - 1;
    for( ; !(i >= lookup_tables_types_num); i = i + 1)
      lookup_tables_types[(signed long int)i] = lookup_tables_types[(signed long int)(i + 1)];
  }

}

// ci_magic_data_type
// file filetype.c line 711
signed int ci_magic_data_type(const char *buf, signed int len)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
  {
    signed int return_value_ci_filetype$1;
    return_value_ci_filetype$1=ci_filetype(_MAGIC_DB, buf, len);
    return return_value_ci_filetype$1;
  }
}

// ci_magic_data_type_ext
// file filetype.c line 720
signed int ci_magic_data_type_ext(struct ci_headers_list *headers, const char *buf, signed int len, signed int *iscompressed)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
  {
    signed int return_value_extend_object_type$1;
    return_value_extend_object_type$1=extend_object_type(_MAGIC_DB, headers, buf, len, iscompressed);
    return return_value_extend_object_type$1;
  }
}

// ci_magic_db_free
// file include/filetype.h line 106
void ci_magic_db_free()
{
  if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
    ci_magics_db_release(_MAGIC_DB);

  _MAGIC_DB = (struct ci_magics_db *)(void *)0;
}

// ci_magic_db_load
// file include/filetype.h line 104
struct ci_magics_db * ci_magic_db_load(const char *filename)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
  {
    _MAGIC_DB=ci_magics_db_build(filename);
    return _MAGIC_DB;
  }

  else
  {
    signed int return_value_ci_magics_db_file_add$1;
    return_value_ci_magics_db_file_add$1=ci_magics_db_file_add(_MAGIC_DB, filename);
    if(!(return_value_ci_magics_db_file_add$1 == 0))
      return _MAGIC_DB;

    else
      return (struct ci_magics_db *)(void *)0;
  }
}

// ci_magic_group_check
// file filetype.c line 745
signed int ci_magic_group_check(signed int type, signed int group)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return 0;

  else
  {
    signed int return_value_ci_belongs_to_group$1;
    return_value_ci_belongs_to_group$1=ci_belongs_to_group(_MAGIC_DB, type, group);
    return return_value_ci_belongs_to_group$1;
  }
}

// ci_magic_group_id
// file filetype.c line 737
signed int ci_magic_group_id(const char *group)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
  {
    signed int return_value_ci_get_data_group_id$1;
    return_value_ci_get_data_group_id$1=ci_get_data_group_id(_MAGIC_DB, group);
    return return_value_ci_get_data_group_id$1;
  }
}

// ci_magic_group_name
// file filetype.c line 783
char * ci_magic_group_name(signed int group)
{
  _Bool tmp_if_expr$2;
  signed int tmp_if_expr$1;
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL) || !(group >= 1))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr$1 = _MAGIC_DB->groups_num;

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = group >= tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    return (char *)(void *)0;

  else
  {
    _Bool tmp_if_expr$3;
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr$3 = group < _MAGIC_DB->groups_num ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    char *tmp_if_expr$4;
    if(group >= 0 && tmp_if_expr$3)
      tmp_if_expr$4 = (_MAGIC_DB->groups + (signed long int)group)->name;

    else
      tmp_if_expr$4 = (char *)(void *)0;
    return tmp_if_expr$4;
  }
}

// ci_magic_groups_count
// file filetype.c line 760
signed int ci_magic_groups_count()
{
  signed int tmp_if_expr$1;
  if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
    tmp_if_expr$1 = _MAGIC_DB->groups_num;

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// ci_magic_req_data_type
// file filetype.c line 694
signed int ci_magic_req_data_type(struct ci_request *req, signed int *isencoded)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
    if(req->preview_data.used == 0)
      return -1;

    else
    {
      if(!(req->preview_data_type >= 0))
        req->preview_data_type=ci_extend_filetype(_MAGIC_DB, req, req->preview_data.buf, req->preview_data.used, isencoded);

      return req->preview_data_type;
    }
}

// ci_magic_type_descr
// file filetype.c line 774
char * ci_magic_type_descr(signed int type)
{
  _Bool tmp_if_expr$2;
  signed int tmp_if_expr$1;
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL) || !(type >= 1))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr$1 = _MAGIC_DB->types_num;

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = type >= tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    return (char *)(void *)0;

  else
  {
    _Bool tmp_if_expr$3;
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr$3 = type < _MAGIC_DB->types_num ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    char *tmp_if_expr$4;
    if(type >= 0 && tmp_if_expr$3)
      tmp_if_expr$4 = (_MAGIC_DB->types + (signed long int)type)->descr;

    else
      tmp_if_expr$4 = (char *)(void *)0;
    return tmp_if_expr$4;
  }
}

// ci_magic_type_id
// file filetype.c line 729
signed int ci_magic_type_id(const char *name)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
  {
    signed int return_value_ci_get_data_type_id$1;
    return_value_ci_get_data_type_id$1=ci_get_data_type_id(_MAGIC_DB, name);
    return return_value_ci_get_data_type_id$1;
  }
}

// ci_magic_type_name
// file filetype.c line 765
char * ci_magic_type_name(signed int type)
{
  _Bool tmp_if_expr$2;
  signed int tmp_if_expr$1;
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL) || !(type >= 1))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr$1 = _MAGIC_DB->types_num;

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = type >= tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    return (char *)(void *)0;

  else
  {
    char *tmp_if_expr$3;
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr$3 = (_MAGIC_DB->types + (signed long int)type)->name;

    else
      tmp_if_expr$3 = (char *)(void *)0;
    return tmp_if_expr$3;
  }
}

// ci_magic_types_count
// file filetype.c line 754
signed int ci_magic_types_count()
{
  signed int tmp_if_expr$1;
  if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
    tmp_if_expr$1 = _MAGIC_DB->types_num;

  else
    tmp_if_expr$1 = 0;
  return tmp_if_expr$1;
}

// ci_magics_db_build
// file filetype.c line 358
struct ci_magics_db * ci_magics_db_build(const char *filename)
{
  struct ci_magics_db *db;
  db=ci_magics_db_init();
  if(!(db == ((struct ci_magics_db *)NULL)))
    ci_magics_db_file_add(db, filename);

  return db;
}

// ci_magics_db_file_add
// file filetype.c line 302
signed int ci_magics_db_file_add(struct ci_magics_db *db, const char *filename)
{
  signed int type;
  signed int ret;
  signed int group;
  signed int i;
  signed int lineNum;
  signed int groups[65l];
  char line[32768l];
  struct ci_magic_record record;
  struct _IO_FILE *f;
  f=fopen64(filename, "r");
  char *return_value_fgets$1;
  if(f == ((struct _IO_FILE *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error opening magic file: %s\n", filename);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error opening magic file: %s\n", filename);

    }

    return 0;
  }

  else
  {
    lineNum = 0;
    ret = 0;
    do
    {
      return_value_fgets$1=fgets(line, 32768, f);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      lineNum = lineNum + 1;
      ret=parse_record(line, &record);
      if(!(ret == 0))
      {
        if(!(ret >= 0))
          break;

        type=ci_get_data_type_id(db, record.type);
        if(!(type >= 0))
        {
          i = 0;
          for( ; !(record.groups[(signed long int)i] == ((char *)NULL)); i = i + 1)
          {
            if(i >= 64)
              break;

            group=ci_get_data_group_id(db, record.groups[(signed long int)i]);
            if(!(group >= 0))
              group=groups_add(db, record.groups[(signed long int)i], "");

            groups[(signed long int)i] = group;
          }
          groups[(signed long int)i] = -1;
          type=types_add(db, record.type, record.descr, groups);
          if(!(type >= 0))
          {
            ret = -2;
            break;
          }

        }

        magics_add(db, record.offset, record.magic, record.len, (signed int)(unsigned int)type);
        free_records_group(&record);
      }

    }
    while((_Bool)1);
    fclose(f);
    if(!(ret >= 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error reading magic file (%d), line number: %d\nBuggy line: %s\n", ret, lineNum, (const void *)line);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error reading magic file (%d), line number: %d\nBuggy line: %s\n", ret, lineNum, (const void *)line);

      }

      return 0;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 3)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "In database: magic: %d, types: %d, groups: %d\n", db->magics_num, db->types_num, db->groups_num);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("In database: magic: %d, types: %d, groups: %d\n", db->magics_num, db->types_num, db->groups_num);

      }

      return 1;
    }
  }
}

// ci_magics_db_init
// file filetype.c line 267
struct ci_magics_db * ci_magics_db_init()
{
  struct ci_magics_db *db;
  signed int i;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ci_magics_db) /*48ul*/ );
  db = (struct ci_magics_db *)return_value_malloc$1;
  if(db == ((struct ci_magics_db *)NULL))
    return (struct ci_magics_db *)(void *)0;

  else
  {
    types_init(db);
    groups_init(db);
    magics_init(db);
    i = 0;
    for( ; !((signed int)predefined_types[(signed long int)i].name[0l] == 0); i = i + 1)
      types_add(db, predefined_types[(signed long int)i].name, predefined_types[(signed long int)i].descr, predefined_types[(signed long int)i].groups);
    i = 0;
    for( ; !((signed int)predefined_groups[(signed long int)i].name[0l] == 0); i = i + 1)
      groups_add(db, predefined_groups[(signed long int)i].name, predefined_groups[(signed long int)i].descr);
    return db;
  }
}

// ci_magics_db_release
// file filetype.c line 294
void ci_magics_db_release(struct ci_magics_db *db)
{
  free((void *)db->types);
  free((void *)db->groups);
  free((void *)db->magics);
  free((void *)db);
}

// ci_mem_allocator_destroy
// file mem.c line 62
void ci_mem_allocator_destroy(struct ci_mem_allocator *allocator)
{
  allocator->destroy(allocator);
  if(allocator->must_free == 1)
    free((void *)allocator);

  else
    if(allocator->must_free == 2)
      ci_object_pool_free((void *)allocator);

}

// ci_membuf_attr_add
// file body.c line 244
signed int ci_membuf_attr_add(struct ci_membuf *body, const char *attr, const void *val, unsigned long int val_size)
{
  if(body->attributes == ((struct ci_array *)NULL))
    body->attributes=ci_array_new((unsigned long int)1024);

  const struct ci_array_item *return_value_ci_array_add$1;
  if(!(body->attributes == ((struct ci_array *)NULL)))
  {
    return_value_ci_array_add$1=ci_array_add(body->attributes, attr, val, val_size);
    return (signed int)(return_value_ci_array_add$1 != (const struct ci_array_item *)(void *)0);
  }

  return 0;
}

// ci_membuf_attr_get
// file body.c line 256
const void * ci_membuf_attr_get(struct ci_membuf *body, const char *attr)
{
  const void *return_value_ci_array_search$1;
  if(!(body->attributes == ((struct ci_array *)NULL)))
  {
    return_value_ci_array_search$1=ci_array_search(body->attributes, attr);
    return return_value_ci_array_search$1;
  }

  return (void *)0;
}

// ci_membuf_free
// file include/body.h line 57
void ci_membuf_free(struct ci_membuf *b)
{
  if(!(b == ((struct ci_membuf *)NULL)))
  {
    if(!(b->buf == ((char *)NULL)))
    {
      if((16u & b->flags) == 0u)
        ci_buffer_free((void *)b->buf);

    }

    if(!(b->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(b->attributes);

    ci_object_pool_free((void *)b);
  }

}

// ci_membuf_from_content
// file body.c line 108
struct ci_membuf * ci_membuf_from_content(char *buf, unsigned long int buf_size, unsigned long int content_size, unsigned int flags)
{
  struct ci_membuf *b;
  if(buf == ((char *)NULL) || !(buf_size >= 1ul) || !(buf_size >= content_size))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_membuf_from_content: Wrong arguments: %p, of size=%u and content size=%u\n", buf, (unsigned int)buf_size, (unsigned int)content_size);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_membuf_from_content: Wrong arguments: %p, of size=%u and content size=%u\n", buf, (unsigned int)buf_size, (unsigned int)content_size);

    }

    return (struct ci_membuf *)(void *)0;
  }

  else
    if(!((15u & flags) == flags))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_membuf_from_content: Wrong flags: %u\n", flags);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_membuf_from_content: Wrong flags: %u\n", flags);

      }

      return (struct ci_membuf *)(void *)0;
    }

    else
    {
      if(!((1u & flags) == 0u))
      {
        if((signed int)buf[-1l + (signed long int)content_size] == 0)
          content_size = content_size - 1ul;

        else
        {
          _Bool tmp_if_expr$1;
          if(content_size >= buf_size)
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = (signed int)buf[(signed long int)content_size] != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$1)
          {
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "ci_membuf_from_content: content is not NULL terminated!\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("ci_membuf_from_content: content is not NULL terminated!\n");

            }

            return (struct ci_membuf *)(void *)0;
          }

        }
      }

      void *return_value_ci_object_pool_alloc$2;
      return_value_ci_object_pool_alloc$2=ci_object_pool_alloc(MEMBUF_POOL);
      b = (struct ci_membuf *)return_value_ci_object_pool_alloc$2;
      if(b == ((struct ci_membuf *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "ci_membuf_from_content: memory allocation failed\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("ci_membuf_from_content: memory allocation failed\n");

        }

        return (struct ci_membuf *)(void *)0;
      }

      else
      {
        b->flags = (unsigned int)0x10 | flags;
        b->endpos = (signed int)content_size;
        b->readpos = 0;
        b->buf = buf;
        b->bufsize = (signed int)buf_size;
        b->unlocked = -1;
        b->attributes = (struct ci_array *)(void *)0;
        return b;
      }
    }
}

// ci_membuf_new
// file include/body.h line 54
struct ci_membuf * ci_membuf_new()
{
  struct ci_membuf *return_value_ci_membuf_new_sized$1;
  return_value_ci_membuf_new_sized$1=ci_membuf_new_sized(8192);
  return return_value_ci_membuf_new_sized$1;
}

// ci_membuf_new_sized
// file body.c line 87
struct ci_membuf * ci_membuf_new_sized(signed int size)
{
  struct ci_membuf *b;
  void *return_value_ci_object_pool_alloc$1;
  return_value_ci_object_pool_alloc$1=ci_object_pool_alloc(MEMBUF_POOL);
  b = (struct ci_membuf *)return_value_ci_object_pool_alloc$1;
  if(b == ((struct ci_membuf *)NULL))
    return (struct ci_membuf *)(void *)0;

  else
  {
    b->endpos = 0;
    b->readpos = 0;
    b->flags = (unsigned int)0;
    void *return_value_ci_buffer_alloc$2;
    return_value_ci_buffer_alloc$2=ci_buffer_alloc((signed int)((unsigned long int)size * sizeof(char) /*1ul*/ ));
    b->buf = (char *)return_value_ci_buffer_alloc$2;
    if(b->buf == ((char *)NULL))
    {
      ci_object_pool_free((void *)b);
      return (struct ci_membuf *)(void *)0;
    }

    else
    {
      b->bufsize = size;
      b->unlocked = -1;
      b->attributes = (struct ci_array *)(void *)0;
      return b;
    }
  }
}

// ci_membuf_read
// file include/body.h line 59
signed int ci_membuf_read(struct ci_membuf *b, char *data, signed int len)
{
  signed int remains;
  signed int copybytes;
  if(b->unlocked >= 0)
    remains = b->unlocked - b->readpos;

  else
    remains = b->endpos - b->readpos;
  if(remains == 0)
  {
    if((2u & b->flags) == 0u)
      goto __CPROVER_DUMP_L3;

    return -2;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    copybytes = len <= remains ? len : remains;
    if(!(copybytes == 0))
    {
      memcpy((void *)data, (const void *)(b->buf + (signed long int)b->readpos), (unsigned long int)copybytes);
      b->readpos = b->readpos + copybytes;
    }

    return copybytes;
  }
}

// ci_membuf_set_flag
// file body.c line 158
unsigned int ci_membuf_set_flag(struct ci_membuf *body, unsigned int flag)
{
  if((5u & flag) == 0u)
    return (unsigned int)0;

  else
  {
    body->flags = body->flags | flag;
    return body->flags;
  }
}

// ci_membuf_truncate
// file body.c line 263
signed int ci_membuf_truncate(struct ci_membuf *body, signed int new_size)
{
  if(!(body->endpos >= new_size))
    return 0;

  else
  {
    body->endpos = new_size;
    if(!((1u & body->flags) == 0u))
      body->buf[(signed long int)body->endpos] = (char)0;

    if(!(body->endpos >= body->readpos))
      body->readpos = body->endpos;

    if(!(body->endpos >= body->unlocked))
      body->unlocked = body->endpos;

    return 1;
  }
}

// ci_membuf_write
// file include/body.h line 58
signed int ci_membuf_write(struct ci_membuf *b, const char *data, signed int len, signed int iseof)
{
  signed int remains;
  signed int newsize;
  char *newbuf;
  signed int terminate = (signed int)(b->flags & (unsigned int)0x01);
  _Bool tmp_if_expr$1;
  if(!((4u & b->flags) == 0u))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (b->flags & (unsigned int)0x08) != 0u ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_membuf_write: can not write: buffer is read-only!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_membuf_write: can not write: buffer is read-only!\n");

    }

    return 0;
  }

  else
    if(!((2u & b->flags) == 0u))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Cannot write to membuf: the eof flag is set!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Cannot write to membuf: the eof flag is set!\n");

      }

      return 0;
    }

    else
    {
      if(!(iseof == 0))
        b->flags = b->flags | (unsigned int)0x02;

      remains = (b->bufsize - b->endpos) - (terminate != 0 ? 1 : 0);
      /* assertion remains >= -1 */
      assert(remains >= -1);
      while(!(remains >= len))
      {
        newsize = b->bufsize + 4096;
        void *return_value_ci_buffer_realloc$2;
        return_value_ci_buffer_realloc$2=ci_buffer_realloc((void *)b->buf, newsize);
        newbuf = (char *)return_value_ci_buffer_realloc$2;
        if(newbuf == ((char *)NULL))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "ci_membuf_write: Failed to grow membuf for new data!\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("ci_membuf_write: Failed to grow membuf for new data!\n");

          }

          if(remains >= 0)
          {
            if(!(remains == 0))
              memcpy((void *)(b->buf + (signed long int)b->endpos), (const void *)data, (unsigned long int)remains);

            if(!(terminate == 0))
            {
              b->endpos = b->bufsize - 1;
              b->buf[(signed long int)b->endpos] = (char)0;
            }

            else
              b->endpos = b->bufsize;
          }

          else
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "ci_membuf_write: Failed to NULL terminate membuf!\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("ci_membuf_write: Failed to NULL terminate membuf!\n");

            }

          return remains;
        }

        b->buf = newbuf;
        b->bufsize = newsize;
        remains = (b->bufsize - b->endpos) - (terminate != 0 ? 1 : 0);
      }
      if(!(len == 0))
      {
        memcpy((void *)(b->buf + (signed long int)b->endpos), (const void *)data, (unsigned long int)len);
        b->endpos = b->endpos + len;
      }

      if(!(terminate == 0))
        b->buf[(signed long int)b->endpos] = (char)0;

      return len;
    }
}

// ci_mktemp_file
// file include/util.h line 34
signed int ci_mktemp_file(char *dir, char *template, char *filename)
{
  snprintf(filename, (unsigned long int)4096, "%s%s", dir, template);
  filename[(signed long int)(4096 - 1)] = (char)0;
  signed int return_value_mkstemp64$1;
  return_value_mkstemp64$1=mkstemp64(filename);
  return return_value_mkstemp64$1;
}

// ci_module_load
// file include/dlib.h line 40
void * ci_module_load(const char *module_file, const char *default_path)
{
  char path[4096l];
  void *handle;
  signed int len;
  if(!((signed int)*module_file == 47))
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(default_path);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(module_file);
    len = (signed int)(return_value_strlen$1 + return_value_strlen$2 + (unsigned long int)1);
    if(len >= 4096)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Path name len of %s+%s is greater than MAXPATH:%d, not loading\n", default_path, module_file, 4096);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Path name len of %s+%s is greater than MAXPATH:%d, not loading\n", default_path, module_file, 4096);

      }

      return (void *)0;
    }

    strcpy(path, default_path);
    strcat(path, "/");
    strcat(path, module_file);
  }

  else
    strncpy(path, module_file, (unsigned long int)(4096 - 1));
  path[(signed long int)(4096 - 1)] = (char)0;
  handle=dlopen(path, 0x00002 | 0x00100);
  if(handle == NULL)
  {
    char *error_str;
    error_str=dlerror();
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error loading module %s:%s\n", module_file, error_str);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error loading module %s:%s\n", module_file, error_str);

    }

    return (void *)0;
  }

  return handle;
}

// ci_module_sym
// file include/dlib.h line 41
void * ci_module_sym(void *handle, const char *symbol)
{
  void *return_value_dlsym$1;
  return_value_dlsym$1=dlsym(handle, symbol);
  return return_value_dlsym$1;
}

// ci_module_unload
// file include/dlib.h line 42
signed int ci_module_unload(void *handle, const char *name)
{
  signed int ret;
  ret=dlclose(handle);
  if(ret == 1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error unloading module:%s\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error unloading module:%s\n", name);

    }

    return 0;
  }

  else
    return 1;
}

// ci_named_pipe_close
// file mpmt_server.c line 460
void ci_named_pipe_close(signed int pipe_fd)
{
  close(pipe_fd);
}

// ci_named_pipe_create
// file mpmt_server.c line 442
signed int ci_named_pipe_create(char *name)
{
  signed int status;
  signed int ci_named_pipe_create$$1$$pipe;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  status=mkfifo(name, (unsigned int)(0400 | 0200 | 0200 >> 3));
  signed int *return_value___errno_location$2;
  if(!(status >= 0))
  {
    return_value___errno_location$2=__errno_location();
    if(!(*return_value___errno_location$2 == 17))
      return -1;

  }

  ci_named_pipe_create$$1$$pipe=open64(name, 00 | 04000);
  return ci_named_pipe_create$$1$$pipe;
}

// ci_named_pipe_open
// file mpmt_server.c line 453
signed int ci_named_pipe_open(char *name)
{
  signed int ci_named_pipe_open$$1$$pipe;
  ci_named_pipe_open$$1$$pipe=open64(name, 00 | 04000);
  return ci_named_pipe_open$$1$$pipe;
}

// ci_netio_init
// file include/net_io.h line 149
signed int ci_netio_init(signed int fd)
{
  fcntl(fd, 4, 04000);
  return 1;
}

// ci_object_pool_alloc
// file include/mem.h line 73
void * ci_object_pool_alloc(signed int id)
{
  struct mem_buffer_block *block = (struct mem_buffer_block *)(void *)0;
  _Bool tmp_if_expr$1;
  if(id >= object_pools_used || !(id >= 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(object_pools[(signed long int)id] != ((struct ci_mem_allocator *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Invalid object pool %d. This is a BUG!\n", id);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Invalid object pool %d. This is a BUG!\n", id);

    }

    return (void *)0;
  }

  else
  {
    void *return_value;
    return_value=object_pools[(signed long int)id]->alloc(object_pools[(signed long int)id], (unsigned long int)1);
    block = (struct mem_buffer_block *)return_value;
    if(block == ((struct mem_buffer_block *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Failed to allocate object from pool %d\n", id);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Failed to allocate object from pool %d\n", id);

      }

      return (void *)0;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 8)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Allocating from objects pool object %d\n", id);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Allocating from objects pool object %d\n", id);

      }

      block->sig = (unsigned short int)0x55AA;
      block->ID = id;
      return (void *)block->data.ptr;
    }
  }
}

// ci_object_pool_free
// file include/mem.h line 74
void ci_object_pool_free(void *ptr)
{
  struct mem_buffer_block *block = (struct mem_buffer_block *)(ptr - (signed long int)(unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
  if(!((signed int)block->sig == 0x55AA))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_object_pool_free: ERROR, %p is not internal buffer. This is a bug!!!!\n", ptr);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_object_pool_free: ERROR, %p is not internal buffer. This is a bug!!!!\n", ptr);

    }

  }

  else
  {
    _Bool tmp_if_expr$1;
    if(!(object_pools_used >= block->ID))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = block->ID < 0 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$2;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = !(object_pools[(signed long int)block->ID] != ((struct ci_mem_allocator *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_object_pool_free: ERROR, %p is pointing to corrupted mem? This is a bug!!!!\n", ptr);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_object_pool_free: ERROR, %p is pointing to corrupted mem? This is a bug!!!!\n", ptr);

      }

    }

    else
    {
      if(CI_DEBUG_LEVEL >= 8)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Storing to objects pool object %d\n", block->ID);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Storing to objects pool object %d\n", block->ID);

      }

      object_pools[(signed long int)block->ID]->free(object_pools[(signed long int)block->ID], (void *)block);
    }
  }
}

// ci_object_pool_register
// file include/mem.h line 71
signed int ci_object_pool_register(const char *name, signed int size)
{
  signed int ID;
  signed int i;
  ID = -1;
  if(object_pools == ((struct ci_mem_allocator **)NULL))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc((unsigned long int)128 * sizeof(struct ci_mem_allocator *) /*8ul*/ );
    object_pools = (struct ci_mem_allocator **)return_value_malloc$1;
    object_pools_size = 128;
    ID = 0;
  }

  else
  {
    i = 0;
    for( ; !(i >= object_pools_used); i = i + 1)
      if(object_pools[(signed long int)i] == ((struct ci_mem_allocator *)NULL))
      {
        ID = i;
        break;
      }

    if(ID == -1)
    {
      if(object_pools_size == object_pools_used)
      {
        object_pools_size = object_pools_size + 128;
        void *return_value_realloc$2;
        return_value_realloc$2=realloc((void *)object_pools, (unsigned long int)object_pools_size * sizeof(struct ci_mem_allocator *) /*8ul*/ );
        object_pools = (struct ci_mem_allocator **)return_value_realloc$2;
      }

      ID = object_pools_used;
    }

  }
  if(object_pools == ((struct ci_mem_allocator **)NULL))
    return -1;

  else
  {
    object_pools[(signed long int)ID]=ci_create_pool_allocator((signed int)((unsigned long int)size + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
    object_pools_used = object_pools_used + 1;
    return ID;
  }
}

// ci_object_pool_unregister
// file include/mem.h line 72
void ci_object_pool_unregister(signed int id)
{
  if(!(id >= object_pools_used) && id >= 0)
  {
    if(!(object_pools[(signed long int)id] == ((struct ci_mem_allocator *)NULL)))
    {
      ci_mem_allocator_destroy(object_pools[(signed long int)id]);
      object_pools[(signed long int)id] = (struct ci_mem_allocator *)(void *)0;
    }

  }

}

// ci_object_pools_destroy
// file mem.c line 310
void ci_object_pools_destroy()
{
  signed int i = 0;
  for( ; !(i >= object_pools_used); i = i + 1)
    if(!(object_pools[(signed long int)i] == ((struct ci_mem_allocator *)NULL)))
      ci_mem_allocator_destroy(object_pools[(signed long int)i]);

}

// ci_object_pools_init
// file mem.c line 305
signed int ci_object_pools_init()
{
  return 1;
}

// ci_pack_allocator_alloc
// file mem.c line 604
void * ci_pack_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size)
{
  size = size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1);
  void *return_value_ci_pack_allocator_alloc_unaligned$1;
  return_value_ci_pack_allocator_alloc_unaligned$1=ci_pack_allocator_alloc_unaligned(allocator, size);
  return return_value_ci_pack_allocator_alloc_unaligned$1;
}

// ci_pack_allocator_alloc_from_rear
// file mem.c line 610
void * ci_pack_allocator_alloc_from_rear(struct ci_mem_allocator *allocator, signed int size)
{
  signed int max_size;
  void *mem;
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  if(pack_alloc == ((struct pack_allocator *)NULL))
    return (void *)0;

  else
  {
    size = (signed int)((unsigned long int)size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    max_size = (signed int)(pack_alloc->endpos - pack_alloc->curpos);
    if(!(max_size >= size))
      return (void *)0;

    else
    {
      pack_alloc->endpos = pack_alloc->endpos - (signed long int)size;
      mem = pack_alloc->endpos;
      return mem;
    }
  }
}

// ci_pack_allocator_alloc_unaligned
// file mem.c line 582
void * ci_pack_allocator_alloc_unaligned(struct ci_mem_allocator *allocator, unsigned long int size)
{
  signed int max_size;
  void *mem;
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  if(pack_alloc == ((struct pack_allocator *)NULL))
    return (void *)0;

  else
  {
    max_size = (signed int)(pack_alloc->endpos - pack_alloc->curpos);
    if(!((unsigned long int)max_size >= size))
      return (void *)0;

    else
    {
      mem = pack_alloc->curpos;
      pack_alloc->curpos = pack_alloc->curpos + (signed long int)size;
      return mem;
    }
  }
}

// ci_pack_allocator_data_size
// file mem.c line 722
signed int ci_pack_allocator_data_size(struct ci_mem_allocator *allocator)
{
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  struct pack_allocator *pack_alloc = (struct pack_allocator *)allocator->data;
  return (signed int)((signed long int)(signed int)(pack_alloc->curpos - pack_alloc->memchunk) + (pack_alloc->end - pack_alloc->endpos));
}

// ci_pack_allocator_destroy
// file mem.c line 647
void ci_pack_allocator_destroy(struct ci_mem_allocator *allocator)
{
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  if(!(pack_alloc->must_free == 0))
  {
    ci_object_pool_free(allocator->data);
    allocator->data = (void *)0;
  }

}

// ci_pack_allocator_free
// file mem.c line 633
void ci_pack_allocator_free(struct ci_mem_allocator *allocator, void *p)
{
  ;
}

// ci_pack_allocator_required_size
// file mem.c line 730
unsigned long int ci_pack_allocator_required_size()
{
  return (sizeof(struct pack_allocator) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (sizeof(struct ci_mem_allocator) /*56ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
}

// ci_pack_allocator_reset
// file mem.c line 638
void ci_pack_allocator_reset(struct ci_mem_allocator *allocator)
{
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  pack_alloc->curpos = pack_alloc->memchunk;
  pack_alloc->endpos = pack_alloc->end;
}

// ci_pack_allocator_set_end_pos
// file mem.c line 746
void ci_pack_allocator_set_end_pos(struct ci_mem_allocator *allocator, void *p)
{
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  /* assertion p <= pack_alloc->end */
  assert(p <= pack_alloc->end);
  if(p == NULL)
    pack_alloc->endpos = pack_alloc->end;

  else
    pack_alloc->endpos = p;
}

// ci_pack_allocator_set_start_pos
// file mem.c line 737
void ci_pack_allocator_set_start_pos(struct ci_mem_allocator *allocator, void *p)
{
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  /* assertion p >= pack_alloc->memchunk */
  assert(p >= pack_alloc->memchunk);
  pack_alloc->curpos = p;
}

// ci_parse_key_value_list
// file util.c line 163
struct ci_dyn_array * ci_parse_key_value_list(const char *str, char sep)
{
  char *s;
  char *e;
  char *k;
  char *v;
  struct ci_dyn_array *args_array;
  s=strdup(str);
  unsigned long int return_value_strlen$1;
  if(s == ((char *)NULL))
    return (struct ci_dyn_array *)(void *)0;

  else
  {
    args_array=ci_dyn_array_new((unsigned long int)1024);
    k = s;
    while(!(k == ((char *)NULL)))
    {
      e=strchr(k, (signed int)sep);
      if(!(e == ((char *)NULL)))
      {
        *e = (char)0;
        e = e + 1l;
      }

      v=strchr(k, 61);
      if(!(v == ((char *)NULL)))
      {
        *v = (char)0;
        v = v + 1l;
      }

      k=ci_str_trim2(k);
      if(!(v == ((char *)NULL)))
        v=ci_str_trim2(v);

      if(!(*k == 0))
      {
        unsigned long int tmp_if_expr$2;
        if(!(v == ((char *)NULL)))
        {
          return_value_strlen$1=strlen(v);
          tmp_if_expr$2 = return_value_strlen$1 + (unsigned long int)1;
        }

        else
          tmp_if_expr$2 = (unsigned long int)1;
        ci_dyn_array_add(args_array, k, (const void *)(v != ((char *)NULL) ? v : ""), tmp_if_expr$2);
      }

      _Bool tmp_if_expr$3;
      if(!(e == ((char *)NULL)))
        tmp_if_expr$3 = *e != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      k = tmp_if_expr$3 ? e : (char *)(void *)0;
    }
    return args_array;
  }
}

// ci_proc_mutex_default_scheme
// file os/unix/proc_mutex.c line 254
const struct ci_proc_mutex_scheme * ci_proc_mutex_default_scheme()
{
  return default_mutex_scheme;
}

// ci_proc_mutex_destroy
// file include/proc_mutex.h line 91
signed int ci_proc_mutex_destroy(struct ci_proc_mutex *mutex)
{
  signed int return_value;
  if(!(mutex->scheme == ((const struct ci_proc_mutex_scheme *)NULL)))
  {
    return_value=mutex->scheme->proc_mutex_destroy(mutex);
    return return_value;
  }

  return 0;
}

// ci_proc_mutex_init
// file include/proc_mutex.h line 88
signed int ci_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name)
{
  if(!(default_mutex_scheme == ((const struct ci_proc_mutex_scheme *)NULL)))
  {
    mutex->scheme = default_mutex_scheme;
    signed int return_value;
    return_value=default_mutex_scheme->proc_mutex_init(mutex, name);
    return return_value;
  }

  return 0;
}

// ci_proc_mutex_lock
// file include/proc_mutex.h line 89
signed int ci_proc_mutex_lock(struct ci_proc_mutex *mutex)
{
  signed int return_value;
  if(!(mutex->scheme == ((const struct ci_proc_mutex_scheme *)NULL)))
  {
    return_value=mutex->scheme->proc_mutex_lock(mutex);
    return return_value;
  }

  return 0;
}

// ci_proc_mutex_set_scheme
// file include/proc_mutex.h line 93
signed int ci_proc_mutex_set_scheme(const char *scheme)
{
  signed int return_value_strcasecmp$3;
  return_value_strcasecmp$3=strcasecmp(scheme, "sysv");
  signed int return_value_strcasecmp$2;
  signed int return_value_strcasecmp$1;
  if(return_value_strcasecmp$3 == 0)
    default_mutex_scheme = &sysv_mutex_scheme;

  else
  {
    return_value_strcasecmp$2=strcasecmp(scheme, "posix");
    if(return_value_strcasecmp$2 == 0)
      default_mutex_scheme = &posix_mutex_scheme;

    else
    {
      return_value_strcasecmp$1=strcasecmp(scheme, "file");
      if(return_value_strcasecmp$1 == 0)
        default_mutex_scheme = &file_mutex_scheme;

      else
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Unknown interprocess locking scheme: '%s'", scheme);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Unknown interprocess locking scheme: '%s'", scheme);

        }

        return 0;
      }
    }
  }
  return 1;
}

// ci_proc_mutex_unlock
// file include/proc_mutex.h line 90
signed int ci_proc_mutex_unlock(struct ci_proc_mutex *mutex)
{
  signed int return_value;
  if(!(mutex->scheme == ((const struct ci_proc_mutex_scheme *)NULL)))
  {
    return_value=mutex->scheme->proc_mutex_unlock(mutex);
    return return_value;
  }

  return 0;
}

// ci_ptr_array_add
// file array.c line 165
const struct ci_array_item * ci_ptr_array_add(struct ci_array *ptr_array, const char *name, void *value)
{
  struct ci_array_item *item;
  struct ci_mem_allocator *packer = ptr_array->alloc;
  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  void *return_value_ci_pack_allocator_alloc_unaligned$1;
  return_value_ci_pack_allocator_alloc_unaligned$1=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((struct ci_array_item *)0)[(signed long int)1]);
  item = (struct ci_array_item *)return_value_ci_pack_allocator_alloc_unaligned$1;
  unsigned long int return_value_strlen$2;
  void *return_value_ci_pack_allocator_alloc_from_rear$3;
  if(!(item == ((struct ci_array_item *)NULL)))
  {
    return_value_strlen$2=strlen(name);
    return_value_ci_pack_allocator_alloc_from_rear$3=ci_pack_allocator_alloc_from_rear(packer, (signed int)(return_value_strlen$2 + (unsigned long int)1));
    item->name = (char *)return_value_ci_pack_allocator_alloc_from_rear$3;
  }

  _Bool tmp_if_expr$4;
  if(item == ((struct ci_array_item *)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = !(item->name != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$4)
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to add the new item to array!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to add the new item to array!\n");

    }

    return (const struct ci_array_item *)(void *)0;
  }

  else
  {
    strcpy(item->name, name);
    item->value = value;
    if(ptr_array->items == ((struct ci_array_item *)NULL))
      ptr_array->items = item;

    ptr_array->count = ptr_array->count + 1u;
    return item;
  }
}

// ci_ptr_array_new2
// file array.c line 151
struct ci_array * ci_ptr_array_new2(unsigned long int items)
{
  unsigned long int array_size;
  unsigned long int return_value_ci_pack_allocator_required_size$1;
  return_value_ci_pack_allocator_required_size$1=ci_pack_allocator_required_size();
  array_size = return_value_ci_pack_allocator_required_size$1 + (sizeof(struct ci_array) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + items * ((sizeof(void *) /*8ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (sizeof(struct ci_array_item) /*16ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  struct ci_array *return_value_ci_array_new$2;
  return_value_ci_array_new$2=ci_array_new(array_size);
  return return_value_ci_array_new$2;
}

// ci_ptr_array_pop
// file array.c line 189
const struct ci_array_item * ci_ptr_array_pop(struct ci_array *ptr_array)
{
  struct ci_array_item *item;
  if(ptr_array->count == 0u)
    return (const struct ci_array_item *)(void *)0;

  else
  {
    item = &ptr_array->items[(signed long int)(ptr_array->count - (unsigned int)1)];
    ci_pack_allocator_set_start_pos(ptr_array->alloc, (void *)item);
    ptr_array->count = ptr_array->count - 1u;
    return item;
  }
}

// ci_ptr_array_pop_value
// file array.c line 200
void * ci_ptr_array_pop_value(struct ci_array *ptr_array, char *name, unsigned long int name_size)
{
  const struct ci_array_item *item;
  item=ci_ptr_array_pop(ptr_array);
  if(item == ((const struct ci_array_item *)NULL))
    return (void *)0;

  else
  {
    strncpy(name, item->name, name_size);
    name[(signed long int)(name_size - (unsigned long int)1)] = (char)0;
    return item->value;
  }
}

// ci_ptr_array_search
// file array.c line 160
void * ci_ptr_array_search(struct ci_array *array, const char *name)
{
  const void *return_value_ci_array_search$1;
  return_value_ci_array_search$1=ci_array_search(array, name);
  return (void *)return_value_ci_array_search$1;
}

// ci_ptr_dyn_array_add
// file array.c line 336
const struct ci_array_item * ci_ptr_dyn_array_add(struct ci_dyn_array *array, const char *name, void *value)
{
  const struct ci_array_item *return_value_ci_dyn_array_add$1;
  return_value_ci_dyn_array_add$1=ci_dyn_array_add(array, name, value, (unsigned long int)0);
  return return_value_ci_dyn_array_add$1;
}

// ci_ptr_vector_add
// file array.c line 479
void * ci_ptr_vector_add(struct ci_vector *vector, void *value)
{
  void **indx;
  struct ci_mem_allocator *packer = vector->alloc;
  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  if(value == NULL)
    return (void *)0;

  else
  {
    void *return_value_ci_pack_allocator_alloc_unaligned$1;
    return_value_ci_pack_allocator_alloc_unaligned$1=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((void **)0)[(signed long int)1]);
    indx = (void **)return_value_ci_pack_allocator_alloc_unaligned$1;
    if(indx == ((void **)NULL))
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Not enough space to add the new item to ptr_vector!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Not enough space to add the new item to ptr_vector!\n");

      }

      return (void *)0;
    }

    else
    {
      *vector->last = value;
      vector->last = indx;
      *vector->last = (void *)0;
      vector->count = vector->count + 1;
      return value;
    }
  }
}

// ci_read
// file os/unix/net_io.c line 253
signed int ci_read(signed int fd, void *buf, unsigned long int count, signed int timeout)
{
  signed int bytes = 0;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    signed long int return_value_read$3;
    return_value_read$3=read(fd, buf, count);
    bytes = (signed int)return_value_read$3;
    if(bytes == -1)
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  signed int *return_value___errno_location$8;
  _Bool tmp_if_expr$6;
  signed int *return_value___errno_location$5;
  if(bytes == -1)
  {
    return_value___errno_location$8=__errno_location();
    if(*return_value___errno_location$8 == 11)
    {
      signed int return_value_ci_wait_for_data$4;
      return_value_ci_wait_for_data$4=ci_wait_for_data(fd, timeout, 0x1);
      if(return_value_ci_wait_for_data$4 == 0)
        return bytes;

      do
      {
        signed long int return_value_read$7;
        return_value_read$7=read(fd, buf, count);
        bytes = (signed int)return_value_read$7;
        if(bytes == -1)
        {
          return_value___errno_location$5=__errno_location();
          tmp_if_expr$6 = *return_value___errno_location$5 == 4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$6 = (_Bool)0;
      }
      while(tmp_if_expr$6);
    }

  }

  if(bytes == 0)
    return -1;

  else
    return bytes;
}

// ci_read_icap_header
// file request.c line 186
static signed int ci_read_icap_header(struct ci_request *req, struct ci_headers_list *h, signed int timeout)
{
  signed int bytes;
  signed int request_status = 0;
  signed int i;
  signed int eoh = 0;
  signed int startsearch = 0;
  signed int readed = 0;
  signed int wait_status = 0;
  char *buf_end;
  signed int dataPrefetch = 0;
  buf_end = h->buf;
  readed = 0;
  bytes = 0;
  if(!(PIPELINING == 0))
  {
    if(!(req->pstrblock_read == ((char *)NULL)))
    {
      if(req->pstrblock_read_len >= 1)
      {
        request_status=icap_header_check_realloc(&h->buf, &h->bufsize, req->pstrblock_read_len, 512);
        if(!(request_status == 0))
          return request_status;

        memmove((void *)h->buf, (const void *)req->pstrblock_read, (unsigned long int)req->pstrblock_read_len);
        readed = req->pstrblock_read_len;
        buf_end = h->buf;
        bytes = readed;
        dataPrefetch = 1;
        req->pstrblock_read = (char *)(void *)0;
        req->pstrblock_read_len = 0;
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Get data from previous request read.\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Get data from previous request read.\n");

        }

      }

    }

  }

  while((_Bool)1)
  {
    if(dataPrefetch == 0)
    {
      wait_status=wait_for_data(req->connection->fd, timeout, 0x1);
      if(wait_status == -1)
        return 10;

      bytes=ci_read_nonblock(req->connection->fd, (void *)buf_end, (unsigned long int)512);
      if(!(bytes >= 1))
        return 10;

      readed = readed + bytes;
      req->bytes_in = req->bytes_in + (unsigned long int)bytes;
    }

    else
      dataPrefetch = 0;
    i = startsearch;
    for( ; !(i >= bytes + -3); i = i + 1)
    {
      signed int return_value_strncmp$1;
      return_value_strncmp$1=strncmp(buf_end + (signed long int)i, "\r\n\r\n", (unsigned long int)4);
      if(return_value_strncmp$1 == 0)
      {
        buf_end = buf_end + (signed long int)i + (signed long int)2;
        eoh = 1;
        break;
      }

    }
    if(!(eoh == 0))
      break;

    request_status=icap_header_check_realloc(&h->buf, &h->bufsize, readed, 512);
    if(!(request_status == 0))
      break;

    buf_end = h->buf + (signed long int)readed;
    if(startsearch >= -2)
      startsearch = readed > 3 ? -3 : -readed;

  }
  h->bufused = (signed int)(buf_end - h->buf);
  req->pstrblock_read = buf_end + (signed long int)2;
  req->pstrblock_read_len = (readed - h->bufused) - 2;
  req->request_bytes_in = (unsigned long int)(h->bufused + 2);
  return request_status;
}

// ci_read_nonblock
// file include/net_io.h line 152
signed int ci_read_nonblock(signed int fd, void *buf, unsigned long int count)
{
  signed int bytes = 0;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    signed long int return_value_read$3;
    return_value_read$3=read(fd, buf, count);
    bytes = (signed int)return_value_read$3;
    if(bytes == -1)
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  signed int *return_value___errno_location$4;
  if(!(bytes >= 0))
  {
    return_value___errno_location$4=__errno_location();
    if(*return_value___errno_location$4 == 11)
      return 0;

  }

  return bytes;
}

// ci_regex_apply
// file include/ci_regex.h line 46
signed int ci_regex_apply(void * const regex, const char *str, signed int len, signed int recurs, struct ci_list *matches, const void *user_data)
{
  signed int count = 0;
  signed int i;
  struct ci_regex_replace_part parts;
  unsigned long int return_value_strlen$1;
  _Bool tmp_if_expr$3;
  if(str == ((const char *)NULL))
    return 0;

  else
  {
    signed int ovector[30l];
    signed int rc;
    signed int offset = 0;
    signed int str_length;
    unsigned long int tmp_if_expr$2;
    if(len >= 0)
      tmp_if_expr$2 = (unsigned long int)len;

    else
    {
      return_value_strlen$1=strlen(str);
      tmp_if_expr$2 = return_value_strlen$1;
    }
    str_length = (signed int)tmp_if_expr$2;
    do
    {
      memset((void *)ovector, 0, sizeof(signed int [30l]) /*120ul*/ );
      rc=pcre_exec((const struct real_pcre *)regex, (const struct pcre_extra *)(void *)0, str, str_length, offset, 0, ovector, 30);
      if(rc >= 0)
      {
        if(!(ovector[0l] == ovector[1l]))
        {
          count = count + 1;
          if(CI_DEBUG_LEVEL >= 9)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Match pattern (pos:%d-%d): '%.*s'\n", ovector[(signed long int)0], ovector[(signed long int)1], ovector[(signed long int)1] - ovector[(signed long int)0], str + (signed long int)ovector[(signed long int)0]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Match pattern (pos:%d-%d): '%.*s'\n", ovector[(signed long int)0], ovector[(signed long int)1], ovector[(signed long int)1] - ovector[(signed long int)0], str + (signed long int)ovector[(signed long int)0]);

          }

          offset = ovector[(signed long int)1];
          if(!(matches == ((struct ci_list *)NULL)))
          {
            parts.user_data = user_data;
            memset((void *)parts.matches, 0, sizeof(struct ci_regex_match [10l]) /*160ul*/ );
            i = 0;
            do
            {
              if(!(i >= 10))
                tmp_if_expr$3 = ovector[(signed long int)(2 * i + 1)] > ovector[(signed long int)(2 * i)] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$3 = (_Bool)0;
              if(!tmp_if_expr$3)
                break;

              if(CI_DEBUG_LEVEL >= 9)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "\t sub-match pattern (pos:%d-%d): '%.*s'\n", ovector[(signed long int)(2 * i)], ovector[(signed long int)(2 * i + 1)], ovector[(signed long int)(2 * i + 1)] - ovector[(signed long int)(2 * i)], str + (signed long int)ovector[(signed long int)(2 * i)]);

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("\t sub-match pattern (pos:%d-%d): '%.*s'\n", ovector[(signed long int)(2 * i)], ovector[(signed long int)(2 * i + 1)], ovector[(signed long int)(2 * i + 1)] - ovector[(signed long int)(2 * i)], str + (signed long int)ovector[(signed long int)(2 * i)]);

              }

              parts.matches[(signed long int)i].s = (unsigned long int)ovector[(signed long int)(2 * i)];
              parts.matches[(signed long int)i].e = (unsigned long int)ovector[(signed long int)(2 * i + 1)];
              i = i + 1;
            }
            while((_Bool)1);
            ci_list_push_back(matches, (void *)&parts);
          }

        }

      }

    }
    while(rc >= 0 && !(recurs == 0) && !(offset >= str_length));
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_regex_apply matches count: %d\n", count);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_regex_apply matches count: %d\n", count);

    }

    return count;
  }
}

// ci_regex_build
// file include/ci_regex.h line 44
void * ci_regex_build(const char *regex_str, signed int regex_flags)
{
  struct real_pcre *re;
  const char *error;
  signed int erroffset;
  re=pcre_compile(regex_str, regex_flags, &error, &erroffset, (const unsigned char *)(void *)0);
  if(re == ((struct real_pcre *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "PCRE compilation failed at offset %d: %s\n", erroffset, error);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("PCRE compilation failed at offset %d: %s\n", erroffset, error);

    }

    return (void *)0;
  }

  else
    return (void *)re;
}

// ci_regex_free
// file include/ci_regex.h line 45
void ci_regex_free(void *regex)
{
  pcre_free((void *)(struct real_pcre *)regex);
}

// ci_regex_parse
// file include/ci_regex.h line 43
char * ci_regex_parse(const char *str, signed int *flags, signed int *recursive)
{
  signed int slen;
  const char *e;
  char *s;
  if(!((signed int)*str == 47))
    return (char *)(void *)0;

  else
  {
    str = str + 1l;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(str);
    slen = (signed int)return_value_strlen$1;
    e = str + (signed long int)slen;
    for( ; !((signed int)*e == 47); e = e - 1l)
      if(e == str)
        break;

    if(!((signed int)*e == 47))
      return (char *)(void *)0;

    else
    {
      slen = (signed int)(e - str);
      void *return_value_malloc$2;
      return_value_malloc$2=malloc((unsigned long int)(slen + 1) * sizeof(char) /*1ul*/ );
      s = (char *)return_value_malloc$2;
      strncpy(s, str, (unsigned long int)slen);
      s[(signed long int)slen] = (char)0;
      *flags = 0;
      *flags = *flags | 0x00400000;
      *flags = *flags | 0x00500000;
      for( ; !((signed int)*e == 0); e = e + 1l)
        if((signed int)*e == 105)
          *flags = *flags | 0x00000001;

        else
          if((signed int)*e == 109)
            *flags = *flags | 0x00000002;

          else
            if((signed int)*e == 115)
              *flags = *flags | 0x00000004;

            else
              if((signed int)*e == 120)
                *flags = *flags | 0x00000008;

              else
                if((signed int)*e == 65)
                  *flags = *flags | 0x00000010;

                else
                  if((signed int)*e == 68)
                    *flags = *flags | 0x00000020;

                  else
                    if((signed int)*e == 85)
                      *flags = *flags | 0x00000200;

                    else
                      if((signed int)*e == 88)
                        *flags = *flags | 0x00000040;

                      else
                        if((signed int)*e == 68)
                          *flags = *flags | 0x00000020;

                        else
                          if((signed int)*e == 117)
                            *flags = *flags | 0x00000800;

                          else
                            if((signed int)*e == 103)
                              *recursive = 1;

      return s;
    }
  }
}

// ci_registry_add_item
// file include/registry.h line 34
signed int ci_registry_add_item(const char *name, const char *label, const void *obj)
{
  struct ci_dyn_array *registry = (struct ci_dyn_array *)(void *)0;
  _Bool tmp_if_expr$4;
  void *return_value_ci_ptr_array_search$3;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    return_value_ci_ptr_array_search$3=ci_ptr_array_search(REGISTRIES, name);
    registry = (struct ci_dyn_array *)return_value_ci_ptr_array_search$3;
    tmp_if_expr$4 = registry == (struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$4)
  {
    if(CI_DEBUG_LEVEL >= 3)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry '%s' does not exist create it\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry '%s' does not exist create it\n", name);

    }

    signed int return_value_ci_registry_create$1;
    return_value_ci_registry_create$1=ci_registry_create(name);
    if(!(return_value_ci_registry_create$1 >= 0))
      return 0;

    void *return_value_ci_ptr_array_search$2;
    return_value_ci_ptr_array_search$2=ci_ptr_array_search(REGISTRIES, name);
    registry = (struct ci_dyn_array *)return_value_ci_ptr_array_search$2;
  }

  const struct ci_array_item *return_value_ci_ptr_dyn_array_add$5;
  return_value_ci_ptr_dyn_array_add$5=ci_ptr_dyn_array_add(registry, label, (void *)obj);
  if(!(return_value_ci_ptr_dyn_array_add$5 == ((const struct ci_array_item *)NULL)))
  {
    REG_ITEMS_COUNT = REG_ITEMS_COUNT + 1;
    return REG_ITEMS_COUNT;
  }

  else
    return 0;
}

// ci_registry_clean
// file include/registry.h line 31
void ci_registry_clean()
{
  struct ci_dyn_array *registry = (struct ci_dyn_array *)(void *)0;
  char buf[1024l];
  void *return_value_ci_ptr_array_pop_value$1;
  if(!(REGISTRIES == ((struct ci_array *)NULL)))
  {
    do
    {
      return_value_ci_ptr_array_pop_value$1=ci_ptr_array_pop_value(REGISTRIES, buf, sizeof(char [1024l]) /*1024ul*/ );
      registry = (struct ci_dyn_array *)return_value_ci_ptr_array_pop_value$1;
      if(registry == ((struct ci_dyn_array *)NULL))
        break;

      if(CI_DEBUG_LEVEL >= 4)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Registry %s removed\n", (const void *)buf);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Registry %s removed\n", (const void *)buf);

      }

      ci_dyn_array_destroy(registry);
    }
    while((_Bool)1);
    ci_array_destroy(REGISTRIES);
    REGISTRIES = (struct ci_array *)(void *)0;
  }

}

// ci_registry_create
// file registry.c line 29
signed int ci_registry_create(const char *name)
{
  void *return_value_ci_ptr_array_search$1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    REGISTRIES=ci_ptr_array_new2((unsigned long int)1024);

  else
  {
    return_value_ci_ptr_array_search$1=ci_ptr_array_search(REGISTRIES, name);
    if(!(return_value_ci_ptr_array_search$1 == NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Registry '%s' already exist!\n", name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Registry '%s' already exist!\n", name);

      }

      return -1;
    }

  }
  struct ci_dyn_array *registry;
  registry=ci_dyn_array_new((unsigned long int)1024);
  ci_ptr_array_add(REGISTRIES, name, (void *)registry);
  if(CI_DEBUG_LEVEL >= 4)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Registry '%s' added and is ready to store new registry entries\n", name);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Registry '%s' added and is ready to store new registry entries\n", name);

  }

  return (signed int)(REGISTRIES->count - (unsigned int)1);
}

// ci_registry_get_id
// file registry.c line 119
signed int ci_registry_get_id(const char *name)
{
  struct check_reg_data rdata;
  rdata.name = name;
  rdata.found = 0;
  rdata.count = 0;
  if(!(REGISTRIES == ((struct ci_array *)NULL)))
    ci_array_iterate(REGISTRIES, (void *)&rdata, check_reg);

  if(!(rdata.found == 0))
    return rdata.count - 1;

  else
    return -1;
}

// ci_registry_get_item
// file include/registry.h line 35
const void * ci_registry_get_item(const char *name, const char *label)
{
  struct ci_dyn_array *registry = (struct ci_dyn_array *)(void *)0;
  _Bool tmp_if_expr$2;
  void *return_value_ci_ptr_array_search$1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_ci_ptr_array_search$1=ci_ptr_array_search(REGISTRIES, name);
    registry = (struct ci_dyn_array *)return_value_ci_ptr_array_search$1;
    tmp_if_expr$2 = registry == (struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry '%s' does not exist!\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry '%s' does not exist!\n", name);

    }

    return (void *)0;
  }

  else
  {
    const void *return_value_ci_dyn_array_search$3;
    return_value_ci_dyn_array_search$3=ci_dyn_array_search(registry, label);
    return return_value_ci_dyn_array_search$3;
  }
}

// ci_registry_id_get_item
// file registry.c line 147
const void * ci_registry_id_get_item(signed int reg_id, const char *label)
{
  const struct ci_dyn_array *registry = (const struct ci_dyn_array *)(void *)0;
  const struct ci_array_item *ai;
  _Bool tmp_if_expr$1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
  {
    ai=ci_array_get_item(REGISTRIES, reg_id);
    tmp_if_expr$1 = ai == (const struct ci_array_item *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    registry = (const struct ci_dyn_array *)ai->value;
    tmp_if_expr$2 = registry == (const struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry with id='%d' does not exist!\n", reg_id);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry with id='%d' does not exist!\n", reg_id);

    }

    return NULL;
  }

  else
  {
    const void *return_value_ci_dyn_array_search$3;
    return_value_ci_dyn_array_search$3=ci_dyn_array_search(registry, label);
    return return_value_ci_dyn_array_search$3;
  }
}

// ci_registry_id_iterate
// file registry.c line 135
signed int ci_registry_id_iterate(signed int reg_id, void *data, signed int (*fn)(void *, const char *, const void *))
{
  const struct ci_dyn_array *registry = (const struct ci_dyn_array *)(void *)0;
  const struct ci_array_item *ai;
  _Bool tmp_if_expr$1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
  {
    ai=ci_array_get_item(REGISTRIES, reg_id);
    tmp_if_expr$1 = ai == (const struct ci_array_item *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    registry = (const struct ci_dyn_array *)ai->value;
    tmp_if_expr$2 = registry == (const struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry with id='%d' does not exist!\n", reg_id);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry with id='%d' does not exist!\n", reg_id);

    }

    return 0;
  }

  else
  {
    ci_dyn_array_iterate(registry, data, fn);
    return 1;
  }
}

// ci_registry_iterate
// file registry.c line 65
signed int ci_registry_iterate(const char *name, void *data, signed int (*fn)(void *, const char *, const void *))
{
  const struct ci_dyn_array *registry = (const struct ci_dyn_array *)(void *)0;
  _Bool tmp_if_expr$2;
  void *return_value_ci_ptr_array_search$1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_ci_ptr_array_search$1=ci_ptr_array_search(REGISTRIES, name);
    registry = (const struct ci_dyn_array *)return_value_ci_ptr_array_search$1;
    tmp_if_expr$2 = registry == (const struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry '%s' does not exist!\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry '%s' does not exist!\n", name);

    }

    return 0;
  }

  else
  {
    ci_dyn_array_iterate(registry, data, fn);
    return 1;
  }
}

// ci_request_206_origin_body
// file request_common.c line 436
signed int ci_request_206_origin_body(struct ci_request *req, unsigned long int offset)
{
  if(req == ((struct ci_request *)NULL))
    return 0;

  else
    if(req->allow206 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Request does not support allow206 responses! Can not set use-original-body extension\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Request does not support allow206 responses! Can not set use-original-body extension\n");

      }

      return 0;
    }

    else
    {
      req->i206_use_original_body = (signed long int)offset;
      return 1;
    }
}

// ci_request_alloc
// file include/request.h line 169
struct ci_request * ci_request_alloc(struct ci_connection *connection)
{
  struct ci_request *req;
  signed int i;
  void *return_value;
  return_value=__intl_malloc((signed int)sizeof(struct ci_request) /*9392ul*/ );
  req = (struct ci_request *)return_value;
  if(req == ((struct ci_request *)NULL))
    return (struct ci_request *)(void *)0;

  else
  {
    req->connection = connection;
    req->packed = 0;
    req->user[(signed long int)0] = (char)0;
    req->access_type = 0;
    req->service[(signed long int)0] = (char)0;
    req->req_server[(signed long int)0] = (char)0;
    req->current_service_mod = (struct ci_service_module *)(void *)0;
    req->service_data = (void *)0;
    req->args[(signed long int)0] = (char)0;
    req->type = -1;
    req->preview = -1;
    ci_buf_init(&req->preview_data);
    req->keepalive = 1;
    req->allow204 = 0;
    req->allow206 = 0;
    req->hasbody = 0;
    req->responce_hasbody = 0;
    req->eof_received = 0;
    req->request_header=ci_headers_create();
    req->response_header=ci_headers_create();
    req->xheaders=ci_headers_create();
    req->status = 0;
    req->return_code = -1;
    req->pstrblock_read = (char *)(void *)0;
    req->pstrblock_read_len = 0;
    req->current_chunk_len = (unsigned int)0;
    req->chunk_bytes_read = (unsigned int)0;
    req->write_to_module_pending = (unsigned int)0;
    req->pstrblock_responce = (char *)(void *)0;
    req->remain_send_block_bytes = 0;
    req->data_locked = 1;
    req->i206_use_original_body = (signed long int)-1;
    req->preview_data_type = -1;
    req->auth_required = 0;
    req->log_str = (char *)(void *)0;
    req->attributes = (struct ci_array *)(void *)0;
    memset((void *)&req->xclient_ip, 0, sizeof(struct ci_ip) /*12ul*/ );
    req->bytes_in = (unsigned long int)0;
    req->bytes_out = (unsigned long int)0;
    req->request_bytes_in = (unsigned long int)0;
    req->http_bytes_in = (unsigned long int)0;
    req->http_bytes_out = (unsigned long int)0;
    req->body_bytes_in = (unsigned long int)0;
    req->body_bytes_out = (unsigned long int)0;
    i = 0;
    if(!(i >= 5))
    {
      req->entities[(signed long int)i] = (struct ci_encaps_entity *)(void *)0;
      i = i + 1;
    }

    i = 0;
    if(!(i >= 7))
    {
      req->trash_entities[(signed long int)i] = (struct ci_encaps_entity *)(void *)0;
      i = i + 1;
    }

    return req;
  }
}

// ci_request_alloc_entity
// file include/request.h line 174
struct ci_encaps_entity * ci_request_alloc_entity(struct ci_request *req, signed int type, signed int val)
{
  struct ci_encaps_entity *e = (struct ci_encaps_entity *)(void *)0;
  if(type >= 6 || !(type >= 0))
    return (struct ci_encaps_entity *)(void *)0;

  else
    if(!(req->trash_entities[(signed long int)type] == ((struct ci_encaps_entity *)NULL)))
    {
      e = req->trash_entities[(signed long int)type];
      req->trash_entities[(signed long int)type] = (struct ci_encaps_entity *)(void *)0;
      e->type = type;
      e->start = val;
      _Bool tmp_if_expr$1;
      if(e->type == 0)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = e->type == 1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        if(!(e->entity == NULL))
          ci_headers_reset((struct ci_headers_list *)e->entity);

      }

      if(CI_DEBUG_LEVEL >= 8)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Get entity from trash....\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Get entity from trash....\n");

      }

      return e;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 8)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Allocate a new entity of type %d\n", type);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Allocate a new entity of type %d\n", type);

      }

      struct ci_encaps_entity *return_value_mk_encaps_entity$2;
      return_value_mk_encaps_entity$2=mk_encaps_entity(type, val);
      return return_value_mk_encaps_entity$2;
    }
}

// ci_request_destroy
// file include/request.h line 171
void ci_request_destroy(struct ci_request *req)
{
  signed int i;
  if(!(req->connection == ((struct ci_connection *)NULL)))
    __intl_free((void *)req->connection);

  ci_buf_mem_free(&req->preview_data);
  ci_headers_destroy(req->request_header);
  ci_headers_destroy(req->response_header);
  ci_headers_destroy(req->xheaders);
  i = 0;
  for( ; !(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)); i = i + 1)
    destroy_encaps_entity(req->entities[(signed long int)i]);
  i = 0;
  for( ; !(i >= 7); i = i + 1)
    if(!(req->trash_entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)))
      destroy_encaps_entity(req->trash_entities[(signed long int)i]);

  if(!(req->log_str == ((char *)NULL)))
    __intl_free((void *)req->log_str);

  if(!(req->attributes == ((struct ci_array *)NULL)))
    ci_array_destroy(req->attributes);

  __intl_free((void *)req);
}

// ci_request_pack
// file request_common.c line 152
void ci_request_pack(struct ci_request *req)
{
  ci_request_t_pack(req, 1);
}

// ci_request_release_entity
// file include/request.h line 175
signed int ci_request_release_entity(struct ci_request *req, signed int pos)
{
  signed int type = 0;
  if(req->entities[(signed long int)pos] == ((struct ci_encaps_entity *)NULL))
    return 0;

  else
  {
    type = req->entities[(signed long int)pos]->type;
    if(type >= 6 || !(type >= 0))
    {
      destroy_encaps_entity(req->entities[(signed long int)pos]);
      req->entities[(signed long int)pos] = (struct ci_encaps_entity *)(void *)0;
      return 0;
    }

    else
    {
      if(!(req->trash_entities[(signed long int)type] == ((struct ci_encaps_entity *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 3)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "ERROR!!!!! There is an entity of type %d to trash..... ", type);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("ERROR!!!!! There is an entity of type %d to trash..... ", type);

        }

        destroy_encaps_entity(req->trash_entities[(signed long int)type]);
      }

      req->trash_entities[(signed long int)type] = req->entities[(signed long int)pos];
      req->entities[(signed long int)pos] = (struct ci_encaps_entity *)(void *)0;
      return 1;
    }
  }
}

// ci_request_reset
// file include/request.h line 170
void ci_request_reset(struct ci_request *req)
{
  signed int i;
  req->packed = 0;
  req->user[(signed long int)0] = (char)0;
  req->service[(signed long int)0] = (char)0;
  req->current_service_mod = (struct ci_service_module *)(void *)0;
  req->service_data = (void *)0;
  req->args[(signed long int)0] = (char)0;
  req->type = -1;
  req->preview = -1;
  ci_buf_reset(&req->preview_data);
  req->keepalive = 1;
  req->allow204 = 0;
  req->allow206 = 0;
  req->hasbody = 0;
  req->responce_hasbody = 0;
  ci_headers_reset(req->request_header);
  ci_headers_reset(req->response_header);
  ci_headers_reset(req->xheaders);
  req->eof_received = 0;
  req->status = 0;
  req->return_code = -1;
  req->pstrblock_read = (char *)(void *)0;
  req->pstrblock_read_len = 0;
  req->current_chunk_len = (unsigned int)0;
  req->chunk_bytes_read = (unsigned int)0;
  req->pstrblock_responce = (char *)(void *)0;
  req->remain_send_block_bytes = 0;
  req->write_to_module_pending = (unsigned int)0;
  req->data_locked = 1;
  req->i206_use_original_body = (signed long int)-1;
  req->preview_data_type = -1;
  req->auth_required = 0;
  if(!(req->log_str == ((char *)NULL)))
    __intl_free((void *)req->log_str);

  req->log_str = (char *)(void *)0;
  if(!(req->attributes == ((struct ci_array *)NULL)))
    ci_array_destroy(req->attributes);

  req->attributes = (struct ci_array *)(void *)0;
  memset((void *)&req->xclient_ip, 0, sizeof(struct ci_ip) /*12ul*/ );
  req->bytes_in = (unsigned long int)0;
  req->bytes_out = (unsigned long int)0;
  req->request_bytes_in = (unsigned long int)0;
  req->http_bytes_in = (unsigned long int)0;
  req->http_bytes_out = (unsigned long int)0;
  req->body_bytes_in = (unsigned long int)0;
  req->body_bytes_out = (unsigned long int)0;
  i = 0;
  for( ; !(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)); i = i + 1)
    ci_request_release_entity(req, i);
  if(!(req->trash_entities[0l] == ((struct ci_encaps_entity *)NULL)))
  {
    if(!(req->trash_entities[0l]->entity == NULL))
      ci_headers_reset((struct ci_headers_list *)req->trash_entities[(signed long int)0]->entity);

  }

  if(!(req->trash_entities[1l] == ((struct ci_encaps_entity *)NULL)))
  {
    if(!(req->trash_entities[1l]->entity == NULL))
      ci_headers_reset((struct ci_headers_list *)req->trash_entities[(signed long int)1]->entity);

  }

}

// ci_request_set_log_str
// file request_common.c line 405
char * ci_request_set_log_str(struct ci_request *req, char *logstr)
{
  signed int size;
  if(!(req->log_str == ((char *)NULL)))
    __intl_free((void *)req->log_str);

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(logstr);
  size = (signed int)(return_value_strlen$1 + (unsigned long int)1);
  void *return_value;
  return_value=__intl_malloc((signed int)((unsigned long int)size * sizeof(char) /*1ul*/ ));
  req->log_str = (char *)return_value;
  if(req->log_str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    strcpy(req->log_str, logstr);
    return req->log_str;
  }
}

// ci_request_set_str_attribute
// file request_common.c line 419
signed int ci_request_set_str_attribute(struct ci_request *req, const char *name, const char *value)
{
  if(req->attributes == ((struct ci_array *)NULL))
  {
    req->attributes=ci_array_new((unsigned long int)4096);
    if(!(req->attributes == ((struct ci_array *)NULL)))
      goto __CPROVER_DUMP_L3;

    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocating request attributes array!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocating request attributes array!\n");

    }

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(value);
    const struct ci_array_item *return_value_ci_array_add$2;
    return_value_ci_array_add$2=ci_array_add(req->attributes, name, (const void *)value, return_value_strlen$1 + (unsigned long int)1);
    if(return_value_ci_array_add$2 == ((const struct ci_array_item *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Not enough space to add attribute %s:%s for service %s\n", name, value, (const void *)req->service);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Not enough space to add attribute %s:%s for service %s\n", name, value, (const void *)req->service);

      }

      return 0;
    }

    else
      return 1;
  }
}

// ci_request_t_pack
// file request_common.c line 92
void ci_request_t_pack(struct ci_request *req, signed int is_request)
{
  struct ci_encaps_entity **elist;
  struct ci_encaps_entity *e;
  char buf[256l];
  req->packed = 1;
  if(!(is_request == 0))
  {
    if(req->preview >= 0)
    {
      sprintf(buf, "Preview: %d", req->preview);
      ci_headers_add(req->request_header, buf);
    }

  }

  elist = req->entities;
  if(!(*elist == ((struct ci_encaps_entity *)NULL)))
    elist[(signed long int)0]->start = 0;

  if(!(elist[1l] == ((struct ci_encaps_entity *)NULL)))
    elist[(signed long int)1]->start=sizeofencaps(elist[(signed long int)0]);

  if(!(elist[2l] == ((struct ci_encaps_entity *)NULL)))
  {
    signed int return_value_sizeofencaps$1;
    return_value_sizeofencaps$1=sizeofencaps(elist[(signed long int)1]);
    elist[(signed long int)2]->start = return_value_sizeofencaps$1 + elist[(signed long int)1]->start;
  }

  if(*elist == ((struct ci_encaps_entity *)NULL))
    sprintf(buf, "Encapsulated: null-body=0");

  else
    if(!(elist[2l] == ((struct ci_encaps_entity *)NULL)))
    {
      _Bool tmp_if_expr$2;
      if(!((*elist)->type >= 6))
        tmp_if_expr$2 = elist[(signed long int)0]->type >= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      const char *tmp_if_expr$3;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = ci_encaps_entities[(signed long int)elist[(signed long int)0]->type];

      else
        tmp_if_expr$3 = "UNKNOWN";
      _Bool tmp_if_expr$4;
      if(!(elist[1l]->type >= 6))
        tmp_if_expr$4 = elist[(signed long int)1]->type >= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      const char *tmp_if_expr$5;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = ci_encaps_entities[(signed long int)elist[(signed long int)1]->type];

      else
        tmp_if_expr$5 = "UNKNOWN";
      _Bool tmp_if_expr$6;
      if(!(elist[2l]->type >= 6))
        tmp_if_expr$6 = elist[(signed long int)2]->type >= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      const char *tmp_if_expr$7;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = ci_encaps_entities[(signed long int)elist[(signed long int)2]->type];

      else
        tmp_if_expr$7 = "UNKNOWN";
      sprintf(buf, "Encapsulated: %s=%d, %s=%d, %s=%d", tmp_if_expr$3, elist[(signed long int)0]->start, tmp_if_expr$5, elist[(signed long int)1]->start, tmp_if_expr$7, elist[(signed long int)2]->start);
    }

    else
      if(!(elist[1l] == ((struct ci_encaps_entity *)NULL)))
      {
        _Bool tmp_if_expr$8;
        if(!((*elist)->type >= 6))
          tmp_if_expr$8 = elist[(signed long int)0]->type >= 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        const char *tmp_if_expr$9;
        if(tmp_if_expr$8)
          tmp_if_expr$9 = ci_encaps_entities[(signed long int)elist[(signed long int)0]->type];

        else
          tmp_if_expr$9 = "UNKNOWN";
        _Bool tmp_if_expr$10;
        if(!(elist[1l]->type >= 6))
          tmp_if_expr$10 = elist[(signed long int)1]->type >= 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$10 = (_Bool)0;
        const char *tmp_if_expr$11;
        if(tmp_if_expr$10)
          tmp_if_expr$11 = ci_encaps_entities[(signed long int)elist[(signed long int)1]->type];

        else
          tmp_if_expr$11 = "UNKNOWN";
        sprintf(buf, "Encapsulated: %s=%d, %s=%d", tmp_if_expr$9, elist[(signed long int)0]->start, tmp_if_expr$11, elist[(signed long int)1]->start);
      }

      else
      {
        _Bool tmp_if_expr$12;
        if(!((*elist)->type >= 6))
          tmp_if_expr$12 = elist[(signed long int)0]->type >= 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$12 = (_Bool)0;
        const char *tmp_if_expr$13;
        if(tmp_if_expr$12)
          tmp_if_expr$13 = ci_encaps_entities[(signed long int)elist[(signed long int)0]->type];

        else
          tmp_if_expr$13 = "UNKNOWN";
        sprintf(buf, "Encapsulated: %s=%d", tmp_if_expr$13, elist[(signed long int)0]->start);
      }
  if(!(is_request == 0))
    ci_headers_add(req->request_header, buf);

  else
    ci_headers_add(req->response_header, buf);
  struct ci_encaps_entity **tmp_post$14;
  do
  {
    tmp_post$14 = elist;
    elist = elist + 1l;
    e = *tmp_post$14;
    if(e == ((struct ci_encaps_entity *)NULL))
      break;

    _Bool tmp_if_expr$15;
    if(e->type == 0)
      tmp_if_expr$15 = (_Bool)1;

    else
      tmp_if_expr$15 = e->type == 1 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$15)
      ci_headers_pack((struct ci_headers_list *)e->entity);

  }
  while((_Bool)1);
  if(!(is_request == 0))
    ci_headers_pack(req->request_header);

  else
    ci_headers_pack(req->response_header);
}

// ci_response_pack
// file include/request.h line 173
void ci_response_pack(struct ci_request *req)
{
  ci_request_t_pack(req, 0);
}

// ci_ring_buf_consume
// file body.c line 931
void ci_ring_buf_consume(struct ci_ring_buf *buf, signed int len)
{
  if(len >= 1)
  {
    buf->read_pos = buf->read_pos + (signed long int)len;
    if(!(buf->end_buf >= buf->read_pos))
      buf->read_pos = buf->buf;

    if(!(buf->full == 0))
      buf->full = 0;

  }

}

// ci_ring_buf_destroy
// file body.c line 882
void ci_ring_buf_destroy(struct ci_ring_buf *buf)
{
  ci_buffer_free((void *)buf->buf);
  ci_object_pool_free((void *)buf);
}

// ci_ring_buf_is_empty
// file body.c line 888
signed int ci_ring_buf_is_empty(struct ci_ring_buf *buf)
{
  _Bool tmp_if_expr$1;
  if(buf->read_pos == buf->write_pos)
    tmp_if_expr$1 = buf->full == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  return (signed int)tmp_if_expr$1;
}

// ci_ring_buf_new
// file body.c line 863
struct ci_ring_buf * ci_ring_buf_new(signed int size)
{
  struct ci_ring_buf *buf;
  void *return_value_ci_object_pool_alloc$1;
  return_value_ci_object_pool_alloc$1=ci_object_pool_alloc(RING_BUF_POOL);
  buf = (struct ci_ring_buf *)return_value_ci_object_pool_alloc$1;
  if(buf == ((struct ci_ring_buf *)NULL))
    return (struct ci_ring_buf *)(void *)0;

  else
  {
    void *return_value_ci_buffer_alloc$2;
    return_value_ci_buffer_alloc$2=ci_buffer_alloc(size);
    buf->buf = (char *)return_value_ci_buffer_alloc$2;
    if(buf->buf == ((char *)NULL))
    {
      ci_object_pool_free((void *)buf);
      return (struct ci_ring_buf *)(void *)0;
    }

    else
    {
      buf->end_buf = (buf->buf + (signed long int)size) - (signed long int)1;
      buf->read_pos = buf->buf;
      buf->write_pos = buf->buf;
      buf->full = 0;
      return buf;
    }
  }
}

// ci_ring_buf_produce
// file body.c line 942
void ci_ring_buf_produce(struct ci_ring_buf *buf, signed int len)
{
  if(len >= 1)
  {
    buf->write_pos = buf->write_pos + (signed long int)len;
    if(!(buf->end_buf >= buf->write_pos))
      buf->write_pos = buf->buf;

    if(buf->write_pos == buf->read_pos)
      buf->full = 1;

  }

}

// ci_ring_buf_read
// file body.c line 975
signed int ci_ring_buf_read(struct ci_ring_buf *buf, char *data, signed int size)
{
  char *rb;
  signed int rb_len;
  signed int ret;
  signed int data_read = 0;
  do
  {
    ret=ci_ring_buf_read_block(buf, &rb, &rb_len);
    if(!(rb_len == 0))
    {
      rb_len = size > rb_len ? rb_len : size;
      memcpy((void *)data, (const void *)rb, (unsigned long int)rb_len);
      ci_ring_buf_consume(buf, rb_len);
      size = size - rb_len;
      data = data + (signed long int)rb_len;
      data_read = data_read + rb_len;
    }

  }
  while(size >= 1 && !(ret == 0));
  return data_read;
}

// ci_ring_buf_read_block
// file body.c line 912
signed int ci_ring_buf_read_block(struct ci_ring_buf *buf, char **rb, signed int *len)
{
  _Bool tmp_if_expr$1;
  if(buf->read_pos == buf->write_pos)
    tmp_if_expr$1 = buf->full == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    *rb = buf->read_pos;
    *len = 0;
    return 0;
  }

  else
    if(buf->read_pos >= buf->write_pos)
    {
      *rb = buf->read_pos;
      *len = (signed int)((buf->end_buf - buf->read_pos) + (signed long int)1);
      return buf->read_pos != buf->buf ? 1 : 0;
    }

    else
    {
      *rb = buf->read_pos;
      *len = (signed int)(buf->write_pos - buf->read_pos);
      return 0;
    }
}

// ci_ring_buf_write
// file body.c line 955
signed int ci_ring_buf_write(struct ci_ring_buf *buf, const char *data, signed int size)
{
  char *wb;
  signed int wb_len;
  signed int ret;
  signed int written = 0;
  do
  {
    ret=ci_ring_buf_write_block(buf, &wb, &wb_len);
    if(!(wb_len == 0))
    {
      wb_len = size > wb_len ? wb_len : size;
      memcpy((void *)wb, (const void *)data, (unsigned long int)wb_len);
      ci_ring_buf_produce(buf, wb_len);
      size = size - wb_len;
      data = data + (signed long int)wb_len;
      written = written + wb_len;
    }

  }
  while(size >= 1 && !(ret == 0));
  return written;
}

// ci_ring_buf_write_block
// file body.c line 893
signed int ci_ring_buf_write_block(struct ci_ring_buf *buf, char **wb, signed int *len)
{
  _Bool tmp_if_expr$1;
  if(buf->read_pos == buf->write_pos)
    tmp_if_expr$1 = buf->full == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    *wb = buf->write_pos;
    *len = (signed int)((buf->end_buf - buf->write_pos) + (signed long int)1);
    return 0;
  }

  else
    if(buf->read_pos >= buf->write_pos)
    {
      *wb = buf->write_pos;
      *len = (signed int)(buf->read_pos - buf->write_pos);
      return 0;
    }

    else
    {
      *wb = buf->write_pos;
      *len = (signed int)((buf->end_buf - buf->write_pos) + (signed long int)1);
      return 1;
    }
}

// ci_service_add_xincludes
// file service_lib.c line 125
void ci_service_add_xincludes(struct ci_service_xdata *srv_xdata, char **xincludes)
{
  signed int len;
  signed int i;
  len = 0;
  i = 0;
  if(!(xincludes == ((char **)NULL)))
  {
    pthread_rwlock_wrlock(&srv_xdata->lock);
    while(511 + -len + -2 >= 1)
    {
      if(xincludes[(signed long int)i] == ((char *)NULL))
        break;

      if(!(len == 0))
      {
        strcat(srv_xdata->xincludes, ", ");
        len = len + 2;
      }

      strncat(srv_xdata->xincludes, xincludes[(signed long int)i], (unsigned long int)(511 - len));
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(xincludes[(signed long int)i]);
      len = len + (signed int)return_value_strlen$1;
      i = i + 1;
    }
    pthread_rwlock_unlock(&srv_xdata->lock);
  }

}

// ci_service_add_xopts
// file service_lib.c line 118
void ci_service_add_xopts(struct ci_service_xdata *srv_xdata, unsigned long int xopts)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->xopts = srv_xdata->xopts | xopts;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_data_read_lock
// file include/service.h line 282
void ci_service_data_read_lock(struct ci_service_xdata *srv_xdata)
{
  pthread_rwlock_rdlock(&srv_xdata->lock);
}

// ci_service_data_read_unlock
// file include/service.h line 283
void ci_service_data_read_unlock(struct ci_service_xdata *srv_xdata)
{
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_enable_204
// file service_lib.c line 82
void ci_service_enable_204(struct ci_service_xdata *srv_xdata)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->allow_204 = 1;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_enable_206
// file service_lib.c line 89
void ci_service_enable_206(struct ci_service_xdata *srv_xdata)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  if(srv_xdata->disable_206 == 0)
    srv_xdata->allow_206 = 1;

  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_istag
// file service_lib.c line 35
void ci_service_set_istag(struct ci_service_xdata *srv_xdata, const char *istag)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  strncpy(srv_xdata->ISTag + (signed long int)13, istag, (unsigned long int)(39 - 13));
  srv_xdata->ISTag[(signed long int)39] = (char)0;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_max_connections
// file include/service.h line 419
void ci_service_set_max_connections(struct ci_service_xdata *srv_xdata, signed int max_connections)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->max_connections = max_connections;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_options_ttl
// file include/service.h line 428
void ci_service_set_options_ttl(struct ci_service_xdata *srv_xdata, signed int ttl)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->options_ttl = ttl;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_preview
// file include/service.h line 391
void ci_service_set_preview(struct ci_service_xdata *srv_xdata, signed int preview)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->preview_size = preview;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_transfer_complete
// file include/service.h line 382
void ci_service_set_transfer_complete(struct ci_service_xdata *srv_xdata, const char *complete)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  strcpy(srv_xdata->TransferComplete, "Transfer-Complete: ");
  strncat(srv_xdata->TransferComplete, complete, (unsigned long int)1023 - sizeof(char [20l]) /*20ul*/ );
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_transfer_ignore
// file include/service.h line 366
void ci_service_set_transfer_ignore(struct ci_service_xdata *srv_xdata, const char *ignore)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  strcpy(srv_xdata->TransferIgnore, "Transfer-Ignore: ");
  strncat(srv_xdata->TransferIgnore, ignore, (unsigned long int)1023 - sizeof(char [18l]) /*18ul*/ );
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_transfer_preview
// file include/service.h line 350
void ci_service_set_transfer_preview(struct ci_service_xdata *srv_xdata, const char *preview)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  strcpy(srv_xdata->TransferPreview, "Transfer-Preview: ");
  strncat(srv_xdata->TransferPreview, preview, (unsigned long int)1023 - sizeof(char [19l]) /*19ul*/ );
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_xopts
// file include/service.h line 325
void ci_service_set_xopts(struct ci_service_xdata *srv_xdata, unsigned long int xopts)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->xopts = xopts;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_shared_mem_attach
// file include/shared_mem.h line 75
void * ci_shared_mem_attach(struct ci_shared_mem_id *id)
{
  _Bool tmp_if_expr$1;
  if(!(id == ((struct ci_shared_mem_id *)NULL)))
    tmp_if_expr$1 = id->scheme != ((const struct ci_shared_mem_scheme *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  /* assertion id && id->scheme */
  assert(tmp_if_expr$1);
  void *return_value;
  return_value=id->scheme->shared_mem_attach(id);
  return return_value;
}

// ci_shared_mem_create
// file include/shared_mem.h line 74
void * ci_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size)
{
  if(default_scheme == ((const struct ci_shared_mem_scheme *)NULL))
    return (void *)0;

  else
  {
    id->scheme = default_scheme;
    void *return_value;
    return_value=default_scheme->shared_mem_create(id, name, size);
    return return_value;
  }
}

// ci_shared_mem_destroy
// file include/shared_mem.h line 77
signed int ci_shared_mem_destroy(struct ci_shared_mem_id *id)
{
  _Bool tmp_if_expr$1;
  if(!(id == ((struct ci_shared_mem_id *)NULL)))
    tmp_if_expr$1 = id->scheme != ((const struct ci_shared_mem_scheme *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  /* assertion id && id->scheme */
  assert(tmp_if_expr$1);
  signed int return_value;
  return_value=id->scheme->shared_mem_destroy(id);
  return return_value;
}

// ci_shared_mem_detach
// file include/shared_mem.h line 76
signed int ci_shared_mem_detach(struct ci_shared_mem_id *id)
{
  _Bool tmp_if_expr$1;
  if(!(id == ((struct ci_shared_mem_id *)NULL)))
    tmp_if_expr$1 = id->scheme != ((const struct ci_shared_mem_scheme *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  /* assertion id && id->scheme */
  assert(tmp_if_expr$1);
  signed int return_value;
  return_value=id->scheme->shared_mem_detach(id);
  return return_value;
}

// ci_shared_mem_set_scheme
// file include/shared_mem.h line 80
signed int ci_shared_mem_set_scheme(const char *name)
{
  signed int return_value_strcasecmp$3;
  return_value_strcasecmp$3=strcasecmp(name, "posix");
  signed int return_value_strcasecmp$2;
  signed int return_value_strcasecmp$1;
  if(return_value_strcasecmp$3 == 0)
    default_scheme = &posix_scheme;

  else
  {
    return_value_strcasecmp$2=strcasecmp(name, "mmap");
    if(return_value_strcasecmp$2 == 0)
      default_scheme = &mmap_scheme;

    else
    {
      return_value_strcasecmp$1=strcasecmp(name, "sysv");
      if(return_value_strcasecmp$1 == 0)
        default_scheme = &sysv_scheme;

      else
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Shared mem scheme '%s' does not supported by c-icap\n", name);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Shared mem scheme '%s' does not supported by c-icap\n", name);

        }

        return 0;
      }
    }
  }
  return 1;
}

// ci_simple_file_destroy
// file body.c line 643
void ci_simple_file_destroy(struct ci_simple_file *body)
{
  if(!(body == ((struct ci_simple_file *)NULL)))
  {
    if(body->fd >= 0)
    {
      do_close(body->fd);
      unlink(body->filename);
    }

    if(!(body->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(body->attributes);

    if(!(body->mmap_addr == ((char *)NULL)))
      munmap((void *)body->mmap_addr, (unsigned long int)body->mmap_size);

    ci_object_pool_free((void *)body);
  }

}

// ci_simple_file_named_new
// file body.c line 601
struct ci_simple_file * ci_simple_file_named_new(char *dir, char *filename, signed long int maxsize)
{
  struct ci_simple_file *body;
  void *return_value_ci_object_pool_alloc$1;
  return_value_ci_object_pool_alloc$1=ci_object_pool_alloc(SIMPLE_FILE_POOL);
  body = (struct ci_simple_file *)return_value_ci_object_pool_alloc$1;
  if(body == ((struct ci_simple_file *)NULL))
    return (struct ci_simple_file *)(void *)0;

  else
  {
    if(!(filename == ((char *)NULL)))
    {
      snprintf(body->filename, (unsigned long int)4096, "%s/%s", dir, filename);
      body->fd=do_open(body->filename, 0100 | 02 | 0200);
      if(!(body->fd >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Can not open temporary filename: %s\n", (const void *)body->filename);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Can not open temporary filename: %s\n", (const void *)body->filename);

        }

        ci_object_pool_free((void *)body);
        return (struct ci_simple_file *)(void *)0;
      }

    }

    else
    {
      body->fd=ci_mktemp_file(dir, "CI_TMP_XXXXXX", body->filename);
      if(!(body->fd >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Can not open temporary filename in directory: %s\n", dir);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Can not open temporary filename in directory: %s\n", dir);

        }

        ci_object_pool_free((void *)body);
        return (struct ci_simple_file *)(void *)0;
      }

    }
    body->endpos = (signed long int)0;
    body->readpos = (signed long int)0;
    body->flags = (unsigned int)0;
    body->unlocked = (signed long int)0;
    body->max_store_size = maxsize > (signed long int)0 ? maxsize : (signed long int)0;
    body->bytes_in = (signed long int)0;
    body->bytes_out = (signed long int)0;
    body->attributes = (struct ci_array *)(void *)0;
    body->mmap_addr = (char *)(void *)0;
    body->mmap_size = (signed long int)0;
    return body;
  }
}

// ci_simple_file_new
// file body.c line 571
struct ci_simple_file * ci_simple_file_new(signed long int maxsize)
{
  struct ci_simple_file *body;
  void *return_value_ci_object_pool_alloc$1;
  return_value_ci_object_pool_alloc$1=ci_object_pool_alloc(SIMPLE_FILE_POOL);
  body = (struct ci_simple_file *)return_value_ci_object_pool_alloc$1;
  if(body == ((struct ci_simple_file *)NULL))
    return (struct ci_simple_file *)(void *)0;

  else
  {
    body->fd=ci_mktemp_file(CI_TMPDIR, "CI_TMP_XXXXXX", body->filename);
    if(!(body->fd >= 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_simple_file_new: Can not open temporary filename in directory:%s\n", CI_TMPDIR);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_simple_file_new: Can not open temporary filename in directory:%s\n", CI_TMPDIR);

      }

      ci_object_pool_free((void *)body);
      return (struct ci_simple_file *)(void *)0;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_simple_file_new: Use temporary filename: %s\n", (const void *)body->filename);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_simple_file_new: Use temporary filename: %s\n", (const void *)body->filename);

      }

      body->endpos = (signed long int)0;
      body->readpos = (signed long int)0;
      body->flags = (unsigned int)0;
      body->unlocked = (signed long int)0;
      body->max_store_size = maxsize > (signed long int)0 ? maxsize : (signed long int)0;
      body->bytes_in = (signed long int)0;
      body->bytes_out = (signed long int)0;
      body->attributes = (struct ci_array *)(void *)0;
      return body;
    }
  }
}

// ci_simple_file_read
// file body.c line 750
signed int ci_simple_file_read(struct ci_simple_file *body, char *buf, signed int len)
{
  signed int remains;
  signed int bytes;
  if(!(len >= 1))
    return 0;

  else
    if(body->readpos == body->endpos)
    {
      if(!((2u & body->flags) == 0u))
      {
        if(CI_DEBUG_LEVEL >= 9)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Has EOF and no data to read, send EOF\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Has EOF and no data to read, send EOF\n");

        }

        return -2;
      }

      return 0;
    }

    else
    {
      if(!(body->max_store_size == 0l))
      {
        if(body->readpos == body->max_store_size)
          body->readpos = (signed long int)0;

      }

      _Bool tmp_if_expr$1;
      if(!((1u & body->flags) == 0u))
        tmp_if_expr$1 = body->unlocked >= (signed long int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        remains = (signed int)(body->unlocked - body->readpos);

      else
        if(!(body->readpos >= body->endpos))
          remains = (signed int)(body->endpos - body->readpos);

        else
          if(!(body->max_store_size == 0l))
            remains = (signed int)(body->max_store_size - body->readpos);

          else
          {
            if(CI_DEBUG_LEVEL >= 9)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error? anyway send EOF\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error? anyway send EOF\n");

            }

            return -2;
          }
      bytes = remains > len ? len : remains;
      lseek64(body->fd, body->readpos, 0);
      bytes=do_read(body->fd, (void *)buf, (unsigned long int)bytes);
      if(bytes >= 1)
      {
        body->readpos = body->readpos + (signed long int)bytes;
        body->bytes_out = body->bytes_out + (signed long int)bytes;
      }

      return bytes;
    }
}

// ci_simple_file_release
// file body.c line 665
void ci_simple_file_release(struct ci_simple_file *body)
{
  if(!(body == ((struct ci_simple_file *)NULL)))
  {
    if(body->fd >= 0)
      do_close(body->fd);

    if(!(body->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(body->attributes);

    if(!(body->mmap_addr == ((char *)NULL)))
      munmap((void *)body->mmap_addr, (unsigned long int)body->mmap_size);

    ci_object_pool_free((void *)body);
  }

}

// ci_simple_file_to_const_string
// file body.c line 824
const char * ci_simple_file_to_const_string(struct ci_simple_file *body)
{
  signed long int map_size;
  char *addr = (char *)(void *)0;
  if((2u & body->flags) == 0u)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "mmap to file: '%s' failed, the eof flag is not set!\n", (const void *)body->filename);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("mmap to file: '%s' failed, the eof flag is not set!\n", (const void *)body->filename);

    }

    return (const char *)(void *)0;
  }

  else
  {
    map_size = body->endpos + (signed long int)1;
    if(body->mmap_addr == ((char *)NULL))
    {
      void *return_value_mmap64$1;
      return_value_mmap64$1=mmap64((void *)0, (unsigned long int)map_size, 0x1 | 0x2, 0x02, body->fd, (signed long int)0);
      addr = (char *)return_value_mmap64$1;
      if(addr == ((char *)NULL))
        return ((const char *)NULL);

      addr[map_size - (signed long int)1] = (char)0;
      body->mmap_addr = addr;
      body->mmap_size = map_size;
    }

    return body->mmap_addr;
  }
}

// ci_simple_file_to_membuf
// file body.c line 848
struct ci_membuf * ci_simple_file_to_membuf(struct ci_simple_file *body, unsigned int flags)
{
  /* assertion ((0x08 | 0x04 | 0x01) & flags) ==flags */
  assert(((unsigned int)(0x08 | 0x04 | 0x01) & flags) == flags);
  /* assertion flags & 0x08 */
  assert((flags & (unsigned int)0x08) != 0u);
  void *addr;
  const char *return_value_ci_simple_file_to_const_string$1;
  return_value_ci_simple_file_to_const_string$1=ci_simple_file_to_const_string(body);
  addr = (void *)return_value_ci_simple_file_to_const_string$1;
  if(addr == NULL)
    return (struct ci_membuf *)(void *)0;

  else
  {
    struct ci_membuf *return_value_ci_membuf_from_content$2;
    return_value_ci_membuf_from_content$2=ci_membuf_from_content(body->mmap_addr, (unsigned long int)body->mmap_size, (unsigned long int)body->endpos, (unsigned int)(0x08 | 0x04 | 0x01 | 0x02));
    return return_value_ci_membuf_from_content$2;
  }
}

// ci_simple_file_truncate
// file body.c line 797
signed int ci_simple_file_truncate(struct ci_simple_file *body, signed long int new_size)
{
  if(!(body->endpos >= new_size))
    return 0;

  else
  {
    if(new_size == 0l)
    {
      new_size=lseek64(body->fd, (signed long int)0, 2);
      if(!(body->endpos >= new_size))
        return 0;

    }

    else
    {
      signed int return_value_ftruncate64$1;
      return_value_ftruncate64$1=ftruncate64(body->fd, new_size);
      if(!(return_value_ftruncate64$1 == 0))
        return 0;

    }
    body->endpos = new_size;
    if(!(new_size >= body->readpos))
      body->readpos = new_size;

    if(!(new_size >= body->unlocked))
      body->unlocked = new_size;

    return 1;
  }
}

// ci_simple_file_write
// file body.c line 686
signed int ci_simple_file_write(struct ci_simple_file *body, const char *buf, signed int len, signed int iseof)
{
  signed int ret;
  signed int wsize = 0;
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  if(!((2u & body->flags) == 0u))
  {
    if(len >= 1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Cannot write to file: '%s', the eof flag is set!\n", (const void *)body->filename);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Cannot write to file: '%s', the eof flag is set!\n", (const void *)body->filename);

      }

    }

    return 0;
  }

  else
    if(!(len >= 1))
    {
      if(!(iseof == 0))
        body->flags = body->flags | (unsigned int)0x02;

      return 0;
    }

    else
    {
      if(!(body->endpos >= body->readpos))
      {
        signed long int tmp_if_expr$1;
        if(!((signed long int)len >= body->readpos + -body->endpos + -1l))
          tmp_if_expr$1 = (signed long int)len;

        else
          tmp_if_expr$1 = (body->readpos - body->endpos) - (signed long int)1;
        wsize = (signed int)tmp_if_expr$1;
      }

      else
      {
        _Bool tmp_if_expr$5;
        if(!(body->max_store_size == 0l))
          tmp_if_expr$5 = body->endpos >= body->max_store_size ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$5 = (_Bool)0;
        if(tmp_if_expr$5)
        {
          _Bool tmp_if_expr$3;
          if(!(body->readpos == 0l))
            tmp_if_expr$3 = (body->flags & (unsigned int)0x01) == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$3 = (_Bool)0;
          if(tmp_if_expr$3)
          {
            body->endpos = (signed long int)0;
            if((4u & body->flags) == 0u)
            {
              body->flags = body->flags | (unsigned int)0x04;
              if(CI_DEBUG_LEVEL >= 9)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "Entering Ring mode!\n");

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("Entering Ring mode!\n");

              }

            }

            signed long int tmp_if_expr$2;
            if(!((signed long int)len >= body->readpos + -body->endpos + -1l))
              tmp_if_expr$2 = (signed long int)len;

            else
              tmp_if_expr$2 = (body->readpos - body->endpos) - (signed long int)1;
            wsize = (signed int)tmp_if_expr$2;
          }

          else
          {
            if(!((1u & body->flags) == 0u))
            {
              if(CI_DEBUG_LEVEL >= 1)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "File locked and no space on file for writing data, (Is this a bug?)!\n");

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("File locked and no space on file for writing data, (Is this a bug?)!\n");

              }

            }

            return 0;
          }
        }

        else
          if(!(body->max_store_size == 0l))
          {
            signed long int tmp_if_expr$4;
            if(!((signed long int)len >= body->max_store_size + -body->endpos))
              tmp_if_expr$4 = (signed long int)len;

            else
              tmp_if_expr$4 = body->max_store_size - body->endpos;
            wsize = (signed int)tmp_if_expr$4;
          }

          else
            wsize = len;
      }
      lseek64(body->fd, body->endpos, 0);
      ret=do_write(body->fd, (const void *)buf, (unsigned long int)wsize);
      if(!(ret >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value___errno_location$6=__errno_location();
            return_value_strerror$7=strerror(*return_value___errno_location$6);
            __log_error((void *)0, "Cannot write to file: %s\n", return_value_strerror$7);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value___errno_location$8=__errno_location();
            return_value_strerror$9=strerror(*return_value___errno_location$8);
            printf("Cannot write to file: %s\n", return_value_strerror$9);
          }

        }

      }

      else
      {
        body->endpos = body->endpos + (signed long int)ret;
        body->bytes_in = body->bytes_in + (signed long int)ret;
      }
      if(ret == len && !(iseof == 0))
      {
        body->flags = body->flags | (unsigned int)0x02;
        if(CI_DEBUG_LEVEL >= 9)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Body data size=%lld\n ", (signed long long int)body->endpos);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Body data size=%lld\n ", (signed long long int)body->endpos);

        }

      }

      return ret;
    }
}

// ci_sockaddr_set_port
// file include/net_io.h line 131
void ci_sockaddr_set_port(struct ci_sockaddr *addr, signed int port)
{
  addr->sockaddr.sin_port=htons((unsigned short int)port);
  addr->ci_sin_port = (signed int)addr->sockaddr.sin_port;
}

// ci_sockaddr_t_to_host
// file include/net_io.h line 135
const char * ci_sockaddr_t_to_host(struct ci_sockaddr *addr, char *hname, signed int maxhostlen)
{
  getnameinfo((struct sockaddr *)&addr->sockaddr, (unsigned int)(addr->ci_sin_family == 10 ? sizeof(struct sockaddr_in6) /*28ul*/  : sizeof(struct sockaddr_in) /*16ul*/ ), hname, (unsigned int)(maxhostlen - 1), (char *)(void *)0, (unsigned int)0, 0);
  return (const char *)hname;
}

// ci_sockaddr_t_to_ip
// file include/net_io.h line 123
const char * ci_sockaddr_t_to_ip(struct ci_sockaddr *addr, char *ip, signed int maxlen)
{
  const char *return_value_ci_inet_ntoa$1;
  return_value_ci_inet_ntoa$1=ci_inet_ntoa(addr->ci_sin_family, addr->ci_sin_addr, ip, maxlen);
  return return_value_ci_inet_ntoa$1;
}

// ci_stat_area_construct
// file stats.c line 198
struct stat_area * ci_stat_area_construct(void *mem_block, signed int size, void (*release_mem)(void *))
{
  struct stat_area *area = (struct stat_area *)(void *)0;
  signed int return_value_ci_stat_memblock_size$1;
  return_value_ci_stat_memblock_size$1=ci_stat_memblock_size();
  if(!(size >= return_value_ci_stat_memblock_size$1))
    return (struct stat_area *)(void *)0;

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct stat_area) /*56ul*/ );
    area = (struct stat_area *)return_value_malloc$2;
    if(area == ((struct stat_area *)NULL))
      return (struct stat_area *)(void *)0;

    else
    {
      /* assertion ((struct stat_memblock *)mem_block)->sig == 0xFAFA */
      assert(((struct stat_memblock *)mem_block)->sig == (unsigned int)0xFAFA);
      ci_thread_mutex_init(&area->mtx);
      area->mem_block = (struct stat_memblock *)mem_block;
      area->release_mem = release_mem;
      area->mem_block->counters64 = (unsigned long int *)(mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
      area->mem_block->counterskbs = (struct kbs *)(mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (signed long int)((unsigned long int)STAT_INT64.entries_num * sizeof(unsigned long int) /*8ul*/ ));
      area->mem_block->counters64_size = STAT_INT64.entries_num;
      area->mem_block->counterskbs_size = STAT_KBS.entries_num;
      ci_stat_area_reset(area);
      return area;
    }
  }
}

// ci_stat_area_destroy
// file stats.c line 236
void ci_stat_area_destroy(struct stat_area *area)
{
  ci_thread_mutex_destroy(&area->mtx);
  if(!(area->release_mem == ((void (*)(void *))NULL)))
    area->release_mem((void *)area->mem_block);

  free((void *)area);
}

// ci_stat_area_kbs_inc
// file stats.c line 257
void ci_stat_area_kbs_inc(struct stat_area *area, signed int ID, signed int count)
{
  if(!(area->mem_block == ((struct stat_memblock *)NULL)))
  {
    _Bool tmp_if_expr$1;
    if(!(ID >= 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = ID >= area->mem_block->counterskbs_size ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1)
    {
      pthread_mutex_lock(&area->mtx);
      (area->mem_block->counterskbs + (signed long int)ID)->bytes = (area->mem_block->counterskbs + (signed long int)ID)->bytes + (unsigned int)count;
      (area->mem_block->counterskbs + (signed long int)ID)->kb = (area->mem_block->counterskbs + (signed long int)ID)->kb + (unsigned long int)((area->mem_block->counterskbs + (signed long int)ID)->bytes >> 10);
      (area->mem_block->counterskbs + (signed long int)ID)->bytes = (area->mem_block->counterskbs + (signed long int)ID)->bytes & (unsigned int)0x3FF;
      pthread_mutex_unlock(&area->mtx);
    }

  }

}

// ci_stat_area_merge
// file stats.c line 322
void ci_stat_area_merge(struct stat_area *dest, struct stat_area *src)
{
  _Bool tmp_if_expr$1;
  if(dest->mem_block == ((struct stat_memblock *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(src->mem_block != ((struct stat_memblock *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
    ci_stat_memblock_merge(dest->mem_block, src->mem_block);

}

// ci_stat_area_reset
// file stats.c line 221
void ci_stat_area_reset(struct stat_area *area)
{
  signed int i;
  pthread_mutex_lock(&area->mtx);
  i = 0;
  for( ; !(i >= area->mem_block->counters64_size); i = i + 1)
    area->mem_block->counters64[(signed long int)i] = (unsigned long int)0;
  i = 0;
  for( ; !(i >= area->mem_block->counterskbs_size); i = i + 1)
  {
    (area->mem_block->counterskbs + (signed long int)i)->kb = (unsigned long int)0;
    (area->mem_block->counterskbs + (signed long int)i)->bytes = (unsigned int)0;
  }
  pthread_mutex_unlock(&area->mtx);
}

// ci_stat_area_uint64_inc
// file stats.c line 245
void ci_stat_area_uint64_inc(struct stat_area *area, signed int ID, signed int count)
{
  if(!(area->mem_block == ((struct stat_memblock *)NULL)))
  {
    _Bool tmp_if_expr$1;
    if(!(ID >= 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = ID >= area->mem_block->counters64_size ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1)
    {
      pthread_mutex_lock(&area->mtx);
      area->mem_block->counters64[(signed long int)ID] = area->mem_block->counters64[(signed long int)ID] + (unsigned long int)count;
      pthread_mutex_unlock(&area->mtx);
    }

  }

}

// ci_stat_attach_mem
// file include/stats.h line 81
void ci_stat_attach_mem(void *mem_block, signed int size, void (*release_mem)(void *))
{
  if(STATS == ((struct stat_area *)NULL))
    STATS=ci_stat_area_construct(mem_block, size, release_mem);

}

// ci_stat_entry_register
// file include/stats.h line 78
signed int ci_stat_entry_register(char *label, signed int type, char *group)
{
  signed int gid;
  gid=stat_group_add(group);
  if(!(gid >= 0))
    return -1;

  else
  {
    if(type == 0)
    {
      signed int return_value_stat_entry_add$1;
      return_value_stat_entry_add$1=stat_entry_add(&STAT_INT64, label, type, gid);
      return return_value_stat_entry_add$1;
    }

    else
      if(type == 1)
      {
        signed int return_value_stat_entry_add$2;
        return_value_stat_entry_add$2=stat_entry_add(&STAT_KBS, label, type, gid);
        return return_value_stat_entry_add$2;
      }

    return -1;
  }
}

// ci_stat_entry_release_lists
// file stats.c line 146
void ci_stat_entry_release_lists()
{
  stat_entry_release_list(&STAT_INT64);
  stat_entry_release_list(&STAT_KBS);
}

// ci_stat_kbs_inc
// file stats.c line 179
void ci_stat_kbs_inc(signed int ID, signed int count)
{
  if(!(STATS->mem_block == ((struct stat_memblock *)NULL)))
  {
    _Bool tmp_if_expr$1;
    if(!(ID >= 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = ID >= STATS->mem_block->counterskbs_size ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$1)
    {
      pthread_mutex_lock(&STATS->mtx);
      (STATS->mem_block->counterskbs + (signed long int)ID)->bytes = (STATS->mem_block->counterskbs + (signed long int)ID)->bytes + (unsigned int)count;
      (STATS->mem_block->counterskbs + (signed long int)ID)->kb = (STATS->mem_block->counterskbs + (signed long int)ID)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)ID)->bytes >> 10);
      (STATS->mem_block->counterskbs + (signed long int)ID)->bytes = (STATS->mem_block->counterskbs + (signed long int)ID)->bytes & (unsigned int)0x3FF;
      pthread_mutex_unlock(&STATS->mtx);
    }

  }

}

// ci_stat_memblock_merge
// file include/stats.h line 94
void ci_stat_memblock_merge(struct stat_memblock *dest_block, struct stat_memblock *mem_block)
{
  signed int i;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(!(dest_block == ((struct stat_memblock *)NULL)) && !(mem_block == ((struct stat_memblock *)NULL)))
  {
    i = 0;
    do
    {
      if(!(i >= dest_block->counters64_size))
        tmp_if_expr$1 = i < mem_block->counters64_size ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      dest_block->counters64[(signed long int)i] = dest_block->counters64[(signed long int)i] + mem_block->counters64[(signed long int)i];
      i = i + 1;
    }
    while((_Bool)1);
    i = 0;
    do
    {
      if(!(i >= dest_block->counterskbs_size))
        tmp_if_expr$2 = i < mem_block->counterskbs_size ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        break;

      (dest_block->counterskbs + (signed long int)i)->kb = (dest_block->counterskbs + (signed long int)i)->kb + (mem_block->counterskbs + (signed long int)i)->kb;
      (dest_block->counterskbs + (signed long int)i)->bytes = (dest_block->counterskbs + (signed long int)i)->bytes + (mem_block->counterskbs + (signed long int)i)->bytes;
      (dest_block->counterskbs + (signed long int)i)->kb = (dest_block->counterskbs + (signed long int)i)->kb + (unsigned long int)((dest_block->counterskbs + (signed long int)i)->bytes >> 10);
      (dest_block->counterskbs + (signed long int)i)->bytes = (dest_block->counterskbs + (signed long int)i)->bytes & (unsigned int)0x3FF;
      i = i + 1;
    }
    while((_Bool)1);
  }

}

// ci_stat_memblock_reset
// file include/stats.h line 95
void ci_stat_memblock_reset(struct stat_memblock *block)
{
  signed int i = 0;
  for( ; !(i >= block->counters64_size); i = i + 1)
    block->counters64[(signed long int)i] = (unsigned long int)0;
  i = 0;
  for( ; !(i >= block->counterskbs_size); i = i + 1)
  {
    (block->counterskbs + (signed long int)i)->kb = (unsigned long int)0;
    (block->counterskbs + (signed long int)i)->bytes = (unsigned int)0;
  }
}

// ci_stat_memblock_size
// file include/stats.h line 77
signed int ci_stat_memblock_size(void)
{
  return (signed int)((sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (unsigned long int)STAT_INT64.entries_num * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)STAT_KBS.entries_num * sizeof(struct kbs) /*16ul*/ );
}

// ci_stat_release
// file stats.c line 160
void ci_stat_release()
{
  if(!(STATS == ((struct stat_area *)NULL)))
  {
    ci_stat_area_destroy(STATS);
    STATS = (struct stat_area *)(void *)0;
  }

}

// ci_stat_uint64_inc
// file stats.c line 168
void ci_stat_uint64_inc(signed int ID, signed int count)
{
  _Bool tmp_if_expr$1;
  if(STATS == ((struct stat_area *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(STATS->mem_block != ((struct stat_memblock *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
  {
    _Bool tmp_if_expr$2;
    if(!(ID >= 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = ID >= STATS->mem_block->counters64_size ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$2)
    {
      pthread_mutex_lock(&STATS->mtx);
      STATS->mem_block->counters64[(signed long int)ID] = STATS->mem_block->counters64[(signed long int)ID] + (unsigned long int)count;
      pthread_mutex_unlock(&STATS->mtx);
    }

  }

}

// ci_str_trim
// file util.c line 108
void ci_str_trim(char *str)
{
  char *s;
  char *e;
  const unsigned short int **return_value___ctype_b_loc$1;
  const unsigned short int **return_value___ctype_b_loc$3;
  if(!(str == ((char *)NULL)))
  {
    s = str;
    e = (char *)(void *)0;
    do
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*s]) == 0)
        break;

      e = s;
      for( ; !((signed int)*e == 0); e = e + 1l)
        *e = e[(signed long int)1];
    }
    while((_Bool)1);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(str);
    e = str + (signed long int)return_value_strlen$2;
    e = e - 1l;
    do
    {
      return_value___ctype_b_loc$3=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*e]) == 0)
        break;

      if(!(e >= str))
        break;

      *e = (char)0;
      e = e - 1l;
    }
    while((_Bool)1);
  }

}

// ci_str_trim2
// file util.c line 131
char * ci_str_trim2(char *s)
{
  char *e;
  const unsigned short int **return_value___ctype_b_loc$1;
  const unsigned short int **return_value___ctype_b_loc$3;
  if(s == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    do
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*s]) == 0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(s);
    e = s + (signed long int)return_value_strlen$2;
    e = e - 1l;
    do
    {
      return_value___ctype_b_loc$3=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*e]) == 0)
        break;

      if(!(e >= s))
        break;

      *e = (char)0;
      e = e - 1l;
    }
    while((_Bool)1);
    return s;
  }
}

// ci_str_vector_iterate
// file array.c line 461
void ci_str_vector_iterate(const struct ci_vector *vector, void *data, signed int (*fn)(void *, const char *))
{
  ci_vector_iterate(vector, data, (signed int (*)(void *, const void *))fn);
}

// ci_str_vector_search
// file include/array.h line 549
const char * ci_str_vector_search(struct ci_vector *vector, const char *item)
{
  signed int i = 0;
  for( ; !(vector->items[(signed long int)i] == NULL); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((const char *)vector->items[(signed long int)i], item);
    if(return_value_strcmp$1 == 0)
      return (const char *)vector->items[(signed long int)i];

  }
  return (const char *)(void *)0;
}

// ci_strcasestr
// file util.c line 43
const char * ci_strcasestr(const char *str, const char *find)
{
  const char *s;
  const char *c;
  const char *f;
  s = str;
  for( ; !((signed int)*s == 0); s = s + 1l)
  {
    f = find;
    c = s;
    for( ; (_Bool)1; c = c + 1l)
    {
      if((signed int)*f == 0)
        return s;

      if((signed int)*c == 0)
        return (const char *)(void *)0;

      signed int return_value_tolower$1;
      return_value_tolower$1=tolower((signed int)*c);
      signed int return_value_tolower$2;
      return_value_tolower$2=tolower((signed int)*f);
      if(!(return_value_tolower$1 == return_value_tolower$2))
        break;

      f = f + 1l;
    }
  }
  return (const char *)(void *)0;
}

// ci_strerror
// file include/util.h line 57
char * ci_strerror(signed int error, char *buf, unsigned long int buflen)
{
  char *return_value_strerror_r$1;
  return_value_strerror_r$1=strerror_r(error, buf, buflen);
  return return_value_strerror_r$1;
}

// ci_strncasestr
// file util.c line 59
const char * ci_strncasestr(const char *s, const char *find, unsigned long int slen)
{
  unsigned long int len;
  len=strlen(find);
  signed int return_value_strncasecmp$1;
  if(len == 0ul)
    return (const char *)(void *)0;

  else
  {
    while(slen >= len)
    {
      signed int return_value_tolower$2;
      return_value_tolower$2=tolower((signed int)*s);
      signed int return_value_tolower$3;
      return_value_tolower$3=tolower((signed int)*find);
      if(return_value_tolower$2 == return_value_tolower$3)
      {
        return_value_strncasecmp$1=strncasecmp(s, find, len);
        if(return_value_strncasecmp$1 == 0)
          return s;

      }

      s = s + 1l;
      slen = slen - 1ul;
    }
    return (const char *)(void *)0;
  }
}

// ci_strnstr
// file include/util.h line 44
const char * ci_strnstr(const char *s, const char *find, unsigned long int slen)
{
  unsigned long int len;
  len=strlen(find);
  signed int return_value_strncmp$1;
  if(len == 0ul)
    return (const char *)(void *)0;

  else
  {
    while(slen >= len)
    {
      if(*s == *find)
      {
        return_value_strncmp$1=strncmp(s, find, len);
        if(return_value_strncmp$1 == 0)
          return s;

      }

      s = s + 1l;
      slen = slen - 1ul;
    }
    return (const char *)(void *)0;
  }
}

// ci_strtime
// file include/util.h line 32
void ci_strtime(char *buf)
{
  struct tm br_tm;
  signed long int tm;
  time(&tm);
  struct tm *return_value_localtime_r$1;
  return_value_localtime_r$1=localtime_r(&tm, &br_tm);
  asctime_r(return_value_localtime_r$1, buf);
  buf[(signed long int)(64 - 1)] = (char)0;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(buf);
  buf[(signed long int)(return_value_strlen$2 - (unsigned long int)1)] = (char)0;
}

// ci_strtime_rfc822
// file include/util.h line 33
void ci_strtime_rfc822(char *buf)
{
  struct tm br_tm;
  signed long int tm;
  time(&tm);
  gmtime_r(&tm, &br_tm);
  snprintf(buf, (unsigned long int)64, "%s, %.2d %s %d %.2d:%.2d:%.2d GMT", days[(signed long int)br_tm.tm_wday], br_tm.tm_mday, months[(signed long int)br_tm.tm_mon], br_tm.tm_year + 1900, br_tm.tm_hour, br_tm.tm_min, br_tm.tm_sec);
  buf[(signed long int)(64 - 1)] = (char)0;
}

// ci_thread_cond_destroy
// file include/ci_threads.h line 62
signed int ci_thread_cond_destroy(union anonymous$9 *pcond)
{
  signed int return_value_pthread_cond_destroy$1;
  return_value_pthread_cond_destroy$1=pthread_cond_destroy(pcond);
  return return_value_pthread_cond_destroy$1;
}

// ci_thread_cond_init
// file include/ci_threads.h line 61
signed int ci_thread_cond_init(union anonymous$9 *pcond)
{
  signed int return_value_pthread_cond_init$1;
  return_value_pthread_cond_init$1=pthread_cond_init(pcond, (const union anonymous$21 *)(void *)0);
  return return_value_pthread_cond_init$1;
}

// ci_thread_create
// file include/ci_threads.h line 67
signed int ci_thread_create(unsigned long int *pthread_id, void * (*pfunc)(void *), void *parg)
{
  signed int return_value_pthread_create$1;
  return_value_pthread_create$1=pthread_create(pthread_id, (const union pthread_attr_t *)(void *)0, pfunc, parg);
  return return_value_pthread_create$1;
}

// ci_thread_join
// file include/ci_threads.h line 68
signed int ci_thread_join(unsigned long int thread_id)
{
  signed int return_value_pthread_join$1;
  return_value_pthread_join$1=pthread_join(thread_id, (void **)(void *)0);
  return return_value_pthread_join$1;
}

// ci_thread_mutex_destroy
// file include/ci_threads.h line 40
signed int ci_thread_mutex_destroy(union anonymous$3 *pmutex)
{
  del_mutex((void *)pmutex);
  signed int return_value_pthread_mutex_destroy$1;
  return_value_pthread_mutex_destroy$1=pthread_mutex_destroy(pmutex);
  return return_value_pthread_mutex_destroy$1;
}

// ci_thread_mutex_init
// file include/ci_threads.h line 39
signed int ci_thread_mutex_init(union anonymous$3 *pmutex)
{
  signed int ret;
  ret=pthread_mutex_init(pmutex, (const union anonymous$21 *)(void *)0);
  if(!(ret == 0))
    return ret;

  else
  {
    add_mutex((void *)pmutex, 0);
    return ret;
  }
}

// ci_thread_rwlock_destroy
// file include/ci_threads.h line 48
signed int ci_thread_rwlock_destroy(union anonymous$1 *rwlock)
{
  del_mutex((void *)rwlock);
  signed int return_value_pthread_rwlock_destroy$1;
  return_value_pthread_rwlock_destroy$1=pthread_rwlock_destroy(rwlock);
  return return_value_pthread_rwlock_destroy$1;
}

// ci_thread_rwlock_init
// file include/ci_threads.h line 47
signed int ci_thread_rwlock_init(union anonymous$1 *rwlock)
{
  signed int ret;
  ret=pthread_rwlock_init(rwlock, (const union anonymous$22 *)(void *)0);
  if(!(ret == 0))
    return ret;

  else
  {
    add_mutex((void *)rwlock, 1);
    return ret;
  }
}

// ci_txt_template_build_content
// file txtTemplate.c line 396
struct ci_membuf * ci_txt_template_build_content(const struct ci_request *req, const char *SERVICE_NAME, const char *TEMPLATE_NAME, struct ci_fmt_entry *user_table)
{
  struct ci_membuf *content;
  char templpath[4096l];
  struct anonymous$7 *template = (struct anonymous$7 *)(void *)0;
  content=ci_membuf_new_sized(TEMPLATE_MEMBUF_SIZE);
  unsigned long int return_value_strlen$1;
  if(content == ((struct ci_membuf *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Failed to allocate buffer to load template!");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Failed to allocate buffer to load template!");

    }

    return (struct ci_membuf *)(void *)0;
  }

  else
  {
    template=templateLoadText(req, SERVICE_NAME, TEMPLATE_NAME);
    if(!(template == ((struct anonymous$7 *)NULL)))
    {
      content->endpos=ci_format_text((struct ci_request *)req, template->data->buf, content->buf, content->bufsize, user_table);
      ci_membuf_write(content, "\0", 1, 1);
      if(!(template->LANGUAGE == ((char *)NULL)))
      {
        return_value_strlen$1=strlen(template->LANGUAGE);
        ci_membuf_attr_add(content, "lang", (const void *)template->LANGUAGE, return_value_strlen$1 + (unsigned long int)1);
      }

      template_release(template);
    }

    else
    {
      makeTemplatePathFileName(templpath, 4096, SERVICE_NAME, TEMPLATE_NAME, TEMPLATE_DEF_LANG);
      content->endpos=snprintf(content->buf, (unsigned long int)content->bufsize, "ERROR: Unable to find specified template: %s\n", (const void *)templpath);
      if(!(content->bufsize >= content->endpos))
        content->endpos = content->bufsize;

      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(TEMPLATE_DEF_LANG);
      ci_membuf_attr_add(content, "lang", (const void *)TEMPLATE_DEF_LANG, return_value_strlen$2 + (unsigned long int)1);
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ERROR: Unable to find specified template: %s\n", (const void *)templpath);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ERROR: Unable to find specified template: %s\n", (const void *)templpath);

      }

    }
    return content;
  }
}

// ci_txt_template_close
// file include/txtTemplate.h line 40
void ci_txt_template_close(void)
{
  signed int i;
  if(!(templates == ((struct anonymous$7 *)NULL)))
  {
    i = 0;
    for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
      templateFree(&templates[(signed long int)i]);
    free((void *)templates);
    templates = (struct anonymous$7 *)(void *)0;
    ci_thread_mutex_destroy(&templates_mutex);
  }

}

// ci_txt_template_init
// file include/txtTemplate.h line 39
signed int ci_txt_template_init(void)
{
  signed int i;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)TEMPLATE_CACHE_SIZE * sizeof(struct anonymous$7) /*72ul*/ );
  templates = (struct anonymous$7 *)return_value_malloc$1;
  if(templates == ((struct anonymous$7 *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Unable to allocate memory in in inittxtTemplate for template storage!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Unable to allocate memory in in inittxtTemplate for template storage!\n");

    }

    return -1;
  }

  else
  {
    i = 0;
    for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    {
      (templates + (signed long int)i)->data = (struct ci_membuf *)(void *)0;
      (templates + (signed long int)i)->loaded = (signed long int)0;
      (templates + (signed long int)i)->locked = 0;
      (templates + (signed long int)i)->must_free = 0;
      (templates + (signed long int)i)->non_cached = 0;
    }
    txtTemplateInited = 1;
    ci_thread_mutex_init(&templates_mutex);
    return 1;
  }
}

// ci_txt_template_reset
// file txtTemplate.c line 181
void ci_txt_template_reset(void)
{
  signed int i = 0;
  pthread_mutex_lock(&templates_mutex);
  i = 0;
  for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    templateFree(&templates[(signed long int)i]);
  pthread_mutex_unlock(&templates_mutex);
}

// ci_txt_template_set_default_lang
// file txtTemplate.c line 104
void ci_txt_template_set_default_lang(const char *lang)
{
  TEMPLATE_DEF_LANG = lang;
}

// ci_txt_template_set_dir
// file include/txtTemplate.h line 41
void ci_txt_template_set_dir(const char *dir)
{
  TEMPLATE_DIR = dir;
}

// ci_uncompress_preview
// file decode.c line 313
signed int ci_uncompress_preview(signed int compress_method, const char *buf, signed int len, char *unzipped_buf, signed int *unzipped_buf_len)
{
  signed int return_value_zlib_inflate$1;
  return_value_zlib_inflate$1=zlib_inflate(buf, len, unzipped_buf, unzipped_buf_len);
  return return_value_zlib_inflate$1;
  return -1;
}

// ci_usleep
// file include/util.h line 35
signed int ci_usleep(unsigned long int usec)
{
  struct timespec us;
  struct timespec ur;
  us.tv_sec = (signed long int)0;
  us.tv_nsec = (signed long int)(usec * (unsigned long int)1000);
  nanosleep(&us, &ur);
  return 0;
}

// ci_vector_add
// file include/array.h line 480
void * ci_vector_add(struct ci_vector *vector, const void *value, unsigned long int size)
{
  void *item;
  void **indx;
  struct ci_mem_allocator *packer = vector->alloc;
  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  void *return_value_ci_pack_allocator_alloc_unaligned$1;
  return_value_ci_pack_allocator_alloc_unaligned$1=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((void **)0)[(signed long int)1]);
  indx = (void **)return_value_ci_pack_allocator_alloc_unaligned$1;
  item=ci_pack_allocator_alloc_from_rear(packer, (signed int)size);
  if(item == NULL || indx == ((void **)NULL))
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to add the new item to vector!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to add the new item to vector!\n");

    }

    return (void *)0;
  }

  else
  {
    memcpy(item, value, size);
    *vector->last = item;
    vector->last = indx;
    *vector->last = (void *)0;
    vector->count = vector->count + 1;
    return item;
  }
}

// ci_vector_cast_from_voidvoid
// file array.c line 386
struct ci_vector * ci_vector_cast_from_voidvoid(const void **p)
{
  const void *buf;
  struct ci_vector *v = (struct ci_vector *)((void *)p - (signed long int)(sizeof(struct ci_vector) /*48ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  unsigned long int return_value_ci_pack_allocator_required_size$1;
  return_value_ci_pack_allocator_required_size$1=ci_pack_allocator_required_size();
  buf = (void *)v - (signed long int)return_value_ci_pack_allocator_required_size$1;
  /* assertion v->mem == buf */
  assert(v->mem == (char *)buf);
  unsigned long int return_value_ci_buffer_blocksize$2;
  return_value_ci_buffer_blocksize$2=ci_buffer_blocksize(buf);
  /* assertion ci_buffer_blocksize(buf) != 0 */
  assert(return_value_ci_buffer_blocksize$2 != (unsigned long int)0);
  return v;
}

// ci_vector_cast_to_voidvoid
// file array.c line 381
const void ** ci_vector_cast_to_voidvoid(struct ci_vector *vector)
{
  return (const void **)vector->items;
}

// ci_vector_create
// file include/array.h line 463
struct ci_vector * ci_vector_create(unsigned long int max_size)
{
  struct ci_vector *vector;
  struct ci_mem_allocator *packer;
  void *buffer;
  void **indx;
  buffer=ci_buffer_alloc((signed int)max_size);
  if(buffer == NULL)
    return (struct ci_vector *)(void *)0;

  else
  {
    packer=ci_create_pack_allocator_on_memblock((char *)buffer, max_size);
    if(packer == ((struct ci_mem_allocator *)NULL))
    {
      ci_buffer_free(buffer);
      return (struct ci_vector *)(void *)0;
    }

    else
    {
      void *return_value_ci_pack_allocator_alloc$1;
      return_value_ci_pack_allocator_alloc$1=ci_pack_allocator_alloc(packer, sizeof(struct ci_vector) /*48ul*/ );
      vector = (struct ci_vector *)return_value_ci_pack_allocator_alloc$1;
      void *return_value_ci_pack_allocator_alloc_unaligned$2;
      return_value_ci_pack_allocator_alloc_unaligned$2=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((void **)0)[(signed long int)1]);
      indx = (void **)return_value_ci_pack_allocator_alloc_unaligned$2;
      if(indx == ((void **)NULL) || vector == ((struct ci_vector *)NULL))
      {
        ci_buffer_free(buffer);
        ci_mem_allocator_destroy(packer);
        return (struct ci_vector *)(void *)0;
      }

      else
      {
        *indx = (void *)0;
        vector->max_size = max_size;
        vector->mem = (char *)buffer;
        vector->items = indx;
        vector->last = indx;
        vector->count = 0;
        vector->alloc = packer;
        return vector;
      }
    }
  }
}

// ci_vector_destroy
// file array.c line 398
void ci_vector_destroy(struct ci_vector *vector)
{
  void *buffer = (void *)vector->mem;
  /* assertion buffer */
  assert(buffer != NULL);
  if(!(vector->alloc == ((struct ci_mem_allocator *)NULL)))
    ci_mem_allocator_destroy(vector->alloc);

  ci_buffer_free(buffer);
}

// ci_vector_iterate
// file array.c line 452
void ci_vector_iterate(const struct ci_vector *vector, void *data, signed int (*fn)(void *, const void *))
{
  signed int i;
  signed int ret = 0;
  i = 0;
  if(ret == 0 && !(vector->items[(signed long int)i] == NULL))
  {
    ret=fn(data, vector->items[(signed long int)i]);
    i = i + 1;
  }

}

// ci_vector_pop
// file array.c line 427
void * ci_vector_pop(struct ci_vector *vector)
{
  void *p;
  if(vector->count == 0)
    return (void *)0;

  else
  {
    ci_pack_allocator_set_start_pos(vector->alloc, (void *)vector->last);
    vector->count = vector->count - 1;
    vector->last = &vector->items[(signed long int)vector->count];
    if(vector->count == 0)
      ci_pack_allocator_set_end_pos(vector->alloc, (void *)0);

    else
      ci_pack_allocator_set_end_pos(vector->alloc, vector->items[(signed long int)(vector->count - 1)]);
    p = *vector->last;
    *vector->last = (void *)0;
    return p;
  }
}

// ci_wait_for_data
// file include/net_io.h line 144
signed int ci_wait_for_data(signed int fd, signed int secs, signed int what_wait)
{
  struct anonymous$19 rfds;
  struct anonymous$19 wfds;
  struct anonymous$19 *preadfds;
  struct anonymous$19 *pwritefds;
  struct timeval tv;
  signed int ret = 0;
  if(secs >= 0)
  {
    tv.tv_sec = (signed long int)secs;
    tv.tv_usec = (signed long int)0;
  }

  preadfds = (struct anonymous$19 *)(void *)0;
  pwritefds = (struct anonymous$19 *)(void *)0;
  if(!((0x1 & what_wait) == 0))
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$19) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfds)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&rfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    preadfds = &rfds;
  }

  if(!((0x2 & what_wait) == 0))
  {
    do
    {
      signed int ci_wait_for_data$$1$$3$$1$$__d0;
      signed int ci_wait_for_data$$1$$3$$1$$__d1;
      asm("cld; rep; stosq" : "=c"(ci_wait_for_data$$1$$3$$1$$__d0), "=D"(ci_wait_for_data$$1$$3$$1$$__d1) : "a"(0), "0"(sizeof(struct anonymous$19) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wfds)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&wfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    pwritefds = &wfds;
  }

  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  ret=select(fd + 1, preadfds, pwritefds, (struct anonymous$19 *)(void *)0, secs >= 0 ? &tv : (struct timeval *)(void *)0);
  signed int *return_value___errno_location$4;
  signed int *return_value___errno_location$2;
  signed int *return_value___errno_location$3;
  if(ret >= 1)
  {
    ret = 0;
    if(!(preadfds == ((struct anonymous$19 *)NULL)))
    {
      if(!((preadfds->fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
        ret = 0x1;

    }

    if(!(pwritefds == ((struct anonymous$19 *)NULL)))
    {
      if(!((pwritefds->fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
        ret = ret | 0x2;

    }

    return ret;
  }

  else
  {
    if(!(ret >= 0))
    {
      return_value___errno_location$4=__errno_location();
      if(!(*return_value___errno_location$4 == 4))
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value___errno_location$2=__errno_location();
            __log_error((void *)0, "Fatal error while waiting for new data (errno=%d....\n", *return_value___errno_location$2);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value___errno_location$3=__errno_location();
            printf("Fatal error while waiting for new data (errno=%d....\n", *return_value___errno_location$3);
          }

        }

        return -1;
      }

    }

    return 0;
  }
}

// ci_write
// file include/net_io.h line 151
signed int ci_write(signed int fd, const void *buf, unsigned long int count, signed int timeout)
{
  signed int bytes = 0;
  signed int remains = (signed int)count;
  char *b = (char *)buf;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$8;
  _Bool tmp_if_expr$6;
  signed int *return_value___errno_location$5;
  while(remains >= 1)
  {
    do
    {
      signed long int return_value_write$3;
      return_value_write$3=write(fd, (const void *)b, (unsigned long int)remains);
      bytes = (signed int)return_value_write$3;
      if(bytes == -1)
      {
        return_value___errno_location$1=__errno_location();
        tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
    }
    while(tmp_if_expr$2);
    if(bytes == -1)
    {
      return_value___errno_location$8=__errno_location();
      if(*return_value___errno_location$8 == 11)
      {
        signed int return_value_ci_wait_for_data$4;
        return_value_ci_wait_for_data$4=ci_wait_for_data(fd, timeout, 0x2);
        if(return_value_ci_wait_for_data$4 == 0)
          return bytes;

        do
        {
          signed long int return_value_write$7;
          return_value_write$7=write(fd, (const void *)b, (unsigned long int)remains);
          bytes = (signed int)return_value_write$7;
          if(bytes == -1)
          {
            return_value___errno_location$5=__errno_location();
            tmp_if_expr$6 = *return_value___errno_location$5 == 4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$6 = (_Bool)0;
        }
        while(tmp_if_expr$6);
      }

    }

    if(!(bytes >= 0))
      return bytes;

    b = b + (signed long int)bytes;
    remains = remains - bytes;
  }
  return (signed int)count;
}

// ci_write_nonblock
// file include/net_io.h line 153
signed int ci_write_nonblock(signed int fd, const void *buf, unsigned long int count)
{
  signed int bytes = 0;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  do
  {
    signed long int return_value_write$3;
    return_value_write$3=write(fd, buf, count);
    bytes = (signed int)return_value_write$3;
    if(bytes == -1)
    {
      return_value___errno_location$1=__errno_location();
      tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  signed int *return_value___errno_location$4;
  if(!(bytes >= 0))
  {
    return_value___errno_location$4=__errno_location();
    if(*return_value___errno_location$4 == 11)
      return 0;

  }

  return bytes;
}

// ci_writen
// file request_common.c line 801
static signed int ci_writen(signed int fd, char *buf, signed int len, signed int timeout)
{
  signed int ret = 0;
  signed int remains = len;
  for( ; !(remains == 0); remains = remains - ret)
  {
    ret=ci_write(fd, (const void *)buf, (unsigned long int)remains, timeout);
    if(!(ret >= 0))
      return ret;

    buf = buf + (signed long int)ret;
  }
  return len;
}

// clear_pid
// file aserver.c line 50
signed int clear_pid(char *pidfile)
{
  signed int return_value_remove$3;
  return_value_remove$3=remove(pidfile);
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  if(!(return_value_remove$3 == 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value___errno_location$1=__errno_location();
        __log_error((void *)0, "Cannot delete the pid file: %s Error:%d\n", pidfile, *return_value___errno_location$1);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value___errno_location$2=__errno_location();
        printf("Cannot delete the pid file: %s Error:%d\n", pidfile, *return_value___errno_location$2);
      }

    }

    return 0;
  }

  else
    return 1;
}

// client_build_headers
// file request_common.c line 1281
static signed int client_build_headers(struct ci_request *req, signed int has_reqhdr, signed int has_reshdr, signed int has_body)
{
  signed int i = 0;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    if(!(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)))
      ci_request_release_entity(req, i);

  i = 0;
  if(!(has_reqhdr == 0))
  {
    signed int tmp_post$1 = i;
    i = i + 1;
    req->entities[(signed long int)tmp_post$1]=ci_request_alloc_entity(req, 0, 0);
  }

  if(!(has_reshdr == 0))
  {
    signed int tmp_post$2 = i;
    i = i + 1;
    req->entities[(signed long int)tmp_post$2]=ci_request_alloc_entity(req, 1, 0);
  }

  if(!(has_body == 0))
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, req->type == 0x04 ? 3 : 2, 0);

  else
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 4, 0);
  return 1;
}

// client_create_request
// file request_common.c line 724
static signed int client_create_request(struct ci_request *req, char *servername, char *service, signed int reqtype)
{
  char buf[256l];
  if(!(reqtype == 0x01) && !(reqtype == 0x02) && !(reqtype == 0x04))
    return -1;

  else
  {
    req->type = reqtype;
    const char *tmp_if_expr$1;
    if(reqtype >= 0x01 && !(reqtype >= 5))
      tmp_if_expr$1 = ci_methods[(signed long int)reqtype];

    else
      tmp_if_expr$1 = "UNKNOWN";
    snprintf(buf, (unsigned long int)255, "%s icap://%s/%s ICAP/1.0", tmp_if_expr$1, servername, service);
    buf[(signed long int)255] = (char)0;
    ci_headers_add(req->request_header, buf);
    snprintf(buf, (unsigned long int)255, "Host: %s", servername);
    buf[(signed long int)255] = (char)0;
    ci_headers_add(req->request_header, buf);
    ci_headers_add(req->request_header, "User-Agent: C-ICAP-Client-Library/0.01");
    _Bool tmp_if_expr$2;
    if(!(req->allow204 == 0))
      tmp_if_expr$2 = req->allow206 != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      ci_headers_add(req->request_header, "Allow: 204, 206");

    else
      if(!(req->allow204 == 0))
        ci_headers_add(req->request_header, "Allow: 204");

    if(!(req->allow206 == 0))
      ci_headers_add(req->request_header, "Allow: 206");

    if(!(req->xheaders->used == 0))
      ci_headers_addheaders(req->request_header, req->xheaders);

    return 1;
  }
}

// client_parse_encaps_header
// file request_common.c line 921
static signed int client_parse_encaps_header(struct ci_request *req, struct ci_headers_list *h, signed int size)
{
  signed int remains;
  signed int readed = 0;
  char *buf_end = (char *)(void *)0;
  remains = size - h->bufused;
  if(!(remains >= 0))
    return -1;

  else
    if(remains == 0)
      return 1;

    else
    {
      if(req->pstrblock_read_len >= 1)
      {
        signed int tmp_if_expr$1;
        if(!(req->pstrblock_read_len >= remains))
          tmp_if_expr$1 = req->pstrblock_read_len;

        else
          tmp_if_expr$1 = remains;
        readed = tmp_if_expr$1;
        memcpy((void *)(h->buf + (signed long int)h->bufused), (const void *)req->pstrblock_read, (unsigned long int)readed);
        h->bufused = h->bufused + readed;
        req->pstrblock_read = req->pstrblock_read + (signed long int)readed;
        req->pstrblock_read_len = req->pstrblock_read_len - readed;
      }

      if(!(h->bufused >= size))
        return 2;

      else
      {
        buf_end = h->buf + (signed long int)h->bufused;
        signed int return_value_strncmp$2;
        return_value_strncmp$2=strncmp(buf_end - (signed long int)4, "\r\n\r\n", (unsigned long int)4);
        if(return_value_strncmp$2 == 0)
        {
          h->bufused = h->bufused - 2;
          return 1;
        }

        else
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Error parsing encapsulated headers,no \\r\\n\\r\\n at the end of headers:%s!\n", buf_end);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Error parsing encapsulated headers,no \\r\\n\\r\\n at the end of headers:%s!\n", buf_end);

          }

          return -1;
        }
      }
    }
}

// client_parse_icap_header
// file request_common.c line 891
static signed int client_parse_icap_header(struct ci_request *req, struct ci_headers_list *h)
{
  signed int readed = 0;
  signed int eoh = 0;
  char *buf;
  char *end;
  if(!(req->pstrblock_read_len >= 4))
    return 2;

  else
  {
    end=strstr(req->pstrblock_read, "\r\n\r\n");
    if(!(end == ((char *)NULL)))
    {
      readed = (signed int)((end - req->pstrblock_read) + (signed long int)4);
      eoh = 1;
    }

    else
      readed = req->pstrblock_read_len - 3;
    signed int return_value_check_realloc$1;
    return_value_check_realloc$1=check_realloc(&h->buf, &h->bufsize, h->bufused, readed);
    if(!(return_value_check_realloc$1 == 1))
      return -1;

    else
    {
      buf = h->buf + (signed long int)h->bufused;
      memcpy((void *)buf, (const void *)req->pstrblock_read, (unsigned long int)readed);
      h->bufused = h->bufused + readed;
      req->pstrblock_read = req->pstrblock_read + (signed long int)readed;
      req->pstrblock_read_len = req->pstrblock_read_len - readed;
      if(eoh == 0)
        return 2;

      else
      {
        h->bufused = h->bufused - 2;
        return 1;
      }
    }
  }
}

// client_parse_incoming_data
// file request_common.c line 1082
static signed int client_parse_incoming_data(struct ci_request *req, void *data_dest, signed int (*dest_write)(void *, char *, signed int))
{
  signed int ret;
  signed int v1;
  signed int v2;
  signed int status;
  signed int bytes;
  signed int size;
  char *buf;
  const char *val;
  struct ci_headers_list *resp_heads;
  if(req->status == 0)
  {
    ret=client_parse_icap_header(req, req->response_header);
    if(!(ret == 1))
      return ret;

    sscanf(req->response_header->buf, "ICAP/%d.%d %d", &v1, &v2, &status);
    if(CI_DEBUG_LEVEL >= 3)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Response was with status:%d \n", status);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Response was with status:%d \n", status);

    }

    ci_headers_unpack(req->response_header);
    if(!(req->allow204 == 0))
    {
      if(status == 204)
      {
        req->status = 4;
        return 204;
      }

    }

    val=ci_headers_search(req->response_header, "Encapsulated");
    if(val == ((const char *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "No encapsulated entities!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("No encapsulated entities!\n");

      }

      return -1;
    }

    process_encapsulated(req, val);
    if(req->entities[0l] == ((struct ci_encaps_entity *)NULL))
      return -1;

    if(req->entities[1l] == ((struct ci_encaps_entity *)NULL))
    {
      req->status = 3;
      if(req->pstrblock_read_len == 0)
        return 2;

    }

    else
    {
      req->status = 1;
      size = req->entities[(signed long int)1]->start - req->entities[(signed long int)0]->start;
      resp_heads = (struct ci_headers_list *)req->entities[(signed long int)0]->entity;
      signed int return_value_ci_headers_setsize$1;
      return_value_ci_headers_setsize$1=ci_headers_setsize(resp_heads, size);
      if(return_value_ci_headers_setsize$1 == 0)
        return -1;

    }
  }

  if(req->status == 1)
  {
    size = req->entities[(signed long int)1]->start - req->entities[(signed long int)0]->start;
    resp_heads = (struct ci_headers_list *)req->entities[(signed long int)0]->entity;
    ret=client_parse_encaps_header(req, resp_heads, size);
    if(!(ret == 1))
      return ret;

    ci_headers_unpack(resp_heads);
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "OK reading headers, going to read body\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("OK reading headers, going to read body\n");

    }

    req->current_chunk_len = (unsigned int)0;
    req->chunk_bytes_read = (unsigned int)0;
    req->write_to_module_pending = (unsigned int)0;
    if(req->entities[1l]->type == 4)
    {
      req->status = 4;
      return 1;
    }

    req->status = 3;
    if(!(req->pstrblock_read_len == 0))
      goto __CPROVER_DUMP_L17;

    return 2;
  }

  else
  {

  __CPROVER_DUMP_L17:
    ;
    if(req->status == 3)
    {
      do
      {
        ret=parse_chunk_data(req, &buf);
        if(ret == -1)
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Error parsing chunks, current chunk len: %d, read: %d, readlen: %d, str: %s\n", req->current_chunk_len, req->chunk_bytes_read, req->pstrblock_read_len, req->pstrblock_read);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Error parsing chunks, current chunk len: %d, read: %d, readlen: %d, str: %s\n", req->current_chunk_len, req->chunk_bytes_read, req->pstrblock_read_len, req->pstrblock_read);

          }

          return -1;
        }

        if(req->write_to_module_pending >= 1u)
        {
          bytes=dest_write(data_dest, buf, (signed int)req->write_to_module_pending);
          if(!(bytes >= 0))
          {
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error writing to output file!\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error writing to output file!\n");

            }

            return -1;
          }

          req->write_to_module_pending = req->write_to_module_pending - (unsigned int)bytes;
        }

        if(ret == -2)
        {
          req->status = 4;
          return 1;
        }

      }
      while(!(ret == 2));
      return 2;
    }

    else
      return 1;
  }
}

// client_prepere_body_chunk
// file request_common.c line 1052
static signed int client_prepere_body_chunk(struct ci_request *req, void *data, signed int (*readdata)(void *, char *, signed int))
{
  signed int chunksize;
  signed int def_bytes;
  char *wbuf = (char *)(void *)0;
  char tmpbuf[30l];
  wbuf = req->wbuf + (signed long int)30;
  chunksize=readdata(data, wbuf, 4064);
  if(!(chunksize >= 1))
  {
    req->remain_send_block_bytes = 0;
    return chunksize;
  }

  else
  {
    wbuf = wbuf + (signed long int)chunksize;
    char *tmp_post$1 = wbuf;
    wbuf = wbuf + 1l;
    *tmp_post$1 = (char)13;
    *wbuf = (char)10;
    def_bytes=snprintf(tmpbuf, (unsigned long int)30, "%x\r\n", chunksize);
    wbuf = (req->wbuf + (signed long int)30) - (signed long int)def_bytes;
    memcpy((void *)wbuf, (const void *)tmpbuf, (unsigned long int)def_bytes);
    req->pstrblock_responce = wbuf;
    req->remain_send_block_bytes = def_bytes + chunksize + 2;
    return req->remain_send_block_bytes;
  }
}

// client_send_get_data
// file request_common.c line 1200
static signed int client_send_get_data(struct ci_request *req, signed int timeout, void *data_source, signed int (*source_read)(void *, char *, signed int), void *data_dest, signed int (*dest_write)(void *, char *, signed int))
{
  signed int io_ret;
  signed int read_status;
  signed int bytes;
  signed int io_action;
  signed int return_value_client_prepere_body_chunk$1;
  if(!(req->pstrblock_read_len == 0))
  {
    read_status=client_parse_incoming_data(req, data_dest, dest_write);
    if(read_status == -1)
      return -1;

    if(read_status == 204)
      return 204;

    if(!(req->status == 4))
      goto __CPROVER_DUMP_L3;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    if(data_source == NULL)
      req->eof_received = 1;

    if(req->eof_received == 0)
      io_action = 0x3;

    else
      io_action = 0x1;
    while(!(io_action == 0))
    {
      io_ret=ci_wait_for_data(req->connection->fd, timeout, io_action);
      if(io_ret == 0)
        break;

      if(!(io_ret >= 0))
        return -1;

      if(!((0x2 & io_ret) == 0))
      {
        if(req->remain_send_block_bytes == 0)
        {
          if(!(data_source == NULL))
          {
            return_value_client_prepere_body_chunk$1=client_prepere_body_chunk(req, data_source, source_read);
            if(!(return_value_client_prepere_body_chunk$1 >= 1))
            {
              req->eof_received = 1;
              req->pstrblock_responce = (char *)eof_str$link1;
              req->remain_send_block_bytes = 5;
            }

          }

        }

        bytes=ci_write_nonblock(req->connection->fd, (const void *)req->pstrblock_responce, (unsigned long int)req->remain_send_block_bytes);
        if(!(bytes >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)bytes;
        req->pstrblock_responce = req->pstrblock_responce + (signed long int)bytes;
        req->remain_send_block_bytes = req->remain_send_block_bytes - bytes;
      }

      _Bool tmp_if_expr$2;
      if(!(req->eof_received == 0))
        tmp_if_expr$2 = req->remain_send_block_bytes == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        io_action = 0;

      else
        io_action = 0x2;
      if(!((0x1 & io_ret) == 0))
      {
        signed int return_value_net_data_read$3;
        return_value_net_data_read$3=net_data_read(req);
        if(return_value_net_data_read$3 == -1)
          return -1;

        read_status=client_parse_incoming_data(req, data_dest, dest_write);
        if(read_status == -1)
          return -1;

        if(read_status == 204)
          return 204;

      }

      if(!(req->status == 4))
        io_action = io_action | 0x1;

    }
    return 1;
  }
}

// client_send_request_headers
// file request_common.c line 816
static signed int client_send_request_headers(struct ci_request *req, signed int has_eof, signed int timeout)
{
  struct ci_encaps_entity **elist;
  struct ci_encaps_entity *e;
  struct ci_headers_list *headers;
  signed int bytes;
  ci_request_pack(req);
  signed int return_value_ci_writen$1;
  return_value_ci_writen$1=ci_writen(req->connection->fd, req->request_header->buf, req->request_header->bufused, timeout);
  struct ci_encaps_entity **tmp_post$2;
  if(!(return_value_ci_writen$1 >= 0))
    return -1;

  else
  {
    req->bytes_out = req->bytes_out + (unsigned long int)req->request_header->bufused;
    elist = req->entities;
    do
    {
      tmp_post$2 = elist;
      elist = elist + 1l;
      e = *tmp_post$2;
      if(e == ((struct ci_encaps_entity *)NULL))
        break;

      _Bool tmp_if_expr$4;
      if(e->type == 0)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = e->type == 1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$4)
      {
        headers = (struct ci_headers_list *)e->entity;
        signed int return_value_ci_writen$3;
        return_value_ci_writen$3=ci_writen(req->connection->fd, headers->buf, headers->bufused, timeout);
        if(!(return_value_ci_writen$3 >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)headers->bufused;
      }

    }
    while((_Bool)1);
    _Bool tmp_if_expr$10;
    if(req->preview >= 1)
      tmp_if_expr$10 = req->preview_data.used > 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$10 = (_Bool)0;
    if(tmp_if_expr$10)
    {
      bytes=sprintf(req->wbuf, "%x\r\n", req->preview);
      signed int return_value_ci_writen$5;
      return_value_ci_writen$5=ci_writen(req->connection->fd, req->wbuf, bytes, timeout);
      if(!(return_value_ci_writen$5 >= 0))
        return -1;

      req->bytes_out = req->bytes_out + (unsigned long int)bytes;
      signed int return_value_ci_writen$6;
      return_value_ci_writen$6=ci_writen(req->connection->fd, req->preview_data.buf, req->preview, timeout);
      if(!(return_value_ci_writen$6 >= 0))
        return -1;

      req->bytes_out = req->bytes_out + (unsigned long int)req->preview;
      if(!(has_eof == 0))
      {
        signed int return_value_ci_writen$7;
        return_value_ci_writen$7=ci_writen(req->connection->fd, "\r\n0; ieof\r\n\r\n", 13, timeout);
        if(!(return_value_ci_writen$7 >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)13;
        req->eof_received = 1;
      }

      else
      {
        signed int return_value_ci_writen$8;
        return_value_ci_writen$8=ci_writen(req->connection->fd, "\r\n0\r\n\r\n", 7, timeout);
        if(!(return_value_ci_writen$8 >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)7;
      }
    }

    else
      if(req->preview == 0)
      {
        signed int return_value_ci_writen$9;
        return_value_ci_writen$9=ci_writen(req->connection->fd, "0\r\n\r\n", 5, timeout);
        if(!(return_value_ci_writen$9 >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)5;
      }

    return 1;
  }
}

// commands_exec_scheduled
// file commands.c line 252
void commands_exec_scheduled()
{
  signed long int tm;
  if(CI_DEBUG_LEVEL >= 10)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Going to execute child commands\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Going to execute child commands\n");

  }

  if(COMMANDS_LIST == ((struct ci_list *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 10)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "None command registered\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("None command registered\n");

    }

  }

  if(!(COMMANDS_QUEUE == ((struct ci_list *)NULL)))
  {
    time(&tm);
    ci_list_iterate(COMMANDS_QUEUE, (void *)&tm, cb_check_queue);
  }

}

// commands_execute_start_child
// file commands.c line 188
signed int commands_execute_start_child()
{
  signed int return_value_execute_child_commands$1;
  return_value_execute_child_commands$1=execute_child_commands(8);
  return return_value_execute_child_commands$1;
}

// commands_execute_stop_child
// file commands.c line 193
signed int commands_execute_stop_child()
{
  signed int return_value_execute_child_commands$1;
  return_value_execute_child_commands$1=execute_child_commands(16);
  return return_value_execute_child_commands$1;
}

// commands_init
// file include/commands.h line 66
void commands_init()
{
  ci_thread_mutex_init(&COMMANDS_MTX);
  COMMANDS_LIST=ci_list_create((unsigned long int)64, sizeof(struct ci_command) /*152ul*/ );
  COMMANDS_QUEUE=ci_list_create((unsigned long int)64, sizeof(struct schedule_data) /*144ul*/ );
}

// commands_reset
// file include/commands.h line 67
void commands_reset()
{
  if(!(COMMANDS_QUEUE == ((struct ci_list *)NULL)))
  {
    ci_list_destroy(COMMANDS_QUEUE);
    COMMANDS_QUEUE=ci_list_create((unsigned long int)64, sizeof(struct schedule_data) /*144ul*/ );
  }

  if(!(COMMANDS_LIST == ((struct ci_list *)NULL)))
  {
    ci_list_destroy(COMMANDS_LIST);
    COMMANDS_LIST=ci_list_create((unsigned long int)64, sizeof(struct ci_command) /*152ul*/ );
  }

}

// common_mutex_destroy
// file cache.c line 114
signed int common_mutex_destroy(struct common_mutex *mtx)
{
  if(!(mtx->isproc == 0))
    return 0;

  else
  {
    signed int return_value_ci_thread_mutex_destroy$1;
    return_value_ci_thread_mutex_destroy$1=ci_thread_mutex_destroy(&mtx->mtx.thread_mutex);
    return return_value_ci_thread_mutex_destroy$1;
  }
}

// common_mutex_init
// file cache.c line 105
signed int common_mutex_init(struct common_mutex *mtx, signed int proc_mtx)
{
  if(!(proc_mtx == 0))
    return 0;

  else
  {
    mtx->isproc = 0;
    signed int return_value_ci_thread_mutex_init$1;
    return_value_ci_thread_mutex_init$1=ci_thread_mutex_init(&mtx->mtx.thread_mutex);
    return return_value_ci_thread_mutex_init$1;
  }
}

// common_mutex_lock
// file cache.c line 121
signed int common_mutex_lock(struct common_mutex *mtx)
{
  if(!(mtx->isproc == 0))
    return 0;

  else
  {
    signed int return_value_pthread_mutex_lock$1;
    return_value_pthread_mutex_lock$1=pthread_mutex_lock(&mtx->mtx.thread_mutex);
    return return_value_pthread_mutex_lock$1;
  }
}

// common_mutex_unlock
// file cache.c line 128
signed int common_mutex_unlock(struct common_mutex *mtx)
{
  if(!(mtx->isproc == 0))
    return 0;

  else
  {
    signed int return_value_pthread_mutex_unlock$1;
    return_value_pthread_mutex_unlock$1=pthread_mutex_unlock(&mtx->mtx.thread_mutex);
    return return_value_pthread_mutex_unlock$1;
  }
}

// compute_my_hostname
// file aserver.c line 58
void compute_my_hostname()
{
  char hostname[64l];
  struct hostent *hent;
  signed int ret;
  ret=gethostname(hostname, (unsigned long int)63);
  if(ret == 0)
  {
    hostname[(signed long int)63] = (char)0;
    hent=gethostbyname(hostname);
    if(!(hent == ((struct hostent *)NULL)))
    {
      strncpy(MY_HOSTNAME, hent->h_name, (unsigned long int)256);
      MY_HOSTNAME[(signed long int)256] = (char)0;
    }

    else
      strcpy(MY_HOSTNAME, hostname);
  }

  else
    strcpy(MY_HOSTNAME, "localhost");
}

// config
// file include/cfg_param.h line 138
signed int config(signed int argc, char **argv)
{
  ARGC = argc;
  ARGV = argv;
  ci_cfg_lib_init();
  signed int return_value_ci_args_apply$1;
  return_value_ci_args_apply$1=ci_args_apply(argc, argv, options);
  if(return_value_ci_args_apply$1 == 0)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error in command line options\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error in command line options\n");

    }

    ci_args_usage(argv[(signed long int)0], options);
    exit(-1);
  }

  signed int return_value_parse_file$2;
  return_value_parse_file$2=parse_file(CI_CONF.cfg_file);
  if(return_value_parse_file$2 == 0)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error opening/parsing config file\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error opening/parsing config file\n");

    }

    exit(0);
  }

  return 1;
}

// create_childs_queue
// file proc_threads_queues.c line 119
signed int create_childs_queue(struct childs_queue *q, signed int size)
{
  signed int ret;
  signed int i;
  struct stat_memblock *mem_block;
  q->stats_block_size=ci_stat_memblock_size();
  q->shared_mem_size = (signed int)(sizeof(struct child_shared_data) /*56ul*/  * (unsigned long int)size + (unsigned long int)(q->stats_block_size * size) + (unsigned long int)q->stats_block_size + sizeof(struct server_statistics) /*12ul*/ );
  void *return_value_ci_shared_mem_create$1;
  return_value_ci_shared_mem_create$1=ci_shared_mem_create(&q->shmid, "kids-queue", q->shared_mem_size);
  q->childs = (struct child_shared_data *)return_value_ci_shared_mem_create$1;
  if(q->childs == ((struct child_shared_data *)NULL))
  {
    log_server((struct ci_request *)(void *)0, "can't get shared memory!");
    return 0;
  }

  else
  {
    q->size = size;
    q->stats_area = (void *)q->childs + (signed long int)(sizeof(struct child_shared_data) /*56ul*/  * (unsigned long int)q->size);
    i = 0;
    for( ; !(i >= q->size); i = i + 1)
    {
      mem_block = (struct stat_memblock *)(q->stats_area + (signed long int)(i * q->stats_block_size));
      mem_block->sig = (unsigned int)0xFAFA;
    }
    q->stats_history = (struct stat_memblock *)(q->stats_area + (signed long int)(q->size * q->stats_block_size));
    q->stats_history->sig = (unsigned int)0xFAFA;
    q->srv_stats = (struct server_statistics *)(q->stats_area + (signed long int)(q->size * q->stats_block_size) + (signed long int)q->stats_block_size);
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Create shared mem, qsize=%d stat_block_size=%d childshared data:%d\n", q->size, q->stats_block_size, (signed int)sizeof(struct child_shared_data) /*56ul*/  * q->size);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Create shared mem, qsize=%d stat_block_size=%d childshared data:%d\n", q->size, q->stats_block_size, (signed int)sizeof(struct child_shared_data) /*56ul*/  * q->size);

    }

    stat_memblock_fix(q->stats_history);
    ci_stat_memblock_reset(q->stats_history);
    i = 0;
    for( ; !(i >= q->size); i = i + 1)
    {
      (q->childs + (signed long int)i)->pid = 0;
      (q->childs + (signed long int)i)->pipe = -1;
    }
    q->srv_stats->started_childs = (unsigned int)0;
    q->srv_stats->closed_childs = (unsigned int)0;
    q->srv_stats->crashed_childs = (unsigned int)0;
    ret=ci_proc_mutex_init(&q->queue_mtx, "children-queue");
    if(ret == 0)
    {
      ci_shared_mem_destroy(&q->shmid);
      log_server((struct ci_request *)(void *)0, "can't create children queue semaphore!");
      return 0;
    }

    else
      return 1;
  }
}

// create_service
// file service.c line 264
struct ci_service_module * create_service(const char *service_file)
{
  char *extension;
  struct service_handler_module *service_handler;
  extension=strrchr(service_file, 46);
  service_handler=find_servicehandler_by_ext(extension);
  if(service_handler == ((struct service_handler_module *)NULL))
    return (struct ci_service_module *)(void *)0;

  else
  {
    struct ci_service_module *return_value;
    return_value=service_handler->create_service(service_file);
    return return_value;
  }
}

// create_service_conf_table
// file service.c line 220
struct ci_conf_entry * create_service_conf_table(struct ci_service_xdata *srv_xdata, struct ci_conf_entry *user_table)
{
  signed int i;
  signed int k;
  signed int size;
  struct ci_conf_entry *table;
  i = 0;
  for( ; !(services_global_conf_table[(signed long int)i].name == ((const char *)NULL)); i = i + 1)
    ;
  size = i;
  if(!(user_table == ((struct ci_conf_entry *)NULL)))
  {
    i = 0;
    for( ; !((user_table + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
      ;
    size = size + i;
  }

  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(size + 1) * sizeof(struct ci_conf_entry) /*32ul*/ );
  table = (struct ci_conf_entry *)return_value_malloc$1;
  if(table == ((struct ci_conf_entry *)NULL))
    return (struct ci_conf_entry *)(void *)0;

  else
  {
    i = 0;
    for( ; !(services_global_conf_table[(signed long int)i].name == ((const char *)NULL)); i = i + 1)
    {
      (table + (signed long int)i)->name = services_global_conf_table[(signed long int)i].name;
      (table + (signed long int)i)->data = (void *)srv_xdata;
      (table + (signed long int)i)->action = services_global_conf_table[(signed long int)i].action;
      (table + (signed long int)i)->msg = services_global_conf_table[(signed long int)i].msg;
    }
    k = i;
    if(!(user_table == ((struct ci_conf_entry *)NULL)))
    {
      i = 0;
      for( ; !((user_table + (signed long int)i)->name == ((const char *)NULL)); k = k + 1)
      {
        (table + (signed long int)k)->name = (user_table + (signed long int)i)->name;
        (table + (signed long int)k)->data = (user_table + (signed long int)i)->data;
        (table + (signed long int)k)->action = (user_table + (signed long int)i)->action;
        (table + (signed long int)k)->msg = (user_table + (signed long int)i)->msg;
        i = i + 1;
      }
    }

    (table + (signed long int)k)->name = (const char *)(void *)0;
    (table + (signed long int)k)->data = (void *)0;
    (table + (signed long int)k)->action = (signed int (*)(const char *, const char **, void *))(void *)0;
    (table + (signed long int)k)->msg = (const char *)(void *)0;
    return table;
  }
}

// datatype_cmp
// file types_ops.c line 330
signed int datatype_cmp(const void *key1, const void *key2)
{
  unsigned int type = *((unsigned int *)key1);
  if(key2 == NULL)
    return -1;

  else
    if((0xFFFF0000 & type) == 0u)
      return (signed int)(*((unsigned int *)key1) - *((unsigned int *)key2));

    else
    {
      type = type >> 16;
      signed int return_value_ci_magic_group_check$1;
      return_value_ci_magic_group_check$1=ci_magic_group_check((signed int)*((unsigned int *)key2), (signed int)type);
      if(!(return_value_ci_magic_group_check$1 == 0))
        return 0;

      else
        return 1;
    }
}

// datatype_dup
// file types_ops.c line 311
void * datatype_dup(const char *str, struct ci_mem_allocator *allocator)
{
  signed int type;
  unsigned int *val;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(unsigned int) /*4ul*/ );
  val = (unsigned int *)return_value;
  type=ci_magic_type_id(str);
  if(type >= 0)
    *val = (unsigned int)type;

  else
  {
    type=ci_magic_group_id(str);
    if(type >= 0)
    {
      *val = (unsigned int)type;
      *val = *val << 16;
    }

    else
    {
      allocator->free(allocator, (void *)val);
      val = (unsigned int *)(void *)0;
    }
  }
  return (void *)val;
}

// datatype_equal
// file types_ops.c line 348
signed int datatype_equal(const void *key1, const void *key2)
{
  unsigned int type = *((unsigned int *)key1);
  if(key2 == NULL)
    return 0;

  else
    if((0xFFFF0000 & type) == 0u)
      return (signed int)(*((unsigned int *)key1) == *((unsigned int *)key2));

    else
    {
      type = type >> 16;
      signed int return_value_ci_magic_group_check$1;
      return_value_ci_magic_group_check$1=ci_magic_group_check((signed int)*((unsigned int *)key2), (signed int)type);
      if(!(return_value_ci_magic_group_check$1 == 0))
        return 1;

      else
        return 0;
    }
}

// datatype_free
// file types_ops.c line 371
void datatype_free(void *key, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, key);
}

// datatype_len
// file types_ops.c line 366
unsigned long int datatype_len(const void *key)
{
  return sizeof(unsigned int) /*4ul*/ ;
}

// default_acl_client_match
// file default_acl.c line 86
signed int default_acl_client_match(struct ci_request *req)
{
  signed int return_value_ci_access_entry_match_request$1;
  return_value_ci_access_entry_match_request$1=ci_access_entry_match_request(acl_connection_access_list, req);
  return return_value_ci_access_entry_match_request$1;
}

// default_acl_init
// file default_acl.c line 67
signed int default_acl_init(struct ci_server_conf *server_conf)
{
  return 1;
}

// default_acl_post_init
// file default_acl.c line 73
signed int default_acl_post_init(struct ci_server_conf *server_conf)
{
  return 1;
}

// default_acl_release
// file default_acl.c line 78
void default_acl_release()
{
  ci_access_entry_release(acl_access_list);
  ci_access_entry_release(acl_connection_access_list);
  acl_access_list = (struct ci_access_entry *)(void *)0;
  acl_connection_access_list = (struct ci_access_entry *)(void *)0;
}

// default_acl_request_match
// file default_acl.c line 91
signed int default_acl_request_match(struct ci_request *req)
{
  signed int return_value_ci_access_entry_match_request$1;
  return_value_ci_access_entry_match_request$1=ci_access_entry_match_request(acl_access_list, req);
  return return_value_ci_access_entry_match_request$1;
}

// default_cmp
// file array.c line 680
static signed int default_cmp(const void *obj1, const void *obj2, unsigned long int size)
{
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp(obj1, obj2, size);
  return return_value_memcmp$1;
}

// del_mutex
// file os/unix/threads.c line 105
static void del_mutex(void *pmutex)
{
  struct mutex_itm *m;
  struct mutex_itm *p = (struct mutex_itm *)(void *)0;
  pthread_mutex_lock(&mutexes_lock);
  m = mutexes;
  for( ; !(m == ((struct mutex_itm *)NULL)); m = m->next)
  {
    if(m->mtx.mutex == (union anonymous$3 *)pmutex)
    {
      if(p == ((struct mutex_itm *)NULL))
        mutexes = mutexes->next;

      else
        p->next = m->next;
      free((void *)m);
      pthread_mutex_unlock(&mutexes_lock);
      goto __CPROVER_DUMP_L6;
    }

    p = m;
  }
  pthread_mutex_unlock(&mutexes_lock);

__CPROVER_DUMP_L6:
  ;
}

// destroy_childs_queue
// file proc_threads_queues.c line 202
signed int destroy_childs_queue(struct childs_queue *q)
{
  ci_proc_mutex_lock(&q->queue_mtx);
  signed int return_value_ci_shared_mem_destroy$1;
  return_value_ci_shared_mem_destroy$1=ci_shared_mem_destroy(&q->shmid);
  if(return_value_ci_shared_mem_destroy$1 == 0)
  {
    log_server((struct ci_request *)(void *)0, "can't destroy shared memory!");
    ci_proc_mutex_unlock(&q->queue_mtx);
    return 0;
  }

  else
  {
    q->childs = (struct child_shared_data *)(void *)0;
    ci_proc_mutex_unlock(&q->queue_mtx);
    ci_proc_mutex_destroy(&q->queue_mtx);
    return 1;
  }
}

// destroy_encaps_entity
// file header.c line 563
void destroy_encaps_entity(struct ci_encaps_entity *e)
{
  _Bool tmp_if_expr$1;
  if(e->type == 0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = e->type == 1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    ci_headers_destroy((struct ci_headers_list *)e->entity);

  else
    free(e->entity);
  free((void *)e);
}

// destroy_queue
// file proc_threads_queues.c line 60
void destroy_queue(struct connections_queue *q)
{
  ci_thread_mutex_destroy(&q->queue_mtx);
  ci_thread_cond_destroy(&q->queue_cond);
  free((void *)q->connections);
  free((void *)q);
}

// dettach_childs_queue
// file proc_threads_queues.c line 187
signed int dettach_childs_queue(struct childs_queue *q)
{
  ci_proc_mutex_lock(&q->queue_mtx);
  signed int return_value_ci_shared_mem_detach$1;
  return_value_ci_shared_mem_detach$1=ci_shared_mem_detach(&q->shmid);
  if(return_value_ci_shared_mem_detach$1 == 0)
  {
    log_server((struct ci_request *)(void *)0, "can't dettach shared memory!");
    ci_proc_mutex_unlock(&q->queue_mtx);
    return 0;
  }

  else
  {
    q->childs = (struct child_shared_data *)(void *)0;
    ci_proc_mutex_unlock(&q->queue_mtx);
    return 1;
  }
}

// do_close
// file body.c line 318
void do_close(signed int fd)
{
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  signed int return_value_close$2;
  signed int *return_value___errno_location$3;
  do
  {
    return_value_close$2=close(fd);
    if(return_value_close$2 >= 0)
      break;

    return_value___errno_location$3=__errno_location();
    if(!(*return_value___errno_location$3 == 4))
      break;

  }
  while((_Bool)1);
}

// do_end_of_data
// file request.c line 1433
static signed int do_end_of_data(struct ci_request *req)
{
  signed int res;
  if(req->current_service_mod->mod_end_of_data_handler == ((signed int (*)(struct ci_request *))NULL))
    return 1;

  else
  {
    res=req->current_service_mod->mod_end_of_data_handler(req);
    if(res == 204)
    {
      if(!(req->allow204 == 0))
      {
        if(req->status == 0)
        {
          signed int return_value_ec_responce$1;
          return_value_ec_responce$1=ec_responce(req, 2);
          if(!(return_value_ec_responce$1 >= 0))
          {
            if(CI_DEBUG_LEVEL >= 5)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "An error occured while sending allow 204 response\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("An error occured while sending allow 204 response\n");

            }

            return -1;
          }

          return 1;
        }

      }

    }

    if(res == 206)
    {
      req->return_code = 3;
      return 1;
    }

    else
      if(!(res == 1))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "An error occured in end-of-data handler !return code : %d, req->allow204=%d, req->allow206=%d\n", res, req->allow204, req->allow206);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("An error occured in end-of-data handler !return code : %d, req->allow204=%d, req->allow206=%d\n", res, req->allow204, req->allow206);

        }

        if(req->status == 0)
        {
          req->keepalive = 0;
          ec_responce(req, 11);
        }

        return -1;
      }

      else
        return 1;
  }
}

// do_fake_preview
// file request.c line 1369
static signed int do_fake_preview(struct ci_request *req)
{
  signed int res;
  if(req->current_service_mod->mod_check_preview_handler == ((signed int (*)(char *, signed int, struct ci_request *))NULL))
    return 1;

  else
  {
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Preview does not supported. Call the preview handler with no preview data.\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Preview does not supported. Call the preview handler with no preview data.\n");

    }

    res=req->current_service_mod->mod_check_preview_handler((char *)(void *)0, 0, req);
    if(res == 204)
    {
      if(!(req->allow204 == 0))
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Preview handler return allow 204 response, and allow204 outside preview supported\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Preview handler return allow 204 response, and allow204 outside preview supported\n");

        }

        signed int return_value_ec_responce$1;
        return_value_ec_responce$1=ec_responce(req, 2);
        if(!(return_value_ec_responce$1 >= 0))
        {
          req->keepalive = 0;
          return -1;
        }

        if(!(req->hasbody == 0))
          res=get_send_body(req, 1);

        return 1;
      }

    }

    if(res == 204)
    {
      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Preview handler return allow 204 response, and allow204 outside preview does NOT supported\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Preview handler return allow 204 response, and allow204 outside preview does NOT supported\n");

      }

      return 1;
    }

    else
      if(res == 206)
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Preview handler return allow 204 response, allow204 outside preview and allow206 supported by t");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Preview handler return allow 204 response, allow204 outside preview and allow206 supported by t");

        }

        req->return_code = 3;
        return 1;
      }

      else
        if(res == 100)
          return 1;

        else
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "An error occured in preview handler (outside preview)! return code: %d, req->allow204=%d, req->allow206=%d\n", res, req->allow204, req->allow206);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("An error occured in preview handler (outside preview)! return code: %d, req->allow204=%d, req->allow206=%d\n", res, req->allow204, req->allow206);

          }

          req->keepalive = 0;
          ec_responce(req, 11);
          return -1;
        }
  }
}

// do_open
// file body.c line 308
signed int do_open(const char *pathname, signed int flags)
{
  signed int fd;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  do
  {
    fd=open64(pathname, flags, 0400 | 0200 | 0400 >> 3 | (0400 >> 3) >> 3);
    if(!(fd >= 0))
    {
      return_value___errno_location$2=__errno_location();
      tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
  }
  while(tmp_if_expr$3);
  return fd;
}

// do_read
// file body.c line 292
signed int do_read(signed int fd, void *buf, unsigned long int count)
{
  signed int bytes;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  do
  {
    signed long int return_value_read$4;
    return_value_read$4=read(fd, buf, count);
    bytes = (signed int)return_value_read$4;
    if(!(bytes >= 0))
    {
      return_value___errno_location$2=__errno_location();
      tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
  }
  while(tmp_if_expr$3);
  return bytes;
}

// do_request
// file request.c line 1475
static signed int do_request(struct ci_request *req)
{
  struct ci_service_xdata *srv_xdata = (struct ci_service_xdata *)(void *)0;
  signed int res;
  signed int preview_status = 0;
  signed int auth_status = 1;
  signed int ret_status = 1;
  res=parse_header(req);
  if(!(res == 0))
  {
    req->return_code = res;
    req->keepalive = 0;
    if(res >= 1)
    {
      if(req->request_header->bufused >= 1)
        ec_responce(req, res);

    }

    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error %d while parsing headers :(%d)\n", res, req->request_header->bufused);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error %d while parsing headers :(%d)\n", res, req->request_header->bufused);

    }

    return -1;
  }

  else
  {
    /* assertion req->current_service_mod */
    assert(req->current_service_mod != ((struct ci_service_module *)NULL));
    srv_xdata=service_data(req->current_service_mod);
    _Bool tmp_if_expr$1;
    if(srv_xdata == ((struct ci_service_xdata *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = srv_xdata->status != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Service %s not initialized\n", req->current_service_mod->mod_name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Service %s not initialized\n", req->current_service_mod->mod_name);

      }

      req->keepalive = 0;
      ec_responce(req, 11);
      return -1;
    }

    else
    {
      auth_status = req->access_type;
      auth_status=access_check_request(req);
      if(auth_status == -1)
      {
        req->keepalive = 0;
        if(!(req->auth_required == 0))
          ec_responce(req, 9);

        else
          ec_responce(req, 6);
        return -1;
      }

      else
        if(res == 0)
        {
          res=parse_encaps_headers(req);
          if(res == 0)
            goto __CPROVER_DUMP_L13;

          req->keepalive = 0;
          ec_responce(req, 4);
          return -1;
        }

        else
        {

        __CPROVER_DUMP_L13:
          ;
          if(!(req->current_service_mod->mod_init_request_data == ((void * (*)(struct ci_request *))NULL)))
            req->service_data=req->current_service_mod->mod_init_request_data(req);

          else
            req->service_data = (void *)0;
          if(CI_DEBUG_LEVEL >= 8)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Requested service: %s\n", req->current_service_mod->mod_name);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Requested service: %s\n", req->current_service_mod->mod_name);

          }

          switch(req->type)
          {
            case 0x01:
            {
              options_responce(req);
              ret_status = 1;
              break;
            }
            case 0x02:

            case 0x04:
            {
              preview_status = 0;
              if(req->preview >= 0)
                preview_status=do_request_preview(req);

              else
              {
                preview_status=do_fake_preview(req);
                if(preview_status == 1)
                {
                  if(!(req->hasbody == 0))
                    req->return_code = 0;

                  else
                    req->return_code = 1;
                }

              }
              if(preview_status == -1)
              {
                ret_status = -1;
                break;
              }

              else
                if(preview_status == -2)
                  req->return_code = 1;

              if(req->return_code == 2)
                break;

              else
                if(!(req->return_code == 0))
                {
                  if(!(req->return_code == 1))
                  {
                    if(!(req->return_code == 3))
                    {
                      ec_responce(req, 11);
                      ret_status = -1;
                      break;
                    }

                  }

                }

              if(req->return_code == 0)
              {
                if(!(req->hasbody == 0))
                {
                  if(!(preview_status == -2))
                  {
                    req->return_code = 1;
                    if(CI_DEBUG_LEVEL >= 9)
                    {
                      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                        __log_error((void *)0, "Going to get/send body data.....\n");

                      if(!(CI_DEBUG_STDOUT == 0))
                        printf("Going to get/send body data.....\n");

                    }

                    ret_status=get_send_body(req, 0);
                    if(ret_status == -1)
                    {
                      req->keepalive = 0;
                      if(CI_DEBUG_LEVEL >= 5)
                      {
                        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                          __log_error((void *)0, "An error occured. Parse error or the client closed the connection (res:%d, preview status:%d)\n", ret_status, preview_status);

                        if(!(CI_DEBUG_STDOUT == 0))
                          printf("An error occured. Parse error or the client closed the connection (res:%d, preview status:%d)\n", ret_status, preview_status);

                      }

                      break;
                    }

                  }

                }

              }

              ret_status=do_end_of_data(req);
              if(ret_status == -1)
              {
                req->keepalive = 0;
                break;
              }

              if(req->return_code == 2)
                break;

              req->data_locked = 0;
              ret_status=send_remaining_response(req);
              if(ret_status == -1)
              {
                req->keepalive = 0;
                if(CI_DEBUG_LEVEL >= 5)
                {
                  if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                    __log_error((void *)0, "Error while sending rest responce or client closed the connection\n");

                  if(!(CI_DEBUG_STDOUT == 0))
                    printf("Error while sending rest responce or client closed the connection\n");

                }

              }

              break;
            }
            default:
            {
              req->keepalive = 0;
              ret_status = -1;
            }
          }
          if(!(req->current_service_mod->mod_release_request_data == ((void (*)(void *))NULL)))
          {
            if(!(req->service_data == NULL))
              req->current_service_mod->mod_release_request_data(req->service_data);

          }

          return ret_status;
        }
    }
  }
}

// do_request_preview
// file request.c line 1296
static signed int do_request_preview(struct ci_request *req)
{
  signed int preview_read_status;
  signed int res;
  if(CI_DEBUG_LEVEL >= 8)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Read preview data if there are and process request\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Read preview data if there are and process request\n");

  }

  if(req->hasbody == 0)
    preview_read_status = -2;

  else
  {
    preview_read_status=read_preview_data(req);
    if(preview_read_status == -1)
    {
      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "An error occured while reading preview data (propably timeout)\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("An error occured while reading preview data (propably timeout)\n");

      }

      req->keepalive = 0;
      ec_responce(req, 10);
      return -1;
    }

  }
  if(req->current_service_mod->mod_check_preview_handler == ((signed int (*)(char *, signed int, struct ci_request *))NULL))
  {
    if(CI_DEBUG_LEVEL >= 3)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Preview request but no preview data handler. Respond with \"100 Continue\"\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Preview request but no preview data handler. Respond with \"100 Continue\"\n");

    }

    res = 100;
  }

  else
    res=req->current_service_mod->mod_check_preview_handler(req->preview_data.buf, req->preview_data.used, req);
  if(res == 204)
  {
    signed int return_value_ec_responce$1;
    return_value_ec_responce$1=ec_responce(req, 2);
    if(!(return_value_ec_responce$1 >= 0))
    {
      req->keepalive = 0;
      return -1;
    }

    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Preview handler return allow 204 response\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Preview handler return allow 204 response\n");

    }

    return 1;
  }

  if(res == 206)
  {
    if(req->allow206 == 0)
      goto __CPROVER_DUMP_L17;

    req->return_code = 3;
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Preview handler return 206 response\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Preview handler return 206 response\n");

    }

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L17:
    ;
    if(!(res == 100))
    {
      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "An error occured in preview handler! return code: %d , req->allow204=%d, req->allow206=%d\n", res, req->allow204, req->allow206);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("An error occured in preview handler! return code: %d , req->allow204=%d, req->allow206=%d\n", res, req->allow204, req->allow206);

      }

      req->keepalive = 0;
      ec_responce(req, 11);
      return -1;
    }

    else
    {
      if(!(preview_read_status == -2))
        ec_responce_simple(req, 0);

      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Preview handler %s\n", preview_read_status == -2 ? "receives all body data" : "continue reading more body data");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Preview handler %s\n", preview_read_status == -2 ? "receives all body data" : "continue reading more body data");

      }

      return preview_read_status;
    }
  }
}

// do_write
// file body.c line 282
signed int do_write(signed int fd, const void *buf, unsigned long int count)
{
  signed int bytes;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  do
  {
    signed long int return_value_write$4;
    return_value_write$4=write(fd, buf, count);
    bytes = (signed int)return_value_write$4;
    if(!(bytes >= 0))
    {
      return_value___errno_location$2=__errno_location();
      tmp_if_expr$3 = *return_value___errno_location$2 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$3 = (_Bool)0;
  }
  while(tmp_if_expr$3);
  return bytes;
}

// dump_queue_statistics
// file proc_threads_queues.c line 402
void dump_queue_statistics(struct childs_queue *q)
{
  signed int i;
  signed int k;
  signed int childs = 0;
  signed int freeservers = 0;
  signed int used = 0;
  signed int requests = 0;
  struct stat_memblock *child_stats;
  struct stat_memblock copy_stats;
  if(!(q->childs == ((struct child_shared_data *)NULL)))
  {
    i = 0;
    for( ; !(i >= q->size); i = i + 1)
      if(!((q->childs + (signed long int)i)->pid == 0))
      {
        if((q->childs + (signed long int)i)->to_be_killed == 0)
        {
          childs = childs + 1;
          freeservers = freeservers + (q->childs + (signed long int)i)->freeservers;
          used = used + (q->childs + (signed long int)i)->usedservers;
          requests = requests + (q->childs + (signed long int)i)->requests;
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "\nChild pid:%d\tFree Servers:%d\tUsed Servers:%d\tRequests:%d\n", (q->childs + (signed long int)i)->pid, (q->childs + (signed long int)i)->freeservers, (q->childs + (signed long int)i)->usedservers, (q->childs + (signed long int)i)->requests);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("\nChild pid:%d\tFree Servers:%d\tUsed Servers:%d\tRequests:%d\n", (q->childs + (signed long int)i)->pid, (q->childs + (signed long int)i)->freeservers, (q->childs + (signed long int)i)->usedservers, (q->childs + (signed long int)i)->requests);

          }

          child_stats = (struct stat_memblock *)(q->stats_area + (signed long int)(i * q->stats_block_size));
          copy_stats.counters64_size = child_stats->counters64_size;
          copy_stats.counterskbs_size = child_stats->counterskbs_size;
          copy_stats.counters64 = (unsigned long int *)((void *)child_stats + (signed long int)sizeof(struct stat_memblock) /*32ul*/ );
          copy_stats.counterskbs = (struct kbs *)((void *)child_stats + (signed long int)sizeof(struct stat_memblock) /*32ul*/  + (signed long int)((unsigned long int)child_stats->counters64_size * sizeof(unsigned long int) /*8ul*/ ));
          k = 0;
          for( ; !(k >= STAT_INT64.entries_num) && !(k >= copy_stats.counters64_size); k = k + 1)
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "\t%s:%llu\n", (STAT_INT64.entries + (signed long int)k)->label, (unsigned long long int)copy_stats.counters64[(signed long int)k]);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("\t%s:%llu\n", (STAT_INT64.entries + (signed long int)k)->label, (unsigned long long int)copy_stats.counters64[(signed long int)k]);

            }

          k = 0;
          for( ; !(k >= STAT_KBS.entries_num) && !(k >= copy_stats.counterskbs_size); k = k + 1)
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "\t%s:%llu kbytes and %d bytes\n", (STAT_KBS.entries + (signed long int)k)->label, (unsigned long long int)(copy_stats.counterskbs + (signed long int)k)->kb, (copy_stats.counterskbs + (signed long int)k)->bytes);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("\t%s:%llu kbytes and %d bytes\n", (STAT_KBS.entries + (signed long int)k)->label, (unsigned long long int)(copy_stats.counterskbs + (signed long int)k)->kb, (copy_stats.counterskbs + (signed long int)k)->bytes);

            }

        }

      }

    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "\nChildren:%d\tFree Servers:%d\tUsed Servers:%d\tRequests:%d\n", childs, freeservers, used, requests);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("\nChildren:%d\tFree Servers:%d\tUsed Servers:%d\tRequests:%d\n", childs, freeservers, used, requests);

    }

    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "\nHistory\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("\nHistory\n");

    }

    k = 0;
    for( ; !(k >= q->stats_history->counters64_size) && !(k >= STAT_INT64.entries_num); k = k + 1)
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "\t%s:%llu\n", (STAT_INT64.entries + (signed long int)k)->label, (unsigned long long int)q->stats_history->counters64[(signed long int)k]);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("\t%s:%llu\n", (STAT_INT64.entries + (signed long int)k)->label, (unsigned long long int)q->stats_history->counters64[(signed long int)k]);

      }

    k = 0;
    for( ; !(k >= q->stats_history->counterskbs_size) && !(k >= STAT_KBS.entries_num); k = k + 1)
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "\t%s:%llu kbytes  and %d bytes\n", (STAT_KBS.entries + (signed long int)k)->label, (unsigned long long int)(q->stats_history->counterskbs + (signed long int)k)->kb, (q->stats_history->counterskbs + (signed long int)k)->bytes);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("\t%s:%llu kbytes  and %d bytes\n", (STAT_KBS.entries + (signed long int)k)->label, (unsigned long long int)(q->stats_history->counterskbs + (signed long int)k)->kb, (q->stats_history->counterskbs + (signed long int)k)->bytes);

      }

  }

}

// dump_statistics_command
// file mpmt_server.c line 1006
void dump_statistics_command(const char *name, signed int type, const char **argv)
{
  if(type == 1)
    dump_queue_statistics(childs_queue);

}

// ec_responce
// file request.c line 623
static signed int ec_responce(struct ci_request *req, signed int ec)
{
  char buf[256l];
  struct ci_service_xdata *srv_xdata = (struct ci_service_xdata *)(void *)0;
  signed int len;
  signed int allow204to200OK = 0;
  if(!(req->current_service_mod == ((struct ci_service_module *)NULL)))
    srv_xdata=service_data(req->current_service_mod);

  ci_headers_reset(req->response_header);
  if(ec == 2 && !(ALLOW204_AS_200OK_ZERO_ENCAPS == 0))
  {
    allow204to200OK = 1;
    ec = 1;
  }

  signed int tmp_if_expr$1;
  if(ec >= 0 && !(ec >= 16))
    tmp_if_expr$1 = ci_error_codes[(signed long int)ec].code;

  else
    tmp_if_expr$1 = 1000;
  char *tmp_if_expr$2;
  if(ec >= 0 && !(ec >= 16))
    tmp_if_expr$2 = ci_error_codes[(signed long int)ec].str;

  else
    tmp_if_expr$2 = "UNKNOWN ERROR CODE";
  snprintf(buf, (unsigned long int)256, "ICAP/1.0 %d %s", tmp_if_expr$1, tmp_if_expr$2);
  ci_headers_add(req->response_header, buf);
  ci_headers_add(req->response_header, "Server: C-ICAP/0.4.2");
  if(!(req->keepalive == 0))
    ci_headers_add(req->response_header, "Connection: keep-alive");

  else
    ci_headers_add(req->response_header, "Connection: close");
  if(!(srv_xdata == ((struct ci_service_xdata *)NULL)))
  {
    ci_service_data_read_lock(srv_xdata);
    ci_headers_add(req->response_header, srv_xdata->ISTag);
    ci_service_data_read_unlock(srv_xdata);
  }

  if(!(req->xheaders->used == 0))
    ci_headers_addheaders(req->response_header, req->xheaders);

  if(!(allow204to200OK == 0))
  {
    if(req->type == 0x02)
      ci_headers_add(req->response_header, "Encapsulated: req-hdr=0, null-body=0");

    else
      ci_headers_add(req->response_header, "Encapsulated: res-hdr=0, null-body=0");
  }

  ci_headers_pack(req->response_header);
  req->return_code = ec;
  len=ci_write(req->connection->fd, (const void *)req->response_header->buf, (unsigned long int)req->response_header->bufused, TIMEOUT);
  req->status = 6;
  if(!(len >= 0))
    return -1;

  else
  {
    req->bytes_out = req->bytes_out + (unsigned long int)len;
    return len;
  }
}

// ec_responce_simple
// file request.c line 610
static void ec_responce_simple(struct ci_request *req, signed int ec)
{
  char buf[256l];
  signed int len;
  signed int tmp_if_expr$1;
  if(ec >= 0 && !(ec >= 16))
    tmp_if_expr$1 = ci_error_codes[(signed long int)ec].code;

  else
    tmp_if_expr$1 = 1000;
  char *tmp_if_expr$2;
  if(ec >= 0 && !(ec >= 16))
    tmp_if_expr$2 = ci_error_codes[(signed long int)ec].str;

  else
    tmp_if_expr$2 = "UNKNOWN ERROR CODE";
  snprintf(buf, (unsigned long int)256, "ICAP/1.0 %d %s\r\n\r\n", tmp_if_expr$1, tmp_if_expr$2);
  buf[(signed long int)255] = (char)0;
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(buf);
  len = (signed int)return_value_strlen$3;
  ci_write(req->connection->fd, (const void *)buf, (unsigned long int)len, TIMEOUT);
  req->bytes_out = req->bytes_out + (unsigned long int)len;
  req->return_code = ec;
}

// empty
// file mpmt_server.c line 114
static void empty(signed int sig)
{
  ;
}

// exec_cmd_step
// file commands.c line 164
static signed int exec_cmd_step(void *data, const void *cmd)
{
  signed int cmd_type = *((signed int *)data);
  struct ci_command *command = (struct ci_command *)cmd;
  if(CI_DEBUG_LEVEL >= 7)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Check command:%s, type: %d \n", (const void *)command->name, command->type);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Check command:%s, type: %d \n", (const void *)command->name, command->type);

  }

  if(command->type == cmd_type)
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Execute command:%s \n", (const void *)command->name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Execute command:%s \n", (const void *)command->name);

    }

    command->$anon0.command_action_extend(command->name, command->type, command->data);
  }

  return 0;
}

// execute_child_commands
// file commands.c line 177
static signed int execute_child_commands(signed int cmd_type)
{
  if(CI_DEBUG_LEVEL >= 5)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Going to execute child commands\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Going to execute child commands\n");

  }

  if(COMMANDS_LIST == ((struct ci_list *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "None command registered\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("None command registered\n");

    }

    return 0;
  }

  else
  {
    ci_list_iterate(COMMANDS_LIST, (void *)&cmd_type, exec_cmd_step);
    return 1;
  }
}

// execute_command
// file commands.c line 152
signed int execute_command(struct ci_command *command, char *cmdline, signed int exec_type)
{
  char **args;
  if(command == ((struct ci_command *)NULL))
    return 0;

  else
  {
    args=split_args(cmdline);
    command->$anon0.command_action(args[(signed long int)0], exec_type, (const char **)(args + (signed long int)1));
    free_args(args);
    return 1;
  }
}

// exit_normaly
// file mpmt_server.c line 180
static void exit_normaly()
{
  system_shutdown();
  child_data = (struct child_shared_data *)(void *)0;
  dettach_childs_queue(childs_queue);
}

// extend_object_type
// file filetype.c line 559
signed int extend_object_type(struct ci_magics_db *db, struct ci_headers_list *headers, const char *buf, signed int len, signed int *iscompressed)
{
  signed int file_type;
  signed int unzip_error = 0;
  signed int unzipped_buf_len = 0;
  char *unzipped_buf = (char *)(void *)0;
  const char *checkbuf = buf;
  const char *content_type = (const char *)(void *)0;
  const char *content_encoding = (const char *)(void *)0;
  *iscompressed = 0;
  char *return_value_strcasestr$2;
  char *return_value_strcasestr$1;
  char *return_value_strcasestr$14;
  char *return_value_strcasestr$16;
  if(!(len >= 1))
    return 5;

  else
  {
    if(!(headers == ((struct ci_headers_list *)NULL)))
    {
      content_encoding=ci_headers_value(headers, "Content-Encoding");
      if(!(content_encoding == ((const char *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 8)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Content-Encoding :%s\n", content_encoding);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Content-Encoding :%s\n", content_encoding);

        }

        char *return_value_strcasestr$3;
        return_value_strcasestr$3=strcasestr(content_encoding, "gzip");
        if(!(return_value_strcasestr$3 == ((char *)NULL)))
          *iscompressed = 1;

        else
        {
          return_value_strcasestr$2=strcasestr(content_encoding, "deflate");
          if(!(return_value_strcasestr$2 == ((char *)NULL)))
            *iscompressed = 2;

          else
          {
            return_value_strcasestr$1=strcasestr(content_encoding, "bzip2");
            if(!(return_value_strcasestr$1 == ((char *)NULL)))
              *iscompressed = 3;

            else
              *iscompressed = 4;
          }
        }
        _Bool tmp_if_expr$6;
        if(*iscompressed == 1)
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = *iscompressed == 2 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
        {
          void *return_value_ci_buffer_alloc$4;
          return_value_ci_buffer_alloc$4=ci_buffer_alloc(len);
          unzipped_buf = (char *)return_value_ci_buffer_alloc$4;
          unzipped_buf_len = len;
          signed int return_value_ci_uncompress_preview$5;
          return_value_ci_uncompress_preview$5=ci_uncompress_preview(*iscompressed, buf, len, unzipped_buf, &unzipped_buf_len);
          if(!(return_value_ci_uncompress_preview$5 == -1))
          {
            checkbuf = unzipped_buf;
            len = unzipped_buf_len;
          }

          else
          {
            if(CI_DEBUG_LEVEL >= 3)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error uncompressing encoded object\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error uncompressing encoded object\n");

            }

            ci_buffer_free((void *)unzipped_buf);
            unzipped_buf = (char *)(void *)0;
            unzip_error = 1;
          }
        }

      }

    }

    file_type=ci_filetype(db, checkbuf, len);
    if(CI_DEBUG_LEVEL >= 7)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        char *tmp_if_expr$7;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$7 = (db->types + (signed long int)file_type)->name;

        else
          tmp_if_expr$7 = (char *)(void *)0;
        _Bool tmp_if_expr$8;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$8 = file_type < db->types_num ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$8 = (_Bool)0;
        char *tmp_if_expr$9;
        if(file_type >= 0 && tmp_if_expr$8)
          tmp_if_expr$9 = (db->types + (signed long int)file_type)->descr;

        else
          tmp_if_expr$9 = (char *)(void *)0;
        __log_error((void *)0, "File type returned :%s,%s\n", tmp_if_expr$7, tmp_if_expr$9);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        char *tmp_if_expr$10;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$10 = (db->types + (signed long int)file_type)->name;

        else
          tmp_if_expr$10 = (char *)(void *)0;
        _Bool tmp_if_expr$11;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$11 = file_type < db->types_num ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$11 = (_Bool)0;
        char *tmp_if_expr$12;
        if(file_type >= 0 && tmp_if_expr$11)
          tmp_if_expr$12 = (db->types + (signed long int)file_type)->descr;

        else
          tmp_if_expr$12 = (char *)(void *)0;
        printf("File type returned :%s,%s\n", tmp_if_expr$10, tmp_if_expr$12);
      }

    }

    signed int return_value_ci_belongs_to_group$18;
    return_value_ci_belongs_to_group$18=ci_belongs_to_group(db, file_type, 0);
    if(!(return_value_ci_belongs_to_group$18 == 0))
    {
      if(!(headers == ((struct ci_headers_list *)NULL)))
      {
        content_type=ci_headers_value(headers, "Content-Type");
        if(!(content_type == ((const char *)NULL)))
        {
          char *return_value_strcasestr$13;
          return_value_strcasestr$13=strcasestr(content_type, "text/html");
          _Bool tmp_if_expr$15;
          if(!(return_value_strcasestr$13 == ((char *)NULL)))
            tmp_if_expr$15 = (_Bool)1;

          else
          {
            return_value_strcasestr$14=strcasestr(content_type, "text/css");
            tmp_if_expr$15 = return_value_strcasestr$14 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
          }
          _Bool tmp_if_expr$17;
          if(tmp_if_expr$15)
            tmp_if_expr$17 = (_Bool)1;

          else
          {
            return_value_strcasestr$16=strcasestr(content_type, "text/javascript");
            tmp_if_expr$17 = return_value_strcasestr$16 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$17)
            file_type = 4;

        }

      }

    }

    if(CI_DEBUG_LEVEL >= 7)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        char *tmp_if_expr$19;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$19 = (db->types + (signed long int)file_type)->name;

        else
          tmp_if_expr$19 = (char *)(void *)0;
        _Bool tmp_if_expr$20;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$20 = file_type < db->types_num ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$20 = (_Bool)0;
        char *tmp_if_expr$21;
        if(file_type >= 0 && tmp_if_expr$20)
          tmp_if_expr$21 = (db->types + (signed long int)file_type)->descr;

        else
          tmp_if_expr$21 = (char *)(void *)0;
        __log_error((void *)0, "The file type now is :%s,%s\n", tmp_if_expr$19, tmp_if_expr$21);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        char *tmp_if_expr$22;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$22 = (db->types + (signed long int)file_type)->name;

        else
          tmp_if_expr$22 = (char *)(void *)0;
        _Bool tmp_if_expr$23;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr$23 = file_type < db->types_num ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$23 = (_Bool)0;
        char *tmp_if_expr$24;
        if(file_type >= 0 && tmp_if_expr$23)
          tmp_if_expr$24 = (db->types + (signed long int)file_type)->descr;

        else
          tmp_if_expr$24 = (char *)(void *)0;
        printf("The file type now is :%s,%s\n", tmp_if_expr$22, tmp_if_expr$24);
      }

    }

    if(!(unzipped_buf == ((char *)NULL)))
      ci_buffer_free((void *)unzipped_buf);

    return file_type;
  }
}

// file_log_access
// file log.c line 308
void file_log_access(struct ci_request *req)
{
  struct logfile *lf;
  char logline[4096l];
  lf = ACCESS_LOG_FILES;
  signed int return_value_ci_access_entry_match_request$1;
  for( ; !(lf == ((struct logfile *)NULL)); lf = lf->next)
  {
    if(!(lf->access_list == ((struct ci_access_entry *)NULL)))
    {
      return_value_ci_access_entry_match_request$1=ci_access_entry_match_request(lf->access_list, req);
      if(!(return_value_ci_access_entry_match_request$1 == 1))
      {
        if(CI_DEBUG_LEVEL >= 6)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "access log file %s does not match, skiping\n", lf->file);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("access log file %s does not match, skiping\n", lf->file);

        }

        goto __CPROVER_DUMP_L9;
      }

    }

    if(CI_DEBUG_LEVEL >= 6)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Log request to access log file %s\n", lf->file);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Log request to access log file %s\n", lf->file);

    }

    ci_format_text(req, lf->log_fmt, logline, (signed int)sizeof(char [4096l]) /*4096ul*/ , (struct ci_fmt_entry *)(void *)0);
    pthread_rwlock_rdlock(&lf->rwlock);
    if(!(lf->access_log == ((struct _IO_FILE *)NULL)))
      fprintf(lf->access_log, "%s\n", (const void *)logline);

    pthread_rwlock_unlock(&lf->rwlock);

  __CPROVER_DUMP_L9:
    ;
  }
}

// file_log_addlogfile
// file cfg_param.c line 489
signed int file_log_addlogfile(const char *file, const char *format, const char **acls)
{
  char *access_log_file;
  char *access_log_format;
  const char *acl_name;
  struct logfile *lf;
  struct logfile *newlf;
  signed int i;
  access_log_file=strdup(file);
  if(access_log_file == ((char *)NULL))
    return 0;

  else
  {
    if(!(format == ((const char *)NULL)))
      access_log_format=logformat_fmt(format);

    else
      access_log_format = (char *)(void *)0;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct logfile) /*96ul*/ );
    newlf = (struct logfile *)return_value_malloc$1;
    newlf->file = access_log_file;
    newlf->log_fmt = access_log_format != (char *)(void *)0 ? access_log_format : DEFAULT_LOG_FORMAT;
    newlf->access_log = (struct _IO_FILE *)(void *)0;
    newlf->access_list = (struct ci_access_entry *)(void *)0;
    newlf->next = (struct logfile *)(void *)0;
    if(!(acls == ((const char **)NULL)))
    {
      if(!(*acls == ((const char *)NULL)))
      {
        struct ci_access_entry *return_value_ci_access_entry_new$2;
        return_value_ci_access_entry_new$2=ci_access_entry_new(&newlf->access_list, 1);
        if(return_value_ci_access_entry_new$2 == ((struct ci_access_entry *)NULL))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Error creating access list for access log file %s!\n", newlf->file);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Error creating access list for access log file %s!\n", newlf->file);

          }

          free((void *)newlf->file);
          free((void *)newlf);
          return 0;
        }

        i = 0;
        for( ; !(acls[(signed long int)i] == ((const char *)NULL)); i = i + 1)
        {
          acl_name = acls[(signed long int)i];
          signed int return_value_ci_access_entry_add_acl_by_name$3;
          return_value_ci_access_entry_add_acl_by_name$3=ci_access_entry_add_acl_by_name(newlf->access_list, acl_name);
          if(return_value_ci_access_entry_add_acl_by_name$3 == 0)
          {
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error addind acl %s to access list for access log file %s!\n", acl_name, newlf->file);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error addind acl %s to access list for access log file %s!\n", acl_name, newlf->file);

            }

            ci_access_entry_release(newlf->access_list);
            free((void *)newlf->file);
            free((void *)newlf);
            return 0;
          }

        }
      }

    }

    if(ACCESS_LOG_FILES == ((struct logfile *)NULL))
      ACCESS_LOG_FILES = newlf;

    else
    {
      lf = ACCESS_LOG_FILES;
      for( ; !(lf->next == ((struct logfile *)NULL)); lf = lf->next)
      {
        signed int return_value_strcmp$4;
        return_value_strcmp$4=strcmp(lf->file, newlf->file);
        if(return_value_strcmp$4 == 0)
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Access log file %s already defined!\n", newlf->file);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Access log file %s already defined!\n", newlf->file);

          }

          if(!(newlf->access_list == ((struct ci_access_entry *)NULL)))
            ci_access_entry_release(newlf->access_list);

          free((void *)newlf->file);
          free((void *)newlf);
          return 0;
        }

      }
      lf->next = newlf;
    }
    return 1;
  }
}

// file_log_close
// file log.c line 260
void file_log_close()
{
  struct logfile *lf;
  struct logfile *tmp;
  lf = ACCESS_LOG_FILES;
  while(!(lf == ((struct logfile *)NULL)))
  {
    if(!(lf->access_log == ((struct _IO_FILE *)NULL)))
      fclose(lf->access_log);

    free((void *)lf->file);
    if(!(lf->access_list == ((struct ci_access_entry *)NULL)))
      ci_access_entry_release(lf->access_list);

    ci_thread_rwlock_destroy(&lf->rwlock);
    tmp = lf;
    lf = lf->next;
    ACCESS_LOG_FILES = lf;
    free((void *)tmp);
  }
  if(!(server_log == ((struct _IO_FILE *)NULL)))
    fclose(server_log);

  server_log = (struct _IO_FILE *)(void *)0;
  ci_thread_rwlock_destroy(&systemlog_rwlock);
}

// file_log_open
// file log.c line 225
signed int file_log_open()
{
  signed int error = 0;
  signed int ret = 0;
  struct logfile *lf;
  /* assertion ret == 0 */
  assert(ret == 0);
  register_command("relog", 1 | 2, file_log_relog);
  lf = ACCESS_LOG_FILES;
  for( ; !(lf == ((struct logfile *)NULL)); lf = lf->next)
    if(lf->file == ((char *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "This is a bug! lf->file==NULL\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("This is a bug! lf->file==NULL\n");

      }

    }

    else
    {
      if(lf->log_fmt == ((const char *)NULL))
        lf->log_fmt = (char *)DEFAULT_LOG_FORMAT;

      lf->access_log=logfile_open(lf->file);
      if(lf->access_log == ((struct _IO_FILE *)NULL))
      {
        error = 1;
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "WARNING! Can not open log file: %s\n", lf->file);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("WARNING! Can not open log file: %s\n", lf->file);

        }

      }

      ret=ci_thread_rwlock_init(&lf->rwlock);
    }
  ret=ci_thread_rwlock_init(&systemlog_rwlock);
  server_log=logfile_open(SERVER_LOG_FILE);
  if(server_log == ((struct _IO_FILE *)NULL))
    return 0;

  else
    if(!(error == 0))
      return 0;

    else
      return 1;
}

// file_log_relog
// file log.c line 284
void file_log_relog(const char *name, signed int type, const char **argv)
{
  struct logfile *lf = ACCESS_LOG_FILES;
  for( ; !(lf == ((struct logfile *)NULL)); lf = lf->next)
  {
    pthread_rwlock_wrlock(&lf->rwlock);
    if(!(lf->access_log == ((struct _IO_FILE *)NULL)))
      fclose(lf->access_log);

    lf->access_log=logfile_open(lf->file);
    pthread_rwlock_unlock(&lf->rwlock);
    if(lf->access_log == ((struct _IO_FILE *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "WARNING! Can not open log file: %s\n", lf->file);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("WARNING! Can not open log file: %s\n", lf->file);

      }

    }

  }
  pthread_rwlock_wrlock(&systemlog_rwlock);
  if(!(server_log == ((struct _IO_FILE *)NULL)))
    fclose(server_log);

  server_log=logfile_open(SERVER_LOG_FILE);
  pthread_rwlock_unlock(&systemlog_rwlock);
}

// file_log_server
// file log.c line 329
void file_log_server(const char *server, const char *format, void **ap)
{
  char buf[64l];
  if(!(server_log == ((struct _IO_FILE *)NULL)))
  {
    ci_strtime(buf);
    pthread_rwlock_rdlock(&systemlog_rwlock);
    fprintf(server_log, "%s, %s, ", (const void *)buf, server);
    vfprintf(server_log, format, ap);
    pthread_rwlock_unlock(&systemlog_rwlock);
  }

}

// file_proc_mutex_destroy
// file os/unix/proc_mutex.c line 195
static signed int file_proc_mutex_destroy(struct ci_proc_mutex *mutex)
{
  close(mutex->$anon0.file.fd);
  signed int return_value_unlink$1;
  return_value_unlink$1=unlink(mutex->name);
  if(!(return_value_unlink$1 == 0))
    return 0;

  else
    return 1;
}

// file_proc_mutex_init
// file os/unix/proc_mutex.c line 185
static signed int file_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name)
{
  strcpy(mutex->name, "/tmp/icap_lock");
  snprintf(mutex->name, (unsigned long int)64, "%s_%s.XXXXXX", (const void *)"/tmp/icap_lock", name);
  mutex->$anon0.file.fd=mkstemp64(mutex->name);
  if(!(mutex->$anon0.file.fd >= 0))
    return 0;

  else
    return 1;
}

// file_proc_mutex_lock
// file os/unix/proc_mutex.c line 203
static signed int file_proc_mutex_lock(struct ci_proc_mutex *mutex)
{
  struct flock fl;
  fl.l_type = (signed short int)1;
  fl.l_whence = (signed short int)0;
  fl.l_start = (signed long int)0;
  fl.l_len = (signed long int)0;
  signed int return_value_fcntl$1;
  return_value_fcntl$1=fcntl(mutex->$anon0.file.fd, 7, &fl);
  if(!(return_value_fcntl$1 >= 0))
    return 0;

  else
    return 1;
}

// file_proc_mutex_print_info
// file os/unix/proc_mutex.c line 228
static signed int file_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, buf_size, "file:%s", (const void *)mutex->name);
  return return_value_snprintf$1;
}

// file_proc_mutex_unlock
// file os/unix/proc_mutex.c line 216
static signed int file_proc_mutex_unlock(struct ci_proc_mutex *mutex)
{
  struct flock fl;
  fl.l_type = (signed short int)2;
  fl.l_whence = (signed short int)0;
  fl.l_start = (signed long int)0;
  fl.l_len = (signed long int)0;
  signed int return_value_fcntl$1;
  return_value_fcntl$1=fcntl(mutex->$anon0.file.fd, 6, &fl);
  if(!(return_value_fcntl$1 >= 0))
    return 0;

  else
    return 1;
}

// file_table_close
// file lookup_file_table.c line 264
void file_table_close(struct ci_lookup_table *table)
{
  signed int i;
  void **vals = (void **)(void *)0;
  struct text_table_entry *tmp;
  struct ci_mem_allocator *allocator = table->allocator;
  struct text_table *text_table = (struct text_table *)table->data;
  if(text_table == ((struct text_table *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Closing a non open file lookup table?(%s)\n", table->path);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Closing a non open file lookup table?(%s)\n", table->path);

    }

  }

  else
  {
    if(!(text_table->entries == ((struct text_table_entry *)NULL)))
    {
      tmp = text_table->entries;
      text_table->entries = text_table->entries->next;
      if(!(tmp->vals == ((void **)NULL)))
      {
        vals = (void **)tmp->vals;
        i = 0;
        if(!(vals[(signed long int)i] == NULL))
        {
          table->val_ops->free(vals[(signed long int)i], allocator);
          i = i + 1;
        }

        allocator->free(allocator, (void *)tmp->vals);
      }

      table->key_ops->free(tmp->key, allocator);
      allocator->free(allocator, (void *)tmp);
    }

    allocator->free(allocator, (void *)text_table);
    table->data = (void *)0;
  }
}

// file_table_open
// file lookup_file_table.c line 247
void * file_table_open(struct ci_lookup_table *table)
{
  struct ci_mem_allocator *allocator = table->allocator;
  struct text_table *text_table;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(struct text_table) /*24ul*/ );
  text_table = (struct text_table *)return_value;
  if(text_table == ((struct text_table *)NULL))
    return (void *)0;

  else
  {
    text_table->entries = (struct text_table_entry *)(void *)0;
    table->data = (void *)text_table;
    signed int return_value_load_text_table$1;
    return_value_load_text_table$1=load_text_table(table->path, table);
    if(return_value_load_text_table$1 == 0)
    {
      table->data = (void *)0;
      return table->data;
    }

    else
    {
      text_table->hash_table = (struct ci_hash_table *)(void *)0;
      return (void *)text_table;
    }
  }
}

// file_table_release_result
// file lookup_file_table.c line 316
void file_table_release_result(struct ci_lookup_table *table_data, void **val)
{
  ;
}

// file_table_search
// file lookup_file_table.c line 294
void * file_table_search(struct ci_lookup_table *table, void *key, void ***vals)
{
  struct text_table_entry *e;
  struct text_table *text_table = (struct text_table *)table->data;
  if(text_table == ((struct text_table *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Search a non open lookup table?(%s)\n", table->path);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Search a non open lookup table?(%s)\n", table->path);

    }

    return (void *)0;
  }

  else
  {
    e = text_table->entries;
    *vals = (void **)(void *)0;
    if(!(e == ((struct text_table_entry *)NULL)))
    {
      signed int return_value;
      return_value=table->key_ops->compare((void *)e->key, key);
      if(return_value == 0)
      {
        *vals = (void **)e->vals;
        return (void *)e->key;
      }

      e = e->next;
    }

    return (void *)0;
  }
}

// fill_queue_statistics
// file info.c line 182
void fill_queue_statistics(struct childs_queue *q, struct info_req_data *info_data)
{
  signed int i;
  signed int requests = 0;
  struct stat_memblock *stats;
  struct stat_memblock copy_stats;
  struct server_statistics *srv_stats;
  if(!(q->childs == ((struct child_shared_data *)NULL)))
  {
    i = 0;
    for( ; !(i >= q->size); i = i + 1)
    {
      _Bool tmp_if_expr$1;
      if(!((q->childs + (signed long int)i)->pid == 0))
        tmp_if_expr$1 = (q->childs + (signed long int)i)->to_be_killed == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
      {
        if(!(info_data->child_pids == ((signed int *)NULL)))
          info_data->child_pids[(signed long int)info_data->childs] = (q->childs + (signed long int)i)->pid;

        info_data->childs = info_data->childs + 1;
        info_data->free_servers = info_data->free_servers + (q->childs + (signed long int)i)->freeservers;
        info_data->used_servers = info_data->used_servers + (q->childs + (signed long int)i)->usedservers;
        requests = requests + (q->childs + (signed long int)i)->requests;
        stats = (struct stat_memblock *)(q->stats_area + (signed long int)(i * q->stats_block_size));
        copy_stats.counters64_size = stats->counters64_size;
        copy_stats.counterskbs_size = stats->counterskbs_size;
        copy_stats.counters64 = (unsigned long int *)((void *)stats + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
        copy_stats.counterskbs = (struct kbs *)((void *)stats + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (signed long int)((unsigned long int)stats->counters64_size * sizeof(unsigned long int) /*8ul*/ ));
        ci_stat_memblock_merge(info_data->collect_stats, &copy_stats);
      }

      else
        if(!((q->childs + (signed long int)i)->pid == 0))
        {
          if(!((q->childs + (signed long int)i)->to_be_killed == 0))
          {
            if(!(info_data->closing_child_pids == ((signed int *)NULL)))
              info_data->closing_child_pids[(signed long int)info_data->closing_childs] = (q->childs + (signed long int)i)->pid;

            info_data->closing_childs = info_data->closing_childs + 1u;
          }

        }

    }
    stats = (struct stat_memblock *)(q->stats_area + (signed long int)(q->size * q->stats_block_size));
    copy_stats.counters64_size = stats->counters64_size;
    copy_stats.counterskbs_size = stats->counterskbs_size;
    copy_stats.counters64 = (unsigned long int *)((void *)stats + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
    copy_stats.counterskbs = (struct kbs *)((void *)stats + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (signed long int)((unsigned long int)stats->counters64_size * sizeof(unsigned long int) /*8ul*/ ));
    ci_stat_memblock_merge(info_data->collect_stats, &copy_stats);
    srv_stats = (struct server_statistics *)(q->stats_area + (signed long int)(q->size * q->stats_block_size) + (signed long int)q->stats_block_size);
    info_data->started_childs = srv_stats->started_childs;
    info_data->closed_childs = srv_stats->closed_childs;
    info_data->crashed_childs = srv_stats->crashed_childs;
  }

}

// find_a_child_nrequests
// file proc_threads_queues.c line 331
signed int find_a_child_nrequests(struct childs_queue *q, signed int max_requests)
{
  signed int i;
  signed int which;
  signed int requests;
  which = -1;
  requests = max_requests;
  ci_proc_mutex_lock(&q->queue_mtx);
  i = 0;
  for( ; !(i >= q->size); i = i + 1)
    if(!((q->childs + (signed long int)i)->pid == 0))
    {
      if(!((q->childs + (signed long int)i)->to_be_killed == 0))
      {
        ci_proc_mutex_unlock(&q->queue_mtx);
        return -1;
      }

      if(!(requests >= (q->childs + (signed long int)i)->requests))
      {
        requests = (q->childs + (signed long int)i)->requests;
        which = i;
      }

    }

  ci_proc_mutex_unlock(&q->queue_mtx);
  return which;
}

// find_a_child_to_be_killed
// file proc_threads_queues.c line 315
signed int find_a_child_to_be_killed(struct childs_queue *q)
{
  signed int i;
  signed int which;
  signed int freeservers;
  ci_proc_mutex_lock(&q->queue_mtx);
  freeservers = (q->childs + (signed long int)0)->freeservers;
  which = 0;
  i = 1;
  for( ; !(i >= q->size); i = i + 1)
    if(!((q->childs + (signed long int)i)->pid == 0))
    {
      if(!((q->childs + (signed long int)i)->freeservers >= freeservers))
      {
        freeservers = (q->childs + (signed long int)i)->freeservers;
        which = i;
      }

    }

  ci_proc_mutex_unlock(&q->queue_mtx);
  return which;
}

// find_access_controller
// file include/module.h line 117
struct access_control_module * find_access_controller(const char *name)
{
  struct access_control_module *sh;
  signed int i = 0;
  signed int return_value_strcmp$1;
  for( ; !(i >= access_controllers.modules_num); i = i + 1)
  {
    sh = (struct access_control_module *)access_controllers.modules[(signed long int)i];
    if(!(sh->name == ((const char *)NULL)))
    {
      return_value_strcmp$1=strcmp(sh->name, name);
      if(return_value_strcmp$1 == 0)
        return sh;

    }

  }
  return (struct access_control_module *)(void *)0;
}

// find_action
// file cfg_param.c line 699
struct ci_conf_entry * find_action(char *str, char **arg)
{
  char *end;
  char *table;
  char *s;
  signed int size;
  end = str;
  const unsigned short int **return_value___ctype_b_loc$1;
  for( ; !((signed int)*end == 0); end = end + 1l)
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*end]) == 0))
      break;

  }
  size = (signed int)(end - str);
  *end = (char)0;
  end = end + 1l;
  const unsigned short int **return_value___ctype_b_loc$2;
  for( ; !((signed int)*end == 0); end = end + 1l)
  {
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*end]) == 0)
      break;

  }
  *arg = end;
  s=strchr(str, 46);
  if(!(s == ((char *)NULL)))
  {
    table = str;
    str = s + (signed long int)1;
    *s = (char)0;
  }

  else
    table = (char *)(void *)0;
  struct ci_conf_entry *return_value_search_variables$3;
  return_value_search_variables$3=search_variables(table, str);
  return return_value_search_variables$3;
}

// find_an_idle_child
// file proc_threads_queues.c line 353
signed int find_an_idle_child(struct childs_queue *q)
{
  signed int i;
  signed int which;
  signed int requests = -1;
  which = -1;
  ci_proc_mutex_lock(&q->queue_mtx);
  i = 0;
  for( ; !(i >= q->size); i = i + 1)
    if(!((q->childs + (signed long int)i)->pid == 0))
    {
      if(!((q->childs + (signed long int)i)->to_be_killed == 0))
      {
        ci_proc_mutex_unlock(&q->queue_mtx);
        return -1;
      }

      if((q->childs + (signed long int)i)->usedservers == 0)
      {
        if((q->childs + (signed long int)i)->idle == 1)
        {
          if(!(requests >= (q->childs + (signed long int)i)->requests))
          {
            requests = (q->childs + (signed long int)i)->requests;
            which = i;
          }

        }

      }

    }

  ci_proc_mutex_unlock(&q->queue_mtx);
  return which;
}

// find_auth_method
// file module.c line 252
struct http_auth_method * find_auth_method(const char *method)
{
  signed int i = 0;
  for( ; !(i >= auth_methods.modules_num); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(method, ((struct http_auth_method *)auth_methods.modules[(signed long int)i])->name);
    if(return_value_strcmp$1 == 0)
      return (struct http_auth_method *)auth_methods.modules[(signed long int)i];

  }
  return (struct http_auth_method *)(void *)0;
}

// find_auth_method_id
// file module.c line 270
struct http_auth_method * find_auth_method_id(const char *method, signed int *method_id)
{
  signed int i;
  *method_id = 0;
  i = 0;
  for( ; !(i >= auth_methods.modules_num); i = i + 1)
  {
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(method, ((struct http_auth_method *)auth_methods.modules[(signed long int)i])->name);
    if(return_value_strcasecmp$1 == 0)
    {
      *method_id = i;
      return (struct http_auth_method *)auth_methods.modules[(signed long int)i];
    }

  }
  return (struct http_auth_method *)(void *)0;
}

// find_authenticator
// file module.c line 286
struct authenticator_module * find_authenticator(const char *name)
{
  signed int i = 0;
  for( ; !(i >= authenticators.modules_num); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(name, ((struct authenticator_module *)authenticators.modules[(signed long int)i])->name);
    if(return_value_strcmp$1 == 0)
      return (struct authenticator_module *)authenticators.modules[(signed long int)i];

  }
  return (struct authenticator_module *)(void *)0;
}

// find_command
// file commands.c line 121
struct ci_command * find_command(const char *cmd_line)
{
  signed int len;
  char *s;
  struct ci_command tmpCmd;
  struct ci_command *cmd;
  unsigned long int return_value_strlen$1;
  if(COMMANDS_LIST == ((struct ci_list *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "None command registered\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("None command registered\n");

    }

    return (struct ci_command *)(void *)0;
  }

  else
  {
    s=strchr(cmd_line, 32);
    if(!(s == ((char *)NULL)))
      len = (signed int)(s - cmd_line);

    else
    {
      return_value_strlen$1=strlen(cmd_line);
      len = (signed int)return_value_strlen$1;
    }
    if(!(len == 0) && !(len >= 128))
    {
      strncpy(tmpCmd.name, cmd_line, (unsigned long int)len);
      tmpCmd.name[(signed long int)len] = (char)0;
      cmd = &tmpCmd;
      ci_list_iterate(COMMANDS_LIST, (void *)&cmd, cb_check_command);
      if(cmd == &tmpCmd)
        goto __CPROVER_DUMP_L6;

      return cmd;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      return (struct ci_command *)(void *)0;
    }
  }
}

// find_common
// file module.c line 234
struct common_module * find_common(const char *name)
{
  struct common_module *m;
  signed int i = 0;
  signed int return_value_strcmp$1;
  for( ; !(i >= common_modules.modules_num); i = i + 1)
  {
    m = (struct common_module *)common_modules.modules[(signed long int)i];
    if(!(m->name == ((const char *)NULL)))
    {
      return_value_strcmp$1=strcmp(m->name, name);
      if(return_value_strcmp$1 == 0)
        return m;

    }

  }
  return (struct common_module *)(void *)0;
}

// find_logger
// file include/module.h line 116
struct logger_module * find_logger(const char *name)
{
  struct logger_module *sh;
  signed int i = 0;
  signed int return_value_strcmp$1;
  for( ; !(i >= loggers.modules_num); i = i + 1)
  {
    sh = (struct logger_module *)loggers.modules[(signed long int)i];
    if(!(sh->name == ((const char *)NULL)))
    {
      return_value_strcmp$1=strcmp(sh->name, name);
      if(return_value_strcmp$1 == 0)
        return sh;

    }

  }
  return (struct logger_module *)(void *)0;
}

// find_module
// file module.c line 313
void * find_module(const char *name, signed int *type)
{
  void *mod;
  struct logger_module *return_value_find_logger$1;
  return_value_find_logger$1=find_logger(name);
  mod = (void *)return_value_find_logger$1;
  if(!(mod == NULL))
  {
    *type = LOGGER;
    return mod;
  }

  else
  {
    struct service_handler_module *return_value_find_servicehandler$2;
    return_value_find_servicehandler$2=find_servicehandler(name);
    mod = (void *)return_value_find_servicehandler$2;
    if(!(mod == NULL))
    {
      *type = SERVICE_HANDLER;
      return mod;
    }

    else
    {
      struct access_control_module *return_value_find_access_controller$3;
      return_value_find_access_controller$3=find_access_controller(name);
      mod = (void *)return_value_find_access_controller$3;
      if(!(mod == NULL))
      {
        *type = ACCESS_CONTROLLER;
        return mod;
      }

      else
      {
        struct http_auth_method *return_value_find_auth_method$4;
        return_value_find_auth_method$4=find_auth_method(name);
        mod = (void *)return_value_find_auth_method$4;
        if(!(mod == NULL))
        {
          *type = AUTH_METHOD;
          return mod;
        }

        else
        {
          struct authenticator_module *return_value_find_authenticator$5;
          return_value_find_authenticator$5=find_authenticator(name);
          mod = (void *)return_value_find_authenticator$5;
          if(!(mod == NULL))
          {
            *type = AUTHENTICATOR;
            return mod;
          }

          else
          {
            struct common_module *return_value_find_common$6;
            return_value_find_common$6=find_common(name);
            mod = (void *)return_value_find_common$6;
            if(!(mod == NULL))
            {
              *type = COMMON;
              return mod;
            }

            else
            {
              *type = UNKNOWN;
              return (void *)0;
            }
          }
        }
      }
    }
  }
}

// find_service
// file include/service.h line 273
struct ci_service_module * find_service(const char *service_name)
{
  signed int i = 0;
  for( ; !(i >= services_num); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(service_list[(signed long int)i]->mod_name, service_name);
    if(return_value_strcmp$1 == 0)
      return service_list[(signed long int)i];

  }
  return (struct ci_service_module *)(void *)0;
}

// find_service_alias
// file include/service.h line 274
struct service_alias * find_service_alias(const char *service_name)
{
  signed int i = 0;
  for( ; !(i >= service_aliases_num); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((service_aliases + (signed long int)i)->alias, service_name);
    if(return_value_strcmp$1 == 0)
      return &service_aliases[(signed long int)i];

  }
  return (struct service_alias *)(void *)0;
}

// find_service_by_alias
// file service.c line 567
struct ci_service_module * find_service_by_alias(const char *service_name)
{
  signed int i = 0;
  for( ; !(i >= service_aliases_num); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((service_aliases + (signed long int)i)->alias, service_name);
    if(return_value_strcmp$1 == 0)
      return (service_aliases + (signed long int)i)->service;

  }
  return (struct ci_service_module *)(void *)0;
}

// find_servicehandler
// file module.c line 301
struct service_handler_module * find_servicehandler(const char *name)
{
  struct service_handler_module *sh;
  signed int i = 0;
  signed int return_value_strcmp$1;
  for( ; !(i >= service_handlers.modules_num); i = i + 1)
  {
    sh = (struct service_handler_module *)service_handlers.modules[(signed long int)i];
    if(!(sh->name == ((const char *)NULL)))
    {
      return_value_strcmp$1=strcmp(sh->name, name);
      if(return_value_strcmp$1 == 0)
        return sh;

    }

  }
  return (struct service_handler_module *)(void *)0;
}

// find_servicehandler_by_ext
// file include/module.h line 119
struct service_handler_module * find_servicehandler_by_ext(const char *extension)
{
  struct service_handler_module *sh;
  const char *s;
  signed int i;
  signed int len_extension;
  signed int len_s = 0;
  signed int found = 0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(extension);
  len_extension = (signed int)return_value_strlen$1;
  i = 0;
  char *return_value_strchr$3;
  for( ; !(i >= service_handlers.modules_num); i = i + 1)
  {
    sh = (struct service_handler_module *)service_handlers.modules[(signed long int)i];
    s = sh->extensions;
    do
    {
      s=strstr(s, extension);
      if(!(s == ((const char *)NULL)))
      {
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(s);
        len_s = (signed int)return_value_strlen$2;
        if(len_s >= len_extension)
        {
          return_value_strchr$3=strchr(",. \t", (signed int)s[(signed long int)len_extension]);
          _Bool tmp_if_expr$4;
          if(!(return_value_strchr$3 == ((char *)NULL)))
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = (signed int)s[(signed long int)len_extension] == 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$4)
            found = 1;

        }

      }

      if(s == ((const char *)NULL) || len_extension >= len_s)
        break;

      s = s + (signed long int)len_extension;
    }
    while(found == 0 && !(s == ((const char *)NULL)));
    if(!(found == 0))
    {
      if(CI_DEBUG_LEVEL >= 3)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Found handler %s for service with extension:%s\n", sh->name, extension);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Found handler %s for service with extension:%s\n", sh->name, extension);

      }

      return sh;
    }

  }
  if(CI_DEBUG_LEVEL >= 1)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "No handler for extension %s. Using default ...\n", extension);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("No handler for extension %s. Using default ...\n", extension);

  }

  return default_service_handler;
}

// fmt_gmttime
// file txt_format.c line 399
signed int fmt_gmttime(struct ci_request *req, char *buf, signed int len, const char *param)
{
  struct tm tm;
  signed long int t;
  const char *tfmt = "%d/%b/%Y:%H:%M:%S";
  if(len == 0)
    return 0;

  else
  {
    if(!(param == ((const char *)NULL)))
    {
      if(!((signed int)*param == 0))
        tfmt = param;

    }

    t=time(&t);
    gmtime_r(&t, &tm);
    unsigned long int return_value_strftime$1;
    return_value_strftime$1=strftime(buf, (unsigned long int)len, tfmt, &tm);
    return (signed int)return_value_strftime$1;
  }
}

// fmt_http_req_head_o
// file txt_format.c line 474
signed int fmt_http_req_head_o(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s = (const char *)(void *)0;
  signed int i;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(len == 0)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(param == ((const char *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)param[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      s=ci_http_request(req);

    else
      s=ci_http_request_get_header(req, param);
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr$2 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_http_req_url_o
// file txt_format.c line 466
signed int fmt_http_req_url_o(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(len == 0)
    return 0;

  else
  {
    signed int return_value_ci_http_request_url$1;
    return_value_ci_http_request_url$1=ci_http_request_url(req, buf, len);
    return return_value_ci_http_request_url$1;
  }
}

// fmt_http_res_head_o
// file txt_format.c line 497
signed int fmt_http_res_head_o(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s = (const char *)(void *)0;
  signed int i;
  struct ci_headers_list *http_resp_headers;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(len == 0)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(param == ((const char *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)param[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      http_resp_headers=ci_http_response_headers(req);
      if(!(http_resp_headers == ((struct ci_headers_list *)NULL)))
      {
        if(!(http_resp_headers->used == 0))
          s = http_resp_headers->headers[(signed long int)0];

      }

    }

    else
      s=ci_http_response_get_header(req, param);
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr$2 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_httpclientip
// file txt_format.c line 429
signed int fmt_httpclientip(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s;
  signed int i;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(len == 0)
    return 0;

  else
  {
    s=ci_headers_value(req->request_header, "X-Client-IP");
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr$1 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
          tmp_if_expr$2 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(!tmp_if_expr$3)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_httpserverip
// file txt_format.c line 448
signed int fmt_httpserverip(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s;
  signed int i;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(len == 0)
    return 0;

  else
  {
    s=ci_headers_value(req->request_header, "X-Server-IP");
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr$1 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(tmp_if_expr$1)
          tmp_if_expr$2 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(!tmp_if_expr$3)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_icap_req_head
// file txt_format.c line 525
signed int fmt_icap_req_head(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s = (const char *)(void *)0;
  signed int i;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(len == 0)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(param == ((const char *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)param[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(!(req->request_header == ((struct ci_headers_list *)NULL)))
      {
        if(!(req->request_header->used == 0))
          s = req->request_header->headers[(signed long int)0];

      }

    }

    else
      s=ci_headers_value(req->request_header, param);
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr$2 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_icap_res_head
// file txt_format.c line 549
signed int fmt_icap_res_head(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s = (const char *)(void *)0;
  signed int i;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(len == 0)
    return 0;

  else
  {
    _Bool tmp_if_expr$1;
    if(param == ((const char *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)param[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(!(req->response_header == ((struct ci_headers_list *)NULL)))
      {
        if(!(req->response_header->used == 0))
          s = req->response_header->headers[(signed long int)0];

      }

    }

    else
    {
      s=ci_headers_value(req->response_header, param);
      if(s == ((const char *)NULL))
      {
        if(!(req->xheaders == ((struct ci_headers_list *)NULL)))
          s=ci_headers_value(req->xheaders, param);

      }

    }
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr$2 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
          tmp_if_expr$4 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(!tmp_if_expr$4)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_icapmethod
// file txt_format.c line 338
signed int fmt_icapmethod(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  const char *s;
  _Bool tmp_if_expr$1;
  if(!(req->type >= 5))
    tmp_if_expr$1 = req->type >= 0x01 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  const char *tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = ci_methods[(signed long int)req->type];

  else
    tmp_if_expr$2 = "UNKNOWN";
  s = tmp_if_expr$2;
  i = 0;
  _Bool tmp_if_expr$3;
  do
  {
    if(!(i >= len))
      tmp_if_expr$3 = *s != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(!tmp_if_expr$3)
      break;

    buf[(signed long int)i] = *s;
    i = i + 1;
    s = s + 1l;
  }
  while((_Bool)1);
  return i;
}

// fmt_icapstatus
// file txt_format.c line 416
signed int fmt_icapstatus(struct ci_request *req, char *buf, signed int len, const char *param)
{
  _Bool tmp_if_expr$1;
  if(req->return_code >= 0)
    tmp_if_expr$1 = req->return_code < 16 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  signed int tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = ci_error_codes[(signed long int)req->return_code].code;

  else
    tmp_if_expr$2 = 1000;
  signed int return_value_snprintf$3;
  return_value_snprintf$3=snprintf(buf, (unsigned long int)len, "%d", tmp_if_expr$2);
  return return_value_snprintf$3;
}

// fmt_localip
// file txt_format.c line 327
signed int fmt_localip(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(!(len >= 16))
    return 0;

  else
  {
    const char *return_value_ci_sockaddr_t_to_ip$1;
    return_value_ci_sockaddr_t_to_ip$1=ci_sockaddr_t_to_ip(&req->connection->srvaddr, buf, 16);
    if(return_value_ci_sockaddr_t_to_ip$1 == ((const char *)NULL))
      strcpy(buf, "-");

    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(buf);
    return (signed int)return_value_strlen$2;
  }
}

// fmt_localtime
// file txt_format.c line 382
signed int fmt_localtime(struct ci_request *req, char *buf, signed int len, const char *param)
{
  struct tm tm;
  signed long int t;
  const char *tfmt = "%d/%b/%Y:%H:%M:%S %z";
  if(len == 0)
    return 0;

  else
  {
    if(!(param == ((const char *)NULL)))
    {
      if(!((signed int)*param == 0))
        tfmt = param;

    }

    t=time(&t);
    localtime_r(&t, &tm);
    unsigned long int return_value_strftime$1;
    return_value_strftime$1=strftime(buf, (unsigned long int)len, tfmt, &tm);
    return (signed int)return_value_strftime$1;
  }
}

// fmt_logstr
// file txt_format.c line 645
signed int fmt_logstr(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  const char *s;
  _Bool tmp_if_expr$1;
  if(req->log_str == ((char *)NULL))
    return 0;

  else
  {
    s = req->log_str;
    i = 0;
    do
    {
      if(!(i >= len))
        tmp_if_expr$1 = *s != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      buf[(signed long int)i] = *s;
      i = i + 1;
      s = s + 1l;
    }
    while((_Bool)1);
    return i;
  }
}

// fmt_none
// file txt_format.c line 142
signed int fmt_none(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(len == 0)
    return 0;

  else
  {
    *buf = (char)45;
    return 1;
  }
}

// fmt_percent
// file txt_format.c line 151
signed int fmt_percent(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(len == 0)
    return 0;

  else
  {
    *buf = (char)37;
    return 1;
  }
}

// fmt_remoteip
// file txt_format.c line 316
signed int fmt_remoteip(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(!(len >= 16))
    return 0;

  else
  {
    const char *return_value_ci_sockaddr_t_to_ip$1;
    return_value_ci_sockaddr_t_to_ip$1=ci_sockaddr_t_to_ip(&req->connection->claddr, buf, 16);
    if(return_value_ci_sockaddr_t_to_ip$1 == ((const char *)NULL))
      strcpy(buf, "-");

    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(buf);
    return (signed int)return_value_strlen$2;
  }
}

// fmt_req_attribute
// file txt_format.c line 659
signed int fmt_req_attribute(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  const char *s;
  _Bool tmp_if_expr$2;
  if(req->attributes == ((struct ci_array *)NULL))
    return 0;

  else
  {
    const void *return_value_ci_array_search$1;
    return_value_ci_array_search$1=ci_array_search(req->attributes, param);
    s = (const char *)return_value_ci_array_search$1;
    if(s == ((const char *)NULL))
      return 0;

    else
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr$2 = *s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }
  }
}

// fmt_req_body_bytes_rcv
// file txt_format.c line 593
signed int fmt_req_body_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->body_bytes_in);
  return return_value_snprintf$1;
}

// fmt_req_body_bytes_sent
// file txt_format.c line 597
signed int fmt_req_body_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->body_bytes_out);
  return return_value_snprintf$1;
}

// fmt_req_bytes_rcv
// file txt_format.c line 577
signed int fmt_req_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->bytes_in);
  return return_value_snprintf$1;
}

// fmt_req_bytes_sent
// file txt_format.c line 581
signed int fmt_req_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->bytes_out);
  return return_value_snprintf$1;
}

// fmt_req_http_bytes_rcv
// file txt_format.c line 585
signed int fmt_req_http_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->http_bytes_in);
  return return_value_snprintf$1;
}

// fmt_req_http_bytes_sent
// file txt_format.c line 589
signed int fmt_req_http_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->http_bytes_out);
  return return_value_snprintf$1;
}

// fmt_req_preview_hex
// file txt_format.c line 601
signed int fmt_req_preview_hex(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  signed int num;
  signed int n;
  signed int bytes;
  _Bool tmp_if_expr$2;
  if(len == 0)
    return 0;

  else
    if(!(req->preview_data.used >= 1))
    {
      *buf = (char)45;
      return 1;
    }

    else
    {
      if(!(param == ((const char *)NULL)))
      {
        signed long int return_value_strtol$1;
        return_value_strtol$1=strtol(param, (char ** restrict )(void *)0, 10);
        num = (signed int)return_value_strtol$1;
      }

      else
        num = 5;
      n = 0;
      i = 0;
      do
      {
        if(!(i >= num))
          tmp_if_expr$2 = i < req->preview_data.used ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!(len >= 1) || !tmp_if_expr$2)
          break;

        _Bool tmp_if_expr$4;
        if((signed int)req->preview_data.buf[(signed long int)i] >= 32)
          tmp_if_expr$4 = (signed int)req->preview_data.buf[(signed long int)i] <= 126 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        if(tmp_if_expr$4)
        {
          signed int tmp_post$3 = n;
          n = n + 1;
          buf[(signed long int)tmp_post$3] = req->preview_data.buf[(signed long int)i];
          len = len - 1;
        }

        else
        {
          bytes=snprintf(buf + (signed long int)n, (unsigned long int)len, "\\x%X", 0xFF & (signed int)buf[(signed long int)i]);
          if(!(len >= bytes))
            bytes = len;

          n = n + bytes;
          len = len - bytes;
        }
        i = i + 1;
      }
      while((_Bool)1);
      return n;
    }
}

// fmt_req_preview_len
// file txt_format.c line 633
signed int fmt_req_preview_len(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf$1;
  if(len == 0)
    return 0;

  else
  {
    if(req->preview >= 0)
    {
      return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%d", req->preview_data.used);
      return return_value_snprintf$1;
    }

    *buf = (char)45;
    return 1;
  }
}

// fmt_request
// file txt_format.c line 365
signed int fmt_request(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  char *s = req->service;
  i = 0;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(i >= len))
      tmp_if_expr$1 = *s != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    buf[(signed long int)i] = *s;
    i = i + 1;
    s = s + 1l;
  }
  while((_Bool)1);
  _Bool tmp_if_expr$2;
  if(!((signed int)req->args[0l] == 0))
  {
    if(!(i >= len))
    {
      buf[(signed long int)i] = (char)63;
      s = req->args;
      i = i + 1;
      do
      {
        if(!(i >= len))
          tmp_if_expr$2 = *s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
    }

  }

  return i;
}

// fmt_seconds
// file txt_format.c line 422
signed int fmt_seconds(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed long int tm;
  time(&tm);
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, (unsigned long int)len, "%ld", tm);
  return return_value_snprintf$1;
}

// fmt_service
// file txt_format.c line 347
signed int fmt_service(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  char *s = req->service;
  i = 0;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(i >= len))
      tmp_if_expr$1 = *s != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    buf[(signed long int)i] = *s;
    i = i + 1;
    s = s + 1l;
  }
  while((_Bool)1);
  return i;
}

// fmt_username
// file txt_format.c line 356
signed int fmt_username(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  char *s = req->user;
  i = 0;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(i >= len))
      tmp_if_expr$1 = *s != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    buf[(signed long int)i] = *s;
    i = i + 1;
    s = s + 1l;
  }
  while((_Bool)1);
  return i;
}

// format_body_chunk
// file request.c line 767
static signed int format_body_chunk(struct ci_request *req)
{
  signed int def_bytes;
  char *wbuf = (char *)(void *)0;
  char tmpbuf[30l];
  if(req->responce_hasbody == 0)
    return -2;

  else
  {
    if(req->remain_send_block_bytes >= 1)
    {
      /* assertion req->remain_send_block_bytes <= 4064 */
      assert(req->remain_send_block_bytes <= 4064);
      req->http_bytes_out = req->http_bytes_out + (unsigned long int)req->remain_send_block_bytes;
      req->body_bytes_out = req->body_bytes_out + (unsigned long int)req->remain_send_block_bytes;
      wbuf = req->wbuf + (signed long int)30 + (signed long int)req->remain_send_block_bytes;
      char *tmp_post$1 = wbuf;
      wbuf = wbuf + 1l;
      *tmp_post$1 = (char)13;
      *wbuf = (char)10;
      def_bytes=snprintf(tmpbuf, (unsigned long int)30, "%x\r\n", req->remain_send_block_bytes);
      wbuf = (req->wbuf + (signed long int)30) - (signed long int)def_bytes;
      memcpy((void *)wbuf, (const void *)tmpbuf, (unsigned long int)def_bytes);
      req->pstrblock_responce = wbuf;
      req->remain_send_block_bytes = req->remain_send_block_bytes + def_bytes + 2;
    }

    else
      if(req->remain_send_block_bytes == -2)
      {
        _Bool tmp_if_expr$2;
        if(req->return_code == 3)
          tmp_if_expr$2 = req->i206_use_original_body >= (signed long int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
        {
          def_bytes=sprintf(req->wbuf, "0; use-original-body=%ld\r\n\r\n", req->i206_use_original_body);
          req->pstrblock_responce = req->wbuf;
          req->remain_send_block_bytes = def_bytes;
        }

        else
        {
          strcpy(req->wbuf, "0\r\n\r\n");
          req->pstrblock_responce = req->wbuf;
          req->remain_send_block_bytes = 5;
        }
        return -2;
      }

    return 1;
  }
}

// fread_line
// file cfg_param.c line 678
signed int fread_line(struct _IO_FILE *f_conf, char *line)
{
  char *return_value_fgets$2;
  return_value_fgets$2=fgets(line, 8192, f_conf);
  if(return_value_fgets$2 == ((char *)NULL))
  {
    signed int return_value_feof$1;
    return_value_feof$1=feof(f_conf);
    if(!(return_value_feof$1 == 0))
    {
      line[(signed long int)0] = (char)0;
      return -1;
    }

    else
      return 0;
  }

  unsigned long int return_value_strlen$5;
  return_value_strlen$5=strlen(line);
  signed int return_value_feof$3;
  if(return_value_strlen$5 >= 8190ul)
  {
    if(!((signed int)line[8190l] == 10))
    {
      do
      {
        return_value_feof$3=feof(f_conf);
        if(!(return_value_feof$3 == 0))
          break;

        signed int return_value_fgetc$4;
        return_value_fgetc$4=fgetc(f_conf);
        if(return_value_fgetc$4 == 10)
          return 1;

      }
      while((_Bool)1);
      return 0;
    }

  }

  return 1;
}

// free_a_buffer
// file decode.c line 203
static void free_a_buffer(void *op, void *ptr)
{
  ci_buffer_free(ptr);
}

// free_args
// file cfg_param.c line 775
void free_args(char **argv)
{
  signed int i;
  if(!(argv == ((char **)NULL)))
  {
    i = 0;
    for( ; !(argv[(signed long int)i] == ((char *)NULL)); i = i + 1)
    {
      free((void *)argv[(signed long int)i]);
      argv[(signed long int)i] = (char *)(void *)0;
    }
    free((void *)argv);
  }

}

// free_auth
// file http_auth.c line 346
void free_auth(struct ci_request *req, void *data)
{
  ;
}

// free_cmp_uint64_data
// file acl.c line 997
void free_cmp_uint64_data(struct ci_request *req, void *param)
{
  ci_buffer_free(param);
}

// free_data_type
// file acl.c line 976
void free_data_type(struct ci_request *req, void *param)
{
  free(param);
}

// free_http_req_header
// file acl.c line 938
void free_http_req_header(struct ci_request *req, void *param)
{
  struct ci_headers_list *heads;
  heads=ci_http_request_headers(req);
  release_header_value(heads, (char *)param);
}

// free_http_resp_header
// file acl.c line 952
void free_http_resp_header(struct ci_request *req, void *param)
{
  struct ci_headers_list *heads;
  heads=ci_http_response_headers(req);
  release_header_value(heads, (char *)param);
}

// free_icap_header
// file acl.c line 911
void free_icap_header(struct ci_request *req, void *param)
{
  struct ci_headers_list *heads = req->request_header;
  release_header_value(heads, (char *)param);
}

// free_icap_response_header
// file acl.c line 925
void free_icap_response_header(struct ci_request *req, void *param)
{
  struct ci_headers_list *heads = req->response_header;
  release_header_value(heads, (char *)param);
}

// free_records_group
// file filetype.c line 167
void free_records_group(struct ci_magic_record *record)
{
  signed int i = 0;
  for( ; !(record->groups[(signed long int)i] == ((char *)NULL)); i = i + 1)
  {
    free((void *)record->groups[(signed long int)i]);
    record->groups[(signed long int)i] = (char *)(void *)0;
  }
}

// free_time_data
// file acl.c line 394
void free_time_data(struct ci_request *req, void *param)
{
  if(CI_DEBUG_LEVEL >= 5)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "free_time_data(req=%p, param=%p)", req, param);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("free_time_data(req=%p, param=%p)", req, param);

  }

  ci_buffer_free(param);
}

// free_user
// file http_auth.c line 306
void free_user(struct ci_request *req, void *data)
{
  ;
}

// get_auth
// file http_auth.c line 335
void * get_auth(struct ci_request *req, char *param)
{
  signed int res;
  res=http_authorize(req, param);
  if(!(res == 1))
    return (void *)0;

  else
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Authenticated user: %s\n", (const void *)req->user);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Authenticated user: %s\n", (const void *)req->user);

    }

    return (void *)req->user;
  }
}

// get_authentication_schema
// file include/module.h line 121
struct http_auth_method * get_authentication_schema(const char *method_name, struct authenticator_module ***authenticators)
{
  signed int method_id;
  struct http_auth_method *method_mod;
  method_mod=find_auth_method_id(method_name, &method_id);
  if(method_mod == ((struct http_auth_method *)NULL))
  {
    *authenticators = (struct authenticator_module **)(void *)0;
    return (struct http_auth_method *)(void *)0;
  }

  else
  {
    *authenticators=get_authenticators_list(&authenticators_hash, method_id);
    return method_mod;
  }
}

// get_authenticators_list
// file module.c line 457
struct authenticator_module ** get_authenticators_list(struct auth_hash *hash, signed int method_id)
{
  if(!(hash->hash_size >= method_id))
    return (struct authenticator_module **)(void *)0;

  else
    return hash->hash[(signed long int)method_id];
}

// get_child_data
// file proc_threads_queues.c line 230
struct child_shared_data * get_child_data(struct childs_queue *q, signed int pid)
{
  signed int i;
  if(q->childs == ((struct child_shared_data *)NULL))
    return (struct child_shared_data *)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= q->size); i = i + 1)
      if((q->childs + (signed long int)i)->pid == pid)
        return &q->childs[(signed long int)i];

    return (struct child_shared_data *)(void *)0;
  }
}

// get_client_ip
// file acl.c line 60
void * get_client_ip(struct ci_request *req, char *param)
{
  return (void *)&req->connection->claddr;
}

// get_content_length
// file acl.c line 980
void * get_content_length(struct ci_request *req, char *param)
{
  struct acl_cmp_uint64_data *clen_p;
  void *return_value_ci_buffer_alloc$1;
  return_value_ci_buffer_alloc$1=ci_buffer_alloc((signed int)sizeof(struct acl_cmp_uint64_data) /*16ul*/ );
  clen_p = (struct acl_cmp_uint64_data *)return_value_ci_buffer_alloc$1;
  signed long int clen;
  clen=ci_http_content_length(req);
  if(!(clen >= 0l))
    return (void *)0;

  else
  {
    clen_p->data = (unsigned long int)clen;
    if((signed int)*param == 61)
      clen_p->operator = 0;

    else
      if((signed int)*param == 62)
        clen_p->operator = 1;

      else
        if((signed int)*param == 60)
          clen_p->operator = 2;

    return (void *)clen_p;
  }
}

// get_data_type
// file acl.c line 961
void * get_data_type(struct ci_request *req, char *param)
{
  signed int type;
  signed int isenc;
  signed int *ret_type;
  type=ci_magic_req_data_type(req, &isenc);
  if(!(type >= 0))
    return (void *)0;

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(unsigned int) /*4ul*/ );
    ret_type = (signed int *)return_value_malloc$1;
    if(ret_type == ((signed int *)NULL))
      return (void *)0;

    else
    {
      *ret_type = type;
      return (void *)ret_type;
    }
  }
}

// get_encaps_type
// file header.c line 573
signed int get_encaps_type(const char *buf, signed int *val, char **endpoint)
{
  signed int return_value_strncmp$2;
  return_value_strncmp$2=strncmp(buf, "req-hdr", (unsigned long int)7);
  if(return_value_strncmp$2 == 0)
  {
    signed long int return_value_strtol$1;
    return_value_strtol$1=strtol(buf + (signed long int)8, endpoint, 10);
    *val = (signed int)return_value_strtol$1;
    return 0;
  }

  signed int return_value_strncmp$4;
  return_value_strncmp$4=strncmp(buf, "res-hdr", (unsigned long int)7);
  if(return_value_strncmp$4 == 0)
  {
    signed long int return_value_strtol$3;
    return_value_strtol$3=strtol(buf + (signed long int)8, endpoint, 10);
    *val = (signed int)return_value_strtol$3;
    return 1;
  }

  signed int return_value_strncmp$6;
  return_value_strncmp$6=strncmp(buf, "req-body", (unsigned long int)8);
  if(return_value_strncmp$6 == 0)
  {
    signed long int return_value_strtol$5;
    return_value_strtol$5=strtol(buf + (signed long int)9, endpoint, 10);
    *val = (signed int)return_value_strtol$5;
    return 2;
  }

  signed int return_value_strncmp$8;
  return_value_strncmp$8=strncmp(buf, "res-body", (unsigned long int)8);
  if(return_value_strncmp$8 == 0)
  {
    signed long int return_value_strtol$7;
    return_value_strtol$7=strtol(buf + (signed long int)9, endpoint, 10);
    *val = (signed int)return_value_strtol$7;
    return 3;
  }

  signed int return_value_strncmp$10;
  return_value_strncmp$10=strncmp(buf, "null-body", (unsigned long int)9);
  if(return_value_strncmp$10 == 0)
  {
    signed long int return_value_strtol$9;
    return_value_strtol$9=strtol(buf + (signed long int)10, endpoint, 10);
    *val = (signed int)return_value_strtol$9;
    return 4;
  }

  return -1;
}

// get_from_queue
// file proc_threads_queues.c line 86
signed int get_from_queue(struct connections_queue *q, struct ci_connection *con)
{
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&q->queue_mtx);
  if(!(return_value_pthread_mutex_lock$1 == 0))
    return -1;

  else
    if(q->used == 0)
    {
      pthread_mutex_unlock(&q->queue_mtx);
      return 0;
    }

    else
    {
      q->used = q->used - 1;
      ci_copy_connection(con, &q->connections[(signed long int)q->used]);
      pthread_mutex_unlock(&q->queue_mtx);
      return 1;
    }
}

// get_header
// file acl.c line 872
const char * get_header(struct ci_headers_list *headers, char *head)
{
  const char *val;
  char *buf;
  signed int i;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(head == ((char *)NULL) || headers == ((struct ci_headers_list *)NULL))
    return (const char *)(void *)0;

  else
  {
    val=ci_headers_value(headers, head);
    if(val == ((const char *)NULL))
      return (const char *)(void *)0;

    else
      if(headers->packed == 0)
        return val;

      else
      {
        void *return_value_ci_buffer_alloc$1;
        return_value_ci_buffer_alloc$1=ci_buffer_alloc(8192);
        buf = (char *)return_value_ci_buffer_alloc$1;
        if(buf == ((char *)NULL))
          return (const char *)(void *)0;

        else
        {
          i = 0;
          do
          {
            if(!(i >= 8191))
              tmp_if_expr$2 = (signed int)*val != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$2 = (_Bool)0;
            if(tmp_if_expr$2)
              tmp_if_expr$3 = (signed int)*val != 13 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$3 = (_Bool)0;
            if(tmp_if_expr$3)
              tmp_if_expr$4 = (signed int)*val != 10 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$4 = (_Bool)0;
            if(!tmp_if_expr$4)
              break;

            buf[(signed long int)i] = *val;
            i = i + 1;
            val = val + 1l;
          }
          while((_Bool)1);
          buf[(signed long int)8191] = (char)0;
          return buf;
        }
      }
  }
}

// get_http_client_ip
// file acl.c line 68
void * get_http_client_ip(struct ci_request *req, char *param)
{
  const struct ci_ip *return_value_ci_http_client_ip$1;
  return_value_ci_http_client_ip$1=ci_http_client_ip(req);
  return (void *)return_value_ci_http_client_ip$1;
}

// get_http_req_header
// file acl.c line 932
void * get_http_req_header(struct ci_request *req, char *param)
{
  struct ci_headers_list *heads;
  heads=ci_http_request_headers(req);
  const char *return_value_get_header$1;
  return_value_get_header$1=get_header(heads, param);
  return (void *)return_value_get_header$1;
}

// get_http_resp_header
// file acl.c line 945
void * get_http_resp_header(struct ci_request *req, char *param)
{
  struct ci_headers_list *heads;
  heads=ci_http_response_headers(req);
  const char *return_value_get_header$1;
  return_value_get_header$1=get_header(heads, param);
  return (void *)return_value_get_header$1;
}

// get_icap_header
// file acl.c line 904
void * get_icap_header(struct ci_request *req, char *param)
{
  struct ci_headers_list *heads = req->request_header;
  const char *return_value_get_header$1;
  return_value_get_header$1=get_header(heads, param);
  return (void *)return_value_get_header$1;
}

// get_icap_response_header
// file acl.c line 918
void * get_icap_response_header(struct ci_request *req, char *param)
{
  struct ci_headers_list *heads = req->response_header;
  const char *return_value_get_header$1;
  return_value_get_header$1=get_header(heads, param);
  return (void *)return_value_get_header$1;
}

// get_method
// file request.c line 304
static signed int get_method(char *buf, char **end)
{
  signed int return_value_strncmp$3;
  return_value_strncmp$3=strncmp(buf, "OPTIONS", (unsigned long int)7);
  signed int return_value_strncmp$2;
  signed int return_value_strncmp$1;
  if(return_value_strncmp$3 == 0)
  {
    *end = buf + (signed long int)7;
    return 0x01;
  }

  else
  {
    return_value_strncmp$2=strncmp(buf, "REQMOD", (unsigned long int)6);
    if(return_value_strncmp$2 == 0)
    {
      *end = buf + (signed long int)6;
      return 0x02;
    }

    else
    {
      return_value_strncmp$1=strncmp(buf, "RESPMOD", (unsigned long int)7);
      if(return_value_strncmp$1 == 0)
      {
        *end = buf + (signed long int)7;
        return 0x04;
      }

      else
      {
        *end = buf;
        return -1;
      }
    }
  }
}

// get_port
// file acl.c line 56
void * get_port(struct ci_request *req, char *param)
{
  return (void *)&req->connection->srvaddr.ci_sin_port;
}

// get_reqtype
// file acl.c line 52
void * get_reqtype(struct ci_request *req, char *param)
{
  _Bool tmp_if_expr$1;
  if(!(req->type >= 5))
    tmp_if_expr$1 = req->type >= 0x01 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  const char *tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = ci_methods[(signed long int)req->type];

  else
    tmp_if_expr$2 = "UNKNOWN";
  return (void *)tmp_if_expr$2;
}

// get_request_options
// file request_common.c line 757
static signed int get_request_options(struct ci_request *req, struct ci_headers_list *h)
{
  const char *pstr;
  pstr=ci_headers_value(h, "Preview");
  if(!(pstr == ((const char *)NULL)))
  {
    signed long int return_value_strtol$1;
    return_value_strtol$1=strtol(pstr, (char ** restrict )(void *)0, 10);
    req->preview = (signed int)return_value_strtol$1;
  }

  else
    req->preview = -1;
  req->allow204 = 0;
  pstr=ci_headers_value(h, "Allow");
  if(!(pstr == ((const char *)NULL)))
  {
    signed long int return_value_strtol$2;
    return_value_strtol$2=strtol(pstr, (char ** restrict )(void *)0, 10);
    if(return_value_strtol$2 == 204l)
      req->allow204 = 1;

  }

  pstr=ci_headers_value(h, "Connection");
  signed int return_value_strncmp$3;
  if(!(pstr == ((const char *)NULL)))
  {
    return_value_strncmp$3=strncmp(pstr, "close", (unsigned long int)5);
    if(return_value_strncmp$3 == 0)
      req->keepalive = 0;

  }

  pstr=ci_headers_value(h, "Transfer-Preview");
  pstr=ci_headers_value(h, "Transfer-Ignore");
  pstr=ci_headers_value(h, "Transfer-Complete");
  return 1;
}

// get_send_body
// file request.c line 907
static signed int get_send_body(struct ci_request *req, signed int parse_only)
{
  char *wchunkdata = (char *)(void *)0;
  char *rchunkdata = (char *)(void *)0;
  signed int ret;
  signed int parse_chunk_ret;
  signed int has_formated_data = 0;
  signed int (*service_io)(char *, signed int *, char *, signed int *, signed int, struct ci_request *);
  signed int action = 0;
  signed int rchunkisfull = 0;
  signed int service_eof = 0;
  signed int wbytes;
  signed int rbytes;
  signed int lock_status;
  signed int no_io;
  if(!(parse_only == 0))
    service_io = mod_null_io;

  else
    service_io = req->current_service_mod->mod_service_io;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  if(service_io == ((signed int (*)(char *, signed int *, char *, signed int *, signed int, struct ci_request *))NULL))
    return -1;

  else
  {
    req->status = 0;
    if(req->pstrblock_read_len == 0)
      action = 0x1;

    ret = 0;
    if(!(action == 0))
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Going to %s/%s data\n", (action & 0x1) != 0 ? "Read" : "-", (action & 0x2) != 0 ? "Write" : "-");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Going to %s/%s data\n", (action & 0x1) != 0 ? "Read" : "-", (action & 0x2) != 0 ? "Write" : "-");

      }

      ret=wait_for_data(req->connection->fd, TIMEOUT, action);
      if(!(ret >= 0))
        goto __CPROVER_DUMP_L55;

      if(!((0x1 & ret) == 0))
      {
        signed int return_value_net_data_read$5;
        return_value_net_data_read$5=net_data_read(req);
        if(return_value_net_data_read$5 == -1)
          return -1;

      }

      if(!((0x2 & ret) == 0))
      {
        if(req->data_locked == 0)
        {
          if(req->status == 0)
            update_send_status(req);

        }

        signed int return_value_send_current_block_data$6;
        return_value_send_current_block_data$6=send_current_block_data(req);
        if(return_value_send_current_block_data$6 == -1)
          return -1;

      }

      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "OK done reading/writing going to process\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("OK done reading/writing going to process\n");

      }

    }

    if(req->data_locked == 0)
    {
      if(req->remain_send_block_bytes == 0)
      {
        signed int return_value_update_send_status$7;
        return_value_update_send_status$7=update_send_status(req);
        if(return_value_update_send_status$7 == -1)
          return -1;

      }

    }

    lock_status = req->data_locked;
    if(!(req->remain_send_block_bytes == 0))
      has_formated_data = 1;

    else
      has_formated_data = 0;
    parse_chunk_ret = 0;
    if(!(req->pstrblock_read_len == 0))
    {
      if(req->write_to_module_pending == 0u)
      {
        parse_chunk_ret=parse_chunk_data(req, &wchunkdata);
        if(parse_chunk_ret == -1)
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Error parsing chunks!\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Error parsing chunks!\n");

          }

          return -1;
        }

        if(parse_chunk_ret == -2)
          req->eof_received = 1;

      }

    }

    _Bool tmp_if_expr$9;
    if(!(wchunkdata == ((char *)NULL)))
      tmp_if_expr$9 = req->write_to_module_pending != 0u ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$9 = (_Bool)0;
    if(tmp_if_expr$9)
      wbytes = (signed int)req->write_to_module_pending;

    else
      wbytes = 0;
    if(req->status == 5 && service_eof == 0)
    {
      if(req->remain_send_block_bytes == 0)
      {
        rchunkdata = req->wbuf + (signed long int)30;
        req->pstrblock_responce = rchunkdata;
        rchunkisfull = 0;
      }

      if(has_formated_data == 0 && 4064 + -req->remain_send_block_bytes >= 1)
        rbytes = 4064 - req->remain_send_block_bytes;

      else
      {
        rchunkisfull = 1;
        rbytes = 0;
      }
    }

    else
      rbytes = 0;
    no_io = 0;
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "get send body: going to write/read: %d/%d bytes\n", wbytes, rbytes);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("get send body: going to write/read: %d/%d bytes\n", wbytes, rbytes);

    }

    signed int return_value;
    return_value=service_io(rchunkdata, &rbytes, wchunkdata, &wbytes, req->eof_received, req);
    if(return_value == -1)
      return -1;

    else
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "get send body: written/read: %d/%d bytes (eof: %d)\n", wbytes, rbytes, req->eof_received);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("get send body: written/read: %d/%d bytes (eof: %d)\n", wbytes, rbytes, req->eof_received);

      }

      no_io = (signed int)(rbytes == 0 && wbytes == 0);
      if(!(wbytes == 0))
      {
        wchunkdata = wchunkdata + (signed long int)wbytes;
        req->write_to_module_pending = req->write_to_module_pending - (unsigned int)wbytes;
      }

      if(rbytes >= 1)
      {
        rchunkdata = rchunkdata + (signed long int)rbytes;
        req->remain_send_block_bytes = req->remain_send_block_bytes + rbytes;
      }

      else
        if(rbytes == -2)
          service_eof = 1;

      _Bool tmp_if_expr$8;
      if(no_io == 0)
        tmp_if_expr$8 = req->pstrblock_read_len != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$8 = (_Bool)0;
      action = 0;
      if(req->write_to_module_pending == 0u)
      {
        action = 0x1;
        wchunkdata = (char *)(void *)0;
      }

      if(req->status == 5)
      {
        if(req->remain_send_block_bytes == 0)
        {
          if(service_eof == 1)
            req->remain_send_block_bytes = -2;

        }

        if(has_formated_data == 0)
        {
          signed int return_value_format_body_chunk$10;
          return_value_format_body_chunk$10=format_body_chunk(req);
          if(return_value_format_body_chunk$10 == -2)
            req->status = 6;

        }

      }

      if(!(req->remain_send_block_bytes == 0))
        action = action | 0x2;

      _Bool tmp_if_expr$2;
      if(req->eof_received == 0)
        tmp_if_expr$2 = (_Bool)1;

      else
      {
        if(!(req->eof_received == 0))
          tmp_if_expr$1 = req->write_to_module_pending != 0u ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr$4;
      if(tmp_if_expr$2)
      {
        if(!(action == 0))
          tmp_if_expr$3 = (_Bool)1;

        else
          tmp_if_expr$3 = lock_status != req->data_locked ? (_Bool)1 : (_Bool)0;
        tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;

    __CPROVER_DUMP_L55:
      ;
      if(!(req->eof_received == 0))
        return 1;

      else
      {
        if(action == 0)
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Bug in the service. Please report to the service author!!!!\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Bug in the service. Please report to the service author!!!!\n");

          }

        }

        else
          if(CI_DEBUG_LEVEL >= 5)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Error reading from network......\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Error reading from network......\n");

          }

        return -1;
      }
    }
  }
}

// get_service
// file acl.c line 48
void * get_service(struct ci_request *req, char *param)
{
  return (void *)req->service;
}

// get_srv_ip
// file acl.c line 64
void * get_srv_ip(struct ci_request *req, char *param)
{
  return (void *)&req->connection->srvaddr;
}

// get_time_data
// file acl.c line 401
void * get_time_data(struct ci_request *req, char *param)
{
  struct acl_time_data *tmd_req;
  void *return_value_ci_buffer_alloc$1;
  return_value_ci_buffer_alloc$1=ci_buffer_alloc((signed int)sizeof(struct acl_time_data) /*12ul*/ );
  tmd_req = (struct acl_time_data *)return_value_ci_buffer_alloc$1;
  struct tm br_tm;
  signed long int tm;
  time(&tm);
  localtime_r(&tm, &br_tm);
  tmd_req->days = (unsigned int)0;
  tmd_req->days = tmd_req->days | (unsigned int)(1 << br_tm.tm_wday);
  tmd_req->start_time = (unsigned int)(br_tm.tm_hour * 60 + br_tm.tm_min);
  tmd_req->end_time = (unsigned int)0;
  return (void *)tmd_req;
}

// get_user
// file acl.c line 44
void * get_user(struct ci_request *req, char *param)
{
  return (void *)req->user;
}

// group_cmp
// file http_auth.c line 276
signed int group_cmp(const void *key1, const void *key2)
{
  const char *group;
  const char *user;
  if(key2 == NULL)
    return -1;

  else
  {
    group = (const char *)key1;
    user = (const char *)key2;
    signed int return_value_check_user_group$1;
    return_value_check_user_group$1=check_user_group(user, group);
    return return_value_check_user_group$1;
  }
}

// group_dup
// file http_auth.c line 258
static void * group_dup(const char *str, struct ci_mem_allocator *allocator)
{
  char *new_s;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  void *return_value;
  return_value=allocator->alloc(allocator, return_value_strlen$1 + (unsigned long int)1);
  new_s = (char *)return_value;
  if(!(new_s == ((char *)NULL)))
    strcpy(new_s, str);

  return (void *)new_s;
}

// group_equal
// file http_auth.c line 286
signed int group_equal(const void *key1, const void *key2)
{
  const char *group;
  const char *user;
  if(key2 == NULL)
    return 0;

  else
  {
    group = (const char *)key1;
    user = (const char *)key2;
    signed int return_value_check_user_group$1;
    return_value_check_user_group$1=check_user_group(user, group);
    return return_value_check_user_group$1;
  }
}

// group_free
// file http_auth.c line 266
static void group_free(void *key, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, key);
}

// group_len
// file http_auth.c line 271
static unsigned long int group_len(const void *key)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen((const char *)key);
  return return_value_strlen$1 + (unsigned long int)1;
}

// group_source_add
// file http_auth.c line 136
signed int group_source_add(const char *table_name, signed int type)
{
  struct group_source *gsrc_indx;
  struct group_source *gsrc;
  if(type >= 2 || !(type >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Non valid group lookup DB type for DB %s! (BUG?)", table_name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Non valid group lookup DB type for DB %s! (BUG?)", table_name);

    }

    return 0;
  }

  else
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct group_source) /*32ul*/ );
    gsrc = (struct group_source *)return_value_malloc$1;
    if(gsrc == ((struct group_source *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error allocating memory/add_group_source!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error allocating memory/add_group_source!\n");

      }

      return 0;
    }

    else
    {
      gsrc->name=strdup(table_name);
      if(gsrc->name == ((char *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error strduping/add_group_source!\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error strduping/add_group_source!\n");

        }

        free((void *)gsrc);
        return 0;
      }

      else
      {
        gsrc->type = type;
        gsrc->db = (struct ci_lookup_table *)(void *)0;
        gsrc->next = (struct group_source *)(void *)0;
        gsrc->db=ci_lookup_table_create(gsrc->name);
        if(gsrc->db == ((struct ci_lookup_table *)NULL))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Error creating lookup table:%s!\n", gsrc->name);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Error creating lookup table:%s!\n", gsrc->name);

          }

          free((void *)gsrc->name);
          free((void *)gsrc);
          return 0;
        }

        else
        {
          void *return_value;
          return_value=gsrc->db->open(gsrc->db);
          if(return_value == NULL)
          {
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error opening lookup table:%s!\n", gsrc->name);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error opening lookup table:%s!\n", gsrc->name);

            }

            ci_lookup_table_destroy(gsrc->db);
            free((void *)gsrc->name);
            free((void *)gsrc);
            return 0;
          }

          else
          {
            if(GROUPS_SOURCE == ((struct group_source *)NULL))
              GROUPS_SOURCE = gsrc;

            else
            {
              gsrc_indx = GROUPS_SOURCE;
              if(!(gsrc_indx->next == ((struct group_source *)NULL)))
                gsrc_indx = gsrc_indx->next;

              gsrc_indx->next = gsrc;
            }
            return 1;
          }
        }
      }
    }
  }
}

// group_source_add_by_group
// file cfg_param.c line 636
signed int group_source_add_by_group(const char *table_name)
{
  signed int return_value_group_source_add$1;
  return_value_group_source_add$1=group_source_add(table_name, 0);
  return return_value_group_source_add$1;
}

// group_source_add_by_user
// file cfg_param.c line 637
signed int group_source_add_by_user(const char *table_name)
{
  signed int return_value_group_source_add$1;
  return_value_group_source_add$1=group_source_add(table_name, 1);
  return return_value_group_source_add$1;
}

// group_source_release
// file http_auth.c line 195
void group_source_release()
{
  struct group_source *gsrc;
  while(!(GROUPS_SOURCE == ((struct group_source *)NULL)))
  {
    gsrc = GROUPS_SOURCE;
    GROUPS_SOURCE = GROUPS_SOURCE->next;
    free((void *)gsrc->name);
    if(!(gsrc->db == ((struct ci_lookup_table *)NULL)))
      ci_lookup_table_destroy(gsrc->db);

    free((void *)gsrc);
  }
}

// groups_add
// file filetype.c line 104
signed int groups_add(struct ci_magics_db *db, const char *name, const char *descr)
{
  struct ci_data_group *newdata;
  signed int indx;
  if(db->groups_num >= db->groups_size)
  {
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)db->groups, (unsigned long int)(db->groups_size + 15) * sizeof(struct ci_data_group) /*67ul*/ );
    newdata = (struct ci_data_group *)return_value_realloc$1;
    if(newdata == ((struct ci_data_group *)NULL))
      return -1;

    db->groups_size = db->groups_size + 15;
    db->groups = newdata;
  }

  indx = db->groups_num;
  db->groups_num = db->groups_num + 1;
  strcpy((db->groups + (signed long int)indx)->name, name);
  strcpy((db->groups + (signed long int)indx)->descr, descr);
  return indx;
}

// groups_init
// file filetype.c line 82
signed int groups_init(struct ci_magics_db *db)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)15 * sizeof(struct ci_data_group) /*67ul*/ );
  db->groups = (struct ci_data_group *)return_value_malloc$1;
  if(db->groups == ((struct ci_data_group *)NULL))
    return 0;

  else
  {
    db->groups_num = 0;
    db->groups_size = 15;
    return 1;
  }
}

// handle_child_process_commands
// file mpmt_server.c line 524
void handle_child_process_commands(char *cmd_line)
{
  struct ci_command *command;
  command=find_command(cmd_line);
  if(!(command == ((struct ci_command *)NULL)))
  {
    if(!((2 & command->type) == 0))
      execute_command(command, cmd_line, 2);

  }

}

// handle_monitor_process_commands
// file mpmt_server.c line 506
void handle_monitor_process_commands(char *cmd_line)
{
  struct ci_command *command;
  signed int i;
  signed int bytes;
  command=find_command(cmd_line);
  if(!(command == ((struct ci_command *)NULL)))
  {
    if(!((1 & command->type) == 0))
      execute_command(command, cmd_line, 1);

    if(!((2 & command->type) == 0))
    {
      i = 0;
      for( ; !(i >= childs_queue->size); i = i + 1)
      {
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(cmd_line);
        signed long int return_value_write$2;
        return_value_write$2=write((childs_queue->childs + (signed long int)i)->pipe, (const void *)cmd_line, return_value_strlen$1);
        bytes = (signed int)return_value_write$2;
      }
    }

    if(!((4 & command->type) == 0))
      execute_command(command, cmd_line, 4);

  }

}

// hash_table_close
// file lookup_file_table.c line 365
void hash_table_close(struct ci_lookup_table *table)
{
  struct text_table *text_table = (struct text_table *)table->data;
  if(!(text_table == ((struct text_table *)NULL)))
  {
    if(!(text_table->hash_table == ((struct ci_hash_table *)NULL)))
    {
      ci_hash_destroy(text_table->hash_table);
      text_table->hash_table = (struct ci_hash_table *)(void *)0;
    }

  }

  file_table_close(table);
}

// hash_table_open
// file lookup_file_table.c line 339
void * hash_table_open(struct ci_lookup_table *table)
{
  struct text_table_entry *e;
  struct text_table *text_table;
  void *return_value_file_table_open$1;
  return_value_file_table_open$1=file_table_open(table);
  text_table = (struct text_table *)return_value_file_table_open$1;
  if(text_table == ((struct text_table *)NULL))
    return (void *)0;

  else
  {
    if(CI_DEBUG_LEVEL >= 7)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Will build a hash for %d rows of data\n", text_table->rows);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Will build a hash for %d rows of data\n", text_table->rows);

    }

    text_table->hash_table=ci_hash_build((unsigned int)text_table->rows, table->key_ops, table->allocator);
    if(text_table->hash_table == ((struct ci_hash_table *)NULL))
    {
      file_table_close(table);
      return (void *)0;
    }

    else
    {
      e = text_table->entries;
      for( ; !(e == ((struct text_table_entry *)NULL)); e = e->next)
        ci_hash_add(text_table->hash_table, e->key, (const void *)e);
      return (void *)text_table;
    }
  }
}

// hash_table_release_result
// file lookup_file_table.c line 396
void hash_table_release_result(struct ci_lookup_table *table_data, void **val)
{
  ;
}

// hash_table_search
// file lookup_file_table.c line 377
void * hash_table_search(struct ci_lookup_table *table, void *key, void ***vals)
{
  struct text_table_entry *e;
  struct text_table *text_table = (struct text_table *)table->data;
  if(text_table == ((struct text_table *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Search a non open hash lookup table?(%s)\n", table->path);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Search a non open hash lookup table?(%s)\n", table->path);

    }

    return (void *)0;
  }

  else
  {
    *vals = (void **)(void *)0;
    const void *return_value_ci_hash_search$1;
    return_value_ci_hash_search$1=ci_hash_search(text_table->hash_table, key);
    e = (struct text_table_entry *)return_value_ci_hash_search$1;
    if(e == ((struct text_table_entry *)NULL))
      return (void *)0;

    else
    {
      *vals = (void **)e->vals;
      return (void *)e->key;
    }
  }
}

// http_authenticate
// file http_auth.c line 59
signed int http_authenticate(struct ci_request *req, char *use_method)
{
  struct http_auth_method *auth_method;
  struct authenticator_module **http_authenticate$$1$$authenticators;
  void *method_data;
  const char *auth_str;
  const char *method_str;
  const char *username;
  char *auth_header = (char *)(void *)0;
  signed int len;
  signed int res;
  if(use_method == ((char *)NULL) && !(ALLOW_REMOTE_PROXY_USERS == 0))
  {
    username=ci_headers_value(req->request_header, REMOTE_PROXY_USER_HEADER);
    if(username == ((const char *)NULL))
      goto __CPROVER_DUMP_L3;

    if(!(REMOTE_PROXY_USER_HEADER_ENCODED == 0))
      ci_base64_decode(username, req->user, 255);

    else
    {
      strncpy(req->user, username, (unsigned long int)255);
      req->user[(signed long int)255] = (char)0;
    }
    return 1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    if(use_method == ((char *)NULL))
      use_method = DEFAULT_AUTH_METHOD;

    auth_method=get_authentication_schema(use_method, &http_authenticate$$1$$authenticators);
    if(auth_method == ((struct http_auth_method *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Authentication method not found ...\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Authentication method not found ...\n");

      }

      return -1;
    }

    else
    {
      res = -1;
      method_str=ci_headers_value(req->request_header, "Proxy-Authorization");
      if(!(method_str == ((const char *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Str is %s ....\n", method_str);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Str is %s ....\n", method_str);

        }

        auth_str=strchr(method_str, 32);
        if(auth_str == ((const char *)NULL))
          return -1;

        len = (signed int)(auth_str - method_str);
        signed int return_value_strncmp$1;
        return_value_strncmp$1=strncmp(method_str, use_method, (unsigned long int)len);
        if(!(return_value_strncmp$1 == 0))
          return -1;

        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Method is %s ....\n", method_str);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Method is %s ....\n", method_str);

        }

        auth_str = auth_str + 1l;
        method_data=auth_method->create_auth_data(auth_str, &username);
        strncpy(req->user, username, (unsigned long int)255);
        req->user[(signed long int)255] = (char)0;
        res=call_authenticators(http_authenticate$$1$$authenticators, method_data);
        auth_method->release_auth_data(method_data);
      }

      if(res == -1)
      {
        auth_header=auth_method->authentication_header();
        ci_headers_add(req->xheaders, auth_header);
        if(!(auth_method->release_authentication_header == ((void (*)())NULL)))
          auth_method->release_authentication_header(auth_header);

        req->auth_required = 1;
        if(CI_DEBUG_LEVEL >= 3)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Access denied. Authentication required!!!!!\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Access denied. Authentication required!!!!!\n");

        }

      }

      return res;
    }
  }
}

// http_authorize
// file http_auth.c line 36
signed int http_authorize(struct ci_request *req, char *method)
{
  signed int return_value_http_authenticate$1;
  return_value_http_authenticate$1=http_authenticate(req, method);
  return return_value_http_authenticate$1;
  if(CI_DEBUG_LEVEL >= 1)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Allowing http_access.....\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Allowing http_access.....\n");

  }

  return 1;
}

// icap_header_check_realloc
// file request.c line 169
static signed int icap_header_check_realloc(char **buf, signed int *size, signed int used, signed int mustadded)
{
  char *newbuf;
  signed int len;
  if(!(*size + -used >= mustadded))
  {
    len = *size + 512;
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)*buf, (unsigned long int)len);
    newbuf = (char *)return_value_realloc$1;
    if(newbuf == ((char *)NULL))
      return 11;

    *buf = newbuf;
    *size = *size + 512;
  }

  return 0;
}

// icap_init_server
// file include/net_io.h line 141
signed int icap_init_server(char *address, signed int port, signed int *protocol_family, signed int secs_to_linger)
{
  signed int fd;
  struct sockaddr_in addr;
  fd=socket(2, 1, 0);
  signed int return_value_inet_pton$1;
  if(fd == -1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error opening socket ....\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error opening socket ....\n");

    }

    return -1;
  }

  else
  {
    icap_socket_opts(fd, secs_to_linger);
    memset((void *)&addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    addr.sin_family = (unsigned short int)2;
    addr.sin_port=htons((unsigned short int)port);
    if(address == ((char *)NULL))
      addr.sin_addr.s_addr = (unsigned int)0x00000000;

    else
    {
      return_value_inet_pton$1=inet_pton(2, address, (void *)&addr.sin_addr.s_addr);
      if(!(return_value_inet_pton$1 == 1))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error converting ipv4 address to the network byte order \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error converting ipv4 address to the network byte order \n");

        }

        close(fd);
        return -1;
      }

    }
    signed int return_value_bind$2;
    return_value_bind$2=bind(fd, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_bind$2 == 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error binding  \n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error binding  \n");

      }

      return -1;
    }

    else
    {
      signed int return_value_listen$3;
      return_value_listen$3=listen(fd, 512);
      if(!(return_value_listen$3 == 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error listening .....\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error listening .....\n");

        }

        return -1;
      }

      else
      {
        *protocol_family = 2;
        return fd;
      }
    }
  }
}

// icap_socket_opts
// file include/net_io.h line 140
signed int icap_socket_opts(signed int fd, signed int secs_to_linger)
{
  struct linger li;
  signed int value = 1;
  signed int return_value_setsockopt$1;
  return_value_setsockopt$1=setsockopt(fd, 1, 2, (const void *)&value, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(return_value_setsockopt$1 == -1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "setsockopt: unable to set SO_REUSEADDR\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("setsockopt: unable to set SO_REUSEADDR\n");

    }

  }

  value = 1;
  signed int return_value_setsockopt$2;
  return_value_setsockopt$2=setsockopt(fd, 6, 1, (const void *)&value, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(return_value_setsockopt$2 == -1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "setsockopt: unable to set TCP_NODELAY\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("setsockopt: unable to set TCP_NODELAY\n");

    }

  }

  li.l_onoff = 1;
  li.l_linger = secs_to_linger;
  signed int return_value_setsockopt$3;
  return_value_setsockopt$3=setsockopt(fd, 1, 13, (const void *)(char *)&li, (unsigned int)sizeof(struct linger) /*8ul*/ );
  if(!(return_value_setsockopt$3 >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "setsockopt: unable to set SO_LINGER \n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("setsockopt: unable to set SO_LINGER \n");

    }

  }

  return 1;
}

// info_check_preview_handler
// file info.c line 134
signed int info_check_preview_handler(char *preview_data, signed int preview_data_len, struct ci_request *req)
{
  struct info_req_data *info_data = (struct info_req_data *)req->service_data;
  if(!(req->hasbody == 0))
    return 204;

  else
  {
    req->data_locked = 0;
    ci_http_response_create(req, 1, 1);
    ci_http_response_add_header(req, "HTTP/1.0 200 OK");
    ci_http_response_add_header(req, "Server: C-ICAP");
    ci_http_response_add_header(req, "Content-Type: text/html");
    ci_http_response_add_header(req, "Content-Language: en");
    ci_http_response_add_header(req, "Connection: close");
    if(!(info_data->body == ((struct ci_membuf *)NULL)))
      build_statistics(info_data);

    return 100;
  }
}

// info_close_service
// file info.c line 85
void info_close_service()
{
  if(CI_DEBUG_LEVEL >= 5)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Service %s shutdown!\n", info_service.mod_name);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Service %s shutdown!\n", info_service.mod_name);

  }

}

// info_end_of_data_handler
// file info.c line 158
signed int info_end_of_data_handler(struct ci_request *req)
{
  return 1;
}

// info_init_request_data
// file info.c line 90
void * info_init_request_data(struct ci_request *req)
{
  struct info_req_data *info_data;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct info_req_data) /*72ul*/ );
  info_data = (struct info_req_data *)return_value_malloc$1;
  info_data->body=ci_membuf_new();
  info_data->childs = 0;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)childs_queue->size * sizeof(signed int) /*4ul*/ );
  info_data->child_pids = (signed int *)return_value_malloc$2;
  info_data->free_servers = 0;
  info_data->used_servers = 0;
  info_data->closing_childs = (unsigned int)0;
  void *return_value_malloc$3;
  return_value_malloc$3=malloc((unsigned long int)childs_queue->size * sizeof(signed int) /*4ul*/ );
  info_data->closing_child_pids = (signed int *)return_value_malloc$3;
  info_data->started_childs = (unsigned int)0;
  info_data->closed_childs = (unsigned int)0;
  info_data->crashed_childs = (unsigned int)0;
  info_data->txt_mode = 0;
  if(!((signed int)req->args[0l] == 0))
  {
    char *return_value_strstr$4;
    return_value_strstr$4=strstr(req->args, "view=text");
    if(!(return_value_strstr$4 == ((char *)NULL)))
      info_data->txt_mode = 1;

  }

  signed int return_value_ci_stat_memblock_size$5;
  return_value_ci_stat_memblock_size$5=ci_stat_memblock_size();
  void *return_value_malloc$6;
  return_value_malloc$6=malloc((unsigned long int)return_value_ci_stat_memblock_size$5);
  info_data->collect_stats = (struct stat_memblock *)return_value_malloc$6;
  info_data->collect_stats->sig = (unsigned int)0xFAFA;
  stat_memblock_fix(info_data->collect_stats);
  ci_stat_memblock_reset(info_data->collect_stats);
  return (void *)info_data;
}

// info_init_service
// file info.c line 78
signed int info_init_service(struct ci_service_xdata *srv_xdata, struct ci_server_conf *server_conf)
{
  ci_service_set_xopts(srv_xdata, (unsigned long int)(8 | 16));
  return 1;
}

// info_io
// file info.c line 163
signed int info_io(char *wbuf, signed int *wlen, char *rbuf, signed int *rlen, signed int iseof, struct ci_request *req)
{
  signed int ret;
  struct info_req_data *info_data = (struct info_req_data *)req->service_data;
  ret = 1;
  if(!(wlen == ((signed int *)NULL)) && !(wbuf == ((char *)NULL)))
  {
    if(!(info_data->body == ((struct ci_membuf *)NULL)))
      *wlen=ci_membuf_read(info_data->body, wbuf, *wlen);

    else
      *wlen = -2;
  }

  return ret;
}

// info_release_request_data
// file info.c line 120
void info_release_request_data(void *data)
{
  struct info_req_data *info_data = (struct info_req_data *)data;
  if(!(info_data->body == ((struct ci_membuf *)NULL)))
    ci_membuf_free(info_data->body);

  if(!(info_data->collect_stats == ((struct stat_memblock *)NULL)))
    free((void *)info_data->collect_stats);

  free((void *)info_data);
}

// init_auth_hash
// file module.c line 432
signed int init_auth_hash(struct auth_hash *hash)
{
  hash->usedsize = 0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)20 * sizeof(struct authenticator_module *) /*8ul*/ );
  hash->hash = (struct authenticator_module ***)return_value_malloc$1;
  if(hash->hash == ((struct authenticator_module ***)NULL))
  {
    hash->hash_size = 20;
    return 0;
  }

  else
  {
    hash->hash_size = 20;
    memset((void *)hash->hash, 0, (unsigned long int)hash->hash_size);
    return 1;
  }
}

// init_body_system
// file aserver.c line 45
signed int init_body_system()
{
  MEMBUF_POOL=ci_object_pool_register("ci_membuf_t", (signed int)sizeof(struct ci_membuf) /*40ul*/ );
  if(!(MEMBUF_POOL >= 0))
    return -1;

  else
  {
    CACHED_FILE_POOL=ci_object_pool_register("ci_cached_file_t", (signed int)sizeof(struct ci_cached_file) /*4152ul*/ );
    if(!(CACHED_FILE_POOL >= 0))
      return -1;

    else
    {
      SIMPLE_FILE_POOL=ci_object_pool_register("ci_simple_file_t", (signed int)sizeof(struct ci_simple_file) /*4184ul*/ );
      if(!(SIMPLE_FILE_POOL >= 0))
        return -1;

      else
      {
        RING_BUF_POOL=ci_object_pool_register("ci_ring_buf_t", (signed int)sizeof(struct ci_ring_buf) /*40ul*/ );
        if(!(RING_BUF_POOL >= 0))
          return -1;

        else
          return 1;
      }
    }
  }
}

// init_child_mutexes
// file os/unix/threads.c line 46
static void init_child_mutexes()
{
  struct mutex_itm *m;
  pthread_mutex_init(&mutexes_lock, (const union anonymous$21 *)(void *)0);
  m = mutexes;
  for( ; !(m == ((struct mutex_itm *)NULL)); m = m->next)
    switch(m->type)
    {
      case 0:
      {
        pthread_mutex_init(m->mtx.mutex, (const union anonymous$21 *)(void *)0);
        break;
      }
      case 1:
        pthread_rwlock_init(m->mtx.rwlock, (const union anonymous$22 *)(void *)0);
    }
}

// init_commands
// file mpmt_server.c line 1036
void init_commands()
{
  register_command("stop", 1, stop_command);
  register_command("reconfigure", 1, reconfigure_command);
  register_command("dump_statistics", 1, dump_statistics_command);
  register_command("test", 1 | 2, test_command);
}

// init_conf_tables
// file aserver.c line 44
void init_conf_tables()
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)10 * sizeof(struct sub_table) /*24ul*/ );
  extra_conf_tables = (struct sub_table *)return_value_malloc$1;
  if(extra_conf_tables == ((struct sub_table *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocating memory...\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocating memory...\n");

    }

  }

  else
    conf_tables_list_size = 10;
}

// init_extra_data
// file service.c line 277
void init_extra_data(struct ci_service_xdata *srv_xdata, const char *service)
{
  char buf[1024l];
  char stat_group[1024l];
  memset((void *)srv_xdata, 0, sizeof(struct ci_service_xdata) /*3768ul*/ );
  ci_thread_rwlock_init(&srv_xdata->lock);
  strcpy(srv_xdata->ISTag, "ISTag: ");
  strcat(srv_xdata->ISTag, "CI0001-XXXXXXXXX");
  memset((void *)srv_xdata->xincludes, 0, (unsigned long int)(511 + 1));
  memset((void *)srv_xdata->TransferPreview, 0, (unsigned long int)(1023 + 1));
  memset((void *)srv_xdata->TransferIgnore, 0, (unsigned long int)(1023 + 1));
  memset((void *)srv_xdata->TransferComplete, 0, (unsigned long int)(1023 + 1));
  srv_xdata->preview_size = 0;
  srv_xdata->allow_204 = 0;
  srv_xdata->allow_206 = 0;
  srv_xdata->disable_206 = 0;
  srv_xdata->max_connections = -1;
  srv_xdata->xopts = (unsigned long int)0;
  srv_xdata->status = -1;
  srv_xdata->options_ttl = -1;
  snprintf(stat_group, (unsigned long int)1023, "Service %s", service);
  stat_group[(signed long int)1023] = (char)0;
  buf[(signed long int)1023] = (char)0;
  snprintf(buf, (unsigned long int)1023, "Service %s REQMODS", service);
  srv_xdata->stat_reqmods=ci_stat_entry_register(buf, 0, stat_group);
  snprintf(buf, (unsigned long int)1023, "Service %s RESPMODS", service);
  srv_xdata->stat_respmods=ci_stat_entry_register(buf, 0, stat_group);
  snprintf(buf, (unsigned long int)1023, "Service %s OPTIONS", service);
  srv_xdata->stat_options=ci_stat_entry_register(buf, 0, stat_group);
  snprintf(buf, (unsigned long int)1023, "Service %s ALLOW 204", service);
  srv_xdata->stat_allow204=ci_stat_entry_register(buf, 0, stat_group);
  snprintf(buf, (unsigned long int)1023, "Service %s BYTES IN", service);
  srv_xdata->stat_bytes_in=ci_stat_entry_register(buf, 1, stat_group);
  snprintf(buf, (unsigned long int)1023, "Service %s BYTES OUT", service);
  srv_xdata->stat_bytes_out=ci_stat_entry_register(buf, 1, stat_group);
  snprintf(buf, (unsigned long int)1023, "Service %s HTTP BYTES IN", service);
  srv_xdata->stat_http_bytes_in=ci_stat_entry_register(buf, 1, stat_group);
  snprintf(buf, (unsigned long int)1023, "Service %s HTTP BYTES OUT", service);
  srv_xdata->stat_http_bytes_out=ci_stat_entry_register(buf, 1, stat_group);
  snprintf(buf, (unsigned long int)1023, "Service %s BODY BYTES IN", service);
  srv_xdata->stat_body_bytes_in=ci_stat_entry_register(buf, 1, stat_group);
  snprintf(buf, (unsigned long int)1023, "Service %s BODY BYTES OUT", service);
  srv_xdata->stat_body_bytes_out=ci_stat_entry_register(buf, 1, stat_group);
}

// init_http_auth
// file aserver.c line 56
void init_http_auth()
{
  ci_acl_type_add(&acl_auth);
  ci_acl_type_add(&acl_group);
}

// init_internal_lookup_tables
// file aserver.c line 53
void init_internal_lookup_tables()
{
  ci_lookup_table_type_register(&file_table_type);
  ci_lookup_table_type_register(&hash_table_type);
  ci_lookup_table_type_register(&regex_table_type);
}

// init_module
// file module.c line 141
static signed int init_module(void *module, enum module_type type)
{
  signed int ret = 0;
  switch((signed int)type)
  {
    case SERVICE_HANDLER:
    {
      if(!(((struct service_handler_module *)module)->init_service_handler == ((signed int (*)(struct ci_server_conf *))NULL)))
        ret=((struct service_handler_module *)module)->init_service_handler(&CI_CONF);

      if(!(((struct service_handler_module *)module)->conf_table == ((struct ci_conf_entry *)NULL)))
        register_conf_table(((struct service_handler_module *)module)->name, ((struct service_handler_module *)module)->conf_table, 1);

      break;
    }
    case LOGGER:
    {
      if(!(((struct logger_module *)module)->init_logger == ((signed int (*)(struct ci_server_conf *))NULL)))
        ret=((struct logger_module *)module)->init_logger(&CI_CONF);

      if(!(((struct logger_module *)module)->conf_table == ((struct ci_conf_entry *)NULL)))
        register_conf_table(((struct logger_module *)module)->name, ((struct logger_module *)module)->conf_table, 1);

      break;
    }
    case ACCESS_CONTROLLER:
    {
      if(!(((struct access_control_module *)module)->init_access_controller == ((signed int (*)(struct ci_server_conf *))NULL)))
        ret=((struct access_control_module *)module)->init_access_controller(&CI_CONF);

      if(!(((struct access_control_module *)module)->conf_table == ((struct ci_conf_entry *)NULL)))
        register_conf_table(((struct access_control_module *)module)->name, ((struct access_control_module *)module)->conf_table, 1);

      break;
    }
    case AUTH_METHOD:
    {
      if(!(((struct http_auth_method *)module)->init_auth_method == ((signed int (*)(struct ci_server_conf *))NULL)))
        ret=((struct http_auth_method *)module)->init_auth_method(&CI_CONF);

      if(!(((struct http_auth_method *)module)->conf_table == ((struct ci_conf_entry *)NULL)))
        register_conf_table(((struct http_auth_method *)module)->name, ((struct http_auth_method *)module)->conf_table, 1);

      break;
    }
    case AUTHENTICATOR:
    {
      if(!(((struct authenticator_module *)module)->init_authenticator == ((signed int (*)(struct ci_server_conf *))NULL)))
        ret=((struct authenticator_module *)module)->init_authenticator(&CI_CONF);

      if(!(((struct authenticator_module *)module)->conf_table == ((struct ci_conf_entry *)NULL)))
        register_conf_table(((struct authenticator_module *)module)->name, ((struct authenticator_module *)module)->conf_table, 1);

      break;
    }
    case COMMON:
    {
      if(!(((struct common_module *)module)->init_module == ((signed int (*)(struct ci_server_conf *))NULL)))
        ret=((struct common_module *)module)->init_module(&CI_CONF);

      if(!(((struct common_module *)module)->conf_table == ((struct ci_conf_entry *)NULL)))
        register_conf_table(((struct common_module *)module)->name, ((struct common_module *)module)->conf_table, 1);

      break;
    }
    default:
      return 0;
  }
  return ret;
}

// init_modules
// file include/module.h line 112
signed int init_modules()
{
  init_auth_hash(&authenticators_hash);
  default_service_handler = &c_service_handler;
  add_to_modules_list(&service_handlers, (void *)default_service_handler);
  default_logger = &file_logger;
  add_to_modules_list(&loggers, (void *)default_logger);
  init_module((void *)&default_acl, (enum module_type)ACCESS_CONTROLLER);
  add_to_modules_list(&access_controllers, (void *)&default_acl);
  init_module((void *)&basic_auth, (enum module_type)AUTH_METHOD);
  add_to_modules_list(&auth_methods, (void *)&basic_auth);
  init_module((void *)&basic_simple_db, (enum module_type)AUTHENTICATOR);
  add_to_modules_list(&authenticators, (void *)&basic_simple_db);
  return 1;
}

// init_pack_allocator
// file mem.c line 661
struct ci_mem_allocator * init_pack_allocator(struct ci_mem_allocator *allocator, struct pack_allocator *pack_alloc, char *memblock, unsigned long int size, signed int free)
{
  unsigned long int tmp_if_expr$1;
  if(!(size == (7 + size & 18446744073709551608)))
    tmp_if_expr$1 = (size - (unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d) + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1);

  else
    tmp_if_expr$1 = size;
  size = tmp_if_expr$1;
  pack_alloc->memchunk = (void *)memblock;
  pack_alloc->curpos = pack_alloc->memchunk;
  pack_alloc->end = pack_alloc->memchunk + (signed long int)size;
  pack_alloc->endpos = pack_alloc->end;
  pack_alloc->must_free = free;
  allocator->alloc = ci_pack_allocator_alloc;
  allocator->free = ci_pack_allocator_free;
  allocator->reset = ci_pack_allocator_reset;
  allocator->destroy = ci_pack_allocator_destroy;
  allocator->data = (void *)pack_alloc;
  allocator->name = (char *)(void *)0;
  allocator->type = 3;
  allocator->must_free = free;
  return allocator;
}

// init_queue
// file proc_threads_queues.c line 31
struct connections_queue * init_queue(signed int size)
{
  signed int ret;
  struct connections_queue *q;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct connections_queue) /*144ul*/ );
  q = (struct connections_queue *)return_value_malloc$1;
  void *return_value_malloc$2;
  if(q == ((struct connections_queue *)NULL))
    return (struct connections_queue *)(void *)0;

  else
  {
    ret=ci_thread_mutex_init(&q->queue_mtx);
    if(ret == 0)
      ret=ci_thread_mutex_init(&q->cond_mtx);

    if(ret == 0)
      ret=ci_thread_cond_init(&q->queue_cond);

    if(ret == 0)
    {
      return_value_malloc$2=malloc((unsigned long int)size * sizeof(struct ci_connection) /*88ul*/ );
      q->connections = (struct ci_connection *)return_value_malloc$2;
      if(!(q->connections == ((struct ci_connection *)NULL)))
      {
        q->size = size;
        q->used = 0;
        return q;
      }

    }

    if(!(q->connections == ((struct ci_connection *)NULL)))
      free((void *)q->connections);

    free((void *)q);
    return (struct connections_queue *)(void *)0;
  }
}

// init_server
// file aserver.c line 47
signed int init_server(char *address, signed int port, signed int *family)
{
  if(!(LISTEN_SOCKET == -1))
    close(LISTEN_SOCKET);

  LISTEN_SOCKET=icap_init_server(address, port, family, MAX_SECS_TO_LINGER);
  if(LISTEN_SOCKET == -1)
    return 0;

  else
    return 1;
}

// init_services
// file include/service.h line 276
signed int init_services()
{
  signed int ret = 0;
  struct ci_service_module *return_value_add_service$1;
  return_value_add_service$1=add_service(&info_service);
  if(!(return_value_add_service$1 == ((struct ci_service_module *)NULL)))
    ret = 1;

  return ret;
}

// int32_cmp
// file types_ops.c line 125
signed int int32_cmp(const void *key1, const void *key2)
{
  signed int k1;
  signed int k2;
  k1 = *((signed int *)key1);
  k2 = *((signed int *)key2);
  if(!(k1 >= k2))
    return -1;

  else
    if(!(k2 >= k1))
      return 1;

    else
      return 0;
}

// int32_dup
// file types_ops.c line 107
void * int32_dup(const char *str, struct ci_mem_allocator *allocator)
{
  signed int *i;
  char *e = (char *)(void *)0;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(signed int) /*4ul*/ );
  i = (signed int *)return_value;
  if(!(i == ((signed int *)NULL)))
  {
    signed long int return_value_strtol$1;
    return_value_strtol$1=strtol(str, &e, 10);
    *i = (signed int)return_value_strtol$1;
    _Bool tmp_if_expr$4;
    if((signed int)*e == 75)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)*e == 107 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      *i = *i * 1000;

    else
    {
      _Bool tmp_if_expr$3;
      if((signed int)*e == 77)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)*e == 109 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        *i = *i * 1000000;

      else
      {
        _Bool tmp_if_expr$2;
        if((signed int)*e == 71)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = (signed int)*e == 103 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          *i = *i * 1000000000;

      }
    }
  }

  return (void *)i;
}

// int32_equal
// file types_ops.c line 138
signed int int32_equal(const void *key1, const void *key2)
{
  signed int k1;
  signed int k2;
  k1 = *((signed int *)key1);
  k2 = *((signed int *)key2);
  return (signed int)(k1 == k2);
}

// int32_free
// file types_ops.c line 151
void int32_free(void *key, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, key);
}

// int32_len
// file types_ops.c line 146
unsigned long int int32_len(const void *key)
{
  return (unsigned long int)4;
}

// intl_cfg_disable
// file cfg_param.c line 1115
signed int intl_cfg_disable(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    cfg_default_value_store(setdata, setdata, (signed int)sizeof(signed int) /*4ul*/ );
    signed int return_value_ci_cfg_disable$1;
    return_value_ci_cfg_disable$1=ci_cfg_disable(directive, argv, setdata);
    return return_value_ci_cfg_disable$1;
  }
}

// intl_cfg_enable
// file cfg_param.c line 1123
signed int intl_cfg_enable(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    cfg_default_value_store(setdata, setdata, (signed int)sizeof(signed int) /*4ul*/ );
    signed int return_value_ci_cfg_enable$1;
    return_value_ci_cfg_enable$1=ci_cfg_enable(directive, argv, setdata);
    return return_value_ci_cfg_enable$1;
  }
}

// intl_cfg_onoff
// file cfg_param.c line 1107
signed int intl_cfg_onoff(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    cfg_default_value_store(setdata, setdata, (signed int)sizeof(signed int) /*4ul*/ );
    signed int return_value_ci_cfg_onoff$1;
    return_value_ci_cfg_onoff$1=ci_cfg_onoff(directive, argv, setdata);
    return return_value_ci_cfg_onoff$1;
  }
}

// intl_cfg_set_int
// file cfg_param.c line 1099
signed int intl_cfg_set_int(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    cfg_default_value_store(setdata, setdata, (signed int)sizeof(signed int) /*4ul*/ );
    signed int return_value_ci_cfg_set_int$1;
    return_value_ci_cfg_set_int$1=ci_cfg_set_int(directive, argv, setdata);
    return return_value_ci_cfg_set_int$1;
  }
}

// intl_cfg_set_str
// file cfg_param.c line 1090
signed int intl_cfg_set_str(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    cfg_default_value_store(setdata, setdata, (signed int)sizeof(char *) /*8ul*/ );
    signed int return_value_ci_cfg_set_str$1;
    return_value_ci_cfg_set_str$1=ci_cfg_set_str(directive, argv, setdata);
    return return_value_ci_cfg_set_str$1;
  }
}

// intl_cfg_size_long
// file cfg_param.c line 1139
signed int intl_cfg_size_long(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    cfg_default_value_store(setdata, setdata, (signed int)sizeof(signed long int) /*8ul*/ );
    signed int return_value_ci_cfg_size_long$1;
    return_value_ci_cfg_size_long$1=ci_cfg_size_long(directive, argv, setdata);
    return return_value_ci_cfg_size_long$1;
  }
}

// intl_cfg_size_off
// file cfg_param.c line 1131
signed int intl_cfg_size_off(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    cfg_default_value_store(setdata, setdata, (signed int)sizeof(signed long int) /*8ul*/ );
    signed int return_value_ci_cfg_size_off$1;
    return_value_ci_cfg_size_off$1=ci_cfg_size_off(directive, argv, setdata);
    return return_value_ci_cfg_size_off$1;
  }
}

// ip_cmp
// file types_ops.c line 520
signed int ip_cmp(const void *ref_key, const void *key_check)
{
  return 0;
}

// ip_dup
// file types_ops.c line 448
void * ip_dup(const char *value, struct ci_mem_allocator *allocator)
{
  signed int socket_family;
  signed int len;
  struct ci_ip *ip;
  char str_addr[17l];
  char str_netmask[17l];
  char *pstr;
  struct in_addr address;
  struct in_addr netmask;
  address.s_addr = (unsigned int)0;
  netmask.s_addr = (unsigned int)0;
  socket_family = 2;
  pstr=strchr(value, 47);
  if(!(pstr == ((char *)NULL)))
  {
    len = (signed int)(pstr - value);
    if(len >= 16)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Invalid ip address (len>%d): %s\n", 16, value);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Invalid ip address (len>%d): %s\n", 16, value);

      }

      return (void *)0;
    }

    strncpy(str_addr, value, (unsigned long int)len);
    str_addr[(signed long int)len] = (char)0;
    signed int return_value_ci_inet_aton$1;
    return_value_ci_inet_aton$1=ci_inet_aton(socket_family, str_addr, (void *)&address);
    if(return_value_ci_inet_aton$1 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Invalid ip address in network %s definition\n", value);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Invalid ip address in network %s definition\n", value);

      }

      return (void *)0;
    }

    strncpy(str_netmask, pstr + (signed long int)1, (unsigned long int)16);
    str_netmask[(signed long int)16] = (char)0;
    signed int return_value_ci_inet_aton$2;
    return_value_ci_inet_aton$2=ci_inet_aton(socket_family, str_netmask, (void *)&netmask);
    if(return_value_ci_inet_aton$2 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Invalid netmask in network %s definition\n", value);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Invalid netmask in network %s definition\n", value);

      }

      return (void *)0;
    }

  }

  else
  {
    signed int return_value_ci_inet_aton$3;
    return_value_ci_inet_aton$3=ci_inet_aton(socket_family, value, (void *)&address);
    if(return_value_ci_inet_aton$3 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Invalid ip address: %s\n", value);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Invalid ip address: %s\n", value);

      }

      return (void *)0;
    }

    netmask.s_addr=htonl(0xFFFFFFFF);
  }
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(struct ci_ip) /*12ul*/ );
  ip = (struct ci_ip *)return_value;
  ip->family = socket_family;
  ip->address = address;
  ip->netmask = netmask;
  return (void *)ip;
}

// ip_equal
// file types_ops.c line 525
signed int ip_equal(const void *ref_key, const void *key_check)
{
  const struct ci_ip *ip_ref = (const struct ci_ip *)ref_key;
  const struct ci_ip *ip_check = (const struct ci_ip *)key_check;
  char buf[128l];
  char buf1[128l];
  char buf2[128l];
  const char *return_value_ci_inet_ntoa$1;
  const char *return_value_ci_inet_ntoa$2;
  const char *return_value_ci_inet_ntoa$3;
  const char *return_value_ci_inet_ntoa$4;
  const char *return_value_ci_inet_ntoa$5;
  const char *return_value_ci_inet_ntoa$6;
  if(ip_check == ((const struct ci_ip *)NULL))
    return 0;

  else
  {
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value_ci_inet_ntoa$1=ci_inet_ntoa(ip_check->family, (const void *)&ip_check->address, buf, 128);
        return_value_ci_inet_ntoa$2=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->address, buf1, 128);
        return_value_ci_inet_ntoa$3=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->netmask, buf2, 128);
        __log_error((void *)0, "going to check addresses  ip address: %s %s/%s\n", return_value_ci_inet_ntoa$1, return_value_ci_inet_ntoa$2, return_value_ci_inet_ntoa$3);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value_ci_inet_ntoa$4=ci_inet_ntoa(ip_check->family, (const void *)&ip_check->address, buf, 128);
        return_value_ci_inet_ntoa$5=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->address, buf1, 128);
        return_value_ci_inet_ntoa$6=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->netmask, buf2, 128);
        printf("going to check addresses  ip address: %s %s/%s\n", return_value_ci_inet_ntoa$4, return_value_ci_inet_ntoa$5, return_value_ci_inet_ntoa$6);
      }

    }

    return (signed int)((ip_ref->address.s_addr & ip_ref->netmask.s_addr) == (ip_check->address.s_addr & ip_ref->netmask.s_addr));
  }
}

// ip_free
// file types_ops.c line 511
void ip_free(void *data, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, data);
}

// ip_len
// file types_ops.c line 515
unsigned long int ip_len(const void *key)
{
  return sizeof(struct ci_ip) /*12ul*/ ;
}

// ip_sockaddr_cmp
// file types_ops.c line 556
signed int ip_sockaddr_cmp(const void *ref_key, const void *key_check)
{
  return 1;
}

// ip_sockaddr_equal
// file types_ops.c line 561
signed int ip_sockaddr_equal(const void *ref_key, const void *key_check)
{
  const struct ci_ip *ip_ref = (const struct ci_ip *)ref_key;
  const struct ci_sockaddr *ip_check = (const struct ci_sockaddr *)key_check;
  char buf[128l];
  char buf1[128l];
  char buf2[128l];
  const char *return_value_ci_inet_ntoa$1;
  const char *return_value_ci_inet_ntoa$2;
  const char *return_value_ci_inet_ntoa$3;
  const char *return_value_ci_inet_ntoa$4;
  const char *return_value_ci_inet_ntoa$5;
  const char *return_value_ci_inet_ntoa$6;
  if(ip_check == ((const struct ci_sockaddr *)NULL))
    return 0;

  else
  {
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value_ci_inet_ntoa$1=ci_inet_ntoa(ip_check->ci_sin_family, ip_check->ci_sin_addr, buf, 128);
        return_value_ci_inet_ntoa$2=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->address, buf1, 128);
        return_value_ci_inet_ntoa$3=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->netmask, buf2, 128);
        __log_error((void *)0, "going to check addresses  ip address: %s %s/%s\n", return_value_ci_inet_ntoa$1, return_value_ci_inet_ntoa$2, return_value_ci_inet_ntoa$3);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value_ci_inet_ntoa$4=ci_inet_ntoa(ip_check->ci_sin_family, ip_check->ci_sin_addr, buf, 128);
        return_value_ci_inet_ntoa$5=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->address, buf1, 128);
        return_value_ci_inet_ntoa$6=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->netmask, buf2, 128);
        printf("going to check addresses  ip address: %s %s/%s\n", return_value_ci_inet_ntoa$4, return_value_ci_inet_ntoa$5, return_value_ci_inet_ntoa$6);
      }

    }

    return (signed int)((ip_ref->address.s_addr & ip_ref->netmask.s_addr) == (((struct in_addr *)ip_check->ci_sin_addr)->s_addr & ip_ref->netmask.s_addr));
  }
}

// isUTF8
// file filetype.c line 439
signed int isUTF8(unsigned char *c, signed int size)
{
  signed int i;
  signed int r_size = 0;
  unsigned int ucs_c = (unsigned int)0;
  if((signed int)text_chars[(signed long int)(signed int)*c] == 1)
    return 1;

  else
  {
    if((0xE0 & (signed int)*c) == 0xC0)
    {
      ucs_c = (unsigned int)((signed int)*c & 0x1F);
      r_size = 2;
    }

    else
      if((0xF0 & (signed int)*c) == 0xE0)
      {
        ucs_c = (unsigned int)((signed int)*c & 0x0F);
        r_size = 3;
      }

      else
        if((0xF8 & (signed int)*c) == 0xF0)
        {
          ucs_c = (unsigned int)((signed int)*c & 0x07);
          r_size = 4;
        }

        else
          if((0xFC & (signed int)*c) == 0xF8)
          {
            ucs_c = (unsigned int)((signed int)*c & 0x03);
            r_size = 5;
          }

          else
            if((0xFE & (signed int)*c) == 0xFC)
            {
              ucs_c = (unsigned int)((signed int)*c & 0x01);
              r_size = 6;
            }

    if(r_size == 0)
      return 0;

    else
    {
      i = 1;
      for( ; !(i >= r_size) && !(i >= size); i = i + 1)
      {
        if(!((0xC0 & (signed int)c[(signed long int)i]) == 0x80))
          return 0;

        ucs_c = ucs_c << 6 | (unsigned int)((signed int)c[(signed long int)i] & 0x3F);
      }
      if(!(i >= r_size))
        return -1;

      else
        if(utf_boundaries[(signed long int)r_size] >= ucs_c)
          return 0;

        else
          if(ucs_c == 65534u || ucs_c == 65535u || ucs_c >= 55296u && !(ucs_c >= 57344u))
            return 0;

          else
            return r_size;
    }
  }
}

// is_icap_running
// file aserver.c line 51
signed int is_icap_running(char *pidfile)
{
  signed int fd;
  signed int bytes;
  signed int ret;
  signed int pid;
  char strPid[30l];
  pid=getpid();
  fd=open64(pidfile, 00, 0644);
  if(!(fd >= 0))
    return 0;

  else
  {
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)strPid, sizeof(char [30l]) /*30ul*/ );
    bytes = (signed int)return_value_read$1;
    close(fd);
    if(!(bytes >= 0))
      return 0;

    else
    {
      if(!((unsigned long int)bytes >= 29ul))
        strPid[(signed long int)bytes] = (char)0;

      else
        strPid[(signed long int)(sizeof(char [30l]) /*30ul*/  - (unsigned long int)1)] = (char)0;
      signed long int return_value_strtol$2;
      return_value_strtol$2=strtol(strPid, (char ** restrict )(void *)0, 10);
      pid = (signed int)return_value_strtol$2;
      if(!(pid >= 1))
        return 0;

      else
      {
        ret=kill(pid, 0);
        if(!(ret >= 0))
          return 0;

        else
          return 1;
      }
    }
  }
}

// keepalive_request
// file request.c line 144
signed int keepalive_request(struct ci_request *req)
{
  char *pstrblock = req->pstrblock_read;
  signed int pstrblock_len = req->pstrblock_read_len;
  ci_request_reset(req);
  if(!(PIPELINING == 0))
  {
    req->pstrblock_read = pstrblock;
    req->pstrblock_read_len = pstrblock_len;
  }

  if(!(req->pstrblock_read == ((char *)NULL)))
  {
    if(!(req->pstrblock_read_len >= 1))
      goto __CPROVER_DUMP_L2;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    signed int return_value_ci_wait_for_data$1;
    return_value_ci_wait_for_data$1=ci_wait_for_data(req->connection->fd, KEEPALIVE_TIMEOUT, 0x1);
    return return_value_ci_wait_for_data$1;
  }
}

// kill_all_childs
// file mpmt_server.c line 321
static void kill_all_childs()
{
  signed int childs_running;
  if(CI_DEBUG_LEVEL >= 5)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Going to term children....\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Going to term children....\n");

  }

  childs_running = 0;
  do
  {
    send_term_to_childs(childs_queue);
    if(!(old_childs_queue == ((struct childs_queue *)NULL)))
      send_term_to_childs(old_childs_queue);

    ci_usleep((unsigned long int)30000);
    wait_childs_to_exit(childs_queue);
    signed int return_value_childs_queue_is_empty$1;
    return_value_childs_queue_is_empty$1=childs_queue_is_empty(childs_queue);
    childs_running = (signed int)!(return_value_childs_queue_is_empty$1 != 0);
    if(!(old_childs_queue == ((struct childs_queue *)NULL)))
    {
      wait_childs_to_exit(old_childs_queue);
      signed int return_value_childs_queue_is_empty$2;
      return_value_childs_queue_is_empty$2=childs_queue_is_empty(old_childs_queue);
      childs_running = childs_running + (signed int)!(return_value_childs_queue_is_empty$2 != 0);
    }

  }
  while(!(childs_running == 0));
  ci_proc_mutex_destroy(&accept_mutex);
  destroy_childs_queue(childs_queue);
  childs_queue = (struct childs_queue *)(void *)0;
  if(!(old_childs_queue == ((struct childs_queue *)NULL)))
    destroy_childs_queue(old_childs_queue);

  old_childs_queue = (struct childs_queue *)(void *)0;
}

// list_alloc_item
// file array.c line 562
static struct ci_list_item * list_alloc_item(struct ci_list *list, const void *data)
{
  struct ci_list_item *it;
  if(!(list->trash == ((struct ci_list_item *)NULL)))
  {
    it = list->trash;
    list->trash = list->trash->next;
  }

  else
  {
    void *return_value;
    return_value=list->alloc->alloc(list->alloc, sizeof(struct ci_list_item) /*16ul*/ );
    it = (struct ci_list_item *)return_value;
    if(it == ((struct ci_list_item *)NULL))
      return (struct ci_list_item *)(void *)0;

    if(!(list->obj_size == 0ul))
    {
      it->item=list->alloc->alloc(list->alloc, list->obj_size);
      if(it->item == NULL)
        return (struct ci_list_item *)(void *)0;

    }

  }
  it->next = (struct ci_list_item *)(void *)0;
  if(!(list->obj_size == 0ul))
  {
    memcpy(it->item, data, list->obj_size);
    if(!(list->copy_func == ((signed int (*)(void *, const void *))NULL)))
      list->copy_func(it->item, data);

  }

  else
    it->item = data;
  return it;
}

// listener_thread
// file mpmt_server.c line 685
void listener_thread(signed int *fd)
{
  struct ci_connection conn;
  unsigned int claddrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  signed int haschild = 1;
  signed int jobs_in_queue = 0;
  signed int pid;
  signed int sockfd = *fd;
  thread_signals(1);
  pthread_mutex_lock(&counters_mtx);
  listener_running = 1;
  pthread_cond_wait(&free_server_cond, &counters_mtx);
  pthread_mutex_unlock(&counters_mtx);
  pid=getpid();
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  signed int *return_value___errno_location$7;
  signed int *return_value___errno_location$8;
  signed int *return_value___errno_location$5;
  signed int *return_value___errno_location$15;
  signed int *return_value___errno_location$13;
  signed int *return_value___errno_location$14;
  signed int *return_value___errno_location$17;
  signed int *return_value___errno_location$18;
  signed int *return_value___errno_location$10;
  _Bool tmp_if_expr$11;
  signed int return_value_ci_proc_mutex_unlock$21;
  signed int *return_value___errno_location$22;
  signed int *return_value___errno_location$23;
  while((_Bool)1)
  {
    if(!(child_data->to_be_killed == 0))
    {
      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Listener of pid:%d exiting!\n", pid);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Listener of pid:%d exiting!\n", pid);

      }

      goto LISTENER_FAILS_UNLOCKED;
    }

    signed int return_value_ci_proc_mutex_lock$4;
    return_value_ci_proc_mutex_lock$4=ci_proc_mutex_lock(&accept_mutex);
    if(return_value_ci_proc_mutex_lock$4 == 0)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      if(*return_value___errno_location$3 == 4)
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "proc_mutex_lock interrupted (EINTR received, pid=%d)!\n", pid);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("proc_mutex_lock interrupted (EINTR received, pid=%d)!\n", pid);

        }

        continue;
      }

      else
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value___errno_location$1=__errno_location();
            __log_error((void *)0, "Unknown errno %d in proc_mutex_lock of pid %d. Exiting!\n", *return_value___errno_location$1, pid);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value___errno_location$2=__errno_location();
            printf("Unknown errno %d in proc_mutex_lock of pid %d. Exiting!\n", *return_value___errno_location$2, pid);
          }

        }

        break;
      }
    }

    child_data->idle = 0;
    if(CI_DEBUG_LEVEL >= 7)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Child %d getting requests now ...\n", pid);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Child %d getting requests now ...\n", pid);

    }

    do
    {
      struct anonymous$19 fds;
      signed int ret;
      do
      {

      __CPROVER_DUMP_L15:
        ;
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$19) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->fds_bits[(signed long int)0]) : "memory");
        (&fds)->fds_bits[(signed long int)(sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->fds_bits[(signed long int)(sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sockfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        *return_value___errno_location$6 = 0;
        ret=select(sockfd + 1, &fds, (struct anonymous$19 *)(void *)0, (struct anonymous$19 *)(void *)0, (struct timeval *)(void *)0);
        if(!(ret >= 0))
        {
          signed int *return_value___errno_location$9;
          return_value___errno_location$9=__errno_location();
          if(!(*return_value___errno_location$9 == 4))
          {
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              {
                return_value___errno_location$7=__errno_location();
                __log_error((void *)0, "Error in select %d! Exiting server!\n", *return_value___errno_location$7);
              }

              if(!(CI_DEBUG_STDOUT == 0))
              {
                return_value___errno_location$8=__errno_location();
                printf("Error in select %d! Exiting server!\n", *return_value___errno_location$8);
              }

            }

            goto LISTENER_FAILS;
          }

          if(!(child_data->to_be_killed == 0))
          {
            if(CI_DEBUG_LEVEL >= 5)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Listener server signalled to exit!\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Listener server signalled to exit!\n");

            }

            goto LISTENER_FAILS;
          }

        }

        return_value___errno_location$5=__errno_location();
      }
      while(*return_value___errno_location$5 == 4);
      do
      {
        signed int *return_value___errno_location$12;
        return_value___errno_location$12=__errno_location();
        *return_value___errno_location$12 = 0;
        claddrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        conn.fd=accept(sockfd, (struct sockaddr *)&conn.claddr.sockaddr, &claddrlen);
        if(conn.fd == -1)
        {
          signed int *return_value___errno_location$16;
          return_value___errno_location$16=__errno_location();
          if(!(*return_value___errno_location$16 == 4))
          {
            return_value___errno_location$15=__errno_location();
            if(!(*return_value___errno_location$15 == 103))
            {
              if(CI_DEBUG_LEVEL >= 1)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                {
                  return_value___errno_location$13=__errno_location();
                  __log_error((void *)0, "Error accept %d!\nExiting server!\n", *return_value___errno_location$13);
                }

                if(!(CI_DEBUG_STDOUT == 0))
                {
                  return_value___errno_location$14=__errno_location();
                  printf("Error accept %d!\nExiting server!\n", *return_value___errno_location$14);
                }

              }

              goto LISTENER_FAILS;
            }

          }

          signed int *return_value___errno_location$19;
          return_value___errno_location$19=__errno_location();
          _Bool tmp_if_expr$20;
          if(*return_value___errno_location$19 == 4)
            tmp_if_expr$20 = child_data->to_be_killed != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$20 = (_Bool)0;
          if(tmp_if_expr$20)
          {
            if(CI_DEBUG_LEVEL >= 5)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Listener server signalled to exit!\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Listener server signalled to exit!\n");

            }

            goto LISTENER_FAILS;
          }

          else
            if(CI_DEBUG_LEVEL >= 2)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              {
                return_value___errno_location$17=__errno_location();
                __log_error((void *)0, "Accept failed: errno=%d, ingore!\n", *return_value___errno_location$17);
              }

              if(!(CI_DEBUG_STDOUT == 0))
              {
                return_value___errno_location$18=__errno_location();
                printf("Accept failed: errno=%d, ingore!\n", *return_value___errno_location$18);
              }

            }

        }

        return_value___errno_location$10=__errno_location();
        if(*return_value___errno_location$10 == 4)
          tmp_if_expr$11 = !(child_data->to_be_killed != 0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$11 = (_Bool)0;
      }
      while(tmp_if_expr$11);
      if(conn.fd >= 0)
      {
        claddrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        getsockname(conn.fd, (struct sockaddr *)&conn.srvaddr.sockaddr, &claddrlen);
        ci_fill_sockaddr(&conn.claddr);
        ci_fill_sockaddr(&conn.srvaddr);
        icap_socket_opts(sockfd, MAX_SECS_TO_LINGER);
        jobs_in_queue=put_to_queue(con_queue, &conn);
        if(jobs_in_queue == 0)
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "ERROR!!!!!! NO AVAILABLE SERVERS! THIS IS A BUG!!!!!!!!\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("ERROR!!!!!! NO AVAILABLE SERVERS! THIS IS A BUG!!!!!!!!\n");

          }

          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Jobs in Queue: %d, Free servers: %d, Used Servers: %d, Requests: %d\n", jobs_in_queue, child_data->freeservers, child_data->usedservers, child_data->requests);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Jobs in Queue: %d, Free servers: %d, Used Servers: %d, Requests: %d\n", jobs_in_queue, child_data->freeservers, child_data->usedservers, child_data->requests);

          }

          goto LISTENER_FAILS;
        }

        child_data->connections = child_data->connections + 1;
        if(!(child_data->to_be_killed == 0))
        {
          if(CI_DEBUG_LEVEL >= 5)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Listener server must exit!\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Listener server must exit!\n");

          }

          goto LISTENER_FAILS;
        }

        pthread_mutex_lock(&counters_mtx);
        haschild = child_data->freeservers - jobs_in_queue > 0 ? 1 : 0;
        pthread_mutex_unlock(&counters_mtx);
      }

    }
    while(!(haschild == 0));
    if(CI_DEBUG_LEVEL >= 7)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Child %d STOPS getting requests now ...\n", pid);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Child %d STOPS getting requests now ...\n", pid);

    }

    child_data->idle = 1;
    do
    {
      return_value_ci_proc_mutex_unlock$21=ci_proc_mutex_unlock(&accept_mutex);
      if(!(return_value_ci_proc_mutex_unlock$21 == 0))
        break;

      signed int *return_value___errno_location$24;
      return_value___errno_location$24=__errno_location();
      if(!(*return_value___errno_location$24 == 4))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value___errno_location$22=__errno_location();
            __log_error((void *)0, "Error:%d while trying to unlock proc_mutex, exiting listener of server:%d\n", *return_value___errno_location$22, pid);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value___errno_location$23=__errno_location();
            printf("Error:%d while trying to unlock proc_mutex, exiting listener of server:%d\n", *return_value___errno_location$23, pid);
          }

        }

        goto LISTENER_FAILS_UNLOCKED;
      }

      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Mutex lock interrupted while trying to unlock proc_mutex, pid: %d\n", pid);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Mutex lock interrupted while trying to unlock proc_mutex, pid: %d\n", pid);

      }

    }
    while((_Bool)1);
    pthread_mutex_lock(&counters_mtx);
    if(!(child_data->freeservers + -con_queue->used >= 1))
    {
      if(CI_DEBUG_LEVEL >= 7)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Child %d waiting for a thread to accept more connections ...\n", pid);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Child %d waiting for a thread to accept more connections ...\n", pid);

      }

      pthread_cond_wait(&free_server_cond, &counters_mtx);
    }

    pthread_mutex_unlock(&counters_mtx);
  }

LISTENER_FAILS_UNLOCKED:
  ;
  listener_running = 0;
  goto __CPROVER_DUMP_L74;

LISTENER_FAILS:
  ;
  listener_running = 0;
  signed int *return_value___errno_location$25;
  return_value___errno_location$25=__errno_location();
  *return_value___errno_location$25 = 0;
  signed int return_value_ci_proc_mutex_unlock$26;
  signed int *return_value___errno_location$27;
  signed int *return_value___errno_location$28;
  do
  {
    return_value_ci_proc_mutex_unlock$26=ci_proc_mutex_unlock(&accept_mutex);
    if(!(return_value_ci_proc_mutex_unlock$26 == 0))
      break;

    signed int *return_value___errno_location$29;
    return_value___errno_location$29=__errno_location();
    if(!(*return_value___errno_location$29 == 4))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value___errno_location$27=__errno_location();
          __log_error((void *)0, "Error:%d while trying to unlock proc_mutex of server:%d\n", *return_value___errno_location$27, pid);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value___errno_location$28=__errno_location();
          printf("Error:%d while trying to unlock proc_mutex of server:%d\n", *return_value___errno_location$28, pid);
        }

      }

      break;
    }

    if(CI_DEBUG_LEVEL >= 7)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Mutex lock interrupted while trying to unlock proc_mutex before terminating\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Mutex lock interrupted while trying to unlock proc_mutex before terminating\n");

    }

  }
  while((_Bool)1);
  goto __CPROVER_DUMP_L74;

__CPROVER_DUMP_L74:
  ;
}

// load_c_service
// file service.c line 606
struct ci_service_module * load_c_service(const char *service_file)
{
  struct ci_service_module *service = (struct ci_service_module *)(void *)0;
  void *service_handle;
  service_handle=ci_module_load(service_file, CI_CONF.SERVICES_DIR);
  if(service_handle == NULL)
    return (struct ci_service_module *)(void *)0;

  else
  {
    void *return_value_ci_module_sym$1;
    return_value_ci_module_sym$1=ci_module_sym(service_handle, "service");
    service = (struct ci_service_module *)return_value_ci_module_sym$1;
    if(service == ((struct ci_service_module *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Not found symbol \"service\" in library, unload it\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Not found symbol \"service\" in library, unload it\n");

      }

      ci_module_unload(service_handle, service_file);
      return (struct ci_service_module *)(void *)0;
    }

    else
    {
      const char *tmp_if_expr$2;
      if(!(service->mod_name == ((const char *)NULL)))
        tmp_if_expr$2 = service->mod_name;

      else
        tmp_if_expr$2 = "";
      ci_dlib_entry(tmp_if_expr$2, service_file, service_handle);
      return service;
    }
  }
}

// load_module
// file module.c line 69
void * load_module(const char *module_file)
{
  void *module = (void *)0;
  void *module_handle;
  module_handle=ci_module_load(module_file, CI_CONF.MODULES_DIR);
  if(module_handle == NULL)
    return (void *)0;

  else
  {
    module=ci_module_sym(module_handle, "module");
    if(module == NULL)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Symbol \"module\" not found in library; unload it\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Symbol \"module\" not found in library; unload it\n");

      }

      ci_module_unload(module_handle, module_file);
      return (void *)0;
    }

    else
    {
      ci_dlib_entry("module", module_file, module_handle);
      return module;
    }
  }
}

// load_text_table
// file lookup_file_table.c line 205
signed int load_text_table(char *filename, struct ci_lookup_table *table)
{
  struct _IO_FILE *f;
  struct text_table_entry *e;
  struct text_table_entry *l = (struct text_table_entry *)(void *)0;
  signed int rows;
  signed int ret;
  struct text_table *text_table = (struct text_table *)table->data;
  f=fopen64(filename, "r");
  if(f == ((struct _IO_FILE *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error opening file: %s\n", filename);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error opening file: %s\n", filename);

    }

    return 0;
  }

  else
  {
    rows = 0;
    if(!(text_table->entries == ((struct text_table_entry *)NULL)))
    {
      l = text_table->entries;
      for( ; !(l->next == ((struct text_table_entry *)NULL)); l = l->next)
        ;
    }

    do
    {
      ret=read_row(f, table->cols, &e, table);
      if(!(ret >= 1))
        break;

      if(!(e == ((struct text_table_entry *)NULL)))
      {
        e->next = (struct text_table_entry *)(void *)0;
        if(text_table->entries == ((struct text_table_entry *)NULL))
        {
          text_table->entries = e;
          l = e;
        }

        else
        {
          l->next = e;
          l = e;
        }
      }

      rows = rows + 1;
    }
    while((_Bool)1);
    fclose(f);
    if(ret == -1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error loading file table %s: parse error on line %d\n", filename, rows + 1);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error loading file table %s: parse error on line %d\n", filename, rows + 1);

      }

      file_table_close(table);
      return 0;
    }

    else
    {
      text_table->rows = rows;
      return 1;
    }
  }
}

// log_access
// file log.c line 64
void log_access(struct ci_request *req, signed int status)
{
  if(!(req == ((struct ci_request *)NULL)))
  {
    if(!(default_logger == ((struct logger_module *)NULL)))
      default_logger->log_access(req);

  }

}

// log_close
// file log.c line 51
void log_close()
{
  if(!(default_logger == ((struct logger_module *)NULL)))
    default_logger->log_close();

}

// log_open
// file include/log.h line 31
signed int log_open()
{
  signed int return_value;
  if(!(default_logger == ((struct logger_module *)NULL)))
  {
    return_value=default_logger->log_open();
    return return_value;
  }

  return 0;
}

// log_reset
// file log.c line 58
void log_reset()
{
  logformat_release();
  default_logger = (struct logger_module *)(void *)0;
}

// log_server
// file include/log.h line 37
void log_server(struct ci_request *req, const char *format, ...)
{
  void **ap;
  char prefix[64l];
  ap = (void **)&format;
  unsigned long int return_value_pthread_self$1;
  if(!(default_logger == ((struct logger_module *)NULL)))
  {
    if(!(MY_PROC_PID == 0))
    {
      return_value_pthread_self$1=pthread_self();
      snprintf(prefix, (unsigned long int)64, "%u/%u", (unsigned int)MY_PROC_PID, (unsigned int)return_value_pthread_self$1);
    }

    else
      strcpy(prefix, "main proc");
    default_logger->log_server(prefix, format, ap);
  }

  ap = ((void **)NULL);
}

// logfile_open
// file log.c line 217
struct _IO_FILE * logfile_open(const char *fname)
{
  struct _IO_FILE *f;
  f=fopen64(fname, "a+");
  if(!(f == ((struct _IO_FILE *)NULL)))
    setvbuf(f, (char *)(void *)0, 2, (unsigned long int)0);

  return f;
}

// logformat_add
// file cfg_param.c line 478
signed int logformat_add(const char *name, const char *format)
{
  struct logformat *lf;
  struct logformat *tmp;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct logformat) /*24ul*/ );
  lf = (struct logformat *)return_value_malloc$1;
  if(lf == ((struct logformat *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocating memory in add_logformat\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocating memory in add_logformat\n");

    }

    return 0;
  }

  else
  {
    lf->name=strdup(name);
    lf->fmt=strdup(format);
    _Bool tmp_if_expr$2;
    if(lf->name == ((char *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = !(lf->fmt != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error strduping in add_logformat\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error strduping in add_logformat\n");

      }

      free((void *)lf);
      return 0;
    }

    else
    {
      lf->next = (struct logformat *)(void *)0;
      if(LOGFORMATS == ((struct logformat *)NULL))
      {
        LOGFORMATS = lf;
        return 1;
      }

      else
      {
        tmp = LOGFORMATS;
        for( ; !(tmp->next == ((struct logformat *)NULL)); tmp = tmp->next)
          ;
        tmp->next = lf;
        return 1;
      }
    }
  }
}

// logformat_fmt
// file log.c line 161
char * logformat_fmt(const char *name)
{
  struct logformat *tmp = LOGFORMATS;
  if(tmp == ((struct logformat *)NULL))
    return (char *)(void *)0;

  else
  {
    while(!(tmp == ((struct logformat *)NULL)))
    {
      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(tmp->name, name);
      if(return_value_strcmp$1 == 0)
        return tmp->fmt;

      tmp = tmp->next;
    }
    return (char *)(void *)0;
  }
}

// logformat_release
// file log.c line 144
void logformat_release()
{
  struct logformat *cur;
  struct logformat *tmp = LOGFORMATS;
  if(!(tmp == ((struct logformat *)NULL)))
  {
    do
    {
      cur = tmp;
      tmp = tmp->next;
      free((void *)cur->name);
      free((void *)cur->fmt);
      free((void *)cur);
    }
    while(!(tmp == ((struct logformat *)NULL)));
    LOGFORMATS = (struct logformat *)(void *)0;
  }

}

// lookup_table_get_row
// file lookup_table.c line 205
static const void * lookup_table_get_row(struct ci_lookup_table *table, const void *key, const char **columns, void ***vals)
{
  signed int i;
  _Bool tmp_if_expr$2;
  if(table->_lt_type == ((struct ci_lookup_table_type *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s is corrupted!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s is corrupted!\n", table->type);

    }

    return (void *)0;
  }

  else
  {
    _Bool tmp_if_expr$1;
    if(table->col_names == ((struct ci_vector *)NULL))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = table->_lt_type->get_row != ((const void * (*)(struct ci_lookup_table *, const void *, const char **, void ***))NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "lookup_table :%s does not support lookup on named columns\n", table->type);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("lookup_table :%s does not support lookup on named columns\n", table->type);

      }

      return (void *)0;
    }

    else
    {
      i = 0;
      do
      {
        if(!(i >= 1024))
          tmp_if_expr$2 = columns[(signed long int)i] != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(!tmp_if_expr$2)
          break;

        const char *return_value_ci_str_vector_search$3;
        return_value_ci_str_vector_search$3=ci_str_vector_search(table->col_names, columns[(signed long int)i]);
        if(return_value_ci_str_vector_search$3 == ((const char *)NULL))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "lookup_table :%s does not has column %s\n", table->type, columns[(signed long int)i]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("lookup_table :%s does not has column %s\n", table->type, columns[(signed long int)i]);

          }

          return (void *)0;
        }

        i = i + 1;
      }
      while((_Bool)1);
      const void *return_value;
      return_value=table->_lt_type->get_row(table, key, columns, vals);
      return return_value;
    }
  }
}

// magics_add
// file filetype.c line 116
signed int magics_add(struct ci_magics_db *db, signed int offset, unsigned char *magic, unsigned long int len, signed int type)
{
  struct ci_magic *newdata;
  signed int indx;
  if(db->magics_num >= db->magics_size)
  {
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)db->magics, (unsigned long int)(db->magics_size + 50) * sizeof(struct ci_magic) /*72ul*/ );
    newdata = (struct ci_magic *)return_value_realloc$1;
    if(newdata == ((struct ci_magic *)NULL))
      return -1;

    db->magics_size = db->magics_size + 50;
    db->magics = newdata;
  }

  indx = db->magics_num;
  db->magics_num = db->magics_num + 1;
  (db->magics + (signed long int)indx)->type = (unsigned int)type;
  (db->magics + (signed long int)indx)->offset = offset;
  (db->magics + (signed long int)indx)->len = len;
  memcpy((void *)(db->magics + (signed long int)indx)->magic, (const void *)magic, len);
  return indx;
}

// magics_init
// file filetype.c line 83
signed int magics_init(struct ci_magics_db *db)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)50 * sizeof(struct ci_magic) /*72ul*/ );
  db->magics = (struct ci_magic *)return_value_malloc$1;
  if(db->magics == ((struct ci_magic *)NULL))
    return 0;

  else
  {
    db->magics_num = 0;
    db->magics_size = 50;
    return 1;
  }
}

// main
// file aserver.c line 128
signed int main(signed int argc, char **argv)
{
  __log_error = (void (*)(void *, const char *, ...))log_server;
  mem_init();
  init_internal_lookup_tables();
  ci_acl_init();
  init_http_auth();
  signed int return_value_init_body_system$1;
  return_value_init_body_system$1=init_body_system();
  if(!(return_value_init_body_system$1 == 1))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Can not initialize body system\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Can not initialize body system\n");

    }

    exit(-1);
  }

  ci_txt_template_init();
  ci_txt_template_set_dir("/usr/share/c_icap/templates");
  commands_init();
  CI_CONF.MAGIC_DB=ci_magic_db_load(CI_CONF.magics_file);
  if(CI_CONF.MAGIC_DB == ((struct ci_magics_db *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Can not load magic file %s!!!\n", CI_CONF.magics_file);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Can not load magic file %s!!!\n", CI_CONF.magics_file);

    }

  }

  init_conf_tables();
  request_stats_init();
  init_modules();
  init_services();
  config(argc, argv);
  compute_my_hostname();
  if(CI_DEBUG_LEVEL >= 2)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "My hostname is:%s\n", (const void *)MY_HOSTNAME);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("My hostname is:%s\n", (const void *)MY_HOSTNAME);

  }

  signed int return_value_log_open$2;
  return_value_log_open$2=log_open();
  if(return_value_log_open$2 == 0)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Can not init loggers. Exiting.....\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Can not init loggers. Exiting.....\n");

    }

    exit(-1);
  }

  signed int return_value_is_icap_running$3;
  return_value_is_icap_running$3=is_icap_running(CI_CONF.PIDFILE);
  if(!(return_value_is_icap_running$3 == 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "c-icap server already running!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("c-icap server already running!\n");

    }

    exit(-1);
  }

  if(!(DAEMON_MODE == 0))
    run_as_daemon();

  signed int return_value_set_running_permissions$4;
  return_value_set_running_permissions$4=set_running_permissions(CI_CONF.RUN_USER, CI_CONF.RUN_GROUP);
  if(return_value_set_running_permissions$4 == 0)
    exit(-1);

  store_pid(CI_CONF.PIDFILE);
  signed int return_value_init_server$5;
  return_value_init_server$5=init_server(CI_CONF.ADDRESS, CI_CONF.PORT, &CI_CONF.PROTOCOL_FAMILY);
  if(return_value_init_server$5 == 0)
    return -1;

  else
  {
    post_init_modules();
    post_init_services();
    start_server();
    clear_pid(CI_CONF.PIDFILE);
    return 0;
  }
}

// main_signals
// file mpmt_server.c line 154
void main_signals()
{
  signal(13, sigpipe_handler);
  signal(15, sigint_handler_main);
  signal(2, sigint_handler_main);
  signal(17, sigchld_handler_main);
  signal(1, (void (*)(signed int))sighup_handler_main);
}

// makeTemplatePathFileName
// file txtTemplate.c line 70
static void makeTemplatePathFileName(char *path, signed int path_len, const char *service_name, const char *page_name, const char *lang)
{
  snprintf(path, (unsigned long int)path_len, "%s/%s/%s/%s", TEMPLATE_DIR, service_name, lang, page_name);
  path[(signed long int)(path_len - 1)] = (char)0;
}

// mem_init
// file aserver.c line 55
signed int mem_init()
{
  signed int ret = -1;
  ret=ci_buffers_init();
  default_allocator=ci_create_os_allocator();
  if(default_allocator == ((struct ci_mem_allocator *)NULL) && ret == -1)
    ret = 0;

  MEM_ALLOCATOR_POOL=ci_object_pool_register("ci_mem_allocator_t", (signed int)sizeof(struct ci_mem_allocator) /*56ul*/ );
  /* assertion MEM_ALLOCATOR_POOL >=0 */
  assert(MEM_ALLOCATOR_POOL >= 0);
  unsigned long int return_value_sizeof_pack_allocator$1;
  return_value_sizeof_pack_allocator$1=sizeof_pack_allocator();
  PACK_ALLOCATOR_POOL=ci_object_pool_register("pack_allocator_t", (signed int)return_value_sizeof_pack_allocator$1);
  /* assertion PACK_ALLOCATOR_POOL >=0 */
  assert(PACK_ALLOCATOR_POOL >= 0);
  return ret;
}

// mem_reset
// file mem.c line 58
void mem_reset()
{
  ;
}

// methods_authenticators
// file module.c line 490
signed int methods_authenticators(struct auth_hash *hash, const char *method_name, signed int method_id, const char **argv)
{
  signed int i;
  signed int k;
  signed int auths_num;
  struct authenticator_module **new_mem;
  struct authenticator_module *auth_mod;
  signed int return_value_check_to_add_method_id$1;
  return_value_check_to_add_method_id$1=check_to_add_method_id(hash, method_id);
  if(return_value_check_to_add_method_id$1 == 0)
    return 0;

  else
  {
    auths_num = 0;
    for( ; !(argv[(signed long int)auths_num] == ((const char *)NULL)); auths_num = auths_num + 1)
      ;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)(auths_num + 1) * sizeof(struct authenticator_module *) /*8ul*/ );
    new_mem = (struct authenticator_module **)return_value_malloc$2;
    if(new_mem == ((struct authenticator_module **)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error allocating memory!!!!!!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error allocating memory!!!!!!\n");

      }

      return 0;
    }

    else
    {
      memset((void *)new_mem, 0, (unsigned long int)(auths_num + 1));
      if(!(hash->hash[(signed long int)method_id] == ((struct authenticator_module **)NULL)))
        free((void *)hash->hash[(signed long int)method_id]);

      hash->hash[(signed long int)method_id] = new_mem;
      k = 0;
      i = 0;
      for( ; !(i >= auths_num); i = i + 1)
      {
        if(CI_DEBUG_LEVEL >= 3)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Authenticator %s......\n", argv[(signed long int)i]);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Authenticator %s......\n", argv[(signed long int)i]);

        }

        auth_mod=find_authenticator(argv[(signed long int)i]);
        if(auth_mod == ((struct authenticator_module *)NULL))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Authenticator %s does not exist!!!!!\n", argv[(signed long int)i]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Authenticator %s does not exist!!!!!\n", argv[(signed long int)i]);

          }

        }

        else
        {
          signed int return_value_strcasecmp$3;
          return_value_strcasecmp$3=strcasecmp(auth_mod->method, method_name);
          if(!(return_value_strcasecmp$3 == 0))
          {
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Authenticator %s does not provide authentication method %s!!!!\n", auth_mod->name, method_name);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Authenticator %s does not provide authentication method %s!!!!\n", auth_mod->name, method_name);

            }

          }

          else
          {
            signed int tmp_post$4 = k;
            k = k + 1;
            new_mem[(signed long int)tmp_post$4] = auth_mod;
          }
        }
      }
      new_mem[(signed long int)k] = (struct authenticator_module *)(void *)0;
      return 1;
    }
  }
}

// mk_encaps_entity
// file header.c line 547
struct ci_encaps_entity * mk_encaps_entity(signed int type, signed int val)
{
  struct ci_encaps_entity *h;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ci_encaps_entity) /*16ul*/ );
  h = (struct ci_encaps_entity *)return_value_malloc$1;
  struct ci_headers_list *return_value_ci_headers_create$2;
  if(h == ((struct ci_encaps_entity *)NULL))
    return (struct ci_encaps_entity *)(void *)0;

  else
  {
    h->start = val;
    h->type = type;
    if(type == 0 || type == 1)
    {
      return_value_ci_headers_create$2=ci_headers_create();
      h->entity = (void *)return_value_ci_headers_create$2;
    }

    else
      h->entity = (void *)0;
    return h;
  }
}

// mk_responce_header
// file request.c line 680
static signed int mk_responce_header(struct ci_request *req)
{
  struct ci_headers_list *head;
  struct ci_encaps_entity **e_list;
  struct ci_service_xdata *srv_xdata;
  char buf[512l];
  srv_xdata=service_data(req->current_service_mod);
  ci_headers_reset(req->response_header);
  head = req->response_header;
  _Bool tmp_if_expr$1;
  if(req->return_code >= 0)
    tmp_if_expr$1 = req->return_code < 16 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  /* assertion req->return_code >= EC_100 && req->return_code < EC_MAX */
  assert(tmp_if_expr$1);
  _Bool tmp_if_expr$2;
  if(req->return_code >= 0)
    tmp_if_expr$2 = req->return_code < 16 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  signed int tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = ci_error_codes[(signed long int)req->return_code].code;

  else
    tmp_if_expr$3 = 1000;
  _Bool tmp_if_expr$4;
  if(req->return_code >= 0)
    tmp_if_expr$4 = req->return_code < 16 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$4 = (_Bool)0;
  char *tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = ci_error_codes[(signed long int)req->return_code].str;

  else
    tmp_if_expr$5 = "UNKNOWN ERROR CODE";
  snprintf(buf, (unsigned long int)512, "ICAP/1.0 %d %s", tmp_if_expr$3, tmp_if_expr$5);
  ci_headers_add(head, buf);
  ci_headers_add(head, "Server: C-ICAP/0.4.2");
  if(!(req->keepalive == 0))
    ci_headers_add(head, "Connection: keep-alive");

  else
    ci_headers_add(head, "Connection: close");
  ci_service_data_read_lock(srv_xdata);
  ci_headers_add(head, srv_xdata->ISTag);
  ci_service_data_read_unlock(srv_xdata);
  if(!(req->xheaders->used == 0))
    ci_headers_addheaders(head, req->xheaders);

  e_list = req->entities;
  if(req->type == 0x04)
  {
    if((*e_list)->type == 0)
    {
      ci_request_release_entity(req, 0);
      e_list[(signed long int)0] = e_list[(signed long int)1];
      e_list[(signed long int)1] = e_list[(signed long int)2];
      e_list[(signed long int)2] = (struct ci_encaps_entity *)(void *)0;
    }

  }

  const char *tmp_if_expr$6;
  if(!(req->current_service_mod->mod_short_descr == ((const char *)NULL)))
    tmp_if_expr$6 = req->current_service_mod->mod_short_descr;

  else
    tmp_if_expr$6 = req->current_service_mod->mod_name;
  snprintf(buf, (unsigned long int)512, "Via: ICAP/1.0 %s (C-ICAP/0.4.2 %s )", (const void *)MY_HOSTNAME, tmp_if_expr$6);
  buf[(signed long int)511] = (char)0;
  if(req->type == 0x04)
    ci_http_response_add_header(req, buf);

  else
    if(req->type == 0x02)
      ci_http_request_add_header(req, buf);

  ci_response_pack(req);
  return 1;
}

// mmap_shared_mem_attach
// file os/unix/shared_mem.c line 118
void * mmap_shared_mem_attach(struct ci_shared_mem_id *id)
{
  return (void *)id->mem;
}

// mmap_shared_mem_create
// file os/unix/shared_mem.c line 103
void * mmap_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size)
{
  id->mem=mmap64(NULL, (unsigned long int)size, 0x1 | 0x2, 0x01 | 0x20, -1, (signed long int)0);
  if(id->mem == (void *)-1)
    return (void *)0;

  else
  {
    id->size = (unsigned long int)size;
    snprintf(id->name, (unsigned long int)64, "%s", name);
    return id->mem;
  }
}

// mmap_shared_mem_destroy
// file os/unix/shared_mem.c line 131
signed int mmap_shared_mem_destroy(struct ci_shared_mem_id *id)
{
  munmap(id->mem, id->size);
  return 1;
}

// mmap_shared_mem_detach
// file os/unix/shared_mem.c line 124
signed int mmap_shared_mem_detach(struct ci_shared_mem_id *id)
{
  return 1;
}

// mmap_shared_mem_print_info
// file os/unix/shared_mem.c line 137
signed int mmap_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, buf_size, "mmap:%s/%p %ld kbs", (const void *)id->name, id->mem, (signed long int)(id->size / (unsigned long int)1024));
  return return_value_snprintf$1;
}

// mod_null_io
// file request.c line 896
static signed int mod_null_io(char *rbuf, signed int *rlen, char *wbuf, signed int *wlen, signed int iseof, struct ci_request *req)
{
  if(!(iseof == 0))
    *rlen = -2;

  else
    *rlen = 0;
  return 1;
}

// module_type
// file module.c line 115
static signed int module_type(const char *type)
{
  signed int return_value_strcmp$6;
  return_value_strcmp$6=strcmp(type, "service_handler");
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(return_value_strcmp$6 == 0)
    return SERVICE_HANDLER;

  else
  {
    return_value_strcmp$5=strcmp(type, "logger");
    if(return_value_strcmp$5 == 0)
      return LOGGER;

    else
    {
      return_value_strcmp$4=strcmp(type, "access_controller");
      if(return_value_strcmp$4 == 0)
        return ACCESS_CONTROLLER;

      else
      {
        return_value_strcmp$3=strcmp(type, "auth_method");
        if(return_value_strcmp$3 == 0)
          return AUTH_METHOD;

        else
        {
          return_value_strcmp$2=strcmp(type, "authenticator");
          if(return_value_strcmp$2 == 0)
            return AUTHENTICATOR;

          else
          {
            return_value_strcmp$1=strcmp(type, "common");
            if(return_value_strcmp$1 == 0)
              return COMMON;

          }
        }
      }
    }
  }
  if(CI_DEBUG_LEVEL >= 1)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Uknown type of module:%s\n", type);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Uknown type of module:%s\n", type);

  }

  return UNKNOWN;
}

// net_data_read
// file include/request.h line 151
signed int net_data_read(struct ci_request *req)
{
  signed int bytes;
  if(!(req->pstrblock_read == req->rbuf))
  {
    if(!(req->pstrblock_read_len == 0))
      memmove((void *)req->rbuf, (const void *)req->pstrblock_read, (unsigned long int)req->pstrblock_read_len);

    req->pstrblock_read = req->rbuf;
  }

  bytes = 4096 - req->pstrblock_read_len;
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  if(!(bytes >= 1))
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to read data! Is this a bug (%d %d)?????\n", req->pstrblock_read_len, 4096);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to read data! Is this a bug (%d %d)?????\n", req->pstrblock_read_len, 4096);

    }

    return -1;
  }

  else
  {
    bytes=ci_read_nonblock(req->connection->fd, (void *)(req->rbuf + (signed long int)req->pstrblock_read_len), (unsigned long int)bytes);
    if(!(bytes >= 1))
    {
      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value___errno_location$1=__errno_location();
          __log_error((void *)0, "Error reading data (read return=%d, errno=%d) \n", bytes, *return_value___errno_location$1);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value___errno_location$2=__errno_location();
          printf("Error reading data (read return=%d, errno=%d) \n", bytes, *return_value___errno_location$2);
        }

      }

      return -1;
    }

    else
    {
      req->pstrblock_read_len = req->pstrblock_read_len + bytes;
      req->bytes_in = req->bytes_in + (unsigned long int)bytes;
      return 1;
    }
  }
}

// newrequest
// file request.c line 102
struct ci_request * newrequest(struct ci_connection *connection)
{
  struct ci_request *req;
  signed int access;
  signed int len;
  struct ci_connection *conn;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ci_connection) /*88ul*/ );
  conn = (struct ci_connection *)return_value_malloc$1;
  /* assertion conn */
  assert(conn != ((struct ci_connection *)NULL));
  ci_copy_connection(conn, connection);
  req=ci_request_alloc(conn);
  access=access_check_client(req);
  if(access == -1)
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen("ICAP/1.0 403 Forbidden\r\n\r\n");
    len = (signed int)return_value_strlen$2;
    ci_write(connection->fd, (const void *)"ICAP/1.0 403 Forbidden\r\n\r\n", (unsigned long int)len, TIMEOUT);
    ci_request_destroy(req);
    return (struct ci_request *)(void *)0;
  }

  req->access_type = access;
  return req;
}

// newthread
// file mpmt_server.c line 537
struct server_decl * newthread(struct connections_queue *con_queue)
{
  struct server_decl *serv;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct server_decl) /*48ul*/ );
  serv = (struct server_decl *)return_value_malloc$1;
  serv->srv_id = 0;
  serv->con_queue = con_queue;
  serv->served_requests = 0;
  serv->served_requests_no_reallocation = 0;
  serv->current_req = (struct ci_request *)(void *)0;
  serv->running = 1;
  return serv;
}

// options_responce
// file request.c line 1123
static void options_responce(struct ci_request *req)
{
  char buf[1024l];
  const char *str;
  struct ci_headers_list *head;
  struct ci_service_xdata *srv_xdata;
  unsigned int xopts;
  signed int preview;
  signed int allow204;
  signed int allow206;
  signed int max_conns;
  signed int xlen;
  signed int hastransfer = 0;
  signed int ttl;
  req->return_code = 1;
  head = req->response_header;
  srv_xdata=service_data(req->current_service_mod);
  ci_headers_reset(head);
  ci_headers_add(head, "ICAP/1.0 200 OK");
  strcpy(buf, "Methods: ");
  if(!((0x04 & req->current_service_mod->mod_type) == 0))
  {
    strcat(buf, "RESPMOD");
    if(!((0x02 & req->current_service_mod->mod_type) == 0))
      strcat(buf, ", REQMOD");

  }

  else
    strcat(buf, "REQMOD");
  ci_headers_add(head, buf);
  str = req->current_service_mod->mod_short_descr;
  const char *tmp_if_expr$1;
  if(!(str == ((const char *)NULL)))
    tmp_if_expr$1 = str;

  else
    tmp_if_expr$1 = req->current_service_mod->mod_name;
  snprintf(buf, (unsigned long int)1023, "Service: C-ICAP/0.4.2 server - %s", tmp_if_expr$1);
  buf[(signed long int)1023] = (char)0;
  ci_headers_add(head, buf);
  ci_service_data_read_lock(srv_xdata);
  ci_headers_add(head, srv_xdata->ISTag);
  if(!((signed int)srv_xdata->TransferPreview[0l] == 0))
  {
    if(srv_xdata->preview_size >= 0)
    {
      ci_headers_add(head, srv_xdata->TransferPreview);
      hastransfer = hastransfer + 1;
    }

  }

  if(!((signed int)srv_xdata->TransferIgnore[0l] == 0))
  {
    ci_headers_add(head, srv_xdata->TransferIgnore);
    hastransfer = hastransfer + 1;
  }

  if(!((signed int)srv_xdata->TransferComplete[0l] == 0))
  {
    ci_headers_add(head, srv_xdata->TransferComplete);
    hastransfer = hastransfer + 1;
  }

  if(hastransfer == 0)
  {
    if(srv_xdata->preview_size >= 0)
      ci_headers_add(head, "Transfer-Preview: *");

  }

  xopts = (unsigned int)srv_xdata->xopts;
  preview = srv_xdata->preview_size;
  allow204 = srv_xdata->allow_204;
  allow206 = srv_xdata->allow_206;
  max_conns = srv_xdata->max_connections;
  ttl = srv_xdata->options_ttl;
  ci_service_data_read_unlock(srv_xdata);
  if(CI_DEBUG_LEVEL >= 5)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Options responce:\n Preview :%d\n Allow 204:%s\n Allow 206:%s\n TransferPreview:\"%s\"\n TransferIgnore:%s\n TransferComplete:%s\n Max-Connections:%d\n", preview, allow204 != 0 ? "yes" : "no", allow206 != 0 ? "yes" : "no", (const void *)srv_xdata->TransferPreview, (const void *)srv_xdata->TransferIgnore, (const void *)srv_xdata->TransferComplete, max_conns);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Options responce:\n Preview :%d\n Allow 204:%s\n Allow 206:%s\n TransferPreview:\"%s\"\n TransferIgnore:%s\n TransferComplete:%s\n Max-Connections:%d\n", preview, allow204 != 0 ? "yes" : "no", allow206 != 0 ? "yes" : "no", (const void *)srv_xdata->TransferPreview, (const void *)srv_xdata->TransferIgnore, (const void *)srv_xdata->TransferComplete, max_conns);

  }

  if(ttl >= 1)
  {
    sprintf(buf, "Options-TTL: %d", ttl);
    ci_headers_add(head, buf);
  }

  else
    ci_headers_add(head, "Options-TTL: 3600");
  strcpy(buf, "Date: ");
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(buf);
  ci_strtime_rfc822(buf + (signed long int)return_value_strlen$2);
  ci_headers_add(head, buf);
  if(preview >= 0)
  {
    sprintf(buf, "Preview: %d", srv_xdata->preview_size);
    ci_headers_add(head, buf);
  }

  if(max_conns >= 0)
  {
    sprintf(buf, "Max-Connections: %d", max_conns);
    ci_headers_add(head, buf);
  }

  if(!(allow204 == 0) && !(allow206 == 0))
    ci_headers_add(head, "Allow: 204, 206");

  else
    if(!(allow204 == 0))
      ci_headers_add(head, "Allow: 204");

  if(!(xopts == 0u))
  {
    strcpy(buf, "X-Include: ");
    xlen = 11;
    if(!((1u & xopts) == 0u))
    {
      strcat(buf, "X-Client-IP");
      xlen = xlen + (signed int)sizeof(char [12l]) /*12ul*/ ;
    }

    if(!((2u & xopts) == 0u))
    {
      if(xlen >= 12)
      {
        strcat(buf, ", ");
        xlen = xlen + 2;
      }

      strcat(buf, "X-Server-IP");
      xlen = xlen + (signed int)sizeof(char [12l]) /*12ul*/ ;
    }

    if(!((4u & xopts) == 0u))
    {
      if(xlen >= 12)
      {
        strcat(buf, ", ");
        xlen = xlen + 2;
      }

      strcat(buf, "X-Subscriber-ID");
      xlen = xlen + (signed int)sizeof(char [16l]) /*16ul*/ ;
    }

    if(!((8u & xopts) == 0u))
    {
      if(xlen >= 12)
      {
        strcat(buf, ", ");
        xlen = xlen + 2;
      }

      strcat(buf, "X-Authenticated-User");
      xlen = xlen + (signed int)sizeof(char [21l]) /*21ul*/ ;
    }

    if(!((16u & xopts) == 0u))
    {
      if(xlen >= 12)
      {
        strcat(buf, ", ");
        xlen = xlen + 2;
      }

      strcat(buf, "X-Authenticated-Groups");
      xlen = xlen + (signed int)sizeof(char [23l]) /*23ul*/ ;
    }

    if(xlen >= 12)
      ci_headers_add(head, buf);

  }

  ci_response_pack(req);
  req->pstrblock_responce = head->buf;
  req->remain_send_block_bytes = head->bufused;
  do
  {
    signed int return_value_wait_for_data$3;
    return_value_wait_for_data$3=wait_for_data(req->connection->fd, TIMEOUT, 0x2);
    if(!(return_value_wait_for_data$3 >= 0))
    {
      if(CI_DEBUG_LEVEL >= 3)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Timeout sending data. Ending .......\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Timeout sending data. Ending .......\n");

      }

      goto __CPROVER_DUMP_L35;
    }

    signed int return_value_send_current_block_data$4;
    return_value_send_current_block_data$4=send_current_block_data(req);
    if(return_value_send_current_block_data$4 == -1)
    {
      if(CI_DEBUG_LEVEL >= 3)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error sending data. Ending .....\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error sending data. Ending .....\n");

      }

      goto __CPROVER_DUMP_L35;
    }

  }
  while(req->remain_send_block_bytes >= 1);

__CPROVER_DUMP_L35:
  ;
}

// os_allocator_alloc
// file mem.c line 404
static void * os_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(size);
  return return_value_malloc$1;
}

// os_allocator_destroy
// file mem.c line 419
static void os_allocator_destroy(struct ci_mem_allocator *allocator)
{
  ;
}

// os_allocator_free
// file mem.c line 409
static void os_allocator_free(struct ci_mem_allocator *allocator, void *p)
{
  free(p);
}

// os_allocator_reset
// file mem.c line 414
static void os_allocator_reset(struct ci_mem_allocator *allocator)
{
  ;
}

// parse_chunk_data
// file include/request.h line 150
signed int parse_chunk_data(struct ci_request *req, char **wdata)
{
  char *end;
  const char *eofChunk;
  signed int chunkLen;
  signed int remains;
  signed int tmp;
  signed int read_status = 0;
  *wdata = (char *)(void *)0;
  signed int return_value_strncmp$4;
  signed int return_value_strncmp$3;
  if(!(req->write_to_module_pending == 0u))
    return -1;

  else
  {
    while((_Bool)1)
    {
      if(req->current_chunk_len == req->chunk_bytes_read)
        read_status = 1;

      else
        read_status = 2;
      if(read_status == 1)
      {
        eofChunk=ci_strnstr(req->pstrblock_read, "\r\n", (unsigned long int)req->pstrblock_read_len);
        if(eofChunk == ((const char *)NULL))
        {
          if(req->pstrblock_read_len >= 4096)
            return -1;

          return 2;
        }

        eofChunk = eofChunk + (signed long int)2;
        chunkLen = (signed int)(eofChunk - req->pstrblock_read);
        req->request_bytes_in = req->request_bytes_in + (unsigned long int)(eofChunk - req->pstrblock_read);
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        *return_value___errno_location$1 = 0;
        signed long int return_value_strtol$2;
        return_value_strtol$2=strtol(req->pstrblock_read, &end, 16);
        tmp = (signed int)return_value_strtol$2;
        if(tmp == 0)
        {
          if(req->pstrblock_read == end)
          {
            if(CI_DEBUG_LEVEL >= 5)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Parse error:count=%d,start=%c\n", tmp, req->pstrblock_read[(signed long int)0]);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Parse error:count=%d,start=%c\n", tmp, req->pstrblock_read[(signed long int)0]);

            }

            return -1;
          }

        }

        req->current_chunk_len = (unsigned int)tmp;
        req->chunk_bytes_read = (unsigned int)0;
        for( ; (_Bool)1; end = end + 1l)
          if(!((signed int)*end == 32))
          {
            if(!((signed int)*end == 9))
              goto __CPROVER_DUMP_L11;

          }


      __CPROVER_DUMP_L11:
        ;
        if(req->current_chunk_len == 0u)
        {
          remains = req->pstrblock_read_len - chunkLen;
          if(!(remains >= 2))
            return 2;

          if(!((signed int)*eofChunk == 13))
          {
            if(!((signed int)eofChunk[1l] == 10))
              return -1;

          }

          eofChunk = eofChunk + (signed long int)2;
          chunkLen = chunkLen + 2;
          req->request_bytes_in = req->request_bytes_in + (unsigned long int)2;
          if((signed int)*end == 59)
          {
            end = end + 1l;
            for( ; (_Bool)1; end = end + 1l)
              if(!((signed int)*end == 32))
              {
                if(!((signed int)*end == 9))
                  goto __CPROVER_DUMP_L16;

              }


          __CPROVER_DUMP_L16:
            ;
            remains = (signed int)((signed long int)req->pstrblock_read_len - (end - req->pstrblock_read));
            _Bool tmp_if_expr$5;
            if(remains >= 18)
            {
              return_value_strncmp$4=strncmp(end, "use-original-body=", (unsigned long int)18);
              tmp_if_expr$5 = return_value_strncmp$4 == 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$5 = (_Bool)0;
            if(tmp_if_expr$5)
              req->i206_use_original_body=strtol(end + (signed long int)18, &end, 10);

            else
              if(remains >= 4)
              {
                return_value_strncmp$3=strncmp(end, "ieof", (unsigned long int)4);
                if(!(return_value_strncmp$3 == 0))
                  return -1;

              }

            for( ; !((signed int)*end == 13); end = end + 1l)
              ;
            req->eof_received = 1;
          }

        }

        else
        {
          read_status = 2;
          req->current_chunk_len = req->current_chunk_len + (unsigned int)2;
        }
        _Bool tmp_if_expr$6;
        if(!((signed int)*end == 13))
          tmp_if_expr$6 = (_Bool)1;

        else
          tmp_if_expr$6 = (signed int)end[(signed long int)1] != 10 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$6)
          return -1;

        req->pstrblock_read_len = req->pstrblock_read_len - chunkLen;
        req->pstrblock_read = req->pstrblock_read + (signed long int)chunkLen;
      }

      if(req->current_chunk_len == 0u)
        return -2;

      if(!(req->write_to_module_pending == 0u))
        return 1;

      if(read_status == 2)
      {
        if(!(req->pstrblock_read_len >= 1))
          return 2;

        *wdata = req->pstrblock_read;
        remains = (signed int)(req->current_chunk_len - req->chunk_bytes_read);
        if(req->pstrblock_read_len >= remains)
        {
          if(remains >= 3)
          {
            req->write_to_module_pending = (unsigned int)(remains - 2);
            req->http_bytes_in = req->http_bytes_in + (unsigned long int)req->write_to_module_pending;
            req->body_bytes_in = req->body_bytes_in + (unsigned long int)req->write_to_module_pending;
          }

          else
            req->write_to_module_pending = (unsigned int)0;
          req->chunk_bytes_read = req->chunk_bytes_read + (unsigned int)remains;
          req->pstrblock_read = req->pstrblock_read + (signed long int)remains;
          req->pstrblock_read_len = req->pstrblock_read_len - remains;
          req->request_bytes_in = req->request_bytes_in + (unsigned long int)remains;
        }

        else
        {
          tmp = remains - req->pstrblock_read_len;
          if(!(tmp >= 2))
            req->write_to_module_pending = (unsigned int)(req->pstrblock_read_len - tmp);

          else
            req->write_to_module_pending = (unsigned int)req->pstrblock_read_len;
          req->http_bytes_in = req->http_bytes_in + (unsigned long int)req->write_to_module_pending;
          req->body_bytes_in = req->body_bytes_in + (unsigned long int)req->write_to_module_pending;
          req->request_bytes_in = req->request_bytes_in + (unsigned long int)req->pstrblock_read_len;
          req->chunk_bytes_read = req->chunk_bytes_read + (unsigned int)req->pstrblock_read_len;
          req->pstrblock_read = req->pstrblock_read + (signed long int)req->pstrblock_read_len;
          req->pstrblock_read_len = req->pstrblock_read_len - req->pstrblock_read_len;
        }
      }

      if(req->pstrblock_read_len == 0)
        return 2;

    }
    return 1;
  }
}

// parse_directive
// file txt_format.c line 160
unsigned int parse_directive(const char *var, unsigned int *width, signed int *left_align, char *parameter)
{
  const char *s1;
  signed int i = 0;
  char *e;
  s1 = var + (signed long int)1;
  parameter[(signed long int)0] = (char)0;
  if((signed int)*s1 == 45)
  {
    *left_align = 1;
    s1 = s1 + 1l;
  }

  else
    *left_align = 0;
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(s1, &e, 10);
  *width = (unsigned int)return_value_strtol$1;
  if(e == s1)
    *width = (unsigned int)0;

  else
    s1 = e;
  if((signed int)*s1 == 123)
  {
    s1 = s1 + 1l;
    i = 0;
    for( ; !(*s1 == 0); s1 = s1 + 1l)
    {
      if((signed int)*s1 == 125)
        break;

      if(i >= 256)
        break;

      parameter[(signed long int)i] = *s1;
      i = i + 1;
    }
    if(!((signed int)*s1 == 125))
      return (unsigned int)0;

    parameter[(signed long int)i] = (char)0;
    s1 = s1 + 1l;
  }

  return (unsigned int)(s1 - var);
}

// parse_encaps_headers
// file request.c line 531
static signed int parse_encaps_headers(struct ci_request *req)
{
  signed int size;
  signed int i;
  signed int request_status = 0;
  struct ci_encaps_entity *e = (struct ci_encaps_entity *)(void *)0;
  i = 0;
  do
  {
    e = req->entities[(signed long int)i];
    if(e == ((struct ci_encaps_entity *)NULL))
      break;

    if(e->type >= 2)
      return 0;

    if(req->entities[(signed long int)(1 + i)] == ((struct ci_encaps_entity *)NULL))
      return 4;

    size = req->entities[(signed long int)(i + 1)]->start - e->start;
    request_status=read_encaps_header(req, (struct ci_headers_list *)e->entity, size);
    if(!(request_status == 0))
      return request_status;

    request_status=ci_headers_unpack((struct ci_headers_list *)e->entity);
    if(!(request_status == 0))
      return request_status;

    i = i + 1;
  }
  while((_Bool)1);
  return 0;
}

// parse_file
// file cfg_param.c line 821
signed int parse_file(const char *conf_file)
{
  struct _IO_FILE *f_conf;
  char line[8192l];
  signed int line_count;
  signed int ret_value;
  signed int return_value_feof$1;
  signed int return_value_process_line$3;
  if(PARSE_LEVEL >= 5)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Include level > %d. I will not parse file:%s\n", 5, conf_file);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Include level > %d. I will not parse file:%s\n", 5, conf_file);

    }

    return 0;
  }

  else
  {
    f_conf=fopen64(conf_file, "r");
    if(f_conf == ((struct _IO_FILE *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Can not open configuration file %s\n", conf_file);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Can not open configuration file %s\n", conf_file);

      }

      return 0;
    }

    else
    {
      line_count = 0;
      ret_value = 1;
      PARSE_LEVEL = PARSE_LEVEL + 1;
      do
      {
        return_value_feof$1=feof(f_conf);
        if(!(return_value_feof$1 == 0))
          break;

        line_count = line_count + 1;
        signed int return_value_fread_line$2;
        return_value_fread_line$2=fread_line(f_conf, line);
        _Bool tmp_if_expr$4;
        if(return_value_fread_line$2 == 0)
          tmp_if_expr$4 = (_Bool)1;

        else
        {
          return_value_process_line$3=process_line(line);
          tmp_if_expr$4 = !(return_value_process_line$3 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$4)
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Fatal error while parsing config file: \"%s\" line: %d\n", conf_file, line_count);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Fatal error while parsing config file: \"%s\" line: %d\n", conf_file, line_count);

          }

          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "The line is: %s\n", (const void *)line);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("The line is: %s\n", (const void *)line);

          }

          ret_value = 0;
        }

      }
      while((_Bool)1);
      fclose(f_conf);
      PARSE_LEVEL = PARSE_LEVEL - 1;
      return ret_value;
    }
  }
}

// parse_header
// file request.c line 478
static signed int parse_header(struct ci_request *req)
{
  signed int i;
  signed int request_status = 0;
  signed int result;
  struct ci_headers_list *h;
  char *val;
  h = req->request_header;
  request_status=ci_read_icap_header(req, h, TIMEOUT);
  const unsigned short int **return_value___ctype_b_loc$1;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$5;
  signed int return_value_strncasecmp$14;
  signed int return_value_strncasecmp$13;
  const unsigned short int **return_value___ctype_b_loc$7;
  _Bool tmp_if_expr$8;
  signed int return_value_strncasecmp$12;
  if(!(request_status == 0))
    return request_status;

  else
  {
    request_status=ci_headers_unpack(h);
    if(!(request_status == 0))
      return request_status;

    else
    {
      request_status=parse_request(req, h->headers[(signed long int)0]);
      if(!(request_status == 0))
        return request_status;

      else
      {
        i = 1;
        for( ; request_status == 0 && !(i >= h->used); i = i + 1)
        {
          signed int return_value_strncasecmp$15;
          return_value_strncasecmp$15=strncasecmp("Preview:", h->headers[(signed long int)i], (unsigned long int)8);
          if(return_value_strncasecmp$15 == 0)
          {
            val = h->headers[(signed long int)i] + (signed long int)8;
            do
            {
              return_value___ctype_b_loc$1=__ctype_b_loc();
              if(!((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*val]) == 0))
                tmp_if_expr$2 = (signed int)*val != 0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$2 = (_Bool)0;
              if(!tmp_if_expr$2)
                break;

              val = val + 1l;
            }
            while((_Bool)1);
            signed int *return_value___errno_location$3;
            return_value___errno_location$3=__errno_location();
            *return_value___errno_location$3 = 0;
            signed long int return_value_strtol$4;
            return_value_strtol$4=strtol(val, (char ** restrict )(void *)0, 10);
            result = (signed int)return_value_strtol$4;
            signed int *return_value___errno_location$6;
            return_value___errno_location$6=__errno_location();
            if(!(*return_value___errno_location$6 == 22))
            {
              return_value___errno_location$5=__errno_location();
              if(!(*return_value___errno_location$5 == 34))
              {
                req->preview = result;
                if(result >= 0)
                  ci_buf_reset_size(&req->preview_data, result + 64);

              }

            }

          }

          else
          {
            return_value_strncasecmp$14=strncasecmp("Encapsulated:", h->headers[(signed long int)i], (unsigned long int)13);
            if(return_value_strncasecmp$14 == 0)
              request_status=process_encapsulated(req, h->headers[(signed long int)i]);

            else
            {
              return_value_strncasecmp$13=strncasecmp("Connection:", h->headers[(signed long int)i], (unsigned long int)11);
              if(return_value_strncasecmp$13 == 0)
              {
                val = h->headers[(signed long int)i] + (signed long int)11;
                do
                {
                  return_value___ctype_b_loc$7=__ctype_b_loc();
                  if(!((8192 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*val]) == 0))
                    tmp_if_expr$8 = (signed int)*val != 0 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr$8 = (_Bool)0;
                  if(!tmp_if_expr$8)
                    break;

                  val = val + 1l;
                }
                while((_Bool)1);
                signed int return_value_strncasecmp$9;
                return_value_strncasecmp$9=strncasecmp(val, "close", (unsigned long int)5);
                if(return_value_strncasecmp$9 == 0)
                  req->keepalive = 0;

              }

              else
              {
                return_value_strncasecmp$12=strncasecmp("Allow:", h->headers[(signed long int)i], (unsigned long int)6);
                if(return_value_strncasecmp$12 == 0)
                {
                  char *return_value_strstr$10;
                  return_value_strstr$10=strstr(h->headers[(signed long int)i] + (signed long int)6, "204");
                  if(!(return_value_strstr$10 == ((char *)NULL)))
                    req->allow204 = 1;

                  char *return_value_strstr$11;
                  return_value_strstr$11=strstr(h->headers[(signed long int)i] + (signed long int)6, "206");
                  if(!(return_value_strstr$11 == ((char *)NULL)))
                    req->allow206 = 1;

                }

              }
            }
          }
        }
        if(!(request_status == 0))
          return request_status;

        else
        {
          signed int return_value_check_request$16;
          return_value_check_request$16=check_request(req);
          return return_value_check_request$16;
        }
      }
    }
  }
}

// parse_record
// file filetype.c line 179
static signed int parse_record(char *line, struct ci_magic_record *record)
{
  char *s;
  char *end;
  char num[4l];
  signed int len;
  signed int c;
  signed int i;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(line);
  len = (signed int)return_value_strlen$1;
  signed int *return_value___errno_location$4;
  if(!(len >= 4))
    return 0;

  else
    if((signed int)*line == 35)
      return 0;

    else
    {
      len = len - 1;
      line[(signed long int)len] = (char)0;
      s = line;
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 0;
      signed long int return_value_strtol$3;
      return_value_strtol$3=strtol(s, &end, 10);
      record->offset = (signed int)return_value_strtol$3;
      _Bool tmp_if_expr$5;
      if(!((signed int)*end == 58))
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        return_value___errno_location$4=__errno_location();
        tmp_if_expr$5 = *return_value___errno_location$4 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$5)
        return 0;

      else
      {
        s = end + (signed long int)1;
        i = 0;
        end = line + (signed long int)len;
        while(!((signed int)*s == 58))
        {
          if(s >= end)
            break;

          if(i >= 50)
            break;

          if((signed int)*s == 92)
          {
            s = s + 1l;
            if((signed int)*s == 120)
            {
              s = s + 1l;
              char *tmp_post$6 = s;
              s = s + 1l;
              num[(signed long int)0] = *tmp_post$6;
              char *tmp_post$7 = s;
              s = s + 1l;
              num[(signed long int)1] = *tmp_post$7;
              num[(signed long int)2] = (char)0;
              signed long int return_value_strtol$8;
              return_value_strtol$8=strtol(num, (char ** restrict )(void *)0, 16);
              c = (signed int)return_value_strtol$8;
            }

            else
            {
              char *tmp_post$9 = s;
              s = s + 1l;
              num[(signed long int)0] = *tmp_post$9;
              char *tmp_post$10 = s;
              s = s + 1l;
              num[(signed long int)1] = *tmp_post$10;
              char *tmp_post$11 = s;
              s = s + 1l;
              num[(signed long int)2] = *tmp_post$11;
              num[(signed long int)3] = (char)0;
              signed long int return_value_strtol$12;
              return_value_strtol$12=strtol(num, (char ** restrict )(void *)0, 8);
              c = (signed int)return_value_strtol$12;
            }
            if(c >= 257 || !(c >= 0))
              return -2;

            signed int tmp_post$13 = i;
            i = i + 1;
            record->magic[(signed long int)tmp_post$13] = (unsigned char)c;
          }

          else
          {
            signed int tmp_post$14 = i;
            i = i + 1;
            record->magic[(signed long int)tmp_post$14] = (unsigned char)*s;
            s = s + 1l;
          }
        }
        record->len = (unsigned long int)i;
        _Bool tmp_if_expr$15;
        if(s >= end)
          tmp_if_expr$15 = (_Bool)1;

        else
          tmp_if_expr$15 = (signed int)*s != 58 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$15)
          return -2;

        else
        {
          s = s + 1l;
          end=strchr(s, 58);
          if(end == ((char *)NULL))
            return -2;

          else
          {
            *end = (char)0;
            strncpy(record->type, s, (unsigned long int)15);
            record->type[(signed long int)15] = (char)0;
            s = end + (signed long int)1;
            end=strchr(s, 58);
            if(end == ((char *)NULL))
              return -2;

            else
            {
              *end = (char)0;
              strncpy(record->descr, s, (unsigned long int)50);
              record->descr[(signed long int)50] = (char)0;
              s = end + (signed long int)1;
              i = 0;
              do
              {
                end=strchr(s, 58);
                if(end == ((char *)NULL))
                  break;

                *end = (char)0;
                void *return_value_malloc$16;
                return_value_malloc$16=malloc((unsigned long int)(15 + 1));
                record->groups[(signed long int)i] = (char *)return_value_malloc$16;
                strncpy(record->groups[(signed long int)i], s, (unsigned long int)15);
                record->groups[(signed long int)i][(signed long int)15] = (char)0;
                i = i + 1;
                if(i >= 64)
                  break;

                s = end + (signed long int)1;
              }
              while((_Bool)1);
              void *return_value_malloc$17;
              return_value_malloc$17=malloc((unsigned long int)(15 + 1));
              record->groups[(signed long int)i] = (char *)return_value_malloc$17;
              strncpy(record->groups[(signed long int)i], s, (unsigned long int)15);
              record->groups[(signed long int)i][(signed long int)15] = (char)0;
              i = i + 1;
              record->groups[(signed long int)i] = (char *)(void *)0;
              return 1;
            }
          }
        }
      }
    }
}

// parse_request
// file request.c line 324
static signed int parse_request(struct ci_request *req, char *buf)
{
  char *start;
  char *end;
  signed int servnamelen;
  signed int len;
  signed int args_len;
  signed int vmajor;
  signed int vminor;
  struct ci_service_module *service = (struct ci_service_module *)(void *)0;
  struct service_alias *salias = (struct service_alias *)(void *)0;
  req->type=get_method(buf, &end);
  signed int return_value_strncasecmp$1;
  if(!(req->type >= 0))
    return 4;

  else
  {
    for( ; (signed int)*end == 32; end = end + 1l)
      ;
    start = end;
    signed int return_value_strncasecmp$2;
    return_value_strncasecmp$2=strncasecmp(start, "icap://", (unsigned long int)7);
    if(return_value_strncasecmp$2 == 0)
      start = start + (signed long int)7;

    else
    {
      return_value_strncasecmp$1=strncasecmp(start, "icaps://", (unsigned long int)8);
      if(return_value_strncasecmp$1 == 0)
        start = start + (signed long int)8;

      else
        return 4;
    }
    unsigned long int return_value_strcspn$3;
    return_value_strcspn$3=strcspn(start, "/ ");
    len = (signed int)return_value_strcspn$3;
    end = start + (signed long int)len;
    servnamelen = 256 > len ? len : 256;
    memcpy((void *)req->req_server, (const void *)start, (unsigned long int)servnamelen);
    req->req_server[(signed long int)servnamelen] = (char)0;
    if((signed int)*end == 47)
    {
      end = end + 1l;
      start = end;
      for( ; !(*end == 0); end = end + 1l)
      {
        if((signed int)*end == 32)
          break;

        if((signed int)*end == 63)
          break;

      }
      len = (signed int)(end - start);
      len = len < 63 ? len : 63;
      if(!(len == 0))
      {
        strncpy(req->service, start, (unsigned long int)len);
        req->service[(signed long int)len] = (char)0;
      }

      if((signed int)*end == 63)
      {
        end = end + 1l;
        start = end;
        end=strchr(start, 32);
        if(!(end == ((char *)NULL)))
        {
          unsigned long int return_value_strlen$4;
          return_value_strlen$4=strlen(req->args);
          args_len = (signed int)return_value_strlen$4;
          len = (signed int)(end - start);
          if(!(args_len == 0) && !(len == 0))
          {
            req->args[(signed long int)args_len] = (char)38;
            args_len = args_len + 1;
          }

          len = len < 255 - args_len ? len : 255 - args_len;
          strncpy(req->args + (signed long int)args_len, start, (unsigned long int)len);
          req->args[(signed long int)(args_len + len)] = (char)0;
        }

      }

    }

    for( ; (signed int)*end == 32; end = end + 1l)
      ;
    start = end;
    vmajor = -1;
    vminor = vmajor;
    signed int return_value_strncmp$7;
    return_value_strncmp$7=strncmp(start, "ICAP/", (unsigned long int)5);
    if(return_value_strncmp$7 == 0)
    {
      start = start + (signed long int)5;
      signed long int return_value_strtol$5;
      return_value_strtol$5=strtol(start, &end, 10);
      vmajor = (signed int)return_value_strtol$5;
      if(vmajor >= 1)
      {
        if((signed int)*end == 46)
        {
          start = end + (signed long int)1;
          signed long int return_value_strtol$6;
          return_value_strtol$6=strtol(start, &end, 10);
          vminor = (signed int)return_value_strtol$6;
          if(end == start)
            vminor = -1;

        }

      }

    }

    if(vminor == -1 || !(vmajor >= 1))
      return 4;

    else
    {
      if((signed int)req->service[0l] == 0)
      {
        if(!(DEFAULT_SERVICE == ((const char *)NULL)))
          strncpy(req->service, DEFAULT_SERVICE, (unsigned long int)63);

      }

      if(!((signed int)req->service[0l] == 0))
      {
        service=find_service(req->service);
        if(service == ((struct ci_service_module *)NULL))
        {
          salias=find_service_alias(req->service);
          if(!(salias == ((struct service_alias *)NULL)))
          {
            service = salias->service;
            if(!((signed int)salias->args[0l] == 0))
              strcpy(req->args, salias->args);

          }

        }

      }

      req->current_service_mod = service;
      if(req->current_service_mod == ((struct ci_service_module *)NULL))
        return 7;

      else
        if((req->current_service_mod->mod_type & req->type) == 0)
        {
          if(req->type == 0x01)
            goto __CPROVER_DUMP_L20;

          return 8;
        }

        else
        {

        __CPROVER_DUMP_L20:
          ;
          return 0;
        }
    }
  }
}

// pointers_cmp
// file array.c line 685
static signed int pointers_cmp(const void *obj1, const void *obj2, unsigned long int size)
{
  return obj1 == obj2 ? 0 : (obj1 > obj2 ? 1 : -1);
}

// pool_allocator_alloc
// file mem.c line 796
static void * pool_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size)
{
  struct mem_block_item *mem_item;
  void *data = (void *)0;
  struct pool_allocator *palloc = (struct pool_allocator *)allocator->data;
  if(!((unsigned long int)palloc->items_size >= size))
    return (void *)0;

  else
  {
    pthread_mutex_lock(&palloc->mutex);
    if(!(palloc->free == ((struct mem_block_item *)NULL)))
    {
      mem_item = palloc->free;
      palloc->free = palloc->free->next;
      data = mem_item->data;
      mem_item->data = (void *)0;
      palloc->hits_count = palloc->hits_count + 1;
    }

    else
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc(sizeof(struct mem_block_item) /*16ul*/ );
      mem_item = (struct mem_block_item *)return_value_malloc$1;
      mem_item->data = (void *)0;
      data=malloc((unsigned long int)palloc->items_size);
      palloc->alloc_count = palloc->alloc_count + 1;
    }
    mem_item->next = palloc->allocated;
    palloc->allocated = mem_item;
    pthread_mutex_unlock(&palloc->mutex);
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "pool hits:%d allocations: %d\n", palloc->hits_count, palloc->alloc_count);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("pool hits:%d allocations: %d\n", palloc->hits_count, palloc->alloc_count);

    }

    return data;
  }
}

// pool_allocator_build
// file mem.c line 775
static struct pool_allocator * pool_allocator_build(signed int items_size, signed int strict)
{
  struct pool_allocator *palloc;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct pool_allocator) /*72ul*/ );
  palloc = (struct pool_allocator *)return_value_malloc$1;
  if(palloc == ((struct pool_allocator *)NULL))
    return (struct pool_allocator *)(void *)0;

  else
  {
    palloc->items_size = items_size;
    palloc->strict = strict;
    palloc->free = (struct mem_block_item *)(void *)0;
    palloc->allocated = (struct mem_block_item *)(void *)0;
    palloc->alloc_count = 0;
    palloc->hits_count = 0;
    ci_thread_mutex_init(&palloc->mutex);
    return palloc;
  }
}

// pool_allocator_destroy
// file mem.c line 880
static void pool_allocator_destroy(struct ci_mem_allocator *allocator)
{
  pool_allocator_reset(allocator);
  struct pool_allocator *palloc = (struct pool_allocator *)allocator->data;
  ci_thread_mutex_destroy(&palloc->mutex);
  free((void *)palloc);
}

// pool_allocator_free
// file mem.c line 829
static void pool_allocator_free(struct ci_mem_allocator *allocator, void *p)
{
  struct mem_block_item *mem_item;
  struct pool_allocator *palloc = (struct pool_allocator *)allocator->data;
  pthread_mutex_lock(&palloc->mutex);
  if(palloc->allocated == ((struct mem_block_item *)NULL))
    free(p);

  else
  {
    mem_item = palloc->allocated;
    palloc->allocated = palloc->allocated->next;
    mem_item->data = p;
    mem_item->next = palloc->free;
    palloc->free = mem_item;
  }
  pthread_mutex_unlock(&palloc->mutex);
}

// pool_allocator_reset
// file mem.c line 850
static void pool_allocator_reset(struct ci_mem_allocator *allocator)
{
  struct mem_block_item *mem_item;
  struct mem_block_item *cur;
  struct pool_allocator *palloc = (struct pool_allocator *)allocator->data;
  pthread_mutex_lock(&palloc->mutex);
  if(!(palloc->allocated == ((struct mem_block_item *)NULL)))
  {
    mem_item = palloc->allocated;
    while(!(mem_item == ((struct mem_block_item *)NULL)))
    {
      cur = mem_item;
      mem_item = mem_item->next;
      free((void *)cur);
    }
  }

  palloc->allocated = (struct mem_block_item *)(void *)0;
  if(!(palloc->free == ((struct mem_block_item *)NULL)))
  {
    mem_item = palloc->free;
    while(!(mem_item == ((struct mem_block_item *)NULL)))
    {
      cur = mem_item;
      mem_item = mem_item->next;
      free(cur->data);
      free((void *)cur);
    }
  }

  palloc->free = (struct mem_block_item *)(void *)0;
  pthread_mutex_unlock(&palloc->mutex);
}

// posix_proc_mutex_destroy
// file os/unix/proc_mutex.c line 139
static signed int posix_proc_mutex_destroy(struct ci_proc_mutex *mutex)
{
  signed int return_value_sem_unlink$1;
  return_value_sem_unlink$1=sem_unlink(mutex->name);
  if(!(return_value_sem_unlink$1 >= 0))
    return 0;

  else
    return 1;
}

// posix_proc_mutex_init
// file os/unix/proc_mutex.c line 118
static signed int posix_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name)
{
  signed int i = 0;
  mutex->$anon0.posix.sem = (union anonymous$10 *)0;
  i = 0;
  for( ; !(i >= 1024); i = i + 1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 0;
    snprintf(mutex->name, (unsigned long int)64, "%s%s.%d", (const void *)"/c-icap-sem.", name, i);
    mutex->$anon0.posix.sem=sem_open(mutex->name, 0100 | 0200, 0400 | 0200 | 0400 >> 3, 1);
    if(!(mutex->$anon0.posix.sem == ((union anonymous$10 *)NULL)))
      return 1;

    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(!(*return_value___errno_location$2 == 17))
      break;

  }
  signed int *return_value___errno_location$5;
  return_value___errno_location$5=__errno_location();
  signed int *return_value___errno_location$3;
  signed int *return_value___errno_location$4;
  if(*return_value___errno_location$5 == 17)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocation posix proc mutex, to many c-icap mutexes are open!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocation posix proc mutex, to many c-icap mutexes are open!\n");

    }

  }

  else
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value___errno_location$3=__errno_location();
        __log_error((void *)0, "Error allocation posix proc mutex, errno: %d\n", *return_value___errno_location$3);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value___errno_location$4=__errno_location();
        printf("Error allocation posix proc mutex, errno: %d\n", *return_value___errno_location$4);
      }

    }

  return 0;
}

// posix_proc_mutex_lock
// file os/unix/proc_mutex.c line 147
static signed int posix_proc_mutex_lock(struct ci_proc_mutex *mutex)
{
  signed int return_value_sem_wait$1;
  return_value_sem_wait$1=sem_wait(mutex->$anon0.posix.sem);
  if(!(return_value_sem_wait$1 == 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Failed to get lock of posix mutex\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Failed to get lock of posix mutex\n");

    }

    return 0;
  }

  else
    return 1;
}

// posix_proc_mutex_print_info
// file os/unix/proc_mutex.c line 165
static signed int posix_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, buf_size, "posix:%s", (const void *)mutex->name);
  return return_value_snprintf$1;
}

// posix_proc_mutex_unlock
// file os/unix/proc_mutex.c line 156
static signed int posix_proc_mutex_unlock(struct ci_proc_mutex *mutex)
{
  signed int return_value_sem_post$1;
  return_value_sem_post$1=sem_post(mutex->$anon0.posix.sem);
  if(!(return_value_sem_post$1 == 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Failed to unlock of posix mutex\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Failed to unlock of posix mutex\n");

    }

    return 0;
  }

  else
    return 1;
}

// posix_shared_mem_attach
// file os/unix/shared_mem.c line 179
void * posix_shared_mem_attach(struct ci_shared_mem_id *id)
{
  return id->mem;
}

// posix_shared_mem_create
// file os/unix/shared_mem.c line 157
void * posix_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size)
{
  signed int i;
  id->size = (unsigned long int)size;
  i = 0;
  for( ; !(i >= 1024); i = i + 1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 0;
    snprintf(id->name, (unsigned long int)64, "%s-%s.%d", (const void *)"/c-icap-shared", name, i);
    id->$anon0.posix.fd=shm_open(id->name, 02 | 0100 | 0200, (unsigned int)(0400 | 0200));
    ftruncate64(id->$anon0.posix.fd, (signed long int)id->size);
    if(id->$anon0.posix.fd >= 0)
    {
      id->mem=mmap64((void *)0, (unsigned long int)size, 0x1 | 0x2, 0x01, id->$anon0.posix.fd, (signed long int)0);
      if(id->mem == (void *)-1)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Posix mem: Failed to created shared memory!\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Posix mem: Failed to created shared memory!\n");

        }

        return (void *)0;
      }

      return id->mem;
    }

  }
  return (void *)0;
}

// posix_shared_mem_destroy
// file os/unix/shared_mem.c line 192
signed int posix_shared_mem_destroy(struct ci_shared_mem_id *id)
{
  munmap(id->mem, id->size);
  close(id->$anon0.posix.fd);
  id->mem = (void *)0;
  shm_unlink(id->name);
  return 1;
}

// posix_shared_mem_detach
// file os/unix/shared_mem.c line 184
signed int posix_shared_mem_detach(struct ci_shared_mem_id *id)
{
  munmap(id->mem, id->size);
  id->mem = (void *)0;
  return 1;
}

// posix_shared_mem_print_info
// file os/unix/shared_mem.c line 201
signed int posix_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, buf_size, "posix:%s %ld kbs", (const void *)id->name, (signed long int)(id->size / (unsigned long int)1024));
  return return_value_snprintf$1;
}

// post_init_modules
// file include/module.h line 113
signed int post_init_modules()
{
  signed int i = 0;
  for( ; !(i >= common_modules.modules_num); i = i + 1)
    if(!(((struct common_module *)common_modules.modules[(signed long int)i])->post_init_module == ((signed int (*)(struct ci_server_conf *))NULL)))
      ((struct common_module *)common_modules.modules[(signed long int)i])->post_init_module(&CI_CONF);

  i = 0;
  for( ; !(i >= service_handlers.modules_num); i = i + 1)
    if(!(((struct service_handler_module *)service_handlers.modules[(signed long int)i])->post_init_service_handler == ((signed int (*)(struct ci_server_conf *))NULL)))
      ((struct service_handler_module *)service_handlers.modules[(signed long int)i])->post_init_service_handler(&CI_CONF);

  i = 0;
  for( ; !(i >= access_controllers.modules_num); i = i + 1)
    if(!(((struct access_control_module *)access_controllers.modules[(signed long int)i])->post_init_access_controller == ((signed int (*)(struct ci_server_conf *))NULL)))
      ((struct access_control_module *)access_controllers.modules[(signed long int)i])->post_init_access_controller(&CI_CONF);

  i = 0;
  for( ; !(i >= auth_methods.modules_num); i = i + 1)
    if(!(((struct http_auth_method *)auth_methods.modules[(signed long int)i])->post_init_auth_method == ((signed int (*)(struct ci_server_conf *))NULL)))
      ((struct http_auth_method *)auth_methods.modules[(signed long int)i])->post_init_auth_method(&CI_CONF);

  i = 0;
  for( ; !(i >= authenticators.modules_num); i = i + 1)
    if(!(((struct authenticator_module *)authenticators.modules[(signed long int)i])->post_init_authenticator == ((signed int (*)(struct ci_server_conf *))NULL)))
      ((struct authenticator_module *)authenticators.modules[(signed long int)i])->post_init_authenticator(&CI_CONF);

  return 1;
}

// post_init_services
// file include/service.h line 277
signed int post_init_services()
{
  signed int i;
  signed int ret;
  struct ci_service_xdata *xdata;
  i = 0;
  for( ; !(i >= services_num); i = i + 1)
    if(!(service_list[(signed long int)i]->mod_post_init_service == ((signed int (*)(struct ci_service_xdata *, struct ci_server_conf *))NULL)))
    {
      xdata = &service_extra_data_list[(signed long int)i];
      if(xdata->status == 0)
      {
        ret=service_list[(signed long int)i]->mod_post_init_service(xdata, &CI_CONF);
        if(!(ret == 1))
          xdata->status = 1;

      }

    }

  return 1;
}

// print_conf_variables
// file cfg_param.c line 314
void print_conf_variables(struct ci_conf_entry *table)
{
  signed int i = 0;
  for( ; !((table + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
  {
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "%s=", (table + (signed long int)i)->name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("%s=", (table + (signed long int)i)->name);

    }

    if((table + (signed long int)i)->data == NULL)
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("\n");

      }

    }

    else
      if((table + (signed long int)i)->action == intl_cfg_set_str)
      {
        if(!(*((char *)(table + (signed long int)i)->data) == 0))
        {
          if(CI_DEBUG_LEVEL >= 9)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "%s\n", *((char **)(table + (signed long int)i)->data));

            if(!(CI_DEBUG_STDOUT == 0))
              printf("%s\n", *((char **)(table + (signed long int)i)->data));

          }

        }

        else
          if(CI_DEBUG_LEVEL >= 9)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("\n");

          }

      }

      else
        if((table + (signed long int)i)->action == intl_cfg_set_int)
        {
          if(CI_DEBUG_LEVEL >= 9)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "%d\n", *((signed int *)(table + (signed long int)i)->data));

            if(!(CI_DEBUG_STDOUT == 0))
              printf("%d\n", *((signed int *)(table + (signed long int)i)->data));

          }

        }

        else
          if((table + (signed long int)i)->action == intl_cfg_size_off)
          {
            if(CI_DEBUG_LEVEL >= 9)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "%lld\n", (signed long long int)*((signed long int *)(table + (signed long int)i)->data));

              if(!(CI_DEBUG_STDOUT == 0))
                printf("%lld\n", (signed long long int)*((signed long int *)(table + (signed long int)i)->data));

            }

          }

          else
            if((table + (signed long int)i)->action == intl_cfg_size_long)
            {
              if(CI_DEBUG_LEVEL >= 9)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "%ld\n", *((signed long int *)(table + (signed long int)i)->data));

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("%ld\n", *((signed long int *)(table + (signed long int)i)->data));

              }

            }

            else
              if((table + (signed long int)i)->action == intl_cfg_onoff)
              {
                if(CI_DEBUG_LEVEL >= 9)
                {
                  if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                    __log_error((void *)0, "%d\n", *((signed int *)(table + (signed long int)i)->data));

                  if(!(CI_DEBUG_STDOUT == 0))
                    printf("%d\n", *((signed int *)(table + (signed long int)i)->data));

                }

              }

              else
                if((table + (signed long int)i)->action == intl_cfg_enable)
                {
                  if(CI_DEBUG_LEVEL >= 9)
                  {
                    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                      __log_error((void *)0, "%d\n", *((signed int *)(table + (signed long int)i)->data));

                    if(!(CI_DEBUG_STDOUT == 0))
                      printf("%d\n", *((signed int *)(table + (signed long int)i)->data));

                  }

                }

                else
                  if((table + (signed long int)i)->action == intl_cfg_disable)
                  {
                    if(CI_DEBUG_LEVEL >= 9)
                    {
                      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                        __log_error((void *)0, "%d\n", *((signed int *)(table + (signed long int)i)->data));

                      if(!(CI_DEBUG_STDOUT == 0))
                        printf("%d\n", *((signed int *)(table + (signed long int)i)->data));

                    }

                  }

                  else
                    if(!((table + (signed long int)i)->data == NULL))
                    {
                      if(CI_DEBUG_LEVEL >= 9)
                      {
                        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                          __log_error((void *)0, "%p\n", (table + (signed long int)i)->data);

                        if(!(CI_DEBUG_STDOUT == 0))
                          printf("%p\n", (table + (signed long int)i)->data);

                      }

                    }

  }
}

// print_variables
// file cfg_param.c line 355
signed int print_variables()
{
  signed int i;
  if(CI_DEBUG_LEVEL >= 9)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "\n\nPrinting variables\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("\n\nPrinting variables\n");

  }

  print_conf_variables(conf_variables);
  if(extra_conf_tables == ((struct sub_table *)NULL))
    return 1;

  else
  {
    i = 0;
    for( ; !(i >= conf_tables_num); i = i + 1)
      if(!((extra_conf_tables + (signed long int)i)->name == ((const char *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 9)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Printing variables in table %s\n", (extra_conf_tables + (signed long int)i)->name);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Printing variables in table %s\n", (extra_conf_tables + (signed long int)i)->name);

        }

        print_conf_variables((extra_conf_tables + (signed long int)i)->conf_table);
      }

    return 1;
  }
}

// process_encapsulated
// file include/request.h line 152
signed int process_encapsulated(struct ci_request *req, const char *buf)
{
  const char *start;
  const char *pos;
  char *end;
  signed int type = 0;
  signed int num = 0;
  signed int val = 0;
  signed int hasbody = 1;
  start = buf + (signed long int)13;
  pos = start;
  end = (char *)start;
  const unsigned short int **return_value___ctype_b_loc$1;
  _Bool tmp_if_expr$2;
  do
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*pos]) == 0))
      tmp_if_expr$2 = (signed int)*pos != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(!tmp_if_expr$2)
      break;

    pos = pos + 1l;
  }
  while((_Bool)1);
  const unsigned short int **return_value___ctype_b_loc$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  while(!((signed int)*pos == 0))
  {
    type=get_encaps_type(pos, &val, &end);
    if(!(type >= 0))
      return 4;

    if(num >= 6)
      break;

    if(type == 4)
      hasbody = 0;

    signed int tmp_post$3 = num;
    num = num + 1;
    req->entities[(signed long int)tmp_post$3]=ci_request_alloc_entity(req, type, val);
    /* assertion start != end */
    assert(start != end);
    pos = end;
    do
    {
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*pos]) == 0))
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)*pos == 44 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (signed int)*pos != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      if(!tmp_if_expr$6)
        break;

      pos = pos + 1l;
    }
    while((_Bool)1);
  }
  req->hasbody = hasbody;
  return 0;
}

// process_line
// file cfg_param.c line 787
signed int process_line(char *orig_line)
{
  char *str;
  char *args;
  char **argv = (char **)(void *)0;
  signed int ret = 1;
  struct ci_conf_entry *entry;
  char line[8192l];
  strncpy(line, orig_line, (unsigned long int)8192);
  line[(signed long int)(8192 - 1)] = (char)0;
  str = line;
  const unsigned short int **return_value___ctype_b_loc$1;
  for( ; !((signed int)*str == 0); str = str + 1l)
  {
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*str]) == 0)
      break;

  }
  _Bool tmp_if_expr$2;
  if((signed int)*str == 0)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)*str == 35 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    return 1;

  else
  {
    entry=find_action(str, &args);
    if(!(entry == ((struct ci_conf_entry *)NULL)))
    {
      if(!(entry->action == ((signed int (*)(const char *, const char **, void *))NULL)))
      {
        argv=split_args(args);
        signed int return_value;
        return_value=entry->action(entry->name, (const char **)argv, entry->data);
        if(return_value == 0)
          ret = 0;

        free_args(argv);
        return ret;
      }

    }

    return 0;
  }
}

// process_request
// file request.c line 1618
signed int process_request(struct ci_request *req)
{
  signed int res;
  struct ci_service_xdata *srv_xdata;
  res=do_request(req);
  if(!(req->pstrblock_read_len == 0))
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "There are unparsed data od size %d: \"%s\"\n. Move to connection buffer\n", req->pstrblock_read_len, req->pstrblock_read);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("There are unparsed data od size %d: \"%s\"\n. Move to connection buffer\n", req->pstrblock_read_len, req->pstrblock_read);

    }

  }

  if(!(res >= 0))
  {
    if(!(req->request_header->bufused == 0))
      goto __CPROVER_DUMP_L3;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    if(!(STATS == ((struct stat_area *)NULL)))
    {
      _Bool tmp_if_expr$1;
      if(!(req->return_code == 7))
        tmp_if_expr$1 = req->current_service_mod != ((struct ci_service_module *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        srv_xdata=service_data(req->current_service_mod);

      else
        srv_xdata = (struct ci_service_xdata *)(void *)0;
      pthread_mutex_lock(&STATS->mtx);
      if(STAT_REQUESTS >= 0)
        STATS->mem_block->counters64[(signed long int)STAT_REQUESTS] = STATS->mem_block->counters64[(signed long int)STAT_REQUESTS] + (unsigned long int)1;

      if(req->type == 0x02)
      {
        STATS->mem_block->counters64[(signed long int)STAT_REQMODS] = STATS->mem_block->counters64[(signed long int)STAT_REQMODS] + (unsigned long int)1;
        if(!(srv_xdata == ((struct ci_service_xdata *)NULL)))
          STATS->mem_block->counters64[(signed long int)srv_xdata->stat_reqmods] = STATS->mem_block->counters64[(signed long int)srv_xdata->stat_reqmods] + (unsigned long int)1;

      }

      else
        if(req->type == 0x04)
        {
          STATS->mem_block->counters64[(signed long int)STAT_RESPMODS] = STATS->mem_block->counters64[(signed long int)STAT_RESPMODS] + (unsigned long int)1;
          if(!(srv_xdata == ((struct ci_service_xdata *)NULL)))
            STATS->mem_block->counters64[(signed long int)srv_xdata->stat_respmods] = STATS->mem_block->counters64[(signed long int)srv_xdata->stat_respmods] + (unsigned long int)1;

        }

        else
          if(req->type == 0x01)
          {
            STATS->mem_block->counters64[(signed long int)STAT_OPTIONS] = STATS->mem_block->counters64[(signed long int)STAT_OPTIONS] + (unsigned long int)1;
            if(!(srv_xdata == ((struct ci_service_xdata *)NULL)))
              STATS->mem_block->counters64[(signed long int)srv_xdata->stat_options] = STATS->mem_block->counters64[(signed long int)srv_xdata->stat_options] + (unsigned long int)1;

          }

      if(STAT_FAILED_REQUESTS >= 0 && !(res >= 0))
        STATS->mem_block->counters64[(signed long int)STAT_FAILED_REQUESTS] = STATS->mem_block->counters64[(signed long int)STAT_FAILED_REQUESTS] + (unsigned long int)1;

      else
        if(req->return_code == 2)
        {
          STATS->mem_block->counters64[(signed long int)STAT_ALLOW204] = STATS->mem_block->counters64[(signed long int)STAT_ALLOW204] + (unsigned long int)1;
          if(!(srv_xdata == ((struct ci_service_xdata *)NULL)))
            STATS->mem_block->counters64[(signed long int)srv_xdata->stat_allow204] = STATS->mem_block->counters64[(signed long int)srv_xdata->stat_allow204] + (unsigned long int)1;

        }

      if(STAT_BYTES_IN >= 0)
      {
        (STATS->mem_block->counterskbs + (signed long int)STAT_BYTES_IN)->bytes = (STATS->mem_block->counterskbs + (signed long int)STAT_BYTES_IN)->bytes + (unsigned int)req->bytes_in;
        (STATS->mem_block->counterskbs + (signed long int)STAT_BYTES_IN)->kb = (STATS->mem_block->counterskbs + (signed long int)STAT_BYTES_IN)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)STAT_BYTES_IN)->bytes >> 10);
        (STATS->mem_block->counterskbs + (signed long int)STAT_BYTES_IN)->bytes = (STATS->mem_block->counterskbs + (signed long int)STAT_BYTES_IN)->bytes & (unsigned int)0x3FF;
      }

      if(STAT_BYTES_OUT >= 0)
      {
        (STATS->mem_block->counterskbs + (signed long int)STAT_BYTES_OUT)->bytes = (STATS->mem_block->counterskbs + (signed long int)STAT_BYTES_OUT)->bytes + (unsigned int)req->bytes_out;
        (STATS->mem_block->counterskbs + (signed long int)STAT_BYTES_OUT)->kb = (STATS->mem_block->counterskbs + (signed long int)STAT_BYTES_OUT)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)STAT_BYTES_OUT)->bytes >> 10);
        (STATS->mem_block->counterskbs + (signed long int)STAT_BYTES_OUT)->bytes = (STATS->mem_block->counterskbs + (signed long int)STAT_BYTES_OUT)->bytes & (unsigned int)0x3FF;
      }

      if(STAT_HTTP_BYTES_IN >= 0)
      {
        (STATS->mem_block->counterskbs + (signed long int)STAT_HTTP_BYTES_IN)->bytes = (STATS->mem_block->counterskbs + (signed long int)STAT_HTTP_BYTES_IN)->bytes + (unsigned int)req->http_bytes_in;
        (STATS->mem_block->counterskbs + (signed long int)STAT_HTTP_BYTES_IN)->kb = (STATS->mem_block->counterskbs + (signed long int)STAT_HTTP_BYTES_IN)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)STAT_HTTP_BYTES_IN)->bytes >> 10);
        (STATS->mem_block->counterskbs + (signed long int)STAT_HTTP_BYTES_IN)->bytes = (STATS->mem_block->counterskbs + (signed long int)STAT_HTTP_BYTES_IN)->bytes & (unsigned int)0x3FF;
      }

      if(STAT_HTTP_BYTES_OUT >= 0)
      {
        (STATS->mem_block->counterskbs + (signed long int)STAT_HTTP_BYTES_OUT)->bytes = (STATS->mem_block->counterskbs + (signed long int)STAT_HTTP_BYTES_OUT)->bytes + (unsigned int)req->http_bytes_out;
        (STATS->mem_block->counterskbs + (signed long int)STAT_HTTP_BYTES_OUT)->kb = (STATS->mem_block->counterskbs + (signed long int)STAT_HTTP_BYTES_OUT)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)STAT_HTTP_BYTES_OUT)->bytes >> 10);
        (STATS->mem_block->counterskbs + (signed long int)STAT_HTTP_BYTES_OUT)->bytes = (STATS->mem_block->counterskbs + (signed long int)STAT_HTTP_BYTES_OUT)->bytes & (unsigned int)0x3FF;
      }

      if(STAT_BODY_BYTES_IN >= 0)
      {
        (STATS->mem_block->counterskbs + (signed long int)STAT_BODY_BYTES_IN)->bytes = (STATS->mem_block->counterskbs + (signed long int)STAT_BODY_BYTES_IN)->bytes + (unsigned int)req->body_bytes_in;
        (STATS->mem_block->counterskbs + (signed long int)STAT_BODY_BYTES_IN)->kb = (STATS->mem_block->counterskbs + (signed long int)STAT_BODY_BYTES_IN)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)STAT_BODY_BYTES_IN)->bytes >> 10);
        (STATS->mem_block->counterskbs + (signed long int)STAT_BODY_BYTES_IN)->bytes = (STATS->mem_block->counterskbs + (signed long int)STAT_BODY_BYTES_IN)->bytes & (unsigned int)0x3FF;
      }

      if(STAT_BODY_BYTES_OUT >= 0)
      {
        (STATS->mem_block->counterskbs + (signed long int)STAT_BODY_BYTES_OUT)->bytes = (STATS->mem_block->counterskbs + (signed long int)STAT_BODY_BYTES_OUT)->bytes + (unsigned int)req->body_bytes_out;
        (STATS->mem_block->counterskbs + (signed long int)STAT_BODY_BYTES_OUT)->kb = (STATS->mem_block->counterskbs + (signed long int)STAT_BODY_BYTES_OUT)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)STAT_BODY_BYTES_OUT)->bytes >> 10);
        (STATS->mem_block->counterskbs + (signed long int)STAT_BODY_BYTES_OUT)->bytes = (STATS->mem_block->counterskbs + (signed long int)STAT_BODY_BYTES_OUT)->bytes & (unsigned int)0x3FF;
      }

      if(!(srv_xdata == ((struct ci_service_xdata *)NULL)))
      {
        if(srv_xdata->stat_bytes_in >= 0)
        {
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_bytes_in)->bytes = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_bytes_in)->bytes + (unsigned int)req->bytes_in;
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_bytes_in)->kb = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_bytes_in)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_bytes_in)->bytes >> 10);
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_bytes_in)->bytes = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_bytes_in)->bytes & (unsigned int)0x3FF;
        }

        if(srv_xdata->stat_bytes_out >= 0)
        {
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_bytes_out)->bytes = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_bytes_out)->bytes + (unsigned int)req->bytes_out;
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_bytes_out)->kb = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_bytes_out)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_bytes_out)->bytes >> 10);
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_bytes_out)->bytes = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_bytes_out)->bytes & (unsigned int)0x3FF;
        }

        if(srv_xdata->stat_http_bytes_in >= 0)
        {
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_http_bytes_in)->bytes = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_http_bytes_in)->bytes + (unsigned int)req->http_bytes_in;
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_http_bytes_in)->kb = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_http_bytes_in)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_http_bytes_in)->bytes >> 10);
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_http_bytes_in)->bytes = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_http_bytes_in)->bytes & (unsigned int)0x3FF;
        }

        if(srv_xdata->stat_http_bytes_out >= 0)
        {
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_http_bytes_out)->bytes = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_http_bytes_out)->bytes + (unsigned int)req->http_bytes_out;
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_http_bytes_out)->kb = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_http_bytes_out)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_http_bytes_out)->bytes >> 10);
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_http_bytes_out)->bytes = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_http_bytes_out)->bytes & (unsigned int)0x3FF;
        }

        if(srv_xdata->stat_body_bytes_in >= 0)
        {
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_body_bytes_in)->bytes = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_body_bytes_in)->bytes + (unsigned int)req->body_bytes_in;
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_body_bytes_in)->kb = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_body_bytes_in)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_body_bytes_in)->bytes >> 10);
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_body_bytes_in)->bytes = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_body_bytes_in)->bytes & (unsigned int)0x3FF;
        }

        if(srv_xdata->stat_body_bytes_out >= 0)
        {
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_body_bytes_out)->bytes = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_body_bytes_out)->bytes + (unsigned int)req->body_bytes_out;
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_body_bytes_out)->kb = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_body_bytes_out)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_body_bytes_out)->bytes >> 10);
          (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_body_bytes_out)->bytes = (STATS->mem_block->counterskbs + (signed long int)srv_xdata->stat_body_bytes_out)->bytes & (unsigned int)0x3FF;
        }

      }

      pthread_mutex_unlock(&STATS->mtx);
    }

    return res;
  }
}

// put_to_queue
// file proc_threads_queues.c line 68
signed int put_to_queue(struct connections_queue *q, struct ci_connection *con)
{
  signed int ret;
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&q->queue_mtx);
  if(!(return_value_pthread_mutex_lock$1 == 0))
    return -1;

  else
    if(q->used == q->size)
    {
      pthread_mutex_unlock(&q->queue_mtx);
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "put_to_queue_fatal error used=%d size=%d\n", q->used, q->size);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("put_to_queue_fatal error used=%d size=%d\n", q->used, q->size);

      }

      return 0;
    }

    else
    {
      ci_copy_connection(&q->connections[(signed long int)q->used], con);
      q->used = q->used + 1;
      ret = q->used;
      pthread_mutex_unlock(&q->queue_mtx);
      pthread_cond_signal(&q->queue_cond);
      return ret;
    }
}

// read_encaps_header
// file request.c line 253
static signed int read_encaps_header(struct ci_request *req, struct ci_headers_list *h, signed int size)
{
  signed int bytes = 0;
  signed int remains;
  signed int readed = 0;
  char *buf_end = (char *)(void *)0;
  signed int return_value_ci_headers_setsize$1;
  return_value_ci_headers_setsize$1=ci_headers_setsize(h, size + (CHECK_FOR_BUGGY_CLIENT != 0 ? 2 : 0));
  signed int return_value_strncmp$4;
  if(return_value_ci_headers_setsize$1 == 0)
    return 11;

  else
  {
    buf_end = h->buf;
    if(req->pstrblock_read_len >= 1)
    {
      signed int tmp_if_expr$2;
      if(!(req->pstrblock_read_len >= size))
        tmp_if_expr$2 = req->pstrblock_read_len;

      else
        tmp_if_expr$2 = size;
      readed = tmp_if_expr$2;
      memcpy((void *)h->buf, (const void *)req->pstrblock_read, (unsigned long int)readed);
      buf_end = h->buf + (signed long int)readed;
      if(req->pstrblock_read_len >= size)
      {
        req->pstrblock_read = req->pstrblock_read + (signed long int)readed;
        req->pstrblock_read_len = req->pstrblock_read_len - readed;
      }

      else
      {
        req->pstrblock_read = (char *)(void *)0;
        req->pstrblock_read_len = 0;
      }
    }

    remains = size - readed;
    while(remains >= 1)
    {
      signed int return_value_wait_for_data$3;
      return_value_wait_for_data$3=wait_for_data(req->connection->fd, TIMEOUT, 0x1);
      if(return_value_wait_for_data$3 == -1)
        return -1;

      bytes=ci_read_nonblock(req->connection->fd, (void *)buf_end, (unsigned long int)remains);
      if(!(bytes >= 1))
        return -1;

      remains = remains - bytes;
      buf_end = buf_end + (signed long int)bytes;
      req->bytes_in = req->bytes_in + (unsigned long int)bytes;
    }
    h->bufused = (signed int)(buf_end - h->buf);
    signed int return_value_strncmp$5;
    return_value_strncmp$5=strncmp(buf_end - (signed long int)4, "\r\n\r\n", (unsigned long int)4);
    if(return_value_strncmp$5 == 0)
      h->bufused = h->bufused - 2;

    else
      if(!(CHECK_FOR_BUGGY_CLIENT == 0))
      {
        return_value_strncmp$4=strncmp(buf_end - (signed long int)2, "\r\n", (unsigned long int)2);
        if(!(return_value_strncmp$4 == 0))
        {
          *buf_end = (char)13;
          buf_end[(signed long int)1] = (char)10;
          h->bufused = h->bufused + 2;
        }

      }

    req->http_bytes_in = req->http_bytes_in + (unsigned long int)size;
    req->request_bytes_in = req->request_bytes_in + (unsigned long int)size;
    return 0;
  }
}

// read_preview_data
// file request.c line 560
static signed int read_preview_data(struct ci_request *req)
{
  signed int ret;
  char *wdata;
  req->current_chunk_len = (unsigned int)0;
  req->chunk_bytes_read = (unsigned int)0;
  req->write_to_module_pending = (unsigned int)0;
  if(req->pstrblock_read_len == 0)
  {
    signed int return_value_wait_for_data$1;
    return_value_wait_for_data$1=wait_for_data(req->connection->fd, TIMEOUT, 0x1);
    if(!(return_value_wait_for_data$1 >= 0))
      return -1;

    signed int return_value_net_data_read$2;
    return_value_net_data_read$2=net_data_read(req);
    if(return_value_net_data_read$2 == -1)
      return -1;

  }

  do
  {

  __CPROVER_DUMP_L3:
    ;
    ret=parse_chunk_data(req, &wdata);
    if(ret == -1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error parsing chunks, current chunk len: %d readed:%d, str:%s\n", req->current_chunk_len, req->chunk_bytes_read, req->pstrblock_read);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error parsing chunks, current chunk len: %d readed:%d, str:%s\n", req->current_chunk_len, req->chunk_bytes_read, req->pstrblock_read);

      }

      return -1;
    }

    signed int return_value_ci_buf_write$3;
    return_value_ci_buf_write$3=ci_buf_write(&req->preview_data, wdata, (signed int)req->write_to_module_pending);
    if(!(return_value_ci_buf_write$3 >= 0))
      return -1;

    req->write_to_module_pending = (unsigned int)0;
    if(ret == -2)
    {
      req->pstrblock_read = (char *)(void *)0;
      req->pstrblock_read_len = 0;
      if(!(req->eof_received == 0))
        return -2;

      return 1;
    }

    if(!(ret == 2))
      goto __CPROVER_DUMP_L3;

    signed int return_value_wait_for_data$4;
    return_value_wait_for_data$4=wait_for_data(req->connection->fd, TIMEOUT, 0x1);
    if(!(return_value_wait_for_data$4 >= 0))
      return -1;

    signed int return_value_net_data_read$5;
    return_value_net_data_read$5=net_data_read(req);
    if(return_value_net_data_read$5 == -1)
      return -1;

  }
  while((_Bool)1);
  return -1;
}

// read_row
// file lookup_file_table.c line 102
signed int read_row(struct _IO_FILE *f, signed int cols, struct text_table_entry **e, struct ci_lookup_table *table)
{
  char line[65536l];
  char *s;
  char *val;
  char *end;
  signed int row_cols;
  signed int line_len;
  signed int i;
  struct ci_mem_allocator *allocator = table->allocator;
  const struct ci_type_ops *key_ops = table->key_ops;
  const struct ci_type_ops *val_ops = table->val_ops;
  *e = (struct text_table_entry *)(void *)0;
  char *return_value_fgets$1;
  return_value_fgets$1=fgets(line, 65535, f);
  unsigned long int return_value_strlen$3;
  if(return_value_fgets$1 == ((char *)NULL))
    return 0;

  else
  {
    line[(signed long int)65535] = (char)0;
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(line);
    line_len = (signed int)return_value_strlen$2;
    if(line_len >= 65536)
    {
      line[(signed long int)64] = (char)0;
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Too long line: %s...", (const void *)line);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Too long line: %s...", (const void *)line);

      }

      return 0;
    }

    else
    {
      if((signed int)line[(signed long int)(line_len + -1)] == 10)
        line[(signed long int)(line_len - 1)] = (char)0;

      s = line;
      for( ; (_Bool)1; s = s + 1l)
        if(!((signed int)*s == 32))
        {
          if(!((signed int)*s == 9))
            goto __CPROVER_DUMP_L8;

        }


    __CPROVER_DUMP_L8:
      ;
      if((signed int)*s == 35)
        return 1;

      else
        if((signed int)*s == 0)
          return 1;

        else
        {
          if(!(cols >= 0))
          {
            s=index(line, 58);
            if(s == ((char *)NULL))
              row_cols = 1;

            else
            {
              row_cols = 2;
              do
              {
                s=index(s, 44);
                if(s == ((char *)NULL))
                  break;

                row_cols = row_cols + 1;
                s = s + 1l;
              }
              while((_Bool)1);
            }
          }

          else
            row_cols = cols;
          *e=alloc_text_table_entry(row_cols - 1, allocator);
          if(*e == ((struct text_table_entry *)NULL))
          {
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error allocating memory for table entry:%s\n", (const void *)line);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error allocating memory for table entry:%s\n", (const void *)line);

            }

            return 0;
          }

          else
          {
            s = line;
            for( ; (_Bool)1; s = s + 1l)
              if(!((signed int)*s == 32))
              {
                if(!((signed int)*s == 9))
                  goto __CPROVER_DUMP_L21;

              }


          __CPROVER_DUMP_L21:
            ;
            val = s;
            end = (char *)(void *)0;
            if(row_cols >= 2)
              end=index(s, 58);

            if(end == ((char *)NULL))
            {
              return_value_strlen$3=strlen(s);
              end = s + (signed long int)return_value_strlen$3;
            }

            s = end + (signed long int)1;
            end = end - 1l;
            for( ; (_Bool)1; end = end - 1l)
              if(!((signed int)*end == 32))
              {
                if(!((signed int)*end == 9))
                  goto __CPROVER_DUMP_L26;

              }


          __CPROVER_DUMP_L26:
            ;
            end[(signed long int)1] = (char)0;
            (*e)->key=key_ops->dup(val, allocator);
            if((*e)->key == NULL)
            {
              if(CI_DEBUG_LEVEL >= 1)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "Error reading key in line:%s\n", (const void *)line);

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("Error reading key in line:%s\n", (const void *)line);

              }

              release_text_table_entry(*e, table);
              *e = (struct text_table_entry *)(void *)0;
              return -1;
            }

            else
            {
              if(row_cols >= 2)
              {
                /* assertion (*e)->vals */
                assert((*e)->vals != ((void **)NULL));
                i = 0;
                if(!((signed int)*s == 0))
                {
                  if(i >= row_cols)
                  {
                    if(CI_DEBUG_LEVEL >= 1)
                    {
                      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                        __log_error((void *)0, "Error in read_row of file lookup table!(line:%s)\n", (const void *)line);

                      if(!(CI_DEBUG_STDOUT == 0))
                        printf("Error in read_row of file lookup table!(line:%s)\n", (const void *)line);

                    }

                    release_text_table_entry(*e, table);
                    *e = (struct text_table_entry *)(void *)0;
                    return -1;
                  }

                  if((signed int)*s == 32)
                    s = s + 1l;

                  val = s;
                  end = s;
                  if(!((signed int)*end == 44))
                  {
                    if(!((signed int)*end == 0))
                      end = end + 1l;

                  }

                  if((signed int)*end == 0)
                    s = end;

                  else
                    s = end + (signed long int)1;
                  end = end - 1l;
                  if((signed int)*end == 32)
                    end = end - 1l;

                  end[(signed long int)1] = (char)0;
                  (*e)->vals[(signed long int)i]=val_ops->dup(val, allocator);
                  i = i + 1;
                }

                (*e)->vals[(signed long int)i] = (void *)0;
              }

              return 1;
            }
          }
        }
    }
  }
}

// reconfig
// file cfg_param.c line 899
signed int reconfig()
{
  cfg_default_value_restore_all();
  ci_cfg_lib_reset();
  signed int return_value_ci_args_apply$1;
  return_value_ci_args_apply$1=ci_args_apply(ARGC, ARGV, options);
  if(return_value_ci_args_apply$1 == 0)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error in command line options, while reconfiguring!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error in command line options, while reconfiguring!\n");

    }

    return 0;
  }

  else
  {
    signed int return_value_parse_file$2;
    return_value_parse_file$2=parse_file(CI_CONF.cfg_file);
    if(return_value_parse_file$2 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error opening/parsing config file, while reconfiguring!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error opening/parsing config file, while reconfiguring!\n");

      }

      return 0;
    }

    else
      return 1;
  }
}

// reconfigure_command
// file mpmt_server.c line 999
void reconfigure_command(const char *name, signed int type, const char **argv)
{
  if(type == 1)
    c_icap_reconfigure = 1;

}

// recycle_request
// file request.c line 127
signed int recycle_request(struct ci_request *req, struct ci_connection *connection)
{
  signed int access;
  signed int len;
  ci_request_reset(req);
  ci_copy_connection(req->connection, connection);
  access=access_check_client(req);
  if(access == -1)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen("ICAP/1.0 403 Forbidden\r\n\r\n");
    len = (signed int)return_value_strlen$1;
    ci_write(connection->fd, (const void *)"ICAP/1.0 403 Forbidden\r\n\r\n", (unsigned long int)len, TIMEOUT);
    return 0;
  }

  req->access_type = access;
  return 1;
}

// regex_cmp
// file types_ops.c line 271
signed int regex_cmp(const void *key1, const void *key2)
{
  struct ci_acl_regex *reg = (struct ci_acl_regex *)key1;
  if(key2 == NULL)
    return -1;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen((const char *)key2);
    signed int return_value_ci_regex_apply$2;
    return_value_ci_regex_apply$2=ci_regex_apply(reg->preg, (const char *)key2, (signed int)return_value_strlen$1, 0, (struct ci_list *)(void *)0, (void *)0);
    return return_value_ci_regex_apply$2 == 0 ? 1 : 0;
  }
}

// regex_dup
// file types_ops.c line 238
void * regex_dup(const char *str, struct ci_mem_allocator *allocator)
{
  struct ci_acl_regex *reg;
  char *newstr;
  signed int flags;
  signed int recursive;
  newstr=ci_regex_parse(str, &flags, &recursive);
  if(newstr == ((char *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Parse error, while parsing regex: '%s')!\n", str);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Parse error, while parsing regex: '%s')!\n", str);

    }

    return (void *)0;
  }

  else
  {
    void *return_value;
    return_value=allocator->alloc(allocator, sizeof(struct ci_acl_regex) /*24ul*/ );
    reg = (struct ci_acl_regex *)return_value;
    if(reg == ((struct ci_acl_regex *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error allocating memory for regex_dup (1)!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error allocating memory for regex_dup (1)!\n");

      }

      free((void *)newstr);
      return (void *)0;
    }

    else
    {
      reg->preg=ci_regex_build(newstr, flags);
      if(reg->preg == NULL)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error compiling regular expression :%s (%s)\n", str, newstr);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error compiling regular expression :%s (%s)\n", str, newstr);

        }

        allocator->free(allocator, (void *)reg);
        free((void *)newstr);
        return (void *)0;
      }

      else
      {
        reg->str = newstr;
        reg->flags = flags;
        return (void *)reg;
      }
    }
  }
}

// regex_equal
// file types_ops.c line 279
signed int regex_equal(const void *key1, const void *key2)
{
  struct ci_acl_regex *reg = (struct ci_acl_regex *)key1;
  if(key2 == NULL)
    return 0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen((const char *)key2);
    signed int return_value_ci_regex_apply$2;
    return_value_ci_regex_apply$2=ci_regex_apply(reg->preg, (const char *)key2, (signed int)return_value_strlen$1, 0, (struct ci_list *)(void *)0, (void *)0);
    return (signed int)(return_value_ci_regex_apply$2 != 0);
  }
}

// regex_free
// file types_ops.c line 292
void regex_free(void *key, struct ci_mem_allocator *allocator)
{
  struct ci_acl_regex *reg = (struct ci_acl_regex *)key;
  ci_regex_free(reg->preg);
  allocator->free(allocator, (void *)reg->str);
  allocator->free(allocator, (void *)reg);
}

// regex_len
// file types_ops.c line 287
unsigned long int regex_len(const void *key)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(((struct ci_acl_regex *)key)->str);
  return return_value_strlen$1;
}

// regex_table_close
// file lookup_file_table.c line 440
void regex_table_close(struct ci_lookup_table *table)
{
  file_table_close(table);
}

// regex_table_open
// file lookup_file_table.c line 419
void * regex_table_open(struct ci_lookup_table *table)
{
  struct text_table *text_table;
  if(!(table->key_ops == &ci_str_ops))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "This type of table is not compatible with regex tables!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("This type of table is not compatible with regex tables!\n");

    }

    return (void *)0;
  }

  else
  {
    table->key_ops = &ci_regex_ops;
    void *return_value_file_table_open$1;
    return_value_file_table_open$1=file_table_open(table);
    text_table = (struct text_table *)return_value_file_table_open$1;
    if(text_table == ((struct text_table *)NULL))
      return (void *)0;

    else
      return (void *)text_table;
  }
}

// regex_table_release_result
// file lookup_file_table.c line 461
void regex_table_release_result(struct ci_lookup_table *table_data, void **val)
{
  ;
}

// regex_table_search
// file lookup_file_table.c line 451
void * regex_table_search(struct ci_lookup_table *table, void *key, void ***vals)
{
  void *return_value_file_table_search$1;
  return_value_file_table_search$1=file_table_search(table, key, vals);
  return return_value_file_table_search$1;
}

// register_child
// file proc_threads_queues.c line 243
struct child_shared_data * register_child(struct childs_queue *q, signed int pid, signed int maxservers, signed int pipe)
{
  signed int i;
  if(q->childs == ((struct child_shared_data *)NULL))
    return (struct child_shared_data *)(void *)0;

  else
  {
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Register in shared mem, qsize=%d stat_block_size=%d childshared data:%d\n", q->size, q->stats_block_size, (signed int)sizeof(struct child_shared_data) /*56ul*/  * q->size);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Register in shared mem, qsize=%d stat_block_size=%d childshared data:%d\n", q->size, q->stats_block_size, (signed int)sizeof(struct child_shared_data) /*56ul*/  * q->size);

    }

    ci_proc_mutex_lock(&q->queue_mtx);
    i = 0;
    for( ; !(i >= q->size); i = i + 1)
      if((q->childs + (signed long int)i)->pid == 0)
      {
        (q->childs + (signed long int)i)->pid = pid;
        (q->childs + (signed long int)i)->freeservers = maxservers;
        (q->childs + (signed long int)i)->usedservers = 0;
        (q->childs + (signed long int)i)->requests = 0;
        (q->childs + (signed long int)i)->connections = 0;
        (q->childs + (signed long int)i)->to_be_killed = 0;
        (q->childs + (signed long int)i)->father_said = 0;
        (q->childs + (signed long int)i)->idle = 1;
        (q->childs + (signed long int)i)->pipe = pipe;
        (q->childs + (signed long int)i)->stats = (struct stat_memblock *)((void *)q->childs + (signed long int)(sizeof(struct child_shared_data) /*56ul*/  * (unsigned long int)q->size) + (signed long int)(i * q->stats_block_size));
        /* assertion q->childs[i].stats->sig == 0xFAFA */
        assert((q->childs + (signed long int)i)->stats->sig == (unsigned int)0xFAFA);
        (q->childs + (signed long int)i)->stats_size = q->stats_block_size;
        ci_proc_mutex_unlock(&q->queue_mtx);
        return &q->childs[(signed long int)i];
      }

    ci_proc_mutex_unlock(&q->queue_mtx);
    return (struct child_shared_data *)(void *)0;
  }
}

// register_command
// file include/commands.h line 54
void register_command(const char *name, signed int type, void (*command_action)(const char *, signed int, const char **))
{
  if((7 & type) == 0)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Can not register command %s ! Wrong type\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Can not register command %s ! Wrong type\n", name);

    }

  }

  else
  {
    struct ci_command cmd;
    strncpy(cmd.name, name, (unsigned long int)128);
    cmd.name[(signed long int)(128 - 1)] = (char)0;
    cmd.type = type;
    cmd.data = (void *)0;
    cmd.$anon0.command_action = command_action;
    pthread_mutex_lock(&COMMANDS_MTX);
    ci_list_push(COMMANDS_LIST, (const void *)&cmd);
    pthread_mutex_unlock(&COMMANDS_MTX);
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Command %s registered\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Command %s registered\n", name);

    }

  }
}

// register_command_extend
// file commands.c line 70
void register_command_extend(const char *name, signed int type, void *data, void (*command_action)(const char *, signed int, void *))
{
  if(!(type == 8) && !(type == 16) && !(type == 32))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Can not register extend command %s ! wrong type\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Can not register extend command %s ! wrong type\n", name);

    }

  }

  else
  {
    struct ci_command cmd;
    strncpy(cmd.name, name, (unsigned long int)128);
    cmd.name[(signed long int)(128 - 1)] = (char)0;
    cmd.type = type;
    cmd.data = data;
    cmd.$anon0.command_action_extend = command_action;
    pthread_mutex_lock(&COMMANDS_MTX);
    ci_list_push(COMMANDS_LIST, (const void *)&cmd);
    pthread_mutex_unlock(&COMMANDS_MTX);
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Extend command %s registered\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Extend command %s registered\n", name);

    }

  }
}

// register_conf_table
// file cfg_param.c line 231
signed int register_conf_table(const char *name, struct ci_conf_entry *table, signed int type)
{
  struct sub_table *new;
  signed int i;
  signed int insert_pos;
  signed int return_value_strcmp$1;
  if(extra_conf_tables == ((struct sub_table *)NULL))
    return 0;

  else
  {
    insert_pos = -1;
    i = 0;
    for( ; !(i >= conf_tables_num) && !(insert_pos >= 0); i = i + 1)
    {
      _Bool tmp_if_expr$2;
      if(!((extra_conf_tables + (signed long int)i)->name == ((const char *)NULL)))
      {
        return_value_strcmp$1=strcmp(name, (extra_conf_tables + (signed long int)i)->name);
        tmp_if_expr$2 = return_value_strcmp$1 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Config table :%s already exists!\n", name);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Config table :%s already exists!\n", name);

        }

        return 0;
      }

      else
        if((extra_conf_tables + (signed long int)i)->name == ((const char *)NULL))
          insert_pos = i;

    }
    if(!(insert_pos >= 0))
    {
      insert_pos = conf_tables_num;
      if(conf_tables_num == conf_tables_list_size)
      {
        void *return_value_realloc$3;
        return_value_realloc$3=realloc((void *)extra_conf_tables, sizeof(struct sub_table) /*24ul*/  * (unsigned long int)(conf_tables_list_size + 10));
        new = (struct sub_table *)return_value_realloc$3;
        if(new == ((struct sub_table *)NULL))
          return 0;

        extra_conf_tables = new;
        conf_tables_list_size = conf_tables_list_size + 10;
      }

      conf_tables_num = conf_tables_num + 1;
    }

    if(CI_DEBUG_LEVEL >= 10)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registering conf table:%s\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registering conf table:%s\n", name);

    }

    (extra_conf_tables + (signed long int)insert_pos)->name = name;
    (extra_conf_tables + (signed long int)insert_pos)->type = type;
    (extra_conf_tables + (signed long int)insert_pos)->conf_table = table;
    return 1;
  }
}

// register_module
// file include/module.h line 114
void * register_module(const char *module_file, const char *type)
{
  void *module = (void *)0;
  signed int mod_type;
  struct modules_list *l = (struct modules_list *)(void *)0;
  struct module_tmp_struct *check_mod;
  signed int check_mod_type;
  mod_type=module_type(type);
  l = modules_lists_table[(signed long int)mod_type];
  if(l == ((struct modules_list *)NULL))
    return (void *)0;

  else
  {
    module=load_module(module_file);
    if(module == NULL)
    {
      if(CI_DEBUG_LEVEL >= 3)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error while loading  module %s\n", module_file);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error while loading  module %s\n", module_file);

      }

      return (void *)0;
    }

    else
    {
      check_mod = (struct module_tmp_struct *)module;
      void *return_value_find_module$1;
      return_value_find_module$1=find_module(check_mod->name, &check_mod_type);
      if(!(return_value_find_module$1 == NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error, the module %s is already loaded\n", check_mod->name);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error, the module %s is already loaded\n", check_mod->name);

        }

        return (void *)0;
      }

      else
      {
        init_module(module, (enum module_type)mod_type);
        add_to_modules_list(l, module);
        return module;
      }
    }
  }
}

// register_service
// file include/service.h line 270
struct ci_service_module * register_service(const char *service_file)
{
  struct ci_service_module *service;
  service=create_service(service_file);
  if(service == ((struct ci_service_module *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 3)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error while loading service %s\n", service_file);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error while loading service %s\n", service_file);

    }

    return (struct ci_service_module *)(void *)0;
  }

  else
  {
    struct ci_service_module *return_value_find_service$1;
    return_value_find_service$1=find_service(service->mod_name);
    if(!(return_value_find_service$1 == ((struct ci_service_module *)NULL)))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error, the service %s  is already loaded\n", service->mod_name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error, the service %s  is already loaded\n", service->mod_name);

      }

      return (struct ci_service_module *)(void *)0;
    }

    else
    {
      struct ci_service_module *return_value_add_service$2;
      return_value_add_service$2=add_service(service);
      return return_value_add_service$2;
    }
  }
}

// release_auth_hash
// file module.c line 444
void release_auth_hash(struct auth_hash *hash)
{
  signed int i = 0;
  for( ; !(i >= hash->hash_size); i = i + 1)
    if(!(hash->hash[(signed long int)i] == ((struct authenticator_module **)NULL)))
      free((void *)hash->hash[(signed long int)i]);

  free((void *)hash->hash);
  hash->hash = (struct authenticator_module ***)(void *)0;
}

// release_body_system
// file body.c line 74
void release_body_system()
{
  ci_object_pool_unregister(MEMBUF_POOL);
  ci_object_pool_unregister(CACHED_FILE_POOL);
  ci_object_pool_unregister(SIMPLE_FILE_POOL);
  ci_object_pool_unregister(RING_BUF_POOL);
}

// release_c_handler
// file service.c line 626
void release_c_handler()
{
  ;
}

// release_header_value
// file acl.c line 898
void release_header_value(struct ci_headers_list *headers, char *head)
{
  if(!(headers == ((struct ci_headers_list *)NULL)))
  {
    if(!(headers->packed == 0))
    {
      if(!(head == ((char *)NULL)))
        ci_buffer_free((void *)head);

    }

  }

}

// release_modules
// file module.c line 659
signed int release_modules()
{
  signed int i;
  log_reset();
  access_reset();
  i = 0;
  for( ; !(i >= service_handlers.modules_num); i = i + 1)
    if(!(((struct service_handler_module *)service_handlers.modules[(signed long int)i])->release_service_handler == ((void (*)())NULL)))
      ((struct service_handler_module *)service_handlers.modules[(signed long int)i])->release_service_handler();

  free((void *)service_handlers.modules);
  service_handlers.modules = (void **)(void *)0;
  service_handlers.list_size = 0;
  service_handlers.modules_num = 0;
  i = 0;
  for( ; !(i >= loggers.modules_num); i = i + 1)
    if(!(((struct logger_module *)loggers.modules[(signed long int)i])->log_close == ((void (*)())NULL)))
      ((struct logger_module *)loggers.modules[(signed long int)i])->log_close();

  free((void *)loggers.modules);
  loggers.modules = (void **)(void *)0;
  loggers.list_size = 0;
  loggers.modules_num = 0;
  i = 0;
  for( ; !(i >= access_controllers.modules_num); i = i + 1)
    if(!(((struct access_control_module *)access_controllers.modules[(signed long int)i])->release_access_controller == ((void (*)())NULL)))
      ((struct access_control_module *)access_controllers.modules[(signed long int)i])->release_access_controller(&CI_CONF);

  free((void *)access_controllers.modules);
  access_controllers.modules = (void **)(void *)0;
  access_controllers.list_size = 0;
  access_controllers.modules_num = 0;
  i = 0;
  for( ; !(i >= auth_methods.modules_num); i = i + 1)
    if(!(((struct http_auth_method *)auth_methods.modules[(signed long int)i])->close_auth_method == ((void (*)())NULL)))
      ((struct http_auth_method *)auth_methods.modules[(signed long int)i])->close_auth_method(&CI_CONF);

  free((void *)auth_methods.modules);
  auth_methods.modules = (void **)(void *)0;
  auth_methods.list_size = 0;
  auth_methods.modules_num = 0;
  i = 0;
  for( ; !(i >= authenticators.modules_num); i = i + 1)
    if(!(((struct authenticator_module *)authenticators.modules[(signed long int)i])->close_authenticator == ((void (*)())NULL)))
      ((struct authenticator_module *)authenticators.modules[(signed long int)i])->close_authenticator(&CI_CONF);

  free((void *)authenticators.modules);
  authenticators.modules = (void **)(void *)0;
  authenticators.list_size = 0;
  authenticators.modules_num = 0;
  i = common_modules.modules_num - 1;
  for( ; i >= 0; i = i - 1)
    if(!(((struct common_module *)common_modules.modules[(signed long int)i])->close_module == ((void (*)())NULL)))
      ((struct common_module *)common_modules.modules[(signed long int)i])->close_module(&CI_CONF);

  free((void *)common_modules.modules);
  common_modules.modules = (void **)(void *)0;
  common_modules.list_size = 0;
  common_modules.modules_num = 0;
  return 1;
}

// release_services
// file include/service.h line 278
signed int release_services()
{
  signed int i;
  struct ci_conf_entry *table;
  i = 0;
  for( ; !(i >= service_aliases_num); i = i + 1)
    unregister_conf_table((service_aliases + (signed long int)i)->alias);
  i = 0;
  for( ; !(i >= services_num); i = i + 1)
    if(!(service_list[(signed long int)i]->mod_close_service == ((void (*)())NULL)))
    {
      service_list[(signed long int)i]->mod_close_service();
      ci_thread_rwlock_destroy(&(service_extra_data_list + (signed long int)i)->lock);
      table=unregister_conf_table(service_list[(signed long int)i]->mod_name);
      if(!(table == (service_extra_data_list + (signed long int)i)->intl_srv_conf_table))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error unregistering service %s configuration table\n", service_list[(signed long int)i]->mod_name);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error unregistering service %s configuration table\n", service_list[(signed long int)i]->mod_name);

        }

      }

      if(!(table == ((struct ci_conf_entry *)NULL)))
        free((void *)table);

      (service_extra_data_list + (signed long int)i)->intl_srv_conf_table = (struct ci_conf_entry *)(void *)0;
    }

  free((void *)service_list);
  service_list = (struct ci_service_module **)(void *)0;
  service_list_size = 0;
  services_num = 0;
  free((void *)service_aliases);
  service_aliases = (struct service_alias *)(void *)0;
  service_aliases_size = 0;
  service_aliases_num = 0;
  return 1;
}

// release_text_table_entry
// file lookup_file_table.c line 81
void release_text_table_entry(struct text_table_entry *e, struct ci_lookup_table *table)
{
  void **vals;
  signed int i;
  struct ci_mem_allocator *allocator = table->allocator;
  if(!(e == ((struct text_table_entry *)NULL)))
  {
    if(!(e->vals == ((void **)NULL)))
    {
      vals = (void **)e->vals;
      i = 0;
      if(!(vals[(signed long int)i] == NULL))
      {
        table->val_ops->free(vals[(signed long int)i], allocator);
        i = i + 1;
      }

      allocator->free(allocator, (void *)e->vals);
    }

    if(!(e->key == NULL))
      table->key_ops->free(e->key, allocator);

    allocator->free(allocator, (void *)e);
  }

}

// release_thread_i
// file mpmt_server.c line 189
static void release_thread_i(signed int i)
{
  if(!(threads_list[(signed long int)i]->current_req == ((struct ci_request *)NULL)))
    ci_request_destroy(threads_list[(signed long int)i]->current_req);

  free((void *)threads_list[(signed long int)i]);
  threads_list[(signed long int)i] = (struct server_decl *)(void *)0;
}

// remove_child
// file proc_threads_queues.c line 284
signed int remove_child(struct childs_queue *q, signed int pid, signed int status)
{
  signed int i;
  struct stat_memblock *child_stats;
  if(q->childs == ((struct child_shared_data *)NULL))
    return 0;

  else
  {
    ci_proc_mutex_lock(&q->queue_mtx);
    i = 0;
    for( ; !(i >= q->size); i = i + 1)
      if((q->childs + (signed long int)i)->pid == pid)
      {
        (q->childs + (signed long int)i)->pid = 0;
        old_requests = old_requests + (q->childs + (signed long int)i)->requests;
        if((q->childs + (signed long int)i)->pipe >= 0)
        {
          close((q->childs + (signed long int)i)->pipe);
          (q->childs + (signed long int)i)->pipe = -1;
        }

        child_stats = (struct stat_memblock *)(q->stats_area + (signed long int)(i * q->stats_block_size));
        stat_memblock_reconstruct(child_stats);
        ci_stat_memblock_merge(q->stats_history, child_stats);
        q->srv_stats->closed_childs = q->srv_stats->closed_childs + 1u;
        if(!(status == 0))
          q->srv_stats->crashed_childs = q->srv_stats->crashed_childs + 1u;

        ci_proc_mutex_unlock(&q->queue_mtx);
        return 1;
      }

    ci_proc_mutex_unlock(&q->queue_mtx);
    return 0;
  }
}

// request_match_specslist
// file acl.c line 716
signed int request_match_specslist(struct ci_request *req, struct ci_specs_list *spec_list)
{
  const struct ci_acl_spec *spec;
  const struct ci_acl_type *type;
  signed int ret;
  signed int negate;
  signed int check_result;
  void *test_data;
  ret = 1;
  if(!(spec_list == ((struct ci_specs_list *)NULL)))
  {
    spec = spec_list->spec;
    negate = spec_list->negate;
    type = spec->type;
    test_data=type->get_test_data(req, spec->parameter);
    if(test_data == NULL)
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "No data to test for %s/%s, ignore\n", (const void *)type->name, spec->parameter);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("No data to test for %s/%s, ignore\n", (const void *)type->name, spec->parameter);

      }

      return 0;
    }

    check_result=spec_data_check(spec, test_data);
    if(check_result == 0 && negate == 0)
      ret = 0;

    else
      if(!(check_result == 0) && !(negate == 0))
        ret = 0;

    if(!(type->free_test_data == ((void (*)(struct ci_request *, void *))NULL)))
      type->free_test_data(req, test_data);

    if(ret == 0)
      return 0;

    spec_list = spec_list->next;
  }

  return 1;
}

// request_stats_init
// file aserver.c line 54
void request_stats_init()
{
  STAT_REQUESTS=ci_stat_entry_register("REQUESTS", 0, "General");
  STAT_REQMODS=ci_stat_entry_register("REQMODS", 0, "General");
  STAT_RESPMODS=ci_stat_entry_register("RESPMODS", 0, "General");
  STAT_OPTIONS=ci_stat_entry_register("OPTIONS", 0, "General");
  STAT_FAILED_REQUESTS=ci_stat_entry_register("FAILED REQUESTS", 0, "General");
  STAT_ALLOW204=ci_stat_entry_register("ALLOW 204", 0, "General");
  STAT_BYTES_IN=ci_stat_entry_register("BYTES IN", 1, "General");
  STAT_BYTES_OUT=ci_stat_entry_register("BYTES OUT", 1, "General");
  STAT_HTTP_BYTES_IN=ci_stat_entry_register("HTTP BYTES IN", 1, "General");
  STAT_HTTP_BYTES_OUT=ci_stat_entry_register("HTTP BYTES OUT", 1, "General");
  STAT_BODY_BYTES_IN=ci_stat_entry_register("BODY BYTES IN", 1, "General");
  STAT_BODY_BYTES_OUT=ci_stat_entry_register("BODY BYTES OUT", 1, "General");
}

// reset_conf_tables
// file cfg_param.c line 226
void reset_conf_tables()
{
  conf_tables_num = 0;
}

// reset_http_auth
// file cfg_param.c line 925
void reset_http_auth()
{
  group_source_release();
  ci_acl_type_add(&acl_auth);
  ci_acl_type_add(&acl_group);
}

// resize_buffer
// file body.c line 343
signed int resize_buffer(struct ci_cached_file *body, signed int new_size)
{
  char *newbuf;
  if(!(new_size >= body->bufsize))
    return 1;

  else
    if(!(CI_BODY_MAX_MEM >= new_size))
      return 0;

    else
    {
      void *return_value_ci_buffer_realloc$1;
      return_value_ci_buffer_realloc$1=ci_buffer_realloc((void *)body->buf, new_size);
      newbuf = (char *)return_value_ci_buffer_realloc$1;
      if(!(newbuf == ((char *)NULL)))
      {
        body->buf = newbuf;
        body->bufsize = new_size;
      }

      return 1;
    }
}

// resp_check_body
// file request.c line 814
static signed int resp_check_body(struct ci_request *req)
{
  signed int i;
  struct ci_encaps_entity **e = req->entities;
  i = 0;
  for( ; !(e[(signed long int)i] == ((struct ci_encaps_entity *)NULL)); i = i + 1)
    if(e[(signed long int)i]->type == 4)
      return 0;

  return 1;
}

// run_as_daemon
// file aserver.c line 78
void run_as_daemon()
{
  signed int fd;
  signed int pid;
  signed int sid;
  pid=fork();
  if(!(pid >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Unable to fork. exiting...");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Unable to fork. exiting...");

    }

    exit(-1);
  }

  if(pid >= 1)
    exit(0);

  umask((unsigned int)0);
  sid=setsid();
  if(!(sid >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Unable to create a new SID for the main process. exiting...");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Unable to create a new SID for the main process. exiting...");

    }

    exit(-1);
  }

  signed int return_value_chdir$1;
  return_value_chdir$1=chdir("/");
  if(!(return_value_chdir$1 >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Unable to change the working directory. exiting...");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Unable to change the working directory. exiting...");

    }

    exit(-1);
  }

  fd=open64("/dev/null", 02);
  if(!(fd >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Unable to open '/dev/null'. exiting...");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Unable to open '/dev/null'. exiting...");

    }

    exit(-1);
  }

  signed int return_value_dup2$2;
  return_value_dup2$2=dup2(fd, 0);
  if(!(return_value_dup2$2 >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Unable to set stdin to '/dev/null'. exiting...");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Unable to set stdin to '/dev/null'. exiting...");

    }

    exit(-1);
  }

  signed int return_value_dup2$3;
  return_value_dup2$3=dup2(fd, 1);
  if(!(return_value_dup2$3 >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Unable to set stdout to '/dev/null'. exiting...");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Unable to set stdout to '/dev/null'. exiting...");

    }

    exit(-1);
  }

  signed int return_value_dup2$4;
  return_value_dup2$4=dup2(fd, 2);
  if(!(return_value_dup2$4 >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Unable to set stderr to '/dev/null'. exiting...");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Unable to set stderr to '/dev/null'. exiting...");

    }

    exit(-1);
  }

  close(fd);
}

// search_conf_table
// file cfg_param.c line 206
struct ci_conf_entry * search_conf_table(struct ci_conf_entry *table, char *varname)
{
  signed int i = 0;
  for( ; !((table + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(varname, (table + (signed long int)i)->name);
    if(return_value_strcmp$1 == 0)
      return &table[(signed long int)i];

  }
  return (struct ci_conf_entry *)(void *)0;
}

// search_options_table
// file cfg_lib.c line 76
struct ci_options_entry * search_options_table(const char *directive, struct ci_options_entry *options)
{
  signed int i;
  const char *option_search;
  if(!((signed int)*directive == 45))
    option_search = "$$";

  else
    option_search = directive;
  i = 0;
  for( ; !((options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(option_search, (options + (signed long int)i)->name);
    if(return_value_strcmp$1 == 0)
      return &options[(signed long int)i];

  }
  return (struct ci_options_entry *)(void *)0;
}

// search_variables
// file cfg_param.c line 292
struct ci_conf_entry * search_variables(char *table, char *varname)
{
  signed int i;
  struct ci_conf_entry *return_value_search_conf_table$1;
  if(table == ((char *)NULL))
  {
    return_value_search_conf_table$1=search_conf_table(conf_variables, varname);
    return return_value_search_conf_table$1;
  }

  if(CI_DEBUG_LEVEL >= 3)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Going to search variable %s in table %s\n", varname, table);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Going to search variable %s in table %s\n", varname, table);

  }

  signed int return_value_strcmp$3;
  if(extra_conf_tables == ((struct sub_table *)NULL))
    return (struct ci_conf_entry *)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= conf_tables_num); i = i + 1)
      if(!((extra_conf_tables + (signed long int)i)->name == ((const char *)NULL)))
      {
        return_value_strcmp$3=strcmp(table, (extra_conf_tables + (signed long int)i)->name);
        if(return_value_strcmp$3 == 0)
        {
          struct ci_conf_entry *return_value_search_conf_table$2;
          return_value_search_conf_table$2=search_conf_table((extra_conf_tables + (signed long int)i)->conf_table, varname);
          return return_value_search_conf_table$2;
        }

      }

    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Variable %s or table %s not found!\n", varname, table);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Variable %s or table %s not found!\n", varname, table);

    }

    return (struct ci_conf_entry *)(void *)0;
  }
}

// send_current_block_data
// file request.c line 741
static signed int send_current_block_data(struct ci_request *req)
{
  signed int bytes;
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  if(req->remain_send_block_bytes == 0)
    return 0;

  else
  {
    bytes=ci_write_nonblock(req->connection->fd, (const void *)req->pstrblock_responce, (unsigned long int)req->remain_send_block_bytes);
    if(!(bytes >= 0))
    {
      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value___errno_location$1=__errno_location();
          __log_error((void *)0, "Error writing to socket (errno:%d, bytes:%d. string:\"%s\")", *return_value___errno_location$1, req->remain_send_block_bytes, req->pstrblock_responce);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value___errno_location$2=__errno_location();
          printf("Error writing to socket (errno:%d, bytes:%d. string:\"%s\")", *return_value___errno_location$2, req->remain_send_block_bytes, req->pstrblock_responce);
        }

      }

      return -1;
    }

    else
      if(bytes == 0)
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Can not write to the client. Is the connection closed?");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Can not write to the client. Is the connection closed?");

        }

        return -1;
      }

      else
      {
        req->pstrblock_responce = req->pstrblock_responce + (signed long int)bytes;
        req->remain_send_block_bytes = req->remain_send_block_bytes - bytes;
        req->bytes_out = req->bytes_out + (unsigned long int)bytes;
        if(req->status >= 2)
        {
          if(!(req->status >= 5))
            req->http_bytes_out = req->http_bytes_out + (unsigned long int)bytes;

        }

        return req->remain_send_block_bytes;
      }
  }
}

// send_remaining_response
// file request.c line 1070
static signed int send_remaining_response(struct ci_request *req)
{
  signed int ret = 0;
  signed int (*service_io)(char *, signed int *, char *, signed int *, signed int, struct ci_request *) = req->current_service_mod->mod_service_io;
  if(service_io == ((signed int (*)(char *, signed int *, char *, signed int *, signed int, struct ci_request *))NULL))
    return -1;

  else
    if(req->status == 6)
    {
      if(!(req->remain_send_block_bytes == 0))
        goto __CPROVER_DUMP_L4;

      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "OK sending all data\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("OK sending all data\n");

      }

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      while((_Bool)1)
      {
        if(req->remain_send_block_bytes >= 1)
        {
          ret=wait_for_data(req->connection->fd, TIMEOUT, 0x2);
          if(!(ret >= 0))
          {
            if(CI_DEBUG_LEVEL >= 3)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Timeout sending data. Ending .......\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Timeout sending data. Ending .......\n");

            }

            return -1;
          }

          signed int return_value_send_current_block_data$1;
          return_value_send_current_block_data$1=send_current_block_data(req);
          if(return_value_send_current_block_data$1 == -1)
            return -1;

          goto __CPROVER_DUMP_L4;
        }

        if(req->status == 5)
        {
          if(req->remain_send_block_bytes == 0)
          {
            req->pstrblock_responce = req->wbuf + (signed long int)30;
            req->remain_send_block_bytes = 4064;
            if(CI_DEBUG_LEVEL >= 9)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "rest response: going to read: %d bytes\n", req->remain_send_block_bytes);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("rest response: going to read: %d bytes\n", req->remain_send_block_bytes);

            }

            service_io(req->pstrblock_responce, &req->remain_send_block_bytes, (char *)(void *)0, (signed int *)(void *)0, 1, req);
            if(CI_DEBUG_LEVEL >= 9)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "rest response: read: %d bytes\n", req->remain_send_block_bytes);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("rest response: read: %d bytes\n", req->remain_send_block_bytes);

            }

            if(req->remain_send_block_bytes == -1)
              return -1;

            if(req->remain_send_block_bytes == 0)
              break;

            ret=format_body_chunk(req);
            if(ret == -2)
              req->status = 6;

          }

        }

        ret=update_send_status(req);
        if(!(ret >= 0))
          break;

      }
      if(ret == -1)
        return ret;

      else
        return 1;
    }
}

// send_term_to_childs
// file mpmt_server.c line 283
static void send_term_to_childs(struct childs_queue *q)
{
  signed int i;
  signed int pid;
  i = 0;
  for( ; !(i >= q->size); i = i + 1)
  {
    pid = (q->childs + (signed long int)i)->pid;
    if(!(pid == 0))
    {
      if(!((q->childs + (signed long int)i)->to_be_killed == 2))
      {
        (q->childs + (signed long int)i)->father_said = 2;
        kill(pid, 15);
      }

    }

  }
}

// serial_allocation
// file mem.c line 476
static void * serial_allocation(struct serial_allocator *serial_alloc, unsigned long int size)
{
  signed int max_size;
  void *mem;
  size = size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1);
  max_size = (signed int)(serial_alloc->endpos - serial_alloc->memchunk);
  if(!((unsigned long int)max_size >= size))
    return (void *)0;

  else
  {
    for( ; !((unsigned long int)(serial_alloc->endpos - serial_alloc->curpos) >= size); serial_alloc = serial_alloc->next)
      if(serial_alloc->next == ((struct serial_allocator *)NULL))
      {
        serial_alloc->next=serial_allocator_build(max_size);
        if(serial_alloc->next == ((struct serial_allocator *)NULL))
          return (void *)0;

      }

    mem = serial_alloc->curpos;
    serial_alloc->curpos = serial_alloc->curpos + (signed long int)size;
    return mem;
  }
}

// serial_allocator_alloc
// file mem.c line 499
static void * serial_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size)
{
  struct serial_allocator *serial_alloc = (struct serial_allocator *)allocator->data;
  if(serial_alloc == ((struct serial_allocator *)NULL))
    return (void *)0;

  else
  {
    void *return_value_serial_allocation$1;
    return_value_serial_allocation$1=serial_allocation(serial_alloc, size);
    return return_value_serial_allocation$1;
  }
}

// serial_allocator_build
// file mem.c line 453
static struct serial_allocator * serial_allocator_build(signed int size)
{
  struct serial_allocator *serial_alloc;
  void *buffer;
  size = (signed int)((unsigned long int)size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
  if(!((unsigned long int)size >= sizeof(struct serial_allocator) * 2 + 24 /*88ul*/ ))
    return (struct serial_allocator *)(void *)0;

  else
  {
    buffer=ci_buffer_alloc(size);
    serial_alloc = (struct serial_allocator *)buffer;
    unsigned long int return_value_ci_buffer_blocksize$1;
    return_value_ci_buffer_blocksize$1=ci_buffer_blocksize(buffer);
    size = (signed int)return_value_ci_buffer_blocksize$1;
    serial_alloc->memchunk = buffer + (signed long int)sizeof(struct serial_allocator) /*32ul*/ ;
    size = size - (signed int)sizeof(struct serial_allocator) /*32ul*/ ;
    serial_alloc->curpos = serial_alloc->memchunk;
    serial_alloc->endpos = serial_alloc->memchunk + (signed long int)size;
    serial_alloc->next = (struct serial_allocator *)(void *)0;
    return serial_alloc;
  }
}

// serial_allocator_destroy
// file mem.c line 530
static void serial_allocator_destroy(struct ci_mem_allocator *allocator)
{
  struct serial_allocator *cur;
  struct serial_allocator *next;
  if(!(allocator->data == NULL))
  {
    cur = (struct serial_allocator *)allocator->data;
    next = cur->next;
    while(!(cur == ((struct serial_allocator *)NULL)))
    {
      ci_buffer_free((void *)cur);
      cur = next;
      if(!(next == ((struct serial_allocator *)NULL)))
        next = next->next;

    }
  }

}

// serial_allocator_free
// file mem.c line 508
static void serial_allocator_free(struct ci_mem_allocator *allocator, void *p)
{
  ;
}

// serial_allocator_reset
// file mem.c line 513
static void serial_allocator_reset(struct ci_mem_allocator *allocator)
{
  struct serial_allocator *serial_alloc;
  struct serial_allocator *sa;
  void *tmp;
  serial_alloc = (struct serial_allocator *)allocator->data;
  serial_alloc->curpos = serial_alloc->memchunk + (signed long int)(sizeof(struct ci_mem_allocator) /*56ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
  sa = serial_alloc->next;
  serial_alloc->next = (struct serial_allocator *)(void *)0;
  for( ; !(sa == ((struct serial_allocator *)NULL)); sa = sa->next)
  {
    tmp = (void *)sa;
    ci_buffer_free(tmp);
  }
}

// server_reconfigure
// file mpmt_server.c line 382
static signed int server_reconfigure()
{
  signed int i;
  if(!(old_childs_queue == ((struct childs_queue *)NULL)))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "A reconfigure pending. Ignoring reconfigure request.....\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("A reconfigure pending. Ignoring reconfigure request.....\n");

    }

    return 1;
  }

  else
  {
    signed int return_value_system_reconfigure$1;
    return_value_system_reconfigure$1=system_reconfigure();
    if(return_value_system_reconfigure$1 == 0)
      return 0;

    else
    {
      init_commands();
      i = 0;
      for( ; !(i >= childs_queue->size); i = i + 1)
        if(!((childs_queue->childs + (signed long int)i)->pid == 0))
        {
          (childs_queue->childs + (signed long int)i)->father_said = 1;
          kill((childs_queue->childs + (signed long int)i)->pid, 15);
        }

      old_childs_queue = childs_queue;
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(struct childs_queue) /*224ul*/ );
      childs_queue = (struct childs_queue *)return_value_malloc$2;
      signed int return_value_create_childs_queue$3;
      return_value_create_childs_queue$3=create_childs_queue(childs_queue, 2 * CI_CONF.MAX_SERVERS);
      if(return_value_create_childs_queue$3 == 0)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Cannot init shared memory. Fatal error, exiting!\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Cannot init shared memory. Fatal error, exiting!\n");

        }

        return 0;
      }

      else
      {
        if(!(CI_CONF.MAX_SERVERS >= CI_CONF.START_SERVERS))
          CI_CONF.START_SERVERS = CI_CONF.MAX_SERVERS;

        i = 0;
        for( ; !(i >= CI_CONF.START_SERVERS); i = i + 1)
          start_child(LISTEN_SOCKET);
        return 1;
      }
    }
  }
}

// service_data
// file include/service.h line 275
struct ci_service_xdata * service_data(struct ci_service_module *srv)
{
  signed int i = 0;
  for( ; !(i >= services_num); i = i + 1)
    if(service_list[(signed long int)i] == srv)
      return &service_extra_data_list[(signed long int)i];

  return (struct ci_service_xdata *)(void *)0;
}

// set_method_authenticators
// file include/module.h line 125
signed int set_method_authenticators(const char *method_name, const char **argv)
{
  signed int method_id;
  struct http_auth_method *method_mod;
  method_mod=find_auth_method_id(method_name, &method_id);
  if(method_mod == ((struct http_auth_method *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Authentication method \"%s\" not supported\n", method_name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Authentication method \"%s\" not supported\n", method_name);

    }

    return 0;
  }

  else
  {
    signed int return_value_methods_authenticators$1;
    return_value_methods_authenticators$1=methods_authenticators(&authenticators_hash, method_name, method_id, argv);
    return return_value_methods_authenticators$1;
  }
}

// set_running_permissions
// file aserver.c line 52
signed int set_running_permissions(char *user, char *group)
{
  unsigned int uid;
  unsigned int gid;
  char *pend;
  struct passwd *pwd;
  struct group *grp;
  signed int *return_value___errno_location$4;
  struct group *return_value_getgrgid$3;
  if(!(group == ((char *)NULL)))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 0;
    signed long int return_value_strtol$2;
    return_value_strtol$2=strtol(group, &pend, 10);
    gid = (unsigned int)return_value_strtol$2;
    _Bool tmp_if_expr$5;
    if(!(pend == ((char *)NULL)))
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value___errno_location$4=__errno_location();
      tmp_if_expr$5 = *return_value___errno_location$4 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
    {
      grp=getgrnam(group);
      if(grp == ((struct group *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "There is no group %s in password file!\n", group);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("There is no group %s in password file!\n", group);

        }

        return 0;
      }

      gid = grp->gr_gid;
    }

    else
    {
      return_value_getgrgid$3=getgrgid(gid);
      if(return_value_getgrgid$3 == ((struct group *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "There is no group with id=%d in password file!\n", gid);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("There is no group with id=%d in password file!\n", gid);

        }

        return 0;
      }

    }
    signed int return_value_setgid$6;
    return_value_setgid$6=setgid(gid);
    if(!(return_value_setgid$6 == 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "setgid to %d failed!!!!\n", gid);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("setgid to %d failed!!!!\n", gid);

      }

      perror("Wtat is this; ");
      return 0;
    }

  }

  signed int *return_value___errno_location$10;
  struct passwd *return_value_getpwuid$9;
  if(!(user == ((char *)NULL)))
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    *return_value___errno_location$7 = 0;
    signed long int return_value_strtol$8;
    return_value_strtol$8=strtol(user, &pend, 10);
    uid = (unsigned int)return_value_strtol$8;
    _Bool tmp_if_expr$11;
    if(!(pend == ((char *)NULL)))
      tmp_if_expr$11 = (_Bool)1;

    else
    {
      return_value___errno_location$10=__errno_location();
      tmp_if_expr$11 = *return_value___errno_location$10 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$11)
    {
      pwd=getpwnam(user);
      if(pwd == ((struct passwd *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "There is no user %s in password file!\n", user);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("There is no user %s in password file!\n", user);

        }

        return 0;
      }

      uid = pwd->pw_uid;
    }

    else
    {
      return_value_getpwuid$9=getpwuid(uid);
      if(return_value_getpwuid$9 == ((struct passwd *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "There is no user with id=%d in password file!\n", uid);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("There is no user with id=%d in password file!\n", uid);

        }

        return 0;
      }

    }
    signed int return_value_setuid$12;
    return_value_setuid$12=setuid(uid);
    if(!(return_value_setuid$12 == 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "setuid to %d failed!!!!\n", uid);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("setuid to %d failed!!!!\n", uid);

      }

      return 0;
    }

  }

  return 1;
}

// sigchld_handler_main
// file mpmt_server.c line 130
static void sigchld_handler_main(signed int sig)
{
  ;
}

// sighup_handler_main
// file mpmt_server.c line 135
static void sighup_handler_main()
{
  c_icap_reconfigure = 1;
}

// sigint_handler_main
// file mpmt_server.c line 118
static void sigint_handler_main(signed int sig)
{
  c_icap_going_to_term = 1;
}

// sigpipe_handler
// file mpmt_server.c line 110
static void sigpipe_handler(signed int sig)
{
  ;
}

// sizeof_pack_allocator
// file mem.c line 735
static unsigned long int sizeof_pack_allocator()
{
  return sizeof(struct pack_allocator) /*40ul*/ ;
}

// sizeofencaps
// file header.c line 613
signed int sizeofencaps(struct ci_encaps_entity *e)
{
  _Bool tmp_if_expr$2;
  if(e->type == 0)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = e->type == 1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    signed int return_value_sizeofheader$1;
    return_value_sizeofheader$1=sizeofheader((struct ci_headers_list *)e->entity);
    return return_value_sizeofheader$1;
  }

  return 0;
}

// sizeofheader
// file header.c line 600
signed int sizeofheader(struct ci_headers_list *h)
{
  return h->bufused + 2;
}

// spec_data_check
// file acl.c line 699
signed int spec_data_check(const struct ci_acl_spec *spec, const void *req_raw_data)
{
  struct ci_acl_data *spec_data = spec->data;
  const struct ci_type_ops *ops = spec->type->type;
  if(CI_DEBUG_LEVEL >= 9)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Check request with ci_acl_spec_t:%s\n", (const void *)spec->name);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Check request with ci_acl_spec_t:%s\n", (const void *)spec->name);

  }

  if(!(spec_data == ((struct ci_acl_data *)NULL)))
  {
    signed int return_value;
    return_value=ops->equal(spec_data->data, (void *)req_raw_data);
    if(!(return_value == 0))
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "The ci_acl_spec_t:%s matches\n", (const void *)spec->name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("The ci_acl_spec_t:%s matches\n", (const void *)spec->name);

      }

      return 1;
    }

    spec_data = spec_data->next;
  }

  return 0;
}

// split_args
// file cfg_param.c line 724
char ** split_args(char *args)
{
  signed int len;
  signed int i = 0;
  signed int brkt;
  char **argv = (char **)(void *)0;
  char *str;
  char *end;
  char *p;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(50 + 1) * sizeof(char *) /*8ul*/ );
  argv = (char **)return_value_malloc$1;
  end = args;
  const unsigned short int **return_value___ctype_b_loc$2;
  const unsigned short int **return_value___ctype_b_loc$4;
  do
  {
    str = end;
    if((signed int)*end == 34)
    {
      end = end + 1l;
      str = end;
      for( ; !((signed int)*end == 0); end = end + 1l)
      {
        if((signed int)*end == 34)
          break;

        if((signed int)*end == 92)
        {
          if((signed int)end[1l] == 34)
          {
            p = end;
            for( ; !((signed int)*p == 0); p = p + 1l)
              *p = p[(signed long int)1];
          }

        }

      }
    }

    else
    {
      brkt = 0;
      for( ; !((signed int)*end == 0); end = end + 1l)
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*end]) == 0))
        {
          if(brkt == 0)
            break;

        }

        if((signed int)*end == 123)
          brkt = 1;

        else
          if(!(brkt == 0))
          {
            if((signed int)*end == 125)
              brkt = 0;

          }

      }
    }
    len = (signed int)(end - str);
    void *return_value_malloc$3;
    return_value_malloc$3=malloc((unsigned long int)(len + 1) * sizeof(char) /*1ul*/ );
    argv[(signed long int)i] = (char *)return_value_malloc$3;
    memcpy((void *)argv[(signed long int)i], (const void *)str, (unsigned long int)len);
    argv[(signed long int)i][(signed long int)len] = (char)0;
    i = i + 1;
    if(i >= 50)
      break;

    if((signed int)*end == 34)
      end = end + 1l;

    for( ; !((signed int)*end == 0); end = end + 1l)
    {
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*end]) == 0)
        break;

    }
  }
  while(!((signed int)*end == 0));
  argv[(signed long int)i] = (char *)(void *)0;
  return argv;
}

// start_child
// file mpmt_server.c line 947
signed int start_child(signed int fd)
{
  signed int pid;
  signed int pfd[2l];
  signed int children_num;
  signed int free_servers;
  signed int used_servers;
  signed int max_requests;
  signed int return_value_pipe$1;
  return_value_pipe$1=pipe(pfd);
  signed int return_value_fcntl$3;
  if(!(return_value_pipe$1 >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error creating pipe for communication with child\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error creating pipe for communication with child\n");

    }

    return -1;
  }

  else
  {
    signed int return_value_fcntl$2;
    return_value_fcntl$2=fcntl(pfd[(signed long int)0], 4, 04000);
    _Bool tmp_if_expr$4;
    if(!(return_value_fcntl$2 >= 0))
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_fcntl$3=fcntl(pfd[(signed long int)1], 4, 04000);
      tmp_if_expr$4 = return_value_fcntl$3 < 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error making the child pipe non-blocking\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error making the child pipe non-blocking\n");

      }

      close(pfd[(signed long int)0]);
      close(pfd[(signed long int)1]);
    }

    pid=fork();
    if(pid == 0)
    {
      MY_PROC_PID=getpid();
      signed int return_value_attach_childs_queue$5;
      return_value_attach_childs_queue$5=attach_childs_queue(childs_queue);
      if(return_value_attach_childs_queue$5 == 0)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Can not access shared memory for %d child\n", (signed int)MY_PROC_PID);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Can not access shared memory for %d child\n", (signed int)MY_PROC_PID);

        }

        exit(-2);
      }

      signed int return_value_getpid$6;
      return_value_getpid$6=getpid();
      child_data=register_child(childs_queue, return_value_getpid$6, CI_CONF.THREADS_PER_CHILD, pfd[(signed long int)1]);
      if(child_data == ((struct child_shared_data *)NULL))
      {
        childs_queue_stats(childs_queue, &children_num, &free_servers, &used_servers, &max_requests);
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Not available slot in shared memory for %d child (Number of slots: %d, Running children: %d, Free servers: %d, Used servers: %d)!\n", (signed int)MY_PROC_PID, childs_queue->size, children_num, free_servers, used_servers);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Not available slot in shared memory for %d child (Number of slots: %d, Running children: %d, Free servers: %d, Used servers: %d)!\n", (signed int)MY_PROC_PID, childs_queue->size, children_num, free_servers, used_servers);

        }

        exit(-3);
      }

      close(pfd[(signed long int)1]);
      child_main(fd, pfd[(signed long int)0]);
      exit(0);
    }

    else
    {
      close(pfd[(signed long int)0]);
      announce_child(childs_queue, pid);
      return pid;
    }
  }
}

// start_server
// file aserver.c line 48
signed int start_server()
{
  signed int child_indx;
  signed int pid;
  signed int i;
  signed int ctl_socket;
  signed int childs;
  signed int freeservers;
  signed int used;
  signed int maxrequests;
  signed int ret;
  char command_buffer[128l];
  signed int user_informed = 0;
  ctl_socket=ci_named_pipe_create(CI_CONF.COMMANDS_SOCKET);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$3;
  char *return_value_strerror$4;
  if(!(ctl_socket >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value___errno_location$1=__errno_location();
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        __log_error((void *)0, "Error opening control socket %s: %s. Fatal error, exiting!\n", return_value_strerror$2, CI_CONF.COMMANDS_SOCKET);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value___errno_location$3=__errno_location();
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        printf("Error opening control socket %s: %s. Fatal error, exiting!\n", return_value_strerror$4, CI_CONF.COMMANDS_SOCKET);
      }

    }

    exit(0);
  }

  signed int return_value_ci_proc_mutex_init$5;
  return_value_ci_proc_mutex_init$5=ci_proc_mutex_init(&accept_mutex, "accept");
  if(return_value_ci_proc_mutex_init$5 == 0)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Can't init mutex for accepting conenctions. Fatal error, exiting!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Can't init mutex for accepting conenctions. Fatal error, exiting!\n");

    }

    exit(0);
  }

  void *return_value_malloc$6;
  return_value_malloc$6=malloc(sizeof(struct childs_queue) /*224ul*/ );
  childs_queue = (struct childs_queue *)return_value_malloc$6;
  signed int return_value_create_childs_queue$7;
  return_value_create_childs_queue$7=create_childs_queue(childs_queue, 2 * CI_CONF.MAX_SERVERS);
  if(return_value_create_childs_queue$7 == 0)
  {
    ci_proc_mutex_destroy(&accept_mutex);
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Can't init shared memory. Fatal error, exiting!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Can't init shared memory. Fatal error, exiting!\n");

    }

    exit(0);
  }

  init_commands();
  pid = 1;
  if(!(CI_CONF.MAX_SERVERS >= CI_CONF.START_SERVERS))
    CI_CONF.START_SERVERS = CI_CONF.MAX_SERVERS;

  i = 0;
  for( ; !(i >= CI_CONF.START_SERVERS); i = i + 1)
    if(!(pid == 0))
      pid=start_child(LISTEN_SOCKET);

  if(!(pid == 0))
  {
    main_signals();
    while((_Bool)1)
    {
      ret=wait_for_commands(ctl_socket, command_buffer, 1);
      if(ret >= 1)
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "I received the command: %s\n", (const void *)command_buffer);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("I received the command: %s\n", (const void *)command_buffer);

        }

        handle_monitor_process_commands(command_buffer);
      }

      if(!(ret >= 0))
      {
        ci_named_pipe_close(ctl_socket);
        ctl_socket=ci_named_pipe_open(CI_CONF.COMMANDS_SOCKET);
        if(!(ctl_socket >= 0))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Error opening control socket. We are unstable and going down!");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Error opening control socket. We are unstable and going down!");

          }

          c_icap_going_to_term = 1;
        }

      }

      if(!(c_icap_going_to_term == 0))
        break;

      childs_queue_stats(childs_queue, &childs, &freeservers, &used, &maxrequests);
      if(CI_DEBUG_LEVEL >= 10)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Server stats: \n\t Children: %d\n\t Free servers: %d\n\tUsed servers:%d\n\tRequests served:%d\n", childs, freeservers, used, maxrequests);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Server stats: \n\t Children: %d\n\t Free servers: %d\n\tUsed servers:%d\n\tRequests served:%d\n", childs, freeservers, used, maxrequests);

      }

      _Bool tmp_if_expr$8;
      if(MAX_REQUESTS_PER_CHILD >= 1)
      {
        child_indx=find_a_child_nrequests(childs_queue, MAX_REQUESTS_PER_CHILD);
        tmp_if_expr$8 = child_indx >= 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$8 = (_Bool)0;
      if(tmp_if_expr$8)
      {
        if(CI_DEBUG_LEVEL >= 8)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Max requests reached for child :%d of pid :%d\n", child_indx, (childs_queue->childs + (signed long int)child_indx)->pid);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Max requests reached for child :%d of pid :%d\n", child_indx, (childs_queue->childs + (signed long int)child_indx)->pid);

        }

        pid=start_child(LISTEN_SOCKET);
        (childs_queue->childs + (signed long int)child_indx)->father_said = 1;
        kill((childs_queue->childs + (signed long int)child_indx)->pid, 15);
      }

      else
        if(CI_CONF.MIN_SPARE_THREADS >= freeservers && !(childs >= CI_CONF.MAX_SERVERS) || !(childs >= CI_CONF.START_SERVERS))
        {
          if(CI_DEBUG_LEVEL >= 8)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Free Servers: %d, children: %d. Going to start a child .....\n", freeservers, childs);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Free Servers: %d, children: %d. Going to start a child .....\n", freeservers, childs);

          }

          pid=start_child(LISTEN_SOCKET);
        }

        else
          if(freeservers >= CI_CONF.MAX_SPARE_THREADS && !(CI_CONF.MIN_SPARE_THREADS >= freeservers + -CI_CONF.THREADS_PER_CHILD) && !(CI_CONF.START_SERVERS >= childs))
          {
            child_indx=find_an_idle_child(childs_queue);
            if(child_indx >= 0)
            {
              (childs_queue->childs + (signed long int)child_indx)->father_said = 1;
              if(CI_DEBUG_LEVEL >= 8)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "Free Servers: %d, children: %d. Going to stop child %d(index: %d)\n", freeservers, childs, (childs_queue->childs + (signed long int)child_indx)->pid, child_indx);

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("Free Servers: %d, children: %d. Going to stop child %d(index: %d)\n", freeservers, childs, (childs_queue->childs + (signed long int)child_indx)->pid, child_indx);

              }

              kill((childs_queue->childs + (signed long int)child_indx)->pid, 15);
              user_informed = 0;
            }

          }

          else
            if(childs == CI_CONF.MAX_SERVERS && !(freeservers >= CI_CONF.MIN_SPARE_THREADS))
            {
              if(user_informed == 0)
              {
                if(CI_DEBUG_LEVEL >= 1)
                {
                  if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                    __log_error((void *)0, "ATTENTION!!!! Not enough available servers (children %d, free servers %d, used servers %d)!!!!! Maybe you should increase the MaxServers and the ThreadsPerChild values in c-icap.conf file!!!!!!!!!", childs, freeservers, used);

                  if(!(CI_DEBUG_STDOUT == 0))
                    printf("ATTENTION!!!! Not enough available servers (children %d, free servers %d, used servers %d)!!!!! Maybe you should increase the MaxServers and the ThreadsPerChild values in c-icap.conf file!!!!!!!!!", childs, freeservers, used);

                }

                user_informed = 1;
              }

            }

      if(!(c_icap_going_to_term == 0))
        break;

      check_for_exited_childs();
      if(!(c_icap_reconfigure == 0))
      {
        c_icap_reconfigure = 0;
        signed int return_value_server_reconfigure$9;
        return_value_server_reconfigure$9=server_reconfigure();
        if(return_value_server_reconfigure$9 == 0)
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Error while reconfiguring, exiting!\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Error while reconfiguring, exiting!\n");

          }

          break;
        }

      }

    }
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Possibly a term signal received. Monitor process going to term all children\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Possibly a term signal received. Monitor process going to term all children\n");

    }

    kill_all_childs();
    system_shutdown();
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Exiting....\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Exiting....\n");

    }

    return 1;
  }

  else
    return 1;
}

// stat_entry_add
// file stats.c line 40
signed int stat_entry_add(struct stat_entry_list *list, const char *label, signed int type, signed int gid)
{
  struct stat_entry *l;
  signed int indx;
  if(list == ((struct stat_entry_list *)NULL))
    return -1;

  else
  {
    indx=stat_entry_by_name(list, label);
    if(indx >= 0)
      return indx;

    else
    {
      if(list->size == list->entries_num)
      {
        if(list->size == 0)
        {
          void *return_value_malloc$1;
          return_value_malloc$1=malloc((unsigned long int)128 * sizeof(struct stat_entry) /*16ul*/ );
          list->entries = (struct stat_entry *)return_value_malloc$1;
          if(list->entries == ((struct stat_entry *)NULL))
            return -1;

        }

        else
        {
          void *return_value_realloc$2;
          return_value_realloc$2=realloc((void *)list->entries, (unsigned long int)(list->size + 128) * sizeof(struct stat_entry) /*16ul*/ );
          l = (struct stat_entry *)return_value_realloc$2;
          if(l == ((struct stat_entry *)NULL))
            return -1;

          list->entries = l;
        }
        list->size = list->size + 128;
      }

      (list->entries + (signed long int)list->entries_num)->label=strdup(label);
      (list->entries + (signed long int)list->entries_num)->type = type;
      (list->entries + (signed long int)list->entries_num)->gid = gid;
      indx = list->entries_num;
      list->entries_num = list->entries_num + 1;
      return indx;
    }
  }
}

// stat_entry_by_name
// file stats.c line 88
signed int stat_entry_by_name(struct stat_entry_list *list, const char *label)
{
  signed int i;
  signed int return_value_strcmp$1;
  if(list->entries == ((struct stat_entry *)NULL))
    return -1;

  else
  {
    i = 0;
    for( ; !(i >= list->entries_num); i = i + 1)
    {
      return_value_strcmp$1=strcmp(label, (list->entries + (signed long int)i)->label);
      if(return_value_strcmp$1 == 0)
        return i;

    }
    return -1;
  }
}

// stat_entry_release_list
// file stats.c line 75
void stat_entry_release_list(struct stat_entry_list *list)
{
  signed int i;
  if(!(list->entries == ((struct stat_entry *)NULL)))
  {
    i = 0;
    for( ; !(i >= list->entries_num); i = i + 1)
      free((void *)(list->entries + (signed long int)i)->label);
    free((void *)list->entries);
    list->entries = (struct stat_entry *)(void *)0;
    list->size = 0;
    list->entries_num = 0;
  }

}

// stat_group_add
// file stats.c line 100
signed int stat_group_add(char *group)
{
  char **group_list;
  signed int gid = 0;
  gid = 0;
  for( ; !(gid >= STAT_GROUPS.entries_num); gid = gid + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(STAT_GROUPS.groups[(signed long int)gid], group);
    if(return_value_strcmp$1 == 0)
      return gid;

  }
  if(STAT_GROUPS.size == 0)
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)128 * sizeof(char *) /*8ul*/ );
    STAT_GROUPS.groups = (char **)return_value_malloc$2;
    if(STAT_GROUPS.groups == ((char **)NULL))
      return -1;

    STAT_GROUPS.size = 128;
  }

  else
    if(STAT_GROUPS.size == STAT_GROUPS.entries_num)
    {
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)STAT_GROUPS.groups, (unsigned long int)(STAT_GROUPS.size + 128) * sizeof(char *) /*8ul*/ );
      group_list = (char **)return_value_realloc$3;
      if(group_list == ((char **)NULL))
        return -1;

      STAT_GROUPS.groups = group_list;
      STAT_GROUPS.size = STAT_GROUPS.size + 128;
    }

  STAT_GROUPS.groups[(signed long int)STAT_GROUPS.entries_num]=strdup(group);
  gid = STAT_GROUPS.entries_num;
  STAT_GROUPS.entries_num = STAT_GROUPS.entries_num + 1;
  return gid;
}

// stat_memblock_fix
// file include/stats.h line 97
void stat_memblock_fix(struct stat_memblock *mem_block)
{
  /* assertion mem_block->sig == 0xFAFA */
  assert(mem_block->sig == (unsigned int)0xFAFA);
  mem_block->counters64_size = STAT_INT64.entries_num;
  mem_block->counterskbs_size = STAT_KBS.entries_num;
  mem_block->counters64 = (unsigned long int *)((void *)mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  mem_block->counterskbs = (struct kbs *)((void *)mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (signed long int)((unsigned long int)mem_block->counters64_size * sizeof(unsigned long int) /*8ul*/ ));
}

// stat_memblock_reconstruct
// file include/stats.h line 98
void stat_memblock_reconstruct(struct stat_memblock *mem_block)
{
  /* assertion mem_block->sig == 0xFAFA */
  assert(mem_block->sig == (unsigned int)0xFAFA);
  mem_block->counters64 = (unsigned long int *)((void *)mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  mem_block->counterskbs = (struct kbs *)((void *)mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (signed long int)((unsigned long int)mem_block->counters64_size * sizeof(unsigned long int) /*8ul*/ ));
}

// stop_command
// file mpmt_server.c line 994
void stop_command(const char *name, signed int type, const char **argv)
{
  c_icap_going_to_term = 1;
}

// store_pid
// file aserver.c line 49
signed int store_pid(char *pidfile)
{
  signed int fd;
  signed int bytes;
  signed int pid;
  char strPid[30l];
  pid=getpid();
  fd=open64(pidfile, 0100 | 01000 | 01, 0644);
  if(!(fd >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Cannot open the pid file: %s\n", pidfile);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Cannot open the pid file: %s\n", pidfile);

    }

    return 0;
  }

  else
  {
    snprintf(strPid, (unsigned long int)29, "%d", pid);
    strPid[(signed long int)29] = (char)0;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(strPid);
    signed long int return_value_write$2;
    return_value_write$2=write(fd, (const void *)strPid, return_value_strlen$1);
    bytes = (signed int)return_value_write$2;
    close(fd);
    return 1;
  }
}

// string_ext_cmp
// file types_ops.c line 73
signed int string_ext_cmp(const void *key1, const void *key2)
{
  if(key2 == NULL)
    return -1;

  else
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((const char *)key1, "*");
    if(return_value_strcmp$1 == 0)
      return 0;

    else
    {
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp((const char *)key1, (const char *)key2);
      return return_value_strcmp$2;
    }
  }
}

// string_ext_equal
// file types_ops.c line 84
signed int string_ext_equal(const void *key1, const void *key2)
{
  if(key2 == NULL)
    return 0;

  else
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((const char *)key1, "*");
    if(return_value_strcmp$1 == 0)
      return 1;

    else
    {
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp((const char *)key1, (const char *)key2);
      return (signed int)(return_value_strcmp$2 == 0);
    }
  }
}

// stringcmp
// file types_ops.c line 41
signed int stringcmp(const void *key1, const void *key2)
{
  if(key2 == NULL)
    return -1;

  else
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((const char *)key1, (const char *)key2);
    return return_value_strcmp$1;
  }
}

// stringdup
// file types_ops.c line 33
void * stringdup(const char *str, struct ci_mem_allocator *allocator)
{
  char *new_s;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  void *return_value;
  return_value=allocator->alloc(allocator, return_value_strlen$1 + (unsigned long int)1);
  new_s = (char *)return_value;
  if(!(new_s == ((char *)NULL)))
    strcpy(new_s, str);

  return (void *)new_s;
}

// stringequal
// file types_ops.c line 48
signed int stringequal(const void *key1, const void *key2)
{
  if(key2 == NULL)
    return 0;

  else
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp((const char *)key1, (const char *)key2);
    return (signed int)(return_value_strcmp$1 == 0);
  }
}

// stringfree
// file types_ops.c line 60
void stringfree(void *key, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, key);
}

// stringlen
// file types_ops.c line 55
unsigned long int stringlen(const void *key)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen((const char *)key);
  return return_value_strlen$1 + (unsigned long int)1;
}

// system_reconfigure
// file cfg_param.c line 954
signed int system_reconfigure()
{
  signed int old_port;
  if(CI_DEBUG_LEVEL >= 1)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Going to reconfigure system!\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Going to reconfigure system!\n");

  }

  system_shutdown();
  reset_conf_tables();
  ci_acl_reset();
  reset_http_auth();
  if(CI_DEBUG_LEVEL >= 1)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "All resources released. Going to reload!\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("All resources released. Going to reload!\n");

  }

  ci_txt_template_init();
  CI_CONF.MAGIC_DB=ci_magic_db_load(CI_CONF.magics_file);
  if(CI_CONF.MAGIC_DB == ((struct ci_magics_db *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Can not load magic file %s!!!\n", CI_CONF.magics_file);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Can not load magic file %s!!!\n", CI_CONF.magics_file);

    }

  }

  init_modules();
  init_services();
  old_port = CI_CONF.PORT;
  signed int return_value_reconfig$1;
  return_value_reconfig$1=reconfig();
  if(return_value_reconfig$1 == 0)
    return 0;

  else
  {
    if(!(old_port == CI_CONF.PORT))
      init_server(CI_CONF.ADDRESS, CI_CONF.PORT, &CI_CONF.PROTOCOL_FAMILY);

    log_open();
    post_init_modules();
    post_init_services();
    return 1;
  }
}

// system_shutdown
// file cfg_param.c line 927
void system_shutdown()
{
  commands_reset();
  ci_registry_clean();
  release_services();
  release_modules();
  ci_dlib_closeall();
  ci_magic_db_free();
  CI_CONF.MAGIC_DB = (struct ci_magics_db *)(void *)0;
  ci_txt_template_close();
}

// sysv_proc_mutex_destroy
// file os/unix/proc_mutex.c line 74
static signed int sysv_proc_mutex_destroy(struct ci_proc_mutex *mutex)
{
  signed int return_value_semctl$1;
  return_value_semctl$1=semctl(mutex->$anon0.sysv.id, 0, 0, 0);
  if(!(return_value_semctl$1 >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error removing mutex\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error removing mutex\n");

    }

    return 0;
  }

  else
    return 1;
}

// sysv_proc_mutex_init
// file os/unix/proc_mutex.c line 56
static signed int sysv_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name)
{
  union semun arg;
  mutex->$anon0.sysv.id=semget((signed int)0, 1, 01000 | 0600);
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  if(!(mutex->$anon0.sysv.id >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error creating mutex\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error creating mutex\n");

    }

    return 0;
  }

  else
  {
    arg.val = 0;
    signed int return_value_semctl$3;
    return_value_semctl$3=semctl(mutex->$anon0.sysv.id, 0, 16, arg);
    if(!(return_value_semctl$3 >= 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value___errno_location$1=__errno_location();
          __log_error((void *)0, "Error setting default value for mutex, errno:%d\n", *return_value___errno_location$1);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value___errno_location$2=__errno_location();
          printf("Error setting default value for mutex, errno:%d\n", *return_value___errno_location$2);
        }

      }

      return 0;
    }

    else
    {
      strncpy(mutex->name, name, (unsigned long int)64);
      mutex->name[(signed long int)(64 - 1)] = (char)0;
      return 1;
    }
  }
}

// sysv_proc_mutex_lock
// file os/unix/proc_mutex.c line 83
static signed int sysv_proc_mutex_lock(struct ci_proc_mutex *mutex)
{
  signed int return_value_semop$1;
  return_value_semop$1=semop(mutex->$anon0.sysv.id, (struct sembuf *)&op_lock, (unsigned long int)2);
  if(!(return_value_semop$1 >= 0))
    return 0;

  else
    return 1;
}

// sysv_proc_mutex_print_info
// file os/unix/proc_mutex.c line 99
static signed int sysv_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, buf_size, "sysv:%s/%d", (const void *)mutex->name, mutex->$anon0.sysv.id);
  return return_value_snprintf$1;
}

// sysv_proc_mutex_unlock
// file os/unix/proc_mutex.c line 91
static signed int sysv_proc_mutex_unlock(struct ci_proc_mutex *mutex)
{
  signed int return_value_semop$1;
  return_value_semop$1=semop(mutex->$anon0.sysv.id, (struct sembuf *)&op_unlock, (unsigned long int)1);
  if(!(return_value_semop$1 >= 0))
    return 0;

  else
    return 1;
}

// sysv_shared_mem_attach
// file os/unix/shared_mem.c line 56
void * sysv_shared_mem_attach(struct ci_shared_mem_id *id)
{
  id->mem=shmat(id->$anon0.sysv.id, (void *)0, 0);
  if(id->mem == (void *)-1)
    return (void *)0;

  else
    return id->mem;
}

// sysv_shared_mem_create
// file os/unix/shared_mem.c line 40
void * sysv_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size)
{
  id->$anon0.sysv.id=shmget((signed int)0, (unsigned long int)size, 0600 | 01000);
  if(!(id->$anon0.sysv.id >= 0))
    return (void *)0;

  else
  {
    id->mem=shmat(id->$anon0.sysv.id, (void *)0, 0);
    if(id->mem == (void *)-1)
      return (void *)0;

    else
    {
      id->size = (unsigned long int)size;
      snprintf(id->name, (unsigned long int)64, "%s", name);
      return id->mem;
    }
  }
}

// sysv_shared_mem_destroy
// file os/unix/shared_mem.c line 73
signed int sysv_shared_mem_destroy(struct ci_shared_mem_id *id)
{
  signed int return_value_shmdt$1;
  return_value_shmdt$1=shmdt(id->mem);
  if(!(return_value_shmdt$1 >= 0))
    return 0;

  else
  {
    signed int return_value_shmctl$2;
    return_value_shmctl$2=shmctl(id->$anon0.sysv.id, 0, (struct shmid_ds *)(void *)0);
    if(!(return_value_shmctl$2 >= 0))
      return 0;

    else
      return 1;
  }
}

// sysv_shared_mem_detach
// file os/unix/shared_mem.c line 64
signed int sysv_shared_mem_detach(struct ci_shared_mem_id *id)
{
  signed int return_value_shmdt$1;
  return_value_shmdt$1=shmdt(id->mem);
  if(!(return_value_shmdt$1 >= 0))
    return 0;

  else
    return 1;
}

// sysv_shared_mem_print_info
// file os/unix/shared_mem.c line 84
signed int sysv_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf$1;
  return_value_snprintf$1=snprintf(buf, buf_size, "sysv:%s/%d %ld kbs", (const void *)id->name, id->$anon0.sysv.id, (signed long int)(id->size / (unsigned long int)1024));
  return return_value_snprintf$1;
}

// templateExpired
// file txtTemplate.c line 109
static signed int templateExpired(struct anonymous$7 *template)
{
  char path[4096l];
  struct stat file;
  signed long int current_time;
  time(&current_time);
  if(current_time + -template->loaded >= (signed long int)TEMPLATE_RELOAD_TIME)
  {
    makeTemplatePathFileName(path, 4096, template->SERVICE_NAME, template->TEMPLATE_NAME, template->LANGUAGE);
    signed int return_value_stat64$1;
    return_value_stat64$1=stat64(path, &file);
    if(!(return_value_stat64$1 >= 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Can not found the text template file %s!", (const void *)path);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Can not found the text template file %s!", (const void *)path);

      }

      return 0;
    }

    if(!(template->modified >= file.st_mtim.tv_sec))
    {
      if(CI_DEBUG_LEVEL >= 4)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "templateFind: found: %s, %s, %s updated on disk, expired.\n", template->SERVICE_NAME, template->LANGUAGE, template->TEMPLATE_NAME);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("templateFind: found: %s, %s, %s updated on disk, expired.\n", template->SERVICE_NAME, template->LANGUAGE, template->TEMPLATE_NAME);

      }

      return 1;
    }

  }

  return 0;
}

// templateFind
// file txtTemplate.c line 208
static struct anonymous$7 * templateFind(const char *SERVICE_NAME, const char *TEMPLATE_NAME, const char *LANGUAGE)
{
  signed int i = 0;
  i = 0;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    if(!((templates + (signed long int)i)->data == ((struct ci_membuf *)NULL)))
    {
      if((templates + (signed long int)i)->must_free == 0)
      {
        signed int return_value_strcmp$3;
        return_value_strcmp$3=strcmp((templates + (signed long int)i)->SERVICE_NAME, SERVICE_NAME);
        if(return_value_strcmp$3 == 0)
        {
          return_value_strcmp$2=strcmp((templates + (signed long int)i)->TEMPLATE_NAME, TEMPLATE_NAME);
          if(return_value_strcmp$2 == 0)
          {
            return_value_strcmp$1=strcmp((templates + (signed long int)i)->LANGUAGE, LANGUAGE);
            if(return_value_strcmp$1 == 0)
            {
              if(CI_DEBUG_LEVEL >= 4)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "templateFind: found: %s, %s, %s in cache at index %d\n", SERVICE_NAME, LANGUAGE, TEMPLATE_NAME, i);

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("templateFind: found: %s, %s, %s in cache at index %d\n", SERVICE_NAME, LANGUAGE, TEMPLATE_NAME, i);

              }

              return &templates[(signed long int)i];
            }

          }

        }

      }

    }

  return (struct anonymous$7 *)(void *)0;
}

// templateFindFree
// file txtTemplate.c line 228
static struct anonymous$7 * templateFindFree(void)
{
  signed long int oldest = (signed long int)0;
  struct anonymous$7 *useme = (struct anonymous$7 *)(void *)0;
  signed int i = 0;
  i = 0;
  for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    if((templates + (signed long int)i)->data == ((struct ci_membuf *)NULL))
      return &templates[(signed long int)i];

  i = 0;
  for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    if(!((templates + (signed long int)i)->last_used >= oldest))
    {
      if(!((templates + (signed long int)i)->locked >= 1))
      {
        oldest = (templates + (signed long int)i)->last_used;
        useme = &templates[(signed long int)i];
      }

    }

  if(!(useme == ((struct anonymous$7 *)NULL)))
  {
    if(!(useme->data == ((struct ci_membuf *)NULL)))
      templateFree(useme);

  }

  return useme;
}

// templateFree
// file txtTemplate.c line 136
static void templateFree(struct anonymous$7 *template)
{
  /* assertion template != ((void *)0) */
  assert(template != (struct anonymous$7 *)(void *)0);
  if(!(template->data == ((struct ci_membuf *)NULL)))
  {
    if(!(template->TEMPLATE_NAME == ((char *)NULL)))
      free((void *)template->TEMPLATE_NAME);

    if(!(template->SERVICE_NAME == ((char *)NULL)))
      free((void *)template->SERVICE_NAME);

    if(!(template->LANGUAGE == ((char *)NULL)))
      free((void *)template->LANGUAGE);

    template->LANGUAGE = (char *)(void *)0;
    template->SERVICE_NAME = template->LANGUAGE;
    template->TEMPLATE_NAME = template->SERVICE_NAME;
    ci_membuf_free(template->data);
    template->data = (struct ci_membuf *)(void *)0;
  }

}

// templateLoadText
// file txtTemplate.c line 347
static struct anonymous$7 * templateLoadText(const struct ci_request *req, const char *service_name, const char *page_name)
{
  const char *acceptLangHeader;
  const char *s;
  char preferred[32l];
  signed int i;
  struct anonymous$7 *template = (struct anonymous$7 *)(void *)0;
  acceptLangHeader=ci_http_request_get_header((struct ci_request *)req, "Accept-Language");
  const unsigned short int **return_value___ctype_b_loc$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  const unsigned short int **return_value___ctype_b_loc$4;
  if(!(acceptLangHeader == ((const char *)NULL)))
  {
    s = acceptLangHeader;
    if(CI_DEBUG_LEVEL >= 4)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "templateLoadText: Languages are: '%s'\n", s);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("templateLoadText: Languages are: '%s'\n", s);

    }

    while(!((signed int)*s == 0))
    {
      for( ; !((signed int)*s == 0); s = s + 1l)
      {
        return_value___ctype_b_loc$1=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*s]) == 0)
          break;

      }
      i = 0;
      do
      {
        if(!((signed int)*s == 0))
          tmp_if_expr$2 = (signed int)*s != 44 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
          tmp_if_expr$3 = (signed int)*s != 59 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
        {
          return_value___ctype_b_loc$4=__ctype_b_loc();
          tmp_if_expr$5 = !(((signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*s] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$5 = (_Bool)0;
        if((unsigned long int)i >= 31ul || !tmp_if_expr$5)
          break;

        preferred[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      preferred[(signed long int)i] = (char)0;
      if(CI_DEBUG_LEVEL >= 6)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Try load the error message on language:%s\n", (const void *)preferred);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Try load the error message on language:%s\n", (const void *)preferred);

      }

      template=templateTryLoadText(req, service_name, page_name, preferred);
      if(!(template == ((struct anonymous$7 *)NULL)))
        return template;

      for( ; !((signed int)*s == 0); s = s + 1l)
        if((signed int)*s == 44)
          break;

      if((signed int)*s == 44)
        s = s + 1l;

    }
  }

  if(CI_DEBUG_LEVEL >= 4)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "templateLoadText: Accept-Language header not found or was empty!\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("templateLoadText: Accept-Language header not found or was empty!\n");

  }

  struct anonymous$7 *return_value_templateTryLoadText$6;
  return_value_templateTryLoadText$6=templateTryLoadText(req, service_name, page_name, TEMPLATE_DEF_LANG);
  return return_value_templateTryLoadText$6;
}

// templateTryLoadText
// file txtTemplate.c line 251
static struct anonymous$7 * templateTryLoadText(const struct ci_request *req, const char *service_name, const char *page_name, const char *lang)
{
  signed int fd;
  char path[4096l];
  char buf[4096l];
  struct stat file;
  signed long int len;
  struct ci_membuf *textbuff = (struct ci_membuf *)(void *)0;
  struct anonymous$7 *tempTemplate = (struct anonymous$7 *)(void *)0;
  signed long int current_time;
  time(&current_time);
  pthread_mutex_lock(&templates_mutex);
  tempTemplate=templateFind(service_name, page_name, lang);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$3;
  char *return_value_strerror$4;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  signed int *return_value___errno_location$7;
  char *return_value_strerror$8;
  if(!(tempTemplate == ((struct anonymous$7 *)NULL)))
  {
    tempTemplate->last_used = current_time;
    tempTemplate->locked = tempTemplate->locked + 1;
    pthread_mutex_unlock(&templates_mutex);
    return tempTemplate;
  }

  else
  {
    pthread_mutex_unlock(&templates_mutex);
    makeTemplatePathFileName(path, 4096, service_name, page_name, lang);
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "templateTryLoadText: %s\n", (const void *)path);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("templateTryLoadText: %s\n", (const void *)path);

    }

    fd=open64(path, 00);
    if(!(fd >= 0))
    {
      if(CI_DEBUG_LEVEL >= 4)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value___errno_location$1=__errno_location();
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          __log_error((void *)0, "templateTryLoadText: '%s': %s\n", (const void *)path, return_value_strerror$2);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value___errno_location$3=__errno_location();
          return_value_strerror$4=strerror(*return_value___errno_location$3);
          printf("templateTryLoadText: '%s': %s\n", (const void *)path, return_value_strerror$4);
        }

      }

      return (struct anonymous$7 *)(void *)0;
    }

    else
    {
      fstat64(fd, &file);
      textbuff=ci_membuf_new_sized((signed int)(file.st_size + (signed long int)1));
      if(textbuff == ((struct ci_membuf *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "templateTryLoadText: membuf allocation failed!\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("templateTryLoadText: membuf allocation failed!\n");

        }

        return (struct anonymous$7 *)(void *)0;
      }

      else
      {
        do
        {
          len=read(fd, (void *)buf, sizeof(char [4096l]) /*4096ul*/ );
          if(!(len >= 1l))
            break;

          ci_membuf_write(textbuff, buf, (signed int)len, 0);
        }
        while((_Bool)1);
        close(fd);
        if(!(len >= 0l))
        {
          if(CI_DEBUG_LEVEL >= 4)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            {
              return_value___errno_location$5=__errno_location();
              return_value_strerror$6=strerror(*return_value___errno_location$5);
              __log_error((void *)0, "templateTryLoadText: failed to fully read: '%s': %s\n", (const void *)path, return_value_strerror$6);
            }

            if(!(CI_DEBUG_STDOUT == 0))
            {
              return_value___errno_location$7=__errno_location();
              return_value_strerror$8=strerror(*return_value___errno_location$7);
              printf("templateTryLoadText: failed to fully read: '%s': %s\n", (const void *)path, return_value_strerror$8);
            }

          }

          ci_membuf_free(textbuff);
          return (struct anonymous$7 *)(void *)0;
        }

        else
        {
          ci_membuf_write(textbuff, "\0", 1, 1);
          pthread_mutex_lock(&templates_mutex);
          tempTemplate=templateFindFree();
          if(!(tempTemplate == ((struct anonymous$7 *)NULL)))
          {
            tempTemplate->locked = tempTemplate->locked + 1;
            tempTemplate->non_cached = 0;
          }

          else
          {
            if(CI_DEBUG_LEVEL >= 4)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "templateTryLoadText: Unable to find free template slot.\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("templateTryLoadText: Unable to find free template slot.\n");

            }

            void *return_value_malloc$9;
            return_value_malloc$9=malloc(sizeof(struct anonymous$7) /*72ul*/ );
            tempTemplate = (struct anonymous$7 *)return_value_malloc$9;
            if(tempTemplate == ((struct anonymous$7 *)NULL))
            {
              if(CI_DEBUG_LEVEL >= 1)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "templateTryLoadText: memory allocation error!\n");

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("templateTryLoadText: memory allocation error!\n");

              }

              pthread_mutex_unlock(&templates_mutex);
              ci_membuf_free(textbuff);
              return (struct anonymous$7 *)(void *)0;
            }

            tempTemplate->non_cached = 1;
          }
          tempTemplate->SERVICE_NAME=strdup(service_name);
          tempTemplate->TEMPLATE_NAME=strdup(page_name);
          tempTemplate->LANGUAGE=strdup(lang);
          tempTemplate->data = textbuff;
          tempTemplate->loaded = current_time;
          tempTemplate->modified = file.st_mtim.tv_sec;
          tempTemplate->last_used = current_time;
          tempTemplate->must_free = 0;
          pthread_mutex_unlock(&templates_mutex);
          return tempTemplate;
        }
      }
    }
  }
}

// template_release
// file txtTemplate.c line 152
static void template_release(struct anonymous$7 *template)
{
  signed int must_free = 0;
  signed int return_value_templateExpired$1;
  if(!(template == ((struct anonymous$7 *)NULL)))
  {
    if(!(template->non_cached == 0))
    {
      templateFree(template);
      free((void *)template);
    }

    else
    {
      _Bool tmp_if_expr$2;
      if(!(template->must_free == 0))
        tmp_if_expr$2 = (_Bool)1;

      else
      {
        return_value_templateExpired$1=templateExpired(template);
        tmp_if_expr$2 = return_value_templateExpired$1 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$2)
        must_free = 1;

      pthread_mutex_lock(&templates_mutex);
      template->locked = template->locked - 1;
      if(!(template->locked >= 0))
        template->locked = 0;

      _Bool tmp_if_expr$3;
      if(!(must_free == 0))
        tmp_if_expr$3 = template->locked == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
        templateFree(template);

      else
        template->must_free = must_free;
      pthread_mutex_unlock(&templates_mutex);
    }
  }

}

// term_handler_child
// file mpmt_server.c line 99
static void term_handler_child(signed int sig)
{
  if(!(child_data == ((struct child_shared_data *)NULL)))
  {
    if(child_data->father_said == 0)
      child_data->to_be_killed = 2;

    else
      child_data->to_be_killed = child_data->father_said;
  }

}

// test_command
// file mpmt_server.c line 1012
void test_command(const char *name, signed int type, const char **argv)
{
  signed int i = 0;
  if(CI_DEBUG_LEVEL >= 1)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Test command for %s. Arguments:", type == 1 ? "monitor process" : "child process");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Test command for %s. Arguments:", type == 1 ? "monitor process" : "child process");

  }

  for( ; !(argv[(signed long int)i] == ((const char *)NULL)); i = i + 1)
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "%s,", argv[(signed long int)i]);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("%s,", argv[(signed long int)i]);

    }

  if(CI_DEBUG_LEVEL >= 1)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("\n");

  }

}

// thread_main
// file mpmt_server.c line 551
signed int thread_main(struct server_decl *srv)
{
  struct ci_connection con;
  char clientname[257l];
  signed int ret;
  signed int request_status = 0;
  signed int keepalive_reqs;
  thread_signals(0);
  srv->srv_id=getpid();
  signed int return_value_keepalive_request$1;
  while((_Bool)1)
  {
    if(child_data->to_be_killed == 2)
    {
      srv->running = 0;
      return 1;
    }

    ret=get_from_queue(con_queue, &con);
    if(ret == 0)
    {
      if(!(child_data->to_be_killed == 0))
      {
        srv->running = 0;
        return 1;
      }

      ret=wait_for_queue(con_queue);
    }

    else
    {
      if(!(ret >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Fatal Error!!! Error getting a connection from connections queue!!!\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Fatal Error!!! Error getting a connection from connections queue!!!\n");

        }

        break;
      }

      pthread_mutex_lock(&counters_mtx);
      child_data->freeservers = child_data->freeservers - 1;
      child_data->usedservers = child_data->usedservers + 1;
      pthread_mutex_unlock(&counters_mtx);
      ci_netio_init(con.fd);
      ret = 1;
      if(srv->current_req == ((struct ci_request *)NULL))
        srv->current_req=newrequest(&con);

      else
        ret=recycle_request(srv->current_req, &con);
      if(srv->current_req == ((struct ci_request *)NULL) || ret == 0)
      {
        ci_sockaddr_t_to_host(&con.claddr, clientname, 256);
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Request from %s denied...\n", (const void *)clientname);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Request from %s denied...\n", (const void *)clientname);

        }

        ci_hard_close((&con)->fd);
      }

      else
      {
        keepalive_reqs = 0;
        while((_Bool)1)
        {
          if(MAX_KEEPALIVE_REQUESTS >= 1 && keepalive_reqs >= MAX_KEEPALIVE_REQUESTS)
            srv->current_req->keepalive = 0;

          if(!(child_data->to_be_killed == 0))
            srv->current_req->keepalive = 0;

          request_status=process_request(srv->current_req);
          if(request_status == 0)
          {
            if(CI_DEBUG_LEVEL >= 5)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Process request timeout or interrupted....\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Process request timeout or interrupted....\n");

            }

            ci_request_reset(srv->current_req);
            break;
          }

          srv->served_requests = srv->served_requests + 1;
          srv->served_requests_no_reallocation = srv->served_requests_no_reallocation + 1;
          keepalive_reqs = keepalive_reqs + 1;
          pthread_mutex_lock(&counters_mtx);
          child_data->requests = child_data->requests + 1;
          pthread_mutex_unlock(&counters_mtx);
          log_access(srv->current_req, request_status);
          if(child_data->to_be_killed == 2)
            break;

          if(child_data->to_be_killed == 1)
          {
            if(srv->current_req->keepalive == 0)
              break;

          }

          if(CI_DEBUG_LEVEL >= 8)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Keep-alive:%d\n", srv->current_req->keepalive);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Keep-alive:%d\n", srv->current_req->keepalive);

          }

          _Bool tmp_if_expr$2;
          if(!(srv->current_req->keepalive == 0))
          {
            return_value_keepalive_request$1=keepalive_request(srv->current_req);
            tmp_if_expr$2 = return_value_keepalive_request$1 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$2 = (_Bool)0;
          if(tmp_if_expr$2)
          {
            if(CI_DEBUG_LEVEL >= 8)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Server %d going to serve new request from client (keep-alive) \n", srv->srv_id);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Server %d going to serve new request from client (keep-alive) \n", srv->srv_id);

            }

          }

          else
            break;
        }
        if(!(srv->current_req == ((struct ci_request *)NULL)))
        {
          _Bool tmp_if_expr$3;
          if(!(request_status == 1))
            tmp_if_expr$3 = (_Bool)1;

          else
            tmp_if_expr$3 = child_data->to_be_killed != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$3)
            ci_hard_close(srv->current_req->connection->fd);

          else
            ci_linger_close(srv->current_req->connection->fd, MAX_SECS_TO_LINGER);
        }

        if(!(MAX_REQUESTS_BEFORE_REALLOCATE_MEM >= srv->served_requests_no_reallocation))
        {
          if(CI_DEBUG_LEVEL >= 5)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Max requests reached, reallocate memory and buffers .....\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Max requests reached, reallocate memory and buffers .....\n");

          }

          ci_request_destroy(srv->current_req);
          srv->current_req = (struct ci_request *)(void *)0;
          srv->served_requests_no_reallocation = 0;
        }

      }

    end_of_main_loop_thread:
      ;
      pthread_mutex_lock(&counters_mtx);
      child_data->freeservers = child_data->freeservers + 1;
      child_data->usedservers = child_data->usedservers - 1;
      pthread_mutex_unlock(&counters_mtx);
      pthread_cond_signal(&free_server_cond);
    }
  }
  srv->running = 0;
  return 0;
}

// thread_signals
// file mpmt_server.c line 164
void thread_signals(signed int islistener)
{
  struct anonymous$18 sig_mask;
  sigemptyset(&sig_mask);
  sigaddset(&sig_mask, 2);
  if(islistener == 0)
    sigaddset(&sig_mask, 1);

  signed int return_value_pthread_sigmask$1;
  return_value_pthread_sigmask$1=pthread_sigmask(0, &sig_mask, (struct anonymous$18 *)(void *)0);
  if(!(return_value_pthread_sigmask$1 == 0))
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "O an error....\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("O an error....\n");

    }

  }

  pthread_setcancelstate(0, (signed int *)(void *)0);
  pthread_setcanceltype(1, (signed int *)(void *)0);
}

// types_add
// file filetype.c line 86
signed int types_add(struct ci_magics_db *db, const char *name, const char *descr, signed int *groups)
{
  struct ci_data_type *newdata;
  signed int indx;
  signed int i;
  if(db->types_num >= db->types_size)
  {
    void *return_value_realloc$1;
    return_value_realloc$1=realloc((void *)db->types, (unsigned long int)(db->types_size + 50) * sizeof(struct ci_data_type) /*324ul*/ );
    newdata = (struct ci_data_type *)return_value_realloc$1;
    if(newdata == ((struct ci_data_type *)NULL))
      return -1;

    db->types_size = db->types_size + 50;
    db->types = newdata;
  }

  indx = db->types_num;
  db->types_num = db->types_num + 1;
  strcpy((db->types + (signed long int)indx)->name, name);
  strcpy((db->types + (signed long int)indx)->descr, descr);
  i = 0;
  for( ; groups[(signed long int)i] >= 0; i = i + 1)
  {
    if(i >= 64)
      break;

    (db->types + (signed long int)indx)->groups[(signed long int)i] = groups[(signed long int)i];
  }
  (db->types + (signed long int)indx)->groups[(signed long int)i] = -1;
  return indx;
}

// types_init
// file filetype.c line 81
signed int types_init(struct ci_magics_db *db)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)50 * sizeof(struct ci_data_type) /*324ul*/ );
  db->types = (struct ci_data_type *)return_value_malloc$1;
  if(db->types == ((struct ci_data_type *)NULL))
    return 0;

  else
  {
    db->types_num = 0;
    db->types_size = 50;
    return 1;
  }
}

// uint64_cmp
// file types_ops.c line 183
signed int uint64_cmp(const void *key1, const void *key2)
{
  unsigned long int k1;
  unsigned long int k2;
  k1 = *((unsigned long int *)key1);
  k2 = *((unsigned long int *)key2);
  if(!(k1 >= k2))
    return -1;

  else
    if(!(k2 >= k1))
      return 1;

    else
      return 0;
}

// uint64_dup
// file types_ops.c line 166
void * uint64_dup(const char *str, struct ci_mem_allocator *allocator)
{
  unsigned long int *i;
  char *e = (char *)(void *)0;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(unsigned long int) /*8ul*/ );
  i = (unsigned long int *)return_value;
  if(!(i == ((unsigned long int *)NULL)))
  {
    signed long long int return_value_strtoll$1;
    return_value_strtoll$1=strtoll(str, &e, 10);
    *i = (unsigned long int)return_value_strtoll$1;
    _Bool tmp_if_expr$4;
    if((signed int)*e == 75)
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = (signed int)*e == 107 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$4)
      *i = *i * (unsigned long int)1000;

    else
    {
      _Bool tmp_if_expr$3;
      if((signed int)*e == 77)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)*e == 109 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
        *i = *i * (unsigned long int)1000000;

      else
      {
        _Bool tmp_if_expr$2;
        if((signed int)*e == 71)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = (signed int)*e == 103 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          *i = *i * (unsigned long int)1000000000;

      }
    }
  }

  return (void *)i;
}

// uint64_equal
// file types_ops.c line 196
signed int uint64_equal(const void *key1, const void *key2)
{
  unsigned long int k1;
  unsigned long int k2;
  k1 = *((unsigned long int *)key1);
  k2 = *((unsigned long int *)key2);
  return (signed int)(k1 == k2);
}

// uint64_free
// file types_ops.c line 204
void uint64_free(void *key, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, key);
}

// uint64_len
// file types_ops.c line 209
unsigned long int uint64_len(const void *key)
{
  return (unsigned long int)sizeof(unsigned long int) /*8ul*/ ;
}

// unregister_conf_table
// file cfg_param.c line 272
struct ci_conf_entry * unregister_conf_table(const char *name)
{
  signed int i;
  struct ci_conf_entry *table;
  signed int return_value_strcmp$1;
  if(!(extra_conf_tables == ((struct sub_table *)NULL)))
  {
    i = 0;
    for( ; !(i >= conf_tables_num); i = i + 1)
      if(!((extra_conf_tables + (signed long int)i)->name == ((const char *)NULL)))
      {
        return_value_strcmp$1=strcmp(name, (extra_conf_tables + (signed long int)i)->name);
        if(return_value_strcmp$1 == 0)
        {
          table = (extra_conf_tables + (signed long int)i)->conf_table;
          (extra_conf_tables + (signed long int)i)->name = (const char *)(void *)0;
          (extra_conf_tables + (signed long int)i)->type = 0;
          (extra_conf_tables + (signed long int)i)->conf_table = (struct ci_conf_entry *)(void *)0;
          return table;
        }

      }

  }

  if(CI_DEBUG_LEVEL >= 1)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Table %s not found!\n", name);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Table %s not found!\n", name);

  }

  return (struct ci_conf_entry *)(void *)0;
}

// update_send_status
// file request.c line 832
static signed int update_send_status(struct ci_request *req)
{
  signed int i;
  signed int status;
  struct ci_encaps_entity *e;
  if(req->status == 0)
  {
    signed int return_value_mk_responce_header$1;
    return_value_mk_responce_header$1=mk_responce_header(req);
    if(return_value_mk_responce_header$1 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error constructing the responce headers!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error constructing the responce headers!\n");

      }

      return -1;
    }

    req->responce_hasbody=resp_check_body(req);
    req->pstrblock_responce = req->response_header->buf;
    req->remain_send_block_bytes = req->response_header->bufused;
    req->status = 1;
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Going to send response headers\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Going to send response headers\n");

    }

    return 1;
  }

  _Bool tmp_if_expr$2;
  if(req->status == 6)
  {
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "The req->status is EOF (remain to send bytes:%d)\n", req->remain_send_block_bytes);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("The req->status is EOF (remain to send bytes:%d)\n", req->remain_send_block_bytes);

    }

    if(req->remain_send_block_bytes == 0)
      return -2;

    return 1;
  }

  else
    if(req->status == 5)
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Send status is SEND_BODY return\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Send status is SEND_BODY return\n");

      }

      return 1;
    }

    else
    {
      status = req->status;
      if(!(status >= 4))
        status = status + 1;

      if(status >= 2 && !(status >= 5))
      {
        i = status - 2;
        e = req->entities[(signed long int)i];
        _Bool tmp_if_expr$3;
        if(!(e == ((struct ci_encaps_entity *)NULL)))
        {
          if(e->type == 0)
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = e->type == 1 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
        {
          req->pstrblock_responce = ((struct ci_headers_list *)e->entity)->buf;
          req->remain_send_block_bytes = ((struct ci_headers_list *)e->entity)->bufused;
          req->status = status;
          if(CI_DEBUG_LEVEL >= 9)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Going to send http headers on entity :%d\n", i);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Going to send http headers on entity :%d\n", i);

          }

          return 1;
        }

        else
          if(!(req->responce_hasbody == 0))
          {
            req->status = 5;
            return 1;
          }

          else
          {
            req->status = 6;
            req->pstrblock_responce = (char *)(void *)0;
            req->remain_send_block_bytes = 0;
            return -2;
          }
      }

      return -1;
    }
}

// url_decoder
// file decode.c line 131
signed int url_decoder(const char *input, char *output, signed int output_len)
{
  signed int i;
  signed int k;
  char str[3l];
  i = 0;
  k = 0;
  for( ; !((signed int)input[(signed long int)i] == 0); k = k + 1)
  {
    if(k >= output_len + -1)
      break;

    if((signed int)input[(signed long int)i] == 37)
    {
      str[(signed long int)0] = input[(signed long int)(i + 1)];
      str[(signed long int)1] = input[(signed long int)(i + 2)];
      str[(signed long int)2] = (char)0;
      signed long int return_value_strtol$1;
      return_value_strtol$1=strtol(str, (char ** restrict )(void *)0, 16);
      output[(signed long int)k] = (char)return_value_strtol$1;
      i = i + 3;
    }

    else
      if((signed int)input[(signed long int)i] == 43)
      {
        output[(signed long int)k] = (char)32;
        i = i + 1;
      }

      else
      {
        output[(signed long int)k] = input[(signed long int)i];
        i = i + 1;
      }
  }
  output[(signed long int)k] = (char)0;
  if(k == output_len + -1)
    return -1;

  else
    return 1;
}

// url_decoder2
// file decode.c line 164
signed int url_decoder2(char *input)
{
  signed int i;
  signed int k;
  char str[3l];
  i = 0;
  k = 0;
  for( ; !((signed int)input[(signed long int)i] == 0); k = k + 1)
    if((signed int)input[(signed long int)i] == 37)
    {
      str[(signed long int)0] = input[(signed long int)(i + 1)];
      str[(signed long int)1] = input[(signed long int)(i + 2)];
      str[(signed long int)2] = (char)0;
      signed long int return_value_strtol$1;
      return_value_strtol$1=strtol(str, (char ** restrict )(void *)0, 16);
      input[(signed long int)k] = (char)return_value_strtol$1;
      i = i + 3;
    }

    else
      if((signed int)input[(signed long int)i] == 43)
      {
        input[(signed long int)k] = (char)32;
        i = i + 1;
      }

      else
      {
        input[(signed long int)k] = input[(signed long int)i];
        i = i + 1;
      }
  input[(signed long int)k] = (char)0;
  return 1;
}

// vlog_server
// file log.c line 90
void vlog_server(struct ci_request *req, const char *format, void **ap)
{
  if(!(default_logger == ((struct logger_module *)NULL)))
    default_logger->log_server("", format, ap);

}

// wait_childs_to_exit
// file mpmt_server.c line 297
static void wait_childs_to_exit(struct childs_queue *q)
{
  signed int i;
  signed int status;
  signed int pid;
  i = 0;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  for( ; !(i >= q->size); i = i + 1)
    if(!((q->childs + (signed long int)i)->pid == 0))
    {
      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Wait for child with pid:%d\n", (q->childs + (signed long int)i)->pid);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Wait for child with pid:%d\n", (q->childs + (signed long int)i)->pid);

      }

      if(!((q->childs + (signed long int)i)->to_be_killed == 2))
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Child %d not signaled yet!\n", (q->childs + (signed long int)i)->pid);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Child %d not signaled yet!\n", (q->childs + (signed long int)i)->pid);

        }

      }

      else
      {
        do
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          *return_value___errno_location$3 = 0;
          pid=waitpid((q->childs + (signed long int)i)->pid, &status, 1);
          if(!(pid >= 0))
          {
            return_value___errno_location$1=__errno_location();
            tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$2 = (_Bool)0;
        }
        while(tmp_if_expr$2);
        if(pid >= 1)
        {
          remove_child(q, pid, 0);
          if(CI_DEBUG_LEVEL >= 5)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Child %d died with status %d\n", pid, status);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Child %d died with status %d\n", pid, status);

          }

        }

      }
    }

}

// wait_for_commands
// file mpmt_server.c line 465
signed int wait_for_commands(signed int ctl_fd, char *command_buffer, signed int secs)
{
  struct anonymous$19 fds;
  struct timeval tv;
  signed int ret = 0;
  if(secs >= 0)
  {
    tv.tv_sec = (signed long int)secs;
    tv.tv_usec = (signed long int)0;
  }

  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$19) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&fds)->fds_bits[(signed long int)(ctl_fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fds)->fds_bits[(signed long int)(ctl_fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << ctl_fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  ret=select(ctl_fd + 1, &fds, (struct anonymous$19 *)(void *)0, (struct anonymous$19 *)(void *)0, secs >= 0 ? &tv : (struct timeval *)(void *)0);
  signed int *return_value___errno_location$2;
  if(ret >= 1)
  {
    if((fds.fds_bits[(signed long int)(ctl_fd / 8)] & (signed long int)(1UL << ctl_fd % 8)) == 0l)
      goto __CPROVER_DUMP_L3;

    ret=ci_read_nonblock(ctl_fd, (void *)command_buffer, (unsigned long int)(128 - 1));
    if(ret >= 1)
    {
      command_buffer[(signed long int)ret] = (char)0;
      return ret;
    }

    if(!(ret == 0))
      goto __CPROVER_DUMP_L3;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    if(!(ret >= 0))
    {
      return_value___errno_location$2=__errno_location();
      if(!(*return_value___errno_location$2 == 4))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Unexpected error waiting for or reading  events in control socket!\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Unexpected error waiting for or reading  events in control socket!\n");

        }

        return -1;
      }

    }

    return 0;
  }
}

// wait_for_data
// file request.c line 83
static signed int wait_for_data(signed int fd, signed int secs, signed int what_wait)
{
  signed int wait_status;
  if(!(CHILD_HALT == 0))
    return -1;

  else
  {
    do
    {
      wait_status=ci_wait_for_data(fd, secs, what_wait);
      if(!(wait_status >= 0))
        return -1;

      if(wait_status == 0 && !(CHILD_HALT == 0))
        return -1;

    }
    while(wait_status == 0);
    return wait_status;
  }
}

// wait_for_queue
// file proc_threads_queues.c line 100
signed int wait_for_queue(struct connections_queue *q)
{
  if(CI_DEBUG_LEVEL >= 7)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Waiting for a request....\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Waiting for a request....\n");

  }

  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&q->cond_mtx);
  if(!(return_value_pthread_mutex_lock$1 == 0))
    return -1;

  else
  {
    signed int return_value_pthread_cond_wait$2;
    return_value_pthread_cond_wait$2=pthread_cond_wait(&q->queue_cond, &q->cond_mtx);
    if(!(return_value_pthread_cond_wait$2 == 0))
    {
      pthread_mutex_unlock(&q->cond_mtx);
      return -1;
    }

    else
    {
      signed int return_value_pthread_mutex_unlock$3;
      return_value_pthread_mutex_unlock$3=pthread_mutex_unlock(&q->cond_mtx);
      if(!(return_value_pthread_mutex_unlock$3 == 0))
        return -1;

      else
        return 1;
    }
  }
}

// zlib_inflate
// file decode.c line 208
static signed int zlib_inflate(const char *buf, signed int len, char *unzipped_buf, signed int *unzipped_buf_len)
{
  signed int ret;
  signed int retriable;
  struct z_stream_s strm;
  strm.zalloc = alloc_a_buffer;
  strm.zfree = free_a_buffer;
  strm.opaque = NULL;
  strm.avail_in = (unsigned int)0;
  strm.next_in = ((unsigned char *)NULL);
  ret=inflateInit2_(&strm, 32 + 15, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
  retriable = 1;

zlib_inflate_retry:
  ;
  for( ; (_Bool)1; retriable = 0)
  {
    if(!(ret == 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error initializing  zlib (inflateInit2 return:%d)\n", ret);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error initializing  zlib (inflateInit2 return:%d)\n", ret);

      }

      return -1;
    }

    strm.next_in = (unsigned char *)buf;
    strm.avail_in = (unsigned int)len;
    strm.avail_out = (unsigned int)*unzipped_buf_len;
    strm.next_out = (unsigned char *)unzipped_buf;
    ret=inflate(&strm, 0);
    inflateEnd(&strm);
    if(!(ret == 2) && !(ret == -3))
    {
      if(ret == -4)
        break;

      goto __CPROVER_DUMP_L7;
    }

    if(retriable == 0)
      break;

    ret=inflateInit2_(&strm, -15, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
  }
  return -1;

__CPROVER_DUMP_L7:
  ;
  if((unsigned int)*unzipped_buf_len == strm.avail_out)
  {
    if(ret == 1)
      goto __CPROVER_DUMP_L8;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L8:
    ;
    *unzipped_buf_len = (signed int)((unsigned int)*unzipped_buf_len - strm.avail_out);
    return 1;
  }
}

