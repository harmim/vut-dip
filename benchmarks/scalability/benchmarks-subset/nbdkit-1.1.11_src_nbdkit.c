// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$4;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$2;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$9;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$14;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$1;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$10;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$15;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$3;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$8;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$12;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$5;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$7;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$6;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$0;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$13;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-connection
// file internal.h line 68
struct connection;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-nbdkit_plugin
// file ../include/nbdkit-plugin.h line 49
struct nbdkit_plugin;

// tag-old_handshake
// file protocol.h line 40
struct old_handshake;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-reply
// file protocol.h line 72
struct reply;

// tag-request
// file protocol.h line 63
struct request;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-thread_data
// file sockets.c line 201
struct thread_data;

// tag-tls
// file tls.c line 54
struct tls;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __bswap_64
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 109
static inline unsigned long int __bswap_64(unsigned long int __bsx);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// _handle_request
// file connections.c line 327
static signed int _handle_request(struct connection *conn, unsigned int cmd, unsigned int flags, unsigned long int offset, unsigned int count, void *buf, unsigned int *error);
// _handle_single_connection
// file connections.c line 61
static signed int _handle_single_connection(signed int sockin, signed int sockout);
// _negotiate_handshake
// file connections.c line 150
static signed int _negotiate_handshake(struct connection *conn);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous$13, unsigned int *);
// accept_connection
// file sockets.c line 226
static void accept_connection(signed int listen_sock);
// accept_incoming_connections
// file internal.h line 111
extern void accept_incoming_connections(signed int *socks, unsigned long int nr_socks);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$13, unsigned int);
// bind_tcpip_socket
// file internal.h line 110
extern signed int * bind_tcpip_socket(unsigned long int *nr_socks);
// bind_unix_socket
// file internal.h line 109
extern signed int * bind_unix_socket(unsigned long int *nr_socks);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// change_user
// file main.c line 468
static void change_user(void);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// cleanup_free
// file cleanup.c line 45
extern void cleanup_free(void *ptr);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// display_version
// file main.c line 122
static void display_version(void);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// dump_config
// file main.c line 128
static void dump_config(void);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fork_into_background
// file main.c line 530
static void fork_into_background(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_connection
// file connections.c line 128
static void free_connection(struct connection *conn);
// free_listening_sockets
// file internal.h line 112
extern void free_listening_sockets(signed int *socks, unsigned long int nr_socks);
// free_tls
// file tls.c line 64
static void free_tls(void *tlsv);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_current_dir_name
// file /usr/include/unistd.h line 517
extern char * get_current_dir_name(void);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getgrnam
// file /usr/include/grp.h line 110
extern struct group * getgrnam(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// handle_quit
// file main.c line 443
static void handle_quit(signed int sig);
// handle_request
// file connections.c line 389
static signed int handle_request(struct connection *conn, unsigned int cmd, unsigned int flags, unsigned long int offset, unsigned int count, void *buf, unsigned int *error);
// handle_single_connection
// file connections.c line 98
extern signed int handle_single_connection(signed int sockin, signed int sockout);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// make_random_fifo
// file main.c line 323
static char * make_random_fifo(void);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdtemp
// file /usr/include/stdlib.h line 662
extern char * mkdtemp(char *);
// nbdkit_absolute_path
// file ../include/nbdkit-plugin.h line 91
extern char * nbdkit_absolute_path(const char *path);
// nbdkit_debug
// file ../include/nbdkit-plugin.h line 87
extern void nbdkit_debug(const char *fs, ...);
// nbdkit_error
// file ../include/nbdkit-plugin.h line 84
extern void nbdkit_error(const char *fs, ...);
// nbdkit_parse_size
// file utils.c line 86
extern signed long int nbdkit_parse_size(const char *str);
// nbdkit_vdebug
// file errors.c line 65
extern void nbdkit_vdebug(const char *fs, void **args);
// nbdkit_verror
// file errors.c line 104
extern void nbdkit_verror(const char *fs, void **args);
// negotiate_handshake
// file connections.c line 222
static signed int negotiate_handshake(struct connection *conn);
// new_connection
// file connections.c line 110
static struct connection * new_connection(signed int sockin, signed int sockout);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// open_plugin_so
// file main.c line 354
static void open_plugin_so(const char *name);
// open_plugin_so::1::plugin_init$object
// 
struct nbdkit_plugin * plugin_init$object(void);
// parsegroup
// file main.c line 673
static unsigned int parsegroup(const char *id);
// parseuser
// file main.c line 645
static unsigned int parseuser(const char *id);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// plugin_can_flush
// file internal.h line 100
extern signed int plugin_can_flush(struct connection *conn);
// plugin_can_trim
// file internal.h line 102
extern signed int plugin_can_trim(struct connection *conn);
// plugin_can_write
// file internal.h line 99
extern signed int plugin_can_write(struct connection *conn);
// plugin_cleanup
// file internal.h line 86
extern void plugin_cleanup(void);
// plugin_close
// file internal.h line 97
extern void plugin_close(struct connection *conn);
// plugin_config
// file internal.h line 90
extern void plugin_config(const char *key, const char *value);
// plugin_config_complete
// file internal.h line 91
extern void plugin_config_complete(void);
// plugin_flush
// file internal.h line 105
extern signed int plugin_flush(struct connection *conn);
// plugin_get_size
// file internal.h line 98
extern signed long int plugin_get_size(struct connection *conn);
// plugin_is_rotational
// file internal.h line 101
extern signed int plugin_is_rotational(struct connection *conn);
// plugin_lock_connection
// file internal.h line 92
extern void plugin_lock_connection(void);
// plugin_lock_request
// file internal.h line 94
extern void plugin_lock_request(struct connection *conn);
// plugin_name
// file internal.h line 87
extern const char * plugin_name(void);
// plugin_open
// file internal.h line 96
extern signed int plugin_open(struct connection *conn, signed int readonly);
// plugin_pread
// file internal.h line 103
extern signed int plugin_pread(struct connection *conn, void *buf, unsigned int count, unsigned long int offset);
// plugin_pwrite
// file internal.h line 104
extern signed int plugin_pwrite(struct connection *conn, void *buf, unsigned int count, unsigned long int offset);
// plugin_register
// file internal.h line 85
extern void plugin_register(const char *_filename, void *_dl, struct nbdkit_plugin * (*plugin_init)(void));
// plugin_register::plugin_init$object
// 
struct nbdkit_plugin * plugin_init$object(void);
// plugin_trim
// file internal.h line 106
extern signed int plugin_trim(struct connection *conn, unsigned int count, unsigned long int offset);
// plugin_unlock_connection
// file internal.h line 93
extern void plugin_unlock_connection(void);
// plugin_unlock_request
// file internal.h line 95
extern void plugin_unlock_request(struct connection *conn);
// plugin_usage
// file internal.h line 88
extern void plugin_usage(void);
// plugin_version
// file internal.h line 89
extern void plugin_version(void);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// prologue
// file errors.c line 46
static void prologue(const char *type);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_getspecific
// file /usr/include/pthread.h line 1121
extern void * pthread_getspecific(unsigned int);
// pthread_key_create
// file /usr/include/pthread.h line 1113
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$6 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$6 *, const union anonymous$7 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$6 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$6 *);
// pthread_setspecific
// file /usr/include/pthread.h line 1124
extern signed int pthread_setspecific(unsigned int, const void *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recv_request_send_reply
// file connections.c line 422
static signed int recv_request_send_reply(struct connection *conn);
// rmdir
// file /usr/include/unistd.h line 835
extern signed int rmdir(const char *);
// run_command
// file main.c line 562
static void run_command(void);
// set_up_signals
// file main.c line 449
static void set_up_signals(void);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setgroups
// file /usr/include/grp.h line 179
extern signed int setgroups(unsigned long int, const unsigned int *);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// skip_over_write_buffer
// file connections.c line 404
static void skip_over_write_buffer(signed int sock, unsigned long int count);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_serving
// file main.c line 397
static void start_serving(void);
// start_thread
// file sockets.c line 209
static void * start_thread(void *datav);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// tls_get_instance_num
// file internal.h line 121
extern unsigned long int tls_get_instance_num(void);
// tls_get_name
// file internal.h line 120
extern const char * tls_get_name(void);
// tls_init
// file internal.h line 115
extern void tls_init(void);
// tls_new_server_thread
// file internal.h line 116
extern void tls_new_server_thread(void);
// tls_set_instance_num
// file internal.h line 118
extern void tls_set_instance_num(unsigned long int instance_num);
// tls_set_name
// file internal.h line 117
extern void tls_set_name(const char *name);
// tls_set_sockaddr
// file internal.h line 119
extern void tls_set_sockaddr(struct sockaddr *addr, unsigned int addrlen);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file main.c line 111
static void usage(void);
// valid_range
// file connections.c line 234
static signed int valid_range(struct connection *conn, unsigned long int offset, unsigned int count);
// validate_request
// file connections.c line 242
static signed int validate_request(struct connection *conn, unsigned int cmd, unsigned int flags, unsigned long int offset, unsigned int count, unsigned int *error);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_pidfile
// file main.c line 500
static void write_pidfile(void);
// xread
// file internal.h line 125
extern signed int xread(signed int sock, void *vbuf, unsigned long int len);
// xwrite
// file internal.h line 126
extern signed int xwrite(signed int sock, const void *vbuf, unsigned long int len);

struct anonymous$4
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$2
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$9
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$14
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$1
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$15
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$3
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$5
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$14 _kill;
  // _timer
  struct anonymous$15 _timer;
  // _rt
  struct anonymous _rt;
  // _sigchld
  struct anonymous$1 _sigchld;
  // _sigfault
  struct anonymous$2 _sigfault;
  // _sigpoll
  struct anonymous$3 _sigpoll;
  // _sigsys
  struct anonymous$4 _sigsys;
};

struct anonymous$10
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$5 _sifields;
};

union anonymous$8
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$10 *, void *);
};

union anonymous$12
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$7
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$6
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$0
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$13
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct connection
{
  // sockin
  signed int sockin;
  // sockout
  signed int sockout;
  // request_lock
  union anonymous$6 request_lock;
  // handle
  void *handle;
  // exportsize
  unsigned long int exportsize;
  // readonly
  signed int readonly;
  // can_flush
  signed int can_flush;
  // is_rotational
  signed int is_rotational;
  // can_trim
  signed int can_trim;
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct in6_addr
{
  // __in6_u
  union anonymous$12 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct nbdkit_plugin
{
  // _struct_size
  unsigned long int _struct_size;
  // _api_version
  signed int _api_version;
  // _thread_model
  signed int _thread_model;
  // name
  const char *name;
  // longname
  const char *longname;
  // version
  const char *version;
  // description
  const char *description;
  // load
  void (*load)(void);
  // unload
  void (*unload)(void);
  // config
  signed int (*config)(const char *, const char *);
  // config_complete
  signed int (*config_complete)(void);
  // config_help
  const char *config_help;
  // open
  void * (*open)(signed int);
  // close
  void (*close)(void *);
  // get_size
  signed long int (*get_size)(void *);
  // can_write
  signed int (*can_write)(void *);
  // can_flush
  signed int (*can_flush)(void *);
  // is_rotational
  signed int (*is_rotational)(void *);
  // can_trim
  signed int (*can_trim)(void *);
  // pread
  signed int (*pread)(void *, void *, unsigned int, unsigned long int);
  // pwrite
  signed int (*pwrite)(void *, const void *, unsigned int, unsigned long int);
  // flush
  signed int (*flush)(void *);
  // trim
  signed int (*trim)(void *, unsigned int, unsigned long int);
};

struct old_handshake
{
  // nbdmagic
  char nbdmagic[8l];
  // version
  unsigned long int version;
  // exportsize
  unsigned long int exportsize;
  // gflags
  unsigned short int gflags;
  // eflags
  unsigned short int eflags;
  // zeroes
  char zeroes[124l];
} __attribute__ ((__packed__));

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct reply
{
  // magic
  unsigned int magic;
  // error
  unsigned int error;
  // handle
  unsigned long int handle;
} __attribute__ ((__packed__));

struct request
{
  // magic
  unsigned int magic;
  // type
  unsigned int type;
  // handle
  unsigned long int handle;
  // offset
  unsigned long int offset;
  // count
  unsigned int count;
} __attribute__ ((__packed__));

struct sigaction
{
  // __sigaction_handler
  union anonymous$8 __sigaction_handler;
  // sa_mask
  struct anonymous$9 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct thread_data
{
  // sock
  signed int sock;
  // instance_num
  unsigned long int instance_num;
  // addr
  struct sockaddr addr;
  // addrlen
  unsigned int addrlen;
};

struct tls
{
  // name
  const char *name;
  // instance_num
  unsigned long int instance_num;
  // addr
  struct sockaddr *addr;
  // addrlen
  unsigned int addrlen;
};


// all_requests_lock
// file plugins.c line 49
static union anonymous$6 all_requests_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// connection_lock
// file plugins.c line 48
static union anonymous$6 connection_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// dl
// file plugins.c line 55
static void *dl;
// filename
// file plugins.c line 54
static char *filename;
// foreground
// file main.c line 68
signed int foreground;
// group
// file main.c line 76
const char *group;
// ipaddr
// file main.c line 69
const char *ipaddr;
// listen_stdin
// file main.c line 70
signed int listen_stdin;
// long_options
// file main.c line 87
static struct option long_options[20l] = { { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=128 }, 
    { .name="dump-config", .has_arg=0, .flag=(signed int *)(void *)0, .val=0 }, 
    { .name="foreground", .has_arg=0, .flag=(signed int *)(void *)0, .val=102 }, 
    { .name="no-fork", .has_arg=0, .flag=(signed int *)(void *)0, .val=102 }, 
    { .name="group", .has_arg=1, .flag=(signed int *)(void *)0, .val=103 }, 
    { .name="ip-addr", .has_arg=1, .flag=(signed int *)(void *)0, .val=105 }, 
    { .name="ipaddr", .has_arg=1, .flag=(signed int *)(void *)0, .val=105 }, 
    { .name="pid-file", .has_arg=1, .flag=(signed int *)(void *)0, .val=80 }, 
    { .name="pidfile", .has_arg=1, .flag=(signed int *)(void *)0, .val=80 }, 
    { .name="port", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 }, 
    { .name="read-only", .has_arg=0, .flag=(signed int *)(void *)0, .val=114 }, 
    { .name="readonly", .has_arg=0, .flag=(signed int *)(void *)0, .val=114 }, 
    { .name="run", .has_arg=1, .flag=(signed int *)(void *)0, .val=0 }, 
    { .name="single", .has_arg=0, .flag=(signed int *)(void *)0, .val=115 }, 
    { .name="stdin", .has_arg=0, .flag=(signed int *)(void *)0, .val=115 }, 
    { .name="unix", .has_arg=1, .flag=(signed int *)(void *)0, .val=85 }, 
    { .name="user", .has_arg=1, .flag=(signed int *)(void *)0, .val=117 }, 
    { .name="verbose", .has_arg=0, .flag=(signed int *)(void *)0, .val=118 }, 
    { .name="version", .has_arg=0, .flag=(signed int *)(void *)0, .val=86 }, 
    { .name=(const char *)(void *)0, .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// pidfile
// file main.c line 71
char *pidfile;
// plugin
// file plugins.c line 56
static struct nbdkit_plugin plugin;
// port
// file main.c line 72
const char *port;
// program_invocation_short_name
// file /usr/include/errno.h line 54
extern char *program_invocation_short_name;
// quit
// file main.c line 79
volatile signed int quit;
// random_fifo
// file main.c line 82
static char *random_fifo = (char *)(void *)0;
// random_fifo_dir
// file main.c line 81
static char *random_fifo_dir = (char *)(void *)0;
// readonly
// file main.c line 73
signed int readonly;
// run
// file main.c line 74
char *run;
// short_options
// file main.c line 86
static const char *short_options = "fg:i:p:P:rsu:U:vV";
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// tls_key
// file tls.c line 61
static unsigned int tls_key;
// unixsocket
// file main.c line 75
char *unixsocket;
// user
// file main.c line 76
const char *user;
// verbose
// file main.c line 77
signed int verbose;

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32$1;
  return_value___builtin_bswap32$1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32$1;
}

// __bswap_64
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 109
static inline unsigned long int __bswap_64(unsigned long int __bsx)
{
  signed long long int return_value___builtin_bswap64$1;
  return_value___builtin_bswap64$1=__builtin_bswap64((signed long long int)__bsx);
  return (unsigned long int)return_value___builtin_bswap64$1;
}

// _handle_request
// file connections.c line 327
static signed int _handle_request(struct connection *conn, unsigned int cmd, unsigned int flags, unsigned long int offset, unsigned int count, void *buf, unsigned int *error)
{
  _Bool flush_after_command;
  signed int r;
  flush_after_command = (flags & (unsigned int)(1 << 16)) != (unsigned int)0;
  _Bool tmp_if_expr$1;
  if(conn->can_flush == 0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = conn->readonly != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    flush_after_command = (_Bool)0;

  signed int tmp_if_expr$4;
  signed int *return_value___errno_location$3;
  signed int tmp_if_expr$7;
  signed int *return_value___errno_location$6;
  signed int tmp_if_expr$10;
  signed int *return_value___errno_location$9;
  signed int tmp_if_expr$13;
  signed int *return_value___errno_location$12;
  switch(cmd)
  {
    case (unsigned int)0:
    {
      r=plugin_pread(conn, buf, count, offset);
      if(r == -1)
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        if(!(*return_value___errno_location$2 == 0))
        {
          return_value___errno_location$3=__errno_location();
          tmp_if_expr$4 = *return_value___errno_location$3;
        }

        else
          tmp_if_expr$4 = 5;
        *error = (unsigned int)tmp_if_expr$4;
        return 0;
      }

      break;
    }
    case (unsigned int)1:
    {
      r=plugin_pwrite(conn, buf, count, offset);
      if(r == -1)
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        if(!(*return_value___errno_location$5 == 0))
        {
          return_value___errno_location$6=__errno_location();
          tmp_if_expr$7 = *return_value___errno_location$6;
        }

        else
          tmp_if_expr$7 = 5;
        *error = (unsigned int)tmp_if_expr$7;
        return 0;
      }

      break;
    }
    case (unsigned int)3:
    {
      r=plugin_flush(conn);
      if(r == -1)
      {
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        if(!(*return_value___errno_location$8 == 0))
        {
          return_value___errno_location$9=__errno_location();
          tmp_if_expr$10 = *return_value___errno_location$9;
        }

        else
          tmp_if_expr$10 = 5;
        *error = (unsigned int)tmp_if_expr$10;
        return 0;
      }

      break;
    }
    case (unsigned int)4:
    {
      r=plugin_trim(conn, count, offset);
      if(r == -1)
      {
        signed int *return_value___errno_location$11;
        return_value___errno_location$11=__errno_location();
        if(!(*return_value___errno_location$11 == 0))
        {
          return_value___errno_location$12=__errno_location();
          tmp_if_expr$13 = *return_value___errno_location$12;
        }

        else
          tmp_if_expr$13 = 5;
        *error = (unsigned int)tmp_if_expr$13;
        return 0;
      }

      break;
    }
    default:
      abort();
  }
  signed int tmp_if_expr$16;
  signed int *return_value___errno_location$15;
  if(!(flush_after_command == (_Bool)0))
  {
    r=plugin_flush(conn);
    if(r == -1)
    {
      signed int *return_value___errno_location$14;
      return_value___errno_location$14=__errno_location();
      if(!(*return_value___errno_location$14 == 0))
      {
        return_value___errno_location$15=__errno_location();
        tmp_if_expr$16 = *return_value___errno_location$15;
      }

      else
        tmp_if_expr$16 = 5;
      *error = (unsigned int)tmp_if_expr$16;
      return 0;
    }

  }

  return 0;
}

// _handle_single_connection
// file connections.c line 61
static signed int _handle_single_connection(signed int sockin, signed int sockout)
{
  signed int r;
  struct connection *conn;
  conn=new_connection(sockin, sockout);
  signed int return_value_plugin_open$1;
  const char *return_value_plugin_name$2;
  signed int return_value_negotiate_handshake$3;
  if(!(conn == ((struct connection *)NULL)))
  {
    return_value_plugin_open$1=plugin_open(conn, readonly);
    if(return_value_plugin_open$1 == -1)
      goto err;

    return_value_plugin_name$2=plugin_name();
    tls_set_name(return_value_plugin_name$2);
    return_value_negotiate_handshake$3=negotiate_handshake(conn);
    if(return_value_negotiate_handshake$3 == -1)
      goto err;

    while(quit == 0)
    {
      r=recv_request_send_reply(conn);
      if(r == -1)
        goto err;

      if(r == 0)
        break;

    }
    free_connection(conn);
    return 0;
  }

  else
  {

  err:
    ;
    free_connection(conn);
    return -1;
  }
}

// _negotiate_handshake
// file connections.c line 150
static signed int _negotiate_handshake(struct connection *conn)
{
  struct old_handshake handshake;
  signed long int r;
  unsigned long int exportsize;
  unsigned short int gflags;
  unsigned short int eflags;
  signed int fl;
  r=plugin_get_size(conn);
  unsigned short int tmp_statement_expression$1;
  unsigned short int tmp_statement_expression$2;
  if(r == -1l)
    return -1;

  else
    if(!(r >= 0l))
    {
      nbdkit_error(".get_size function returned invalid value (%li)", r);
      return -1;
    }

    else
    {
      exportsize = (unsigned long int)r;
      conn->exportsize = exportsize;
      gflags = (unsigned short int)0;
      eflags = (unsigned short int)1;
      fl=plugin_can_write(conn);
      if(fl == -1)
        return -1;

      else
      {
        if(fl == 0 || !(readonly == 0))
        {
          eflags = eflags | (unsigned short int)2;
          conn->readonly = 1;
        }

        fl=plugin_can_flush(conn);
        if(fl == -1)
          return -1;

        else
        {
          if(!(fl == 0))
          {
            eflags = eflags | (unsigned short int)(4 | 8);
            conn->can_flush = 1;
          }

          fl=plugin_is_rotational(conn);
          if(fl == -1)
            return -1;

          else
          {
            if(!(fl == 0))
            {
              eflags = eflags | (unsigned short int)16;
              conn->is_rotational = 1;
            }

            fl=plugin_can_trim(conn);
            if(fl == -1)
              return -1;

            else
            {
              if(!(fl == 0))
              {
                eflags = eflags | (unsigned short int)32;
                conn->can_trim = 1;
              }

              nbdkit_debug("flags: global 0x%x export 0x%x", gflags, eflags);
              memset((void *)&handshake, 0, sizeof(struct old_handshake) /*152ul*/ );
              memcpy((void *)handshake.nbdmagic, (const void *)"NBDMAGIC", (unsigned long int)8);
              handshake.version=__bswap_64(0x420281861253UL);
              handshake.exportsize=__bswap_64(exportsize);
              unsigned short int _negotiate_handshake$$1$$6$$__v;
              unsigned short int _negotiate_handshake$$1$$6$$__x = (unsigned short int)gflags;
              asm("rorw $8, %w0" : "=r"(_negotiate_handshake$$1$$6$$__v) : "0"(_negotiate_handshake$$1$$6$$__x) : "cc");
              tmp_statement_expression$1 = _negotiate_handshake$$1$$6$$__v;
              handshake.gflags = tmp_statement_expression$1;
              unsigned short int __v;
              unsigned short int __x = (unsigned short int)eflags;
              asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
              tmp_statement_expression$2 = __v;
              handshake.eflags = tmp_statement_expression$2;
              signed int return_value_xwrite$3;
              return_value_xwrite$3=xwrite(conn->sockout, (const void *)&handshake, sizeof(struct old_handshake) /*152ul*/ );
              if(return_value_xwrite$3 == -1)
              {
                nbdkit_error("write: %m");
                return -1;
              }

              else
                return 0;
            }
          }
        }
      }
    }
}

// accept_connection
// file sockets.c line 226
static void accept_connection(signed int listen_sock)
{
  signed int err;
  union pthread_attr_t attrs;
  unsigned long int thread;
  struct thread_data thread_data;
  static unsigned long int instance_num = (unsigned long int)1;
  unsigned long int tmp_post$1 = instance_num;
  instance_num = instance_num + 1ul;
  thread_data.instance_num = tmp_post$1;
  thread_data.addrlen = (unsigned int)sizeof(struct sockaddr) /*16ul*/ ;
  signed int *return_value___errno_location$2;
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$3;
  do
  {

  again:
    ;
    thread_data.sock=accept(listen_sock, &thread_data.addr, &thread_data.addrlen);
    if(!(thread_data.sock == -1))
      goto __CPROVER_DUMP_L4;

    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 4)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value___errno_location$3=__errno_location();
      tmp_if_expr$4 = *return_value___errno_location$3 == 11 ? (_Bool)1 : (_Bool)0;
    }
  }
  while(tmp_if_expr$4);
  perror("accept");
  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L4:
  ;
  pthread_attr_init(&attrs);
  pthread_attr_setdetachstate(&attrs, 1);
  err=pthread_create(&thread, &attrs, start_thread, (void *)&thread_data);
  pthread_attr_destroy(&attrs);
  if(!(err == 0))
  {
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(err);
    fprintf(stderr, "%s: pthread_create: %s\n", program_invocation_short_name, return_value_strerror$5);
    close(thread_data.sock);
    goto __CPROVER_DUMP_L6;
  }


__CPROVER_DUMP_L6:
  ;
}

// accept_incoming_connections
// file internal.h line 111
extern void accept_incoming_connections(signed int *socks, unsigned long int nr_socks)
{
  const signed long int accept_incoming_connections$array_size0 = (signed long int)nr_socks;
  struct pollfd fds[accept_incoming_connections$array_size0];
  unsigned long int i;
  signed int r;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  while(quit == 0)
  {
    i = (unsigned long int)0;
    for( ; !(i >= nr_socks); i = i + 1ul)
    {
      fds[(signed long int)i].fd = socks[(signed long int)i];
      fds[(signed long int)i].events = (signed short int)0x001;
      fds[(signed long int)i].revents = (signed short int)0;
    }
    r=poll(fds, nr_socks, -1);
    if(r == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 4)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = *return_value___errno_location$2 == 11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        continue;

      perror("poll");
      exit(1);
    }

    i = (unsigned long int)0;
    for( ; !(i >= nr_socks); i = i + 1ul)
      if(!((0x001 & (signed int)fds[(signed long int)i].revents) == 0))
        accept_connection(fds[(signed long int)i].fd);

  }
}

// bind_tcpip_socket
// file internal.h line 110
extern signed int * bind_tcpip_socket(unsigned long int *nr_socks)
{
  struct addrinfo *ai = (struct addrinfo *)(void *)0;
  struct addrinfo hints;
  struct addrinfo *a;
  signed int err;
  signed int opt;
  signed int *socks = (signed int *)(void *)0;
  _Bool addr_in_use;
  if(port == ((const char *)NULL))
    port = "10809";

  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_flags = 0x0001 | 0x0020;
  hints.ai_socktype = 1;
  err=getaddrinfo(ipaddr, port, &hints, &ai);
  if(!(err == 0))
  {
    const char *return_value_gai_strerror$1;
    return_value_gai_strerror$1=gai_strerror(err);
    fprintf(stderr, "%s: getaddrinfo: %s: %s: %s", program_invocation_short_name, ipaddr != ((const char *)NULL) ? ipaddr : "<any>", port, return_value_gai_strerror$1);
    exit(1);
  }

  *nr_socks = (unsigned long int)0;
  a = ai;
  for( ; !(a == ((struct addrinfo *)NULL)); a = a->ai_next)
  {
    signed int sock;
    sock=socket(a->ai_family, a->ai_socktype, a->ai_protocol);
    if(sock == -1)
    {
      perror("socket");
      exit(1);
    }

    opt = 1;
    signed int return_value_setsockopt$2;
    return_value_setsockopt$2=setsockopt(sock, 1, 2, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(return_value_setsockopt$2 == -1)
      perror("setsockopt: SO_REUSEADDR");

    if(a->ai_family == 10)
    {
      signed int return_value_setsockopt$3;
      return_value_setsockopt$3=setsockopt(sock, 41, 26, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(return_value_setsockopt$3 == -1)
        perror("setsockopt: IPv6 only");

    }

    signed int return_value_bind$5;
    return_value_bind$5=bind(sock, a->ai_addr, a->ai_addrlen);
    if(return_value_bind$5 == -1)
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      if(*return_value___errno_location$4 == 98)
      {
        addr_in_use = (_Bool)1;
        close(sock);
        goto __CPROVER_DUMP_L12;
      }

      perror("bind");
      exit(1);
    }

    signed int return_value_listen$6;
    return_value_listen$6=listen(sock, 128);
    if(return_value_listen$6 == -1)
    {
      perror("listen");
      exit(1);
    }

    *nr_socks = *nr_socks + 1ul;
    void *return_value_realloc$7;
    return_value_realloc$7=realloc((void *)socks, sizeof(signed int) /*4ul*/  * *nr_socks);
    socks = (signed int *)return_value_realloc$7;
    if(socks == ((signed int *)NULL))
    {
      perror("realloc");
      exit(1);
    }

    socks[(signed long int)(*nr_socks - (unsigned long int)1)] = sock;

  __CPROVER_DUMP_L12:
    ;
  }
  freeaddrinfo(ai);
  if(*nr_socks == 0ul)
  {
    if(!(addr_in_use == (_Bool)0))
    {
      char *return_value_strerror$8;
      return_value_strerror$8=strerror(98);
      fprintf(stderr, "%s: unable to bind to any sockets: %s\n", program_invocation_short_name, return_value_strerror$8);
      exit(1);
    }

  }

  nbdkit_debug("bound to IP address %s:%s (%zu socket(s))", ipaddr != ((const char *)NULL) ? ipaddr : "<any>", port, *nr_socks);
  return socks;
}

// bind_unix_socket
// file internal.h line 109
extern signed int * bind_unix_socket(unsigned long int *nr_socks)
{
  unsigned long int len;
  signed int sock;
  struct sockaddr_un addr;
  signed int *ret;
  /* assertion unixsocket */
  assert(unixsocket != ((char *)NULL));
  /* assertion unixsocket[0] == '/' */
  assert((signed int)unixsocket[(signed long int)0] == 47);
  len=strlen(unixsocket);
  if(len >= 108ul)
  {
    fprintf(stderr, "%s: -U option: path too long (max is %d) bytes", program_invocation_short_name, 108 - 1);
    exit(1);
  }

  sock=socket(1, 1 | 524288, 0);
  if(sock == -1)
  {
    perror("socket");
    exit(1);
  }

  addr.sun_family = (unsigned short int)1;
  memcpy((void *)addr.sun_path, (const void *)unixsocket, len + (unsigned long int)1);
  signed int return_value_bind$1;
  return_value_bind$1=bind(sock, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
  if(return_value_bind$1 == -1)
  {
    perror(unixsocket);
    exit(1);
  }

  signed int return_value_listen$2;
  return_value_listen$2=listen(sock, 128);
  if(return_value_listen$2 == -1)
  {
    perror("listen");
    exit(1);
  }

  void *return_value_malloc$3;
  return_value_malloc$3=malloc(sizeof(signed int) /*4ul*/ );
  ret = (signed int *)return_value_malloc$3;
  if(ret == ((signed int *)NULL))
  {
    perror("malloc");
    exit(1);
  }

  ret[(signed long int)0] = sock;
  *nr_socks = (unsigned long int)1;
  nbdkit_debug("bound to unix socket %s", unixsocket);
  return ret;
}

// change_user
// file main.c line 468
static void change_user(void)
{
  if(!(group == ((const char *)NULL)))
  {
    unsigned int gid;
    gid=parsegroup(group);
    signed int return_value_setgid$1;
    return_value_setgid$1=setgid(gid);
    if(return_value_setgid$1 == -1)
    {
      perror("setgid");
      exit(1);
    }

    signed int return_value_setgroups$2;
    return_value_setgroups$2=setgroups((unsigned long int)1, &gid);
    if(return_value_setgroups$2 == -1)
    {
      perror("setgroups");
      exit(1);
    }

    nbdkit_debug("changed group to %s", group);
  }

  if(!(user == ((const char *)NULL)))
  {
    unsigned int uid;
    uid=parseuser(user);
    signed int return_value_setuid$3;
    return_value_setuid$3=setuid(uid);
    if(return_value_setuid$3 == -1)
    {
      perror("setuid");
      exit(1);
    }

    nbdkit_debug("changed user to %s", user);
  }

}

// cleanup_free
// file cleanup.c line 45
extern void cleanup_free(void *ptr)
{
  free(*((void **)ptr));
}

// display_version
// file main.c line 122
static void display_version(void)
{
  printf("%s %s\n", (const void *)"nbdkit", (const void *)"1.1.11");
}

// dump_config
// file main.c line 128
static void dump_config(void)
{
  printf("%s=%s\n", (const void *)"bindir", (const void *)"/usr/bin");
  printf("%s=%s\n", (const void *)"libdir", (const void *)"/usr/lib/x86_64-linux-gnu");
  printf("%s=%s\n", (const void *)"name", (const void *)"nbdkit");
  printf("%s=%s\n", (const void *)"plugindir", (const void *)"/usr/lib/x86_64-linux-gnu/nbdkit/plugins");
  printf("%s=%s\n", (const void *)"sbindir", (const void *)"/usr/sbin");
  printf("%s=%s\n", (const void *)"sysconfdir", (const void *)"/etc");
  printf("%s=%s\n", (const void *)"version", (const void *)"1.1.11");
}

// fork_into_background
// file main.c line 530
static void fork_into_background(void)
{
  signed int pid;
  if(foreground == 0)
  {
    pid=fork();
    if(pid == -1)
    {
      perror("fork");
      exit(1);
    }

    if(pid >= 1)
      exit(0);

    chdir("/");
    close(0);
    close(1);
    open("/dev/null", 00);
    open("/dev/null", 01);
    if(verbose == 0)
      dup2(1, 2);

    signed int return_value_getpid$1;
    return_value_getpid$1=getpid();
    nbdkit_debug("forked into background (new pid = %d)", return_value_getpid$1);
  }

}

// free_connection
// file connections.c line 128
static void free_connection(struct connection *conn)
{
  if(!(conn == ((struct connection *)NULL)))
  {
    if(conn->sockin >= 0)
      close(conn->sockin);

    if(conn->sockout >= 0)
    {
      if(!(conn->sockin == conn->sockout))
        close(conn->sockout);

    }

    pthread_mutex_destroy(&conn->request_lock);
    if(!(conn->handle == NULL))
      plugin_close(conn);

    free((void *)conn);
  }

}

// free_listening_sockets
// file internal.h line 112
extern void free_listening_sockets(signed int *socks, unsigned long int nr_socks)
{
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= nr_socks); i = i + 1ul)
    close(socks[(signed long int)i]);
  free((void *)socks);
}

// free_tls
// file tls.c line 64
static void free_tls(void *tlsv)
{
  struct tls *tls = (struct tls *)tlsv;
  free((void *)tls->addr);
  free((void *)tls);
}

// handle_quit
// file main.c line 443
static void handle_quit(signed int sig)
{
  quit = 1;
}

// handle_request
// file connections.c line 389
static signed int handle_request(struct connection *conn, unsigned int cmd, unsigned int flags, unsigned long int offset, unsigned int count, void *buf, unsigned int *error)
{
  signed int r;
  plugin_lock_request(conn);
  r=_handle_request(conn, cmd, flags, offset, count, buf, error);
  plugin_unlock_request(conn);
  return r;
}

// handle_single_connection
// file connections.c line 98
extern signed int handle_single_connection(signed int sockin, signed int sockout)
{
  signed int r;
  plugin_lock_connection();
  r=_handle_single_connection(sockin, sockout);
  plugin_unlock_connection();
  return r;
}

// main
// file main.c line 140
signed int main(signed int argc, char **argv)
{
  signed int c;
  signed int option_index;
  signed int help = 0;
  signed int version = 0;
  tls_init();
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  signed int return_value_strcmp$3;
  do
  {
    c=getopt_long(argc, argv, short_options, long_options, &option_index);
    if(c == -1)
      break;

    switch(c)
    {
      case 0:
      {
        return_value_strcmp$2=strcmp(long_options[(signed long int)option_index].name, "dump-config");
        if(return_value_strcmp$2 == 0)
        {
          dump_config();
          exit(0);
        }

        else
        {
          return_value_strcmp$1=strcmp(long_options[(signed long int)option_index].name, "run");
          if(return_value_strcmp$1 == 0)
          {
            run = optarg;
            foreground = 1;
          }

          else
          {
            fprintf(stderr, "%s: unknown long option: %s (%d)\n", program_invocation_short_name, long_options[(signed long int)option_index].name, option_index);
            exit(1);
          }
        }
        break;
      }
      case 102:
      {
        foreground = 1;
        break;
      }
      case 103:
      {
        group = optarg;
        break;
      }
      case 105:
      {
        ipaddr = optarg;
        break;
      }
      case 80:
      {
        pidfile=nbdkit_absolute_path(optarg);
        if(pidfile == ((char *)NULL))
          exit(1);

        break;
      }
      case 112:
      {
        port = optarg;
        break;
      }
      case 114:
      {
        readonly = 1;
        break;
      }
      case 115:
      {
        listen_stdin = 1;
        break;
      }
      case 85:
      {
        return_value_strcmp$3=strcmp(optarg, "-");
        if(return_value_strcmp$3 == 0)
          unixsocket=make_random_fifo();

        else
          unixsocket=nbdkit_absolute_path(optarg);
        if(unixsocket == ((char *)NULL))
          exit(1);

        break;
      }
      case 117:
      {
        user = optarg;
        break;
      }
      case 118:
      {
        verbose = 1;
        break;
      }
      case 86:
      {
        version = 1;
        break;
      }
      case 128:
      {
        help = 1;
        break;
      }
      default:
      {
        usage();
        exit(1);
      }
    }
  }
  while((_Bool)1);
  if(optind >= argc)
  {
    if(!(help == 0))
    {
      usage();
      exit(0);
    }

    if(!(version == 0))
    {
      display_version();
      exit(0);
    }

    fprintf(stderr, "%s: no plugins given on the command line.\nRead nbdkit(1) for documentation.\n", program_invocation_short_name);
    exit(1);
  }

  while(!(optind >= argc))
  {
    const char *main$$1$$3$$filename = argv[(signed long int)optind];
    char *p;
    open_plugin_so(main$$1$$3$$filename);
    optind = optind + 1;
    while(!(optind >= argc))
    {
      p=strchr(argv[(signed long int)optind], 61);
      if(p == ((char *)NULL))
        break;

      if(help == 0 && version == 0)
      {
        *p = (char)0;
        plugin_config(argv[(signed long int)optind], p + (signed long int)1);
        optind = optind + 1;
      }

    }
    if(!(help == 0))
    {
      usage();
      printf("\n%s:\n\n", main$$1$$3$$filename);
      plugin_usage();
      exit(0);
    }

    if(!(version == 0))
    {
      display_version();
      plugin_version();
      exit(0);
    }

    plugin_config_complete();
    optind = optind + 1;
    if(!(optind >= argc))
    {
      fprintf(stderr, "%s: this server only supports a single plugin\n", program_invocation_short_name);
      exit(1);
    }

  }
  start_serving();
  plugin_cleanup();
  free((void *)unixsocket);
  free((void *)pidfile);
  if(!(random_fifo == ((char *)NULL)))
  {
    unlink(random_fifo);
    free((void *)random_fifo);
  }

  if(!(random_fifo_dir == ((char *)NULL)))
  {
    rmdir(random_fifo_dir);
    free((void *)random_fifo_dir);
  }

  exit(0);
}

// make_random_fifo
// file main.c line 323
static char * make_random_fifo(void)
{
  char template[18l] = { '/', 't', 'm', 'p', '/', 'n', 'b', 'd', 'k', 'i', 't', 'X', 'X', 'X', 'X', 'X', 'X', 0 };
  char *make_random_fifo$$1$$unixsocket;
  char *return_value_mkdtemp$1;
  return_value_mkdtemp$1=mkdtemp(template);
  if(return_value_mkdtemp$1 == ((char *)NULL))
  {
    perror("mkdtemp");
    return (char *)(void *)0;
  }

  else
  {
    random_fifo_dir=strdup(template);
    if(random_fifo_dir == ((char *)NULL))
    {
      perror("strdup");
      return (char *)(void *)0;
    }

    else
    {
      signed int return_value_asprintf$2;
      return_value_asprintf$2=asprintf(&random_fifo, "%s/socket", (const void *)template);
      if(return_value_asprintf$2 == -1)
      {
        perror("asprintf");
        return (char *)(void *)0;
      }

      else
      {
        make_random_fifo$$1$$unixsocket=strdup(random_fifo);
        if(make_random_fifo$$1$$unixsocket == ((char *)NULL))
        {
          perror("strdup");
          return (char *)(void *)0;
        }

        else
          return make_random_fifo$$1$$unixsocket;
      }
    }
  }
}

// nbdkit_absolute_path
// file ../include/nbdkit-plugin.h line 91
extern char * nbdkit_absolute_path(const char *path)
{
  char *pwd = (char *)(void *)0;
  char *ret;
  _Bool tmp_if_expr$1;
  if(path == ((const char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*path == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    nbdkit_error("cannot convert null or empty path to an absolute path");
    return (char *)(void *)0;
  }

  else
    if((signed int)*path == 47)
    {
      ret=strdup(path);
      if(ret == ((char *)NULL))
      {
        nbdkit_error("strdup: %m");
        return (char *)(void *)0;
      }

      return ret;
    }

    else
    {
      pwd=get_current_dir_name();
      if(pwd == ((char *)NULL))
      {
        nbdkit_error("get_current_dir_name: %m");
        return (char *)(void *)0;
      }

      else
      {
        signed int return_value_asprintf$2;
        return_value_asprintf$2=asprintf(&ret, "%s/%s", pwd, path);
        if(return_value_asprintf$2 == -1)
        {
          nbdkit_error("asprintf: %m");
          return (char *)(void *)0;
        }

        else
          return ret;
      }
    }
}

// nbdkit_debug
// file ../include/nbdkit-plugin.h line 87
extern void nbdkit_debug(const char *fs, ...)
{
  void **args;
  signed int err;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  err = *return_value___errno_location$1;
  if(!(verbose == 0))
  {
    prologue("debug");
    args = (void **)&fs;
    vfprintf(stderr, fs, args);
    args = ((void **)NULL);
    fprintf(stderr, "\n");
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = err;
  }

}

// nbdkit_error
// file ../include/nbdkit-plugin.h line 84
extern void nbdkit_error(const char *fs, ...)
{
  void **args;
  signed int err;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  err = *return_value___errno_location$1;
  prologue("error");
  args = (void **)&fs;
  vfprintf(stderr, fs, args);
  args = ((void **)NULL);
  fprintf(stderr, "\n");
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = err;
}

// nbdkit_parse_size
// file utils.c line 86
extern signed long int nbdkit_parse_size(const char *str)
{
  unsigned long int size;
  char t;
  signed int return_value_sscanf$1;
  return_value_sscanf$1=sscanf(str, "%lu%c", &size, &t);
  if(return_value_sscanf$1 == 2)
    switch((signed int)t)
    {
      case 98:

      case 66:
        return (signed long int)size;
      case 107:

      case 75:
        return (signed long int)size * (signed long int)1024;
      case 109:

      case 77:
        return (signed long int)size * (signed long int)1024 * (signed long int)1024;
      case 103:

      case 71:
        return (signed long int)size * (signed long int)1024 * (signed long int)1024 * (signed long int)1024;
      case 116:

      case 84:
        return (signed long int)size * (signed long int)1024 * (signed long int)1024 * (signed long int)1024 * (signed long int)1024;
      case 112:

      case 80:
        return (signed long int)size * (signed long int)1024 * (signed long int)1024 * (signed long int)1024 * (signed long int)1024 * (signed long int)1024;
      case 101:

      case 69:
        return (signed long int)size * (signed long int)1024 * (signed long int)1024 * (signed long int)1024 * (signed long int)1024 * (signed long int)1024 * (signed long int)1024;
      case 115:

      case 83:
        return (signed long int)size * (signed long int)512;
      default:
      {
        nbdkit_error("could not parse size: unknown specifier '%c'", t);
        return (signed long int)-1;
      }
    }

  else
  {
    signed int return_value_sscanf$2;
    return_value_sscanf$2=sscanf(str, "%lu", &size);
    if(return_value_sscanf$2 == 1)
      return (signed long int)size;

    else
    {
      nbdkit_error("could not parse size string (%s)", str);
      return (signed long int)-1;
    }
  }
}

// nbdkit_vdebug
// file errors.c line 65
extern void nbdkit_vdebug(const char *fs, void **args)
{
  signed int err;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  err = *return_value___errno_location$1;
  if(!(verbose == 0))
  {
    prologue("debug");
    vfprintf(stderr, fs, args);
    fprintf(stderr, "\n");
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = err;
  }

}

// nbdkit_verror
// file errors.c line 104
extern void nbdkit_verror(const char *fs, void **args)
{
  signed int err;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  err = *return_value___errno_location$1;
  prologue("error");
  vfprintf(stderr, fs, args);
  fprintf(stderr, "\n");
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = err;
}

// negotiate_handshake
// file connections.c line 222
static signed int negotiate_handshake(struct connection *conn)
{
  signed int r;
  plugin_lock_request(conn);
  r=_negotiate_handshake(conn);
  plugin_unlock_request(conn);
  return r;
}

// new_connection
// file connections.c line 110
static struct connection * new_connection(signed int sockin, signed int sockout)
{
  struct connection *conn;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct connection) /*80ul*/ );
  conn = (struct connection *)return_value_calloc$1;
  if(conn == ((struct connection *)NULL))
  {
    perror("malloc");
    return (struct connection *)(void *)0;
  }

  else
  {
    conn->sockin = sockin;
    conn->sockout = sockout;
    pthread_mutex_init(&conn->request_lock, (const union anonymous$7 *)(void *)0);
    return conn;
  }
}

// open_plugin_so
// file main.c line 354
static void open_plugin_so(const char *name)
{
  char *open_plugin_so$$1$$filename = (char *)name;
  signed int free_filename = 0;
  void *open_plugin_so$$1$$dl;
  struct nbdkit_plugin * (*plugin_init)(void);
  char *error;
  char *return_value_strchr$3;
  return_value_strchr$3=strchr(name, 46);
  char *return_value_strchr$2;
  if(return_value_strchr$3 == ((char *)NULL))
  {
    return_value_strchr$2=strchr(name, 47);
    if(return_value_strchr$2 == ((char *)NULL))
    {
      signed int return_value_asprintf$1;
      return_value_asprintf$1=asprintf(&open_plugin_so$$1$$filename, "%s/nbdkit-%s-plugin.so", (const void *)"/usr/lib/x86_64-linux-gnu/nbdkit/plugins", name);
      if(return_value_asprintf$1 == -1)
      {
        perror("asprintf");
        exit(1);
      }

      free_filename = 1;
    }

  }

  open_plugin_so$$1$$dl=dlopen(open_plugin_so$$1$$filename, 0x00002 | 0x00100);
  if(open_plugin_so$$1$$dl == NULL)
  {
    char *return_value_dlerror$4;
    return_value_dlerror$4=dlerror();
    fprintf(stderr, "%s: %s: %s\n", program_invocation_short_name, open_plugin_so$$1$$filename, return_value_dlerror$4);
    exit(1);
  }

  dlerror();
  *((void **)&plugin_init)=dlsym(open_plugin_so$$1$$dl, "plugin_init");
  error=dlerror();
  if(!(error == ((char *)NULL)))
  {
    fprintf(stderr, "%s: %s: %s\n", program_invocation_short_name, name, error);
    exit(1);
  }

  if(plugin_init == ((struct nbdkit_plugin * (*)(void))NULL))
  {
    fprintf(stderr, "%s: %s: invalid plugin_init\n", program_invocation_short_name, name);
    exit(1);
  }

  plugin_register(open_plugin_so$$1$$filename, open_plugin_so$$1$$dl, plugin_init);
  if(!(free_filename == 0))
    free((void *)open_plugin_so$$1$$filename);

}

// parsegroup
// file main.c line 673
static unsigned int parsegroup(const char *id)
{
  struct group *grp;
  signed int saved_errno;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  grp=getgrnam(id);
  char *return_value_strerror$4;
  if(grp == ((struct group *)NULL))
  {
    signed int val;
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    saved_errno = *return_value___errno_location$2;
    signed int return_value_sscanf$3;
    return_value_sscanf$3=sscanf(id, "%d", &val);
    if(return_value_sscanf$3 == 1)
      return (unsigned int)val;

    fprintf(stderr, "%s: -g option: %s is not a valid group name or gid", program_invocation_short_name, id);
    if(!(saved_errno == 0))
    {
      return_value_strerror$4=strerror(saved_errno);
      fprintf(stderr, " (getgrnam error: %s)", return_value_strerror$4);
    }

    fprintf(stderr, "\n");
    exit(1);
  }

  return grp->gr_gid;
}

// parseuser
// file main.c line 645
static unsigned int parseuser(const char *id)
{
  struct passwd *pwd;
  signed int saved_errno;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  pwd=getpwnam(id);
  char *return_value_strerror$4;
  if(pwd == ((struct passwd *)NULL))
  {
    signed int val;
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    saved_errno = *return_value___errno_location$2;
    signed int return_value_sscanf$3;
    return_value_sscanf$3=sscanf(id, "%d", &val);
    if(return_value_sscanf$3 == 1)
      return (unsigned int)val;

    fprintf(stderr, "%s: -u option: %s is not a valid user name or uid", program_invocation_short_name, id);
    if(!(saved_errno == 0))
    {
      return_value_strerror$4=strerror(saved_errno);
      fprintf(stderr, " (getpwnam error: %s)", return_value_strerror$4);
    }

    fprintf(stderr, "\n");
    exit(1);
  }

  return pwd->pw_uid;
}

// plugin_can_flush
// file internal.h line 100
extern signed int plugin_can_flush(struct connection *conn)
{
  /* assertion dl */
  assert(dl != NULL);
  /* assertion conn->handle */
  assert(conn->handle != NULL);
  nbdkit_debug("can_flush");
  signed int return_value;
  if(!(plugin.can_flush == ((signed int (*)(void *))NULL)))
  {
    return_value=plugin.can_flush(conn->handle);
    return return_value;
  }

  else
    return (signed int)(plugin.flush != (signed int (*)(void *))(void *)0);
}

// plugin_can_trim
// file internal.h line 102
extern signed int plugin_can_trim(struct connection *conn)
{
  /* assertion dl */
  assert(dl != NULL);
  /* assertion conn->handle */
  assert(conn->handle != NULL);
  nbdkit_debug("can_trim");
  signed int return_value;
  if(!(plugin.can_trim == ((signed int (*)(void *))NULL)))
  {
    return_value=plugin.can_trim(conn->handle);
    return return_value;
  }

  else
    return (signed int)(plugin.trim != (signed int (*)(void *, unsigned int, unsigned long int))(void *)0);
}

// plugin_can_write
// file internal.h line 99
extern signed int plugin_can_write(struct connection *conn)
{
  /* assertion dl */
  assert(dl != NULL);
  /* assertion conn->handle */
  assert(conn->handle != NULL);
  nbdkit_debug("can_write");
  signed int return_value;
  if(!(plugin.can_write == ((signed int (*)(void *))NULL)))
  {
    return_value=plugin.can_write(conn->handle);
    return return_value;
  }

  else
    return (signed int)(plugin.pwrite != (signed int (*)(void *, const void *, unsigned int, unsigned long int))(void *)0);
}

// plugin_cleanup
// file internal.h line 86
extern void plugin_cleanup(void)
{
  if(!(dl == NULL))
  {
    nbdkit_debug("%s: unload", filename);
    if(!(plugin.unload == ((void (*)(void))NULL)))
      plugin.unload();

    dlclose(dl);
    dl = (void *)0;
    free((void *)filename);
    filename = (char *)(void *)0;
  }

}

// plugin_close
// file internal.h line 97
extern void plugin_close(struct connection *conn)
{
  /* assertion dl */
  assert(dl != NULL);
  /* assertion conn->handle */
  assert(conn->handle != NULL);
  nbdkit_debug("close");
  if(!(plugin.close == ((void (*)(void *))NULL)))
    plugin.close(conn->handle);

  conn->handle = (void *)0;
}

// plugin_config
// file internal.h line 90
extern void plugin_config(const char *key, const char *value)
{
  /* assertion dl */
  assert(dl != NULL);
  nbdkit_debug("%s: config key=%s, value=%s", filename, key, value);
  if(plugin.config == ((signed int (*)(const char *, const char *))NULL))
  {
    fprintf(stderr, "%s: %s: this plugin does not need command line configuration\nTry using: %s --help %s\n", program_invocation_short_name, filename, program_invocation_short_name, filename);
    exit(1);
  }

  signed int return_value;
  return_value=plugin.config(key, value);
  if(return_value == -1)
    exit(1);

}

// plugin_config_complete
// file internal.h line 91
extern void plugin_config_complete(void)
{
  /* assertion dl */
  assert(dl != NULL);
  nbdkit_debug("%s: config_complete", filename);
  if(!(plugin.config_complete == ((signed int (*)(void))NULL)))
  {
    signed int return_value;
    return_value=plugin.config_complete();
    if(return_value == -1)
      exit(1);

  }

}

// plugin_flush
// file internal.h line 105
extern signed int plugin_flush(struct connection *conn)
{
  /* assertion dl */
  assert(dl != NULL);
  /* assertion conn->handle */
  assert(conn->handle != NULL);
  nbdkit_debug("flush");
  signed int return_value;
  if(!(plugin.flush == ((signed int (*)(void *))NULL)))
  {
    return_value=plugin.flush(conn->handle);
    return return_value;
  }

  else
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }
}

// plugin_get_size
// file internal.h line 98
extern signed long int plugin_get_size(struct connection *conn)
{
  /* assertion dl */
  assert(dl != NULL);
  /* assertion conn->handle */
  assert(conn->handle != NULL);
  /* assertion plugin.get_size != ((void *)0) */
  assert(plugin.get_size != (signed long int (*)(void *))(void *)0);
  nbdkit_debug("get_size");
  signed long int return_value;
  return_value=plugin.get_size(conn->handle);
  return return_value;
}

// plugin_is_rotational
// file internal.h line 101
extern signed int plugin_is_rotational(struct connection *conn)
{
  /* assertion dl */
  assert(dl != NULL);
  /* assertion conn->handle */
  assert(conn->handle != NULL);
  nbdkit_debug("is_rotational");
  signed int return_value;
  if(!(plugin.is_rotational == ((signed int (*)(void *))NULL)))
  {
    return_value=plugin.is_rotational(conn->handle);
    return return_value;
  }

  else
    return 0;
}

// plugin_lock_connection
// file internal.h line 92
extern void plugin_lock_connection(void)
{
  /* assertion dl */
  assert(dl != NULL);
  if(!(plugin._thread_model >= 1))
  {
    nbdkit_debug("%s: acquire connection lock", filename);
    pthread_mutex_lock(&connection_lock);
  }

}

// plugin_lock_request
// file internal.h line 94
extern void plugin_lock_request(struct connection *conn)
{
  /* assertion dl */
  assert(dl != NULL);
  if(!(plugin._thread_model >= 2))
  {
    nbdkit_debug("acquire global request lock");
    pthread_mutex_lock(&all_requests_lock);
  }

  if(!(plugin._thread_model >= 3))
  {
    nbdkit_debug("acquire per-connection request lock");
    pthread_mutex_lock(&conn->request_lock);
  }

}

// plugin_name
// file internal.h line 87
extern const char * plugin_name(void)
{
  /* assertion dl */
  assert(dl != NULL);
  return plugin.name;
}

// plugin_open
// file internal.h line 96
extern signed int plugin_open(struct connection *conn, signed int readonly)
{
  void *handle;
  /* assertion dl */
  assert(dl != NULL);
  /* assertion conn->handle == ((void *)0) */
  assert(conn->handle == (void *)0);
  /* assertion plugin.open != ((void *)0) */
  assert(plugin.open != (void * (*)(signed int))(void *)0);
  nbdkit_debug("%s: open readonly=%d", filename, readonly);
  handle=plugin.open(readonly);
  if(handle == NULL)
    return -1;

  else
  {
    conn->handle = handle;
    return 0;
  }
}

// plugin_pread
// file internal.h line 103
extern signed int plugin_pread(struct connection *conn, void *buf, unsigned int count, unsigned long int offset)
{
  /* assertion dl */
  assert(dl != NULL);
  /* assertion conn->handle */
  assert(conn->handle != NULL);
  /* assertion plugin.pread != ((void *)0) */
  assert(plugin.pread != (signed int (*)(void *, void *, unsigned int, unsigned long int))(void *)0);
  nbdkit_debug("pread count=%u offset=%lu", count, offset);
  signed int return_value;
  return_value=plugin.pread(conn->handle, buf, count, offset);
  return return_value;
}

// plugin_pwrite
// file internal.h line 104
extern signed int plugin_pwrite(struct connection *conn, void *buf, unsigned int count, unsigned long int offset)
{
  /* assertion dl */
  assert(dl != NULL);
  /* assertion conn->handle */
  assert(conn->handle != NULL);
  nbdkit_debug("pwrite count=%u offset=%lu", count, offset);
  signed int return_value;
  if(!(plugin.pwrite == ((signed int (*)(void *, const void *, unsigned int, unsigned long int))NULL)))
  {
    return_value=plugin.pwrite(conn->handle, buf, count, offset);
    return return_value;
  }

  else
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 30;
    return -1;
  }
}

// plugin_register
// file internal.h line 85
extern void plugin_register(const char *_filename, void *_dl, struct nbdkit_plugin * (*plugin_init)(void))
{
  struct nbdkit_plugin *_plugin;
  unsigned long int i;
  unsigned long int len;
  unsigned long int size;
  filename=strdup(_filename);
  if(filename == ((char *)NULL))
  {
    perror("strdup");
    exit(1);
  }

  dl = _dl;
  nbdkit_debug("registering %s", filename);
  _plugin=plugin_init();
  if(_plugin == ((struct nbdkit_plugin *)NULL))
  {
    fprintf(stderr, "%s: %s: plugin registration function failed\n", program_invocation_short_name, filename);
    exit(1);
  }

  if(!(_plugin->_api_version == 1))
  {
    fprintf(stderr, "%s: %s: plugin is incompatible with this version of nbdkit (_api_version = %d)\n", program_invocation_short_name, filename, _plugin->_api_version);
    exit(1);
  }

  size = sizeof(struct nbdkit_plugin) /*176ul*/ ;
  memset((void *)&plugin, 0, size);
  if(!(_plugin->_struct_size >= size))
    size = _plugin->_struct_size;

  memcpy((void *)&plugin, (const void *)_plugin, size);
  if(plugin.name == ((const char *)NULL))
  {
    fprintf(stderr, "%s: %s: plugin must have a .name field\n", program_invocation_short_name, filename);
    exit(1);
  }

  if(plugin.open == ((void * (*)(signed int))NULL))
  {
    fprintf(stderr, "%s: %s: plugin must have a .open callback\n", program_invocation_short_name, filename);
    exit(1);
  }

  if(plugin.get_size == ((signed long int (*)(void *))NULL))
  {
    fprintf(stderr, "%s: %s: plugin must have a .get_size callback\n", program_invocation_short_name, filename);
    exit(1);
  }

  if(plugin.pread == ((signed int (*)(void *, void *, unsigned int, unsigned long int))NULL))
  {
    fprintf(stderr, "%s: %s: plugin must have a .pread callback\n", program_invocation_short_name, filename);
    exit(1);
  }

  len=strlen(plugin.name);
  if(len == 0ul)
  {
    fprintf(stderr, "%s: %s: plugin.name field must not be empty\n", program_invocation_short_name, filename);
    exit(1);
  }

  i = (unsigned long int)0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  if(!(i >= len))
  {
    if((signed int)plugin.name[(signed long int)i] >= 48)
      tmp_if_expr$1 = (signed int)plugin.name[(signed long int)i] <= 57 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      if((signed int)plugin.name[(signed long int)i] >= 97)
        tmp_if_expr$2 = (signed int)plugin.name[(signed long int)i] <= 122 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      if((signed int)plugin.name[(signed long int)i] >= 65)
        tmp_if_expr$4 = (signed int)plugin.name[(signed long int)i] <= 90 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$5)
    {
      fprintf(stderr, "%s: %s: plugin.name ('%s') field must contain only ASCII alphanumeric characters\n", program_invocation_short_name, filename, plugin.name);
      exit(1);
    }

    i = i + 1ul;
  }

  nbdkit_debug("registered %s (name %s)", filename, plugin.name);
  nbdkit_debug("%s: load", filename);
  if(!(plugin.load == ((void (*)(void))NULL)))
    plugin.load();

}

// plugin_trim
// file internal.h line 106
extern signed int plugin_trim(struct connection *conn, unsigned int count, unsigned long int offset)
{
  /* assertion dl */
  assert(dl != NULL);
  /* assertion conn->handle */
  assert(conn->handle != NULL);
  nbdkit_debug("trim count=%u offset=%lu", count, offset);
  signed int return_value;
  if(!(plugin.trim == ((signed int (*)(void *, unsigned int, unsigned long int))NULL)))
  {
    return_value=plugin.trim(conn->handle, count, offset);
    return return_value;
  }

  else
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return -1;
  }
}

// plugin_unlock_connection
// file internal.h line 93
extern void plugin_unlock_connection(void)
{
  /* assertion dl */
  assert(dl != NULL);
  if(!(plugin._thread_model >= 1))
  {
    nbdkit_debug("%s: release connection lock", filename);
    pthread_mutex_unlock(&connection_lock);
  }

}

// plugin_unlock_request
// file internal.h line 95
extern void plugin_unlock_request(struct connection *conn)
{
  /* assertion dl */
  assert(dl != NULL);
  if(!(plugin._thread_model >= 3))
  {
    nbdkit_debug("release per-connection request lock");
    pthread_mutex_unlock(&conn->request_lock);
  }

  if(!(plugin._thread_model >= 2))
  {
    nbdkit_debug("release global request lock");
    pthread_mutex_unlock(&all_requests_lock);
  }

}

// plugin_usage
// file internal.h line 88
extern void plugin_usage(void)
{
  /* assertion dl */
  assert(dl != NULL);
  printf("%s", plugin.name);
  if(!(plugin.longname == ((const char *)NULL)))
    printf(" (%s)", plugin.longname);

  printf("\n");
  if(!(plugin.description == ((const char *)NULL)))
  {
    printf("\n");
    printf("%s\n", plugin.description);
  }

  if(!(plugin.config_help == ((const char *)NULL)))
  {
    printf("\n");
    printf("%s\n", plugin.config_help);
  }

}

// plugin_version
// file internal.h line 89
extern void plugin_version(void)
{
  /* assertion dl */
  assert(dl != NULL);
  printf("%s", plugin.name);
  if(!(plugin.version == ((const char *)NULL)))
    printf(" %s", plugin.version);

  printf("\n");
}

// prologue
// file errors.c line 46
static void prologue(const char *type)
{
  const char *name;
  name=tls_get_name();
  unsigned long int instance_num;
  instance_num=tls_get_instance_num();
  fprintf(stderr, "%s: ", program_invocation_short_name);
  if(!(name == ((const char *)NULL)))
  {
    fprintf(stderr, "%s", name);
    if(instance_num >= 1ul)
      fprintf(stderr, "[%zu]", instance_num);

    fprintf(stderr, ": ");
  }

  fprintf(stderr, "%s: ", type);
}

// recv_request_send_reply
// file connections.c line 422
static signed int recv_request_send_reply(struct connection *conn)
{
  signed int r;
  struct request request;
  struct reply reply;
  unsigned int magic;
  unsigned int cmd;
  unsigned int flags;
  unsigned int count;
  unsigned int error = (unsigned int)0;
  unsigned long int offset;
  char *buf = (char *)(void *)0;
  r=xread(conn->sockin, (void *)&request, sizeof(struct request) /*28ul*/ );
  if(r == -1)
  {
    nbdkit_error("read request: %m");
    return -1;
  }

  else
    if(r == 0)
    {
      nbdkit_debug("client closed input socket, closing connection");
      return 0;
    }

    else
    {
      magic=__bswap_32(request.magic);
      if(!(magic == 627086611u))
      {
        nbdkit_error("invalid request: 'magic' field is incorrect (0x%x)", magic);
        return -1;
      }

      else
      {
        cmd=__bswap_32(request.type);
        flags = cmd;
        cmd = cmd & (unsigned int)0xffff;
        offset=__bswap_64(request.offset);
        count=__bswap_32(request.count);
        if(cmd == 2u)
        {
          nbdkit_debug("client sent disconnect command, closing connection");
          return 0;
        }

        else
        {
          r=validate_request(conn, cmd, flags, offset, count, &error);
          if(r == -1)
            return -1;

          else
          {
            if(r == 0)
            {
              if(cmd == 1u)
                skip_over_write_buffer(conn->sockin, (unsigned long int)count);

            }

            else
            {
              if(cmd == 0u || cmd == 1u)
              {
                void *return_value_malloc$1;
                return_value_malloc$1=malloc((unsigned long int)count);
                buf = (char *)return_value_malloc$1;
                if(buf == ((char *)NULL))
                {
                  perror("malloc");
                  error = (unsigned int)12;
                  if(cmd == 1u)
                    skip_over_write_buffer(conn->sockin, (unsigned long int)count);

                  goto send_reply;
                }

              }

              if(cmd == 1u)
              {
                r=xread(conn->sockin, (void *)buf, (unsigned long int)count);
                if(r == -1)
                {
                  nbdkit_error("read data: %m");
                  return -1;
                }

                if(r == 0)
                {
                  nbdkit_debug("client closed input unexpectedly, closing connection");
                  return 0;
                }

              }

              r=handle_request(conn, cmd, flags, offset, count, (void *)buf, &error);
              if(r == -1)
                return -1;

            }

          send_reply:
            ;
            reply.magic=__bswap_32((unsigned int)0x67446698);
            reply.handle = request.handle;
            reply.error=__bswap_32(error);
            r=xwrite(conn->sockout, (const void *)&reply, sizeof(struct reply) /*16ul*/ );
            if(r == -1)
            {
              nbdkit_error("write reply: %m");
              return -1;
            }

            else
              if(cmd == 0u)
              {
                r=xwrite(conn->sockout, (const void *)buf, (unsigned long int)count);
                if(!(r == -1))
                  goto __CPROVER_DUMP_L15;

                nbdkit_error("write data: %m");
                return -1;
              }

              else
              {

              __CPROVER_DUMP_L15:
                ;
                return 1;
              }
          }
        }
      }
    }
}

// run_command
// file main.c line 562
static void run_command(void)
{
  char *url;
  char *cmd;
  signed int r;
  signed int pid;
  if(!(run == ((char *)NULL)))
  {
    char *return_value_strstr$1;
    return_value_strstr$1=strstr(run, "guestfish");
    if(!(return_value_strstr$1 == ((char *)NULL)))
    {
      if(!(port == ((const char *)NULL)))
        r=asprintf(&url, "nbd://localhost:%s", port);

      else
        if(!(unixsocket == ((char *)NULL)))
          r=asprintf(&url, "nbd://?socket=%s", unixsocket);

        else
          abort();
    }

    else
      if(!(port == ((const char *)NULL)))
        r=asprintf(&url, "nbd:localhost:%s", port);

      else
        if(!(unixsocket == ((char *)NULL)))
          r=asprintf(&url, "nbd:unix:%s", unixsocket);

        else
          abort();
    if(r == -1)
    {
      perror("asprintf");
      exit(1);
    }

    r=asprintf(&cmd, "nbd='%s'\nport='%s'\nunixsocket='%s'\n%s", url, port != ((const char *)NULL) ? port : "", unixsocket != ((char *)NULL) ? unixsocket : "", run);
    if(r == -1)
    {
      perror("asprintf");
      exit(1);
    }

    free((void *)url);
    pid=fork();
    if(pid == -1)
    {
      perror("fork");
      exit(1);
    }

    if(pid >= 1)
    {
      r=system(cmd);
      /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous$11
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
      ;
      if((0x7f & r) == 0)
        r = (((union anonymous$11){ .__in=r }).__i & 0xff00) >> 8;

      else
        if((signed int)((127 & (signed char)r) + 1) >> 1 >= 1)
        {
          fprintf(stderr, "%s: external command was killed by signal %d\n", program_invocation_short_name, ((union anonymous$11){ .__in=r }).__i & 0x7f);
          r = 1;
        }

        else
          if((0xff & r) == 0x7f)
          {
            fprintf(stderr, "%s: external command was stopped by signal %d\n", program_invocation_short_name, (((union anonymous$11){ .__in=r }).__i & 0xff00) >> 8);
            r = 1;
          }

      kill(pid, 15);
      _exit(r);
    }

    free((void *)cmd);
    signed int return_value_getpid$2;
    return_value_getpid$2=getpid();
    nbdkit_debug("forked into background (new pid = %d)", return_value_getpid$2);
  }

}

// set_up_signals
// file main.c line 449
static void set_up_signals(void)
{
  struct sigaction sa;
  memset((void *)&sa, 0, sizeof(struct sigaction) /*152ul*/ );
  sa.sa_flags = 0x10000000;
  sa.__sigaction_handler.sa_handler = handle_quit;
  sigaction(2, &sa, (struct sigaction *)(void *)0);
  sigaction(3, &sa, (struct sigaction *)(void *)0);
  sigaction(15, &sa, (struct sigaction *)(void *)0);
  sigaction(1, &sa, (struct sigaction *)(void *)0);
  memset((void *)&sa, 0, sizeof(struct sigaction) /*152ul*/ );
  sa.sa_flags = 0x10000000;
  sa.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  sigaction(13, &sa, (struct sigaction *)(void *)0);
}

// skip_over_write_buffer
// file connections.c line 404
static void skip_over_write_buffer(signed int sock, unsigned long int count)
{
  char buf[8192l];
  signed long int r;
  for( ; count >= 1ul; count = count - (unsigned long int)r)
  {
    r=read(sock, (void *)buf, count > (unsigned long int)8192 ? (unsigned long int)8192 : count);
    if(r == -1l)
    {
      nbdkit_error("skipping write buffer: %m");
      goto __CPROVER_DUMP_L5;
    }

    if(r == 0l)
      goto __CPROVER_DUMP_L5;

  }

__CPROVER_DUMP_L5:
  ;
}

// start_serving
// file main.c line 397
static void start_serving(void)
{
  signed int *socks;
  unsigned long int nr_socks;
  if(!(port == ((const char *)NULL)) && !(unixsocket == ((char *)NULL)) || !(port == ((const char *)NULL)) && !(listen_stdin == 0) || !(run == ((char *)NULL)) && !(listen_stdin == 0) || !(unixsocket == ((char *)NULL)) && !(listen_stdin == 0))
  {
    fprintf(stderr, "%s: -p, -U and -s options cannot appear at the same time\n", program_invocation_short_name);
    exit(1);
  }

  set_up_signals();
  if(!(listen_stdin == 0))
  {
    change_user();
    write_pidfile();
    tls_new_server_thread();
    signed int return_value_handle_single_connection$1;
    return_value_handle_single_connection$1=handle_single_connection(0, 1);
    if(return_value_handle_single_connection$1 == -1)
      exit(1);

    goto __CPROVER_DUMP_L6;
  }

  if(!(unixsocket == ((char *)NULL)))
    socks=bind_unix_socket(&nr_socks);

  else
    socks=bind_tcpip_socket(&nr_socks);
  run_command();
  change_user();
  fork_into_background();
  write_pidfile();
  accept_incoming_connections(socks, nr_socks);
  free_listening_sockets(socks, nr_socks);

__CPROVER_DUMP_L6:
  ;
}

// start_thread
// file sockets.c line 209
static void * start_thread(void *datav)
{
  struct thread_data *data = (struct thread_data *)datav;
  nbdkit_debug("accepted connection");
  tls_new_server_thread();
  tls_set_instance_num(data->instance_num);
  tls_set_sockaddr(&data->addr, data->addrlen);
  handle_single_connection(data->sock, data->sock);
  return (void *)0;
}

// tls_get_instance_num
// file internal.h line 121
extern unsigned long int tls_get_instance_num(void)
{
  struct tls *tls;
  void *return_value_pthread_getspecific$1;
  return_value_pthread_getspecific$1=pthread_getspecific(tls_key);
  tls = (struct tls *)return_value_pthread_getspecific$1;
  if(tls == ((struct tls *)NULL))
    return (unsigned long int)0;

  else
    return tls->instance_num;
}

// tls_get_name
// file internal.h line 120
extern const char * tls_get_name(void)
{
  struct tls *tls;
  void *return_value_pthread_getspecific$1;
  return_value_pthread_getspecific$1=pthread_getspecific(tls_key);
  tls = (struct tls *)return_value_pthread_getspecific$1;
  if(tls == ((struct tls *)NULL))
    return (const char *)(void *)0;

  else
    return tls->name;
}

// tls_init
// file internal.h line 115
extern void tls_init(void)
{
  signed int err;
  err=pthread_key_create(&tls_key, free_tls);
  if(!(err == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(err);
    fprintf(stderr, "%s: pthread_key_create: %s\n", program_invocation_short_name, return_value_strerror$1);
    exit(1);
  }

}

// tls_new_server_thread
// file internal.h line 116
extern void tls_new_server_thread(void)
{
  struct tls *tls;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct tls) /*32ul*/ );
  tls = (struct tls *)return_value_calloc$1;
  if(tls == ((struct tls *)NULL))
  {
    perror("malloc");
    exit(1);
  }

  pthread_setspecific(tls_key, (const void *)tls);
}

// tls_set_instance_num
// file internal.h line 118
extern void tls_set_instance_num(unsigned long int instance_num)
{
  struct tls *tls;
  void *return_value_pthread_getspecific$1;
  return_value_pthread_getspecific$1=pthread_getspecific(tls_key);
  tls = (struct tls *)return_value_pthread_getspecific$1;
  if(!(tls == ((struct tls *)NULL)))
    tls->instance_num = instance_num;

}

// tls_set_name
// file internal.h line 117
extern void tls_set_name(const char *name)
{
  struct tls *tls;
  void *return_value_pthread_getspecific$1;
  return_value_pthread_getspecific$1=pthread_getspecific(tls_key);
  tls = (struct tls *)return_value_pthread_getspecific$1;
  if(!(tls == ((struct tls *)NULL)))
    tls->name = name;

}

// tls_set_sockaddr
// file internal.h line 119
extern void tls_set_sockaddr(struct sockaddr *addr, unsigned int addrlen)
{
  struct tls *tls;
  void *return_value_pthread_getspecific$1;
  return_value_pthread_getspecific$1=pthread_getspecific(tls_key);
  tls = (struct tls *)return_value_pthread_getspecific$1;
  if(!(tls == ((struct tls *)NULL)))
  {
    free((void *)tls->addr);
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)1, (unsigned long int)addrlen);
    tls->addr = (struct sockaddr *)return_value_calloc$2;
    if(tls->addr == ((struct sockaddr *)NULL))
    {
      perror("calloc");
      exit(1);
    }

    memcpy((void *)tls->addr, (const void *)addr, (unsigned long int)addrlen);
  }

}

// usage
// file main.c line 111
static void usage(void)
{
  printf("nbdkit [--dump-config] [-f] [-g GROUP] [-i IPADDR]\n       [-P PIDFILE] [-p PORT] [-r] [--run CMD] [-s]\n       [-U SOCKET] [-u USER] [-v] [-V]\n       PLUGIN [key=value [key=value [...]]]\n\nPlease read the nbdkit(1) manual page for full usage.\n");
}

// valid_range
// file connections.c line 234
static signed int valid_range(struct connection *conn, unsigned long int offset, unsigned int count)
{
  unsigned long int exportsize = conn->exportsize;
  return (signed int)(count > (unsigned int)0 && offset <= exportsize && offset + (unsigned long int)count <= exportsize);
}

// validate_request
// file connections.c line 242
static signed int validate_request(struct connection *conn, unsigned int cmd, unsigned int flags, unsigned long int offset, unsigned int count, unsigned int *error)
{
  signed int r;
  switch(cmd)
  {
    case (unsigned int)0:

    case (unsigned int)1:

    case (unsigned int)4:
    {
      r=valid_range(conn, offset, count);
      if(r == -1)
        return -1;

      if(r == 0)
      {
        nbdkit_error("invalid request: offset and length are out of range");
        *error = (unsigned int)5;
        return 0;
      }

      break;
    }
    case (unsigned int)3:
    {
      if(!(count == 0u) || !(offset == 0ul))
      {
        nbdkit_error("invalid flush request: expecting offset and length == 0");
        *error = (unsigned int)22;
        return 0;
      }

      break;
    }
    default:
    {
      nbdkit_error("invalid request: unknown command (%u) ignored", cmd);
      *error = (unsigned int)22;
      return 0;
    }
  }
  if(count >= 67108865u && (cmd == 0u || cmd == 1u))
  {
    nbdkit_error("invalid request: data request is too large (%u > %d)", count, 64 * 1024 * 1024);
    *error = (unsigned int)12;
    return 0;
  }

  else
    if(!(conn->readonly == 0))
    {
      if(!(cmd == 1u) && !(cmd == 3u) && !(cmd == 4u))
        goto __CPROVER_DUMP_L9;

      nbdkit_error("invalid request: write request on readonly connection");
      *error = (unsigned int)30;
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L9:
      ;
      if(conn->can_flush == 0)
      {
        if(!(cmd == 3u))
          goto __CPROVER_DUMP_L10;

        nbdkit_error("invalid request: flush operation not supported");
        *error = (unsigned int)22;
        return 0;
      }

      else
      {

      __CPROVER_DUMP_L10:
        ;
        if(conn->can_trim == 0)
        {
          if(!(cmd == 4u))
            goto __CPROVER_DUMP_L11;

          nbdkit_error("invalid request: trim operation not supported");
          *error = (unsigned int)22;
          return 0;
        }

        else
        {

        __CPROVER_DUMP_L11:
          ;
          return 1;
        }
      }
    }
}

// write_pidfile
// file main.c line 500
static void write_pidfile(void)
{
  signed int fd;
  signed int pid;
  char pidstr[64l];
  unsigned long int len;
  _Bool tmp_if_expr$3;
  signed int return_value_close$2;
  if(!(pidfile == ((char *)NULL)))
  {
    pid=getpid();
    snprintf(pidstr, sizeof(char [64l]) /*64ul*/ , "%d\n", pid);
    len=strlen(pidstr);
    fd=open(pidfile, 01 | 01000 | 0100 | 02000000 | 0400, 0644);
    if(fd == -1)
    {
      perror(pidfile);
      exit(1);
    }

    signed long int return_value_write$1;
    return_value_write$1=write(fd, (const void *)pidstr, len);
    if(!((unsigned long int)return_value_write$1 >= len))
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value_close$2=close(fd);
      tmp_if_expr$3 = return_value_close$2 == -1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
    {
      perror(pidfile);
      exit(1);
    }

    nbdkit_debug("written pidfile %s", pidfile);
  }

}

// xread
// file internal.h line 125
extern signed int xread(signed int sock, void *vbuf, unsigned long int len)
{
  char *buf = (char *)vbuf;
  signed long int r;
  _Bool first_read = (_Bool)1;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  while(len >= 1ul)
  {
    r=read(sock, (void *)buf, len);
    if(r == -1l)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 4)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = *return_value___errno_location$2 == 11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        continue;

      return -1;
    }

    if(r == 0l)
    {
      if(!(first_read == (_Bool)0))
        return 0;

      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      *return_value___errno_location$4 = 74;
      return -1;
    }

    first_read = (_Bool)0;
    buf = buf + r;
    len = len - (unsigned long int)r;
  }
  return 1;
}

// xwrite
// file internal.h line 126
extern signed int xwrite(signed int sock, const void *vbuf, unsigned long int len)
{
  const char *buf = (const char *)vbuf;
  signed long int r;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  while(len >= 1ul)
  {
    r=write(sock, (const void *)buf, len);
    if(r == -1l)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 4)
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        return_value___errno_location$2=__errno_location();
        tmp_if_expr$3 = *return_value___errno_location$2 == 11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        continue;

      return -1;
    }

    buf = buf + r;
    len = len - (unsigned long int)r;
  }
  return 0;
}

