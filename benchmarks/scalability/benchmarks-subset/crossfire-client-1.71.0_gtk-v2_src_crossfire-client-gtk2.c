// #anon_enum$COMM_CAT_MISC=0$COMM_CAT_HELP=1$COMM_CAT_INFO=2$COMM_CAT_SETUP=3$COMM_CAT_SCRIPT=4$COMM_CAT_DEBUG=5
// file ./p_cmd.h line 44
enum anonymous$46 { COMM_CAT_MISC=0, COMM_CAT_HELP=1, COMM_CAT_INFO=2, COMM_CAT_SETUP=3, COMM_CAT_SCRIPT=4, COMM_CAT_DEBUG=5 };

// #anon_enum$CURLE_OK=0$CURLE_UNSUPPORTED_PROTOCOL=1$CURLE_FAILED_INIT=2$CURLE_URL_MALFORMAT=3$CURLE_NOT_BUILT_IN=4$CURLE_COULDNT_RESOLVE_PROXY=5$CURLE_COULDNT_RESOLVE_HOST=6$CURLE_COULDNT_CONNECT=7$CURLE_FTP_WEIRD_SERVER_REPLY=8$CURLE_REMOTE_ACCESS_DENIED=9$CURLE_FTP_ACCEPT_FAILED=10$CURLE_FTP_WEIRD_PASS_REPLY=11$CURLE_FTP_ACCEPT_TIMEOUT=12$CURLE_FTP_WEIRD_PASV_REPLY=13$CURLE_FTP_WEIRD_227_FORMAT=14$CURLE_FTP_CANT_GET_HOST=15$CURLE_HTTP2=16$CURLE_FTP_COULDNT_SET_TYPE=17$CURLE_PARTIAL_FILE=18$CURLE_FTP_COULDNT_RETR_FILE=19$CURLE_OBSOLETE20=20$CURLE_QUOTE_ERROR=21$CURLE_HTTP_RETURNED_ERROR=22$CURLE_WRITE_ERROR=23$CURLE_OBSOLETE24=24$CURLE_UPLOAD_FAILED=25$CURLE_READ_ERROR=26$CURLE_OUT_OF_MEMORY=27$CURLE_OPERATION_TIMEDOUT=28$CURLE_OBSOLETE29=29$CURLE_FTP_PORT_FAILED=30$CURLE_FTP_COULDNT_USE_REST=31$CURLE_OBSOLETE32=32$CURLE_RANGE_ERROR=33$CURLE_HTTP_POST_ERROR=34$CURLE_SSL_CONNECT_ERROR=35$CURLE_BAD_DOWNLOAD_RESUME=36$CURLE_FILE_COULDNT_READ_FILE=37$CURLE_LDAP_CANNOT_BIND=38$CURLE_LDAP_SEARCH_FAILED=39$CURLE_OBSOLETE40=40$CURLE_FUNCTION_NOT_FOUND=41$CURLE_ABORTED_BY_CALLBACK=42$CURLE_BAD_FUNCTION_ARGUMENT=43$CURLE_OBSOLETE44=44$CURLE_INTERFACE_FAILED=45$CURLE_OBSOLETE46=46$CURLE_TOO_MANY_REDIRECTS=47$CURLE_UNKNOWN_OPTION=48$CURLE_TELNET_OPTION_SYNTAX=49$CURLE_OBSOLETE50=50$CURLE_PEER_FAILED_VERIFICATION=51$CURLE_GOT_NOTHING=52$CURLE_SSL_ENGINE_NOTFOUND=53$CURLE_SSL_ENGINE_SETFAILED=54$CURLE_SEND_ERROR=55$CURLE_RECV_ERROR=56$CURLE_OBSOLETE57=57$CURLE_SSL_CERTPROBLEM=58$CURLE_SSL_CIPHER=59$CURLE_SSL_CACERT=60$CURLE_BAD_CONTENT_ENCODING=61$CURLE_LDAP_INVALID_URL=62$CURLE_FILESIZE_EXCEEDED=63$CURLE_USE_SSL_FAILED=64$CURLE_SEND_FAIL_REWIND=65$CURLE_SSL_ENGINE_INITFAILED=66$CURLE_LOGIN_DENIED=67$CURLE_TFTP_NOTFOUND=68$CURLE_TFTP_PERM=69$CURLE_REMOTE_DISK_FULL=70$CURLE_TFTP_ILLEGAL=71$CURLE_TFTP_UNKNOWNID=72$CURLE_REMOTE_FILE_EXISTS=73$CURLE_TFTP_NOSUCHUSER=74$CURLE_CONV_FAILED=75$CURLE_CONV_REQD=76$CURLE_SSL_CACERT_BADFILE=77$CURLE_REMOTE_FILE_NOT_FOUND=78$CURLE_SSH=79$CURLE_SSL_SHUTDOWN_FAILED=80$CURLE_AGAIN=81$CURLE_SSL_CRL_BADFILE=82$CURLE_SSL_ISSUER_ERROR=83$CURLE_FTP_PRET_FAILED=84$CURLE_RTSP_CSEQ_ERROR=85$CURLE_RTSP_SESSION_ERROR=86$CURLE_FTP_BAD_FILE_LIST=87$CURLE_CHUNK_FAILED=88$CURLE_NO_CONNECTION_AVAILABLE=89$CURLE_SSL_PINNEDPUBKEYNOTMATCH=90$CURLE_SSL_INVALIDCERTSTATUS=91$CURL_LAST=92
// file /usr/include/curl/curl.h line 413
enum anonymous$33 { CURLE_OK=0, CURLE_UNSUPPORTED_PROTOCOL=1, CURLE_FAILED_INIT=2, CURLE_URL_MALFORMAT=3, CURLE_NOT_BUILT_IN=4, CURLE_COULDNT_RESOLVE_PROXY=5, CURLE_COULDNT_RESOLVE_HOST=6, CURLE_COULDNT_CONNECT=7, CURLE_FTP_WEIRD_SERVER_REPLY=8, CURLE_REMOTE_ACCESS_DENIED=9, CURLE_FTP_ACCEPT_FAILED=10, CURLE_FTP_WEIRD_PASS_REPLY=11, CURLE_FTP_ACCEPT_TIMEOUT=12, CURLE_FTP_WEIRD_PASV_REPLY=13, CURLE_FTP_WEIRD_227_FORMAT=14, CURLE_FTP_CANT_GET_HOST=15, CURLE_HTTP2=16, CURLE_FTP_COULDNT_SET_TYPE=17, CURLE_PARTIAL_FILE=18, CURLE_FTP_COULDNT_RETR_FILE=19, CURLE_OBSOLETE20=20, CURLE_QUOTE_ERROR=21, CURLE_HTTP_RETURNED_ERROR=22, CURLE_WRITE_ERROR=23, CURLE_OBSOLETE24=24, CURLE_UPLOAD_FAILED=25, CURLE_READ_ERROR=26, CURLE_OUT_OF_MEMORY=27, CURLE_OPERATION_TIMEDOUT=28, CURLE_OBSOLETE29=29, CURLE_FTP_PORT_FAILED=30, CURLE_FTP_COULDNT_USE_REST=31, CURLE_OBSOLETE32=32, CURLE_RANGE_ERROR=33, CURLE_HTTP_POST_ERROR=34, CURLE_SSL_CONNECT_ERROR=35, CURLE_BAD_DOWNLOAD_RESUME=36, CURLE_FILE_COULDNT_READ_FILE=37, CURLE_LDAP_CANNOT_BIND=38, CURLE_LDAP_SEARCH_FAILED=39, CURLE_OBSOLETE40=40, CURLE_FUNCTION_NOT_FOUND=41, CURLE_ABORTED_BY_CALLBACK=42, CURLE_BAD_FUNCTION_ARGUMENT=43, CURLE_OBSOLETE44=44, CURLE_INTERFACE_FAILED=45, CURLE_OBSOLETE46=46, CURLE_TOO_MANY_REDIRECTS=47, CURLE_UNKNOWN_OPTION=48, CURLE_TELNET_OPTION_SYNTAX=49, CURLE_OBSOLETE50=50, CURLE_PEER_FAILED_VERIFICATION=51, CURLE_GOT_NOTHING=52, CURLE_SSL_ENGINE_NOTFOUND=53, CURLE_SSL_ENGINE_SETFAILED=54, CURLE_SEND_ERROR=55, CURLE_RECV_ERROR=56, CURLE_OBSOLETE57=57, CURLE_SSL_CERTPROBLEM=58, CURLE_SSL_CIPHER=59, CURLE_SSL_CACERT=60, CURLE_BAD_CONTENT_ENCODING=61, CURLE_LDAP_INVALID_URL=62, CURLE_FILESIZE_EXCEEDED=63, CURLE_USE_SSL_FAILED=64, CURLE_SEND_FAIL_REWIND=65, CURLE_SSL_ENGINE_INITFAILED=66, CURLE_LOGIN_DENIED=67, CURLE_TFTP_NOTFOUND=68, CURLE_TFTP_PERM=69, CURLE_REMOTE_DISK_FULL=70, CURLE_TFTP_ILLEGAL=71, CURLE_TFTP_UNKNOWNID=72, CURLE_REMOTE_FILE_EXISTS=73, CURLE_TFTP_NOSUCHUSER=74, CURLE_CONV_FAILED=75, CURLE_CONV_REQD=76, CURLE_SSL_CACERT_BADFILE=77, CURLE_REMOTE_FILE_NOT_FOUND=78, CURLE_SSH=79, CURLE_SSL_SHUTDOWN_FAILED=80, CURLE_AGAIN=81, CURLE_SSL_CRL_BADFILE=82, CURLE_SSL_ISSUER_ERROR=83, CURLE_FTP_PRET_FAILED=84, CURLE_RTSP_CSEQ_ERROR=85, CURLE_RTSP_SESSION_ERROR=86, CURLE_FTP_BAD_FILE_LIST=87, CURLE_CHUNK_FAILED=88, CURLE_NO_CONNECTION_AVAILABLE=89, CURLE_SSL_PINNEDPUBKEYNOTMATCH=90, CURLE_SSL_INVALIDCERTSTATUS=91, CURL_LAST=92 };

// #anon_enum$CURLOPT_WRITEDATA=10001$CURLOPT_URL=10002$CURLOPT_PORT=3$CURLOPT_PROXY=10004$CURLOPT_USERPWD=10005$CURLOPT_PROXYUSERPWD=10006$CURLOPT_RANGE=10007$CURLOPT_READDATA=10009$CURLOPT_ERRORBUFFER=10010$CURLOPT_WRITEFUNCTION=20011$CURLOPT_READFUNCTION=20012$CURLOPT_TIMEOUT=13$CURLOPT_INFILESIZE=14$CURLOPT_POSTFIELDS=10015$CURLOPT_REFERER=10016$CURLOPT_FTPPORT=10017$CURLOPT_USERAGENT=10018$CURLOPT_LOW_SPEED_LIMIT=19$CURLOPT_LOW_SPEED_TIME=20$CURLOPT_RESUME_FROM=21$CURLOPT_COOKIE=10022$CURLOPT_HTTPHEADER=10023$CURLOPT_HTTPPOST=10024$CURLOPT_SSLCERT=10025$CURLOPT_KEYPASSWD=10026$CURLOPT_CRLF=27$CURLOPT_QUOTE=10028$CURLOPT_HEADERDATA=10029$CURLOPT_COOKIEFILE=10031$CURLOPT_SSLVERSION=32$CURLOPT_TIMECONDITION=33$CURLOPT_TIMEVALUE=34$CURLOPT_CUSTOMREQUEST=10036$CURLOPT_STDERR=10037$CURLOPT_POSTQUOTE=10039$CURLOPT_OBSOLETE40=10040$CURLOPT_VERBOSE=41$CURLOPT_HEADER=42$CURLOPT_NOPROGRESS=43$CURLOPT_NOBODY=44$CURLOPT_FAILONERROR=45$CURLOPT_UPLOAD=46$CURLOPT_POST=47$CURLOPT_DIRLISTONLY=48$CURLOPT_APPEND=50$CURLOPT_NETRC=51$CURLOPT_FOLLOWLOCATION=52$CURLOPT_TRANSFERTEXT=53$CURLOPT_PUT=54$CURLOPT_PROGRESSFUNCTION=20056$CURLOPT_PROGRESSDATA=10057$CURLOPT_AUTOREFERER=58$CURLOPT_PROXYPORT=59$CURLOPT_POSTFIELDSIZE=60$CURLOPT_HTTPPROXYTUNNEL=61$CURLOPT_INTERFACE=10062$CURLOPT_KRBLEVEL=10063$CURLOPT_SSL_VERIFYPEER=64$CURLOPT_CAINFO=10065$CURLOPT_MAXREDIRS=68$CURLOPT_FILETIME=69$CURLOPT_TELNETOPTIONS=10070$CURLOPT_MAXCONNECTS=71$CURLOPT_OBSOLETE72=72$CURLOPT_FRESH_CONNECT=74$CURLOPT_FORBID_REUSE=75$CURLOPT_RANDOM_FILE=10076$CURLOPT_EGDSOCKET=10077$CURLOPT_CONNECTTIMEOUT=78$CURLOPT_HEADERFUNCTION=20079$CURLOPT_HTTPGET=80$CURLOPT_SSL_VERIFYHOST=81$CURLOPT_COOKIEJAR=10082$CURLOPT_SSL_CIPHER_LIST=10083$CURLOPT_HTTP_VERSION=84$CURLOPT_FTP_USE_EPSV=85$CURLOPT_SSLCERTTYPE=10086$CURLOPT_SSLKEY=10087$CURLOPT_SSLKEYTYPE=10088$CURLOPT_SSLENGINE=10089$CURLOPT_SSLENGINE_DEFAULT=90$CURLOPT_DNS_USE_GLOBAL_CACHE=91$CURLOPT_DNS_CACHE_TIMEOUT=92$CURLOPT_PREQUOTE=10093$CURLOPT_DEBUGFUNCTION=20094$CURLOPT_DEBUGDATA=10095$CURLOPT_COOKIESESSION=96$CURLOPT_CAPATH=10097$CURLOPT_BUFFERSIZE=98$CURLOPT_NOSIGNAL=99$CURLOPT_SHARE=10100$CURLOPT_PROXYTYPE=101$CURLOPT_ACCEPT_ENCODING=10102$CURLOPT_PRIVATE=10103$CURLOPT_HTTP200ALIASES=10104$CURLOPT_UNRESTRICTED_AUTH=105$CURLOPT_FTP_USE_EPRT=106$CURLOPT_HTTPAUTH=107$CURLOPT_SSL_CTX_FUNCTION=20108$CURLOPT_SSL_CTX_DATA=10109$CURLOPT_FTP_CREATE_MISSING_DIRS=110$CURLOPT_PROXYAUTH=111$CURLOPT_FTP_RESPONSE_TIMEOUT=112$CURLOPT_IPRESOLVE=113$CURLOPT_MAXFILESIZE=114$CURLOPT_INFILESIZE_LARGE=30115$CURLOPT_RESUME_FROM_LARGE=30116$CURLOPT_MAXFILESIZE_LARGE=30117$CURLOPT_NETRC_FILE=10118$CURLOPT_USE_SSL=119$CURLOPT_POSTFIELDSIZE_LARGE=30120$CURLOPT_TCP_NODELAY=121$CURLOPT_FTPSSLAUTH=129$CURLOPT_IOCTLFUNCTION=20130$CURLOPT_IOCTLDATA=10131$CURLOPT_FTP_ACCOUNT=10134$CURLOPT_COOKIELIST=10135$CURLOPT_IGNORE_CONTENT_LENGTH=136$CURLOPT_FTP_SKIP_PASV_IP=137$CURLOPT_FTP_FILEMETHOD=138$CURLOPT_LOCALPORT=139$CURLOPT_LOCALPORTRANGE=140$CURLOPT_CONNECT_ONLY=141$CURLOPT_CONV_FROM_NETWORK_FUNCTION=20142$CURLOPT_CONV_TO_NETWORK_FUNCTION=20143$CURLOPT_CONV_FROM_UTF8_FUNCTION=20144$CURLOPT_MAX_SEND_SPEED_LARGE=30145$CURLOPT_MAX_RECV_SPEED_LARGE=30146$CURLOPT_FTP_ALTERNATIVE_TO_USER=10147$CURLOPT_SOCKOPTFUNCTION=20148$CURLOPT_SOCKOPTDATA=10149$CURLOPT_SSL_SESSIONID_CACHE=150$CURLOPT_SSH_AUTH_TYPES=151$CURLOPT_SSH_PUBLIC_KEYFILE=10152$CURLOPT_SSH_PRIVATE_KEYFILE=10153$CURLOPT_FTP_SSL_CCC=154$CURLOPT_TIMEOUT_MS=155$CURLOPT_CONNECTTIMEOUT_MS=156$CURLOPT_HTTP_TRANSFER_DECODING=157$CURLOPT_HTTP_CONTENT_DECODING=158$CURLOPT_NEW_FILE_PERMS=159$CURLOPT_NEW_DIRECTORY_PERMS=160$CURLOPT_POSTREDIR=161$CURLOPT_SSH_HOST_PUBLIC_KEY_MD5=10162$CURLOPT_OPENSOCKETFUNCTION=20163$CURLOPT_OPENSOCKETDATA=10164$CURLOPT_COPYPOSTFIELDS=10165$CURLOPT_PROXY_TRANSFER_MODE=166$CURLOPT_SEEKFUNCTION=20167$CURLOPT_SEEKDATA=10168$CURLOPT_CRLFILE=10169$CURLOPT_ISSUERCERT=10170$CURLOPT_ADDRESS_SCOPE=171$CURLOPT_CERTINFO=172$CURLOPT_USERNAME=10173$CURLOPT_PASSWORD=10174$CURLOPT_PROXYUSERNAME=10175$CURLOPT_PROXYPASSWORD=10176$CURLOPT_NOPROXY=10177$CURLOPT_TFTP_BLKSIZE=178$CURLOPT_SOCKS5_GSSAPI_SERVICE=10179$CURLOPT_SOCKS5_GSSAPI_NEC=180$CURLOPT_PROTOCOLS=181$CURLOPT_REDIR_PROTOCOLS=182$CURLOPT_SSH_KNOWNHOSTS=10183$CURLOPT_SSH_KEYFUNCTION=20184$CURLOPT_SSH_KEYDATA=10185$CURLOPT_MAIL_FROM=10186$CURLOPT_MAIL_RCPT=10187$CURLOPT_FTP_USE_PRET=188$CURLOPT_RTSP_REQUEST=189$CURLOPT_RTSP_SESSION_ID=10190$CURLOPT_RTSP_STREAM_URI=10191$CURLOPT_RTSP_TRANSPORT=10192$CURLOPT_RTSP_CLIENT_CSEQ=193$CURLOPT_RTSP_SERVER_CSEQ=194$CURLOPT_INTERLEAVEDATA=10195$CURLOPT_INTERLEAVEFUNCTION=20196$CURLOPT_WILDCARDMATCH=197$CURLOPT_CHUNK_BGN_FUNCTION=20198$CURLOPT_CHUNK_END_FUNCTION=20199$CURLOPT_FNMATCH_FUNCTION=20200$CURLOPT_CHUNK_DATA=10201$CURLOPT_FNMATCH_DATA=10202$CURLOPT_RESOLVE=10203$CURLOPT_TLSAUTH_USERNAME=10204$CURLOPT_TLSAUTH_PASSWORD=10205$CURLOPT_TLSAUTH_TYPE=10206$CURLOPT_TRANSFER_ENCODING=207$CURLOPT_CLOSESOCKETFUNCTION=20208$CURLOPT_CLOSESOCKETDATA=10209$CURLOPT_GSSAPI_DELEGATION=210$CURLOPT_DNS_SERVERS=10211$CURLOPT_ACCEPTTIMEOUT_MS=212$CURLOPT_TCP_KEEPALIVE=213$CURLOPT_TCP_KEEPIDLE=214$CURLOPT_TCP_KEEPINTVL=215$CURLOPT_SSL_OPTIONS=216$CURLOPT_MAIL_AUTH=10217$CURLOPT_SASL_IR=218$CURLOPT_XFERINFOFUNCTION=20219$CURLOPT_XOAUTH2_BEARER=10220$CURLOPT_DNS_INTERFACE=10221$CURLOPT_DNS_LOCAL_IP4=10222$CURLOPT_DNS_LOCAL_IP6=10223$CURLOPT_LOGIN_OPTIONS=10224$CURLOPT_SSL_ENABLE_NPN=225$CURLOPT_SSL_ENABLE_ALPN=226$CURLOPT_EXPECT_100_TIMEOUT_MS=227$CURLOPT_PROXYHEADER=10228$CURLOPT_HEADEROPT=229$CURLOPT_PINNEDPUBLICKEY=10230$CURLOPT_UNIX_SOCKET_PATH=10231$CURLOPT_SSL_VERIFYSTATUS=232$CURLOPT_SSL_FALSESTART=233$CURLOPT_PATH_AS_IS=234$CURLOPT_PROXY_SERVICE_NAME=10235$CURLOPT_SERVICE_NAME=10236$CURLOPT_PIPEWAIT=237$CURLOPT_DEFAULT_PROTOCOL=10238$CURLOPT_STREAM_WEIGHT=239$CURLOPT_STREAM_DEPENDS=10240$CURLOPT_STREAM_DEPENDS_E=10241$CURLOPT_LASTENTRY=10242
// file /usr/include/curl/curl.h line 863
enum anonymous$34 { CURLOPT_WRITEDATA=10001, CURLOPT_URL=10002, CURLOPT_PORT=3, CURLOPT_PROXY=10004, CURLOPT_USERPWD=10005, CURLOPT_PROXYUSERPWD=10006, CURLOPT_RANGE=10007, CURLOPT_READDATA=10009, CURLOPT_ERRORBUFFER=10010, CURLOPT_WRITEFUNCTION=20011, CURLOPT_READFUNCTION=20012, CURLOPT_TIMEOUT=13, CURLOPT_INFILESIZE=14, CURLOPT_POSTFIELDS=10015, CURLOPT_REFERER=10016, CURLOPT_FTPPORT=10017, CURLOPT_USERAGENT=10018, CURLOPT_LOW_SPEED_LIMIT=19, CURLOPT_LOW_SPEED_TIME=20, CURLOPT_RESUME_FROM=21, CURLOPT_COOKIE=10022, CURLOPT_HTTPHEADER=10023, CURLOPT_HTTPPOST=10024, CURLOPT_SSLCERT=10025, CURLOPT_KEYPASSWD=10026, CURLOPT_CRLF=27, CURLOPT_QUOTE=10028, CURLOPT_HEADERDATA=10029, CURLOPT_COOKIEFILE=10031, CURLOPT_SSLVERSION=32, CURLOPT_TIMECONDITION=33, CURLOPT_TIMEVALUE=34, CURLOPT_CUSTOMREQUEST=10036, CURLOPT_STDERR=10037, CURLOPT_POSTQUOTE=10039, CURLOPT_OBSOLETE40=10040, CURLOPT_VERBOSE=41, CURLOPT_HEADER=42, CURLOPT_NOPROGRESS=43, CURLOPT_NOBODY=44, CURLOPT_FAILONERROR=45, CURLOPT_UPLOAD=46, CURLOPT_POST=47, CURLOPT_DIRLISTONLY=48, CURLOPT_APPEND=50, CURLOPT_NETRC=51, CURLOPT_FOLLOWLOCATION=52, CURLOPT_TRANSFERTEXT=53, CURLOPT_PUT=54, CURLOPT_PROGRESSFUNCTION=20056, CURLOPT_PROGRESSDATA=10057, CURLOPT_AUTOREFERER=58, CURLOPT_PROXYPORT=59, CURLOPT_POSTFIELDSIZE=60, CURLOPT_HTTPPROXYTUNNEL=61, CURLOPT_INTERFACE=10062, CURLOPT_KRBLEVEL=10063, CURLOPT_SSL_VERIFYPEER=64, CURLOPT_CAINFO=10065, CURLOPT_MAXREDIRS=68, CURLOPT_FILETIME=69, CURLOPT_TELNETOPTIONS=10070, CURLOPT_MAXCONNECTS=71, CURLOPT_OBSOLETE72=72, CURLOPT_FRESH_CONNECT=74, CURLOPT_FORBID_REUSE=75, CURLOPT_RANDOM_FILE=10076, CURLOPT_EGDSOCKET=10077, CURLOPT_CONNECTTIMEOUT=78, CURLOPT_HEADERFUNCTION=20079, CURLOPT_HTTPGET=80, CURLOPT_SSL_VERIFYHOST=81, CURLOPT_COOKIEJAR=10082, CURLOPT_SSL_CIPHER_LIST=10083, CURLOPT_HTTP_VERSION=84, CURLOPT_FTP_USE_EPSV=85, CURLOPT_SSLCERTTYPE=10086, CURLOPT_SSLKEY=10087, CURLOPT_SSLKEYTYPE=10088, CURLOPT_SSLENGINE=10089, CURLOPT_SSLENGINE_DEFAULT=90, CURLOPT_DNS_USE_GLOBAL_CACHE=91, CURLOPT_DNS_CACHE_TIMEOUT=92, CURLOPT_PREQUOTE=10093, CURLOPT_DEBUGFUNCTION=20094, CURLOPT_DEBUGDATA=10095, CURLOPT_COOKIESESSION=96, CURLOPT_CAPATH=10097, CURLOPT_BUFFERSIZE=98, CURLOPT_NOSIGNAL=99, CURLOPT_SHARE=10100, CURLOPT_PROXYTYPE=101, CURLOPT_ACCEPT_ENCODING=10102, CURLOPT_PRIVATE=10103, CURLOPT_HTTP200ALIASES=10104, CURLOPT_UNRESTRICTED_AUTH=105, CURLOPT_FTP_USE_EPRT=106, CURLOPT_HTTPAUTH=107, CURLOPT_SSL_CTX_FUNCTION=20108, CURLOPT_SSL_CTX_DATA=10109, CURLOPT_FTP_CREATE_MISSING_DIRS=110, CURLOPT_PROXYAUTH=111, CURLOPT_FTP_RESPONSE_TIMEOUT=112, CURLOPT_IPRESOLVE=113, CURLOPT_MAXFILESIZE=114, CURLOPT_INFILESIZE_LARGE=30115, CURLOPT_RESUME_FROM_LARGE=30116, CURLOPT_MAXFILESIZE_LARGE=30117, CURLOPT_NETRC_FILE=10118, CURLOPT_USE_SSL=119, CURLOPT_POSTFIELDSIZE_LARGE=30120, CURLOPT_TCP_NODELAY=121, CURLOPT_FTPSSLAUTH=129, CURLOPT_IOCTLFUNCTION=20130, CURLOPT_IOCTLDATA=10131, CURLOPT_FTP_ACCOUNT=10134, CURLOPT_COOKIELIST=10135, CURLOPT_IGNORE_CONTENT_LENGTH=136, CURLOPT_FTP_SKIP_PASV_IP=137, CURLOPT_FTP_FILEMETHOD=138, CURLOPT_LOCALPORT=139, CURLOPT_LOCALPORTRANGE=140, CURLOPT_CONNECT_ONLY=141, CURLOPT_CONV_FROM_NETWORK_FUNCTION=20142, CURLOPT_CONV_TO_NETWORK_FUNCTION=20143, CURLOPT_CONV_FROM_UTF8_FUNCTION=20144, CURLOPT_MAX_SEND_SPEED_LARGE=30145, CURLOPT_MAX_RECV_SPEED_LARGE=30146, CURLOPT_FTP_ALTERNATIVE_TO_USER=10147, CURLOPT_SOCKOPTFUNCTION=20148, CURLOPT_SOCKOPTDATA=10149, CURLOPT_SSL_SESSIONID_CACHE=150, CURLOPT_SSH_AUTH_TYPES=151, CURLOPT_SSH_PUBLIC_KEYFILE=10152, CURLOPT_SSH_PRIVATE_KEYFILE=10153, CURLOPT_FTP_SSL_CCC=154, CURLOPT_TIMEOUT_MS=155, CURLOPT_CONNECTTIMEOUT_MS=156, CURLOPT_HTTP_TRANSFER_DECODING=157, CURLOPT_HTTP_CONTENT_DECODING=158, CURLOPT_NEW_FILE_PERMS=159, CURLOPT_NEW_DIRECTORY_PERMS=160, CURLOPT_POSTREDIR=161, CURLOPT_SSH_HOST_PUBLIC_KEY_MD5=10162, CURLOPT_OPENSOCKETFUNCTION=20163, CURLOPT_OPENSOCKETDATA=10164, CURLOPT_COPYPOSTFIELDS=10165, CURLOPT_PROXY_TRANSFER_MODE=166, CURLOPT_SEEKFUNCTION=20167, CURLOPT_SEEKDATA=10168, CURLOPT_CRLFILE=10169, CURLOPT_ISSUERCERT=10170, CURLOPT_ADDRESS_SCOPE=171, CURLOPT_CERTINFO=172, CURLOPT_USERNAME=10173, CURLOPT_PASSWORD=10174, CURLOPT_PROXYUSERNAME=10175, CURLOPT_PROXYPASSWORD=10176, CURLOPT_NOPROXY=10177, CURLOPT_TFTP_BLKSIZE=178, CURLOPT_SOCKS5_GSSAPI_SERVICE=10179, CURLOPT_SOCKS5_GSSAPI_NEC=180, CURLOPT_PROTOCOLS=181, CURLOPT_REDIR_PROTOCOLS=182, CURLOPT_SSH_KNOWNHOSTS=10183, CURLOPT_SSH_KEYFUNCTION=20184, CURLOPT_SSH_KEYDATA=10185, CURLOPT_MAIL_FROM=10186, CURLOPT_MAIL_RCPT=10187, CURLOPT_FTP_USE_PRET=188, CURLOPT_RTSP_REQUEST=189, CURLOPT_RTSP_SESSION_ID=10190, CURLOPT_RTSP_STREAM_URI=10191, CURLOPT_RTSP_TRANSPORT=10192, CURLOPT_RTSP_CLIENT_CSEQ=193, CURLOPT_RTSP_SERVER_CSEQ=194, CURLOPT_INTERLEAVEDATA=10195, CURLOPT_INTERLEAVEFUNCTION=20196, CURLOPT_WILDCARDMATCH=197, CURLOPT_CHUNK_BGN_FUNCTION=20198, CURLOPT_CHUNK_END_FUNCTION=20199, CURLOPT_FNMATCH_FUNCTION=20200, CURLOPT_CHUNK_DATA=10201, CURLOPT_FNMATCH_DATA=10202, CURLOPT_RESOLVE=10203, CURLOPT_TLSAUTH_USERNAME=10204, CURLOPT_TLSAUTH_PASSWORD=10205, CURLOPT_TLSAUTH_TYPE=10206, CURLOPT_TRANSFER_ENCODING=207, CURLOPT_CLOSESOCKETFUNCTION=20208, CURLOPT_CLOSESOCKETDATA=10209, CURLOPT_GSSAPI_DELEGATION=210, CURLOPT_DNS_SERVERS=10211, CURLOPT_ACCEPTTIMEOUT_MS=212, CURLOPT_TCP_KEEPALIVE=213, CURLOPT_TCP_KEEPIDLE=214, CURLOPT_TCP_KEEPINTVL=215, CURLOPT_SSL_OPTIONS=216, CURLOPT_MAIL_AUTH=10217, CURLOPT_SASL_IR=218, CURLOPT_XFERINFOFUNCTION=20219, CURLOPT_XOAUTH2_BEARER=10220, CURLOPT_DNS_INTERFACE=10221, CURLOPT_DNS_LOCAL_IP4=10222, CURLOPT_DNS_LOCAL_IP6=10223, CURLOPT_LOGIN_OPTIONS=10224, CURLOPT_SSL_ENABLE_NPN=225, CURLOPT_SSL_ENABLE_ALPN=226, CURLOPT_EXPECT_100_TIMEOUT_MS=227, CURLOPT_PROXYHEADER=10228, CURLOPT_HEADEROPT=229, CURLOPT_PINNEDPUBLICKEY=10230, CURLOPT_UNIX_SOCKET_PATH=10231, CURLOPT_SSL_VERIFYSTATUS=232, CURLOPT_SSL_FALSESTART=233, CURLOPT_PATH_AS_IS=234, CURLOPT_PROXY_SERVICE_NAME=10235, CURLOPT_SERVICE_NAME=10236, CURLOPT_PIPEWAIT=237, CURLOPT_DEFAULT_PROTOCOL=10238, CURLOPT_STREAM_WEIGHT=239, CURLOPT_STREAM_DEPENDS=10240, CURLOPT_STREAM_DEPENDS_E=10241, CURLOPT_LASTENTRY=10242 };

// #anon_enum$GDK_ACTION_DEFAULT=1$GDK_ACTION_COPY=2$GDK_ACTION_MOVE=4$GDK_ACTION_LINK=8$GDK_ACTION_PRIVATE=16$GDK_ACTION_ASK=32
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 40
enum anonymous$4 { GDK_ACTION_DEFAULT=1, GDK_ACTION_COPY=2, GDK_ACTION_MOVE=4, GDK_ACTION_LINK=8, GDK_ACTION_PRIVATE=16, GDK_ACTION_ASK=32 };

// #anon_enum$GDK_AXIS_IGNORE=0$GDK_AXIS_X=1$GDK_AXIS_Y=2$GDK_AXIS_PRESSURE=3$GDK_AXIS_XTILT=4$GDK_AXIS_YTILT=5$GDK_AXIS_WHEEL=6$GDK_AXIS_LAST=7
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 73
enum anonymous { GDK_AXIS_IGNORE=0, GDK_AXIS_X=1, GDK_AXIS_Y=2, GDK_AXIS_PRESSURE=3, GDK_AXIS_XTILT=4, GDK_AXIS_YTILT=5, GDK_AXIS_WHEEL=6, GDK_AXIS_LAST=7 };

// #anon_enum$GDK_COLORSPACE_RGB=0
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 140
enum anonymous$63 { GDK_COLORSPACE_RGB=0 };

// #anon_enum$GDK_COPY=0$GDK_INVERT=1$GDK_XOR=2$GDK_CLEAR=3$GDK_AND=4$GDK_AND_REVERSE=5$GDK_AND_INVERT=6$GDK_NOOP=7$GDK_OR=8$GDK_EQUIV=9$GDK_OR_REVERSE=10$GDK_COPY_INVERT=11$GDK_OR_INVERT=12$GDK_NAND=13$GDK_NOR=14$GDK_SET=15
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 88
enum anonymous$65 { GDK_COPY=0, GDK_INVERT=1, GDK_XOR=2, GDK_CLEAR=3, GDK_AND=4, GDK_AND_REVERSE=5, GDK_AND_INVERT=6, GDK_NOOP=7, GDK_OR=8, GDK_EQUIV=9, GDK_OR_REVERSE=10, GDK_COPY_INVERT=11, GDK_OR_INVERT=12, GDK_NAND=13, GDK_NOR=14, GDK_SET=15 };

// #anon_enum$GDK_CROSSING_NORMAL=0$GDK_CROSSING_GRAB=1$GDK_CROSSING_UNGRAB=2$GDK_CROSSING_GTK_GRAB=3$GDK_CROSSING_GTK_UNGRAB=4$GDK_CROSSING_STATE_CHANGED=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 225
enum anonymous$10 { GDK_CROSSING_NORMAL=0, GDK_CROSSING_GRAB=1, GDK_CROSSING_UNGRAB=2, GDK_CROSSING_GTK_GRAB=3, GDK_CROSSING_GTK_UNGRAB=4, GDK_CROSSING_STATE_CHANGED=5 };

// #anon_enum$GDK_DRAG_PROTO_MOTIF=0$GDK_DRAG_PROTO_XDND=1$GDK_DRAG_PROTO_ROOTWIN=2$GDK_DRAG_PROTO_NONE=3$GDK_DRAG_PROTO_WIN32_DROPFILES=4$GDK_DRAG_PROTO_OLE2=5$GDK_DRAG_PROTO_LOCAL=6
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 50
enum anonymous$3 { GDK_DRAG_PROTO_MOTIF=0, GDK_DRAG_PROTO_XDND=1, GDK_DRAG_PROTO_ROOTWIN=2, GDK_DRAG_PROTO_NONE=3, GDK_DRAG_PROTO_WIN32_DROPFILES=4, GDK_DRAG_PROTO_OLE2=5, GDK_DRAG_PROTO_LOCAL=6 };

// #anon_enum$GDK_FONT_FONT=0$GDK_FONT_FONTSET=1
// file /usr/include/gtk-2.0/gdk/gdkfont.h line 43
enum anonymous$29 { GDK_FONT_FONT=0, GDK_FONT_FONTSET=1 };

// #anon_enum$GDK_GRAVITY_NORTH_WEST=1$GDK_GRAVITY_NORTH=2$GDK_GRAVITY_NORTH_EAST=3$GDK_GRAVITY_WEST=4$GDK_GRAVITY_CENTER=5$GDK_GRAVITY_EAST=6$GDK_GRAVITY_SOUTH_WEST=7$GDK_GRAVITY_SOUTH=8$GDK_GRAVITY_SOUTH_EAST=9$GDK_GRAVITY_STATIC=10
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 181
enum anonymous$50 { GDK_GRAVITY_NORTH_WEST=1, GDK_GRAVITY_NORTH=2, GDK_GRAVITY_NORTH_EAST=3, GDK_GRAVITY_WEST=4, GDK_GRAVITY_CENTER=5, GDK_GRAVITY_EAST=6, GDK_GRAVITY_SOUTH_WEST=7, GDK_GRAVITY_SOUTH=8, GDK_GRAVITY_SOUTH_EAST=9, GDK_GRAVITY_STATIC=10 };

// #anon_enum$GDK_HINT_POS=1$GDK_HINT_MIN_SIZE=2$GDK_HINT_MAX_SIZE=4$GDK_HINT_BASE_SIZE=8$GDK_HINT_ASPECT=16$GDK_HINT_RESIZE_INC=32$GDK_HINT_WIN_GRAVITY=64$GDK_HINT_USER_POS=128$GDK_HINT_USER_SIZE=256
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 107
enum anonymous$53 { GDK_HINT_POS=1, GDK_HINT_MIN_SIZE=2, GDK_HINT_MAX_SIZE=4, GDK_HINT_BASE_SIZE=8, GDK_HINT_ASPECT=16, GDK_HINT_RESIZE_INC=32, GDK_HINT_WIN_GRAVITY=64, GDK_HINT_USER_POS=128, GDK_HINT_USER_SIZE=256 };

// #anon_enum$GDK_IMAGE_NORMAL=0$GDK_IMAGE_SHARED=1$GDK_IMAGE_FASTEST=2
// file /usr/include/gtk-2.0/gdk/gdkimage.h line 49
enum anonymous$30 { GDK_IMAGE_NORMAL=0, GDK_IMAGE_SHARED=1, GDK_IMAGE_FASTEST=2 };

// #anon_enum$GDK_INPUT_READ=1$GDK_INPUT_WRITE=2$GDK_INPUT_EXCEPTION=4
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 155
enum anonymous$49 { GDK_INPUT_READ=1, GDK_INPUT_WRITE=2, GDK_INPUT_EXCEPTION=4 };

// #anon_enum$GDK_LSB_FIRST=0$GDK_MSB_FIRST=1
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 118
enum anonymous$32 { GDK_LSB_FIRST=0, GDK_MSB_FIRST=1 };

// #anon_enum$GDK_MODE_DISABLED=0$GDK_MODE_SCREEN=1$GDK_MODE_WINDOW=2
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 66
enum anonymous$2 { GDK_MODE_DISABLED=0, GDK_MODE_SCREEN=1, GDK_MODE_WINDOW=2 };

// #anon_enum$GDK_NOTHING=-1$GDK_DELETE=0$GDK_DESTROY=1$GDK_EXPOSE=2$GDK_MOTION_NOTIFY=3$GDK_BUTTON_PRESS=4$GDK_2BUTTON_PRESS=5$GDK_3BUTTON_PRESS=6$GDK_BUTTON_RELEASE=7$GDK_KEY_PRESS=8$GDK_KEY_RELEASE=9$GDK_ENTER_NOTIFY=10$GDK_LEAVE_NOTIFY=11$GDK_FOCUS_CHANGE=12$GDK_CONFIGURE=13$GDK_MAP=14$GDK_UNMAP=15$GDK_PROPERTY_NOTIFY=16$GDK_SELECTION_CLEAR=17$GDK_SELECTION_REQUEST=18$GDK_SELECTION_NOTIFY=19$GDK_PROXIMITY_IN=20$GDK_PROXIMITY_OUT=21$GDK_DRAG_ENTER=22$GDK_DRAG_LEAVE=23$GDK_DRAG_MOTION=24$GDK_DRAG_STATUS=25$GDK_DROP_START=26$GDK_DROP_FINISHED=27$GDK_CLIENT_EVENT=28$GDK_VISIBILITY_NOTIFY=29$GDK_NO_EXPOSE=30$GDK_SCROLL=31$GDK_WINDOW_STATE=32$GDK_SETTING=33$GDK_OWNER_CHANGE=34$GDK_GRAB_BROKEN=35$GDK_DAMAGE=36$GDK_EVENT_LAST=37
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 115
enum anonymous$5 { GDK_NOTHING=-1, GDK_DELETE=0, GDK_DESTROY=1, GDK_EXPOSE=2, GDK_MOTION_NOTIFY=3, GDK_BUTTON_PRESS=4, GDK_2BUTTON_PRESS=5, GDK_3BUTTON_PRESS=6, GDK_BUTTON_RELEASE=7, GDK_KEY_PRESS=8, GDK_KEY_RELEASE=9, GDK_ENTER_NOTIFY=10, GDK_LEAVE_NOTIFY=11, GDK_FOCUS_CHANGE=12, GDK_CONFIGURE=13, GDK_MAP=14, GDK_UNMAP=15, GDK_PROPERTY_NOTIFY=16, GDK_SELECTION_CLEAR=17, GDK_SELECTION_REQUEST=18, GDK_SELECTION_NOTIFY=19, GDK_PROXIMITY_IN=20, GDK_PROXIMITY_OUT=21, GDK_DRAG_ENTER=22, GDK_DRAG_LEAVE=23, GDK_DRAG_MOTION=24, GDK_DRAG_STATUS=25, GDK_DROP_START=26, GDK_DROP_FINISHED=27, GDK_CLIENT_EVENT=28, GDK_VISIBILITY_NOTIFY=29, GDK_NO_EXPOSE=30, GDK_SCROLL=31, GDK_WINDOW_STATE=32, GDK_SETTING=33, GDK_OWNER_CHANGE=34, GDK_GRAB_BROKEN=35, GDK_DAMAGE=36, GDK_EVENT_LAST=37 };

// #anon_enum$GDK_NOTIFY_ANCESTOR=0$GDK_NOTIFY_VIRTUAL=1$GDK_NOTIFY_INFERIOR=2$GDK_NOTIFY_NONLINEAR=3$GDK_NOTIFY_NONLINEAR_VIRTUAL=4$GDK_NOTIFY_UNKNOWN=5
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 210
enum anonymous$9 { GDK_NOTIFY_ANCESTOR=0, GDK_NOTIFY_VIRTUAL=1, GDK_NOTIFY_INFERIOR=2, GDK_NOTIFY_NONLINEAR=3, GDK_NOTIFY_NONLINEAR_VIRTUAL=4, GDK_NOTIFY_UNKNOWN=5 };

// #anon_enum$GDK_OWNER_CHANGE_NEW_OWNER=0$GDK_OWNER_CHANGE_DESTROY=1$GDK_OWNER_CHANGE_CLOSE=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 259
enum anonymous$13 { GDK_OWNER_CHANGE_NEW_OWNER=0, GDK_OWNER_CHANGE_DESTROY=1, GDK_OWNER_CHANGE_CLOSE=2 };

// #anon_enum$GDK_RGB_DITHER_NONE=0$GDK_RGB_DITHER_NORMAL=1$GDK_RGB_DITHER_MAX=2
// file /usr/include/gtk-2.0/gdk/gdkrgb.h line 40
enum anonymous$15 { GDK_RGB_DITHER_NONE=0, GDK_RGB_DITHER_NORMAL=1, GDK_RGB_DITHER_MAX=2 };

// #anon_enum$GDK_SCROLL_UP=0$GDK_SCROLL_DOWN=1$GDK_SCROLL_LEFT=2$GDK_SCROLL_RIGHT=3
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 194
enum anonymous$8 { GDK_SCROLL_UP=0, GDK_SCROLL_DOWN=1, GDK_SCROLL_LEFT=2, GDK_SCROLL_RIGHT=3 };

// #anon_enum$GDK_SETTING_ACTION_NEW=0$GDK_SETTING_ACTION_CHANGED=1$GDK_SETTING_ACTION_DELETED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 252
enum anonymous$12 { GDK_SETTING_ACTION_NEW=0, GDK_SETTING_ACTION_CHANGED=1, GDK_SETTING_ACTION_DELETED=2 };

// #anon_enum$GDK_SHIFT_MASK=1$GDK_LOCK_MASK=2$GDK_CONTROL_MASK=4$GDK_MOD1_MASK=8$GDK_MOD2_MASK=16$GDK_MOD3_MASK=32$GDK_MOD4_MASK=64$GDK_MOD5_MASK=128$GDK_BUTTON1_MASK=256$GDK_BUTTON2_MASK=512$GDK_BUTTON3_MASK=1024$GDK_BUTTON4_MASK=2048$GDK_BUTTON5_MASK=4096$GDK_SUPER_MASK=67108864$GDK_HYPER_MASK=134217728$GDK_META_MASK=268435456$GDK_RELEASE_MASK=1073741824$GDK_MODIFIER_MASK=1543512063
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 126
enum anonymous$0 { GDK_SHIFT_MASK=1, GDK_LOCK_MASK=2, GDK_CONTROL_MASK=4, GDK_MOD1_MASK=8, GDK_MOD2_MASK=16, GDK_MOD3_MASK=32, GDK_MOD4_MASK=64, GDK_MOD5_MASK=128, GDK_BUTTON1_MASK=256, GDK_BUTTON2_MASK=512, GDK_BUTTON3_MASK=1024, GDK_BUTTON4_MASK=2048, GDK_BUTTON5_MASK=4096, GDK_SUPER_MASK=67108864, GDK_HYPER_MASK=134217728, GDK_META_MASK=268435456, GDK_RELEASE_MASK=1073741824, GDK_MODIFIER_MASK=1543512063 };

// #anon_enum$GDK_SOURCE_MOUSE=0$GDK_SOURCE_PEN=1$GDK_SOURCE_ERASER=2$GDK_SOURCE_CURSOR=3
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 58
enum anonymous$1 { GDK_SOURCE_MOUSE=0, GDK_SOURCE_PEN=1, GDK_SOURCE_ERASER=2, GDK_SOURCE_CURSOR=3 };

// #anon_enum$GDK_VISIBILITY_UNOBSCURED=0$GDK_VISIBILITY_PARTIAL=1$GDK_VISIBILITY_FULLY_OBSCURED=2
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 187
enum anonymous$6 { GDK_VISIBILITY_UNOBSCURED=0, GDK_VISIBILITY_PARTIAL=1, GDK_VISIBILITY_FULLY_OBSCURED=2 };

// #anon_enum$GDK_VISUAL_STATIC_GRAY=0$GDK_VISUAL_GRAYSCALE=1$GDK_VISUAL_STATIC_COLOR=2$GDK_VISUAL_PSEUDO_COLOR=3$GDK_VISUAL_TRUE_COLOR=4$GDK_VISUAL_DIRECT_COLOR=5
// file /usr/include/gtk-2.0/gdk/gdkvisual.h line 55
enum anonymous$35 { GDK_VISUAL_STATIC_GRAY=0, GDK_VISUAL_GRAYSCALE=1, GDK_VISUAL_STATIC_COLOR=2, GDK_VISUAL_PSEUDO_COLOR=3, GDK_VISUAL_TRUE_COLOR=4, GDK_VISUAL_DIRECT_COLOR=5 };

// #anon_enum$GDK_WINDOW_STATE_WITHDRAWN=1$GDK_WINDOW_STATE_ICONIFIED=2$GDK_WINDOW_STATE_MAXIMIZED=4$GDK_WINDOW_STATE_STICKY=8$GDK_WINDOW_STATE_FULLSCREEN=16$GDK_WINDOW_STATE_ABOVE=32$GDK_WINDOW_STATE_BELOW=64
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 241
enum anonymous$11 { GDK_WINDOW_STATE_WITHDRAWN=1, GDK_WINDOW_STATE_ICONIFIED=2, GDK_WINDOW_STATE_MAXIMIZED=4, GDK_WINDOW_STATE_STICKY=8, GDK_WINDOW_STATE_FULLSCREEN=16, GDK_WINDOW_STATE_ABOVE=32, GDK_WINDOW_STATE_BELOW=64 };

// #anon_enum$GDK_X_CURSOR=0$GDK_ARROW=2$GDK_BASED_ARROW_DOWN=4$GDK_BASED_ARROW_UP=6$GDK_BOAT=8$GDK_BOGOSITY=10$GDK_BOTTOM_LEFT_CORNER=12$GDK_BOTTOM_RIGHT_CORNER=14$GDK_BOTTOM_SIDE=16$GDK_BOTTOM_TEE=18$GDK_BOX_SPIRAL=20$GDK_CENTER_PTR=22$GDK_CIRCLE=24$GDK_CLOCK=26$GDK_COFFEE_MUG=28$GDK_CROSS=30$GDK_CROSS_REVERSE=32$GDK_CROSSHAIR=34$GDK_DIAMOND_CROSS=36$GDK_DOT=38$GDK_DOTBOX=40$GDK_DOUBLE_ARROW=42$GDK_DRAFT_LARGE=44$GDK_DRAFT_SMALL=46$GDK_DRAPED_BOX=48$GDK_EXCHANGE=50$GDK_FLEUR=52$GDK_GOBBLER=54$GDK_GUMBY=56$GDK_HAND1=58$GDK_HAND2=60$GDK_HEART=62$GDK_ICON=64$GDK_IRON_CROSS=66$GDK_LEFT_PTR=68$GDK_LEFT_SIDE=70$GDK_LEFT_TEE=72$GDK_LEFTBUTTON=74$GDK_LL_ANGLE=76$GDK_LR_ANGLE=78$GDK_MAN=80$GDK_MIDDLEBUTTON=82$GDK_MOUSE=84$GDK_PENCIL=86$GDK_PIRATE=88$GDK_PLUS=90$GDK_QUESTION_ARROW=92$GDK_RIGHT_PTR=94$GDK_RIGHT_SIDE=96$GDK_RIGHT_TEE=98$GDK_RIGHTBUTTON=100$GDK_RTL_LOGO=102$GDK_SAILBOAT=104$GDK_SB_DOWN_ARROW=106$GDK_SB_H_DOUBLE_ARROW=108$GDK_SB_LEFT_ARROW=110$GDK_SB_RIGHT_ARROW=112$GDK_SB_UP_ARROW=114$GDK_SB_V_DOUBLE_ARROW=116$GDK_SHUTTLE=118$GDK_SIZING=120$GDK_SPIDER=122$GDK_SPRAYCAN=124$GDK_STAR=126$GDK_TARGET=128$GDK_TCROSS=130$GDK_TOP_LEFT_ARROW=132$GDK_TOP_LEFT_CORNER=134$GDK_TOP_RIGHT_CORNER=136$GDK_TOP_SIDE=138$GDK_TOP_TEE=140$GDK_TREK=142$GDK_UL_ANGLE=144$GDK_UMBRELLA=146$GDK_UR_ANGLE=148$GDK_WATCH=150$GDK_XTERM=152$GDK_LAST_CURSOR=153$GDK_BLANK_CURSOR=-2$GDK_CURSOR_IS_PIXMAP=-1
// file /usr/include/gtk-2.0/gdk/gdkcursor.h line 43
enum anonymous$37 { GDK_X_CURSOR=0, GDK_ARROW=2, GDK_BASED_ARROW_DOWN=4, GDK_BASED_ARROW_UP=6, GDK_BOAT=8, GDK_BOGOSITY=10, GDK_BOTTOM_LEFT_CORNER=12, GDK_BOTTOM_RIGHT_CORNER=14, GDK_BOTTOM_SIDE=16, GDK_BOTTOM_TEE=18, GDK_BOX_SPIRAL=20, GDK_CENTER_PTR=22, GDK_CIRCLE=24, GDK_CLOCK=26, GDK_COFFEE_MUG=28, GDK_CROSS=30, GDK_CROSS_REVERSE=32, GDK_CROSSHAIR=34, GDK_DIAMOND_CROSS=36, GDK_DOT=38, GDK_DOTBOX=40, GDK_DOUBLE_ARROW=42, GDK_DRAFT_LARGE=44, GDK_DRAFT_SMALL=46, GDK_DRAPED_BOX=48, GDK_EXCHANGE=50, GDK_FLEUR=52, GDK_GOBBLER=54, GDK_GUMBY=56, GDK_HAND1=58, GDK_HAND2=60, GDK_HEART=62, GDK_ICON=64, GDK_IRON_CROSS=66, GDK_LEFT_PTR=68, GDK_LEFT_SIDE=70, GDK_LEFT_TEE=72, GDK_LEFTBUTTON=74, GDK_LL_ANGLE=76, GDK_LR_ANGLE=78, GDK_MAN=80, GDK_MIDDLEBUTTON=82, GDK_MOUSE=84, GDK_PENCIL=86, GDK_PIRATE=88, GDK_PLUS=90, GDK_QUESTION_ARROW=92, GDK_RIGHT_PTR=94, GDK_RIGHT_SIDE=96, GDK_RIGHT_TEE=98, GDK_RIGHTBUTTON=100, GDK_RTL_LOGO=102, GDK_SAILBOAT=104, GDK_SB_DOWN_ARROW=106, GDK_SB_H_DOUBLE_ARROW=108, GDK_SB_LEFT_ARROW=110, GDK_SB_RIGHT_ARROW=112, GDK_SB_UP_ARROW=114, GDK_SB_V_DOUBLE_ARROW=116, GDK_SHUTTLE=118, GDK_SIZING=120, GDK_SPIDER=122, GDK_SPRAYCAN=124, GDK_STAR=126, GDK_TARGET=128, GDK_TCROSS=130, GDK_TOP_LEFT_ARROW=132, GDK_TOP_LEFT_CORNER=134, GDK_TOP_RIGHT_CORNER=136, GDK_TOP_SIDE=138, GDK_TOP_TEE=140, GDK_TREK=142, GDK_UL_ANGLE=144, GDK_UMBRELLA=146, GDK_UR_ANGLE=148, GDK_WATCH=150, GDK_XTERM=152, GDK_LAST_CURSOR=153, GDK_BLANK_CURSOR=-2, GDK_CURSOR_IS_PIXMAP=-1 };

// #anon_enum$GTK_BUTTONS_NONE=0$GTK_BUTTONS_OK=1$GTK_BUTTONS_CLOSE=2$GTK_BUTTONS_CANCEL=3$GTK_BUTTONS_YES_NO=4$GTK_BUTTONS_OK_CANCEL=5
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 89
enum anonymous$42 { GTK_BUTTONS_NONE=0, GTK_BUTTONS_OK=1, GTK_BUTTONS_CLOSE=2, GTK_BUTTONS_CANCEL=3, GTK_BUTTONS_YES_NO=4, GTK_BUTTONS_OK_CANCEL=5 };

// #anon_enum$GTK_CLIST_DRAG_NONE=0$GTK_CLIST_DRAG_BEFORE=1$GTK_CLIST_DRAG_INTO=2$GTK_CLIST_DRAG_AFTER=3
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 70
enum anonymous$27 { GTK_CLIST_DRAG_NONE=0, GTK_CLIST_DRAG_BEFORE=1, GTK_CLIST_DRAG_INTO=2, GTK_CLIST_DRAG_AFTER=3 };

// #anon_enum$GTK_DIALOG_MODAL=1$GTK_DIALOG_DESTROY_WITH_PARENT=2$GTK_DIALOG_NO_SEPARATOR=4
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 41
enum anonymous$40 { GTK_DIALOG_MODAL=1, GTK_DIALOG_DESTROY_WITH_PARENT=2, GTK_DIALOG_NO_SEPARATOR=4 };

// #anon_enum$GTK_EXPAND=1$GTK_SHRINK=2$GTK_FILL=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 79
enum anonymous$16 { GTK_EXPAND=1, GTK_SHRINK=2, GTK_FILL=4 };

// #anon_enum$GTK_ICON_SIZE_INVALID=0$GTK_ICON_SIZE_MENU=1$GTK_ICON_SIZE_SMALL_TOOLBAR=2$GTK_ICON_SIZE_LARGE_TOOLBAR=3$GTK_ICON_SIZE_BUTTON=4$GTK_ICON_SIZE_DND=5$GTK_ICON_SIZE_DIALOG=6
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 142
enum anonymous$22 { GTK_ICON_SIZE_INVALID=0, GTK_ICON_SIZE_MENU=1, GTK_ICON_SIZE_SMALL_TOOLBAR=2, GTK_ICON_SIZE_LARGE_TOOLBAR=3, GTK_ICON_SIZE_BUTTON=4, GTK_ICON_SIZE_DND=5, GTK_ICON_SIZE_DIALOG=6 };

// #anon_enum$GTK_IMAGE_EMPTY=0$GTK_IMAGE_PIXMAP=1$GTK_IMAGE_IMAGE=2$GTK_IMAGE_PIXBUF=3$GTK_IMAGE_STOCK=4$GTK_IMAGE_ICON_SET=5$GTK_IMAGE_ANIMATION=6$GTK_IMAGE_ICON_NAME=7$GTK_IMAGE_GICON=8
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 129
enum anonymous$20 { GTK_IMAGE_EMPTY=0, GTK_IMAGE_PIXMAP=1, GTK_IMAGE_IMAGE=2, GTK_IMAGE_PIXBUF=3, GTK_IMAGE_STOCK=4, GTK_IMAGE_ICON_SET=5, GTK_IMAGE_ANIMATION=6, GTK_IMAGE_ICON_NAME=7, GTK_IMAGE_GICON=8 };

// #anon_enum$GTK_JUSTIFY_LEFT=0$GTK_JUSTIFY_RIGHT=1$GTK_JUSTIFY_CENTER=2$GTK_JUSTIFY_FILL=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 181
enum anonymous$43 { GTK_JUSTIFY_LEFT=0, GTK_JUSTIFY_RIGHT=1, GTK_JUSTIFY_CENTER=2, GTK_JUSTIFY_FILL=3 };

// #anon_enum$GTK_MESSAGE_INFO=0$GTK_MESSAGE_WARNING=1$GTK_MESSAGE_QUESTION=2$GTK_MESSAGE_ERROR=3$GTK_MESSAGE_OTHER=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 221
enum anonymous$41 { GTK_MESSAGE_INFO=0, GTK_MESSAGE_WARNING=1, GTK_MESSAGE_QUESTION=2, GTK_MESSAGE_ERROR=3, GTK_MESSAGE_OTHER=4 };

// #anon_enum$GTK_POLICY_ALWAYS=0$GTK_POLICY_AUTOMATIC=1$GTK_POLICY_NEVER=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 305
enum anonymous$17 { GTK_POLICY_ALWAYS=0, GTK_POLICY_AUTOMATIC=1, GTK_POLICY_NEVER=2 };

// #anon_enum$GTK_PROGRESS_CONTINUOUS=0$GTK_PROGRESS_DISCRETE=1
// file /usr/include/gtk-2.0/gtk/gtkprogressbar.h line 51
enum anonymous$69 { GTK_PROGRESS_CONTINUOUS=0, GTK_PROGRESS_DISCRETE=1 };

// #anon_enum$GTK_PROGRESS_LEFT_TO_RIGHT=0$GTK_PROGRESS_RIGHT_TO_LEFT=1$GTK_PROGRESS_BOTTOM_TO_TOP=2$GTK_PROGRESS_TOP_TO_BOTTOM=3
// file /usr/include/gtk-2.0/gtk/gtkprogressbar.h line 57
enum anonymous$70 { GTK_PROGRESS_LEFT_TO_RIGHT=0, GTK_PROGRESS_RIGHT_TO_LEFT=1, GTK_PROGRESS_BOTTOM_TO_TOP=2, GTK_PROGRESS_TOP_TO_BOTTOM=3 };

// #anon_enum$GTK_RC_FG=1$GTK_RC_BG=2$GTK_RC_TEXT=4$GTK_RC_BASE=8
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 52
enum anonymous$28 { GTK_RC_FG=1, GTK_RC_BG=2, GTK_RC_TEXT=4, GTK_RC_BASE=8 };

// #anon_enum$GTK_SELECTION_NONE=0$GTK_SELECTION_SINGLE=1$GTK_SELECTION_BROWSE=2$GTK_SELECTION_MULTIPLE=3$GTK_SELECTION_EXTENDED=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 379
enum anonymous$24 { GTK_SELECTION_NONE=0, GTK_SELECTION_SINGLE=1, GTK_SELECTION_BROWSE=2, GTK_SELECTION_MULTIPLE=3, GTK_SELECTION_EXTENDED=3 };

// #anon_enum$GTK_SHADOW_NONE=0$GTK_SHADOW_IN=1$GTK_SHADOW_OUT=2$GTK_SHADOW_ETCHED_IN=3$GTK_SHADOW_ETCHED_OUT=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 389
enum anonymous$23 { GTK_SHADOW_NONE=0, GTK_SHADOW_IN=1, GTK_SHADOW_OUT=2, GTK_SHADOW_ETCHED_IN=3, GTK_SHADOW_ETCHED_OUT=4 };

// #anon_enum$GTK_SORT_ASCENDING=0$GTK_SORT_DESCENDING=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 476
enum anonymous$26 { GTK_SORT_ASCENDING=0, GTK_SORT_DESCENDING=1 };

// #anon_enum$GTK_STATE_NORMAL=0$GTK_STATE_ACTIVE=1$GTK_STATE_PRELIGHT=2$GTK_STATE_SELECTED=3$GTK_STATE_INSENSITIVE=4
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 399
enum anonymous$25 { GTK_STATE_NORMAL=0, GTK_STATE_ACTIVE=1, GTK_STATE_PRELIGHT=2, GTK_STATE_SELECTED=3, GTK_STATE_INSENSITIVE=4 };

// #anon_enum$GTK_TEXT_DIR_NONE=0$GTK_TEXT_DIR_LTR=1$GTK_TEXT_DIR_RTL=2
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 173
enum anonymous$44 { GTK_TEXT_DIR_NONE=0, GTK_TEXT_DIR_LTR=1, GTK_TEXT_DIR_RTL=2 };

// #anon_enum$GTK_TREE_VIEW_COLUMN_GROW_ONLY=0$GTK_TREE_VIEW_COLUMN_AUTOSIZE=1$GTK_TREE_VIEW_COLUMN_FIXED=2
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 45
enum anonymous$18 { GTK_TREE_VIEW_COLUMN_GROW_ONLY=0, GTK_TREE_VIEW_COLUMN_AUTOSIZE=1, GTK_TREE_VIEW_COLUMN_FIXED=2 };

// #anon_enum$GTK_UPDATE_ALWAYS=0$GTK_UPDATE_IF_VALID=1
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 53
enum anonymous$62 { GTK_UPDATE_ALWAYS=0, GTK_UPDATE_IF_VALID=1 };

// #anon_enum$GTK_WINDOW_TOPLEVEL=0$GTK_WINDOW_POPUP=1
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 460
enum anonymous$67 { GTK_WINDOW_TOPLEVEL=0, GTK_WINDOW_POPUP=1 };

// #anon_enum$GTK_WRAP_NONE=0$GTK_WRAP_CHAR=1$GTK_WRAP_WORD=2$GTK_WRAP_WORD_CHAR=3
// file /usr/include/gtk-2.0/gtk/gtkenums.h line 467
enum anonymous$45 { GTK_WRAP_NONE=0, GTK_WRAP_CHAR=1, GTK_WRAP_WORD=2, GTK_WRAP_WORD_CHAR=3 };

// #anon_enum$G_CONNECT_AFTER=1$G_CONNECT_SWAPPED=2
// file /usr/include/glib-2.0/gobject/gsignal.h line 155
enum anonymous$36 { G_CONNECT_AFTER=1, G_CONNECT_SWAPPED=2 };

// #anon_enum$G_LOG_FLAG_RECURSION=1$G_LOG_FLAG_FATAL=2$G_LOG_LEVEL_ERROR=4$G_LOG_LEVEL_CRITICAL=8$G_LOG_LEVEL_WARNING=16$G_LOG_LEVEL_MESSAGE=32$G_LOG_LEVEL_INFO=64$G_LOG_LEVEL_DEBUG=128$G_LOG_LEVEL_MASK=-4
// file /usr/include/glib-2.0/glib/gmessages.h line 51
enum anonymous$52 { G_LOG_FLAG_RECURSION=1, G_LOG_FLAG_FATAL=2, G_LOG_LEVEL_ERROR=4, G_LOG_LEVEL_CRITICAL=8, G_LOG_LEVEL_WARNING=16, G_LOG_LEVEL_MESSAGE=32, G_LOG_LEVEL_INFO=64, G_LOG_LEVEL_DEBUG=128, G_LOG_LEVEL_MASK=-4 };

// #anon_enum$G_SIGNAL_MATCH_ID=1$G_SIGNAL_MATCH_DETAIL=2$G_SIGNAL_MATCH_CLOSURE=4$G_SIGNAL_MATCH_FUNC=8$G_SIGNAL_MATCH_DATA=16$G_SIGNAL_MATCH_UNBLOCKED=32
// file /usr/include/glib-2.0/gobject/gsignal.h line 173
enum anonymous$7 { G_SIGNAL_MATCH_ID=1, G_SIGNAL_MATCH_DETAIL=2, G_SIGNAL_MATCH_CLOSURE=4, G_SIGNAL_MATCH_FUNC=8, G_SIGNAL_MATCH_DATA=16, G_SIGNAL_MATCH_UNBLOCKED=32 };

// tag-#anon#ST[*{S8}$S8$'name'||U32'checksum'||U32'$pad0'||*{U8}$U8$'png_data'||U32'width'||U32'height'|]
// file image.c line 57
struct anonymous$68;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visual'||U64'visualid'||S32'screen'||S32'depth'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'colormap_size'||S32'bits_per_rgb'|]
// file /usr/include/X11/Xutil.h line 287
struct anonymous$59;

// tag-#anon#ST[*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'menuitem'||U32'pickup_mode'||U32'$pad0'|]
// file pickup.c line 32
struct anonymous$61;

// tag-#anon#ST[*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'playername'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'Str'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'Dex'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'Con'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'Int'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'Wis'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'Cha'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'Pow'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'wc'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'dam'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'ac'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'armor'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'speed'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'weapon_speed'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'range'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'exp'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'level'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'table_skills_exp'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'table_protections'||ARR102{*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$}$*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$$'skill_exp'||ARR36{*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$}$*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$$'resists'|]
// file stats.c line 79
struct anonymous$71;

// tag-#anon#ST[*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'ptr'||S32'state'||U32'$pad0'|]
// file info.c line 194
struct anonymous$72;

// tag-#anon#ST[*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'ptr'||U32'state'||cU32'default_state'|]
// file info.c line 165
struct anonymous$74;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]
// file /usr/include/X11/Xlib.h line 257
struct anonymous$57;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private1'||S32'fd'||S32'private2'||S32'proto_major_version'||S32'proto_minor_version'||*{S8}$S8$'vendor'||U64'private3'||U64'private4'||U64'private5'||S32'private6'||U32'$pad0'||*{U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64}$U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64$'resource_alloc'||S32'byte_order'||S32'bitmap_unit'||S32'bitmap_pad'||S32'bitmap_bit_order'||S32'nformats'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#$'pixmap_format'||S32'private8'||S32'release'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private9'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private10'||S32'qlen'||U32'$pad2'||U64'last_request_read'||U64'request'||*{S8}$S8$'private11'||*{S8}$S8$'private12'||*{S8}$S8$'private13'||*{S8}$S8$'private14'||U32'max_request_size'||U32'$pad3'||*{SYM#tag-_XrmHashBucketRec#}$SYM#tag-_XrmHashBucketRec#$'db'||*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32$'private15'||*{S8}$S8$'display_name'||S32'default_screen'||S32'nscreens'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#$'screens'||U64'motion_buffer'||U64'private16'||S32'min_keycode'||S32'max_keycode'||*{S8}$S8$'private17'||*{S8}$S8$'private18'||S32'private19'||U32'$pad4'||*{S8}$S8$'xdefaults'|]
// file /usr/include/X11/Xlib.h line 493
struct anonymous$58;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]
// file /usr/include/X11/Xlib.h line 280
struct anonymous$54;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]
// file /usr/include/X11/Xlib.h line 227
struct anonymous$56;

// tag-#anon#ST[*{cS8}$cS8$'name'||*{cS8}$cS8$'tooltip'||*{c*{cS8}$cS8$}$c*{cS8}$cS8$$'xpm'||*{S32(*{SYM#tag-item_struct#}$SYM#tag-item_struct#$)->S32}$S32(*{SYM#tag-item_struct#}$SYM#tag-item_struct#$)->S32$'show_func'||S32'type'||U32'$pad0'||*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'treeview'||*{SYM#tag-_GtkTreeStore#}$SYM#tag-_GtkTreeStore#$'treestore'|]
// file inventory.c line 89
struct anonymous$19;

// tag-#anon#ST[*{cS8}$cS8$'name'||EN#anon_enum$COMM_CAT_MISC=0$COMM_CAT_HELP=1$COMM_CAT_INFO=2$COMM_CAT_SETUP=3$COMM_CAT_SCRIPT=4$COMM_CAT_DEBUG=5#{U32}$U32$'cat'||U32'$pad0'||*{V(*{cS8}$cS8$)->V}$V(*{cS8}$cS8$)->V$'dofunc'||*{*{cS8}$cS8$()->*{cS8}$cS8$}$*{cS8}$cS8$()->*{cS8}$cS8$$'helpfunc'||*{cS8}$cS8$'desc'|]
// file ./p_cmd.h line 57
struct anonymous$47;

// tag-#anon#ST[*{cS8}$cS8$'name'||S32'value'||U32'$pad0'|]
// file ../../common/client.h line 432
struct anonymous$66;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$51;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$64;

// tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]
// file /usr/include/X11/Xlib.h line 243
struct anonymous$55;

// tag-#anon#ST[SYM#tag-#anon#ST[*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'ptr'||S32'state'||U32'$pad0'|]#'buffer'||ARR2{SYM#tag-#anon#ST[*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'ptr'||S32'state'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_GtkWidget#}$SYM#tag-_GtkWidget#$'ptr'||S32'state'||U32'$pad0'|]#$'pane'|]
// file info.c line 205
struct anonymous$73;

// tag-#anon#ST[U64'background_pixmap'||U64'background_pixel'||U64'border_pixmap'||U64'border_pixel'||S32'bit_gravity'||S32'win_gravity'||S32'backing_store'||U32'$pad0'||U64'backing_planes'||U64'backing_pixel'||S32'save_under'||U32'$pad1'||S64'event_mask'||S64'do_not_propagate_mask'||S32'override_redirect'||U32'$pad2'||U64'colormap'||U64'cursor'|]
// file /usr/include/X11/Xlib.h line 290
struct anonymous$60;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$75;

// tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 445
union anonymous$14;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$38;

// tag-#anon#UN[S32'v_int'||U32'v_uint'||S64'v_long'||U64'v_ulong'||S64'v_int64'||U64'v_uint64'||F32'v_float'||F64'v_double'||*{V}$V$'v_pointer'|]
// file /usr/include/glib-2.0/gobject/gvalue.h line 112
union anonymous$31;

// tag-#anon#UN[SYM#tag-_GtkImagePixmapData#'pixmap'||SYM#tag-_GtkImageImageData#'image'||SYM#tag-_GtkImagePixbufData#'pixbuf'||SYM#tag-_GtkImageStockData#'stock'||SYM#tag-_GtkImageIconSetData#'icon_set'||SYM#tag-_GtkImageAnimationData#'anim'||SYM#tag-_GtkImageIconNameData#'name'||SYM#tag-_GtkImageGIconData#'gicon'|]
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 154
union anonymous$21;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$39;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$76;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$48;

// tag-Animations
// file ../../common/client.h line 48
struct Animations;

// tag-BigCell
// file mapdata.c line 79
struct BigCell;

// tag-Cache_Entry
// file ../../common/client.h line 479
struct Cache_Entry;

// tag-ChildProcess
// file ../../common/client.h line 405
struct ChildProcess;

// tag-ClientSocket
// file ../../common/client.h line 76
struct ClientSocket;

// tag-CmdFormat
// file ./script.h line 43
enum CmdFormat { ASCII=0, SHORT_ARRAY=1, INT_ARRAY=2, SHORT_INT=3, MIXED=4, STATS=5, NODATA=6 };

// tag-CmdMapping
// file client.c line 87
struct CmdMapping;

// tag-FD_Cache
// file image.c line 39
struct FD_Cache;

// tag-FaceSets_struct
// file ../../common/client.h line 349
struct FaceSets_struct;

// tag-Face_Information_struct
// file ../../common/client.h line 363
struct Face_Information_struct;

// tag-Image_Cache
// file image.c line 179
struct Image_Cache;

// tag-Info_Pane
// file info.h line 55
struct Info_Pane;

// tag-Input_State
// file ../../common/client.h line 97
enum Input_State { Playing=0, Reply_One=1, Reply_Many=2, Configure_Keys=3, Command_Mode=4, Metaserver_Select=5 };

// tag-LogLevel
// file ../../common/client.h line 390
enum LogLevel { LOG_DEBUG=0, LOG_INFO=1, LOG_WARNING=2, LOG_ERROR=3, LOG_CRITICAL=4 };

// tag-Map
// file ../../common/mapdata.h line 91
struct Map;

// tag-MapCell
// file ../../common/mapdata.h line 79
struct MapCell;

// tag-MapCellLayer
// file ../../common/mapdata.h line 48
struct MapCellLayer;

// tag-Meta_Info
// file ../../common/metaserver.h line 50
struct Meta_Info;

// tag-Msg_Type_Names
// file ../../common/client.h line 511
struct Msg_Type_Names;

// tag-PipeLog
// file ../../common/client.h line 394
struct PipeLog;

// tag-PixmapInfo
// file image.h line 47
struct PixmapInfo;

// tag-PlayerPosition
// file ../../common/client.h line 504
struct PlayerPosition;

// tag-Player_Struct
// file ../../common/client.h line 291
struct Player_Struct;

// tag-RC_Choice
// file ../../common/client.h line 565
struct RC_Choice;

// tag-Race_Class_Info
// file ../../common/client.h line 573
struct Race_Class_Info;

// tag-SDL_BlitMap
// file /usr/include/SDL/SDL_video.h line 115
struct SDL_BlitMap;

// tag-SDL_Color
// file /usr/include/SDL/SDL_video.h line 55
struct SDL_Color;

// tag-SDL_Palette
// file /usr/include/SDL/SDL_video.h line 63
struct SDL_Palette;

// tag-SDL_PixelFormat
// file /usr/include/SDL/SDL_video.h line 70
struct SDL_PixelFormat;

// tag-SDL_Rect
// file /usr/include/SDL/SDL_video.h line 50
struct SDL_Rect;

// tag-SDL_Surface
// file /usr/include/SDL/SDL_video.h line 96
struct SDL_Surface;

// tag-SockList
// file ../../common/shared/newclient.h line 675
struct SockList;

// tag-Spell_struct
// file ../../common/client.h line 250
struct Spell_struct;

// tag-Starting_Map_Info
// file ../../common/client.h line 582
struct Starting_Map_Info;

// tag-Stat_Mapping
// file ../../common/client.h line 548
struct Stat_Mapping;

// tag-Stat_struct
// file ../../common/client.h line 207
struct Stat_struct;

// tag-TextManager
// file ./client-types.h line 144
struct TextManager;

// tag-_GArray
// file /usr/include/glib-2.0/glib/garray.h line 37
struct _GArray;

// tag-_GClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 74
struct _GClosure;

// tag-_GClosureNotifyData
// file /usr/include/glib-2.0/gobject/gclosure.h line 75
struct _GClosureNotifyData;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GError
// file /usr/include/glib-2.0/glib/gerror.h line 42
struct _GError;

// tag-_GHashTable
// file /usr/include/glib-2.0/glib/ghash.h line 37
struct _GHashTable;

// tag-_GIcon
// file /usr/include/glib-2.0/gio/giotypes.h line 102
struct _GIcon;

// tag-_GList
// file /usr/include/glib-2.0/glib/glist.h line 37
struct _GList;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GSList
// file /usr/include/glib-2.0/glib/gslist.h line 37
struct _GSList;

// tag-_GTimeVal
// file /usr/include/glib-2.0/glib/gtypes.h line 449
struct _GTimeVal;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_GValue
// file /usr/include/glib-2.0/gobject/gtype.h line 386
struct _GValue;

// tag-_GdkAtom
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 80
struct _GdkAtom;

// tag-_GdkColor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 102
struct _GdkColor;

// tag-_GdkColormap
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 103
struct _GdkColormap;

// tag-_GdkCursor
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 104
struct _GdkCursor;

// tag-_GdkDevice
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 47
struct _GdkDevice;

// tag-_GdkDeviceAxis
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 46
struct _GdkDeviceAxis;

// tag-_GdkDeviceKey
// file /usr/include/gtk-2.0/gdk/gdkinput.h line 45
struct _GdkDeviceKey;

// tag-_GdkDragContext
// file /usr/include/gtk-2.0/gdk/gdkdnd.h line 38
struct _GdkDragContext;

// tag-_GdkDrawable
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 111
struct _GdkDrawable;

// tag-_GdkEvent
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 68
union _GdkEvent;

// tag-_GdkEventAny
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 47
struct _GdkEventAny;

// tag-_GdkEventButton
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 52
struct _GdkEventButton;

// tag-_GdkEventClient
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 62
struct _GdkEventClient;

// tag-_GdkEventConfigure
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 57
struct _GdkEventConfigure;

// tag-_GdkEventCrossing
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 56
struct _GdkEventCrossing;

// tag-_GdkEventDND
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 63
struct _GdkEventDND;

// tag-_GdkEventExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 48
struct _GdkEventExpose;

// tag-_GdkEventFocus
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 55
struct _GdkEventFocus;

// tag-_GdkEventGrabBroken
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 66
struct _GdkEventGrabBroken;

// tag-_GdkEventKey
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 54
struct _GdkEventKey;

// tag-_GdkEventMotion
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 51
struct _GdkEventMotion;

// tag-_GdkEventNoExpose
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 49
struct _GdkEventNoExpose;

// tag-_GdkEventOwnerChange
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 60
struct _GdkEventOwnerChange;

// tag-_GdkEventProperty
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 58
struct _GdkEventProperty;

// tag-_GdkEventProximity
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 61
struct _GdkEventProximity;

// tag-_GdkEventScroll
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 53
struct _GdkEventScroll;

// tag-_GdkEventSelection
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 59
struct _GdkEventSelection;

// tag-_GdkEventSetting
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 65
struct _GdkEventSetting;

// tag-_GdkEventVisibility
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 50
struct _GdkEventVisibility;

// tag-_GdkEventWindowState
// file /usr/include/gtk-2.0/gdk/gdkevents.h line 64
struct _GdkEventWindowState;

// tag-_GdkFont
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 105
struct _GdkFont;

// tag-_GdkGC
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 106
struct _GdkGC;

// tag-_GdkGeometry
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 40
struct _GdkGeometry;

// tag-_GdkImage
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 107
struct _GdkImage;

// tag-_GdkPixbuf
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 155
struct _GdkPixbuf;

// tag-_GdkPixbufAnimation
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-animation.h line 44
struct _GdkPixbufAnimation;

// tag-_GdkPixbufAnimationIter
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-animation.h line 53
struct _GdkPixbufAnimationIter;

// tag-_GdkRectangle
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 69
struct _GdkRectangle;

// tag-_GdkRegion
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 108
struct _GdkRegion;

// tag-_GdkScreen
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 116
struct _GdkScreen;

// tag-_GdkVisual
// file /usr/include/gtk-2.0/gdk/gdktypes.h line 109
struct _GdkVisual;

// tag-_GtkAdjustment
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 48
struct _GtkAdjustment;

// tag-_GtkBin
// file /usr/include/gtk-2.0/gtk/gtkbin.h line 48
struct _GtkBin;

// tag-_GtkBox
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 49
struct _GtkBox;

// tag-_GtkBuildable
// file /usr/include/gtk-2.0/gtk/gtkbuildable.h line 40
struct _GtkBuildable;

// tag-_GtkBuilder
// file /usr/include/gtk-2.0/gtk/gtkbuilder.h line 42
struct _GtkBuilder;

// tag-_GtkBuilderPrivate
// file /usr/include/gtk-2.0/gtk/gtkbuilder.h line 44
struct _GtkBuilderPrivate;

// tag-_GtkButton
// file /usr/include/gtk-2.0/gtk/gtkbutton.h line 48
struct _GtkButton;

// tag-_GtkCList
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 117
struct _GtkCList;

// tag-_GtkCListCellInfo
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 132
struct _GtkCListCellInfo;

// tag-_GtkCListColumn
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 119
struct _GtkCListColumn;

// tag-_GtkCellEditable
// file /usr/include/gtk-2.0/gtk/gtkcelleditable.h line 37
struct _GtkCellEditable;

// tag-_GtkCellLayout
// file /usr/include/gtk-2.0/gtk/gtkcelllayout.h line 39
struct _GtkCellLayout;

// tag-_GtkCellRenderer
// file /usr/include/gtk-2.0/gtk/gtkcellrenderer.h line 55
struct _GtkCellRenderer;

// tag-_GtkCheckButton
// file /usr/include/gtk-2.0/gtk/gtkcheckbutton.h line 48
struct _GtkCheckButton;

// tag-_GtkCheckMenuItem
// file /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h line 48
struct _GtkCheckMenuItem;

// tag-_GtkComboBox
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 40
struct _GtkComboBox;

// tag-_GtkComboBoxPrivate
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 42
struct _GtkComboBoxPrivate;

// tag-_GtkContainer
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 51
struct _GtkContainer;

// tag-_GtkDialog
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 94
struct _GtkDialog;

// tag-_GtkDrawingArea
// file /usr/include/gtk-2.0/gtk/gtkdrawingarea.h line 48
struct _GtkDrawingArea;

// tag-_GtkEditable
// file /usr/include/gtk-2.0/gtk/gtkeditable.h line 47
struct _GtkEditable;

// tag-_GtkEntry
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 63
struct _GtkEntry;

// tag-_GtkIMContext
// file /usr/include/gtk-2.0/gtk/gtkimcontext.h line 42
struct _GtkIMContext;

// tag-_GtkIconSet
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 58
struct _GtkIconSet;

// tag-_GtkImage
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 49
struct _GtkImage;

// tag-_GtkImageAnimationData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 57
struct _GtkImageAnimationData;

// tag-_GtkImageGIconData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 59
struct _GtkImageGIconData;

// tag-_GtkImageIconNameData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 58
struct _GtkImageIconNameData;

// tag-_GtkImageIconSetData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 56
struct _GtkImageIconSetData;

// tag-_GtkImageImageData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 53
struct _GtkImageImageData;

// tag-_GtkImagePixbufData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 54
struct _GtkImagePixbufData;

// tag-_GtkImagePixmapData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 52
struct _GtkImagePixmapData;

// tag-_GtkImageStockData
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 55
struct _GtkImageStockData;

// tag-_GtkItem
// file /usr/include/gtk-2.0/gtk/gtkitem.h line 48
struct _GtkItem;

// tag-_GtkLabel
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 49
struct _GtkLabel;

// tag-_GtkLabelSelectionInfo
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 52
struct _GtkLabelSelectionInfo;

// tag-_GtkListStore
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 42
struct _GtkListStore;

// tag-_GtkMenuItem
// file /usr/include/gtk-2.0/gtk/gtkmenuitem.h line 48
struct _GtkMenuItem;

// tag-_GtkMessageDialog
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 47
struct _GtkMessageDialog;

// tag-_GtkMisc
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 48
struct _GtkMisc;

// tag-_GtkNotebook
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 55
struct _GtkNotebook;

// tag-_GtkNotebookPage
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 58
struct _GtkNotebookPage;

// tag-_GtkObject
// file /usr/include/gtk-2.0/gtk/gtktypeutils.h line 49
struct _GtkObject;

// tag-_GtkPaned
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 46
struct _GtkPaned;

// tag-_GtkPanedPrivate
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 48
struct _GtkPanedPrivate;

// tag-_GtkProgress
// file /usr/include/gtk-2.0/gtk/gtkprogress.h line 48
struct _GtkProgress;

// tag-_GtkProgressBar
// file /usr/include/gtk-2.0/gtk/gtkprogressbar.h line 48
struct _GtkProgressBar;

// tag-_GtkRcContext
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 41
struct _GtkRcContext;

// tag-_GtkRcStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 57
struct _GtkRcStyle;

// tag-_GtkRequisition
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 478
struct _GtkRequisition;

// tag-_GtkScrolledWindow
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 52
struct _GtkScrolledWindow;

// tag-_GtkSettings
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 61
struct _GtkSettings;

// tag-_GtkSettingsPropertyValue
// file /usr/include/gtk-2.0/gtk/gtksettings.h line 43
struct _GtkSettingsPropertyValue;

// tag-_GtkSpinButton
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 71
struct _GtkSpinButton;

// tag-_GtkStyle
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 54
struct _GtkStyle;

// tag-_GtkTable
// file /usr/include/gtk-2.0/gtk/gtktable.h line 48
struct _GtkTable;

// tag-_GtkTableChild
// file /usr/include/gtk-2.0/gtk/gtktable.h line 50
struct _GtkTableChild;

// tag-_GtkTableRowCol
// file /usr/include/gtk-2.0/gtk/gtktable.h line 51
struct _GtkTableRowCol;

// tag-_GtkTextAppearance
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 170
struct _GtkTextAppearance;

// tag-_GtkTextAttributes
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 70
struct _GtkTextAttributes;

// tag-_GtkTextBTree
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 61
struct _GtkTextBTree;

// tag-_GtkTextBuffer
// file /usr/include/gtk-2.0/gtk/gtktextiter.h line 51
struct _GtkTextBuffer;

// tag-_GtkTextIter
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 67
struct _GtkTextIter;

// tag-_GtkTextLayout
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 72
struct _GtkTextLayout;

// tag-_GtkTextLogAttrCache
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 63
struct _GtkTextLogAttrCache;

// tag-_GtkTextMark
// file /usr/include/gtk-2.0/gtk/gtktextmark.h line 61
struct _GtkTextMark;

// tag-_GtkTextPendingScroll
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 66
struct _GtkTextPendingScroll;

// tag-_GtkTextTag
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 81
struct _GtkTextTag;

// tag-_GtkTextTagTable
// file /usr/include/gtk-2.0/gtk/gtktexttag.h line 68
struct _GtkTextTagTable;

// tag-_GtkTextView
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 61
struct _GtkTextView;

// tag-_GtkTextWindow
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 65
struct _GtkTextWindow;

// tag-_GtkToggleButton
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 48
struct _GtkToggleButton;

// tag-_GtkTooltips
// file /usr/include/gtk-2.0/gtk/gtktooltips.h line 46
struct _GtkTooltips;

// tag-_GtkTooltipsData
// file /usr/include/gtk-2.0/gtk/gtktooltips.h line 48
struct _GtkTooltipsData;

// tag-_GtkTreeIter
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 43
struct _GtkTreeIter;

// tag-_GtkTreeModel
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 46
struct _GtkTreeModel;

// tag-_GtkTreePath
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 44
struct _GtkTreePath;

// tag-_GtkTreeSelection
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 58
struct _GtkTreeSelection;

// tag-_GtkTreeSortable
// file /usr/include/gtk-2.0/gtk/gtktreesortable.h line 45
struct _GtkTreeSortable;

// tag-_GtkTreeStore
// file /usr/include/gtk-2.0/gtk/gtktreestore.h line 43
struct _GtkTreeStore;

// tag-_GtkTreeView
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 55
struct _GtkTreeView;

// tag-_GtkTreeViewColumn
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 52
struct _GtkTreeViewColumn;

// tag-_GtkTreeViewPrivate
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 57
struct _GtkTreeViewPrivate;

// tag-_GtkWidget
// file /usr/include/gtk-2.0/gtk/gtkstyle.h line 69
struct _GtkWidget;

// tag-_GtkWindow
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 485
struct _GtkWindow;

// tag-_GtkWindowGeometryInfo
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 50
struct _GtkWindowGeometryInfo;

// tag-_GtkWindowGroup
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 51
struct _GtkWindowGroup;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_PangoAttrList
// file /usr/include/pango-1.0/pango/pango-attributes.h line 111
struct _PangoAttrList;

// tag-_PangoFontDescription
// file /usr/include/pango-1.0/pango/pango-font.h line 40
struct _PangoFontDescription;

// tag-_PangoLanguage
// file /usr/include/pango-1.0/pango/pango-language.h line 30
struct _PangoLanguage;

// tag-_PangoLayout
// file /usr/include/pango-1.0/pango/pango-layout.h line 32
struct _PangoLayout;

// tag-_PangoTabArray
// file /usr/include/pango-1.0/pango/pango-tabs.h line 29
struct _PangoTabArray;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-__GLXcontextRec
// file /usr/include/GL/glx.h line 165
struct __GLXcontextRec;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_cairo_font_options
// file /usr/include/cairo/cairo.h line 1366
struct _cairo_font_options;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-buffer_control_t
// file info.c line 180
struct buffer_control_t;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-info_buffer_t
// file info.c line 134
struct info_buffer_t;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-item_struct
// file ../../common/item.h line 50
struct item_struct;

// tag-keybind
// file keys.c line 48
struct keybind;

// tag-lua_State
// file /usr/include/lua5.1/lua.h line 50
struct lua_State;

// tag-msgctrl_data_t
// file info.c line 231
struct msgctrl_data_t;

// tag-png_color_16_struct
// file /usr/include/libpng12/png.h line 436
struct png_color_16_struct;

// tag-png_color_8_struct
// file /usr/include/libpng12/png.h line 447
struct png_color_8_struct;

// tag-png_color_struct
// file /usr/include/libpng12/png.h line 427
struct png_color_struct;

// tag-png_info_struct
// file /usr/include/libpng12/png.h line 610
struct png_info_struct;

// tag-png_row_info_struct
// file /usr/include/libpng12/png.h line 953
struct png_row_info_struct;

// tag-png_sPLT_entry_struct
// file /usr/include/libpng12/png.h line 462
struct png_sPLT_entry_struct;

// tag-png_sPLT_struct
// file /usr/include/libpng12/png.h line 478
struct png_sPLT_struct;

// tag-png_struct_def
// file /usr/include/libpng12/png.h line 972
struct png_struct_def;

// tag-png_text_struct
// file /usr/include/libpng12/png.h line 497
struct png_text_struct;

// tag-png_time_struct
// file /usr/include/libpng12/png.h line 537
struct png_time_struct;

// tag-png_unknown_chunk_t
// file /usr/include/libpng12/png.h line 557
struct png_unknown_chunk_t;

// tag-private_hwdata
// file /usr/include/SDL/SDL_video.h line 105
struct private_hwdata;

// tag-protoent
// file /usr/include/netdb.h line 326
struct protoent;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-script
// file script.c line 124
struct script;

// tag-script_state
// file script_lua.c line 44
struct script_state;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// AccountPlayersCmd
// file ./proto.h line 41
void AccountPlayersCmd(char *buf, signed int len);
// AddMeFail
// file ./proto.h line 10
void AddMeFail(char *data, signed int len);
// AddMeSuccess
// file ./proto.h line 11
void AddMeSuccess(char *data, signed int len);
// AddspellCmd
// file ./proto.h line 28
void AddspellCmd(unsigned char *data, signed int len);
// AnimCmd
// file ./proto.h line 13
void AnimCmd(unsigned char *data, signed int len);
// CompleteCmd
// file ./proto.h line 149
void CompleteCmd(unsigned char *data, signed int len);
// DeleteInventory
// file ./proto.h line 27
void DeleteInventory(unsigned char *data, signed int len);
// DeleteItem
// file ./proto.h line 26
void DeleteItem(unsigned char *data, signed int len);
// DeleteSpell
// file ./proto.h line 30
void DeleteSpell(unsigned char *data, signed int len);
// DoClient
// file ../../common/proto.h line 2
void DoClient(struct ClientSocket *csocket);
// DrawExtInfoCmd
// file ./proto.h line 17
void DrawExtInfoCmd(char *data, signed int len);
// DrawExtInfoCmd::1::fnct$object
// 
void fnct$object(signed int, signed int, signed int, char *);
// DrawInfoCmd
// file ./proto.h line 15
void DrawInfoCmd(char *data, signed int len);
// ExtSmooth
// file commands.c line 2207
signed int ExtSmooth(unsigned char *data, signed int len, signed int x, signed int y, signed int layer);
// Face2Cmd
// file ./proto.h line 48
void Face2Cmd(unsigned char *data, signed int len);
// FailureCmd
// file ./proto.h line 40
void FailureCmd(char *buf, signed int len);
// GetChar_String
// file ./proto.h line 127
char GetChar_String(const unsigned char *data);
// GetInt64_String
// file ./proto.h line 129
signed long int GetInt64_String(const unsigned char *data);
// GetInt_String
// file ./proto.h line 128
signed int GetInt_String(const unsigned char *data);
// GetShort_String
// file ./proto.h line 130
signed short int GetShort_String(const unsigned char *data);
// GoodbyeCmd
// file ./proto.h line 12
void GoodbyeCmd(char *data, signed int len);
// Image2Cmd
// file ./proto.h line 49
void Image2Cmd(unsigned char *data, signed int len);
// Item2Cmd
// file ./proto.h line 24
void Item2Cmd(unsigned char *data, signed int len);
// LOG
// file ../../common/proto.h line 114
void LOG(enum LogLevel level, const char *origin, const char *format, ...);
// MagicMapCmd
// file ./proto.h line 36
void MagicMapCmd(unsigned char *data, signed int len);
// Map2Cmd
// file ./proto.h line 32
void Map2Cmd(unsigned char *data, signed int len);
// MapExtendedCmd
// file ./proto.h line 35
void MapExtendedCmd(unsigned char *data, signed int len);
// MusicCmd
// file sound.c line 237
void MusicCmd(const char *data, signed int len);
// NewmapCmd
// file ./proto.h line 31
void NewmapCmd(unsigned char *data, signed int len);
// PickupCmd
// file ./proto.h line 39
void PickupCmd(unsigned char *data, signed int len);
// PlayerCmd
// file ./proto.h line 22
void PlayerCmd(unsigned char *data, signed int len);
// ReplyInfoCmd
// file ./proto.h line 7
void ReplyInfoCmd(unsigned char *buf, signed int len);
// SDL_CreateRGBSurface
// file /usr/include/SDL/SDL_video.h line 553
extern struct SDL_Surface * SDL_CreateRGBSurface(unsigned int, signed int, signed int, signed int, unsigned int, unsigned int, unsigned int, unsigned int);
// SDL_CreateRGBSurfaceFrom
// file /usr/include/SDL/SDL_video.h line 557
extern struct SDL_Surface * SDL_CreateRGBSurfaceFrom(void *, signed int, signed int, signed int, signed int, unsigned int, unsigned int, unsigned int, unsigned int);
// SDL_DisplayFormatAlpha
// file /usr/include/SDL/SDL_video.h line 795
extern struct SDL_Surface * SDL_DisplayFormatAlpha(struct SDL_Surface *);
// SDL_FillRect
// file /usr/include/SDL/SDL_video.h line 767
extern signed int SDL_FillRect(struct SDL_Surface *, struct SDL_Rect *, unsigned int);
// SDL_Flip
// file /usr/include/SDL/SDL_video.h line 414
extern signed int SDL_Flip(struct SDL_Surface *);
// SDL_FreeSurface
// file /usr/include/SDL/SDL_video.h line 560
extern void SDL_FreeSurface(struct SDL_Surface *);
// SDL_GetError
// file /usr/include/SDL/SDL_error.h line 44
extern char * SDL_GetError(void);
// SDL_Init
// file /usr/include/SDL/SDL.h line 76
extern signed int SDL_Init(unsigned int);
// SDL_LockSurface
// file /usr/include/SDL/SDL_video.h line 580
extern signed int SDL_LockSurface(struct SDL_Surface *);
// SDL_MapRGB
// file /usr/include/SDL/SDL_video.h line 492
extern unsigned int SDL_MapRGB(const struct SDL_PixelFormat *, const unsigned char, const unsigned char, const unsigned char);
// SDL_MapRGBA
// file /usr/include/SDL/SDL_video.h line 499
extern unsigned int SDL_MapRGBA(const struct SDL_PixelFormat *, const unsigned char, const unsigned char, const unsigned char, const unsigned char);
// SDL_Quit
// file /usr/include/SDL/SDL.h line 93
extern void SDL_Quit(void);
// SDL_SetAlpha
// file /usr/include/SDL/SDL_video.h line 633
extern signed int SDL_SetAlpha(struct SDL_Surface *, unsigned int, unsigned char);
// SDL_SetVideoMode
// file /usr/include/SDL/SDL_video.h line 384
extern struct SDL_Surface * SDL_SetVideoMode(signed int, signed int, signed int, unsigned int);
// SDL_UnlockSurface
// file /usr/include/SDL/SDL_video.h line 581
extern void SDL_UnlockSurface(struct SDL_Surface *);
// SDL_UpperBlit
// file /usr/include/SDL/SDL_video.h line 748
extern signed int SDL_UpperBlit(struct SDL_Surface *, struct SDL_Rect *, struct SDL_Surface *, struct SDL_Rect *);
// SDL_WasInit
// file /usr/include/SDL/SDL.h line 88
extern unsigned int SDL_WasInit(unsigned int);
// SendAddMe
// file ./proto.h line 56
void SendAddMe(struct ClientSocket csock);
// SendVersion
// file ./proto.h line 55
void SendVersion(struct ClientSocket csock);
// SetupCmd
// file ./proto.h line 8
void SetupCmd(char *buf, signed int len);
// SinkCmd
// file ./proto.h line 37
void SinkCmd(unsigned char *data, signed int len);
// SmoothCmd
// file ./proto.h line 14
void SmoothCmd(unsigned char *data, signed int len);
// SockList_AddChar
// file ../../common/proto.h line 122
void SockList_AddChar(struct SockList *sl, char c);
// SockList_AddInt
// file ./proto.h line 124
void SockList_AddInt(struct SockList *sl, unsigned int data);
// SockList_AddShort
// file newsocket.c line 110
void SockList_AddShort(struct SockList *sl, unsigned short int data);
// SockList_AddString
// file ../../common/proto.h line 125
void SockList_AddString(struct SockList *sl, const char *str);
// SockList_Init
// file ../../common/proto.h line 121
void SockList_Init(struct SockList *sl, unsigned char *buf);
// SockList_ReadPacket
// file ./proto.h line 131
signed int SockList_ReadPacket(signed int fd, struct SockList *sl, signed int len);
// SockList_Send
// file ../../common/proto.h line 126
signed int SockList_Send(struct SockList *sl, signed int fd);
// Sound2Cmd
// file sound.c line 154
void Sound2Cmd(unsigned char *data, signed int len);
// StatsCmd
// file ./proto.h line 19
void StatsCmd(unsigned char *data, signed int len);
// TickCmd
// file ./proto.h line 38
void TickCmd(unsigned char *data, signed int len);
// UpdateItemCmd
// file ./proto.h line 25
void UpdateItemCmd(unsigned char *data, signed int len);
// UpdspellCmd
// file ./proto.h line 29
void UpdspellCmd(unsigned char *data, signed int len);
// VersionCmd
// file ./proto.h line 54
void VersionCmd(char *data, signed int len);
// XCreateColormap
// file /usr/include/X11/Xlib.h line 1552
extern unsigned long int XCreateColormap(struct _XDisplay *, unsigned long int, struct anonymous$56 *, signed int);
// XCreateWindow
// file /usr/include/X11/Xlib.h line 1636
extern unsigned long int XCreateWindow(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, unsigned int, signed int, unsigned int, struct anonymous$56 *, unsigned long int, struct anonymous$60 *);
// XMapWindow
// file /usr/include/X11/Xlib.h line 2806
extern signed int XMapWindow(struct _XDisplay *, unsigned long int);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _curl_easy_setopt_err_CURLSH
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH(void);
// _curl_easy_setopt_err_FILE
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE(void);
// _curl_easy_setopt_err_cb_data
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data(void);
// _curl_easy_setopt_err_conv_cb
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb(void);
// _curl_easy_setopt_err_curl_httpost
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost(void);
// _curl_easy_setopt_err_curl_off_t
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t(void);
// _curl_easy_setopt_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist(void);
// _curl_easy_setopt_err_debug_cb
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb(void);
// _curl_easy_setopt_err_error_buffer
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer(void);
// _curl_easy_setopt_err_ioctl_cb
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb(void);
// _curl_easy_setopt_err_long
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long(void);
// _curl_easy_setopt_err_opensocket_cb
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb(void);
// _curl_easy_setopt_err_postfields
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields(void);
// _curl_easy_setopt_err_progress_cb
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb(void);
// _curl_easy_setopt_err_read_cb
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb(void);
// _curl_easy_setopt_err_seek_cb
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb(void);
// _curl_easy_setopt_err_sockopt_cb
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb(void);
// _curl_easy_setopt_err_ssl_ctx_cb
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb(void);
// _curl_easy_setopt_err_string
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string(void);
// _curl_easy_setopt_err_write_callback
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback(void);
// _setjmp
// file /usr/include/setjmp.h line 63
extern signed int _setjmp(struct __jmp_buf_tag *);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// account_add_character_failure
// file account.c line 292
extern void account_add_character_failure(char *message);
// account_change_password_failure
// file account.c line 1256
void account_change_password_failure(char *message);
// account_creation_failure
// file account.c line 759
extern void account_creation_failure(char *message);
// account_login_failure
// file account.c line 944
extern void account_login_failure(char *message);
// add_character_to_account
// file account.c line 259
static void add_character_to_account(const char *name, const char *password, signed int force);
// add_item
// file item.c line 410
static void add_item(struct item_struct *env, struct item_struct *op);
// add_marked_text_to_pane
// file gtk2proto.h line 69
extern void add_marked_text_to_pane(struct Info_Pane *pane, const char *message, signed int type, signed int subtype, signed int orig_color);
// add_object_to_store
// file inventory.c line 718
static void add_object_to_store(struct item_struct *it, struct _GtkTreeStore *store, struct _GtkTreeIter *new, struct _GtkTreeIter *parent, signed int color);
// add_style_to_textbuffer
// file gtk2proto.h line 66
extern void add_style_to_textbuffer(struct Info_Pane *pane, struct _GtkStyle *base_style);
// add_tags_to_textbuffer
// file gtk2proto.h line 65
extern void add_tags_to_textbuffer(struct Info_Pane *pane, struct _GtkTextBuffer *textbuf);
// add_to_textbuf
// file info.c line 677
static void add_to_textbuf(struct Info_Pane *pane, const char *message, signed int type, signed int subtype, signed int bold, signed int italic, signed int font, const char *color, signed int underline);
// addsmooth
// file image.c line 434
extern void addsmooth(unsigned short int face, unsigned short int smooth_face);
// alloc_items
// file item.c line 246
static struct item_struct * alloc_items(signed int nrof);
// alphasort
// file /usr/include/dirent.h line 324
extern signed int alphasort(struct dirent **, struct dirent **);
// animate_inventory
// file inventory.c line 1163
extern void animate_inventory(void);
// animate_look
// file inventory.c line 1235
extern void animate_look(void);
// animate_objects
// file item.c line 712
void animate_objects(void);
// associate_cache_entry
// file image.c line 447
extern signed int associate_cache_entry(struct Cache_Entry *ce, signed int pixnum);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind_key
// file keys.c line 1088
extern void bind_key(char *params);
// bsearch
// file /usr/include/stdlib.h line 754
extern void * bsearch(const void *, const void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// cache_newpng
// file image.c line 575
static void cache_newpng(signed int face, unsigned char *buf, signed int buflen, signed int setnum, struct Cache_Entry **ce);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// can_write_spell_on
// file item.c line 778
extern signed int can_write_spell_on(struct item_struct *it);
// character_data_ok
// file create_char.c line 401
static signed int character_data_ok();
// check_server_version
// file ../../common/proto.h line 99
signed int check_server_version(signed int entry);
// choose_char_window_show
// file account.c line 457
extern void choose_char_window_show();
// choose_character_init
// file account.c line 440
extern void choose_character_init(void);
// cleanup_connection
// file main.c line 154
extern void cleanup_connection(void);
// clear_fire
// file ../../common/proto.h line 143
void clear_fire(void);
// clear_fire_run
// file player.c line 122
void clear_fire_run(void);
// clear_run
// file ../../common/proto.h line 144
void clear_run(void);
// clear_stat_mapping
// file gtk2proto.h line 269
extern void clear_stat_mapping(void);
// client_pickup
// file pickup.c line 633
extern void client_pickup(unsigned int pickup);
// client_send_apply
// file ../../common/proto.h line 137
void client_send_apply(signed int tag);
// client_send_examine
// file ../../common/proto.h line 138
void client_send_examine(signed int tag);
// client_send_move
// file ../../common/proto.h line 139
void client_send_move(signed int loc, signed int tag, signed int nrof);
// client_tick
// file main.c line 126
extern void client_tick(unsigned int tick);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_container
// file inventory.c line 595
extern void close_container(struct item_struct *op);
// close_server_connection
// file ../../common/proto.h line 6
void close_server_connection(void);
// command_foodbeep
// file p_cmd.c line 347
static void command_foodbeep(const char *cpnext);
// command_help
// file p_cmd.c line 269
static void command_help(const char *cpnext);
// command_show
// file inventory.c line 613
extern void command_show(const char *params);
// command_take
// file ./proto.h line 150
void command_take(const char *command, const char *cpnext);
// common_item_command
// file commands.c line 1649
static void common_item_command(unsigned char *data, signed int len);
// complete_command
// file ../../common/p_cmd.h line 103
extern const char * complete_command(const char *command);
// config_init
// file config.c line 491
extern void config_init(struct _GtkWidget *window_root);
// configure_keys
// file keys.c line 1367
static void configure_keys(unsigned int keysym);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous$48, unsigned int);
// create_and_rescale_image_from_data
// file image.c line 293
extern signed int create_and_rescale_image_from_data(struct Cache_Entry *ce, signed int pixmap_num, unsigned char *rgba_data, signed int width, signed int height);
// create_character_set_sensitive
// file create_char.c line 123
static void create_character_set_sensitive(signed int sensitive);
// create_character_window_hide
// file gtk2proto.h line 53
extern void create_character_window_hide();
// create_character_window_show
// file gtk2proto.h line 52
extern void create_character_window_show();
// create_icon_image
// file image.c line 122
static void create_icon_image(unsigned char *data, struct PixmapInfo *pi, signed int pixmap_num);
// create_map_image
// file image.c line 137
static void create_map_image(unsigned char *data, struct PixmapInfo *pi);
// create_new_character
// file account.c line 163
static void create_new_character();
// create_new_character_failure
// file account.c line 153
extern void create_new_character_failure(char *message);
// create_new_item
// file item.c line 435
struct item_struct * create_new_item(struct item_struct *env, signed int tag);
// create_opengl_map_image
// file gtk2proto.h line 187
extern void create_opengl_map_image(unsigned char *data, struct PixmapInfo *pi);
// create_opengl_question_mark
// file gtk2proto.h line 189
extern void create_opengl_question_mark(void);
// cs_print_string
// file ../../common/proto.h line 132
signed int cs_print_string(signed int fd, const char *str, ...);
// curl_easy_cleanup
// file /usr/include/curl/easy.h line 31
void curl_easy_cleanup(void *);
// curl_easy_init
// file /usr/include/curl/easy.h line 28
void * curl_easy_init(void);
// curl_easy_perform
// file /usr/include/curl/easy.h line 30
enum anonymous$33 curl_easy_perform(void *);
// curl_easy_setopt
// file /usr/include/curl/easy.h line 29
enum anonymous$33 curl_easy_setopt(void *, enum anonymous$34, ...);
// curl_global_init
// file /usr/include/curl/curl.h line 2014
enum anonymous$33 curl_global_init(signed long int);
// default_msgctrl_configuration
// file info.c line 1771
extern void default_msgctrl_configuration(void);
// display_map_doneupdate
// file map.c line 809
extern void display_map_doneupdate(signed int redraw, signed int notice);
// display_map_newmap
// file map.c line 558
extern void display_map_newmap(void);
// display_map_startupdate
// file map.c line 798
extern void display_map_startupdate(void);
// display_mapcell
// file map.c line 362
static void display_mapcell(signed int ax, signed int ay, signed int mx, signed int my);
// display_mapcell$link1
// file sdl.c line 887
static void display_mapcell$link1(signed int ax$link1, signed int ay$link1, signed int mx$link1, signed int my$link1);
// display_mapscroll
// file map.c line 217
extern signed int display_mapscroll(signed int dx, signed int dy);
// display_newpng
// file image.c line 684
void display_newpng(signed int face, unsigned char *buf, signed int buflen, signed int setnum);
// do_SDL_error
// file sdl.c line 63
static void do_SDL_error(const char *SDL_function, const char *file, signed int line);
// do_account_change
// file account.c line 1165
static void do_account_change(const char *old, const char *p1, const char *p2);
// do_account_create
// file account.c line 775
static void do_account_create(const char *name, const char *p1, const char *p2);
// do_account_login
// file account.c line 1002
static void do_account_login(const char *name, const char *password);
// do_clearinfo
// file p_cmd.c line 419
static void do_clearinfo(const char *ignored);
// do_clienthelp
// file p_cmd.c line 187
static void do_clienthelp(const char *arg);
// do_clienthelp_list
// file p_cmd.c line 65
static void do_clienthelp_list(void);
// do_disconnect
// file p_cmd.c line 428
static void do_disconnect(const char *ignored);
// do_inv
// file p_cmd.c line 462
static void do_inv(const char *ignored);
// do_item
// file script_lua.c line 103
static void do_item(struct lua_State *lua, struct item_struct *it);
// do_magicmap
// file p_cmd.c line 467
static void do_magicmap(const char *ignored);
// do_metaserver
// file p_cmd.c line 477
static void do_metaserver(const char *ignored);
// do_network
// file main.c line 177
extern void do_network(void);
// do_num_free_items
// file p_cmd.c line 518
static void do_num_free_items(const char *ignored);
// do_savedefaults
// file p_cmd.c line 491
static void do_savedefaults(const char *ignored);
// do_savewinpos
// file p_cmd.c line 500
static void do_savewinpos(const char *ignored);
// do_script_list
// file p_cmd.c line 410
static void do_script_list(const char *ignored);
// do_sdl_per_pixel_lighting
// file sdl.c line 414
static void do_sdl_per_pixel_lighting(signed int x, signed int y, signed int mx, signed int my);
// do_serverhelp
// file p_cmd.c line 233
static void do_serverhelp(const char *arg);
// do_take
// file p_cmd.c line 509
static void do_take(const char *used);
// do_timeout
// file main.c line 109
extern signed int do_timeout(void);
// draw_ext_info
// file gtk2proto.h line 70
extern void draw_ext_info(signed int orig_color, signed int type, signed int subtype, const char *message);
// draw_inv
// file inventory.c line 1076
extern void draw_inv(signed int tab);
// draw_inv_list
// file inventory.c line 798
extern void draw_inv_list(signed int tab);
// draw_inv_table
// file inventory.c line 905
extern void draw_inv_table(signed int animate);
// draw_keybindings
// file keys.c line 1713
extern void draw_keybindings(struct _GtkWidget *keylist);
// draw_lists
// file gtk2proto.h line 110
extern void draw_lists(void);
// draw_look_list
// file inventory.c line 762
extern void draw_look_list(void);
// draw_magic_map
// file magicmap.c line 38
void draw_magic_map(void);
// draw_map
// file gtk2proto.h line 162
extern void draw_map(signed int redraw);
// draw_message_window
// file gtk2proto.h line 267
extern void draw_message_window(signed int redraw);
// draw_pixmap
// file map.c line 204
static void draw_pixmap(signed int srcx, signed int srcy, signed int dstx, signed int dsty, signed int clipx, signed int clipy, void *mask, void *image, signed int sizex, signed int sizey);
// draw_prompt
// file keys.c line 1757
extern void draw_prompt(const char *str);
// draw_smoothing
// file opengl.c line 532
static void draw_smoothing(signed int layer);
// draw_splash
// file gtk2proto.h line 161
extern void draw_splash(void);
// draw_stats
// file gtk2proto.h line 268
extern void draw_stats(signed int redraw);
// drawingarea_inventory_table_button_press_event
// file inventory.c line 859
extern signed int drawingarea_inventory_table_button_press_event(struct _GtkWidget *widget, struct _GdkEventButton *event, void *user_data);
// drawingarea_inventory_table_expose_event
// file inventory.c line 875
extern signed int drawingarea_inventory_table_expose_event(struct _GtkWidget *widget, struct _GdkEventExpose *event, void *user_data);
// drawquarterlightmap_sdl
// file sdl.c line 351
extern void drawquarterlightmap_sdl(signed int tl, signed int tr, signed int bl, signed int br, signed int width, signed int height, signed int startx, signed int starty, signed int endx, signed int endy, signed int destx, signed int desty);
// drawsmooth
// file map.c line 237
extern void drawsmooth(signed int mx, signed int my, signed int layer, signed int picx, signed int picy);
// drawsmooth_opengl
// file opengl.c line 404
static void drawsmooth_opengl(signed int x, signed int y, signed int mx, signed int my, signed int layer);
// drawsmooth_sdl
// file sdl.c line 681
static void drawsmooth_sdl(signed int mx, signed int my, signed int layer, struct SDL_Rect dst);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// error_dialog
// file gtk2proto.h line 148
extern void error_dialog(char *description, char *information);
// event_loop
// file main.c line 238
extern void event_loop(void);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// expand_clear_bigface
// file mapdata.c line 312
static void expand_clear_bigface(signed int x, signed int y, signed int w, signed int h, signed int layer, signed int set_need_update);
// expand_clear_bigface_from_layer
// file mapdata.c line 366
static void expand_clear_bigface_from_layer(signed int x, signed int y, signed int layer, signed int set_need_update);
// expand_clear_face
// file mapdata.c line 179
static void expand_clear_face(signed int x, signed int y, signed int w, signed int h, signed int layer);
// expand_clear_face_from_layer
// file mapdata.c line 234
static void expand_clear_face_from_layer(signed int x, signed int y, signed int layer);
// expand_need_update
// file mapdata.c line 477
static void expand_need_update(signed int x, signed int y, signed int w, signed int h);
// expand_need_update_from_layer
// file mapdata.c line 505
static void expand_need_update_from_layer(signed int x, signed int y, signed int layer);
// expand_set_bigface
// file mapdata.c line 412
static void expand_set_bigface(signed int x, signed int y, signed int layer, signed short int face, signed int clear);
// expand_set_face
// file mapdata.c line 261
static void expand_set_face(signed int x, signed int y, signed int layer, signed short int face, signed int clear);
// extended_command
// file ../../common/p_cmd.h line 101
extern void extended_command(const char *ocommand);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fill_combobox_from_datadir
// file config.c line 655
static void fill_combobox_from_datadir(struct _GtkWidget *combobox, char *active, unsigned long int want_none, char *subdir, signed int (*scandir_filter)());
// fill_combobox_from_datadir::scandir_filter$object
// 
signed int scandir_filter$object();
// find_command
// file p_cmd.c line 998
extern const struct anonymous$47 * find_command(const char *cmd);
// finish_face_cmd
// file image.c line 432
void finish_face_cmd(signed int pnum, unsigned int checksum, signed int has_sum, char *face, signed int faceset);
// fire_dir
// file ../../common/proto.h line 145
void fire_dir(signed int dir);
// focusoutfunc
// file keys.c line 1527
extern void focusoutfunc(struct _GtkWidget *widget, struct _GdkEventKey *event, struct _GtkWidget *window);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// format_si_number
// file stats.c line 258
static void format_si_number(signed long int number, char *buffer, signed int limit);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_all_items
// file item.c line 264
void free_all_items(struct item_struct *op);
// free_all_race_class_info
// file commands.c line 421
void free_all_race_class_info(struct Race_Class_Info *data, signed int num_entries);
// free_all_starting_map_info
// file commands.c line 134
void free_all_starting_map_info();
// free_pixmap
// file image.c line 238
static void free_pixmap(struct PixmapInfo *pi);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// g_assertion_message_expr
// file /usr/include/glib-2.0/glib/gtestutils.h line 302
extern void g_assertion_message_expr(const char *, const char *, signed int, const char *, const char *);
// g_error_free
// file /usr/include/glib-2.0/glib/gerror.h line 68
extern void g_error_free(struct _GError *);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_list_free
// file /usr/include/glib-2.0/glib/glist.h line 51
extern void g_list_free(struct _GList *);
// g_list_length
// file /usr/include/glib-2.0/glib/glist.h line 130
extern unsigned int g_list_length(struct _GList *);
// g_list_nth_data
// file /usr/include/glib-2.0/glib/glist.h line 143
extern void * g_list_nth_data(struct _GList *, unsigned int);
// g_log
// file /usr/include/glib-2.0/glib/gmessages.h line 101
extern void g_log(const char *, enum anonymous$52, const char *, ...);
// g_object_ref
// file /usr/include/glib-2.0/gobject/gobject.h line 478
extern void * g_object_ref(void *);
// g_object_set
// file /usr/include/glib-2.0/gobject/gobject.h line 432
extern void g_object_set(void *, const char *, ...);
// g_object_unref
// file /usr/include/glib-2.0/gobject/gobject.h line 480
extern void g_object_unref(void *);
// g_signal_connect_data
// file /usr/include/glib-2.0/gobject/gsignal.h line 388
extern unsigned long int g_signal_connect_data(void *, const char *, void (*)(void), void *, void (*)(void *, struct _GClosure *), enum anonymous$36);
// g_signal_handler_disconnect
// file /usr/include/glib-2.0/gobject/gsignal.h line 401
extern void g_signal_handler_disconnect(void *, unsigned long int);
// g_signal_handler_find
// file /usr/include/glib-2.0/gobject/gsignal.h line 407
extern unsigned long int g_signal_handler_find(void *, enum anonymous$7, unsigned int, unsigned int, struct _GClosure *, void *, void *);
// g_signal_handlers_block_matched
// file /usr/include/glib-2.0/gobject/gsignal.h line 415
extern unsigned int g_signal_handlers_block_matched(void *, enum anonymous$7, unsigned int, unsigned int, struct _GClosure *, void *, void *);
// g_signal_handlers_unblock_matched
// file /usr/include/glib-2.0/gobject/gsignal.h line 423
extern unsigned int g_signal_handlers_unblock_matched(void *, enum anonymous$7, unsigned int, unsigned int, struct _GClosure *, void *, void *);
// g_signal_stop_emission_by_name
// file /usr/include/glib-2.0/gobject/gsignal.h line 357
extern void g_signal_stop_emission_by_name(void *, const char *);
// g_slist_free
// file /usr/include/glib-2.0/glib/gslist.h line 50
extern void g_slist_free(struct _GSList *);
// g_type_check_instance_cast
// file /usr/include/glib-2.0/gobject/gtype.h line 2168
extern struct _GTypeInstance * g_type_check_instance_cast(struct _GTypeInstance *, unsigned long int);
// gdk_beep
// file /usr/include/gtk-2.0/gdk/gdk.h line 140
void gdk_beep(void);
// gdk_color_alloc
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 154
signed int gdk_color_alloc(struct _GdkColormap *, struct _GdkColor *);
// gdk_color_get_type
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 143
unsigned long int gdk_color_get_type(void);
// gdk_color_parse
// file /usr/include/gtk-2.0/gdk/gdkcolor.h line 136
signed int gdk_color_parse(const char *, struct _GdkColor *);
// gdk_draw_drawable
// file /usr/include/gtk-2.0/gdk/gdkdrawable.h line 326
void gdk_draw_drawable(struct _GdkDrawable *, struct _GdkGC *, struct _GdkDrawable *, signed int, signed int, signed int, signed int, signed int, signed int);
// gdk_draw_pixbuf
// file /usr/include/gtk-2.0/gdk/gdkdrawable.h line 356
void gdk_draw_pixbuf(struct _GdkDrawable *, struct _GdkGC *, const struct _GdkPixbuf *, signed int, signed int, signed int, signed int, signed int, signed int, enum anonymous$15, signed int, signed int);
// gdk_draw_point
// file /usr/include/gtk-2.0/gdk/gdkdrawable.h line 275
void gdk_draw_point(struct _GdkDrawable *, struct _GdkGC *, signed int, signed int);
// gdk_draw_rectangle
// file /usr/include/gtk-2.0/gdk/gdkdrawable.h line 285
void gdk_draw_rectangle(struct _GdkDrawable *, struct _GdkGC *, signed int, signed int, signed int, signed int, signed int);
// gdk_draw_rgb_32_image
// file /usr/include/gtk-2.0/gdk/gdkrgb.h line 89
void gdk_draw_rgb_32_image(struct _GdkDrawable *, struct _GdkGC *, signed int, signed int, signed int, signed int, enum anonymous$15, const unsigned char *, signed int);
// gdk_draw_rgb_image
// file /usr/include/gtk-2.0/gdk/gdkrgb.h line 69
void gdk_draw_rgb_image(struct _GdkDrawable *, struct _GdkGC *, signed int, signed int, signed int, signed int, enum anonymous$15, const unsigned char *, signed int);
// gdk_drawable_get_size
// file /usr/include/gtk-2.0/gdk/gdkdrawable.h line 259
void gdk_drawable_get_size(struct _GdkDrawable *, signed int *, signed int *);
// gdk_gc_new
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 225
struct _GdkGC * gdk_gc_new(struct _GdkDrawable *);
// gdk_gc_set_clip_mask
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 258
void gdk_gc_set_clip_mask(struct _GdkGC *, struct _GdkDrawable *);
// gdk_gc_set_clip_origin
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 255
void gdk_gc_set_clip_origin(struct _GdkGC *, signed int, signed int);
// gdk_gc_set_foreground
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 238
void gdk_gc_set_foreground(struct _GdkGC *, const struct _GdkColor *);
// gdk_gc_set_function
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 244
void gdk_gc_set_function(struct _GdkGC *, enum anonymous$65);
// gdk_gc_unref
// file /usr/include/gtk-2.0/gdk/gdkgc.h line 231
void gdk_gc_unref(struct _GdkGC *);
// gdk_input_add
// file /usr/include/gtk-2.0/gdk/gdk.h line 105
signed int gdk_input_add(signed int, enum anonymous$49, void (*)(void *, signed int, enum anonymous$49), void *);
// gdk_input_remove
// file /usr/include/gtk-2.0/gdk/gdk.h line 109
void gdk_input_remove(signed int);
// gdk_keyval_from_name
// file /usr/include/gtk-2.0/gdk/gdkkeys.h line 119
unsigned int gdk_keyval_from_name(const char *);
// gdk_keyval_name
// file /usr/include/gtk-2.0/gdk/gdkkeys.h line 118
char * gdk_keyval_name(unsigned int);
// gdk_keyval_to_lower
// file /usr/include/gtk-2.0/gdk/gdkkeys.h line 124
unsigned int gdk_keyval_to_lower(unsigned int);
// gdk_pixbuf_get_pixels
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 235
unsigned char * gdk_pixbuf_get_pixels(const struct _GdkPixbuf *);
// gdk_pixbuf_get_rowstride
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 238
signed int gdk_pixbuf_get_rowstride(const struct _GdkPixbuf *);
// gdk_pixbuf_new
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 250
struct _GdkPixbuf * gdk_pixbuf_new(enum anonymous$63, signed int, signed int, signed int, signed int);
// gdk_pixbuf_new_from_xpm_data
// file /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-core.h line 310
struct _GdkPixbuf * gdk_pixbuf_new_from_xpm_data(const char **);
// gdk_pixmap_create_from_xpm_d
// file /usr/include/gtk-2.0/gdk/gdkpixmap.h line 95
struct _GdkDrawable * gdk_pixmap_create_from_xpm_d(struct _GdkDrawable *, struct _GdkDrawable **, const struct _GdkColor *, char **);
// gdk_pixmap_new
// file /usr/include/gtk-2.0/gdk/gdkpixmap.h line 69
struct _GdkDrawable * gdk_pixmap_new(struct _GdkDrawable *, signed int, signed int, signed int);
// gdk_screen_get_default
// file /usr/include/gtk-2.0/gdk/gdkscreen.h line 113
struct _GdkScreen * gdk_screen_get_default(void);
// gdk_window_clear
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 366
void gdk_window_clear(struct _GdkDrawable *);
// gdk_window_get_geometry
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 552
void gdk_window_get_geometry(struct _GdkDrawable *, signed int *, signed int *, signed int *, signed int *, signed int *);
// gdk_window_get_origin
// file /usr/include/gtk-2.0/gdk/gdkwindow.h line 561
signed int gdk_window_get_origin(struct _GdkDrawable *, signed int *, signed int *);
// gdk_x11_drawable_get_xdisplay
// file /usr/include/gtk-2.0/gdk/gdkx.h line 41
struct _XDisplay * gdk_x11_drawable_get_xdisplay(struct _GdkDrawable *);
// gdk_x11_drawable_get_xid
// file /usr/include/gtk-2.0/gdk/gdkx.h line 42
unsigned long int gdk_x11_drawable_get_xid(struct _GdkDrawable *);
// gdk_x11_get_default_screen
// file /usr/include/gtk-2.0/gdk/gdkx.h line 68
signed int gdk_x11_get_default_screen(void);
// gdk_x11_window_get_drawable_impl
// file /usr/include/gtk-2.0/gdk/gdkx.h line 43
struct _GdkDrawable * gdk_x11_window_get_drawable_impl(struct _GdkDrawable *);
// getLogLevelText
// file misc.c line 173
static const char * getLogLevelText(enum LogLevel level);
// getTextManager
// file commands.c line 1246
static void (*getTextManager(signed int type))(signed int, signed int, signed int, char *);
// get_cat_sorted_commands
// file p_cmd.c line 1039
struct anonymous$47 ** get_cat_sorted_commands(void);
// get_category_name
// file p_cmd.c line 366
const char * get_category_name(enum anonymous$46 cat);
// get_class_info
// file commands.c line 678
static void get_class_info(char *data, signed int len);
// get_exp_info
// file commands.c line 706
static void get_exp_info(const unsigned char *data, signed int len);
// get_flags
// file item.c line 508
static void get_flags(struct item_struct *op, unsigned short int flags);
// get_image_info
// file ./proto.h line 51
void get_image_info(unsigned char *data, signed int len);
// get_image_sums
// file ./proto.h line 52
void get_image_sums(char *data, signed int len);
// get_info_width
// file info.c line 1321
extern signed int get_info_width(void);
// get_item_env
// file inventory.c line 180
static signed int get_item_env(struct item_struct *it);
// get_key_info
// file keys.c line 987
static char * get_key_info(struct keybind *kb, signed int save_mode);
// get_key_modchars
// file keys.c line 949
static void get_key_modchars(struct keybind *kb, signed int save_mode, char *buf);
// get_map_image_size
// file image.c line 541
extern void get_map_image_size(signed int face, unsigned char *w, unsigned char *h);
// get_metaserver
// file gtk2proto.h line 177
extern void get_metaserver(void);
// get_metaserver2_data
// file metaserver.c line 438
static signed int get_metaserver2_data(char *metaserver2);
// get_new_char_info
// file commands.c line 248
static void get_new_char_info(char *data, signed int len);
// get_num_commands
// file p_cmd.c line 901
extern signed int get_num_commands(void);
// get_number
// file item.c line 190
const char * get_number(unsigned int i);
// get_race_info
// file commands.c line 645
static void get_race_info(char *data, signed int len);
// get_row_style
// file inventory.c line 656
static struct _GtkStyle * get_row_style(struct item_struct *it);
// get_skill_info
// file commands.c line 733
static void get_skill_info(char *data, signed int len);
// get_starting_map_info
// file commands.c line 172
static void get_starting_map_info(char *data, signed int len);
// get_type_from_name
// file item.c line 42
unsigned char get_type_from_name(const char *name);
// get_window_coord
// file gtk2proto.h line 151
extern void get_window_coord(struct _GtkWidget *win, signed int *x, signed int *y, signed int *wx, signed int *wy, signed int *w, signed int *h);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getprotobyname
// file /usr/include/netdb.h line 357
extern struct protoent * getprotobyname(const char *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// glBegin
// file /usr/include/GL/gl.h line 929
void glBegin(unsigned int);
// glBindTexture
// file /usr/include/GL/gl.h line 1311
void glBindTexture(unsigned int, unsigned int);
// glBlendFunc
// file /usr/include/GL/gl.h line 760
void glBlendFunc(unsigned int, unsigned int);
// glClear
// file /usr/include/GL/gl.h line 752
void glClear(unsigned int);
// glClearColor
// file /usr/include/GL/gl.h line 750
void glClearColor(float, float, float, float);
// glClearDepth
// file /usr/include/GL/gl.h line 844
void glClearDepth(double);
// glColor4f
// file /usr/include/GL/gl.h line 1003
void glColor4f(float, float, float, float);
// glColor4ub
// file /usr/include/GL/gl.h line 1009
void glColor4ub(unsigned char, unsigned char, unsigned char, unsigned char);
// glDeleteTextures
// file /usr/include/GL/gl.h line 1309
void glDeleteTextures(signed int, const unsigned int *);
// glEnable
// file /usr/include/GL/gl.h line 796
void glEnable(unsigned int);
// glEnd
// file /usr/include/GL/gl.h line 931
void glEnd(void);
// glFlush
// file /usr/include/GL/gl.h line 835
void glFlush(void);
// glGenTextures
// file /usr/include/GL/gl.h line 1307
void glGenTextures(signed int, unsigned int *);
// glGetIntegerv
// file /usr/include/GL/gl.h line 814
void glGetIntegerv(unsigned int, signed int *);
// glLoadIdentity
// file /usr/include/GL/gl.h line 883
void glLoadIdentity(void);
// glMatrixMode
// file /usr/include/GL/gl.h line 866
void glMatrixMode(unsigned int);
// glOrtho
// file /usr/include/GL/gl.h line 868
void glOrtho(double, double, double, double, double, double);
// glShadeModel
// file /usr/include/GL/gl.h line 1157
void glShadeModel(unsigned int);
// glTexCoord2f
// file /usr/include/GL/gl.h line 1042
void glTexCoord2f(float, float);
// glTexImage2D
// file /usr/include/GL/gl.h line 1294
void glTexImage2D(unsigned int, signed int, signed int, signed int, signed int, signed int, unsigned int, unsigned int, const void *);
// glTexParameteri
// file /usr/include/GL/gl.h line 1270
void glTexParameteri(unsigned int, unsigned int, signed int);
// glVertex3i
// file /usr/include/GL/gl.h line 941
void glVertex3i(signed int, signed int, signed int);
// glViewport
// file /usr/include/GL/gl.h line 876
void glViewport(signed int, signed int, signed int, signed int);
// glXChooseVisual
// file /usr/include/GL/glx.h line 187
extern struct anonymous$59 * glXChooseVisual(struct _XDisplay *, signed int, signed int *);
// glXCreateContext
// file /usr/include/GL/glx.h line 190
extern struct __GLXcontextRec * glXCreateContext(struct _XDisplay *, struct anonymous$59 *, struct __GLXcontextRec *, signed int);
// glXIsDirect
// file /usr/include/GL/glx.h line 212
extern signed int glXIsDirect(struct _XDisplay *, struct __GLXcontextRec *);
// glXMakeCurrent
// file /usr/include/GL/glx.h line 195
extern signed int glXMakeCurrent(struct _XDisplay *, unsigned long int, struct __GLXcontextRec *);
// glXSwapBuffers
// file /usr/include/GL/glx.h line 201
extern void glXSwapBuffers(struct _XDisplay *, unsigned long int);
// gtk_adjustment_new
// file /usr/include/gtk-2.0/gtk/gtkadjustment.h line 79
struct _GtkObject * gtk_adjustment_new(double, double, double, double, double, double);
// gtk_box_get_type
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 104
unsigned long int gtk_box_get_type(void);
// gtk_box_pack_start
// file /usr/include/gtk-2.0/gtk/gtkbox.h line 109
void gtk_box_pack_start(struct _GtkBox *, struct _GtkWidget *, signed int, signed int, unsigned int);
// gtk_buildable_get_name
// file /usr/include/gtk-2.0/gtk/gtkbuildable.h line 140
const char * gtk_buildable_get_name(struct _GtkBuildable *);
// gtk_builder_add_from_file
// file /usr/include/gtk-2.0/gtk/gtkbuilder.h line 97
unsigned int gtk_builder_add_from_file(struct _GtkBuilder *, const char *, struct _GError **);
// gtk_builder_get_object
// file /usr/include/gtk-2.0/gtk/gtkbuilder.h line 113
struct _GObject * gtk_builder_get_object(struct _GtkBuilder *, const char *);
// gtk_builder_get_objects
// file /usr/include/gtk-2.0/gtk/gtkbuilder.h line 115
struct _GSList * gtk_builder_get_objects(struct _GtkBuilder *);
// gtk_builder_new
// file /usr/include/gtk-2.0/gtk/gtkbuilder.h line 95
struct _GtkBuilder * gtk_builder_new(void);
// gtk_cell_layout_clear
// file /usr/include/gtk-2.0/gtk/gtkcelllayout.h line 86
void gtk_cell_layout_clear(struct _GtkCellLayout *);
// gtk_cell_layout_get_type
// file /usr/include/gtk-2.0/gtk/gtkcelllayout.h line 78
unsigned long int gtk_cell_layout_get_type(void);
// gtk_cell_layout_pack_start
// file /usr/include/gtk-2.0/gtk/gtkcelllayout.h line 79
void gtk_cell_layout_pack_start(struct _GtkCellLayout *, struct _GtkCellRenderer *, signed int);
// gtk_cell_layout_set_attributes
// file /usr/include/gtk-2.0/gtk/gtkcelllayout.h line 87
void gtk_cell_layout_set_attributes(struct _GtkCellLayout *, struct _GtkCellRenderer *, ...);
// gtk_cell_renderer_pixbuf_new
// file /usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h line 65
struct _GtkCellRenderer * gtk_cell_renderer_pixbuf_new(void);
// gtk_cell_renderer_text_new
// file /usr/include/gtk-2.0/gtk/gtkcellrenderertext.h line 97
struct _GtkCellRenderer * gtk_cell_renderer_text_new(void);
// gtk_check_button_new
// file /usr/include/gtk-2.0/gtk/gtkcheckbutton.h line 72
struct _GtkWidget * gtk_check_button_new(void);
// gtk_check_menu_item_get_active
// file /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h line 84
signed int gtk_check_menu_item_get_active(struct _GtkCheckMenuItem *);
// gtk_check_menu_item_get_type
// file /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h line 77
unsigned long int gtk_check_menu_item_get_type(void);
// gtk_check_menu_item_set_active
// file /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h line 82
void gtk_check_menu_item_set_active(struct _GtkCheckMenuItem *, signed int);
// gtk_clist_append
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 682
signed int gtk_clist_append(struct _GtkCList *, char **);
// gtk_clist_clear
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 733
void gtk_clist_clear(struct _GtkCList *);
// gtk_clist_get_type
// file /usr/include/gtk-2.0/gtk/gtkclist.h line 443
unsigned long int gtk_clist_get_type(void);
// gtk_combo_box_append_text
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 132
void gtk_combo_box_append_text(struct _GtkComboBox *, const char *);
// gtk_combo_box_get_active
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 100
signed int gtk_combo_box_get_active(struct _GtkComboBox *);
// gtk_combo_box_get_active_text
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 141
char * gtk_combo_box_get_active_text(struct _GtkComboBox *);
// gtk_combo_box_get_model
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 111
struct _GtkTreeModel * gtk_combo_box_get_model(struct _GtkComboBox *);
// gtk_combo_box_get_type
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 70
unsigned long int gtk_combo_box_get_type(void);
// gtk_combo_box_remove_text
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 139
void gtk_combo_box_remove_text(struct _GtkComboBox *, signed int);
// gtk_combo_box_set_active
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 101
void gtk_combo_box_set_active(struct _GtkComboBox *, signed int);
// gtk_combo_box_set_model
// file /usr/include/gtk-2.0/gtk/gtkcombobox.h line 109
void gtk_combo_box_set_model(struct _GtkComboBox *, struct _GtkTreeModel *);
// gtk_command_history
// file keys.c line 1767
extern void gtk_command_history(signed int direction);
// gtk_complete_command
// file keys.c line 1814
extern void gtk_complete_command(void);
// gtk_container_add
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 111
void gtk_container_add(struct _GtkContainer *, struct _GtkWidget *);
// gtk_container_get_type
// file /usr/include/gtk-2.0/gtk/gtkcontainer.h line 107
unsigned long int gtk_container_get_type(void);
// gtk_dialog_get_content_area
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 178
struct _GtkWidget * gtk_dialog_get_content_area(struct _GtkDialog *);
// gtk_dialog_get_type
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 127
unsigned long int gtk_dialog_get_type(void);
// gtk_dialog_new_with_buttons
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 130
struct _GtkWidget * gtk_dialog_new_with_buttons(const char *, struct _GtkWindow *, enum anonymous$40, const char *, ...);
// gtk_dialog_run
// file /usr/include/gtk-2.0/gtk/gtkdialog.h line 175
signed int gtk_dialog_run(struct _GtkDialog *);
// gtk_draw_map
// file map.c line 501
extern void gtk_draw_map(signed int redraw);
// gtk_drawing_area_get_type
// file /usr/include/gtk-2.0/gtk/gtkdrawingarea.h line 70
unsigned long int gtk_drawing_area_get_type(void);
// gtk_drawing_area_new
// file /usr/include/gtk-2.0/gtk/gtkdrawingarea.h line 71
struct _GtkWidget * gtk_drawing_area_new(void);
// gtk_drawing_area_size
// file /usr/include/gtk-2.0/gtk/gtkdrawingarea.h line 74
void gtk_drawing_area_size(struct _GtkDrawingArea *, signed int, signed int);
// gtk_editable_get_type
// file /usr/include/gtk-2.0/gtk/gtkeditable.h line 87
unsigned long int gtk_editable_get_type(void);
// gtk_editable_select_region
// file /usr/include/gtk-2.0/gtk/gtkeditable.h line 88
void gtk_editable_select_region(struct _GtkEditable *, signed int, signed int);
// gtk_editable_set_position
// file /usr/include/gtk-2.0/gtk/gtkeditable.h line 108
void gtk_editable_set_position(struct _GtkEditable *, signed int);
// gtk_entry_get_text
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 216
const char * gtk_entry_get_text(struct _GtkEntry *);
// gtk_entry_get_type
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 166
unsigned long int gtk_entry_get_type(void);
// gtk_entry_set_position
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 323
void gtk_entry_set_position(struct _GtkEntry *, signed int);
// gtk_entry_set_text
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 213
void gtk_entry_set_text(struct _GtkEntry *, const char *);
// gtk_entry_set_visibility
// file /usr/include/gtk-2.0/gtk/gtkentry.h line 176
void gtk_entry_set_visibility(struct _GtkEntry *, signed int);
// gtk_event_box_new
// file /usr/include/gtk-2.0/gtk/gtkeventbox.h line 61
struct _GtkWidget * gtk_event_box_new(void);
// gtk_events_pending
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 137
signed int gtk_events_pending(void);
// gtk_get_current_event
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 209
union _GdkEvent * gtk_get_current_event(void);
// gtk_hpaned_get_type
// file /usr/include/gtk-2.0/gtk/gtkhpaned.h line 60
unsigned long int gtk_hpaned_get_type(void);
// gtk_image_get_type
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 190
unsigned long int gtk_image_get_type(void);
// gtk_image_new_from_pixbuf
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 198
struct _GtkWidget * gtk_image_new_from_pixbuf(struct _GdkPixbuf *);
// gtk_image_set_from_pixbuf
// file /usr/include/gtk-2.0/gtk/gtkimage.h line 218
void gtk_image_set_from_pixbuf(struct _GtkImage *, struct _GdkPixbuf *);
// gtk_init
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 94
void gtk_init(signed int *, char ***);
// gtk_label_get_text
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 114
const char * gtk_label_get_text(struct _GtkLabel *);
// gtk_label_get_type
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 109
unsigned long int gtk_label_get_type(void);
// gtk_label_new
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 110
struct _GtkWidget * gtk_label_new(const char *);
// gtk_label_set_text
// file /usr/include/gtk-2.0/gtk/gtklabel.h line 112
void gtk_label_set_text(struct _GtkLabel *, const char *);
// gtk_list_store_append
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 126
void gtk_list_store_append(struct _GtkListStore *, struct _GtkTreeIter *);
// gtk_list_store_clear
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 128
void gtk_list_store_clear(struct _GtkListStore *);
// gtk_list_store_get_type
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 77
unsigned long int gtk_list_store_get_type(void);
// gtk_list_store_new
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 78
struct _GtkListStore * gtk_list_store_new(signed int, ...);
// gtk_list_store_set
// file /usr/include/gtk-2.0/gtk/gtkliststore.h line 92
void gtk_list_store_set(struct _GtkListStore *, struct _GtkTreeIter *, ...);
// gtk_main
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 145
void gtk_main(void);
// gtk_main_iteration
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 148
signed int gtk_main_iteration(void);
// gtk_main_iteration_do
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 150
signed int gtk_main_iteration_do(signed int);
// gtk_main_quit
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 147
void gtk_main_quit(void);
// gtk_message_dialog_format_secondary_markup
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 127
void gtk_message_dialog_format_secondary_markup(struct _GtkMessageDialog *, const char *, ...);
// gtk_message_dialog_get_type
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 99
unsigned long int gtk_message_dialog_get_type(void);
// gtk_message_dialog_new
// file /usr/include/gtk-2.0/gtk/gtkmessagedialog.h line 101
struct _GtkWidget * gtk_message_dialog_new(struct _GtkWindow *, enum anonymous$40, enum anonymous$41, enum anonymous$42, const char *, ...);
// gtk_misc_get_type
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 68
unsigned long int gtk_misc_get_type(void);
// gtk_misc_set_alignment
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 69
void gtk_misc_set_alignment(struct _GtkMisc *, float, float);
// gtk_misc_set_padding
// file /usr/include/gtk-2.0/gtk/gtkmisc.h line 75
void gtk_misc_set_padding(struct _GtkMisc *, signed int, signed int);
// gtk_notebook_get_current_page
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 205
signed int gtk_notebook_get_current_page(struct _GtkNotebook *);
// gtk_notebook_get_n_pages
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 208
signed int gtk_notebook_get_n_pages(struct _GtkNotebook *);
// gtk_notebook_get_type
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 151
unsigned long int gtk_notebook_get_type(void);
// gtk_notebook_insert_page
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 167
signed int gtk_notebook_insert_page(struct _GtkNotebook *, struct _GtkWidget *, struct _GtkWidget *, signed int);
// gtk_notebook_next_page
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 213
void gtk_notebook_next_page(struct _GtkNotebook *);
// gtk_notebook_set_current_page
// file /usr/include/gtk-2.0/gtk/gtknotebook.h line 211
void gtk_notebook_set_current_page(struct _GtkNotebook *, signed int);
// gtk_object_get_type
// file /usr/include/gtk-2.0/gtk/gtkobject.h line 146
unsigned long int gtk_object_get_type(void);
// gtk_paned_get_position
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 123
signed int gtk_paned_get_position(struct _GtkPaned *);
// gtk_paned_get_type
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 109
unsigned long int gtk_paned_get_type(void);
// gtk_paned_set_position
// file /usr/include/gtk-2.0/gtk/gtkpaned.h line 124
void gtk_paned_set_position(struct _GtkPaned *, signed int);
// gtk_progress_bar_get_type
// file /usr/include/gtk-2.0/gtk/gtkprogressbar.h line 98
unsigned long int gtk_progress_bar_get_type(void);
// gtk_progress_bar_new_with_adjustment
// file /usr/include/gtk-2.0/gtk/gtkprogressbar.h line 152
struct _GtkWidget * gtk_progress_bar_new_with_adjustment(struct _GtkAdjustment *);
// gtk_progress_bar_set_bar_style
// file /usr/include/gtk-2.0/gtk/gtkprogressbar.h line 153
void gtk_progress_bar_set_bar_style(struct _GtkProgressBar *, enum anonymous$69);
// gtk_progress_get_type
// file /usr/include/gtk-2.0/gtk/gtkprogress.h line 88
unsigned long int gtk_progress_get_type(void);
// gtk_progress_set_format_string
// file /usr/include/gtk-2.0/gtk/gtkprogress.h line 94
void gtk_progress_set_format_string(struct _GtkProgress *, const char *);
// gtk_progress_set_percentage
// file /usr/include/gtk-2.0/gtk/gtkprogress.h line 102
void gtk_progress_set_percentage(struct _GtkProgress *, double);
// gtk_progress_set_show_text
// file /usr/include/gtk-2.0/gtk/gtkprogress.h line 89
void gtk_progress_set_show_text(struct _GtkProgress *, signed int);
// gtk_progress_set_value
// file /usr/include/gtk-2.0/gtk/gtkprogress.h line 104
void gtk_progress_set_value(struct _GtkProgress *, double);
// gtk_rc_add_default_file
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 141
void gtk_rc_add_default_file(const char *);
// gtk_rc_get_default_files
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 143
char ** gtk_rc_get_default_files(void);
// gtk_rc_get_style_by_paths
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 145
struct _GtkStyle * gtk_rc_get_style_by_paths(struct _GtkSettings *, const char *, const char *, unsigned long int);
// gtk_rc_reparse_all_for_settings
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 150
signed int gtk_rc_reparse_all_for_settings(struct _GtkSettings *, signed int);
// gtk_rc_reset_styles
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 152
void gtk_rc_reset_styles(struct _GtkSettings *);
// gtk_rc_set_default_files
// file /usr/include/gtk-2.0/gtk/gtkrc.h line 142
void gtk_rc_set_default_files(char **);
// gtk_scrolled_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 102
unsigned long int gtk_scrolled_window_get_type(void);
// gtk_scrolled_window_get_vadjustment
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 110
struct _GtkAdjustment * gtk_scrolled_window_get_vadjustment(struct _GtkScrolledWindow *);
// gtk_scrolled_window_new
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 103
struct _GtkWidget * gtk_scrolled_window_new(struct _GtkAdjustment *, struct _GtkAdjustment *);
// gtk_scrolled_window_set_policy
// file /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h line 113
void gtk_scrolled_window_set_policy(struct _GtkScrolledWindow *, enum anonymous$17, enum anonymous$17);
// gtk_settings_get_default
// file /usr/include/gtk-2.0/gtk/gtksettings.h line 80
struct _GtkSettings * gtk_settings_get_default(void);
// gtk_settings_get_for_screen
// file /usr/include/gtk-2.0/gtk/gtksettings.h line 82
struct _GtkSettings * gtk_settings_get_for_screen(struct _GdkScreen *);
// gtk_spin_button_get_type
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 123
unsigned long int gtk_spin_button_get_type(void);
// gtk_spin_button_get_value_as_int
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 163
signed int gtk_spin_button_get_value_as_int(struct _GtkSpinButton *);
// gtk_spin_button_set_range
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 154
void gtk_spin_button_set_range(struct _GtkSpinButton *, double, double);
// gtk_spin_button_set_value
// file /usr/include/gtk-2.0/gtk/gtkspinbutton.h line 165
void gtk_spin_button_set_value(struct _GtkSpinButton *, double);
// gtk_table_attach
// file /usr/include/gtk-2.0/gtk/gtktable.h line 109
void gtk_table_attach(struct _GtkTable *, struct _GtkWidget *, unsigned int, unsigned int, unsigned int, unsigned int, enum anonymous$16, enum anonymous$16, unsigned int, unsigned int);
// gtk_table_attach_defaults
// file /usr/include/gtk-2.0/gtk/gtktable.h line 119
void gtk_table_attach_defaults(struct _GtkTable *, struct _GtkWidget *, unsigned int, unsigned int, unsigned int, unsigned int);
// gtk_table_get_type
// file /usr/include/gtk-2.0/gtk/gtktable.h line 102
unsigned long int gtk_table_get_type(void);
// gtk_table_resize
// file /usr/include/gtk-2.0/gtk/gtktable.h line 106
void gtk_table_resize(struct _GtkTable *, unsigned int, unsigned int);
// gtk_text_buffer_add_mark
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 256
void gtk_text_buffer_add_mark(struct _GtkTextBuffer *, struct _GtkTextMark *, const struct _GtkTextIter *);
// gtk_text_buffer_create_mark
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 259
struct _GtkTextMark * gtk_text_buffer_create_mark(struct _GtkTextBuffer *, const char *, const struct _GtkTextIter *, signed int);
// gtk_text_buffer_create_tag
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 314
struct _GtkTextTag * gtk_text_buffer_create_tag(struct _GtkTextBuffer *, const char *, const char *, ...);
// gtk_text_buffer_get_end_iter
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 338
void gtk_text_buffer_get_end_iter(struct _GtkTextBuffer *, struct _GtkTextIter *);
// gtk_text_buffer_get_start_iter
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 336
void gtk_text_buffer_get_start_iter(struct _GtkTextBuffer *, struct _GtkTextIter *);
// gtk_text_buffer_get_tag_table
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 167
struct _GtkTextTagTable * gtk_text_buffer_get_tag_table(struct _GtkTextBuffer *);
// gtk_text_buffer_insert_with_tags
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 203
void gtk_text_buffer_insert_with_tags(struct _GtkTextBuffer *, struct _GtkTextIter *, const char *, signed int, struct _GtkTextTag *, ...);
// gtk_text_buffer_set_text
// file /usr/include/gtk-2.0/gtk/gtktextbuffer.h line 170
void gtk_text_buffer_set_text(struct _GtkTextBuffer *, const char *, signed int);
// gtk_text_mark_new
// file /usr/include/gtk-2.0/gtk/gtktextmark.h line 95
struct _GtkTextMark * gtk_text_mark_new(const char *, signed int);
// gtk_text_tag_table_remove
// file /usr/include/gtk-2.0/gtk/gtktexttagtable.h line 80
void gtk_text_tag_table_remove(struct _GtkTextTagTable *, struct _GtkTextTag *);
// gtk_text_view_get_buffer
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 222
struct _GtkTextBuffer * gtk_text_view_get_buffer(struct _GtkTextView *);
// gtk_text_view_get_type
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 217
unsigned long int gtk_text_view_get_type(void);
// gtk_text_view_get_visible_rect
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 241
void gtk_text_view_get_visible_rect(struct _GtkTextView *, struct _GdkRectangle *);
// gtk_text_view_scroll_mark_onscreen
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 235
void gtk_text_view_scroll_mark_onscreen(struct _GtkTextView *, struct _GtkTextMark *);
// gtk_text_view_scroll_to_mark
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 229
void gtk_text_view_scroll_to_mark(struct _GtkTextView *, struct _GtkTextMark *, double, signed int, double, double);
// gtk_text_view_set_wrap_mode
// file /usr/include/gtk-2.0/gtk/gtktextview.h line 334
void gtk_text_view_set_wrap_mode(struct _GtkTextView *, enum anonymous$45);
// gtk_timeout_add
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 174
unsigned int gtk_timeout_add(unsigned int, signed int (*)(void *), void *);
// gtk_timeout_remove
// file /usr/include/gtk-2.0/gtk/gtkmain.h line 182
void gtk_timeout_remove(unsigned int);
// gtk_toggle_button_get_active
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 84
signed int gtk_toggle_button_get_active(struct _GtkToggleButton *);
// gtk_toggle_button_get_type
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 74
unsigned long int gtk_toggle_button_get_type(void);
// gtk_toggle_button_set_active
// file /usr/include/gtk-2.0/gtk/gtktogglebutton.h line 82
void gtk_toggle_button_set_active(struct _GtkToggleButton *, signed int);
// gtk_tooltips_enable
// file /usr/include/gtk-2.0/gtk/gtktooltips.h line 90
void gtk_tooltips_enable(struct _GtkTooltips *);
// gtk_tooltips_new
// file /usr/include/gtk-2.0/gtk/gtktooltips.h line 88
struct _GtkTooltips * gtk_tooltips_new(void);
// gtk_tooltips_set_tip
// file /usr/include/gtk-2.0/gtk/gtktooltips.h line 94
void gtk_tooltips_set_tip(struct _GtkTooltips *, struct _GtkWidget *, const char *, const char *);
// gtk_tree_model_get
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 234
void gtk_tree_model_get(struct _GtkTreeModel *, struct _GtkTreeIter *, ...);
// gtk_tree_model_get_iter
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 198
signed int gtk_tree_model_get_iter(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreePath *);
// gtk_tree_model_get_iter_first
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 206
signed int gtk_tree_model_get_iter_first(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_get_path
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 208
struct _GtkTreePath * gtk_tree_model_get_path(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_get_type
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 190
unsigned long int gtk_tree_model_get_type(void);
// gtk_tree_model_iter_n_children
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 221
signed int gtk_tree_model_iter_n_children(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_iter_next
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 214
signed int gtk_tree_model_iter_next(struct _GtkTreeModel *, struct _GtkTreeIter *);
// gtk_tree_model_iter_nth_child
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 223
signed int gtk_tree_model_iter_nth_child(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, signed int);
// gtk_tree_model_row_changed
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 252
void gtk_tree_model_row_changed(struct _GtkTreeModel *, struct _GtkTreePath *, struct _GtkTreeIter *);
// gtk_tree_path_free
// file /usr/include/gtk-2.0/gtk/gtktreemodel.h line 139
void gtk_tree_path_free(struct _GtkTreePath *);
// gtk_tree_selection_get_selected
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 92
signed int gtk_tree_selection_get_selected(struct _GtkTreeSelection *, struct _GtkTreeModel **, struct _GtkTreeIter *);
// gtk_tree_selection_set_mode
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 78
void gtk_tree_selection_set_mode(struct _GtkTreeSelection *, enum anonymous$24);
// gtk_tree_selection_set_select_function
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 81
void gtk_tree_selection_set_select_function(struct _GtkTreeSelection *, signed int (*)(struct _GtkTreeSelection *, struct _GtkTreeModel *, struct _GtkTreePath *, signed int, void *), void *, void (*)(void *));
// gtk_tree_selection_unselect_all
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 114
void gtk_tree_selection_unselect_all(struct _GtkTreeSelection *);
// gtk_tree_selection_unselect_iter
// file /usr/include/gtk-2.0/gtk/gtktreeselection.h line 107
void gtk_tree_selection_unselect_iter(struct _GtkTreeSelection *, struct _GtkTreeIter *);
// gtk_tree_sortable_get_type
// file /usr/include/gtk-2.0/gtk/gtktreesortable.h line 81
unsigned long int gtk_tree_sortable_get_type(void);
// gtk_tree_sortable_set_sort_column_id
// file /usr/include/gtk-2.0/gtk/gtktreesortable.h line 87
void gtk_tree_sortable_set_sort_column_id(struct _GtkTreeSortable *, signed int, enum anonymous$26);
// gtk_tree_store_append
// file /usr/include/gtk-2.0/gtk/gtktreestore.h line 131
void gtk_tree_store_append(struct _GtkTreeStore *, struct _GtkTreeIter *, struct _GtkTreeIter *);
// gtk_tree_store_clear
// file /usr/include/gtk-2.0/gtk/gtktreestore.h line 139
void gtk_tree_store_clear(struct _GtkTreeStore *);
// gtk_tree_store_new
// file /usr/include/gtk-2.0/gtk/gtktreestore.h line 77
struct _GtkTreeStore * gtk_tree_store_new(signed int, ...);
// gtk_tree_store_set
// file /usr/include/gtk-2.0/gtk/gtktreestore.h line 91
void gtk_tree_store_set(struct _GtkTreeStore *, struct _GtkTreeIter *, ...);
// gtk_tree_view_append_column
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 167
signed int gtk_tree_view_append_column(struct _GtkTreeView *, struct _GtkTreeViewColumn *);
// gtk_tree_view_column_add_attribute
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 141
void gtk_tree_view_column_add_attribute(struct _GtkTreeViewColumn *, struct _GtkCellRenderer *, const char *, signed int);
// gtk_tree_view_column_get_width
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 167
signed int gtk_tree_view_column_get_width(struct _GtkTreeViewColumn *);
// gtk_tree_view_column_new_with_attributes
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 128
struct _GtkTreeViewColumn * gtk_tree_view_column_new_with_attributes(const char *, struct _GtkCellRenderer *, ...);
// gtk_tree_view_column_set_expand
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 186
void gtk_tree_view_column_set_expand(struct _GtkTreeViewColumn *, signed int);
// gtk_tree_view_column_set_min_width
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 171
void gtk_tree_view_column_set_min_width(struct _GtkTreeViewColumn *, signed int);
// gtk_tree_view_column_set_sizing
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 164
void gtk_tree_view_column_set_sizing(struct _GtkTreeViewColumn *, enum anonymous$18);
// gtk_tree_view_column_set_sort_column_id
// file /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h line 207
void gtk_tree_view_column_set_sort_column_id(struct _GtkTreeViewColumn *, signed int);
// gtk_tree_view_expand_row
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 217
signed int gtk_tree_view_expand_row(struct _GtkTreeView *, struct _GtkTreePath *, signed int);
// gtk_tree_view_get_columns
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 188
struct _GList * gtk_tree_view_get_columns(struct _GtkTreeView *);
// gtk_tree_view_get_model
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 145
struct _GtkTreeModel * gtk_tree_view_get_model(struct _GtkTreeView *);
// gtk_tree_view_get_selection
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 148
struct _GtkTreeSelection * gtk_tree_view_get_selection(struct _GtkTreeView *);
// gtk_tree_view_get_type
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 140
unsigned long int gtk_tree_view_get_type(void);
// gtk_tree_view_new_with_model
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 142
struct _GtkWidget * gtk_tree_view_new_with_model(struct _GtkTreeModel *);
// gtk_tree_view_set_expander_column
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 192
void gtk_tree_view_set_expander_column(struct _GtkTreeView *, struct _GtkTreeViewColumn *);
// gtk_tree_view_set_model
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 146
void gtk_tree_view_set_model(struct _GtkTreeView *, struct _GtkTreeModel *);
// gtk_tree_view_set_rules_hint
// file /usr/include/gtk-2.0/gtk/gtktreeview.h line 162
void gtk_tree_view_set_rules_hint(struct _GtkTreeView *, signed int);
// gtk_vpaned_get_type
// file /usr/include/gtk-2.0/gtk/gtkvpaned.h line 60
unsigned long int gtk_vpaned_get_type(void);
// gtk_widget_add_events
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1044
void gtk_widget_add_events(struct _GtkWidget *, signed int);
// gtk_widget_destroy
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 837
void gtk_widget_destroy(struct _GtkWidget *);
// gtk_widget_event
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 912
signed int gtk_widget_event(struct _GtkWidget *, union _GdkEvent *);
// gtk_widget_get_colormap
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1053
struct _GdkColormap * gtk_widget_get_colormap(struct _GtkWidget *);
// gtk_widget_get_style
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1141
struct _GtkStyle * gtk_widget_get_style(struct _GtkWidget *);
// gtk_widget_get_type
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 833
unsigned long int gtk_widget_get_type(void);
// gtk_widget_grab_focus
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 942
void gtk_widget_grab_focus(struct _GtkWidget *);
// gtk_widget_hide
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 853
void gtk_widget_hide(struct _GtkWidget *);
// gtk_widget_hide_on_delete
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1131
signed int gtk_widget_hide_on_delete(struct _GtkWidget *);
// gtk_widget_modify_base
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1155
void gtk_widget_modify_base(struct _GtkWidget *, enum anonymous$25, const struct _GdkColor *);
// gtk_widget_modify_bg
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1149
void gtk_widget_modify_bg(struct _GtkWidget *, enum anonymous$25, const struct _GdkColor *);
// gtk_widget_modify_fg
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1146
void gtk_widget_modify_fg(struct _GtkWidget *, enum anonymous$25, const struct _GdkColor *);
// gtk_widget_modify_font
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1161
void gtk_widget_modify_font(struct _GtkWidget *, struct _PangoFontDescription *);
// gtk_widget_realize
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 860
void gtk_widget_realize(struct _GtkWidget *);
// gtk_widget_set_sensitive
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 964
void gtk_widget_set_sensitive(struct _GtkWidget *, signed int);
// gtk_widget_set_uposition
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 1034
void gtk_widget_set_uposition(struct _GtkWidget *, signed int, signed int);
// gtk_widget_show
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 851
void gtk_widget_show(struct _GtkWidget *);
// gtk_widget_show_all
// file /usr/include/gtk-2.0/gtk/gtkwidget.h line 854
void gtk_widget_show_all(struct _GtkWidget *);
// gtk_window_get_type
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 178
unsigned long int gtk_window_get_type(void);
// gtk_window_move
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 379
void gtk_window_move(struct _GtkWindow *, signed int, signed int);
// gtk_window_new
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 179
struct _GtkWidget * gtk_window_new(enum anonymous$67);
// gtk_window_set_default_size
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 367
void gtk_window_set_default_size(struct _GtkWindow *, signed int, signed int);
// gtk_window_set_geometry_hints
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 246
void gtk_window_set_geometry_hints(struct _GtkWindow *, struct _GtkWidget *, struct _GdkGeometry *, enum anonymous$53);
// gtk_window_set_policy
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 357
void gtk_window_set_policy(struct _GtkWindow *, signed int, signed int, signed int);
// gtk_window_set_transient_for
// file /usr/include/gtk-2.0/gtk/gtkwindow.h line 206
void gtk_window_set_transient_for(struct _GtkWindow *, struct _GtkWindow *);
// handle_local_command
// file p_cmd.c line 1053
extern signed int handle_local_command(const char *cp, const char *cpnext);
// handle_query
// file ./proto.h line 20
void handle_query(char *data, signed int len);
// help_bind
// file p_cmd.c line 531
static const char * help_bind(void);
// help_clienthelp
// file p_cmd.c line 212
static const char * help_clienthelp(void);
// help_cwindow
// file p_cmd.c line 563
static const char * help_cwindow(void);
// help_help
// file p_cmd.c line 297
static const char * help_help(void);
// help_inv
// file p_cmd.c line 555
static const char * help_inv(void);
// help_magicmap
// file p_cmd.c line 547
static const char * help_magicmap(void);
// help_metaserver
// file p_cmd.c line 618
static const char * help_metaserver(void);
// help_savewinpos
// file p_cmd.c line 605
static const char * help_savewinpos(void);
// help_script
// file p_cmd.c line 580
static const char * help_script(void);
// help_scriptkill
// file p_cmd.c line 639
static const char * help_scriptkill(void);
// help_scripttell
// file p_cmd.c line 590
static const char * help_scripttell(void);
// help_serverhelp
// file p_cmd.c line 249
static const char * help_serverhelp(void);
// help_showweight
// file p_cmd.c line 653
static const char * help_showweight(void);
// help_unbind
// file p_cmd.c line 539
static const char * help_unbind(void);
// hide_all_login_windows
// file account.c line 103
extern void hide_all_login_windows(void);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// image_add_hash
// file image.c line 298
static struct Cache_Entry * image_add_hash(char *imagename, char *filename, unsigned int checksum, unsigned int ispublic);
// image_find_cache_entry
// file image.c line 274
static struct Cache_Entry * image_find_cache_entry(char *imagename, unsigned int checksum, signed int has_sum);
// image_find_hash
// file image.c line 210
static signed int image_find_hash(char *str);
// image_hash_name
// file image.c line 190
static unsigned int image_hash_name(char *str, signed int tablesize);
// image_process_line
// file image.c line 342
static void image_process_line(char *line, unsigned int ispublic);
// image_remove_hash
// file image.c line 239
static void image_remove_hash(char *imagename, struct Cache_Entry *ce);
// image_update_download_status
// file image.c line 494
extern void image_update_download_status(signed int start, signed int end, signed int total);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// info_buffer_flush
// file info.c line 1003
extern void info_buffer_flush(const signed int id);
// info_buffer_init
// file info.c line 976
extern void info_buffer_init(void);
// info_buffer_tick
// file info.c line 1052
extern void info_buffer_tick(void);
// info_get_styles
// file gtk2proto.h line 67
extern void info_get_styles(void);
// info_init
// file info.c line 616
extern void info_init(struct _GtkWidget *window_root);
// init_SDL
// file gtk2proto.h line 237
extern void init_SDL(struct _GtkWidget *sdl_window, signed int just_lightmap);
// init_account_password_window
// file account.c line 1264
static void init_account_password_window();
// init_add_character_window
// file account.c line 399
static void init_add_character_window();
// init_choose_char_window
// file account.c line 642
static void init_choose_char_window();
// init_client_vars
// file ../../common/proto.h line 57
void init_client_vars(void);
// init_commands
// file p_cmd.h line 84
extern void init_commands(void);
// init_common_cache_data
// file ../../common/proto.h line 44
void init_common_cache_data(void);
// init_connection
// file ../../common/proto.h line 3
signed int init_connection(char *host, signed int port);
// init_create_account_window
// file account.c line 883
static void init_create_account_window();
// init_create_character_window
// file create_char.c line 794
extern void init_create_character_window();
// init_default_keybindings
// file keys.c line 496
static void init_default_keybindings();
// init_glx_opengl
// file opengl.c line 118
extern void init_glx_opengl(struct _GtkWidget *drawingarea);
// init_image_cache_data
// file image.c line 574
extern void init_image_cache_data(void);
// init_login_window
// file account.c line 1077
static void init_login_window();
// init_menu_items
// file gtk2proto.h line 174
extern void init_menu_items();
// init_metaserver
// file ./proto.h line 103
void init_metaserver(void);
// init_new_character_window
// file account.c line 223
static void init_new_character_window();
// init_opengl
// file gtk2proto.h line 185
extern void init_opengl(struct _GtkWidget *drawingarea);
// init_opengl_common
// file opengl.c line 72
static void init_opengl_common(void);
// init_sockets
// file main.c line 660
static void init_sockets();
// init_sounds
// file sound.c line 49
signed int init_sounds();
// init_theme
// file config.c line 128
extern void init_theme();
// init_ui
// file main.c line 687
static void init_ui();
// inscribe_magical_scroll
// file item.c line 783
void inscribe_magical_scroll(struct item_struct *scroll, struct Spell_struct *spell);
// insert_item_before_item
// file item.c line 72
static void insert_item_before_item(struct item_struct *newitem, struct item_struct *before);
// inventory_get_styles
// file gtk2proto.h line 93
extern void inventory_get_styles(void);
// inventory_init
// file inventory.c line 454
extern void inventory_init(struct _GtkWidget *window_root);
// inventory_tick
// file inventory.c line 1295
extern void inventory_tick(void);
// item_actions
// file commands.c line 1627
void item_actions(struct item_struct *op);
// item_event_container_clearing
// file inventory.c line 702
extern void item_event_container_clearing(struct item_struct *container);
// item_event_item_changed
// file inventory.c line 703
extern void item_event_item_changed(struct item_struct *it);
// item_event_item_deleting
// file inventory.c line 701
extern void item_event_item_deleting(struct item_struct *it);
// keybind_find
// file keys.c line 199
static struct keybind * keybind_find(unsigned int keysym, unsigned int flags, signed int scope);
// keybind_free
// file keys.c line 302
static void keybind_free(struct keybind **entry);
// keybind_insert
// file keys.c line 228
static signed int keybind_insert(unsigned int keysym, unsigned int flags, const char *command);
// keybind_overwrite_confirm
// file keys.c line 2085
static signed int keybind_overwrite_confirm(struct keybind *kb);
// keybind_remove
// file keys.c line 282
static signed int keybind_remove(struct keybind *entry);
// keybinding_get_data
// file keys.c line 2272
static void keybinding_get_data(unsigned int *keysym, unsigned char *flags, const char **command);
// keybinding_selection_func
// file keys.c line 2456
extern signed int keybinding_selection_func(struct _GtkTreeSelection *selection, struct _GtkTreeModel *model, struct _GtkTreePath *path, signed int path_currently_selected, void *userdata);
// keybindings_init
// file gtk2proto.h line 117
extern void keybindings_init(const char *character_name);
// keyfunc
// file keys.c line 1570
extern void keyfunc(struct _GtkWidget *widget, struct _GdkEventKey *event, struct _GtkWidget *window);
// keyrelfunc
// file keys.c line 1556
extern void keyrelfunc(struct _GtkWidget *widget, struct _GdkEventKey *event, struct _GtkWidget *window);
// keys_init
// file keys.c line 633
extern void keys_init(struct _GtkWidget *window_root);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// l_readerfile
// file script_lua.c line 61
static const char * l_readerfile(struct lua_State *L, void *data, unsigned long int *size);
// list_item_action
// file inventory.c line 199
static void list_item_action(struct _GdkEventButton *event, struct item_struct *tmp);
// list_row_collapse
// file inventory.c line 314
extern void list_row_collapse(struct _GtkTreeView *treeview, struct _GtkTreeIter *iter, struct _GtkTreePath *path, void *user_data);
// list_selection_func
// file inventory.c line 269
extern signed int list_selection_func(struct _GtkTreeSelection *selection, struct _GtkTreeModel *model, struct _GtkTreePath *path, signed int path_currently_selected, void *userdata);
// load_defaults
// file config.c line 264
extern void load_defaults(void);
// load_image
// file image.c line 57
static signed int load_image(char *filename, unsigned char *data, signed int *len, unsigned int *csum);
// load_msgctrl_configuration
// file info.c line 1589
extern void load_msgctrl_configuration(void);
// load_theme
// file config.c line 199
extern void load_theme(signed int reload);
// load_window_positions
// file config.c line 1165
extern void load_window_positions(struct _GtkWidget *window_root);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// locate_item
// file ../../common/proto.h line 65
struct item_struct * locate_item(signed int tag);
// locate_item_from_item
// file item.c line 281
static struct item_struct * locate_item_from_item(struct item_struct *op, signed int tag);
// logChildPipe
// file ../../common/proto.h line 118
void logChildPipe(struct ChildProcess *child, enum LogLevel level, signed int flag);
// logPipe
// file misc.c line 287
void logPipe(struct ChildProcess *child, enum LogLevel level, signed int pipe);
// look_at
// file ../../common/proto.h line 136
void look_at(signed int x, signed int y);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// luaL_newstate
// file /usr/include/lua5.1/lauxlib.h line 82
extern struct lua_State * luaL_newstate(void);
// lua_close
// file /usr/include/lua5.1/lua.h line 111
extern void lua_close(struct lua_State *);
// lua_createtable
// file /usr/include/lua5.1/lua.h line 181
extern void lua_createtable(struct lua_State *, signed int, signed int);
// lua_draw
// file script_lua.c line 174
static signed int lua_draw(struct lua_State *L);
// lua_error
// file /usr/include/lua5.1/lua.h line 237
extern signed int lua_error(struct lua_State *);
// lua_gettable
// file /usr/include/lua5.1/lua.h line 177
extern void lua_gettable(struct lua_State *, signed int);
// lua_gettop
// file /usr/include/lua5.1/lua.h line 120
extern signed int lua_gettop(struct lua_State *);
// lua_isnumber
// file /usr/include/lua5.1/lua.h line 135
extern signed int lua_isnumber(struct lua_State *, signed int);
// lua_isstring
// file /usr/include/lua5.1/lua.h line 136
extern signed int lua_isstring(struct lua_State *, signed int);
// lua_issue
// file script_lua.c line 193
static signed int lua_issue(struct lua_State *L);
// lua_load
// file /usr/include/lua5.1/lua.h line 204
extern signed int lua_load(struct lua_State *, const char * (*)(struct lua_State *, void *, unsigned long int *), void *, const char *);
// lua_pcall
// file /usr/include/lua5.1/lua.h line 202
extern signed int lua_pcall(struct lua_State *, signed int, signed int, signed int);
// lua_pushcclosure
// file /usr/include/lua5.1/lua.h line 168
extern void lua_pushcclosure(struct lua_State *, signed int (*)(struct lua_State *), signed int);
// lua_pushnumber
// file /usr/include/lua5.1/lua.h line 161
extern void lua_pushnumber(struct lua_State *, double);
// lua_pushstring
// file /usr/include/lua5.1/lua.h line 164
extern void lua_pushstring(struct lua_State *, const char *);
// lua_setfield
// file /usr/include/lua5.1/lua.h line 191
extern void lua_setfield(struct lua_State *, signed int, const char *);
// lua_settable
// file /usr/include/lua5.1/lua.h line 190
extern void lua_settable(struct lua_State *, signed int);
// lua_settop
// file /usr/include/lua5.1/lua.h line 121
extern void lua_settop(struct lua_State *, signed int);
// lua_tolstring
// file /usr/include/lua5.1/lua.h line 149
extern const char * lua_tolstring(struct lua_State *, signed int, unsigned long int *);
// lua_tonumber
// file /usr/include/lua5.1/lua.h line 146
extern double lua_tonumber(struct lua_State *, signed int);
// lua_type
// file /usr/include/lua5.1/lua.h line 139
extern signed int lua_type(struct lua_State *, signed int);
// luaopen_base
// file /usr/include/lua5.1/lualib.h line 19
extern signed int luaopen_base(struct lua_State *);
// luaopen_table
// file /usr/include/lua5.1/lualib.h line 22
extern signed int luaopen_table(struct lua_State *);
// magic_map_flash_pos
// file magicmap.c line 114
void magic_map_flash_pos(void);
// make_path_to_dir
// file ./proto.h line 111
signed int make_path_to_dir(char *directory);
// make_path_to_file
// file ../../common/proto.h line 112
signed int make_path_to_file(char *filename);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// map_init
// file gtk2proto.h line 153
extern void map_init(struct _GtkWidget *window_root);
// map_item
// file ./proto.h line 74
struct item_struct * map_item(void);
// map_scrollCmd
// file ./proto.h line 33
void map_scrollCmd(char *data, signed int len);
// mapdata_animation
// file ../../common/proto.h line 97
void mapdata_animation(void);
// mapdata_bigface
// file ../../common/proto.h line 95
signed short int mapdata_bigface(signed int x, signed int y, signed int layer, signed int *ww, signed int *hh);
// mapdata_bigface_head
// file ../../common/proto.h line 96
signed short int mapdata_bigface_head(signed int x, signed int y, signed int layer, signed int *ww, signed int *hh);
// mapdata_clear_old
// file ./proto.h line 89
void mapdata_clear_old(signed int x, signed int y);
// mapdata_clear_space
// file ./proto.h line 85
void mapdata_clear_space(signed int x, signed int y);
// mapdata_face
// file ../../common/proto.h line 94
signed short int mapdata_face(signed int x, signed int y, signed int layer);
// mapdata_get_image_size
// file mapdata.c line 1256
static void mapdata_get_image_size(signed int face, unsigned char *w, unsigned char *h);
// mapdata_init
// file ../../common/proto.h line 81
void mapdata_init(void);
// mapdata_is_inside
// file mapdata.c line 595
signed int mapdata_is_inside(signed int x, signed int y);
// mapdata_newmap
// file ./proto.h line 93
void mapdata_newmap(void);
// mapdata_reset
// file ../../common/proto.h line 82
void mapdata_reset(void);
// mapdata_scroll
// file ./proto.h line 92
void mapdata_scroll(signed int dx, signed int dy);
// mapdata_set_anim_layer
// file ./proto.h line 91
void mapdata_set_anim_layer(signed int x, signed int y, unsigned short int anim, unsigned char anim_speed, signed int layer);
// mapdata_set_check_space
// file ./proto.h line 86
void mapdata_set_check_space(signed int x, signed int y);
// mapdata_set_darkness
// file ./proto.h line 87
void mapdata_set_darkness(signed int x, signed int y, signed int darkness);
// mapdata_set_face_layer
// file ./proto.h line 90
void mapdata_set_face_layer(signed int x, signed int y, signed short int face, signed int layer);
// mapdata_set_size
// file ../../common/proto.h line 83
void mapdata_set_size(signed int viewx, signed int viewy);
// mapdata_set_smooth
// file ./proto.h line 88
void mapdata_set_smooth(signed int x, signed int y, signed int smooth, signed int layer);
// mapping_sort
// file stats.c line 515
static signed int mapping_sort(struct anonymous$66 *a, struct anonymous$66 *b);
// mark_resmooth
// file mapdata.c line 158
static void mark_resmooth(signed int x, signed int y, signed int layer);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// menu_about
// file about.c line 41
extern void menu_about(struct _GtkMenuItem *menuitem, void *user_data);
// menu_clear
// file info.c line 1278
extern void menu_clear(void);
// menu_quit_character
// file menubar.c line 88
extern void menu_quit_character(struct _GtkMenuItem *menuitem, void *user_data);
// menu_quit_program
// file menubar.c line 68
extern void menu_quit_program(struct _GtkMenuItem *menuitem, void *user_data);
// message_callback
// file info.c line 1110
static void message_callback(signed int orig_color, signed int type, signed int subtype, char *message);
// meta_sort
// file ../../common/metaserver.h line 80
extern signed int meta_sort(struct Meta_Info *m1, struct Meta_Info *m2);
// metaserver1_get_info
// file metaserver.c line 822
signed int metaserver1_get_info(void);
// metaserver1_thread
// file metaserver.c line 636
void * metaserver1_thread(void *junk);
// metaserver2_get_info
// file metaserver.c line 502
signed int metaserver2_get_info(void);
// metaserver2_thread
// file metaserver.c line 472
void * metaserver2_thread(void *junk);
// metaserver2_writer
// file metaserver.c line 298
unsigned long int metaserver2_writer(void *ptr, unsigned long int size, unsigned long int nmemb, void *data);
// metaserver_check_status
// file ../../common/proto.h line 106
signed int metaserver_check_status(void);
// metaserver_connect_to
// file metaserver.c line 246
static void metaserver_connect_to(const char *name);
// metaserver_get_info
// file ../../common/proto.h line 107
signed int metaserver_get_info(char *metaserver, signed int meta_port);
// metaserver_load_cache
// file metaserver.c line 122
static void metaserver_load_cache(void);
// metaserver_save_cache
// file metaserver.c line 154
static void metaserver_save_cache(void);
// metaserver_select
// file metaserver.c line 971
signed int metaserver_select(char *sel);
// metaserver_selection_func
// file metaserver.c line 53
extern signed int metaserver_selection_func(struct _GtkTreeSelection *selection, struct _GtkTreeModel *model, struct _GtkTreePath *path, signed int path_currently_selected, void *userdata);
// metaserver_show
// file metaserver.c line 905
void metaserver_show(signed int show_selection);
// metaserver_update_cache
// file ../../common/metaserver.h line 93
extern void metaserver_update_cache(const char *server_name, const char *server_ip);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// monitorChilds
// file misc.c line 246
void monitorChilds(void);
// move_player
// file ../../common/proto.h line 140
void move_player(signed int dir);
// msgctrl_init
// file info.c line 1340
extern void msgctrl_init(struct _GtkWidget *window_root);
// my_log_handler
// file main.c line 655
extern void my_log_handler(const char *log_domain, enum anonymous$52 log_level, const char *message, void *user_data);
// negotiate_connection
// file ../../common/proto.h line 4
void negotiate_connection(signed int sound);
// new_char_window_update_info
// file create_char.c line 636
void new_char_window_update_info();
// new_item
// file item.c line 213
static struct item_struct * new_item(void);
// new_menu_pickup
// file pickup.c line 96
static void new_menu_pickup(signed int on, signed int val);
// new_player
// file ./proto.h line 135
void new_player(signed long int tag, char *name, signed long int weight, signed long int face);
// num_free_items
// file item.c line 458
signed int num_free_items(void);
// on_about_close_clicked
// file about.c line 67
extern void on_about_close_clicked(struct _GtkButton *button, void *user_data);
// on_button_account_password_cancel_clicked
// file account.c line 1194
void on_button_account_password_cancel_clicked(struct _GtkButton *button, void *user_data);
// on_button_account_password_clicked
// file account.c line 549
void on_button_account_password_clicked(struct _GtkButton *button, void *user_data);
// on_button_account_password_confirm_clicked
// file account.c line 1206
void on_button_account_password_confirm_clicked(struct _GtkButton *button, void *user_data);
// on_button_add_character_clicked
// file account.c line 522
extern void on_button_add_character_clicked(struct _GtkButton *button, void *user_data);
// on_button_cc_cancel
// file create_char.c line 370
void on_button_cc_cancel(struct _GtkButton *button, void *user_data);
// on_button_cc_done
// file create_char.c line 501
void on_button_cc_done(struct _GtkButton *button, void *user_data);
// on_button_choose_starting_map
// file create_char.c line 385
void on_button_choose_starting_map(struct _GtkButton *button, void *user_data);
// on_button_create_account_clicked
// file account.c line 955
extern void on_button_create_account_clicked(struct _GtkButton *button, void *user_data);
// on_button_create_character_clicked
// file account.c line 505
extern void on_button_create_character_clicked(struct _GtkButton *button, void *user_data);
// on_button_create_new_char_clicked
// file account.c line 194
extern void on_button_create_new_char_clicked(struct _GtkButton *button, void *user_data);
// on_button_csm_cancel
// file create_char.c line 724
void on_button_csm_cancel(struct _GtkButton *button, void *user_data);
// on_button_do_add_character_clicked
// file account.c line 344
extern void on_button_do_add_character_clicked(struct _GtkButton *button, void *user_data);
// on_button_exit_client_clicked
// file account.c line 988
extern void on_button_exit_client_clicked(struct _GtkButton *button, void *user_data);
// on_button_go_metaserver_clicked
// file account.c line 972
extern void on_button_go_metaserver_clicked(struct _GtkButton *button, void *user_data);
// on_button_login_clicked
// file account.c line 1030
extern void on_button_login_clicked(struct _GtkButton *button, void *user_data);
// on_button_metaserver_quit_pressed
// file metaserver.c line 355
extern void on_button_metaserver_quit_pressed(struct _GtkButton *button, void *user_data);
// on_button_new_cancel_clicked
// file account.c line 826
extern void on_button_new_cancel_clicked(struct _GtkButton *button, void *user_data);
// on_button_new_char_cancel_clicked
// file account.c line 215
extern void on_button_new_char_cancel_clicked(struct _GtkButton *button, void *user_data);
// on_button_new_create_account_clicked
// file account.c line 805
extern void on_button_new_create_account_clicked(struct _GtkButton *button, void *user_data);
// on_button_play_character_clicked
// file account.c line 483
extern void on_button_play_character_clicked(struct _GtkButton *button, void *user_data);
// on_button_return_character_select_clicked
// file account.c line 358
extern void on_button_return_character_select_clicked(struct _GtkButton *button, void *user_data);
// on_button_return_login_clicked
// file account.c line 537
extern void on_button_return_login_clicked(struct _GtkButton *button, void *user_data);
// on_combobox_rcs_changed
// file create_char.c line 538
void on_combobox_rcs_changed(struct _GtkComboBox *box, void *user_data);
// on_combobox_starting_map_changed
// file create_char.c line 731
void on_combobox_starting_map_changed(struct _GtkComboBox *box, void *user_data);
// on_config_button_apply_clicked
// file config.c line 1065
extern void on_config_button_apply_clicked(struct _GtkButton *button, void *user_data);
// on_config_button_close_clicked
// file config.c line 1076
extern void on_config_button_close_clicked(struct _GtkButton *button, void *user_data);
// on_config_button_save_clicked
// file config.c line 1053
extern void on_config_button_save_clicked(struct _GtkButton *button, void *user_data);
// on_configure_activate
// file config.c line 1086
extern void on_configure_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_disconnect_activate
// file menubar.c line 48
void on_disconnect_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_drawingarea_magic_map_expose_event
// file magicmap.c line 150
signed int on_drawingarea_magic_map_expose_event(struct _GtkWidget *widget, struct _GdkEventExpose *event, void *user_data);
// on_drawingarea_map_button_press_event
// file map.c line 697
extern signed int on_drawingarea_map_button_press_event(struct _GtkWidget *widget, struct _GdkEventButton *event, void *user_data);
// on_drawingarea_map_configure_event
// file map.c line 580
extern signed int on_drawingarea_map_configure_event(struct _GtkWidget *widget, struct _GdkEventConfigure *event, void *user_data);
// on_drawingarea_map_expose_event
// file map.c line 681
extern signed int on_drawingarea_map_expose_event(struct _GtkWidget *widget, struct _GdkEventExpose *event, void *user_data);
// on_entry_account_name_activate
// file account.c line 1042
extern void on_entry_account_name_activate(struct _GtkEntry *entry, void *user_data);
// on_entry_account_password
// file account.c line 1223
void on_entry_account_password(struct _GtkEntry *entry, void *user_data);
// on_entry_account_password_activate
// file account.c line 1061
extern void on_entry_account_password_activate(struct _GtkEntry *entry, void *user_data);
// on_entry_character
// file account.c line 372
extern void on_entry_character(struct _GtkEntry *entry, void *user_data);
// on_entry_commands_activate
// file keys.c line 1835
extern void on_entry_commands_activate(struct _GtkEntry *entry, void *user_data);
// on_entry_new_account
// file account.c line 841
extern void on_entry_new_account(struct _GtkEntry *entry, void *user_data);
// on_entry_new_character_name
// file account.c line 204
extern void on_entry_new_character_name(struct _GtkEntry *entry, void *user_data);
// on_inv_table_expose_event
// file inventory.c line 1152
extern signed int on_inv_table_expose_event(struct _GtkWidget *widget, struct _GdkEventExpose *event, void *user_data);
// on_kb_scope_togglebutton_character_toggled
// file keys.c line 2196
extern void on_kb_scope_togglebutton_character_toggled(struct _GtkToggleButton *toggle_button, void *user_data);
// on_kb_scope_togglebutton_global_toggled
// file keys.c line 2218
extern void on_kb_scope_togglebutton_global_toggled(struct _GtkToggleButton *toggle_button, void *user_data);
// on_keybinding_button_bind_clicked
// file keys.c line 2339
extern void on_keybinding_button_bind_clicked(struct _GtkButton *button, void *user_data);
// on_keybinding_button_clear_clicked
// file keys.c line 2564
extern void on_keybinding_button_clear_clicked(struct _GtkButton *button, void *user_data);
// on_keybinding_button_close_clicked
// file keys.c line 2422
extern void on_keybinding_button_close_clicked(struct _GtkButton *button, void *user_data);
// on_keybinding_button_remove_clicked
// file keys.c line 2240
extern void on_keybinding_button_remove_clicked(struct _GtkButton *button, void *user_data);
// on_keybinding_button_update_clicked
// file keys.c line 2373
extern void on_keybinding_button_update_clicked(struct _GtkButton *button, void *user_data);
// on_keybinding_checkbutton_any_clicked
// file keys.c line 2432
extern void on_keybinding_checkbutton_any_clicked(struct _GtkCheckButton *cb, void *user_data);
// on_keybinding_entry_key_key_press_event
// file keys.c line 1992
extern signed int on_keybinding_entry_key_key_press_event(struct _GtkWidget *widget, struct _GdkEventKey *event, void *user_data);
// on_keybindings_activate
// file keys.c line 1974
extern void on_keybindings_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_all_weapons_activate
// file gtk2proto.h line 213
extern void on_menu_all_weapons_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_arrows_activate
// file gtk2proto.h line 216
extern void on_menu_arrows_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_body_armor_activate
// file gtk2proto.h line 193
extern void on_menu_body_armor_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_boots_activate
// file gtk2proto.h line 194
extern void on_menu_boots_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_bows_activate
// file gtk2proto.h line 215
extern void on_menu_bows_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_cloaks_activate
// file gtk2proto.h line 195
extern void on_menu_cloaks_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_containers_activate
// file gtk2proto.h line 211
extern void on_menu_containers_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_dont_pickup_activate
// file gtk2proto.h line 191
extern void on_menu_dont_pickup_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_drinks_activate
// file gtk2proto.h line 202
extern void on_menu_drinks_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_flesh_activate
// file gtk2proto.h line 212
extern void on_menu_flesh_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_food_activate
// file gtk2proto.h line 203
extern void on_menu_food_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_gloves_activate
// file gtk2proto.h line 196
extern void on_menu_gloves_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_helmets_activate
// file gtk2proto.h line 197
extern void on_menu_helmets_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_jewels_activate
// file gtk2proto.h line 210
extern void on_menu_jewels_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_keys_activate
// file gtk2proto.h line 204
extern void on_menu_keys_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_magical_items_activate
// file gtk2proto.h line 205
extern void on_menu_magical_items_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_missile_weapons_activate
// file gtk2proto.h line 214
extern void on_menu_missile_weapons_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_normal_book_scrolls_activate
// file gtk2proto.h line 200
extern void on_menu_normal_book_scrolls_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_not_cursed_activate
// file gtk2proto.h line 209
extern void on_menu_not_cursed_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_potions_activate
// file gtk2proto.h line 206
extern void on_menu_potions_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_ratio_10_activate
// file gtk2proto.h line 219
extern void on_menu_ratio_10_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_ratio_15_activate
// file gtk2proto.h line 220
extern void on_menu_ratio_15_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_ratio_20_activate
// file gtk2proto.h line 221
extern void on_menu_ratio_20_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_ratio_25_activate
// file gtk2proto.h line 222
extern void on_menu_ratio_25_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_ratio_30_activate
// file pickup.c line 364
extern void on_menu_ratio_30_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_ratio_35_activate
// file gtk2proto.h line 224
extern void on_menu_ratio_35_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_ratio_40_activate
// file gtk2proto.h line 225
extern void on_menu_ratio_40_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_ratio_45_activate
// file gtk2proto.h line 226
extern void on_menu_ratio_45_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_ratio_50_activate
// file gtk2proto.h line 227
extern void on_menu_ratio_50_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_ratio_5_activate
// file gtk2proto.h line 218
extern void on_menu_ratio_5_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_ratio_pickup_off_activate
// file gtk2proto.h line 217
extern void on_menu_ratio_pickup_off_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_shields_activate
// file gtk2proto.h line 198
extern void on_menu_shields_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_skillscrolls_activate
// file gtk2proto.h line 199
extern void on_menu_skillscrolls_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_spellbooks_activate
// file gtk2proto.h line 201
extern void on_menu_spellbooks_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_stop_before_pickup_activate
// file gtk2proto.h line 192
extern void on_menu_stop_before_pickup_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_valuables_activate
// file gtk2proto.h line 207
extern void on_menu_valuables_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_menu_wands_rods_horns_activate
// file gtk2proto.h line 208
extern void on_menu_wands_rods_horns_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_metaserver_select_clicked
// file metaserver.c line 283
extern void on_metaserver_select_clicked(struct _GtkButton *button, void *user_data);
// on_metaserver_text_entry_activate
// file metaserver.c line 342
extern void on_metaserver_text_entry_activate(struct _GtkEntry *entry, void *user_data);
// on_metaserver_text_entry_key_press_event
// file metaserver.c line 368
extern signed int on_metaserver_text_entry_key_press_event(struct _GtkWidget *widget, struct _GdkEventKey *event, void *user_data);
// on_msgctrl_activate
// file info.c line 1907
extern void on_msgctrl_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_msgctrl_button_apply_clicked
// file info.c line 1877
extern void on_msgctrl_button_apply_clicked(struct _GtkButton *button, void *user_data);
// on_msgctrl_button_close_clicked
// file info.c line 1891
extern void on_msgctrl_button_close_clicked(struct _GtkButton *button, void *user_data);
// on_msgctrl_button_defaults_clicked
// file info.c line 1862
extern void on_msgctrl_button_defaults_clicked(struct _GtkButton *button, void *user_data);
// on_msgctrl_button_load_clicked
// file info.c line 1848
extern void on_msgctrl_button_load_clicked(struct _GtkButton *button, void *user_data);
// on_msgctrl_button_save_clicked
// file info.c line 1832
extern void on_msgctrl_button_save_clicked(struct _GtkButton *button, void *user_data);
// on_notebook_switch_page
// file inventory.c line 1130
extern void on_notebook_switch_page(struct _GtkNotebook *notebook, struct _GtkNotebookPage *page, unsigned int page_num, void *user_data);
// on_save_window_position_activate
// file config.c line 1150
extern void on_save_window_position_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_skill_close_clicked
// file skills.c line 271
extern void on_skill_close_clicked(struct _GtkButton *button, void *user_data);
// on_skill_ready_clicked
// file skills.c line 242
extern void on_skill_ready_clicked(struct _GtkButton *button, void *user_data);
// on_skill_treeview_row_activated
// file skills.c line 225
extern void on_skill_treeview_row_activated(struct _GtkTreeView *treeview, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data);
// on_skill_use_clicked
// file skills.c line 257
extern void on_skill_use_clicked(struct _GtkButton *button, void *user_data);
// on_skills_activate
// file gtk2proto.h line 243
extern void on_skills_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_spell_cast_clicked
// file spells.c line 527
extern void on_spell_cast_clicked(struct _GtkButton *button, void *user_data);
// on_spell_close_clicked
// file spells.c line 583
extern void on_spell_close_clicked(struct _GtkButton *button, void *user_data);
// on_spell_invoke_clicked
// file spells.c line 555
extern void on_spell_invoke_clicked(struct _GtkButton *button, void *user_data);
// on_spell_treeview_row_activated
// file spells.c line 495
extern void on_spell_treeview_row_activated(struct _GtkTreeView *treeview, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data);
// on_spell_window_size_allocate
// file spells.c line 127
extern void on_spell_window_size_allocate(struct _GtkWidget *widget, void *user_data);
// on_spells_activate
// file gtk2proto.h line 258
extern void on_spells_activate(struct _GtkMenuItem *menuitem, void *user_data);
// on_spinbutton_cc
// file create_char.c line 519
void on_spinbutton_cc(struct _GtkSpinButton *spinbutton, void *user_data);
// on_treeview_choose_character_activated
// file account.c line 618
extern void on_treeview_choose_character_activated(struct _GtkTreeView *treeview, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data);
// on_treeview_metaserver_row_activated
// file metaserver.c line 322
extern void on_treeview_metaserver_row_activated(struct _GtkTreeView *treeview, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data);
// on_window_delete_event
// file account.c line 134
extern signed int on_window_delete_event(struct _GtkWidget *window, void **user_data);
// on_window_destroy_event
// file main.c line 165
extern void on_window_destroy_event(struct _GtkObject *object, void *user_data);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// open_container
// file inventory.c line 604
extern void open_container(struct item_struct *op);
// opengl_free_pixmap
// file gtk2proto.h line 188
extern void opengl_free_pixmap(struct PixmapInfo *pi);
// opengl_gen_map
// file gtk2proto.h line 186
extern void opengl_gen_map(signed int redraw);
// opengl_light_space
// file opengl.c line 281
static void opengl_light_space(signed int x, signed int y, signed int mx, signed int my);
// overlay_grid
// file sdl.c line 117
static void overlay_grid(signed int re_init, signed int ax, signed int ay);
// pango_font_description_get_type
// file /usr/include/pango-1.0/pango/pango-font.h line 217
unsigned long int pango_font_description_get_type(void);
// parse_args
// file main.c line 350
static signed int parse_args(signed int argc, char **argv);
// parse_key
// file keys.c line 826
static void parse_key(char key, unsigned int keysym);
// parse_key_release
// file keys.c line 787
static void parse_key_release(unsigned int keysym);
// parse_keybind_line
// file keys.c line 316
static void parse_keybind_line(char *buf, signed int line, unsigned int scope_flag);
// parse_keys_file
// file keys.c line 517
static signed int parse_keys_file(char *filename, unsigned int scope_flag);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pickup_init
// file gtk2proto.h line 228
extern void pickup_init(struct _GtkWidget *window_root);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// play_character
// file account.c line 466
static void play_character(const char *name);
// play_sound_effect
// file sound.c line 117
void play_sound_effect(signed char x, signed char y, unsigned char dir, unsigned char vol, unsigned char type, const char *sound, const char *source);
// player_item
// file ./proto.h line 73
struct item_struct * player_item(void);
// png_create_info_struct
// file /usr/include/libpng12/png.h line 1426
extern struct png_info_struct * png_create_info_struct(struct png_struct_def *);
// png_create_read_struct
// file /usr/include/libpng12/png.h line 1376
extern struct png_struct_def * png_create_read_struct(const char *, void *, void (*)(struct png_struct_def *, const char *), void (*)(struct png_struct_def *, const char *));
// png_destroy_read_struct
// file /usr/include/libpng12/png.h line 1672
extern void png_destroy_read_struct(struct png_struct_def **, struct png_info_struct **, struct png_info_struct **);
// png_get_IHDR
// file /usr/include/libpng12/png.h line 2156
extern unsigned long int png_get_IHDR(struct png_struct_def *, struct png_info_struct *, unsigned long int *, unsigned long int *, signed int *, signed int *, signed int *, signed int *, signed int *);
// png_get_bit_depth
// file /usr/include/libpng12/png.h line 2038
extern unsigned char png_get_bit_depth(struct png_struct_def *, struct png_info_struct *);
// png_get_color_type
// file /usr/include/libpng12/png.h line 2042
extern unsigned char png_get_color_type(struct png_struct_def *, struct png_info_struct *);
// png_get_image_height
// file /usr/include/libpng12/png.h line 2034
extern unsigned long int png_get_image_height(struct png_struct_def *, struct png_info_struct *);
// png_get_image_width
// file /usr/include/libpng12/png.h line 2030
extern unsigned long int png_get_image_width(struct png_struct_def *, struct png_info_struct *);
// png_get_interlace_type
// file /usr/include/libpng12/png.h line 2050
extern unsigned char png_get_interlace_type(struct png_struct_def *, struct png_info_struct *);
// png_get_valid
// file /usr/include/libpng12/png.h line 2004
extern unsigned long int png_get_valid(struct png_struct_def *, struct png_info_struct *, unsigned long int);
// png_read_image
// file /usr/include/libpng12/png.h line 1641
extern void png_read_image(struct png_struct_def *, unsigned char **);
// png_read_info
// file /usr/include/libpng12/png.h line 1449
extern void png_read_info(struct png_struct_def *, struct png_info_struct *);
// png_read_update_info
// file /usr/include/libpng12/png.h line 1623
extern void png_read_update_info(struct png_struct_def *, struct png_info_struct *);
// png_set_expand
// file /usr/include/libpng12/png.h line 1470
extern void png_set_expand(struct png_struct_def *);
// png_set_filler
// file /usr/include/libpng12/png.h line 1525
extern void png_set_filler(struct png_struct_def *, unsigned long int, signed int);
// png_set_gray_to_rgb
// file /usr/include/libpng12/png.h line 1491
extern void png_set_gray_to_rgb(struct png_struct_def *);
// png_set_interlace_handling
// file /usr/include/libpng12/png.h line 1561
extern signed int png_set_interlace_handling(struct png_struct_def *);
// png_set_read_fn
// file /usr/include/libpng12/png.h line 1822
extern void png_set_read_fn(struct png_struct_def *, void *, void (*)(struct png_struct_def *, unsigned char *, unsigned long int));
// png_set_strip_16
// file /usr/include/libpng12/png.h line 1584
extern void png_set_strip_16(struct png_struct_def *);
// png_to_data
// file png.c line 71
unsigned char * png_to_data(unsigned char *data, signed int len, unsigned int *width, unsigned int *height);
// png_to_gdkpixmap
// file png.c line 558
signed int png_to_gdkpixmap(struct _GdkDrawable *window, unsigned char *data, signed int len, struct _GdkDrawable **pix, struct _GdkDrawable **mask, struct _GdkColormap *colormap);
// print_inventory
// file item.c line 678
void print_inventory(struct item_struct *op);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_race_class_info
// file commands.c line 470
static void process_race_class_info(char *data, signed int len, struct Race_Class_Info *rci);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$39 *, const union anonymous$38 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$39 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$39 *);
// purgePipe
// file misc.c line 210
void purgePipe(struct ChildProcess *cp, signed int pipe);
// putenv
// file /usr/include/stdlib.h line 578
extern signed int putenv(char *);
// putpixel
// file sdl.c line 78
static void putpixel(struct SDL_Surface *surface, signed int x, signed int y, unsigned int pixel);
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// raiseChild
// file ../../common/proto.h line 119
struct ChildProcess * raiseChild(char *name, signed int flag);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// rc_compar
// file commands.c line 406
static signed int rc_compar(const struct Race_Class_Info *a, const struct Race_Class_Info *b);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_config_window
// file config.c line 886
static void read_config_window(void);
// read_msgctrl_configuration
// file info.c line 1793
extern void read_msgctrl_configuration(void);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recenter_virtual_map_view
// file mapdata.c line 1099
static void recenter_virtual_map_view(signed int diff_x, signed int diff_y);
// remove_item
// file ./proto.h line 66
void remove_item(struct item_struct *op);
// remove_item_inventory
// file ../../common/proto.h line 67
void remove_item_inventory(struct item_struct *op);
// replace_chars_with_string
// file misc.c line 49
void replace_chars_with_string(char *buffer, const unsigned short int buffer_size, const char find, const char *replace);
// requestface
// file image.c line 415
void requestface(signed int pnum, char *facename);
// rescale_rgba_data
// file png.c line 262
unsigned char * rescale_rgba_data(unsigned char *data, signed int *width, signed int *height, signed int scale);
// reset_client_vars
// file ../../common/proto.h line 59
void reset_client_vars(void);
// reset_image_cache_data
// file ../../common/proto.h line 47
void reset_image_cache_data(void);
// reset_image_data
// file image.c line 459
extern void reset_image_data(void);
// reset_keybinding_status
// file keys.c line 2534
extern void reset_keybinding_status(void);
// reset_map
// file gtk2proto.h line 154
extern void reset_map(void);
// reset_player_data
// file ./proto.h line 58
void reset_player_data(void);
// resize_map_window
// file map.c line 569
extern void resize_map_window(signed int x, signed int y);
// rgba_to_gdkpixbuf
// file png.c line 514
signed int rgba_to_gdkpixbuf(unsigned char *data, signed int width, signed int height, struct _GdkPixbuf **pix);
// rgba_to_gdkpixmap
// file png.c line 455
signed int rgba_to_gdkpixmap(struct _GdkDrawable *window, unsigned char *data, signed int width, signed int height, struct _GdkDrawable **pix, struct _GdkDrawable **mask, struct _GdkColormap *colormap);
// run_dir
// file ../../common/proto.h line 147
void run_dir(signed int dir);
// save_defaults
// file config.c line 450
extern void save_defaults(void);
// save_individual_key
// file keys.c line 1256
static void save_individual_key(struct _IO_FILE *fp, struct keybind *kb, unsigned char kc);
// save_keys
// file keys.c line 1270
static void save_keys(void);
// save_msgctrl_configuration
// file info.c line 1520
extern void save_msgctrl_configuration(void);
// save_winpos
// file config.c line 1094
extern void save_winpos(void);
// scandir
// file /usr/include/dirent.h line 254
extern signed int scandir(const char *, struct dirent *** restrict , signed int (*)(struct dirent *), signed int (*)(struct dirent **, struct dirent **));
// scandir_theme_filter
// file config.c line 589
static signed int scandir_theme_filter(struct dirent *d);
// scandir_ui_filter
// file config.c line 607
static signed int scandir_ui_filter(struct dirent *d);
// script_by_name
// file script.c line 989
static signed int script_by_name(const char *name);
// script_dead
// file script.c line 1020
static void script_dead(signed int i);
// script_fdset
// file ../../common/script.h line 60
void script_fdset(signed int *maxfd, struct anonymous$51 *set);
// script_init
// file ./script.h line 53
void script_init(const char *cparams);
// script_kill
// file ./script.h line 56
void script_kill(const char *params);
// script_list
// file ./script.h line 54
void script_list(void);
// script_lua_command
// file ./proto.h line 157
signed int script_lua_command(const char *command, const char *param);
// script_lua_kill
// file ./proto.h line 155
void script_lua_kill(const char *param);
// script_lua_list
// file ./proto.h line 154
void script_lua_list(const char *param);
// script_lua_load
// file ./proto.h line 153
void script_lua_load(const char *name);
// script_lua_stats
// file ./proto.h line 156
void script_lua_stats(void);
// script_monitor
// file ./script.h line 63
void script_monitor(const char *command, signed int repeat, signed int must_send);
// script_monitor_str
// file ./script.h line 64
void script_monitor_str(const char *command);
// script_process
// file ../../common/script.h line 61
void script_process(struct anonymous$51 *set);
// script_process_cmd
// file script.c line 1076
static void script_process_cmd(signed int i);
// script_send_item
// file script.c line 1621
static void script_send_item(signed int i, const char *head, const struct item_struct *it);
// script_sync
// file ./script.h line 55
void script_sync(signed int commdiff);
// script_tell
// file ./script.h line 65
void script_tell(const char *params);
// script_watch
// file ./script.h line 62
void script_watch(const char *cmd, const unsigned char *data_initial, const signed int data_len, const enum CmdFormat format);
// sdl_gen_map
// file gtk2proto.h line 239
extern void sdl_gen_map(signed int redraw);
// sdl_mapscroll
// file gtk2proto.h line 240
extern signed int sdl_mapscroll(signed int dx, signed int dy);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$51 *, struct anonymous$51 *, struct anonymous$51 *, struct timeval *);
// send_command
// file ../../common/proto.h line 148
signed int send_command(const char *command, signed int repeat, signed int must_send);
// send_create_player_to_server
// file create_char.c line 268
static void send_create_player_to_server();
// send_map
// file script.c line 1053
static void send_map(signed int i, signed int x, signed int y);
// send_mark_obj
// file ../../common/proto.h line 72
void send_mark_obj(struct item_struct *op);
// send_reply
// file ../../common/proto.h line 21
void send_reply(const char *text);
// setTextManager
// file ../../common/proto.h line 16
void setTextManager(signed int type, void (*callback)(signed int, signed int, signed int, char *));
// setTextManager::callback$object
// 
void callback$object(signed int, signed int, signed int, char *);
// set_autorepeat
// file info.c line 1309
extern void set_autorepeat(const char *s);
// set_command_window
// file p_cmd.c line 328
static void set_command_window(const char *cpnext);
// set_darkness
// file mapdata.c line 126
static void set_darkness(signed int x, signed int y, signed int darkness);
// set_flag_string
// file item.c line 477
static void set_flag_string(struct item_struct *op);
// set_item_values
// file item.c line 523
void set_item_values(struct item_struct *op, char *name, signed int weight, unsigned short int face, unsigned short int flags, unsigned short int anim, unsigned short int animspeed, unsigned int nrof, unsigned short int type);
// set_scroll
// file info.c line 1296
extern void set_scroll(const char *s);
// set_show_icon
// file inventory.c line 575
extern void set_show_icon(const char *s);
// set_show_weight
// file inventory.c line 583
extern void set_show_weight(const char *s);
// set_text_tag_from_style
// file info.c line 301
extern void set_text_tag_from_style(struct _GtkTextTag *tag, struct _GtkStyle *style, struct _GtkStyle *base_style);
// set_weight_limit
// file inventory.c line 646
extern void set_weight_limit(unsigned int wlim);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setup_config_window
// file config.c line 720
static void setup_config_window();
// setup_list_columns
// file inventory.c line 332
static void setup_list_columns(struct _GtkWidget *treeview);
// show_all
// file inventory.c line 106
static signed int show_all(struct item_struct *it);
// show_applied
// file inventory.c line 110
static signed int show_applied(struct item_struct *it);
// show_cursed
// file inventory.c line 122
static signed int show_cursed(struct item_struct *it);
// show_help
// file p_cmd.c line 158
static void show_help(const struct anonymous$47 *cc);
// show_keys
// file keys.c line 1024
static void show_keys(void);
// show_locked
// file inventory.c line 134
static signed int show_locked(struct item_struct *it);
// show_magical
// file inventory.c line 126
static signed int show_magical(struct item_struct *it);
// show_nonmagical
// file inventory.c line 130
static signed int show_nonmagical(struct item_struct *it);
// show_unapplied
// file inventory.c line 114
static signed int show_unapplied(struct item_struct *it);
// show_unidentified
// file inventory.c line 142
static signed int show_unidentified(struct item_struct *it);
// show_unlocked
// file inventory.c line 138
static signed int show_unlocked(struct item_struct *it);
// show_unpaid
// file inventory.c line 118
static signed int show_unpaid(struct item_struct *it);
// show_window
// file create_char.c line 92
static void show_window(signed int window);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sigpipe_handler
// file main.c line 288
static void sigpipe_handler(signed int sig);
// skill_selection_func
// file skills.c line 50
static signed int skill_selection_func(struct _GtkTreeSelection *selection, struct _GtkTreeModel *model, struct _GtkTreePath *path, signed int path_currently_selected, void *userdata);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sort_by_category
// file p_cmd.c line 930
static signed int sort_by_category(const void *a_, const void *b_);
// sort_by_name
// file p_cmd.c line 913
static signed int sort_by_name(const void *a_, const void *b_);
// spell_get_styles
// file gtk2proto.h line 255
extern void spell_get_styles(void);
// spell_selection_func
// file spells.c line 103
static signed int spell_selection_func(struct _GtkTreeSelection *selection, struct _GtkTreeModel *model, struct _GtkTreePath *path, signed int path_currently_selected, void *userdata);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_login
// file account.c line 1404
extern void start_login(signed int method);
// starting_map_update_info
// file create_char.c line 756
void starting_map_update_info();
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// stats_get_styles
// file gtk2proto.h line 264
extern void stats_get_styles(void);
// stats_init
// file gtk2proto.h line 265
extern void stats_init(struct _GtkWidget *window_root);
// stop_fire
// file ../../common/proto.h line 141
void stop_fire(void);
// stop_run
// file ../../common/proto.h line 146
void stop_run(void);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strdup_local
// file ../../common/proto.h line 113
char * strdup_local(const char *str);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strsep
// file /usr/include/string.h line 556
extern char * strsep(char ** restrict , const char *);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// toggle_buttons_scope
// file keys.c line 2045
void toggle_buttons_scope(signed int scope);
// toggle_keybind_scope
// file keys.c line 2120
void toggle_keybind_scope(signed int scope, struct keybind *kb);
// toggle_locked
// file ../../common/proto.h line 71
void toggle_locked(struct item_struct *op);
// trigger_skill
// file skills.c line 201
extern void trigger_skill(struct _GtkTreeIter iter, struct _GtkTreeModel *model, signed int use_skill);
// unbind_key
// file keys.c line 1466
extern void unbind_key(const char *params);
// unbind_usage
// file keys.c line 1455
static void unbind_usage(void);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// update_all_stats
// file create_char.c line 211
static void update_all_stats();
// update_character_choose
// file account.c line 572
extern void update_character_choose(const char *name, const char *class, const char *race, const char *face, const char *party, const char *map, signed int level, signed int faceno);
// update_ground
// file script_lua.c line 150
static void update_ground(struct lua_State *lua);
// update_inv
// file script_lua.c line 132
static void update_inv(struct lua_State *lua);
// update_item
// file ./proto.h line 75
void update_item(signed int tag, signed int loc, char *name, signed int weight, signed int face, signed int flags, signed int anim, signed int animspeed, unsigned int nrof, signed int type);
// update_item_sort
// file item.c line 91
void update_item_sort(struct item_struct *it);
// update_keybinding_list
// file keys.c line 1904
extern void update_keybinding_list(void);
// update_login_info
// file account.c line 1315
extern void update_login_info(signed int type);
// update_msgctrl_configuration
// file info.c line 1490
extern void update_msgctrl_configuration(void);
// update_player
// file script_lua.c line 78
static void update_player(struct lua_State *lua);
// update_redrawbitmap
// file sdl.c line 830
static void update_redrawbitmap(void);
// update_skill_information
// file skills.c line 66
extern void update_skill_information(void);
// update_spell_information
// file gtk2proto.h line 257
extern void update_spell_information(void);
// update_stat
// file stats.c line 307
extern void update_stat(signed int stat_no, signed long int max_stat, signed long int current_stat, signed long int statbar_max, signed long int statbar_stat, signed int can_alert);
// update_stat_mapping
// file stats.c line 533
static void update_stat_mapping(void);
// usage
// file main.c line 299
static void usage(char *progname);
// use_skill
// file commands.c line 1316
void use_skill(signed int skill_id);
// user_read_data
// file png.c line 58
static void user_read_data(struct png_struct_def *png_ptr, unsigned char *data, unsigned long int length);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vsprintf
// file /usr/include/stdio.h line 379
extern signed int vsprintf(char *, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_socket
// file newsocket.c line 54
static signed int write_socket(signed int fd, const unsigned char *buf, signed int len);
// x_set_echo
// file keys.c line 1748
extern void x_set_echo(void);

struct anonymous$68
{
  // name
  char *name;
  // checksum
  unsigned int checksum;
  // png_data
  unsigned char *png_data;
  // width
  unsigned int width;
  // height
  unsigned int height;
};

struct anonymous$59
{
  // visual
  struct anonymous$56 *visual;
  // visualid
  unsigned long int visualid;
  // screen
  signed int screen;
  // depth
  signed int depth;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
};

struct anonymous$61
{
  // menuitem
  struct _GtkWidget *menuitem;
  // pickup_mode
  unsigned int pickup_mode;
};

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _GtkObject
{
  // parent_instance
  struct _GObject parent_instance;
  // flags
  unsigned int flags;
};

struct _GtkRequisition
{
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkRectangle
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GtkWidget
{
  // object
  struct _GtkObject object;
  // private_flags
  unsigned short int private_flags;
  // state
  unsigned char state;
  // saved_state
  unsigned char saved_state;
  // name
  char *name;
  // style
  struct _GtkStyle *style;
  // requisition
  struct _GtkRequisition requisition;
  // allocation
  struct _GdkRectangle allocation;
  // window
  struct _GdkDrawable *window;
  // parent
  struct _GtkWidget *parent;
};

struct anonymous$71
{
  // playername
  struct _GtkWidget *playername;
  // Str
  struct _GtkWidget *Str;
  // Dex
  struct _GtkWidget *Dex;
  // Con
  struct _GtkWidget *Con;
  // Int
  struct _GtkWidget *Int;
  // Wis
  struct _GtkWidget *Wis;
  // Cha
  struct _GtkWidget *Cha;
  // Pow
  struct _GtkWidget *Pow;
  // wc
  struct _GtkWidget *wc;
  // dam
  struct _GtkWidget *dam;
  // ac
  struct _GtkWidget *ac;
  // armor
  struct _GtkWidget *armor;
  // speed
  struct _GtkWidget *speed;
  // weapon_speed
  struct _GtkWidget *weapon_speed;
  // range
  struct _GtkWidget *range;
  // exp
  struct _GtkWidget *exp;
  // level
  struct _GtkWidget *level;
  // table_skills_exp
  struct _GtkWidget *table_skills_exp;
  // table_protections
  struct _GtkWidget *table_protections;
  // skill_exp
  struct _GtkWidget *skill_exp[102l];
  // resists
  struct _GtkWidget *resists[36l];
};

struct anonymous$72
{
  // ptr
  struct _GtkWidget *ptr;
  // state
  signed int state;
};

struct anonymous$74
{
  // ptr
  struct _GtkWidget *ptr;
  // state
  unsigned int state;
  // default_state
  unsigned int default_state;
};

struct anonymous$57
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous$55 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous$56 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous$58
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous$54 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous$57 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous$54
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous$56
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous$19
{
  // name
  const char *name;
  // tooltip
  const char *tooltip;
  // xpm
  const char * const *xpm;
  // show_func
  signed int (*show_func)(struct item_struct *);
  // type
  signed int type;
  // treeview
  struct _GtkWidget *treeview;
  // treestore
  struct _GtkTreeStore *treestore;
};

struct anonymous$47
{
  // name
  const char *name;
  // cat
  enum anonymous$46 cat;
  // dofunc
  void (*dofunc)(const char *);
  // helpfunc
  const char * (*helpfunc)(void);
  // desc
  const char *desc;
};

struct anonymous$66
{
  // name
  const char *name;
  // value
  signed int value;
};

struct anonymous$51
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$64
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$55
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous$56 *visuals;
};

struct anonymous$73
{
  // buffer
  struct anonymous$72 buffer;
  // pane
  struct anonymous$72 pane[2l];
};

struct anonymous$60
{
  // background_pixmap
  unsigned long int background_pixmap;
  // background_pixel
  unsigned long int background_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // border_pixel
  unsigned long int border_pixel;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // event_mask
  signed long int event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // colormap
  unsigned long int colormap;
  // cursor
  unsigned long int cursor;
};

union anonymous$75
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$14
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

union anonymous$38
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$31
{
  // v_int
  signed int v_int;
  // v_uint
  unsigned int v_uint;
  // v_long
  signed long int v_long;
  // v_ulong
  unsigned long int v_ulong;
  // v_int64
  signed long int v_int64;
  // v_uint64
  unsigned long int v_uint64;
  // v_float
  float v_float;
  // v_double
  double v_double;
  // v_pointer
  void *v_pointer;
};

struct _GtkImagePixmapData
{
  // pixmap
  struct _GdkDrawable *pixmap;
};

struct _GtkImageImageData
{
  // image
  struct _GdkImage *image;
};

struct _GtkImagePixbufData
{
  // pixbuf
  struct _GdkPixbuf *pixbuf;
};

struct _GtkImageStockData
{
  // stock_id
  char *stock_id;
};

struct _GtkImageIconSetData
{
  // icon_set
  struct _GtkIconSet *icon_set;
};

struct _GtkImageAnimationData
{
  // anim
  struct _GdkPixbufAnimation *anim;
  // iter
  struct _GdkPixbufAnimationIter *iter;
  // frame_timeout
  unsigned int frame_timeout;
};

struct _GtkImageIconNameData
{
  // icon_name
  char *icon_name;
  // pixbuf
  struct _GdkPixbuf *pixbuf;
  // theme_change_id
  unsigned int theme_change_id;
};

struct _GtkImageGIconData
{
  // icon
  struct _GIcon *icon;
  // pixbuf
  struct _GdkPixbuf *pixbuf;
  // theme_change_id
  unsigned int theme_change_id;
};

union anonymous$21
{
  // pixmap
  struct _GtkImagePixmapData pixmap;
  // image
  struct _GtkImageImageData image;
  // pixbuf
  struct _GtkImagePixbufData pixbuf;
  // stock
  struct _GtkImageStockData stock;
  // icon_set
  struct _GtkImageIconSetData icon_set;
  // anim
  struct _GtkImageAnimationData anim;
  // name
  struct _GtkImageIconNameData name;
  // gicon
  struct _GtkImageGIconData gicon;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$39
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$76
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$48
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct Animations
{
  // flags
  unsigned short int flags;
  // num_animations
  unsigned char num_animations;
  // speed
  unsigned char speed;
  // speed_left
  unsigned char speed_left;
  // phase
  unsigned char phase;
  // faces
  unsigned short int *faces;
};

struct MapCellLayer
{
  // face
  signed short int face;
  // size_x
  signed char size_x;
  // size_y
  signed char size_y;
  // animation
  signed short int animation;
  // animation_speed
  unsigned char animation_speed;
  // animation_left
  unsigned char animation_left;
  // animation_phase
  unsigned char animation_phase;
};

struct BigCell
{
  // next
  struct BigCell *next;
  // prev
  struct BigCell *prev;
  // head
  struct MapCellLayer head;
  // tail
  struct MapCellLayer tail;
  // x
  unsigned short int x;
  // y
  unsigned short int y;
  // layer
  unsigned char layer;
};

struct Cache_Entry
{
  // filename
  char *filename;
  // checksum
  unsigned int checksum;
  // ispublic
  unsigned int ispublic : 1;
  // image_data
  void *image_data;
  // next
  struct Cache_Entry *next;
};

struct PipeLog
{
  // name
  char *name;
  // level
  enum LogLevel level;
  // log
  signed int log;
};

struct ChildProcess
{
  // name
  char *name;
  // flag
  signed int flag;
  // pid
  signed int pid;
  // tube
  signed int tube[3l];
  // logger
  struct PipeLog logger[3l];
  // next
  struct ChildProcess *next;
};

struct SockList
{
  // len
  signed int len;
  // buf
  unsigned char *buf;
};

struct ClientSocket
{
  // fd
  signed int fd;
  // inbuf
  struct SockList inbuf;
  // cs_version
  signed int cs_version;
  // sc_version
  signed int sc_version;
  // command_sent
  signed int command_sent;
  // command_received
  signed int command_received;
  // command_time
  signed int command_time;
  // servername
  char *servername;
};

struct CmdMapping
{
  // cmdname
  const char *cmdname;
  // cmdproc
  void (*cmdproc)(unsigned char *, signed int);
  // cmdformat
  enum CmdFormat cmdformat;
};

struct FD_Cache
{
  // name
  char name[256l];
  // fd
  signed int fd;
};

struct FaceSets_struct
{
  // setnum
  unsigned char setnum;
  // fallback
  unsigned char fallback;
  // prefix
  char *prefix;
  // fullname
  char *fullname;
  // size
  char *size;
  // extension
  char *extension;
  // comment
  char *comment;
};

struct Face_Information_struct
{
  // faceset
  unsigned char faceset;
  // want_faceset
  char *want_faceset;
  // num_images
  signed short int num_images;
  // bmaps_checksum
  unsigned int bmaps_checksum;
  // old_bmaps_checksum
  unsigned int old_bmaps_checksum;
  // cache_hits
  signed short int cache_hits;
  // cache_misses
  signed short int cache_misses;
  // have_faceset_info
  unsigned char have_faceset_info;
  // facesets
  struct FaceSets_struct facesets[20l];
};

struct Image_Cache
{
  // image_name
  char *image_name;
  // cache_entry
  struct Cache_Entry *cache_entry;
};

struct _GtkTextTag
{
  // parent_instance
  struct _GObject parent_instance;
  // table
  struct _GtkTextTagTable *table;
  // name
  char *name;
  // priority
  signed int priority;
  // values
  struct _GtkTextAttributes *values;
  // bg_color_set
  unsigned int bg_color_set : 1;
  // bg_stipple_set
  unsigned int bg_stipple_set : 1;
  // fg_color_set
  unsigned int fg_color_set : 1;
  // scale_set
  unsigned int scale_set : 1;
  // fg_stipple_set
  unsigned int fg_stipple_set : 1;
  // justification_set
  unsigned int justification_set : 1;
  // left_margin_set
  unsigned int left_margin_set : 1;
  // indent_set
  unsigned int indent_set : 1;
  // rise_set
  unsigned int rise_set : 1;
  // strikethrough_set
  unsigned int strikethrough_set : 1;
  // right_margin_set
  unsigned int right_margin_set : 1;
  // pixels_above_lines_set
  unsigned int pixels_above_lines_set : 1;
  // pixels_below_lines_set
  unsigned int pixels_below_lines_set : 1;
  // pixels_inside_wrap_set
  unsigned int pixels_inside_wrap_set : 1;
  // tabs_set
  unsigned int tabs_set : 1;
  // underline_set
  unsigned int underline_set : 1;
  // wrap_mode_set
  unsigned int wrap_mode_set : 1;
  // bg_full_height_set
  unsigned int bg_full_height_set : 1;
  // invisible_set
  unsigned int invisible_set : 1;
  // editable_set
  unsigned int editable_set : 1;
  // language_set
  unsigned int language_set : 1;
  // pg_bg_color_set
  unsigned int pg_bg_color_set : 1;
  // accumulative_margin
  unsigned int accumulative_margin : 1;
  // pad1
  unsigned int pad1 : 1;
};

struct Info_Pane
{
  // textview
  struct _GtkWidget *textview;
  // scrolled_window
  struct _GtkWidget *scrolled_window;
  // textbuffer
  struct _GtkTextBuffer *textbuffer;
  // textmark
  struct _GtkTextMark *textmark;
  // adjustment
  struct _GtkAdjustment *adjustment;
  // color_tags
  struct _GtkTextTag *color_tags[13l];
  // font_tags
  struct _GtkTextTag *font_tags[5l];
  // bold_tag
  struct _GtkTextTag *bold_tag;
  // italic_tag
  struct _GtkTextTag *italic_tag;
  // underline_tag
  struct _GtkTextTag *underline_tag;
  // default_tag
  struct _GtkTextTag *default_tag;
  // msg_type_tags
  struct _GtkTextTag **msg_type_tags[21l];
};

struct Map
{
  // x
  signed int x;
  // y
  signed int y;
  // cells
  struct MapCell **cells;
};

struct MapCell
{
  // heads
  struct MapCellLayer heads[10l];
  // tails
  struct MapCellLayer tails[10l];
  // smooth
  unsigned short int smooth[10l];
  // darkness
  unsigned char darkness;
  // need_update
  unsigned char need_update : 1;
  // have_darkness
  unsigned char have_darkness : 1;
  // need_resmooth
  unsigned char need_resmooth : 1;
  // cleared
  unsigned char cleared : 1;
};

struct Meta_Info
{
  // ip_addr
  char ip_addr[60l];
  // hostname
  char hostname[512l];
  // port
  signed int port;
  // html_comment
  char html_comment[512l];
  // text_comment
  char text_comment[512l];
  // archbase
  char archbase[60l];
  // mapbase
  char mapbase[60l];
  // codebase
  char codebase[60l];
  // flags
  char flags[60l];
  // num_players
  signed int num_players;
  // in_bytes
  unsigned int in_bytes;
  // out_bytes
  unsigned int out_bytes;
  // idle_time
  signed int idle_time;
  // uptime
  signed int uptime;
  // version
  char version[60l];
  // sc_version
  signed int sc_version;
  // cs_version
  signed int cs_version;
};

struct Msg_Type_Names
{
  // type
  signed int type;
  // subtype
  signed int subtype;
  // style_name
  const char *style_name;
};

struct PixmapInfo
{
  // icon_mask
  void *icon_mask;
  // icon_image
  void *icon_image;
  // icon_width
  unsigned short int icon_width;
  // icon_height
  unsigned short int icon_height;
  // map_mask
  void *map_mask;
  // map_image
  void *map_image;
  // map_width
  unsigned short int map_width;
  // map_height
  unsigned short int map_height;
  // fog_image
  void *fog_image;
  // smooth_face
  unsigned short int smooth_face;
  // map_texture
  unsigned int map_texture;
  // fog_texture
  unsigned int fog_texture;
};

struct PlayerPosition
{
  // x
  signed int x;
  // y
  signed int y;
};

struct item_struct
{
  // next
  struct item_struct *next;
  // prev
  struct item_struct *prev;
  // env
  struct item_struct *env;
  // inv
  struct item_struct *inv;
  // d_name
  char d_name[128l];
  // s_name
  char s_name[128l];
  // p_name
  char p_name[128l];
  // flags
  char flags[128l];
  // tag
  signed int tag;
  // nrof
  unsigned int nrof;
  // weight
  float weight;
  // face
  signed short int face;
  // animation_id
  unsigned short int animation_id;
  // anim_speed
  unsigned char anim_speed;
  // anim_state
  unsigned char anim_state;
  // last_anim
  unsigned short int last_anim;
  // magical
  unsigned short int magical : 1;
  // cursed
  unsigned short int cursed : 1;
  // damned
  unsigned short int damned : 1;
  // unpaid
  unsigned short int unpaid : 1;
  // locked
  unsigned short int locked : 1;
  // applied
  unsigned short int applied : 1;
  // open
  unsigned short int open : 1;
  // was_open
  unsigned short int was_open : 1;
  // inv_updated
  unsigned short int inv_updated : 1;
  // apply_type
  unsigned char apply_type;
  // flagsval
  unsigned int flagsval;
  // type
  unsigned short int type;
};

struct Stat_struct
{
  // Str
  signed char Str;
  // Dex
  signed char Dex;
  // Con
  signed char Con;
  // Wis
  signed char Wis;
  // Cha
  signed char Cha;
  // Int
  signed char Int;
  // Pow
  signed char Pow;
  // wc
  signed char wc;
  // ac
  signed char ac;
  // level
  signed char level;
  // hp
  signed short int hp;
  // maxhp
  signed short int maxhp;
  // sp
  signed short int sp;
  // maxsp
  signed short int maxsp;
  // grace
  signed short int grace;
  // maxgrace
  signed short int maxgrace;
  // exp
  signed long int exp;
  // food
  signed short int food;
  // dam
  signed short int dam;
  // speed
  signed int speed;
  // weapon_sp
  signed int weapon_sp;
  // attuned
  unsigned int attuned;
  // repelled
  unsigned int repelled;
  // denied
  unsigned int denied;
  // flags
  unsigned short int flags;
  // resists
  signed short int resists[30l];
  // resist_change
  unsigned int resist_change : 1;
  // skill_level
  signed short int skill_level[50l];
  // skill_exp
  signed long int skill_exp[50l];
  // weight_limit
  unsigned int weight_limit;
};

struct Player_Struct
{
  // ob
  struct item_struct *ob;
  // below
  struct item_struct *below;
  // container
  struct item_struct *container;
  // count_left
  unsigned short int count_left;
  // input_state
  enum Input_State input_state;
  // last_command
  char last_command[256l];
  // input_text
  char input_text[256l];
  // ranges
  struct item_struct *ranges[8l];
  // ready_spell
  unsigned char ready_spell;
  // spells
  char spells[255l][40l];
  // stats
  struct Stat_struct stats;
  // spelldata
  struct Spell_struct *spelldata;
  // title
  char title[256l];
  // range
  char range[256l];
  // spells_updated
  unsigned int spells_updated;
  // fire_on
  unsigned int fire_on : 1;
  // run_on
  unsigned int run_on : 1;
  // meta_on
  unsigned int meta_on : 1;
  // alt_on
  unsigned int alt_on : 1;
  // no_echo
  unsigned int no_echo : 1;
  // count
  unsigned int count;
  // mmapx
  unsigned short int mmapx;
  // mmapy
  unsigned short int mmapy;
  // pmapx
  unsigned short int pmapx;
  // pmapy
  unsigned short int pmapy;
  // magicmap
  unsigned char *magicmap;
  // showmagic
  unsigned char showmagic;
  // mapxres
  unsigned short int mapxres;
  // mapyres
  unsigned short int mapyres;
  // name
  char *name;
};

struct RC_Choice
{
  // choice_name
  char *choice_name;
  // choice_desc
  char *choice_desc;
  // num_values
  signed int num_values;
  // value_arch
  char **value_arch;
  // value_desc
  char **value_desc;
};

struct Race_Class_Info
{
  // arch_name
  char *arch_name;
  // public_name
  char *public_name;
  // description
  char *description;
  // stat_adj
  signed char stat_adj[7l];
  // num_rc_choice
  signed int num_rc_choice;
  // rc_choice
  struct RC_Choice *rc_choice;
};

struct SDL_Color
{
  // r
  unsigned char r;
  // g
  unsigned char g;
  // b
  unsigned char b;
  // unused
  unsigned char unused;
};

struct SDL_Palette
{
  // ncolors
  signed int ncolors;
  // colors
  struct SDL_Color *colors;
};

struct SDL_PixelFormat
{
  // palette
  struct SDL_Palette *palette;
  // BitsPerPixel
  unsigned char BitsPerPixel;
  // BytesPerPixel
  unsigned char BytesPerPixel;
  // Rloss
  unsigned char Rloss;
  // Gloss
  unsigned char Gloss;
  // Bloss
  unsigned char Bloss;
  // Aloss
  unsigned char Aloss;
  // Rshift
  unsigned char Rshift;
  // Gshift
  unsigned char Gshift;
  // Bshift
  unsigned char Bshift;
  // Ashift
  unsigned char Ashift;
  // Rmask
  unsigned int Rmask;
  // Gmask
  unsigned int Gmask;
  // Bmask
  unsigned int Bmask;
  // Amask
  unsigned int Amask;
  // colorkey
  unsigned int colorkey;
  // alpha
  unsigned char alpha;
};

struct SDL_Rect
{
  // x
  signed short int x;
  // y
  signed short int y;
  // w
  unsigned short int w;
  // h
  unsigned short int h;
};

struct SDL_Surface
{
  // flags
  unsigned int flags;
  // format
  struct SDL_PixelFormat *format;
  // w
  signed int w;
  // h
  signed int h;
  // pitch
  unsigned short int pitch;
  // pixels
  void *pixels;
  // offset
  signed int offset;
  // hwdata
  struct private_hwdata *hwdata;
  // clip_rect
  struct SDL_Rect clip_rect;
  // unused1
  unsigned int unused1;
  // locked
  unsigned int locked;
  // map
  struct SDL_BlitMap *map;
  // format_version
  unsigned int format_version;
  // refcount
  signed int refcount;
};

struct Spell_struct
{
  // next
  struct Spell_struct *next;
  // name
  char name[256l];
  // message
  char message[10000l];
  // tag
  unsigned int tag;
  // level
  unsigned short int level;
  // time
  unsigned short int time;
  // sp
  unsigned short int sp;
  // grace
  unsigned short int grace;
  // dam
  unsigned short int dam;
  // skill_number
  unsigned char skill_number;
  // skill
  char *skill;
  // path
  unsigned int path;
  // face
  signed int face;
  // usage
  unsigned char usage;
  // requirements
  char requirements[256l];
};

struct Starting_Map_Info
{
  // arch_name
  char *arch_name;
  // public_name
  char *public_name;
  // description
  char *description;
};

struct Stat_Mapping
{
  // widget_suffix
  const char *widget_suffix;
  // cs_value
  unsigned char cs_value;
  // rc_offset
  unsigned char rc_offset;
};

struct TextManager
{
  // type
  signed int type;
  // callback
  void (*callback)(signed int, signed int, signed int, char *);
  // next
  struct TextManager *next;
};

struct _GArray
{
  // data
  char *data;
  // len
  unsigned int len;
};

struct _GClosure
{
  // ref_count
  volatile unsigned int ref_count : 15;
  // meta_marshal_nouse
  volatile unsigned int meta_marshal_nouse : 1;
  // n_guards
  volatile unsigned int n_guards : 1;
  // n_fnotifiers
  volatile unsigned int n_fnotifiers : 2;
  // n_inotifiers
  volatile unsigned int n_inotifiers : 8;
  // in_inotify
  volatile unsigned int in_inotify : 1;
  // floating
  volatile unsigned int floating : 1;
  // derivative_flag
  volatile unsigned int derivative_flag : 1;
  // in_marshal
  volatile unsigned int in_marshal : 1;
  // is_invalid
  volatile unsigned int is_invalid : 1;
  // marshal
  void (*marshal)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
  // data
  void *data;
  // notifiers
  struct _GClosureNotifyData *notifiers;
};

struct _GClosureNotifyData
{
  // data
  void *data;
  // notify
  void (*notify)(void *, struct _GClosure *);
};

struct _GError
{
  // domain
  unsigned int domain;
  // code
  signed int code;
  // message
  char *message;
};

struct _GList
{
  // data
  void *data;
  // next
  struct _GList *next;
  // prev
  struct _GList *prev;
};

struct _GSList
{
  // data
  void *data;
  // next
  struct _GSList *next;
};

struct _GTimeVal
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _GValue
{
  // g_type
  unsigned long int g_type;
  // data
  union anonymous$31 data[2l];
};

struct _GdkColor
{
  // pixel
  unsigned int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
};

struct _GdkColormap
{
  // parent_instance
  struct _GObject parent_instance;
  // size
  signed int size;
  // colors
  struct _GdkColor *colors;
  // visual
  struct _GdkVisual *visual;
  // windowing_data
  void *windowing_data;
};

struct _GdkCursor
{
  // type
  enum anonymous$37 type;
  // ref_count
  unsigned int ref_count;
};

struct _GdkDevice
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // source
  enum anonymous$1 source;
  // mode
  enum anonymous$2 mode;
  // has_cursor
  signed int has_cursor;
  // num_axes
  signed int num_axes;
  // axes
  struct _GdkDeviceAxis *axes;
  // num_keys
  signed int num_keys;
  // keys
  struct _GdkDeviceKey *keys;
};

struct _GdkDeviceAxis
{
  // use
  enum anonymous use;
  // min
  double min;
  // max
  double max;
};

struct _GdkDeviceKey
{
  // keyval
  unsigned int keyval;
  // modifiers
  enum anonymous$0 modifiers;
};

struct _GdkDragContext
{
  // parent_instance
  struct _GObject parent_instance;
  // protocol
  enum anonymous$3 protocol;
  // is_source
  signed int is_source;
  // source_window
  struct _GdkDrawable *source_window;
  // dest_window
  struct _GdkDrawable *dest_window;
  // targets
  struct _GList *targets;
  // actions
  enum anonymous$4 actions;
  // suggested_action
  enum anonymous$4 suggested_action;
  // action
  enum anonymous$4 action;
  // start_time
  unsigned int start_time;
  // windowing_data
  void *windowing_data;
};

struct _GdkDrawable
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GdkEventAny
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkEventExpose
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // area
  struct _GdkRectangle area;
  // region
  struct _GdkRegion *region;
  // count
  signed int count;
};

struct _GdkEventNoExpose
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
};

struct _GdkEventVisibility
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // state
  enum anonymous$6 state;
};

struct _GdkEventMotion
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // is_hint
  signed short int is_hint;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventButton
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // axes
  double *axes;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventScroll
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // state
  unsigned int state;
  // direction
  enum anonymous$8 direction;
  // device
  struct _GdkDevice *device;
  // x_root
  double x_root;
  // y_root
  double y_root;
};

struct _GdkEventKey
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // state
  unsigned int state;
  // keyval
  unsigned int keyval;
  // length
  signed int length;
  // string
  char *string;
  // hardware_keycode
  unsigned short int hardware_keycode;
  // group
  unsigned char group;
  // is_modifier
  unsigned int is_modifier : 1;
};

struct _GdkEventCrossing
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // subwindow
  struct _GdkDrawable *subwindow;
  // time
  unsigned int time;
  // x
  double x;
  // y
  double y;
  // x_root
  double x_root;
  // y_root
  double y_root;
  // mode
  enum anonymous$10 mode;
  // detail
  enum anonymous$9 detail;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct _GdkEventFocus
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // in
  signed short int in;
};

struct _GdkEventConfigure
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
};

struct _GdkEventProperty
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // atom
  struct _GdkAtom *atom;
  // time
  unsigned int time;
  // state
  unsigned int state;
};

struct _GdkEventSelection
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // selection
  struct _GdkAtom *selection;
  // target
  struct _GdkAtom *target;
  // property
  struct _GdkAtom *property;
  // time
  unsigned int time;
  // requestor
  unsigned int requestor;
};

struct _GdkEventOwnerChange
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // owner
  unsigned int owner;
  // reason
  enum anonymous$13 reason;
  // selection
  struct _GdkAtom *selection;
  // time
  unsigned int time;
  // selection_time
  unsigned int selection_time;
};

struct _GdkEventProximity
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // time
  unsigned int time;
  // device
  struct _GdkDevice *device;
};

struct _GdkEventClient
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // message_type
  struct _GdkAtom *message_type;
  // data_format
  unsigned short int data_format;
  // data
  union anonymous$14 data;
};

struct _GdkEventDND
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // context
  struct _GdkDragContext *context;
  // time
  unsigned int time;
  // x_root
  signed short int x_root;
  // y_root
  signed short int y_root;
};

struct _GdkEventWindowState
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // changed_mask
  enum anonymous$11 changed_mask;
  // new_window_state
  enum anonymous$11 new_window_state;
};

struct _GdkEventSetting
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // action
  enum anonymous$12 action;
  // name
  char *name;
};

struct _GdkEventGrabBroken
{
  // type
  enum anonymous$5 type;
  // window
  struct _GdkDrawable *window;
  // send_event
  signed char send_event;
  // keyboard
  signed int keyboard;
  // implicit
  signed int implicit;
  // grab_window
  struct _GdkDrawable *grab_window;
};

union _GdkEvent
{
  // type
  enum anonymous$5 type;
  // any
  struct _GdkEventAny any;
  // expose
  struct _GdkEventExpose expose;
  // no_expose
  struct _GdkEventNoExpose no_expose;
  // visibility
  struct _GdkEventVisibility visibility;
  // motion
  struct _GdkEventMotion motion;
  // button
  struct _GdkEventButton button;
  // scroll
  struct _GdkEventScroll scroll;
  // key
  struct _GdkEventKey key;
  // crossing
  struct _GdkEventCrossing crossing;
  // focus_change
  struct _GdkEventFocus focus_change;
  // configure
  struct _GdkEventConfigure configure;
  // property
  struct _GdkEventProperty property;
  // selection
  struct _GdkEventSelection selection;
  // owner_change
  struct _GdkEventOwnerChange owner_change;
  // proximity
  struct _GdkEventProximity proximity;
  // client
  struct _GdkEventClient client;
  // dnd
  struct _GdkEventDND dnd;
  // window_state
  struct _GdkEventWindowState window_state;
  // setting
  struct _GdkEventSetting setting;
  // grab_broken
  struct _GdkEventGrabBroken grab_broken;
};

struct _GdkFont
{
  // type
  enum anonymous$29 type;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct _GdkGC
{
  // parent_instance
  struct _GObject parent_instance;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // colormap
  struct _GdkColormap *colormap;
};

struct _GdkGeometry
{
  // min_width
  signed int min_width;
  // min_height
  signed int min_height;
  // max_width
  signed int max_width;
  // max_height
  signed int max_height;
  // base_width
  signed int base_width;
  // base_height
  signed int base_height;
  // width_inc
  signed int width_inc;
  // height_inc
  signed int height_inc;
  // min_aspect
  double min_aspect;
  // max_aspect
  double max_aspect;
  // win_gravity
  enum anonymous$50 win_gravity;
};

struct _GdkImage
{
  // parent_instance
  struct _GObject parent_instance;
  // type
  enum anonymous$30 type;
  // visual
  struct _GdkVisual *visual;
  // byte_order
  enum anonymous$32 byte_order;
  // width
  signed int width;
  // height
  signed int height;
  // depth
  unsigned short int depth;
  // bpp
  unsigned short int bpp;
  // bpl
  unsigned short int bpl;
  // bits_per_pixel
  unsigned short int bits_per_pixel;
  // mem
  void *mem;
  // colormap
  struct _GdkColormap *colormap;
  // windowing_data
  void *windowing_data;
};

struct _GdkScreen
{
  // parent_instance
  struct _GObject parent_instance;
  // closed
  unsigned int closed : 1;
  // normal_gcs
  struct _GdkGC *normal_gcs[32l];
  // exposure_gcs
  struct _GdkGC *exposure_gcs[32l];
  // subwindow_gcs
  struct _GdkGC *subwindow_gcs[32l];
  // font_options
  struct _cairo_font_options *font_options;
  // resolution
  double resolution;
};

struct _GdkVisual
{
  // parent_instance
  struct _GObject parent_instance;
  // type
  enum anonymous$35 type;
  // depth
  signed int depth;
  // byte_order
  enum anonymous$32 byte_order;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
  // red_mask
  unsigned int red_mask;
  // red_shift
  signed int red_shift;
  // red_prec
  signed int red_prec;
  // green_mask
  unsigned int green_mask;
  // green_shift
  signed int green_shift;
  // green_prec
  signed int green_prec;
  // blue_mask
  unsigned int blue_mask;
  // blue_shift
  signed int blue_shift;
  // blue_prec
  signed int blue_prec;
};

struct _GtkAdjustment
{
  // parent_instance
  struct _GtkObject parent_instance;
  // lower
  double lower;
  // upper
  double upper;
  // value
  double value;
  // step_increment
  double step_increment;
  // page_increment
  double page_increment;
  // page_size
  double page_size;
};

struct _GtkContainer
{
  // widget
  struct _GtkWidget widget;
  // focus_child
  struct _GtkWidget *focus_child;
  // border_width
  unsigned int border_width : 16;
  // need_resize
  unsigned int need_resize : 1;
  // resize_mode
  unsigned int resize_mode : 2;
  // reallocate_redraws
  unsigned int reallocate_redraws : 1;
  // has_focus_chain
  unsigned int has_focus_chain : 1;
};

struct _GtkBin
{
  // container
  struct _GtkContainer container;
  // child
  struct _GtkWidget *child;
};

struct _GtkBox
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // spacing
  signed short int spacing;
  // homogeneous
  unsigned int homogeneous : 1;
};

struct _GtkBuilder
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GtkBuilderPrivate *priv;
};

struct _GtkButton
{
  // bin
  struct _GtkBin bin;
  // event_window
  struct _GdkDrawable *event_window;
  // label_text
  char *label_text;
  // activate_timeout
  unsigned int activate_timeout;
  // constructed
  unsigned int constructed : 1;
  // in_button
  unsigned int in_button : 1;
  // button_down
  unsigned int button_down : 1;
  // relief
  unsigned int relief : 2;
  // use_underline
  unsigned int use_underline : 1;
  // use_stock
  unsigned int use_stock : 1;
  // depressed
  unsigned int depressed : 1;
  // depress_on_activate
  unsigned int depress_on_activate : 1;
  // focus_on_click
  unsigned int focus_on_click : 1;
};

struct _GtkCListCellInfo
{
  // row
  signed int row;
  // column
  signed int column;
};

struct _GtkCList
{
  // container
  struct _GtkContainer container;
  // flags
  unsigned short int flags;
  // reserved1
  void *reserved1;
  // reserved2
  void *reserved2;
  // freeze_count
  unsigned int freeze_count;
  // internal_allocation
  struct _GdkRectangle internal_allocation;
  // rows
  signed int rows;
  // row_height
  signed int row_height;
  // row_list
  struct _GList *row_list;
  // row_list_end
  struct _GList *row_list_end;
  // columns
  signed int columns;
  // column_title_area
  struct _GdkRectangle column_title_area;
  // title_window
  struct _GdkDrawable *title_window;
  // column
  struct _GtkCListColumn *column;
  // clist_window
  struct _GdkDrawable *clist_window;
  // clist_window_width
  signed int clist_window_width;
  // clist_window_height
  signed int clist_window_height;
  // hoffset
  signed int hoffset;
  // voffset
  signed int voffset;
  // shadow_type
  enum anonymous$23 shadow_type;
  // selection_mode
  enum anonymous$24 selection_mode;
  // selection
  struct _GList *selection;
  // selection_end
  struct _GList *selection_end;
  // undo_selection
  struct _GList *undo_selection;
  // undo_unselection
  struct _GList *undo_unselection;
  // undo_anchor
  signed int undo_anchor;
  // button_actions
  unsigned char button_actions[5l];
  // drag_button
  unsigned char drag_button;
  // click_cell
  struct _GtkCListCellInfo click_cell;
  // hadjustment
  struct _GtkAdjustment *hadjustment;
  // vadjustment
  struct _GtkAdjustment *vadjustment;
  // xor_gc
  struct _GdkGC *xor_gc;
  // fg_gc
  struct _GdkGC *fg_gc;
  // bg_gc
  struct _GdkGC *bg_gc;
  // cursor_drag
  struct _GdkCursor *cursor_drag;
  // x_drag
  signed int x_drag;
  // focus_row
  signed int focus_row;
  // focus_header_column
  signed int focus_header_column;
  // anchor
  signed int anchor;
  // anchor_state
  enum anonymous$25 anchor_state;
  // drag_pos
  signed int drag_pos;
  // htimer
  signed int htimer;
  // vtimer
  signed int vtimer;
  // sort_type
  enum anonymous$26 sort_type;
  // compare
  signed int (*compare)(struct _GtkCList *, const void *, const void *);
  // sort_column
  signed int sort_column;
  // drag_highlight_row
  signed int drag_highlight_row;
  // drag_highlight_pos
  enum anonymous$27 drag_highlight_pos;
};

struct _GtkCListColumn
{
  // title
  char *title;
  // area
  struct _GdkRectangle area;
  // button
  struct _GtkWidget *button;
  // window
  struct _GdkDrawable *window;
  // width
  signed int width;
  // min_width
  signed int min_width;
  // max_width
  signed int max_width;
  // justification
  enum anonymous$43 justification;
  // visible
  unsigned int visible : 1;
  // width_set
  unsigned int width_set : 1;
  // resizeable
  unsigned int resizeable : 1;
  // auto_resize
  unsigned int auto_resize : 1;
  // button_passive
  unsigned int button_passive : 1;
};

struct _GtkCellRenderer
{
  // parent
  struct _GtkObject parent;
  // xalign
  float xalign;
  // yalign
  float yalign;
  // width
  signed int width;
  // height
  signed int height;
  // xpad
  unsigned short int xpad;
  // ypad
  unsigned short int ypad;
  // mode
  unsigned int mode : 2;
  // visible
  unsigned int visible : 1;
  // is_expander
  unsigned int is_expander : 1;
  // is_expanded
  unsigned int is_expanded : 1;
  // cell_background_set
  unsigned int cell_background_set : 1;
  // sensitive
  unsigned int sensitive : 1;
  // editing
  unsigned int editing : 1;
};

struct _GtkToggleButton
{
  // button
  struct _GtkButton button;
  // active
  unsigned int active : 1;
  // draw_indicator
  unsigned int draw_indicator : 1;
  // inconsistent
  unsigned int inconsistent : 1;
};

struct _GtkCheckButton
{
  // toggle_button
  struct _GtkToggleButton toggle_button;
};

struct _GtkItem
{
  // bin
  struct _GtkBin bin;
};

struct _GtkMenuItem
{
  // item
  struct _GtkItem item;
  // submenu
  struct _GtkWidget *submenu;
  // event_window
  struct _GdkDrawable *event_window;
  // toggle_size
  unsigned short int toggle_size;
  // accelerator_width
  unsigned short int accelerator_width;
  // accel_path
  char *accel_path;
  // show_submenu_indicator
  unsigned int show_submenu_indicator : 1;
  // submenu_placement
  unsigned int submenu_placement : 1;
  // submenu_direction
  unsigned int submenu_direction : 1;
  // right_justify
  unsigned int right_justify : 1;
  // timer_from_keypress
  unsigned int timer_from_keypress : 1;
  // from_menubar
  unsigned int from_menubar : 1;
  // timer
  unsigned int timer;
};

struct _GtkCheckMenuItem
{
  // menu_item
  struct _GtkMenuItem menu_item;
  // active
  unsigned int active : 1;
  // always_show_toggle
  unsigned int always_show_toggle : 1;
  // inconsistent
  unsigned int inconsistent : 1;
  // draw_as_radio
  unsigned int draw_as_radio : 1;
};

struct _GtkComboBox
{
  // parent_instance
  struct _GtkBin parent_instance;
  // priv
  struct _GtkComboBoxPrivate *priv;
};

struct _GtkWindow
{
  // bin
  struct _GtkBin bin;
  // title
  char *title;
  // wmclass_name
  char *wmclass_name;
  // wmclass_class
  char *wmclass_class;
  // wm_role
  char *wm_role;
  // focus_widget
  struct _GtkWidget *focus_widget;
  // default_widget
  struct _GtkWidget *default_widget;
  // transient_parent
  struct _GtkWindow *transient_parent;
  // geometry_info
  struct _GtkWindowGeometryInfo *geometry_info;
  // frame
  struct _GdkDrawable *frame;
  // group
  struct _GtkWindowGroup *group;
  // configure_request_count
  unsigned short int configure_request_count;
  // allow_shrink
  unsigned int allow_shrink : 1;
  // allow_grow
  unsigned int allow_grow : 1;
  // configure_notify_received
  unsigned int configure_notify_received : 1;
  // need_default_position
  unsigned int need_default_position : 1;
  // need_default_size
  unsigned int need_default_size : 1;
  // position
  unsigned int position : 3;
  // type
  unsigned int type : 4;
  // has_user_ref_count
  unsigned int has_user_ref_count : 1;
  // has_focus
  unsigned int has_focus : 1;
  // modal
  unsigned int modal : 1;
  // destroy_with_parent
  unsigned int destroy_with_parent : 1;
  // has_frame
  unsigned int has_frame : 1;
  // iconify_initially
  unsigned int iconify_initially : 1;
  // stick_initially
  unsigned int stick_initially : 1;
  // maximize_initially
  unsigned int maximize_initially : 1;
  // decorated
  unsigned int decorated : 1;
  // type_hint
  unsigned int type_hint : 3;
  // gravity
  unsigned int gravity : 5;
  // is_active
  unsigned int is_active : 1;
  // has_toplevel_focus
  unsigned int has_toplevel_focus : 1;
  // frame_left
  unsigned int frame_left;
  // frame_top
  unsigned int frame_top;
  // frame_right
  unsigned int frame_right;
  // frame_bottom
  unsigned int frame_bottom;
  // keys_changed_handler
  unsigned int keys_changed_handler;
  // mnemonic_modifier
  enum anonymous$0 mnemonic_modifier;
  // screen
  struct _GdkScreen *screen;
};

struct _GtkDialog
{
  // window
  struct _GtkWindow window;
  // vbox
  struct _GtkWidget *vbox;
  // action_area
  struct _GtkWidget *action_area;
  // separator
  struct _GtkWidget *separator;
};

struct _GtkDrawingArea
{
  // widget
  struct _GtkWidget widget;
  // draw_data
  void *draw_data;
};

struct _GtkEntry
{
  // widget
  struct _GtkWidget widget;
  // text
  char *text;
  // editable
  unsigned int editable : 1;
  // visible
  unsigned int visible : 1;
  // overwrite_mode
  unsigned int overwrite_mode : 1;
  // in_drag
  unsigned int in_drag : 1;
  // text_length
  unsigned short int text_length;
  // text_max_length
  unsigned short int text_max_length;
  // text_area
  struct _GdkDrawable *text_area;
  // im_context
  struct _GtkIMContext *im_context;
  // popup_menu
  struct _GtkWidget *popup_menu;
  // current_pos
  signed int current_pos;
  // selection_bound
  signed int selection_bound;
  // cached_layout
  struct _PangoLayout *cached_layout;
  // cache_includes_preedit
  unsigned int cache_includes_preedit : 1;
  // need_im_reset
  unsigned int need_im_reset : 1;
  // has_frame
  unsigned int has_frame : 1;
  // activates_default
  unsigned int activates_default : 1;
  // cursor_visible
  unsigned int cursor_visible : 1;
  // in_click
  unsigned int in_click : 1;
  // is_cell_renderer
  unsigned int is_cell_renderer : 1;
  // editing_canceled
  unsigned int editing_canceled : 1;
  // mouse_cursor_obscured
  unsigned int mouse_cursor_obscured : 1;
  // select_words
  unsigned int select_words : 1;
  // select_lines
  unsigned int select_lines : 1;
  // resolved_dir
  unsigned int resolved_dir : 4;
  // truncate_multiline
  unsigned int truncate_multiline : 1;
  // button
  unsigned int button;
  // blink_timeout
  unsigned int blink_timeout;
  // recompute_idle
  unsigned int recompute_idle;
  // scroll_offset
  signed int scroll_offset;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
  // x_text_size
  unsigned short int x_text_size;
  // x_n_bytes
  unsigned short int x_n_bytes;
  // preedit_length
  unsigned short int preedit_length;
  // preedit_cursor
  unsigned short int preedit_cursor;
  // dnd_position
  signed int dnd_position;
  // drag_start_x
  signed int drag_start_x;
  // drag_start_y
  signed int drag_start_y;
  // invisible_char
  unsigned int invisible_char;
  // width_chars
  signed int width_chars;
};

struct _GtkIMContext
{
  // parent_instance
  struct _GObject parent_instance;
};

struct _GtkMisc
{
  // widget
  struct _GtkWidget widget;
  // xalign
  float xalign;
  // yalign
  float yalign;
  // xpad
  unsigned short int xpad;
  // ypad
  unsigned short int ypad;
};

struct _GtkImage
{
  // misc
  struct _GtkMisc misc;
  // storage_type
  enum anonymous$20 storage_type;
  // data
  union anonymous$21 data;
  // mask
  struct _GdkDrawable *mask;
  // icon_size
  enum anonymous$22 icon_size;
};

struct _GtkLabel
{
  // misc
  struct _GtkMisc misc;
  // label
  char *label;
  // jtype
  unsigned int jtype : 2;
  // wrap
  unsigned int wrap : 1;
  // use_underline
  unsigned int use_underline : 1;
  // use_markup
  unsigned int use_markup : 1;
  // ellipsize
  unsigned int ellipsize : 3;
  // single_line_mode
  unsigned int single_line_mode : 1;
  // have_transform
  unsigned int have_transform : 1;
  // in_click
  unsigned int in_click : 1;
  // wrap_mode
  unsigned int wrap_mode : 3;
  // pattern_set
  unsigned int pattern_set : 1;
  // track_links
  unsigned int track_links : 1;
  // mnemonic_keyval
  unsigned int mnemonic_keyval;
  // text
  char *text;
  // attrs
  struct _PangoAttrList *attrs;
  // effective_attrs
  struct _PangoAttrList *effective_attrs;
  // layout
  struct _PangoLayout *layout;
  // mnemonic_widget
  struct _GtkWidget *mnemonic_widget;
  // mnemonic_window
  struct _GtkWindow *mnemonic_window;
  // select_info
  struct _GtkLabelSelectionInfo *select_info;
};

struct _GtkListStore
{
  // parent
  struct _GObject parent;
  // stamp
  signed int stamp;
  // seq
  void *seq;
  // _gtk_reserved1
  void *_gtk_reserved1;
  // sort_list
  struct _GList *sort_list;
  // n_columns
  signed int n_columns;
  // sort_column_id
  signed int sort_column_id;
  // order
  enum anonymous$26 order;
  // column_headers
  unsigned long int *column_headers;
  // length
  signed int length;
  // default_sort_func
  signed int (*default_sort_func)(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, void *);
  // default_sort_data
  void *default_sort_data;
  // default_sort_destroy
  void (*default_sort_destroy)(void *);
  // columns_dirty
  unsigned int columns_dirty : 1;
};

struct _GtkMessageDialog
{
  // parent_instance
  struct _GtkDialog parent_instance;
  // image
  struct _GtkWidget *image;
  // label
  struct _GtkWidget *label;
};

struct _GtkNotebook
{
  // container
  struct _GtkContainer container;
  // cur_page
  struct _GtkNotebookPage *cur_page;
  // children
  struct _GList *children;
  // first_tab
  struct _GList *first_tab;
  // focus_tab
  struct _GList *focus_tab;
  // menu
  struct _GtkWidget *menu;
  // event_window
  struct _GdkDrawable *event_window;
  // timer
  unsigned int timer;
  // tab_hborder
  unsigned short int tab_hborder;
  // tab_vborder
  unsigned short int tab_vborder;
  // show_tabs
  unsigned int show_tabs : 1;
  // homogeneous
  unsigned int homogeneous : 1;
  // show_border
  unsigned int show_border : 1;
  // tab_pos
  unsigned int tab_pos : 2;
  // scrollable
  unsigned int scrollable : 1;
  // in_child
  unsigned int in_child : 3;
  // click_child
  unsigned int click_child : 3;
  // button
  unsigned int button : 2;
  // need_timer
  unsigned int need_timer : 1;
  // child_has_focus
  unsigned int child_has_focus : 1;
  // have_visible_child
  unsigned int have_visible_child : 1;
  // focus_out
  unsigned int focus_out : 1;
  // has_before_previous
  unsigned int has_before_previous : 1;
  // has_before_next
  unsigned int has_before_next : 1;
  // has_after_previous
  unsigned int has_after_previous : 1;
  // has_after_next
  unsigned int has_after_next : 1;
};

struct _GtkPaned
{
  // container
  struct _GtkContainer container;
  // child1
  struct _GtkWidget *child1;
  // child2
  struct _GtkWidget *child2;
  // handle
  struct _GdkDrawable *handle;
  // xor_gc
  struct _GdkGC *xor_gc;
  // cursor_type
  enum anonymous$37 cursor_type;
  // handle_pos
  struct _GdkRectangle handle_pos;
  // child1_size
  signed int child1_size;
  // last_allocation
  signed int last_allocation;
  // min_position
  signed int min_position;
  // max_position
  signed int max_position;
  // position_set
  unsigned int position_set : 1;
  // in_drag
  unsigned int in_drag : 1;
  // child1_shrink
  unsigned int child1_shrink : 1;
  // child1_resize
  unsigned int child1_resize : 1;
  // child2_shrink
  unsigned int child2_shrink : 1;
  // child2_resize
  unsigned int child2_resize : 1;
  // orientation
  unsigned int orientation : 1;
  // in_recursion
  unsigned int in_recursion : 1;
  // handle_prelit
  unsigned int handle_prelit : 1;
  // last_child1_focus
  struct _GtkWidget *last_child1_focus;
  // last_child2_focus
  struct _GtkWidget *last_child2_focus;
  // priv
  struct _GtkPanedPrivate *priv;
  // drag_pos
  signed int drag_pos;
  // original_position
  signed int original_position;
};

struct _GtkProgress
{
  // widget
  struct _GtkWidget widget;
  // adjustment
  struct _GtkAdjustment *adjustment;
  // offscreen_pixmap
  struct _GdkDrawable *offscreen_pixmap;
  // format
  char *format;
  // x_align
  float x_align;
  // y_align
  float y_align;
  // show_text
  unsigned int show_text : 1;
  // activity_mode
  unsigned int activity_mode : 1;
  // use_text_format
  unsigned int use_text_format : 1;
};

struct _GtkProgressBar
{
  // progress
  struct _GtkProgress progress;
  // bar_style
  enum anonymous$69 bar_style;
  // orientation
  enum anonymous$70 orientation;
  // blocks
  unsigned int blocks;
  // in_block
  signed int in_block;
  // activity_pos
  signed int activity_pos;
  // activity_step
  unsigned int activity_step;
  // activity_blocks
  unsigned int activity_blocks;
  // pulse_fraction
  double pulse_fraction;
  // activity_dir
  unsigned int activity_dir : 1;
  // ellipsize
  unsigned int ellipsize : 3;
  // dirty
  unsigned int dirty : 1;
};

struct _GtkRcStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // name
  char *name;
  // bg_pixmap_name
  char *bg_pixmap_name[5l];
  // font_desc
  struct _PangoFontDescription *font_desc;
  // color_flags
  enum anonymous$28 color_flags[5l];
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // rc_properties
  struct _GArray *rc_properties;
  // rc_style_lists
  struct _GSList *rc_style_lists;
  // icon_factories
  struct _GSList *icon_factories;
  // engine_specified
  unsigned int engine_specified : 1;
};

struct _GtkScrolledWindow
{
  // container
  struct _GtkBin container;
  // hscrollbar
  struct _GtkWidget *hscrollbar;
  // vscrollbar
  struct _GtkWidget *vscrollbar;
  // hscrollbar_policy
  unsigned int hscrollbar_policy : 2;
  // vscrollbar_policy
  unsigned int vscrollbar_policy : 2;
  // hscrollbar_visible
  unsigned int hscrollbar_visible : 1;
  // vscrollbar_visible
  unsigned int vscrollbar_visible : 1;
  // window_placement
  unsigned int window_placement : 2;
  // focus_out
  unsigned int focus_out : 1;
  // shadow_type
  unsigned short int shadow_type;
};

struct _GtkSettings
{
  // parent_instance
  struct _GObject parent_instance;
  // queued_settings
  struct _GData *queued_settings;
  // property_values
  struct _GtkSettingsPropertyValue *property_values;
  // rc_context
  struct _GtkRcContext *rc_context;
  // screen
  struct _GdkScreen *screen;
};

struct _GtkSpinButton
{
  // entry
  struct _GtkEntry entry;
  // adjustment
  struct _GtkAdjustment *adjustment;
  // panel
  struct _GdkDrawable *panel;
  // timer
  unsigned int timer;
  // climb_rate
  double climb_rate;
  // timer_step
  double timer_step;
  // update_policy
  enum anonymous$62 update_policy;
  // in_child
  unsigned int in_child : 2;
  // click_child
  unsigned int click_child : 2;
  // button
  unsigned int button : 2;
  // need_timer
  unsigned int need_timer : 1;
  // timer_calls
  unsigned int timer_calls : 3;
  // digits
  unsigned int digits : 10;
  // numeric
  unsigned int numeric : 1;
  // wrap
  unsigned int wrap : 1;
  // snap_to_ticks
  unsigned int snap_to_ticks : 1;
};

struct _GtkStyle
{
  // parent_instance
  struct _GObject parent_instance;
  // fg
  struct _GdkColor fg[5l];
  // bg
  struct _GdkColor bg[5l];
  // light
  struct _GdkColor light[5l];
  // dark
  struct _GdkColor dark[5l];
  // mid
  struct _GdkColor mid[5l];
  // text
  struct _GdkColor text[5l];
  // base
  struct _GdkColor base[5l];
  // text_aa
  struct _GdkColor text_aa[5l];
  // black
  struct _GdkColor black;
  // white
  struct _GdkColor white;
  // font_desc
  struct _PangoFontDescription *font_desc;
  // xthickness
  signed int xthickness;
  // ythickness
  signed int ythickness;
  // fg_gc
  struct _GdkGC *fg_gc[5l];
  // bg_gc
  struct _GdkGC *bg_gc[5l];
  // light_gc
  struct _GdkGC *light_gc[5l];
  // dark_gc
  struct _GdkGC *dark_gc[5l];
  // mid_gc
  struct _GdkGC *mid_gc[5l];
  // text_gc
  struct _GdkGC *text_gc[5l];
  // base_gc
  struct _GdkGC *base_gc[5l];
  // text_aa_gc
  struct _GdkGC *text_aa_gc[5l];
  // black_gc
  struct _GdkGC *black_gc;
  // white_gc
  struct _GdkGC *white_gc;
  // bg_pixmap
  struct _GdkDrawable *bg_pixmap[5l];
  // attach_count
  signed int attach_count;
  // depth
  signed int depth;
  // colormap
  struct _GdkColormap *colormap;
  // private_font
  struct _GdkFont *private_font;
  // private_font_desc
  struct _PangoFontDescription *private_font_desc;
  // rc_style
  struct _GtkRcStyle *rc_style;
  // styles
  struct _GSList *styles;
  // property_cache
  struct _GArray *property_cache;
  // icon_factories
  struct _GSList *icon_factories;
};

struct _GtkTable
{
  // container
  struct _GtkContainer container;
  // children
  struct _GList *children;
  // rows
  struct _GtkTableRowCol *rows;
  // cols
  struct _GtkTableRowCol *cols;
  // nrows
  unsigned short int nrows;
  // ncols
  unsigned short int ncols;
  // column_spacing
  unsigned short int column_spacing;
  // row_spacing
  unsigned short int row_spacing;
  // homogeneous
  unsigned int homogeneous : 1;
};

struct _GtkTableChild
{
  // widget
  struct _GtkWidget *widget;
  // left_attach
  unsigned short int left_attach;
  // right_attach
  unsigned short int right_attach;
  // top_attach
  unsigned short int top_attach;
  // bottom_attach
  unsigned short int bottom_attach;
  // xpadding
  unsigned short int xpadding;
  // ypadding
  unsigned short int ypadding;
  // xexpand
  unsigned int xexpand : 1;
  // yexpand
  unsigned int yexpand : 1;
  // xshrink
  unsigned int xshrink : 1;
  // yshrink
  unsigned int yshrink : 1;
  // xfill
  unsigned int xfill : 1;
  // yfill
  unsigned int yfill : 1;
};

struct _GtkTableRowCol
{
  // requisition
  unsigned short int requisition;
  // allocation
  unsigned short int allocation;
  // spacing
  unsigned short int spacing;
  // need_expand
  unsigned int need_expand : 1;
  // need_shrink
  unsigned int need_shrink : 1;
  // expand
  unsigned int expand : 1;
  // shrink
  unsigned int shrink : 1;
  // empty
  unsigned int empty : 1;
};

struct _GtkTextAppearance
{
  // bg_color
  struct _GdkColor bg_color;
  // fg_color
  struct _GdkColor fg_color;
  // bg_stipple
  struct _GdkDrawable *bg_stipple;
  // fg_stipple
  struct _GdkDrawable *fg_stipple;
  // rise
  signed int rise;
  // padding1
  void *padding1;
  // underline
  unsigned int underline : 4;
  // strikethrough
  unsigned int strikethrough : 1;
  // draw_bg
  unsigned int draw_bg : 1;
  // inside_selection
  unsigned int inside_selection : 1;
  // is_text
  unsigned int is_text : 1;
  // pad1
  unsigned int pad1 : 1;
  // pad2
  unsigned int pad2 : 1;
  // pad3
  unsigned int pad3 : 1;
  // pad4
  unsigned int pad4 : 1;
};

struct _GtkTextAttributes
{
  // refcount
  unsigned int refcount;
  // appearance
  struct _GtkTextAppearance appearance;
  // justification
  enum anonymous$43 justification;
  // direction
  enum anonymous$44 direction;
  // font
  struct _PangoFontDescription *font;
  // font_scale
  double font_scale;
  // left_margin
  signed int left_margin;
  // indent
  signed int indent;
  // right_margin
  signed int right_margin;
  // pixels_above_lines
  signed int pixels_above_lines;
  // pixels_below_lines
  signed int pixels_below_lines;
  // pixels_inside_wrap
  signed int pixels_inside_wrap;
  // tabs
  struct _PangoTabArray *tabs;
  // wrap_mode
  enum anonymous$45 wrap_mode;
  // language
  struct _PangoLanguage *language;
  // pg_bg_color
  struct _GdkColor *pg_bg_color;
  // invisible
  unsigned int invisible : 1;
  // bg_full_height
  unsigned int bg_full_height : 1;
  // editable
  unsigned int editable : 1;
  // realized
  unsigned int realized : 1;
  // pad1
  unsigned int pad1 : 1;
  // pad2
  unsigned int pad2 : 1;
  // pad3
  unsigned int pad3 : 1;
  // pad4
  unsigned int pad4 : 1;
};

struct _GtkTextBuffer
{
  // parent_instance
  struct _GObject parent_instance;
  // tag_table
  struct _GtkTextTagTable *tag_table;
  // btree
  struct _GtkTextBTree *btree;
  // clipboard_contents_buffers
  struct _GSList *clipboard_contents_buffers;
  // selection_clipboards
  struct _GSList *selection_clipboards;
  // log_attr_cache
  struct _GtkTextLogAttrCache *log_attr_cache;
  // user_action_count
  unsigned int user_action_count;
  // modified
  unsigned int modified : 1;
  // has_selection
  unsigned int has_selection : 1;
};

struct _GtkTextIter
{
  // dummy1
  void *dummy1;
  // dummy2
  void *dummy2;
  // dummy3
  signed int dummy3;
  // dummy4
  signed int dummy4;
  // dummy5
  signed int dummy5;
  // dummy6
  signed int dummy6;
  // dummy7
  signed int dummy7;
  // dummy8
  signed int dummy8;
  // dummy9
  void *dummy9;
  // dummy10
  void *dummy10;
  // dummy11
  signed int dummy11;
  // dummy12
  signed int dummy12;
  // dummy13
  signed int dummy13;
  // dummy14
  void *dummy14;
};

struct _GtkTextMark
{
  // parent_instance
  struct _GObject parent_instance;
  // segment
  void *segment;
};

struct _GtkTextTagTable
{
  // parent_instance
  struct _GObject parent_instance;
  // hash
  struct _GHashTable *hash;
  // anonymous
  struct _GSList *anonymous;
  // anon_count
  signed int anon_count;
  // buffers
  struct _GSList *buffers;
};

struct _GtkTextView
{
  // parent_instance
  struct _GtkContainer parent_instance;
  // layout
  struct _GtkTextLayout *layout;
  // buffer
  struct _GtkTextBuffer *buffer;
  // selection_drag_handler
  unsigned int selection_drag_handler;
  // scroll_timeout
  unsigned int scroll_timeout;
  // pixels_above_lines
  signed int pixels_above_lines;
  // pixels_below_lines
  signed int pixels_below_lines;
  // pixels_inside_wrap
  signed int pixels_inside_wrap;
  // wrap_mode
  enum anonymous$45 wrap_mode;
  // justify
  enum anonymous$43 justify;
  // left_margin
  signed int left_margin;
  // right_margin
  signed int right_margin;
  // indent
  signed int indent;
  // tabs
  struct _PangoTabArray *tabs;
  // editable
  unsigned int editable : 1;
  // overwrite_mode
  unsigned int overwrite_mode : 1;
  // cursor_visible
  unsigned int cursor_visible : 1;
  // need_im_reset
  unsigned int need_im_reset : 1;
  // accepts_tab
  unsigned int accepts_tab : 1;
  // width_changed
  unsigned int width_changed : 1;
  // onscreen_validated
  unsigned int onscreen_validated : 1;
  // mouse_cursor_obscured
  unsigned int mouse_cursor_obscured : 1;
  // text_window
  struct _GtkTextWindow *text_window;
  // left_window
  struct _GtkTextWindow *left_window;
  // right_window
  struct _GtkTextWindow *right_window;
  // top_window
  struct _GtkTextWindow *top_window;
  // bottom_window
  struct _GtkTextWindow *bottom_window;
  // hadjustment
  struct _GtkAdjustment *hadjustment;
  // vadjustment
  struct _GtkAdjustment *vadjustment;
  // xoffset
  signed int xoffset;
  // yoffset
  signed int yoffset;
  // width
  signed int width;
  // height
  signed int height;
  // virtual_cursor_x
  signed int virtual_cursor_x;
  // virtual_cursor_y
  signed int virtual_cursor_y;
  // first_para_mark
  struct _GtkTextMark *first_para_mark;
  // first_para_pixels
  signed int first_para_pixels;
  // dnd_mark
  struct _GtkTextMark *dnd_mark;
  // blink_timeout
  unsigned int blink_timeout;
  // first_validate_idle
  unsigned int first_validate_idle;
  // incremental_validate_idle
  unsigned int incremental_validate_idle;
  // im_context
  struct _GtkIMContext *im_context;
  // popup_menu
  struct _GtkWidget *popup_menu;
  // drag_start_x
  signed int drag_start_x;
  // drag_start_y
  signed int drag_start_y;
  // children
  struct _GSList *children;
  // pending_scroll
  struct _GtkTextPendingScroll *pending_scroll;
  // pending_place_cursor_button
  signed int pending_place_cursor_button;
};

struct _GtkTooltips
{
  // parent_instance
  struct _GtkObject parent_instance;
  // tip_window
  struct _GtkWidget *tip_window;
  // tip_label
  struct _GtkWidget *tip_label;
  // active_tips_data
  struct _GtkTooltipsData *active_tips_data;
  // tips_data_list
  struct _GList *tips_data_list;
  // delay
  unsigned int delay : 30;
  // enabled
  unsigned int enabled : 1;
  // have_grab
  unsigned int have_grab : 1;
  // use_sticky_delay
  unsigned int use_sticky_delay : 1;
  // timer_tag
  signed int timer_tag;
  // last_popdown
  struct _GTimeVal last_popdown;
};

struct _GtkTooltipsData
{
  // tooltips
  struct _GtkTooltips *tooltips;
  // widget
  struct _GtkWidget *widget;
  // tip_text
  char *tip_text;
  // tip_private
  char *tip_private;
};

struct _GtkTreeIter
{
  // stamp
  signed int stamp;
  // user_data
  void *user_data;
  // user_data2
  void *user_data2;
  // user_data3
  void *user_data3;
};

struct _GtkTreeSelection
{
  // parent
  struct _GObject parent;
  // tree_view
  struct _GtkTreeView *tree_view;
  // type
  enum anonymous$24 type;
  // user_func
  signed int (*user_func)(struct _GtkTreeSelection *, struct _GtkTreeModel *, struct _GtkTreePath *, signed int, void *);
  // user_data
  void *user_data;
  // destroy
  void (*destroy)(void *);
};

struct _GtkTreeStore
{
  // parent
  struct _GObject parent;
  // stamp
  signed int stamp;
  // root
  void *root;
  // last
  void *last;
  // n_columns
  signed int n_columns;
  // sort_column_id
  signed int sort_column_id;
  // sort_list
  struct _GList *sort_list;
  // order
  enum anonymous$26 order;
  // column_headers
  unsigned long int *column_headers;
  // default_sort_func
  signed int (*default_sort_func)(struct _GtkTreeModel *, struct _GtkTreeIter *, struct _GtkTreeIter *, void *);
  // default_sort_data
  void *default_sort_data;
  // default_sort_destroy
  void (*default_sort_destroy)(void *);
  // columns_dirty
  unsigned int columns_dirty : 1;
};

struct _GtkTreeView
{
  // parent
  struct _GtkContainer parent;
  // priv
  struct _GtkTreeViewPrivate *priv;
};

struct _GtkTreeViewColumn
{
  // parent
  struct _GtkObject parent;
  // tree_view
  struct _GtkWidget *tree_view;
  // button
  struct _GtkWidget *button;
  // child
  struct _GtkWidget *child;
  // arrow
  struct _GtkWidget *arrow;
  // alignment
  struct _GtkWidget *alignment;
  // window
  struct _GdkDrawable *window;
  // editable_widget
  struct _GtkCellEditable *editable_widget;
  // xalign
  float xalign;
  // property_changed_signal
  unsigned int property_changed_signal;
  // spacing
  signed int spacing;
  // column_type
  enum anonymous$18 column_type;
  // requested_width
  signed int requested_width;
  // button_request
  signed int button_request;
  // resized_width
  signed int resized_width;
  // width
  signed int width;
  // fixed_width
  signed int fixed_width;
  // min_width
  signed int min_width;
  // max_width
  signed int max_width;
  // drag_x
  signed int drag_x;
  // drag_y
  signed int drag_y;
  // title
  char *title;
  // cell_list
  struct _GList *cell_list;
  // sort_clicked_signal
  unsigned int sort_clicked_signal;
  // sort_column_changed_signal
  unsigned int sort_column_changed_signal;
  // sort_column_id
  signed int sort_column_id;
  // sort_order
  enum anonymous$26 sort_order;
  // visible
  unsigned int visible : 1;
  // resizable
  unsigned int resizable : 1;
  // clickable
  unsigned int clickable : 1;
  // dirty
  unsigned int dirty : 1;
  // show_sort_indicator
  unsigned int show_sort_indicator : 1;
  // maybe_reordered
  unsigned int maybe_reordered : 1;
  // reorderable
  unsigned int reorderable : 1;
  // use_resized_width
  unsigned int use_resized_width : 1;
  // expand
  unsigned int expand : 1;
};

struct _GtkWindowGroup
{
  // parent_instance
  struct _GObject parent_instance;
  // grabs
  struct _GSList *grabs;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous$64 __saved_mask;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct buffer_control_t
{
  // count
  struct anonymous$74 count;
  // timer
  struct anonymous$74 timer;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in6_addr
{
  // __in6_u
  union anonymous$75 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct info_buffer_t
{
  // age
  signed int age;
  // count
  signed int count;
  // orig_color
  signed int orig_color;
  // type
  signed int type;
  // subtype
  signed int subtype;
  // message
  char message[56l];
};

struct internal_state
{
  // dummy
  signed int dummy;
};

struct keybind
{
  // flags
  unsigned char flags;
  // direction
  signed char direction;
  // keysym
  unsigned int keysym;
  // command
  char *command;
  // next
  struct keybind *next;
};

struct msgctrl_data_t
{
  // description
  const char *description;
  // buffer
  const signed int buffer;
  // pane
  const signed int pane[2l];
};

struct png_color_16_struct
{
  // index
  unsigned char index;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // gray
  unsigned short int gray;
};

struct png_color_8_struct
{
  // red
  unsigned char red;
  // green
  unsigned char green;
  // blue
  unsigned char blue;
  // gray
  unsigned char gray;
  // alpha
  unsigned char alpha;
};

struct png_color_struct
{
  // red
  unsigned char red;
  // green
  unsigned char green;
  // blue
  unsigned char blue;
};

struct png_time_struct
{
  // year
  unsigned short int year;
  // month
  unsigned char month;
  // day
  unsigned char day;
  // hour
  unsigned char hour;
  // minute
  unsigned char minute;
  // second
  unsigned char second;
};

struct png_info_struct
{
  // width
  unsigned long int width;
  // height
  unsigned long int height;
  // valid
  unsigned long int valid;
  // rowbytes
  unsigned long int rowbytes;
  // palette
  struct png_color_struct *palette;
  // num_palette
  unsigned short int num_palette;
  // num_trans
  unsigned short int num_trans;
  // bit_depth
  unsigned char bit_depth;
  // color_type
  unsigned char color_type;
  // compression_type
  unsigned char compression_type;
  // filter_type
  unsigned char filter_type;
  // interlace_type
  unsigned char interlace_type;
  // channels
  unsigned char channels;
  // pixel_depth
  unsigned char pixel_depth;
  // spare_byte
  unsigned char spare_byte;
  // signature
  unsigned char signature[8l];
  // gamma
  float gamma;
  // srgb_intent
  unsigned char srgb_intent;
  // num_text
  signed int num_text;
  // max_text
  signed int max_text;
  // text
  struct png_text_struct *text;
  // mod_time
  struct png_time_struct mod_time;
  // sig_bit
  struct png_color_8_struct sig_bit;
  // trans
  unsigned char *trans;
  // trans_values
  struct png_color_16_struct trans_values;
  // background
  struct png_color_16_struct background;
  // x_offset
  signed long int x_offset;
  // y_offset
  signed long int y_offset;
  // offset_unit_type
  unsigned char offset_unit_type;
  // x_pixels_per_unit
  unsigned long int x_pixels_per_unit;
  // y_pixels_per_unit
  unsigned long int y_pixels_per_unit;
  // phys_unit_type
  unsigned char phys_unit_type;
  // hist
  unsigned short int *hist;
  // x_white
  float x_white;
  // y_white
  float y_white;
  // x_red
  float x_red;
  // y_red
  float y_red;
  // x_green
  float x_green;
  // y_green
  float y_green;
  // x_blue
  float x_blue;
  // y_blue
  float y_blue;
  // pcal_purpose
  char *pcal_purpose;
  // pcal_X0
  signed long int pcal_X0;
  // pcal_X1
  signed long int pcal_X1;
  // pcal_units
  char *pcal_units;
  // pcal_params
  char **pcal_params;
  // pcal_type
  unsigned char pcal_type;
  // pcal_nparams
  unsigned char pcal_nparams;
  // free_me
  unsigned long int free_me;
  // unknown_chunks
  struct png_unknown_chunk_t *unknown_chunks;
  // unknown_chunks_num
  unsigned long int unknown_chunks_num;
  // iccp_name
  char *iccp_name;
  // iccp_profile
  char *iccp_profile;
  // iccp_proflen
  unsigned long int iccp_proflen;
  // iccp_compression
  unsigned char iccp_compression;
  // splt_palettes
  struct png_sPLT_struct *splt_palettes;
  // splt_palettes_num
  unsigned long int splt_palettes_num;
  // scal_unit
  unsigned char scal_unit;
  // scal_pixel_width
  double scal_pixel_width;
  // scal_pixel_height
  double scal_pixel_height;
  // scal_s_width
  char *scal_s_width;
  // scal_s_height
  char *scal_s_height;
  // row_pointers
  unsigned char **row_pointers;
  // int_gamma
  signed long int int_gamma;
  // int_x_white
  signed long int int_x_white;
  // int_y_white
  signed long int int_y_white;
  // int_x_red
  signed long int int_x_red;
  // int_y_red
  signed long int int_y_red;
  // int_x_green
  signed long int int_x_green;
  // int_y_green
  signed long int int_y_green;
  // int_x_blue
  signed long int int_x_blue;
  // int_y_blue
  signed long int int_y_blue;
};

struct png_row_info_struct
{
  // width
  unsigned long int width;
  // rowbytes
  unsigned long int rowbytes;
  // color_type
  unsigned char color_type;
  // bit_depth
  unsigned char bit_depth;
  // channels
  unsigned char channels;
  // pixel_depth
  unsigned char pixel_depth;
};

struct png_sPLT_entry_struct
{
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // alpha
  unsigned short int alpha;
  // frequency
  unsigned short int frequency;
};

struct png_sPLT_struct
{
  // name
  char *name;
  // depth
  unsigned char depth;
  // entries
  struct png_sPLT_entry_struct *entries;
  // nentries
  signed long int nentries;
};

struct z_stream_s
{
  // next_in
  unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};

struct png_unknown_chunk_t
{
  // name
  unsigned char name[5l];
  // data
  unsigned char *data;
  // size
  unsigned long int size;
  // location
  unsigned char location;
};

struct png_struct_def
{
  // jmpbuf
  struct __jmp_buf_tag jmpbuf[1l];
  // error_fn
  void (*error_fn)(struct png_struct_def *, const char *);
  // warning_fn
  void (*warning_fn)(struct png_struct_def *, const char *);
  // error_ptr
  void *error_ptr;
  // write_data_fn
  void (*write_data_fn)(struct png_struct_def *, unsigned char *, unsigned long int);
  // read_data_fn
  void (*read_data_fn)(struct png_struct_def *, unsigned char *, unsigned long int);
  // io_ptr
  void *io_ptr;
  // read_user_transform_fn
  void (*read_user_transform_fn)(struct png_struct_def *, struct png_row_info_struct *, unsigned char *);
  // write_user_transform_fn
  void (*write_user_transform_fn)(struct png_struct_def *, struct png_row_info_struct *, unsigned char *);
  // user_transform_ptr
  void *user_transform_ptr;
  // user_transform_depth
  unsigned char user_transform_depth;
  // user_transform_channels
  unsigned char user_transform_channels;
  // mode
  unsigned long int mode;
  // flags
  unsigned long int flags;
  // transformations
  unsigned long int transformations;
  // zstream
  struct z_stream_s zstream;
  // zbuf
  unsigned char *zbuf;
  // zbuf_size
  unsigned long int zbuf_size;
  // zlib_level
  signed int zlib_level;
  // zlib_method
  signed int zlib_method;
  // zlib_window_bits
  signed int zlib_window_bits;
  // zlib_mem_level
  signed int zlib_mem_level;
  // zlib_strategy
  signed int zlib_strategy;
  // width
  unsigned long int width;
  // height
  unsigned long int height;
  // num_rows
  unsigned long int num_rows;
  // usr_width
  unsigned long int usr_width;
  // rowbytes
  unsigned long int rowbytes;
  // user_chunk_cache_max
  unsigned long int user_chunk_cache_max;
  // iwidth
  unsigned long int iwidth;
  // row_number
  unsigned long int row_number;
  // prev_row
  unsigned char *prev_row;
  // row_buf
  unsigned char *row_buf;
  // sub_row
  unsigned char *sub_row;
  // up_row
  unsigned char *up_row;
  // avg_row
  unsigned char *avg_row;
  // paeth_row
  unsigned char *paeth_row;
  // row_info
  struct png_row_info_struct row_info;
  // idat_size
  unsigned long int idat_size;
  // crc
  unsigned long int crc;
  // palette
  struct png_color_struct *palette;
  // num_palette
  unsigned short int num_palette;
  // num_trans
  unsigned short int num_trans;
  // chunk_name
  unsigned char chunk_name[5l];
  // compression
  unsigned char compression;
  // filter
  unsigned char filter;
  // interlaced
  unsigned char interlaced;
  // pass
  unsigned char pass;
  // do_filter
  unsigned char do_filter;
  // color_type
  unsigned char color_type;
  // bit_depth
  unsigned char bit_depth;
  // usr_bit_depth
  unsigned char usr_bit_depth;
  // pixel_depth
  unsigned char pixel_depth;
  // channels
  unsigned char channels;
  // usr_channels
  unsigned char usr_channels;
  // sig_bytes
  unsigned char sig_bytes;
  // filler
  unsigned short int filler;
  // background_gamma_type
  unsigned char background_gamma_type;
  // background_gamma
  float background_gamma;
  // background
  struct png_color_16_struct background;
  // background_1
  struct png_color_16_struct background_1;
  // output_flush_fn
  void (*output_flush_fn)(struct png_struct_def *);
  // flush_dist
  unsigned long int flush_dist;
  // flush_rows
  unsigned long int flush_rows;
  // gamma_shift
  signed int gamma_shift;
  // gamma
  float gamma;
  // screen_gamma
  float screen_gamma;
  // gamma_table
  unsigned char *gamma_table;
  // gamma_from_1
  unsigned char *gamma_from_1;
  // gamma_to_1
  unsigned char *gamma_to_1;
  // gamma_16_table
  unsigned short int **gamma_16_table;
  // gamma_16_from_1
  unsigned short int **gamma_16_from_1;
  // gamma_16_to_1
  unsigned short int **gamma_16_to_1;
  // sig_bit
  struct png_color_8_struct sig_bit;
  // shift
  struct png_color_8_struct shift;
  // trans
  unsigned char *trans;
  // trans_values
  struct png_color_16_struct trans_values;
  // read_row_fn
  void (*read_row_fn)(struct png_struct_def *, unsigned long int, signed int);
  // write_row_fn
  void (*write_row_fn)(struct png_struct_def *, unsigned long int, signed int);
  // info_fn
  void (*info_fn)(struct png_struct_def *, struct png_info_struct *);
  // row_fn
  void (*row_fn)(struct png_struct_def *, unsigned char *, unsigned long int, signed int);
  // end_fn
  void (*end_fn)(struct png_struct_def *, struct png_info_struct *);
  // save_buffer_ptr
  unsigned char *save_buffer_ptr;
  // save_buffer
  unsigned char *save_buffer;
  // current_buffer_ptr
  unsigned char *current_buffer_ptr;
  // current_buffer
  unsigned char *current_buffer;
  // push_length
  unsigned long int push_length;
  // skip_length
  unsigned long int skip_length;
  // save_buffer_size
  unsigned long int save_buffer_size;
  // save_buffer_max
  unsigned long int save_buffer_max;
  // buffer_size
  unsigned long int buffer_size;
  // current_buffer_size
  unsigned long int current_buffer_size;
  // process_mode
  signed int process_mode;
  // cur_palette
  signed int cur_palette;
  // current_text_size
  unsigned long int current_text_size;
  // current_text_left
  unsigned long int current_text_left;
  // current_text
  char *current_text;
  // current_text_ptr
  char *current_text_ptr;
  // palette_lookup
  unsigned char *palette_lookup;
  // dither_index
  unsigned char *dither_index;
  // hist
  unsigned short int *hist;
  // time_buffer
  char *time_buffer;
  // free_me
  unsigned long int free_me;
  // user_chunk_ptr
  void *user_chunk_ptr;
  // read_user_chunk_fn
  signed int (*read_user_chunk_fn)(struct png_struct_def *, struct png_unknown_chunk_t *);
  // num_chunk_list
  signed int num_chunk_list;
  // chunk_list
  unsigned char *chunk_list;
  // rgb_to_gray_status
  unsigned char rgb_to_gray_status;
  // rgb_to_gray_red_coeff
  unsigned short int rgb_to_gray_red_coeff;
  // rgb_to_gray_green_coeff
  unsigned short int rgb_to_gray_green_coeff;
  // rgb_to_gray_blue_coeff
  unsigned short int rgb_to_gray_blue_coeff;
  // mng_features_permitted
  unsigned long int mng_features_permitted;
  // int_gamma
  signed long int int_gamma;
  // filter_type
  unsigned char filter_type;
  // mmx_bitdepth_threshold
  unsigned char mmx_bitdepth_threshold;
  // mmx_rowbytes_threshold
  unsigned long int mmx_rowbytes_threshold;
  // asm_flags
  unsigned long int asm_flags;
  // mem_ptr
  void *mem_ptr;
  // malloc_fn
  void * (*malloc_fn)(struct png_struct_def *, unsigned long int);
  // free_fn
  void (*free_fn)(struct png_struct_def *, void *);
  // big_row_buf
  unsigned char *big_row_buf;
  // dither_sort
  unsigned char *dither_sort;
  // index_to_palette
  unsigned char *index_to_palette;
  // palette_to_index
  unsigned char *palette_to_index;
  // compression_type
  unsigned char compression_type;
  // user_width_max
  unsigned long int user_width_max;
  // user_height_max
  unsigned long int user_height_max;
  // unknown_chunk
  struct png_unknown_chunk_t unknown_chunk;
  // old_big_row_buf_size
  unsigned long int old_big_row_buf_size;
  // old_prev_row_size
  unsigned long int old_prev_row_size;
  // chunkdata
  char *chunkdata;
};

struct png_text_struct
{
  // compression
  signed int compression;
  // key
  char *key;
  // text
  char *text;
  // text_length
  unsigned long int text_length;
};

struct protoent
{
  // p_name
  char *p_name;
  // p_aliases
  char **p_aliases;
  // p_proto
  signed int p_proto;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct script
{
  // name
  char *name;
  // params
  char *params;
  // out_fd
  signed int out_fd;
  // in_fd
  signed int in_fd;
  // monitor
  signed int monitor;
  // num_watch
  signed int num_watch;
  // watch
  char **watch;
  // cmd_count
  signed int cmd_count;
  // cmd
  char cmd[1024l];
  // pid
  signed int pid;
  // sync_watch
  signed int sync_watch;
};

struct script_state
{
  // state
  struct lua_State *state;
  // filename
  const char *filename;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// CommonCommands
// file p_cmd.c line 703
static struct anonymous$47 CommonCommands[28l];
// CommonCommands
// file p_cmd.c line 703
static struct anonymous$47 CommonCommands[28l] = { { .name="autorepeat", .cat=(enum anonymous$46)COMM_CAT_MISC, .dofunc=set_autorepeat,
    .helpfunc=(const char * (*)(void))(void *)0, .desc="toggle autorepeat" }, 
    { .name="bind", .cat=(enum anonymous$46)COMM_CAT_SETUP, .dofunc=bind_key,
    .helpfunc=help_bind, .desc="bind a command to a key" }, 
    { .name="script", .cat=(enum anonymous$46)COMM_CAT_SCRIPT, .dofunc=script_init,
    .helpfunc=help_script, .desc=(const char *)(void *)0 }, 
    { .name="lua_load", .cat=(enum anonymous$46)COMM_CAT_SCRIPT, .dofunc=script_lua_load,
    .helpfunc=(const char * (*)(void))(void *)0, .desc=(const char *)(void *)0 }, 
    { .name="lua_list", .cat=(enum anonymous$46)COMM_CAT_SCRIPT, .dofunc=script_lua_list,
    .helpfunc=(const char * (*)(void))(void *)0, .desc=(const char *)(void *)0 }, 
    { .name="lua_kill", .cat=(enum anonymous$46)COMM_CAT_SCRIPT, .dofunc=script_lua_kill,
    .helpfunc=(const char * (*)(void))(void *)0, .desc=(const char *)(void *)0 }, 
    { .name="scripts", .cat=(enum anonymous$46)COMM_CAT_SCRIPT, .dofunc=do_script_list,
    .helpfunc=(const char * (*)(void))(void *)0, .desc="List the running scripts(?)" }, 
    { .name="scriptkill", .cat=(enum anonymous$46)COMM_CAT_SCRIPT, .dofunc=script_kill,
    .helpfunc=help_scriptkill, .desc=(const char *)(void *)0 }, 
    { .name="scripttell", .cat=(enum anonymous$46)COMM_CAT_SCRIPT, .dofunc=script_tell,
    .helpfunc=help_scripttell, .desc=(const char *)(void *)0 }, 
    { .name="clearinfo", .cat=(enum anonymous$46)COMM_CAT_MISC, .dofunc=do_clearinfo,
    .helpfunc=(const char * (*)(void))(void *)0, .desc="clear the info window" }, 
    { .name="cwindow", .cat=(enum anonymous$46)COMM_CAT_SETUP, .dofunc=set_command_window,
    .helpfunc=help_cwindow, .desc=(const char *)(void *)0 }, 
    { .name="disconnect", .cat=(enum anonymous$46)COMM_CAT_MISC, .dofunc=do_disconnect,
    .helpfunc=(const char * (*)(void))(void *)0, .desc="close connection to server" }, 
    { .name="foodbeep", .cat=(enum anonymous$46)COMM_CAT_SETUP, .dofunc=command_foodbeep,
    .helpfunc=(const char * (*)(void))(void *)0, .desc="toggle audible low on food warning" }, 
    { .name="help", .cat=(enum anonymous$46)COMM_CAT_HELP, .dofunc=command_help,
    .helpfunc=help_help, .desc=(const char *)(void *)0 }, 
    { .name="clienthelp", .cat=(enum anonymous$46)COMM_CAT_HELP, .dofunc=do_clienthelp,
    .helpfunc=help_clienthelp, .desc="Client-side command information" }, 
    { .name="serverhelp", .cat=(enum anonymous$46)COMM_CAT_HELP, .dofunc=do_serverhelp,
    .helpfunc=help_serverhelp, .desc="Server-side command information" }, 
    { .name="inv", .cat=(enum anonymous$46)COMM_CAT_DEBUG, .dofunc=do_inv,
    .helpfunc=help_inv, .desc="show clients inventory (debug)" }, 
    { .name="magicmap", .cat=(enum anonymous$46)COMM_CAT_MISC, .dofunc=do_magicmap,
    .helpfunc=help_magicmap, .desc="show last received magic map" }, 
    { .name="metaserver", .cat=(enum anonymous$46)COMM_CAT_INFO, .dofunc=do_metaserver,
    .helpfunc=help_metaserver, .desc="Print 'metaserver information'. Warning - your client will pause." }, 
    { .name="savedefaults", .cat=(enum anonymous$46)COMM_CAT_SETUP, .dofunc=do_savedefaults,
    .helpfunc=(const char * (*)(void))(void *)0, .desc="save various defaults into ~/.crossfire/defaults" }, 
    { .name="savewinpos", .cat=(enum anonymous$46)COMM_CAT_SETUP, .dofunc=do_savewinpos,
    .helpfunc=help_savewinpos, .desc="Saves the position and sizes of windows." }, 
    { .name="scroll", .cat=(enum anonymous$46)COMM_CAT_SETUP, .dofunc=set_scroll,
    .helpfunc=(const char * (*)(void))(void *)0, .desc="toggle scroll/wrap mode in info window" }, 
    { .name="showicon", .cat=(enum anonymous$46)COMM_CAT_SETUP, .dofunc=set_show_icon,
    .helpfunc=(const char * (*)(void))(void *)0, .desc="Toggles if you see the worn, locked, cursed etc state in the inventory pane." }, 
    { .name="showweight", .cat=(enum anonymous$46)COMM_CAT_SETUP, .dofunc=set_show_weight,
    .helpfunc=help_showweight, .desc="Toggles if you see item weights in inventory look windows." }, 
    { .name="take", .cat=(enum anonymous$46)COMM_CAT_MISC, .dofunc=do_take,
    .helpfunc=(const char * (*)(void))(void *)0, .desc=(const char *)(void *)0 }, 
    { .name="unbind", .cat=(enum anonymous$46)COMM_CAT_SETUP, .dofunc=unbind_key,
    .helpfunc=help_unbind, .desc=(const char *)(void *)0 }, 
    { .name="num_free_items", .cat=(enum anonymous$46)COMM_CAT_DEBUG, .dofunc=do_num_free_items,
    .helpfunc=(const char * (*)(void))(void *)0, .desc="log the number of free items?" }, 
    { .name="show", .cat=(enum anonymous$46)COMM_CAT_SETUP, .dofunc=command_show,
    .helpfunc=(const char * (*)(void))(void *)0, .desc="Change what items to show in inventory" } };
// CommonCommandsSize
// file p_cmd.c line 886
const signed int CommonCommandsSize = (const signed int)(sizeof(struct anonymous$47 [28l]) /*1120ul*/  / sizeof(struct anonymous$47) /*40ul*/ );
// FirstChild
// file misc.c line 204
struct ChildProcess *FirstChild = (struct ChildProcess *)(void *)0;
// LastChild
// file misc.c line 205
struct ChildProcess *LastChild = (struct ChildProcess *)(void *)0;
// LogLevelTexts
// file misc.c line 164
static const char * const LogLevelTexts[6l] = { "\033[34;1mDD\033[0m", "\033[32;1mII\033[0m", "\033[35;1mWW\033[0m", "\033[31;1mEE\033[0m", "\033[31;1m!!\033[0m", "\033[30;1m??\033[0m" };
// MINLOG
// file misc.c line 177
signed int MINLOG = 0;
// Style_Names
// file inventory.c line 66
static const char *Style_Names[5l] = { "inv_magical", "inv_cursed", "inv_unpaid", "inv_locked", "inv_applied" };
// Style_Names$link1
// file spells.c line 48
static const char *Style_Names$link1[4l] = { "spell_attuned", "spell_repelled", "spell_denied", "spell_normal" };
// VERSION_INFO
// file client.c line 48
char VERSION_INFO[256l];
// about_window
// file about.c line 33
static struct _GtkWidget *about_window = (struct _GtkWidget *)(void *)0;
// account_password
// file account.c line 65
char account_password[256l];
// account_password_window
// file account.c line 33
static struct _GtkWidget *account_password_window;
// add_character_window
// file account.c line 32
static struct _GtkWidget *add_character_window;
// all_xpm
// file ../../pixmaps/all.xpm line 2
static const char * const all_xpm[21l] = { "20 16 4 1", " \tc None", ".\tc #A0522D", "+\tc #CD853F", "@\tc #000000", "                    ", "          .+        ", "         .+..       ", "        @+..@       ", "       .@@@         ", "      .+.+@+        ", "     .+.+.+..       ", "    .+.+.+..@.      ", "    +.+......@.     ", "    .+......@.@     ", "    +.+....@.@.     ", "    .+....@.@.@     ", "    +..@.@.@.@      ", "     +@.@.@.@       ", "       @.@.@        ", "                    " };
// altkeysym
// file keys.c line 128
static unsigned int altkeysym[2l];
// animations
// file commands.c line 1128
struct Animations animations[2000l];
// apply_string
// file item.c line 473
static const char * const apply_string[6l] = { "", " (readied)", " (wielded)", " (worn)", " (active)", " (applied)" };
// bar_colors
// file stats.c line 66
struct _GdkColor *bar_colors[5l][6l];
// bc_exclude
// file opengl.c line 376
static signed int bc_exclude[8l] = { 1 + 2, 0, 2 + 4, 0, 4 + 8, 0, 8 + 1, 0 };
// bigfaces
// file mapdata.c line 112
static struct BigCell bigfaces[64l][64l][10l];
// bigfaces_head
// file mapdata.c line 105
static struct BigCell *bigfaces_head;
// bind_buf
// file keys.c line 132
static char bind_buf[256l];
// bind_flags
// file keys.c line 131
static signed int bind_flags = 0;
// bind_keysym
// file keys.c line 127
static unsigned int *bind_keysym;
// buffer_control
// file info.c line 183
struct buffer_control_t buffer_control = { .count={ .ptr=(struct _GtkWidget *)(void *)0, .state=(unsigned int)0, .default_state=(const unsigned int)16 }, .timer={ .ptr=(struct _GtkWidget *)(void *)0, .state=(unsigned int)0, .default_state=(const unsigned int)16 } };
// button_account_password
// file account.c line 49
static struct _GtkWidget *button_account_password;
// button_account_password_cancel
// file account.c line 60
static struct _GtkWidget *button_account_password_cancel;
// button_account_password_confirm
// file account.c line 59
static struct _GtkWidget *button_account_password_confirm;
// button_add_character
// file account.c line 49
static struct _GtkWidget *button_add_character;
// button_cc_cancel
// file create_char.c line 58
static struct _GtkWidget *button_cc_cancel;
// button_cc_done
// file create_char.c line 58
static struct _GtkWidget *button_cc_done;
// button_choose_starting_map
// file create_char.c line 59
static struct _GtkWidget *button_choose_starting_map;
// button_create_account
// file account.c line 36
static struct _GtkWidget *button_create_account;
// button_create_character
// file account.c line 48
static struct _GtkWidget *button_create_character;
// button_create_new_char
// file account.c line 54
static struct _GtkWidget *button_create_new_char;
// button_csm_cancel
// file create_char.c line 66
static struct _GtkWidget *button_csm_cancel;
// button_csm_done
// file create_char.c line 66
static struct _GtkWidget *button_csm_done;
// button_do_add_character
// file account.c line 75
static struct _GtkWidget *button_do_add_character;
// button_exit_client
// file account.c line 37
static struct _GtkWidget *button_exit_client;
// button_go_metaserver
// file account.c line 37
static struct _GtkWidget *button_go_metaserver;
// button_login
// file account.c line 36
static struct _GtkWidget *button_login;
// button_new_cancel
// file account.c line 42
static struct _GtkWidget *button_new_cancel;
// button_new_char_cancel
// file account.c line 55
static struct _GtkWidget *button_new_char_cancel;
// button_new_create_account
// file account.c line 42
static struct _GtkWidget *button_new_create_account;
// button_play_character
// file account.c line 48
static struct _GtkWidget *button_play_character;
// button_return_character_select
// file account.c line 76
static struct _GtkWidget *button_return_character_select;
// button_return_login
// file account.c line 49
static struct _GtkWidget *button_return_login;
// bweights
// file opengl.c line 374
static signed int bweights[8l] = { 2, 0, 4, 0, 8, 0, 1, 0 };
// cached_server_file
// file metaserver.c line 106
const char *cached_server_file = (const char *)(void *)0;
// cached_servers_ip
// file metaserver.c line 104
char *cached_servers_ip[10l];
// cached_servers_loaded
// file metaserver.c line 105
static signed int cached_servers_loaded = 0;
// cached_servers_name
// file metaserver.c line 103
char *cached_servers_name[10l];
// cached_servers_num
// file metaserver.c line 102
signed int cached_servers_num = 0;
// cancelkeysym
// file keys.c line 129
static unsigned int cancelkeysym;
// cat_sorted_commands
// file p_cmd.c line 921
static struct anonymous$47 **cat_sorted_commands;
// character_store
// file account.c line 62
struct _GtkListStore *character_store;
// choose_char_window
// file account.c line 32
static struct _GtkWidget *choose_char_window;
// choose_starting_map_window
// file create_char.c line 65
static struct _GtkWidget *choose_starting_map_window;
// classes
// file commands.c line 98
struct Race_Class_Info *classes = (struct Race_Class_Info *)(void *)0;
// coin_xpm
// file ../../pixmaps/coin.xpm line 2
static const char * const coin_xpm[22l] = { "20 16 5 1", " \tc None", ".\tc #000000", "+\tc #FFD700", "@\tc #FFFF00", "#\tc #DAA520", "                    ", "      ...           ", "    ..+++..         ", "   .+++@#++.        ", "   .++@++#+...      ", "  .++@+++..+++..    ", "  .++@++.+++@#++.   ", "  .++@++.++@++#+.   ", "   .++@.++@+++#++.  ", "   .+++.++@+++#++.  ", "    ..+.++@+++#++.  ", "      ...++@##++.   ", "        .+++++++.   ", "         ..+++..    ", "           ...      ", "                    " };
// colorname
// file main.c line 47
const char * const colorname[13l] = { "Black", "White", "Navy", "Red", "Orange", "DodgerBlue", "DarkOrange2", "SeaGreen", "DarkSeaGreen", "Grey50", "Sienna", "Gold", "Khaki" };
// combobox_cs
// file create_char.c line 59
static struct _GtkWidget *combobox_cs;
// combobox_rs
// file create_char.c line 58
static struct _GtkWidget *combobox_rs;
// combobox_starting_map
// file create_char.c line 66
static struct _GtkWidget *combobox_starting_map;
// commandkeysym
// file keys.c line 127
static unsigned int commandkeysym;
// commands
// file client.c line 100
struct CmdMapping commands[36l];
// commands
// file client.c line 100
struct CmdMapping commands[36l] = { { .cmdname="map2", .cmdproc=Map2Cmd, .cmdformat=(enum CmdFormat)1 }, 
    { .cmdname="map_scroll", .cmdproc=(void (*)(unsigned char *, signed int))map_scrollCmd, .cmdformat=(enum CmdFormat)0 }, 
    { .cmdname="magicmap", .cmdproc=MagicMapCmd, .cmdformat=(enum CmdFormat)4 }, 
    { .cmdname="newmap", .cmdproc=NewmapCmd, .cmdformat=(enum CmdFormat)6 }, 
    { .cmdname="mapextended", .cmdproc=MapExtendedCmd, .cmdformat=(enum CmdFormat)4 }, 
    { .cmdname="item2", .cmdproc=Item2Cmd, .cmdformat=(enum CmdFormat)4 }, 
    { .cmdname="upditem", .cmdproc=UpdateItemCmd, .cmdformat=(enum CmdFormat)4 }, 
    { .cmdname="delitem", .cmdproc=DeleteItem, .cmdformat=(enum CmdFormat)2 }, 
    { .cmdname="delinv", .cmdproc=DeleteInventory, .cmdformat=(enum CmdFormat)0 }, 
    { .cmdname="addspell", .cmdproc=AddspellCmd, .cmdformat=(enum CmdFormat)4 }, 
    { .cmdname="updspell", .cmdproc=UpdspellCmd, .cmdformat=(enum CmdFormat)4 }, 
    { .cmdname="delspell", .cmdproc=DeleteSpell, .cmdformat=(enum CmdFormat)2 }, 
    { .cmdname="drawinfo", .cmdproc=(void (*)(unsigned char *, signed int))DrawInfoCmd, .cmdformat=(enum CmdFormat)0 }, 
    { .cmdname="drawextinfo", .cmdproc=(void (*)(unsigned char *, signed int))DrawExtInfoCmd, .cmdformat=(enum CmdFormat)0 }, 
    { .cmdname="stats", .cmdproc=StatsCmd, .cmdformat=(enum CmdFormat)5 }, 
    { .cmdname="image2", .cmdproc=Image2Cmd, .cmdformat=(enum CmdFormat)4 }, 
    { .cmdname="face2", .cmdproc=Face2Cmd, .cmdformat=(enum CmdFormat)4 }, 
    { .cmdname="tick", .cmdproc=TickCmd, .cmdformat=(enum CmdFormat)2 }, 
    { .cmdname="music", .cmdproc=(void (*)(unsigned char *, signed int))MusicCmd, .cmdformat=(enum CmdFormat)0 }, 
    { .cmdname="sound2", .cmdproc=Sound2Cmd, .cmdformat=(enum CmdFormat)4 }, 
    { .cmdname="anim", .cmdproc=AnimCmd, .cmdformat=(enum CmdFormat)1 }, 
    { .cmdname="smooth", .cmdproc=SmoothCmd, .cmdformat=(enum CmdFormat)1 }, 
    { .cmdname="player", .cmdproc=PlayerCmd, .cmdformat=(enum CmdFormat)4 }, 
    { .cmdname="comc", .cmdproc=CompleteCmd, .cmdformat=(enum CmdFormat)3 }, 
    { .cmdname="addme_failed", .cmdproc=(void (*)(unsigned char *, signed int))AddMeFail, .cmdformat=(enum CmdFormat)6 }, 
    { .cmdname="addme_success", .cmdproc=(void (*)(unsigned char *, signed int))AddMeSuccess, .cmdformat=(enum CmdFormat)6 }, 
    { .cmdname="version", .cmdproc=(void (*)(unsigned char *, signed int))VersionCmd, .cmdformat=(enum CmdFormat)0 }, 
    { .cmdname="goodbye", .cmdproc=(void (*)(unsigned char *, signed int))GoodbyeCmd, .cmdformat=(enum CmdFormat)6 }, 
    { .cmdname="setup", .cmdproc=(void (*)(unsigned char *, signed int))SetupCmd, .cmdformat=(enum CmdFormat)0 }, 
    { .cmdname="failure", .cmdproc=(void (*)(unsigned char *, signed int))FailureCmd, .cmdformat=(enum CmdFormat)0 }, 
    { .cmdname="accountplayers", .cmdproc=(void (*)(unsigned char *, signed int))AccountPlayersCmd, .cmdformat=(enum CmdFormat)0 }, 
    { .cmdname="query", .cmdproc=(void (*)(unsigned char *, signed int))handle_query, .cmdformat=(enum CmdFormat)0 }, 
    { .cmdname="replyinfo", .cmdproc=ReplyInfoCmd, .cmdformat=(enum CmdFormat)0 }, 
    { .cmdname="ExtendedTextSet", .cmdproc=(void (*)(unsigned char *, signed int))SinkCmd, .cmdformat=(enum CmdFormat)6 }, 
    { .cmdname="ExtendedInfoSet", .cmdproc=(void (*)(unsigned char *, signed int))SinkCmd, .cmdformat=(enum CmdFormat)6 }, 
    { .cmdname="pickup", .cmdproc=PickupCmd, .cmdformat=(enum CmdFormat)2 } };
// commands$link1
// file p_cmd.c line 1149
static const char * const commands$link1[141l] = { "accuse", "afk", "apply", "applymode", "archs", "beg", "bleed", "blush", "body", "bounce", "bow", "bowmode", "brace", "build", "burp", "cackle", "cast", "chat", "chuckle", "clap", "cointoss", "cough", "cringe", "cry", "dance", "disarm", "dm", "dmhide", "drop", "dropall", "east", "examine", "explore", "fire", "fire_stop", "fix_me", "flip", "frown", "gasp", "get", "giggle", "glare", "grin", "groan", "growl", "gsay", "help", "hiccup", "hiscore", "hug", "inventory", "invoke", "killpets", "kiss", "laugh", "lick", "listen", "logs", "mapinfo", "maps", "mark", "me", "motd", "nod", "north", "northeast", "northwest", "orcknuckle", "output-count", "output-sync", "party", "peaceful", "petmode", "pickup", "players", "poke", "pout", "prepare", "printlos", "puke", "quests", "quit", "ready_skill", "rename", "reply", "resistances", "rotateshoottype", "run", "run_stop", "save", "say", "scream", "search", "search-items", "shake", "shiver", "shout", "showpets", "shrug", "shutdown", "sigh", "skills", "slap", "smile", "smirk", "snap", "sneeze", "snicker", "sniff", "snore", "sound", "south", "southeast", "southwest", "spit", "statistics", "stay", "strings", "strut", "sulk", "take", "tell", "thank", "think", "throw", "time", "title", "twiddle", "use_skill", "usekeys", "version", "wave", "weather", "west", "whereabouts", "whereami", "whistle", "who", "wimpy", "wink", "yawn" };
// completekeysym
// file keys.c line 128
static unsigned int completekeysym;
// config_button_cache
// file config.c line 90
struct _GtkWidget *config_button_cache;
// config_button_download
// file config.c line 90
struct _GtkWidget *config_button_download;
// config_button_echo
// file config.c line 87
struct _GtkWidget *config_button_echo;
// config_button_fasttcp
// file config.c line 88
struct _GtkWidget *config_button_fasttcp;
// config_button_fog
// file config.c line 91
struct _GtkWidget *config_button_fog;
// config_button_foodbeep
// file config.c line 89
struct _GtkWidget *config_button_foodbeep;
// config_button_grad_color
// file config.c line 88
struct _GtkWidget *config_button_grad_color;
// config_button_smoothing
// file config.c line 93
struct _GtkWidget *config_button_smoothing;
// config_button_sound
// file config.c line 90
struct _GtkWidget *config_button_sound;
// config_button_timestamp
// file config.c line 88
struct _GtkWidget *config_button_timestamp;
// config_combobox_displaymode
// file config.c line 93
struct _GtkWidget *config_combobox_displaymode;
// config_combobox_faceset
// file config.c line 94
struct _GtkWidget *config_combobox_faceset;
// config_combobox_layout
// file config.c line 95
struct _GtkWidget *config_combobox_layout;
// config_combobox_lighting
// file config.c line 94
struct _GtkWidget *config_combobox_lighting;
// config_combobox_theme
// file config.c line 95
struct _GtkWidget *config_combobox_theme;
// config_names
// file init.c line 29
const char * const config_names[32l] = { (const char *)(void *)0, "download_all_images", "echo_bindings", "fasttcpsend", "command_window", "cacheimages", "fog_of_war", "iconscale", "mapscale", "popups", "displaymode", "showicon", "tooltips", "sound", "splitinfo", "split", "show_grid", "lighting", "trim_info_window", "map_width", "map_height", "foodbeep", "darkness", "port", "grad_color_bars", "resistances", "smoothing", "nosplash", "auto_apply_container", "mapscroll", "sign_popups", "message_timestamping" };
// config_spinbutton_cwindow
// file config.c line 87
struct _GtkWidget *config_spinbutton_cwindow;
// config_spinbutton_iconscale
// file config.c line 91
struct _GtkWidget *config_spinbutton_iconscale;
// config_spinbutton_mapheight
// file config.c line 92
struct _GtkWidget *config_spinbutton_mapheight;
// config_spinbutton_mapscale
// file config.c line 91
struct _GtkWidget *config_spinbutton_mapscale;
// config_spinbutton_mapwidth
// file config.c line 92
struct _GtkWidget *config_spinbutton_mapwidth;
// config_window
// file config.c line 87
struct _GtkWidget *config_window;
// cpl
// file client.c line 69
struct Player_Struct cpl;
// create_account_window
// file account.c line 33
static struct _GtkWidget *create_account_window;
// create_char_pane
// file create_char.c line 73
struct Info_Pane create_char_pane[1l];
// create_character_window
// file create_char.c line 58
static struct _GtkWidget *create_character_window;
// crossfiretitle_xpm
// file ../../pixmaps/crossfiretitle.xpm line 2
static char *crossfiretitle_xpm[109l] = { "346 87 21 1", " \tc None", ".\tc #339966", "+\tc #00CC00", "@\tc #FF6666", "#\tc #666600", "$\tc #FF9900", "%\tc #CC0033", "&\tc #FF3300", "*\tc #000000", "=\tc #CC9933", "-\tc #FFFFFF", ";\tc #FFCC66", ">\tc #660000", ",\tc #333366", "'\tc #FFFF00", ")\tc #FFFF99", "!\tc #CCCC66", "~\tc #CCCCCC", "{\tc #999999", "]\tc #FFFF66", "^\tc #0099CC", "                                                                                 .                                                                                                                                                                                                                                                                        ", 
    "                                                            +++             .     .                                                                                                                                                                                                                                                                       ", 
    "                                                  ++++++++++@+               .     .                                                                                                                                                                                                                                                                      ", 
    "                           ++++++++++++++++++++++++++++++++@@+      +++++++++ .     .                                                                                                                                                                                                                                                                     ", 
    "                             ++@++++@+++@++++@++++@@@@@@@@@+@+ ++++++@+++@+@+  .#    ..                                                                                                                                                                                                                                                                   ", 
    "                               ++@@@@@@@+@@@@+@@@@@@+@@++@@@+@+@@@@@@@@@@@@@+   ..    #.                                                            $                                                                                                                                                                                                     ", 
    "                                 +++@@@@@@@@@@@@@@@@@@@@@@@@+@+@@+@++@+@++@@+    .#.   ..                                                        $  $                                                                                                                                                                                                     ", 
    "                                    ++@@@+++@+@+@++@+@++@@+@@+@+@@@@@@@@@@@@+     .%&&&.%&                                                       $  $                                                                                                                                                                               ** ***                ", 
    "                                      ++@@@@@@@@@@@@@@@@@@@@@@+@+@@+@+@++@@++     &&%%%#%%&                                                      $$ =$                                                                                                                                                       ***                    ** **-**              ", 
    "                                        +++@@@+++@++@@++@+@+@@+@+@@@@@@@@@@+       &&&%%#%#&                                                     =$  $$                                                                                                                                                     ***-* %%              **-* *-****             ", 
    "                                           ++@@@@@@@@@@@@@@@@@@+@+@@@+@++@@+       &&&&%%%%%&                                                     $$ =$$    *                                                                                                                                              ***---*;%              ***   *****             ", 
    "                                             +++@@@++@+@+@@+@+@@+@+@@@@@@@@+       &%&&&&%%%&                                                     =$$-=$$. .. **          ..                                                                                                                              ***-----*                 && &&                 ", 
    "                                                ++@@@@@@@@@@@@@@+@+@@+@+@@++    & &&%&&+++>%%&                                                     =$$-=$.#.#.*  **        ..,...........                                                                                                                  *-*-----*              * && && ***             ", 
    "                                                  ++@@@@++@++@+@@+@+@@@@@@+     &&&%>%&&+'+%>&                                                      =$..&.....,..*        ,...,.,.,.,.,.,....                                                                                                               *%*-----*   *         ***********         *   ", 
    "                                                   %+++@@@@@@@@@@@+@+@+@@+&  & &&>%%&%%&&+&&%%&                                                      #.&&#.#...,..**     ..,..*.*.*.*.*.*,.#.**                                                                                                             &))*-----*  **        ***********        **   ", 
    "                                                &  %&%%++@@@++@+@@+@+@@@@+%  &&%%%%%%&&&%&%&&%>&                                                    ........#...,..**  *.#..*.,..#..,.....*..  *                                                                                                           %));%*---*   ***        **---****        ***   ", 
    "                                            &   &&&&%&&&&++@@@@@@@@+@+@@+&%&&%%>%&%%%&&&&%&  &%%&                                               ...#.,.#.#.*.**..,.    *...,..,...,...,.,.,.*.       !!!!!!!!!~~                                                                                          #)#)%*-*-*     ****      *-*-*-***      ****    ", 
    "                                        &   &&&&%&%%>%%%%%%++@@@++@@+@++&&&%%%%&%%%%&&  &&%&  &%>&                                              *.,.......,.*..*...,   *  *....,*.*.*.*....,..,   !=#==#======#=#==!!~                             {=~                                                   %)))#  ***      *******   *-*-*-**    *******    ", 
    "                                 ~!==~  &&&&%&%>%>%&>%>&%&%%%++@@@@@@+@+%%%%%&%%%%%&&    &&%&  &%&                                              ...,.#   ..*  ,.*...*     ,.,.*...,..,.*,.*..*. !#======#==#=#==========!!              !         !===                                                  #)#)%             ********{======={,*********     ", 
    "                              !!======$&%&%%>%%&%%%%%%%%&%%#%%%+@@@+@@+&&%%&%%%&%&&&      &&%&  &                                               ,....    #**  .**.,.**     ...,.,..#.*....,.,..=============================!~       ~!==!~      !=====~                                               %)))#              *********{{{{{{{***********     ", 
    "                         ~~!!==========#%>%&%>%>%#&%&%&%&%&&%%%%%%%%%%%%%>%>%%%%&&&        &&%&                                                  .,.    .*    ..*...         ...*.*..,.* *..-*=======!;;;;;;!;!================!!!========!     !=======                                             {&%]!%               ,**************************     ", 
    "               !=========================#%>%%%%%&%#%%%%&%%%%&%&&&%&%%%&%%%&%%&%&&%&        &&&                                                  .     .*     ,.,.,.*        #.*.#..**.   .,-!===!;];];];];];;;];;;;;======================~  !===!;!!===~                                          {{{)%&              ,{{,*************&&**********   &&", 
    "              !===!==!==!=!=!!!=!;]]]!=!===%%%%%%&%&%%%%%&&%%#%%%%&%%&%&%&%&%&%&&>%%&&                                                             ,  .*     .*.*...**        #..#.*  *.  *.!==!];]]])])])])]])]))))]];];;!!!=!=!!==!==;!!==!!===;]])!!!==!                                        ,{,,{%               ,,{,,************&{&&&&&&&&&&&&&,&", 
    "             !={!!=!=!!!=!=!!!;]]]]);;!!=====&&%%&%&%&%%#%%%%%#%&&%&&&&%>%%&&%&&%%%%%>&&                                                           ..#.      .,*.#.# *        ...*.*   *.  #={;]])))];!];!];);;);];]))])]];];!=!=!!!!]]];!=!==!=;])])!!!=!=!~                                     {,,,,{{{            ,{,,,#,************&{{{{{{{{{{{{{{{&", 
    "            !!!!!!!!!!=!!;]]]]]])))]));!!!!!==%%%&&%%%&%&%&&%&&&%%%%%&&%&%#%&&&&&&%&%%%%&                                                             *     ...*....          ,.*,..**  * !!!];]));)]);)])])])])]!);])])]))])];]]]]]]]]))#=!!!!;]]))]))!!=!=!~                                   %.{,,{{,{,           {,{,,,,*********$**&{{{{{*****,{,{,&", 
    "           !!=]]]]]]]]]]]]]))))))])])]));!!=!!!=%&&#&%%#%%#&%>%%%%&%&%&&%%%%#&    &&&&&%%&&                                                                 ,**.#.#.*    *    .*...,*.  *!=!;])))]);))]))]))])])]);));)])]))])))])))))))!#!!!]]])))])]);;!!!=! ~                                %#%.,{{,,{,{,{       ,{,,,,,,#***********&{{{{*-----*{,{,&", 
    "          ;!!;])))))))))))))))])])))));))];;!=!=!=&&%#%>%&%%&%&%&%&%&%%&&#%%%&       &&&%%%&&&&                                                            ...*....**   **   ,..#..*     !!!;;))])))]))])))]))))))))])))))])))]))))))])]=#!!;]))))]))))))];;!!!~~ ~                             %)%%{.{{{,,{,,,{,   {,{,,,,{,{********$**&{{{*-------*{,{&", 
    "         !!!]])))))))!!!=!!;))))))])))))))];;;!!!!=&%&%%#%#%&&&%&%&%&&&%&%&#%%&         &&%%%%%&                                                           ,**.,.,.  *  .... ..,..*     !!!;]]))))]))))));)))])])]))))]);)))])))])]))))!##!!;!));)))]))]);!!!!!!                                &!)%% ,{,#,,,,,,#{{{.,#,,,,{,{*******$$$*&{{{*-**-**-*,{,&", 
    "         ;!;]]))))));=,***#;!)))))))))))))))]];;!;!=&>%&%%&&%&%&%&%&%&&&&&%%&%&           &%&&&%&                                                          ..,.....* ***,.#.,...#.*  ** ;!!;!)))))))))!)!)!)))))))))))))))))))))))))));!*{!!=##!!)))))))!=*#=!;~~~~ ~                            %&%    {{{,,#,,,{,{,#,,,{,{,  *****$***$&{{{*-**-**-*{,{&", 
    "        !!!]))-)))))!*#!!!##!;))))))))))))))))]];;!;=%&%%%%%>&&%&%&&&&&&%&&%&%>&           &&  &%&                                                        .***.#.#...........,....*...-~!;!];))))))!;!!#===!!!))))))))))))))))))))))))]##;!;!!##!]))))!;#,#!;!~~--~                                      ,{,,{,#,#,,{,,,,{,{   *$$$$*****&{{{*-------*,{,&", 
    "       !;;])))))))))=#;;!;!=#{!))))))))))))-))-)]]];!=%&&%#%%&&&&&&&&%%&&%&&%%%&           &&   &&                                                       ,...*...**,.,*,.,.,..,.,.,.,.*,!;!;!)))))]=#****,****=!;!)))))))))))))))))));#*=!;!!;!=#{!)))],*=;!;~~~~-~~ ~                                     {{{,,{,#,{#,{,,{,   ******&&&*&{{{{**-*-**,{,{&", 
    "      );!]))-)))))))##!;!;!;=##])))))))-)))))))))!=!;;=%%&%%&%&&&&&%%%%%&&%&&&%>&&          &&   &                                        !       ==      .#.*.#*.......*..!...........#];!!!)))!!,*#=!;!;!;;!#*,#!!;)))))-)))-))))!;#*{]!!~!;!;=#!))!#*!!;!!~~~~~-~  ~                                     {{{{{,#,{,,{,{     *$*$*&***&&{{{{{*---*{,{,{&", 
    "      ;];]))-)-)-))],=];]!]!;!##!)))-))))-)-)-);!,#];!&%&#%&;=&  &&&%&>%%&=;-&&&%%&&         &&       );!                              ~);!;!    ==.=    .***..*.#.,*,...!;!;!..,.,.,...!;;!{));=*#!!;!]!;])))]!=#**,=!!;!))))))));!*,=!;!~{~!];]=#!;#,!!]!!{!{~~~~~~ ;!             ;                        ,{{!!;{{,{,      *$$$*&***&&{{{{{*****{{{{,&", 
    "     !]!]))-)))))))=#;;!!~!;];!=#!))))-)))))))!=*#!;;~%%%%=!;!$   &&&%%%%&]!]  &&&%%&&         &     !;];;!)                         )]!;];]!;)    ,.#   .#..,*.......!;]!]!];!{.....,..!]!;=!!#*=!;]!];]))))-!=]!;!#,**##={;!;!;=,*#!;]{{{{~{!;!;=##*!]!;~{{!{!~~~-~]!])           !;]                        ;!];]!;{        *****&&*&&*&.{.{.*{*{{{{{& ", 
    "     !];])-))-)-)))##!];!!{!!]!;=,#))))-)-)))!,,=;]!!~~&%@;];]!)   &&%&%=;!;!;   &&&%%&&&&        );]!;]!]!;!;                     ;];;];;];]!;! ==...== .....*,.,.{!!;];!];!];]!{...,.#.!];!##*!]!];!]))))--],!;]!]!];!=#,***#***#!!;]!{{{{{{~!)]!!=!!;!!{{{{!{~~~!];!;])         ;];;;                    )!;]!;!];];        *$*$**&*&**&{.{.{.{{{{{{{& ", 
    "    ;]!)])-)))))-);,!;];~{~{!;;];!##]))))))!=*#=];!!{~~~;];]!];!)   &&%&;]]]]!]    &&&%%%>&&    )!;!];]];];]!]!;)                ;!];];]]))]];];];!!.=!..#*,...*..!]];];]]))]]!];]!!=.....!!!!=!];]!]])))--))!,]!;]!]!];!;;];!!=;;;];]{.{{{{{!!;];;])]];]!{{!{{!~~;]!]];];)       !]];];]                 )!;]!];]]];]!;)      *$$$$**&***&.{.-{.{.{-,{,& ", 
    "    !];))--)-)-)-)]#!;];{{{!!]])))]{#!)-))!#*#!;];{{{!!;]!])))];!)   &@];)))]]!;     &&%&&%%@)];]]]!])))))]];]!]!;)            ]!];];]))))-))];];];];]...*.***..!];!]!]])))-)])]!];]!]]....!;];]!;);;))---)))!#]!]!;;]!]];];];];];];]{{{{{{{{];]!]]))))];]!{{!{!!;];])))];;)     ];)))]];;               ;]];]!))))))]]]!;     ***********&.{--.{.{.--,{& ", 
    "   ];]]])-))-))))){#]!]!{{!!;])))-)))-));!*#!]];!{{{{];];)))-)]];]!  !]!]))-!];]!)    &&  &$;];];!]))))--)))]];];];)         )!;]!])))))---))))]];];];]...*..,!];];]]))))----))])]!];]!]{...!;];);]!)))-))-))!#];]!{{!!;]])];]!];]!;{,{{{{{!]!];))))--);]];!{{!;];])))-)]]!])  !;!]))-!]];]~           ;];];)])))---))];]];)   *$*$**&&&**&{.{{-,{,-{.{.& ", 
    "   ;];)))-)-)--)-)#=;];!{{];];]--)-)--)]#*#!]!]{{{{{;];])))---)]];])];])))--)!);];!   &&  )]!]!]]))))--)-)--)))])]!]!       );]];))))---)-)-)-)))))]!];]!.#--!;];]))))----))-)-))))]!];]]....!;-);]]))--)-)-))#)];;!;];];)))))]!]!{.,{,{.{{];]]))))--)-!!]]]]{);];))))--);]]!);]])))--)!)]!]!         )];]]))))----)-))]);];!  *$$$*&***&*&{.{.{-.-{.{.{& ", 
    "  )!]!))-)-)))-)))#{];){{{;])]!))-)-)]{**{]];!{,,.{;]]))))--)-)!;)];]])))--)))]]]];]~  &&);];)))))----)-))-)--)))]);])~    )];)))))---)-)-)-)-)-))))))]]!---)];])))----)))-))-)-))))))))]]{....*;]!)]-))-))-))=];])]]!);))--)])];]{{{{{{{!])))))---))-))!];;];]!))))--)-)!!]];];)))--)-];]];];       ;;]))))----)))-)--)])]]])~*****&***&**&{{{{{-,{,{,&  ", 
    "  ])]]])-)-)-))-))#{]!]{{{!;];=!))));=*#!];]!{,{{{]!])))---)))-){];];]))-)-)-)))])]]!   @]])))))----)-))-)-)))--))]];]) ~ )];])))--)))-))))))-))-)-))));];~)!]))))--))-)-)-)-)))-)--))));];.#,.{];]))--))-)-)-!!;];;];]]))-)--!]);]{{{{{{];)))----)-))-)!{])!]])))----))-)!)];]]))--)-)-)])]!]! ~  ~]]!)))----)))-)))))-)])];];#****&&*&&**&{{{{-{-,{,{&  ", 
    "  !]!);-)))))-))))*!];]{{{{!]!!#{;]!,*=;]!!{,{,.{!;)))--)))-)))))!]))))--))))-)))])];]~);!))))--)))))))-))))-)))-))])!]!-);])))--)!#=)))-)-)))-)))---){=]!];])))--)!#=)))))))-)-))))--){=];]..#];]);))))-))))-)!)]];)])))--))))!]!]!{{{!];];!-))))))-))))#;];)))--))))))))!!]))))-)))))-))))]];]~  !];)))-);)))-))-)-)))-))]]!]!,****&&&***&{{--{,{--.{&  ", 
    "  ];])!-))-)))-))]#;];;{{{{{!!]=#*#*#!!];!>{.{,{;];]!)))-))))-)))=))))-)))-)))))-))];]!;]]))-)-))-))-))))-)))-)))-));];])];]))-)))#**#]))))-)))-))))]!*{]!]!]))-)))#**#]))-))))))-)))]!*{]!!.,.!];]!)-))))-))))))))))))--))-)))!!];;!{{{!];!##)))-)))-))]#!]!]!)))-))-)-)))!))))--))-)))-))));]];~];])))-!*,!))))))))-))))-))]];!#**********&{{-,{,-{.&   ", 
    " !!;!])))))))))))!#;!]!,{{{{{!;!!!{!!;]!=>>>>{{,{!;!=#!)))))))))))))--)))))))-))))){!;];!])))!;])))))))))))))))))))));];!];))-))))={!#,=))))))))))))!,#;;!];)))-)))={!#,=])))))))))))!##;!;.*#.;!]]!))))))))))))!]))---)))))))-;#;];!{{{{!;]!=!)))))))))!#;!;!=#!)))))))))))))--))))))))))-)){!;]!;]))-)]###,#;)))))))))-))))]];]!#*********&{{{{{{{{{&   ", 
    " !]!;!)-)))))))))!#!;!!,,{{{{~];!;!]!;!~{{>>#,,+*{;!!=#))))))))))-)-))))))))))))]!#*!;];]]))!**,=!;!)))))))))))))))))!!];!]])-))))!!;!=*#!;)))))))))!,!;];!]]))))))!!;;=,#!!)))))))))!*!;]!,,.#];!;!)))))))))))),*,=;))))))))))]#;!;]{~{~!;;!;!)))))))))=#]!]!!=#)))))))))))-)))))))))))))]!#*!!;!]]))-)]*=;!#,!))))))))))))))!!;!!#********&&{{{{{{{&&   ", 
    " ;!;]!)))))))))))==!]!!.{{{{~~~!;];!;!~~{~{{,,+++#!;!;!!))))))))))];!;!))))))))!;#*!!;!!]));*#=#,*,#=!)))))))))))))))){;!]]))))))))!;];!#*,=!!;!)));##;!!;]]))))))))!];!!#*,=!!)!)));##;!;#,##.!;!;!))))))))))))!!!##!))))))))!!#!;!!~{~~!!];!]))))))))!{#;!;!;!!!))))))))))];!;!))))))))!;#*{;!]!]))))!=#!;!!=*!])))))))))))!!=!;!!,*****,,,&{{{{{{{&    ", 
    " ;!!]!)))))))))))!#!;!!,{{{{{~~~!;!!!~~~~{~{{,#,#,!!;!;!)))))))));=#,#,#=;!)))]!#,!;!!;]]))=,!;!;!=#**#!!!))))))))))))!!;!!)))))))))];];!!=,*,#=!!)]#=!;!!;!)))))))));]]!!!=,**#=!!);#=!!!#~~,.;!!!{)))))))))))))=;!##!!))))));##];!!~{~~;!;!!!))))))));==!;];!!;!)))))))));{#,#*#=;!)))]!#,!!;!!]])-))]#=!!;!;=#{!))))))))!!#*#;!!,,***,#,#,&&,{,{,&&    ", 
    "~!;!;!))))))))));{=!!;{{,{{{!~~~-~-~~~~~~{~{~{~{~~!!!;!;))))))))!#*,####,*=])!;#*=!!;!!)]-;#=!!!;!;!!=#**=;!))))))))));{!;!)))))))))))]];;!;!=#**#=!*!!;!;!!)))))))))))]];;!;!=#**#=!,!;!;{~~#,!;!!=))))))))))))){!!!##!])))]!=*=!!!~{~~~!!!;!;))))))))]#=!!!!;!!;))))))))!#**####*,=])!;#*=;!!;;])))));#=;!!;!!=#=])))))!!=*,=!!!,,,,,{{{,{,,&&{,{&&     ", 
    "-!!!;!))])););))]{#!!!!{.{{{~~~~~-~--~~~!!!!!!~~~~!;!!!!));));))]#=!!;!!!=#=];=,=;!!;!];))!#=!;!!!!;!!!!=,*#!;])););)))!!!=)])]))]))))))]]];;!;!!=*##!!!!!;=;);))]));))))]]];;!;!!=*##!!!!{{~,##!;!==;!))]));)]));=;!!=#!;);!=*#!;!{{~{~~!;!!!!);))])));#=!;!!;!!!)))]);))]#=!!;!!!=#=];=,=!!!!!];))]))],!!;!!!!!=#!)])]]!**#!!;=,,,,,,,{,,,,,,&&,&&      ", 
    "-!;!!!)]))]))););!#!;!!.{{{{~~~-~-~-~~~!!;!!!!!~~~!!!;!;)));)););#=!!!!;!;]]!!*=!!!!!!];));#=!!!)!!!!;!!!!=#,=;]))));)]!#;=!)))]))])])])))]]]]];!!!!=;!!!!!=!));))]))])])))]]]]];!!!!=!;{{{{#,#*!!!=#;)]))])))])))=!!!!=!;!=,*=!!!{{{~{~~!!!;!;))]))]))!#=!!!!!!;!)])!))])!==;!!!!!;]]!!*#!;!!!!];)))])!#!!!!;!;!]]]);];#*#=!!!=,#,,,,,,{,#,#,#,&&&       ", 
    "-=!!!!));););))])=#!!!!,.{{{~~~~~--~-!;!!!!;!!=!~-!!!!!!);));)]))#=;!!!!]]))],#!!!!!!!]!));#;!!!~~~!!!=!@!!!=#*!!!])!));#!==!;);)]))]))]))))))]]]];!!!!=;!!==];)]))]!])))))))))]]]]!;!!!!#{#,,#~~!!!==!)])])]);););=;!;==!#*#=!!!{{{{~{~~!!!!!!;))])])]!#!!!;!!!!!))])])]))#=!!!$!]]))]##!!!!!!;]))])]);#;!!!!!;]])))!=**=!!;!=**,,,,,,-,.{#{{,#{         ", 
    "~!!=!=)])]);)!);)!#!!!={{{{~~~~-----!!=!!!!!!!!!!~!=!=!!)]!]);)!]#=!=!!;]));=,=!!!!!!;!]);]==!=!!~~~~!{!!!!!!==,=;);)])]=!!=!!)])])]);););)])))))]];;!!!!=!=#!!););)])!];])]);))))]];;!!!!#,##*~~!=!==!;)]););)])]!=!=!=#*#=!!!!{{{{{{~{~!!!!!;)])])]!]!#!!!!!!!!;]););)]);#=!=!!;]));=,=!!!!!!;!)])););==!=!;]]]));!#*#=!!=!#,,***,,,,~,{,#,,,,{         ", 
    " !!!==])])]);]);]!#=!!!,{{{{~~~~~--~=!!;]]]];;!!!!;!!!=!);])])])]#=!!!!];)]!##!!!{!!!;!;);){=!!=!~~{~~!{{!!!!!!=#=!;);]!#===#!;);)]!)];)];);]);];))]];;!!!!!=#!;);]!])])])]!)!);];))]];;!!!{*{~~~~!!!==;)];)]!]!)])!=!!!!!=!=!!{{{{{{{{~~!!!=!!)!)])])]!#!!=!!=!!!)!);])]]!#=!!=!];])!##!!={!=!;!)]!];);==!!;]])))!=*#==!!!{#**,,,*,,,~-,{,,,,,,{         ", 
    " !==!=;];];])];);!#=!!!{,{{~~~~---!!!;;]])))];;!=!!!=!!;]!];];];!#==!=;]])!=,=!=!{!=!!!;];];=!!=!!~~{~{~!{{!!=!==#!;];)!#=!==#=!];;);])];);];])])];)])!;!!====#=!];]!]!;];);];])]!];)]]!;!=!{{~~~~!=!!=!;])];])];!);!===!!=!=!{{{{***~~!~!=!!!!];];]!])!#=!=!!!!!!];]!];])!#==!!;]])!=,==!!!!!!!;;););])!=;]]])]!=**#=!!=!{,,,*,**#,#,~~~,{,#{,{{         ", 
    " !!!==!!);];];];];#!!=!{{{{{~~~~-~=!!;]]);];]]!=!==!=!=!););])]]!#=!=!;;];!=#!!!{{!!==!)];);!=!==!{~~~{~{~{~{!=!==#!];]!#=====#=!!!];];!]!]!];];]!]!;]]!!!!!==###!!)];];]!]!];];];];!);]!!!=={~~~~~=====!]!]!]!];]!]!=!=!!!={{{{{*****{~~!!!==!]!]!);];!#=!!=!=!=!)];])];]!#=!=!;;];;=#!=!{{!=!=!];];];;!=;]]);=#*#=!==!{{{,,,**,,,,,~~~-,{,,,,,{         ", 
    " !====!;;!];;!]!;!=====.{{{~~~~~-=!==!;];];!];]==!=!==!!;];;]!;;!====!!];]!##==={{==!=!!]!];]!=!=!=!!{~!~~{~{~{====!;!]!===!===##=!!;;];;];;!]!;];;]!;];=!==!=!=##==!!;];;];!];!];;]]!];]=!=!=!~~~~!====!;;;];!]!];]!====={{{{{{{*{{**~~~!===!!;;;]!;];!#==!====!!;];!];!]!#===!!];]!##==={!=!=!!;];;]!];]]);!=*,#===!{{{{***,*,,,,,{~~--.,###,#.         ", 
    "  !====];!]!];!];!==!=={{{{{~~~~-~===##!!;]!;!]!=======!;];!]!]!;#====!]!;!#==!=!{!===!;;;!;!]=!=!==={{{~~~~~~{!====!;;!#=======##*#=!!!;];];;];;];!];!]!========##*#=!!!;];;];;!]!;;!]!;!=====~~~~!!==#!!];!];;!;!;;==!=={{{{{{{*{{**~~~!!===!!]!;]!;;!#====!===!;!];!];;!#=!==!];;!#==!={{====!;!]!;]!;];!=#*#=====!{{{{*,,*,,,,,#~~~~~ {{,,***         ", 
    "  {===#!;;!;!;]!;;=#===={{{~~~~---!===#!!;!;];!!#======!;!;;;!;;!#===!;;!]!======{=====!]!];!;;!=======!!{~~~~~=====;!;!#==========#*,#!!!;;!;;!;;]!;!;;;===========#**#!=!;!;];!;!]!;;];!=====!~~~~=====;;!;!]!];];!=#===={{{{{{{***~~~~!====!;;];!]!]=#========!];!;]!;]!#===!!;!];======!=====;!;;!;;];!=**=====!{{{{{*,{,*,,,#,~~~~   ,.#*~~~*        ", 
    "  !=====;!;]!;!;];!#====.{{{~~~-~--====#!;!;!;;=#======!]!]!];];!#====!;;!;============;!;!;]!;;;!!========{!!~=====]!;!#============#**#==!!]!]!;!;]!]!;=============##*#==!;!;];!;]!;!];=====!~~~~=====;!];!;;!;!];!#====,{{{***^^^****!====!;;!;;;!;!#========!;];!;!;;!##===!!;!;============;!]!]!;!;;;========={!{!#={#*,#,,,~~~~~  {{,*!{~*        ", 
    "   ====#!;!;!;]!;;!#===={{{~~~~~---!====!;!]!]!!#======!;!;!;!;;!#=====!;;!;=!;;========;];!;!]!;;;=!===============;!!=#====;;;!=======##,#==!;!;]!;!;!]!#===;;;!!======#,*#==!!;;!;!;!;;!#====~~~-!====!;!;!]!;;;!;!#===={{**^^^^^**{{,#====!;];!]!;!!#========!;;!;]!;!!#=====;!;!;=!!!!=====#!!;;!;]!;];!!==============##,,,,~~~ ~    ,,*~~!*        ", 
    "   !===#=!!;!;!;!;!====={{{{~~~-~--!====!;!;;!;=#======!!;;!;!!;!##====!;!;];!;;!=======!;];!;!;!;]!;!==============;;=##====!];];;!;!====##,*#=!;!;;!;!;=#===!];;;;!;=====##,##!!!;!;];!;!#====~~~~!====!!;!;!;];!;!!#====**^**,^^^*{{{,#====!!;;!;!;;!#========!;!;!;!;;!##====!;!;];;;;=======#!;!;!;!;!;;];!============###,,,~ ~ ~ ~  {{,*{~*        ", 
    "    ====#!;!;!;!;!;=#===={{{~~~~---!=====;!;!;!##======!;!;!;;!;!#===##!!;!;!]]!#=====#=!;!;!;!;!;!;;;;!============]!=,======!;];];;;;!=====##*=!!;!;!;!=#====!];];];;!!=====##,#!;!;!;!!=#===={~~~!=====]!;;!;!;!;!=#====,**{~**^**.,,{#====!;!;!;!;!!#========!;!;!;!;!!#===##!!;!;!]]!=#=====#=!;!;!;!;!!!;;!!===========###,~~ ~      ,,,***         ", 
    "    ~===##!!;!;!;!;!#==#={{{~~~~-~-!#===!];!;!!*#======!;!]!;!;!!##===##=!;!;!!=##=====#=!;!;!;!;!;!!;;];!$!=======!;!##=====!;!!!;!!;];;!=====##=!!;!;!==#==!=;!!!!;!;];!;======#=!;!;!;==#==={{~=======!;!!;!;!;!;!=#===#*{{{~*^^^*{{.{#=====];!;!;!;!=#========];!;!;!;!##===##=!!;!;==##======#!!;!;!;!;;!;!;;;!;!;!;!$!==#=#-~ ~ ~    {#,#{{         ", 
    "     !=#=#=!!;!;!;!;!======{{!~-!~!=====;;!!;=##===#===!;!;!!;!;!##=$==###=====##=====###=!;!;!;!;!;!!;!];];;!$!=!!;!=*#=====!;!;!;!;!!;];;!======!;!;!;!##===!;!;;!;!;!;;]!!======!;!;!;!##=#={{====#===;!;!;!;!;!;=##===#{{{{~**^*^*,{*!====!;!;!;!;!!=#==#====!;!;!;!;!!#===$=###=====###=={===##!!;!;!;!!;!;!];;;;;;;;;!===#{!~        ,{,,,{         ", 
    "      !==##=!!;!!;!!;==$#=========#$===!]!;!!=*#=======!!;!;!!;!!##=====##*#,**##=={{===##!!;!!;!!;!;!!;!!!!];];;;!;=###$#===;]!;!;!;!;!;!;;!=====;!;!!!=##===;]!!!;!!;!!!;;;!=====;!;!!==##==={==#=$===!]!;!;!!;!!!!###==,,{{{~*^^^^*{,*!#=#=!;!!;!!;!;=#$==#=#=!;!;!!;!;!##=#===##,##**##=={{!===##!!;!!;!;!!;!;!!!;!]!!=###=#!~ ~ ~     {#,#{,         ", 
    "       {==###!!;!;!;!;====#===#=#$====!;;!;!=###=#=#$#==;!!;!;!;!##==##===#####===!{~{===##!!;!;!;!;!;!;!;;!!!;!;];!###=====!!;!!;!!;!!;!;!;;;!=;!]!!;==*#===!;!;;!;!;!;!;!!;!;!=;!]!!;!=*#==#{#==#===!;;;!!;!;!!;!=##====,{{{{~~****-**-!=====!;!;!;!;!=#=#======!!;!;!!;!##=#=#===####===={{!~{=####!!;!;!!;!;!;!;!;!!==*##==#~~         .,#,#{         ", 
    "        !==###!!!;!;!;;!============!;;];!!=##==={=====!];!]!;!;!##===#=========={{~{~!==###=!;!]!;];!;!;!;;;!;!!==#,#=====!!;!!;!;]!;;!]!;]!;]!;;;!!=###===!!;!!!]!;];!;!;!;!;]!;];!==#*##=={====!;;;;]!];!]!;]!;!=,#===,,,{{{~******---!====!]!;];!;!;;#=======!]!;];;!;!##===#=========={{{~{!{==###=!!];!]!;!;!]!;!=#*##=={,~~~ ~ ~    ,{,,{.         ", 
    "         !===##=!!;]!;!]!;!=!====;;;;]]!!!=*#==={{{====!!;;!;]!;!#===={,========{{****~{===##==!;!;;];]!]!]!;!!=##*##========##==!=!;];!;!;;;!;]!!==#**#======##===!!;;];]!];];!;!!==#*,#===,=====;];]];!;!;!;!;]!=##===#,{{{{{~******---!====!;;!;]!];!!#=======!;;!;!]!;!====={,========{{{!~~~~{===##=!!;!;;];]!;;!!#*#===#,~~~-~       {#,#,{         ", 
    "          !===###=!!;];;;;];;;;;];;]];;!=#,#==={{{=====!;];]!;!]!=#===#*{======*****>***{===##*==!!;!;!;;!;!==#**##===!{{==##***,*,==!;!];];];!==#**##======###**,*,==!;!;;!;;!;!=#**##====,{,===##=!!!]!];]!];!!!###=={,,,,{{{***~-***--====!;];]!;;!;;!#=======!]!];!];!;=#==={.{======{{{{{{{!~~!===###=!;];;!;!]!=#*====#,,~~~~-~ ~    {#,#{.         ", 
    "        ~  !====#*#==!!!!];]]])]]]]!!!==**#==={{{{====!];]!;];];;!#===#*****************~!====##,#==!!];]!==,*#======!~!{!========#*,#=!!;]!!==#*##======{=========#*,#=!;];]!==**##======{,{{{===###=!!;!;];;!!#*#===#,,,{{{{~***-~***-!===!;];!;]!];];]=#=====!;];!];!];;!#===={{{{{!{{{!{~~!~~~~~!====#*#=!!];]!;=#*====#,,,~~~~-~      {{,#,{         ", 
    "            !=====#*,###==!=!=!=!==##,**#===={~~{{=====!==!======!#====************~***~~~!======#*,##=!==**#======={{~{~!!!=========#*#!!;;=**#========,,{{==========###!!;!=,*#========.{{,{{{====#*##=!=====#*#==={,,,,,{{{{**~~  ***!====!!=!===!===!=#======!=!====!==!#===={{{{{{~!{!{!{~{~~~~~!=====#*##!!!!=##====,,,,,,~~~~-~ ~   .{,{,,         ", 
    "          ~ ~!=!======#,***,#,*#*****#=====!!~{{{{{!==#,*********,#=!{*************~~~~~~~~~!==!====##*##,#====!=!=!{{!{!{{!!!=!=!=====##==#*#====!==!{.{,{{!=!==!======##==#*#===!=!=!{,{,{,{{{{=!====#******,#===!.,,,,{{{{!***-~  *** !===#************#=!===#***********#===.{{{{{{~!~~~~~!~~~~~~~!!===!=##**##*#====*,,*,,,,~-~-~     ,,,,{{         ", 
    "              ~!!=!========#=####=!=!==!=!=~~~{{!{{{!==!=!!=!=!===!!=**************~~~~~-~~~~!!=!!!====##====!=!!{{{{{{~{~!{!{!!=!=!!!===##*#!=!!!={{{{{,{.{{{{!{!!!!!!===##*#=!=!!={{{{.{.{{{{{{~!=!====!=!===!!!={,,,,,,{{{{**~~ ~  **  !=!===!!!!!=!=!=!=!{=!!=!!=!==!===!=!{{{{{{~{~~!{~~~~~~~~~-~~~!!!=!====##====#*,**,*,,,~~~-~ ~  {#,#{,,         ", 
    "             ~~~!=!!!!!!=!=!=!=!!==!=!==!!~~{~~{{{{{!=!=!!=!=!!!!=!!*****{{!~~******~~~~-~-~ ~~!=!!!!!=!==!=!{{{{{{{{~{{~~~~~~~~~~!{!!!!=====!=!!{{{{{{{{{{{{{{{{~{!!!!!!====!!=!={{{{{{{{{{{{{{{~!!!!!!!=!=!=!==!{{,.{.{{{{{~**~     ***  !=!!!!==!=!==!!=!,{{!!=!!!=!=!=!=!=.{{{{{{~~~~~~~~~~~~~~-~~~~~!!!!!!!=!=!!!#,***,*,,#,~~~-~    ,,,,#,,{        ", 
    "               ~~~!!=!!=!=!=!=!=!!=!=!!!~~~~!~{~{~{{~{!!=!=!=!!!!!!{{***{{{{~~~*****~-~~~-~  ~~~~{!!=!=!!!!{{{{{{{{{{{~{!~{~~~~~~~~~~!=!=!=!=!{{.{.{{{{.{{{{{{~{~{~{!{!!!=!=!=!!{{.{.{{{{{{{{{{!{~~~!!=!!!!!=!=!!{{{{,{{,{{{{~**~~ ~   **   !!=!!!!!=!=!=!={{{{{!!=!=!=!!!=!={{{{{{{{{~~~~~~~~~~-~-~    ~~~!!!!!!!!!!#**,,,,,,,,~~~~~ ~   {,,,,,{,,       ", 
    "              ~ ~~~~~{!{!!!!!!!!!!!!!!~~~~~{~{{~{~!~~~!!!!!!!=!!!!{{{**{{~~~~~~**~ **-~  ~ ~ ~-~~~~~{!=!=!{{{{{{{{{{{{~{~~~~~~~~~~~~~~~!!=!!!{{{{{{{{{{{{{{{~{~!~~~~~~~{!=!=!={{{{{{{{{{{{{{{~~~~~~~~~~!!=!!!!!{{{{{,{{{{{{~~***       **    !=!=!=!!!!=!!{{{{{{{=!=!!=!=!=!{{{{{{{~~~~~~~-~~-~ ~ ~ ~  ~-~~~~{!!!!!=#*,,,,,,,{~{~~~-~     ,{,{,,,#{       ", 
    "                 ~~~~~~{~{{{{{{{!~{~~~~~~~~~~~~!{~~~~~~~~~~~~~~~{{{{**{{{{{~~~~**~ ***-~      ~-~~~~~~{{{{{{{{{{{{{{{{{~{~~~~~-~-~~~~~~!{!!!{{{{{{{{{{{{{{{~{~~~~~~~~~~~~{!=!{{{{{{{{{{{{{{~{~{~~~~~   ~-~~~~~~{{{{{{{{{{{{{~~~~~               ~-~~~~~{{{{{{{{{{~~~~~~~{~{{{{{{{{{~{~~~-~-~ ~  ~       ~ ~~~~~~{!{,#,,,,{{{{{~~~~~-~ ~     ,{{{{{{       ", 
    "              ~ ~ ~~~~~~~{~{!{!{!~~~~~~~~~~~!~~~~~~~~~~-~-~~~~~{~{{{***{~~~~~  *** ~***    ~ ~ ~ ~~~~!~{~{{{{{{{{{{~{~~~~~~~-~-~-~-~~~~~~{!{{{{{{{{{{{~{~~{~~~~~~~~~~~~~~~~!{{{{{{{{{{{{!{~~~~~~~~ ~ ~  ~-~~~~~{~{{{{{{{{~~~~~  ~                ~-~~~~{~{{{{{{~~!~~~~~~~{~{{{{{{~!~~~~ ~ ~  ~    ~        ~~~~~~~{{{{{{{{{{!{~~~~~-~                     ", 
    "                    ~~~~~~~~!~~~~!{~~~~~~~~~~~~~~~~~~~-~ ~  ~~~~~~~~{~{~~~~~~~ ~                   ~~~~~~{~{{{{{~{~{~{~~~~ ~~ ~ ~ ~ ~~~~~~~~{~{{{{{{~{~{!~~~~~~~~~~~~~~~~~~~~!{!{{{{{~{~{~{~~~~~ ~ ~  ~  ~-~~~~~~{~{{{~{~{~~~~~  ~               ~-~~~~~{~{{~{~!{~~~~~~~~~~~{~{~{~~~~~~ ~  ~   ~        ~  ~ ~~~~~~~~{~{{!{!{!~~~~ ~  ~                   ", 
    "                ~ ~ ~-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-~-~    ~ ~~~~~!~~~~~~~~-~   ~                ~ ~~~~~~~~{~~~{~{~~~~~~~~ ~    ~   ~ ~~~~~~~~~~!~!~~!~~~~~~~-~    ~ ~~~~~~~~~~~~~~~{~~~~~~~~~ ~ ~   ~    ~-~~~~{~~!~{~~~~~~  ~                ~  ~ ~~~~~{~~{~~~~~~~~~~~~~~~~!~~~~~~~-~                    ~ ~~~~~~{~~{~{~!~~~~~~~ ~                      ", 
    "                     ~ ~~~~~~~~~~~~~~~~~~~~~~~~~ ~ ~ ~   ~    ~~~~~~~~~~~~~~ ~   ~                   ~~~~~~~~~~~~~~~~~~-~~ ~ ~   ~  ~ ~ ~~~~~~~~~~~~~~~~~~~-~-~ ~  ~   ~-~~~~~~~~{~~~~~~~~~~-~ ~ ~        ~--~~~~~~~!~~~~~~-~  ~                     ~~~~~~~~~~~~~~~~-~~~~~~~~~~~~~~~-~                        ~~~~~~~~~~~~~~~~~ ~  ~                     ", 
    "                    ~   ~-~~~~~~~~~~~~~~~~~-~ ~  ~ ~   ~     ~~ ~~~~~~~~                        ~ ~  ~ ~~~~~~~~~~~~~~ ~-~             ~ ~-~~~~~~~~~~~~~~-~-~ ~       ~  ~  ~~~~~~~~~~~~~~-~ ~          ~   ~-~ ~~~~~~~~~~-~-~                    ~ ~ ~~~~~~~~~~~~ ~~-~ ~ ~~~~~~~~~-~ ~                       ~   ~~~~~~~~~~~~~-~                          ", 
    "                         ~--~-~-~  ~  ~~~ ~-~ ~ ~   ~         ~ ~-~~~~ ~~~~                        ~      ~-~~~~~~~ ~  ~ ~ ~       ~     ~ ~-~~~~~~~~~~ ~ ~             ~ ~  ~ ~~~~~~~~~ ~                  ~  ~ ~~~~~~-~~ ~  ~                        ~-~~~~~~ ~ ~-~  ~  ~ ~~~~-~-~ ~                             ~ ~~~~~~-~-~ ~                         ", 
    "                          ~~ ~ ~ ~ ~ ~  ~  ~  ~   ~        ~     ~   ~ ~                             ~ ~ ~ ~ ~    ~ ~                       ~         ~              ~      ~   ~ ~    ~                     ~ ~ ~ ~   ~                            ~ ~ ~     ~ ~  ~    ~ ~ ~ ~ ~ ~                              ~ ~ ~ ~   ~ ~                            ", 
    "                                      ~        ~                   ~ ~  ~ ~                                ~  ~~                              ~  ~~ ~    ~                         ~ ~      ~                    ~       ~ ~                             ~ ~~   ~    ~              ~                                ~ ~  ~   ~                           ", 
    "                            ~       ~                                                                                                                                        ~                                ~       ~                                       ~         ~    ~ ~                                  ~                                       ", 
    "                                                                                                                                                  ~                                    ~                                                                                                                               ~                                  " };
// csocket
// file client.c line 70
struct ClientSocket csocket;
// csocket_fd
// file main.c line 92
signed int csocket_fd = 0;
// cur_history_position
// file keys.c line 97
static signed int cur_history_position = 0;
// cweights
// file opengl.c line 375
static signed int cweights[8l] = { 0, 2, 0, 4, 0, 8, 0, 1 };
// dark
// file map.c line 61
static struct _GdkDrawable *dark;
// dark1
// file map.c line 60
static struct _GdkDrawable *dark1;
// dark2
// file map.c line 60
static struct _GdkDrawable *dark2;
// dark3
// file map.c line 60
static struct _GdkDrawable *dark3;
// data_cp
// file png.c line 49
static unsigned char *data_cp;
// data_len
// file png.c line 50
static signed int data_len;
// data_start
// file png.c line 50
static signed int data_start;
// def_keys
// file ../../common/def-keys.h line 2
const char * const def_keys[70l] = { "\n", "quotedbl 1 AE say \n", "Return 1 AE chat \n", "\n", "comma 1 A take\n", "period 1 N stay fire\n", "question 1 A help\n", "\n", "a 1 N apply\n", "d 1 N disarm\n", "e 1 NR examine\n", "s 1 F brace\n", "s 1 N search\n", "t 1 N ready_skill throwing\n", "\n", "b 1 N southwest\n", "h 1 N west\n", "j 1 N south\n", "k 1 N north\n", "l 1 N east\n", "n 1 N southeast\n", "u 1 N northeast\n", "y 1 N northwest\n", "\n", "b 1 R southwest\n", "h 1 R west\n", "j 1 R south\n", "k 1 R north\n", "l 1 R east\n", "n 1 R southeast\n", "u 1 R northeast\n", "y 1 R northwest\n", "\n", "b 1 F southwest\n", "h 1 F west\n", "j 1 F south\n", "k 1 F north\n", "l 1 F east\n", "n 1 F southeast\n", "u 1 F northeast\n", "y 1 F northwest\n", "\n", "Up 1 A north\n", "Down 1 A south\n", "Left 1 A west\n", "Right 1 A east\n", "\n", "KP_8 1 A north\n", "KP_2 1 A south\n", "KP_4 1 A west\n", "KP_6 1 A east\n", "KP_7 1 A northwest\n", "KP_9 1 A northeast\n", "KP_5 1 A stay\n", "KP_1 1 A southwest\n", "KP_3 1 A southeast\n", "\n", "KP_Up 1 A north\n", "KP_Down 1 A south\n", "KP_Right 1 A east\n", "KP_Left 1 A west\n", "KP_Home 1 A northwest\n", "KP_Prior 1 A northeast\n", "KP_End 1 A southwest\n", "KP_Next 1 A southeast\n", "\n", "KP_Add 1 A rotateshoottype\n", "KP_Subtract 1 A rotateshoottype -\n", "minus 1 N rotateshoottype -1\n", "plus 1 NF rotateshoottype\n" };
// default_files
// file config.c line 127
static char **default_files = (char **)(void *)0;
// description_renderer
// file spells.c line 52
static void *description_renderer = (void *)0;
// dfire
// file player.c line 108
static signed int dfire = -1;
// dialog_xml
// file main.c line 44
struct _GtkBuilder *dialog_xml;
// dialog_xml_file
// file main.c line 83
char dialog_xml_file[256l] = { 'd', 'i', 'a', 'l', 'o', 'g', 's', '.', 'u', 'i', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// dialog_xml_path
// file main.c line 84
char dialog_xml_path[256l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// directions
// file player.c line 38
const char * const directions[9l] = { "stay", "north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest" };
// display
// file opengl.c line 61
static struct _XDisplay *display;
// display_modes
// file config.c line 103
static const char * const display_modes[3l] = { "Pixmap", "SDL", "OpenGL" };
// drun
// file player.c line 108
static signed int drun = -1;
// dx
// file opengl.c line 371
static signed int dx[8l] = { 0, 1, 1, 1, 0, -1, -1, -1 };
// dy
// file opengl.c line 372
static signed int dy[8l] = { -1, -1, 0, 1, 1, 1, 0, -1 };
// encumbrance_current
// file inventory.c line 44
struct _GtkWidget *encumbrance_current;
// encumbrance_max
// file inventory.c line 45
struct _GtkWidget *encumbrance_max;
// entry_account_name
// file account.c line 38
static struct _GtkWidget *entry_account_name;
// entry_account_password
// file account.c line 39
static struct _GtkWidget *entry_account_password;
// entry_account_password_confirm
// file account.c line 59
static struct _GtkWidget *entry_account_password_confirm;
// entry_account_password_current
// file account.c line 58
static struct _GtkWidget *entry_account_password_current;
// entry_account_password_new
// file account.c line 58
static struct _GtkWidget *entry_account_password_new;
// entry_character_name
// file account.c line 76
static struct _GtkWidget *entry_character_name;
// entry_character_password
// file account.c line 77
static struct _GtkWidget *entry_character_password;
// entry_commands
// file keys.c line 71
struct _GtkWidget *entry_commands;
// entry_new_account_name
// file account.c line 43
static struct _GtkWidget *entry_new_account_name;
// entry_new_account_password
// file account.c line 44
static struct _GtkWidget *entry_new_account_password;
// entry_new_character_name
// file account.c line 53
static struct _GtkWidget *entry_new_character_name;
// entry_new_character_name$link1
// file create_char.c line 59
static struct _GtkWidget *entry_new_character_name$link1;
// entry_new_confirm_password
// file account.c line 44
static struct _GtkWidget *entry_new_confirm_password;
// exp_table
// file client.c line 65
unsigned long int *exp_table = (unsigned long int *)(void *)0;
// exp_table_max
// file client.c line 64
unsigned short int exp_table_max = (unsigned short int)0;
// face_info
// file image.c line 171
struct Face_Information_struct face_info;
// facecachedir
// file image.c line 410
char facecachedir[256l];
// facetoname
// file image.c line 176
static char *facetoname[10000l];
// fd_cache
// file image.c line 42
struct FD_Cache fd_cache[20l];
// fire_label
// file keys.c line 57
static struct _GtkWidget *fire_label;
// firekeysym
// file keys.c line 127
static unsigned int firekeysym[2l];
// firstTextManager
// file commands.c line 1217
struct TextManager *firstTextManager = (struct TextManager *)(void *)0;
// fogmap
// file sdl.c line 44
static struct SDL_Surface *fogmap;
// font_style_names
// file info.c line 33
static const char *font_style_names[5l] = { "info_font_normal", "info_font_arcane", "info_font_strange", "info_font_fixed", "info_font_hand" };
// format
// file sound.c line 40
static const char format[31l] = { '%', '4', 'x', ' ', '%', '4', 'x', ' ', '%', '4', 'x', ' ', '%', '4', 'x', ' ', '%', '4', 'x', ' ', '"', '%', 's', '"', ' ', '"', '%', 's', '"', '\n', 0 };
// free_items
// file item.c line 26
static struct item_struct *free_items;
// hand2_xpm
// file ../../pixmaps/hand2.xpm line 2
static const char * const hand2_xpm[26l] = { "20 16 9 1", " \tc None", ".\tc #BFBFBF", "+\tc #7F7F7F", "@\tc #404040", "#\tc #FFFFFF", "$\tc #DAA520", "%\tc #CD853F", "&\tc #A0522D", "*\tc #000000", " ..++@   .          ", " #.++@  ..#         ", "  #.++@...@         ", "  ..++@..@          ", "  #..+++@   $%&%&%  ", " #...+@@@  &&&%&&%% ", "#....@++@   &%$&%%$%", "...@@.++%$%$%$%%$$%$", "@@@  #.+%%*&*&*&%%%%", "     #.++&%&%&%&%%%%", "      #.+%*%***%%%%%", "      #.+&%&%%%%%%&%", "       #.+&%*&*%%%%&", "       #.++&%&%&%&  ", "        #.++&&&%    ", "        #.++@       " };
// hand_xpm
// file ../../pixmaps/hand.xpm line 2
static const char * const hand_xpm[26l] = { "20 16 9 1", " \tc None", ".\tc #FFFFFF", "+\tc #BFBFBF", "@\tc #7F7F7F", "#\tc #404040", "$\tc #A0522D", "%\tc #000000", "&\tc #CD853F", "*\tc #DAA520", "    .+@@#   .+      ", "     .+@@..++#      ", "     .+@@@+@@#      ", "     ..@@@@@#       ", "    .++@@@##$$      ", "   .@@@@#%%$$$$     ", "  .+@@##$$$$&%*&*&*&", " ++@##%&&&&&**&*&*&*", " +# &&%$%$%$&&&&*&*&", "     $&$&$&$&&&&&&&&", "     &%&%%%&&&&&&&&&", "     $&$&&&&&&$&$&$&", "      $&%$%&&&&$&$&$", "       $&$&$&$      ", "        $$$&@@#     ", "         .++@@#     " };
// has_init
// file account.c line 95
static signed int has_init = 0;
// has_init$link1
// file create_char.c line 70
static signed int has_init$link1 = 0;
// has_init$link2
// file skills.c line 38
static signed int has_init$link2 = 0;
// has_init$link3
// file spells.c line 58
static signed int has_init$link3 = 0;
// has_style
// file info.c line 76
static signed int has_style = 0;
// have_new_image
// file image.c line 71
signed int have_new_image = 0;
// height
// file opengl.c line 66
static signed int height = 1;
// height$link1
// file mapdata.c line 98
static signed int height$link1;
// history
// file keys.c line 95
char history[50l][256l];
// icon_rescale_factor
// file image.c line 88
static const signed int icon_rescale_factor[10l] = { 100, 100, 80, 60, 50, 45, 40, 35, 35, 33 };
// image_cache
// file image.c line 182
struct Image_Cache image_cache[8192l];
// image_size
// file image.c line 55
signed int image_size = 32;
// info_buffer
// file info.c line 155
struct info_buffer_t info_buffer[10l];
// info_pane
// file info.c line 58
struct Info_Pane info_pane[2l];
// inv_notebook
// file inventory.c line 42
struct _GtkWidget *inv_notebook;
// inv_notebooks
// file inventory.c line 147
struct anonymous$19 inv_notebooks[11l];
// lock_xpm
// file ../../pixmaps/lock.xpm line 2
static const char * const lock_xpm[23l] = { "20 16 6 1", " \tc None", ".\tc #BFBFBF", "+\tc #FFFFFF", "@\tc #7F7F7F", "#\tc #404040", "$\tc #000000", "                    ", "       .+..@@       ", "      +#@@@@.#      ", "      .@    .@      ", "      .#    .#      ", "      ..    @@      ", "     +.@...@@@#     ", "     .@.@##@@@$     ", "     +@.#$$#@@@     ", "     ..@#$$#@@#     ", "     +@@@$$@@#$     ", "     .@@@$$@@#@     ", "     @@@@$$@#@$     ", "     .@@@###@##     ", "     @@@##$@#$#     ", "                    " };
// mag_xpm
// file ../../pixmaps/mag.xpm line 2
static const char * const mag_xpm[23l] = { "20 16 6 1", " \tc None", ".\tc #1E90FF", "+\tc #FFFFFF", "@\tc #7F7F7F", "#\tc #404040", "$\tc #000000", "                    ", "                    ", "             .   .  ", "              . .   ", "   .  . . . .     . ", " .  . . . . . +@ .  ", "  .           +@   .", ".  +++++++++++#@$+$ ", " +++@+@+@+@+@+$@+++.", ".  ############@$+$ ", "  .           +@   .", " .  . . . . . +@ .  ", "   .  . . . .     . ", "              . .   ", "             .   .  ", "                    " };
// nonmag_xpm
// file ../../pixmaps/nonmag.xpm line 2
static const char * const nonmag_xpm[22l] = { "20 16 5 1", " \tc None", ".\tc #FFFFFF", "+\tc #7F7F7F", "@\tc #404040", "#\tc #000000", "                    ", "                    ", "                    ", "                    ", "                    ", "              .+    ", "              .+    ", "   ...........@+#.# ", " ...+.+.+.+.+.#+... ", "   @@@@@@@@@@@@+#.# ", "              .+    ", "              .+    ", "                    ", "                    ", "                    ", "                    " };
// skull_xpm
// file ../../pixmaps/skull.xpm line 2
static const char * const skull_xpm[23l] = { "20 16 6 1", " \tc None", ".\tc #FFFFFF", "+\tc #BFBFBF", "@\tc #7F7F7F", "#\tc #000000", "$\tc #404040", "                    ", "       .+.++.       ", "      ....++.+      ", "     ..++.+.+..     ", "     .+..++..@+     ", "    ...##@+##.+@    ", "    .+###+@###+@    ", "    .+.#+++@#@@@    ", "     ....##.@++     ", "      +..##.+@      ", "      +..##@++      ", "       @..++$       ", "       .####+       ", "        +++@        ", "        +@@@        ", "                    " };
// unidentified_xpm
// file ../../pixmaps/unidentified.xpm line 2
static const char * const unidentified_xpm[19l] = { "20 16 2 1", " \tc None", ".\tc #000000", "                    ", "       ....         ", "      ......        ", "     ..    ..       ", "    ..      ..      ", "    ..      ..      ", "    ..      ..      ", "     ..    ..       ", "           ..       ", "         ...        ", "        ...         ", "        ..          ", "                    ", "                    ", "        ..          ", "        ..          " };
// unlock_xpm
// file ../../pixmaps/unlock.xpm line 2
static const char * const unlock_xpm[23l] = { "20 16 6 1", " \tc None", ".\tc #7F7F7F", "+\tc #BFBFBF", "@\tc #FFFFFF", "#\tc #404040", "$\tc #000000", "        ..          ", "       +.           ", "      @#.           ", "      +.            ", "      +#            ", "      ++            ", "     @+.+++...#     ", "     +.+.##...$     ", "     @.+#$$#...     ", "     ++.#$$#..#     ", "     @...$$..#$     ", "     +...$$..#.     ", "     ....$$.#.$     ", "     +...###.##     ", "     ...##$.#$#     ", "                    " };
// inv_notebooks
// file inventory.c line 147
struct anonymous$19 inv_notebooks[11l] = { { .name="all", .tooltip="All Items", .xpm=all_xpm, .show_func=show_all,
    .type=0, .treeview=((struct _GtkWidget *)NULL), .treestore=((struct _GtkTreeStore *)NULL) }, 
    { .name="applied", .tooltip="Applied Items", .xpm=hand_xpm,
    .show_func=show_applied, .type=0,
    .treeview=((struct _GtkWidget *)NULL), .treestore=((struct _GtkTreeStore *)NULL) }, 
    { .name="unapplied", .tooltip="Unapplied Items", .xpm=hand2_xpm,
    .show_func=show_unapplied, .type=0,
    .treeview=((struct _GtkWidget *)NULL), .treestore=((struct _GtkTreeStore *)NULL) }, 
    { .name="unpaid", .tooltip="Unpaid items", .xpm=coin_xpm,
    .show_func=show_unpaid, .type=0,
    .treeview=((struct _GtkWidget *)NULL), .treestore=((struct _GtkTreeStore *)NULL) }, 
    { .name="cursed", .tooltip="Cursed items", .xpm=skull_xpm,
    .show_func=show_cursed, .type=0,
    .treeview=((struct _GtkWidget *)NULL), .treestore=((struct _GtkTreeStore *)NULL) }, 
    { .name="magical", .tooltip="Magical items", .xpm=mag_xpm,
    .show_func=show_magical, .type=0,
    .treeview=((struct _GtkWidget *)NULL), .treestore=((struct _GtkTreeStore *)NULL) }, 
    { .name="nonmagical", .tooltip="Nonmagical items", .xpm=nonmag_xpm,
    .show_func=show_nonmagical, .type=0,
    .treeview=((struct _GtkWidget *)NULL), .treestore=((struct _GtkTreeStore *)NULL) }, 
    { .name="locked", .tooltip="Inventory locked items", .xpm=lock_xpm,
    .show_func=show_locked, .type=0,
    .treeview=((struct _GtkWidget *)NULL), .treestore=((struct _GtkTreeStore *)NULL) }, 
    { .name="unlocked", .tooltip="Inventory unlocked items", .xpm=unlock_xpm,
    .show_func=show_unlocked, .type=0,
    .treeview=((struct _GtkWidget *)NULL), .treestore=((struct _GtkTreeStore *)NULL) }, 
    { .name="unidentified", .tooltip="Inventory unidentified items", .xpm=unidentified_xpm,
    .show_func=show_unidentified, .type=0,
    .treeview=((struct _GtkWidget *)NULL), .treestore=((struct _GtkTreeStore *)NULL) }, 
    { .name="icons", .tooltip="Quick icon view", .xpm=(const char * const *)(void *)0,
    .show_func=show_all,
    .type=1, .treeview=((struct _GtkWidget *)NULL), .treestore=((struct _GtkTreeStore *)NULL) } };
// inv_styles
// file inventory.c line 71
static struct _GtkStyle *inv_styles[5l];
// inv_table
// file inventory.c line 46
struct _GtkWidget *inv_table;
// inv_table_children
// file inventory.c line 58
struct _GtkWidget *inv_table_children[100l][20l];
// inv_table_tooltips
// file inventory.c line 49
static struct _GtkTooltips *inv_table_tooltips;
// item_types
// file ./item-types.h line 8
static const char * const item_types[256l][64l] = { { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "sack", "Luggage", "pouch", "quiver", "bag", "chest", "key ring", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "axe", "club", "dagger", "falchion", "hammer", "katana", "mace", "magnifying glass", "morningstar", "nunchacu", "quarterstaff", "sabre", "scimitar", "shovel", "^spear", "stake", "^sword", "Belzebub's sword", "Firebrand", "Harakiri sword", "broadsword", "light sword", "Serpentman sword", "shortsword", "long sword", "taifu", "trident", "BoneCrusher", "Darkblade", "Demonslayer", "Dragonslayer", "Excalibur", "firebrand", "Firestar", "Flame Tongue", "FlameTongue", "Frost Hammer", "Katana of Masamune", "Lightning sticks", "Mjoellnir", "Mournblade", "Sting", "Stormbringer", "Trident", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "^bow", "elven bow", "long bow", "crossbow", "sling", "arrow", "^bolt", "boulder", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "mail", "leather", "^robe", "shirt", "apron", "hauberk", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "helmet", "Crown", "crown", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "shield", "Demonspawn Shield", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "boot", "glove", "gauntlet", "shoe", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "girdle", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "cloak", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "bracer", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "apple", "booze", "bread", "cabbage", "cake", "carrot", "chocolate", "clover", "cup ", "egg", "fish", "food", "mint sprig", "mushroom", "onion", "orange", "potato", "roast bird", "steak", "waybread", "^water", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "diamond", "emerald", "gold nugget", "pearl", "ruby", "sapphire", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "coin", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "rod", "Rod", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "wand", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "staff", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "horn", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "amulet", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "ring", "Ring ", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "scroll", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "grimore", "grimoire", "hymnal", "manual", "prayerbook", "sacred text", "spellbook", "testiment", "treatise", "tome", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "book", "catalog", "codex", "collection", "compendium", "compilation", "divine text", "divine work", "encyclopedia", "exposition", "file ", "formulary", "guide ", "holy book ", "holy record ", "index", "moral text", "notes", "note", "pamphlet", "record ", "tables", "transcript", "volume", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "potion", "bottle", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "^balm", "^dust", "dust ", "figurine", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "Improve", "Lower Weapon", "Enchant Weapon", "Prepare Weapon", "Enchant Armour", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "holy symbol", "lockpick", "talisman", "writing pen", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "key", "Key", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "arm", "claw", "corpse", "dragon scale", "ectoplasm", "eye", "finger", "foot", "hand", "head", "Head", "heart", "icor", "leg", "lich dust", "liver", "orc chop", "pixie dust", "residue", "skin", "stinger", "tongue", "tooth", "^wing", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "dirt", "lead", "mandrake root", "pile", "rock", "stone", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "flint and steel", "torch", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "clock", "flower", "Gate Pass", "Glowing Crystal", "gravestone", "icecube", "library card", "Passport", "Port Pass", "rose", "Apartment Extender", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { "chair", "table", (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, 
    { (const char *)(void *)0, ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) } };
// kb_scope_togglebutton_character
// file keys.c line 58
static struct _GtkWidget *kb_scope_togglebutton_character;
// kb_scope_togglebutton_global
// file keys.c line 58
static struct _GtkWidget *kb_scope_togglebutton_global;
// keybinding_button_bind
// file keys.c line 65
static struct _GtkWidget *keybinding_button_bind;
// keybinding_button_remove
// file keys.c line 64
static struct _GtkWidget *keybinding_button_remove;
// keybinding_button_update
// file keys.c line 64
static struct _GtkWidget *keybinding_button_update;
// keybinding_checkbutton_alt
// file keys.c line 61
static struct _GtkWidget *keybinding_checkbutton_alt;
// keybinding_checkbutton_any
// file keys.c line 59
static struct _GtkWidget *keybinding_checkbutton_any;
// keybinding_checkbutton_control
// file keys.c line 60
static struct _GtkWidget *keybinding_checkbutton_control;
// keybinding_checkbutton_edit
// file keys.c line 62
static struct _GtkWidget *keybinding_checkbutton_edit;
// keybinding_checkbutton_meta
// file keys.c line 61
static struct _GtkWidget *keybinding_checkbutton_meta;
// keybinding_checkbutton_shift
// file keys.c line 60
static struct _GtkWidget *keybinding_checkbutton_shift;
// keybinding_entry_command
// file keys.c line 63
static struct _GtkWidget *keybinding_entry_command;
// keybinding_entry_key
// file keys.c line 62
static struct _GtkWidget *keybinding_entry_key;
// keybinding_selection
// file keys.c line 68
static struct _GtkTreeSelection *keybinding_selection;
// keybinding_store
// file keys.c line 67
static struct _GtkListStore *keybinding_store;
// keybinding_treeview
// file keys.c line 63
static struct _GtkWidget *keybinding_treeview;
// keybinding_window
// file keys.c line 57
static struct _GtkWidget *keybinding_window;
// keys_char
// file keys.c line 174
static struct keybind *keys_char[257l];
// keys_global
// file keys.c line 174
static struct keybind *keys_global[257l];
// label_account_login_status
// file account.c line 39
static struct _GtkWidget *label_account_login_status;
// label_account_password_status
// file account.c line 60
static struct _GtkWidget *label_account_password_status;
// label_add_status
// file account.c line 77
static struct _GtkWidget *label_add_status;
// label_cc_desc
// file create_char.c line 57
static struct _GtkWidget *label_cc_desc;
// label_cc_status_update
// file create_char.c line 57
static struct _GtkWidget *label_cc_status_update;
// label_cc_unspent
// file create_char.c line 57
static struct _GtkWidget *label_cc_unspent;
// label_create_account_status
// file account.c line 45
static struct _GtkWidget *label_create_account_status;
// label_cs
// file create_char.c line 56
static struct _GtkWidget *label_cs[7l];
// label_new_char_status
// file account.c line 54
static struct _GtkWidget *label_new_char_status;
// label_rs
// file create_char.c line 55
static struct _GtkWidget *label_rs[7l];
// label_tot
// file create_char.c line 56
static struct _GtkWidget *label_tot[7l];
// last_face_num
// file image.c line 68
signed int last_face_num = 0;
// last_used_skills
// file client.c line 55
signed int last_used_skills[51l];
// lastmax
// file stats.c line 108
static signed int lastmax[5l];
// lastval
// file stats.c line 108
static signed int lastval[5l];
// layoutdir
// file config.c line 101
static char *layoutdir = "ui";
// lightmap
// file sdl.c line 43
static struct SDL_Surface *lightmap;
// login_pane
// file account.c line 91
struct Info_Pane login_pane[4l];
// login_window
// file account.c line 33
static struct _GtkWidget *login_window;
// magic_map
// file main.c line 43
struct _GtkWidget *magic_map;
// magic_map_gc
// file magicmap.c line 32
static struct _GdkGC *magic_map_gc = (struct _GdkGC *)(void *)0;
// map
// file item.c line 27
static struct item_struct *map;
// map_darkness
// file opengl.c line 252
static unsigned short int map_darkness[66l][66l];
// map_drawing_area
// file map.c line 56
struct _GtkWidget *map_drawing_area;
// map_image_half_size
// file map.c line 59
signed int map_image_half_size = 32 / 2;
// map_image_size
// file map.c line 58
signed int map_image_size = 32;
// map_notebook
// file map.c line 56
struct _GtkWidget *map_notebook;
// map_updated
// file map.c line 45
static unsigned char map_updated = (unsigned char)0;
// mapgc
// file map.c line 57
struct _GdkGC *mapgc;
// mapsurface
// file sdl.c line 42
struct SDL_Surface *mapsurface;
// mapupdatesent
// file commands.c line 55
signed int mapupdatesent = 0;
// max_subtype
// file info.c line 76
static signed int max_subtype = 0;
// maxfd
// file client.c line 59
signed int maxfd;
// meta_numservers
// file metaserver.c line 46
signed int meta_numservers = 0;
// meta_port
// file client.c line 57
signed int meta_port = 13326;
// meta_server
// file client.c line 50
char *meta_server = "crossfire.real-time.com";
// meta_servers
// file metaserver.c line 44
struct Meta_Info *meta_servers = (struct Meta_Info *)(void *)0;
// metakeysym
// file keys.c line 128
static unsigned int metakeysym[2l];
// metaserver2_on
// file client.c line 59
signed int metaserver2_on = 1;
// metaserver_button
// file metaserver.c line 33
static struct _GtkWidget *metaserver_button;
// metaserver_entry
// file metaserver.c line 34
static struct _GtkWidget *metaserver_entry;
// metaserver_on
// file client.c line 59
signed int metaserver_on = 0;
// metaserver_selection
// file metaserver.c line 36
static struct _GtkTreeSelection *metaserver_selection;
// metaserver_status
// file metaserver.c line 34
static struct _GtkWidget *metaserver_status;
// metaserver_window
// file metaserver.c line 33
static struct _GtkWidget *metaserver_window;
// metaservers
// file metaserver.c line 272
static char *metaservers[1l] = { "http://crossfire.real-time.com/metaserver2/meta_client.php" };
// motd
// file commands.c line 82
char *motd = (char *)(void *)0;
// ms1_is_running
// file metaserver.c line 557
static signed int ms1_is_running = 0;
// ms2_info_mutex
// file metaserver.c line 255
union anonymous$39 ms2_info_mutex;
// ms2_is_running
// file metaserver.c line 262
static signed int ms2_is_running = 0;
// msg_type_names
// file ../../common/msgtypes.h line 5
const struct Msg_Type_Names msg_type_names[184l] = { { .type=0, .subtype=0, .style_name="generic" }, 
    { .type=1, .subtype=0, .style_name="book" }, 
    { .type=2, .subtype=0, .style_name="card" }, 
    { .type=3, .subtype=0, .style_name="paper" }, 
    { .type=4, .subtype=0, .style_name="sign" }, 
    { .type=5, .subtype=0, .style_name="monument" }, 
    { .type=6, .subtype=0, .style_name="dialog" }, 
    { .type=7, .subtype=0, .style_name="motd" }, 
    { .type=8, .subtype=0, .style_name="admin" }, 
    { .type=9, .subtype=0, .style_name="shop" }, 
    { .type=10, .subtype=0, .style_name="command" }, 
    { .type=11, .subtype=0, .style_name="attribute" }, 
    { .type=12, .subtype=0, .style_name="skill" }, 
    { .type=13, .subtype=0, .style_name="apply" }, 
    { .type=14, .subtype=0, .style_name="attack" }, 
    { .type=15, .subtype=0, .style_name="communication" }, 
    { .type=16, .subtype=0, .style_name="spell" }, 
    { .type=17, .subtype=0, .style_name="item" }, 
    { .type=18, .subtype=0, .style_name="misc" }, 
    { .type=19, .subtype=0, .style_name="victim" }, 
    { .type=20, .subtype=0, .style_name="client" }, 
    { .type=1, .subtype=1, .style_name="book_clasp_1" }, 
    { .type=1, .subtype=2, .style_name="book_clasp_2" }, 
    { .type=1, .subtype=3, .style_name="book_elegant_1" }, 
    { .type=1, .subtype=4, .style_name="book_elegant_2" }, 
    { .type=1, .subtype=5, .style_name="book_quarto_1" }, 
    { .type=1, .subtype=6, .style_name="book_quarto_2" }, 
    { .type=1, .subtype=7, .style_name="book_spell_evoker" }, 
    { .type=1, .subtype=8, .style_name="book_spell_prayer" }, 
    { .type=1, .subtype=9, .style_name="book_spell_pyro" }, 
    { .type=1, .subtype=10, .style_name="book_spell_sorcerer" }, 
    { .type=1, .subtype=11, .style_name="book_spell_summoner" }, 
    { .type=2, .subtype=1, .style_name="card_simple_1" }, 
    { .type=2, .subtype=2, .style_name="card_simple_2" }, 
    { .type=2, .subtype=3, .style_name="card_simple_3" }, 
    { .type=2, .subtype=4, .style_name="card_elegant_1" }, 
    { .type=2, .subtype=5, .style_name="card_elegant_2" }, 
    { .type=2, .subtype=6, .style_name="card_elegant_3" }, 
    { .type=2, .subtype=7, .style_name="card_strange_1" }, 
    { .type=2, .subtype=8, .style_name="card_strange_2" }, 
    { .type=2, .subtype=9, .style_name="card_strange_3" }, 
    { .type=2, .subtype=10, .style_name="card_money_1" }, 
    { .type=2, .subtype=11, .style_name="card_money_2" }, 
    { .type=2, .subtype=12, .style_name="card_money_3" }, 
    { .type=3, .subtype=1, .style_name="paper_note_1" }, 
    { .type=3, .subtype=2, .style_name="paper_note_2" }, 
    { .type=3, .subtype=3, .style_name="paper_note_3" }, 
    { .type=3, .subtype=4, .style_name="paper_letter_old_1" }, 
    { .type=3, .subtype=5, .style_name="paper_letter_old_2" }, 
    { .type=3, .subtype=6, .style_name="paper_letter_new_1" }, 
    { .type=3, .subtype=7, .style_name="paper_letter_new_2" }, 
    { .type=3, .subtype=8, .style_name="paper_envelope_1" }, 
    { .type=3, .subtype=9, .style_name="paper_envelope_2" }, 
    { .type=3, .subtype=10, .style_name="paper_scroll_old_1" }, 
    { .type=3, .subtype=11, .style_name="paper_scroll_old_2" }, 
    { .type=3, .subtype=12, .style_name="paper_scroll_new_1" }, 
    { .type=3, .subtype=13, .style_name="paper_scroll_new_2" }, 
    { .type=3, .subtype=14, .style_name="paper_scroll_magic" }, 
    { .type=4, .subtype=1, .style_name="sign_basic" }, 
    { .type=4, .subtype=2, .style_name="sign_dir_left" }, 
    { .type=4, .subtype=3, .style_name="sign_dir_right" }, 
    { .type=4, .subtype=4, .style_name="sign_dir_both" }, 
    { .type=4, .subtype=5, .style_name="sign_magic_mouth" }, 
    { .type=5, .subtype=1, .style_name="monument_stone_1" }, 
    { .type=5, .subtype=2, .style_name="monument_stone_2" }, 
    { .type=5, .subtype=3, .style_name="monument_stone_3" }, 
    { .type=5, .subtype=4, .style_name="monument_statue_1" }, 
    { .type=5, .subtype=5, .style_name="monument_statue_2" }, 
    { .type=5, .subtype=6, .style_name="monument_statue_3" }, 
    { .type=5, .subtype=7, .style_name="monument_gravestone_1" }, 
    { .type=5, .subtype=8, .style_name="monument_gravestone_2" }, 
    { .type=5, .subtype=9, .style_name="monument_gravestone_3" }, 
    { .type=5, .subtype=10, .style_name="monument_wall_1" }, 
    { .type=5, .subtype=11, .style_name="monument_wall_2" }, 
    { .type=5, .subtype=12, .style_name="monument_wall_3" }, 
    { .type=6, .subtype=1, .style_name="dialog_npc" }, 
    { .type=6, .subtype=2, .style_name="dialog_altar" }, 
    { .type=6, .subtype=3, .style_name="dialog_magic_ear" }, 
    { .type=8, .subtype=1, .style_name="admin_rules" }, 
    { .type=8, .subtype=2, .style_name="admin_news" }, 
    { .type=8, .subtype=3, .style_name="admin_player" }, 
    { .type=8, .subtype=4, .style_name="admin_dm" }, 
    { .type=8, .subtype=5, .style_name="admin_hiscore" }, 
    { .type=8, .subtype=6, .style_name="admin_loadsave" }, 
    { .type=8, .subtype=7, .style_name="admin_login" }, 
    { .type=8, .subtype=8, .style_name="admin_version" }, 
    { .type=8, .subtype=9, .style_name="admin_error" }, 
    { .type=9, .subtype=1, .style_name="shop_listing" }, 
    { .type=9, .subtype=2, .style_name="shop_payment" }, 
    { .type=9, .subtype=3, .style_name="shop_sell" }, 
    { .type=9, .subtype=4, .style_name="shop_misc" }, 
    { .type=10, .subtype=1, .style_name="command_who" }, 
    { .type=10, .subtype=2, .style_name="command_maps" }, 
    { .type=10, .subtype=3, .style_name="command_body" }, 
    { .type=10, .subtype=4, .style_name="command_malloc" }, 
    { .type=10, .subtype=5, .style_name="command_weather" }, 
    { .type=10, .subtype=6, .style_name="command_statistics" }, 
    { .type=10, .subtype=7, .style_name="command_config" }, 
    { .type=10, .subtype=8, .style_name="command_info" }, 
    { .type=10, .subtype=9, .style_name="command_quests" }, 
    { .type=10, .subtype=10, .style_name="command_debug" }, 
    { .type=10, .subtype=11, .style_name="command_error" }, 
    { .type=10, .subtype=12, .style_name="command_success" }, 
    { .type=10, .subtype=13, .style_name="command_failure" }, 
    { .type=10, .subtype=14, .style_name="command_examine" }, 
    { .type=10, .subtype=15, .style_name="command_inventory" }, 
    { .type=10, .subtype=16, .style_name="command_help" }, 
    { .type=10, .subtype=17, .style_name="command_dm" }, 
    { .type=10, .subtype=18, .style_name="command_newplayer" }, 
    { .type=11, .subtype=1, .style_name="attribute_attacktype_gain" }, 
    { .type=11, .subtype=2, .style_name="attribute_attacktype_loss" }, 
    { .type=11, .subtype=3, .style_name="attribute_protection_gain" }, 
    { .type=11, .subtype=4, .style_name="attribute_protection_loss" }, 
    { .type=11, .subtype=5, .style_name="attribute_move" }, 
    { .type=11, .subtype=6, .style_name="attribute_race" }, 
    { .type=11, .subtype=7, .style_name="attribute_bad_effect_start" }, 
    { .type=11, .subtype=8, .style_name="attribute_bad_effect_end" }, 
    { .type=11, .subtype=9, .style_name="attribute_stat_gain" }, 
    { .type=11, .subtype=10, .style_name="attribute_stat_loss" }, 
    { .type=11, .subtype=11, .style_name="attribute_level_gain" }, 
    { .type=11, .subtype=12, .style_name="attribute_level_loss" }, 
    { .type=11, .subtype=13, .style_name="attribute_good_effect_start" }, 
    { .type=11, .subtype=14, .style_name="attribute_good_effect_end" }, 
    { .type=11, .subtype=15, .style_name="attribute_god" }, 
    { .type=12, .subtype=1, .style_name="skill_missing" }, 
    { .type=12, .subtype=2, .style_name="skill_error" }, 
    { .type=12, .subtype=3, .style_name="skill_success" }, 
    { .type=12, .subtype=4, .style_name="skill_failure" }, 
    { .type=12, .subtype=5, .style_name="skill_pray" }, 
    { .type=12, .subtype=6, .style_name="skill_list" }, 
    { .type=13, .subtype=1, .style_name="apply_error" }, 
    { .type=13, .subtype=2, .style_name="apply_unapply" }, 
    { .type=13, .subtype=3, .style_name="apply_success" }, 
    { .type=13, .subtype=4, .style_name="apply_failure" }, 
    { .type=13, .subtype=5, .style_name="apply_cursed" }, 
    { .type=13, .subtype=6, .style_name="apply_trap" }, 
    { .type=13, .subtype=7, .style_name="apply_badbody" }, 
    { .type=13, .subtype=8, .style_name="apply_prohibition" }, 
    { .type=13, .subtype=9, .style_name="apply_build" }, 
    { .type=14, .subtype=1, .style_name="attack_did_hit" }, 
    { .type=14, .subtype=2, .style_name="attack_pet_hit" }, 
    { .type=14, .subtype=3, .style_name="attack_fumble" }, 
    { .type=14, .subtype=4, .style_name="attack_did_kill" }, 
    { .type=14, .subtype=5, .style_name="attack_pet_died" }, 
    { .type=14, .subtype=6, .style_name="attack_nokey" }, 
    { .type=14, .subtype=7, .style_name="attack_noattack" }, 
    { .type=14, .subtype=8, .style_name="attack_pushed" }, 
    { .type=14, .subtype=9, .style_name="attack_miss" }, 
    { .type=15, .subtype=1, .style_name="communication_random" }, 
    { .type=15, .subtype=2, .style_name="communication_say" }, 
    { .type=15, .subtype=3, .style_name="communication_me" }, 
    { .type=15, .subtype=4, .style_name="communication_tell" }, 
    { .type=15, .subtype=5, .style_name="communication_emote" }, 
    { .type=15, .subtype=6, .style_name="communication_party" }, 
    { .type=15, .subtype=7, .style_name="communication_shout" }, 
    { .type=15, .subtype=8, .style_name="communication_chat" }, 
    { .type=16, .subtype=1, .style_name="spell_heal" }, 
    { .type=16, .subtype=2, .style_name="spell_pet" }, 
    { .type=16, .subtype=3, .style_name="spell_failure" }, 
    { .type=16, .subtype=4, .style_name="spell_end" }, 
    { .type=16, .subtype=5, .style_name="spell_success" }, 
    { .type=16, .subtype=6, .style_name="spell_error" }, 
    { .type=16, .subtype=7, .style_name="spell_perceive_self" }, 
    { .type=16, .subtype=8, .style_name="spell_target" }, 
    { .type=16, .subtype=9, .style_name="spell_info" }, 
    { .type=17, .subtype=1, .style_name="item_remove" }, 
    { .type=17, .subtype=2, .style_name="item_add" }, 
    { .type=17, .subtype=3, .style_name="item_change" }, 
    { .type=17, .subtype=4, .style_name="item_info" }, 
    { .type=19, .subtype=1, .style_name="victim_swamp" }, 
    { .type=19, .subtype=2, .style_name="victim_was_hit" }, 
    { .type=19, .subtype=3, .style_name="victim_steal" }, 
    { .type=19, .subtype=4, .style_name="victim_spell" }, 
    { .type=19, .subtype=5, .style_name="victim_died" }, 
    { .type=19, .subtype=6, .style_name="victim_was_pushed" }, 
    { .type=20, .subtype=1, .style_name="client_config" }, 
    { .type=20, .subtype=2, .style_name="client_server" }, 
    { .type=20, .subtype=3, .style_name="client_command" }, 
    { .type=20, .subtype=4, .style_name="client_query" }, 
    { .type=20, .subtype=5, .style_name="client_debug" }, 
    { .type=20, .subtype=6, .style_name="client_notice" }, 
    { .type=20, .subtype=7, .style_name="client_metaserver" }, 
    { .type=20, .subtype=8, .style_name="client_script" }, 
    { .type=20, .subtype=9, .style_name="client_error" } };
// msgctrl_defaults
// file info.c line 252
struct msgctrl_data_t msgctrl_defaults[20l] = { { .description="Books", .buffer=0, .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Cards", .buffer=0, .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Paper", .buffer=0, .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Signs & Magic Mouths", .buffer=0, .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Monuments", .buffer=0, .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Dialogs (Altar/NPC/Magic Ear)", .buffer=0,
    .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Message of the day", .buffer=0, .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Administrative", .buffer=0, .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Shops", .buffer=(const signed int)!(0 != 0), .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Command responses", .buffer=0, .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Changes to attributes", .buffer=(const signed int)!(0 != 0), .pane={ (const signed int)!(0 != 0), (const signed int)!(0 != 0) } }, 
    { .description="Skill-related messages", .buffer=(const signed int)!(0 != 0),
    .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Apply results", .buffer=(const signed int)!(0 != 0), .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Attack results", .buffer=(const signed int)!(0 != 0), .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Player communication", .buffer=0, .pane={ (const signed int)!(0 != 0), (const signed int)!(0 != 0) } }, 
    { .description="Spell results", .buffer=(const signed int)!(0 != 0), .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Item information", .buffer=(const signed int)!(0 != 0), .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Miscellaneous", .buffer=(const signed int)!(0 != 0), .pane={ (const signed int)!(0 != 0), 0 } }, 
    { .description="Victim notification", .buffer=0, .pane={ (const signed int)!(0 != 0), (const signed int)!(0 != 0) } }, 
    { .description="Client-generated messages", .buffer=0,
    .pane={ (const signed int)!(0 != 0), 0 } } };
// msgctrl_table
// file info.c line 98
struct _GtkWidget *msgctrl_table;
// msgctrl_widgets
// file info.c line 216
struct anonymous$73 msgctrl_widgets[20l];
// msgctrl_window
// file info.c line 94
struct _GtkWidget *msgctrl_window;
// name_sorted_commands
// file p_cmd.c line 906
static struct anonymous$47 **name_sorted_commands;
// need_mapping_update
// file stats.c line 106
signed int need_mapping_update = 1;
// negative_stat
// file create_char.c line 70
static signed int negative_stat = 0;
// new_character_window
// file account.c line 53
static struct _GtkWidget *new_character_window;
// news
// file commands.c line 82
char *news = (char *)(void *)0;
// nextkeysym
// file keys.c line 128
static unsigned int nextkeysym;
// no_recurse
// file pickup.c line 87
static unsigned int no_recurse = (unsigned int)0;
// num_classes
// file commands.c line 90
signed int num_classes = 0;
// num_commands
// file p_cmd.c line 896
signed int num_commands;
// num_inv_notebook_pages
// file inventory.c line 87
static signed int num_inv_notebook_pages = 0;
// num_pickups
// file pickup.c line 40
static signed int num_pickups = 0;
// num_races
// file commands.c line 87
signed int num_races = 0;
// num_scripts
// file script.c line 153
static signed int num_scripts = 0;
// opt_combobox
// file create_char.c line 60
static struct _GtkWidget *opt_combobox[6l];
// opt_label
// file create_char.c line 60
static struct _GtkWidget *opt_label[6l];
// padj
// file image.c line 481
static struct _GtkAdjustment *padj = (struct _GtkAdjustment *)(void *)0;
// pbar
// file image.c line 479
static struct _GtkWidget *pbar = (struct _GtkWidget *)(void *)0;
// pbar_window
// file image.c line 480
static struct _GtkWidget *pbar_window = (struct _GtkWidget *)(void *)0;
// pickup_mapping
// file pickup.c line 39
struct anonymous$61 pickup_mapping[50l];
// pixmaps
// file image.c line 66
struct PixmapInfo *pixmaps[10000l];
// pl_pos
// file map.c line 54
struct PlayerPosition pl_pos;
// player
// file item.c line 27
static struct item_struct *player;
// pmode
// file pickup.c line 87
static unsigned int pmode = (unsigned int)0;
// prevkeysym
// file keys.c line 128
static unsigned int prevkeysym;
// private_cache
// file image.c line 62
struct anonymous$68 private_cache[10000l];
// question_bits
// file ../../pixmaps/question.111 line 3
static const char question_bits[128l] = { (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x1f, (const char)0x00, (const char)0x00, (const char)0xc0, (const char)0x7f, (const char)0x00, (const char)0x00, (const char)0xe0, (const char)0xff, (const char)0x00, (const char)0x00, (const char)0x70, (const char)0xc0, (const char)0x01, (const char)0x00, (const char)0x38, (const char)0x80, (const char)0x03, (const char)0x00, (const char)0x38, (const char)0x80, (const char)0x03, (const char)0x00, (const char)0x38, (const char)0x80, (const char)0x03, (const char)0x00, (const char)0x38, (const char)0x80, (const char)0x03, (const char)0x00, (const char)0x38, (const char)0x80, (const char)0x03, (const char)0x00, (const char)0x70, (const char)0xc0, (const char)0x01, (const char)0x00, (const char)0x00, (const char)0xc0, (const char)0x01, (const char)0x00, (const char)0x00, (const char)0x70, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x78, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x3e, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x0e, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x0e, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x0e, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x0e, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x0e, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00, (const char)0x00 };
// races
// file commands.c line 98
struct Race_Class_Info *races = (struct Race_Class_Info *)(void *)0;
// redrawbitmap
// file sdl.c line 45
static char *redrawbitmap;
// replyinfo_last_face
// file client.c line 58
signed int replyinfo_last_face = 0;
// replyinfo_status
// file client.c line 58
signed int replyinfo_status = 0;
// requestinfo_sent
// file client.c line 58
signed int requestinfo_sent = 0;
// resist_mapping
// file client.c line 67
struct anonymous$66 resist_mapping[18l];
// resists_name
// file client.c line 72
const char * const resists_name[18l] = { "armor", "magic", "fire", "elec", "cold", "conf", "acid", "drain", "ghit", "pois", "slow", "para", "t undead", "fear", "depl", "death", "hword", "blind" };
// rgb
// file png.c line 439
unsigned char rgb[786432l];
// root_color
// file main.c line 89
struct _GdkColor root_color[13l];
// rules
// file commands.c line 82
char *rules = (char *)(void *)0;
// run_label
// file keys.c line 57
static struct _GtkWidget *run_label;
// runkeysym
// file keys.c line 127
static unsigned int runkeysym[2l];
// script_count
// file script_lua.c line 76
static signed int script_count = 0;
// scripts
// file script.c line 151
static struct script *scripts = (struct script *)(void *)0;
// scripts$link1
// file script_lua.c line 75
static struct script_state *scripts$link1 = (struct script_state *)(void *)0;
// scroll_history_position
// file keys.c line 97
static signed int scroll_history_position = 0;
// server
// file client.c line 45
char *server = (char *)(void *)0;
// serverloginmethod
// file client.c line 60
signed int serverloginmethod = 0;
// short_stat_name
// file commands.c line 107
const char * const short_stat_name[7l] = { "Str", "Dex", "Con", "Wis", "Cha", "Int", "Pow" };
// skill_mapping
// file client.c line 67
struct anonymous$66 skill_mapping[50l];
// skill_names
// file client.c line 51
char *skill_names[50l];
// skill_ready
// file skills.c line 32
static struct _GtkWidget *skill_ready;
// skill_selection
// file skills.c line 34
static struct _GtkTreeSelection *skill_selection;
// skill_store
// file skills.c line 33
static struct _GtkListStore *skill_store;
// skill_treeview
// file skills.c line 32
static struct _GtkWidget *skill_treeview;
// skill_use
// file skills.c line 32
static struct _GtkWidget *skill_use;
// skill_window
// file skills.c line 32
static struct _GtkWidget *skill_window;
// sound_pipe
// file sound.c line 33
struct _IO_FILE *sound_pipe = (struct _IO_FILE *)(void *)0;
// sound_process
// file sound.c line 34
struct ChildProcess *sound_process;
// sound_server
// file client.c line 52
char *sound_server = "cfsndserv";
// spell_cast
// file spells.c line 39
static struct _GtkWidget *spell_cast;
// spell_eventbox
// file spells.c line 40
static struct _GtkWidget *spell_eventbox[4l];
// spell_invoke
// file spells.c line 38
static struct _GtkWidget *spell_invoke;
// spell_label
// file spells.c line 40
static struct _GtkWidget *spell_label[4l];
// spell_options
// file spells.c line 39
static struct _GtkWidget *spell_options;
// spell_selection
// file spells.c line 37
static struct _GtkTreeSelection *spell_selection;
// spell_store
// file spells.c line 36
static struct _GtkListStore *spell_store;
// spell_styles
// file spells.c line 55
static struct _GtkStyle *spell_styles[4l];
// spell_treeview
// file spells.c line 39
static struct _GtkWidget *spell_treeview;
// spell_window
// file spells.c line 38
static struct _GtkWidget *spell_window;
// spellmon_level
// file commands.c line 84
signed int spellmon_level = 0;
// spinbutton_cc
// file create_char.c line 55
static struct _GtkWidget *spinbutton_cc[7l];
// spinbutton_count
// file keys.c line 70
struct _GtkWidget *spinbutton_count;
// starting_map_info
// file commands.c line 99
struct Starting_Map_Info *starting_map_info = (struct Starting_Map_Info *)(void *)0;
// starting_map_number
// file commands.c line 96
signed int starting_map_number = 0;
// stat_bar
// file stats.c line 44
static struct _GtkWidget *stat_bar[5l];
// stat_bar_names
// file stats.c line 38
static const char * const stat_bar_names[5l] = { "hp", "sp", "grace", "food", "exp" };
// stat_current
// file stats.c line 42
static struct _GtkWidget *stat_current[5l];
// stat_mapping
// file commands.c line 118
struct Stat_Mapping stat_mapping[7l] = { { .widget_suffix="str", .cs_value=(unsigned char)5, .rc_offset=(unsigned char)0 }, 
    { .widget_suffix="con", .cs_value=(unsigned char)9, .rc_offset=(unsigned char)1 }, 
    { .widget_suffix="dex", .cs_value=(unsigned char)8, .rc_offset=(unsigned char)2 }, 
    { .widget_suffix="int", .cs_value=(unsigned char)6, .rc_offset=(unsigned char)3 }, 
    { .widget_suffix="wis", .cs_value=(unsigned char)7, .rc_offset=(unsigned char)4 }, 
    { .widget_suffix="pow", .cs_value=(unsigned char)22, .rc_offset=(unsigned char)5 }, 
    { .widget_suffix="cha", .cs_value=(unsigned char)10, .rc_offset=(unsigned char)6 } };
// stat_max
// file stats.c line 43
static struct _GtkWidget *stat_max[5l];
// stat_maximum
// file commands.c line 95
signed int stat_maximum = 0;
// stat_min
// file commands.c line 94
signed int stat_min = 0;
// stat_points
// file commands.c line 93
signed int stat_points = 0;
// stat_style_names
// file stats.c line 58
static const char * const stat_style_names[6l] = { "bar_normal", "bar_low", "bar_super", "gradual_bar_normal", "gradual_bar_low", "gradual_bar_super" };
// statwindow
// file stats.c line 104
static struct anonymous$71 statwindow;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// store_look
// file inventory.c line 47
struct _GtkTreeStore *store_look;
// store_metaserver
// file metaserver.c line 35
static struct _GtkListStore *store_metaserver;
// text_mark_cs
// file create_char.c line 62
static struct _GtkTextMark *text_mark_cs;
// text_mark_rs
// file create_char.c line 62
static struct _GtkTextMark *text_mark_rs;
// textbuf_motd
// file account.c line 79
struct _GtkTextBuffer *textbuf_motd;
// textbuf_news
// file account.c line 79
struct _GtkTextBuffer *textbuf_news;
// textbuf_rules_account
// file account.c line 79
struct _GtkTextBuffer *textbuf_rules_account;
// textbuf_rules_char
// file account.c line 80
struct _GtkTextBuffer *textbuf_rules_char;
// textbuf_starting_map
// file create_char.c line 68
struct _GtkTextBuffer *textbuf_starting_map;
// textview_cs_desc
// file create_char.c line 59
static struct _GtkWidget *textview_cs_desc;
// textview_rs_desc
// file create_char.c line 57
static struct _GtkWidget *textview_rs_desc;
// the_map
// file mapdata.c line 115
struct Map the_map;
// theme
// file config.c line 99
static char *theme = "Standard";
// themedir
// file config.c line 100
static char *themedir = "themes";
// tick
// file client.c line 62
unsigned int tick = (unsigned int)0;
// time_map_redraw
// file map.c line 67
signed int time_map_redraw = 0;
// timeout
// file main.c line 90
struct timeval timeout;
// treeview_choose_character
// file account.c line 50
static struct _GtkWidget *treeview_choose_character;
// treeview_look
// file inventory.c line 43
struct _GtkWidget *treeview_look;
// treeview_metaserver
// file metaserver.c line 33
static struct _GtkWidget *treeview_metaserver;
// updatekeycodes
// file main.c line 93
static unsigned char updatekeycodes = (unsigned char)0;
// use_config
// file init.c line 39
signed short int use_config[32l];
// used_classes
// file commands.c line 91
signed int used_classes = 0;
// used_races
// file commands.c line 88
signed int used_races = 0;
// usercolorname
// file main.c line 67
const char * const usercolorname[13l] = { "black", "white", "darkblue", "red", "orange", "lightblue", "darkorange", "green", "darkgreen", "grey", "brown", "yellow", "tan" };
// want_config
// file init.c line 39
signed short int want_config[32l];
// want_skill_exp
// file client.c line 57
signed int want_skill_exp = 0;
// wantloginmethod
// file client.c line 60
signed int wantloginmethod = 0;
// weight_limit
// file inventory.c line 48
static double weight_limit;
// width
// file opengl.c line 66
static signed int width = 1;
// width$link1
// file mapdata.c line 98
static signed int width$link1;
// window
// file opengl.c line 62
static unsigned long int window;
// window_root
// file main.c line 43
struct _GtkWidget *window_root;
// window_xml
// file main.c line 44
struct _GtkBuilder *window_xml;
// window_xml_file
// file main.c line 87
char window_xml_file[256l] = { 'g', 't', 'k', '-', 'v', '1', '.', 'u', 'i', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// window_xml_path
// file main.c line 88
char window_xml_path[256l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// xdg_cache_dir
// file client.c line 53
char *xdg_cache_dir;
// xdg_config_dir
// file client.c line 53
char *xdg_config_dir;

// AccountPlayersCmd
// file ./proto.h line 41
void AccountPlayersCmd(char *buf, signed int len)
{
  signed int level;
  signed int pos;
  signed int flen;
  signed int faceno;
  char name[256l];
  char class[256l];
  char race[256l];
  char face[256l];
  char party[256l];
  char AccountPlayersCmd$$1$$map[256l];
  choose_character_init();
  level = 0;
  name[(signed long int)0] = (char)0;
  class[(signed long int)0] = (char)0;
  race[(signed long int)0] = (char)0;
  face[(signed long int)0] = (char)0;
  party[(signed long int)0] = (char)0;
  AccountPlayersCmd$$1$$map[(signed long int)0] = (char)0;
  faceno = 0;
  pos = 1;
  signed short int return_value_GetShort_String$1;
  signed short int return_value_GetShort_String$2;
  while(!(pos >= len))
  {
    flen = (signed int)buf[(signed long int)pos];
    if(flen == 0)
    {
      update_character_choose(name, class, race, face, party, AccountPlayersCmd$$1$$map, level, faceno);
      level = 0;
      name[(signed long int)0] = (char)0;
      class[(signed long int)0] = (char)0;
      race[(signed long int)0] = (char)0;
      face[(signed long int)0] = (char)0;
      party[(signed long int)0] = (char)0;
      AccountPlayersCmd$$1$$map[(signed long int)0] = (char)0;
      faceno = 0;
      pos = pos + 1;
    }

    else
    {
      pos = pos + 1;
      if(flen >= 256 || !(len >= flen + pos))
      {
        LOG((enum LogLevel)LOG_ERROR, "commands.c:AccountPlayerCmd", "data overran buffer");
        goto __CPROVER_DUMP_L15;
      }

      switch((signed int)buf[(signed long int)pos])
      {
        case 1:
        {
          strncpy(name, buf + (signed long int)pos + (signed long int)1, (unsigned long int)(flen - 1));
          name[(signed long int)(flen - 1)] = (char)0;
          break;
        }
        case 2:
        {
          strncpy(class, buf + (signed long int)pos + (signed long int)1, (unsigned long int)(flen - 1));
          class[(signed long int)(flen - 1)] = (char)0;
          break;
        }
        case 3:
        {
          strncpy(race, buf + (signed long int)pos + (signed long int)1, (unsigned long int)(flen - 1));
          race[(signed long int)(flen - 1)] = (char)0;
          break;
        }
        case 5:
        {
          strncpy(face, buf + (signed long int)pos + (signed long int)1, (unsigned long int)(flen - 1));
          face[(signed long int)(flen - 1)] = (char)0;
          break;
        }
        case 6:
        {
          strncpy(party, buf + (signed long int)pos + (signed long int)1, (unsigned long int)(flen - 1));
          party[(signed long int)(flen - 1)] = (char)0;
          break;
        }
        case 7:
        {
          strncpy(AccountPlayersCmd$$1$$map, buf + (signed long int)pos + (signed long int)1, (unsigned long int)(flen - 1));
          AccountPlayersCmd$$1$$map[(signed long int)(flen - 1)] = (char)0;
          break;
        }
        case 4:
        {
          return_value_GetShort_String$1=GetShort_String((const unsigned char *)(buf + (signed long int)pos + (signed long int)1));
          level = (signed int)return_value_GetShort_String$1;
          break;
        }
        case 8:
        {
          return_value_GetShort_String$2=GetShort_String((const unsigned char *)(buf + (signed long int)pos + (signed long int)1));
          faceno = (signed int)return_value_GetShort_String$2;
        }
      }
      pos = pos + flen;
    }
  }

__CPROVER_DUMP_L15:
  ;
}

// AddMeFail
// file ./proto.h line 10
void AddMeFail(char *data, signed int len)
{
  (void)data;
  (void)len;
  LOG((enum LogLevel)LOG_INFO, "common::AddMeFail", "addme_failed received.");
}

// AddMeSuccess
// file ./proto.h line 11
void AddMeSuccess(char *data, signed int len)
{
  (void)data;
  (void)len;
  hide_all_login_windows();
  LOG((enum LogLevel)LOG_INFO, "common::AddMeSuccess", "addme_success received.");
}

// AddspellCmd
// file ./proto.h line 28
void AddspellCmd(unsigned char *data, signed int len)
{
  unsigned char nlen;
  unsigned short int mlen;
  unsigned short int pos = (unsigned short int)0;
  struct Spell_struct *newspell;
  struct Spell_struct *tmp;
  while(!((signed int)pos >= len))
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct Spell_struct) /*10560ul*/ );
    newspell = (struct Spell_struct *)return_value_calloc$1;
    signed int return_value_GetInt_String$2;
    return_value_GetInt_String$2=GetInt_String(data + (signed long int)pos);
    newspell->tag = (unsigned int)return_value_GetInt_String$2;
    pos = pos + (unsigned short int)4;
    signed short int return_value_GetShort_String$3;
    return_value_GetShort_String$3=GetShort_String(data + (signed long int)pos);
    newspell->level = (unsigned short int)return_value_GetShort_String$3;
    pos = pos + (unsigned short int)2;
    signed short int return_value_GetShort_String$4;
    return_value_GetShort_String$4=GetShort_String(data + (signed long int)pos);
    newspell->time = (unsigned short int)return_value_GetShort_String$4;
    pos = pos + (unsigned short int)2;
    signed short int return_value_GetShort_String$5;
    return_value_GetShort_String$5=GetShort_String(data + (signed long int)pos);
    newspell->sp = (unsigned short int)return_value_GetShort_String$5;
    pos = pos + (unsigned short int)2;
    signed short int return_value_GetShort_String$6;
    return_value_GetShort_String$6=GetShort_String(data + (signed long int)pos);
    newspell->grace = (unsigned short int)return_value_GetShort_String$6;
    pos = pos + (unsigned short int)2;
    signed short int return_value_GetShort_String$7;
    return_value_GetShort_String$7=GetShort_String(data + (signed long int)pos);
    newspell->dam = (unsigned short int)return_value_GetShort_String$7;
    pos = pos + (unsigned short int)2;
    char return_value_GetChar_String$8;
    return_value_GetChar_String$8=GetChar_String(data + (signed long int)pos);
    newspell->skill_number = (unsigned char)return_value_GetChar_String$8;
    pos = pos + (unsigned short int)1;
    signed int return_value_GetInt_String$9;
    return_value_GetInt_String$9=GetInt_String(data + (signed long int)pos);
    newspell->path = (unsigned int)return_value_GetInt_String$9;
    pos = pos + (unsigned short int)4;
    newspell->face=GetInt_String(data + (signed long int)pos);
    pos = pos + (unsigned short int)4;
    char return_value_GetChar_String$10;
    return_value_GetChar_String$10=GetChar_String(data + (signed long int)pos);
    nlen = (unsigned char)return_value_GetChar_String$10;
    pos = pos + (unsigned short int)1;
    strncpy(newspell->name, (char *)data + (signed long int)pos, (unsigned long int)nlen);
    pos = pos + (unsigned short int)nlen;
    newspell->name[(signed long int)nlen] = (char)0;
    signed short int return_value_GetShort_String$11;
    return_value_GetShort_String$11=GetShort_String(data + (signed long int)pos);
    mlen = (unsigned short int)return_value_GetShort_String$11;
    pos = pos + (unsigned short int)2;
    strncpy(newspell->message, (char *)data + (signed long int)pos, (unsigned long int)mlen);
    pos = pos + mlen;
    newspell->message[(signed long int)mlen] = (char)0;
    if(!(spellmon_level >= 2))
    {
      newspell->usage = (unsigned char)0;
      newspell->requirements[(signed long int)0] = (char)0;
    }

    else
      if(!((signed int)pos >= len))
      {
        char return_value_GetChar_String$12;
        return_value_GetChar_String$12=GetChar_String(data + (signed long int)pos);
        newspell->usage = (unsigned char)return_value_GetChar_String$12;
        pos = pos + (unsigned short int)1;
        char return_value_GetChar_String$13;
        return_value_GetChar_String$13=GetChar_String(data + (signed long int)pos);
        nlen = (unsigned char)return_value_GetChar_String$13;
        pos = pos + (unsigned short int)1;
        strncpy(newspell->requirements, (char *)data + (signed long int)pos, (unsigned long int)nlen);
        pos = pos + (unsigned short int)nlen;
        newspell->requirements[(signed long int)nlen] = (char)0;
      }

    newspell->skill = skill_names[(signed long int)((signed int)newspell->skill_number - 140)];
    if(cpl.spelldata == ((struct Spell_struct *)NULL))
      cpl.spelldata = newspell;

    else
    {
      tmp = cpl.spelldata;
      for( ; !(tmp->next == ((struct Spell_struct *)NULL)); tmp = tmp->next)
        ;
      tmp->next = newspell;
    }
  }
  if(!(len >= (signed int)pos))
    LOG((enum LogLevel)LOG_WARNING, "common::AddspellCmd", "Overread buffer: %d > %d", pos, len);

  cpl.spells_updated = (unsigned int)1;
}

// AnimCmd
// file ./proto.h line 13
void AnimCmd(unsigned char *data, signed int len)
{
  signed short int anum;
  signed int i;
  signed int j;
  anum=GetShort_String(data);
  if((signed int)anum >= 2001 || !((signed int)anum >= 0))
    LOG((enum LogLevel)LOG_WARNING, "common::AnimCmd", "animation number invalid: %d", anum);

  else
  {
    signed short int return_value_GetShort_String$1;
    return_value_GetShort_String$1=GetShort_String(data + (signed long int)2);
    animations[(signed long int)anum].flags = (unsigned short int)return_value_GetShort_String$1;
    animations[(signed long int)anum].num_animations = (unsigned char)((len - 4) / 2);
    if(!((signed int)animations[(signed long int)anum].num_animations >= 1))
      LOG((enum LogLevel)LOG_WARNING, "common::AnimCmd", "num animations invalid: %d", animations[(signed long int)anum].num_animations);

    else
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(sizeof(unsigned short int) /*2ul*/  * (unsigned long int)animations[(signed long int)anum].num_animations);
      animations[(signed long int)anum].faces = (unsigned short int *)return_value_malloc$2;
      i = 4;
      j = 0;
      for( ; !(i >= len); j = j + 1)
      {
        signed short int return_value_GetShort_String$3;
        return_value_GetShort_String$3=GetShort_String(data + (signed long int)i);
        animations[(signed long int)anum].faces[(signed long int)j] = (unsigned short int)return_value_GetShort_String$3;
        i = i + 2;
      }
      if(!(j == (signed int)animations[(signed long int)anum].num_animations))
        LOG((enum LogLevel)LOG_WARNING, "common::AnimCmd", "Calculated animations does not equal stored animations? (%d!=%d)", j, animations[(signed long int)anum].num_animations);

      animations[(signed long int)anum].speed = (unsigned char)0;
      animations[(signed long int)anum].speed_left = (unsigned char)0;
      animations[(signed long int)anum].phase = (unsigned char)0;
      LOG((enum LogLevel)LOG_DEBUG, "common::AnimCmd", "Received animation %d, %d faces", anum, animations[(signed long int)anum].num_animations);
    }
  }
}

// CompleteCmd
// file ./proto.h line 149
void CompleteCmd(unsigned char *data, signed int len)
{
  if(!(len == 6))
    LOG((enum LogLevel)LOG_ERROR, "common::CompleteCmd", "Invalid length %d - ignoring", len);

  else
  {
    signed short int return_value_GetShort_String$1;
    return_value_GetShort_String$1=GetShort_String(data);
    csocket.command_received = (signed int)return_value_GetShort_String$1;
    csocket.command_time=GetInt_String(data + (signed long int)2);
    script_sync(csocket.command_sent - csocket.command_received);
  }
}

// DeleteInventory
// file ./proto.h line 27
void DeleteInventory(unsigned char *data, signed int len)
{
  signed int tag;
  struct item_struct *op;
  (void)len;
  tag=atoi((const char *)data);
  op=locate_item(tag);
  if(!(op == ((struct item_struct *)NULL)))
    remove_item_inventory(op);

  else
    LOG((enum LogLevel)LOG_WARNING, "common::DeleteInventory", "Invalid tag: %d", tag);
}

// DeleteItem
// file ./proto.h line 26
void DeleteItem(unsigned char *data, signed int len)
{
  signed int pos = 0;
  signed int tag;
  while(!(pos >= len))
  {
    struct item_struct *op;
    tag=GetInt_String(data + (signed long int)pos);
    pos = pos + 4;
    op=locate_item(tag);
    if(!(op == ((struct item_struct *)NULL)))
      remove_item(op);

    else
      LOG((enum LogLevel)LOG_WARNING, "common::DeleteItem", "Cannot find tag %d", tag);
  }
  if(!(len >= pos))
    LOG((enum LogLevel)LOG_WARNING, "common::DeleteItem", "Overread buffer: %d > %d", pos, len);

}

// DeleteSpell
// file ./proto.h line 30
void DeleteSpell(unsigned char *data, signed int len)
{
  signed int tag;
  struct Spell_struct *tmp;
  struct Spell_struct *target;
  _Bool tmp_if_expr$1;
  if(cpl.spelldata == ((struct Spell_struct *)NULL))
    LOG((enum LogLevel)LOG_WARNING, "common::DeleteSpell", "I know no spells to delete");

  else
  {
    tag=GetInt_String(data);
    if(cpl.spelldata->tag == (unsigned int)tag)
    {
      target = cpl.spelldata;
      if(!(target->next == ((struct Spell_struct *)NULL)))
        cpl.spelldata = target->next;

      else
        cpl.spelldata = (struct Spell_struct *)(void *)0;
      free((void *)target);
    }

    else
    {
      tmp = cpl.spelldata;
      do
      {
        if(!(tmp->next == ((struct Spell_struct *)NULL)))
          tmp_if_expr$1 = tmp->next->tag != (unsigned int)tag ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$1 = (_Bool)0;
        if(!tmp_if_expr$1)
          break;

        tmp = tmp->next;
      }
      while((_Bool)1);
      if(tmp->next == ((struct Spell_struct *)NULL))
        LOG((enum LogLevel)LOG_WARNING, "common::DeleteSpell", "Invalid tag: %d", tag);

      else
      {
        target = tmp->next;
        if(!(target->next == ((struct Spell_struct *)NULL)))
          tmp->next = target->next;

        else
          tmp->next = (struct Spell_struct *)(void *)0;
        free((void *)target);
        cpl.spells_updated = (unsigned int)1;
      }
    }
  }
}

// DoClient
// file ../../common/proto.h line 2
void DoClient(struct ClientSocket *csocket)
{
  signed int i;
  signed int len;
  unsigned char *data;
  while((_Bool)1)
  {
    i=SockList_ReadPacket(csocket->fd, &csocket->inbuf, (2 + 65535 + 1) - 1);
    if(i == -1)
    {
      close_server_connection();
      goto __CPROVER_DUMP_L13;
    }

    if(i == 0)
      goto __CPROVER_DUMP_L13;

    csocket->inbuf.buf[(signed long int)csocket->inbuf.len] = (unsigned char)0;
    data = csocket->inbuf.buf + (signed long int)2;
    for( ; !((signed int)*data == 32); data = data + 1l)
      if((signed int)*data == 0)
        break;

    if((signed int)*data == 32)
    {
      *data = (unsigned char)0;
      data = data + 1l;
      len = (signed int)((signed long int)csocket->inbuf.len - (data - csocket->inbuf.buf));
    }

    else
      len = 0;
    i = 0;
    for( ; !(i >= 36); i = i + 1)
    {
      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp((char *)csocket->inbuf.buf + (signed long int)2, commands[(signed long int)i].cmdname);
      if(return_value_strcmp$1 == 0)
      {
        script_watch((char *)csocket->inbuf.buf + (signed long int)2, data, len, commands[(signed long int)i].cmdformat);
        commands[(signed long int)i].cmdproc(data, len);
        break;
      }

    }
    csocket->inbuf.len = 0;
    if(i == 36)
      printf("Unrecognized command from server (%s)\n", csocket->inbuf.buf + (signed long int)2);

  }

__CPROVER_DUMP_L13:
  ;
}

// DrawExtInfoCmd
// file ./proto.h line 17
void DrawExtInfoCmd(char *data, signed int len)
{
  signed int color;
  signed int type;
  signed int subtype;
  char *buf = data;
  signed int wordCount = 3;
  void (*fnct)(signed int, signed int, signed int, char *);
  while(wordCount >= 1)
  {
    for( ; (signed int)*buf == 32; buf = buf + 1l)
      ;
    wordCount = wordCount - 1;
    while(!((signed int)*buf == 32))
      if((signed int)*buf == 0)
      {
        LOG((enum LogLevel)LOG_WARNING, "common::DrawExtInfoCmd", "Data is missing %d parameters %s", wordCount, data);
        goto __CPROVER_DUMP_L12;
      }

      else
        buf = buf + 1l;
    if((signed int)*buf == 32)
      buf = buf + 1l;

  }
  wordCount=sscanf(data, "%d %d %d", &color, &type, &subtype);
  if(!(wordCount == 3))
    LOG((enum LogLevel)LOG_WARNING, "common::DrawExtInfoCmd", "Wrong parameters received. Could only parse %d out of 3 int in %s", wordCount, data);

  else
  {
    fnct=getTextManager(type);
    if(fnct == ((void (*)(signed int, signed int, signed int, char *))NULL))
      LOG((enum LogLevel)LOG_WARNING, "common::DrawExtInfoCmd", "Server send us a type %d but i can't find any callback for it", type);

    else
      fnct(color, type, subtype, buf);
  }

__CPROVER_DUMP_L12:
  ;
}

// DrawInfoCmd
// file ./proto.h line 15
void DrawInfoCmd(char *data, signed int len)
{
  signed int color;
  color=atoi(data);
  char *buf;
  (void)len;
  buf=strchr(data, 32);
  if(buf == ((char *)NULL))
  {
    LOG((enum LogLevel)LOG_WARNING, "common::DrawInfoCmd", "got no data");
    buf = "";
  }

  else
    buf = buf + 1l;
  draw_ext_info(color, 20, 3, buf);
}

// ExtSmooth
// file commands.c line 2207
signed int ExtSmooth(unsigned char *data, signed int len, signed int x, signed int y, signed int layer)
{
  signed int i;
  signed int rx;
  signed int ry;
  signed int newsm;
  if(!(len >= 1))
    return 0;

  else
  {
    x = x + pl_pos.x;
    y = y + pl_pos.y;
    char return_value_GetChar_String$1;
    return_value_GetChar_String$1=GetChar_String(data);
    newsm = (signed int)return_value_GetChar_String$1;
    if(!((signed int)(the_map.cells[(signed long int)x] + (signed long int)y)->smooth[(signed long int)layer] == newsm))
    {
      i = 0;
      for( ; !(i >= 8); i = i + 1)
      {
        static signed int ExtSmooth$$1$$dx[8l] = { 0, 1, 1, 1, 0, -1, -1, -1 };
        rx = x + ExtSmooth$$1$$dx[(signed long int)i];
        static signed int ExtSmooth$$1$$dy[8l] = { -1, -1, 0, 1, 1, 1, 0, -1 };
        ry = y + ExtSmooth$$1$$dy[(signed long int)i];
        if(!(rx >= the_map.x) && !(ry >= the_map.y) && rx >= 0 && ry >= 0)
          (the_map.cells[(signed long int)x] + (signed long int)y)->need_resmooth = (unsigned char)1;

      }
    }

    (the_map.cells[(signed long int)x] + (signed long int)y)->smooth[(signed long int)layer] = (unsigned short int)newsm;
    return 1;
  }
}

// Face2Cmd
// file ./proto.h line 48
void Face2Cmd(unsigned char *data, signed int len)
{
  signed int pnum;
  unsigned char setnum;
  unsigned int checksum;
  char *face;
  if(use_config[5l] == 0)
    LOG((enum LogLevel)LOG_WARNING, "common::Face2Cmd", "Received a 'face' command when we are not caching");

  else
  {
    signed short int return_value_GetShort_String$1;
    return_value_GetShort_String$1=GetShort_String(data);
    pnum = (signed int)return_value_GetShort_String$1;
    setnum = data[(signed long int)2];
    signed int return_value_GetInt_String$2;
    return_value_GetInt_String$2=GetInt_String(data + (signed long int)3);
    checksum = (unsigned int)return_value_GetInt_String$2;
    face = (char *)data + (signed long int)7;
    data[(signed long int)len] = (unsigned char)0;
    finish_face_cmd(pnum, checksum, 1, face, (signed int)setnum);
  }
}

// FailureCmd
// file ./proto.h line 40
void FailureCmd(char *buf, signed int len)
{
  char *cp;
  cp=strchr(buf, 32);
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(!(cp == ((char *)NULL)))
  {
    *cp = (char)0;
    cp = cp + 1l;
    signed int return_value_strcmp$5;
    return_value_strcmp$5=strcmp(buf, "accountlogin");
    if(return_value_strcmp$5 == 0)
      account_login_failure(cp);

    else
    {
      return_value_strcmp$4=strcmp(buf, "accountnew");
      if(return_value_strcmp$4 == 0)
        account_creation_failure(cp);

      else
      {
        return_value_strcmp$3=strcmp(buf, "accountaddplayer");
        if(return_value_strcmp$3 == 0)
          account_add_character_failure(cp);

        else
        {
          return_value_strcmp$2=strcmp(buf, "createplayer");
          if(return_value_strcmp$2 == 0)
            create_new_character_failure(cp);

          else
          {
            return_value_strcmp$1=strcmp(buf, "accountpw");
            if(return_value_strcmp$1 == 0)
              account_change_password_failure(cp);

            else
              LOG((enum LogLevel)LOG_ERROR, "common::FailureCmd", "Got a failure response we can not handle: %s:%s", buf, cp);
          }
        }
      }
    }
  }

}

// GetChar_String
// file ./proto.h line 127
char GetChar_String(const unsigned char *data)
{
  return (char)data[(signed long int)0];
}

// GetInt64_String
// file ./proto.h line 129
signed long int GetInt64_String(const unsigned char *data)
{
  return (signed long int)(((unsigned long int)data[(signed long int)0] << 56) + ((unsigned long int)data[(signed long int)1] << 48) + ((unsigned long int)data[(signed long int)2] << 40) + ((unsigned long int)data[(signed long int)3] << 32) + ((unsigned long int)data[(signed long int)4] << 24) + (unsigned long int)((signed int)data[(signed long int)5] << 16) + (unsigned long int)((signed int)data[(signed long int)6] << 8) + (unsigned long int)data[(signed long int)7]);
}

// GetInt_String
// file ./proto.h line 128
signed int GetInt_String(const unsigned char *data)
{
  return ((signed int)data[(signed long int)0] << 24) + ((signed int)data[(signed long int)1] << 16) + ((signed int)data[(signed long int)2] << 8) + (signed int)data[(signed long int)3];
}

// GetShort_String
// file ./proto.h line 130
signed short int GetShort_String(const unsigned char *data)
{
  return (signed short int)(((signed int)data[(signed long int)0] << 8) + (signed int)data[(signed long int)1]);
}

// GoodbyeCmd
// file ./proto.h line 12
void GoodbyeCmd(char *data, signed int len)
{
  (void)data;
  (void)len;
  LOG((enum LogLevel)LOG_WARNING, "common::GoodbyeCmd", "Received goodbye command from server - exiting");
  exit(0);
}

// Image2Cmd
// file ./proto.h line 49
void Image2Cmd(unsigned char *data, signed int len)
{
  signed int pnum;
  signed int plen;
  unsigned char setnum;
  pnum=GetInt_String(data);
  setnum = data[(signed long int)4];
  plen=GetInt_String(data + (signed long int)5);
  if(!(len + -9 == plen) || !(len >= 9))
    LOG((enum LogLevel)LOG_WARNING, "common::Image2Cmd", "Lengths don't compare (%d,%d)", len - 9, plen);

  else
    display_newpng(pnum, data + (signed long int)9, plen, (signed int)setnum);
}

// Item2Cmd
// file ./proto.h line 24
void Item2Cmd(unsigned char *data, signed int len)
{
  common_item_command(data, len);
}

// LOG
// file ../../common/proto.h line 114
void LOG(enum LogLevel level, const char *origin, const char *format, ...)
{
  void **ap;
  char buf[20480l];
  if((signed int)level >= MINLOG)
  {
    ap = (void **)&format;
    vsnprintf(buf, sizeof(char [20480l]) /*20480ul*/ , format, ap);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(buf);
    if(return_value_strlen$2 >= 1ul)
    {
      const char *return_value_getLogLevelText$1;
      return_value_getLogLevelText$1=getLogLevelText(level);
      fprintf(stderr, "[%s] (%s) %s\n", return_value_getLogLevelText$1, origin, (const void *)buf);
    }

    ap = ((void **)NULL);
  }

}

// MagicMapCmd
// file ./proto.h line 36
void MagicMapCmd(unsigned char *data, signed int len)
{
  unsigned char *cp;
  signed int i;
  signed int return_value_sscanf$1;
  return_value_sscanf$1=sscanf((const char *)data, "%hd %hd %hd %hd", &cpl.mmapx, &cpl.mmapy, &cpl.pmapx, &cpl.pmapy);
  if(!(return_value_sscanf$1 == 4))
    LOG((enum LogLevel)LOG_WARNING, "common::MagicMapCmd", "Was not able to properly extract magic map size, pos");

  else
    if((signed int)cpl.mmapx == 0 || (signed int)cpl.mmapy == 0)
      LOG((enum LogLevel)LOG_WARNING, "common::MagicMapCmd", "empty map");

    else
    {
      cp = data;
      i = 0;
      for( ; !(cp >= data + (signed long int)len) && !(i >= 4); cp = cp + 1l)
        if((signed int)*cp == 32)
          i = i + 1;

      if(!(i == 4))
        LOG((enum LogLevel)LOG_WARNING, "common::MagicMapCmd", "Was unable to find start of magic map data");

      else
      {
        i = (signed int)((signed long int)len - (cp - data));
        if(!(i == (signed int)cpl.mmapx * (signed int)cpl.mmapy))
          LOG((enum LogLevel)LOG_WARNING, "common::MagicMapCmd", "Magic map size mismatch.  Have %d bytes, should have %d", i, (signed int)cpl.mmapx * (signed int)cpl.mmapy);

        else
        {
          free((void *)cpl.magicmap);
          void *return_value_malloc$2;
          return_value_malloc$2=malloc((unsigned long int)((signed int)cpl.mmapx * (signed int)cpl.mmapy));
          cpl.magicmap = (unsigned char *)return_value_malloc$2;
          memcpy((void *)cpl.magicmap, (const void *)cp, (unsigned long int)((signed int)cpl.mmapx * (signed int)cpl.mmapy));
          cpl.showmagic = (unsigned char)1;
          draw_magic_map();
        }
      }
    }
}

// Map2Cmd
// file ./proto.h line 32
void Map2Cmd(unsigned char *data, signed int len)
{
  signed int mask;
  signed int x;
  signed int y;
  signed int pos = 0;
  signed int space_len;
  signed int value;
  unsigned char type;
  display_map_startupdate();
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$5;
  signed int tmp_post$6;
  while(!(pos >= len))
  {
    signed short int return_value_GetShort_String$1;
    return_value_GetShort_String$1=GetShort_String(data + (signed long int)pos);
    mask = (signed int)return_value_GetShort_String$1;
    pos = pos + 2;
    x = (mask >> 10 & 0x3f) - 15;
    y = (mask >> 4 & 0x3f) - 15;
    if(!((0x1 & mask) == 0))
      mapdata_scroll(x, y);

    else
    {
      if(!(x >= 0))
      {
        LOG((enum LogLevel)LOG_WARNING, "commands.c::Map2Cmd", "got negative x!");
        x = 0;
      }

      else
        if(x >= 64)
        {
          LOG((enum LogLevel)LOG_WARNING, "commands.c::Map2Cmd", "got x >= MAX_VIEW!");
          x = 64 - 1;
        }

      if(!(y >= 0))
      {
        LOG((enum LogLevel)LOG_WARNING, "commands.c::Map2Cmd", "got negative y!");
        y = 0;
      }

      else
        if(y >= 64)
        {
          LOG((enum LogLevel)LOG_WARNING, "commands.c::Map2Cmd", "got y >= MAX_VIEW!");
          y = 64 - 1;
        }

      /* assertion 0 <= x && x < 64 */
      assert(0 <= x && x < 64);
      /* assertion 0 <= y && y < 64 */
      assert(0 <= y && y < 64);
      mapdata_clear_old(x, y);
      while(!(pos >= len))
      {
        tmp_post$2 = pos;
        pos = pos + 1;
        type = data[(signed long int)tmp_post$2];
        if((signed int)type == 255)
        {
          mapdata_set_check_space(x, y);
          break;
        }

        space_len = (signed int)type >> 5;
        type = type & (unsigned char)0x1f;
        if((signed int)type == 0x0)
        {
          mapdata_clear_space(x, y);
          continue;
        }

        else
          if((signed int)type == 0x1)
          {
            tmp_post$3 = pos;
            pos = pos + 1;
            value = (signed int)data[(signed long int)tmp_post$3];
            mapdata_set_darkness(x, y, value);
            continue;
          }

          else
            if((signed int)type >= 0x10 && !((signed int)type >= 10))
            {
              signed int layer;
              signed int opt;
              layer = (signed int)type & 0xf;
              if(!(layer >= 0))
              {
                LOG((enum LogLevel)LOG_WARNING, "commands.c::Map2Cmd", "got negative layer!");
                layer = 0;
              }

              else
                if(layer >= 10)
                {
                  LOG((enum LogLevel)LOG_WARNING, "commands.c::Map2Cmd", "got layer >= MAXLAYERS!");
                  layer = 10 - 1;
                }

              /* assertion 0 <= layer && layer < 10 */
              assert(0 <= layer && layer < 10);
              signed short int return_value_GetShort_String$4;
              return_value_GetShort_String$4=GetShort_String(data + (signed long int)pos);
              value = (signed int)return_value_GetShort_String$4;
              pos = pos + 2;
              if((32768 & value) == 0)
                mapdata_set_face_layer(x, y, (signed short int)value, layer);

              if(space_len >= 3)
              {
                tmp_post$5 = pos;
                pos = pos + 1;
                opt = (signed int)data[(signed long int)tmp_post$5];
                if(!((32768 & value) == 0))
                  mapdata_set_anim_layer(x, y, (unsigned short int)value, (unsigned char)opt, layer);

                else
                  mapdata_set_smooth(x, y, opt, layer);
              }

              if(space_len >= 4)
              {
                tmp_post$6 = pos;
                pos = pos + 1;
                opt = (signed int)data[(signed long int)tmp_post$6];
                mapdata_set_smooth(x, y, opt, layer);
              }

            }

      }
    }
  }
  mapupdatesent = 0;
  display_map_doneupdate(0, 0);
}

// MapExtendedCmd
// file ./proto.h line 35
void MapExtendedCmd(unsigned char *data, signed int len)
{
  signed int mask;
  signed int x;
  signed int y;
  signed int pos = 0;
  signed int layer;
  signed int noredraw = 0;
  signed int hassmooth = 0;
  signed int entrysize;
  signed int startpackentry;
  if(mapupdatesent == 0)
    display_map_startupdate();

  mapupdatesent = 1;
  char return_value_GetChar_String$1;
  return_value_GetChar_String$1=GetChar_String(data + (signed long int)pos);
  mask = (signed int)return_value_GetChar_String$1;
  pos = pos + 1;
  if(!((0x01 & mask) == 0))
    noredraw = 1;

  if(!((0x02 & mask) == 0))
    hassmooth = 1;

  while(!((0x80 & mask) == 0))
  {
    char return_value_GetChar_String$2;
    return_value_GetChar_String$2=GetChar_String(data + (signed long int)pos);
    mask = (signed int)return_value_GetChar_String$2;
    pos = pos + 1;
  }
  char return_value_GetChar_String$3;
  return_value_GetChar_String$3=GetChar_String(data + (signed long int)pos);
  entrysize = (signed int)return_value_GetChar_String$3;
  pos = pos + 1;
  while(len >= 2 + entrysize + pos)
  {
    signed short int return_value_GetShort_String$4;
    return_value_GetShort_String$4=GetShort_String(data + (signed long int)pos);
    mask = (signed int)return_value_GetShort_String$4;
    pos = pos + 2;
    x = mask >> 10 & 0x3f;
    y = mask >> 4 & 0x3f;
    layer = 3 - 1;
    for( ; layer >= 0; layer = layer - 1)
      if(!((1 << layer & mask) == 0))
      {
        if(!(len >= entrysize + pos))
          break;

        startpackentry = pos;
        if(!(hassmooth == 0))
        {
          signed int return_value_ExtSmooth$5;
          return_value_ExtSmooth$5=ExtSmooth(data + (signed long int)pos, len - pos, x, y, (3 - 1) - layer);
          pos = pos + return_value_ExtSmooth$5;
        }

        pos = startpackentry + entrysize;
      }

  }
  if(noredraw == 0)
  {
    display_map_doneupdate(0, 0);
    mapupdatesent = 0;
  }

}

// MusicCmd
// file sound.c line 237
void MusicCmd(const char *data, signed int len)
{
  _Bool tmp_if_expr$4;
  signed int return_value_fflush$3;
  if(!(use_config[13l] == 0))
  {
    if(!(data[(signed long int)len] == 0))
      LOG((enum LogLevel)LOG_ERROR, "gtk-v2::MusicCmd", "Music command string is not null-terminated.");

    else
    {
      signed int return_value_fprintf$2;
      return_value_fprintf$2=fprintf(sound_pipe, "\"%s\"\n", data);
      if(!(return_value_fprintf$2 >= 1))
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        return_value_fflush$3=fflush(sound_pipe);
        tmp_if_expr$4 = return_value_fflush$3 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$4)
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        LOG((enum LogLevel)LOG_ERROR, "gtk-v2::MusicCmd", "Cannot write sound pipe: %d", *return_value___errno_location$1);
        use_config[(signed long int)13] = (signed short int)0;
        fclose(sound_pipe);
        sound_process = (struct ChildProcess *)(void *)0;
        goto __CPROVER_DUMP_L6;
      }

      else
        LOG((enum LogLevel)LOG_DEBUG, "gtk-v2::MusicCmd", "\"%s\"", data);
    }
  }


__CPROVER_DUMP_L6:
  ;
}

// NewmapCmd
// file ./proto.h line 31
void NewmapCmd(unsigned char *data, signed int len)
{
  (void)data;
  (void)len;
  mapdata_newmap();
}

// PickupCmd
// file ./proto.h line 39
void PickupCmd(unsigned char *data, signed int len)
{
  unsigned int pickup;
  signed int return_value_GetInt_String$1;
  return_value_GetInt_String$1=GetInt_String(data);
  pickup = (unsigned int)return_value_GetInt_String$1;
  client_pickup(pickup);
}

// PlayerCmd
// file ./proto.h line 22
void PlayerCmd(unsigned char *data, signed int len)
{
  char name[256l];
  signed int tag;
  signed int weight;
  signed int face;
  signed int i = 0;
  signed int nlen;
  reset_player_data();
  tag=GetInt_String(data);
  i = i + 4;
  weight=GetInt_String(data + (signed long int)i);
  i = i + 4;
  face=GetInt_String(data + (signed long int)i);
  i = i + 4;
  signed int tmp_post$1 = i;
  i = i + 1;
  nlen = (signed int)data[(signed long int)tmp_post$1];
  memcpy((void *)name, (const void *)((const char *)data + (signed long int)i), (unsigned long int)nlen);
  name[(signed long int)nlen] = (char)0;
  i = i + nlen;
  if(!(i == len))
    LOG((enum LogLevel)LOG_WARNING, "common::PlayerCmd", "lengths do not match (%d!=%d)", len, i);

  new_player((signed long int)tag, name, (signed long int)weight, (signed long int)face);
}

// ReplyInfoCmd
// file ./proto.h line 7
void ReplyInfoCmd(unsigned char *buf, signed int len)
{
  unsigned char *cp;
  signed int i;
  _Bool tmp_if_expr$1;
  unsigned char *tmp_post$2;
  signed int return_value_strcmp$18;
  signed int return_value_strcmp$17;
  signed int return_value_strcmp$16;
  signed int return_value_strcmp$15;
  signed int return_value_strcmp$14;
  signed int return_value_strcmp$13;
  signed int return_value_strcmp$12;
  unsigned char *tmp_post$3;
  signed int return_value_strcmp$11;
  unsigned char *tmp_post$5;
  signed int return_value_strcmp$10;
  signed int return_value_strcmp$9;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$7;
  if(!(buf == ((unsigned char *)NULL)))
  {
    i = 0;
    for( ; !(i >= len); i = i + 1)
    {
      if((signed int)buf[(signed long int)i] == 32)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)buf[(signed long int)i] == 10 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        break;

    }
    if(i >= len)
      LOG((enum LogLevel)LOG_DEBUG, "common::ReplyInfoCmd", "Never found a space in the replyinfo");

    else
    {
      cp = buf + (signed long int)i;
      tmp_post$2 = cp;
      cp = cp + 1l;
      *tmp_post$2 = (unsigned char)0;
      signed int return_value_strcmp$19;
      return_value_strcmp$19=strcmp((char *)buf, "image_info");
      if(return_value_strcmp$19 == 0)
        get_image_info(cp, (len - i) - 1);

      else
      {
        return_value_strcmp$18=strcmp((char *)buf, "image_sums");
        if(return_value_strcmp$18 == 0)
          get_image_sums((char *)cp, (len - i) - 1);

        else
        {
          return_value_strcmp$17=strcmp((char *)buf, "skill_info");
          if(return_value_strcmp$17 == 0)
            get_skill_info((char *)cp, (len - i) - 1);

          else
          {
            return_value_strcmp$16=strcmp((char *)buf, "exp_table");
            if(return_value_strcmp$16 == 0)
              get_exp_info(cp, (len - i) - 1);

            else
            {
              return_value_strcmp$15=strcmp((char *)buf, "motd");
              if(return_value_strcmp$15 == 0)
              {
                if(!(motd == ((char *)NULL)))
                  free((void *)(char *)motd);

                motd=strdup((const char *)cp);
                update_login_info(2);
              }

              else
              {
                return_value_strcmp$14=strcmp((char *)buf, "news");
                if(return_value_strcmp$14 == 0)
                {
                  if(!(news == ((char *)NULL)))
                    free((void *)(char *)news);

                  news=strdup((const char *)cp);
                  update_login_info(1);
                }

                else
                {
                  return_value_strcmp$13=strcmp((char *)buf, "rules");
                  if(return_value_strcmp$13 == 0)
                  {
                    if(!(rules == ((char *)NULL)))
                      free((void *)(char *)rules);

                    rules=strdup((const char *)cp);
                    update_login_info(3);
                  }

                  else
                  {
                    return_value_strcmp$12=strcmp((char *)buf, "race_list");
                    if(return_value_strcmp$12 == 0)
                    {
                      char *cp1 = (char *)cp;
                      for( ; !((signed int)*cp == 0); cp = cp + 1l)
                        if((signed int)*cp == 124)
                        {
                          tmp_post$3 = cp;
                          cp = cp + 1l;
                          *tmp_post$3 = (unsigned char)0;
                          if(!((signed int)*cp1 == 0))
                          {
                            cs_print_string(csocket.fd, "requestinfo race_info %s", cp1);
                            num_races = num_races + 1;
                          }

                          cp1 = (char *)cp;
                        }

                      if(!((signed int)*cp1 == 0))
                      {
                        cs_print_string(csocket.fd, "requestinfo race_info %s", cp1);
                        num_races = num_races + 1;
                      }

                      if(!(races == ((struct Race_Class_Info *)NULL)))
                      {
                        free_all_race_class_info(races, num_races);
                        num_races = 0;
                        used_races = 0;
                      }

                      void *return_value_calloc$4;
                      return_value_calloc$4=calloc((unsigned long int)num_races, sizeof(struct Race_Class_Info) /*48ul*/ );
                      races = (struct Race_Class_Info *)return_value_calloc$4;
                    }

                    else
                    {
                      return_value_strcmp$11=strcmp((char *)buf, "class_list");
                      if(return_value_strcmp$11 == 0)
                      {
                        char *ReplyInfoCmd$$1$$12$$cp1 = (char *)cp;
                        for( ; !((signed int)*cp == 0); cp = cp + 1l)
                          if((signed int)*cp == 124)
                          {
                            tmp_post$5 = cp;
                            cp = cp + 1l;
                            *tmp_post$5 = (unsigned char)0;
                            if(!((signed int)*ReplyInfoCmd$$1$$12$$cp1 == 0))
                            {
                              cs_print_string(csocket.fd, "requestinfo class_info %s", ReplyInfoCmd$$1$$12$$cp1);
                              num_classes = num_classes + 1;
                            }

                            ReplyInfoCmd$$1$$12$$cp1 = (char *)cp;
                          }

                        if(!((signed int)*ReplyInfoCmd$$1$$12$$cp1 == 0))
                        {
                          cs_print_string(csocket.fd, "requestinfo class_info %s", ReplyInfoCmd$$1$$12$$cp1);
                          num_classes = num_classes + 1;
                        }

                        if(!(classes == ((struct Race_Class_Info *)NULL)))
                        {
                          free_all_race_class_info(classes, num_classes);
                          num_classes = 0;
                          used_classes = 0;
                        }

                        void *return_value_calloc$6;
                        return_value_calloc$6=calloc((unsigned long int)num_classes, sizeof(struct Race_Class_Info) /*48ul*/ );
                        classes = (struct Race_Class_Info *)return_value_calloc$6;
                      }

                      else
                      {
                        return_value_strcmp$10=strcmp((char *)buf, "race_info");
                        if(return_value_strcmp$10 == 0)
                          get_race_info((char *)cp, (len - i) - 1);

                        else
                        {
                          return_value_strcmp$9=strcmp((char *)buf, "class_info");
                          if(return_value_strcmp$9 == 0)
                            get_class_info((char *)cp, (len - i) - 1);

                          else
                          {
                            return_value_strcmp$8=strcmp((char *)buf, "newcharinfo");
                            if(return_value_strcmp$8 == 0)
                              get_new_char_info((char *)cp, (len - i) - 1);

                            else
                            {
                              return_value_strcmp$7=strcmp((char *)buf, "startingmap");
                              if(return_value_strcmp$7 == 0)
                                get_starting_map_info((char *)cp, (len - i) - 1);

                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

}

// SendAddMe
// file ./proto.h line 56
void SendAddMe(struct ClientSocket csock)
{
  cs_print_string(csock.fd, "addme");
}

// SendVersion
// file ./proto.h line 55
void SendVersion(struct ClientSocket csock)
{
  cs_print_string(csock.fd, "version %d %d %s", 1023, 1029, (const void *)VERSION_INFO);
}

// SetupCmd
// file ./proto.h line 8
void SetupCmd(char *buf, signed int len)
{
  signed int s;
  char *cmd;
  char *param;
  LOG((enum LogLevel)LOG_DEBUG, "common::SetupCmd", "%s", buf);
  s = 0;
  _Bool tmp_if_expr$1;
  signed int tmp_post$2;
  _Bool tmp_if_expr$3;
  signed int tmp_post$4;
  signed int return_value_strcmp$22;
  signed int return_value_strcmp$21;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$7;
  signed int return_value_strcmp$20;
  signed int return_value_strcmp$19;
  signed int return_value_strcmp$18;
  signed int return_value_strcmp$17;
  signed int return_value_strcmp$16;
  signed int return_value_strcmp$15;
  signed int return_value_strcmp$14;
  while(!(s >= len))
  {
    cmd = &buf[(signed long int)s];
    do
    {
      if(!(buf[(signed long int)s] == 0))
        tmp_if_expr$1 = (signed int)buf[(signed long int)s] != 32 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(!tmp_if_expr$1)
        break;

      s = s + 1;
    }
    while((_Bool)1);
    tmp_post$2 = s;
    s = s + 1;
    buf[(signed long int)tmp_post$2] = (char)0;
    for( ; (signed int)buf[(signed long int)s] == 32; s = s + 1)
      ;
    if(s >= len)
      break;

    param = &buf[(signed long int)s];
    do
    {
      if(!(buf[(signed long int)s] == 0))
        tmp_if_expr$3 = (signed int)buf[(signed long int)s] != 32 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(!tmp_if_expr$3)
        break;

      s = s + 1;
    }
    while((_Bool)1);
    tmp_post$4 = s;
    s = s + 1;
    buf[(signed long int)tmp_post$4] = (char)0;
    for( ; !(s >= len); s = s + 1)
      if(!((signed int)buf[(signed long int)s] == 32))
        break;

    signed int return_value_strcmp$23;
    return_value_strcmp$23=strcmp(cmd, "sound2");
    if(!(return_value_strcmp$23 == 0))
    {
      return_value_strcmp$22=strcmp(cmd, "sound");
      if(!(return_value_strcmp$22 == 0))
      {
        return_value_strcmp$21=strcmp(cmd, "mapsize");
        if(return_value_strcmp$21 == 0)
        {
          signed int x;
          signed int y = 0;
          char *cp;
          char tmpbuf[256l];
          signed int return_value_strcasecmp$5;
          return_value_strcasecmp$5=strcasecmp(param, "false");
          if(return_value_strcasecmp$5 == 0)
          {
            draw_ext_info(3, 20, 2, "Server only supports standard sized maps (11x11)");
            use_config[(signed long int)19] = (signed short int)11;
            use_config[(signed long int)20] = (signed short int)11;
            mapdata_set_size((signed int)use_config[(signed long int)19], (signed int)use_config[(signed long int)20]);
            resize_map_window((signed int)use_config[(signed long int)19], (signed int)use_config[(signed long int)20]);
            continue;
          }

          x=atoi(param);
          cp = param;
          for( ; !((signed int)*cp == 0); cp = cp + 1l)
          {
            if((signed int)*cp == 120)
              tmp_if_expr$6 = (_Bool)1;

            else
              tmp_if_expr$6 = (signed int)*cp == 88 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$6)
            {
              y=atoi(cp + (signed long int)1);
              break;
            }

          }
          if(!(x >= (signed int)use_config[19l]))
            tmp_if_expr$8 = (_Bool)1;

          else
            tmp_if_expr$8 = (signed int)use_config[(signed long int)20] > y ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$8)
          {
            if(!(x >= (signed int)use_config[19l]))
              use_config[(signed long int)19] = (signed short int)x;

            if(!(y >= (signed int)use_config[20l]))
              use_config[(signed long int)20] = (signed short int)y;

            mapdata_set_size((signed int)use_config[(signed long int)19], (signed int)use_config[(signed long int)20]);
            cs_print_string(csocket.fd, "setup mapsize %dx%d", use_config[(signed long int)19], use_config[(signed long int)20]);
            snprintf(tmpbuf, sizeof(char [256l]) /*256ul*/ , "Server supports a max mapsize of %d x %d - requesting a %d x %d mapsize", x, y, use_config[(signed long int)19], use_config[(signed long int)20]);
            draw_ext_info(3, 20, 2, tmpbuf);
          }

          else
          {
            if((signed int)use_config[19l] == x)
              tmp_if_expr$7 = (signed int)use_config[(signed long int)20] == y ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$7 = (_Bool)0;
            if(tmp_if_expr$7)
            {
              mapdata_set_size((signed int)use_config[(signed long int)19], (signed int)use_config[(signed long int)20]);
              resize_map_window((signed int)use_config[(signed long int)19], (signed int)use_config[(signed long int)20]);
            }

            else
            {
              snprintf(tmpbuf, sizeof(char [256l]) /*256ul*/ , "Unable to set mapsize on server - we wanted %d x %d, server returned %d x %d", use_config[(signed long int)19], use_config[(signed long int)20], x, y);
              draw_ext_info(3, 20, 2, tmpbuf);
            }
          }
        }

        else
        {
          return_value_strcmp$20=strcmp(cmd, "darkness");
          if(return_value_strcmp$20 == 0)
          {
            signed int return_value_strcmp$9;
            return_value_strcmp$9=strcmp(param, "FALSE");
            if(return_value_strcmp$9 == 0)
              LOG((enum LogLevel)LOG_WARNING, "common::SetupCmd", "Server returned FALSE for setup command %s", cmd);

          }

          else
          {
            return_value_strcmp$19=strcmp(cmd, "spellmon");
            if(return_value_strcmp$19 == 0)
            {
              signed int return_value_strcmp$10;
              return_value_strcmp$10=strcmp(param, "FALSE");
              if(return_value_strcmp$10 == 0)
                LOG((enum LogLevel)LOG_INFO, "common::SetupCmd", "Server returned FALSE for a %s setup command", cmd);

              else
                spellmon_level=atoi(param);
            }

            else
            {
              return_value_strcmp$18=strcmp(cmd, "facecache");
              if(return_value_strcmp$18 == 0)
              {
                signed int return_value_atoi$11;
                return_value_atoi$11=atoi(param);
                use_config[(signed long int)5] = (signed short int)return_value_atoi$11;
              }

              else
              {
                return_value_strcmp$17=strcmp(cmd, "faceset");
                if(return_value_strcmp$17 == 0)
                {
                  signed int return_value_strcmp$12;
                  return_value_strcmp$12=strcmp(param, "FALSE");
                  if(return_value_strcmp$12 == 0)
                  {
                    draw_ext_info(3, 20, 2, "Server does not support other image sets, will use default");
                    face_info.faceset = (unsigned char)0;
                  }

                }

                else
                {
                  return_value_strcmp$16=strcmp(cmd, "map2cmd");
                  if(return_value_strcmp$16 == 0)
                  {
                    signed int return_value_strcmp$13;
                    return_value_strcmp$13=strcmp(param, "FALSE");
                    if(return_value_strcmp$13 == 0)
                    {
                      draw_ext_info(3, 20, 2, "Server does not support map2cmd!");
                      draw_ext_info(3, 20, 2, "This server is too old to support this client!");
                      close_server_connection();
                    }

                  }

                  else
                  {
                    return_value_strcmp$15=strcmp(cmd, "want_pickup");
                    if(!(return_value_strcmp$15 == 0))
                    {
                      return_value_strcmp$14=strcmp(cmd, "loginmethod");
                      if(return_value_strcmp$14 == 0)
                      {
                        signed int method;
                        method=atoi(param);
                        if(!(method == 0))
                          start_login(method);

                      }

                      else
                        LOG((enum LogLevel)LOG_INFO, "common::SetupCmd", "Got setup for a command we don't understand: %s %s", cmd, param);
                    }

                  }
                }
              }
            }
          }
        }
      }

    }

  }
}

// SinkCmd
// file ./proto.h line 37
void SinkCmd(unsigned char *data, signed int len)
{
  ;
}

// SmoothCmd
// file ./proto.h line 14
void SmoothCmd(unsigned char *data, signed int len)
{
  unsigned short int faceid;
  unsigned short int smoothing;
  signed short int return_value_GetShort_String$1;
  return_value_GetShort_String$1=GetShort_String(data);
  faceid = (unsigned short int)return_value_GetShort_String$1;
  signed short int return_value_GetShort_String$2;
  return_value_GetShort_String$2=GetShort_String(data + (signed long int)2);
  smoothing = (unsigned short int)return_value_GetShort_String$2;
  addsmooth(faceid, smoothing);
}

// SockList_AddChar
// file ../../common/proto.h line 122
void SockList_AddChar(struct SockList *sl, char c)
{
  signed int tmp_post$1 = sl->len;
  sl->len = sl->len + 1;
  sl->buf[(signed long int)tmp_post$1] = (unsigned char)c;
}

// SockList_AddInt
// file ./proto.h line 124
void SockList_AddInt(struct SockList *sl, unsigned int data)
{
  signed int tmp_post$1 = sl->len;
  sl->len = sl->len + 1;
  sl->buf[(signed long int)tmp_post$1] = (unsigned char)(data >> 24 & (unsigned int)0xff);
  signed int tmp_post$2 = sl->len;
  sl->len = sl->len + 1;
  sl->buf[(signed long int)tmp_post$2] = (unsigned char)(data >> 16 & (unsigned int)0xff);
  signed int tmp_post$3 = sl->len;
  sl->len = sl->len + 1;
  sl->buf[(signed long int)tmp_post$3] = (unsigned char)(data >> 8 & (unsigned int)0xff);
  signed int tmp_post$4 = sl->len;
  sl->len = sl->len + 1;
  sl->buf[(signed long int)tmp_post$4] = (unsigned char)(data & (unsigned int)0xff);
}

// SockList_AddShort
// file newsocket.c line 110
void SockList_AddShort(struct SockList *sl, unsigned short int data)
{
  signed int tmp_post$1 = sl->len;
  sl->len = sl->len + 1;
  sl->buf[(signed long int)tmp_post$1] = (unsigned char)((signed int)data >> 8 & 0xff);
  signed int tmp_post$2 = sl->len;
  sl->len = sl->len + 1;
  sl->buf[(signed long int)tmp_post$2] = (unsigned char)((signed int)data & 0xff);
}

// SockList_AddString
// file ../../common/proto.h line 125
void SockList_AddString(struct SockList *sl, const char *str)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  len = (signed int)return_value_strlen$1;
  if(sl->len + len >= 255)
    len = (256 - 2) - sl->len;

  memcpy((void *)(sl->buf + (signed long int)sl->len), (const void *)str, (unsigned long int)len);
  sl->len = sl->len + len;
}

// SockList_Init
// file ../../common/proto.h line 121
void SockList_Init(struct SockList *sl, unsigned char *buf)
{
  sl->len = 0;
  sl->buf = buf + (signed long int)2;
}

// SockList_ReadPacket
// file ./proto.h line 131
signed int SockList_ReadPacket(signed int fd, struct SockList *sl, signed int len)
{
  signed int SockList_ReadPacket$$1$$stat;
  signed int toread;
  _Bool tmp_if_expr$2;
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$5;
  if(!(sl->len >= 2))
  {
    do
    {
      signed long int return_value_read$3;
      return_value_read$3=read(fd, (void *)(sl->buf + (signed long int)sl->len), (unsigned long int)(2 - sl->len));
      SockList_ReadPacket$$1$$stat = (signed int)return_value_read$3;
      if(SockList_ReadPacket$$1$$stat == -1)
      {
        return_value___errno_location$1=__errno_location();
        tmp_if_expr$2 = *return_value___errno_location$1 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
    }
    while(tmp_if_expr$2);
    if(!(SockList_ReadPacket$$1$$stat >= 0))
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      if(!(*return_value___errno_location$6 == 11))
      {
        return_value___errno_location$5=__errno_location();
        if(!(*return_value___errno_location$5 == 11))
        {
          perror("ReadPacket got an error.");
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          LOG((enum LogLevel)LOG_DEBUG, "SockList_ReadPacket", "ReadPacket got error %d, returning -1", *return_value___errno_location$4);
          return -1;
        }

      }

      return 0;
    }

    if(SockList_ReadPacket$$1$$stat == 0)
      return -1;

    sl->len = sl->len + SockList_ReadPacket$$1$$stat;
    if(!(SockList_ReadPacket$$1$$stat >= 2))
      return 0;

  }

  toread = (2 + ((signed int)sl->buf[(signed long int)0] << 8) + (signed int)sl->buf[(signed long int)1]) - sl->len;
  _Bool tmp_if_expr$8;
  signed int *return_value___errno_location$7;
  signed int *return_value___errno_location$11;
  if(!(len >= sl->len + toread))
  {
    LOG((enum LogLevel)LOG_ERROR, "SockList_ReadPacket", "Want to read more bytes than will fit in buffer.\n");
    return -1;
  }

  else
  {
    do
    {

    __CPROVER_DUMP_L9:
      ;
      signed long int return_value_read$9;
      return_value_read$9=read(fd, (void *)(sl->buf + (signed long int)sl->len), (unsigned long int)toread);
      SockList_ReadPacket$$1$$stat = (signed int)return_value_read$9;
      if(!(SockList_ReadPacket$$1$$stat >= 0))
      {
        return_value___errno_location$7=__errno_location();
        tmp_if_expr$8 = *return_value___errno_location$7 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$8 = (_Bool)0;
      if(tmp_if_expr$8)
        goto __CPROVER_DUMP_L9;

      if(!(SockList_ReadPacket$$1$$stat >= 0))
      {
        signed int *return_value___errno_location$12;
        return_value___errno_location$12=__errno_location();
        if(!(*return_value___errno_location$12 == 11))
        {
          return_value___errno_location$11=__errno_location();
          if(!(*return_value___errno_location$11 == 11))
          {
            perror("ReadPacket got an error.");
            signed int *return_value___errno_location$10;
            return_value___errno_location$10=__errno_location();
            LOG((enum LogLevel)LOG_DEBUG, "SockList_ReadPacket", "ReadPacket got error %d, returning 0", *return_value___errno_location$10);
          }

        }

        return 0;
      }

      if(SockList_ReadPacket$$1$$stat == 0)
        return -1;

      sl->len = sl->len + SockList_ReadPacket$$1$$stat;
      toread = toread - SockList_ReadPacket$$1$$stat;
      if(toread == 0)
        return 1;

      if(!(toread >= 0))
      {
        LOG((enum LogLevel)LOG_ERROR, "SockList_ReadPacket", "SockList_ReadPacket: Read more bytes than desired.");
        return 1;
      }

    }
    while(toread >= 1);
    return 0;
  }
}

// SockList_Send
// file ../../common/proto.h line 126
signed int SockList_Send(struct SockList *sl, signed int fd)
{
  sl->buf[(signed long int)-2] = (unsigned char)(sl->len / 256);
  sl->buf[(signed long int)-1] = (unsigned char)(sl->len % 256);
  signed int return_value_write_socket$1;
  return_value_write_socket$1=write_socket(fd, sl->buf - (signed long int)2, sl->len + 2);
  return return_value_write_socket$1;
}

// Sound2Cmd
// file sound.c line 154
void Sound2Cmd(unsigned char *data, signed int len)
{
  signed char x;
  signed char y;
  unsigned char dir;
  unsigned char vol;
  unsigned char type;
  unsigned char len_sound;
  unsigned char len_source;
  char *sound = (char *)(void *)0;
  char *source = (char *)(void *)0;
  if(!(len >= 8))
    LOG((enum LogLevel)LOG_WARNING, "gtk-v2::Sound2Cmd", "Sound command too short: %d\n bytes", len);

  else
  {
    x = (signed char)data[(signed long int)0];
    y = (signed char)data[(signed long int)1];
    dir = data[(signed long int)2];
    vol = data[(signed long int)3];
    type = data[(signed long int)4];
    len_sound = data[(signed long int)5];
    if(!(len >= 1 + (signed int)len_sound))
      LOG((enum LogLevel)LOG_WARNING, "gtk-v2::Sound2Cmd", "sound length check: %i len: %i\n", len_sound, len);

    else
    {
      len_source = data[(signed long int)(6 + (signed int)len_sound)];
      if(!((signed int)len_sound == 0))
      {
        sound = (char *)data + (signed long int)6;
        data[(signed long int)(6 + (signed int)len_sound)] = (unsigned char)0;
      }

      if(!(len >= 1 + (signed int)len_sound + (signed int)len_source))
        LOG((enum LogLevel)LOG_WARNING, "gtk-v2::Sound2Cmd", "source length check: %i len: %i\n", len_source, len);

      else
      {
        if(!((signed int)len_source == 0))
        {
          source = (char *)data + (signed long int)6 + (signed long int)len_sound + (signed long int)1;
          data[(signed long int)(6 + (signed int)len_sound + 1 + (signed int)len_source)] = (unsigned char)0;
        }

        LOG((enum LogLevel)LOG_DEBUG, "gtk-v2::Sound2Cmd", "Playing sound2 x=%hhd y=%hhd dir=%hhd volume=%hhd type=%hhd", x, y, dir, vol, type);
        LOG((enum LogLevel)LOG_DEBUG, "gtk-v2::Sound2Cmd", "               len_sound=%hhd sound=%s", len_sound, sound);
        LOG((enum LogLevel)LOG_DEBUG, "gtk-v2::Sound2Cmd", "               len_source=%hhd source=%s", len_source, source);
        play_sound_effect(x, y, dir, vol, type, sound, source);
      }
    }
  }
}

// StatsCmd
// file ./proto.h line 19
void StatsCmd(unsigned char *data, signed int len)
{
  signed int i = 0;
  signed int c;
  signed int redraw = 0;
  signed long int last_exp;
  signed int tmp_post$1;
  signed int tmp_post$2;
  signed short int return_value_GetShort_String$3;
  signed short int return_value_GetShort_String$4;
  signed short int return_value_GetShort_String$5;
  signed short int return_value_GetShort_String$6;
  signed short int return_value_GetShort_String$7;
  signed short int return_value_GetShort_String$8;
  signed short int return_value_GetShort_String$9;
  signed int return_value_GetInt_String$10;
  signed short int return_value_GetShort_String$11;
  signed short int return_value_GetShort_String$12;
  signed short int return_value_GetShort_String$13;
  signed int return_value_GetInt_String$14;
  signed int return_value_GetInt_String$15;
  signed int return_value_GetInt_String$16;
  signed short int return_value_GetShort_String$17;
  signed int return_value_GetInt_String$18;
  signed int rlen;
  signed int tmp_post$19;
  signed int StatsCmd$$1$$1$$3$$1$$2$$rlen;
  signed int tmp_post$20;
  while(!(i >= len))
  {
    tmp_post$1 = i;
    i = i + 1;
    c = (signed int)data[(signed long int)tmp_post$1];
    if(c >= 100 && !(c >= 118))
    {
      cpl.stats.resists[(signed long int)(c - 100)]=GetShort_String(data + (signed long int)i);
      i = i + 2;
      cpl.stats.resist_change = (unsigned int)1;
    }

    else
      if(c >= 140 && !(c >= 50))
      {
        tmp_post$2 = i;
        i = i + 1;
        cpl.stats.skill_level[(signed long int)(c - 140)] = (signed short int)data[(signed long int)tmp_post$2];
        last_exp = cpl.stats.skill_exp[(signed long int)(c - 140)];
        cpl.stats.skill_exp[(signed long int)(c - 140)]=GetInt64_String(data + (signed long int)i);
        use_skill(c - 140);
        if(last_exp == 0l)
        {
          if(!(cpl.stats.skill_exp[(signed long int)(c + -140)] == 0l))
            redraw = 1;

        }

        i = i + 8;
      }

      else
        switch(c)
        {
          case 1:
          {
            cpl.stats.hp=GetShort_String(data + (signed long int)i);
            i = i + 2;
            break;
          }
          case 2:
          {
            cpl.stats.maxhp=GetShort_String(data + (signed long int)i);
            i = i + 2;
            break;
          }
          case 3:
          {
            cpl.stats.sp=GetShort_String(data + (signed long int)i);
            i = i + 2;
            break;
          }
          case 4:
          {
            cpl.stats.maxsp=GetShort_String(data + (signed long int)i);
            i = i + 2;
            break;
          }
          case 23:
          {
            cpl.stats.grace=GetShort_String(data + (signed long int)i);
            i = i + 2;
            break;
          }
          case 24:
          {
            cpl.stats.maxgrace=GetShort_String(data + (signed long int)i);
            i = i + 2;
            break;
          }
          case 5:
          {
            return_value_GetShort_String$3=GetShort_String(data + (signed long int)i);
            cpl.stats.Str = (signed char)return_value_GetShort_String$3;
            i = i + 2;
            break;
          }
          case 6:
          {
            return_value_GetShort_String$4=GetShort_String(data + (signed long int)i);
            cpl.stats.Int = (signed char)return_value_GetShort_String$4;
            i = i + 2;
            break;
          }
          case 22:
          {
            return_value_GetShort_String$5=GetShort_String(data + (signed long int)i);
            cpl.stats.Pow = (signed char)return_value_GetShort_String$5;
            i = i + 2;
            break;
          }
          case 7:
          {
            return_value_GetShort_String$6=GetShort_String(data + (signed long int)i);
            cpl.stats.Wis = (signed char)return_value_GetShort_String$6;
            i = i + 2;
            break;
          }
          case 8:
          {
            return_value_GetShort_String$7=GetShort_String(data + (signed long int)i);
            cpl.stats.Dex = (signed char)return_value_GetShort_String$7;
            i = i + 2;
            break;
          }
          case 9:
          {
            return_value_GetShort_String$8=GetShort_String(data + (signed long int)i);
            cpl.stats.Con = (signed char)return_value_GetShort_String$8;
            i = i + 2;
            break;
          }
          case 10:
          {
            return_value_GetShort_String$9=GetShort_String(data + (signed long int)i);
            cpl.stats.Cha = (signed char)return_value_GetShort_String$9;
            i = i + 2;
            break;
          }
          case 11:
          {
            return_value_GetInt_String$10=GetInt_String(data + (signed long int)i);
            cpl.stats.exp = (signed long int)return_value_GetInt_String$10;
            i = i + 4;
            break;
          }
          case 28:
          {
            cpl.stats.exp=GetInt64_String(data + (signed long int)i);
            i = i + 8;
            break;
          }
          case 12:
          {
            return_value_GetShort_String$11=GetShort_String(data + (signed long int)i);
            cpl.stats.level = (signed char)return_value_GetShort_String$11;
            i = i + 2;
            break;
          }
          case 13:
          {
            return_value_GetShort_String$12=GetShort_String(data + (signed long int)i);
            cpl.stats.wc = (signed char)return_value_GetShort_String$12;
            i = i + 2;
            break;
          }
          case 14:
          {
            return_value_GetShort_String$13=GetShort_String(data + (signed long int)i);
            cpl.stats.ac = (signed char)return_value_GetShort_String$13;
            i = i + 2;
            break;
          }
          case 15:
          {
            cpl.stats.dam=GetShort_String(data + (signed long int)i);
            i = i + 2;
            break;
          }
          case 16:
          {
            cpl.stats.resists[(signed long int)0]=GetShort_String(data + (signed long int)i);
            i = i + 2;
            break;
          }
          case 17:
          {
            cpl.stats.speed=GetInt_String(data + (signed long int)i);
            i = i + 4;
            break;
          }
          case 18:
          {
            cpl.stats.food=GetShort_String(data + (signed long int)i);
            i = i + 2;
            break;
          }
          case 19:
          {
            cpl.stats.weapon_sp=GetInt_String(data + (signed long int)i);
            i = i + 4;
            break;
          }
          case 29:
          {
            return_value_GetInt_String$14=GetInt_String(data + (signed long int)i);
            cpl.stats.attuned = (unsigned int)return_value_GetInt_String$14;
            i = i + 4;
            cpl.spells_updated = (unsigned int)1;
            break;
          }
          case 30:
          {
            return_value_GetInt_String$15=GetInt_String(data + (signed long int)i);
            cpl.stats.repelled = (unsigned int)return_value_GetInt_String$15;
            i = i + 4;
            cpl.spells_updated = (unsigned int)1;
            break;
          }
          case 31:
          {
            return_value_GetInt_String$16=GetInt_String(data + (signed long int)i);
            cpl.stats.denied = (unsigned int)return_value_GetInt_String$16;
            i = i + 4;
            cpl.spells_updated = (unsigned int)1;
            break;
          }
          case 25:
          {
            return_value_GetShort_String$17=GetShort_String(data + (signed long int)i);
            cpl.stats.flags = (unsigned short int)return_value_GetShort_String$17;
            i = i + 2;
            break;
          }
          case 26:
          {
            return_value_GetInt_String$18=GetInt_String(data + (signed long int)i);
            cpl.stats.weight_limit = (unsigned int)return_value_GetInt_String$18;
            set_weight_limit(cpl.stats.weight_limit);
            i = i + 4;
            break;
          }
          case 20:
          {
            tmp_post$19 = i;
            i = i + 1;
            rlen = (signed int)data[(signed long int)tmp_post$19];
            strncpy(cpl.range, (const char *)data + (signed long int)i, (unsigned long int)rlen);
            cpl.range[(signed long int)rlen] = (char)0;
            i = i + rlen;
            break;
          }
          case 21:
          {
            tmp_post$20 = i;
            i = i + 1;
            StatsCmd$$1$$1$$3$$1$$2$$rlen = (signed int)data[(signed long int)tmp_post$20];
            strncpy(cpl.title, (const char *)data + (signed long int)i, (unsigned long int)StatsCmd$$1$$1$$3$$1$$2$$rlen);
            cpl.title[(signed long int)StatsCmd$$1$$1$$3$$1$$2$$rlen] = (char)0;
            i = i + StatsCmd$$1$$1$$3$$1$$2$$rlen;
            break;
          }
          default:
            LOG((enum LogLevel)LOG_WARNING, "common::StatsCmd", "Unknown stat number %d", c);
        }
  }
  if(!(len >= i))
    LOG((enum LogLevel)LOG_WARNING, "common::StatsCmd", "got stats overflow, processed %d bytes out of %d", i, len);

  draw_stats(redraw);
  draw_message_window(0);
  script_lua_stats();
}

// TickCmd
// file ./proto.h line 38
void TickCmd(unsigned char *data, signed int len)
{
  signed int return_value_GetInt_String$1;
  return_value_GetInt_String$1=GetInt_String(data);
  tick = (unsigned int)return_value_GetInt_String$1;
  client_tick(tick);
}

// UpdateItemCmd
// file ./proto.h line 25
void UpdateItemCmd(unsigned char *data, signed int len)
{
  signed int weight;
  signed int loc;
  signed int tag;
  signed int face;
  signed int sendflags;
  signed int flags;
  signed int pos = 0;
  signed int nlen;
  signed int anim;
  unsigned int nrof;
  char name[256l];
  struct item_struct *ip;
  unsigned char animspeed;
  sendflags = (signed int)data[(signed long int)0];
  pos = pos + 1;
  tag=GetInt_String(data + (signed long int)pos);
  pos = pos + 4;
  ip=locate_item(tag);
  signed int tmp_if_expr$1;
  signed int tmp_post$2;
  signed int tmp_post$4;
  if(!(ip == ((struct item_struct *)NULL)))
  {
    name[0l] = (char)0;
    if(!(ip->env == ((struct item_struct *)NULL)))
      tmp_if_expr$1 = ip->env->tag;

    else
      tmp_if_expr$1 = 0;
    loc = tmp_if_expr$1;
    weight = (signed int)(ip->weight * (float)1000);
    face = (signed int)ip->face;
    flags = (signed int)ip->flagsval;
    anim = (signed int)ip->animation_id;
    animspeed = ip->anim_speed;
    nrof = ip->nrof;
    if(!((0x01 & sendflags) == 0))
    {
      loc=GetInt_String(data + (signed long int)pos);
      LOG((enum LogLevel)LOG_WARNING, "common::UpdateItemCmd", "Got tag of unknown object (%d) for new location", loc);
      pos = pos + 4;
    }

    if(!((0x02 & sendflags) == 0))
    {
      flags=GetInt_String(data + (signed long int)pos);
      pos = pos + 4;
    }

    if(!((0x04 & sendflags) == 0))
    {
      weight=GetInt_String(data + (signed long int)pos);
      pos = pos + 4;
    }

    if(!((0x08 & sendflags) == 0))
    {
      face=GetInt_String(data + (signed long int)pos);
      pos = pos + 4;
    }

    if(!((0x10 & sendflags) == 0))
    {
      tmp_post$2 = pos;
      pos = pos + 1;
      nlen = (signed int)data[(signed long int)tmp_post$2];
      memcpy((void *)name, (const void *)((char *)data + (signed long int)pos), (unsigned long int)nlen);
      pos = pos + nlen;
      name[(signed long int)nlen] = (char)0;
    }

    if(!(len >= pos))
      LOG((enum LogLevel)LOG_WARNING, "common::UpdateItemCmd", "Overread buffer: %d > %d", pos, len);

    else
    {
      if(!((0x20 & sendflags) == 0))
      {
        signed short int return_value_GetShort_String$3;
        return_value_GetShort_String$3=GetShort_String(data + (signed long int)pos);
        anim = (signed int)return_value_GetShort_String$3;
        pos = pos + 2;
      }

      if(!((0x40 & sendflags) == 0))
      {
        tmp_post$4 = pos;
        pos = pos + 1;
        animspeed = data[(signed long int)tmp_post$4];
      }

      if(!((0x80 & sendflags) == 0))
      {
        signed int return_value_GetInt_String$5;
        return_value_GetInt_String$5=GetInt_String(data + (signed long int)pos);
        nrof = (unsigned int)return_value_GetInt_String$5;
        pos = pos + 4;
      }

      update_item(tag, loc, name, weight, face, flags, anim, (signed int)animspeed, nrof, (signed int)ip->type);
      struct item_struct *return_value_locate_item$6;
      return_value_locate_item$6=locate_item(tag);
      item_actions(return_value_locate_item$6);
    }
  }

}

// UpdspellCmd
// file ./proto.h line 29
void UpdspellCmd(unsigned char *data, signed int len)
{
  signed int flags;
  signed int tag;
  signed int pos = 0;
  struct Spell_struct *tmp;
  _Bool tmp_if_expr$2;
  if(cpl.spelldata == ((struct Spell_struct *)NULL))
    LOG((enum LogLevel)LOG_WARNING, "common::UpdspellCmd", "I know no spells to update");

  else
  {
    char return_value_GetChar_String$1;
    return_value_GetChar_String$1=GetChar_String(data + (signed long int)pos);
    flags = (signed int)return_value_GetChar_String$1;
    pos = pos + 1;
    tag=GetInt_String(data + (signed long int)pos);
    pos = pos + 4;
    tmp = cpl.spelldata;
    do
    {
      if(!(tmp == ((struct Spell_struct *)NULL)))
        tmp_if_expr$2 = tmp->tag != (unsigned int)tag ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(!tmp_if_expr$2)
        break;

      tmp = tmp->next;
    }
    while((_Bool)1);
    if(tmp == ((struct Spell_struct *)NULL))
      LOG((enum LogLevel)LOG_WARNING, "common::UpdspellCmd", "Invalid tag: %d", tag);

    else
    {
      if(!((0x01 & flags) == 0))
      {
        signed short int return_value_GetShort_String$3;
        return_value_GetShort_String$3=GetShort_String(data + (signed long int)pos);
        tmp->sp = (unsigned short int)return_value_GetShort_String$3;
        pos = pos + 2;
      }

      if(!((0x02 & flags) == 0))
      {
        signed short int return_value_GetShort_String$4;
        return_value_GetShort_String$4=GetShort_String(data + (signed long int)pos);
        tmp->grace = (unsigned short int)return_value_GetShort_String$4;
        pos = pos + 2;
      }

      if(!((0x04 & flags) == 0))
      {
        signed short int return_value_GetShort_String$5;
        return_value_GetShort_String$5=GetShort_String(data + (signed long int)pos);
        tmp->dam = (unsigned short int)return_value_GetShort_String$5;
        pos = pos + 2;
      }

      if(!(len >= pos))
        LOG((enum LogLevel)LOG_WARNING, "common::UpdspellCmd", "Overread buffer: %d > %d", pos, len);

      cpl.spells_updated = (unsigned int)1;
    }
  }
}

// VersionCmd
// file ./proto.h line 54
void VersionCmd(char *data, signed int len)
{
  char *cp;
  csocket.cs_version=atoi(data);
  csocket.sc_version = csocket.cs_version;
  if(!(csocket.cs_version == 1023))
    LOG((enum LogLevel)LOG_WARNING, "common::VersionCmd", "Differing C->S version numbers (%d,%d)", 1023, csocket.cs_version);

  cp=strchr(data, 32);
  if(!(cp == ((char *)NULL)))
  {
    csocket.sc_version=atoi(cp);
    if(!(csocket.sc_version == 1029))
      LOG((enum LogLevel)LOG_WARNING, "common::VersionCmd", "Differing S->C version numbers (%d,%d)", 1029, csocket.sc_version);

    cp=strchr(cp + (signed long int)1, 32);
    if(!(cp == ((char *)NULL)))
      LOG((enum LogLevel)LOG_INFO, "common::VersionCmd", "Playing on server type %s", cp);

  }

}

// _curl_easy_setopt_err_CURLSH
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH(void)
{
  asm("");
}

// _curl_easy_setopt_err_FILE
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE(void)
{
  asm("");
}

// _curl_easy_setopt_err_cb_data
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data(void)
{
  asm("");
}

// _curl_easy_setopt_err_conv_cb
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_httpost
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_off_t
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist(void)
{
  asm("");
}

// _curl_easy_setopt_err_debug_cb
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_error_buffer
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer(void)
{
  asm("");
}

// _curl_easy_setopt_err_ioctl_cb
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_long
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long(void)
{
  asm("");
}

// _curl_easy_setopt_err_opensocket_cb
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_postfields
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields(void)
{
  asm("");
}

// _curl_easy_setopt_err_progress_cb
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_read_cb
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_seek_cb
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_sockopt_cb
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_ssl_ctx_cb
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_string
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string(void)
{
  asm("");
}

// _curl_easy_setopt_err_write_callback
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback(void)
{
  asm("");
}

// account_add_character_failure
// file account.c line 292
extern void account_add_character_failure(char *message)
{
  char *cp;
  signed int retry;
  retry=atoi(message);
  cp=strchr(message, 32);
  if(!(cp == ((char *)NULL)))
    cp = cp + 1l;

  else
    cp = message;
  if(retry == 0)
  {
    unsigned long int return_value_gtk_label_get_type$1;
    return_value_gtk_label_get_type$1=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)label_add_status, return_value_gtk_label_get_type$1);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, cp);
  }

  else
  {
    struct _GtkWidget *dialog;
    signed int result;
    const char *name;
    const char *password;
    dialog=gtk_message_dialog_new((struct _GtkWindow *)(void *)0, (enum anonymous$40)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$41)GTK_MESSAGE_QUESTION, (enum anonymous$42)GTK_BUTTONS_YES_NO, "%s\n%s", cp, (const void *)"Apply anyways?");
    unsigned long int return_value_gtk_dialog_get_type$3;
    return_value_gtk_dialog_get_type$3=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$3);
    result=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$4);
    gtk_widget_destroy(dialog);
    if(result == -8)
    {
      unsigned long int return_value_gtk_entry_get_type$5;
      return_value_gtk_entry_get_type$5=gtk_entry_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)entry_character_name, return_value_gtk_entry_get_type$5);
      name=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$6);
      unsigned long int return_value_gtk_entry_get_type$7;
      return_value_gtk_entry_get_type$7=gtk_entry_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)entry_character_password, return_value_gtk_entry_get_type$7);
      password=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$8);
      add_character_to_account(name, password, 1);
    }

    else
    {
      unsigned long int return_value_gtk_entry_get_type$9;
      return_value_gtk_entry_get_type$9=gtk_entry_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
      return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)entry_character_name, return_value_gtk_entry_get_type$9);
      gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$10, "");
      unsigned long int return_value_gtk_entry_get_type$11;
      return_value_gtk_entry_get_type$11=gtk_entry_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
      return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)entry_character_password, return_value_gtk_entry_get_type$11);
      gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$12, "");
      gtk_widget_grab_focus(entry_character_name);
    }
  }
}

// account_change_password_failure
// file account.c line 1256
void account_change_password_failure(char *message)
{
  unsigned long int return_value_gtk_label_get_type$1;
  return_value_gtk_label_get_type$1=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)label_account_password_status, return_value_gtk_label_get_type$1);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, message);
}

// account_creation_failure
// file account.c line 759
extern void account_creation_failure(char *message)
{
  unsigned long int return_value_gtk_label_get_type$1;
  return_value_gtk_label_get_type$1=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)label_create_account_status, return_value_gtk_label_get_type$1);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, message);
}

// account_login_failure
// file account.c line 944
extern void account_login_failure(char *message)
{
  unsigned long int return_value_gtk_label_get_type$1;
  return_value_gtk_label_get_type$1=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)label_account_login_status, return_value_gtk_label_get_type$1);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, message);
}

// add_character_to_account
// file account.c line 259
static void add_character_to_account(const char *name, const char *password, signed int force)
{
  struct SockList sl;
  unsigned char buf[256l];
  _Bool tmp_if_expr$7;
  if(name == ((const char *)NULL) || password == ((const char *)NULL))
    tmp_if_expr$7 = (_Bool)1;

  else
    tmp_if_expr$7 = (signed int)*name == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$8;
  if(tmp_if_expr$7)
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = (signed int)*password == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$8)
  {
    unsigned long int return_value_gtk_label_get_type$1;
    return_value_gtk_label_get_type$1=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)label_add_status, return_value_gtk_label_get_type$1);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, "You must enter both a name and password!");
  }

  else
  {
    unsigned long int return_value_gtk_label_get_type$3;
    return_value_gtk_label_get_type$3=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)label_add_status, return_value_gtk_label_get_type$3);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, "");
    SockList_Init(&sl, buf);
    SockList_AddString(&sl, "accountaddplayer ");
    SockList_AddChar(&sl, (char)force);
    unsigned long int return_value_strlen$5;
    return_value_strlen$5=strlen(name);
    SockList_AddChar(&sl, (char)return_value_strlen$5);
    SockList_AddString(&sl, name);
    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(password);
    SockList_AddChar(&sl, (char)return_value_strlen$6);
    SockList_AddString(&sl, password);
    SockList_Send(&sl, csocket.fd);
  }
}

// add_item
// file item.c line 410
static void add_item(struct item_struct *env, struct item_struct *op)
{
  struct item_struct *tmp = env->inv;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(tmp == ((struct item_struct *)NULL)))
      tmp_if_expr$1 = tmp->next != ((struct item_struct *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    tmp = tmp->next;
  }
  while((_Bool)1);
  op->next = (struct item_struct *)(void *)0;
  op->prev = tmp;
  op->env = env;
  if(tmp == ((struct item_struct *)NULL))
    env->inv = op;

  else
  {
    if(!(tmp->next == ((struct item_struct *)NULL)))
      tmp->next->prev = op;

    tmp->next = op;
  }
}

// add_marked_text_to_pane
// file gtk2proto.h line 69
extern void add_marked_text_to_pane(struct Info_Pane *pane, const char *message, signed int type, signed int subtype, signed int orig_color)
{
  char *marker;
  char *current;
  char *original;
  signed int bold = 0;
  signed int italic = 0;
  signed int font = 0;
  signed int underline = 0;
  const char *color = (const char *)(void *)0;
  current=strdup(message);
  original = current;
  _Bool tmp_if_expr$1;
  if(has_style == 0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = pane->msg_type_tags[(signed long int)type][(signed long int)subtype] == ((struct _GtkTextTag *)NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    if(orig_color >= 14 || !(orig_color >= 0))
      LOG((enum LogLevel)LOG_ERROR, "info.c::draw_ext_info", "Passed invalid color from server: %d, max allowed is %d\n", orig_color, 13);

    else
      color = usercolorname[(signed long int)orig_color];
  }

  signed int return_value_strcmp$14;
  signed int return_value_strcmp$13;
  signed int return_value_strcmp$12;
  signed int return_value_strcmp$11;
  signed int return_value_strcmp$10;
  signed int return_value_strcmp$9;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$7;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strncmp$3;
  do
  {
    marker=strchr(current, 91);
    if(marker == ((char *)NULL))
      break;

    *marker = (char)0;
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(current);
    if(return_value_strlen$2 >= 1ul)
      add_to_textbuf(pane, current, type, subtype, bold, italic, font, color, underline);

    current = marker + (signed long int)1;
    marker=strchr(current, 93);
    if(marker == ((char *)NULL))
    {
      free((void *)original);
      goto __CPROVER_DUMP_L22;
    }

    *marker = (char)0;
    signed int return_value_strcmp$15;
    return_value_strcmp$15=strcmp(current, "b");
    if(return_value_strcmp$15 == 0)
      bold = (signed int)!(0 != 0);

    else
    {
      return_value_strcmp$14=strcmp(current, "/b");
      if(return_value_strcmp$14 == 0)
        bold = 0;

      else
      {
        return_value_strcmp$13=strcmp(current, "i");
        if(return_value_strcmp$13 == 0)
          italic = (signed int)!(0 != 0);

        else
        {
          return_value_strcmp$12=strcmp(current, "/i");
          if(return_value_strcmp$12 == 0)
            italic = 0;

          else
          {
            return_value_strcmp$11=strcmp(current, "ul");
            if(return_value_strcmp$11 == 0)
              underline = (signed int)!(0 != 0);

            else
            {
              return_value_strcmp$10=strcmp(current, "/ul");
              if(return_value_strcmp$10 == 0)
                underline = 0;

              else
              {
                return_value_strcmp$9=strcmp(current, "fixed");
                if(return_value_strcmp$9 == 0)
                  font = 3;

                else
                {
                  return_value_strcmp$8=strcmp(current, "arcane");
                  if(return_value_strcmp$8 == 0)
                    font = 1;

                  else
                  {
                    return_value_strcmp$7=strcmp(current, "hand");
                    if(return_value_strcmp$7 == 0)
                      font = 4;

                    else
                    {
                      return_value_strcmp$6=strcmp(current, "strange");
                      if(return_value_strcmp$6 == 0)
                        font = 2;

                      else
                      {
                        return_value_strcmp$5=strcmp(current, "print");
                        if(return_value_strcmp$5 == 0)
                          font = 0;

                        else
                        {
                          return_value_strcmp$4=strcmp(current, "/color");
                          if(return_value_strcmp$4 == 0)
                            color = (const char *)(void *)0;

                          else
                          {
                            return_value_strncmp$3=strncmp(current, "color=", (unsigned long int)6);
                            if(return_value_strncmp$3 == 0)
                              color = current + (signed long int)6;

                            else
                              LOG((enum LogLevel)LOG_INFO, "info.c::message_callback", "unrecognized tag: [%s]\n", current);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    current = marker + (signed long int)1;
  }
  while((_Bool)1);
  add_to_textbuf(pane, current, type, subtype, bold, italic, font, color, underline);
  add_to_textbuf(pane, "\n", type, subtype, bold, italic, font, color, underline);
  free((void *)original);

__CPROVER_DUMP_L22:
  ;
}

// add_object_to_store
// file inventory.c line 718
static void add_object_to_store(struct item_struct *it, struct _GtkTreeStore *store, struct _GtkTreeIter *new, struct _GtkTreeIter *parent, signed int color)
{
  char buf[256l];
  char buf1[256l];
  struct _GdkColor *foreground = (struct _GdkColor *)(void *)0;
  struct _GdkColor *background = (struct _GdkColor *)(void *)0;
  struct _PangoFontDescription *font = (struct _PangoFontDescription *)(void *)0;
  struct _GtkStyle *row_style;
  if(it->weight < 0.000000f)
    strcpy(buf, " ");

  else
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%6.1f", (float)it->nrof * it->weight);
  snprintf(buf1, (unsigned long int)255, "%s %s", (const void *)it->d_name, (const void *)it->flags);
  if(!(color == 0))
  {
    row_style=get_row_style(it);
    if(!(row_style == ((struct _GtkStyle *)NULL)))
    {
      foreground = &row_style->text[(signed long int)GTK_STATE_NORMAL];
      background = &row_style->base[(signed long int)GTK_STATE_NORMAL];
      font = row_style->font_desc;
    }

  }

  gtk_tree_store_append(store, new, parent);
  gtk_tree_store_set(store, new, 1, (struct _GdkPixbuf *)pixmaps[(signed long int)it->face]->icon_image, 2, (const void *)buf1, 3, (const void *)buf, 5, background, 8, foreground, 9, font, 4, it, 6, it->type, 7, (const void *)it->s_name, -1);
}

// add_style_to_textbuffer
// file gtk2proto.h line 66
extern void add_style_to_textbuffer(struct Info_Pane *pane, struct _GtkStyle *base_style)
{
  signed int i;
  char style_name[256l];
  struct _GtkStyle *tmp_style;
  if(!(base_style == ((struct _GtkStyle *)NULL)))
  {
    i = 0;
    for( ; !(i >= 13); i = i + 1)
    {
      snprintf(style_name, (unsigned long int)256, "info_%s", usercolorname[(signed long int)i]);
      struct _GtkSettings *return_value_gtk_settings_get_default$1;
      return_value_gtk_settings_get_default$1=gtk_settings_get_default();
      tmp_style=gtk_rc_get_style_by_paths(return_value_gtk_settings_get_default$1, (const char *)(void *)0, style_name, (unsigned long int)(1 << 2));
      if(!(tmp_style == ((struct _GtkStyle *)NULL)))
      {
        if(pane->color_tags[(signed long int)i] == ((struct _GtkTextTag *)NULL))
          pane->color_tags[(signed long int)i]=gtk_text_buffer_create_tag(pane->textbuffer, (const char *)(void *)0, (const char *)(void *)0);

        set_text_tag_from_style(pane->color_tags[(signed long int)i], tmp_style, base_style);
      }

      else
        if(!(pane->color_tags[(signed long int)i] == ((struct _GtkTextTag *)NULL)))
        {
          struct _GtkTextTagTable *return_value_gtk_text_buffer_get_tag_table$2;
          return_value_gtk_text_buffer_get_tag_table$2=gtk_text_buffer_get_tag_table(pane->textbuffer);
          gtk_text_tag_table_remove(return_value_gtk_text_buffer_get_tag_table$2, pane->color_tags[(signed long int)i]);
          pane->color_tags[(signed long int)i] = (struct _GtkTextTag *)(void *)0;
        }

    }
    i = 0;
    for( ; !(i >= 5); i = i + 1)
    {
      struct _GtkSettings *return_value_gtk_settings_get_default$3;
      return_value_gtk_settings_get_default$3=gtk_settings_get_default();
      tmp_style=gtk_rc_get_style_by_paths(return_value_gtk_settings_get_default$3, (const char *)(void *)0, font_style_names[(signed long int)i], (unsigned long int)(1 << 2));
      if(!(tmp_style == ((struct _GtkStyle *)NULL)))
      {
        if(pane->font_tags[(signed long int)i] == ((struct _GtkTextTag *)NULL))
          pane->font_tags[(signed long int)i]=gtk_text_buffer_create_tag(pane->textbuffer, (const char *)(void *)0, (const char *)(void *)0);

        set_text_tag_from_style(pane->font_tags[(signed long int)i], tmp_style, base_style);
      }

      else
        if(!(pane->font_tags[(signed long int)i] == ((struct _GtkTextTag *)NULL)))
        {
          struct _GtkTextTagTable *return_value_gtk_text_buffer_get_tag_table$4;
          return_value_gtk_text_buffer_get_tag_table$4=gtk_text_buffer_get_tag_table(pane->textbuffer);
          gtk_text_tag_table_remove(return_value_gtk_text_buffer_get_tag_table$4, pane->font_tags[(signed long int)i]);
          pane->font_tags[(signed long int)i] = (struct _GtkTextTag *)(void *)0;
        }

    }
  }

  else
  {
    i = 0;
    for( ; !(i >= 13); i = i + 1)
      if(!(pane->color_tags[(signed long int)i] == ((struct _GtkTextTag *)NULL)))
      {
        struct _GtkTextTagTable *return_value_gtk_text_buffer_get_tag_table$5;
        return_value_gtk_text_buffer_get_tag_table$5=gtk_text_buffer_get_tag_table(pane->textbuffer);
        gtk_text_tag_table_remove(return_value_gtk_text_buffer_get_tag_table$5, pane->color_tags[(signed long int)i]);
        pane->color_tags[(signed long int)i] = (struct _GtkTextTag *)(void *)0;
      }

    i = 0;
    for( ; !(i >= 5); i = i + 1)
      if(!(pane->font_tags[(signed long int)i] == ((struct _GtkTextTag *)NULL)))
      {
        struct _GtkTextTagTable *return_value_gtk_text_buffer_get_tag_table$6;
        return_value_gtk_text_buffer_get_tag_table$6=gtk_text_buffer_get_tag_table(pane->textbuffer);
        gtk_text_tag_table_remove(return_value_gtk_text_buffer_get_tag_table$6, pane->font_tags[(signed long int)i]);
        pane->font_tags[(signed long int)i] = (struct _GtkTextTag *)(void *)0;
      }

  }
}

// add_tags_to_textbuffer
// file gtk2proto.h line 65
extern void add_tags_to_textbuffer(struct Info_Pane *pane, struct _GtkTextBuffer *textbuf)
{
  signed int i;
  if(!(textbuf == ((struct _GtkTextBuffer *)NULL)))
    pane->textbuffer = textbuf;

  i = 0;
  void *return_value_calloc$1;
  for( ; !(i >= 21); i = i + 1)
  {
    return_value_calloc$1=calloc((unsigned long int)(max_subtype + 1), sizeof(struct _GtkTextTag *) /*8ul*/ );
    pane->msg_type_tags[(signed long int)i] = (struct _GtkTextTag **)return_value_calloc$1;
  }
  i = 0;
  for( ; !(i >= 5); i = i + 1)
    pane->font_tags[(signed long int)i] = (struct _GtkTextTag *)(void *)0;
  i = 0;
  for( ; !(i >= 13); i = i + 1)
    pane->color_tags[(signed long int)i] = (struct _GtkTextTag *)(void *)0;
  pane->bold_tag=gtk_text_buffer_create_tag(pane->textbuffer, "bold", "weight", 700, (void *)0);
  pane->italic_tag=gtk_text_buffer_create_tag(pane->textbuffer, "italic", "style", 2, (void *)0);
  pane->underline_tag=gtk_text_buffer_create_tag(pane->textbuffer, "underline", "underline", 1, (void *)0);
  if(pane->default_tag == ((struct _GtkTextTag *)NULL))
    pane->default_tag=gtk_text_buffer_create_tag(pane->textbuffer, "default", (const char *)(void *)0);

}

// add_to_textbuf
// file info.c line 677
static void add_to_textbuf(struct Info_Pane *pane, const char *message, signed int type, signed int subtype, signed int bold, signed int italic, signed int font, const char *color, signed int underline)
{
  struct _GtkTextIter end;
  struct _GdkRectangle rect;
  signed int scroll_to_end = 0;
  signed int color_num;
  struct _GtkTextTag *color_tag = (struct _GtkTextTag *)(void *)0;
  struct _GtkTextTag *type_tag = (struct _GtkTextTag *)(void *)0;
  signed int return_value_strcasecmp$1;
  if(!(color == ((const char *)NULL)))
  {
    color_num = 0;
    for( ; !(color_num >= 13); color_num = color_num + 1)
    {
      return_value_strcasecmp$1=strcasecmp(usercolorname[(signed long int)color_num], color);
      if(return_value_strcasecmp$1 == 0)
        break;

    }
    if(!(color_num >= 13))
      color_tag = pane->color_tags[(signed long int)color_num];

  }

  if(color_tag == ((struct _GtkTextTag *)NULL))
    color_tag = pane->default_tag;

  type_tag = pane->default_tag;
  if(!(type == 20) || !(max_subtype == 0))
  {
    if(subtype >= max_subtype || type >= 21 || !(subtype >= 0) || !(type >= 0))
      LOG((enum LogLevel)LOG_ERROR, "info.c::add_to_textbuf", "type (%d) >= MSG_TYPE_LAST (%d) or subtype (%d) >= max_subtype (%d)\n", type, 21, subtype, max_subtype);

    else
      if(!(pane->msg_type_tags[(signed long int)type][(signed long int)subtype] == ((struct _GtkTextTag *)NULL)))
        type_tag = pane->msg_type_tags[(signed long int)type][(signed long int)subtype];

      else
        if(!(*pane->msg_type_tags[(signed long int)type] == ((struct _GtkTextTag *)NULL)))
          type_tag = pane->msg_type_tags[(signed long int)type][(signed long int)0];

  }

  unsigned long int return_value_gtk_text_view_get_type$2;
  return_value_gtk_text_view_get_type$2=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)pane->textview, return_value_gtk_text_view_get_type$2);
  gtk_text_view_get_visible_rect((struct _GtkTextView *)return_value_g_type_check_instance_cast$3, &rect);
  if(!(pane->adjustment == ((struct _GtkAdjustment *)NULL)))
  {
    if(pane->adjustment->value + (double)rect.height >= pane->adjustment->upper)
      scroll_to_end = 1;

  }

  gtk_text_buffer_get_end_iter(pane->textbuffer, &end);
  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(message);
  struct _GtkTextTag *tmp_if_expr$5;
  if(!(bold == 0))
    tmp_if_expr$5 = pane->bold_tag;

  else
    tmp_if_expr$5 = pane->default_tag;
  struct _GtkTextTag *tmp_if_expr$6;
  if(!(italic == 0))
    tmp_if_expr$6 = pane->italic_tag;

  else
    tmp_if_expr$6 = pane->default_tag;
  struct _GtkTextTag *tmp_if_expr$7;
  if(!(underline == 0))
    tmp_if_expr$7 = pane->underline_tag;

  else
    tmp_if_expr$7 = pane->default_tag;
  struct _GtkTextTag *tmp_if_expr$8;
  if(!(pane->font_tags[(signed long int)font] == ((struct _GtkTextTag *)NULL)))
    tmp_if_expr$8 = pane->font_tags[(signed long int)font];

  else
    tmp_if_expr$8 = pane->default_tag;
  gtk_text_buffer_insert_with_tags(pane->textbuffer, &end, message, (signed int)return_value_strlen$4, tmp_if_expr$5, tmp_if_expr$6, tmp_if_expr$7, tmp_if_expr$8, color_tag, type_tag, (void *)0);
  unsigned long int return_value_gtk_text_view_get_type$9;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  if(!(scroll_to_end == 0))
  {
    return_value_gtk_text_view_get_type$9=gtk_text_view_get_type();
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)pane->textview, return_value_gtk_text_view_get_type$9);
    gtk_text_view_scroll_mark_onscreen((struct _GtkTextView *)return_value_g_type_check_instance_cast$10, pane->textmark);
  }

}

// addsmooth
// file image.c line 434
extern void addsmooth(unsigned short int face, unsigned short int smooth_face)
{
  pixmaps[(signed long int)face]->smooth_face = smooth_face;
}

// alloc_items
// file item.c line 246
static struct item_struct * alloc_items(signed int nrof)
{
  struct item_struct *op;
  struct item_struct *list;
  signed int i;
  op=new_item();
  list = op;
  i = 1;
  for( ; !(i >= nrof); i = i + 1)
  {
    op->next=new_item();
    op->next->prev = op;
    op = op->next;
  }
  return list;
}

// animate_inventory
// file inventory.c line 1163
extern void animate_inventory(void)
{
  signed int valid;
  struct _GtkTreeIter iter;
  struct item_struct *tmp;
  signed int page;
  struct _GtkTreeStore *store;
  if(tick == 0u)
  {
    static signed int inv_tick = 0;
    inv_tick = inv_tick + 1;
    if(!(inv_tick >= 12))
      goto __CPROVER_DUMP_L8;

    inv_tick = 0;
  }

  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)inv_notebook, return_value_gtk_notebook_get_type$1);
  page=gtk_notebook_get_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2);
  if(inv_notebooks[(signed long int)page].type == 1)
    draw_inv_table(1);

  else
  {
    store = inv_notebooks[(signed long int)page].treestore;
    unsigned long int return_value_gtk_tree_model_get_type$3;
    return_value_gtk_tree_model_get_type$3=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_tree_model_get_type$3);
    valid=gtk_tree_model_get_iter_first((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$4, &iter);
    while(!(valid == 0))
    {
      unsigned long int return_value_gtk_tree_model_get_type$5;
      return_value_gtk_tree_model_get_type$5=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_tree_model_get_type$5);
      gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$6, &iter, 4, &tmp, -1);
      if((signed int)tmp->animation_id >= 1)
      {
        if(!(tmp->anim_speed == 0))
        {
          if(!(animations[(signed long int)tmp->animation_id].faces == ((unsigned short int *)NULL)))
          {
            tmp->last_anim = tmp->last_anim + 1;
            if((signed int)tmp->last_anim >= (signed int)tmp->anim_speed)
            {
              tmp->anim_state = tmp->anim_state + 1;
              if((signed int)tmp->anim_state >= (signed int)animations[(signed long int)tmp->animation_id].num_animations)
                tmp->anim_state = (unsigned char)0;

              tmp->face = (signed short int)animations[(signed long int)tmp->animation_id].faces[(signed long int)tmp->anim_state];
              tmp->last_anim = (unsigned short int)0;
              gtk_tree_store_set(store, &iter, 1, (struct _GdkPixbuf *)pixmaps[(signed long int)tmp->face]->icon_image, -1);
            }

          }

        }

      }

      unsigned long int return_value_gtk_tree_model_get_type$7;
      return_value_gtk_tree_model_get_type$7=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_tree_model_get_type$7);
      valid=gtk_tree_model_iter_next((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$8, &iter);
    }
  }

__CPROVER_DUMP_L8:
  ;
}

// animate_look
// file inventory.c line 1235
extern void animate_look(void)
{
  signed int valid;
  struct _GtkTreeIter iter;
  struct item_struct *tmp;
  if(tick == 0u)
  {
    static signed int inv_tick = 0;
    inv_tick = inv_tick + 1;
    if(!(inv_tick >= 12))
      goto __CPROVER_DUMP_L7;

    inv_tick = 0;
  }

  unsigned long int return_value_gtk_tree_model_get_type$1;
  return_value_gtk_tree_model_get_type$1=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)store_look, return_value_gtk_tree_model_get_type$1);
  valid=gtk_tree_model_get_iter_first((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$2, &iter);
  while(!(valid == 0))
  {
    unsigned long int return_value_gtk_tree_model_get_type$3;
    return_value_gtk_tree_model_get_type$3=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)store_look, return_value_gtk_tree_model_get_type$3);
    gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$4, &iter, 4, &tmp, -1);
    if((signed int)tmp->animation_id >= 1)
    {
      if(!(tmp->anim_speed == 0))
      {
        tmp->last_anim = tmp->last_anim + 1;
        if((signed int)tmp->last_anim >= (signed int)tmp->anim_speed)
        {
          tmp->anim_state = tmp->anim_state + 1;
          if((signed int)tmp->anim_state >= (signed int)animations[(signed long int)tmp->animation_id].num_animations)
            tmp->anim_state = (unsigned char)0;

          tmp->face = (signed short int)animations[(signed long int)tmp->animation_id].faces[(signed long int)tmp->anim_state];
          tmp->last_anim = (unsigned short int)0;
          gtk_tree_store_set(store_look, &iter, 1, (struct _GdkPixbuf *)pixmaps[(signed long int)tmp->face]->icon_image, -1);
        }

      }

    }

    unsigned long int return_value_gtk_tree_model_get_type$5;
    return_value_gtk_tree_model_get_type$5=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)store_look, return_value_gtk_tree_model_get_type$5);
    valid=gtk_tree_model_iter_next((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$6, &iter);
  }

__CPROVER_DUMP_L7:
  ;
}

// animate_objects
// file item.c line 712
void animate_objects(void)
{
  struct item_struct *ip;
  signed int got_one = 0;
  ip = player->inv;
  for( ; !(ip == ((struct item_struct *)NULL)); ip = ip->next)
    if((signed int)ip->animation_id >= 1)
    {
      if(!(ip->anim_speed == 0))
      {
        ip->last_anim = ip->last_anim + 1;
        if((signed int)ip->last_anim >= (signed int)ip->anim_speed)
        {
          ip->anim_state = ip->anim_state + 1;
          if((signed int)ip->anim_state >= (signed int)animations[(signed long int)ip->animation_id].num_animations)
            ip->anim_state = (unsigned char)0;

          ip->face = (signed short int)animations[(signed long int)ip->animation_id].faces[(signed long int)ip->anim_state];
          ip->last_anim = (unsigned short int)0;
          got_one = 1;
        }

      }

    }

  if(!(got_one == 0))
    player->inv_updated = (unsigned short int)1;

  if(!(cpl.container == ((struct item_struct *)NULL)))
  {
    ip = cpl.container->inv;
    for( ; !(ip == ((struct item_struct *)NULL)); ip = ip->next)
      if((signed int)ip->animation_id >= 1)
      {
        if(!(ip->anim_speed == 0))
        {
          ip->last_anim = ip->last_anim + 1;
          if((signed int)ip->last_anim >= (signed int)ip->anim_speed)
          {
            ip->anim_state = ip->anim_state + 1;
            if((signed int)ip->anim_state >= (signed int)animations[(signed long int)ip->animation_id].num_animations)
              ip->anim_state = (unsigned char)0;

            ip->face = (signed short int)animations[(signed long int)ip->animation_id].faces[(signed long int)ip->anim_state];
            ip->last_anim = (unsigned short int)0;
            got_one = 1;
          }

        }

      }

    if(!(got_one == 0))
      cpl.container->inv_updated = (unsigned short int)1;

  }

  else
  {
    ip = cpl.below->inv;
    for( ; !(ip == ((struct item_struct *)NULL)); ip = ip->next)
      if((signed int)ip->animation_id >= 1)
      {
        if(!(ip->anim_speed == 0))
        {
          ip->last_anim = ip->last_anim + 1;
          if((signed int)ip->last_anim >= (signed int)ip->anim_speed)
          {
            ip->anim_state = ip->anim_state + 1;
            if((signed int)ip->anim_state >= (signed int)animations[(signed long int)ip->animation_id].num_animations)
              ip->anim_state = (unsigned char)0;

            ip->face = (signed short int)animations[(signed long int)ip->animation_id].faces[(signed long int)ip->anim_state];
            ip->last_anim = (unsigned short int)0;
            got_one = 1;
          }

        }

      }

    if(!(got_one == 0))
      cpl.below->inv_updated = (unsigned short int)1;

  }
}

// associate_cache_entry
// file image.c line 447
extern signed int associate_cache_entry(struct Cache_Entry *ce, signed int pixnum)
{
  pixmaps[(signed long int)pixnum] = (struct PixmapInfo *)ce->image_data;
  return 0;
}

// bind_key
// file keys.c line 1088
extern void bind_key(char *params)
{
  char buf[272l];
  if(params == ((char *)NULL))
    draw_ext_info(0, 20, 6, "Usage: 'bind -ei {<commandline>,commandkey,firekey{1,2},runkey{1,2},altkey{1,2},metakey{1,2},completekey,nextkey,prevkey}'\nWhere\n      -e means enter edit mode\n      -g means this binding should be global (used for all your characters)\n      -i means ignore modifier keys (keybinding works no matter if Ctrl/Alt etc are held)");

  else
  {
    for( ; (signed int)*params == 32; params = params + 1l)
      ;
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(params, "commandkey");
    if(return_value_strcmp$1 == 0)
    {
      bind_keysym = &commandkeysym;
      draw_ext_info(0, 20, 4, "Push key to bind new commandkey.");
      cpl.input_state = (enum Input_State)Configure_Keys;
    }

    else
    {
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(params, "firekey1");
      if(return_value_strcmp$2 == 0)
      {
        bind_keysym = &firekeysym[(signed long int)0];
        draw_ext_info(0, 20, 4, "Push key to bind new firekey 1.");
        cpl.input_state = (enum Input_State)Configure_Keys;
      }

      else
      {
        signed int return_value_strcmp$3;
        return_value_strcmp$3=strcmp(params, "firekey2");
        if(return_value_strcmp$3 == 0)
        {
          bind_keysym = &firekeysym[(signed long int)1];
          draw_ext_info(0, 20, 4, "Push key to bind new firekey 2.");
          cpl.input_state = (enum Input_State)Configure_Keys;
        }

        else
        {
          signed int return_value_strcmp$4;
          return_value_strcmp$4=strcmp(params, "metakey1");
          if(return_value_strcmp$4 == 0)
          {
            bind_keysym = &metakeysym[(signed long int)0];
            draw_ext_info(0, 20, 4, "Push key to bind new metakey 1.");
            cpl.input_state = (enum Input_State)Configure_Keys;
          }

          else
          {
            signed int return_value_strcmp$5;
            return_value_strcmp$5=strcmp(params, "metakey2");
            if(return_value_strcmp$5 == 0)
            {
              bind_keysym = &metakeysym[(signed long int)1];
              draw_ext_info(0, 20, 4, "Push key to bind new metakey 2.");
              cpl.input_state = (enum Input_State)Configure_Keys;
            }

            else
            {
              signed int return_value_strcmp$6;
              return_value_strcmp$6=strcmp(params, "altkey1");
              if(return_value_strcmp$6 == 0)
              {
                bind_keysym = &altkeysym[(signed long int)0];
                draw_ext_info(0, 20, 4, "Push key to bind new altkey 1.");
                cpl.input_state = (enum Input_State)Configure_Keys;
              }

              else
              {
                signed int return_value_strcmp$7;
                return_value_strcmp$7=strcmp(params, "altkey2");
                if(return_value_strcmp$7 == 0)
                {
                  bind_keysym = &altkeysym[(signed long int)1];
                  draw_ext_info(0, 20, 4, "Push key to bind new altkey 2.");
                  cpl.input_state = (enum Input_State)Configure_Keys;
                }

                else
                {
                  signed int return_value_strcmp$8;
                  return_value_strcmp$8=strcmp(params, "runkey1");
                  if(return_value_strcmp$8 == 0)
                  {
                    bind_keysym = &runkeysym[(signed long int)0];
                    draw_ext_info(0, 20, 4, "Push key to bind new runkey 1.");
                    cpl.input_state = (enum Input_State)Configure_Keys;
                  }

                  else
                  {
                    signed int return_value_strcmp$9;
                    return_value_strcmp$9=strcmp(params, "runkey2");
                    if(return_value_strcmp$9 == 0)
                    {
                      bind_keysym = &runkeysym[(signed long int)1];
                      draw_ext_info(0, 20, 4, "Push key to bind new runkey 2.");
                      cpl.input_state = (enum Input_State)Configure_Keys;
                    }

                    else
                    {
                      signed int return_value_strcmp$10;
                      return_value_strcmp$10=strcmp(params, "completekey");
                      if(return_value_strcmp$10 == 0)
                      {
                        bind_keysym = &completekeysym;
                        draw_ext_info(0, 20, 4, "Push key to bind new command completion key");
                        cpl.input_state = (enum Input_State)Configure_Keys;
                      }

                      else
                      {
                        signed int return_value_strcmp$11;
                        return_value_strcmp$11=strcmp(params, "prevkey");
                        if(return_value_strcmp$11 == 0)
                        {
                          bind_keysym = &prevkeysym;
                          draw_ext_info(0, 20, 4, "Push key to bind new previous command in history key.");
                          cpl.input_state = (enum Input_State)Configure_Keys;
                        }

                        else
                        {
                          signed int return_value_strcmp$12;
                          return_value_strcmp$12=strcmp(params, "nextkey");
                          if(return_value_strcmp$12 == 0)
                          {
                            bind_keysym = &nextkeysym;
                            draw_ext_info(0, 20, 4, "Push key to bind new next command in history key.");
                            cpl.input_state = (enum Input_State)Configure_Keys;
                          }

                          else
                          {
                            bind_keysym = (unsigned int *)(void *)0;
                            bind_flags = 0;
                            if((signed int)*params == 45)
                            {
                              params = params + 1l;
                              for( ; !((signed int)*params == 32); params = params + 1l)
                                switch((signed int)*params)
                                {
                                  case 101:
                                  {
                                    bind_flags = bind_flags | 1 << 5;
                                    break;
                                  }
                                  case 105:
                                  {
                                    bind_flags = bind_flags | 1 << 4;
                                    break;
                                  }
                                  case 103:
                                  {
                                    bind_flags = bind_flags | 1 << 6;
                                    break;
                                  }
                                  case 0:
                                  {
                                    draw_ext_info(0, 20, 6, "Use unbind to remove bindings.");
                                    goto __CPROVER_DUMP_L26;
                                  }
                                  default:
                                  {
                                    snprintf(buf, sizeof(char [272l]) /*272ul*/ , "Unsupported or invalid bind flag: '%c'", *params);
                                    draw_ext_info(0, 20, 9, buf);
                                    goto __CPROVER_DUMP_L26;
                                  }
                                }
                              params = params + 1l;
                            }

                            if(*params == 0)
                              draw_ext_info(0, 20, 6, "Use unbind to remove bindings.");

                            else
                            {
                              unsigned long int return_value_strlen$13;
                              return_value_strlen$13=strlen(params);
                              if(return_value_strlen$13 >= sizeof(char [256l]) /*256ul*/ )
                              {
                                params[(signed long int)(sizeof(char [256l]) /*256ul*/  - (unsigned long int)1)] = (char)0;
                                draw_ext_info(3, 20, 9, "Keybinding too long! Truncated:");
                                draw_ext_info(3, 20, 9, params);
                              }

                              snprintf(buf, sizeof(char [272l]) /*272ul*/ , "Push key to bind '%s'.", params);
                              draw_ext_info(0, 20, 4, buf);
                              strcpy(bind_buf, params);
                              cpl.input_state = (enum Input_State)Configure_Keys;
                              goto __CPROVER_DUMP_L26;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

__CPROVER_DUMP_L26:
  ;
}

// cache_newpng
// file image.c line 575
static void cache_newpng(signed int face, unsigned char *buf, signed int buflen, signed int setnum, struct Cache_Entry **ce)
{
  char filename[256l];
  char basename[256l];
  struct _IO_FILE *tmpfile;
  unsigned int i;
  unsigned int csum;
  _Bool tmp_if_expr$5;
  signed int return_value_access$6;
  if(facetoname[(signed long int)face] == ((char *)NULL))
    LOG((enum LogLevel)LOG_WARNING, "common::display_newpng", "Caching images, but name for %ld not set", face);

  else
  {
    char *return_value_getenv$1;
    return_value_getenv$1=getenv("HOME");
    snprintf(filename, sizeof(char [256l]) /*256ul*/ , "%s/%s/crossfire/image-cache", return_value_getenv$1, xdg_cache_dir);
    signed int return_value_access$2;
    return_value_access$2=access(filename, 4 | 2 | 1);
    if(return_value_access$2 == -1)
      mkdir(filename, (unsigned int)0755);

    char *return_value_getenv$3;
    return_value_getenv$3=getenv("HOME");
    snprintf(filename, sizeof(char [256l]) /*256ul*/ , "%s/%s/crossfire/image-cache/%c%c", return_value_getenv$3, xdg_cache_dir, facetoname[(signed long int)face][(signed long int)0], facetoname[(signed long int)face][(signed long int)1]);
    signed int return_value_access$4;
    return_value_access$4=access(filename, 4 | 2 | 1);
    if(return_value_access$4 == -1)
      mkdir(filename, (unsigned int)0755);

    if(setnum >= 0 && !(setnum >= 20))
      tmp_if_expr$5 = face_info.facesets[(signed long int)setnum].prefix != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      snprintf(basename, sizeof(char [256l]) /*256ul*/ , "%s.%s", facetoname[(signed long int)face], face_info.facesets[(signed long int)setnum].prefix);

    else
      strcpy(basename, facetoname[(signed long int)face]);
    setnum = setnum - 1;
    do
    {
      setnum = setnum + 1;
      char *return_value_getenv$7;
      return_value_getenv$7=getenv("HOME");
      snprintf(filename, sizeof(char [256l]) /*256ul*/ , "%s/%s/crossfire/image-cache/%c%c/%s.%d", return_value_getenv$7, xdg_cache_dir, facetoname[(signed long int)face][(signed long int)0], facetoname[(signed long int)face][(signed long int)1], (const void *)basename, setnum);
      return_value_access$6=access(filename, 0);
    }
    while(return_value_access$6 == 0);
    tmpfile=fopen(filename, "w");
    if(tmpfile == ((struct _IO_FILE *)NULL))
      LOG((enum LogLevel)LOG_WARNING, "common::display_newpng", "Can not open %s for writing", (const void *)filename);

    else
    {
      fwrite((const void *)buf, (unsigned long int)buflen, (unsigned long int)1, tmpfile);
      fclose(tmpfile);
      csum = (unsigned int)0;
      i = (unsigned int)0;
      for( ; !((signed int)i >= buflen); i = i + 1u)
      {
        if(!((1u & csum) == 0u))
          csum = (csum >> 1) + 0x80000000;

        else
          csum = csum >> 1;
        csum = csum + (unsigned int)buf[(signed long int)i];
        csum = csum & 0xffffffff;
      }
      snprintf(filename, sizeof(char [256l]) /*256ul*/ , "%c%c/%s.%d", facetoname[(signed long int)face][(signed long int)0], facetoname[(signed long int)face][(signed long int)1], (const void *)basename, setnum);
      *ce=image_add_hash(facetoname[(signed long int)face], filename, csum, (unsigned int)0);
      char *return_value_getenv$8;
      return_value_getenv$8=getenv("HOME");
      snprintf(filename, sizeof(char [256l]) /*256ul*/ , "%s/%s/crossfire/image-cache/bmaps.client", return_value_getenv$8, xdg_cache_dir);
      tmpfile=fopen(filename, "a");
      if(tmpfile == ((struct _IO_FILE *)NULL))
        LOG((enum LogLevel)LOG_WARNING, "common::display_newpng", "Can not open %s for appending", (const void *)filename);

      else
      {
        fprintf(tmpfile, "%s %u %c%c/%s.%d\n", facetoname[(signed long int)face], csum, facetoname[(signed long int)face][(signed long int)0], facetoname[(signed long int)face][(signed long int)1], (const void *)basename, setnum);
        fclose(tmpfile);
      }
    }
  }
}

// can_write_spell_on
// file item.c line 778
extern signed int can_write_spell_on(struct item_struct *it)
{
  return (signed int)((signed int)it->type == 661);
}

// character_data_ok
// file create_char.c line 401
static signed int character_data_ok()
{
  const char *char_name;
  signed int i;
  signed int stat_points_used = 0;
  signed int tmp[7l];
  signed int character_data_ok$$1$$negative_stat = 0;
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_character_name$link1, return_value_gtk_entry_get_type$1);
  char_name=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  _Bool tmp_if_expr$5;
  if(char_name == ((const char *)NULL))
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = (signed int)char_name[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$5)
  {
    unsigned long int return_value_gtk_label_get_type$3;
    return_value_gtk_label_get_type$3=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)label_cc_status_update, return_value_gtk_label_get_type$3);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, "You must enter a character name");
    show_window(1);
    return 0;
  }

  i = 0;
  for( ; !(i >= 7); i = i + 1)
  {
    unsigned long int return_value_gtk_spin_button_get_type$6;
    return_value_gtk_spin_button_get_type$6=gtk_spin_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)spinbutton_cc[(signed long int)i], return_value_gtk_spin_button_get_type$6);
    tmp[(signed long int)i]=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$7);
    stat_points_used = stat_points_used + tmp[(signed long int)i];
  }
  if(!(stat_points >= stat_points_used))
  {
    unsigned long int return_value_gtk_label_get_type$8;
    return_value_gtk_label_get_type$8=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)label_cc_status_update, return_value_gtk_label_get_type$8);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$9, "You have used more than your allotted total attribute points");
    show_window(1);
    return 0;
  }

  if(!(character_data_ok$$1$$negative_stat == 0))
  {
    unsigned long int return_value_gtk_label_get_type$10;
    return_value_gtk_label_get_type$10=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
    return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)label_cc_status_update, return_value_gtk_label_get_type$10);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$11, "Attributes less than 1 are not allowed - adjust your selections before finishing");
    show_window(1);
    return 0;
  }

  if(!(stat_points_used >= stat_points))
  {
    struct _GtkWidget *character_data_ok$$1$$5$$dialog;
    signed int result;
    unsigned long int return_value_gtk_window_get_type$12;
    return_value_gtk_window_get_type$12=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)create_character_window, return_value_gtk_window_get_type$12);
    character_data_ok$$1$$5$$dialog=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$13, (enum anonymous$40)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$41)GTK_MESSAGE_QUESTION, (enum anonymous$42)GTK_BUTTONS_YES_NO, "%s\n%s\n%s", (const void *)"You have not spent all your attribute points.", (const void *)"You will be unable to spend these later.", (const void *)"Create character anyways?");
    unsigned long int return_value_gtk_dialog_get_type$14;
    return_value_gtk_dialog_get_type$14=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)character_data_ok$$1$$5$$dialog, return_value_gtk_dialog_get_type$14);
    result=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$15);
    gtk_widget_destroy(character_data_ok$$1$$5$$dialog);
    if(result == -9)
    {
      show_window(1);
      return 0;
    }

  }

  unsigned long int return_value_gtk_combo_box_get_type$16;
  return_value_gtk_combo_box_get_type$16=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)combobox_starting_map, return_value_gtk_combo_box_get_type$16);
  i=gtk_combo_box_get_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$17);
  if(i == -1 && !(starting_map_number == 0))
  {
    struct _GtkWidget *dialog;
    show_window(2);
    unsigned long int return_value_gtk_window_get_type$18;
    return_value_gtk_window_get_type$18=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
    return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)choose_starting_map_window, return_value_gtk_window_get_type$18);
    dialog=gtk_message_dialog_new((struct _GtkWindow *)return_value_g_type_check_instance_cast$19, (enum anonymous$40)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$41)GTK_MESSAGE_WARNING, (enum anonymous$42)GTK_BUTTONS_OK, "You must choose a starting map before you can start playing");
    unsigned long int return_value_gtk_dialog_get_type$20;
    return_value_gtk_dialog_get_type$20=gtk_dialog_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
    return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$20);
    gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$21);
    gtk_widget_destroy(dialog);
    return 0;
  }

  return (signed int)!(0 != 0);
}

// check_server_version
// file ../../common/proto.h line 99
signed int check_server_version(signed int entry)
{
  _Bool tmp_if_expr$1;
  if((meta_servers + (signed long int)entry)->sc_version == 0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !((meta_servers + (signed long int)entry)->cs_version != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    return 1;

  else
    if(!((meta_servers + (signed long int)entry)->sc_version == 1029))
    {
      if((meta_servers + (signed long int)entry)->sc_version == 1027)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (meta_servers + (signed long int)entry)->sc_version == 1028 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$2)
        goto __CPROVER_DUMP_L6;

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      if(!((meta_servers + (signed long int)entry)->cs_version == 1023))
        return 0;

      else
        return 1;
    }
}

// choose_char_window_show
// file account.c line 457
extern void choose_char_window_show()
{
  gtk_widget_show(choose_char_window);
}

// choose_character_init
// file account.c line 440
extern void choose_character_init(void)
{
  gtk_widget_hide(login_window);
  gtk_widget_hide(add_character_window);
  gtk_widget_hide(create_account_window);
  gtk_widget_show(choose_char_window);
  gtk_list_store_clear(character_store);
}

// cleanup_connection
// file main.c line 154
extern void cleanup_connection(void)
{
  if(!(csocket_fd == 0))
  {
    gdk_input_remove(csocket_fd);
    csocket_fd = 0;
    gtk_main_quit();
  }

}

// clear_fire
// file ../../common/proto.h line 143
void clear_fire(void)
{
  if(!(dfire == -1))
  {
    send_command("fire_stop", -1, 1);
    dfire = -1;
  }

}

// clear_fire_run
// file player.c line 122
void clear_fire_run(void)
{
  if(!((0x100 & dfire) == 0) && !(dfire == -1))
  {
    send_command("fire_stop", -1, 1);
    dfire = -1;
  }

  if(!((0x100 & drun) == 0) && !(drun == -1))
  {
    send_command("run_stop", -1, 1);
    drun = -1;
  }

}

// clear_run
// file ../../common/proto.h line 144
void clear_run(void)
{
  if(!(drun == -1))
  {
    send_command("run_stop", -1, 1);
    drun = -1;
  }

}

// clear_stat_mapping
// file gtk2proto.h line 269
extern void clear_stat_mapping(void)
{
  need_mapping_update = 1;
}

// client_pickup
// file pickup.c line 633
extern void client_pickup(unsigned int pickup)
{
  signed int i;
  no_recurse = (unsigned int)1;
  pmode = pickup;
  i = 0;
  _Bool tmp_if_expr$5;
  for( ; !(i >= num_pickups); i = i + 1)
  {
    if(!((4294967280u & pickup_mapping[(signed long int)i].pickup_mode & pickup) == 0u))
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = (pickup & (unsigned int)0x0000000F) == pickup_mapping[(signed long int)i].pickup_mode ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
    {
      unsigned long int return_value_gtk_check_menu_item_get_type$1;
      return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)pickup_mapping[(signed long int)i].menuitem, return_value_gtk_check_menu_item_get_type$1);
      gtk_check_menu_item_set_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2, 1);
    }

    else
    {
      unsigned long int return_value_gtk_check_menu_item_get_type$3;
      return_value_gtk_check_menu_item_get_type$3=gtk_check_menu_item_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)pickup_mapping[(signed long int)i].menuitem, return_value_gtk_check_menu_item_get_type$3);
      gtk_check_menu_item_set_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$4, 0);
    }
  }
  no_recurse = (unsigned int)0;
}

// client_send_apply
// file ../../common/proto.h line 137
void client_send_apply(signed int tag)
{
  cs_print_string(csocket.fd, "apply %d", tag);
}

// client_send_examine
// file ../../common/proto.h line 138
void client_send_examine(signed int tag)
{
  cs_print_string(csocket.fd, "examine %d", tag);
}

// client_send_move
// file ../../common/proto.h line 139
void client_send_move(signed int loc, signed int tag, signed int nrof)
{
  cs_print_string(csocket.fd, "move %d %d %d", loc, tag, nrof);
}

// client_tick
// file main.c line 126
extern void client_tick(unsigned int tick)
{
  info_buffer_tick();
  inventory_tick();
  mapdata_animation();
  if(tick % 5u == 0u && !(have_new_image == 0))
  {
    if(!(cpl.container == ((struct item_struct *)NULL)))
      cpl.container->inv_updated = (unsigned short int)1;

    cpl.ob->inv_updated = (unsigned short int)1;
    have_new_image = 0;
    draw_map(1);
    draw_lists();
  }

  else
    draw_map(0);
}

// close_container
// file inventory.c line 595
extern void close_container(struct item_struct *op)
{
  draw_lists();
}

// close_server_connection
// file ../../common/proto.h line 6
void close_server_connection(void)
{
  close(csocket.fd);
  csocket.fd = -1;
}

// command_foodbeep
// file p_cmd.c line 347
static void command_foodbeep(const char *cpnext)
{
  (void)cpnext;
  if(!(want_config[21l] == 0))
  {
    want_config[(signed long int)21] = (signed short int)0;
    draw_ext_info(0, 20, 6, "Warning bell when low on food disabled");
  }

  else
  {
    want_config[(signed long int)21] = (signed short int)1;
    draw_ext_info(0, 20, 6, "Warning bell when low on food enabled");
  }
  use_config[(signed long int)21] = want_config[(signed long int)21];
}

// command_help
// file p_cmd.c line 269
static void command_help(const char *cpnext)
{
  if(!(cpnext == ((const char *)NULL)))
  {
    const struct anonymous$47 *cc;
    char buf[256l];
    cc=find_command(cpnext);
    if(!(cc == ((const struct anonymous$47 *)NULL)))
      show_help(cc);

    else
    {
      snprintf(buf, sizeof(char [256l]) /*256ul*/ , "help %s", cpnext);
      send_command(buf, -1, 1);
    }
  }

  else
  {
    do_clienthelp_list();
    send_command("help", -1, 1);
  }
}

// command_show
// file inventory.c line 613
extern void command_show(const char *params)
{
  if(params == ((const char *)NULL))
  {
    unsigned long int return_value_gtk_notebook_get_type$5;
    return_value_gtk_notebook_get_type$5=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)inv_notebook, return_value_gtk_notebook_get_type$5);
    signed int return_value_gtk_notebook_get_current_page$7;
    return_value_gtk_notebook_get_current_page$7=gtk_notebook_get_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$6);
    if(return_value_gtk_notebook_get_current_page$7 == num_inv_notebook_pages)
    {
      unsigned long int return_value_gtk_notebook_get_type$1;
      return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)inv_notebook, return_value_gtk_notebook_get_type$1);
      gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2, 0);
    }

    else
    {
      unsigned long int return_value_gtk_notebook_get_type$3;
      return_value_gtk_notebook_get_type$3=gtk_notebook_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)inv_notebook, return_value_gtk_notebook_get_type$3);
      gtk_notebook_next_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$4);
    }
  }

  else
  {
    signed int i;
    char buf[256l];
    i = 0;
    for( ; !(i >= 11); i = i + 1)
    {
      unsigned long int return_value_strlen$10;
      return_value_strlen$10=strlen(params);
      signed int return_value_strncmp$11;
      return_value_strncmp$11=strncmp(params, inv_notebooks[(signed long int)i].name, return_value_strlen$10);
      if(return_value_strncmp$11 == 0)
      {
        unsigned long int return_value_gtk_notebook_get_type$8;
        return_value_gtk_notebook_get_type$8=gtk_notebook_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
        return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)inv_notebook, return_value_gtk_notebook_get_type$8);
        gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$9, i);
        goto __CPROVER_DUMP_L7;
      }

    }
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Unknown notebook page %s\n", params);
    draw_ext_info(3, 20, 9, buf);
  }

__CPROVER_DUMP_L7:
  ;
}

// command_take
// file ./proto.h line 150
void command_take(const char *command, const char *cpnext)
{
  if(cpl.container == ((struct item_struct *)NULL) || !(cpnext == ((const char *)NULL)))
    send_command(command, (signed int)cpl.count, 0);

  else
    if(cpl.container->inv == ((struct item_struct *)NULL))
      draw_ext_info(0, 20, 6, "There is nothing in the container to move");

    else
      cs_print_string(csocket.fd, "move %d %d %d", cpl.ob->tag, cpl.container->inv->tag, cpl.count);
}

// common_item_command
// file commands.c line 1649
static void common_item_command(unsigned char *data, signed int len)
{
  signed int weight;
  signed int loc;
  signed int tag;
  signed int face;
  signed int flags;
  signed int pos = 0;
  signed int nlen;
  signed int anim;
  signed int nrof;
  signed int type;
  unsigned char animspeed;
  char name[256l];
  loc=GetInt_String(data);
  pos = pos + 4;
  signed int tmp_post$1;
  signed int tmp_post$3;
  if(pos == len)
  {
    LOG((enum LogLevel)LOG_WARNING, "common::common_item_command", "Got location with no other data");
    goto __CPROVER_DUMP_L5;
  }

  else
    if(!(loc >= 0))
    {
      LOG((enum LogLevel)LOG_WARNING, "common::common_item_command", "Got location with negative value (%d)", loc);
      goto __CPROVER_DUMP_L5;
    }

    else
    {
      while(!(pos >= len))
      {
        tag=GetInt_String(data + (signed long int)pos);
        pos = pos + 4;
        flags=GetInt_String(data + (signed long int)pos);
        pos = pos + 4;
        weight=GetInt_String(data + (signed long int)pos);
        pos = pos + 4;
        face=GetInt_String(data + (signed long int)pos);
        pos = pos + 4;
        tmp_post$1 = pos;
        pos = pos + 1;
        nlen = (signed int)data[(signed long int)tmp_post$1];
        memcpy((void *)name, (const void *)((char *)data + (signed long int)pos), (unsigned long int)nlen);
        pos = pos + nlen;
        name[(signed long int)nlen] = (char)0;
        signed short int return_value_GetShort_String$2;
        return_value_GetShort_String$2=GetShort_String(data + (signed long int)pos);
        anim = (signed int)return_value_GetShort_String$2;
        pos = pos + 2;
        tmp_post$3 = pos;
        pos = pos + 1;
        animspeed = data[(signed long int)tmp_post$3];
        nrof=GetInt_String(data + (signed long int)pos);
        pos = pos + 4;
        signed short int return_value_GetShort_String$4;
        return_value_GetShort_String$4=GetShort_String(data + (signed long int)pos);
        type = (signed int)return_value_GetShort_String$4;
        pos = pos + 2;
        update_item(tag, loc, name, weight, face, flags, anim, (signed int)animspeed, (unsigned int)nrof, type);
        struct item_struct *return_value_locate_item$5;
        return_value_locate_item$5=locate_item(tag);
        item_actions(return_value_locate_item$5);
      }
      if(!(len >= pos))
        LOG((enum LogLevel)LOG_WARNING, "common::common_item_cmd", "Overread buffer: %d > %d", pos, len);

    }

__CPROVER_DUMP_L5:
  ;
}

// complete_command
// file ../../common/p_cmd.h line 103
extern const char * complete_command(const char *command)
{
  signed int i;
  signed int len;
  signed int complete_command$$1$$display;
  const char *match;
  char list[500l];
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(command);
  len = (signed int)return_value_strlen$1;
  if(len == 0)
    return (const char *)(void *)0;

  else
  {
    complete_command$$1$$display = 0;
    strcpy(list, "Matching commands:");
    match = (const char *)(void *)0;
    i = 0;
    for( ; !(i >= 141); i = i + 1)
    {
      signed int return_value_strncmp$6;
      return_value_strncmp$6=strncmp(command, commands$link1[(signed long int)i], (unsigned long int)len);
      if(return_value_strncmp$6 == 0)
      {
        if(!(complete_command$$1$$display == 0))
        {
          unsigned long int return_value_strlen$2;
          return_value_strlen$2=strlen(list);
          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(list);
          snprintf(list + (signed long int)return_value_strlen$2, (unsigned long int)499 - return_value_strlen$3, " %s", commands$link1[(signed long int)i]);
        }

        else
          if(!(match == ((const char *)NULL)))
          {
            complete_command$$1$$display = 1;
            unsigned long int return_value_strlen$4;
            return_value_strlen$4=strlen(list);
            unsigned long int return_value_strlen$5;
            return_value_strlen$5=strlen(list);
            snprintf(list + (signed long int)return_value_strlen$4, (unsigned long int)499 - return_value_strlen$5, " %s %s", match, commands$link1[(signed long int)i]);
            match = (const char *)(void *)0;
          }

          else
            match = commands$link1[(signed long int)i];
      }

    }
    i = 0;
    for( ; !(i >= CommonCommandsSize); i = i + 1)
    {
      signed int return_value_strncmp$11;
      return_value_strncmp$11=strncmp(command, CommonCommands[(signed long int)i].name, (unsigned long int)len);
      if(return_value_strncmp$11 == 0)
      {
        if(!(complete_command$$1$$display == 0))
        {
          unsigned long int return_value_strlen$7;
          return_value_strlen$7=strlen(list);
          unsigned long int return_value_strlen$8;
          return_value_strlen$8=strlen(list);
          snprintf(list + (signed long int)return_value_strlen$7, (unsigned long int)499 - return_value_strlen$8, " %s", CommonCommands[(signed long int)i].name);
        }

        else
          if(!(match == ((const char *)NULL)))
          {
            complete_command$$1$$display = 1;
            unsigned long int return_value_strlen$9;
            return_value_strlen$9=strlen(list);
            unsigned long int return_value_strlen$10;
            return_value_strlen$10=strlen(list);
            snprintf(list + (signed long int)return_value_strlen$9, (unsigned long int)499 - return_value_strlen$10, " %s %s", match, CommonCommands[(signed long int)i].name);
            match = (const char *)(void *)0;
          }

          else
            match = CommonCommands[(signed long int)i].name;
      }

    }
    if(match == ((const char *)NULL))
    {
      if(!(complete_command$$1$$display == 0))
      {
        unsigned long int return_value_strlen$12;
        return_value_strlen$12=strlen(list);
        strncat(list, "\n", (unsigned long int)499 - return_value_strlen$12);
        draw_ext_info(0, 20, 6, list);
      }

      else
        draw_ext_info(0, 20, 6, "No matching command.\n");
      return (const char *)(void *)0;
    }

    else
    {
      static char result[64l];
      snprintf(result, sizeof(char [64l]) /*64ul*/ , "%s ", match);
      return result;
    }
  }
}

// config_init
// file config.c line 491
extern void config_init(struct _GtkWidget *window_root)
{
  struct _GtkWidget *widget;
  signed int count;
  signed int i;
  static signed int config_init$$1$$has_init = 0;
  config_init$$1$$has_init = 1;
  struct _GObject *return_value_gtk_builder_get_object$1;
  return_value_gtk_builder_get_object$1=gtk_builder_get_object(dialog_xml, "config_window");
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
  config_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
  struct _GObject *return_value_gtk_builder_get_object$4;
  return_value_gtk_builder_get_object$4=gtk_builder_get_object(dialog_xml, "config_spinbutton_cwindow");
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$4, return_value_gtk_widget_get_type$5);
  config_spinbutton_cwindow = (struct _GtkWidget *)return_value_g_type_check_instance_cast$6;
  struct _GObject *return_value_gtk_builder_get_object$7;
  return_value_gtk_builder_get_object$7=gtk_builder_get_object(dialog_xml, "config_button_echo");
  unsigned long int return_value_gtk_widget_get_type$8;
  return_value_gtk_widget_get_type$8=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$7, return_value_gtk_widget_get_type$8);
  config_button_echo = (struct _GtkWidget *)return_value_g_type_check_instance_cast$9;
  struct _GObject *return_value_gtk_builder_get_object$10;
  return_value_gtk_builder_get_object$10=gtk_builder_get_object(dialog_xml, "config_button_fasttcp");
  unsigned long int return_value_gtk_widget_get_type$11;
  return_value_gtk_widget_get_type$11=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$10, return_value_gtk_widget_get_type$11);
  config_button_fasttcp = (struct _GtkWidget *)return_value_g_type_check_instance_cast$12;
  struct _GObject *return_value_gtk_builder_get_object$13;
  return_value_gtk_builder_get_object$13=gtk_builder_get_object(dialog_xml, "config_button_timestamp");
  unsigned long int return_value_gtk_widget_get_type$14;
  return_value_gtk_widget_get_type$14=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$13, return_value_gtk_widget_get_type$14);
  config_button_timestamp = (struct _GtkWidget *)return_value_g_type_check_instance_cast$15;
  struct _GObject *return_value_gtk_builder_get_object$16;
  return_value_gtk_builder_get_object$16=gtk_builder_get_object(dialog_xml, "config_button_grad_color");
  unsigned long int return_value_gtk_widget_get_type$17;
  return_value_gtk_widget_get_type$17=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$16, return_value_gtk_widget_get_type$17);
  config_button_grad_color = (struct _GtkWidget *)return_value_g_type_check_instance_cast$18;
  struct _GObject *return_value_gtk_builder_get_object$19;
  return_value_gtk_builder_get_object$19=gtk_builder_get_object(dialog_xml, "config_button_foodbeep");
  unsigned long int return_value_gtk_widget_get_type$20;
  return_value_gtk_widget_get_type$20=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
  return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$19, return_value_gtk_widget_get_type$20);
  config_button_foodbeep = (struct _GtkWidget *)return_value_g_type_check_instance_cast$21;
  struct _GObject *return_value_gtk_builder_get_object$22;
  return_value_gtk_builder_get_object$22=gtk_builder_get_object(dialog_xml, "config_button_sound");
  unsigned long int return_value_gtk_widget_get_type$23;
  return_value_gtk_widget_get_type$23=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$22, return_value_gtk_widget_get_type$23);
  config_button_sound = (struct _GtkWidget *)return_value_g_type_check_instance_cast$24;
  struct _GObject *return_value_gtk_builder_get_object$25;
  return_value_gtk_builder_get_object$25=gtk_builder_get_object(dialog_xml, "config_button_cache");
  unsigned long int return_value_gtk_widget_get_type$26;
  return_value_gtk_widget_get_type$26=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
  return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$25, return_value_gtk_widget_get_type$26);
  config_button_cache = (struct _GtkWidget *)return_value_g_type_check_instance_cast$27;
  struct _GObject *return_value_gtk_builder_get_object$28;
  return_value_gtk_builder_get_object$28=gtk_builder_get_object(dialog_xml, "config_button_download");
  unsigned long int return_value_gtk_widget_get_type$29;
  return_value_gtk_widget_get_type$29=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$28, return_value_gtk_widget_get_type$29);
  config_button_download = (struct _GtkWidget *)return_value_g_type_check_instance_cast$30;
  struct _GObject *return_value_gtk_builder_get_object$31;
  return_value_gtk_builder_get_object$31=gtk_builder_get_object(dialog_xml, "config_button_fog");
  unsigned long int return_value_gtk_widget_get_type$32;
  return_value_gtk_widget_get_type$32=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
  return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$31, return_value_gtk_widget_get_type$32);
  config_button_fog = (struct _GtkWidget *)return_value_g_type_check_instance_cast$33;
  struct _GObject *return_value_gtk_builder_get_object$34;
  return_value_gtk_builder_get_object$34=gtk_builder_get_object(dialog_xml, "config_button_smoothing");
  unsigned long int return_value_gtk_widget_get_type$35;
  return_value_gtk_widget_get_type$35=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
  return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$34, return_value_gtk_widget_get_type$35);
  config_button_smoothing = (struct _GtkWidget *)return_value_g_type_check_instance_cast$36;
  struct _GObject *return_value_gtk_builder_get_object$37;
  return_value_gtk_builder_get_object$37=gtk_builder_get_object(dialog_xml, "config_spinbutton_iconscale");
  unsigned long int return_value_gtk_widget_get_type$38;
  return_value_gtk_widget_get_type$38=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$39;
  return_value_g_type_check_instance_cast$39=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$37, return_value_gtk_widget_get_type$38);
  config_spinbutton_iconscale = (struct _GtkWidget *)return_value_g_type_check_instance_cast$39;
  struct _GObject *return_value_gtk_builder_get_object$40;
  return_value_gtk_builder_get_object$40=gtk_builder_get_object(dialog_xml, "config_spinbutton_mapscale");
  unsigned long int return_value_gtk_widget_get_type$41;
  return_value_gtk_widget_get_type$41=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$42;
  return_value_g_type_check_instance_cast$42=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$40, return_value_gtk_widget_get_type$41);
  config_spinbutton_mapscale = (struct _GtkWidget *)return_value_g_type_check_instance_cast$42;
  struct _GObject *return_value_gtk_builder_get_object$43;
  return_value_gtk_builder_get_object$43=gtk_builder_get_object(dialog_xml, "config_spinbutton_mapwidth");
  unsigned long int return_value_gtk_widget_get_type$44;
  return_value_gtk_widget_get_type$44=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$45;
  return_value_g_type_check_instance_cast$45=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$43, return_value_gtk_widget_get_type$44);
  config_spinbutton_mapwidth = (struct _GtkWidget *)return_value_g_type_check_instance_cast$45;
  struct _GObject *return_value_gtk_builder_get_object$46;
  return_value_gtk_builder_get_object$46=gtk_builder_get_object(dialog_xml, "config_spinbutton_mapheight");
  unsigned long int return_value_gtk_widget_get_type$47;
  return_value_gtk_widget_get_type$47=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$48;
  return_value_g_type_check_instance_cast$48=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$46, return_value_gtk_widget_get_type$47);
  config_spinbutton_mapheight = (struct _GtkWidget *)return_value_g_type_check_instance_cast$48;
  struct _GObject *return_value_gtk_builder_get_object$49;
  return_value_gtk_builder_get_object$49=gtk_builder_get_object(dialog_xml, "config_combobox_displaymode");
  unsigned long int return_value_gtk_widget_get_type$50;
  return_value_gtk_widget_get_type$50=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$51;
  return_value_g_type_check_instance_cast$51=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$49, return_value_gtk_widget_get_type$50);
  config_combobox_displaymode = (struct _GtkWidget *)return_value_g_type_check_instance_cast$51;
  struct _GObject *return_value_gtk_builder_get_object$52;
  return_value_gtk_builder_get_object$52=gtk_builder_get_object(dialog_xml, "config_combobox_faceset");
  unsigned long int return_value_gtk_widget_get_type$53;
  return_value_gtk_widget_get_type$53=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$54;
  return_value_g_type_check_instance_cast$54=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$52, return_value_gtk_widget_get_type$53);
  config_combobox_faceset = (struct _GtkWidget *)return_value_g_type_check_instance_cast$54;
  struct _GObject *return_value_gtk_builder_get_object$55;
  return_value_gtk_builder_get_object$55=gtk_builder_get_object(dialog_xml, "config_combobox_lighting");
  unsigned long int return_value_gtk_widget_get_type$56;
  return_value_gtk_widget_get_type$56=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$57;
  return_value_g_type_check_instance_cast$57=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$55, return_value_gtk_widget_get_type$56);
  config_combobox_lighting = (struct _GtkWidget *)return_value_g_type_check_instance_cast$57;
  struct _GObject *return_value_gtk_builder_get_object$58;
  return_value_gtk_builder_get_object$58=gtk_builder_get_object(dialog_xml, "config_combobox_theme");
  unsigned long int return_value_gtk_widget_get_type$59;
  return_value_gtk_widget_get_type$59=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$60;
  return_value_g_type_check_instance_cast$60=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$58, return_value_gtk_widget_get_type$59);
  config_combobox_theme = (struct _GtkWidget *)return_value_g_type_check_instance_cast$60;
  struct _GObject *return_value_gtk_builder_get_object$61;
  return_value_gtk_builder_get_object$61=gtk_builder_get_object(dialog_xml, "config_combobox_glade");
  unsigned long int return_value_gtk_widget_get_type$62;
  return_value_gtk_widget_get_type$62=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$63;
  return_value_g_type_check_instance_cast$63=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$61, return_value_gtk_widget_get_type$62);
  config_combobox_layout = (struct _GtkWidget *)return_value_g_type_check_instance_cast$63;
  g_signal_connect_data((void *)config_window, "delete_event", (void (*)(void))gtk_widget_hide_on_delete, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$64;
  return_value_gtk_builder_get_object$64=gtk_builder_get_object(dialog_xml, "config_button_save");
  unsigned long int return_value_gtk_widget_get_type$65;
  return_value_gtk_widget_get_type$65=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$66;
  return_value_g_type_check_instance_cast$66=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$64, return_value_gtk_widget_get_type$65);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$66;
  g_signal_connect_data((void *)widget, "clicked", (void (*)(void))on_config_button_save_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$67;
  return_value_gtk_builder_get_object$67=gtk_builder_get_object(dialog_xml, "config_button_apply");
  unsigned long int return_value_gtk_widget_get_type$68;
  return_value_gtk_widget_get_type$68=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$69;
  return_value_g_type_check_instance_cast$69=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$67, return_value_gtk_widget_get_type$68);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$69;
  g_signal_connect_data((void *)widget, "clicked", (void (*)(void))on_config_button_apply_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$70;
  return_value_gtk_builder_get_object$70=gtk_builder_get_object(dialog_xml, "config_button_close");
  unsigned long int return_value_gtk_widget_get_type$71;
  return_value_gtk_widget_get_type$71=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$72;
  return_value_g_type_check_instance_cast$72=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$70, return_value_gtk_widget_get_type$71);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$72;
  g_signal_connect_data((void *)widget, "clicked", (void (*)(void))on_config_button_close_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  unsigned long int return_value_gtk_combo_box_get_type$73;
  return_value_gtk_combo_box_get_type$73=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$74;
  return_value_g_type_check_instance_cast$74=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_displaymode, return_value_gtk_combo_box_get_type$73);
  struct _GtkTreeModel *return_value_gtk_combo_box_get_model$75;
  return_value_gtk_combo_box_get_model$75=gtk_combo_box_get_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$74);
  count=gtk_tree_model_iter_n_children(return_value_gtk_combo_box_get_model$75, (struct _GtkTreeIter *)(void *)0);
  i = 0;
  for( ; !(i >= count); i = i + 1)
  {
    unsigned long int return_value_gtk_combo_box_get_type$76;
    return_value_gtk_combo_box_get_type$76=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$77;
    return_value_g_type_check_instance_cast$77=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_displaymode, return_value_gtk_combo_box_get_type$76);
    gtk_combo_box_remove_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$77, 0);
  }
  unsigned long int return_value_gtk_combo_box_get_type$78;
  return_value_gtk_combo_box_get_type$78=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$79;
  return_value_g_type_check_instance_cast$79=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_displaymode, return_value_gtk_combo_box_get_type$78);
  gtk_combo_box_append_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$79, "OpenGL");
  unsigned long int return_value_gtk_combo_box_get_type$80;
  return_value_gtk_combo_box_get_type$80=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$81;
  return_value_g_type_check_instance_cast$81=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_displaymode, return_value_gtk_combo_box_get_type$80);
  gtk_combo_box_append_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$81, "SDL");
  unsigned long int return_value_gtk_combo_box_get_type$82;
  return_value_gtk_combo_box_get_type$82=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$83;
  return_value_g_type_check_instance_cast$83=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_displaymode, return_value_gtk_combo_box_get_type$82);
  gtk_combo_box_append_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$83, "Pixmap");
}

// configure_keys
// file keys.c line 1367
static void configure_keys(unsigned int keysym)
{
  char buf[256l];
  struct keybind *kb;
  keysym=gdk_keyval_to_lower(keysym);
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  char *tmp_if_expr$6;
  char *return_value_gdk_keyval_name$5;
  if(bind_keysym == ((unsigned int *)NULL))
  {
    if(keysym == altkeysym[0l])
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = keysym == altkeysym[(signed long int)1] ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      cpl.alt_on = (unsigned int)1;
      goto __CPROVER_DUMP_L22;
    }

    if(keysym == metakeysym[0l])
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = keysym == metakeysym[(signed long int)1] ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      cpl.meta_on = (unsigned int)1;
      goto __CPROVER_DUMP_L22;
    }

    if(keysym == firekeysym[0l])
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = keysym == firekeysym[(signed long int)1] ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      cpl.fire_on = (unsigned int)1;
      draw_message_window(0);
      goto __CPROVER_DUMP_L22;
    }

    if(keysym == runkeysym[0l])
      tmp_if_expr$4 = (_Bool)1;

    else
      tmp_if_expr$4 = keysym == runkeysym[(signed long int)1] ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$4)
      goto __CPROVER_DUMP_L12;

    cpl.run_on = (unsigned int)1;
    draw_message_window(0);
  }

  else
  {

  __CPROVER_DUMP_L12:
    ;
    if((16 & bind_flags) == 0)
    {
      if(!(cpl.fire_on == 0u))
        bind_flags = bind_flags | 1 << 0;

      if(!(cpl.run_on == 0u))
        bind_flags = bind_flags | 1 << 1;

      if(!(cpl.meta_on == 0u))
        bind_flags = bind_flags | 1 << 3;

      if(!(cpl.alt_on == 0u))
        bind_flags = bind_flags | 1 << 2;

    }

    cpl.input_state = (enum Input_State)Playing;
    if(!(bind_keysym == ((unsigned int *)NULL)))
    {
      *bind_keysym = keysym;
      bind_keysym = (unsigned int *)(void *)0;
    }

    else
    {
      kb=keybind_find(keysym, (unsigned int)bind_flags, bind_flags & 1 << 6);
      if(!(kb == ((struct keybind *)NULL)))
      {
        snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Error: Key already used for command \"%s\". Use unbind first.", kb->command);
        draw_ext_info(3, 20, 9, buf);
        goto __CPROVER_DUMP_L22;
      }

      else
        keybind_insert(keysym, (unsigned int)bind_flags, bind_buf);
    }
    if((signed long int)keysym == 0L)
      tmp_if_expr$6 = "unknown";

    else
    {
      return_value_gdk_keyval_name$5=gdk_keyval_name(keysym);
      tmp_if_expr$6 = return_value_gdk_keyval_name$5;
    }
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Bound to key '%s' (%i)", tmp_if_expr$6, keysym);
    draw_ext_info(0, 20, 1, buf);
    draw_message_window(0);
    save_keys();
    goto __CPROVER_DUMP_L22;
  }

__CPROVER_DUMP_L22:
  ;
}

// create_and_rescale_image_from_data
// file image.c line 293
extern signed int create_and_rescale_image_from_data(struct Cache_Entry *ce, signed int pixmap_num, unsigned char *rgba_data, signed int width, signed int height)
{
  signed int nx;
  signed int ny;
  signed int iscale;
  signed int factor;
  unsigned char *png_tmp;
  struct PixmapInfo *pi;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  if(pixmap_num >= 10000 || !(pixmap_num >= 1))
    return 1;

  else
  {
    if(!(pixmaps[(signed long int)pixmap_num] == pixmaps[0l]))
    {
      if(use_config[5l] == 0)
      {
        free_pixmap(pixmaps[(signed long int)pixmap_num]);
        free((void *)pixmaps[(signed long int)pixmap_num]);
      }

      pixmaps[(signed long int)pixmap_num] = pixmaps[(signed long int)0];
    }

    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct PixmapInfo) /*72ul*/ );
    pi = (struct PixmapInfo *)return_value_calloc$1;
    iscale = (signed int)use_config[(signed long int)7];
    if(height >= 33 || width >= 33)
    {
      signed int ts = 100;
      factor = width / 32;
      if(factor >= 10)
        factor = 10 - 1;

      if(!(icon_rescale_factor[(signed long int)factor] >= ts))
        ts = icon_rescale_factor[(signed long int)factor];

      factor = height / 32;
      if(factor >= 10)
        factor = 10 - 1;

      if(!(icon_rescale_factor[(signed long int)factor] >= ts))
        ts = icon_rescale_factor[(signed long int)factor];

      iscale = (ts * (signed int)use_config[(signed long int)7]) / 100;
    }

    if(!(iscale == 100))
    {
      nx = width;
      ny = height;
      png_tmp=rescale_rgba_data(rgba_data, &nx, &ny, iscale);
      pi->icon_width = (unsigned short int)nx;
      pi->icon_height = (unsigned short int)ny;
      create_icon_image(png_tmp, pi, pixmap_num);
      free((void *)png_tmp);
    }

    else
    {
      pi->icon_width = (unsigned short int)width;
      pi->icon_height = (unsigned short int)height;
      create_icon_image(rgba_data, pi, pixmap_num);
    }
    if(!((signed int)use_config[8l] == 100))
    {
      nx = width;
      ny = height;
      png_tmp=rescale_rgba_data(rgba_data, &nx, &ny, (signed int)use_config[(signed long int)8]);
      pi->map_width = (unsigned short int)nx;
      pi->map_height = (unsigned short int)ny;
      create_map_image(png_tmp, pi);
      if((signed int)use_config[10l] == 0)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)use_config[(signed long int)10] == 2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        free((void *)png_tmp);

    }

    else
    {
      pi->map_width = (unsigned short int)width;
      pi->map_height = (unsigned short int)height;
      if((signed int)use_config[10l] == 1)
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc((unsigned long int)(width * height * 4));
        png_tmp = (unsigned char *)return_value_malloc$3;
        memcpy((void *)png_tmp, (const void *)rgba_data, (unsigned long int)(width * height * 4));
      }

      else
        png_tmp = rgba_data;
      create_map_image(png_tmp, pi);
    }
    if(pi->icon_image == NULL)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      if(pi->map_image == NULL)
        tmp_if_expr$4 = (signed int)use_config[(signed long int)10] != 2 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
    {
      free_pixmap(pi);
      free((void *)pi);
      return 1;
    }

    else
    {
      if(!(ce == ((struct Cache_Entry *)NULL)))
        ce->image_data = (void *)pi;

      pixmaps[(signed long int)pixmap_num] = pi;
      if(!(use_config[5l] == 0))
        have_new_image = have_new_image + 1;

      return 0;
    }
  }
}

// create_character_set_sensitive
// file create_char.c line 123
static void create_character_set_sensitive(signed int sensitive)
{
  signed int i;
  gtk_widget_set_sensitive(button_cc_done, sensitive);
  gtk_widget_set_sensitive(button_choose_starting_map, sensitive);
  gtk_widget_set_sensitive(entry_new_character_name$link1, sensitive);
  gtk_widget_set_sensitive(combobox_rs, sensitive);
  gtk_widget_set_sensitive(combobox_cs, sensitive);
  i = 0;
  for( ; !(i >= 7); i = i + 1)
    gtk_widget_set_sensitive(spinbutton_cc[(signed long int)i], sensitive);
  if(!(starting_map_number == 0))
    gtk_widget_show(button_choose_starting_map);

  else
    gtk_widget_hide(button_choose_starting_map);
}

// create_character_window_hide
// file gtk2proto.h line 53
extern void create_character_window_hide()
{
  show_window(0);
}

// create_character_window_show
// file gtk2proto.h line 52
extern void create_character_window_show()
{
  signed int reset_needed = 0;
  if(races == ((struct Race_Class_Info *)NULL))
  {
    cs_print_string(csocket.fd, "requestinfo race_list");
    reset_needed = 1;
  }

  if(classes == ((struct Race_Class_Info *)NULL))
  {
    cs_print_string(csocket.fd, "requestinfo class_list");
    reset_needed = 1;
  }

  if(stat_points == 0)
  {
    cs_print_string(csocket.fd, "requestinfo newcharinfo");
    reset_needed = 1;
  }

  if(!(reset_needed == 0))
  {
    unsigned long int return_value_gtk_label_get_type$1;
    return_value_gtk_label_get_type$1=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)label_cc_status_update, return_value_gtk_label_get_type$1);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, "Getting race & class information from the server");
    create_character_set_sensitive(0);
  }

  gtk_widget_show(create_character_window);
}

// create_icon_image
// file image.c line 122
static void create_icon_image(unsigned char *data, struct PixmapInfo *pi, signed int pixmap_num)
{
  pi->icon_mask = (void *)0;
  signed int return_value_rgba_to_gdkpixbuf$1;
  return_value_rgba_to_gdkpixbuf$1=rgba_to_gdkpixbuf(data, (signed int)pi->icon_width, (signed int)pi->icon_height, (struct _GdkPixbuf **)&pi->icon_image);
  if(!(return_value_rgba_to_gdkpixbuf$1 == 0))
    LOG((enum LogLevel)LOG_ERROR, "gtk-v2::create_icon_image", "Unable to create scaled image, dest num = %d\n", pixmap_num);

}

// create_map_image
// file image.c line 137
static void create_map_image(unsigned char *data, struct PixmapInfo *pi)
{
  pi->map_image = (void *)0;
  pi->map_mask = (void *)0;
  signed int tmp_if_expr$2;
  unsigned int tmp_if_expr$3;
  if((signed int)use_config[10l] == 1)
  {
    signed int i;
    struct SDL_Surface *fog;
    unsigned int g;
    unsigned int *p;
    unsigned char *l;
    struct SDL_Surface *return_value_SDL_CreateRGBSurfaceFrom$1;
    return_value_SDL_CreateRGBSurfaceFrom$1=SDL_CreateRGBSurfaceFrom((void *)data, (signed int)pi->map_width, (signed int)pi->map_height, 32, (signed int)pi->map_width * 4, (unsigned int)0xff, (unsigned int)0xff00, (unsigned int)0xff0000, 0xff000000);
    pi->map_image = (void *)return_value_SDL_CreateRGBSurfaceFrom$1;
    fog=SDL_CreateRGBSurface((unsigned int)(0x00010000 | 0x00000001), (signed int)pi->map_width, (signed int)pi->map_height, 32, (unsigned int)0xff, (unsigned int)0xff00, (unsigned int)0xff0000, 0xff000000);
    SDL_LockSurface(fog);
    i = 0;
    for( ; !(i >= (signed int)pi->map_height * (signed int)pi->map_width); i = i + 1)
    {
      l = (unsigned char *)(data + (signed long int)(i * 4));
      if(!((signed int)l[1l] >= (signed int)*l))
        tmp_if_expr$2 = (signed int)*l;

      else
        tmp_if_expr$2 = (signed int)l[(signed long int)1];
      g = (unsigned int)tmp_if_expr$2;
      if(!((unsigned int)l[2l] >= g))
        tmp_if_expr$3 = g;

      else
        tmp_if_expr$3 = (unsigned int)l[(signed long int)2];
      g = tmp_if_expr$3;
      p = (unsigned int *)fog->pixels + (signed long int)i;
      *p = g | g << 8 | g << 16 | (unsigned int)((signed int)l[(signed long int)3] << 24);
    }
    SDL_UnlockSurface(fog);
    pi->fog_image = (void *)fog;
  }

  else
    if((signed int)use_config[10l] == 2)
      create_opengl_map_image(data, pi);

    else
      if((signed int)use_config[10l] == 0)
      {
        struct _GdkColormap *return_value_gtk_widget_get_colormap$4;
        return_value_gtk_widget_get_colormap$4=gtk_widget_get_colormap(window_root);
        rgba_to_gdkpixmap(window_root->window, data, (signed int)pi->map_width, (signed int)pi->map_height, (struct _GdkDrawable **)&pi->map_image, (struct _GdkDrawable **)&pi->map_mask, return_value_gtk_widget_get_colormap$4);
      }

}

// create_new_character
// file account.c line 163
static void create_new_character()
{
  const char *name;
  unsigned char buf[256l];
  struct SockList sl;
  SockList_Init(&sl, buf);
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_character_name, return_value_gtk_entry_get_type$1);
  name=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  _Bool tmp_if_expr$9;
  if(name == ((const char *)NULL))
    tmp_if_expr$9 = (_Bool)1;

  else
    tmp_if_expr$9 = (signed int)*name == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$9)
  {
    unsigned long int return_value_gtk_label_get_type$3;
    return_value_gtk_label_get_type$3=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)label_new_char_status, return_value_gtk_label_get_type$3);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, "You must enter a character name.");
    goto __CPROVER_DUMP_L5;
  }

  else
  {
    unsigned long int return_value_gtk_label_get_type$5;
    return_value_gtk_label_get_type$5=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)label_new_char_status, return_value_gtk_label_get_type$5);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$6, "");
    SockList_AddString(&sl, "createplayer ");
    unsigned long int return_value_strlen$7;
    return_value_strlen$7=strlen(name);
    SockList_AddChar(&sl, (char)return_value_strlen$7);
    SockList_AddString(&sl, name);
    unsigned long int return_value_strlen$8;
    return_value_strlen$8=strlen(account_password);
    SockList_AddChar(&sl, (char)return_value_strlen$8);
    SockList_AddString(&sl, account_password);
    SockList_Send(&sl, csocket.fd);
  }

__CPROVER_DUMP_L5:
  ;
}

// create_new_character_failure
// file account.c line 153
extern void create_new_character_failure(char *message)
{
  struct _GtkWidget *dialog;
  dialog=gtk_message_dialog_new((struct _GtkWindow *)(void *)0, (enum anonymous$40)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$41)GTK_MESSAGE_QUESTION, (enum anonymous$42)GTK_BUTTONS_OK, "Error: %s", message);
  unsigned long int return_value_gtk_dialog_get_type$1;
  return_value_gtk_dialog_get_type$1=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$1);
  gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$2);
  gtk_widget_destroy(dialog);
}

// create_new_item
// file item.c line 435
struct item_struct * create_new_item(struct item_struct *env, signed int tag)
{
  struct item_struct *op;
  if(free_items == ((struct item_struct *)NULL))
    free_items=alloc_items(50);

  op = free_items;
  free_items = free_items->next;
  if(!(free_items == ((struct item_struct *)NULL)))
    free_items->prev = (struct item_struct *)(void *)0;

  op->tag = tag;
  op->locked = (unsigned short int)0;
  if(!(env == ((struct item_struct *)NULL)))
    add_item(env, op);

  return op;
}

// create_opengl_map_image
// file gtk2proto.h line 187
extern void create_opengl_map_image(unsigned char *data, struct PixmapInfo *pi)
{
  signed int nwidth;
  signed int nheight;
  signed int numshifts;
  signed int i;
  unsigned char *data_to_use = data;
  unsigned char *l;
  unsigned int g;
  unsigned int *p;
  nwidth = (signed int)pi->map_width;
  numshifts = 0;
  for( ; nwidth >= 2; numshifts = numshifts + 1)
    nwidth = nwidth >> 1;
  nwidth = nwidth << numshifts;
  if(!(nwidth == (signed int)pi->map_width))
    nwidth = nwidth << 1;

  nheight = (signed int)pi->map_height;
  numshifts = 0;
  for( ; nheight >= 2; numshifts = numshifts + 1)
    nheight = nheight >> 1;
  nheight = nheight << numshifts;
  if(!(nheight == (signed int)pi->map_height))
    nheight = nheight << 1;

  _Bool tmp_if_expr$4;
  if(!((signed int)pi->map_width == nwidth))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = (signed int)pi->map_height != nheight ? (_Bool)1 : (_Bool)0;
  static unsigned char *newdata;
  static signed int size = 0;
  if(tmp_if_expr$4)
  {
    signed int y;
    unsigned char *datastart;
    if(!(size >= 4 * nheight * nwidth))
    {
      size = nwidth * nheight * 4;
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)newdata, (unsigned long int)size);
      newdata = (unsigned char *)return_value_realloc$1;
      if(newdata == ((unsigned char *)NULL))
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        char *return_value_strerror$3;
        return_value_strerror$3=strerror(*return_value___errno_location$2);
        LOG((enum LogLevel)LOG_ERROR, "create_opengl_map_image", "Could not allocate memory: %s", return_value_strerror$3);
        exit(1);
      }

    }

    if(!((signed int)pi->map_height >= nheight))
    {
      memset((void *)newdata, 0, (unsigned long int)((nheight - (signed int)pi->map_height) * nwidth * 4));
      datastart = newdata + (signed long int)((nheight - (signed int)pi->map_height) * nwidth * 4);
    }

    else
      datastart = newdata;
    y = 0;
    for( ; !(y >= (signed int)pi->map_height); y = y + 1)
    {
      memset((void *)(datastart + (signed long int)(y * nwidth * 4)), 0, (unsigned long int)((nwidth - (signed int)pi->map_width) * 4));
      memcpy((void *)(datastart + (signed long int)(y * nwidth * 4) + (signed long int)((nwidth - (signed int)pi->map_width) * 4)), (const void *)(data + (signed long int)(y * (signed int)pi->map_width * 4)), (unsigned long int)((signed int)pi->map_width * 4));
    }
    data_to_use = newdata;
    pi->map_width = (unsigned short int)nwidth;
    pi->map_height = (unsigned short int)nheight;
  }

  glGenTextures(1, &pi->map_texture);
  glBindTexture((unsigned int)0x0DE1, pi->map_texture);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2801, 0x2601);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2800, 0x2601);
  glTexImage2D((unsigned int)0x0DE1, 0, 4, (signed int)pi->map_width, (signed int)pi->map_height, 0, (unsigned int)0x1908, (unsigned int)0x1401, (const void *)data_to_use);
  if(!(size >= 4 * (signed int)pi->map_height * (signed int)pi->map_width))
  {
    size = (signed int)pi->map_width * (signed int)pi->map_height * 4;
    void *return_value_realloc$5;
    return_value_realloc$5=realloc((void *)newdata, (unsigned long int)size);
    newdata = (unsigned char *)return_value_realloc$5;
  }

  if(!(data_to_use == newdata))
    memcpy((void *)newdata, (const void *)data, (unsigned long int)((signed int)pi->map_height * (signed int)pi->map_width * 4));

  i = 0;
  signed int tmp_if_expr$6;
  unsigned int tmp_if_expr$7;
  for( ; !(i >= (signed int)pi->map_height * (signed int)pi->map_width); i = i + 1)
  {
    l = (unsigned char *)(newdata + (signed long int)(i * 4));
    if(!((signed int)l[1l] >= (signed int)*l))
      tmp_if_expr$6 = (signed int)*l;

    else
      tmp_if_expr$6 = (signed int)l[(signed long int)1];
    g = (unsigned int)tmp_if_expr$6;
    if(!((unsigned int)l[2l] >= g))
      tmp_if_expr$7 = g;

    else
      tmp_if_expr$7 = (unsigned int)l[(signed long int)2];
    g = tmp_if_expr$7;
    p = (unsigned int *)newdata + (signed long int)i;
    *p = g | g << 8 | g << 16 | (unsigned int)((signed int)l[(signed long int)3] << 24);
  }
  glGenTextures(1, &pi->fog_texture);
  glBindTexture((unsigned int)0x0DE1, pi->fog_texture);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2801, 0x2601);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2800, 0x2601);
  glTexImage2D((unsigned int)0x0DE1, 0, 4, (signed int)pi->map_width, (signed int)pi->map_height, 0, (unsigned int)0x1908, (unsigned int)0x1401, (const void *)newdata);
}

// create_opengl_question_mark
// file gtk2proto.h line 189
extern void create_opengl_question_mark(void)
{
  unsigned char question[32l][32l][4l];
  signed int xb;
  signed int x;
  signed int y;
  signed int offset = 0;
  y = 0;
  for( ; !(y >= 32); y = y + 1)
  {
    xb = 0;
    for( ; !(xb >= 4); xb = xb + 1)
    {
      x = 0;
      for( ; !(x >= 8); x = x + 1)
        if(!((1 << x & (signed int)question_bits[(signed long int)offset]) == 0))
        {
          question[(signed long int)y][(signed long int)(xb * 8 + x)][(signed long int)0] = (unsigned char)255;
          question[(signed long int)y][(signed long int)(xb * 8 + x)][(signed long int)1] = (unsigned char)255;
          question[(signed long int)y][(signed long int)(xb * 8 + x)][(signed long int)2] = (unsigned char)255;
          question[(signed long int)y][(signed long int)(xb * 8 + x)][(signed long int)3] = (unsigned char)255;
        }

        else
        {
          question[(signed long int)y][(signed long int)(xb * 8 + x)][(signed long int)0] = (unsigned char)0;
          question[(signed long int)y][(signed long int)(xb * 8 + x)][(signed long int)1] = (unsigned char)0;
          question[(signed long int)y][(signed long int)(xb * 8 + x)][(signed long int)2] = (unsigned char)0;
          question[(signed long int)y][(signed long int)(xb * 8 + x)][(signed long int)3] = (unsigned char)0;
        }
      offset = offset + 1;
    }
  }
  glGenTextures(1, &pixmaps[(signed long int)0]->map_texture);
  glBindTexture((unsigned int)0x0DE1, pixmaps[(signed long int)0]->map_texture);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2801, 0x2601);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2800, 0x2601);
  glTexImage2D((unsigned int)0x0DE1, 0, 4, 32, 32, 0, (unsigned int)0x1908, (unsigned int)0x1401, (const void *)&question[(signed long int)0][(signed long int)0][(signed long int)0]);
  glGenTextures(1, &pixmaps[(signed long int)0]->fog_texture);
  glBindTexture((unsigned int)0x0DE1, pixmaps[(signed long int)0]->fog_texture);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2801, 0x2601);
  glTexParameteri((unsigned int)0x0DE1, (unsigned int)0x2800, 0x2601);
  glTexImage2D((unsigned int)0x0DE1, 0, 4, 32, 32, 0, (unsigned int)0x1908, (unsigned int)0x1401, (const void *)&question[(signed long int)0][(signed long int)0][(signed long int)0]);
}

// cs_print_string
// file ../../common/proto.h line 132
signed int cs_print_string(signed int fd, const char *str, ...)
{
  void **args;
  struct SockList sl;
  unsigned char buf[256l];
  SockList_Init(&sl, buf);
  args = (void **)&str;
  signed int return_value_vsprintf$1;
  return_value_vsprintf$1=vsprintf((char *)sl.buf + (signed long int)sl.len, str, args);
  sl.len = sl.len + return_value_vsprintf$1;
  args = ((void **)NULL);
  script_monitor_str((char *)sl.buf);
  signed int return_value_SockList_Send$2;
  return_value_SockList_Send$2=SockList_Send(&sl, fd);
  return return_value_SockList_Send$2;
}

// default_msgctrl_configuration
// file info.c line 1771
extern void default_msgctrl_configuration(void)
{
  unsigned int pane;
  unsigned int type;
  buffer_control.count.state = (unsigned int)buffer_control.count.default_state;
  buffer_control.timer.state = (unsigned int)buffer_control.timer.default_state;
  type = (unsigned int)0;
  for( ; !(type >= 20u); type = type + (unsigned int)1)
  {
    msgctrl_widgets[(signed long int)type].buffer.state = msgctrl_defaults[(signed long int)type].buffer;
    pane = (unsigned int)0;
    for( ; !(pane >= 2u); pane = pane + (unsigned int)1)
      msgctrl_widgets[(signed long int)type].pane[(signed long int)pane].state = msgctrl_defaults[(signed long int)type].pane[(signed long int)pane];
  }
  update_msgctrl_configuration();
}

// display_map_doneupdate
// file map.c line 809
extern void display_map_doneupdate(signed int redraw, signed int notice)
{
  map_updated = map_updated | (unsigned char)(redraw != 0 || !(notice != 0));
}

// display_map_newmap
// file map.c line 558
extern void display_map_newmap(void)
{
  reset_map();
}

// display_map_startupdate
// file map.c line 798
extern void display_map_startupdate(void)
{
  ;
}

// display_mapcell
// file map.c line 362
static void display_mapcell(signed int ax, signed int ay, signed int mx, signed int my)
{
  signed int layer;
  gdk_draw_rectangle(map_drawing_area->window, map_drawing_area->style->black_gc, (signed int)!(0 != 0), ax * map_image_size, ay * map_image_size, map_image_size, map_image_size);
  _Bool tmp_if_expr$5;
  if(!(use_config[6l] == 0))
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = !((the_map.cells[(signed long int)mx] + (signed long int)my)->cleared != 0) ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$3;
  if(tmp_if_expr$5)
  {
    layer = 0;
    for( ; !(layer >= 10); layer = layer + 1)
    {
      signed int sx;
      signed int sy;
      signed int face;
      signed short int return_value_mapdata_face$1;
      return_value_mapdata_face$1=mapdata_face(ax, ay, layer);
      face = (signed int)return_value_mapdata_face$1;
      if(face >= 1)
      {
        if(!(pixmaps[(signed long int)face]->map_image == NULL))
        {
          signed int src_x = (signed int)pixmaps[(signed long int)face]->map_width - map_image_size;
          signed int src_y = (signed int)pixmaps[(signed long int)face]->map_height - map_image_size;
          signed int off_x = 0;
          signed int off_y = 0;
          if(!(src_x >= 0))
          {
            off_x = -src_x;
            src_x = 0;
          }

          if(!(src_y >= 0))
          {
            off_y = -src_y;
            src_y = 0;
          }

          if(!(map_image_size >= (signed int)pixmaps[(signed long int)face]->map_width))
            tmp_if_expr$2 = map_image_size;

          else
            tmp_if_expr$2 = (signed int)pixmaps[(signed long int)face]->map_width;
          if(!(map_image_size >= (signed int)pixmaps[(signed long int)face]->map_height))
            tmp_if_expr$3 = map_image_size;

          else
            tmp_if_expr$3 = (signed int)pixmaps[(signed long int)face]->map_height;
          draw_pixmap(src_x, src_y, ax * map_image_size + off_x, ay * map_image_size + off_y, (ax * map_image_size + map_image_size) - (signed int)pixmaps[(signed long int)face]->map_width, (ay * map_image_size + map_image_size) - (signed int)pixmaps[(signed long int)face]->map_height, pixmaps[(signed long int)face]->map_mask, pixmaps[(signed long int)face]->map_image, tmp_if_expr$2, tmp_if_expr$3);
        }

      }

      if(!(use_config[26l] == 0))
        drawsmooth(mx, my, layer, ax * map_image_size, ay * map_image_size);

      signed short int return_value_mapdata_bigface$4;
      return_value_mapdata_bigface$4=mapdata_bigface(ax, ay, layer, &sx, &sy);
      face = (signed int)return_value_mapdata_bigface$4;
      if(face >= 1)
      {
        if(!(pixmaps[(signed long int)face]->map_image == NULL))
        {
          signed int display_mapcell$$1$$1$$1$$1$$3$$dx;
          signed int display_mapcell$$1$$1$$1$$1$$3$$dy;
          signed int sourcex;
          signed int sourcey;
          signed int offx;
          signed int offy;
          signed int clipx;
          signed int clipy;
          display_mapcell$$1$$1$$1$$1$$3$$dx = (signed int)pixmaps[(signed long int)face]->map_width % map_image_size;
          offx = display_mapcell$$1$$1$$1$$1$$3$$dx != 0 ? map_image_size - display_mapcell$$1$$1$$1$$1$$3$$dx : 0;
          clipx = (ax - sx) * map_image_size + offx;
          if(!(sx == 0))
          {
            sourcex = sx * map_image_size - offx;
            offx = 0;
          }

          else
            sourcex = 0;
          display_mapcell$$1$$1$$1$$1$$3$$dy = (signed int)pixmaps[(signed long int)face]->map_height % map_image_size;
          offy = display_mapcell$$1$$1$$1$$1$$3$$dy != 0 ? map_image_size - display_mapcell$$1$$1$$1$$1$$3$$dy : 0;
          clipy = (ay - sy) * map_image_size + offy;
          if(!(sy == 0))
          {
            sourcey = sy * map_image_size - offy;
            offy = 0;
          }

          else
            sourcey = 0;
          draw_pixmap(sourcex, sourcey, ax * map_image_size + offx, ay * map_image_size + offy, clipx, clipy, pixmaps[(signed long int)face]->map_mask, pixmaps[(signed long int)face]->map_image, map_image_size - offx, map_image_size - offy);
        }

      }

    }
  }

  _Bool tmp_if_expr$6;
  if(!(use_config[6l] == 0))
    tmp_if_expr$6 = (the_map.cells[(signed long int)mx] + (signed long int)my)->cleared != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$6 = (_Bool)0;
  if(tmp_if_expr$6)
    draw_pixmap(0, 0, ax * map_image_size, ay * map_image_size, ax * map_image_size, ay * map_image_size, (void *)dark1, (void *)dark, map_image_size, map_image_size);

  else
    if((signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->darkness >= 193)
      gdk_draw_rectangle(map_drawing_area->window, map_drawing_area->style->black_gc, (signed int)!(0 != 0), map_image_size * ax, map_image_size * ay, map_image_size, map_image_size);

    else
      if((signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->darkness >= 129)
        draw_pixmap(0, 0, ax * map_image_size, ay * map_image_size, ax * map_image_size, ay * map_image_size, (void *)dark1, (void *)dark, map_image_size, map_image_size);

      else
        if((signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->darkness >= 65)
          draw_pixmap(0, 0, ax * map_image_size, ay * map_image_size, ax * map_image_size, ay * map_image_size, (void *)dark2, (void *)dark, map_image_size, map_image_size);

        else
          if((signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->darkness >= 2)
            draw_pixmap(0, 0, ax * map_image_size, ay * map_image_size, ax * map_image_size, ay * map_image_size, (void *)dark3, (void *)dark, map_image_size, map_image_size);

}

// display_mapcell$link1
// file sdl.c line 887
static void display_mapcell$link1(signed int ax$link1, signed int ay$link1, signed int mx$link1, signed int my$link1)
{
  struct SDL_Rect dst;
  struct SDL_Rect src;
  signed int layer$link1;
  dst.x = (signed short int)(ax$link1 * map_image_size);
  dst.y = (signed short int)(ay$link1 * map_image_size);
  dst.w = (unsigned short int)map_image_size;
  dst.h = (unsigned short int)map_image_size;
  unsigned int return_value_SDL_MapRGB$1;
  return_value_SDL_MapRGB$1=SDL_MapRGB(mapsurface->format, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0);
  SDL_FillRect(mapsurface, &dst, return_value_SDL_MapRGB$1);
  _Bool tmp_if_expr$8;
  if(!(use_config[6l] == 0))
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = !((the_map.cells[(signed long int)mx$link1] + (signed long int)my$link1)->cleared != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$8)
  {
    layer$link1 = 0;
    for( ; !(layer$link1 >= 10); layer$link1 = layer$link1 + 1)
    {
      signed int sx$link1;
      signed int sy$link1;
      signed int face$link1;
      signed short int return_value_mapdata_face$2;
      return_value_mapdata_face$2=mapdata_face(ax$link1, ay$link1, layer$link1);
      face$link1 = (signed int)return_value_mapdata_face$2;
      if(face$link1 >= 1)
      {
        if(!(pixmaps[(signed long int)face$link1]->map_image == NULL))
        {
          signed int w = (signed int)pixmaps[(signed long int)face$link1]->map_width;
          signed int h = (signed int)pixmaps[(signed long int)face$link1]->map_height;
          src.x = (signed short int)(w - map_image_size);
          src.y = (signed short int)(h - map_image_size);
          src.w = (unsigned short int)map_image_size;
          src.h = (unsigned short int)map_image_size;
          dst.x = (signed short int)(ax$link1 * map_image_size);
          dst.y = (signed short int)(ay$link1 * map_image_size);
          if(!((the_map.cells[(signed long int)mx$link1] + (signed long int)my$link1)->cleared == 0))
          {
            signed int return_value_SDL_UpperBlit$3;
            return_value_SDL_UpperBlit$3=SDL_UpperBlit((struct SDL_Surface *)pixmaps[(signed long int)face$link1]->fog_image, &src, mapsurface, &dst);
            if(!(return_value_SDL_UpperBlit$3 == 0))
              do_SDL_error("BlitSurface", "sdl.c", 920);

          }

          else
          {
            signed int return_value_SDL_UpperBlit$4;
            return_value_SDL_UpperBlit$4=SDL_UpperBlit((struct SDL_Surface *)pixmaps[(signed long int)face$link1]->map_image, &src, mapsurface, &dst);
            if(!(return_value_SDL_UpperBlit$4 == 0))
              do_SDL_error("BlitSurface", "sdl.c", 924);

          }
        }

      }

      if(!(use_config[26l] == 0))
        drawsmooth_sdl(mx$link1, my$link1, layer$link1, dst);

      signed short int return_value_mapdata_bigface$5;
      return_value_mapdata_bigface$5=mapdata_bigface(ax$link1, ay$link1, layer$link1, &sx$link1, &sy$link1);
      face$link1 = (signed int)return_value_mapdata_bigface$5;
      if(face$link1 >= 1)
      {
        if(!(pixmaps[(signed long int)face$link1]->map_image == NULL))
        {
          signed int dx$link1;
          signed int dy$link1;
          signed int sourcex$link1;
          signed int sourcey$link1;
          signed int offx$link1;
          signed int offy$link1;
          dx$link1 = (signed int)pixmaps[(signed long int)face$link1]->map_width % map_image_size;
          offx$link1 = dx$link1 != 0 ? map_image_size - dx$link1 : 0;
          if(!(sx$link1 == 0))
          {
            sourcex$link1 = sx$link1 * map_image_size - offx$link1;
            offx$link1 = 0;
          }

          else
            sourcex$link1 = 0;
          dy$link1 = (signed int)pixmaps[(signed long int)face$link1]->map_height % map_image_size;
          offy$link1 = dy$link1 != 0 ? map_image_size - dy$link1 : 0;
          if(!(sy$link1 == 0))
          {
            sourcey$link1 = sy$link1 * map_image_size - offy$link1;
            offy$link1 = 0;
          }

          else
            sourcey$link1 = 0;
          src.x = (signed short int)sourcex$link1;
          src.y = (signed short int)sourcey$link1;
          src.w = (unsigned short int)(map_image_size - offx$link1);
          src.h = (unsigned short int)(map_image_size - offy$link1);
          dst.x = (signed short int)(ax$link1 * map_image_size + offx$link1);
          dst.y = (signed short int)(ay$link1 * map_image_size + offy$link1);
          if(!((the_map.cells[(signed long int)mx$link1] + (signed long int)my$link1)->cleared == 0))
          {
            signed int return_value_SDL_UpperBlit$6;
            return_value_SDL_UpperBlit$6=SDL_UpperBlit((struct SDL_Surface *)pixmaps[(signed long int)face$link1]->fog_image, &src, mapsurface, &dst);
            if(!(return_value_SDL_UpperBlit$6 == 0))
              do_SDL_error("BlitSurface", "sdl.c", 977);

          }

          else
          {
            signed int return_value_SDL_UpperBlit$7;
            return_value_SDL_UpperBlit$7=SDL_UpperBlit((struct SDL_Surface *)pixmaps[(signed long int)face$link1]->map_image, &src, mapsurface, &dst);
            if(!(return_value_SDL_UpperBlit$7 == 0))
              do_SDL_error("BlitSurface", "sdl.c", 981);

          }
        }

      }

    }
  }

  _Bool tmp_if_expr$10;
  if((signed int)use_config[17l] == 1)
  {
    dst.x = (signed short int)(ax$link1 * map_image_size);
    dst.y = (signed short int)(ay$link1 * map_image_size);
    dst.w = (unsigned short int)map_image_size;
    dst.h = (unsigned short int)map_image_size;
    if((signed int)(the_map.cells[(signed long int)mx$link1] + (signed long int)my$link1)->darkness == 255)
    {
      unsigned int return_value_SDL_MapRGB$9;
      return_value_SDL_MapRGB$9=SDL_MapRGB(mapsurface->format, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0);
      SDL_FillRect(mapsurface, &dst, return_value_SDL_MapRGB$9);
    }

    else
      if(!((signed int)(the_map.cells[(signed long int)mx$link1] + (signed long int)my$link1)->darkness == 0))
      {
        SDL_SetAlpha(lightmap, (unsigned int)(0x00010000 | 0x00004000), (the_map.cells[(signed long int)mx$link1] + (signed long int)my$link1)->darkness);
        SDL_UpperBlit(lightmap, (struct SDL_Rect *)(void *)0, mapsurface, &dst);
      }

  }

  else
  {
    if((signed int)use_config[17l] == 2)
      tmp_if_expr$10 = (_Bool)1;

    else
      tmp_if_expr$10 = (signed int)use_config[(signed long int)17] == 3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$10)
      do_sdl_per_pixel_lighting(ax$link1, ay$link1, mx$link1, my$link1);

  }
}

// display_mapscroll
// file map.c line 217
extern signed int display_mapscroll(signed int dx, signed int dy)
{
  if((signed int)use_config[10l] == 1)
  {
    signed int return_value_sdl_mapscroll$1;
    return_value_sdl_mapscroll$1=sdl_mapscroll(dx, dy);
    return return_value_sdl_mapscroll$1;
  }

  else
    return 0;
}

// display_newpng
// file image.c line 684
void display_newpng(signed int face, unsigned char *buf, signed int buflen, signed int setnum)
{
  unsigned char *pngtmp;
  unsigned int display_newpng$$1$$width;
  unsigned int display_newpng$$1$$height;
  struct Cache_Entry *ce = (struct Cache_Entry *)(void *)0;
  if(!(use_config[5l] == 0))
    cache_newpng(face, buf, buflen, setnum, &ce);

  pngtmp=png_to_data(buf, buflen, &display_newpng$$1$$width, &display_newpng$$1$$height);
  signed int return_value_create_and_rescale_image_from_data$1;
  return_value_create_and_rescale_image_from_data$1=create_and_rescale_image_from_data(ce, face, pngtmp, (signed int)display_newpng$$1$$width, (signed int)display_newpng$$1$$height);
  if(!(return_value_create_and_rescale_image_from_data$1 == 0))
    LOG((enum LogLevel)LOG_WARNING, "common::display_newpng", "create_and_rescale_image_from_data failed for face %ld", face);

  if(!(use_config[5l] == 0))
  {
    free((void *)facetoname[(signed long int)face]);
    facetoname[(signed long int)face] = (char *)(void *)0;
  }

  free((void *)pngtmp);
}

// do_SDL_error
// file sdl.c line 63
static void do_SDL_error(const char *SDL_function, const char *file, signed int line)
{
  char *return_value_SDL_GetError$1;
  return_value_SDL_GetError$1=SDL_GetError();
  LOG((enum LogLevel)LOG_CRITICAL, SDL_function, "SDL error in file %s line %d\n%s", file, line, return_value_SDL_GetError$1);
  SDL_Quit();
  exit(1);
}

// do_account_change
// file account.c line 1165
static void do_account_change(const char *old, const char *p1, const char *p2)
{
  struct SockList sl;
  unsigned char buf[256l];
  signed int return_value_strcmp$7;
  return_value_strcmp$7=strcmp(p1, p2);
  if(!(return_value_strcmp$7 == 0))
  {
    unsigned long int return_value_gtk_label_get_type$1;
    return_value_gtk_label_get_type$1=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)label_account_password_status, return_value_gtk_label_get_type$1);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, "The passwords you entered do not match!");
    goto __CPROVER_DUMP_L3;
  }

  else
  {
    unsigned long int return_value_gtk_label_get_type$3;
    return_value_gtk_label_get_type$3=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)label_account_password_status, return_value_gtk_label_get_type$3);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, "");
    SockList_Init(&sl, buf);
    SockList_AddString(&sl, "accountpw ");
    unsigned long int return_value_strlen$5;
    return_value_strlen$5=strlen(old);
    SockList_AddChar(&sl, (char)return_value_strlen$5);
    SockList_AddString(&sl, old);
    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(p1);
    SockList_AddChar(&sl, (char)return_value_strlen$6);
    SockList_AddString(&sl, p1);
    SockList_Send(&sl, csocket.fd);
    snprintf(account_password, sizeof(char [256l]) /*256ul*/ , "%s", p1);
  }

__CPROVER_DUMP_L3:
  ;
}

// do_account_create
// file account.c line 775
static void do_account_create(const char *name, const char *p1, const char *p2)
{
  struct SockList sl;
  unsigned char buf[256l];
  signed int return_value_strcmp$7;
  return_value_strcmp$7=strcmp(p1, p2);
  if(!(return_value_strcmp$7 == 0))
  {
    unsigned long int return_value_gtk_label_get_type$1;
    return_value_gtk_label_get_type$1=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)label_create_account_status, return_value_gtk_label_get_type$1);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, "The passwords you entered do not match!");
    goto __CPROVER_DUMP_L3;
  }

  else
  {
    unsigned long int return_value_gtk_label_get_type$3;
    return_value_gtk_label_get_type$3=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)label_create_account_status, return_value_gtk_label_get_type$3);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, "");
    SockList_Init(&sl, buf);
    SockList_AddString(&sl, "accountnew ");
    unsigned long int return_value_strlen$5;
    return_value_strlen$5=strlen(name);
    SockList_AddChar(&sl, (char)return_value_strlen$5);
    SockList_AddString(&sl, name);
    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(p1);
    SockList_AddChar(&sl, (char)return_value_strlen$6);
    SockList_AddString(&sl, p1);
    SockList_Send(&sl, csocket.fd);
    snprintf(account_password, sizeof(char [256l]) /*256ul*/ , "%s", p1);
  }

__CPROVER_DUMP_L3:
  ;
}

// do_account_login
// file account.c line 1002
static void do_account_login(const char *name, const char *password)
{
  struct SockList sl;
  unsigned char buf[256l];
  _Bool tmp_if_expr$7;
  if(name == ((const char *)NULL) || password == ((const char *)NULL))
    tmp_if_expr$7 = (_Bool)1;

  else
    tmp_if_expr$7 = (signed int)*name == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$8;
  if(tmp_if_expr$7)
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = (signed int)*password == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$8)
  {
    unsigned long int return_value_gtk_label_get_type$1;
    return_value_gtk_label_get_type$1=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)label_account_login_status, return_value_gtk_label_get_type$1);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, "You must enter both a name and password!");
  }

  else
  {
    unsigned long int return_value_gtk_label_get_type$3;
    return_value_gtk_label_get_type$3=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)label_account_login_status, return_value_gtk_label_get_type$3);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, "");
    SockList_Init(&sl, buf);
    SockList_AddString(&sl, "accountlogin ");
    unsigned long int return_value_strlen$5;
    return_value_strlen$5=strlen(name);
    SockList_AddChar(&sl, (char)return_value_strlen$5);
    SockList_AddString(&sl, name);
    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(password);
    SockList_AddChar(&sl, (char)return_value_strlen$6);
    SockList_AddString(&sl, password);
    SockList_Send(&sl, csocket.fd);
    snprintf(account_password, sizeof(char [256l]) /*256ul*/ , "%s", password);
  }
}

// do_clearinfo
// file p_cmd.c line 419
static void do_clearinfo(const char *ignored)
{
  menu_clear();
}

// do_clienthelp
// file p_cmd.c line 187
static void do_clienthelp(const char *arg)
{
  const struct anonymous$47 *cc;
  _Bool tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(arg == ((const char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    return_value_strlen$1=strlen(arg);
    tmp_if_expr$2 = !(return_value_strlen$1 != 0ul) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    do_clienthelp_list();

  else
  {
    cc=find_command(arg);
    if(cc == ((const struct anonymous$47 *)NULL))
    {
      char buf[256l];
      snprintf(buf, (unsigned long int)(256 - 1), "clienthelp: Unknown command %s.", arg);
      draw_ext_info(0, 20, 6, buf);
      goto __CPROVER_DUMP_L5;
    }

    show_help(cc);
  }

__CPROVER_DUMP_L5:
  ;
}

// do_clienthelp_list
// file p_cmd.c line 65
static void do_clienthelp_list(void)
{
  struct anonymous$47 **commands_array;
  struct anonymous$47 *commands_copy;
  signed int i;
  enum anonymous$46 current_cat = (enum anonymous$46)COMM_CAT_MISC;
  char line_buf[256l];
  unsigned long int line_len = (unsigned long int)0;
  line_buf[(signed long int)0] = (char)0;
  commands_array=get_cat_sorted_commands();
  draw_ext_info(0, 20, 6, " === Client Side Commands === ");
  i = 0;
  signed int return_value_get_num_commands$1;
  signed int return_value_get_info_width$4;
  signed int return_value_get_info_width$3;
  do
  {
    return_value_get_num_commands$1=get_num_commands();
    if(i >= return_value_get_num_commands$1)
      break;

    commands_copy = commands_array[(signed long int)i];
    if(!(commands_copy->cat == current_cat))
    {
      char buf[256l];
      if(line_len >= 1ul)
      {
        draw_ext_info(0, 20, 6, line_buf);
        line_buf[(signed long int)0] = (char)0;
        line_len = (unsigned long int)0;
      }

      const char *return_value_get_category_name$2;
      return_value_get_category_name$2=get_category_name(commands_copy->cat);
      snprintf(buf, (unsigned long int)(256 - 1), " --- %s Commands --- ", return_value_get_category_name$2);
      draw_ext_info(0, 20, 6, buf);
      current_cat = commands_copy->cat;
    }

    unsigned long int name_len;
    name_len=strlen(commands_copy->name);
    unsigned long int return_value_strlen$5;
    return_value_strlen$5=strlen(commands_copy->name);
    if(return_value_strlen$5 >= 257ul)
      draw_ext_info(0, 20, 6, commands_copy->name);

    else
    {
      return_value_get_info_width$4=get_info_width();
      if(!((unsigned long int)return_value_get_info_width$4 >= name_len))
      {
        draw_ext_info(0, 20, 6, line_buf);
        draw_ext_info(0, 20, 6, commands_copy->name);
        line_len = (unsigned long int)0;
      }

      else
      {
        return_value_get_info_width$3=get_info_width();
        if(!((unsigned long int)return_value_get_info_width$3 >= name_len + line_len))
        {
          draw_ext_info(0, 20, 6, line_buf);
          strncpy(line_buf, commands_copy->name, name_len + (unsigned long int)1);
          line_len = name_len;
        }

        else
        {
          if(line_len >= 1ul)
          {
            strncat(line_buf, " ", (unsigned long int)2);
            line_len = line_len + (unsigned long int)1;
          }

          strncat(line_buf, commands_copy->name, name_len + (unsigned long int)1);
          line_len = line_len + name_len;
        }
      }
    }
    i = i + 1;
  }
  while((_Bool)1);
  if(!(line_len == 0ul))
    draw_ext_info(0, 20, 6, line_buf);

}

// do_disconnect
// file p_cmd.c line 428
static void do_disconnect(const char *ignored)
{
  close_server_connection();
  cleanup_connection();
}

// do_inv
// file p_cmd.c line 462
static void do_inv(const char *ignored)
{
  print_inventory(cpl.ob);
}

// do_item
// file script_lua.c line 103
static void do_item(struct lua_State *lua, struct item_struct *it)
{
  lua_createtable(lua, 0, 0);
  lua_pushstring(lua, "s_name");
  lua_pushstring(lua, it->s_name);
  lua_settable(lua, -3);
  lua_pushstring(lua, "magical");
  lua_pushnumber(lua, (double)it->magical);
  lua_settable(lua, -3);
  lua_pushstring(lua, "cursed");
  lua_pushnumber(lua, (double)it->cursed);
  lua_settable(lua, -3);
  lua_pushstring(lua, "damned");
  lua_pushnumber(lua, (double)it->damned);
  lua_settable(lua, -3);
  lua_pushstring(lua, "unpaid");
  lua_pushnumber(lua, (double)it->unpaid);
  lua_settable(lua, -3);
  lua_pushstring(lua, "locked");
  lua_pushnumber(lua, (double)it->locked);
  lua_settable(lua, -3);
  lua_pushstring(lua, "applied");
  lua_pushnumber(lua, (double)it->applied);
  lua_settable(lua, -3);
  lua_pushstring(lua, "open");
  lua_pushnumber(lua, (double)it->open);
  lua_settable(lua, -3);
}

// do_magicmap
// file p_cmd.c line 467
static void do_magicmap(const char *ignored)
{
  cpl.showmagic = (unsigned char)1;
  draw_magic_map();
}

// do_metaserver
// file p_cmd.c line 477
static void do_metaserver(const char *ignored)
{
  signed int return_value_metaserver_get_info$1;
  return_value_metaserver_get_info$1=metaserver_get_info(meta_server, meta_port);
  if(return_value_metaserver_get_info$1 == 0)
    metaserver_show(0);

  else
    draw_ext_info(0, 20, 7, "Unable to get metaserver information.");
}

// do_network
// file main.c line 177
extern void do_network(void)
{
  struct anonymous$51 tmp_read;
  signed int pollret;
  if(csocket.fd == -1)
  {
    if(!(csocket_fd == 0))
    {
      gdk_input_remove(csocket_fd);
      csocket_fd = 0;
      gtk_main_quit();
    }

  }

  else
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$51) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&tmp_read)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&tmp_read)->fds_bits[(signed long int)(csocket.fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&tmp_read)->fds_bits[(signed long int)(csocket.fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << csocket.fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    script_fdset(&maxfd, &tmp_read);
    pollret=select(maxfd, &tmp_read, (struct anonymous$51 *)(void *)0, (struct anonymous$51 *)(void *)0, &timeout);
    if(pollret == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      LOG((enum LogLevel)LOG_WARNING, "main.c::do_network", "Got errno %d on select call.", *return_value___errno_location$1);
    }

    else
      if(pollret >= 1)
      {
        if(!((tmp_read.fds_bits[(signed long int)(csocket.fd / 8)] & (signed long int)(1UL << csocket.fd % 8)) == 0l))
        {
          DoClient(&csocket);
          if(pollret >= 2)
            script_process(&tmp_read);

        }

        else
          script_process(&tmp_read);
      }

    if(csocket.fd == -1)
    {
      if(!(csocket_fd == 0))
      {
        gdk_input_remove(csocket_fd);
        csocket_fd = 0;
        gtk_main_quit();
      }

    }

    else
    {
      if((signed int)use_config[10l] == 1)
        sdl_gen_map(0);

      else
        if((signed int)use_config[10l] == 2)
          opengl_gen_map(0);

        else
          draw_map(0);
      draw_lists();
    }
  }
}

// do_num_free_items
// file p_cmd.c line 518
static void do_num_free_items(const char *ignored)
{
  signed int return_value_num_free_items$1;
  return_value_num_free_items$1=num_free_items();
  LOG((enum LogLevel)LOG_INFO, "common::extended_command", "num_free_items=%d", return_value_num_free_items$1);
}

// do_savedefaults
// file p_cmd.c line 491
static void do_savedefaults(const char *ignored)
{
  save_defaults();
}

// do_savewinpos
// file p_cmd.c line 500
static void do_savewinpos(const char *ignored)
{
  save_winpos();
}

// do_script_list
// file p_cmd.c line 410
static void do_script_list(const char *ignored)
{
  script_list();
}

// do_sdl_per_pixel_lighting
// file sdl.c line 414
static void do_sdl_per_pixel_lighting(signed int x, signed int y, signed int mx, signed int my)
{
  signed int dark0;
  signed int do_sdl_per_pixel_lighting$$1$$dark1;
  signed int do_sdl_per_pixel_lighting$$1$$dark2;
  signed int do_sdl_per_pixel_lighting$$1$$dark3;
  signed int dark4;
  struct SDL_Rect dst;
  dark0 = (signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->darkness;
  _Bool tmp_if_expr$1;
  if(!(y + -1 >= 0))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !((the_map.cells[(signed long int)mx] + (signed long int)(my - 1))->have_darkness != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    do_sdl_per_pixel_lighting$$1$$dark1 = dark0;

  else
    do_sdl_per_pixel_lighting$$1$$dark1 = (signed int)(the_map.cells[(signed long int)mx] + (signed long int)(my - 1))->darkness;
  _Bool tmp_if_expr$2;
  if(1 + x >= (signed int)use_config[19l])
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !((the_map.cells[(signed long int)(mx + 1)] + (signed long int)my)->have_darkness != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    do_sdl_per_pixel_lighting$$1$$dark2 = dark0;

  else
    do_sdl_per_pixel_lighting$$1$$dark2 = (signed int)(the_map.cells[(signed long int)(mx + 1)] + (signed long int)my)->darkness;
  _Bool tmp_if_expr$3;
  if(1 + y >= (signed int)use_config[20l])
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = !((the_map.cells[(signed long int)mx] + (signed long int)(my + 1))->have_darkness != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
    do_sdl_per_pixel_lighting$$1$$dark3 = dark0;

  else
    do_sdl_per_pixel_lighting$$1$$dark3 = (signed int)(the_map.cells[(signed long int)mx] + (signed long int)(my + 1))->darkness;
  _Bool tmp_if_expr$4;
  if(!(x + -1 >= 0))
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = !((the_map.cells[(signed long int)(mx - 1)] + (signed long int)my)->have_darkness != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$4)
    dark4 = dark0;

  else
    dark4 = (signed int)(the_map.cells[(signed long int)(mx - 1)] + (signed long int)my)->darkness;
  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$20;
  if(dark0 == do_sdl_per_pixel_lighting$$1$$dark1 && dark0 == do_sdl_per_pixel_lighting$$1$$dark2 && dark0 == do_sdl_per_pixel_lighting$$1$$dark3 && dark0 == dark4)
  {
    if((signed int)use_config[17l] == 3)
      goto __CPROVER_DUMP_L19;

    dst.x = (signed short int)(x * map_image_size);
    dst.y = (signed short int)(y * map_image_size);
    dst.w = (unsigned short int)map_image_size;
    dst.h = (unsigned short int)map_image_size;
    if(dark0 == 255)
    {
      unsigned int return_value_SDL_MapRGB$5;
      return_value_SDL_MapRGB$5=SDL_MapRGB(mapsurface->format, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0);
      SDL_FillRect(mapsurface, &dst, return_value_SDL_MapRGB$5);
    }

    else
      if(!((signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->darkness == 0))
      {
        unsigned int return_value_SDL_MapRGBA$6;
        return_value_SDL_MapRGBA$6=SDL_MapRGBA(lightmap->format, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (the_map.cells[(signed long int)mx] + (signed long int)my)->darkness);
        SDL_FillRect(lightmap, (struct SDL_Rect *)(void *)0, return_value_SDL_MapRGBA$6);
        SDL_UpperBlit(lightmap, (struct SDL_Rect *)(void *)0, mapsurface, &dst);
      }

  }

  else
  {

  __CPROVER_DUMP_L19:
    ;
    if((signed int)use_config[17l] == 2)
    {
      signed int i;
      if(do_sdl_per_pixel_lighting$$1$$dark1 == dark0)
      {
        dst.x = (signed short int)0;
        dst.y = (signed short int)0;
        dst.w = (unsigned short int)map_image_size;
        dst.h = (unsigned short int)map_image_half_size;
        unsigned int return_value_SDL_MapRGBA$7;
        return_value_SDL_MapRGBA$7=SDL_MapRGBA(lightmap->format, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)((2 * dark0) / 3));
        SDL_FillRect(lightmap, &dst, return_value_SDL_MapRGBA$7);
      }

      else
      {
        i = 0;
        for( ; !(i >= map_image_half_size); i = i + 1)
        {
          dst.x = (signed short int)0;
          dst.y = (signed short int)i;
          dst.w = (unsigned short int)map_image_size;
          dst.h = (unsigned short int)1;
          unsigned int return_value_SDL_MapRGBA$8;
          return_value_SDL_MapRGBA$8=SDL_MapRGBA(lightmap->format, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)(((2 * ((map_image_half_size - i) * do_sdl_per_pixel_lighting$$1$$dark1 + i * dark0)) / 3) / map_image_half_size));
          SDL_FillRect(lightmap, &dst, return_value_SDL_MapRGBA$8);
        }
      }
      if(do_sdl_per_pixel_lighting$$1$$dark3 == dark0)
      {
        dst.x = (signed short int)0;
        dst.y = (signed short int)map_image_half_size;
        dst.w = (unsigned short int)map_image_size;
        dst.h = (unsigned short int)map_image_half_size;
        unsigned int return_value_SDL_MapRGBA$9;
        return_value_SDL_MapRGBA$9=SDL_MapRGBA(lightmap->format, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)((2 * dark0) / 3));
        SDL_FillRect(lightmap, &dst, return_value_SDL_MapRGBA$9);
      }

      else
      {
        i = map_image_half_size;
        for( ; !(i >= map_image_size); i = i + 1)
        {
          dst.x = (signed short int)0;
          dst.y = (signed short int)i;
          dst.w = (unsigned short int)map_image_size;
          dst.h = (unsigned short int)1;
          unsigned int return_value_SDL_MapRGBA$10;
          return_value_SDL_MapRGBA$10=SDL_MapRGBA(lightmap->format, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)(((2 * (dark0 * (map_image_size - i) + do_sdl_per_pixel_lighting$$1$$dark3 * (i - map_image_half_size))) / 3) / map_image_half_size));
          SDL_FillRect(lightmap, &dst, return_value_SDL_MapRGBA$10);
        }
      }
      dst.x = (signed short int)(x * map_image_size);
      dst.y = (signed short int)(y * map_image_size);
      SDL_UpperBlit(lightmap, (struct SDL_Rect *)(void *)0, mapsurface, &dst);
      if(dark4 == dark0)
      {
        dst.x = (signed short int)0;
        dst.y = (signed short int)0;
        dst.w = (unsigned short int)map_image_half_size;
        dst.h = (unsigned short int)map_image_size;
        unsigned int return_value_SDL_MapRGBA$11;
        return_value_SDL_MapRGBA$11=SDL_MapRGBA(lightmap->format, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)((2 * dark0) / 3));
        SDL_FillRect(lightmap, &dst, return_value_SDL_MapRGBA$11);
      }

      else
      {
        i = 0;
        for( ; !(i >= map_image_half_size); i = i + 1)
        {
          dst.x = (signed short int)i;
          dst.y = (signed short int)0;
          dst.w = (unsigned short int)1;
          dst.h = (unsigned short int)map_image_size;
          unsigned int return_value_SDL_MapRGBA$12;
          return_value_SDL_MapRGBA$12=SDL_MapRGBA(lightmap->format, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)(((2 * (dark4 * (map_image_half_size - i) + dark0 * i)) / 3) / map_image_half_size));
          SDL_FillRect(lightmap, &dst, return_value_SDL_MapRGBA$12);
        }
      }
      if(do_sdl_per_pixel_lighting$$1$$dark2 == dark0)
      {
        dst.x = (signed short int)map_image_half_size;
        dst.y = (signed short int)0;
        dst.w = (unsigned short int)map_image_half_size;
        dst.h = (unsigned short int)map_image_size;
        unsigned int return_value_SDL_MapRGBA$13;
        return_value_SDL_MapRGBA$13=SDL_MapRGBA(lightmap->format, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)((2 * dark0) / 3));
        SDL_FillRect(lightmap, &dst, return_value_SDL_MapRGBA$13);
      }

      else
      {
        i = map_image_half_size;
        for( ; !(i >= map_image_size); i = i + 1)
        {
          dst.x = (signed short int)i;
          dst.y = (signed short int)0;
          dst.w = (unsigned short int)1;
          dst.h = (unsigned short int)map_image_size;
          unsigned int return_value_SDL_MapRGBA$14;
          return_value_SDL_MapRGBA$14=SDL_MapRGBA(lightmap->format, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)(((2 * (dark0 * (map_image_size - i) + do_sdl_per_pixel_lighting$$1$$dark2 * (i - map_image_half_size))) / 3) / map_image_half_size));
          SDL_FillRect(lightmap, &dst, return_value_SDL_MapRGBA$14);
        }
      }
      dst.x = (signed short int)(x * map_image_size);
      dst.y = (signed short int)(y * map_image_size);
      SDL_UpperBlit(lightmap, (struct SDL_Rect *)(void *)0, mapsurface, &dst);
    }

    else
      if((signed int)use_config[17l] == 3)
      {
        signed int dark5;
        signed int dark6;
        signed int dark7;
        signed int dark8;
        if(!(y + -1 >= 0))
          tmp_if_expr$15 = (_Bool)1;

        else
          tmp_if_expr$15 = x + 1 >= (signed int)use_config[(signed long int)19] ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$15)
          tmp_if_expr$16 = (_Bool)1;

        else
          tmp_if_expr$16 = !((the_map.cells[(signed long int)(mx + 1)] + (signed long int)(my - 1))->have_darkness != 0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$16)
          dark5 = do_sdl_per_pixel_lighting$$1$$dark1 + do_sdl_per_pixel_lighting$$1$$dark2 >> 1;

        else
          dark5 = (signed int)(the_map.cells[(signed long int)(mx + 1)] + (signed long int)(my - 1))->darkness;
        if(1 + x >= (signed int)use_config[19l])
          tmp_if_expr$17 = (_Bool)1;

        else
          tmp_if_expr$17 = y + 1 >= (signed int)use_config[(signed long int)20] ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$17)
          tmp_if_expr$18 = (_Bool)1;

        else
          tmp_if_expr$18 = !((the_map.cells[(signed long int)(mx + 1)] + (signed long int)(my + 1))->have_darkness != 0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$18)
          dark6 = do_sdl_per_pixel_lighting$$1$$dark2 + do_sdl_per_pixel_lighting$$1$$dark3 >> 1;

        else
          dark6 = (signed int)(the_map.cells[(signed long int)(mx + 1)] + (signed long int)(my + 1))->darkness;
        if(1 + y >= (signed int)use_config[20l] || !(x + -1 >= 0))
          tmp_if_expr$19 = (_Bool)1;

        else
          tmp_if_expr$19 = !((the_map.cells[(signed long int)(mx - 1)] + (signed long int)(my + 1))->have_darkness != 0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$19)
          dark7 = do_sdl_per_pixel_lighting$$1$$dark3 + dark4 >> 1;

        else
          dark7 = (signed int)(the_map.cells[(signed long int)(mx - 1)] + (signed long int)(my + 1))->darkness;
        if(!(x + -1 >= 0) || !(y + -1 >= 0))
          tmp_if_expr$20 = (_Bool)1;

        else
          tmp_if_expr$20 = !((the_map.cells[(signed long int)(mx - 1)] + (signed long int)(my - 1))->have_darkness != 0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$20)
          dark8 = dark4 + do_sdl_per_pixel_lighting$$1$$dark1 >> 1;

        else
          dark8 = (signed int)(the_map.cells[(signed long int)(mx - 1)] + (signed long int)(my - 1))->darkness;
        drawquarterlightmap_sdl(dark8, do_sdl_per_pixel_lighting$$1$$dark1, dark4, dark0, map_image_size, map_image_size, map_image_half_size, map_image_half_size, map_image_size, map_image_size, 0, 0);
        drawquarterlightmap_sdl(do_sdl_per_pixel_lighting$$1$$dark1, dark5, dark0, do_sdl_per_pixel_lighting$$1$$dark2, map_image_size, map_image_size, 0, map_image_half_size, map_image_half_size, map_image_size, map_image_half_size, 0);
        drawquarterlightmap_sdl(dark4, dark0, dark7, do_sdl_per_pixel_lighting$$1$$dark3, map_image_size, map_image_size, map_image_half_size, 0, map_image_size, map_image_half_size, 0, map_image_half_size);
        drawquarterlightmap_sdl(dark0, do_sdl_per_pixel_lighting$$1$$dark2, do_sdl_per_pixel_lighting$$1$$dark3, dark6, map_image_size, map_image_size, 0, 0, map_image_half_size, map_image_half_size, map_image_half_size, map_image_half_size);
        dst.w = (unsigned short int)map_image_size;
        dst.h = (unsigned short int)map_image_size;
        dst.x = (signed short int)(x * map_image_size);
        dst.y = (signed short int)(y * map_image_size);
        SDL_UnlockSurface(lightmap);
        SDL_UpperBlit(lightmap, (struct SDL_Rect *)(void *)0, mapsurface, &dst);
      }

  }
}

// do_serverhelp
// file p_cmd.c line 233
static void do_serverhelp(const char *arg)
{
  if(!(arg == ((const char *)NULL)))
  {
    char buf[256l];
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "help %s", arg);
    send_command(buf, -1, 1);
  }

  else
    send_command("help", -1, 1);
}

// do_take
// file p_cmd.c line 509
static void do_take(const char *used)
{
  command_take("take", used);
}

// do_timeout
// file main.c line 109
extern signed int do_timeout(void)
{
  if(!(cpl.showmagic == 0))
    magic_map_flash_pos();

  if(!(cpl.spells_updated == 0u))
    update_spell_information();

  if(tick == 0u)
  {
    inventory_tick();
    mapdata_animation();
  }

  return (signed int)!(0 != 0);
}

// draw_ext_info
// file gtk2proto.h line 70
extern void draw_ext_info(signed int orig_color, signed int type, signed int subtype, const char *message)
{
  signed int type_err = 0;
  signed int pane;
  char *stamp = (char *)(void *)0;
  const char *draw = (const char *)(void *)0;
  if(!(want_config[31l] == 0))
  {
    signed long int curtime;
    struct tm *ltime;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(message);
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)1, return_value_strlen$1 + (unsigned long int)7);
    stamp = (char *)return_value_calloc$2;
    curtime=time((signed long int *)(void *)0);
    ltime=localtime(&curtime);
    strftime(stamp, (unsigned long int)6, "%I:%M", ltime);
    strcat(stamp, " ");
    strcat(stamp, message);
    draw = stamp;
  }

  else
    draw = message;
  if(type >= 21 || !(type >= 1))
  {
    LOG((enum LogLevel)LOG_ERROR, "info.c::draw_ext_info", "Invalid message type: %d", type);
    type_err = 1;
  }

  pane = 0;
  for( ; !(pane >= 2); pane = pane + 1)
  {
    if(!(type_err == 0))
    {
      if(!(pane == 0))
        break;

    }

    else
      if(msgctrl_widgets[(signed long int)(type + -1)].pane[(signed long int)pane].state == 0)
        goto __CPROVER_DUMP_L7;

    add_marked_text_to_pane(&info_pane[(signed long int)pane], draw, type, subtype, orig_color);

  __CPROVER_DUMP_L7:
    ;
  }
  if(!(want_config[31l] == 0))
    free((void *)stamp);

}

// draw_inv
// file inventory.c line 1076
extern void draw_inv(signed int tab)
{
  char buf[256l];
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%6.1f", cpl.ob->weight);
  unsigned long int return_value_gtk_label_get_type$1;
  return_value_gtk_label_get_type$1=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)encumbrance_current, return_value_gtk_label_get_type$1);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, buf);
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%6.1f", weight_limit);
  unsigned long int return_value_gtk_label_get_type$3;
  return_value_gtk_label_get_type$3=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)encumbrance_max, return_value_gtk_label_get_type$3);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, buf);
  if(inv_notebooks[(signed long int)tab].type == 0)
    draw_inv_list(tab);

  else
    if(inv_notebooks[(signed long int)tab].type == 1)
      draw_inv_table(0);

}

// draw_inv_list
// file inventory.c line 798
extern void draw_inv_list(signed int tab)
{
  struct item_struct *tmp;
  struct _GtkTreeIter iter;
  signed int rowflag;
  gtk_tree_store_clear(inv_notebooks[(signed long int)tab].treestore);
  tmp = cpl.ob->inv;
  if(!(tmp == ((struct item_struct *)NULL)))
  {
    rowflag=inv_notebooks[(signed long int)tab].show_func(tmp);
    if(!((0x1 & rowflag) == 0))
    {
      add_object_to_store(tmp, inv_notebooks[(signed long int)tab].treestore, &iter, (struct _GtkTreeIter *)(void *)0, rowflag & 0x2);
      if(cpl.container == tmp)
      {
        if(!(tmp->open == 0))
        {
          struct item_struct *tmp2;
          struct _GtkTreeIter iter1;
          struct _GtkTreePath *path;
          tmp2 = tmp->inv;
          if(!(tmp2 == ((struct item_struct *)NULL)))
          {
            if(!((0x1 & rowflag) == 0))
              add_object_to_store(tmp2, inv_notebooks[(signed long int)tab].treestore, &iter1, &iter, rowflag & 0x2);

            tmp2 = tmp2->next;
          }

          unsigned long int return_value_gtk_tree_model_get_type$1;
          return_value_gtk_tree_model_get_type$1=gtk_tree_model_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
          return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)inv_notebooks[(signed long int)tab].treestore, return_value_gtk_tree_model_get_type$1);
          path=gtk_tree_model_get_path((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$2, &iter);
          unsigned long int return_value_gtk_tree_view_get_type$3;
          return_value_gtk_tree_view_get_type$3=gtk_tree_view_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
          return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)inv_notebooks[(signed long int)tab].treeview, return_value_gtk_tree_view_get_type$3);
          gtk_tree_view_expand_row((struct _GtkTreeView *)return_value_g_type_check_instance_cast$4, path, 0);
          gtk_tree_path_free(path);
        }

      }

    }

    tmp = tmp->next;
  }

}

// draw_inv_table
// file inventory.c line 905
extern void draw_inv_table(signed int animate)
{
  signed int x;
  signed int y;
  signed int rows;
  signed int columns;
  signed int num_items;
  signed int i;
  struct item_struct *tmp;
  char buf[256l];
  unsigned long int handler;
  num_items = 0;
  tmp = cpl.ob->inv;
  for( ; !(tmp == ((struct item_struct *)NULL)); tmp = tmp->next)
    num_items = num_items + 1;
  columns = inv_table->allocation.width / image_size;
  if(columns >= 21)
    columns = 20;

  rows = inv_table->allocation.height / image_size;
  if(!(columns * rows >= num_items))
  {
    rows = num_items / columns;
    if(!(num_items % columns == 0))
      rows = rows + 1;

  }

  if(rows >= 101)
    rows = 100;

  unsigned long int return_value_gtk_table_get_type$1;
  return_value_gtk_table_get_type$1=gtk_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)inv_table, return_value_gtk_table_get_type$1);
  gtk_table_resize((struct _GtkTable *)return_value_g_type_check_instance_cast$2, (unsigned int)rows, (unsigned int)columns);
  x = 0;
  y = 0;
  tmp = cpl.ob->inv;
  for( ; !(tmp == ((struct item_struct *)NULL)); tmp = tmp->next)
  {
    if(inv_table_children[(signed long int)x][(signed long int)y] == ((struct _GtkWidget *)NULL))
    {
      inv_table_children[(signed long int)x][(signed long int)y]=gtk_drawing_area_new();
      unsigned long int return_value_gtk_drawing_area_get_type$3;
      return_value_gtk_drawing_area_get_type$3=gtk_drawing_area_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)inv_table_children[(signed long int)x][(signed long int)y], return_value_gtk_drawing_area_get_type$3);
      gtk_drawing_area_size((struct _GtkDrawingArea *)return_value_g_type_check_instance_cast$4, image_size, image_size);
      unsigned long int return_value_gtk_table_get_type$5;
      return_value_gtk_table_get_type$5=gtk_table_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)inv_table, return_value_gtk_table_get_type$5);
      gtk_table_attach((struct _GtkTable *)return_value_g_type_check_instance_cast$6, inv_table_children[(signed long int)x][(signed long int)y], (unsigned int)x, (unsigned int)(x + 1), (unsigned int)y, (unsigned int)(y + 1), (enum anonymous$16)GTK_FILL, (enum anonymous$16)GTK_FILL, (unsigned int)0, (unsigned int)0);
    }

    if(!(animate == 0))
    {
      if((signed int)tmp->animation_id >= 1)
      {
        if(!(tmp->anim_speed == 0))
        {
          tmp->last_anim = tmp->last_anim + 1;
          if((signed int)tmp->last_anim >= (signed int)tmp->anim_speed)
          {
            tmp->anim_state = tmp->anim_state + 1;
            if((signed int)tmp->anim_state >= (signed int)animations[(signed long int)tmp->animation_id].num_animations)
              tmp->anim_state = (unsigned char)0;

            tmp->face = (signed short int)animations[(signed long int)tmp->animation_id].faces[(signed long int)tmp->anim_state];
            tmp->last_anim = (unsigned short int)0;
            gdk_window_clear(inv_table_children[(signed long int)x][(signed long int)y]->window);
            gdk_draw_pixbuf(inv_table_children[(signed long int)x][(signed long int)y]->window, (struct _GdkGC *)(void *)0, (struct _GdkPixbuf *)pixmaps[(signed long int)tmp->face]->icon_image, 0, 0, 0, 0, image_size, image_size, (enum anonymous$15)GDK_RGB_DITHER_NONE, 0, 0);
          }

        }

      }

    }

    else
    {
      handler=g_signal_handler_find((void *)inv_table_children[(signed long int)x][(signed long int)y], (enum anonymous$7)G_SIGNAL_MATCH_FUNC, (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))drawingarea_inventory_table_button_press_event, (void *)0);
      if(!(handler == 0ul))
        g_signal_handler_disconnect((void *)inv_table_children[(signed long int)x][(signed long int)y], handler);

      handler=g_signal_handler_find((void *)inv_table_children[(signed long int)x][(signed long int)y], (enum anonymous$7)G_SIGNAL_MATCH_FUNC, (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))drawingarea_inventory_table_expose_event, (void *)0);
      if(!(handler == 0ul))
        g_signal_handler_disconnect((void *)inv_table_children[(signed long int)x][(signed long int)y], handler);

      gtk_widget_add_events(inv_table_children[(signed long int)x][(signed long int)y], 4194302);
      g_signal_connect_data((void *)inv_table_children[(signed long int)x][(signed long int)y], "button_press_event", (void (*)(void))drawingarea_inventory_table_button_press_event, (void *)tmp, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
      g_signal_connect_data((void *)inv_table_children[(signed long int)x][(signed long int)y], "expose_event", (void (*)(void))drawingarea_inventory_table_expose_event, (void *)tmp, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
      gdk_window_clear(inv_table_children[(signed long int)x][(signed long int)y]->window);
      gdk_draw_pixbuf(inv_table_children[(signed long int)x][(signed long int)y]->window, (struct _GdkGC *)(void *)0, (struct _GdkPixbuf *)pixmaps[(signed long int)tmp->face]->icon_image, 0, 0, 0, 0, image_size, image_size, (enum anonymous$15)GDK_RGB_DITHER_NONE, 0, 0);
      gtk_widget_show(inv_table_children[(signed long int)x][(signed long int)y]);
      snprintf(buf, (unsigned long int)255, "%s %s", (const void *)tmp->d_name, (const void *)tmp->flags);
      gtk_tooltips_set_tip(inv_table_tooltips, inv_table_children[(signed long int)x][(signed long int)y], buf, "Left click examines the object.  Middle click applies the object. Right click drops the object.  Shift left click locks/unlocks the object.  Shift middle click marks the object");
    }
    x = x + 1;
    if(x == columns)
    {
      x = 0;
      y = y + 1;
    }

  }
  if(animate == 0)
  {
    i = num_items;
    static signed int max_drawn = 0;
    for( ; max_drawn >= i; i = i + 1)
    {
      if(!(inv_table_children[(signed long int)x][(signed long int)y] == ((struct _GtkWidget *)NULL)))
      {
        gdk_window_clear(inv_table_children[(signed long int)x][(signed long int)y]->window);
        handler=g_signal_handler_find((void *)inv_table_children[(signed long int)x][(signed long int)y], (enum anonymous$7)G_SIGNAL_MATCH_FUNC, (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))drawingarea_inventory_table_button_press_event, (void *)0);
        if(!(handler == 0ul))
          g_signal_handler_disconnect((void *)inv_table_children[(signed long int)x][(signed long int)y], handler);

        handler=g_signal_handler_find((void *)inv_table_children[(signed long int)x][(signed long int)y], (enum anonymous$7)G_SIGNAL_MATCH_FUNC, (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))drawingarea_inventory_table_expose_event, (void *)0);
        if(!(handler == 0ul))
          g_signal_handler_disconnect((void *)inv_table_children[(signed long int)x][(signed long int)y], handler);

        gtk_widget_hide(inv_table_children[(signed long int)x][(signed long int)y]);
      }

      x = x + 1;
      if(x == columns)
      {
        x = 0;
        y = y + 1;
      }

    }
    max_drawn = num_items;
    gtk_widget_show(inv_table);
  }

}

// draw_keybindings
// file keys.c line 1713
extern void draw_keybindings(struct _GtkWidget *keylist)
{
  signed int i;
  signed int j;
  signed int count = 1;
  struct keybind *kb;
  char buff[256l];
  char buffer[5l][256l];
  char *buffers[5l];
  unsigned long int return_value_gtk_clist_get_type$1;
  return_value_gtk_clist_get_type$1=gtk_clist_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)keylist, return_value_gtk_clist_get_type$1);
  gtk_clist_clear((struct _GtkCList *)return_value_g_type_check_instance_cast$2);
  i = 0;
  struct keybind *tmp_if_expr$3;
  for( ; !(i >= 257); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 2); j = j + 1)
    {
      if(j == 0)
        tmp_if_expr$3 = keys_global[(signed long int)i];

      else
        tmp_if_expr$3 = keys_char[(signed long int)i];
      kb = tmp_if_expr$3;
      for( ; !(kb == ((struct keybind *)NULL)); kb = kb->next)
      {
        get_key_modchars(kb, 0, buff);
        if(!((signed long int)kb->keysym == 0L))
        {
          snprintf(buffer[(signed long int)0], sizeof(char [256l]) /*256ul*/ , "%i", count);
          char *return_value_gdk_keyval_name$4;
          return_value_gdk_keyval_name$4=gdk_keyval_name(kb->keysym);
          snprintf(buffer[(signed long int)1], sizeof(char [256l]) /*256ul*/ , "%s", return_value_gdk_keyval_name$4);
          snprintf(buffer[(signed long int)2], sizeof(char [256l]) /*256ul*/ , "%i", i);
          snprintf(buffer[(signed long int)3], sizeof(char [256l]) /*256ul*/ , "%s", (const void *)buff);
          snprintf(buffer[(signed long int)4], sizeof(char [256l]) /*256ul*/ , "%s", kb->command);
          buffers[(signed long int)0] = buffer[(signed long int)0];
          buffers[(signed long int)1] = buffer[(signed long int)1];
          buffers[(signed long int)2] = buffer[(signed long int)2];
          buffers[(signed long int)3] = buffer[(signed long int)3];
          buffers[(signed long int)4] = buffer[(signed long int)4];
          unsigned long int return_value_gtk_clist_get_type$5;
          return_value_gtk_clist_get_type$5=gtk_clist_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
          return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)keylist, return_value_gtk_clist_get_type$5);
          gtk_clist_append((struct _GtkCList *)return_value_g_type_check_instance_cast$6, buffers);
        }

        count = count + 1;
      }
    }
  }
}

// draw_lists
// file gtk2proto.h line 110
extern void draw_lists(void)
{
  if(!(cpl.container == ((struct item_struct *)NULL)))
  {
    if(!(cpl.container->inv_updated == 0))
    {
      cpl.container->env->inv_updated = (unsigned short int)1;
      cpl.container->inv_updated = (unsigned short int)0;
    }

  }

  if(!(cpl.ob->inv_updated == 0))
  {
    unsigned long int return_value_gtk_notebook_get_type$1;
    return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)inv_notebook, return_value_gtk_notebook_get_type$1);
    signed int return_value_gtk_notebook_get_current_page$3;
    return_value_gtk_notebook_get_current_page$3=gtk_notebook_get_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2);
    draw_inv(return_value_gtk_notebook_get_current_page$3);
    cpl.ob->inv_updated = (unsigned short int)0;
  }

  if(!(cpl.below->inv_updated == 0))
  {
    draw_look_list();
    cpl.below->inv_updated = (unsigned short int)0;
  }

}

// draw_look_list
// file inventory.c line 762
extern void draw_look_list(void)
{
  struct item_struct *tmp;
  struct _GtkTreeIter iter;
  gtk_tree_store_clear(store_look);
  tmp = cpl.below->inv;
  for( ; !(tmp == ((struct item_struct *)NULL)); tmp = tmp->next)
  {
    add_object_to_store(tmp, store_look, &iter, (struct _GtkTreeIter *)(void *)0, 1);
    if(cpl.container == tmp)
    {
      if(!(tmp->open == 0))
      {
        struct item_struct *tmp2;
        struct _GtkTreeIter iter1;
        struct _GtkTreePath *path;
        tmp2 = tmp->inv;
        for( ; !(tmp2 == ((struct item_struct *)NULL)); tmp2 = tmp2->next)
          add_object_to_store(tmp2, store_look, &iter1, &iter, 1);
        unsigned long int return_value_gtk_tree_model_get_type$1;
        return_value_gtk_tree_model_get_type$1=gtk_tree_model_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
        return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)store_look, return_value_gtk_tree_model_get_type$1);
        path=gtk_tree_model_get_path((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$2, &iter);
        unsigned long int return_value_gtk_tree_view_get_type$3;
        return_value_gtk_tree_view_get_type$3=gtk_tree_view_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
        return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)treeview_look, return_value_gtk_tree_view_get_type$3);
        gtk_tree_view_expand_row((struct _GtkTreeView *)return_value_g_type_check_instance_cast$4, path, 0);
        gtk_tree_path_free(path);
      }

    }

  }
}

// draw_magic_map
// file magicmap.c line 38
void draw_magic_map(void)
{
  signed int x = 0;
  signed int y = 0;
  if(!(cpl.magicmap == ((unsigned char *)NULL)))
  {
    unsigned long int return_value_gtk_notebook_get_type$1;
    return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)map_notebook, return_value_gtk_notebook_get_type$1);
    gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2, 1);
    gtk_widget_show(magic_map);
    if(magic_map_gc == ((struct _GdkGC *)NULL))
      magic_map_gc=gdk_gc_new(magic_map->window);

    gdk_gc_set_foreground(magic_map_gc, &root_color[(signed long int)0]);
    gdk_draw_rectangle(magic_map->window, magic_map_gc, (signed int)!(0 != 0), 0, 0, magic_map->allocation.width, magic_map->allocation.height);
    cpl.mapxres = (unsigned short int)(magic_map->allocation.width / (signed int)cpl.mmapx);
    cpl.mapyres = (unsigned short int)(magic_map->allocation.height / (signed int)cpl.mmapy);
    if(!((signed int)cpl.mapxres >= 1) || !((signed int)cpl.mapyres >= 1))
      LOG((enum LogLevel)LOG_WARNING, "gtk-v2::draw_magic_map", "magic map resolution less than 1, map is %dx%d", cpl.mmapx, cpl.mmapy);

    else
    {
      if(!((signed int)cpl.mapyres >= (signed int)cpl.mapxres))
        cpl.mapxres = cpl.mapyres;

      else
        cpl.mapyres = cpl.mapxres;
      y = 0;
      for( ; !(y >= (signed int)cpl.mmapy); y = y + 1)
      {
        x = 0;
        for( ; !(x >= (signed int)cpl.mmapx); x = x + 1)
        {
          unsigned char val = cpl.magicmap[(signed long int)(y * (signed int)cpl.mmapx + x)];
          gdk_gc_set_foreground(magic_map_gc, &root_color[(signed long int)((signed int)val & 0xf)]);
          gdk_draw_rectangle(magic_map->window, magic_map_gc, (signed int)!(0 != 0), (signed int)cpl.mapxres * x, (signed int)cpl.mapyres * y, (signed int)cpl.mapxres, (signed int)cpl.mapyres);
        }
      }
    }
  }

}

// draw_map
// file gtk2proto.h line 162
extern void draw_map(signed int redraw)
{
  if((signed int)use_config[10l] == 1)
    sdl_gen_map(redraw);

  else
    if((signed int)use_config[10l] == 2)
      opengl_gen_map(redraw);

    else
      if((signed int)use_config[10l] == 0)
      {
        if((signed int)cpl.input_state == Metaserver_Select)
          draw_splash();

        else
          gtk_draw_map(redraw);
      }

}

// draw_message_window
// file gtk2proto.h line 267
extern void draw_message_window(signed int redraw)
{
  update_stat(0, (signed long int)cpl.stats.maxhp, (signed long int)cpl.stats.hp, (signed long int)cpl.stats.maxhp, (signed long int)cpl.stats.hp, (signed int)!(0 != 0));
  update_stat(1, (signed long int)cpl.stats.maxsp, (signed long int)cpl.stats.sp, (signed long int)cpl.stats.maxsp, (signed long int)cpl.stats.sp, (signed int)!(0 != 0));
  update_stat(2, (signed long int)cpl.stats.maxgrace, (signed long int)cpl.stats.grace, (signed long int)cpl.stats.maxgrace, (signed long int)cpl.stats.grace, (signed int)!(0 != 0));
  update_stat(3, (signed long int)999, (signed long int)cpl.stats.food, (signed long int)999, (signed long int)cpl.stats.food, (signed int)!(0 != 0));
  static signed long int level_diff;
  if(!(1 + (signed int)cpl.stats.level >= (signed int)exp_table_max))
    level_diff = (signed long int)(exp_table[(signed long int)((signed int)cpl.stats.level + 1)] - exp_table[(signed long int)cpl.stats.level]);

  else
    level_diff = cpl.stats.exp;
  unsigned long int tmp_if_expr$1;
  if(!(1 + (signed int)cpl.stats.level >= (signed int)exp_table_max))
    tmp_if_expr$1 = exp_table[(signed long int)((signed int)cpl.stats.level + 1)];

  else
    tmp_if_expr$1 = (unsigned long int)cpl.stats.exp;
  unsigned long int tmp_if_expr$2;
  if(!(1 + (signed int)cpl.stats.level >= (signed int)exp_table_max))
    tmp_if_expr$2 = (unsigned long int)cpl.stats.exp - exp_table[(signed long int)cpl.stats.level];

  else
    tmp_if_expr$2 = (unsigned long int)cpl.stats.exp;
  update_stat(4, (signed long int)tmp_if_expr$1, cpl.stats.exp, level_diff, (signed long int)tmp_if_expr$2, 0);
  if((signed int)cpl.stats.food % 4 == 3 && !(use_config[21l] == 0) && !((signed int)cpl.stats.food >= 200))
    gdk_beep();

  else
    if(!(use_config[21l] == 0))
    {
      if((signed int)cpl.stats.food == 0)
      {
        static signed int lastbeep = 0;
        lastbeep = lastbeep + 1;
        if(lastbeep == 5)
        {
          lastbeep = 0;
          gdk_beep();
        }

      }

    }

}

// draw_pixmap
// file map.c line 204
static void draw_pixmap(signed int srcx, signed int srcy, signed int dstx, signed int dsty, signed int clipx, signed int clipy, void *mask, void *image, signed int sizex, signed int sizey)
{
  gdk_gc_set_clip_mask(mapgc, (struct _GdkDrawable *)mask);
  gdk_gc_set_clip_origin(mapgc, clipx, clipy);
  gdk_draw_drawable(map_drawing_area->window, mapgc, (struct _GdkDrawable *)image, srcx, srcy, dstx, dsty, sizex, sizey);
}

// draw_prompt
// file keys.c line 1757
extern void draw_prompt(const char *str)
{
  draw_ext_info(1, 20, 4, str);
  unsigned long int return_value_gtk_widget_get_type$1;
  return_value_gtk_widget_get_type$1=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_widget_get_type$1);
  gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
}

// draw_smoothing
// file opengl.c line 532
static void draw_smoothing(signed int layer)
{
  signed int x;
  signed int y;
  signed int mx;
  signed int my;
  y = (signed int)use_config[(signed long int)20] + 8;
  _Bool tmp_if_expr$1;
  for( ; y >= 0; y = y - 1)
  {
    x = (signed int)use_config[(signed long int)19] + 8;
    for( ; x >= 0; x = x - 1)
    {
      mx = x + pl_pos.x;
      my = y + pl_pos.y;
      if((signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->heads[(signed long int)layer].face == 0 && layer >= 1)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (the_map.cells[(signed long int)mx] + (signed long int)my)->smooth[(signed long int)layer] != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        drawsmooth_opengl(x, y, mx, my, layer);

    }
  }
}

// draw_splash
// file gtk2proto.h line 161
extern void draw_splash(void)
{
  struct _GdkDrawable *aboutgdkmask;
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  if((signed int)use_config[10l] == 0)
  {
    static struct _GdkDrawable *splash;
    static signed int have_init = 0;
    if(have_init == 0)
    {
      static char *draw_splash$$1$$crossfiretitle_xpm[109l] = { "346 87 21 1", " \tc None", ".\tc #339966", "+\tc #00CC00", "@\tc #FF6666", "#\tc #666600", "$\tc #FF9900", "%\tc #CC0033", "&\tc #FF3300", "*\tc #000000", "=\tc #CC9933", "-\tc #FFFFFF", ";\tc #FFCC66", ">\tc #660000", ",\tc #333366", "'\tc #FFFF00", ")\tc #FFFF99", "!\tc #CCCC66", "~\tc #CCCCCC", "{\tc #999999", "]\tc #FFFF66", "^\tc #0099CC", "                                                                                 .                                                                                                                                                                                                                                                                        ", 
    "                                                            +++             .     .                                                                                                                                                                                                                                                                       ", 
    "                                                  ++++++++++@+               .     .                                                                                                                                                                                                                                                                      ", 
    "                           ++++++++++++++++++++++++++++++++@@+      +++++++++ .     .                                                                                                                                                                                                                                                                     ", 
    "                             ++@++++@+++@++++@++++@@@@@@@@@+@+ ++++++@+++@+@+  .#    ..                                                                                                                                                                                                                                                                   ", 
    "                               ++@@@@@@@+@@@@+@@@@@@+@@++@@@+@+@@@@@@@@@@@@@+   ..    #.                                                            $                                                                                                                                                                                                     ", 
    "                                 +++@@@@@@@@@@@@@@@@@@@@@@@@+@+@@+@++@+@++@@+    .#.   ..                                                        $  $                                                                                                                                                                                                     ", 
    "                                    ++@@@+++@+@+@++@+@++@@+@@+@+@@@@@@@@@@@@+     .%&&&.%&                                                       $  $                                                                                                                                                                               ** ***                ", 
    "                                      ++@@@@@@@@@@@@@@@@@@@@@@+@+@@+@+@++@@++     &&%%%#%%&                                                      $$ =$                                                                                                                                                       ***                    ** **-**              ", 
    "                                        +++@@@+++@++@@++@+@+@@+@+@@@@@@@@@@+       &&&%%#%#&                                                     =$  $$                                                                                                                                                     ***-* %%              **-* *-****             ", 
    "                                           ++@@@@@@@@@@@@@@@@@@+@+@@@+@++@@+       &&&&%%%%%&                                                     $$ =$$    *                                                                                                                                              ***---*;%              ***   *****             ", 
    "                                             +++@@@++@+@+@@+@+@@+@+@@@@@@@@+       &%&&&&%%%&                                                     =$$-=$$. .. **          ..                                                                                                                              ***-----*                 && &&                 ", 
    "                                                ++@@@@@@@@@@@@@@+@+@@+@+@@++    & &&%&&+++>%%&                                                     =$$-=$.#.#.*  **        ..,...........                                                                                                                  *-*-----*              * && && ***             ", 
    "                                                  ++@@@@++@++@+@@+@+@@@@@@+     &&&%>%&&+'+%>&                                                      =$..&.....,..*        ,...,.,.,.,.,.,....                                                                                                               *%*-----*   *         ***********         *   ", 
    "                                                   %+++@@@@@@@@@@@+@+@+@@+&  & &&>%%&%%&&+&&%%&                                                      #.&&#.#...,..**     ..,..*.*.*.*.*.*,.#.**                                                                                                             &))*-----*  **        ***********        **   ", 
    "                                                &  %&%%++@@@++@+@@+@+@@@@+%  &&%%%%%%&&&%&%&&%>&                                                    ........#...,..**  *.#..*.,..#..,.....*..  *                                                                                                           %));%*---*   ***        **---****        ***   ", 
    "                                            &   &&&&%&&&&++@@@@@@@@+@+@@+&%&&%%>%&%%%&&&&%&  &%%&                                               ...#.,.#.#.*.**..,.    *...,..,...,...,.,.,.*.       !!!!!!!!!~~                                                                                          #)#)%*-*-*     ****      *-*-*-***      ****    ", 
    "                                        &   &&&&%&%%>%%%%%%++@@@++@@+@++&&&%%%%&%%%%&&  &&%&  &%>&                                              *.,.......,.*..*...,   *  *....,*.*.*.*....,..,   !=#==#======#=#==!!~                             {=~                                                   %)))#  ***      *******   *-*-*-**    *******    ", 
    "                                 ~!==~  &&&&%&%>%>%&>%>&%&%%%++@@@@@@+@+%%%%%&%%%%%&&    &&%&  &%&                                              ...,.#   ..*  ,.*...*     ,.,.*...,..,.*,.*..*. !#======#==#=#==========!!              !         !===                                                  #)#)%             ********{======={,*********     ", 
    "                              !!======$&%&%%>%%&%%%%%%%%&%%#%%%+@@@+@@+&&%%&%%%&%&&&      &&%&  &                                               ,....    #**  .**.,.**     ...,.,..#.*....,.,..=============================!~       ~!==!~      !=====~                                               %)))#              *********{{{{{{{***********     ", 
    "                         ~~!!==========#%>%&%>%>%#&%&%&%&%&&%%%%%%%%%%%%%>%>%%%%&&&        &&%&                                                  .,.    .*    ..*...         ...*.*..,.* *..-*=======!;;;;;;!;!================!!!========!     !=======                                             {&%]!%               ,**************************     ", 
    "               !=========================#%>%%%%%&%#%%%%&%%%%&%&&&%&%%%&%%%&%%&%&&%&        &&&                                                  .     .*     ,.,.,.*        #.*.#..**.   .,-!===!;];];];];];;;];;;;;======================~  !===!;!!===~                                          {{{)%&              ,{{,*************&&**********   &&", 
    "              !===!==!==!=!=!!!=!;]]]!=!===%%%%%%&%&%%%%%&&%%#%%%%&%%&%&%&%&%&%&&>%%&&                                                             ,  .*     .*.*...**        #..#.*  *.  *.!==!];]]])])])])]])]))))]];];;!!!=!=!!==!==;!!==!!===;]])!!!==!                                        ,{,,{%               ,,{,,************&{&&&&&&&&&&&&&,&", 
    "             !={!!=!=!!!=!=!!!;]]]]);;!!=====&&%%&%&%&%%#%%%%%#%&&%&&&&%>%%&&%&&%%%%%>&&                                                           ..#.      .,*.#.# *        ...*.*   *.  #={;]])))];!];!];);;);];]))])]];];!=!=!!!!]]];!=!==!=;])])!!!=!=!~                                     {,,,,{{{            ,{,,,#,************&{{{{{{{{{{{{{{{&", 
    "            !!!!!!!!!!=!!;]]]]]])))]));!!!!!==%%%&&%%%&%&%&&%&&&%%%%%&&%&%#%&&&&&&%&%%%%&                                                             *     ...*....          ,.*,..**  * !!!];]));)]);)])])])])]!);])])]))])];]]]]]]]]))#=!!!!;]]))]))!!=!=!~                                   %.{,,{{,{,           {,{,,,,*********$**&{{{{{*****,{,{,&", 
    "           !!=]]]]]]]]]]]]]))))))])])]));!!=!!!=%&&#&%%#%%#&%>%%%%&%&%&&%%%%#&    &&&&&%%&&                                                                 ,**.#.#.*    *    .*...,*.  *!=!;])))]);))]))]))])])]);));)])]))])))])))))))!#!!!]]])))])]);;!!!=! ~                                %#%.,{{,,{,{,{       ,{,,,,,,#***********&{{{{*-----*{,{,&", 
    "          ;!!;])))))))))))))))])])))));))];;!=!=!=&&%#%>%&%%&%&%&%&%&%%&&#%%%&       &&&%%%&&&&                                                            ...*....**   **   ,..#..*     !!!;;))])))]))])))]))))))))])))))])))]))))))])]=#!!;]))))]))))))];;!!!~~ ~                             %)%%{.{{{,,{,,,{,   {,{,,,,{,{********$**&{{{*-------*{,{&", 
    "         !!!]])))))))!!!=!!;))))))])))))))];;;!!!!=&%&%%#%#%&&&%&%&%&&&%&%&#%%&         &&%%%%%&                                                           ,**.,.,.  *  .... ..,..*     !!!;]]))))]))))));)))])])]))))]);)))])))])]))))!##!!;!));)))]))]);!!!!!!                                &!)%% ,{,#,,,,,,#{{{.,#,,,,{,{*******$$$*&{{{*-**-**-*,{,&", 
    "         ;!;]]))))));=,***#;!)))))))))))))))]];;!;!=&>%&%%&&%&%&%&%&%&&&&&%%&%&           &%&&&%&                                                          ..,.....* ***,.#.,...#.*  ** ;!!;!)))))))))!)!)!)))))))))))))))))))))))))));!*{!!=##!!)))))))!=*#=!;~~~~ ~                            %&%    {{{,,#,,,{,{,#,,,{,{,  *****$***$&{{{*-**-**-*{,{&", 
    "        !!!]))-)))))!*#!!!##!;))))))))))))))))]];;!;=%&%%%%%>&&%&%&&&&&&%&&%&%>&           &&  &%&                                                        .***.#.#...........,....*...-~!;!];))))))!;!!#===!!!))))))))))))))))))))))))]##;!;!!##!]))))!;#,#!;!~~--~                                      ,{,,{,#,#,,{,,,,{,{   *$$$$*****&{{{*-------*,{,&", 
    "       !;;])))))))))=#;;!;!=#{!))))))))))))-))-)]]];!=%&&%#%%&&&&&&&&%%&&%&&%%%&           &&   &&                                                       ,...*...**,.,*,.,.,..,.,.,.,.*,!;!;!)))))]=#****,****=!;!)))))))))))))))))));#*=!;!!;!=#{!)))],*=;!;~~~~-~~ ~                                     {{{,,{,#,{#,{,,{,   ******&&&*&{{{{**-*-**,{,{&", 
    "      );!]))-)))))))##!;!;!;=##])))))))-)))))))))!=!;;=%%&%%&%&&&&&%%%%%&&%&&&%>&&          &&   &                                        !       ==      .#.*.#*.......*..!...........#];!!!)))!!,*#=!;!;!;;!#*,#!!;)))))-)))-))))!;#*{]!!~!;!;=#!))!#*!!;!!~~~~~-~  ~                                     {{{{{,#,{,,{,{     *$*$*&***&&{{{{{*---*{,{,{&", 
    "      ;];]))-)-)-))],=];]!]!;!##!)))-))))-)-)-);!,#];!&%&#%&;=&  &&&%&>%%&=;-&&&%%&&         &&       );!                              ~);!;!    ==.=    .***..*.#.,*,...!;!;!..,.,.,...!;;!{));=*#!!;!]!;])))]!=#**,=!!;!))))))));!*,=!;!~{~!];]=#!;#,!!]!!{!{~~~~~~ ;!             ;                        ,{{!!;{{,{,      *$$$*&***&&{{{{{*****{{{{,&", 
    "     !]!]))-)))))))=#;;!!~!;];!=#!))))-)))))))!=*#!;;~%%%%=!;!$   &&&%%%%&]!]  &&&%%&&         &     !;];;!)                         )]!;];]!;)    ,.#   .#..,*.......!;]!]!];!{.....,..!]!;=!!#*=!;]!];]))))-!=]!;!#,**##={;!;!;=,*#!;]{{{{~{!;!;=##*!]!;~{{!{!~~~-~]!])           !;]                        ;!];]!;{        *****&&*&&*&.{.{.*{*{{{{{& ", 
    "     !];])-))-)-)))##!];!!{!!]!;=,#))))-)-)))!,,=;]!!~~&%@;];]!)   &&%&%=;!;!;   &&&%%&&&&        );]!;]!]!;!;                     ;];;];;];]!;! ==...== .....*,.,.{!!;];!];!];]!{...,.#.!];!##*!]!];!]))))--],!;]!]!];!=#,***#***#!!;]!{{{{{{~!)]!!=!!;!!{{{{!{~~~!];!;])         ;];;;                    )!;]!;!];];        *$*$**&*&**&{.{.{.{{{{{{{& ", 
    "    ;]!)])-)))))-);,!;];~{~{!;;];!##]))))))!=*#=];!!{~~~;];]!];!)   &&%&;]]]]!]    &&&%%%>&&    )!;!];]];];]!]!;)                ;!];];]]))]];];];!!.=!..#*,...*..!]];];]]))]]!];]!!=.....!!!!=!];]!]])))--))!,]!;]!]!];!;;];!!=;;;];]{.{{{{{!!;];;])]];]!{{!{{!~~;]!]];];)       !]];];]                 )!;]!];]]];]!;)      *$$$$**&***&.{.-{.{.{-,{,& ", 
    "    !];))--)-)-)-)]#!;];{{{!!]])))]{#!)-))!#*#!;];{{{!!;]!])))];!)   &@];)))]]!;     &&%&&%%@)];]]]!])))))]];]!]!;)            ]!];];]))))-))];];];];]...*.***..!];!]!]])))-)])]!];]!]]....!;];]!;);;))---)))!#]!]!;;]!]];];];];];];]{{{{{{{{];]!]]))))];]!{{!{!!;];])))];;)     ];)))]];;               ;]];]!))))))]]]!;     ***********&.{--.{.{.--,{& ", 
    "   ];]]])-))-))))){#]!]!{{!!;])))-)))-));!*#!]];!{{{{];];)))-)]];]!  !]!]))-!];]!)    &&  &$;];];!]))))--)))]];];];)         )!;]!])))))---))))]];];];]...*..,!];];]]))))----))])]!];]!]{...!;];);]!)))-))-))!#];]!{{!!;]])];]!];]!;{,{{{{{!]!];))))--);]];!{{!;];])))-)]]!])  !;!]))-!]];]~           ;];];)])))---))];]];)   *$*$**&&&**&{.{{-,{,-{.{.& ", 
    "   ;];)))-)-)--)-)#=;];!{{];];]--)-)--)]#*#!]!]{{{{{;];])))---)]];])];])))--)!);];!   &&  )]!]!]]))))--)-)--)))])]!]!       );]];))))---)-)-)-)))))]!];]!.#--!;];]))))----))-)-))))]!];]]....!;-);]]))--)-)-))#)];;!;];];)))))]!]!{.,{,{.{{];]]))))--)-!!]]]]{);];))))--);]]!);]])))--)!)]!]!         )];]]))))----)-))]);];!  *$$$*&***&*&{.{.{-.-{.{.{& ", 
    "  )!]!))-)-)))-)))#{];){{{;])]!))-)-)]{**{]];!{,,.{;]]))))--)-)!;)];]])))--)))]]]];]~  &&);];)))))----)-))-)--)))]);])~    )];)))))---)-)-)-)-)-))))))]]!---)];])))----)))-))-)-))))))))]]{....*;]!)]-))-))-))=];])]]!);))--)])];]{{{{{{{!])))))---))-))!];;];]!))))--)-)!!]];];)))--)-];]];];       ;;]))))----)))-)--)])]]])~*****&***&**&{{{{{-,{,{,&  ", 
    "  ])]]])-)-)-))-))#{]!]{{{!;];=!))));=*#!];]!{,{{{]!])))---)))-){];];]))-)-)-)))])]]!   @]])))))----)-))-)-)))--))]];]) ~ )];])))--)))-))))))-))-)-))));];~)!]))))--))-)-)-)-)))-)--))));];.#,.{];]))--))-)-)-!!;];;];]]))-)--!]);]{{{{{{];)))----)-))-)!{])!]])))----))-)!)];]]))--)-)-)])]!]! ~  ~]]!)))----)))-)))))-)])];];#****&&*&&**&{{{{-{-,{,{&  ", 
    "  !]!);-)))))-))))*!];]{{{{!]!!#{;]!,*=;]!!{,{,.{!;)))--)))-)))))!]))))--))))-)))])];]~);!))))--)))))))-))))-)))-))])!]!-);])))--)!#=)))-)-)))-)))---){=]!];])))--)!#=)))))))-)-))))--){=];]..#];]);))))-))))-)!)]];)])))--))))!]!]!{{{!];];!-))))))-))))#;];)))--))))))))!!]))))-)))))-))))]];]~  !];)))-);)))-))-)-)))-))]]!]!,****&&&***&{{--{,{--.{&  ", 
    "  ];])!-))-)))-))]#;];;{{{{{!!]=#*#*#!!];!>{.{,{;];]!)))-))))-)))=))))-)))-)))))-))];]!;]]))-)-))-))-))))-)))-)))-));];])];]))-)))#**#]))))-)))-))))]!*{]!]!]))-)))#**#]))-))))))-)))]!*{]!!.,.!];]!)-))))-))))))))))))--))-)))!!];;!{{{!];!##)))-)))-))]#!]!]!)))-))-)-)))!))))--))-)))-))));]];~];])))-!*,!))))))))-))))-))]];!#**********&{{-,{,-{.&   ", 
    " !!;!])))))))))))!#;!]!,{{{{{!;!!!{!!;]!=>>>>{{,{!;!=#!)))))))))))))--)))))))-))))){!;];!])))!;])))))))))))))))))))));];!];))-))))={!#,=))))))))))))!,#;;!];)))-)))={!#,=])))))))))))!##;!;.*#.;!]]!))))))))))))!]))---)))))))-;#;];!{{{{!;]!=!)))))))))!#;!;!=#!)))))))))))))--))))))))))-)){!;]!;]))-)]###,#;)))))))))-))))]];]!#*********&{{{{{{{{{&   ", 
    " !]!;!)-)))))))))!#!;!!,,{{{{~];!;!]!;!~{{>>#,,+*{;!!=#))))))))))-)-))))))))))))]!#*!;];]]))!**,=!;!)))))))))))))))))!!];!]])-))))!!;!=*#!;)))))))))!,!;];!]]))))))!!;;=,#!!)))))))))!*!;]!,,.#];!;!)))))))))))),*,=;))))))))))]#;!;]{~{~!;;!;!)))))))))=#]!]!!=#)))))))))))-)))))))))))))]!#*!!;!]]))-)]*=;!#,!))))))))))))))!!;!!#********&&{{{{{{{&&   ", 
    " ;!;]!)))))))))))==!]!!.{{{{~~~!;];!;!~~{~{{,,+++#!;!;!!))))))))))];!;!))))))))!;#*!!;!!]));*#=#,*,#=!)))))))))))))))){;!]]))))))))!;];!#*,=!!;!)));##;!!;]]))))))))!];!!#*,=!!)!)));##;!;#,##.!;!;!))))))))))))!!!##!))))))))!!#!;!!~{~~!!];!]))))))))!{#;!;!;!!!))))))))))];!;!))))))))!;#*{;!]!]))))!=#!;!!=*!])))))))))))!!=!;!!,*****,,,&{{{{{{{&    ", 
    " ;!!]!)))))))))))!#!;!!,{{{{{~~~!;!!!~~~~{~{{,#,#,!!;!;!)))))))));=#,#,#=;!)))]!#,!;!!;]]))=,!;!;!=#**#!!!))))))))))))!!;!!)))))))))];];!!=,*,#=!!)]#=!;!!;!)))))))));]]!!!=,**#=!!);#=!!!#~~,.;!!!{)))))))))))))=;!##!!))))));##];!!~{~~;!;!!!))))))));==!;];!!;!)))))))));{#,#*#=;!)))]!#,!!;!!]])-))]#=!!;!;=#{!))))))))!!#*#;!!,,***,#,#,&&,{,{,&&    ", 
    "~!;!;!))))))))));{=!!;{{,{{{!~~~-~-~~~~~~{~{~{~{~~!!!;!;))))))))!#*,####,*=])!;#*=!!;!!)]-;#=!!!;!;!!=#**=;!))))))))));{!;!)))))))))))]];;!;!=#**#=!*!!;!;!!)))))))))))]];;!;!=#**#=!,!;!;{~~#,!;!!=))))))))))))){!!!##!])))]!=*=!!!~{~~~!!!;!;))))))))]#=!!!!;!!;))))))))!#**####*,=])!;#*=;!!;;])))));#=;!!;!!=#=])))))!!=*,=!!!,,,,,{{{,{,,&&{,{&&     ", 
    "-!!!;!))])););))]{#!!!!{.{{{~~~~~-~--~~~!!!!!!~~~~!;!!!!));));))]#=!!;!!!=#=];=,=;!!;!];))!#=!;!!!!;!!!!=,*#!;])););)))!!!=)])]))]))))))]]];;!;!!=*##!!!!!;=;);))]));))))]]];;!;!!=*##!!!!{{~,##!;!==;!))]));)]));=;!!=#!;);!=*#!;!{{~{~~!;!!!!);))])));#=!;!!;!!!)))]);))]#=!!;!!!=#=];=,=!!!!!];))]))],!!;!!!!!=#!)])]]!**#!!;=,,,,,,,{,,,,,,&&,&&      ", 
    "-!;!!!)]))]))););!#!;!!.{{{{~~~-~-~-~~~!!;!!!!!~~~!!!;!;)));)););#=!!!!;!;]]!!*=!!!!!!];));#=!!!)!!!!;!!!!=#,=;]))));)]!#;=!)))]))])])])))]]]]];!!!!=;!!!!!=!));))]))])])))]]]]];!!!!=!;{{{{#,#*!!!=#;)]))])))])))=!!!!=!;!=,*=!!!{{{~{~~!!!;!;))]))]))!#=!!!!!!;!)])!))])!==;!!!!!;]]!!*#!;!!!!];)))])!#!!!!;!;!]]]);];#*#=!!!=,#,,,,,,{,#,#,#,&&&       ", 
    "-=!!!!));););))])=#!!!!,.{{{~~~~~--~-!;!!!!;!!=!~-!!!!!!);));)]))#=;!!!!]]))],#!!!!!!!]!));#;!!!~~~!!!=!@!!!=#*!!!])!));#!==!;);)]))]))]))))))]]]];!!!!=;!!==];)]))]!])))))))))]]]]!;!!!!#{#,,#~~!!!==!)])])]);););=;!;==!#*#=!!!{{{{~{~~!!!!!!;))])])]!#!!!;!!!!!))])])]))#=!!!$!]]))]##!!!!!!;]))])]);#;!!!!!;]])))!=**=!!;!=**,,,,,,-,.{#{{,#{         ", 
    "~!!=!=)])]);)!);)!#!!!={{{{~~~~-----!!=!!!!!!!!!!~!=!=!!)]!]);)!]#=!=!!;]));=,=!!!!!!;!]);]==!=!!~~~~!{!!!!!!==,=;);)])]=!!=!!)])])]);););)])))))]];;!!!!=!=#!!););)])!];])]);))))]];;!!!!#,##*~~!=!==!;)]););)])]!=!=!=#*#=!!!!{{{{{{~{~!!!!!;)])])]!]!#!!!!!!!!;]););)]);#=!=!!;]));=,=!!!!!!;!)])););==!=!;]]]));!#*#=!!=!#,,***,,,,~,{,#,,,,{         ", 
    " !!!==])])]);]);]!#=!!!,{{{{~~~~~--~=!!;]]]];;!!!!;!!!=!);])])])]#=!!!!];)]!##!!!{!!!;!;);){=!!=!~~{~~!{{!!!!!!=#=!;);]!#===#!;);)]!)];)];);]);];))]];;!!!!!=#!;);]!])])])]!)!);];))]];;!!!{*{~~~~!!!==;)];)]!]!)])!=!!!!!=!=!!{{{{{{{{~~!!!=!!)!)])])]!#!!=!!=!!!)!);])]]!#=!!=!];])!##!!={!=!;!)]!];);==!!;]])))!=*#==!!!{#**,,,*,,,~-,{,,,,,,{         ", 
    " !==!=;];];])];);!#=!!!{,{{~~~~---!!!;;]])))];;!=!!!=!!;]!];];];!#==!=;]])!=,=!=!{!=!!!;];];=!!=!!~~{~{~!{{!!=!==#!;];)!#=!==#=!];;);])];);];])])];)])!;!!====#=!];]!]!;];);];])]!];)]]!;!=!{{~~~~!=!!=!;])];])];!);!===!!=!=!{{{{***~~!~!=!!!!];];]!])!#=!=!!!!!!];]!];])!#==!!;]])!=,==!!!!!!!;;););])!=;]]])]!=**#=!!=!{,,,*,**#,#,~~~,{,#{,{{         ", 
    " !!!==!!);];];];];#!!=!{{{{{~~~~-~=!!;]]);];]]!=!==!=!=!););])]]!#=!=!;;];!=#!!!{{!!==!)];);!=!==!{~~~{~{~{~{!=!==#!];]!#=====#=!!!];];!]!]!];];]!]!;]]!!!!!==###!!)];];]!]!];];];];!);]!!!=={~~~~~=====!]!]!]!];]!]!=!=!!!={{{{{*****{~~!!!==!]!]!);];!#=!!=!=!=!)];])];]!#=!=!;;];;=#!=!{{!=!=!];];];;!=;]]);=#*#=!==!{{{,,,**,,,,,~~~-,{,,,,,{         ", 
    " !====!;;!];;!]!;!=====.{{{~~~~~-=!==!;];];!];]==!=!==!!;];;]!;;!====!!];]!##==={{==!=!!]!];]!=!=!=!!{~!~~{~{~{====!;!]!===!===##=!!;;];;];;!]!;];;]!;];=!==!=!=##==!!;];;];!];!];;]]!];]=!=!=!~~~~!====!;;;];!]!];]!====={{{{{{{*{{**~~~!===!!;;;]!;];!#==!====!!;];!];!]!#===!!];]!##==={!=!=!!;];;]!];]]);!=*,#===!{{{{***,*,,,,,{~~--.,###,#.         ", 
    "  !====];!]!];!];!==!=={{{{{~~~~-~===##!!;]!;!]!=======!;];!]!]!;#====!]!;!#==!=!{!===!;;;!;!]=!=!==={{{~~~~~~{!====!;;!#=======##*#=!!!;];];;];;];!];!]!========##*#=!!!;];;];;!]!;;!]!;!=====~~~~!!==#!!];!];;!;!;;==!=={{{{{{{*{{**~~~!!===!!]!;]!;;!#====!===!;!];!];;!#=!==!];;!#==!={{====!;!]!;]!;];!=#*#=====!{{{{*,,*,,,,,#~~~~~ {{,,***         ", 
    "  {===#!;;!;!;]!;;=#===={{{~~~~---!===#!!;!;];!!#======!;!;;;!;;!#===!;;!]!======{=====!]!];!;;!=======!!{~~~~~=====;!;!#==========#*,#!!!;;!;;!;;]!;!;;;===========#**#!=!;!;];!;!]!;;];!=====!~~~~=====;;!;!]!];];!=#===={{{{{{{***~~~~!====!;;];!]!]=#========!];!;]!;]!#===!!;!];======!=====;!;;!;;];!=**=====!{{{{{*,{,*,,,#,~~~~   ,.#*~~~*        ", 
    "  !=====;!;]!;!;];!#====.{{{~~~-~--====#!;!;!;;=#======!]!]!];];!#====!;;!;============;!;!;]!;;;!!========{!!~=====]!;!#============#**#==!!]!]!;!;]!]!;=============##*#==!;!;];!;]!;!];=====!~~~~=====;!];!;;!;!];!#====,{{{***^^^****!====!;;!;;;!;!#========!;];!;!;;!##===!!;!;============;!]!]!;!;;;========={!{!#={#*,#,,,~~~~~  {{,*!{~*        ", 
    "   ====#!;!;!;]!;;!#===={{{~~~~~---!====!;!]!]!!#======!;!;!;!;;!#=====!;;!;=!;;========;];!;!]!;;;=!===============;!!=#====;;;!=======##,#==!;!;]!;!;!]!#===;;;!!======#,*#==!!;;!;!;!;;!#====~~~-!====!;!;!]!;;;!;!#===={{**^^^^^**{{,#====!;];!]!;!!#========!;;!;]!;!!#=====;!;!;=!!!!=====#!!;;!;]!;];!!==============##,,,,~~~ ~    ,,*~~!*        ", 
    "   !===#=!!;!;!;!;!====={{{{~~~-~--!====!;!;;!;=#======!!;;!;!!;!##====!;!;];!;;!=======!;];!;!;!;]!;!==============;;=##====!];];;!;!====##,*#=!;!;;!;!;=#===!];;;;!;=====##,##!!!;!;];!;!#====~~~~!====!!;!;!;];!;!!#====**^**,^^^*{{{,#====!!;;!;!;;!#========!;!;!;!;;!##====!;!;];;;;=======#!;!;!;!;!;;];!============###,,,~ ~ ~ ~  {{,*{~*        ", 
    "    ====#!;!;!;!;!;=#===={{{~~~~---!=====;!;!;!##======!;!;!;;!;!#===##!!;!;!]]!#=====#=!;!;!;!;!;!;;;;!============]!=,======!;];];;;;!=====##*=!!;!;!;!=#====!];];];;!!=====##,#!;!;!;!!=#===={~~~!=====]!;;!;!;!;!=#====,**{~**^**.,,{#====!;!;!;!;!!#========!;!;!;!;!!#===##!!;!;!]]!=#=====#=!;!;!;!;!!!;;!!===========###,~~ ~      ,,,***         ", 
    "    ~===##!!;!;!;!;!#==#={{{~~~~-~-!#===!];!;!!*#======!;!]!;!;!!##===##=!;!;!!=##=====#=!;!;!;!;!;!!;;];!$!=======!;!##=====!;!!!;!!;];;!=====##=!!;!;!==#==!=;!!!!;!;];!;======#=!;!;!;==#==={{~=======!;!!;!;!;!;!=#===#*{{{~*^^^*{{.{#=====];!;!;!;!=#========];!;!;!;!##===##=!!;!;==##======#!!;!;!;!;;!;!;;;!;!;!;!$!==#=#-~ ~ ~    {#,#{{         ", 
    "     !=#=#=!!;!;!;!;!======{{!~-!~!=====;;!!;=##===#===!;!;!!;!;!##=$==###=====##=====###=!;!;!;!;!;!!;!];];;!$!=!!;!=*#=====!;!;!;!;!!;];;!======!;!;!;!##===!;!;;!;!;!;;]!!======!;!;!;!##=#={{====#===;!;!;!;!;!;=##===#{{{{~**^*^*,{*!====!;!;!;!;!!=#==#====!;!;!;!;!!#===$=###=====###=={===##!!;!;!;!!;!;!];;;;;;;;;!===#{!~        ,{,,,{         ", 
    "      !==##=!!;!!;!!;==$#=========#$===!]!;!!=*#=======!!;!;!!;!!##=====##*#,**##=={{===##!!;!!;!!;!;!!;!!!!];];;;!;=###$#===;]!;!;!;!;!;!;;!=====;!;!!!=##===;]!!!;!!;!!!;;;!=====;!;!!==##==={==#=$===!]!;!;!!;!!!!###==,,{{{~*^^^^*{,*!#=#=!;!!;!!;!;=#$==#=#=!;!;!!;!;!##=#===##,##**##=={{!===##!!;!!;!;!!;!;!!!;!]!!=###=#!~ ~ ~     {#,#{,         ", 
    "       {==###!!;!;!;!;====#===#=#$====!;;!;!=###=#=#$#==;!!;!;!;!##==##===#####===!{~{===##!!;!;!;!;!;!;!;;!!!;!;];!###=====!!;!!;!!;!!;!;!;;;!=;!]!!;==*#===!;!;;!;!;!;!;!!;!;!=;!]!!;!=*#==#{#==#===!;;;!!;!;!!;!=##====,{{{{~~****-**-!=====!;!;!;!;!=#=#======!!;!;!!;!##=#=#===####===={{!~{=####!!;!;!!;!;!;!;!;!!==*##==#~~         .,#,#{         ", 
    "        !==###!!!;!;!;;!============!;;];!!=##==={=====!];!]!;!;!##===#=========={{~{~!==###=!;!]!;];!;!;!;;;!;!!==#,#=====!!;!!;!;]!;;!]!;]!;]!;;;!!=###===!!;!!!]!;];!;!;!;!;]!;];!==#*##=={====!;;;;]!];!]!;]!;!=,#===,,,{{{~******---!====!]!;];!;!;;#=======!]!;];;!;!##===#=========={{{~{!{==###=!!];!]!;!;!]!;!=#*##=={,~~~ ~ ~    ,{,,{.         ", 
    "         !===##=!!;]!;!]!;!=!====;;;;]]!!!=*#==={{{====!!;;!;]!;!#===={,========{{****~{===##==!;!;;];]!]!]!;!!=##*##========##==!=!;];!;!;;;!;]!!==#**#======##===!!;;];]!];];!;!!==#*,#===,=====;];]];!;!;!;!;]!=##===#,{{{{{~******---!====!;;!;]!];!!#=======!;;!;!]!;!====={,========{{{!~~~~{===##=!!;!;;];]!;;!!#*#===#,~~~-~       {#,#,{         ", 
    "          !===###=!!;];;;;];;;;;];;]];;!=#,#==={{{=====!;];]!;!]!=#===#*{======*****>***{===##*==!!;!;!;;!;!==#**##===!{{==##***,*,==!;!];];];!==#**##======###**,*,==!;!;;!;;!;!=#**##====,{,===##=!!!]!];]!];!!!###=={,,,,{{{***~-***--====!;];]!;;!;;!#=======!]!];!];!;=#==={.{======{{{{{{{!~~!===###=!;];;!;!]!=#*====#,,~~~~-~ ~    {#,#{.         ", 
    "        ~  !====#*#==!!!!];]]])]]]]!!!==**#==={{{{====!];]!;];];;!#===#*****************~!====##,#==!!];]!==,*#======!~!{!========#*,#=!!;]!!==#*##======{=========#*,#=!;];]!==**##======{,{{{===###=!!;!;];;!!#*#===#,,,{{{{~***-~***-!===!;];!;]!];];]=#=====!;];!];!];;!#===={{{{{!{{{!{~~!~~~~~!====#*#=!!];]!;=#*====#,,,~~~~-~      {{,#,{         ", 
    "            !=====#*,###==!=!=!=!==##,**#===={~~{{=====!==!======!#====************~***~~~!======#*,##=!==**#======={{~{~!!!=========#*#!!;;=**#========,,{{==========###!!;!=,*#========.{{,{{{====#*##=!=====#*#==={,,,,,{{{{**~~  ***!====!!=!===!===!=#======!=!====!==!#===={{{{{{~!{!{!{~{~~~~~!=====#*##!!!!=##====,,,,,,~~~~-~ ~   .{,{,,         ", 
    "          ~ ~!=!======#,***,#,*#*****#=====!!~{{{{{!==#,*********,#=!{*************~~~~~~~~~!==!====##*##,#====!=!=!{{!{!{{!!!=!=!=====##==#*#====!==!{.{,{{!=!==!======##==#*#===!=!=!{,{,{,{{{{=!====#******,#===!.,,,,{{{{!***-~  *** !===#************#=!===#***********#===.{{{{{{~!~~~~~!~~~~~~~!!===!=##**##*#====*,,*,,,,~-~-~     ,,,,{{         ", 
    "              ~!!=!========#=####=!=!==!=!=~~~{{!{{{!==!=!!=!=!===!!=**************~~~~~-~~~~!!=!!!====##====!=!!{{{{{{~{~!{!{!!=!=!!!===##*#!=!!!={{{{{,{.{{{{!{!!!!!!===##*#=!=!!={{{{.{.{{{{{{~!=!====!=!===!!!={,,,,,,{{{{**~~ ~  **  !=!===!!!!!=!=!=!=!{=!!=!!=!==!===!=!{{{{{{~{~~!{~~~~~~~~~-~~~!!!=!====##====#*,**,*,,,~~~-~ ~  {#,#{,,         ", 
    "             ~~~!=!!!!!!=!=!=!=!!==!=!==!!~~{~~{{{{{!=!=!!=!=!!!!=!!*****{{!~~******~~~~-~-~ ~~!=!!!!!=!==!=!{{{{{{{{~{{~~~~~~~~~~!{!!!!=====!=!!{{{{{{{{{{{{{{{{~{!!!!!!====!!=!={{{{{{{{{{{{{{{~!!!!!!!=!=!=!==!{{,.{.{{{{{~**~     ***  !=!!!!==!=!==!!=!,{{!!=!!!=!=!=!=!=.{{{{{{~~~~~~~~~~~~~~-~~~~~!!!!!!!=!=!!!#,***,*,,#,~~~-~    ,,,,#,,{        ", 
    "               ~~~!!=!!=!=!=!=!=!!=!=!!!~~~~!~{~{~{{~{!!=!=!=!!!!!!{{***{{{{~~~*****~-~~~-~  ~~~~{!!=!=!!!!{{{{{{{{{{{~{!~{~~~~~~~~~~!=!=!=!=!{{.{.{{{{.{{{{{{~{~{~{!{!!!=!=!=!!{{.{.{{{{{{{{{{!{~~~!!=!!!!!=!=!!{{{{,{{,{{{{~**~~ ~   **   !!=!!!!!=!=!=!={{{{{!!=!=!=!!!=!={{{{{{{{{~~~~~~~~~~-~-~    ~~~!!!!!!!!!!#**,,,,,,,,~~~~~ ~   {,,,,,{,,       ", 
    "              ~ ~~~~~{!{!!!!!!!!!!!!!!~~~~~{~{{~{~!~~~!!!!!!!=!!!!{{{**{{~~~~~~**~ **-~  ~ ~ ~-~~~~~{!=!=!{{{{{{{{{{{{~{~~~~~~~~~~~~~~~!!=!!!{{{{{{{{{{{{{{{~{~!~~~~~~~{!=!=!={{{{{{{{{{{{{{{~~~~~~~~~~!!=!!!!!{{{{{,{{{{{{~~***       **    !=!=!=!!!!=!!{{{{{{{=!=!!=!=!=!{{{{{{{~~~~~~~-~~-~ ~ ~ ~  ~-~~~~{!!!!!=#*,,,,,,,{~{~~~-~     ,{,{,,,#{       ", 
    "                 ~~~~~~{~{{{{{{{!~{~~~~~~~~~~~~!{~~~~~~~~~~~~~~~{{{{**{{{{{~~~~**~ ***-~      ~-~~~~~~{{{{{{{{{{{{{{{{{~{~~~~~-~-~~~~~~!{!!!{{{{{{{{{{{{{{{~{~~~~~~~~~~~~{!=!{{{{{{{{{{{{{{~{~{~~~~~   ~-~~~~~~{{{{{{{{{{{{{~~~~~               ~-~~~~~{{{{{{{{{{~~~~~~~{~{{{{{{{{{~{~~~-~-~ ~  ~       ~ ~~~~~~{!{,#,,,,{{{{{~~~~~-~ ~     ,{{{{{{       ", 
    "              ~ ~ ~~~~~~~{~{!{!{!~~~~~~~~~~~!~~~~~~~~~~-~-~~~~~{~{{{***{~~~~~  *** ~***    ~ ~ ~ ~~~~!~{~{{{{{{{{{{~{~~~~~~~-~-~-~-~~~~~~{!{{{{{{{{{{{~{~~{~~~~~~~~~~~~~~~~!{{{{{{{{{{{{!{~~~~~~~~ ~ ~  ~-~~~~~{~{{{{{{{{~~~~~  ~                ~-~~~~{~{{{{{{~~!~~~~~~~{~{{{{{{~!~~~~ ~ ~  ~    ~        ~~~~~~~{{{{{{{{{{!{~~~~~-~                     ", 
    "                    ~~~~~~~~!~~~~!{~~~~~~~~~~~~~~~~~~~-~ ~  ~~~~~~~~{~{~~~~~~~ ~                   ~~~~~~{~{{{{{~{~{~{~~~~ ~~ ~ ~ ~ ~~~~~~~~{~{{{{{{~{~{!~~~~~~~~~~~~~~~~~~~~!{!{{{{{~{~{~{~~~~~ ~ ~  ~  ~-~~~~~~{~{{{~{~{~~~~~  ~               ~-~~~~~{~{{~{~!{~~~~~~~~~~~{~{~{~~~~~~ ~  ~   ~        ~  ~ ~~~~~~~~{~{{!{!{!~~~~ ~  ~                   ", 
    "                ~ ~ ~-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-~-~    ~ ~~~~~!~~~~~~~~-~   ~                ~ ~~~~~~~~{~~~{~{~~~~~~~~ ~    ~   ~ ~~~~~~~~~~!~!~~!~~~~~~~-~    ~ ~~~~~~~~~~~~~~~{~~~~~~~~~ ~ ~   ~    ~-~~~~{~~!~{~~~~~~  ~                ~  ~ ~~~~~{~~{~~~~~~~~~~~~~~~~!~~~~~~~-~                    ~ ~~~~~~{~~{~{~!~~~~~~~ ~                      ", 
    "                     ~ ~~~~~~~~~~~~~~~~~~~~~~~~~ ~ ~ ~   ~    ~~~~~~~~~~~~~~ ~   ~                   ~~~~~~~~~~~~~~~~~~-~~ ~ ~   ~  ~ ~ ~~~~~~~~~~~~~~~~~~~-~-~ ~  ~   ~-~~~~~~~~{~~~~~~~~~~-~ ~ ~        ~--~~~~~~~!~~~~~~-~  ~                     ~~~~~~~~~~~~~~~~-~~~~~~~~~~~~~~~-~                        ~~~~~~~~~~~~~~~~~ ~  ~                     ", 
    "                    ~   ~-~~~~~~~~~~~~~~~~~-~ ~  ~ ~   ~     ~~ ~~~~~~~~                        ~ ~  ~ ~~~~~~~~~~~~~~ ~-~             ~ ~-~~~~~~~~~~~~~~-~-~ ~       ~  ~  ~~~~~~~~~~~~~~-~ ~          ~   ~-~ ~~~~~~~~~~-~-~                    ~ ~ ~~~~~~~~~~~~ ~~-~ ~ ~~~~~~~~~-~ ~                       ~   ~~~~~~~~~~~~~-~                          ", 
    "                         ~--~-~-~  ~  ~~~ ~-~ ~ ~   ~         ~ ~-~~~~ ~~~~                        ~      ~-~~~~~~~ ~  ~ ~ ~       ~     ~ ~-~~~~~~~~~~ ~ ~             ~ ~  ~ ~~~~~~~~~ ~                  ~  ~ ~~~~~~-~~ ~  ~                        ~-~~~~~~ ~ ~-~  ~  ~ ~~~~-~-~ ~                             ~ ~~~~~~-~-~ ~                         ", 
    "                          ~~ ~ ~ ~ ~ ~  ~  ~  ~   ~        ~     ~   ~ ~                             ~ ~ ~ ~ ~    ~ ~                       ~         ~              ~      ~   ~ ~    ~                     ~ ~ ~ ~   ~                            ~ ~ ~     ~ ~  ~    ~ ~ ~ ~ ~ ~                              ~ ~ ~ ~   ~ ~                            ", 
    "                                      ~        ~                   ~ ~  ~ ~                                ~  ~~                              ~  ~~ ~    ~                         ~ ~      ~                    ~       ~ ~                             ~ ~~   ~    ~              ~                                ~ ~  ~   ~                           ", 
    "                            ~       ~                                                                                                                                        ~                                ~       ~                                       ~         ~    ~ ~                                  ~                                       ", 
    "                                                                                                                                                  ~                                    ~                                                                                                                               ~                                  " };
      splash=gdk_pixmap_create_from_xpm_d(map_drawing_area->window, &aboutgdkmask, (const struct _GdkColor *)(void *)0, (char **)draw_splash$$1$$crossfiretitle_xpm);
      have_init = 1;
    }

    gdk_window_clear(map_drawing_area->window);
    gdk_drawable_get_size(splash, &w, &h);
    x = (map_drawing_area->allocation.width - w) / 2;
    y = (map_drawing_area->allocation.height - h) / 2;
    gdk_gc_set_clip_mask(mapgc, (struct _GdkDrawable *)(void *)0);
    gdk_draw_drawable(map_drawing_area->window, mapgc, splash, 0, 0, x, y, w, h);
  }

}

// draw_stats
// file gtk2proto.h line 268
extern void draw_stats(signed int redraw)
{
  float weap_sp;
  char buff[256l];
  signed int i;
  signed int on_skill;
  signed int sk;
  static struct Stat_struct last_stats;
  static signed int init_before = 0;
  if(init_before == 0)
  {
    init_before = 1;
    memset((void *)&last_stats, 0, sizeof(struct Stat_struct) /*632ul*/ );
  }

  if(!(need_mapping_update == 0))
  {
    if(!(skill_names[1l] == ((char *)NULL)))
      update_stat_mapping();

  }

  signed int return_value_strcmp$3;
  static char last_name[256l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  return_value_strcmp$3=strcmp(cpl.title, last_name);
  if(!(return_value_strcmp$3 == 0) || !(redraw == 0))
  {
    strcpy(last_name, cpl.title);
    unsigned long int return_value_gtk_label_get_type$1;
    return_value_gtk_label_get_type$1=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.playername, return_value_gtk_label_get_type$1);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, cpl.title);
  }

  if(!(cpl.stats.exp == last_stats.exp) || !(redraw == 0))
  {
    last_stats.exp = cpl.stats.exp;
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "Experience: %5ld", cpl.stats.exp);
    unsigned long int return_value_gtk_label_get_type$4;
    return_value_gtk_label_get_type$4=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.exp, return_value_gtk_label_get_type$4);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$5, buff);
  }

  if(!(cpl.stats.level == last_stats.level) || !(redraw == 0))
  {
    last_stats.level = cpl.stats.level;
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "Level: %d", cpl.stats.level);
    unsigned long int return_value_gtk_label_get_type$6;
    return_value_gtk_label_get_type$6=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.level, return_value_gtk_label_get_type$6);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$7, buff);
  }

  if(!(cpl.stats.Str == last_stats.Str) || !(redraw == 0))
  {
    last_stats.Str = cpl.stats.Str;
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%2d", cpl.stats.Str);
    unsigned long int return_value_gtk_label_get_type$8;
    return_value_gtk_label_get_type$8=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.Str, return_value_gtk_label_get_type$8);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$9, buff);
  }

  if(!(cpl.stats.Dex == last_stats.Dex) || !(redraw == 0))
  {
    last_stats.Dex = cpl.stats.Dex;
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%2d", cpl.stats.Dex);
    unsigned long int return_value_gtk_label_get_type$10;
    return_value_gtk_label_get_type$10=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
    return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.Dex, return_value_gtk_label_get_type$10);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$11, buff);
  }

  if(!(cpl.stats.Con == last_stats.Con) || !(redraw == 0))
  {
    last_stats.Con = cpl.stats.Con;
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%2d", cpl.stats.Con);
    unsigned long int return_value_gtk_label_get_type$12;
    return_value_gtk_label_get_type$12=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.Con, return_value_gtk_label_get_type$12);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$13, buff);
  }

  if(!(cpl.stats.Int == last_stats.Int) || !(redraw == 0))
  {
    last_stats.Int = cpl.stats.Int;
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%2d", cpl.stats.Int);
    unsigned long int return_value_gtk_label_get_type$14;
    return_value_gtk_label_get_type$14=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.Int, return_value_gtk_label_get_type$14);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$15, buff);
  }

  if(!(cpl.stats.Wis == last_stats.Wis) || !(redraw == 0))
  {
    last_stats.Wis = cpl.stats.Wis;
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%2d", cpl.stats.Wis);
    unsigned long int return_value_gtk_label_get_type$16;
    return_value_gtk_label_get_type$16=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
    return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.Wis, return_value_gtk_label_get_type$16);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$17, buff);
  }

  if(!(cpl.stats.Pow == last_stats.Pow) || !(redraw == 0))
  {
    last_stats.Pow = cpl.stats.Pow;
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%2d", cpl.stats.Pow);
    unsigned long int return_value_gtk_label_get_type$18;
    return_value_gtk_label_get_type$18=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
    return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.Pow, return_value_gtk_label_get_type$18);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$19, buff);
  }

  if(!(cpl.stats.Cha == last_stats.Cha) || !(redraw == 0))
  {
    last_stats.Cha = cpl.stats.Cha;
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%2d", cpl.stats.Cha);
    unsigned long int return_value_gtk_label_get_type$20;
    return_value_gtk_label_get_type$20=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
    return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.Cha, return_value_gtk_label_get_type$20);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$21, buff);
  }

  if(!(cpl.stats.wc == last_stats.wc) || !(redraw == 0))
  {
    last_stats.wc = cpl.stats.wc;
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%2d", cpl.stats.wc);
    unsigned long int return_value_gtk_label_get_type$22;
    return_value_gtk_label_get_type$22=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
    return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.wc, return_value_gtk_label_get_type$22);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$23, buff);
  }

  if(!(cpl.stats.dam == last_stats.dam) || !(redraw == 0))
  {
    last_stats.dam = cpl.stats.dam;
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%d", cpl.stats.dam);
    unsigned long int return_value_gtk_label_get_type$24;
    return_value_gtk_label_get_type$24=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
    return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.dam, return_value_gtk_label_get_type$24);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$25, buff);
  }

  if(!(cpl.stats.ac == last_stats.ac) || !(redraw == 0))
  {
    last_stats.ac = cpl.stats.ac;
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%d", cpl.stats.ac);
    unsigned long int return_value_gtk_label_get_type$26;
    return_value_gtk_label_get_type$26=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
    return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.ac, return_value_gtk_label_get_type$26);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$27, buff);
  }

  _Bool tmp_if_expr$30;
  if(!(redraw == 0))
    tmp_if_expr$30 = (_Bool)1;

  else
    tmp_if_expr$30 = cpl.stats.resists[(signed long int)0] != last_stats.resists[(signed long int)0] ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$30)
  {
    last_stats.resists[(signed long int)0] = cpl.stats.resists[(signed long int)0];
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%d", cpl.stats.resists[(signed long int)0]);
    unsigned long int return_value_gtk_label_get_type$28;
    return_value_gtk_label_get_type$28=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
    return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.armor, return_value_gtk_label_get_type$28);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$29, buff);
  }

  if(!(cpl.stats.speed == last_stats.speed) || !(redraw == 0))
  {
    last_stats.speed = cpl.stats.speed;
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%3.2f", (double)(float)cpl.stats.speed / 100000.0);
    unsigned long int return_value_gtk_label_get_type$31;
    return_value_gtk_label_get_type$31=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
    return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.speed, return_value_gtk_label_get_type$31);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$32, buff);
  }

  if(csocket.sc_version >= 1029)
    weap_sp = (float)((double)(float)cpl.stats.weapon_sp / 100000.0);

  else
    weap_sp = (float)cpl.stats.speed / (float)cpl.stats.weapon_sp;
  if(IEEE_FLOAT_NOTEQUAL(weap_sp, (float)last_stats.weapon_sp) || !(redraw == 0))
  {
    last_stats.weapon_sp = (signed int)weap_sp;
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%3.2f", weap_sp);
    unsigned long int return_value_gtk_label_get_type$33;
    return_value_gtk_label_get_type$33=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
    return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.weapon_speed, return_value_gtk_label_get_type$33);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$34, buff);
  }

  _Bool tmp_if_expr$38;
  signed int return_value_strcmp$37;
  static char last_range[256l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  if(!(redraw == 0))
    tmp_if_expr$38 = (_Bool)1;

  else
  {
    return_value_strcmp$37=strcmp(cpl.range, last_range);
    tmp_if_expr$38 = return_value_strcmp$37 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$38)
  {
    strcpy(last_range, cpl.range);
    snprintf(buff, sizeof(char [256l]) /*256ul*/ , "Range: %s", (const void *)cpl.range);
    unsigned long int return_value_gtk_label_get_type$35;
    return_value_gtk_label_get_type$35=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
    return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.range, return_value_gtk_label_get_type$35);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$36, cpl.range);
  }

  update_skill_information();
  _Bool tmp_if_expr$45;
  _Bool tmp_if_expr$46;
  _Bool tmp_if_expr$47;
  signed int tmp_post$39;
  signed int tmp_post$42;
  if(!(statwindow.table_skills_exp == ((struct _GtkWidget *)NULL)))
  {
    on_skill = 0;
    /* assertion sizeof(statwindow.skill_exp)/sizeof(*statwindow.skill_exp) >= 2*50 */
    assert(sizeof(struct _GtkWidget *[102l]) /*816ul*/  / sizeof(struct _GtkWidget *) /*8ul*/  >= (unsigned long int)(2 * 50));
    i = 0;
    for( ; !(i >= 50); i = i + 1)
    {
      sk = skill_mapping[(signed long int)i].value;
      if(!(redraw == 0))
        tmp_if_expr$45 = (_Bool)1;

      else
        tmp_if_expr$45 = cpl.stats.skill_exp[(signed long int)sk] != last_stats.skill_exp[(signed long int)sk] ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$45)
        tmp_if_expr$46 = skill_mapping[(signed long int)i].name != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$46 = (_Bool)0;
      if(tmp_if_expr$46)
        tmp_if_expr$47 = cpl.stats.skill_exp[(signed long int)sk] != 0l ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$47 = (_Bool)0;
      if(tmp_if_expr$47)
      {
        tmp_post$39 = on_skill;
        on_skill = on_skill + 1;
        unsigned long int return_value_gtk_label_get_type$40;
        return_value_gtk_label_get_type$40=gtk_label_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$41;
        return_value_g_type_check_instance_cast$41=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.skill_exp[(signed long int)tmp_post$39], return_value_gtk_label_get_type$40);
        gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$41, skill_mapping[(signed long int)i].name);
        snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%ld (%d)", cpl.stats.skill_exp[(signed long int)sk], cpl.stats.skill_level[(signed long int)sk]);
        tmp_post$42 = on_skill;
        on_skill = on_skill + 1;
        unsigned long int return_value_gtk_label_get_type$43;
        return_value_gtk_label_get_type$43=gtk_label_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$44;
        return_value_g_type_check_instance_cast$44=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.skill_exp[(signed long int)tmp_post$42], return_value_gtk_label_get_type$43);
        gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$44, buff);
        last_stats.skill_level[(signed long int)sk] = cpl.stats.skill_level[(signed long int)sk];
        last_stats.skill_exp[(signed long int)sk] = cpl.stats.skill_exp[(signed long int)sk];
      }

      else
        if(!(cpl.stats.skill_exp[(signed long int)sk] == 0l))
          on_skill = on_skill + 2;

    }
    static signed int max_drawn_skill = 0;
    if(!(on_skill >= max_drawn_skill))
    {
      signed int k = on_skill;
      for( ; max_drawn_skill >= k; k = k + 1)
      {
        unsigned long int return_value_gtk_label_get_type$48;
        return_value_gtk_label_get_type$48=gtk_label_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$49;
        return_value_g_type_check_instance_cast$49=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.skill_exp[(signed long int)k], return_value_gtk_label_get_type$48);
        gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$49, "");
      }
    }

    max_drawn_skill = on_skill;
  }

  if(!(redraw == 0) || !(cpl.stats.resist_change == 0u))
  {
    signed int draw_stats$$1$$23$$i;
    signed int j = 0;
    cpl.stats.resist_change = (unsigned int)0;
    draw_stats$$1$$23$$i = 0;
    for( ; !(draw_stats$$1$$23$$i >= 18); draw_stats$$1$$23$$i = draw_stats$$1$$23$$i + 1)
    {
      sk = resist_mapping[(signed long int)draw_stats$$1$$23$$i].value;
      if(!(cpl.stats.resists[(signed long int)sk] == 0))
      {
        unsigned long int return_value_gtk_label_get_type$50;
        return_value_gtk_label_get_type$50=gtk_label_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$51;
        return_value_g_type_check_instance_cast$51=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.resists[(signed long int)j], return_value_gtk_label_get_type$50);
        gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$51, resist_mapping[(signed long int)draw_stats$$1$$23$$i].name);
        j = j + 1;
        snprintf(buff, sizeof(char [256l]) /*256ul*/ , "%+4d", cpl.stats.resists[(signed long int)sk]);
        unsigned long int return_value_gtk_label_get_type$52;
        return_value_gtk_label_get_type$52=gtk_label_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$53;
        return_value_g_type_check_instance_cast$53=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.resists[(signed long int)j], return_value_gtk_label_get_type$52);
        gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$53, buff);
        j = j + 1;
        if(j >= 6)
          break;

      }

    }
    static signed int max_drawn_resists = 0;
    if(!(j >= max_drawn_resists))
    {
      draw_stats$$1$$23$$i = j;
      for( ; max_drawn_resists >= draw_stats$$1$$23$$i; draw_stats$$1$$23$$i = draw_stats$$1$$23$$i + 1)
      {
        unsigned long int return_value_gtk_label_get_type$54;
        return_value_gtk_label_get_type$54=gtk_label_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$55;
        return_value_g_type_check_instance_cast$55=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.resists[(signed long int)draw_stats$$1$$23$$i], return_value_gtk_label_get_type$54);
        gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$55, "");
      }
    }

    max_drawn_resists = j;
  }

}

// drawingarea_inventory_table_button_press_event
// file inventory.c line 859
extern signed int drawingarea_inventory_table_button_press_event(struct _GtkWidget *widget, struct _GdkEventButton *event, void *user_data)
{
  list_item_action(event, (struct item_struct *)user_data);
  return (signed int)!(0 != 0);
}

// drawingarea_inventory_table_expose_event
// file inventory.c line 875
extern signed int drawingarea_inventory_table_expose_event(struct _GtkWidget *widget, struct _GdkEventExpose *event, void *user_data)
{
  struct item_struct *tmp = (struct item_struct *)user_data;
  gdk_window_clear(widget->window);
  if(!(tmp->face == 0))
    gdk_draw_pixbuf(widget->window, (struct _GdkGC *)(void *)0, (struct _GdkPixbuf *)pixmaps[(signed long int)tmp->face]->icon_image, 0, 0, 0, 0, image_size, image_size, (enum anonymous$15)GDK_RGB_DITHER_NONE, 0, 0);

  return (signed int)!(0 != 0);
}

// drawquarterlightmap_sdl
// file sdl.c line 351
extern void drawquarterlightmap_sdl(signed int tl, signed int tr, signed int bl, signed int br, signed int width, signed int height, signed int startx, signed int starty, signed int endx, signed int endy, signed int destx, signed int desty)
{
  signed int x;
  signed int y;
  signed int top;
  signed int bottom;
  signed int val;
  x = startx;
  for( ; !(x >= endx); x = x + 1)
  {
    top = (x * (tr - tl)) / width + tl;
    bottom = (x * (br - bl)) / width + bl;
    y = starty;
    for( ; !(y >= endy); y = y + 1)
    {
      val = (y * (bottom - top)) / height + top;
      if(val >= 256)
        val = 255;

      if(!(val >= 0))
        val = 0;

      unsigned int return_value_SDL_MapRGBA$1;
      return_value_SDL_MapRGBA$1=SDL_MapRGBA(lightmap->format, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)val);
      putpixel(lightmap, (destx + x) - startx, (desty + y) - starty, return_value_SDL_MapRGBA$1);
    }
  }
}

// drawsmooth
// file map.c line 237
extern void drawsmooth(signed int mx, signed int my, signed int layer, signed int picx, signed int picy)
{
  signed int partdone[8l] = { 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int slevels[8l];
  signed int sfaces[8l];
  signed int i;
  signed int weight;
  signed int weightC;
  signed int emx;
  signed int emy;
  signed int smoothface;
  signed int hasFace = 0;
  i = 0;
  for( ; layer >= i; i = i + 1)
    hasFace = hasFace | (signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->heads[(signed long int)i].face;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(hasFace == 0)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if((signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->heads[(signed long int)layer].face == 0 && layer >= 1)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (the_map.cells[(signed long int)mx] + (signed long int)my)->smooth[(signed long int)layer] != 0 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$2 = !tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(!tmp_if_expr$2)
  {
    i = 0;
    for( ; !(i >= 8); i = i + 1)
    {
      static signed int drawsmooth$$1$$dx[8l] = { 0, 1, 1, 1, 0, -1, -1, -1 };
      emx = mx + drawsmooth$$1$$dx[(signed long int)i];
      static signed int drawsmooth$$1$$dy[8l] = { -1, -1, 0, 1, 1, 1, 0, -1 };
      emy = my + drawsmooth$$1$$dy[(signed long int)i];
      if(emx >= the_map.x || emy >= the_map.y || !(emx >= 0) || !(emy >= 0))
      {
        slevels[(signed long int)i] = 0;
        sfaces[(signed long int)i] = 0;
      }

      else
        if((signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->smooth[(signed long int)layer] >= (signed int)(the_map.cells[(signed long int)emx] + (signed long int)emy)->smooth[(signed long int)layer])
        {
          slevels[(signed long int)i] = 0;
          sfaces[(signed long int)i] = 0;
        }

        else
        {
          slevels[(signed long int)i] = (signed int)(the_map.cells[(signed long int)emx] + (signed long int)emy)->smooth[(signed long int)layer];
          sfaces[(signed long int)i] = (signed int)pixmaps[(signed long int)(the_map.cells[(signed long int)emx] + (signed long int)emy)->heads[(signed long int)layer].face]->smooth_face;
        }
    }
    while((_Bool)1)
    {
      signed int lowest = -1;
      i = 0;
      for( ; !(i >= 8); i = i + 1)
        if(slevels[(signed long int)i] >= 1)
        {
          if(partdone[(signed long int)i] == 0)
          {
            if(!(lowest >= 0))
              tmp_if_expr$3 = (_Bool)1;

            else
              tmp_if_expr$3 = slevels[(signed long int)i] < slevels[(signed long int)lowest] ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$3)
              lowest = i;

          }

        }

      if(!(lowest >= 0))
        break;

      weight = 0;
      weightC = 15;
      i = 0;
      for( ; !(i >= 8); i = i + 1)
      {
        if(slevels[(signed long int)i] == slevels[(signed long int)lowest])
          tmp_if_expr$4 = sfaces[(signed long int)i] == sfaces[(signed long int)lowest] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        static signed int drawsmooth$$1$$cweights[8l] = { 0, 2, 0, 4, 0, 8, 0, 1 };
        if(tmp_if_expr$4)
        {
          partdone[(signed long int)i] = 1;
          static signed int drawsmooth$$1$$bweights[8l] = { 2, 0, 4, 0, 8, 0, 1, 0 };
          weight = weight + drawsmooth$$1$$bweights[(signed long int)i];
          static signed int drawsmooth$$1$$bc_exclude[8l] = { 1 + 2, 0, 2 + 4, 0, 4 + 8, 0, 8 + 1, 0 };
          weightC = weightC & ~drawsmooth$$1$$bc_exclude[(signed long int)i];
        }

        else
          weightC = weightC & ~drawsmooth$$1$$cweights[(signed long int)i];
      }
      if(sfaces[(signed long int)lowest] >= 1)
      {
        smoothface = sfaces[(signed long int)lowest];
        if(smoothface >= 1)
        {
          if(pixmaps[(signed long int)smoothface]->map_image == NULL)
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = pixmaps[(signed long int)smoothface] == pixmaps[(signed long int)0] ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr$5)
          {
            if(weight >= 1)
              draw_pixmap(weight * map_image_size, 0, picx, picy, picx - weight * map_image_size, picy, pixmaps[(signed long int)smoothface]->map_mask, pixmaps[(signed long int)smoothface]->map_image, map_image_size, map_image_size);

            if(weightC >= 1)
              draw_pixmap(weightC * map_image_size, map_image_size, picx, picy, picx - weightC * map_image_size, picy + map_image_size, pixmaps[(signed long int)smoothface]->map_mask, pixmaps[(signed long int)smoothface]->map_image, map_image_size, map_image_size);

          }

        }

      }

    }
  }

}

// drawsmooth_opengl
// file opengl.c line 404
static void drawsmooth_opengl(signed int x, signed int y, signed int mx, signed int my, signed int layer)
{
  signed int partdone[8l] = { 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int slevels[8l];
  signed int sfaces[8l];
  signed int i;
  signed int weight;
  signed int weightC;
  signed int emx;
  signed int emy;
  signed int smoothface;
  signed int dosmooth;
  signed int lowest;
  signed int havesmooth;
  dosmooth = 0;
  i = 0;
  _Bool tmp_if_expr$1;
  for( ; !(i >= 8); i = i + 1)
  {
    emx = mx + dx[(signed long int)i];
    emy = my + dy[(signed long int)i];
    if(emx >= the_map.x || emy >= the_map.y || !(emx >= 0) || !(emy >= 0))
    {
      slevels[(signed long int)i] = 0;
      sfaces[(signed long int)i] = 0;
    }

    else
    {
      if((signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->smooth[(signed long int)layer] >= (signed int)(the_map.cells[(signed long int)emx] + (signed long int)emy)->smooth[(signed long int)layer])
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)(the_map.cells[(signed long int)emx] + (signed long int)emy)->heads[(signed long int)layer].face == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        slevels[(signed long int)i] = 0;
        sfaces[(signed long int)i] = 0;
      }

      else
      {
        slevels[(signed long int)i] = (signed int)(the_map.cells[(signed long int)emx] + (signed long int)emy)->smooth[(signed long int)layer];
        sfaces[(signed long int)i] = (signed int)pixmaps[(signed long int)(the_map.cells[(signed long int)emx] + (signed long int)emy)->heads[(signed long int)layer].face]->smooth_face;
        dosmooth = dosmooth + 1;
      }
    }
  }
  havesmooth = 0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  while(!(havesmooth >= dosmooth))
  {
    lowest = -1;
    i = 0;
    for( ; !(i >= 8); i = i + 1)
      if(slevels[(signed long int)i] >= 1)
      {
        if(partdone[(signed long int)i] == 0)
        {
          if(!(lowest >= 0))
            tmp_if_expr$2 = (_Bool)1;

          else
            tmp_if_expr$2 = slevels[(signed long int)i] < slevels[(signed long int)lowest] ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$2)
            lowest = i;

        }

      }

    if(!(lowest >= 0))
      break;

    weight = 0;
    weightC = 15;
    i = 0;
    for( ; !(i >= 8); i = i + 1)
    {
      if(slevels[(signed long int)i] == slevels[(signed long int)lowest])
        tmp_if_expr$3 = sfaces[(signed long int)i] == sfaces[(signed long int)lowest] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
      {
        partdone[(signed long int)i] = 1;
        weight = weight + bweights[(signed long int)i];
        weightC = weightC & ~bc_exclude[(signed long int)i];
        havesmooth = havesmooth + 1;
      }

      else
        weightC = weightC & ~cweights[(signed long int)i];
    }
    smoothface = sfaces[(signed long int)lowest];
    if(smoothface >= 1)
    {
      if(pixmaps[(signed long int)smoothface]->map_texture == 0u)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = pixmaps[(signed long int)smoothface] == pixmaps[(signed long int)0] ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$4)
      {
        if(!((the_map.cells[(signed long int)mx] + (signed long int)my)->cleared == 0))
          glBindTexture((unsigned int)0x0DE1, pixmaps[(signed long int)smoothface]->fog_texture);

        else
          glBindTexture((unsigned int)0x0DE1, pixmaps[(signed long int)smoothface]->map_texture);
        if(!(weight == 0))
        {
          glBegin((unsigned int)0x0007);
          glTexCoord2f((float)((1.0 / 16.0) * (double)weight), 0.0f);
          glVertex3i(x * map_image_size, y * map_image_size, 0);
          glTexCoord2f((float)((1.0 / 16.0) * (double)(weight + 1)), 0.0f);
          glVertex3i((x + 1) * map_image_size, y * map_image_size, 0);
          glTexCoord2f((float)((1.0 / 16.0) * (double)(weight + 1)), 0.5f);
          glVertex3i((x + 1) * map_image_size, (y + 1) * map_image_size, 0);
          glTexCoord2f((float)((1.0 / 16.0) * (double)weight), 0.5f);
          glVertex3i(x * map_image_size, (y + 1) * map_image_size, 0);
          glEnd();
        }

        if(!(weightC == 0))
        {
          glBegin((unsigned int)0x0007);
          glTexCoord2f((float)((1.0 / 16.0) * (double)weight), 0.5f);
          glVertex3i(x * map_image_size, y * map_image_size, 0);
          glTexCoord2f((float)((1.0 / 16.0) * (double)(weight + 1)), 0.5f);
          glVertex3i((x + 1) * map_image_size, y * map_image_size, 0);
          glTexCoord2f((float)((1.0 / 16.0) * (double)(weight + 1)), 1.0f);
          glVertex3i((x + 1) * map_image_size, (y + 1) * map_image_size, 0);
          glTexCoord2f((float)((1.0 / 16.0) * (double)weight), 1.0f);
          glVertex3i(x * map_image_size, (y + 1) * map_image_size, 0);
          glEnd();
        }

      }

    }

  }
}

// drawsmooth_sdl
// file sdl.c line 681
static void drawsmooth_sdl(signed int mx, signed int my, signed int layer, struct SDL_Rect dst)
{
  signed int partdone[8l] = { 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int slevels[8l];
  signed int sfaces[8l];
  signed int i;
  signed int weight;
  signed int weightC;
  signed int emx;
  signed int emy;
  signed int smoothface;
  signed int hasFace = 0;
  struct SDL_Rect src;
  i = 0;
  for( ; layer >= i; i = i + 1)
    hasFace = hasFace | (signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->heads[(signed long int)i].face;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(hasFace == 0)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if((signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->heads[(signed long int)layer].face == 0 && layer >= 1)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (the_map.cells[(signed long int)mx] + (signed long int)my)->smooth[(signed long int)layer] != 0 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$2 = !tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  if(!tmp_if_expr$2)
  {
    src.w = dst.w;
    src.h = dst.h;
    i = 0;
    for( ; !(i >= 8); i = i + 1)
    {
      static signed int drawsmooth_sdl$$1$$dx[8l] = { 0, 1, 1, 1, 0, -1, -1, -1 };
      emx = mx + drawsmooth_sdl$$1$$dx[(signed long int)i];
      static signed int drawsmooth_sdl$$1$$dy[8l] = { -1, -1, 0, 1, 1, 1, 0, -1 };
      emy = my + drawsmooth_sdl$$1$$dy[(signed long int)i];
      if(emx >= the_map.x || emy >= the_map.y || !(emx >= 0) || !(emy >= 0))
      {
        slevels[(signed long int)i] = 0;
        sfaces[(signed long int)i] = 0;
      }

      else
        if((signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->smooth[(signed long int)layer] >= (signed int)(the_map.cells[(signed long int)emx] + (signed long int)emy)->smooth[(signed long int)layer])
        {
          slevels[(signed long int)i] = 0;
          sfaces[(signed long int)i] = 0;
        }

        else
        {
          slevels[(signed long int)i] = (signed int)(the_map.cells[(signed long int)emx] + (signed long int)emy)->smooth[(signed long int)layer];
          sfaces[(signed long int)i] = (signed int)pixmaps[(signed long int)(the_map.cells[(signed long int)emx] + (signed long int)emy)->heads[(signed long int)layer].face]->smooth_face;
        }
    }
    while((_Bool)1)
    {
      signed int lowest = -1;
      i = 0;
      for( ; !(i >= 8); i = i + 1)
        if(slevels[(signed long int)i] >= 1)
        {
          if(partdone[(signed long int)i] == 0)
          {
            if(!(lowest >= 0))
              tmp_if_expr$3 = (_Bool)1;

            else
              tmp_if_expr$3 = slevels[(signed long int)i] < slevels[(signed long int)lowest] ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$3)
              lowest = i;

          }

        }

      if(!(lowest >= 0))
        break;

      weight = 0;
      weightC = 15;
      i = 0;
      for( ; !(i >= 8); i = i + 1)
      {
        if(slevels[(signed long int)i] == slevels[(signed long int)lowest])
          tmp_if_expr$4 = sfaces[(signed long int)i] == sfaces[(signed long int)lowest] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$4 = (_Bool)0;
        static signed int drawsmooth_sdl$$1$$cweights[8l] = { 0, 2, 0, 4, 0, 8, 0, 1 };
        if(tmp_if_expr$4)
        {
          partdone[(signed long int)i] = 1;
          static signed int drawsmooth_sdl$$1$$bweights[8l] = { 2, 0, 4, 0, 8, 0, 1, 0 };
          weight = weight + drawsmooth_sdl$$1$$bweights[(signed long int)i];
          static signed int drawsmooth_sdl$$1$$bc_exclude[8l] = { 1 + 2, 0, 2 + 4, 0, 4 + 8, 0, 8 + 1, 0 };
          weightC = weightC & ~drawsmooth_sdl$$1$$bc_exclude[(signed long int)i];
        }

        else
          weightC = weightC & ~drawsmooth_sdl$$1$$cweights[(signed long int)i];
      }
      if(sfaces[(signed long int)lowest] >= 1)
      {
        smoothface = sfaces[(signed long int)lowest];
        if(smoothface >= 1)
        {
          if(pixmaps[(signed long int)smoothface]->map_image == NULL)
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = pixmaps[(signed long int)smoothface] == pixmaps[(signed long int)0] ? (_Bool)1 : (_Bool)0;
          if(!tmp_if_expr$5)
          {
            if(weight >= 1)
            {
              src.x = (signed short int)(map_image_size * weight);
              src.y = (signed short int)0;
              if(!((the_map.cells[(signed long int)mx] + (signed long int)my)->cleared == 0))
              {
                signed int return_value_SDL_UpperBlit$6;
                return_value_SDL_UpperBlit$6=SDL_UpperBlit((struct SDL_Surface *)pixmaps[(signed long int)smoothface]->fog_image, &src, mapsurface, &dst);
                if(!(return_value_SDL_UpperBlit$6 == 0))
                  do_SDL_error("BlitSurface", "sdl.c", 793);

              }

              else
              {
                signed int return_value_SDL_UpperBlit$7;
                return_value_SDL_UpperBlit$7=SDL_UpperBlit((struct SDL_Surface *)pixmaps[(signed long int)smoothface]->map_image, &src, mapsurface, &dst);
                if(!(return_value_SDL_UpperBlit$7 == 0))
                  do_SDL_error("BlitSurface", "sdl.c", 798);

              }
            }

            if(weightC >= 1)
            {
              src.x = (signed short int)(map_image_size * weightC);
              src.y = (signed short int)map_image_size;
              if(!((the_map.cells[(signed long int)mx] + (signed long int)my)->cleared == 0))
              {
                signed int return_value_SDL_UpperBlit$8;
                return_value_SDL_UpperBlit$8=SDL_UpperBlit((struct SDL_Surface *)pixmaps[(signed long int)smoothface]->fog_image, &src, mapsurface, &dst);
                if(!(return_value_SDL_UpperBlit$8 == 0))
                  do_SDL_error("BlitSurface", "sdl.c", 808);

              }

              else
              {
                signed int return_value_SDL_UpperBlit$9;
                return_value_SDL_UpperBlit$9=SDL_UpperBlit((struct SDL_Surface *)pixmaps[(signed long int)smoothface]->map_image, &src, mapsurface, &dst);
                if(!(return_value_SDL_UpperBlit$9 == 0))
                  do_SDL_error("BlitSurface", "sdl.c", 813);

              }
            }

          }

        }

      }

    }
  }

}

// error_dialog
// file gtk2proto.h line 148
extern void error_dialog(char *description, char *information)
{
  struct _GtkWidget *dialog;
  gtk_init((signed int *)(void *)0, (char ***)(void *)0);
  dialog=gtk_message_dialog_new((struct _GtkWindow *)(void *)0, (enum anonymous$40)GTK_DIALOG_DESTROY_WITH_PARENT, (enum anonymous$41)GTK_MESSAGE_ERROR, (enum anonymous$42)GTK_BUTTONS_CLOSE, "Crossfire %s\n%s", (const void *)VERSION_INFO, description);
  unsigned long int return_value_gtk_message_dialog_get_type$1;
  return_value_gtk_message_dialog_get_type$1=gtk_message_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_message_dialog_get_type$1);
  gtk_message_dialog_format_secondary_markup((struct _GtkMessageDialog *)return_value_g_type_check_instance_cast$2, "%s", information);
  unsigned long int return_value_gtk_dialog_get_type$3;
  return_value_gtk_dialog_get_type$3=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$3);
  gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$4);
  gtk_widget_destroy(dialog);
}

// event_loop
// file main.c line 238
extern void event_loop(void)
{
  signed int tag;
  maxfd = csocket.fd + 1;
  timeout.tv_sec = (signed long int)0;
  timeout.tv_usec = (signed long int)0;
  gtk_timeout_add((unsigned int)10, (signed int (*)(void *))do_timeout, (void *)0);
  if(csocket.fd == -1)
  {
    if(!(csocket_fd == 0))
    {
      gdk_input_remove(csocket_fd);
      csocket_fd = 0;
      gtk_main_quit();
    }

  }

  else
  {
    csocket_fd=gdk_input_add((signed int)csocket.fd, (enum anonymous$49)GDK_INPUT_READ, (void (*)(void *, signed int, enum anonymous$49))do_network, (void *)&csocket);
    tag = csocket_fd;
    gtk_main();
    gtk_timeout_remove((unsigned int)tag);
    LOG((enum LogLevel)LOG_INFO, "main.c::event_loop", "gtk_main exited, returning from event_loop");
  }
}

// expand_clear_bigface
// file mapdata.c line 312
static void expand_clear_bigface(signed int x, signed int y, signed int w, signed int h, signed int layer, signed int set_need_update)
{
  signed int expand_clear_bigface$$1$$dx;
  signed int expand_clear_bigface$$1$$dy;
  struct MapCellLayer *head;
  /* assertion 0 <= x && x < 64 */
  assert(0 <= x && x < 64);
  /* assertion 0 <= y && y < 64 */
  assert(0 <= y && y < 64);
  /* assertion 1 <= w && w <= 16 */
  assert(1 <= w && w <= 16);
  /* assertion 1 <= h && h <= 16 */
  assert(1 <= h && h <= 16);
  head = &bigfaces[(signed long int)x][(signed long int)y][(signed long int)layer].head;
  expand_clear_bigface$$1$$dx = 0;
  for( ; x >= expand_clear_bigface$$1$$dx && !(expand_clear_bigface$$1$$dx >= w); expand_clear_bigface$$1$$dx = expand_clear_bigface$$1$$dx + 1)
  {
    expand_clear_bigface$$1$$dy = (signed int)!(expand_clear_bigface$$1$$dx != 0);
    for( ; y >= expand_clear_bigface$$1$$dy && !(expand_clear_bigface$$1$$dy >= h); expand_clear_bigface$$1$$dy = expand_clear_bigface$$1$$dy + 1)
    {
      struct MapCellLayer *tail = &bigfaces[(signed long int)(x - expand_clear_bigface$$1$$dx)][(signed long int)(y - expand_clear_bigface$$1$$dy)][(signed long int)layer].tail;
      /* assertion 0 <= x-dx && x-dx < 64 */
      assert(0 <= x - expand_clear_bigface$$1$$dx && x - expand_clear_bigface$$1$$dx < 64);
      /* assertion 0 <= y-dy && y-dy < 64 */
      assert(0 <= y - expand_clear_bigface$$1$$dy && y - expand_clear_bigface$$1$$dy < 64);
      /* assertion 0 <= layer && layer < 10 */
      assert(0 <= layer && layer < 10);
      if(tail->face == head->face)
      {
        if((signed int)tail->size_x == expand_clear_bigface$$1$$dx)
        {
          if((signed int)tail->size_y == expand_clear_bigface$$1$$dy)
          {
            tail->face = (signed short int)0;
            tail->size_x = (signed char)0;
            tail->size_y = (signed char)0;
            if(x + -expand_clear_bigface$$1$$dx >= 0 && y + -expand_clear_bigface$$1$$dy >= 0 && !(x + -expand_clear_bigface$$1$$dx >= width$link1) && !(y + -expand_clear_bigface$$1$$dy >= height$link1))
            {
              /* assertion 0 <= pl_pos.x+x-dx && pl_pos.x+x-dx < 512 */
              assert(0 <= (pl_pos.x + x) - expand_clear_bigface$$1$$dx && (pl_pos.x + x) - expand_clear_bigface$$1$$dx < 512);
              /* assertion 0 <= pl_pos.y+y-dy && pl_pos.y+y-dy < 512 */
              assert(0 <= (pl_pos.y + y) - expand_clear_bigface$$1$$dy && (pl_pos.y + y) - expand_clear_bigface$$1$$dy < 512);
              if(!(set_need_update == 0))
                (the_map.cells[(signed long int)((pl_pos.x + x) - expand_clear_bigface$$1$$dx)] + (signed long int)((pl_pos.y + y) - expand_clear_bigface$$1$$dy))->need_update = (unsigned char)1;

            }

          }

        }

      }

    }
  }
  head->face = (signed short int)0;
  head->size_x = (signed char)1;
  head->size_y = (signed char)1;
}

// expand_clear_bigface_from_layer
// file mapdata.c line 366
static void expand_clear_bigface_from_layer(signed int x, signed int y, signed int layer, signed int set_need_update)
{
  struct BigCell *headcell;
  struct MapCellLayer *head;
  /* assertion 0 <= x && x < 64 */
  assert(0 <= x && x < 64);
  /* assertion 0 <= y && y < 64 */
  assert(0 <= y && y < 64);
  /* assertion 0 <= layer && layer < 10 */
  assert(0 <= layer && layer < 10);
  headcell = &bigfaces[(signed long int)x][(signed long int)y][(signed long int)layer];
  head = &headcell->head;
  if(!((signed int)head->face == 0))
  {
    /* assertion headcell->prev != ((void *)0) || headcell == bigfaces_head */
    assert(headcell->prev != (struct BigCell *)(void *)0 ? (_Bool)1 : (headcell == bigfaces_head ? (_Bool)1 : (_Bool)0));
    if(!(headcell->prev == ((struct BigCell *)NULL)))
      headcell->prev->next = headcell->next;

    if(!(headcell->next == ((struct BigCell *)NULL)))
      headcell->next->prev = headcell->prev;

    if(bigfaces_head == headcell)
    {
      /* assertion headcell->prev == ((void *)0) */
      assert(headcell->prev == (struct BigCell *)(void *)0);
      bigfaces_head = headcell->next;
    }

    else
      /* assertion headcell->prev != ((void *)0) */
      assert(headcell->prev != (struct BigCell *)(void *)0);
    headcell->prev = (struct BigCell *)(void *)0;
    headcell->next = (struct BigCell *)(void *)0;
    expand_clear_bigface(x, y, (signed int)head->size_x, (signed int)head->size_y, layer, set_need_update);
  }

  else
  {
    /* assertion headcell->prev == ((void *)0) && headcell != bigfaces_head */
    assert(headcell->prev == (struct BigCell *)(void *)0 ? (headcell != bigfaces_head ? (_Bool)1 : (_Bool)0) : (_Bool)0);
    /* assertion head->size_x == 1 */
    assert((signed int)head->size_x == 1);
    /* assertion head->size_y == 1 */
    assert((signed int)head->size_y == 1);
  }
}

// expand_clear_face
// file mapdata.c line 179
static void expand_clear_face(signed int x, signed int y, signed int w, signed int h, signed int layer)
{
  signed int expand_clear_face$$1$$dx;
  signed int expand_clear_face$$1$$dy;
  struct MapCell *cell;
  /* assertion 0 <= x && x < 512 */
  assert(0 <= x && x < 512);
  /* assertion 0 <= y && y < 512 */
  assert(0 <= y && y < 512);
  /* assertion 1 <= w && w <= 16 */
  assert(1 <= w && w <= 16);
  /* assertion 1 <= h && h <= 16 */
  assert(1 <= h && h <= 16);
  /* assertion 0 <= x-w+1 && x-w+1 < 512 */
  assert(0 <= (x - w) + 1 && (x - w) + 1 < 512);
  /* assertion 0 <= y-h+1 && y-h+1 < 512 */
  assert(0 <= (y - h) + 1 && (y - h) + 1 < 512);
  cell = &the_map.cells[(signed long int)x][(signed long int)y];
  expand_clear_face$$1$$dx = 0;
  for( ; !(expand_clear_face$$1$$dx >= w); expand_clear_face$$1$$dx = expand_clear_face$$1$$dx + 1)
  {
    expand_clear_face$$1$$dy = (signed int)!(expand_clear_face$$1$$dx != 0);
    for( ; !(expand_clear_face$$1$$dy >= h); expand_clear_face$$1$$dy = expand_clear_face$$1$$dy + 1)
    {
      struct MapCellLayer *tail = &(the_map.cells[(signed long int)(x - expand_clear_face$$1$$dx)] + (signed long int)(y - expand_clear_face$$1$$dy))->tails[(signed long int)layer];
      /* assertion 0 <= x-dx && x-dx < 512 */
      assert(0 <= x - expand_clear_face$$1$$dx && x - expand_clear_face$$1$$dx < 512);
      /* assertion 0 <= y-dy && y-dy < 512 */
      assert(0 <= y - expand_clear_face$$1$$dy && y - expand_clear_face$$1$$dy < 512);
      /* assertion 0 <= layer && layer < 10 */
      assert(0 <= layer && layer < 10);
      if(tail->face == cell->heads[(signed long int)layer].face)
      {
        if((signed int)tail->size_x == expand_clear_face$$1$$dx)
        {
          if((signed int)tail->size_y == expand_clear_face$$1$$dy)
          {
            tail->face = (signed short int)0;
            tail->size_x = (signed char)0;
            tail->size_y = (signed char)0;
            (the_map.cells[(signed long int)(x - expand_clear_face$$1$$dx)] + (signed long int)(y - expand_clear_face$$1$$dy))->need_update = (unsigned char)1;
          }

        }

      }

      mark_resmooth(x - expand_clear_face$$1$$dx, y - expand_clear_face$$1$$dy, layer);
    }
  }
  cell->heads[(signed long int)layer].face = (signed short int)0;
  cell->heads[(signed long int)layer].animation = (signed short int)0;
  cell->heads[(signed long int)layer].animation_speed = (unsigned char)0;
  cell->heads[(signed long int)layer].animation_left = (unsigned char)0;
  cell->heads[(signed long int)layer].animation_phase = (unsigned char)0;
  cell->heads[(signed long int)layer].size_x = (signed char)1;
  cell->heads[(signed long int)layer].size_y = (signed char)1;
  cell->need_update = (unsigned char)1;
  cell->need_resmooth = (unsigned char)1;
  mark_resmooth(x, y, layer);
}

// expand_clear_face_from_layer
// file mapdata.c line 234
static void expand_clear_face_from_layer(signed int x, signed int y, signed int layer)
{
  struct MapCellLayer *cell;
  /* assertion 0 <= x && x < 512 */
  assert(0 <= x && x < 512);
  /* assertion 0 <= y && y < 512 */
  assert(0 <= y && y < 512);
  /* assertion 0 <= layer && layer < 10 */
  assert(0 <= layer && layer < 10);
  cell = &(the_map.cells[(signed long int)x] + (signed long int)y)->heads[(signed long int)layer];
  if(!(cell->size_x == 0))
  {
    if(!(cell->size_y == 0))
      expand_clear_face(x, y, (signed int)cell->size_x, (signed int)cell->size_y, layer);

  }

}

// expand_need_update
// file mapdata.c line 477
static void expand_need_update(signed int x, signed int y, signed int w, signed int h)
{
  signed int expand_need_update$$1$$dx;
  signed int expand_need_update$$1$$dy;
  /* assertion 0 <= x && x < 512 */
  assert(0 <= x && x < 512);
  /* assertion 0 <= y && y < 512 */
  assert(0 <= y && y < 512);
  /* assertion 1 <= w && w <= 16 */
  assert(1 <= w && w <= 16);
  /* assertion 1 <= h && h <= 16 */
  assert(1 <= h && h <= 16);
  /* assertion 0 <= x-w+1 && x-w+1 < 512 */
  assert(0 <= (x - w) + 1 && (x - w) + 1 < 512);
  /* assertion 0 <= y-h+1 && y-h+1 < 512 */
  assert(0 <= (y - h) + 1 && (y - h) + 1 < 512);
  expand_need_update$$1$$dx = 0;
  for( ; !(expand_need_update$$1$$dx >= w); expand_need_update$$1$$dx = expand_need_update$$1$$dx + 1)
  {
    expand_need_update$$1$$dy = 0;
    for( ; !(expand_need_update$$1$$dy >= h); expand_need_update$$1$$dy = expand_need_update$$1$$dy + 1)
    {
      struct MapCell *cell = &the_map.cells[(signed long int)(x - expand_need_update$$1$$dx)][(signed long int)(y - expand_need_update$$1$$dy)];
      /* assertion 0 <= x-dx && x-dx < 512 */
      assert(0 <= x - expand_need_update$$1$$dx && x - expand_need_update$$1$$dx < 512);
      /* assertion 0 <= y-dy && y-dy < 512 */
      assert(0 <= y - expand_need_update$$1$$dy && y - expand_need_update$$1$$dy < 512);
      cell->need_update = (unsigned char)1;
    }
  }
}

// expand_need_update_from_layer
// file mapdata.c line 505
static void expand_need_update_from_layer(signed int x, signed int y, signed int layer)
{
  struct MapCellLayer *head;
  /* assertion 0 <= x && x < 512 */
  assert(0 <= x && x < 512);
  /* assertion 0 <= y && y < 512 */
  assert(0 <= y && y < 512);
  /* assertion 0 <= layer && layer < 10 */
  assert(0 <= layer && layer < 10);
  head = &(the_map.cells[(signed long int)x] + (signed long int)y)->heads[(signed long int)layer];
  if(!((signed int)head->face == 0))
    expand_need_update(x, y, (signed int)head->size_x, (signed int)head->size_y);

  else
  {
    /* assertion head->size_x == 1 */
    assert((signed int)head->size_x == 1);
    /* assertion head->size_y == 1 */
    assert((signed int)head->size_y == 1);
  }
}

// expand_set_bigface
// file mapdata.c line 412
static void expand_set_bigface(signed int x, signed int y, signed int layer, signed short int face, signed int clear)
{
  struct BigCell *headcell;
  struct MapCellLayer *head;
  signed int expand_set_bigface$$1$$dx;
  signed int expand_set_bigface$$1$$dy;
  unsigned char w;
  unsigned char h;
  /* assertion 0 <= x && x < 64 */
  assert(0 <= x && x < 64);
  /* assertion 0 <= y && y < 64 */
  assert(0 <= y && y < 64);
  /* assertion 0 <= layer && layer < 10 */
  assert(0 <= layer && layer < 10);
  headcell = &bigfaces[(signed long int)x][(signed long int)y][(signed long int)layer];
  head = &headcell->head;
  if(!(clear == 0))
    expand_clear_bigface_from_layer(x, y, layer, 1);

  if(!((signed int)face == 0))
  {
    /* assertion headcell->prev == ((void *)0) */
    assert(headcell->prev == (struct BigCell *)(void *)0);
    /* assertion headcell->next == ((void *)0) */
    assert(headcell->next == (struct BigCell *)(void *)0);
    /* assertion headcell != bigfaces_head */
    assert(headcell != bigfaces_head);
    if(!(bigfaces_head == ((struct BigCell *)NULL)))
    {
      /* assertion bigfaces_head->prev == ((void *)0) */
      assert(bigfaces_head->prev == (struct BigCell *)(void *)0);
      bigfaces_head->prev = headcell;
    }

    headcell->next = bigfaces_head;
    bigfaces_head = headcell;
  }

  mapdata_get_image_size((signed int)face, &w, &h);
  /* assertion 1 <= w && w <= 16 */
  assert(1 <= (signed int)w && (signed int)w <= 16);
  /* assertion 1 <= h && h <= 16 */
  assert(1 <= (signed int)h && (signed int)h <= 16);
  head->face = face;
  head->size_x = (signed char)w;
  head->size_y = (signed char)h;
  expand_set_bigface$$1$$dx = 0;
  for( ; x >= expand_set_bigface$$1$$dx && !(expand_set_bigface$$1$$dx >= (signed int)w); expand_set_bigface$$1$$dx = expand_set_bigface$$1$$dx + 1)
  {
    expand_set_bigface$$1$$dy = (signed int)!(expand_set_bigface$$1$$dx != 0);
    for( ; y >= expand_set_bigface$$1$$dy && !(expand_set_bigface$$1$$dy >= (signed int)h); expand_set_bigface$$1$$dy = expand_set_bigface$$1$$dy + 1)
    {
      struct MapCellLayer *tail = &bigfaces[(signed long int)(x - expand_set_bigface$$1$$dx)][(signed long int)(y - expand_set_bigface$$1$$dy)][(signed long int)layer].tail;
      /* assertion 0 <= x-dx && x-dx < 64 */
      assert(0 <= x - expand_set_bigface$$1$$dx && x - expand_set_bigface$$1$$dx < 64);
      /* assertion 0 <= y-dy && y-dy < 64 */
      assert(0 <= y - expand_set_bigface$$1$$dy && y - expand_set_bigface$$1$$dy < 64);
      /* assertion 0 <= layer && layer < 10 */
      assert(0 <= layer && layer < 10);
      tail->face = face;
      tail->size_x = (signed char)expand_set_bigface$$1$$dx;
      tail->size_y = (signed char)expand_set_bigface$$1$$dy;
      if(x + -expand_set_bigface$$1$$dx >= 0 && y + -expand_set_bigface$$1$$dy >= 0 && !(x + -expand_set_bigface$$1$$dx >= width$link1) && !(y + -expand_set_bigface$$1$$dy >= height$link1))
      {
        /* assertion 0 <= pl_pos.x+x-dx && pl_pos.x+x-dx < 512 */
        assert(0 <= (pl_pos.x + x) - expand_set_bigface$$1$$dx && (pl_pos.x + x) - expand_set_bigface$$1$$dx < 512);
        /* assertion 0 <= pl_pos.y+y-dy && pl_pos.y+y-dy < 512 */
        assert(0 <= (pl_pos.y + y) - expand_set_bigface$$1$$dy && (pl_pos.y + y) - expand_set_bigface$$1$$dy < 512);
        (the_map.cells[(signed long int)((pl_pos.x + x) - expand_set_bigface$$1$$dx)] + (signed long int)((pl_pos.y + y) - expand_set_bigface$$1$$dy))->need_update = (unsigned char)1;
      }

    }
  }
}

// expand_set_face
// file mapdata.c line 261
static void expand_set_face(signed int x, signed int y, signed int layer, signed short int face, signed int clear)
{
  struct MapCell *cell;
  signed int expand_set_face$$1$$dx;
  signed int expand_set_face$$1$$dy;
  unsigned char w;
  unsigned char h;
  /* assertion 0 <= x && x < 512 */
  assert(0 <= x && x < 512);
  /* assertion 0 <= y && y < 512 */
  assert(0 <= y && y < 512);
  /* assertion 0 <= layer && layer < 10 */
  assert(0 <= layer && layer < 10);
  cell = &the_map.cells[(signed long int)x][(signed long int)y];
  if(!(clear == 0))
    expand_clear_face_from_layer(x, y, layer);

  mapdata_get_image_size((signed int)face, &w, &h);
  /* assertion 1 <= w && w <= 16 */
  assert(1 <= (signed int)w && (signed int)w <= 16);
  /* assertion 1 <= h && h <= 16 */
  assert(1 <= (signed int)h && (signed int)h <= 16);
  cell->heads[(signed long int)layer].face = face;
  cell->heads[(signed long int)layer].size_x = (signed char)w;
  cell->heads[(signed long int)layer].size_y = (signed char)h;
  cell->need_update = (unsigned char)1;
  mark_resmooth(x, y, layer);
  expand_set_face$$1$$dx = 0;
  for( ; !(expand_set_face$$1$$dx >= (signed int)w); expand_set_face$$1$$dx = expand_set_face$$1$$dx + 1)
  {
    expand_set_face$$1$$dy = (signed int)!(expand_set_face$$1$$dx != 0);
    for( ; !(expand_set_face$$1$$dy >= (signed int)h); expand_set_face$$1$$dy = expand_set_face$$1$$dy + 1)
    {
      struct MapCellLayer *tail = &(the_map.cells[(signed long int)(x - expand_set_face$$1$$dx)] + (signed long int)(y - expand_set_face$$1$$dy))->tails[(signed long int)layer];
      /* assertion 0 <= x-dx && x-dx < 512 */
      assert(0 <= x - expand_set_face$$1$$dx && x - expand_set_face$$1$$dx < 512);
      /* assertion 0 <= y-dy && y-dy < 512 */
      assert(0 <= y - expand_set_face$$1$$dy && y - expand_set_face$$1$$dy < 512);
      /* assertion 0 <= layer && layer < 10 */
      assert(0 <= layer && layer < 10);
      tail->face = face;
      tail->size_x = (signed char)expand_set_face$$1$$dx;
      tail->size_y = (signed char)expand_set_face$$1$$dy;
      (the_map.cells[(signed long int)(x - expand_set_face$$1$$dx)] + (signed long int)(y - expand_set_face$$1$$dy))->need_update = (unsigned char)1;
      mark_resmooth(x - expand_set_face$$1$$dx, y - expand_set_face$$1$$dy, layer);
    }
  }
}

// extended_command
// file ../../common/p_cmd.h line 101
extern void extended_command(const char *ocommand)
{
  const char *cp = ocommand;
  char *cpnext;
  char command[256l];
  cpnext=strchr(cp, 32);
  if(!(cpnext == ((char *)NULL)))
  {
    signed int len = (signed int)(cpnext - ocommand);
    if(len >= 256)
      len = 256 - 1;

    strncpy(command, ocommand, (unsigned long int)len);
    command[(signed long int)len] = (char)0;
    cp = command;
    for( ; (signed int)*cpnext == 32; cpnext = cpnext + 1l)
      ;
    if((signed int)*cpnext == 0)
      cpnext = (char *)(void *)0;

  }

  signed int return_value_script_lua_command$1;
  return_value_script_lua_command$1=script_lua_command(cp, cpnext);
  if(return_value_script_lua_command$1 == 0)
  {
    signed int return_value_handle_local_command$2;
    return_value_handle_local_command$2=handle_local_command(cp, cpnext);
    if(return_value_handle_local_command$2 == 0)
    {
      strncpy(command, ocommand, (unsigned long int)(256 - 1));
      command[(signed long int)(256 - 1)] = (char)0;
      cp=strtok(command, ";");
      while(!(cp == ((const char *)NULL)))
      {
        for( ; (signed int)*cp == 32; cp = cp + 1l)
          ;
        send_command(cp, (signed int)cpl.count, 0);
        cp=strtok((char *)(void *)0, ";");
      }
    }

  }

}

// fill_combobox_from_datadir
// file config.c line 655
static void fill_combobox_from_datadir(struct _GtkWidget *combobox, char *active, unsigned long int want_none, char *subdir, signed int (*scandir_filter)())
{
  signed int count;
  signed int i;
  struct _GtkTreeModel *model;
  char *buf;
  struct _GtkTreeIter iter;
  unsigned long int return_value_gtk_combo_box_get_type$1;
  return_value_gtk_combo_box_get_type$1=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)combobox, return_value_gtk_combo_box_get_type$1);
  model=gtk_combo_box_get_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$2);
  count=gtk_tree_model_iter_n_children(model, (struct _GtkTreeIter *)(void *)0);
  signed int return_value_strcmp$5;
  if(count == 0)
  {
    char path[256l];
    struct dirent **files;
    signed int done_none = 0;
    snprintf(path, (unsigned long int)256, "%s/%s", (const void *)"/usr/share/games/crossfire-client", subdir);
    count=scandir(path, &files, (signed int (*)(struct dirent *))(scandir_filter), alphasort);
    LOG((enum LogLevel)LOG_DEBUG, "config.c::fill_combobox_from_datadir", "found %d files in %s\n", count, (const void *)path);
    i = 0;
    for( ; !(i >= count); i = i + 1)
    {
      if(done_none == 0 && !(want_none == 0ul))
      {
        return_value_strcmp$5=strcmp(files[(signed long int)i]->d_name, "None");
        if(return_value_strcmp$5 >= 1)
        {
          unsigned long int return_value_gtk_combo_box_get_type$3;
          return_value_gtk_combo_box_get_type$3=gtk_combo_box_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
          return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)combobox, return_value_gtk_combo_box_get_type$3);
          gtk_combo_box_append_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$4, "None");
          done_none = 1;
        }

      }

      unsigned long int return_value_gtk_combo_box_get_type$6;
      return_value_gtk_combo_box_get_type$6=gtk_combo_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
      return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)combobox, return_value_gtk_combo_box_get_type$6);
      gtk_combo_box_append_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$7, files[(signed long int)i]->d_name);
    }
    count=gtk_tree_model_iter_n_children(model, (struct _GtkTreeIter *)(void *)0);
  }

  i = 0;
  for( ; !(i >= count); i = i + 1)
  {
    signed int return_value_gtk_tree_model_iter_nth_child$8;
    return_value_gtk_tree_model_iter_nth_child$8=gtk_tree_model_iter_nth_child(model, &iter, (struct _GtkTreeIter *)(void *)0, i);
    if(return_value_gtk_tree_model_iter_nth_child$8 == 0)
    {
      LOG((enum LogLevel)LOG_ERROR, "config.c::fill_combobox_from_datadir", "Unable to get combo box iter\n");
      break;
    }

    gtk_tree_model_get(model, &iter, 0, &buf, -1);
    signed int return_value_strcasecmp$11;
    return_value_strcasecmp$11=strcasecmp(active, buf);
    if(return_value_strcasecmp$11 == 0)
    {
      unsigned long int return_value_gtk_combo_box_get_type$9;
      return_value_gtk_combo_box_get_type$9=gtk_combo_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
      return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)combobox, return_value_gtk_combo_box_get_type$9);
      gtk_combo_box_set_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$10, i);
      g_free((void *)buf);
      break;
    }

    g_free((void *)buf);
  }
}

// find_command
// file p_cmd.c line 998
extern const struct anonymous$47 * find_command(const char *cmd)
{
  struct anonymous$47 **asp_p = (struct anonymous$47 **)(void *)0;
  struct anonymous$47 dummy;
  struct anonymous$47 *dummy_p;
  struct anonymous$47 *asp;
  char *cp;
  char *cmd_cpy;
  cmd_cpy=strdup(cmd);
  cp = cmd_cpy;
  _Bool tmp_if_expr$1;
  signed int tmp_if_expr$2;
  for( ; !(*cp == 0); cp = cp + 1l)
  {
    if((signed int)*cp >= 65)
      tmp_if_expr$1 = (signed int)*cp <= 90 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = ((signed int)*cp - 65) + 97;

    else
      tmp_if_expr$2 = (signed int)*cp;
    *cp = (char)tmp_if_expr$2;
  }
  dummy.name = cmd_cpy;
  dummy_p = &dummy;
  void *return_value_bsearch$3;
  return_value_bsearch$3=bsearch((void *)&dummy_p, (void *)name_sorted_commands, (unsigned long int)num_commands, sizeof(struct anonymous$47 *) /*8ul*/ , sort_by_name);
  asp_p = (struct anonymous$47 **)return_value_bsearch$3;
  if(asp_p == ((struct anonymous$47 **)NULL))
  {
    free((void *)cmd_cpy);
    return (const struct anonymous$47 *)(void *)0;
  }

  else
  {
    asp = *asp_p;
    free((void *)cmd_cpy);
    return asp;
  }
}

// finish_face_cmd
// file image.c line 432
void finish_face_cmd(signed int pnum, unsigned int checksum, signed int has_sum, char *face, signed int faceset)
{
  signed int len;
  unsigned int nx;
  unsigned int ny;
  unsigned char data[65536l];
  unsigned char *png_tmp;
  char filename[1024l];
  unsigned int newsum = (unsigned int)0;
  struct Cache_Entry *ce = (struct Cache_Entry *)(void *)0;
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("HOME");
  snprintf(filename, sizeof(char [1024l]) /*1024ul*/ , "%s/%s/crossfire/gfx/%s.png", return_value_getenv$1, xdg_cache_dir, face);
  signed int return_value_load_image$5;
  return_value_load_image$5=load_image(filename, data, &len, &newsum);
  char *return_value_getenv$3;
  if(return_value_load_image$5 == -1)
  {
    ce=image_find_cache_entry(face, checksum, has_sum);
    if(ce == ((struct Cache_Entry *)NULL))
    {
      requestface(pnum, face);
      goto __CPROVER_DUMP_L12;
    }

    else
      if(!(ce->image_data == NULL))
      {
        signed int return_value_associate_cache_entry$2;
        return_value_associate_cache_entry$2=associate_cache_entry(ce, pnum);
        if(return_value_associate_cache_entry$2 == 0)
          goto __CPROVER_DUMP_L12;

      }

    if(!(ce->ispublic == 0u))
      snprintf(filename, sizeof(char [1024l]) /*1024ul*/ , "%s/%s", (const void *)"/usr/share/games/crossfire-client", ce->filename);

    else
    {
      return_value_getenv$3=getenv("HOME");
      snprintf(filename, sizeof(char [1024l]) /*1024ul*/ , "%s/%s/crossfire/image-cache/%s", return_value_getenv$3, xdg_cache_dir, ce->filename);
    }
    signed int return_value_load_image$4;
    return_value_load_image$4=load_image(filename, data, &len, &newsum);
    if(return_value_load_image$4 == -1)
    {
      LOG((enum LogLevel)LOG_WARNING, "common::finish_face_cmd", "file %s listed in cache file, but unable to load", (const void *)filename);
      requestface(pnum, face);
      goto __CPROVER_DUMP_L12;
    }

  }

  png_tmp=png_to_data(data, len, &nx, &ny);
  if(png_tmp == ((unsigned char *)NULL))
  {
    LOG((enum LogLevel)LOG_WARNING, "common::finish_face_cmd", "Got error on png_to_data, image=%s", face);
    if(!(ce == ((struct Cache_Entry *)NULL)))
    {
      if(ce->ispublic == 0u)
        unlink(filename);

      image_remove_hash(face, ce);
    }

    requestface(pnum, face);
  }

  signed int return_value_create_and_rescale_image_from_data$6;
  return_value_create_and_rescale_image_from_data$6=create_and_rescale_image_from_data(ce, pnum, png_tmp, (signed int)nx, (signed int)ny);
  if(!(return_value_create_and_rescale_image_from_data$6 == 0))
  {
    LOG((enum LogLevel)LOG_WARNING, "common::finish_face_cmd", "Got error on create_and_rescale_image_from_data, file=%s", (const void *)filename);
    requestface(pnum, face);
  }

  free((void *)png_tmp);

__CPROVER_DUMP_L12:
  ;
}

// fire_dir
// file ../../common/proto.h line 145
void fire_dir(signed int dir)
{
  char buf[256l];
  if((signed int)cpl.input_state == Playing)
  {
    if(!(dir == dfire))
    {
      snprintf(buf, sizeof(char [256l]) /*256ul*/ , "fire %d", dir);
      signed int return_value_send_command$1;
      return_value_send_command$1=send_command(buf, (signed int)cpl.count, 0);
      if(!(return_value_send_command$1 == 0))
      {
        dfire = dir;
        cpl.count = (unsigned int)0;
      }

    }

    else
      dfire = dfire & 0xff;
  }

}

// focusoutfunc
// file keys.c line 1527
extern void focusoutfunc(struct _GtkWidget *widget, struct _GdkEventKey *event, struct _GtkWidget *window)
{
  if((signed int)cpl.fire_on == 1)
  {
    cpl.fire_on = (unsigned int)0;
    clear_fire();
    unsigned long int return_value_gtk_label_get_type$1;
    return_value_gtk_label_get_type$1=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)fire_label, return_value_gtk_label_get_type$1);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, "    ");
  }

  if((signed int)cpl.run_on == 1)
  {
    cpl.run_on = (unsigned int)0;
    if(!(use_config[2l] == 0))
      draw_ext_info(0, 20, 6, "stop run");

    clear_run();
    unsigned long int return_value_gtk_label_get_type$3;
    return_value_gtk_label_get_type$3=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)run_label, return_value_gtk_label_get_type$3);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, "   ");
  }

  if((signed int)cpl.alt_on == 1)
    cpl.alt_on = (unsigned int)0;

  if((signed int)cpl.meta_on == 1)
    cpl.meta_on = (unsigned int)0;

}

// format_si_number
// file stats.c line 258
static void format_si_number(signed long int number, char *buffer, signed int limit)
{
  const char SI_SUFFIX[4l] = { (const char)0, (const char)107, (const char)77, (const char)71 };
  const float SI_VALUE[4l] = { (const float)1, (const float)1000, (const float)1000000, (const float)1000000000 };
  signed int suffix = 0;
  signed int i;
  float value;
  i = (signed int)(sizeof(const char [4l]) /*4ul*/  / sizeof(char) /*1ul*/  - (unsigned long int)1);
  for( ; i >= 1; i = i - 1)
    if((float)number / SI_VALUE[(signed long int)i] >= 10.000000f)
    {
      suffix = i;
      break;
    }

  value = (float)number / SI_VALUE[(signed long int)suffix];
  if(IEEE_FLOAT_EQUAL(value + -((float)(signed int)value), 0.000000f))
    snprintf(buffer, (unsigned long int)limit, "%.0f%c", value, SI_SUFFIX[(signed long int)suffix]);

  else
    snprintf(buffer, (unsigned long int)limit, "%.1f%c", value, SI_SUFFIX[(signed long int)suffix]);
}

// free_all_items
// file item.c line 264
void free_all_items(struct item_struct *op)
{
  struct item_struct *tmp;
  for( ; !(op == ((struct item_struct *)NULL)); op = tmp)
  {
    if(!(op->inv == ((struct item_struct *)NULL)))
      free_all_items(op->inv);

    tmp = op->next;
    free((void *)op);
  }
}

// free_all_race_class_info
// file commands.c line 421
void free_all_race_class_info(struct Race_Class_Info *data, signed int num_entries)
{
  signed int i = 0;
  for( ; !(i >= num_entries); i = i + 1)
  {
    signed int j;
    if(!((data + (signed long int)i)->arch_name == ((char *)NULL)))
      free((void *)(data + (signed long int)i)->arch_name);

    if(!((data + (signed long int)i)->public_name == ((char *)NULL)))
      free((void *)(data + (signed long int)i)->public_name);

    if(!((data + (signed long int)i)->description == ((char *)NULL)))
      free((void *)(data + (signed long int)i)->description);

    j = 0;
    for( ; !(j >= (data + (signed long int)i)->num_rc_choice); j = j + 1)
    {
      signed int k = 0;
      for( ; !(k >= ((data + (signed long int)i)->rc_choice + (signed long int)j)->num_values); k = k + 1)
      {
        free((void *)((data + (signed long int)i)->rc_choice + (signed long int)j)->value_arch[(signed long int)k]);
        free((void *)((data + (signed long int)i)->rc_choice + (signed long int)j)->value_desc[(signed long int)k]);
      }
      free((void *)((data + (signed long int)i)->rc_choice + (signed long int)j)->value_arch);
      free((void *)((data + (signed long int)i)->rc_choice + (signed long int)j)->value_desc);
      free((void *)((data + (signed long int)i)->rc_choice + (signed long int)j)->choice_name);
      free((void *)((data + (signed long int)i)->rc_choice + (signed long int)j)->choice_desc);
    }
  }
  free((void *)data);
  data = (struct Race_Class_Info *)(void *)0;
}

// free_all_starting_map_info
// file commands.c line 134
void free_all_starting_map_info()
{
  signed int i;
  if(!(starting_map_info == ((struct Starting_Map_Info *)NULL)))
  {
    i = 0;
    for( ; !(i >= starting_map_number); i = i + 1)
    {
      if(!((starting_map_info + (signed long int)i)->arch_name == ((char *)NULL)))
        free((void *)(starting_map_info + (signed long int)i)->arch_name);

      if(!((starting_map_info + (signed long int)i)->public_name == ((char *)NULL)))
        free((void *)(starting_map_info + (signed long int)i)->public_name);

      if(!((starting_map_info + (signed long int)i)->description == ((char *)NULL)))
        free((void *)(starting_map_info + (signed long int)i)->description);

    }
    free((void *)starting_map_info);
    starting_map_info = (struct Starting_Map_Info *)(void *)0;
    starting_map_number = 0;
  }

}

// free_pixmap
// file image.c line 238
static void free_pixmap(struct PixmapInfo *pi)
{
  if(!(pi->icon_image == NULL))
    g_object_unref(pi->icon_image);

  if(!(pi->icon_mask == NULL))
    g_object_unref(pi->icon_mask);

  if(!(pi->map_mask == NULL))
    g_object_unref(pi->map_mask);

  if((signed int)use_config[10l] == 1)
  {
    if(!(pi->map_image == NULL))
    {
      SDL_FreeSurface((struct SDL_Surface *)pi->map_image);
      free(((struct SDL_Surface *)pi->map_image)->pixels);
      SDL_FreeSurface((struct SDL_Surface *)pi->fog_image);
    }

  }

  else
    if((signed int)use_config[10l] == 2)
      opengl_free_pixmap(pi);

    else
      if((signed int)use_config[10l] == 0)
      {
        if(!(pi->map_image == NULL))
          g_object_unref(pi->map_image);

      }

}

// getLogLevelText
// file misc.c line 173
static const char * getLogLevelText(enum LogLevel level)
{
  return LogLevelTexts[(signed long int)((signed int)level > LOG_CRITICAL ? LOG_CRITICAL + 1 : (signed int)level)];
}

// getTextManager
// file commands.c line 1246
static void (*getTextManager(signed int type))(signed int, signed int, signed int, char *)
{
  struct TextManager *current = firstTextManager;
  for( ; !(current == ((struct TextManager *)NULL)); current = current->next)
    if(current->type == type)
      return current->callback;

  return (void (*)(signed int, signed int, signed int, char *))(void *)0;
}

// get_cat_sorted_commands
// file p_cmd.c line 1039
struct anonymous$47 ** get_cat_sorted_commands(void)
{
  return cat_sorted_commands;
}

// get_category_name
// file p_cmd.c line 366
const char * get_category_name(enum anonymous$46 cat)
{
  const char *cat_name;
  switch((signed int)cat)
  {
    case COMM_CAT_MISC:
    {
      cat_name = "Miscellaneous";
      break;
    }
    case COMM_CAT_HELP:
    {
      cat_name = "Help";
      break;
    }
    case COMM_CAT_INFO:
    {
      cat_name = "Informational";
      break;
    }
    case COMM_CAT_SETUP:
    {
      cat_name = "Configuration";
      break;
    }
    case COMM_CAT_SCRIPT:
    {
      cat_name = "Scripting";
      break;
    }
    case COMM_CAT_DEBUG:
    {
      cat_name = "Debugging";
      break;
    }
    default:
      cat_name = "PROGRAMMER ERROR";
  }
  return cat_name;
}

// get_class_info
// file commands.c line 678
static void get_class_info(char *data, signed int len)
{
  if(used_classes >= num_classes)
    LOG((enum LogLevel)LOG_ERROR, "common::get_race_info", "used classes exceed num classes, %d>=%d", used_classes, num_classes);

  else
  {
    process_race_class_info(data, len, &classes[(signed long int)used_classes]);
    used_classes = used_classes + 1;
    if(used_classes == num_classes)
    {
      qsort((void *)classes, (unsigned long int)used_classes, sizeof(struct Race_Class_Info) /*48ul*/ , (signed int (*)(const void *, const void *))rc_compar);
      new_char_window_update_info();
    }

  }
}

// get_exp_info
// file commands.c line 706
static void get_exp_info(const unsigned char *data, signed int len)
{
  signed int pos;
  signed int level;
  if(!(len >= 2))
    LOG((enum LogLevel)LOG_ERROR, "common::get_exp_info", "no max level info from server provided");

  else
  {
    signed short int return_value_GetShort_String$1;
    return_value_GetShort_String$1=GetShort_String(data);
    exp_table_max = (unsigned short int)return_value_GetShort_String$1;
    pos = 2;
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)exp_table_max, sizeof(unsigned long int) /*8ul*/ );
    exp_table = (unsigned long int *)return_value_calloc$2;
    level = 1;
    for( ; (signed int)exp_table_max >= level && !(pos >= len); level = level + 1)
    {
      signed long int return_value_GetInt64_String$3;
      return_value_GetInt64_String$3=GetInt64_String(data + (signed long int)pos);
      exp_table[(signed long int)level] = (unsigned long int)return_value_GetInt64_String$3;
      pos = pos + 8;
    }
    if(!(level == (signed int)exp_table_max))
      LOG((enum LogLevel)LOG_ERROR, "common::get_exp_info", "Incomplete table sent - got %d entries, wanted %d", level, exp_table_max);

  }
}

// get_flags
// file item.c line 508
static void get_flags(struct item_struct *op, unsigned short int flags)
{
  op->was_open = (unsigned short int)op->open;
  op->open = (unsigned short int)(((signed int)flags & 0x2000) != 0 ? 1 : 0);
  op->damned = (unsigned short int)(((signed int)flags & 0x1000) != 0 ? 1 : 0);
  op->cursed = (unsigned short int)(((signed int)flags & 0x0800) != 0 ? 1 : 0);
  op->magical = (unsigned short int)(((signed int)flags & 0x0400) != 0 ? 1 : 0);
  op->unpaid = (unsigned short int)(((signed int)flags & 0x0200) != 0 ? 1 : 0);
  op->applied = (unsigned short int)(((signed int)flags & 0x000F) != 0 ? 1 : 0);
  op->locked = (unsigned short int)(((signed int)flags & 0x8000) != 0 ? 1 : 0);
  op->flagsval = (unsigned int)flags;
  op->apply_type = (unsigned char)((signed int)flags & 0x000F);
  set_flag_string(op);
}

// get_image_info
// file ./proto.h line 51
void get_image_info(unsigned char *data, signed int len)
{
  char *cp;
  char *lp;
  char *cps[7l];
  char buf[256l];
  signed int onset = 0;
  signed int badline = 0;
  signed int i;
  replyinfo_status = replyinfo_status | 0x1;
  lp = (char *)data;
  cp=strchr(lp, 10);
  char *tmp_post$3;
  signed int return_value_atoi$7;
  signed int return_value_strcasecmp$5;
  signed int return_value_strcasecmp$6;
  if(!(cp == ((char *)NULL)) && (signed long int)len >= cp - lp)
  {
    signed int return_value_atoi$1;
    return_value_atoi$1=atoi(lp);
    face_info.num_images = (signed short int)return_value_atoi$1;
    lp = cp + (signed long int)1;
    cp=strchr(lp, 10);
    if(!(cp == ((char *)NULL)) && (signed long int)len >= cp - lp)
    {
      unsigned long int return_value_strtoul$2;
      return_value_strtoul$2=strtoul(lp, (char ** restrict )(void *)0, 10);
      face_info.bmaps_checksum = (unsigned int)return_value_strtoul$2;
      lp = cp + (signed long int)1;
      cp=strchr(lp, 10);
      while((signed long int)len >= cp - lp && !(cp == ((char *)NULL)))
      {
        tmp_post$3 = cp;
        cp = cp + 1l;
        *tmp_post$3 = (char)0;
        cps[(signed long int)0]=strtok(lp, ":");
        if(cps[0l] == ((char *)NULL))
          badline = 1;

        i = 1;
        for( ; !(i >= 7); i = i + 1)
        {
          cps[(signed long int)i]=strtok((char *)(void *)0, ":");
          if(cps[(signed long int)i] == ((char *)NULL))
            badline = 1;

        }
        if(!(badline == 0))
          LOG((enum LogLevel)LOG_WARNING, "common::get_image_info", "bad data, ignoring line:/%s/", lp);

        else
        {
          onset=atoi(cps[(signed long int)0]);
          if(onset >= 20)
            LOG((enum LogLevel)LOG_WARNING, "common::get_image_info", "setnum is too high: %d > %d", onset, 20);

          face_info.facesets[(signed long int)onset].prefix=strdup_local(cps[(signed long int)1]);
          face_info.facesets[(signed long int)onset].fullname=strdup_local(cps[(signed long int)2]);
          signed int return_value_atoi$4;
          return_value_atoi$4=atoi(cps[(signed long int)3]);
          face_info.facesets[(signed long int)onset].fallback = (unsigned char)return_value_atoi$4;
          face_info.facesets[(signed long int)onset].size=strdup_local(cps[(signed long int)4]);
          face_info.facesets[(signed long int)onset].extension=strdup_local(cps[(signed long int)5]);
          face_info.facesets[(signed long int)onset].comment=strdup_local(cps[(signed long int)6]);
        }
        lp = cp;
        cp=strchr(lp, 10);
      }
      face_info.have_faceset_info = (unsigned char)1;
      if(!(face_info.want_faceset == ((char *)NULL)))
      {
        return_value_atoi$7=atoi(face_info.want_faceset);
        if(return_value_atoi$7 == 0)
        {
          onset = 0;
          for( ; !(onset >= 20); onset = onset + 1)
          {
            if(!(face_info.facesets[(signed long int)onset].prefix == ((char *)NULL)))
            {
              return_value_strcasecmp$5=strcasecmp(face_info.facesets[(signed long int)onset].prefix, face_info.want_faceset);
              if(return_value_strcasecmp$5 == 0)
                break;

            }

            if(!(face_info.facesets[(signed long int)onset].fullname == ((char *)NULL)))
            {
              return_value_strcasecmp$6=strcasecmp(face_info.facesets[(signed long int)onset].fullname, face_info.want_faceset);
              if(return_value_strcasecmp$6 == 0)
                break;

            }

          }
          if(!(onset >= 20))
          {
            face_info.faceset = (unsigned char)onset;
            cs_print_string(csocket.fd, "setup faceset %d", onset);
          }

          else
          {
            snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Unable to find match for faceset %s on the server", face_info.want_faceset);
            draw_ext_info(3, 20, 1, buf);
          }
        }

      }

    }

  }

}

// get_image_sums
// file ./proto.h line 52
void get_image_sums(char *data, signed int len)
{
  signed int stop;
  signed int imagenum;
  signed int slen;
  signed int faceset;
  unsigned int checksum;
  char *cp;
  char *lp;
  cp=strchr((char *)data, 32);
  const unsigned short int **return_value___ctype_b_loc$1;
  if(!(cp == ((char *)NULL)) && (signed long int)len >= cp - data)
  {
    do
    {
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*cp]) == 0)
        break;

      cp = cp + 1l;
    }
    while((_Bool)1);
    lp = cp;
    cp=strchr(lp, 32);
    if(!(cp == ((char *)NULL)) && (signed long int)len >= cp - data)
    {
      stop=atoi(lp);
      replyinfo_last_face = stop;
      for( ; (signed int)*cp == 32; cp = cp + 1l)
        ;
      while(!(cp - data >= (signed long int)len))
      {
        signed short int return_value_GetShort_String$2;
        return_value_GetShort_String$2=GetShort_String((unsigned char *)cp);
        imagenum = (signed int)return_value_GetShort_String$2;
        cp = cp + (signed long int)2;
        signed int return_value_GetInt_String$3;
        return_value_GetInt_String$3=GetInt_String((unsigned char *)cp);
        checksum = (unsigned int)return_value_GetInt_String$3;
        cp = cp + (signed long int)4;
        faceset = (signed int)*cp;
        cp = cp + 1l;
        slen = (signed int)*cp;
        cp = cp + 1l;
        finish_face_cmd(imagenum, checksum, 1, (char *)cp, faceset);
        if(!(stop >= imagenum))
          LOG((enum LogLevel)LOG_WARNING, "common::get_image_sums", "Received an image beyond our range? %d > %d", imagenum, stop);

        cp = cp + (signed long int)slen;
      }
    }

  }

}

// get_info_width
// file info.c line 1321
extern signed int get_info_width(void)
{
  return 40;
}

// get_item_env
// file inventory.c line 180
static signed int get_item_env(struct item_struct *it)
{
  if(it->env == cpl.ob)
    return 0x1;

  else
    if(it->env == cpl.below)
      return 0x2;

    else
      if(it->env == ((struct item_struct *)NULL))
        return 0;

      else
      {
        signed int return_value_get_item_env$1;
        return_value_get_item_env$1=get_item_env(it->env);
        return 0x4 | return_value_get_item_env$1;
      }
}

// get_key_info
// file keys.c line 987
static char * get_key_info(struct keybind *kb, signed int save_mode)
{
  char buff[256l];
  get_key_modchars(kb, save_mode, buff);
  static char buf[512l];
  if(!(save_mode == 0))
  {
    if((signed long int)kb->keysym == 0L)
      snprintf(buf, sizeof(char [512l]) /*512ul*/ , "(null) %i %s %s", 0, (const void *)buff, kb->command);

    else
    {
      char *return_value_gdk_keyval_name$1;
      return_value_gdk_keyval_name$1=gdk_keyval_name(kb->keysym);
      snprintf(buf, sizeof(char [512l]) /*512ul*/ , "%s %i %s %s", return_value_gdk_keyval_name$1, 0, (const void *)buff, kb->command);
    }
  }

  else
    if((signed long int)kb->keysym == 0L)
      snprintf(buf, sizeof(char [512l]) /*512ul*/ , "key (null) %s %s", (const void *)buff, kb->command);

    else
    {
      char *return_value_gdk_keyval_name$2;
      return_value_gdk_keyval_name$2=gdk_keyval_name(kb->keysym);
      snprintf(buf, sizeof(char [512l]) /*512ul*/ , "key %s %s %s", return_value_gdk_keyval_name$2, (const void *)buff, kb->command);
    }
  return buf;
}

// get_key_modchars
// file keys.c line 949
static void get_key_modchars(struct keybind *kb, signed int save_mode, char *buf)
{
  signed int bi = 0;
  signed int tmp_post$1;
  if(!((16 & (signed int)kb->flags) == 0))
  {
    tmp_post$1 = bi;
    bi = bi + 1;
    buf[(signed long int)tmp_post$1] = (char)65;
  }

  _Bool tmp_if_expr$7;
  if(!(save_mode == 0))
    tmp_if_expr$7 = (_Bool)1;

  else
    tmp_if_expr$7 = !(((signed int)kb->flags & 1 << 4) != 0) ? (_Bool)1 : (_Bool)0;
  signed int tmp_post$2;
  signed int tmp_post$3;
  signed int tmp_post$4;
  signed int tmp_post$5;
  signed int tmp_post$6;
  if(tmp_if_expr$7)
  {
    if((15 & (signed int)kb->flags) == 0)
    {
      tmp_post$2 = bi;
      bi = bi + 1;
      buf[(signed long int)tmp_post$2] = (char)78;
    }

    if(!((1 & (signed int)kb->flags) == 0))
    {
      tmp_post$3 = bi;
      bi = bi + 1;
      buf[(signed long int)tmp_post$3] = (char)70;
    }

    if(!((2 & (signed int)kb->flags) == 0))
    {
      tmp_post$4 = bi;
      bi = bi + 1;
      buf[(signed long int)tmp_post$4] = (char)82;
    }

    if(!((4 & (signed int)kb->flags) == 0))
    {
      tmp_post$5 = bi;
      bi = bi + 1;
      buf[(signed long int)tmp_post$5] = (char)76;
    }

    if(!((8 & (signed int)kb->flags) == 0))
    {
      tmp_post$6 = bi;
      bi = bi + 1;
      buf[(signed long int)tmp_post$6] = (char)77;
    }

  }

  signed int tmp_post$8;
  if(!((32 & (signed int)kb->flags) == 0))
  {
    tmp_post$8 = bi;
    bi = bi + 1;
    buf[(signed long int)tmp_post$8] = (char)69;
  }

  buf[(signed long int)bi] = (char)0;
}

// get_map_image_size
// file image.c line 541
extern void get_map_image_size(signed int face, unsigned char *w, unsigned char *h)
{
  if(face >= 10000 || !(face >= 0))
  {
    *w = (unsigned char)1;
    *h = (unsigned char)1;
  }

  else
  {
    *w = (unsigned char)((((signed int)pixmaps[(signed long int)face]->map_width + map_image_size) - 1) / map_image_size);
    *h = (unsigned char)((((signed int)pixmaps[(signed long int)face]->map_height + map_image_size) - 1) / map_image_size);
  }
}

// get_metaserver
// file gtk2proto.h line 177
extern void get_metaserver(void)
{
  struct _GtkTreeIter iter;
  struct _GtkWidget *widget;
  char file_cache[256l];
  const char *metaserver_txt;
  signed int i;
  signed int j;
  hide_all_login_windows();
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("HOME");
  snprintf(file_cache, (unsigned long int)256, "%s/%s/crossfire/servers.cache", return_value_getenv$1, xdg_cache_dir);
  cached_server_file = file_cache;
  static signed int get_metaserver$$1$$has_init = 0;
  if(get_metaserver$$1$$has_init == 0)
  {
    struct _GtkTreeViewColumn *column;
    struct _GtkCellRenderer *renderer;
    struct _GObject *return_value_gtk_builder_get_object$2;
    return_value_gtk_builder_get_object$2=gtk_builder_get_object(dialog_xml, "metaserver_window");
    unsigned long int return_value_gtk_widget_get_type$3;
    return_value_gtk_widget_get_type$3=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$2, return_value_gtk_widget_get_type$3);
    metaserver_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$4;
    unsigned long int return_value_gtk_window_get_type$5;
    return_value_gtk_window_get_type$5=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)metaserver_window, return_value_gtk_window_get_type$5);
    unsigned long int return_value_gtk_window_get_type$7;
    return_value_gtk_window_get_type$7=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_window_get_type$7);
    gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast$6, (struct _GtkWindow *)return_value_g_type_check_instance_cast$8);
    struct _GObject *return_value_gtk_builder_get_object$9;
    return_value_gtk_builder_get_object$9=gtk_builder_get_object(dialog_xml, "treeview_metaserver");
    unsigned long int return_value_gtk_widget_get_type$10;
    return_value_gtk_widget_get_type$10=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
    return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$9, return_value_gtk_widget_get_type$10);
    treeview_metaserver = (struct _GtkWidget *)return_value_g_type_check_instance_cast$11;
    struct _GObject *return_value_gtk_builder_get_object$12;
    return_value_gtk_builder_get_object$12=gtk_builder_get_object(dialog_xml, "metaserver_select");
    unsigned long int return_value_gtk_widget_get_type$13;
    return_value_gtk_widget_get_type$13=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
    return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$12, return_value_gtk_widget_get_type$13);
    metaserver_button = (struct _GtkWidget *)return_value_g_type_check_instance_cast$14;
    struct _GObject *return_value_gtk_builder_get_object$15;
    return_value_gtk_builder_get_object$15=gtk_builder_get_object(dialog_xml, "metaserver_status");
    unsigned long int return_value_gtk_widget_get_type$16;
    return_value_gtk_widget_get_type$16=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
    return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$15, return_value_gtk_widget_get_type$16);
    metaserver_status = (struct _GtkWidget *)return_value_g_type_check_instance_cast$17;
    struct _GObject *return_value_gtk_builder_get_object$18;
    return_value_gtk_builder_get_object$18=gtk_builder_get_object(dialog_xml, "metaserver_text_entry");
    unsigned long int return_value_gtk_widget_get_type$19;
    return_value_gtk_widget_get_type$19=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
    return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$18, return_value_gtk_widget_get_type$19);
    metaserver_entry = (struct _GtkWidget *)return_value_g_type_check_instance_cast$20;
    g_signal_connect_data((void *)metaserver_window, "destroy", (void (*)(void))on_window_destroy_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)treeview_metaserver, "row_activated", (void (*)(void))on_treeview_metaserver_row_activated, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)metaserver_entry, "activate", (void (*)(void))on_metaserver_text_entry_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)metaserver_entry, "key_press_event", (void (*)(void))on_metaserver_text_entry_key_press_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)metaserver_button, "clicked", (void (*)(void))on_metaserver_select_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    struct _GObject *return_value_gtk_builder_get_object$21;
    return_value_gtk_builder_get_object$21=gtk_builder_get_object(dialog_xml, "button_metaserver_quit");
    unsigned long int return_value_gtk_widget_get_type$22;
    return_value_gtk_widget_get_type$22=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
    return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$21, return_value_gtk_widget_get_type$22);
    widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$23;
    g_signal_connect_data((void *)widget, "pressed", (void (*)(void))on_button_metaserver_quit_pressed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_button_metaserver_quit_pressed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    store_metaserver=gtk_list_store_new(6, (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(6 << 2), (unsigned long int)(6 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2));
    unsigned long int return_value_gtk_tree_view_get_type$24;
    return_value_gtk_tree_view_get_type$24=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
    return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)treeview_metaserver, return_value_gtk_tree_view_get_type$24);
    unsigned long int return_value_gtk_tree_model_get_type$26;
    return_value_gtk_tree_model_get_type$26=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
    return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)store_metaserver, return_value_gtk_tree_model_get_type$26);
    gtk_tree_view_set_model((struct _GtkTreeView *)return_value_g_type_check_instance_cast$25, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$27);
    renderer=gtk_cell_renderer_text_new();
    column=gtk_tree_view_column_new_with_attributes("Hostname", renderer, (const void *)"text", 0, (void *)0);
    gtk_tree_view_column_set_sort_column_id(column, 0);
    unsigned long int return_value_gtk_tree_view_get_type$28;
    return_value_gtk_tree_view_get_type$28=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
    return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)treeview_metaserver, return_value_gtk_tree_view_get_type$28);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$29, column);
    renderer=gtk_cell_renderer_text_new();
    column=gtk_tree_view_column_new_with_attributes("Updated (Sec)", renderer, (const void *)"text", 2, (void *)0);
    gtk_tree_view_column_set_sort_column_id(column, 2);
    unsigned long int return_value_gtk_tree_view_get_type$30;
    return_value_gtk_tree_view_get_type$30=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$31;
    return_value_g_type_check_instance_cast$31=g_type_check_instance_cast((struct _GTypeInstance *)treeview_metaserver, return_value_gtk_tree_view_get_type$30);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$31, column);
    renderer=gtk_cell_renderer_text_new();
    column=gtk_tree_view_column_new_with_attributes("Players", renderer, (const void *)"text", 3, (void *)0);
    gtk_tree_view_column_set_sort_column_id(column, 3);
    unsigned long int return_value_gtk_tree_view_get_type$32;
    return_value_gtk_tree_view_get_type$32=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
    return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)treeview_metaserver, return_value_gtk_tree_view_get_type$32);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$33, column);
    renderer=gtk_cell_renderer_text_new();
    column=gtk_tree_view_column_new_with_attributes("Version", renderer, (const void *)"text", 4, (void *)0);
    gtk_tree_view_column_set_sort_column_id(column, 4);
    unsigned long int return_value_gtk_tree_view_get_type$34;
    return_value_gtk_tree_view_get_type$34=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$35;
    return_value_g_type_check_instance_cast$35=g_type_check_instance_cast((struct _GTypeInstance *)treeview_metaserver, return_value_gtk_tree_view_get_type$34);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$35, column);
    renderer=gtk_cell_renderer_text_new();
    column=gtk_tree_view_column_new_with_attributes("Server Comment", renderer, (const void *)"text", 5, (void *)0);
    unsigned long int return_value_gtk_tree_view_get_type$36;
    return_value_gtk_tree_view_get_type$36=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$37;
    return_value_g_type_check_instance_cast$37=g_type_check_instance_cast((struct _GTypeInstance *)treeview_metaserver, return_value_gtk_tree_view_get_type$36);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$37, column);
    gtk_widget_realize(metaserver_window);
    unsigned long int return_value_gtk_tree_view_get_type$38;
    return_value_gtk_tree_view_get_type$38=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$39;
    return_value_g_type_check_instance_cast$39=g_type_check_instance_cast((struct _GTypeInstance *)treeview_metaserver, return_value_gtk_tree_view_get_type$38);
    metaserver_selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$39);
    gtk_tree_selection_set_mode(metaserver_selection, (enum anonymous$24)GTK_SELECTION_BROWSE);
    gtk_tree_selection_set_select_function(metaserver_selection, metaserver_selection_func, (void *)0, (void (*)(void *))(void *)0);
    get_metaserver$$1$$has_init = 1;
  }

  gtk_widget_show(metaserver_window);
  unsigned long int return_value_gtk_label_get_type$40;
  return_value_gtk_label_get_type$40=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$41;
  return_value_g_type_check_instance_cast$41=g_type_check_instance_cast((struct _GTypeInstance *)metaserver_status, return_value_gtk_label_get_type$40);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$41, "Waiting for data from metaserver");
  unsigned long int return_value_gtk_entry_get_type$42;
  return_value_gtk_entry_get_type$42=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$43;
  return_value_g_type_check_instance_cast$43=g_type_check_instance_cast((struct _GTypeInstance *)metaserver_entry, return_value_gtk_entry_get_type$42);
  metaserver_txt=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$43);
  if((signed int)*metaserver_txt == 0)
    gtk_widget_set_sensitive(metaserver_button, 0);

  else
    gtk_widget_set_sensitive(metaserver_button, (signed int)!(0 != 0));
  gtk_list_store_clear(store_metaserver);
  signed int return_value_metaserver_check_status$44;
  do
  {
    return_value_metaserver_check_status$44=metaserver_check_status();
    if(return_value_metaserver_check_status$44 == 0)
      break;

    usleep((unsigned int)100);
    gtk_main_iteration_do(0);
  }
  while((_Bool)1);
  pthread_mutex_lock(&ms2_info_mutex);
  if(!(cached_servers_num == 0))
  {
    i = 0;
    for( ; !(i >= cached_servers_num); i = i + 1)
    {
      j = 0;
      for( ; !(j >= meta_numservers); j = j + 1)
      {
        signed int return_value_strcmp$45;
        return_value_strcmp$45=strcmp(cached_servers_name[(signed long int)i], (meta_servers + (signed long int)j)->hostname);
        if(return_value_strcmp$45 == 0)
          break;

      }
      if(j == meta_numservers)
      {
        gtk_list_store_append(store_metaserver, &iter);
        gtk_list_store_set(store_metaserver, &iter, 0, cached_servers_name[(signed long int)i], 1, cached_servers_ip[(signed long int)i], 5, (const void *)"Cached server entry", -1);
      }

    }
  }

  qsort((void *)meta_servers, (unsigned long int)meta_numservers, sizeof(struct Meta_Info) /*1928ul*/ , (signed int (*)(const void *, const void *))meta_sort);
  i = 0;
  for( ; !(i >= meta_numservers); i = i + 1)
  {
    signed int return_value_check_server_version$46;
    return_value_check_server_version$46=check_server_version(i);
    if(!(return_value_check_server_version$46 == 0))
    {
      gtk_list_store_append(store_metaserver, &iter);
      gtk_list_store_set(store_metaserver, &iter, 0, (const void *)(meta_servers + (signed long int)i)->hostname, 1, (const void *)(meta_servers + (signed long int)i)->hostname, 2, (meta_servers + (signed long int)i)->idle_time, 3, (meta_servers + (signed long int)i)->num_players, 4, (const void *)(meta_servers + (signed long int)i)->version, 5, (const void *)(meta_servers + (signed long int)i)->text_comment, -1);
    }

  }
  pthread_mutex_unlock(&ms2_info_mutex);
  if(!(server == ((char *)NULL)))
  {
    gtk_list_store_append(store_metaserver, &iter);
    gtk_list_store_set(store_metaserver, &iter, 0, server, 5, (const void *)"default server", -1);
  }

  cpl.input_state = (enum Input_State)Metaserver_Select;
  unsigned long int return_value_gtk_label_get_type$47;
  return_value_gtk_label_get_type$47=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$48;
  return_value_g_type_check_instance_cast$48=g_type_check_instance_cast((struct _GTypeInstance *)metaserver_status, return_value_gtk_label_get_type$47);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$48, "Waiting for user selection");
  gtk_main();
  gtk_widget_hide(metaserver_window);
}

// get_metaserver2_data
// file metaserver.c line 438
static signed int get_metaserver2_data(char *metaserver2)
{
  void *curl;
  enum anonymous$33 res;
  char leftover[16384l];
  curl=curl_easy_init();
  if(curl == NULL)
    return 0;

  else
  {
    leftover[(signed long int)0] = (char)0;
    signed int get_metaserver2_data$$1$$2$$_curl_opt = CURLOPT_URL;
    curl_easy_setopt(curl, (enum anonymous$34)get_metaserver2_data$$1$$2$$_curl_opt, metaserver2);
    signed int _curl_opt = CURLOPT_WRITEFUNCTION;
    curl_easy_setopt(curl, (enum anonymous$34)_curl_opt, metaserver2_writer);
    signed int get_metaserver2_data$$1$$4$$_curl_opt = CURLOPT_WRITEDATA;
    curl_easy_setopt(curl, (enum anonymous$34)get_metaserver2_data$$1$$4$$_curl_opt, (const void *)leftover);
    res=curl_easy_perform(curl);
    curl_easy_cleanup(curl);
    if(!(res == /*enum*/CURLE_OK))
      return 0;

    else
      return 1;
  }
}

// get_new_char_info
// file commands.c line 248
static void get_new_char_info(char *data, signed int len)
{
  signed int olen = 0;
  signed int llen;
  stat_points = 0;
  stat_min = 0;
  stat_maximum = 0;
  signed int return_value_strcasecmp$15;
  signed int return_value_strcasecmp$14;
  signed int return_value_strcasecmp$11;
  _Bool tmp_if_expr$13;
  signed int return_value_strcasecmp$12;
  signed int return_value_strcasecmp$10;
  while(!(olen >= len))
  {
    char datatype;
    char *cp;
    char return_value_GetChar_String$1;
    return_value_GetChar_String$1=GetChar_String((const unsigned char *)(data + (signed long int)olen));
    llen = olen + (signed int)return_value_GetChar_String$1;
    data[(signed long int)llen] = (char)0;
    if(!(len >= llen))
    {
      LOG((enum LogLevel)LOG_WARNING, "common::get_new_char_info", "Length of line is greater than buffer (%d>%d)", llen, len);
      goto __CPROVER_DUMP_L33;
    }

    olen = olen + 1;
    datatype=GetChar_String((const unsigned char *)(data + (signed long int)olen));
    olen = olen + 1;
    while(len >= olen)
    {
      const unsigned short int **return_value___ctype_b_loc$2;
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)data[(signed long int)olen]]) == 0)
        break;

      olen = olen + 1;
    }
    if(!(len >= olen))
    {
      LOG((enum LogLevel)LOG_WARNING, "common::get_new_char_info", "Overran length of buffer (%d>%d)", olen, len);
      goto __CPROVER_DUMP_L33;
    }

    cp = data + (signed long int)olen;
    while(len >= olen)
    {
      const unsigned short int **return_value___ctype_b_loc$3;
      return_value___ctype_b_loc$3=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)data[(signed long int)olen]]) == 0))
        break;

      olen = olen + 1;
    }
    data[(signed long int)olen] = (char)0;
    olen = olen + 1;
    if(!(len >= olen))
    {
      LOG((enum LogLevel)LOG_WARNING, "common::get_new_char_info", "Overran length of buffer (%d>%d)", olen, len);
      goto __CPROVER_DUMP_L33;
    }

    signed int return_value_strcasecmp$16;
    return_value_strcasecmp$16=strcasecmp(cp, "points");
    if(return_value_strcasecmp$16 == 0)
    {
      stat_points=atoi(data + (signed long int)olen);
      olen = llen + 1;
      continue;
    }

    else
    {
      return_value_strcasecmp$15=strcasecmp(cp, "statrange");
      if(return_value_strcasecmp$15 == 0)
      {
        signed int return_value_sscanf$4;
        return_value_sscanf$4=sscanf(data + (signed long int)olen, "%d %d", &stat_min, &stat_maximum);
        if(!(return_value_sscanf$4 == 2))
          LOG((enum LogLevel)LOG_WARNING, "common::get_new_char_info", "Unable to process statrange line (%s)", data + (signed long int)olen);

        olen = llen + 1;
        continue;
      }

      else
      {
        return_value_strcasecmp$14=strcasecmp(cp, "statname");
        if(return_value_strcasecmp$14 == 0)
        {
          signed int i;
          signed int matches = 0;
          while(!(olen >= llen))
          {
            i = 0;
            for( ; !(i >= 7); i = i + 1)
            {
              unsigned long int return_value_strlen$6;
              return_value_strlen$6=strlen(short_stat_name[(signed long int)i]);
              signed int return_value_strncasecmp$7;
              return_value_strncasecmp$7=strncasecmp(data + (signed long int)olen, short_stat_name[(signed long int)i], return_value_strlen$6);
              if(return_value_strncasecmp$7 == 0)
              {
                matches = matches + 1;
                unsigned long int return_value_strlen$5;
                return_value_strlen$5=strlen(short_stat_name[(signed long int)i]);
                olen = olen + (signed int)(return_value_strlen$5 + (unsigned long int)1);
                break;
              }

            }
            if(i == 7)
            {
              LOG((enum LogLevel)LOG_WARNING, "common::get_new_char_info", "Unable to find matching stat name (%s)", data + (signed long int)olen);
              break;
            }

          }
          if(!(matches == 7))
            LOG((enum LogLevel)LOG_WARNING, "common::get_new_char_info", "Did not get correct number of stats (%d!=%d)", matches, 7);

          olen = llen + 1;
          continue;
        }

        else
        {
          return_value_strcasecmp$11=strcasecmp(cp, "race");
          if(return_value_strcasecmp$11 == 0)
            tmp_if_expr$13 = (_Bool)1;

          else
          {
            return_value_strcasecmp$12=strcasecmp(cp, "class");
            tmp_if_expr$13 = !(return_value_strcasecmp$12 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$13)
          {
            signed int return_value_strcasecmp$8;
            return_value_strcasecmp$8=strcasecmp(data + (signed long int)olen, "requestinfo");
            if(!(return_value_strcasecmp$8 == 0))
              LOG((enum LogLevel)LOG_WARNING, "common::get_new_char_info", "Got unexpected value for %s: %s", cp, data + (signed long int)olen);

            olen = llen + 1;
            continue;
          }

          else
          {
            return_value_strcasecmp$10=strcasecmp(cp, "startingmap");
            if(return_value_strcasecmp$10 == 0)
            {
              signed int return_value_strcasecmp$9;
              return_value_strcasecmp$9=strcasecmp(data + (signed long int)olen, "requestinfo");
              if(!(return_value_strcasecmp$9 == 0))
                LOG((enum LogLevel)LOG_WARNING, "common::get_new_char_info", "Got unexpected value for %s: %s", cp, data + (signed long int)olen);

              else
              {
                cs_print_string(csocket.fd, "requestinfo startingmap");
                free_all_starting_map_info();
              }
              olen = llen + 1;
              continue;
            }

            else
            {
              if((signed int)datatype == 82 || (signed int)datatype == 86)
                LOG((enum LogLevel)LOG_WARNING, "common::get_new_char_info", "Got unsupported string from server, type %c, value %s", datatype, cp);

              olen = llen + 1;
            }
          }
        }
      }
    }
  }
  if(stat_maximum == 0 || stat_min == 0 || stat_points == 0)
    LOG((enum LogLevel)LOG_ERROR, "common::get_new_char_info", "Processed all newcharinfo yet have 0 value: stat_min=%d, stat_maximum=%d, stat_points=%d", stat_min, stat_maximum, stat_points);

  else
    new_char_window_update_info();

__CPROVER_DUMP_L33:
  ;
}

// get_num_commands
// file p_cmd.c line 901
extern signed int get_num_commands(void)
{
  return num_commands;
}

// get_number
// file item.c line 190
const char * get_number(unsigned int i)
{
  static const char numbers[21l][20l] = { { 'n', 'o', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 'a', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 't', 'w', 'o', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 't', 'h', 'r', 'e', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 'f', 'o', 'u', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 'f', 'i', 'v', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 's', 'i', 'x', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 's', 'e', 'v', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 'e', 'i', 'g', 'h', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 'n', 'i', 'n', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 't', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 'e', 'l', 'e', 'v', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 't', 'w', 'e', 'l', 'v', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 't', 'h', 'i', 'r', 't', 'e', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 'f', 'o', 'u', 'r', 't', 'e', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 'f', 'i', 'f', 't', 'e', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 's', 'i', 'x', 't', 'e', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 's', 'e', 'v', 'e', 'n', 't', 'e', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 'e', 'i', 'g', 'h', 't', 'e', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 'n', 'i', 'n', 'e', 't', 'e', 'e', 'n', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 
    { 't', 'w', 'e', 'n', 't', 'y', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } };
  if(!(i >= 21u))
    return numbers[(signed long int)i];

  else
  {
    static char buf[256l];
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%u", i);
    return buf;
  }
}

// get_race_info
// file commands.c line 645
static void get_race_info(char *data, signed int len)
{
  if(used_races >= num_races)
    LOG((enum LogLevel)LOG_ERROR, "common::get_race_info", "used races exceed num races, %d>=%d", used_races, num_races);

  else
  {
    process_race_class_info(data, len, &races[(signed long int)used_races]);
    used_races = used_races + 1;
    if(used_races == num_races)
    {
      qsort((void *)races, (unsigned long int)used_races, sizeof(struct Race_Class_Info) /*48ul*/ , (signed int (*)(const void *, const void *))rc_compar);
      new_char_window_update_info();
    }

  }
}

// get_row_style
// file inventory.c line 656
static struct _GtkStyle * get_row_style(struct item_struct *it)
{
  signed int style;
  _Bool tmp_if_expr$1;
  if(!(it->unpaid == 0))
    style = 2;

  else
  {
    if(!(it->cursed == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = it->damned != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      style = 1;

    else
      if(!(it->magical == 0))
        style = 0;

      else
        if(!(it->applied == 0))
          style = 4;

        else
          if(!(it->locked == 0))
            style = 3;

          else
            return (struct _GtkStyle *)(void *)0;
  }
  return inv_styles[(signed long int)style];
}

// get_skill_info
// file commands.c line 733
static void get_skill_info(char *data, signed int len)
{
  char *cp;
  char *nl;
  char *sn;
  signed int val;
  cp = data;
  do
  {
    nl=strchr(cp, 10);
    if(!(nl == ((char *)NULL)))
    {
      *nl = (char)0;
      nl = nl + 1l;
    }

    sn=strchr(cp, 58);
    if(sn == ((char *)NULL))
    {
      LOG((enum LogLevel)LOG_WARNING, "common::get_skill_info", "corrupt line: /%s/", cp);
      goto __CPROVER_DUMP_L5;
    }

    *sn = (char)0;
    sn = sn + 1l;
    val=atoi(cp);
    val = val - 140;
    if(val >= 50 || !(val >= 0))
    {
      LOG((enum LogLevel)LOG_WARNING, "common::get_skill_info", "invalid skill number %d", val);
      goto __CPROVER_DUMP_L5;
    }

    free((void *)skill_names[(signed long int)val]);
    skill_names[(signed long int)val]=strdup_local(sn);
    cp = nl;
  }
  while(!(cp >= data + (signed long int)len));

__CPROVER_DUMP_L5:
  ;
}

// get_starting_map_info
// file commands.c line 172
static void get_starting_map_info(char *data, signed int len)
{
  signed int pos;
  signed int type;
  signed int length;
  signed int map_entry = -1;
  char *cp;
  pos = 0;
  while(!(pos >= len))
  {
    type = (signed int)data[(signed long int)pos];
    pos = pos + 1;
    signed short int return_value_GetShort_String$1;
    return_value_GetShort_String$1=GetShort_String((const unsigned char *)(data + (signed long int)pos));
    length = (signed int)return_value_GetShort_String$1;
    pos = pos + 2;
    if(!(len >= length + pos))
    {
      LOG((enum LogLevel)LOG_WARNING, "common::get_starting_map_info", "Length of data is greater than buffer (%d>%d)", length + pos, len);
      goto __CPROVER_DUMP_L9;
    }

    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)(length + 1));
    cp = (char *)return_value_malloc$2;
    strncpy(cp, data + (signed long int)pos, (unsigned long int)length);
    cp[(signed long int)length] = (char)0;
    pos = pos + length;
    if(type == 1)
    {
      map_entry = map_entry + 1;
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)starting_map_info, (unsigned long int)(map_entry + 1) * sizeof(struct Starting_Map_Info) /*24ul*/ );
      starting_map_info = (struct Starting_Map_Info *)return_value_realloc$3;
      if(starting_map_info == ((struct Starting_Map_Info *)NULL))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        char *return_value_strerror$5;
        return_value_strerror$5=strerror(*return_value___errno_location$4);
        LOG((enum LogLevel)LOG_ERROR, "get_starting_map_info", "Could not allocate memory: %s", return_value_strerror$5);
        exit(1);
      }

      memset((void *)&starting_map_info[(signed long int)map_entry], 0, sizeof(struct Starting_Map_Info) /*24ul*/ );
      (starting_map_info + (signed long int)map_entry)->arch_name = cp;
    }

    else
      if(type == 2)
        (starting_map_info + (signed long int)map_entry)->public_name = cp;

      else
        if(type == 3)
          (starting_map_info + (signed long int)map_entry)->description = cp;

        else
          LOG((enum LogLevel)LOG_WARNING, "common::get_starting_map_info", "Unknown type: %d\n", type);
  }
  starting_map_number = map_entry;
  starting_map_update_info();

__CPROVER_DUMP_L9:
  ;
}

// get_type_from_name
// file item.c line 42
unsigned char get_type_from_name(const char *name)
{
  signed int type;
  signed int pos;
  type = 0;
  char *return_value_strstr$3;
  for( ; !(type >= 256); type = type + 1)
  {
    pos = 0;
    while(!(item_types[(signed long int)type][(signed long int)pos] == ((const char *)NULL)))
    {
      if((signed int)*item_types[(signed long int)type][(signed long int)pos] == 94)
      {
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(item_types[(signed long int)type][(signed long int)pos] + (signed long int)1);
        signed int return_value_strncasecmp$2;
        return_value_strncasecmp$2=strncasecmp(name, item_types[(signed long int)type][(signed long int)pos] + (signed long int)1, return_value_strlen$1);
        if(return_value_strncasecmp$2 == 0)
          return (unsigned char)type;

      }

      else
      {
        return_value_strstr$3=strstr(name, item_types[(signed long int)type][(signed long int)pos]);
        if(!(return_value_strstr$3 == ((char *)NULL)))
          return (unsigned char)type;

      }
      pos = pos + 1;
    }
  }
  LOG((enum LogLevel)LOG_WARNING, "common::get_type_from_name", "Could not find match for %s", name);
  return (unsigned char)255;
}

// get_window_coord
// file gtk2proto.h line 151
extern void get_window_coord(struct _GtkWidget *win, signed int *x, signed int *y, signed int *wx, signed int *wy, signed int *w, signed int *h)
{
  gdk_window_get_geometry(win->window, x, y, w, h, (signed int *)(void *)0);
  gdk_window_get_origin(win->window, wx, wy);
  *wx = *wx - *x;
  *wy = *wy - *y;
}

// gtk_command_history
// file keys.c line 1767
extern void gtk_command_history(signed int direction)
{
  signed int i = scroll_history_position;
  if(!(direction == 0))
  {
    i = i - 1;
    if(!(i >= 0))
      i = i + 50;

    if(i == cur_history_position)
      goto __CPROVER_DUMP_L7;

  }

  else
  {
    i = i + 1;
    if(i >= 50)
      i = 0;

    if(i == cur_history_position)
    {
      unsigned long int return_value_gtk_entry_get_type$1;
      return_value_gtk_entry_get_type$1=gtk_entry_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_entry_get_type$1);
      gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2, "");
      unsigned long int return_value_gtk_entry_get_type$3;
      return_value_gtk_entry_get_type$3=gtk_entry_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_entry_get_type$3);
      gtk_entry_set_position((struct _GtkEntry *)return_value_g_type_check_instance_cast$4, 0);
      scroll_history_position = cur_history_position;
      goto __CPROVER_DUMP_L7;
    }

  }
  if(!((signed int)history[(signed long int)i][0l] == 0))
  {
    scroll_history_position = i;
    unsigned long int return_value_gtk_entry_get_type$5;
    return_value_gtk_entry_get_type$5=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_entry_get_type$5);
    gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$6, history[(signed long int)i]);
    unsigned long int return_value_gtk_widget_get_type$7;
    return_value_gtk_widget_get_type$7=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_widget_get_type$7);
    gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$8);
    unsigned long int return_value_gtk_editable_get_type$9;
    return_value_gtk_editable_get_type$9=gtk_editable_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_editable_get_type$9);
    gtk_editable_select_region((struct _GtkEditable *)return_value_g_type_check_instance_cast$10, 0, 0);
    unsigned long int return_value_gtk_editable_get_type$11;
    return_value_gtk_editable_get_type$11=gtk_editable_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_editable_get_type$11);
    gtk_editable_set_position((struct _GtkEditable *)return_value_g_type_check_instance_cast$12, -1);
    cpl.input_state = (enum Input_State)Command_Mode;
  }


__CPROVER_DUMP_L7:
  ;
}

// gtk_complete_command
// file keys.c line 1814
extern void gtk_complete_command(void)
{
  const char *entry_text;
  const char *newcommand;
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_entry_get_type$1);
  entry_text=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  newcommand=complete_command(entry_text);
  if(!(newcommand == ((const char *)NULL)))
  {
    unsigned long int return_value_gtk_entry_get_type$3;
    return_value_gtk_entry_get_type$3=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_entry_get_type$3);
    gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4, newcommand);
    unsigned long int return_value_gtk_widget_get_type$5;
    return_value_gtk_widget_get_type$5=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_widget_get_type$5);
    gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$6);
    unsigned long int return_value_gtk_editable_get_type$7;
    return_value_gtk_editable_get_type$7=gtk_editable_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_editable_get_type$7);
    gtk_editable_select_region((struct _GtkEditable *)return_value_g_type_check_instance_cast$8, 0, 0);
    unsigned long int return_value_gtk_editable_get_type$9;
    return_value_gtk_editable_get_type$9=gtk_editable_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_editable_get_type$9);
    gtk_editable_set_position((struct _GtkEditable *)return_value_g_type_check_instance_cast$10, -1);
  }

}

// gtk_draw_map
// file map.c line 501
extern void gtk_draw_map(signed int redraw)
{
  signed int mx;
  signed int my;
  signed int x;
  signed int y;
  struct timeval tv1;
  struct timeval tv2;
  struct timeval tv3;
  signed long int elapsed1;
  signed long int elapsed2;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(!(redraw == 0) || !(map_updated == 0))
  {
    if(!(time_map_redraw == 0))
      gettimeofday(&tv1, (struct timezone *)(void *)0);

    x = 0;
    for( ; !(x >= (signed int)use_config[19l]); x = x + 1)
    {
      y = 0;
      for( ; !(y >= (signed int)use_config[20l]); y = y + 1)
      {
        mx = pl_pos.x + x;
        my = pl_pos.y + y;
        if(!(redraw == 0))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (the_map.cells[(signed long int)mx] + (signed long int)my)->need_update != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = (the_map.cells[(signed long int)mx] + (signed long int)my)->need_resmooth != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
        {
          display_mapcell(x, y, mx, my);
          (the_map.cells[(signed long int)mx] + (signed long int)my)->need_update = (unsigned char)0;
          (the_map.cells[(signed long int)mx] + (signed long int)my)->need_resmooth = (unsigned char)0;
        }

      }
    }
    if(!(time_map_redraw == 0))
      gettimeofday(&tv2, (struct timezone *)(void *)0);

    if(!(time_map_redraw == 0))
    {
      gettimeofday(&tv3, (struct timezone *)(void *)0);
      elapsed1 = (tv2.tv_sec - tv1.tv_sec) * (signed long int)1000000 + (tv2.tv_usec - tv1.tv_usec);
      elapsed2 = (tv3.tv_sec - tv2.tv_sec) * (signed long int)1000000 + (tv3.tv_usec - tv2.tv_usec);
      if(elapsed1 + elapsed2 >= 10001l)
        LOG((enum LogLevel)LOG_INFO, "gtk-v2::sdl_gen_map", "gen took %7ld, flip took %7ld, total = %7ld", elapsed1, elapsed2, elapsed1 + elapsed2);

    }

  }

}

// handle_local_command
// file p_cmd.c line 1053
extern signed int handle_local_command(const char *cp, const char *cpnext)
{
  const struct anonymous$47 *cc = (const struct anonymous$47 *)(void *)0;
  cc=find_command(cp);
  if(cc == ((const struct anonymous$47 *)NULL))
    return 0;

  else
  {
    if(cc->dofunc == ((void (*)(const char *))NULL))
    {
      char buf[256l];
      snprintf(buf, (unsigned long int)(256 - 1), "Client command %s has no implementation!", cc->name);
      draw_ext_info(3, 20, 6, buf);
      return 0;
    }

    cc->dofunc(cpnext);
    return 1;
  }
}

// handle_query
// file ./proto.h line 20
void handle_query(char *data, signed int len)
{
  char *buf;
  char *cp;
  unsigned char flags;
  signed int return_value_atoi$1;
  return_value_atoi$1=atoi(data);
  flags = (unsigned char)return_value_atoi$1;
  (void)len;
  if(!((0x4 & (signed int)flags) == 0))
    cpl.no_echo = (unsigned int)1;

  else
    cpl.no_echo = (unsigned int)0;
  x_set_echo();
  buf=strchr(data, 32);
  if(!(buf == ((char *)NULL)))
    buf = buf + 1l;

  char *tmp_post$2;
  if(!(buf == ((char *)NULL)))
  {
    cp = buf;
    do
    {
      buf=strchr(buf, 10);
      if(buf == ((char *)NULL))
        break;

      tmp_post$2 = buf;
      buf = buf + 1l;
      *tmp_post$2 = (char)0;
      draw_ext_info(0, 20, 4, cp);
      cp = buf;
    }
    while((_Bool)1);
    if(!((0x2 & (signed int)flags) == 0))
      cpl.input_state = (enum Input_State)Reply_One;

    else
      cpl.input_state = (enum Input_State)Reply_Many;
    if(!(cp == ((char *)NULL)))
      draw_prompt(cp);

  }

  LOG((enum LogLevel)LOG_DEBUG, "common::handle_query", "Received query.  Input state now %d", cpl.input_state);
}

// help_bind
// file p_cmd.c line 531
static const char * help_bind(void)
{
  return "Syntax:\n bind [[-nframeg] <command>]\n\nFlags (default -nrfam):\n n - used in normal-mode\n f - used in fire-mode\n r - used in run-mode\n a - used with alt key\n m - used with meta key\n e - leave command in line edit\n g - global key (not recommended)\nEach client may not support every flag.\n\nbind without flags/command gets client help.\n\nSpecial 'commands':\n bind commandkey - sets commandkey\n bind firekey1 - sets first firekey\n bind firekey2 - sets second firekey\n bind runkey1 - sets first runkey\n bind runkey2 - sets second runkey\n bind prevkey - sets history-previous key\n bind nextkey - sets history-next key\n bind completekey - sets complete-command key\n\nExamples:\nbind -f cast paralyzed (F3)\n  will typically mean that Shift-F3\n  is used to select that spell (Shift\n  being the fire key)\n\nbind -e shout  (\")\n  will put the cursor in the command\n  box after writing 'shout' when you\n  press double-quote. So you can shout\n  to your friends easier. ;)\n";
}

// help_clienthelp
// file p_cmd.c line 212
static const char * help_clienthelp(void)
{
  return "Syntax:\n\n    clienthelp\n    clienthelp <command>\n\nWithout any arguments, displays a list of client-side commands.\n\nWith arguments, displays the help for the client-side command <command>.\n\nSee also: serverhelp, help.";
}

// help_cwindow
// file p_cmd.c line 563
static const char * help_cwindow(void)
{
  return "Syntax:\n\n    cwindow <val>\n\nset size of commandwindow (if val is exceededclient won't send newcommands to server\n\n(What does this mean, 'put a lid on it'?) TODO";
}

// help_help
// file p_cmd.c line 297
static const char * help_help(void)
{
  return "Syntax:\n\n    help\n    help <topic>\n\nWithout any arguments, displays a list of client-side commands, and fetches the without-arguments help from the server.\n\nWith arguments, first checks if there's a client command named <topic>. If there is, display it's help. If there isn't, send the topic to the server.\n\nSee also: clienthelp, serverhelp.";
}

// help_inv
// file p_cmd.c line 555
static const char * help_inv(void)
{
  return "Syntax:\n inv\nDebug info about inventory.";
}

// help_magicmap
// file p_cmd.c line 547
static const char * help_magicmap(void)
{
  return "Syntax:\n magicmap\nDisplays last shown magic map.";
}

// help_metaserver
// file p_cmd.c line 618
static const char * help_metaserver(void)
{
  return "Syntax:\n\n    metaserver\n\nGet updated list of servers from the metaserver and show it.This is the same information that the client uses to show a list of servers when it starts.\n\nWarning: This command may freeze the client until it gets the list.";
}

// help_savewinpos
// file p_cmd.c line 605
static const char * help_savewinpos(void)
{
  return "Syntax:\n\n    savewinpos\n\nsave window positions - split windows mode only.";
}

// help_script
// file p_cmd.c line 580
static const char * help_script(void)
{
  return "Syntax: script <path>\n\nStart an executable client script located at <path>. For details on client-side scripting, please see the Crossfire Wiki.";
}

// help_scriptkill
// file p_cmd.c line 639
static const char * help_scriptkill(void)
{
  return "Syntax:\n\n    scriptkill <name>\n\nStop scripts named <name>.\n(Not guaranteed to work?)";
}

// help_scripttell
// file p_cmd.c line 590
static const char * help_scripttell(void)
{
  return "Syntax:\n\n    scripttell <yourname> <data>\n\n?";
}

// help_serverhelp
// file p_cmd.c line 249
static const char * help_serverhelp(void)
{
  return "Syntax:\n\n    serverhelp\n    serverhelp <command>\n\nFetches help from the server.\n\nNote that currently nothing can be done (without a recompile) if a client command masks a server command.\n\nSee also: clienthelp, help.";
}

// help_showweight
// file p_cmd.c line 653
static const char * help_showweight(void)
{
  return "Syntax:\n\n    showweight\n    showweight inventory\n    showweight look\n\n(Or any prefix of the arguments.)Toggles if you see the weight ofitems in your inventory (also ifno argument given) or yourlook-window.";
}

// help_unbind
// file p_cmd.c line 539
static const char * help_unbind(void)
{
  return "Syntax:\n unbind [-g] [#]\n unbind reset\nWithout -g command uses user's bindind,\nwith -g global binding.\nWithout number it displays current bindings,\nwith # it unbinds it.\n'reset' resets default bindings.";
}

// hide_all_login_windows
// file account.c line 103
extern void hide_all_login_windows(void)
{
  if(!(has_init == 0))
  {
    gtk_widget_hide(login_window);
    gtk_widget_hide(add_character_window);
    gtk_widget_hide(choose_char_window);
    gtk_widget_hide(create_account_window);
    gtk_widget_hide(new_character_window);
    gtk_widget_hide(account_password_window);
    create_character_window_hide();
    unsigned long int return_value_gtk_widget_get_type$1;
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)treeview_look, return_value_gtk_widget_get_type$1);
    gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
  }

}

// image_add_hash
// file image.c line 298
static struct Cache_Entry * image_add_hash(char *imagename, char *filename, unsigned int checksum, unsigned int ispublic)
{
  struct Cache_Entry *new_entry;
  unsigned int hash;
  hash=image_hash_name(imagename, 8192);
  unsigned int newhash = hash;
  signed int return_value_strcmp$1;
  while(!(image_cache[(signed long int)newhash].image_name == ((char *)NULL)))
  {
    return_value_strcmp$1=strcmp(image_cache[(signed long int)newhash].image_name, imagename);
    if(return_value_strcmp$1 == 0)
      break;

    newhash = newhash + 1u;
    if(newhash == 8192u)
      newhash = (unsigned int)0;

    if(newhash == hash)
    {
      LOG((enum LogLevel)LOG_WARNING, "common::image_find_hash", "Hash table is full, increase IMAGE_CACHE size");
      return (struct Cache_Entry *)(void *)0;
    }

  }
  if(image_cache[(signed long int)newhash].image_name == ((char *)NULL))
    image_cache[(signed long int)newhash].image_name=strdup(imagename);

  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct Cache_Entry) /*32ul*/ );
  new_entry = (struct Cache_Entry *)return_value_malloc$2;
  new_entry->filename=strdup(filename);
  new_entry->checksum = checksum;
  new_entry->ispublic = ispublic;
  new_entry->image_data = (void *)0;
  new_entry->next = image_cache[(signed long int)newhash].cache_entry;
  image_cache[(signed long int)newhash].cache_entry = new_entry;
  return new_entry;
}

// image_find_cache_entry
// file image.c line 274
static struct Cache_Entry * image_find_cache_entry(char *imagename, unsigned int checksum, signed int has_sum)
{
  signed int hash_entry;
  struct Cache_Entry *entry;
  hash_entry=image_find_hash(imagename);
  if(hash_entry == -1)
    return (struct Cache_Entry *)(void *)0;

  else
  {
    entry = image_cache[(signed long int)hash_entry].cache_entry;
    if(!(has_sum == 0))
      for( ; !(entry == ((struct Cache_Entry *)NULL)); entry = entry->next)
        if(entry->checksum == checksum)
          break;


    return entry;
  }
}

// image_find_hash
// file image.c line 210
static signed int image_find_hash(char *str)
{
  unsigned int hash;
  hash=image_hash_name(str, 8192);
  unsigned int newhash = hash;
  while((_Bool)1)
  {
    if(image_cache[(signed long int)newhash].image_name == ((char *)NULL))
      return -1;

    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(image_cache[(signed long int)newhash].image_name, str);
    if(return_value_strcmp$1 == 0)
      return (signed int)newhash;

    newhash = newhash + 1u;
    if(newhash == 8192u)
      newhash = (unsigned int)0;

    if(newhash == hash)
      break;

  }
  LOG((enum LogLevel)LOG_WARNING, "common::image_find_hash", "Hash table is full, increase IMAGE_CACHE size");
  return -1;
}

// image_hash_name
// file image.c line 190
static unsigned int image_hash_name(char *str, signed int tablesize)
{
  unsigned int hash = (unsigned int)0;
  char *p = str;
  _Bool tmp_if_expr$1;
  do
  {
    if(!((signed int)*p == 0))
      tmp_if_expr$1 = (signed int)*p != 46 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    hash = hash + (unsigned int)*p;
    hash = hash + (hash << 10);
    hash = hash ^ hash >> 6;
    p = p + 1l;
  }
  while((_Bool)1);
  hash = hash + (hash << 3);
  hash = hash ^ hash >> 11;
  hash = hash + (hash << 15);
  return hash % (unsigned int)tablesize;
}

// image_process_line
// file image.c line 342
static void image_process_line(char *line, unsigned int ispublic)
{
  char imagename[256l];
  char filename[256l];
  unsigned int checksum;
  if(!((signed int)*line == 35))
  {
    signed int return_value_sscanf$1;
    return_value_sscanf$1=sscanf(line, "%s %u %s", (const void *)imagename, &checksum, (const void *)filename);
    if(return_value_sscanf$1 == 3)
      image_add_hash(imagename, filename, checksum, ispublic);

    else
      LOG((enum LogLevel)LOG_WARNING, "common::image_process_line", "Did not parse line %s properly?", line);
  }

}

// image_remove_hash
// file image.c line 239
static void image_remove_hash(char *imagename, struct Cache_Entry *ce)
{
  signed int hash_entry;
  struct Cache_Entry *last;
  hash_entry=image_find_hash(imagename);
  if(hash_entry == -1)
    LOG((enum LogLevel)LOG_ERROR, "common::image_remove_hash", "Unable to find cache entry for %s, %s", imagename, ce->filename);

  else
    if(image_cache[(signed long int)hash_entry].cache_entry == ce)
    {
      image_cache[(signed long int)hash_entry].cache_entry = ce->next;
      free((void *)ce->filename);
      free((void *)ce);
    }

    else
    {
      last = image_cache[(signed long int)hash_entry].cache_entry;
      for( ; !(last->next == ((struct Cache_Entry *)NULL)); last = last->next)
        if(last->next == ce)
          break;

      if(last->next == ((struct Cache_Entry *)NULL))
        LOG((enum LogLevel)LOG_ERROR, "common::image_rmove_hash", "Unable to find cache entry for %s, %s", imagename, ce->filename);

      else
      {
        last->next = ce->next;
        free((void *)ce->filename);
        free((void *)ce);
      }
    }
}

// image_update_download_status
// file image.c line 494
extern void image_update_download_status(signed int start, signed int end, signed int total)
{
  signed int x;
  signed int y;
  signed int wx;
  signed int wy;
  signed int w;
  signed int h;
  if(start == 1)
  {
    struct _GtkObject *return_value_gtk_adjustment_new$1;
    return_value_gtk_adjustment_new$1=gtk_adjustment_new((double)0, (double)1, (double)total, (double)0, (double)0, (double)0);
    padj = (struct _GtkAdjustment *)return_value_gtk_adjustment_new$1;
    pbar=gtk_progress_bar_new_with_adjustment(padj);
    unsigned long int return_value_gtk_progress_get_type$2;
    return_value_gtk_progress_get_type$2=gtk_progress_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)pbar, return_value_gtk_progress_get_type$2);
    gtk_progress_set_format_string((struct _GtkProgress *)return_value_g_type_check_instance_cast$3, "Downloading image %v of %u (%p%% complete)");
    unsigned long int return_value_gtk_progress_bar_get_type$4;
    return_value_gtk_progress_bar_get_type$4=gtk_progress_bar_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)pbar, return_value_gtk_progress_bar_get_type$4);
    gtk_progress_bar_set_bar_style((struct _GtkProgressBar *)return_value_g_type_check_instance_cast$5, (enum anonymous$69)GTK_PROGRESS_CONTINUOUS);
    unsigned long int return_value_gtk_progress_get_type$6;
    return_value_gtk_progress_get_type$6=gtk_progress_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)pbar, return_value_gtk_progress_get_type$6);
    gtk_progress_set_show_text((struct _GtkProgress *)return_value_g_type_check_instance_cast$7, (signed int)!(0 != 0));
    get_window_coord(window_root, &x, &y, &wx, &wy, &w, &h);
    pbar_window=gtk_window_new((enum anonymous$67)GTK_WINDOW_POPUP);
    unsigned long int return_value_gtk_window_get_type$8;
    return_value_gtk_window_get_type$8=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)pbar_window, return_value_gtk_window_get_type$8);
    gtk_window_set_policy((struct _GtkWindow *)return_value_g_type_check_instance_cast$9, (signed int)!(0 != 0), (signed int)!(0 != 0), 0);
    unsigned long int return_value_gtk_window_get_type$10;
    return_value_gtk_window_get_type$10=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
    return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)pbar_window, return_value_gtk_window_get_type$10);
    unsigned long int return_value_gtk_window_get_type$12;
    return_value_gtk_window_get_type$12=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_window_get_type$12);
    gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast$11, (struct _GtkWindow *)return_value_g_type_check_instance_cast$13);
    gtk_widget_set_uposition(pbar_window, (wx + w) / 2, (wy + h) / 2);
    unsigned long int return_value_gtk_container_get_type$14;
    return_value_gtk_container_get_type$14=gtk_container_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)pbar_window, return_value_gtk_container_get_type$14);
    gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$15, pbar);
    gtk_widget_show(pbar);
    gtk_widget_show(pbar_window);
  }

  signed int return_value_gtk_events_pending$18;
  if(start == total)
  {
    gtk_widget_destroy(pbar_window);
    pbar = (struct _GtkWidget *)(void *)0;
    pbar_window = (struct _GtkWidget *)(void *)0;
    padj = (struct _GtkAdjustment *)(void *)0;
  }

  else
  {
    unsigned long int return_value_gtk_progress_get_type$16;
    return_value_gtk_progress_get_type$16=gtk_progress_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
    return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)pbar, return_value_gtk_progress_get_type$16);
    gtk_progress_set_value((struct _GtkProgress *)return_value_g_type_check_instance_cast$17, (double)start);
    do
    {
      return_value_gtk_events_pending$18=gtk_events_pending();
      if(return_value_gtk_events_pending$18 == 0)
        break;

      gtk_main_iteration();
    }
    while((_Bool)1);
  }
}

// info_buffer_flush
// file info.c line 1003
extern void info_buffer_flush(const signed int id)
{
  char output_buffer[72l];
  if(info_buffer[(signed long int)id].count >= 1)
  {
    if(info_buffer[(signed long int)id].count >= 2)
    {
      snprintf(output_buffer, sizeof(char [72l]) /*72ul*/ , "%u times %s", info_buffer[(signed long int)id].count, (const void *)info_buffer[(signed long int)id].message);
      draw_ext_info(info_buffer[(signed long int)id].orig_color, info_buffer[(signed long int)id].type, info_buffer[(signed long int)id].subtype, output_buffer);
    }

    else
      draw_ext_info(info_buffer[(signed long int)id].orig_color, info_buffer[(signed long int)id].type, info_buffer[(signed long int)id].subtype, info_buffer[(signed long int)id].message);
  }

  info_buffer[(signed long int)id].count = -1;
}

// info_buffer_init
// file info.c line 976
extern void info_buffer_init(void)
{
  signed int loop = 0;
  for( ; !(loop >= 10); loop = loop + 1)
  {
    info_buffer[(signed long int)loop].count = -1;
    info_buffer[(signed long int)loop].age = 0;
    info_buffer[(signed long int)loop].type = 0;
    info_buffer[(signed long int)loop].subtype = 0;
    info_buffer[(signed long int)loop].orig_color = 0;
    info_buffer[(signed long int)loop].message[(signed long int)0] = (char)0;
  }
}

// info_buffer_tick
// file info.c line 1052
extern void info_buffer_tick(void)
{
  signed int loop = 0;
  _Bool tmp_if_expr$1;
  for( ; !(loop >= 10); loop = loop + 1)
    if(info_buffer[(signed long int)loop].count >= 0)
    {
      if(!(info_buffer[(signed long int)loop].age >= (signed int)buffer_control.timer.state))
        tmp_if_expr$1 = info_buffer[(signed long int)loop].count < (signed int)buffer_control.count.state ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        info_buffer[(signed long int)loop].age = info_buffer[(signed long int)loop].age + 1;

      else
        info_buffer_flush(loop);
    }

    else
      if(!(info_buffer[(signed long int)loop].age >= 1 + info_buffer[(signed long int)loop].age))
        info_buffer[(signed long int)loop].age = info_buffer[(signed long int)loop].age + 1;

}

// info_get_styles
// file gtk2proto.h line 67
extern void info_get_styles(void)
{
  unsigned int i;
  unsigned int j;
  struct _GtkStyle *tmp_style;
  struct _GtkStyle *base_style[2l];
  char style_name[256l];
  static signed int info_get_styles$$1$$has_init = 0;
  if(info_get_styles$$1$$has_init == 0)
  {
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 184ul); i = i + 1u)
      if(!(max_subtype >= msg_type_names[(signed long int)i].subtype))
        max_subtype = msg_type_names[(signed long int)i].subtype;

    j = (unsigned int)0;
    for( ; !(j >= 2u); j = j + 1u)
      add_tags_to_textbuffer(&info_pane[(signed long int)j], (struct _GtkTextBuffer *)(void *)0);
    info_get_styles$$1$$has_init = 1;
  }

  i = (unsigned int)0;
  for( ; !(i >= 2u); i = i + 1u)
  {
    struct _GtkSettings *return_value_gtk_settings_get_default$1;
    return_value_gtk_settings_get_default$1=gtk_settings_get_default();
    base_style[(signed long int)i]=gtk_rc_get_style_by_paths(return_value_gtk_settings_get_default$1, (const char *)(void *)0, "info_default", (unsigned long int)(1 << 2));
  }
  if(base_style[0l] == ((struct _GtkStyle *)NULL))
    LOG((enum LogLevel)LOG_INFO, "info.c::info_get_styles", "Unable to find base style info_default - will not process most info tag styles!");

  has_style = 0;
  if(!(base_style[0l] == ((struct _GtkStyle *)NULL)))
  {
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 184ul); i = i + 1u)
    {
      signed int info_get_styles$$1$$4$$1$$1$$type;
      signed int info_get_styles$$1$$4$$1$$1$$subtype;
      snprintf(style_name, sizeof(char [256l]) /*256ul*/ , "msg_%s", msg_type_names[(signed long int)i].style_name);
      info_get_styles$$1$$4$$1$$1$$type = msg_type_names[(signed long int)i].type;
      info_get_styles$$1$$4$$1$$1$$subtype = msg_type_names[(signed long int)i].subtype;
      struct _GtkSettings *return_value_gtk_settings_get_default$2;
      return_value_gtk_settings_get_default$2=gtk_settings_get_default();
      tmp_style=gtk_rc_get_style_by_paths(return_value_gtk_settings_get_default$2, (const char *)(void *)0, style_name, (unsigned long int)(1 << 2));
      j = (unsigned int)0;
      for( ; !(j >= 2u); j = j + 1u)
      {
        if(!(tmp_style == ((struct _GtkStyle *)NULL)))
        {
          if(info_pane[(signed long int)j].msg_type_tags[(signed long int)info_get_styles$$1$$4$$1$$1$$type][(signed long int)info_get_styles$$1$$4$$1$$1$$subtype] == ((struct _GtkTextTag *)NULL))
            info_pane[(signed long int)j].msg_type_tags[(signed long int)info_get_styles$$1$$4$$1$$1$$type][(signed long int)info_get_styles$$1$$4$$1$$1$$subtype]=gtk_text_buffer_create_tag(info_pane[(signed long int)j].textbuffer, (const char *)(void *)0, (const char *)(void *)0);

          set_text_tag_from_style(info_pane[(signed long int)j].msg_type_tags[(signed long int)info_get_styles$$1$$4$$1$$1$$type][(signed long int)info_get_styles$$1$$4$$1$$1$$subtype], tmp_style, base_style[(signed long int)j]);
          has_style = 1;
        }

        else
          if(!(info_pane[(signed long int)j].msg_type_tags[(signed long int)info_get_styles$$1$$4$$1$$1$$type][(signed long int)info_get_styles$$1$$4$$1$$1$$subtype] == ((struct _GtkTextTag *)NULL)))
          {
            struct _GtkTextTagTable *return_value_gtk_text_buffer_get_tag_table$3;
            return_value_gtk_text_buffer_get_tag_table$3=gtk_text_buffer_get_tag_table(info_pane[(signed long int)j].textbuffer);
            gtk_text_tag_table_remove(return_value_gtk_text_buffer_get_tag_table$3, info_pane[(signed long int)j].msg_type_tags[(signed long int)info_get_styles$$1$$4$$1$$1$$type][(signed long int)info_get_styles$$1$$4$$1$$1$$subtype]);
            info_pane[(signed long int)j].msg_type_tags[(signed long int)info_get_styles$$1$$4$$1$$1$$type][(signed long int)info_get_styles$$1$$4$$1$$1$$subtype] = (struct _GtkTextTag *)(void *)0;
          }

        add_style_to_textbuffer(&info_pane[(signed long int)j], base_style[(signed long int)j]);
      }
    }
  }

  else
  {
    has_style = 0;
    i = (unsigned int)0;
    for( ; !((unsigned long int)i >= 184ul); i = i + 1u)
    {
      signed int type;
      signed int subtype;
      type = msg_type_names[(signed long int)i].type;
      subtype = msg_type_names[(signed long int)i].subtype;
      j = (unsigned int)0;
      for( ; !(j >= 2u); j = j + 1u)
      {
        if(!(info_pane[(signed long int)j].msg_type_tags[(signed long int)type][(signed long int)subtype] == ((struct _GtkTextTag *)NULL)))
        {
          struct _GtkTextTagTable *return_value_gtk_text_buffer_get_tag_table$4;
          return_value_gtk_text_buffer_get_tag_table$4=gtk_text_buffer_get_tag_table(info_pane[(signed long int)j].textbuffer);
          gtk_text_tag_table_remove(return_value_gtk_text_buffer_get_tag_table$4, info_pane[(signed long int)j].msg_type_tags[(signed long int)type][(signed long int)subtype]);
          info_pane[(signed long int)j].msg_type_tags[(signed long int)type][(signed long int)subtype] = (struct _GtkTextTag *)(void *)0;
        }

        add_style_to_textbuffer(&info_pane[(signed long int)j], (struct _GtkStyle *)(void *)0);
      }
    }
  }
}

// info_init
// file info.c line 616
extern void info_init(struct _GtkWidget *window_root)
{
  signed int i;
  struct _GtkTextIter end;
  char widget_name[256l];
  i = 0;
  for( ; !(i >= 2); i = i + 1)
  {
    snprintf(widget_name, (unsigned long int)256, "textview_info%d", i + 1);
    struct _GObject *return_value_gtk_builder_get_object$1;
    return_value_gtk_builder_get_object$1=gtk_builder_get_object(window_xml, widget_name);
    unsigned long int return_value_gtk_widget_get_type$2;
    return_value_gtk_widget_get_type$2=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
    info_pane[(signed long int)i].textview = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
    snprintf(widget_name, (unsigned long int)256, "scrolledwindow_textview%d", i + 1);
    struct _GObject *return_value_gtk_builder_get_object$4;
    return_value_gtk_builder_get_object$4=gtk_builder_get_object(window_xml, widget_name);
    unsigned long int return_value_gtk_widget_get_type$5;
    return_value_gtk_widget_get_type$5=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$4, return_value_gtk_widget_get_type$5);
    info_pane[(signed long int)i].scrolled_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$6;
    unsigned long int return_value_gtk_text_view_get_type$7;
    return_value_gtk_text_view_get_type$7=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)info_pane[(signed long int)i].textview, return_value_gtk_text_view_get_type$7);
    gtk_text_view_set_wrap_mode((struct _GtkTextView *)return_value_g_type_check_instance_cast$8, (enum anonymous$45)GTK_WRAP_WORD);
    unsigned long int return_value_gtk_text_view_get_type$9;
    return_value_gtk_text_view_get_type$9=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)info_pane[(signed long int)i].textview, return_value_gtk_text_view_get_type$9);
    info_pane[(signed long int)i].textbuffer=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$10);
    unsigned long int return_value_gtk_scrolled_window_get_type$11;
    return_value_gtk_scrolled_window_get_type$11=gtk_scrolled_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)info_pane[(signed long int)i].scrolled_window, return_value_gtk_scrolled_window_get_type$11);
    info_pane[(signed long int)i].adjustment=gtk_scrolled_window_get_vadjustment((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$12);
    gtk_text_buffer_get_end_iter(info_pane[(signed long int)i].textbuffer, &end);
    info_pane[(signed long int)i].textmark=gtk_text_buffer_create_mark(info_pane[(signed long int)i].textbuffer, (const char *)(void *)0, &end, 0);
    gtk_widget_realize(info_pane[(signed long int)i].textview);
  }
  info_buffer_init();
  i = 0;
  for( ; !(i >= 21); i = i + 1)
    setTextManager(i, message_callback);
}

// init_SDL
// file gtk2proto.h line 237
extern void init_SDL(struct _GtkWidget *sdl_window, signed int just_lightmap)
{
  char SDL_windowhack[32l];
  if(just_lightmap == 0)
  {
    do
      if(sdl_window == ((struct _GtkWidget *)NULL))
        g_assertion_message_expr((char *)0, "sdl.c", 227, (const char *)"init_SDL", "sdl_window != NULL");

    while((_Bool)0);
    unsigned int return_value_SDL_WasInit$1;
    return_value_SDL_WasInit$1=SDL_WasInit((unsigned int)0x00000020);
    if(!(return_value_SDL_WasInit$1 == 0u))
    {
      if(!(lightmap == ((struct SDL_Surface *)NULL)))
        SDL_FreeSurface(lightmap);

      if(!(mapsurface == ((struct SDL_Surface *)NULL)))
        SDL_FreeSurface(mapsurface);

      SDL_Quit();
    }

    unsigned long int return_value_gdk_x11_drawable_get_xid$2;
    return_value_gdk_x11_drawable_get_xid$2=gdk_x11_drawable_get_xid(sdl_window->window);
    snprintf(SDL_windowhack, sizeof(char [32l]) /*32ul*/ , "SDL_WINDOWID=%ld", return_value_gdk_x11_drawable_get_xid$2);
    putenv(SDL_windowhack);
    signed int return_value_SDL_Init$4;
    return_value_SDL_Init$4=SDL_Init((unsigned int)0x00000020);
    if(!(return_value_SDL_Init$4 >= 0))
    {
      char *return_value_SDL_GetError$3;
      return_value_SDL_GetError$3=SDL_GetError();
      LOG((enum LogLevel)LOG_CRITICAL, "gtk-v2::init_SDL", "Could not initialize SDL: %s", return_value_SDL_GetError$3);
      gtk_main_quit();
    }

    mapsurface=SDL_SetVideoMode(map_image_size * (signed int)use_config[(signed long int)19], map_image_size * (signed int)use_config[(signed long int)20], 0, (unsigned int)(0x00000001 | 0x40000000));
    if(mapsurface == ((struct SDL_Surface *)NULL))
      do_SDL_error("SetVideoMode", "sdl.c", 260);

    if(!(fogmap == ((struct SDL_Surface *)NULL)))
      SDL_FreeSurface(fogmap);

    fogmap=SDL_CreateRGBSurface((unsigned int)(0x00000001 | 0x00010000), map_image_size, map_image_size, (signed int)mapsurface->format->BitsPerPixel, mapsurface->format->Rmask, mapsurface->format->Gmask, mapsurface->format->Bmask, mapsurface->format->Amask);
    if(fogmap == ((struct SDL_Surface *)NULL))
      do_SDL_error("SDL_CreateRGBSurface", "sdl.c", 276);

    signed int return_value_SDL_SetAlpha$5;
    return_value_SDL_SetAlpha$5=SDL_SetAlpha(fogmap, (unsigned int)(0x00010000 | 0x00004000), (unsigned char)128);
    if(!(return_value_SDL_SetAlpha$5 >= 0))
      do_SDL_error("SDL_SetAlpha", "sdl.c", 284);

  }

  if(!(lightmap == ((struct SDL_Surface *)NULL)) && !(just_lightmap == 0))
    SDL_FreeSurface(lightmap);

  lightmap=SDL_CreateRGBSurface((unsigned int)(0x00000001 | 0x00010000), map_image_size, map_image_size, (signed int)mapsurface->format->BitsPerPixel, mapsurface->format->Rmask, mapsurface->format->Gmask, mapsurface->format->Bmask, mapsurface->format->Amask);
  if(lightmap == ((struct SDL_Surface *)NULL))
    do_SDL_error("SDL_CreateRGBSurface", "sdl.c", 300);

  if(!((signed int)use_config[17l] == 1))
  {
    lightmap=SDL_DisplayFormatAlpha(lightmap);
    if(lightmap == ((struct SDL_Surface *)NULL))
      do_SDL_error("DisplayFormatAlpha", "sdl.c", 308);

  }

  if((signed int)use_config[16l] == 1)
    overlay_grid(1, 0, 0);

  void *return_value_malloc$6;
  return_value_malloc$6=malloc(sizeof(char) /*1ul*/  * (unsigned long int)(31 + 2) * (unsigned long int)(31 + 2));
  redrawbitmap = (char *)return_value_malloc$6;
}

// init_account_password_window
// file account.c line 1264
static void init_account_password_window()
{
  struct _GObject *return_value_gtk_builder_get_object$1;
  return_value_gtk_builder_get_object$1=gtk_builder_get_object(dialog_xml, "account_password_window");
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
  account_password_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
  unsigned long int return_value_gtk_window_get_type$4;
  return_value_gtk_window_get_type$4=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)account_password_window, return_value_gtk_window_get_type$4);
  unsigned long int return_value_gtk_window_get_type$6;
  return_value_gtk_window_get_type$6=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_window_get_type$6);
  gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, (struct _GtkWindow *)return_value_g_type_check_instance_cast$7);
  struct _GObject *return_value_gtk_builder_get_object$8;
  return_value_gtk_builder_get_object$8=gtk_builder_get_object(dialog_xml, "button_account_password_confirm");
  unsigned long int return_value_gtk_widget_get_type$9;
  return_value_gtk_widget_get_type$9=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$8, return_value_gtk_widget_get_type$9);
  button_account_password_confirm = (struct _GtkWidget *)return_value_g_type_check_instance_cast$10;
  struct _GObject *return_value_gtk_builder_get_object$11;
  return_value_gtk_builder_get_object$11=gtk_builder_get_object(dialog_xml, "button_account_password_cancel");
  unsigned long int return_value_gtk_widget_get_type$12;
  return_value_gtk_widget_get_type$12=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$11, return_value_gtk_widget_get_type$12);
  button_account_password_cancel = (struct _GtkWidget *)return_value_g_type_check_instance_cast$13;
  struct _GObject *return_value_gtk_builder_get_object$14;
  return_value_gtk_builder_get_object$14=gtk_builder_get_object(dialog_xml, "entry_account_password_current");
  unsigned long int return_value_gtk_widget_get_type$15;
  return_value_gtk_widget_get_type$15=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$14, return_value_gtk_widget_get_type$15);
  entry_account_password_current = (struct _GtkWidget *)return_value_g_type_check_instance_cast$16;
  struct _GObject *return_value_gtk_builder_get_object$17;
  return_value_gtk_builder_get_object$17=gtk_builder_get_object(dialog_xml, "entry_account_password_new");
  unsigned long int return_value_gtk_widget_get_type$18;
  return_value_gtk_widget_get_type$18=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
  return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$17, return_value_gtk_widget_get_type$18);
  entry_account_password_new = (struct _GtkWidget *)return_value_g_type_check_instance_cast$19;
  struct _GObject *return_value_gtk_builder_get_object$20;
  return_value_gtk_builder_get_object$20=gtk_builder_get_object(dialog_xml, "entry_account_password_confirm");
  unsigned long int return_value_gtk_widget_get_type$21;
  return_value_gtk_widget_get_type$21=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$20, return_value_gtk_widget_get_type$21);
  entry_account_password_confirm = (struct _GtkWidget *)return_value_g_type_check_instance_cast$22;
  struct _GObject *return_value_gtk_builder_get_object$23;
  return_value_gtk_builder_get_object$23=gtk_builder_get_object(dialog_xml, "label_account_password_status");
  unsigned long int return_value_gtk_widget_get_type$24;
  return_value_gtk_widget_get_type$24=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
  return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$23, return_value_gtk_widget_get_type$24);
  label_account_password_status = (struct _GtkWidget *)return_value_g_type_check_instance_cast$25;
  g_signal_connect_data((void *)account_password_window, "delete_event", (void (*)(void))on_window_delete_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_account_password_confirm, "clicked", (void (*)(void))on_button_account_password_confirm_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_account_password_cancel, "clicked", (void (*)(void))on_button_account_password_cancel_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)entry_account_password_current, "activate", (void (*)(void))on_entry_account_password, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)entry_account_password_new, "activate", (void (*)(void))on_entry_account_password, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)entry_account_password_confirm, "activate", (void (*)(void))on_entry_account_password, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
}

// init_add_character_window
// file account.c line 399
static void init_add_character_window()
{
  struct _GObject *return_value_gtk_builder_get_object$1;
  return_value_gtk_builder_get_object$1=gtk_builder_get_object(dialog_xml, "add_character_window");
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
  add_character_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
  unsigned long int return_value_gtk_window_get_type$4;
  return_value_gtk_window_get_type$4=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)add_character_window, return_value_gtk_window_get_type$4);
  unsigned long int return_value_gtk_window_get_type$6;
  return_value_gtk_window_get_type$6=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_window_get_type$6);
  gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, (struct _GtkWindow *)return_value_g_type_check_instance_cast$7);
  struct _GObject *return_value_gtk_builder_get_object$8;
  return_value_gtk_builder_get_object$8=gtk_builder_get_object(dialog_xml, "button_do_add_character");
  unsigned long int return_value_gtk_widget_get_type$9;
  return_value_gtk_widget_get_type$9=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$8, return_value_gtk_widget_get_type$9);
  button_do_add_character = (struct _GtkWidget *)return_value_g_type_check_instance_cast$10;
  struct _GObject *return_value_gtk_builder_get_object$11;
  return_value_gtk_builder_get_object$11=gtk_builder_get_object(dialog_xml, "button_return_character_select");
  unsigned long int return_value_gtk_widget_get_type$12;
  return_value_gtk_widget_get_type$12=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$11, return_value_gtk_widget_get_type$12);
  button_return_character_select = (struct _GtkWidget *)return_value_g_type_check_instance_cast$13;
  struct _GObject *return_value_gtk_builder_get_object$14;
  return_value_gtk_builder_get_object$14=gtk_builder_get_object(dialog_xml, "entry_character_name");
  unsigned long int return_value_gtk_widget_get_type$15;
  return_value_gtk_widget_get_type$15=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$14, return_value_gtk_widget_get_type$15);
  entry_character_name = (struct _GtkWidget *)return_value_g_type_check_instance_cast$16;
  struct _GObject *return_value_gtk_builder_get_object$17;
  return_value_gtk_builder_get_object$17=gtk_builder_get_object(dialog_xml, "entry_character_password");
  unsigned long int return_value_gtk_widget_get_type$18;
  return_value_gtk_widget_get_type$18=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
  return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$17, return_value_gtk_widget_get_type$18);
  entry_character_password = (struct _GtkWidget *)return_value_g_type_check_instance_cast$19;
  struct _GObject *return_value_gtk_builder_get_object$20;
  return_value_gtk_builder_get_object$20=gtk_builder_get_object(dialog_xml, "label_add_status");
  unsigned long int return_value_gtk_widget_get_type$21;
  return_value_gtk_widget_get_type$21=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$20, return_value_gtk_widget_get_type$21);
  label_add_status = (struct _GtkWidget *)return_value_g_type_check_instance_cast$22;
  g_signal_connect_data((void *)add_character_window, "delete_event", (void (*)(void))on_window_delete_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_do_add_character, "clicked", (void (*)(void))on_button_do_add_character_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_return_character_select, "clicked", (void (*)(void))on_button_return_character_select_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)entry_character_name, "activate", (void (*)(void))on_entry_character, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)entry_character_password, "activate", (void (*)(void))on_entry_character, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
}

// init_choose_char_window
// file account.c line 642
static void init_choose_char_window()
{
  struct _GtkTextIter end;
  struct _GtkCellRenderer *renderer;
  struct _GtkTreeViewColumn *column;
  struct _GObject *return_value_gtk_builder_get_object$1;
  return_value_gtk_builder_get_object$1=gtk_builder_get_object(dialog_xml, "choose_character_window");
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
  choose_char_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
  unsigned long int return_value_gtk_window_get_type$4;
  return_value_gtk_window_get_type$4=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)choose_char_window, return_value_gtk_window_get_type$4);
  unsigned long int return_value_gtk_window_get_type$6;
  return_value_gtk_window_get_type$6=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_window_get_type$6);
  gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, (struct _GtkWindow *)return_value_g_type_check_instance_cast$7);
  struct _GObject *return_value_gtk_builder_get_object$8;
  return_value_gtk_builder_get_object$8=gtk_builder_get_object(dialog_xml, "button_play_character");
  unsigned long int return_value_gtk_widget_get_type$9;
  return_value_gtk_widget_get_type$9=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$8, return_value_gtk_widget_get_type$9);
  button_play_character = (struct _GtkWidget *)return_value_g_type_check_instance_cast$10;
  struct _GObject *return_value_gtk_builder_get_object$11;
  return_value_gtk_builder_get_object$11=gtk_builder_get_object(dialog_xml, "button_create_character");
  unsigned long int return_value_gtk_widget_get_type$12;
  return_value_gtk_widget_get_type$12=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$11, return_value_gtk_widget_get_type$12);
  button_create_character = (struct _GtkWidget *)return_value_g_type_check_instance_cast$13;
  struct _GObject *return_value_gtk_builder_get_object$14;
  return_value_gtk_builder_get_object$14=gtk_builder_get_object(dialog_xml, "button_add_character");
  unsigned long int return_value_gtk_widget_get_type$15;
  return_value_gtk_widget_get_type$15=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$14, return_value_gtk_widget_get_type$15);
  button_add_character = (struct _GtkWidget *)return_value_g_type_check_instance_cast$16;
  struct _GObject *return_value_gtk_builder_get_object$17;
  return_value_gtk_builder_get_object$17=gtk_builder_get_object(dialog_xml, "button_return_login");
  unsigned long int return_value_gtk_widget_get_type$18;
  return_value_gtk_widget_get_type$18=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
  return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$17, return_value_gtk_widget_get_type$18);
  button_return_login = (struct _GtkWidget *)return_value_g_type_check_instance_cast$19;
  struct _GObject *return_value_gtk_builder_get_object$20;
  return_value_gtk_builder_get_object$20=gtk_builder_get_object(dialog_xml, "button_account_password");
  unsigned long int return_value_gtk_widget_get_type$21;
  return_value_gtk_widget_get_type$21=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$20, return_value_gtk_widget_get_type$21);
  button_account_password = (struct _GtkWidget *)return_value_g_type_check_instance_cast$22;
  struct _GObject *return_value_gtk_builder_get_object$23;
  return_value_gtk_builder_get_object$23=gtk_builder_get_object(dialog_xml, "textview_rules_char");
  unsigned long int return_value_gtk_widget_get_type$24;
  return_value_gtk_widget_get_type$24=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
  return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$23, return_value_gtk_widget_get_type$24);
  login_pane[(signed long int)3].textview = (struct _GtkWidget *)return_value_g_type_check_instance_cast$25;
  unsigned long int return_value_gtk_text_view_get_type$26;
  return_value_gtk_text_view_get_type$26=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
  return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)login_pane[(signed long int)3].textview, return_value_gtk_text_view_get_type$26);
  textbuf_rules_char=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$27);
  struct _GObject *return_value_gtk_builder_get_object$28;
  return_value_gtk_builder_get_object$28=gtk_builder_get_object(dialog_xml, "treeview_choose_character");
  unsigned long int return_value_gtk_widget_get_type$29;
  return_value_gtk_widget_get_type$29=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$28, return_value_gtk_widget_get_type$29);
  treeview_choose_character = (struct _GtkWidget *)return_value_g_type_check_instance_cast$30;
  add_tags_to_textbuffer(&login_pane[(signed long int)3], textbuf_rules_char);
  add_style_to_textbuffer(&login_pane[(signed long int)3], (struct _GtkStyle *)(void *)0);
  gtk_text_buffer_get_end_iter(login_pane[(signed long int)3].textbuffer, &end);
  login_pane[(signed long int)3].textmark=gtk_text_buffer_create_mark(login_pane[(signed long int)3].textbuffer, (const char *)(void *)0, &end, 0);
  g_signal_connect_data((void *)choose_char_window, "delete_event", (void (*)(void))on_window_delete_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_play_character, "clicked", (void (*)(void))on_button_play_character_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_create_character, "clicked", (void (*)(void))on_button_create_character_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_add_character, "clicked", (void (*)(void))on_button_add_character_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_return_login, "clicked", (void (*)(void))on_button_return_login_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_account_password, "clicked", (void (*)(void))on_button_account_password_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)treeview_choose_character, "row_activated", (void (*)(void))on_treeview_choose_character_activated, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  character_store=gtk_list_store_new(8, (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(6 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(20 << 2));
  unsigned long int return_value_gtk_tree_view_get_type$31;
  return_value_gtk_tree_view_get_type$31=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
  return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)treeview_choose_character, return_value_gtk_tree_view_get_type$31);
  unsigned long int return_value_gtk_tree_model_get_type$33;
  return_value_gtk_tree_model_get_type$33=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
  return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)character_store, return_value_gtk_tree_model_get_type$33);
  gtk_tree_view_set_model((struct _GtkTreeView *)return_value_g_type_check_instance_cast$32, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$34);
  renderer=gtk_cell_renderer_pixbuf_new();
  column=gtk_tree_view_column_new_with_attributes("?", renderer, (const void *)"pixbuf", 7, (void *)0);
  gtk_tree_view_column_set_min_width(column, image_size);
  unsigned long int return_value_gtk_tree_view_get_type$35;
  return_value_gtk_tree_view_get_type$35=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
  return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)treeview_choose_character, return_value_gtk_tree_view_get_type$35);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$36, column);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes("Character Name", renderer, (const void *)"text", 1, (void *)0);
  gtk_tree_view_column_set_sort_column_id(column, 1);
  unsigned long int return_value_gtk_tree_view_get_type$37;
  return_value_gtk_tree_view_get_type$37=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$38;
  return_value_g_type_check_instance_cast$38=g_type_check_instance_cast((struct _GTypeInstance *)treeview_choose_character, return_value_gtk_tree_view_get_type$37);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$38, column);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes("Class", renderer, (const void *)"text", 2, (void *)0);
  gtk_tree_view_column_set_sort_column_id(column, 2);
  unsigned long int return_value_gtk_tree_view_get_type$39;
  return_value_gtk_tree_view_get_type$39=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$40;
  return_value_g_type_check_instance_cast$40=g_type_check_instance_cast((struct _GTypeInstance *)treeview_choose_character, return_value_gtk_tree_view_get_type$39);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$40, column);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes("Race", renderer, (const void *)"text", 3, (void *)0);
  gtk_tree_view_column_set_sort_column_id(column, 3);
  unsigned long int return_value_gtk_tree_view_get_type$41;
  return_value_gtk_tree_view_get_type$41=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$42;
  return_value_g_type_check_instance_cast$42=g_type_check_instance_cast((struct _GTypeInstance *)treeview_choose_character, return_value_gtk_tree_view_get_type$41);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$42, column);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes("Level", renderer, (const void *)"text", 4, (void *)0);
  gtk_tree_view_column_set_sort_column_id(column, 4);
  unsigned long int return_value_gtk_tree_view_get_type$43;
  return_value_gtk_tree_view_get_type$43=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$44;
  return_value_g_type_check_instance_cast$44=g_type_check_instance_cast((struct _GTypeInstance *)treeview_choose_character, return_value_gtk_tree_view_get_type$43);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$44, column);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes("Party", renderer, (const void *)"text", 5, (void *)0);
  gtk_tree_view_column_set_sort_column_id(column, 5);
  unsigned long int return_value_gtk_tree_view_get_type$45;
  return_value_gtk_tree_view_get_type$45=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$46;
  return_value_g_type_check_instance_cast$46=g_type_check_instance_cast((struct _GTypeInstance *)treeview_choose_character, return_value_gtk_tree_view_get_type$45);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$46, column);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes("Map", renderer, (const void *)"text", 6, (void *)0);
  gtk_tree_view_column_set_sort_column_id(column, 6);
  unsigned long int return_value_gtk_tree_view_get_type$47;
  return_value_gtk_tree_view_get_type$47=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$48;
  return_value_g_type_check_instance_cast$48=g_type_check_instance_cast((struct _GTypeInstance *)treeview_choose_character, return_value_gtk_tree_view_get_type$47);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$48, column);
}

// init_client_vars
// file ../../common/proto.h line 57
void init_client_vars(void)
{
  char buf[4096l];
  signed int i;
  if(!(exp_table == ((unsigned long int *)NULL)))
  {
    free((void *)exp_table);
    exp_table = (unsigned long int *)(void *)0;
  }

  exp_table_max = (unsigned short int)0;
  cpl.count_left = (unsigned short int)0;
  cpl.container = (struct item_struct *)(void *)0;
  memset((void *)&cpl.stats, 0, sizeof(struct Stat_struct) /*632ul*/ );
  cpl.stats.maxsp = (signed short int)1;
  cpl.stats.maxhp = (signed short int)1;
  cpl.stats.maxgrace = (signed short int)1;
  cpl.stats.speed = 1;
  cpl.input_text[(signed long int)0] = (char)0;
  cpl.title[(signed long int)0] = (char)0;
  cpl.range[(signed long int)0] = (char)0;
  cpl.last_command[(signed long int)0] = (char)0;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    cpl.ranges[(signed long int)i] = (struct item_struct *)(void *)0;
  i = 0;
  for( ; !(i >= 50); i = i + 1)
  {
    cpl.stats.skill_exp[(signed long int)i] = (signed long int)0;
    cpl.stats.skill_level[(signed long int)i] = (signed short int)0;
    skill_names[(signed long int)i] = (char *)(void *)0;
    last_used_skills[(signed long int)i] = -1;
  }
  last_used_skills[(signed long int)50] = -1;
  cpl.ob=player_item();
  cpl.below=map_item();
  cpl.magicmap = (unsigned char *)(void *)0;
  cpl.showmagic = (unsigned char)0;
  csocket.command_sent = 0;
  csocket.command_received = 0;
  csocket.command_time = 0;
  face_info.faceset = (unsigned char)0;
  face_info.num_images = (signed short int)0;
  face_info.bmaps_checksum = (unsigned int)0;
  face_info.old_bmaps_checksum = (unsigned int)0;
  face_info.want_faceset = (char *)(void *)0;
  face_info.cache_hits = (signed short int)0;
  face_info.cache_misses = (signed short int)0;
  face_info.have_faceset_info = (unsigned char)0;
  i = 0;
  for( ; !(i >= 20); i = i + 1)
  {
    face_info.facesets[(signed long int)i].prefix = (char *)(void *)0;
    face_info.facesets[(signed long int)i].fullname = (char *)(void *)0;
    face_info.facesets[(signed long int)i].fallback = (unsigned char)0;
    face_info.facesets[(signed long int)i].size = (char *)(void *)0;
    face_info.facesets[(signed long int)i].extension = (char *)(void *)0;
    face_info.facesets[(signed long int)i].comment = (char *)(void *)0;
  }
  want_config[(signed long int)1] = (signed short int)0;
  want_config[(signed long int)2] = (signed short int)0;
  want_config[(signed long int)3] = (signed short int)1;
  want_config[(signed long int)4] = (signed short int)10;
  want_config[(signed long int)5] = (signed short int)0;
  want_config[(signed long int)6] = (signed short int)1;
  want_config[(signed long int)7] = (signed short int)100;
  want_config[(signed long int)8] = (signed short int)100;
  want_config[(signed long int)9] = (signed short int)0;
  want_config[(signed long int)10] = (signed short int)0;
  want_config[(signed long int)11] = (signed short int)0;
  want_config[(signed long int)12] = (signed short int)1;
  want_config[(signed long int)13] = (signed short int)1;
  want_config[(signed long int)14] = (signed short int)0;
  want_config[(signed long int)15] = (signed short int)0;
  want_config[(signed long int)16] = (signed short int)0;
  want_config[(signed long int)17] = (signed short int)1;
  want_config[(signed long int)18] = (signed short int)0;
  want_config[(signed long int)19] = (signed short int)11;
  want_config[(signed long int)20] = (signed short int)11;
  want_config[(signed long int)21] = (signed short int)0;
  want_config[(signed long int)22] = (signed short int)1;
  want_config[(signed long int)23] = (signed short int)13327;
  want_config[(signed long int)24] = (signed short int)0;
  want_config[(signed long int)25] = (signed short int)0;
  want_config[(signed long int)25] = (signed short int)0;
  want_config[(signed long int)26] = (signed short int)0;
  want_config[(signed long int)27] = (signed short int)1;
  want_config[(signed long int)28] = (signed short int)1;
  want_config[(signed long int)29] = (signed short int)1;
  want_config[(signed long int)30] = (signed short int)1;
  want_config[(signed long int)31] = (signed short int)0;
  i = 0;
  for( ; !(i >= 32); i = i + 1)
    use_config[(signed long int)i] = want_config[(signed long int)i];
  xdg_config_dir=getenv("XDG_CONFIG_HOME");
  if(xdg_config_dir == ((char *)NULL))
    xdg_config_dir = ".config";

  xdg_cache_dir=getenv("XDG_CACHE_HOME");
  if(xdg_cache_dir == ((char *)NULL))
    xdg_cache_dir = ".cache";

  char *return_value_getenv$1;
  return_value_getenv$1=getenv("HOME");
  snprintf(buf, sizeof(char [4096l]) /*4096ul*/ , "%s/%s/crossfire", return_value_getenv$1, xdg_config_dir);
  char *return_value_getenv$2;
  return_value_getenv$2=getenv("HOME");
  snprintf(buf, sizeof(char [4096l]) /*4096ul*/ , "%s/%s/crossfire", return_value_getenv$2, xdg_cache_dir);
  make_path_to_dir(buf);
  init_commands();
  init_metaserver();
  signed long int return_value_time$3;
  return_value_time$3=time((signed long int *)(void *)0);
  srandom((unsigned int)return_value_time$3);
}

// init_commands
// file p_cmd.h line 84
extern void init_commands(void)
{
  signed int i;
  num_commands = CommonCommandsSize;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$47 *) /*8ul*/  * (unsigned long int)num_commands);
  name_sorted_commands = (struct anonymous$47 **)return_value_malloc$1;
  i = 0;
  for( ; !(i >= CommonCommandsSize); i = i + 1)
    name_sorted_commands[(signed long int)i] = &CommonCommands[(signed long int)i];
  qsort((void *)name_sorted_commands, (unsigned long int)num_commands, sizeof(struct anonymous$47 *) /*8ul*/ , sort_by_name);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct anonymous$47 *) /*8ul*/  * (unsigned long int)num_commands);
  cat_sorted_commands = (struct anonymous$47 **)return_value_malloc$2;
  memcpy((void *)cat_sorted_commands, (const void *)name_sorted_commands, sizeof(struct anonymous$47 *) /*8ul*/  * (unsigned long int)num_commands);
  qsort((void *)cat_sorted_commands, (unsigned long int)num_commands, sizeof(struct anonymous$47 *) /*8ul*/ , sort_by_category);
}

// init_common_cache_data
// file ../../common/proto.h line 44
void init_common_cache_data(void)
{
  struct _IO_FILE *fp;
  char bmaps[256l];
  char inbuf[256l];
  signed int i;
  char *return_value_fgets$1;
  char *return_value_fgets$3;
  if(!(want_config[5l] == 0))
  {
    i = 0;
    for( ; !(i >= 10000); i = i + 1)
      facetoname[(signed long int)i] = (char *)(void *)0;
    memset((void *)image_cache, 0, (unsigned long int)8192 * sizeof(struct Image_Cache) /*16ul*/ );
    snprintf(bmaps, sizeof(char [256l]) /*256ul*/ , "%s/bmaps.client", (const void *)"/usr/share/games/crossfire-client");
    fp=fopen(bmaps, "r");
    if(!(fp == ((struct _IO_FILE *)NULL)))
    {
      do
      {
        return_value_fgets$1=fgets(inbuf, 256 - 1, fp);
        if(return_value_fgets$1 == ((char *)NULL))
          break;

        image_process_line(inbuf, (unsigned int)1);
      }
      while((_Bool)1);
      fclose(fp);
    }

    else
    {
      snprintf(inbuf, sizeof(char [256l]) /*256ul*/ , "Unable to open %s.  You may wish to download and install the image file to improve performance.\n", (const void *)bmaps);
      draw_ext_info(3, 20, 6, inbuf);
    }
    char *return_value_getenv$2;
    return_value_getenv$2=getenv("HOME");
    snprintf(bmaps, sizeof(char [256l]) /*256ul*/ , "%s/%s/crossfire/image-cache/bmaps.client", return_value_getenv$2, xdg_cache_dir);
    fp=fopen(bmaps, "r");
    if(!(fp == ((struct _IO_FILE *)NULL)))
    {
      do
      {
        return_value_fgets$3=fgets(inbuf, 256 - 1, fp);
        if(return_value_fgets$3 == ((char *)NULL))
          break;

        image_process_line(inbuf, (unsigned int)0);
      }
      while((_Bool)1);
      fclose(fp);
    }

    i = 0;
    for( ; !(i >= 20); i = i + 1)
    {
      fd_cache[(signed long int)i].fd = -1;
      fd_cache[(signed long int)i].name[(signed long int)0] = (char)0;
    }
  }

}

// init_connection
// file ../../common/proto.h line 3
signed int init_connection(char *host, signed int port)
{
  signed int fd = -1;
  signed int oldbufsize;
  signed int newbufsize = 65535;
  unsigned int buflen = (unsigned int)sizeof(signed int) /*4ul*/ ;
  struct addrinfo hints;
  struct addrinfo *res = (struct addrinfo *)(void *)0;
  struct addrinfo *ai;
  char port_str[6l];
  signed int fd_status;
  signed int fd_flags;
  signed int fd_select;
  signed int fd_sockopt;
  struct timeval tv;
  struct anonymous$51 fdset;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(host, "(null)");
  _Bool tmp_if_expr$20;
  signed int *return_value___errno_location$19;
  if(return_value_strcmp$1 == 0)
    return -1;

  else
  {
    snprintf(port_str, sizeof(char [6l]) /*6ul*/ , "%d", port);
    memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
    hints.ai_family = 0;
    hints.ai_socktype = 1;
    hints.ai_protocol = 6;
    signed int return_value_getaddrinfo$2;
    return_value_getaddrinfo$2=getaddrinfo(host, port_str, &hints, &res);
    if(!(return_value_getaddrinfo$2 == 0))
      return -1;

    else
    {
      fd_status = 0;
      ai = res;
      for( ; !(ai == ((struct addrinfo *)NULL)); ai = ai->ai_next)
      {
        fd=socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if(fd == -1)
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          char *return_value_strerror$5;
          return_value_strerror$5=strerror(*return_value___errno_location$4);
          LOG((enum LogLevel)LOG_ERROR, "common::init_connection", "Error creating socket (%d %s)\n", *return_value___errno_location$3, return_value_strerror$5);
          goto __CPROVER_DUMP_L24;
        }

        fd_flags=fcntl(fd, 3, (void *)0);
        if(fd_flags == -1)
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          char *return_value_strerror$7;
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          LOG((enum LogLevel)LOG_ERROR, "common::init_connection", "Error fcntl(fd, F_GETFL) (%s)\n", return_value_strerror$7);
          fd_status = -1;
          break;
        }

        fd_flags = fd_flags | 04000;
        signed int return_value_fcntl$10;
        return_value_fcntl$10=fcntl(fd, 4, fd_flags);
        if(return_value_fcntl$10 == -1)
        {
          signed int *return_value___errno_location$8;
          return_value___errno_location$8=__errno_location();
          char *return_value_strerror$9;
          return_value_strerror$9=strerror(*return_value___errno_location$8);
          LOG((enum LogLevel)LOG_ERROR, "common::init_connection", "Error fcntl(fd, F_SETFL) (%s)\n", return_value_strerror$9);
          fd_status = -1;
          break;
        }

        signed int return_value_connect$25;
        return_value_connect$25=connect(fd, ai->ai_addr, ai->ai_addrlen);
        if(return_value_connect$25 == -1)
        {
          fd_status = -1;
          signed int *return_value___errno_location$24;
          return_value___errno_location$24=__errno_location();
          if(*return_value___errno_location$24 == 115)
          {
            tv.tv_sec = (signed long int)30;
            tv.tv_usec = (signed long int)0;
            do
            {
              signed int __d0;
              signed int __d1;
              asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$51) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fdset)->fds_bits[(signed long int)0]) : "memory");
            }
            while((_Bool)0);
            (&fdset)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&fdset)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
            fd_select=select(fd + 1, (struct anonymous$51 *)(void *)0, &fdset, (struct anonymous$51 *)(void *)0, &tv);
            if(fd_select == -1)
            {
              return_value___errno_location$19=__errno_location();
              tmp_if_expr$20 = *return_value___errno_location$19 != 4 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$20 = (_Bool)0;
            if(tmp_if_expr$20)
            {
              signed int *return_value___errno_location$11;
              return_value___errno_location$11=__errno_location();
              signed int *return_value___errno_location$12;
              return_value___errno_location$12=__errno_location();
              char *return_value_strerror$13;
              return_value_strerror$13=strerror(*return_value___errno_location$12);
              LOG((enum LogLevel)LOG_ERROR, "common::init_connection", "Error connecting %d - %s\n", *return_value___errno_location$11, return_value_strerror$13);
              goto __CPROVER_DUMP_L16;
            }

            else
              if(fd_select >= 1)
              {
                signed int return_value_getsockopt$17;
                return_value_getsockopt$17=getsockopt(fd, 1, 4, (void *)&fd_sockopt, &buflen);
                if(!(return_value_getsockopt$17 == 0))
                {
                  signed int *return_value___errno_location$14;
                  return_value___errno_location$14=__errno_location();
                  signed int *return_value___errno_location$15;
                  return_value___errno_location$15=__errno_location();
                  char *return_value_strerror$16;
                  return_value_strerror$16=strerror(*return_value___errno_location$15);
                  LOG((enum LogLevel)LOG_ERROR, "common::init_connection", "Error in getsockopt %d - %s\n", *return_value___errno_location$14, return_value_strerror$16);
                  goto __CPROVER_DUMP_L16;
                }

                if(!(fd_sockopt == 0))
                {
                  char *return_value_strerror$18;
                  return_value_strerror$18=strerror(fd_sockopt);
                  LOG((enum LogLevel)LOG_ERROR, "common::init_connection", "Error in delayed connection %d - %s\n", fd_sockopt, return_value_strerror$18);
                  goto __CPROVER_DUMP_L16;
                }

                fd_status = 0;
                goto __CPROVER_DUMP_L16;
              }

              else
              {
                LOG((enum LogLevel)LOG_ERROR, "common::init_connection", "Connection timed out.\n");
                return -1;
              }
          }

          else
          {
            signed int *return_value___errno_location$21;
            return_value___errno_location$21=__errno_location();
            signed int *return_value___errno_location$22;
            return_value___errno_location$22=__errno_location();
            char *return_value_strerror$23;
            return_value_strerror$23=strerror(*return_value___errno_location$22);
            LOG((enum LogLevel)LOG_ERROR, "common::init_connection", "Error connecting %d - %s\n", *return_value___errno_location$21, return_value_strerror$23);
            fd_status = 0;
            goto __CPROVER_DUMP_L24;
          }
        }


      __CPROVER_DUMP_L16:
        ;
        if(fd_status == 0)
        {
          fd_flags=fcntl(fd, 3, (void *)0);
          if(fd_flags == -1)
          {
            signed int *return_value___errno_location$26;
            return_value___errno_location$26=__errno_location();
            char *return_value_strerror$27;
            return_value_strerror$27=strerror(*return_value___errno_location$26);
            LOG((enum LogLevel)LOG_ERROR, "common::init_connection", "Error fcntl(..., F_GETFL) (%s)\n", return_value_strerror$27);
            fd_status = -1;
          }

          else
          {
            fd_flags = fd_flags & ~04000;
            signed int return_value_fcntl$30;
            return_value_fcntl$30=fcntl(fd, 4, fd_flags);
            if(return_value_fcntl$30 == -1)
            {
              signed int *return_value___errno_location$28;
              return_value___errno_location$28=__errno_location();
              char *return_value_strerror$29;
              return_value_strerror$29=strerror(*return_value___errno_location$28);
              LOG((enum LogLevel)LOG_ERROR, "common::init_connection", "Error fcntl(..., F_SETFL) (%s)\n", return_value_strerror$29);
              fd_status = -1;
            }

          }
          break;
        }


      __CPROVER_DUMP_L24:
        ;
      }
      if(!(fd_status == 0))
      {
        close(fd);
        fd = -1;
      }

      freeaddrinfo(res);
      if(fd == -1)
        return -1;

      else
      {
        free((void *)csocket.servername);
        unsigned long int return_value_strlen$31;
        return_value_strlen$31=strlen(host);
        void *return_value_malloc$32;
        return_value_malloc$32=malloc(sizeof(char) /*1ul*/  * (return_value_strlen$31 + (unsigned long int)1));
        csocket.servername = (char *)return_value_malloc$32;
        strcpy(csocket.servername, host);
        signed int return_value_fcntl$33;
        return_value_fcntl$33=fcntl(fd, 4, 04000);
        if(return_value_fcntl$33 == -1)
          LOG((enum LogLevel)LOG_ERROR, "common::init_connection", "Error on fcntl.");

        if(!(use_config[3l] == 0))
        {
          signed int i = 1;
          signed int return_value_setsockopt$34;
          return_value_setsockopt$34=setsockopt(fd, 6, 1, (const void *)&i, (unsigned int)sizeof(signed int) /*4ul*/ );
          if(return_value_setsockopt$34 == -1)
            perror("TCP_NODELAY");

        }

        signed int return_value_getsockopt$35;
        return_value_getsockopt$35=getsockopt(fd, 1, 8, (void *)(char *)&oldbufsize, &buflen);
        if(return_value_getsockopt$35 == -1)
          oldbufsize = 0;

        if(!(oldbufsize >= newbufsize))
        {
          signed int return_value_setsockopt$36;
          return_value_setsockopt$36=setsockopt(fd, 1, 8, (const void *)(char *)&newbufsize, (unsigned int)sizeof(signed int *) /*8ul*/ );
          if(!(return_value_setsockopt$36 == 0))
          {
            LOG((enum LogLevel)LOG_WARNING, "common::init_connection: setsockopt", " unable to set output buf size to %d", newbufsize);
            setsockopt(fd, 1, 8, (const void *)(char *)&oldbufsize, (unsigned int)sizeof(signed int *) /*8ul*/ );
          }

        }

        return fd;
      }
    }
  }
}

// init_create_account_window
// file account.c line 883
static void init_create_account_window()
{
  struct _GtkTextIter end;
  struct _GObject *return_value_gtk_builder_get_object$1;
  return_value_gtk_builder_get_object$1=gtk_builder_get_object(dialog_xml, "create_account_window");
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
  create_account_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
  unsigned long int return_value_gtk_window_get_type$4;
  return_value_gtk_window_get_type$4=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)create_account_window, return_value_gtk_window_get_type$4);
  unsigned long int return_value_gtk_window_get_type$6;
  return_value_gtk_window_get_type$6=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_window_get_type$6);
  gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, (struct _GtkWindow *)return_value_g_type_check_instance_cast$7);
  struct _GObject *return_value_gtk_builder_get_object$8;
  return_value_gtk_builder_get_object$8=gtk_builder_get_object(dialog_xml, "button_new_create_account");
  unsigned long int return_value_gtk_widget_get_type$9;
  return_value_gtk_widget_get_type$9=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$8, return_value_gtk_widget_get_type$9);
  button_new_create_account = (struct _GtkWidget *)return_value_g_type_check_instance_cast$10;
  struct _GObject *return_value_gtk_builder_get_object$11;
  return_value_gtk_builder_get_object$11=gtk_builder_get_object(dialog_xml, "button_new_cancel");
  unsigned long int return_value_gtk_widget_get_type$12;
  return_value_gtk_widget_get_type$12=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$11, return_value_gtk_widget_get_type$12);
  button_new_cancel = (struct _GtkWidget *)return_value_g_type_check_instance_cast$13;
  struct _GObject *return_value_gtk_builder_get_object$14;
  return_value_gtk_builder_get_object$14=gtk_builder_get_object(dialog_xml, "textview_rules_account");
  unsigned long int return_value_gtk_widget_get_type$15;
  return_value_gtk_widget_get_type$15=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$14, return_value_gtk_widget_get_type$15);
  login_pane[(signed long int)2].textview = (struct _GtkWidget *)return_value_g_type_check_instance_cast$16;
  unsigned long int return_value_gtk_text_view_get_type$17;
  return_value_gtk_text_view_get_type$17=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)login_pane[(signed long int)2].textview, return_value_gtk_text_view_get_type$17);
  textbuf_rules_account=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$18);
  struct _GObject *return_value_gtk_builder_get_object$19;
  return_value_gtk_builder_get_object$19=gtk_builder_get_object(dialog_xml, "entry_new_account_name");
  unsigned long int return_value_gtk_widget_get_type$20;
  return_value_gtk_widget_get_type$20=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
  return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$19, return_value_gtk_widget_get_type$20);
  entry_new_account_name = (struct _GtkWidget *)return_value_g_type_check_instance_cast$21;
  struct _GObject *return_value_gtk_builder_get_object$22;
  return_value_gtk_builder_get_object$22=gtk_builder_get_object(dialog_xml, "entry_new_account_password");
  unsigned long int return_value_gtk_widget_get_type$23;
  return_value_gtk_widget_get_type$23=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$22, return_value_gtk_widget_get_type$23);
  entry_new_account_password = (struct _GtkWidget *)return_value_g_type_check_instance_cast$24;
  struct _GObject *return_value_gtk_builder_get_object$25;
  return_value_gtk_builder_get_object$25=gtk_builder_get_object(dialog_xml, "entry_new_confirm_password");
  unsigned long int return_value_gtk_widget_get_type$26;
  return_value_gtk_widget_get_type$26=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
  return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$25, return_value_gtk_widget_get_type$26);
  entry_new_confirm_password = (struct _GtkWidget *)return_value_g_type_check_instance_cast$27;
  struct _GObject *return_value_gtk_builder_get_object$28;
  return_value_gtk_builder_get_object$28=gtk_builder_get_object(dialog_xml, "label_create_account_status");
  unsigned long int return_value_gtk_widget_get_type$29;
  return_value_gtk_widget_get_type$29=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$28, return_value_gtk_widget_get_type$29);
  label_create_account_status = (struct _GtkWidget *)return_value_g_type_check_instance_cast$30;
  add_tags_to_textbuffer(&login_pane[(signed long int)2], textbuf_rules_account);
  add_style_to_textbuffer(&login_pane[(signed long int)2], (struct _GtkStyle *)(void *)0);
  gtk_text_buffer_get_end_iter(login_pane[(signed long int)2].textbuffer, &end);
  login_pane[(signed long int)2].textmark=gtk_text_buffer_create_mark(login_pane[(signed long int)2].textbuffer, (const char *)(void *)0, &end, 0);
  g_signal_connect_data((void *)create_account_window, "delete_event", (void (*)(void))on_window_delete_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_new_create_account, "clicked", (void (*)(void))on_button_new_create_account_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_new_cancel, "clicked", (void (*)(void))on_button_new_cancel_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)entry_new_account_name, "activate", (void (*)(void))on_entry_new_account, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)entry_new_account_password, "activate", (void (*)(void))on_entry_new_account, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)entry_new_confirm_password, "activate", (void (*)(void))on_entry_new_account, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
}

// init_create_character_window
// file create_char.c line 794
extern void init_create_character_window()
{
  char tmpbuf[80l];
  signed int i;
  struct _GtkTextIter iter;
  struct _GtkCellRenderer *renderer;
  if(has_init$link1 == 0)
  {
    has_init$link1 = 1;
    struct _GObject *return_value_gtk_builder_get_object$1;
    return_value_gtk_builder_get_object$1=gtk_builder_get_object(dialog_xml, "create_character_window");
    unsigned long int return_value_gtk_widget_get_type$2;
    return_value_gtk_widget_get_type$2=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
    create_character_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
    unsigned long int return_value_gtk_window_get_type$4;
    return_value_gtk_window_get_type$4=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)create_character_window, return_value_gtk_window_get_type$4);
    unsigned long int return_value_gtk_window_get_type$6;
    return_value_gtk_window_get_type$6=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_window_get_type$6);
    gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, (struct _GtkWindow *)return_value_g_type_check_instance_cast$7);
    struct _GObject *return_value_gtk_builder_get_object$8;
    return_value_gtk_builder_get_object$8=gtk_builder_get_object(dialog_xml, "button_cc_done");
    unsigned long int return_value_gtk_widget_get_type$9;
    return_value_gtk_widget_get_type$9=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$8, return_value_gtk_widget_get_type$9);
    button_cc_done = (struct _GtkWidget *)return_value_g_type_check_instance_cast$10;
    struct _GObject *return_value_gtk_builder_get_object$11;
    return_value_gtk_builder_get_object$11=gtk_builder_get_object(dialog_xml, "button_cc_cancel");
    unsigned long int return_value_gtk_widget_get_type$12;
    return_value_gtk_widget_get_type$12=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$11, return_value_gtk_widget_get_type$12);
    button_cc_cancel = (struct _GtkWidget *)return_value_g_type_check_instance_cast$13;
    struct _GObject *return_value_gtk_builder_get_object$14;
    return_value_gtk_builder_get_object$14=gtk_builder_get_object(dialog_xml, "button_choose_starting_map");
    unsigned long int return_value_gtk_widget_get_type$15;
    return_value_gtk_widget_get_type$15=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$14, return_value_gtk_widget_get_type$15);
    button_choose_starting_map = (struct _GtkWidget *)return_value_g_type_check_instance_cast$16;
    struct _GObject *return_value_gtk_builder_get_object$17;
    return_value_gtk_builder_get_object$17=gtk_builder_get_object(dialog_xml, "label_cc_status_update");
    unsigned long int return_value_gtk_widget_get_type$18;
    return_value_gtk_widget_get_type$18=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
    return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$17, return_value_gtk_widget_get_type$18);
    label_cc_status_update = (struct _GtkWidget *)return_value_g_type_check_instance_cast$19;
    struct _GObject *return_value_gtk_builder_get_object$20;
    return_value_gtk_builder_get_object$20=gtk_builder_get_object(dialog_xml, "label_cc_desc");
    unsigned long int return_value_gtk_widget_get_type$21;
    return_value_gtk_widget_get_type$21=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
    return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$20, return_value_gtk_widget_get_type$21);
    label_cc_desc = (struct _GtkWidget *)return_value_g_type_check_instance_cast$22;
    struct _GObject *return_value_gtk_builder_get_object$23;
    return_value_gtk_builder_get_object$23=gtk_builder_get_object(dialog_xml, "label_cc_unspent");
    unsigned long int return_value_gtk_widget_get_type$24;
    return_value_gtk_widget_get_type$24=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
    return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$23, return_value_gtk_widget_get_type$24);
    label_cc_unspent = (struct _GtkWidget *)return_value_g_type_check_instance_cast$25;
    struct _GObject *return_value_gtk_builder_get_object$26;
    return_value_gtk_builder_get_object$26=gtk_builder_get_object(dialog_xml, "combobox_rs");
    unsigned long int return_value_gtk_widget_get_type$27;
    return_value_gtk_widget_get_type$27=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
    return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$26, return_value_gtk_widget_get_type$27);
    combobox_rs = (struct _GtkWidget *)return_value_g_type_check_instance_cast$28;
    struct _GObject *return_value_gtk_builder_get_object$29;
    return_value_gtk_builder_get_object$29=gtk_builder_get_object(dialog_xml, "combobox_cs");
    unsigned long int return_value_gtk_widget_get_type$30;
    return_value_gtk_widget_get_type$30=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$31;
    return_value_g_type_check_instance_cast$31=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$29, return_value_gtk_widget_get_type$30);
    combobox_cs = (struct _GtkWidget *)return_value_g_type_check_instance_cast$31;
    struct _GObject *return_value_gtk_builder_get_object$32;
    return_value_gtk_builder_get_object$32=gtk_builder_get_object(dialog_xml, "cc_entry_new_character_name");
    unsigned long int return_value_gtk_widget_get_type$33;
    return_value_gtk_widget_get_type$33=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
    return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$32, return_value_gtk_widget_get_type$33);
    entry_new_character_name$link1 = (struct _GtkWidget *)return_value_g_type_check_instance_cast$34;
    struct _GObject *return_value_gtk_builder_get_object$35;
    return_value_gtk_builder_get_object$35=gtk_builder_get_object(dialog_xml, "textview_rs_desc");
    unsigned long int return_value_gtk_widget_get_type$36;
    return_value_gtk_widget_get_type$36=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$37;
    return_value_g_type_check_instance_cast$37=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$35, return_value_gtk_widget_get_type$36);
    textview_rs_desc = (struct _GtkWidget *)return_value_g_type_check_instance_cast$37;
    text_mark_rs=gtk_text_mark_new("rs_start", (signed int)!(0 != 0));
    unsigned long int return_value_gtk_text_view_get_type$38;
    return_value_gtk_text_view_get_type$38=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$39;
    return_value_g_type_check_instance_cast$39=g_type_check_instance_cast((struct _GTypeInstance *)textview_rs_desc, return_value_gtk_text_view_get_type$38);
    struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$40;
    return_value_gtk_text_view_get_buffer$40=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$39);
    gtk_text_buffer_get_start_iter(return_value_gtk_text_view_get_buffer$40, &iter);
    unsigned long int return_value_gtk_text_view_get_type$41;
    return_value_gtk_text_view_get_type$41=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$42;
    return_value_g_type_check_instance_cast$42=g_type_check_instance_cast((struct _GTypeInstance *)textview_rs_desc, return_value_gtk_text_view_get_type$41);
    struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$43;
    return_value_gtk_text_view_get_buffer$43=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$42);
    gtk_text_buffer_add_mark(return_value_gtk_text_view_get_buffer$43, text_mark_rs, &iter);
    struct _GObject *return_value_gtk_builder_get_object$44;
    return_value_gtk_builder_get_object$44=gtk_builder_get_object(dialog_xml, "textview_cs_desc");
    unsigned long int return_value_gtk_widget_get_type$45;
    return_value_gtk_widget_get_type$45=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$46;
    return_value_g_type_check_instance_cast$46=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$44, return_value_gtk_widget_get_type$45);
    textview_cs_desc = (struct _GtkWidget *)return_value_g_type_check_instance_cast$46;
    text_mark_cs=gtk_text_mark_new("cs_start", (signed int)!(0 != 0));
    unsigned long int return_value_gtk_text_view_get_type$47;
    return_value_gtk_text_view_get_type$47=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$48;
    return_value_g_type_check_instance_cast$48=g_type_check_instance_cast((struct _GTypeInstance *)textview_cs_desc, return_value_gtk_text_view_get_type$47);
    struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$49;
    return_value_gtk_text_view_get_buffer$49=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$48);
    gtk_text_buffer_get_start_iter(return_value_gtk_text_view_get_buffer$49, &iter);
    unsigned long int return_value_gtk_text_view_get_type$50;
    return_value_gtk_text_view_get_type$50=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$51;
    return_value_g_type_check_instance_cast$51=g_type_check_instance_cast((struct _GTypeInstance *)textview_cs_desc, return_value_gtk_text_view_get_type$50);
    struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$52;
    return_value_gtk_text_view_get_buffer$52=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$51);
    gtk_text_buffer_add_mark(return_value_gtk_text_view_get_buffer$52, text_mark_cs, &iter);
    i = 0;
    for( ; !(i >= 7); i = i + 1)
    {
      snprintf(tmpbuf, (unsigned long int)80, "spinbutton_cc_%s", stat_mapping[(signed long int)i].widget_suffix);
      struct _GObject *return_value_gtk_builder_get_object$53;
      return_value_gtk_builder_get_object$53=gtk_builder_get_object(dialog_xml, tmpbuf);
      unsigned long int return_value_gtk_widget_get_type$54;
      return_value_gtk_widget_get_type$54=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$55;
      return_value_g_type_check_instance_cast$55=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$53, return_value_gtk_widget_get_type$54);
      spinbutton_cc[(signed long int)i] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$55;
      g_signal_connect_data((void *)spinbutton_cc[(signed long int)i], "value-changed", (void (*)(void))on_spinbutton_cc, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
      snprintf(tmpbuf, (unsigned long int)80, "label_rs_%s", stat_mapping[(signed long int)i].widget_suffix);
      struct _GObject *return_value_gtk_builder_get_object$56;
      return_value_gtk_builder_get_object$56=gtk_builder_get_object(dialog_xml, tmpbuf);
      unsigned long int return_value_gtk_widget_get_type$57;
      return_value_gtk_widget_get_type$57=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$58;
      return_value_g_type_check_instance_cast$58=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$56, return_value_gtk_widget_get_type$57);
      label_rs[(signed long int)i] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$58;
      snprintf(tmpbuf, (unsigned long int)80, "label_cs_%s", stat_mapping[(signed long int)i].widget_suffix);
      struct _GObject *return_value_gtk_builder_get_object$59;
      return_value_gtk_builder_get_object$59=gtk_builder_get_object(dialog_xml, tmpbuf);
      unsigned long int return_value_gtk_widget_get_type$60;
      return_value_gtk_widget_get_type$60=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$61;
      return_value_g_type_check_instance_cast$61=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$59, return_value_gtk_widget_get_type$60);
      label_cs[(signed long int)i] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$61;
      snprintf(tmpbuf, (unsigned long int)80, "label_tot_%s", stat_mapping[(signed long int)i].widget_suffix);
      struct _GObject *return_value_gtk_builder_get_object$62;
      return_value_gtk_builder_get_object$62=gtk_builder_get_object(dialog_xml, tmpbuf);
      unsigned long int return_value_gtk_widget_get_type$63;
      return_value_gtk_widget_get_type$63=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$64;
      return_value_g_type_check_instance_cast$64=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$62, return_value_gtk_widget_get_type$63);
      label_tot[(signed long int)i] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$64;
    }
    i = 0;
    for( ; !(i >= 6); i = i + 1)
    {
      struct _GtkListStore *store;
      snprintf(tmpbuf, (unsigned long int)80, "opt_label%d", i + 1);
      struct _GObject *return_value_gtk_builder_get_object$65;
      return_value_gtk_builder_get_object$65=gtk_builder_get_object(dialog_xml, tmpbuf);
      unsigned long int return_value_gtk_widget_get_type$66;
      return_value_gtk_widget_get_type$66=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$67;
      return_value_g_type_check_instance_cast$67=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$65, return_value_gtk_widget_get_type$66);
      opt_label[(signed long int)i] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$67;
      snprintf(tmpbuf, (unsigned long int)80, "opt_combobox%d", i + 1);
      struct _GObject *return_value_gtk_builder_get_object$68;
      return_value_gtk_builder_get_object$68=gtk_builder_get_object(dialog_xml, tmpbuf);
      unsigned long int return_value_gtk_widget_get_type$69;
      return_value_gtk_widget_get_type$69=gtk_widget_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$70;
      return_value_g_type_check_instance_cast$70=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$68, return_value_gtk_widget_get_type$69);
      opt_combobox[(signed long int)i] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$70;
      unsigned long int return_value_gtk_cell_layout_get_type$71;
      return_value_gtk_cell_layout_get_type$71=gtk_cell_layout_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$72;
      return_value_g_type_check_instance_cast$72=g_type_check_instance_cast((struct _GTypeInstance *)opt_combobox[(signed long int)i], return_value_gtk_cell_layout_get_type$71);
      gtk_cell_layout_clear((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$72);
      renderer=gtk_cell_renderer_text_new();
      unsigned long int return_value_gtk_cell_layout_get_type$73;
      return_value_gtk_cell_layout_get_type$73=gtk_cell_layout_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$74;
      return_value_g_type_check_instance_cast$74=g_type_check_instance_cast((struct _GTypeInstance *)opt_combobox[(signed long int)i], return_value_gtk_cell_layout_get_type$73);
      gtk_cell_layout_pack_start((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$74, renderer, 0);
      unsigned long int return_value_gtk_cell_layout_get_type$75;
      return_value_gtk_cell_layout_get_type$75=gtk_cell_layout_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$76;
      return_value_g_type_check_instance_cast$76=g_type_check_instance_cast((struct _GTypeInstance *)opt_combobox[(signed long int)i], return_value_gtk_cell_layout_get_type$75);
      gtk_cell_layout_set_attributes((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$76, renderer, (const void *)"text", 0, (void *)0);
      store=gtk_list_store_new(1, (unsigned long int)(16 << 2));
      unsigned long int return_value_gtk_combo_box_get_type$77;
      return_value_gtk_combo_box_get_type$77=gtk_combo_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$78;
      return_value_g_type_check_instance_cast$78=g_type_check_instance_cast((struct _GTypeInstance *)opt_combobox[(signed long int)i], return_value_gtk_combo_box_get_type$77);
      unsigned long int return_value_gtk_tree_model_get_type$79;
      return_value_gtk_tree_model_get_type$79=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$80;
      return_value_g_type_check_instance_cast$80=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_tree_model_get_type$79);
      gtk_combo_box_set_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$78, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$80);
    }
    g_signal_connect_data((void *)button_cc_done, "clicked", (void (*)(void))on_button_cc_done, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)button_cc_cancel, "clicked", (void (*)(void))on_button_cc_cancel, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)button_choose_starting_map, "clicked", (void (*)(void))on_button_choose_starting_map, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    struct _GObject *return_value_gtk_builder_get_object$81;
    return_value_gtk_builder_get_object$81=gtk_builder_get_object(dialog_xml, "choose_starting_map_window");
    unsigned long int return_value_gtk_widget_get_type$82;
    return_value_gtk_widget_get_type$82=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$83;
    return_value_g_type_check_instance_cast$83=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$81, return_value_gtk_widget_get_type$82);
    choose_starting_map_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$83;
    unsigned long int return_value_gtk_window_get_type$84;
    return_value_gtk_window_get_type$84=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$85;
    return_value_g_type_check_instance_cast$85=g_type_check_instance_cast((struct _GTypeInstance *)choose_starting_map_window, return_value_gtk_window_get_type$84);
    unsigned long int return_value_gtk_window_get_type$86;
    return_value_gtk_window_get_type$86=gtk_window_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$87;
    return_value_g_type_check_instance_cast$87=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_window_get_type$86);
    gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast$85, (struct _GtkWindow *)return_value_g_type_check_instance_cast$87);
    struct _GObject *return_value_gtk_builder_get_object$88;
    return_value_gtk_builder_get_object$88=gtk_builder_get_object(dialog_xml, "textview_starting_map");
    unsigned long int return_value_gtk_widget_get_type$89;
    return_value_gtk_widget_get_type$89=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$90;
    return_value_g_type_check_instance_cast$90=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$88, return_value_gtk_widget_get_type$89);
    create_char_pane[(signed long int)0].textview = (struct _GtkWidget *)return_value_g_type_check_instance_cast$90;
    unsigned long int return_value_gtk_text_view_get_type$91;
    return_value_gtk_text_view_get_type$91=gtk_text_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$92;
    return_value_g_type_check_instance_cast$92=g_type_check_instance_cast((struct _GTypeInstance *)create_char_pane[(signed long int)0].textview, return_value_gtk_text_view_get_type$91);
    textbuf_starting_map=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$92);
    add_tags_to_textbuffer(&create_char_pane[(signed long int)0], textbuf_starting_map);
    add_style_to_textbuffer(&create_char_pane[(signed long int)0], (struct _GtkStyle *)(void *)0);
    gtk_text_buffer_get_end_iter(create_char_pane[(signed long int)0].textbuffer, &iter);
    create_char_pane[(signed long int)0].textmark=gtk_text_buffer_create_mark(create_char_pane[(signed long int)0].textbuffer, (const char *)(void *)0, &iter, 0);
    struct _GObject *return_value_gtk_builder_get_object$93;
    return_value_gtk_builder_get_object$93=gtk_builder_get_object(dialog_xml, "button_csm_done");
    unsigned long int return_value_gtk_widget_get_type$94;
    return_value_gtk_widget_get_type$94=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$95;
    return_value_g_type_check_instance_cast$95=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$93, return_value_gtk_widget_get_type$94);
    button_csm_done = (struct _GtkWidget *)return_value_g_type_check_instance_cast$95;
    struct _GObject *return_value_gtk_builder_get_object$96;
    return_value_gtk_builder_get_object$96=gtk_builder_get_object(dialog_xml, "button_csm_cancel");
    unsigned long int return_value_gtk_widget_get_type$97;
    return_value_gtk_widget_get_type$97=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$98;
    return_value_g_type_check_instance_cast$98=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$96, return_value_gtk_widget_get_type$97);
    button_csm_cancel = (struct _GtkWidget *)return_value_g_type_check_instance_cast$98;
    struct _GObject *return_value_gtk_builder_get_object$99;
    return_value_gtk_builder_get_object$99=gtk_builder_get_object(dialog_xml, "combobox_starting_map");
    unsigned long int return_value_gtk_widget_get_type$100;
    return_value_gtk_widget_get_type$100=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$101;
    return_value_g_type_check_instance_cast$101=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$99, return_value_gtk_widget_get_type$100);
    combobox_starting_map = (struct _GtkWidget *)return_value_g_type_check_instance_cast$101;
    g_signal_connect_data((void *)button_csm_done, "clicked", (void (*)(void))on_button_cc_done, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)button_csm_cancel, "clicked", (void (*)(void))on_button_csm_cancel, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  }

}

// init_default_keybindings
// file keys.c line 496
static void init_default_keybindings()
{
  char *nextline;
  signed int i;
  LOG((enum LogLevel)LOG_DEBUG, "init_default_keybindings", "Loading default keybindings");
  i = 0;
  for( ; !((unsigned long int)i >= 70ul); i = i + 1)
  {
    nextline=strdup(def_keys[(signed long int)i]);
    parse_keybind_line(nextline, i, (unsigned int)(1 << 6));
    free((void *)nextline);
  }
}

// init_glx_opengl
// file opengl.c line 118
extern void init_glx_opengl(struct _GtkWidget *drawingarea)
{
  struct __GLXcontextRec *ctx;
  struct anonymous$59 *vi;
  signed int attrListDbl[13l] = { 4, 5, 8, 4, 9, 4, 10, 4, 11, 4, 12, 16, (signed int)0L };
  struct anonymous$60 attr;
  struct _GdkDrawable *return_value_gdk_x11_window_get_drawable_impl$1;
  return_value_gdk_x11_window_get_drawable_impl$1=gdk_x11_window_get_drawable_impl(drawingarea->window);
  display=gdk_x11_drawable_get_xdisplay(return_value_gdk_x11_window_get_drawable_impl$1);
  signed int return_value_gdk_x11_get_default_screen$2;
  return_value_gdk_x11_get_default_screen$2=gdk_x11_get_default_screen();
  vi=glXChooseVisual(display, return_value_gdk_x11_get_default_screen$2, attrListDbl);
  width = drawingarea->allocation.width;
  height = drawingarea->allocation.height;
  signed int return_value_gdk_x11_get_default_screen$3;
  return_value_gdk_x11_get_default_screen$3=gdk_x11_get_default_screen();
  (&((struct anonymous$58 *)display)->screens[(signed long int)return_value_gdk_x11_get_default_screen$3])->root_visual;
  unsigned long int return_value_gdk_x11_drawable_get_xid$4;
  return_value_gdk_x11_drawable_get_xid$4=gdk_x11_drawable_get_xid(drawingarea->window);
  attr.colormap=XCreateColormap(display, return_value_gdk_x11_drawable_get_xid$4, vi->visual, 0);
  unsigned long int return_value_gdk_x11_drawable_get_xid$5;
  return_value_gdk_x11_drawable_get_xid$5=gdk_x11_drawable_get_xid(drawingarea->window);
  window=XCreateWindow(display, return_value_gdk_x11_drawable_get_xid$5, 0, 0, (unsigned int)width, (unsigned int)height, (unsigned int)0, vi->depth, (unsigned int)1, vi->visual, (unsigned long int)(1L << 13), &attr);
  XMapWindow(display, window);
  if(vi == ((struct anonymous$59 *)NULL))
    LOG((enum LogLevel)LOG_WARNING, "gtk-v2::init_glx_opengl", "Could not get double buffered screen!\n");

  ctx=glXCreateContext(display, vi, ((struct __GLXcontextRec *)NULL), 1);
  signed int return_value_glXMakeCurrent$6;
  return_value_glXMakeCurrent$6=glXMakeCurrent(display, window, ctx);
  if(return_value_glXMakeCurrent$6 == 0)
  {
    LOG((enum LogLevel)LOG_ERROR, "gtk-v2::init_glx_opengl", "Could not set opengl context!\n");
    exit(1);
  }

  signed int return_value_glXIsDirect$7;
  return_value_glXIsDirect$7=glXIsDirect(display, ctx);
  if(!(return_value_glXIsDirect$7 == 0))
    LOG((enum LogLevel)LOG_INFO, "gtk-v2::init_glx_opengl", "Direct rendering is available!\n");

  else
    LOG((enum LogLevel)LOG_INFO, "gtk-v2::init_glx_opengl", "Direct rendering is not available!\n");
}

// init_image_cache_data
// file image.c line 574
extern void init_image_cache_data(void)
{
  signed int i;
  struct _GtkStyle *style;
  LOG((enum LogLevel)LOG_INFO, "gtk-v2::init_image_cache_data", "Init Image Cache");
  style=gtk_widget_get_style(window_root);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct PixmapInfo) /*72ul*/ );
  pixmaps[(signed long int)0] = (struct PixmapInfo *)return_value_malloc$1;
  struct _GdkDrawable *return_value_gdk_pixmap_create_from_xpm_d$2;
  static const char * const question_xpm[28l] = { "24 24 3 1", " \tc None", ".\tc #FFFFFF", "+\tc #000000", "........................", "........................", "........+++++...........", "......+++++++++.........", ".....+++++++++++........", "....+++.......+++.......", "...+++.........+++......", "...+++.........+++......", "...+++.........+++......", "...+++.........+++......", "...+++.........+++......", "....+++.......+++.......", "..............+++.......", "............+++.........", "...........++++.........", ".........+++++..........", ".........+++............", ".........+++............", "........................", "........................", "........................", ".........+++............", ".........+++............", ".........+++............" };
  return_value_gdk_pixmap_create_from_xpm_d$2=gdk_pixmap_create_from_xpm_d(window_root->window, (struct _GdkDrawable **)&pixmaps[(signed long int)0]->icon_mask, &style->bg[(signed long int)GTK_STATE_NORMAL], (char **)question_xpm);
  pixmaps[(signed long int)0]->icon_image = (void *)return_value_gdk_pixmap_create_from_xpm_d$2;
  if((signed int)use_config[10l] == 1)
  {
    struct SDL_Surface *return_value_SDL_CreateRGBSurfaceFrom$3;
    static unsigned int question_sdl[32l] = { (unsigned int)0x00000000, (unsigned int)0x00000000, (unsigned int)0x0000f800, (unsigned int)0x0000fe03, (unsigned int)0x0000ff07, (unsigned int)0x0080030e, (unsigned int)0x00c0011c, (unsigned int)0x00c0011c, (unsigned int)0x00c0011c, (unsigned int)0x00c0011c, (unsigned int)0x00c0011c, (unsigned int)0x0080030e, (unsigned int)0x00800300, (unsigned int)0x00000e00, (unsigned int)0x00001e00, (unsigned int)0x00007c00, (unsigned int)0x00007000, (unsigned int)0x00007000, (unsigned int)0x00000000, (unsigned int)0x00000000, (unsigned int)0x00000000, (unsigned int)0x00007000, (unsigned int)0x00007000, (unsigned int)0x00007000, (unsigned int)0x00000000, (unsigned int)0x00000000, (unsigned int)0x00000000, (unsigned int)0x00000000, (unsigned int)0x00000000, (unsigned int)0x00000000, (unsigned int)0x00000000, (unsigned int)0x00000000 };
    return_value_SDL_CreateRGBSurfaceFrom$3=SDL_CreateRGBSurfaceFrom((void *)question_sdl, 32, 32, 1, 4, (unsigned int)1, (unsigned int)1, (unsigned int)1, (unsigned int)1);
    pixmaps[(signed long int)0]->map_image = (void *)return_value_SDL_CreateRGBSurfaceFrom$3;
    SDL_SetAlpha((struct SDL_Surface *)pixmaps[(signed long int)0]->map_image, (unsigned int)0x00010000, (unsigned char)70);
    struct SDL_Surface *return_value_SDL_CreateRGBSurfaceFrom$4;
    return_value_SDL_CreateRGBSurfaceFrom$4=SDL_CreateRGBSurfaceFrom((void *)question_sdl, 32, 32, 1, 4, (unsigned int)1, (unsigned int)1, (unsigned int)1, (unsigned int)1);
    pixmaps[(signed long int)0]->fog_image = (void *)return_value_SDL_CreateRGBSurfaceFrom$4;
    SDL_SetAlpha((struct SDL_Surface *)pixmaps[(signed long int)0]->fog_image, (unsigned int)0x00010000, (unsigned char)70);
  }

  else
    if((signed int)use_config[10l] == 0)
    {
      pixmaps[(signed long int)0]->map_image = pixmaps[(signed long int)0]->icon_image;
      pixmaps[(signed long int)0]->fog_image = pixmaps[(signed long int)0]->icon_image;
      pixmaps[(signed long int)0]->map_mask = pixmaps[(signed long int)0]->icon_mask;
    }

    else
      if((signed int)use_config[10l] == 2)
        create_opengl_question_mark();

  pixmaps[(signed long int)0]->map_height = (unsigned short int)map_image_size;
  pixmaps[(signed long int)0]->map_width = pixmaps[(signed long int)0]->map_height;
  pixmaps[(signed long int)0]->icon_height = pixmaps[(signed long int)0]->map_width;
  pixmaps[(signed long int)0]->icon_width = pixmaps[(signed long int)0]->icon_height;
  pixmaps[(signed long int)0]->smooth_face = (unsigned short int)0;
  i = 1;
  for( ; !(i >= 10000); i = i + 1)
    pixmaps[(signed long int)i] = pixmaps[(signed long int)0];
  init_common_cache_data();
}

// init_login_window
// file account.c line 1077
static void init_login_window()
{
  struct _GtkTextIter end;
  struct _GObject *return_value_gtk_builder_get_object$1;
  return_value_gtk_builder_get_object$1=gtk_builder_get_object(dialog_xml, "login_window");
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
  login_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
  if(login_window == ((struct _GtkWidget *)NULL))
  {
    error_dialog("Failed to open dialogs.", "Did you run `make install`?");
    exit(1);
  }

  unsigned long int return_value_gtk_window_get_type$4;
  return_value_gtk_window_get_type$4=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)login_window, return_value_gtk_window_get_type$4);
  unsigned long int return_value_gtk_window_get_type$6;
  return_value_gtk_window_get_type$6=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_window_get_type$6);
  gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, (struct _GtkWindow *)return_value_g_type_check_instance_cast$7);
  struct _GObject *return_value_gtk_builder_get_object$8;
  return_value_gtk_builder_get_object$8=gtk_builder_get_object(dialog_xml, "button_login");
  unsigned long int return_value_gtk_widget_get_type$9;
  return_value_gtk_widget_get_type$9=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$8, return_value_gtk_widget_get_type$9);
  button_login = (struct _GtkWidget *)return_value_g_type_check_instance_cast$10;
  struct _GObject *return_value_gtk_builder_get_object$11;
  return_value_gtk_builder_get_object$11=gtk_builder_get_object(dialog_xml, "button_create_account");
  unsigned long int return_value_gtk_widget_get_type$12;
  return_value_gtk_widget_get_type$12=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$11, return_value_gtk_widget_get_type$12);
  button_create_account = (struct _GtkWidget *)return_value_g_type_check_instance_cast$13;
  struct _GObject *return_value_gtk_builder_get_object$14;
  return_value_gtk_builder_get_object$14=gtk_builder_get_object(dialog_xml, "button_go_metaserver");
  unsigned long int return_value_gtk_widget_get_type$15;
  return_value_gtk_widget_get_type$15=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$14, return_value_gtk_widget_get_type$15);
  button_go_metaserver = (struct _GtkWidget *)return_value_g_type_check_instance_cast$16;
  struct _GObject *return_value_gtk_builder_get_object$17;
  return_value_gtk_builder_get_object$17=gtk_builder_get_object(dialog_xml, "button_exit_client");
  unsigned long int return_value_gtk_widget_get_type$18;
  return_value_gtk_widget_get_type$18=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
  return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$17, return_value_gtk_widget_get_type$18);
  button_exit_client = (struct _GtkWidget *)return_value_g_type_check_instance_cast$19;
  struct _GObject *return_value_gtk_builder_get_object$20;
  return_value_gtk_builder_get_object$20=gtk_builder_get_object(dialog_xml, "label_account_login_status");
  unsigned long int return_value_gtk_widget_get_type$21;
  return_value_gtk_widget_get_type$21=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$20, return_value_gtk_widget_get_type$21);
  label_account_login_status = (struct _GtkWidget *)return_value_g_type_check_instance_cast$22;
  struct _GObject *return_value_gtk_builder_get_object$23;
  return_value_gtk_builder_get_object$23=gtk_builder_get_object(dialog_xml, "textview_motd");
  unsigned long int return_value_gtk_widget_get_type$24;
  return_value_gtk_widget_get_type$24=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
  return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$23, return_value_gtk_widget_get_type$24);
  login_pane[(signed long int)0].textview = (struct _GtkWidget *)return_value_g_type_check_instance_cast$25;
  unsigned long int return_value_gtk_text_view_get_type$26;
  return_value_gtk_text_view_get_type$26=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
  return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)login_pane[(signed long int)0].textview, return_value_gtk_text_view_get_type$26);
  textbuf_motd=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$27);
  add_tags_to_textbuffer(&login_pane[(signed long int)0], textbuf_motd);
  add_style_to_textbuffer(&login_pane[(signed long int)0], (struct _GtkStyle *)(void *)0);
  gtk_text_buffer_get_end_iter(login_pane[(signed long int)0].textbuffer, &end);
  login_pane[(signed long int)0].textmark=gtk_text_buffer_create_mark(login_pane[(signed long int)0].textbuffer, (const char *)(void *)0, &end, 0);
  struct _GObject *return_value_gtk_builder_get_object$28;
  return_value_gtk_builder_get_object$28=gtk_builder_get_object(dialog_xml, "textview_news");
  unsigned long int return_value_gtk_widget_get_type$29;
  return_value_gtk_widget_get_type$29=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$28, return_value_gtk_widget_get_type$29);
  login_pane[(signed long int)1].textview = (struct _GtkWidget *)return_value_g_type_check_instance_cast$30;
  unsigned long int return_value_gtk_text_view_get_type$31;
  return_value_gtk_text_view_get_type$31=gtk_text_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
  return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)login_pane[(signed long int)1].textview, return_value_gtk_text_view_get_type$31);
  textbuf_news=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$32);
  add_tags_to_textbuffer(&login_pane[(signed long int)1], textbuf_news);
  add_style_to_textbuffer(&login_pane[(signed long int)1], (struct _GtkStyle *)(void *)0);
  gtk_text_buffer_get_end_iter(login_pane[(signed long int)1].textbuffer, &end);
  login_pane[(signed long int)1].textmark=gtk_text_buffer_create_mark(login_pane[(signed long int)1].textbuffer, (const char *)(void *)0, &end, 0);
  struct _GObject *return_value_gtk_builder_get_object$33;
  return_value_gtk_builder_get_object$33=gtk_builder_get_object(dialog_xml, "entry_account_name");
  unsigned long int return_value_gtk_widget_get_type$34;
  return_value_gtk_widget_get_type$34=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$35;
  return_value_g_type_check_instance_cast$35=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$33, return_value_gtk_widget_get_type$34);
  entry_account_name = (struct _GtkWidget *)return_value_g_type_check_instance_cast$35;
  struct _GObject *return_value_gtk_builder_get_object$36;
  return_value_gtk_builder_get_object$36=gtk_builder_get_object(dialog_xml, "entry_account_password");
  unsigned long int return_value_gtk_widget_get_type$37;
  return_value_gtk_widget_get_type$37=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$38;
  return_value_g_type_check_instance_cast$38=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$36, return_value_gtk_widget_get_type$37);
  entry_account_password = (struct _GtkWidget *)return_value_g_type_check_instance_cast$38;
  g_signal_connect_data((void *)login_window, "delete_event", (void (*)(void))on_window_delete_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)entry_account_name, "activate", (void (*)(void))on_entry_account_name_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)entry_account_password, "activate", (void (*)(void))on_entry_account_password_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_login, "clicked", (void (*)(void))on_button_login_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_create_account, "clicked", (void (*)(void))on_button_create_account_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_go_metaserver, "clicked", (void (*)(void))on_button_go_metaserver_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_exit_client, "clicked", (void (*)(void))on_button_exit_client_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
}

// init_menu_items
// file gtk2proto.h line 174
extern void init_menu_items()
{
  struct _GtkWidget *widget;
  struct _GObject *return_value_gtk_builder_get_object$1;
  return_value_gtk_builder_get_object$1=gtk_builder_get_object(window_xml, "quit_character");
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))menu_quit_character, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$4;
  return_value_gtk_builder_get_object$4=gtk_builder_get_object(window_xml, "quit");
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$4, return_value_gtk_widget_get_type$5);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$6;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))menu_quit_program, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$7;
  return_value_gtk_builder_get_object$7=gtk_builder_get_object(window_xml, "configure");
  unsigned long int return_value_gtk_widget_get_type$8;
  return_value_gtk_widget_get_type$8=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$7, return_value_gtk_widget_get_type$8);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$9;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_configure_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$10;
  return_value_gtk_builder_get_object$10=gtk_builder_get_object(window_xml, "disconnect");
  unsigned long int return_value_gtk_widget_get_type$11;
  return_value_gtk_widget_get_type$11=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$10, return_value_gtk_widget_get_type$11);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$12;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_disconnect_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$13;
  return_value_gtk_builder_get_object$13=gtk_builder_get_object(window_xml, "keybindings");
  unsigned long int return_value_gtk_widget_get_type$14;
  return_value_gtk_widget_get_type$14=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$13, return_value_gtk_widget_get_type$14);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$15;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_keybindings_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$16;
  return_value_gtk_builder_get_object$16=gtk_builder_get_object(window_xml, "msgctrl");
  unsigned long int return_value_gtk_widget_get_type$17;
  return_value_gtk_widget_get_type$17=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$16, return_value_gtk_widget_get_type$17);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$18;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_msgctrl_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$19;
  return_value_gtk_builder_get_object$19=gtk_builder_get_object(window_xml, "save_window_position");
  unsigned long int return_value_gtk_widget_get_type$20;
  return_value_gtk_widget_get_type$20=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
  return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$19, return_value_gtk_widget_get_type$20);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$21;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_save_window_position_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$22;
  return_value_gtk_builder_get_object$22=gtk_builder_get_object(window_xml, "spells");
  unsigned long int return_value_gtk_widget_get_type$23;
  return_value_gtk_widget_get_type$23=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$22, return_value_gtk_widget_get_type$23);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$24;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_spells_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$25;
  return_value_gtk_builder_get_object$25=gtk_builder_get_object(window_xml, "skills");
  unsigned long int return_value_gtk_widget_get_type$26;
  return_value_gtk_widget_get_type$26=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
  return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$25, return_value_gtk_widget_get_type$26);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$27;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_skills_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$28;
  return_value_gtk_builder_get_object$28=gtk_builder_get_object(window_xml, "do_not_pickup");
  unsigned long int return_value_gtk_widget_get_type$29;
  return_value_gtk_widget_get_type$29=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$28, return_value_gtk_widget_get_type$29);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$30;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_dont_pickup_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$31;
  return_value_gtk_builder_get_object$31=gtk_builder_get_object(window_xml, "stop_before_pickup");
  unsigned long int return_value_gtk_widget_get_type$32;
  return_value_gtk_widget_get_type$32=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
  return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$31, return_value_gtk_widget_get_type$32);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$33;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_stop_before_pickup_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$34;
  return_value_gtk_builder_get_object$34=gtk_builder_get_object(window_xml, "body_armor");
  unsigned long int return_value_gtk_widget_get_type$35;
  return_value_gtk_widget_get_type$35=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
  return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$34, return_value_gtk_widget_get_type$35);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$36;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_body_armor_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$37;
  return_value_gtk_builder_get_object$37=gtk_builder_get_object(window_xml, "boots");
  unsigned long int return_value_gtk_widget_get_type$38;
  return_value_gtk_widget_get_type$38=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$39;
  return_value_g_type_check_instance_cast$39=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$37, return_value_gtk_widget_get_type$38);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$39;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_boots_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$40;
  return_value_gtk_builder_get_object$40=gtk_builder_get_object(window_xml, "cloaks");
  unsigned long int return_value_gtk_widget_get_type$41;
  return_value_gtk_widget_get_type$41=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$42;
  return_value_g_type_check_instance_cast$42=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$40, return_value_gtk_widget_get_type$41);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$42;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_cloaks_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$43;
  return_value_gtk_builder_get_object$43=gtk_builder_get_object(window_xml, "gloves");
  unsigned long int return_value_gtk_widget_get_type$44;
  return_value_gtk_widget_get_type$44=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$45;
  return_value_g_type_check_instance_cast$45=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$43, return_value_gtk_widget_get_type$44);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$45;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_gloves_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$46;
  return_value_gtk_builder_get_object$46=gtk_builder_get_object(window_xml, "helmets");
  unsigned long int return_value_gtk_widget_get_type$47;
  return_value_gtk_widget_get_type$47=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$48;
  return_value_g_type_check_instance_cast$48=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$46, return_value_gtk_widget_get_type$47);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$48;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_helmets_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$49;
  return_value_gtk_builder_get_object$49=gtk_builder_get_object(window_xml, "shields");
  unsigned long int return_value_gtk_widget_get_type$50;
  return_value_gtk_widget_get_type$50=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$51;
  return_value_g_type_check_instance_cast$51=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$49, return_value_gtk_widget_get_type$50);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$51;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_shields_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$52;
  return_value_gtk_builder_get_object$52=gtk_builder_get_object(window_xml, "skillscrolls");
  unsigned long int return_value_gtk_widget_get_type$53;
  return_value_gtk_widget_get_type$53=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$54;
  return_value_g_type_check_instance_cast$54=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$52, return_value_gtk_widget_get_type$53);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$54;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_skillscrolls_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$55;
  return_value_gtk_builder_get_object$55=gtk_builder_get_object(window_xml, "normal_book_scrolls");
  unsigned long int return_value_gtk_widget_get_type$56;
  return_value_gtk_widget_get_type$56=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$57;
  return_value_g_type_check_instance_cast$57=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$55, return_value_gtk_widget_get_type$56);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$57;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_normal_book_scrolls_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$58;
  return_value_gtk_builder_get_object$58=gtk_builder_get_object(window_xml, "spellbooks");
  unsigned long int return_value_gtk_widget_get_type$59;
  return_value_gtk_widget_get_type$59=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$60;
  return_value_g_type_check_instance_cast$60=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$58, return_value_gtk_widget_get_type$59);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$60;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_spellbooks_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$61;
  return_value_gtk_builder_get_object$61=gtk_builder_get_object(window_xml, "drinks");
  unsigned long int return_value_gtk_widget_get_type$62;
  return_value_gtk_widget_get_type$62=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$63;
  return_value_g_type_check_instance_cast$63=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$61, return_value_gtk_widget_get_type$62);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$63;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_drinks_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$64;
  return_value_gtk_builder_get_object$64=gtk_builder_get_object(window_xml, "food");
  unsigned long int return_value_gtk_widget_get_type$65;
  return_value_gtk_widget_get_type$65=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$66;
  return_value_g_type_check_instance_cast$66=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$64, return_value_gtk_widget_get_type$65);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$66;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_food_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$67;
  return_value_gtk_builder_get_object$67=gtk_builder_get_object(window_xml, "flesh");
  unsigned long int return_value_gtk_widget_get_type$68;
  return_value_gtk_widget_get_type$68=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$69;
  return_value_g_type_check_instance_cast$69=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$67, return_value_gtk_widget_get_type$68);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$69;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_flesh_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$70;
  return_value_gtk_builder_get_object$70=gtk_builder_get_object(window_xml, "keys");
  unsigned long int return_value_gtk_widget_get_type$71;
  return_value_gtk_widget_get_type$71=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$72;
  return_value_g_type_check_instance_cast$72=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$70, return_value_gtk_widget_get_type$71);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$72;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_keys_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$73;
  return_value_gtk_builder_get_object$73=gtk_builder_get_object(window_xml, "magical_items");
  unsigned long int return_value_gtk_widget_get_type$74;
  return_value_gtk_widget_get_type$74=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$75;
  return_value_g_type_check_instance_cast$75=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$73, return_value_gtk_widget_get_type$74);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$75;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_magical_items_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$76;
  return_value_gtk_builder_get_object$76=gtk_builder_get_object(window_xml, "potions");
  unsigned long int return_value_gtk_widget_get_type$77;
  return_value_gtk_widget_get_type$77=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$78;
  return_value_g_type_check_instance_cast$78=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$76, return_value_gtk_widget_get_type$77);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$78;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_potions_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$79;
  return_value_gtk_builder_get_object$79=gtk_builder_get_object(window_xml, "valuables");
  unsigned long int return_value_gtk_widget_get_type$80;
  return_value_gtk_widget_get_type$80=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$81;
  return_value_g_type_check_instance_cast$81=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$79, return_value_gtk_widget_get_type$80);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$81;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_valuables_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$82;
  return_value_gtk_builder_get_object$82=gtk_builder_get_object(window_xml, "wands_rods_horns");
  unsigned long int return_value_gtk_widget_get_type$83;
  return_value_gtk_widget_get_type$83=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$84;
  return_value_g_type_check_instance_cast$84=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$82, return_value_gtk_widget_get_type$83);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$84;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_wands_rods_horns_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$85;
  return_value_gtk_builder_get_object$85=gtk_builder_get_object(window_xml, "jewels");
  unsigned long int return_value_gtk_widget_get_type$86;
  return_value_gtk_widget_get_type$86=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$87;
  return_value_g_type_check_instance_cast$87=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$85, return_value_gtk_widget_get_type$86);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$87;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_jewels_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$88;
  return_value_gtk_builder_get_object$88=gtk_builder_get_object(window_xml, "containers");
  unsigned long int return_value_gtk_widget_get_type$89;
  return_value_gtk_widget_get_type$89=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$90;
  return_value_g_type_check_instance_cast$90=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$88, return_value_gtk_widget_get_type$89);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$90;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_containers_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$91;
  return_value_gtk_builder_get_object$91=gtk_builder_get_object(window_xml, "all_weapons");
  unsigned long int return_value_gtk_widget_get_type$92;
  return_value_gtk_widget_get_type$92=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$93;
  return_value_g_type_check_instance_cast$93=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$91, return_value_gtk_widget_get_type$92);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$93;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_all_weapons_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$94;
  return_value_gtk_builder_get_object$94=gtk_builder_get_object(window_xml, "missile_weapons");
  unsigned long int return_value_gtk_widget_get_type$95;
  return_value_gtk_widget_get_type$95=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$96;
  return_value_g_type_check_instance_cast$96=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$94, return_value_gtk_widget_get_type$95);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$96;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_missile_weapons_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$97;
  return_value_gtk_builder_get_object$97=gtk_builder_get_object(window_xml, "bows");
  unsigned long int return_value_gtk_widget_get_type$98;
  return_value_gtk_widget_get_type$98=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$99;
  return_value_g_type_check_instance_cast$99=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$97, return_value_gtk_widget_get_type$98);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$99;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_bows_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$100;
  return_value_gtk_builder_get_object$100=gtk_builder_get_object(window_xml, "arrows");
  unsigned long int return_value_gtk_widget_get_type$101;
  return_value_gtk_widget_get_type$101=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$102;
  return_value_g_type_check_instance_cast$102=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$100, return_value_gtk_widget_get_type$101);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$102;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_arrows_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$103;
  return_value_gtk_builder_get_object$103=gtk_builder_get_object(window_xml, "ratio_pickup_off");
  unsigned long int return_value_gtk_widget_get_type$104;
  return_value_gtk_widget_get_type$104=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$105;
  return_value_g_type_check_instance_cast$105=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$103, return_value_gtk_widget_get_type$104);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$105;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_ratio_pickup_off_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$106;
  return_value_gtk_builder_get_object$106=gtk_builder_get_object(window_xml, "ratio_5");
  unsigned long int return_value_gtk_widget_get_type$107;
  return_value_gtk_widget_get_type$107=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$108;
  return_value_g_type_check_instance_cast$108=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$106, return_value_gtk_widget_get_type$107);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$108;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_ratio_5_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$109;
  return_value_gtk_builder_get_object$109=gtk_builder_get_object(window_xml, "ratio_10");
  unsigned long int return_value_gtk_widget_get_type$110;
  return_value_gtk_widget_get_type$110=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$111;
  return_value_g_type_check_instance_cast$111=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$109, return_value_gtk_widget_get_type$110);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$111;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_ratio_10_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$112;
  return_value_gtk_builder_get_object$112=gtk_builder_get_object(window_xml, "ratio_15");
  unsigned long int return_value_gtk_widget_get_type$113;
  return_value_gtk_widget_get_type$113=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$114;
  return_value_g_type_check_instance_cast$114=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$112, return_value_gtk_widget_get_type$113);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$114;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_ratio_15_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$115;
  return_value_gtk_builder_get_object$115=gtk_builder_get_object(window_xml, "ratio_20");
  unsigned long int return_value_gtk_widget_get_type$116;
  return_value_gtk_widget_get_type$116=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$117;
  return_value_g_type_check_instance_cast$117=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$115, return_value_gtk_widget_get_type$116);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$117;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_ratio_20_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$118;
  return_value_gtk_builder_get_object$118=gtk_builder_get_object(window_xml, "ratio_25");
  unsigned long int return_value_gtk_widget_get_type$119;
  return_value_gtk_widget_get_type$119=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$120;
  return_value_g_type_check_instance_cast$120=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$118, return_value_gtk_widget_get_type$119);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$120;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_ratio_25_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$121;
  return_value_gtk_builder_get_object$121=gtk_builder_get_object(window_xml, "ratio_30");
  unsigned long int return_value_gtk_widget_get_type$122;
  return_value_gtk_widget_get_type$122=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$123;
  return_value_g_type_check_instance_cast$123=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$121, return_value_gtk_widget_get_type$122);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$123;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_ratio_35_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$124;
  return_value_gtk_builder_get_object$124=gtk_builder_get_object(window_xml, "ratio_35");
  unsigned long int return_value_gtk_widget_get_type$125;
  return_value_gtk_widget_get_type$125=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$126;
  return_value_g_type_check_instance_cast$126=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$124, return_value_gtk_widget_get_type$125);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$126;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_ratio_35_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$127;
  return_value_gtk_builder_get_object$127=gtk_builder_get_object(window_xml, "ratio_40");
  unsigned long int return_value_gtk_widget_get_type$128;
  return_value_gtk_widget_get_type$128=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$129;
  return_value_g_type_check_instance_cast$129=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$127, return_value_gtk_widget_get_type$128);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$129;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_ratio_40_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$130;
  return_value_gtk_builder_get_object$130=gtk_builder_get_object(window_xml, "ratio_45");
  unsigned long int return_value_gtk_widget_get_type$131;
  return_value_gtk_widget_get_type$131=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$132;
  return_value_g_type_check_instance_cast$132=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$130, return_value_gtk_widget_get_type$131);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$132;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_ratio_45_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$133;
  return_value_gtk_builder_get_object$133=gtk_builder_get_object(window_xml, "ratio_50");
  unsigned long int return_value_gtk_widget_get_type$134;
  return_value_gtk_widget_get_type$134=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$135;
  return_value_g_type_check_instance_cast$135=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$133, return_value_gtk_widget_get_type$134);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$135;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_ratio_50_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$136;
  return_value_gtk_builder_get_object$136=gtk_builder_get_object(window_xml, "not_cursed");
  unsigned long int return_value_gtk_widget_get_type$137;
  return_value_gtk_widget_get_type$137=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$138;
  return_value_g_type_check_instance_cast$138=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$136, return_value_gtk_widget_get_type$137);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$138;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))on_menu_not_cursed_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$139;
  return_value_gtk_builder_get_object$139=gtk_builder_get_object(window_xml, "about");
  unsigned long int return_value_gtk_widget_get_type$140;
  return_value_gtk_widget_get_type$140=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$141;
  return_value_g_type_check_instance_cast$141=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$139, return_value_gtk_widget_get_type$140);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$141;
  g_signal_connect_data((void *)widget, "activate", (void (*)(void))menu_about, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
}

// init_metaserver
// file ./proto.h line 103
void init_metaserver(void)
{
  pthread_mutex_init(&ms2_info_mutex, (const union anonymous$38 *)(void *)0);
  curl_global_init((signed long int)(1 << 0 | 1 << 1));
}

// init_new_character_window
// file account.c line 223
static void init_new_character_window()
{
  struct _GObject *return_value_gtk_builder_get_object$1;
  return_value_gtk_builder_get_object$1=gtk_builder_get_object(dialog_xml, "create_character_window");
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
  new_character_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
  unsigned long int return_value_gtk_window_get_type$4;
  return_value_gtk_window_get_type$4=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)new_character_window, return_value_gtk_window_get_type$4);
  unsigned long int return_value_gtk_window_get_type$6;
  return_value_gtk_window_get_type$6=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_window_get_type$6);
  gtk_window_set_transient_for((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, (struct _GtkWindow *)return_value_g_type_check_instance_cast$7);
  struct _GObject *return_value_gtk_builder_get_object$8;
  return_value_gtk_builder_get_object$8=gtk_builder_get_object(dialog_xml, "button_create_character");
  unsigned long int return_value_gtk_widget_get_type$9;
  return_value_gtk_widget_get_type$9=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$8, return_value_gtk_widget_get_type$9);
  button_create_new_char = (struct _GtkWidget *)return_value_g_type_check_instance_cast$10;
  struct _GObject *return_value_gtk_builder_get_object$11;
  return_value_gtk_builder_get_object$11=gtk_builder_get_object(dialog_xml, "button_cc_cancel");
  unsigned long int return_value_gtk_widget_get_type$12;
  return_value_gtk_widget_get_type$12=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
  return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$11, return_value_gtk_widget_get_type$12);
  button_new_char_cancel = (struct _GtkWidget *)return_value_g_type_check_instance_cast$13;
  struct _GObject *return_value_gtk_builder_get_object$14;
  return_value_gtk_builder_get_object$14=gtk_builder_get_object(dialog_xml, "cc_entry_new_character_name");
  unsigned long int return_value_gtk_widget_get_type$15;
  return_value_gtk_widget_get_type$15=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$14, return_value_gtk_widget_get_type$15);
  entry_new_character_name = (struct _GtkWidget *)return_value_g_type_check_instance_cast$16;
  struct _GObject *return_value_gtk_builder_get_object$17;
  return_value_gtk_builder_get_object$17=gtk_builder_get_object(dialog_xml, "label_cc_status_update");
  unsigned long int return_value_gtk_widget_get_type$18;
  return_value_gtk_widget_get_type$18=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
  return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$17, return_value_gtk_widget_get_type$18);
  label_new_char_status = (struct _GtkWidget *)return_value_g_type_check_instance_cast$19;
  g_signal_connect_data((void *)new_character_window, "delete_event", (void (*)(void))on_window_delete_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_create_new_char, "clicked", (void (*)(void))on_button_create_new_char_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)button_new_char_cancel, "clicked", (void (*)(void))on_button_new_char_cancel_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)entry_new_character_name, "activate", (void (*)(void))on_entry_new_character_name, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
}

// init_opengl
// file gtk2proto.h line 185
extern void init_opengl(struct _GtkWidget *drawingarea)
{
  init_glx_opengl(drawingarea);
  init_opengl_common();
}

// init_opengl_common
// file opengl.c line 72
static void init_opengl_common(void)
{
  signed int texSize;
  glEnable((unsigned int)0x0DE1);
  glShadeModel((unsigned int)0x1D01);
  glEnable((unsigned int)0x0BE2);
  glBlendFunc((unsigned int)0x0302, (unsigned int)0x0303);
  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
  glClearDepth((double)1.0f);
  glViewport(0, 0, (signed int)(float)width, (signed int)(float)height);
  glMatrixMode((unsigned int)0x1701);
  glLoadIdentity();
  glOrtho((double)0.0f, (double)width, (double)height, (double)0.0f, (double)-1.0f, (double)1.0f);
  glMatrixMode((unsigned int)0x1700);
  glLoadIdentity();
  glFlush();
  glGetIntegerv((unsigned int)0x0D33, &texSize);
  LOG((enum LogLevel)LOG_INFO, "gtk-v2::opengl_common", "Maximum texture size is %d\n", texSize);
}

// init_sockets
// file main.c line 660
static void init_sockets()
{
  wantloginmethod = 2;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(2 + 65535 + 1));
  csocket.inbuf.buf = (unsigned char *)return_value_malloc$1;
  signal(13, sigpipe_handler);
  signed long int return_value_sysconf$2;
  return_value_sysconf$2=sysconf(4);
  maxfd = (signed int)return_value_sysconf$2;
}

// init_sounds
// file sound.c line 49
signed int init_sounds()
{
  char sound_path[256l];
  if(want_config[13l] == 0)
    return -1;

  else
    if((signed int)*sound_server == 0)
    {
      LOG((enum LogLevel)LOG_ERROR, "gtk-v2::init_sounds", "No sound server is set.");
      return -1;
    }

    else
    {
      if((signed int)*sound_server == 47)
        strncpy(sound_path, sound_server, sizeof(char [256l]) /*256ul*/ );

      else
        snprintf(sound_path, sizeof(char [256l]) /*256ul*/ , "%s/%s", (const void *)"/usr/games", sound_server);
      signed int return_value_access$1;
      return_value_access$1=access(sound_path, 1);
      if(!(return_value_access$1 >= 0))
      {
        LOG((enum LogLevel)LOG_ERROR, "gtk-v2::init_sounds", "Unable to find sound server at '%s'", (const void *)sound_path);
        return -1;
      }

      else
      {
        sound_process=raiseChild(sound_path, 1 | 2 | 4);
        logChildPipe(sound_process, (enum LogLevel)LOG_INFO, 2 | 4);
        signed int return_value_fcntl$2;
        return_value_fcntl$2=fcntl(sound_process->tube[(signed long int)0], 4, 04000);
        if(!(return_value_fcntl$2 >= 0))
          perror("init_sounds: Warning - unable to set non blocking on sound pipe\n");

        sound_pipe=fdopen(sound_process->tube[(signed long int)0], "w");
        return 0;
      }
    }
}

// init_theme
// file config.c line 128
extern void init_theme()
{
  char path[256l];
  char xml_basename[256l];
  char **tmp;
  char *cp;
  signed int i;
  tmp=gtk_rc_get_default_files();
  i = 0;
  for( ; !(tmp[(signed long int)i] == ((char *)NULL)); i = i + 1)
    ;
  i = i + 2;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(char *) /*8ul*/  * (unsigned long int)(i + 1));
  default_files = (char **)return_value_malloc$1;
  i = 0;
  for( ; !(tmp[(signed long int)i] == ((char *)NULL)); i = i + 1)
    default_files[(signed long int)i]=strdup(tmp[(signed long int)i]);
  char *return_value_getenv$2;
  return_value_getenv$2=getenv("HOME");
  snprintf(path, sizeof(char [256l]) /*256ul*/ , "%s/.crossfire/gtkrc", return_value_getenv$2);
  default_files[(signed long int)i]=strdup(path);
  i = i + 1;
  snprintf(xml_basename, sizeof(char [256l]) /*256ul*/ , "%s", (const void *)window_xml_file);
  cp=strrchr(xml_basename, 46);
  if(!(cp == ((char *)NULL)))
    cp[(signed long int)0] = (char)0;

  char *return_value_getenv$3;
  return_value_getenv$3=getenv("HOME");
  snprintf(path, sizeof(char [256l]) /*256ul*/ , "%s/.crossfire/%s.gtkrc", return_value_getenv$3, (const void *)xml_basename);
  default_files[(signed long int)i]=strdup(path);
  i = i + 1;
  default_files[(signed long int)i] = (char *)(void *)0;
}

// init_ui
// file main.c line 687
static void init_ui()
{
  struct _GError *error = (struct _GError *)(void *)0;
  struct _GdkGeometry geometry;
  signed int i;
  if((signed int)dialog_xml_path[0l] == 0)
    snprintf(dialog_xml_path, sizeof(char [256l]) /*256ul*/ , "%s%s", (const void *)"/usr/share/games/crossfire-client/ui/", (const void *)dialog_xml_file);

  if((signed int)window_xml_path[0l] == 0)
    snprintf(window_xml_path, sizeof(char [256l]) /*256ul*/ , "%s%s", (const void *)"/usr/share/games/crossfire-client/ui/", (const void *)window_xml_file);

  dialog_xml=gtk_builder_new();
  unsigned int return_value_gtk_builder_add_from_file$1;
  return_value_gtk_builder_add_from_file$1=gtk_builder_add_from_file(dialog_xml, dialog_xml_path, &error);
  if(return_value_gtk_builder_add_from_file$1 == 0u)
  {
    error_dialog("Couldn't load UI dialogs.", error->message);
    g_log((char *)0, (enum anonymous$52)G_LOG_LEVEL_WARNING, "Couldn't load UI dialogs: %s", error->message);
    g_error_free(error);
    exit(1);
  }

  window_xml=gtk_builder_new();
  unsigned int return_value_gtk_builder_add_from_file$3;
  return_value_gtk_builder_add_from_file$3=gtk_builder_add_from_file(window_xml, window_xml_path, &error);
  if(return_value_gtk_builder_add_from_file$3 == 0u)
  {
    LOG((enum LogLevel)LOG_WARNING, "main.c::init_ui", "Couldn't load '%s'; using default.", (const void *)window_xml_path);
    error = (struct _GError *)(void *)0;
    snprintf(window_xml_path, sizeof(char [256l]) /*256ul*/ , "%s%s", (const void *)"/usr/share/games/crossfire-client/ui/", (const void *)"gtk-v1.ui");
    unsigned int return_value_gtk_builder_add_from_file$2;
    return_value_gtk_builder_add_from_file$2=gtk_builder_add_from_file(window_xml, window_xml_path, &error);
    if(return_value_gtk_builder_add_from_file$2 == 0u)
    {
      error_dialog("Couldn't load client window.", error->message);
      g_error_free(error);
      exit(1);
    }

  }

  struct _GObject *return_value_gtk_builder_get_object$4;
  return_value_gtk_builder_get_object$4=gtk_builder_get_object(window_xml, "window_root");
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$4, return_value_gtk_widget_get_type$5);
  window_root = (struct _GtkWidget *)return_value_g_type_check_instance_cast$6;
  gtk_widget_add_events((struct _GtkWidget *)(void *)window_root, 16384);
  g_signal_connect_data((void *)window_root, "focus-out-event", (void (*)(void))focusoutfunc, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  unsigned long int return_value_gtk_object_get_type$7;
  return_value_gtk_object_get_type$7=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_object_get_type$7);
  g_signal_connect_data((void *)window_root, "key_press_event", (void (*)(void))keyfunc, (void *)(struct _GtkObject *)return_value_g_type_check_instance_cast$8, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)G_CONNECT_SWAPPED);
  unsigned long int return_value_gtk_object_get_type$9;
  return_value_gtk_object_get_type$9=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_object_get_type$9);
  g_signal_connect_data((void *)window_root, "key_release_event", (void (*)(void))keyrelfunc, (void *)(struct _GtkObject *)return_value_g_type_check_instance_cast$10, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)G_CONNECT_SWAPPED);
  g_signal_connect_data((void *)window_root, "destroy", (void (*)(void))on_window_destroy_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  geometry.min_width = 640;
  geometry.min_height = 480;
  unsigned long int return_value_gtk_window_get_type$11;
  return_value_gtk_window_get_type$11=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_window_get_type$11);
  gtk_window_set_geometry_hints((struct _GtkWindow *)return_value_g_type_check_instance_cast$12, window_root, &geometry, (enum anonymous$53)GDK_HINT_MIN_SIZE);
  struct _GObject *return_value_gtk_builder_get_object$13;
  return_value_gtk_builder_get_object$13=gtk_builder_get_object(window_xml, "drawingarea_magic_map");
  unsigned long int return_value_gtk_widget_get_type$14;
  return_value_gtk_widget_get_type$14=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$13, return_value_gtk_widget_get_type$14);
  magic_map = (struct _GtkWidget *)return_value_g_type_check_instance_cast$15;
  g_signal_connect_data((void *)magic_map, "expose_event", (void (*)(void))on_drawingarea_magic_map_expose_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  i = 0;
  for( ; !(i >= 13); i = i + 1)
  {
    signed int return_value_gdk_color_parse$16;
    return_value_gdk_color_parse$16=gdk_color_parse(colorname[(signed long int)i], &root_color[(signed long int)i]);
    if(return_value_gdk_color_parse$16 == 0)
      fprintf(stderr, "gdk_color_parse failed (%s)\n", colorname[(signed long int)i]);

    struct _GdkColormap *return_value_gtk_widget_get_colormap$17;
    return_value_gtk_widget_get_colormap$17=gtk_widget_get_colormap(window_root);
    signed int return_value_gdk_color_alloc$18;
    return_value_gdk_color_alloc$18=gdk_color_alloc(return_value_gtk_widget_get_colormap$17, &root_color[(signed long int)i]);
    if(return_value_gdk_color_alloc$18 == 0)
      fprintf(stderr, "gdk_color_alloc failed\n");

  }
  inventory_init(window_root);
  info_init(window_root);
  keys_init(window_root);
  stats_init(window_root);
  config_init(window_root);
  pickup_init(window_root);
  msgctrl_init(window_root);
  init_create_character_window();
  load_window_positions(window_root);
  init_theme();
  load_theme((signed int)!(0 != 0));
  init_menu_items();
}

// inscribe_magical_scroll
// file item.c line 783
void inscribe_magical_scroll(struct item_struct *scroll, struct Spell_struct *spell)
{
  struct SockList sl;
  unsigned char buf[256l];
  snprintf((char *)buf, sizeof(unsigned char [256l]) /*256ul*/ , "inscribe 0 %d %d", scroll->tag, spell->tag);
  script_monitor_str((char *)buf);
  SockList_Init(&sl, buf);
  SockList_AddString(&sl, "inscribe ");
  SockList_AddChar(&sl, (char)0);
  SockList_AddInt(&sl, (unsigned int)scroll->tag);
  SockList_AddInt(&sl, spell->tag);
  SockList_Send(&sl, csocket.fd);
}

// insert_item_before_item
// file item.c line 72
static void insert_item_before_item(struct item_struct *newitem, struct item_struct *before)
{
  if(!(before->prev == ((struct item_struct *)NULL)))
    before->prev->next = newitem;

  else
    newitem->env->inv = newitem;
  newitem->prev = before->prev;
  before->prev = newitem;
  newitem->next = before;
  if(!(newitem->env == ((struct item_struct *)NULL)))
    newitem->env->inv_updated = (unsigned short int)1;

}

// inventory_get_styles
// file gtk2proto.h line 93
extern void inventory_get_styles(void)
{
  signed int i;
  struct _GtkStyle *tmp_style;
  i = 0;
  static signed int inventory_get_styles$$1$$has_init = 0;
  for( ; !(i >= 5); i = i + 1)
  {
    if(!(inventory_get_styles$$1$$has_init == 0))
    {
      if(!(inv_styles[(signed long int)i] == ((struct _GtkStyle *)NULL)))
        g_object_unref((void *)inv_styles[(signed long int)i]);

    }

    struct _GtkSettings *return_value_gtk_settings_get_default$1;
    return_value_gtk_settings_get_default$1=gtk_settings_get_default();
    tmp_style=gtk_rc_get_style_by_paths(return_value_gtk_settings_get_default$1, (const char *)(void *)0, Style_Names[(signed long int)i], (unsigned long int)(1 << 2));
    if(!(tmp_style == ((struct _GtkStyle *)NULL)))
    {
      void *return_value_g_object_ref$2;
      return_value_g_object_ref$2=g_object_ref((void *)tmp_style);
      inv_styles[(signed long int)i] = (struct _GtkStyle *)return_value_g_object_ref$2;
    }

    else
    {
      LOG((enum LogLevel)LOG_INFO, "inventory.c::inventory_get_styles", "Unable to find style for %s", Style_Names[(signed long int)i]);
      inv_styles[(signed long int)i] = (struct _GtkStyle *)(void *)0;
    }
  }
  inventory_get_styles$$1$$has_init = 1;
}

// inventory_init
// file inventory.c line 454
extern void inventory_init(struct _GtkWidget *window_root)
{
  signed int i;
  struct _GObject *return_value_gtk_builder_get_object$1;
  return_value_gtk_builder_get_object$1=gtk_builder_get_object(window_xml, "notebook_inv");
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
  inv_notebook = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
  struct _GObject *return_value_gtk_builder_get_object$4;
  return_value_gtk_builder_get_object$4=gtk_builder_get_object(window_xml, "treeview_look");
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$4, return_value_gtk_widget_get_type$5);
  treeview_look = (struct _GtkWidget *)return_value_g_type_check_instance_cast$6;
  struct _GObject *return_value_gtk_builder_get_object$7;
  return_value_gtk_builder_get_object$7=gtk_builder_get_object(window_xml, "label_stat_encumbrance_current");
  unsigned long int return_value_gtk_widget_get_type$8;
  return_value_gtk_widget_get_type$8=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$7, return_value_gtk_widget_get_type$8);
  encumbrance_current = (struct _GtkWidget *)return_value_g_type_check_instance_cast$9;
  struct _GObject *return_value_gtk_builder_get_object$10;
  return_value_gtk_builder_get_object$10=gtk_builder_get_object(window_xml, "label_stat_encumbrance_max");
  unsigned long int return_value_gtk_widget_get_type$11;
  return_value_gtk_widget_get_type$11=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$10, return_value_gtk_widget_get_type$11);
  encumbrance_max = (struct _GtkWidget *)return_value_g_type_check_instance_cast$12;
  struct _GObject *return_value_gtk_builder_get_object$13;
  return_value_gtk_builder_get_object$13=gtk_builder_get_object(window_xml, "inv_table");
  unsigned long int return_value_gtk_widget_get_type$14;
  return_value_gtk_widget_get_type$14=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$13, return_value_gtk_widget_get_type$14);
  inv_table = (struct _GtkWidget *)return_value_g_type_check_instance_cast$15;
  g_signal_connect_data((void *)inv_notebook, "switch_page", (void (*)(void))on_notebook_switch_page, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)inv_table, "expose_event", (void (*)(void))on_inv_table_expose_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)treeview_look, "row_collapsed", (void (*)(void))list_row_collapse, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  inv_table_tooltips=gtk_tooltips_new();
  gtk_tooltips_enable(inv_table_tooltips);
  memset((void *)inv_table_children, 0, sizeof(struct _GtkWidget *) /*8ul*/  * (unsigned long int)100 * (unsigned long int)20);
  unsigned long int return_value_gdk_color_get_type$16;
  return_value_gdk_color_get_type$16=gdk_color_get_type();
  unsigned long int return_value_gdk_color_get_type$17;
  return_value_gdk_color_get_type$17=gdk_color_get_type();
  unsigned long int return_value_pango_font_description_get_type$18;
  return_value_pango_font_description_get_type$18=pango_font_description_get_type();
  store_look=gtk_tree_store_new(10, (unsigned long int)(16 << 2), (unsigned long int)(20 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(17 << 2), return_value_gdk_color_get_type$16, (unsigned long int)(6 << 2), (unsigned long int)(16 << 2), return_value_gdk_color_get_type$17, return_value_pango_font_description_get_type$18);
  unsigned long int return_value_gtk_tree_view_get_type$19;
  return_value_gtk_tree_view_get_type$19=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)treeview_look, return_value_gtk_tree_view_get_type$19);
  unsigned long int return_value_gtk_tree_model_get_type$21;
  return_value_gtk_tree_model_get_type$21=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)store_look, return_value_gtk_tree_model_get_type$21);
  gtk_tree_view_set_model((struct _GtkTreeView *)return_value_g_type_check_instance_cast$20, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$22);
  setup_list_columns(treeview_look);
  i = 0;
  for( ; !(i >= 11); i = i + 1)
  {
    struct _GtkWidget *swindow;
    struct _GtkWidget *image;
    if(inv_notebooks[(signed long int)i].type == 0)
    {
      swindow=gtk_scrolled_window_new((struct _GtkAdjustment *)(void *)0, (struct _GtkAdjustment *)(void *)0);
      gtk_widget_show(swindow);
      unsigned long int return_value_gtk_scrolled_window_get_type$23;
      return_value_gtk_scrolled_window_get_type$23=gtk_scrolled_window_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
      return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)swindow, return_value_gtk_scrolled_window_get_type$23);
      gtk_scrolled_window_set_policy((struct _GtkScrolledWindow *)return_value_g_type_check_instance_cast$24, (enum anonymous$17)GTK_POLICY_NEVER, (enum anonymous$17)GTK_POLICY_ALWAYS);
      struct _GdkPixbuf *return_value_gdk_pixbuf_new_from_xpm_data$25;
      return_value_gdk_pixbuf_new_from_xpm_data$25=gdk_pixbuf_new_from_xpm_data((const char **)inv_notebooks[(signed long int)i].xpm);
      image=gtk_image_new_from_pixbuf(return_value_gdk_pixbuf_new_from_xpm_data$25);
      if(!(inv_notebooks[(signed long int)i].tooltip == ((const char *)NULL)))
      {
        struct _GtkWidget *eb;
        eb=gtk_event_box_new();
        gtk_widget_show(eb);
        unsigned long int return_value_gtk_container_get_type$26;
        return_value_gtk_container_get_type$26=gtk_container_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
        return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)eb, return_value_gtk_container_get_type$26);
        gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$27, image);
        gtk_widget_show(image);
        image = eb;
        gtk_tooltips_set_tip(inv_table_tooltips, image, inv_notebooks[(signed long int)i].tooltip, (const char *)(void *)0);
      }

      unsigned long int return_value_gtk_notebook_get_type$28;
      return_value_gtk_notebook_get_type$28=gtk_notebook_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
      return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)inv_notebook, return_value_gtk_notebook_get_type$28);
      gtk_notebook_insert_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$29, swindow, image, i);
      unsigned long int return_value_gdk_color_get_type$30;
      return_value_gdk_color_get_type$30=gdk_color_get_type();
      unsigned long int return_value_gdk_color_get_type$31;
      return_value_gdk_color_get_type$31=gdk_color_get_type();
      unsigned long int return_value_pango_font_description_get_type$32;
      return_value_pango_font_description_get_type$32=pango_font_description_get_type();
      inv_notebooks[(signed long int)i].treestore=gtk_tree_store_new(10, (unsigned long int)(16 << 2), (unsigned long int)(20 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(17 << 2), return_value_gdk_color_get_type$30, (unsigned long int)(6 << 2), (unsigned long int)(16 << 2), return_value_gdk_color_get_type$31, return_value_pango_font_description_get_type$32);
      unsigned long int return_value_gtk_tree_model_get_type$33;
      return_value_gtk_tree_model_get_type$33=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
      return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)inv_notebooks[(signed long int)i].treestore, return_value_gtk_tree_model_get_type$33);
      inv_notebooks[(signed long int)i].treeview=gtk_tree_view_new_with_model((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$34);
      g_signal_connect_data((void *)inv_notebooks[(signed long int)i].treeview, "row_collapsed", (void (*)(void))list_row_collapse, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
      setup_list_columns(inv_notebooks[(signed long int)i].treeview);
      gtk_widget_show(inv_notebooks[(signed long int)i].treeview);
      unsigned long int return_value_gtk_container_get_type$35;
      return_value_gtk_container_get_type$35=gtk_container_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
      return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)swindow, return_value_gtk_container_get_type$35);
      gtk_container_add((struct _GtkContainer *)return_value_g_type_check_instance_cast$36, inv_notebooks[(signed long int)i].treeview);
    }

  }
  unsigned long int return_value_gtk_notebook_get_type$37;
  return_value_gtk_notebook_get_type$37=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$38;
  return_value_g_type_check_instance_cast$38=g_type_check_instance_cast((struct _GTypeInstance *)inv_notebook, return_value_gtk_notebook_get_type$37);
  num_inv_notebook_pages=gtk_notebook_get_n_pages((struct _GtkNotebook *)return_value_g_type_check_instance_cast$38);
  unsigned long int return_value_gtk_notebook_get_type$39;
  return_value_gtk_notebook_get_type$39=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$40;
  return_value_g_type_check_instance_cast$40=g_type_check_instance_cast((struct _GTypeInstance *)inv_notebook, return_value_gtk_notebook_get_type$39);
  gtk_notebook_set_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$40, 0);
  if(!(num_inv_notebook_pages == 11))
    LOG((enum LogLevel)LOG_ERROR, "inventory.c::inventory_init", "num_inv_notebook_pages (%d) does not match NUM_INV_LISTS(%d)\n", num_inv_notebook_pages, 11);

}

// inventory_tick
// file inventory.c line 1295
extern void inventory_tick(void)
{
  animate_inventory();
  animate_look();
}

// item_actions
// file commands.c line 1627
void item_actions(struct item_struct *op)
{
  if(!(op == ((struct item_struct *)NULL)))
  {
    if(!(op->open == 0))
    {
      open_container(op);
      cpl.container = op;
    }

    else
      if(!(op->was_open == 0))
      {
        close_container(op);
        cpl.container = (struct item_struct *)(void *)0;
      }

  }

}

// item_event_container_clearing
// file inventory.c line 702
extern void item_event_container_clearing(struct item_struct *container)
{
  ;
}

// item_event_item_changed
// file inventory.c line 703
extern void item_event_item_changed(struct item_struct *it)
{
  ;
}

// item_event_item_deleting
// file inventory.c line 701
extern void item_event_item_deleting(struct item_struct *it)
{
  ;
}

// keybind_find
// file keys.c line 199
static struct keybind * keybind_find(unsigned int keysym, unsigned int flags, signed int scope)
{
  struct keybind *kb;
  struct keybind *tmp_if_expr$1;
  if(!(scope == 0))
    tmp_if_expr$1 = keys_global[(signed long int)(keysym % (unsigned int)257)];

  else
    tmp_if_expr$1 = keys_char[(signed long int)(keysym % (unsigned int)257)];
  kb = tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  for( ; !(kb == ((struct keybind *)NULL)); kb = kb->next)
  {
    if(kb->keysym == 0u)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = kb->keysym == keysym ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      if(!((16 & (signed int)kb->flags) == 0) || !((16u & flags) == 0u))
        return kb;

      if((15u & (unsigned int)(signed int)kb->flags) == (15u & flags))
        return kb;

    }

  }
  return (struct keybind *)(void *)0;
}

// keybind_free
// file keys.c line 302
static void keybind_free(struct keybind **entry)
{
  free((void *)(*entry)->command);
  (*entry)->command = (char *)(void *)0;
  free((void *)*entry);
  *entry = (struct keybind *)(void *)0;
}

// keybind_insert
// file keys.c line 228
static signed int keybind_insert(unsigned int keysym, unsigned int flags, const char *command)
{
  struct keybind **next_ptr;
  struct keybind *kb;
  signed int slot;
  signed int i;
  signed int dir;
  kb=keybind_find(keysym, flags, (signed int)(flags & (unsigned int)(1 << 6)));
  while(!(kb == ((struct keybind *)NULL)))
  {
    char *return_value_gdk_keyval_name$1;
    return_value_gdk_keyval_name$1=gdk_keyval_name(keysym);
    LOG((enum LogLevel)LOG_WARNING, "gtk-v2::keybind_insert", "Overwriting previous binding for key %s with command %s ", return_value_gdk_keyval_name$1, kb->command);
    keybind_remove(kb);
    keybind_free(&kb);
    kb=keybind_find(keysym, flags, (signed int)(flags & (unsigned int)(1 << 6)));
  }
  slot = (signed int)(keysym % (unsigned int)257);
  struct keybind **tmp_if_expr$2;
  if(!((64u & flags) == 0u))
    tmp_if_expr$2 = &keys_global[(signed long int)slot];

  else
    tmp_if_expr$2 = &keys_char[(signed long int)slot];
  next_ptr = tmp_if_expr$2;
  for( ; !(*next_ptr == ((struct keybind *)NULL)); next_ptr = &(*next_ptr)->next)
    ;
  void *return_value_calloc$3;
  return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct keybind) /*24ul*/ );
  *next_ptr = (struct keybind *)return_value_calloc$3;
  if(*next_ptr == ((struct keybind *)NULL))
    return -1;

  else
  {
    (*next_ptr)->keysym = keysym;
    (*next_ptr)->flags = (unsigned char)flags;
    (*next_ptr)->command=strdup_local(command);
    dir = -1;
    i = 0;
    for( ; !(i >= 9); i = i + 1)
    {
      signed int return_value_strcmp$4;
      return_value_strcmp$4=strcmp(command, directions[(signed long int)i]);
      if(return_value_strcmp$4 == 0)
      {
        dir = i;
        break;
      }

    }
    (*next_ptr)->direction = (signed char)dir;
    return 0;
  }
}

// keybind_overwrite_confirm
// file keys.c line 2085
static signed int keybind_overwrite_confirm(struct keybind *kb)
{
  struct _GtkWidget *dialog;
  struct _GtkWidget *label;
  signed int result;
  char buf[256l];
  char buf2[256l];
  unsigned long int return_value_gtk_window_get_type$1;
  return_value_gtk_window_get_type$1=gtk_window_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_window, return_value_gtk_window_get_type$1);
  dialog=gtk_dialog_new_with_buttons("Key already in use", (struct _GtkWindow *)return_value_g_type_check_instance_cast$2, (enum anonymous$40)GTK_DIALOG_MODAL, "gtk-yes", 1, (const void *)"gtk-no", 2, (void *)0);
  get_key_modchars(kb, 1, buf2);
  char *return_value_gdk_keyval_name$3;
  return_value_gdk_keyval_name$3=gdk_keyval_name(kb->keysym);
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Overwrite this binding?\n  (%s) %s\n%s", (const void *)buf2, return_value_gdk_keyval_name$3, kb->command);
  label=gtk_label_new(buf);
  unsigned long int return_value_gtk_dialog_get_type$4;
  return_value_gtk_dialog_get_type$4=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$4);
  struct _GtkWidget *return_value_gtk_dialog_get_content_area$6;
  return_value_gtk_dialog_get_content_area$6=gtk_dialog_get_content_area((struct _GtkDialog *)return_value_g_type_check_instance_cast$5);
  unsigned long int return_value_gtk_box_get_type$7;
  return_value_gtk_box_get_type$7=gtk_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_dialog_get_content_area$6, return_value_gtk_box_get_type$7);
  gtk_box_pack_start((struct _GtkBox *)return_value_g_type_check_instance_cast$8, label, (signed int)!(0 != 0), (signed int)!(0 != 0), (unsigned int)0);
  gtk_widget_show_all(dialog);
  unsigned long int return_value_gtk_dialog_get_type$9;
  return_value_gtk_dialog_get_type$9=gtk_dialog_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)dialog, return_value_gtk_dialog_get_type$9);
  result=gtk_dialog_run((struct _GtkDialog *)return_value_g_type_check_instance_cast$10);
  gtk_widget_destroy(dialog);
  return (signed int)(result == 1);
}

// keybind_remove
// file keys.c line 282
static signed int keybind_remove(struct keybind *entry)
{
  struct keybind **next_ptr;
  signed int slot = (signed int)(entry->keysym % (unsigned int)257);
  struct keybind **tmp_if_expr$1;
  if(!((64 & (signed int)entry->flags) == 0))
    tmp_if_expr$1 = &keys_global[(signed long int)slot];

  else
    tmp_if_expr$1 = &keys_char[(signed long int)slot];
  next_ptr = tmp_if_expr$1;
  for( ; !(*next_ptr == ((struct keybind *)NULL)); next_ptr = &(*next_ptr)->next)
    if(*next_ptr == entry)
    {
      *next_ptr = entry->next;
      return 0;
    }

  return -1;
}

// keybinding_get_data
// file keys.c line 2272
static void keybinding_get_data(unsigned int *keysym, unsigned char *flags, const char **command)
{
  const char *ed;
  *flags = (unsigned char)0;
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_any, return_value_gtk_toggle_button_get_type$1);
  signed int return_value_gtk_toggle_button_get_active$3;
  return_value_gtk_toggle_button_get_active$3=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2);
  if(!(return_value_gtk_toggle_button_get_active$3 == 0))
    *flags = *flags | (unsigned char)(1 << 4);

  unsigned long int return_value_gtk_toggle_button_get_type$4;
  return_value_gtk_toggle_button_get_type$4=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)kb_scope_togglebutton_global, return_value_gtk_toggle_button_get_type$4);
  signed int return_value_gtk_toggle_button_get_active$6;
  return_value_gtk_toggle_button_get_active$6=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$5);
  if(!(return_value_gtk_toggle_button_get_active$6 == 0))
    *flags = *flags | (unsigned char)(1 << 6);

  unsigned long int return_value_gtk_toggle_button_get_type$7;
  return_value_gtk_toggle_button_get_type$7=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_control, return_value_gtk_toggle_button_get_type$7);
  signed int return_value_gtk_toggle_button_get_active$9;
  return_value_gtk_toggle_button_get_active$9=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$8);
  if(!(return_value_gtk_toggle_button_get_active$9 == 0))
    *flags = *flags | (unsigned char)(1 << 1);

  unsigned long int return_value_gtk_toggle_button_get_type$10;
  return_value_gtk_toggle_button_get_type$10=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_shift, return_value_gtk_toggle_button_get_type$10);
  signed int return_value_gtk_toggle_button_get_active$12;
  return_value_gtk_toggle_button_get_active$12=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$11);
  if(!(return_value_gtk_toggle_button_get_active$12 == 0))
    *flags = *flags | (unsigned char)(1 << 0);

  unsigned long int return_value_gtk_toggle_button_get_type$13;
  return_value_gtk_toggle_button_get_type$13=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_alt, return_value_gtk_toggle_button_get_type$13);
  signed int return_value_gtk_toggle_button_get_active$15;
  return_value_gtk_toggle_button_get_active$15=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$14);
  if(!(return_value_gtk_toggle_button_get_active$15 == 0))
    *flags = *flags | (unsigned char)(1 << 2);

  unsigned long int return_value_gtk_toggle_button_get_type$16;
  return_value_gtk_toggle_button_get_type$16=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_meta, return_value_gtk_toggle_button_get_type$16);
  signed int return_value_gtk_toggle_button_get_active$18;
  return_value_gtk_toggle_button_get_active$18=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$17);
  if(!(return_value_gtk_toggle_button_get_active$18 == 0))
    *flags = *flags | (unsigned char)(1 << 3);

  unsigned long int return_value_gtk_toggle_button_get_type$19;
  return_value_gtk_toggle_button_get_type$19=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_edit, return_value_gtk_toggle_button_get_type$19);
  signed int return_value_gtk_toggle_button_get_active$21;
  return_value_gtk_toggle_button_get_active$21=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$20);
  if(!(return_value_gtk_toggle_button_get_active$21 == 0))
    *flags = *flags | (unsigned char)(1 << 5);

  unsigned long int return_value_gtk_entry_get_type$22;
  return_value_gtk_entry_get_type$22=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
  return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_entry_command, return_value_gtk_entry_get_type$22);
  ed=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$23);
  unsigned long int return_value_strlen$24;
  return_value_strlen$24=strlen(ed);
  if(return_value_strlen$24 >= sizeof(char [256l]) /*256ul*/ )
  {
    draw_ext_info(3, 20, 9, "Keybinding too long! Truncated.");
    static char keybinding_get_data$$1$$bind_buf[256l];
    strncpy(keybinding_get_data$$1$$bind_buf, ed, (unsigned long int)(256 - 1));
    keybinding_get_data$$1$$bind_buf[(signed long int)(256 - 1)] = (char)0;
    *command = keybinding_get_data$$1$$bind_buf;
  }

  else
    *command = ed;
  unsigned long int return_value_gtk_entry_get_type$25;
  return_value_gtk_entry_get_type$25=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_entry_key, return_value_gtk_entry_get_type$25);
  const char *return_value_gtk_entry_get_text$27;
  return_value_gtk_entry_get_text$27=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$26);
  *keysym=gdk_keyval_from_name(return_value_gtk_entry_get_text$27);
  if(*keysym == 16777215u)
    LOG((enum LogLevel)LOG_ERROR, "keys.c::keybinding_get_data", "Cannot get valid keysym from selection");

}

// keybinding_selection_func
// file keys.c line 2456
extern signed int keybinding_selection_func(struct _GtkTreeSelection *selection, struct _GtkTreeModel *model, struct _GtkTreePath *path, signed int path_currently_selected, void *userdata)
{
  struct _GtkTreeIter iter;
  struct keybind *kb;
  gtk_widget_set_sensitive(keybinding_button_remove, (signed int)!(0 != 0));
  gtk_widget_set_sensitive(keybinding_button_update, (signed int)!(0 != 0));
  signed int return_value_gtk_tree_model_get_iter$30;
  return_value_gtk_tree_model_get_iter$30=gtk_tree_model_get_iter(model, &iter, path);
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  unsigned long int return_value_gtk_toggle_button_get_type$3;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  unsigned long int return_value_gtk_toggle_button_get_type$5;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  unsigned long int return_value_gtk_toggle_button_get_type$7;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  unsigned long int return_value_gtk_toggle_button_get_type$9;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  unsigned long int return_value_gtk_toggle_button_get_type$11;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  unsigned long int return_value_gtk_toggle_button_get_type$13;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  unsigned long int return_value_gtk_toggle_button_get_type$15;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  unsigned long int return_value_gtk_toggle_button_get_type$17;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  unsigned long int return_value_gtk_toggle_button_get_type$19;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  unsigned long int return_value_gtk_toggle_button_get_type$21;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  unsigned long int return_value_gtk_toggle_button_get_type$23;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  if(!(return_value_gtk_tree_model_get_iter$30 == 0))
  {
    gtk_tree_model_get(model, &iter, 6, &kb, -1);
    if(kb == ((struct keybind *)NULL))
    {
      LOG((enum LogLevel)LOG_ERROR, "keys.c::keybinding_selection_func", "Unable to get key_entry structure\n");
      return 0;
    }

    if(!((16 & (signed int)kb->flags) == 0))
    {
      return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_any, return_value_gtk_toggle_button_get_type$1);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2, (signed int)!(0 != 0));
    }

    else
    {
      return_value_gtk_toggle_button_get_type$3=gtk_toggle_button_get_type();
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_any, return_value_gtk_toggle_button_get_type$3);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$4, 0);
    }
    if(!((2 & (signed int)kb->flags) == 0))
    {
      return_value_gtk_toggle_button_get_type$5=gtk_toggle_button_get_type();
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_control, return_value_gtk_toggle_button_get_type$5);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$6, (signed int)!(0 != 0));
    }

    else
    {
      return_value_gtk_toggle_button_get_type$7=gtk_toggle_button_get_type();
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_control, return_value_gtk_toggle_button_get_type$7);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$8, 0);
    }
    if(!((1 & (signed int)kb->flags) == 0))
    {
      return_value_gtk_toggle_button_get_type$9=gtk_toggle_button_get_type();
      return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_shift, return_value_gtk_toggle_button_get_type$9);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$10, (signed int)!(0 != 0));
    }

    else
    {
      return_value_gtk_toggle_button_get_type$11=gtk_toggle_button_get_type();
      return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_shift, return_value_gtk_toggle_button_get_type$11);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$12, 0);
    }
    if(!((4 & (signed int)kb->flags) == 0))
    {
      return_value_gtk_toggle_button_get_type$13=gtk_toggle_button_get_type();
      return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_alt, return_value_gtk_toggle_button_get_type$13);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$14, (signed int)!(0 != 0));
    }

    else
    {
      return_value_gtk_toggle_button_get_type$15=gtk_toggle_button_get_type();
      return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_alt, return_value_gtk_toggle_button_get_type$15);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$16, 0);
    }
    if(!((8 & (signed int)kb->flags) == 0))
    {
      return_value_gtk_toggle_button_get_type$17=gtk_toggle_button_get_type();
      return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_meta, return_value_gtk_toggle_button_get_type$17);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$18, (signed int)!(0 != 0));
    }

    else
    {
      return_value_gtk_toggle_button_get_type$19=gtk_toggle_button_get_type();
      return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_meta, return_value_gtk_toggle_button_get_type$19);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$20, 0);
    }
    if(!((32 & (signed int)kb->flags) == 0))
    {
      return_value_gtk_toggle_button_get_type$21=gtk_toggle_button_get_type();
      return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_edit, return_value_gtk_toggle_button_get_type$21);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$22, (signed int)!(0 != 0));
    }

    else
    {
      return_value_gtk_toggle_button_get_type$23=gtk_toggle_button_get_type();
      return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_edit, return_value_gtk_toggle_button_get_type$23);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$24, 0);
    }
    unsigned long int return_value_gtk_entry_get_type$25;
    return_value_gtk_entry_get_type$25=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
    return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_entry_key, return_value_gtk_entry_get_type$25);
    char *return_value_gdk_keyval_name$27;
    return_value_gdk_keyval_name$27=gdk_keyval_name(kb->keysym);
    gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$26, return_value_gdk_keyval_name$27);
    unsigned long int return_value_gtk_entry_get_type$28;
    return_value_gtk_entry_get_type$28=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
    return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_entry_command, return_value_gtk_entry_get_type$28);
    gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$29, kb->command);
    toggle_buttons_scope((signed int)(((signed int)kb->flags & 1 << 6) != 0));
  }

  return (signed int)!(0 != 0);
}

// keybindings_init
// file gtk2proto.h line 117
extern void keybindings_init(const char *character_name)
{
  char buf[1024l];
  signed int i = 0;
  for( ; !(i >= 50); i = i + 1)
    history[(signed long int)i][(signed long int)0] = (char)0;
  commandkeysym = (unsigned int)0x027;
  firekeysym[(signed long int)0] = (unsigned int)0xffe1;
  firekeysym[(signed long int)1] = (unsigned int)0xffe2;
  runkeysym[(signed long int)0] = (unsigned int)0xffe3;
  runkeysym[(signed long int)1] = (unsigned int)0xffe4;
  metakeysym[(signed long int)0] = (unsigned int)0xffe7;
  metakeysym[(signed long int)1] = (unsigned int)0xffe8;
  altkeysym[(signed long int)0] = (unsigned int)0xffe9;
  altkeysym[(signed long int)1] = (unsigned int)0xffea;
  completekeysym = (unsigned int)0xff09;
  cancelkeysym = (unsigned int)0xff1b;
  nextkeysym = (unsigned int)0L;
  prevkeysym = (unsigned int)0L;
  i = 0;
  for( ; !(i >= 257); i = i + 1)
  {
    while(!(keys_global[(signed long int)i] == ((struct keybind *)NULL)))
      keybind_remove(keys_global[(signed long int)i]);
    while(!(keys_char[(signed long int)i] == ((struct keybind *)NULL)))
      keybind_remove(keys_char[(signed long int)i]);
  }
  if(!(cpl.name == ((char *)NULL)))
  {
    free((void *)cpl.name);
    cpl.name = (char *)(void *)0;
  }

  if(!(character_name == ((const char *)NULL)))
    cpl.name=strdup(character_name);

  init_default_keybindings();
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("HOME");
  snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%s/.crossfire/keys", return_value_getenv$1);
  parse_keys_file(buf, (unsigned int)(1 << 6));
  if(!(cpl.name == ((char *)NULL)))
  {
    char *return_value_getenv$2;
    return_value_getenv$2=getenv("HOME");
    snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%s/.crossfire/%s.%s.keys", return_value_getenv$2, csocket.servername, cpl.name);
    parse_keys_file(buf, (unsigned int)(1 << 7));
  }

}

// keyfunc
// file keys.c line 1570
extern void keyfunc(struct _GtkWidget *widget, struct _GdkEventKey *event, struct _GtkWidget *window)
{
  char *text;
  if(use_config[9l] == 0)
  {
    if((signed int)cpl.input_state == Reply_One || (signed int)cpl.input_state == Reply_Many)
    {
      if(event->keyval == cancelkeysym)
      {
        close_server_connection();
        if(!(csocket_fd == 0))
        {
          gdk_input_remove(csocket_fd);
          csocket_fd = 0;
          gtk_main_quit();
        }

        unsigned long int return_value_gtk_object_get_type$1;
        return_value_gtk_object_get_type$1=gtk_object_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
        return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_object_get_type$1);
        g_signal_stop_emission_by_name((void *)(struct _GtkObject *)return_value_g_type_check_instance_cast$2, "key_press_event");
        goto __CPROVER_DUMP_L35;
      }

    }

    if((signed int)cpl.input_state == Reply_One)
    {
      text=gdk_keyval_name(event->keyval);
      send_reply(text);
      cpl.input_state = (enum Input_State)Playing;
      unsigned long int return_value_gtk_object_get_type$3;
      return_value_gtk_object_get_type$3=gtk_object_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_object_get_type$3);
      g_signal_stop_emission_by_name((void *)(struct _GtkObject *)return_value_g_type_check_instance_cast$4, "key_press_event");
      goto __CPROVER_DUMP_L35;
    }

    else
      if((signed int)cpl.input_state == Reply_Many)
      {
        unsigned long int return_value_gtk_object_get_type$9;
        return_value_gtk_object_get_type$9=gtk_object_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
        return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_object_get_type$9);
        if(!((4096u & ((struct _GtkObject *)return_value_g_type_check_instance_cast$10)->flags) == 0u))
        {
          unsigned long int return_value_gtk_widget_get_type$5;
          return_value_gtk_widget_get_type$5=gtk_widget_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
          return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_widget_get_type$5);
          gtk_widget_event((struct _GtkWidget *)return_value_g_type_check_instance_cast$6, (union _GdkEvent *)event);
        }

        else
        {
          unsigned long int return_value_gtk_widget_get_type$7;
          return_value_gtk_widget_get_type$7=gtk_widget_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
          return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_widget_get_type$7);
          gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$8);
        }
        unsigned long int return_value_gtk_object_get_type$11;
        return_value_gtk_object_get_type$11=gtk_object_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
        return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_object_get_type$11);
        g_signal_stop_emission_by_name((void *)(struct _GtkObject *)return_value_g_type_check_instance_cast$12, "key_press_event");
        goto __CPROVER_DUMP_L35;
      }

  }

  _Bool tmp_if_expr$15;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$28;
  unsigned long int return_value_gtk_widget_get_type$24;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
  unsigned long int return_value_gtk_widget_get_type$29;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  if(event->keyval >= 1u)
  {
    unsigned long int return_value_gtk_object_get_type$31;
    return_value_gtk_object_get_type$31=gtk_object_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
    return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_object_get_type$31);
    if(!((4096u & ((struct _GtkObject *)return_value_g_type_check_instance_cast$32)->flags) == 0u))
    {
      if(event->keyval == completekeysym)
        gtk_complete_command();

      if(event->keyval == prevkeysym)
        tmp_if_expr$15 = (_Bool)1;

      else
        tmp_if_expr$15 = event->keyval == nextkeysym ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$15)
        gtk_command_history(event->keyval == nextkeysym ? 0 : 1);

      else
      {
        unsigned long int return_value_gtk_widget_get_type$13;
        return_value_gtk_widget_get_type$13=gtk_widget_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
        return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_widget_get_type$13);
        gtk_widget_event((struct _GtkWidget *)return_value_g_type_check_instance_cast$14, (union _GdkEvent *)event);
      }
    }

    else
      switch((signed int)cpl.input_state)
      {
        case Playing:
        {
          if(event->keyval == prevkeysym)
            tmp_if_expr$21 = (_Bool)1;

          else
            tmp_if_expr$21 = event->keyval == nextkeysym ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$21)
            gtk_command_history(event->keyval == nextkeysym ? 0 : 1);

          else
          {
            if(!(cpl.run_on == 0u))
            {
              if((4u & event->state) == 0u)
              {
                unsigned long int return_value_gtk_label_get_type$16;
                return_value_gtk_label_get_type$16=gtk_label_get_type();
                struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
                return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)run_label, return_value_gtk_label_get_type$16);
                gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$17, "   ");
                cpl.run_on = (unsigned int)0;
                stop_run();
              }

            }

            if(!(cpl.fire_on == 0u))
            {
              if((1u & event->state) == 0u)
              {
                unsigned long int return_value_gtk_label_get_type$18;
                return_value_gtk_label_get_type$18=gtk_label_get_type();
                struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
                return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)fire_label, return_value_gtk_label_get_type$18);
                gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$19, "   ");
                cpl.fire_on = (unsigned int)0;
                stop_fire();
              }

            }

            if(!((4u & event->state) == 0u))
            {
              if(!((1u & event->state) == 0u))
              {
                if(event->keyval == 105u)
                  tmp_if_expr$20 = (_Bool)1;

                else
                  tmp_if_expr$20 = event->keyval == (unsigned int)0x049 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$20)
                  reset_map();

              }

            }

            parse_key(event->string[(signed long int)0], event->keyval);
          }
          break;
        }
        case Configure_Keys:
        {
          configure_keys(event->keyval);
          break;
        }
        case Command_Mode:
        {
          if(event->keyval == completekeysym)
            gtk_complete_command();

          if(event->keyval == prevkeysym)
            tmp_if_expr$28 = (_Bool)1;

          else
            tmp_if_expr$28 = event->keyval == nextkeysym ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$28)
            gtk_command_history(event->keyval == nextkeysym ? 0 : 1);

          else
          {
            unsigned long int return_value_gtk_widget_get_type$22;
            return_value_gtk_widget_get_type$22=gtk_widget_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
            return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_widget_get_type$22);
            gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$23);
            unsigned long int return_value_gtk_object_get_type$26;
            return_value_gtk_object_get_type$26=gtk_object_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
            return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_object_get_type$26);
            if((4096u & ((struct _GtkObject *)return_value_g_type_check_instance_cast$27)->flags) == 0u)
            {
              return_value_gtk_widget_get_type$24=gtk_widget_get_type();
              return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_widget_get_type$24);
              gtk_widget_event((struct _GtkWidget *)return_value_g_type_check_instance_cast$25, (union _GdkEvent *)event);
            }

          }
          break;
        }
        case Metaserver_Select:
        {
          return_value_gtk_widget_get_type$29=gtk_widget_get_type();
          return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_widget_get_type$29);
          gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$30);
          break;
        }
        default:
          LOG((enum LogLevel)LOG_ERROR, "gtk-v2::keyfunc", "Unknown input state: %d", cpl.input_state);
      }
  }

  unsigned long int return_value_gtk_object_get_type$33;
  return_value_gtk_object_get_type$33=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
  return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_object_get_type$33);
  g_signal_stop_emission_by_name((void *)(struct _GtkObject *)return_value_g_type_check_instance_cast$34, "key_press_event");

__CPROVER_DUMP_L35:
  ;
}

// keyrelfunc
// file keys.c line 1556
extern void keyrelfunc(struct _GtkWidget *widget, struct _GdkEventKey *event, struct _GtkWidget *window)
{
  unsigned long int return_value_gtk_object_get_type$1;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  if(event->keyval >= 1u)
  {
    return_value_gtk_object_get_type$1=gtk_object_get_type();
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_object_get_type$1);
    if((4096u & ((struct _GtkObject *)return_value_g_type_check_instance_cast$2)->flags) == 0u)
      parse_key_release(event->keyval);

  }

  unsigned long int return_value_gtk_object_get_type$3;
  return_value_gtk_object_get_type$3=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)window, return_value_gtk_object_get_type$3);
  g_signal_stop_emission_by_name((void *)(struct _GtkObject *)return_value_g_type_check_instance_cast$4, "key_release_event");
}

// keys_init
// file keys.c line 633
extern void keys_init(struct _GtkWidget *window_root)
{
  struct _GtkTreeViewColumn *column;
  struct _GtkCellRenderer *renderer;
  struct _GtkWidget *widget;
  signed int i;
  struct _GObject *return_value_gtk_builder_get_object$1;
  return_value_gtk_builder_get_object$1=gtk_builder_get_object(window_xml, "fire_label");
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
  fire_label = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
  struct _GObject *return_value_gtk_builder_get_object$4;
  return_value_gtk_builder_get_object$4=gtk_builder_get_object(window_xml, "run_label");
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$4, return_value_gtk_widget_get_type$5);
  run_label = (struct _GtkWidget *)return_value_g_type_check_instance_cast$6;
  struct _GObject *return_value_gtk_builder_get_object$7;
  return_value_gtk_builder_get_object$7=gtk_builder_get_object(window_xml, "entry_commands");
  unsigned long int return_value_gtk_widget_get_type$8;
  return_value_gtk_widget_get_type$8=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$7, return_value_gtk_widget_get_type$8);
  entry_commands = (struct _GtkWidget *)return_value_g_type_check_instance_cast$9;
  struct _GObject *return_value_gtk_builder_get_object$10;
  return_value_gtk_builder_get_object$10=gtk_builder_get_object(window_xml, "spinbutton_count");
  unsigned long int return_value_gtk_widget_get_type$11;
  return_value_gtk_widget_get_type$11=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$10, return_value_gtk_widget_get_type$11);
  spinbutton_count = (struct _GtkWidget *)return_value_g_type_check_instance_cast$12;
  g_signal_connect_data((void *)entry_commands, "activate", (void (*)(void))on_entry_commands_activate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$13;
  return_value_gtk_builder_get_object$13=gtk_builder_get_object(dialog_xml, "keybinding_window");
  unsigned long int return_value_gtk_widget_get_type$14;
  return_value_gtk_widget_get_type$14=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$13, return_value_gtk_widget_get_type$14);
  keybinding_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$15;
  struct _GObject *return_value_gtk_builder_get_object$16;
  return_value_gtk_builder_get_object$16=gtk_builder_get_object(dialog_xml, "kb_scope_togglebutton_global");
  unsigned long int return_value_gtk_widget_get_type$17;
  return_value_gtk_widget_get_type$17=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$16, return_value_gtk_widget_get_type$17);
  kb_scope_togglebutton_global = (struct _GtkWidget *)return_value_g_type_check_instance_cast$18;
  struct _GObject *return_value_gtk_builder_get_object$19;
  return_value_gtk_builder_get_object$19=gtk_builder_get_object(dialog_xml, "kb_scope_togglebutton_character");
  unsigned long int return_value_gtk_widget_get_type$20;
  return_value_gtk_widget_get_type$20=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
  return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$19, return_value_gtk_widget_get_type$20);
  kb_scope_togglebutton_character = (struct _GtkWidget *)return_value_g_type_check_instance_cast$21;
  struct _GObject *return_value_gtk_builder_get_object$22;
  return_value_gtk_builder_get_object$22=gtk_builder_get_object(dialog_xml, "keybinding_checkbutton_any");
  unsigned long int return_value_gtk_widget_get_type$23;
  return_value_gtk_widget_get_type$23=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$22, return_value_gtk_widget_get_type$23);
  keybinding_checkbutton_any = (struct _GtkWidget *)return_value_g_type_check_instance_cast$24;
  struct _GObject *return_value_gtk_builder_get_object$25;
  return_value_gtk_builder_get_object$25=gtk_builder_get_object(dialog_xml, "keybinding_checkbutton_control");
  unsigned long int return_value_gtk_widget_get_type$26;
  return_value_gtk_widget_get_type$26=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
  return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$25, return_value_gtk_widget_get_type$26);
  keybinding_checkbutton_control = (struct _GtkWidget *)return_value_g_type_check_instance_cast$27;
  struct _GObject *return_value_gtk_builder_get_object$28;
  return_value_gtk_builder_get_object$28=gtk_builder_get_object(dialog_xml, "keybinding_checkbutton_shift");
  unsigned long int return_value_gtk_widget_get_type$29;
  return_value_gtk_widget_get_type$29=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$28, return_value_gtk_widget_get_type$29);
  keybinding_checkbutton_shift = (struct _GtkWidget *)return_value_g_type_check_instance_cast$30;
  struct _GObject *return_value_gtk_builder_get_object$31;
  return_value_gtk_builder_get_object$31=gtk_builder_get_object(dialog_xml, "keybinding_checkbutton_alt");
  unsigned long int return_value_gtk_widget_get_type$32;
  return_value_gtk_widget_get_type$32=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
  return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$31, return_value_gtk_widget_get_type$32);
  keybinding_checkbutton_alt = (struct _GtkWidget *)return_value_g_type_check_instance_cast$33;
  struct _GObject *return_value_gtk_builder_get_object$34;
  return_value_gtk_builder_get_object$34=gtk_builder_get_object(dialog_xml, "keybinding_checkbutton_meta");
  unsigned long int return_value_gtk_widget_get_type$35;
  return_value_gtk_widget_get_type$35=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
  return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$34, return_value_gtk_widget_get_type$35);
  keybinding_checkbutton_meta = (struct _GtkWidget *)return_value_g_type_check_instance_cast$36;
  struct _GObject *return_value_gtk_builder_get_object$37;
  return_value_gtk_builder_get_object$37=gtk_builder_get_object(dialog_xml, "keybinding_checkbutton_stayinedit");
  unsigned long int return_value_gtk_widget_get_type$38;
  return_value_gtk_widget_get_type$38=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$39;
  return_value_g_type_check_instance_cast$39=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$37, return_value_gtk_widget_get_type$38);
  keybinding_checkbutton_edit = (struct _GtkWidget *)return_value_g_type_check_instance_cast$39;
  struct _GObject *return_value_gtk_builder_get_object$40;
  return_value_gtk_builder_get_object$40=gtk_builder_get_object(dialog_xml, "keybinding_entry_key");
  unsigned long int return_value_gtk_widget_get_type$41;
  return_value_gtk_widget_get_type$41=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$42;
  return_value_g_type_check_instance_cast$42=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$40, return_value_gtk_widget_get_type$41);
  keybinding_entry_key = (struct _GtkWidget *)return_value_g_type_check_instance_cast$42;
  struct _GObject *return_value_gtk_builder_get_object$43;
  return_value_gtk_builder_get_object$43=gtk_builder_get_object(dialog_xml, "keybinding_entry_command");
  unsigned long int return_value_gtk_widget_get_type$44;
  return_value_gtk_widget_get_type$44=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$45;
  return_value_g_type_check_instance_cast$45=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$43, return_value_gtk_widget_get_type$44);
  keybinding_entry_command = (struct _GtkWidget *)return_value_g_type_check_instance_cast$45;
  struct _GObject *return_value_gtk_builder_get_object$46;
  return_value_gtk_builder_get_object$46=gtk_builder_get_object(dialog_xml, "keybinding_treeview");
  unsigned long int return_value_gtk_widget_get_type$47;
  return_value_gtk_widget_get_type$47=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$48;
  return_value_g_type_check_instance_cast$48=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$46, return_value_gtk_widget_get_type$47);
  keybinding_treeview = (struct _GtkWidget *)return_value_g_type_check_instance_cast$48;
  struct _GObject *return_value_gtk_builder_get_object$49;
  return_value_gtk_builder_get_object$49=gtk_builder_get_object(dialog_xml, "keybinding_button_remove");
  unsigned long int return_value_gtk_widget_get_type$50;
  return_value_gtk_widget_get_type$50=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$51;
  return_value_g_type_check_instance_cast$51=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$49, return_value_gtk_widget_get_type$50);
  keybinding_button_remove = (struct _GtkWidget *)return_value_g_type_check_instance_cast$51;
  struct _GObject *return_value_gtk_builder_get_object$52;
  return_value_gtk_builder_get_object$52=gtk_builder_get_object(dialog_xml, "keybinding_button_update");
  unsigned long int return_value_gtk_widget_get_type$53;
  return_value_gtk_widget_get_type$53=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$54;
  return_value_g_type_check_instance_cast$54=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$52, return_value_gtk_widget_get_type$53);
  keybinding_button_update = (struct _GtkWidget *)return_value_g_type_check_instance_cast$54;
  struct _GObject *return_value_gtk_builder_get_object$55;
  return_value_gtk_builder_get_object$55=gtk_builder_get_object(dialog_xml, "keybinding_button_bind");
  unsigned long int return_value_gtk_widget_get_type$56;
  return_value_gtk_widget_get_type$56=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$57;
  return_value_g_type_check_instance_cast$57=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$55, return_value_gtk_widget_get_type$56);
  keybinding_button_bind = (struct _GtkWidget *)return_value_g_type_check_instance_cast$57;
  g_signal_connect_data((void *)keybinding_window, "delete_event", (void (*)(void))gtk_widget_hide_on_delete, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)keybinding_entry_key, "key_press_event", (void (*)(void))on_keybinding_entry_key_key_press_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)keybinding_button_remove, "clicked", (void (*)(void))on_keybinding_button_remove_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)keybinding_button_update, "clicked", (void (*)(void))on_keybinding_button_update_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)keybinding_button_bind, "clicked", (void (*)(void))on_keybinding_button_bind_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)kb_scope_togglebutton_character, "toggled", (void (*)(void))on_kb_scope_togglebutton_character_toggled, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)kb_scope_togglebutton_global, "toggled", (void (*)(void))on_kb_scope_togglebutton_global_toggled, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)keybinding_checkbutton_any, "clicked", (void (*)(void))on_keybinding_checkbutton_any_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$58;
  return_value_gtk_builder_get_object$58=gtk_builder_get_object(dialog_xml, "keybinding_button_clear");
  unsigned long int return_value_gtk_widget_get_type$59;
  return_value_gtk_widget_get_type$59=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$60;
  return_value_g_type_check_instance_cast$60=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$58, return_value_gtk_widget_get_type$59);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$60;
  g_signal_connect_data((void *)widget, "clicked", (void (*)(void))on_keybinding_button_clear_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$61;
  return_value_gtk_builder_get_object$61=gtk_builder_get_object(dialog_xml, "keybinding_button_close");
  unsigned long int return_value_gtk_widget_get_type$62;
  return_value_gtk_widget_get_type$62=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$63;
  return_value_g_type_check_instance_cast$63=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$61, return_value_gtk_widget_get_type$62);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$63;
  g_signal_connect_data((void *)widget, "clicked", (void (*)(void))on_keybinding_button_close_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  gtk_widget_set_sensitive(keybinding_button_remove, 0);
  gtk_widget_set_sensitive(keybinding_button_update, 0);
  keybinding_store=gtk_list_store_new(7, (unsigned long int)(6 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(16 << 2), (unsigned long int)(17 << 2));
  unsigned long int return_value_gtk_tree_view_get_type$64;
  return_value_gtk_tree_view_get_type$64=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$65;
  return_value_g_type_check_instance_cast$65=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_treeview, return_value_gtk_tree_view_get_type$64);
  unsigned long int return_value_gtk_tree_model_get_type$66;
  return_value_gtk_tree_model_get_type$66=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$67;
  return_value_g_type_check_instance_cast$67=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_store, return_value_gtk_tree_model_get_type$66);
  gtk_tree_view_set_model((struct _GtkTreeView *)return_value_g_type_check_instance_cast$65, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$67);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes("Key", renderer, (const void *)"text", 1, (void *)0);
  gtk_tree_view_column_set_sort_column_id(column, 1);
  unsigned long int return_value_gtk_tree_view_get_type$68;
  return_value_gtk_tree_view_get_type$68=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$69;
  return_value_g_type_check_instance_cast$69=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_treeview, return_value_gtk_tree_view_get_type$68);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$69, column);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes("Modifiers", renderer, (const void *)"text", 2, (void *)0);
  gtk_tree_view_column_set_sort_column_id(column, 2);
  unsigned long int return_value_gtk_tree_view_get_type$70;
  return_value_gtk_tree_view_get_type$70=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$71;
  return_value_g_type_check_instance_cast$71=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_treeview, return_value_gtk_tree_view_get_type$70);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$71, column);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes("Scope", renderer, (const void *)"text", 3, (void *)0);
  gtk_tree_view_column_set_sort_column_id(column, 3);
  unsigned long int return_value_gtk_tree_view_get_type$72;
  return_value_gtk_tree_view_get_type$72=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$73;
  return_value_g_type_check_instance_cast$73=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_treeview, return_value_gtk_tree_view_get_type$72);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$73, column);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes("Edit Mode", renderer, (const void *)"text", 4, (void *)0);
  gtk_tree_view_column_set_sort_column_id(column, 4);
  unsigned long int return_value_gtk_tree_view_get_type$74;
  return_value_gtk_tree_view_get_type$74=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$75;
  return_value_g_type_check_instance_cast$75=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_treeview, return_value_gtk_tree_view_get_type$74);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$75, column);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes("Command", renderer, (const void *)"text", 5, (void *)0);
  gtk_tree_view_column_set_sort_column_id(column, 5);
  unsigned long int return_value_gtk_tree_view_get_type$76;
  return_value_gtk_tree_view_get_type$76=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$77;
  return_value_g_type_check_instance_cast$77=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_treeview, return_value_gtk_tree_view_get_type$76);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$77, column);
  unsigned long int return_value_gtk_tree_view_get_type$78;
  return_value_gtk_tree_view_get_type$78=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$79;
  return_value_g_type_check_instance_cast$79=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_treeview, return_value_gtk_tree_view_get_type$78);
  keybinding_selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$79);
  gtk_tree_selection_set_mode(keybinding_selection, (enum anonymous$24)GTK_SELECTION_BROWSE);
  gtk_tree_selection_set_select_function(keybinding_selection, keybinding_selection_func, (void *)0, (void (*)(void *))(void *)0);
  unsigned long int return_value_gtk_tree_sortable_get_type$80;
  return_value_gtk_tree_sortable_get_type$80=gtk_tree_sortable_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$81;
  return_value_g_type_check_instance_cast$81=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_store, return_value_gtk_tree_sortable_get_type$80);
  gtk_tree_sortable_set_sort_column_id((struct _GtkTreeSortable *)return_value_g_type_check_instance_cast$81, 1, (enum anonymous$26)GTK_SORT_ASCENDING);
  i = 0;
  for( ; !(i >= 257); i = i + 1)
  {
    keys_global[(signed long int)i] = (struct keybind *)(void *)0;
    keys_char[(signed long int)i] = (struct keybind *)(void *)0;
  }
}

// l_readerfile
// file script_lua.c line 61
static const char * l_readerfile(struct lua_State *L, void *data, unsigned long int *size)
{
  struct _IO_FILE *file = (struct _IO_FILE *)data;
  static char buf[4096l];
  *size=fread((void *)buf, (unsigned long int)1, (unsigned long int)4096, file);
  signed int return_value_ferror$1;
  signed int return_value_feof$2;
  if(*size == 0ul)
  {
    return_value_ferror$1=ferror(file);
    if(return_value_ferror$1 == 0)
      goto __CPROVER_DUMP_L1;

    return (const char *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(*size == 0ul)
    {
      return_value_feof$2=feof(file);
      if(return_value_feof$2 == 0)
        goto __CPROVER_DUMP_L2;

      return (const char *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      return buf;
    }
  }
}

// list_item_action
// file inventory.c line 199
static void list_item_action(struct _GdkEventButton *event, struct item_struct *tmp)
{
  signed int env;
  env=get_item_env(tmp);
  _Bool tmp_if_expr$7;
  signed int return_value_get_item_env$4;
  _Bool tmp_if_expr$6;
  signed int return_value_get_item_env$5;
  if(event->button == 1u)
  {
    if(!((1u & event->state) == 0u))
      toggle_locked(tmp);

    else
      client_send_examine(tmp->tag);
  }

  else
    if(event->button == 2u)
    {
      if(!((1u & event->state) == 0u))
        send_mark_obj(tmp);

      else
        client_send_apply(tmp->tag);
    }

    else
      if(event->button == 3u)
      {
        if(!(tmp->locked == 0))
          draw_ext_info(0, 20, 6, "This item is locked. To drop it, first unlock by shift+leftclicking on it.");

        else
        {
          unsigned int dest;
          unsigned long int return_value_gtk_spin_button_get_type$1;
          return_value_gtk_spin_button_get_type$1=gtk_spin_button_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
          return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)spinbutton_count, return_value_gtk_spin_button_get_type$1);
          signed int return_value_gtk_spin_button_get_value_as_int$3;
          return_value_gtk_spin_button_get_value_as_int$3=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$2);
          cpl.count = (unsigned int)return_value_gtk_spin_button_get_value_as_int$3;
          if(!((6 & env) == 0))
            dest = (unsigned int)cpl.ob->tag;

          else
          {
            if(env == 0x1 && !(cpl.container == ((struct item_struct *)NULL)))
            {
              return_value_get_item_env$4=get_item_env(cpl.container);
              if(return_value_get_item_env$4 == 0x1)
                tmp_if_expr$6 = (_Bool)1;

              else
              {
                return_value_get_item_env$5=get_item_env(cpl.container);
                tmp_if_expr$6 = return_value_get_item_env$5 == 0x2 ? (_Bool)1 : (_Bool)0;
              }
              tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$7 = (_Bool)0;
            if(tmp_if_expr$7)
              dest = (unsigned int)cpl.container->tag;

            else
              dest = (unsigned int)0;
          }
          client_send_move((signed int)dest, tmp->tag, (signed int)cpl.count);
          unsigned long int return_value_gtk_spin_button_get_type$8;
          return_value_gtk_spin_button_get_type$8=gtk_spin_button_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
          return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)spinbutton_count, return_value_gtk_spin_button_get_type$8);
          gtk_spin_button_set_value((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$9, 0.0);
          cpl.count = (unsigned int)0;
        }
      }

}

// list_row_collapse
// file inventory.c line 314
extern void list_row_collapse(struct _GtkTreeView *treeview, struct _GtkTreeIter *iter, struct _GtkTreePath *path, void *user_data)
{
  struct _GtkTreeModel *model;
  struct item_struct *tmp;
  model=gtk_tree_view_get_model(treeview);
  unsigned long int return_value_gtk_tree_model_get_type$1;
  return_value_gtk_tree_model_get_type$1=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)model, return_value_gtk_tree_model_get_type$1);
  gtk_tree_model_get((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$2, iter, 4, &tmp, -1);
  client_send_apply(tmp->tag);
}

// list_selection_func
// file inventory.c line 269
extern signed int list_selection_func(struct _GtkTreeSelection *selection, struct _GtkTreeModel *model, struct _GtkTreePath *path, signed int path_currently_selected, void *userdata)
{
  struct _GtkTreeIter iter;
  struct _GdkEventButton *event;
  union _GdkEvent *return_value_gtk_get_current_event$1;
  return_value_gtk_get_current_event$1=gtk_get_current_event();
  event = (struct _GdkEventButton *)return_value_gtk_get_current_event$1;
  if(event == ((struct _GdkEventButton *)NULL))
  {
    LOG((enum LogLevel)LOG_ERROR, "inventory.c::list_selection_func", "Unable to get event structure\n");
    return 0;
  }

  else
  {
    signed int return_value_gtk_tree_model_get_iter$2;
    return_value_gtk_tree_model_get_iter$2=gtk_tree_model_get_iter(model, &iter, path);
    if(!(return_value_gtk_tree_model_get_iter$2 == 0))
    {
      struct item_struct *tmp;
      gtk_tree_model_get(model, &iter, 4, &tmp, -1);
      if(tmp == ((struct item_struct *)NULL))
      {
        LOG((enum LogLevel)LOG_ERROR, "inventory.c::list_selection_func", "Unable to get item structure\n");
        return 0;
      }

      list_item_action(event, tmp);
    }

    return 0;
  }
}

// load_defaults
// file config.c line 264
extern void load_defaults(void)
{
  char path[256l];
  char inbuf[256l];
  char *cp;
  struct _IO_FILE *fp;
  signed int i;
  signed int val;
  i = 0;
  for( ; !(i >= 32); i = i + 1)
    use_config[(signed long int)i] = want_config[(signed long int)i];
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("HOME");
  snprintf(path, sizeof(char [256l]) /*256ul*/ , "%s/.crossfire/gdefaults2", return_value_getenv$1);
  fp=fopen(path, "r");
  char *return_value_fgets$2;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$18;
  signed int return_value_strcmp$17;
  signed int return_value_strcmp$16;
  signed int return_value_strcmp$15;
  signed int return_value_strcmp$14;
  signed int return_value_strcmp$13;
  signed int return_value_strcmp$12;
  signed int return_value_strcmp$11;
  signed int return_value_strcmp$10;
  signed int return_value_strcmp$9;
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$21;
  _Bool tmp_if_expr$22;
  _Bool tmp_if_expr$23;
  if(!(fp == ((struct _IO_FILE *)NULL)))
  {
    do
    {
      return_value_fgets$2=fgets(inbuf, 256 - 1, fp);
      if(return_value_fgets$2 == ((char *)NULL))
        break;

      inbuf[(signed long int)(256 - 1)] = (char)0;
      unsigned long int return_value_strlen$3;
      return_value_strlen$3=strlen(inbuf);
      inbuf[(signed long int)(return_value_strlen$3 - (unsigned long int)1)] = (char)0;
      if(!((signed int)inbuf[0l] == 35))
      {
        cp=strchr(inbuf, 58);
        if(!(cp == ((char *)NULL)))
        {
          *cp = (char)0;
          cp = cp + (signed long int)2;
          val = -1;
          const unsigned short int **return_value___ctype_b_loc$6;
          return_value___ctype_b_loc$6=__ctype_b_loc();
          if(!((2048 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)*cp]) == 0))
            val=atoi(cp);

          else
          {
            return_value_strcmp$5=strcmp(cp, "True");
            if(return_value_strcmp$5 == 0)
              val = (signed int)!(0 != 0);

            else
            {
              return_value_strcmp$4=strcmp(cp, "False");
              if(return_value_strcmp$4 == 0)
                val = 0;

            }
          }
          i = 1;
          for( ; !(i >= 32); i = i + 1)
          {
            signed int return_value_strcmp$7;
            return_value_strcmp$7=strcmp(config_names[(signed long int)i], inbuf);
            if(return_value_strcmp$7 == 0)
            {
              if(val == -1)
                LOG((enum LogLevel)LOG_WARNING, "config.c::load_defaults", "Invalid value/line: %s: %s", (const void *)inbuf, cp);

              else
                want_config[(signed long int)i] = (signed short int)val;
              break;
            }

          }
          if(i >= 32)
          {
            signed int return_value_strcmp$19;
            return_value_strcmp$19=strcmp(inbuf, "mapsize");
            if(return_value_strcmp$19 == 0)
            {
              signed int return_value_sscanf$8;
              return_value_sscanf$8=sscanf(cp, "%hdx%hd", &want_config[(signed long int)19], &want_config[(signed long int)20]);
              if(!(return_value_sscanf$8 == 2))
                LOG((enum LogLevel)LOG_WARNING, "config.c::load_defaults", "Malformed mapsize option in gdefaults2.  Ignoring");

            }

            else
            {
              return_value_strcmp$18=strcmp(inbuf, "theme");
              if(return_value_strcmp$18 == 0)
              {
                theme=strdup_local(cp);
                continue;
              }

              else
              {
                return_value_strcmp$17=strcmp(inbuf, "window_layout");
                if(return_value_strcmp$17 == 0)
                {
                  strncpy(window_xml_file, cp, (unsigned long int)(256 - 1));
                  continue;
                }

                else
                {
                  return_value_strcmp$16=strcmp(inbuf, "nopopups");
                  if(return_value_strcmp$16 == 0)
                  {
                    want_config[(signed long int)9] = (signed short int)!(val != 0);
                    continue;
                  }

                  else
                  {
                    return_value_strcmp$15=strcmp(inbuf, "nosplash");
                    if(return_value_strcmp$15 == 0)
                    {
                      want_config[(signed long int)27] = (signed short int)!(val != 0);
                      continue;
                    }

                    else
                    {
                      return_value_strcmp$14=strcmp(inbuf, "splash");
                      if(return_value_strcmp$14 == 0)
                      {
                        want_config[(signed long int)27] = (signed short int)val;
                        continue;
                      }

                      else
                      {
                        return_value_strcmp$13=strcmp(inbuf, "faceset");
                        if(return_value_strcmp$13 == 0)
                        {
                          face_info.want_faceset=strdup_local(cp);
                          continue;
                        }

                        else
                        {
                          return_value_strcmp$12=strcmp(inbuf, "per_tile_lighting");
                          if(return_value_strcmp$12 == 0)
                          {
                            if(!(val == 0))
                              want_config[(signed long int)17] = (signed short int)1;

                          }

                          else
                          {
                            return_value_strcmp$11=strcmp(inbuf, "per_pixel_lighting");
                            if(return_value_strcmp$11 == 0)
                            {
                              if(!(val == 0))
                                want_config[(signed long int)17] = (signed short int)2;

                            }

                            else
                            {
                              return_value_strcmp$10=strcmp(inbuf, "resists");
                              if(return_value_strcmp$10 == 0)
                              {
                                if(!(val == 0))
                                  want_config[(signed long int)25] = (signed short int)val;

                              }

                              else
                              {
                                return_value_strcmp$9=strcmp(inbuf, "sdl");
                                if(return_value_strcmp$9 == 0)
                                {
                                  if(!(val == 0))
                                    want_config[(signed long int)10] = (signed short int)1;

                                }

                                else
                                  LOG((enum LogLevel)LOG_WARNING, "config.c::load_defaults", "Unknown line in gdefaults2: %s %s", (const void *)inbuf, cp);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

        }

      }

    }
    while((_Bool)1);
    fclose(fp);
    if(!((signed int)want_config[7l] >= 25))
      tmp_if_expr$20 = (_Bool)1;

    else
      tmp_if_expr$20 = (signed int)want_config[(signed long int)7] > 200 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$20)
    {
      LOG((enum LogLevel)LOG_WARNING, "config.c::load_defaults", "Ignoring iconscale value read from gdefaults2 file.\nInvalid iconscale range (%d), valid range for -iconscale is 25 through 200", want_config[(signed long int)7]);
      want_config[(signed long int)7] = use_config[(signed long int)7];
    }

    if(!((signed int)want_config[8l] >= 25))
      tmp_if_expr$21 = (_Bool)1;

    else
      tmp_if_expr$21 = (signed int)want_config[(signed long int)8] > 200 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$21)
    {
      LOG((enum LogLevel)LOG_WARNING, "config.c::load_defaults", "ignoring mapscale value read for gdefaults2 file.\nInvalid mapscale range (%d), valid range for -iconscale is 25 through 200", want_config[(signed long int)8]);
      want_config[(signed long int)8] = use_config[(signed long int)8];
    }

    if(want_config[17l] == 0)
    {
      LOG((enum LogLevel)LOG_WARNING, "config.c::load_defaults", "No lighting mechanism selected - will not use darkness code");
      want_config[(signed long int)22] = (signed short int)0;
    }

    if((signed int)want_config[25l] >= 3)
    {
      LOG((enum LogLevel)LOG_WARNING, "config.c::load_defaults", "ignoring resists display value read for gdafaults file.\nInvalid value (%d), must be one value of 0, 1 or 2.", want_config[(signed long int)25]);
      want_config[(signed long int)25] = (signed short int)0;
    }

    if(!((signed int)want_config[19l] >= 9))
      tmp_if_expr$22 = (_Bool)1;

    else
      tmp_if_expr$22 = (signed int)want_config[(signed long int)19] > 31 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$22)
    {
      LOG((enum LogLevel)LOG_WARNING, "config.c::load_defaults", "Invalid map width (%d) option in gdefaults2. Valid range is 9 to %d", want_config[(signed long int)19], 31);
      want_config[(signed long int)19] = use_config[(signed long int)19];
    }

    if(!((signed int)want_config[20l] >= 9))
      tmp_if_expr$23 = (_Bool)1;

    else
      tmp_if_expr$23 = (signed int)want_config[(signed long int)20] > 31 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$23)
    {
      LOG((enum LogLevel)LOG_WARNING, "config.c::load_defaults", "Invalid map height (%d) option in gdefaults2. Valid range is 9 to %d", want_config[(signed long int)20], 31);
      want_config[(signed long int)20] = use_config[(signed long int)20];
    }

    i = 0;
    for( ; !(i >= 32); i = i + 1)
      use_config[(signed long int)i] = want_config[(signed long int)i];
    image_size = (32 * (signed int)use_config[(signed long int)7]) / 100;
    map_image_size = (32 * (signed int)use_config[(signed long int)8]) / 100;
    map_image_half_size = (32 * (signed int)use_config[(signed long int)8]) / 200;
  }

}

// load_image
// file image.c line 57
static signed int load_image(char *filename, unsigned char *data, signed int *len, unsigned int *csum)
{
  signed int fd;
  signed int i;
  char *cp;
  cp=strchr(filename, 64);
  if(!(cp == ((char *)NULL)))
  {
    char *lp;
    signed int offset;
    signed int last = -1;
    offset=atoi(cp + (signed long int)1);
    lp=strchr(cp, 58);
    if(lp == ((char *)NULL))
    {
      LOG((enum LogLevel)LOG_ERROR, "common::load_image", "Corrupt filename - has '@' but no ':' ?(%s)", filename);
      return -1;
    }

    *cp = (char)0;
    i = 0;
    for( ; !(i >= 20); i = i + 1)
    {
      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(fd_cache[(signed long int)i].name, filename);
      if(return_value_strcmp$1 == 0)
        break;

      if(last == -1)
      {
        if(fd_cache[(signed long int)i].fd == -1)
          last = i;

      }

    }
    if(i == 20)
    {
      if(last == -1)
      {
        LOG((enum LogLevel)LOG_WARNING, "common::load_image", "fd_cache filled up?  unable to load matching cache entry");
        *cp = (char)64;
        return -1;
      }

      fd_cache[(signed long int)last].fd=open(filename, 00);
      if(fd_cache[(signed long int)last].fd == -1)
      {
        LOG((enum LogLevel)LOG_WARNING, "common::load_image", "unable to load listed cache file %s", filename);
        *cp = (char)64;
        return -1;
      }

      strcpy(fd_cache[(signed long int)last].name, filename);
      i = last;
    }

    lseek(fd_cache[(signed long int)i].fd, (signed long int)offset, 0);
    signed long int return_value_read$2;
    return_value_read$2=read(fd_cache[(signed long int)i].fd, (void *)data, (unsigned long int)65535);
    *len = (signed int)return_value_read$2;
    *cp = (char)64;
  }

  else
  {
    fd=open(filename, 00);
    if(fd == -1)
      return -1;

    signed long int return_value_read$3;
    return_value_read$3=read(fd, (void *)data, (unsigned long int)65535);
    *len = (signed int)return_value_read$3;
    close(fd);
  }
  face_info.cache_hits = face_info.cache_hits + 1;
  *csum = (unsigned int)0;
  return 0;
}

// load_msgctrl_configuration
// file info.c line 1589
extern void load_msgctrl_configuration(void)
{
  char pathbuf[256l];
  char textbuf[256l];
  char recordtype;
  char *cptr;
  struct _IO_FILE *fptr;
  unsigned int pane;
  unsigned int type;
  unsigned int error;
  struct anonymous$73 statebuf;
  struct anonymous$74 countbuf;
  struct anonymous$74 timerbuf;
  unsigned int cvalid;
  unsigned int tvalid;
  unsigned int mvalid;
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("HOME");
  snprintf(pathbuf, sizeof(char [256l]) /*256ul*/ , "%s/.crossfire/msgs", return_value_getenv$1);
  fptr=fopen(pathbuf, "r");
  char *return_value_fgets$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$8;
  signed int return_value_sscanf$7;
  _Bool tmp_if_expr$10;
  signed int return_value_sscanf$9;
  _Bool tmp_if_expr$12;
  signed int return_value_sscanf$11;
  _Bool tmp_if_expr$14;
  signed int return_value_sscanf$13;
  _Bool tmp_if_expr$16;
  signed int return_value_sscanf$15;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$18;
  if(fptr == ((struct _IO_FILE *)NULL))
  {
    snprintf(textbuf, sizeof(char [256l]) /*256ul*/ , "Error opening %s, Message Control settings not loaded.", (const void *)pathbuf);
    draw_ext_info(3, 20, 9, textbuf);
  }

  else
  {
    error = (unsigned int)0;
    cvalid = (unsigned int)0;
    tvalid = (unsigned int)0;
    mvalid = (unsigned int)0;
    do
    {
      return_value_fgets$2=fgets(textbuf, 256 - 1, fptr);
      if(return_value_fgets$2 == ((char *)NULL))
        break;

      if((signed int)textbuf[0l] == 35)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)textbuf[(signed long int)0] == 10 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$3)
      {
        cptr=strtok(textbuf, "\t ");
        if(cptr == ((char *)NULL))
          tmp_if_expr$6 = (_Bool)1;

        else
        {
          if(!((signed int)*cptr == 67))
            tmp_if_expr$4 = (signed int)*cptr != 84 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(tmp_if_expr$4)
            tmp_if_expr$5 = (signed int)*cptr != 77 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$5 = (_Bool)0;
          tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$6)
          error = error + (unsigned int)1;

        else
        {
          recordtype = *cptr;
          if((signed int)recordtype == 67)
          {
            cptr=strtok((char *)(void *)0, "\n");
            if(cptr == ((char *)NULL))
              tmp_if_expr$8 = (_Bool)1;

            else
            {
              return_value_sscanf$7=sscanf(cptr, "%u", &countbuf.state);
              tmp_if_expr$8 = return_value_sscanf$7 != 1 ? (_Bool)1 : (_Bool)0;
            }
            if(countbuf.state >= 97u || !(countbuf.state >= 1u) || tmp_if_expr$8)
            {
              error = error + (unsigned int)1;
              continue;
            }

          }

          if((signed int)recordtype == 84)
          {
            cptr=strtok((char *)(void *)0, "\n");
            if(cptr == ((char *)NULL))
              tmp_if_expr$10 = (_Bool)1;

            else
            {
              return_value_sscanf$9=sscanf(cptr, "%u", &timerbuf.state);
              tmp_if_expr$10 = return_value_sscanf$9 != 1 ? (_Bool)1 : (_Bool)0;
            }
            if(timerbuf.state >= 97u || !(timerbuf.state >= 1u) || tmp_if_expr$10)
            {
              error = error + (unsigned int)1;
              continue;
            }

          }

          if((signed int)recordtype == 77)
          {
            cptr=strtok((char *)(void *)0, "\t ");
            if(cptr == ((char *)NULL))
              tmp_if_expr$12 = (_Bool)1;

            else
            {
              return_value_sscanf$11=sscanf(cptr, "%d", &type);
              tmp_if_expr$12 = return_value_sscanf$11 != 1 ? (_Bool)1 : (_Bool)0;
            }
            if(type >= 21u || !(type >= 1u) || tmp_if_expr$12)
            {
              error = error + (unsigned int)1;
              continue;
            }

            cptr=strtok((char *)(void *)0, "\t ");
            if(cptr == ((char *)NULL))
              tmp_if_expr$14 = (_Bool)1;

            else
            {
              return_value_sscanf$13=sscanf(cptr, "%d", &statebuf.buffer.state);
              tmp_if_expr$14 = return_value_sscanf$13 != 1 ? (_Bool)1 : (_Bool)0;
            }
            if(statebuf.buffer.state >= 2 || !(statebuf.buffer.state >= 0) || tmp_if_expr$14)
            {
              error = error + (unsigned int)1;
              continue;
            }

            pane = (unsigned int)0;
            for( ; !(pane >= 2u); pane = pane + (unsigned int)1)
            {
              cptr=strtok((char *)(void *)0, "\t ");
              if(cptr == ((char *)NULL))
                tmp_if_expr$16 = (_Bool)1;

              else
              {
                return_value_sscanf$15=sscanf(cptr, "%d", &statebuf.pane[(signed long int)pane].state);
                tmp_if_expr$16 = return_value_sscanf$15 != 1 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$16)
                tmp_if_expr$17 = (_Bool)1;

              else
                tmp_if_expr$17 = statebuf.pane[(signed long int)pane].state < 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$17)
                tmp_if_expr$18 = (_Bool)1;

              else
                tmp_if_expr$18 = statebuf.pane[(signed long int)pane].state > 1 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$18)
                error = error + (unsigned int)1;

            }
            cptr=strtok((char *)(void *)0, "\n");
            if(!(cptr == ((char *)NULL)))
            {
              error = error + (unsigned int)1;
              continue;
            }

          }

          if((signed int)recordtype == 67)
          {
            buffer_control.count.state = countbuf.state;
            cvalid = cvalid + (unsigned int)1;
          }

          if((signed int)recordtype == 84)
          {
            buffer_control.timer.state = timerbuf.state;
            tvalid = tvalid + (unsigned int)1;
          }

          if((signed int)recordtype == 77)
          {
            type = type - (unsigned int)1;
            msgctrl_widgets[(signed long int)type].buffer.state = statebuf.buffer.state;
            pane = (unsigned int)0;
            for( ; !(pane >= 2u); pane = pane + (unsigned int)1)
              msgctrl_widgets[(signed long int)type].pane[(signed long int)pane].state = statebuf.pane[(signed long int)pane].state;
            mvalid = mvalid + (unsigned int)1;
          }

        }
      }

    }
    while((_Bool)1);
    fclose(fptr);
    if(error >= 1u || !(cvalid == 1u) || !(mvalid == 20u) || !(tvalid == 1u))
    {
      snprintf(textbuf, sizeof(char [256l]) /*256ul*/ , "Corrupted Message Control settings in %s.", (const void *)pathbuf);
      draw_ext_info(3, 20, 9, textbuf);
      LOG((enum LogLevel)LOG_ERROR, "gtk-v2::load_msgctrl_configuration", "Error loading %s. %s\n", (const void *)pathbuf, (const void *)textbuf);
    }

    if(cvalid + mvalid + tvalid >= 1u)
    {
      LOG((enum LogLevel)LOG_DEBUG, "gtk-v2::load_msgctrl_configuration", "Message control settings loaded from '%s'", (const void *)pathbuf);
      update_msgctrl_configuration();
    }

  }
}

// load_theme
// file config.c line 199
extern void load_theme(signed int reload)
{
  char path[256l];
  gtk_rc_set_default_files(default_files);
  signed int return_value_strcmp$2;
  return_value_strcmp$2=strcmp(theme, "None");
  if(!(return_value_strcmp$2 == 0))
  {
    snprintf(path, (unsigned long int)256, "%s/%s/%s", (const void *)"/usr/share/games/crossfire-client", themedir, theme);
    signed int return_value_access$1;
    return_value_access$1=access(path, 4);
    if(return_value_access$1 == -1)
      LOG((enum LogLevel)LOG_ERROR, "config.c::load_theme", "Unable to find theme file %s", (const void *)path);

    gtk_rc_add_default_file(path);
  }

  struct _GdkScreen *return_value_gdk_screen_get_default$3;
  return_value_gdk_screen_get_default$3=gdk_screen_get_default();
  struct _GtkSettings *return_value_gtk_settings_get_for_screen$4;
  return_value_gtk_settings_get_for_screen$4=gtk_settings_get_for_screen(return_value_gdk_screen_get_default$3);
  gtk_rc_reparse_all_for_settings(return_value_gtk_settings_get_for_screen$4, (signed int)!(0 != 0));
  struct _GdkScreen *return_value_gdk_screen_get_default$5;
  return_value_gdk_screen_get_default$5=gdk_screen_get_default();
  struct _GtkSettings *return_value_gtk_settings_get_for_screen$6;
  return_value_gtk_settings_get_for_screen$6=gtk_settings_get_for_screen(return_value_gdk_screen_get_default$5);
  gtk_rc_reset_styles(return_value_gtk_settings_get_for_screen$6);
  info_get_styles();
  inventory_get_styles();
  stats_get_styles();
  spell_get_styles();
  update_spell_information();
  cpl.below->inv_updated = (unsigned short int)1;
  cpl.ob->inv_updated = (unsigned short int)1;
  draw_lists();
  draw_stats((signed int)!(0 != 0));
  draw_message_window((signed int)!(0 != 0));
}

// load_window_positions
// file config.c line 1165
extern void load_window_positions(struct _GtkWidget *window_root)
{
  char loadname[256l];
  char buf[256l];
  char *cp;
  struct _GtkWidget *widget;
  struct _IO_FILE *load;
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%s", (const void *)window_xml_file);
  cp=strrchr(buf, 46);
  if(!(cp == ((char *)NULL)))
    cp[(signed long int)0] = (char)0;

  char *return_value_getenv$1;
  return_value_getenv$1=getenv("HOME");
  snprintf(loadname, sizeof(char [256l]) /*256ul*/ , "%s/.crossfire/%s.pos", return_value_getenv$1, (const void *)buf);
  load=fopen(loadname, "r");
  if(load == ((struct _IO_FILE *)NULL))
  {
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Cannot open %s: Using default window positions.", (const void *)loadname);
    draw_ext_info(3, 20, 1, buf);
    goto __CPROVER_DUMP_L15;
  }

  else
    LOG((enum LogLevel)LOG_DEBUG, "gtk-v2::load_window_positions", "Loading window positions from '%s'", (const void *)loadname);
  char *return_value_fgets$2;
  const unsigned short int **return_value___ctype_b_loc$3;
  char *return_value_strstr$15;
  do
  {
    return_value_fgets$2=fgets(buf, 256 - 1, load);
    if(return_value_fgets$2 == ((char *)NULL))
      break;

    cp=strchr(buf, 58);
    if(!(cp == ((char *)NULL)))
    {
      *cp = (char)0;
      cp = cp + 1l;
      do
      {
        return_value___ctype_b_loc$3=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*cp]) == 0)
          break;

        cp = cp + 1l;
      }
      while((_Bool)1);
      signed int return_value_strcmp$16;
      return_value_strcmp$16=strcmp(buf, "window_root");
      if(return_value_strcmp$16 == 0)
      {
        signed int x;
        signed int y;
        signed int w;
        signed int h;
        signed int return_value_sscanf$8;
        return_value_sscanf$8=sscanf(cp, "+%d+%dx%dx%d", &x, &y, &w, &h);
        if(return_value_sscanf$8 == 4)
        {
          unsigned long int return_value_gtk_window_get_type$4;
          return_value_gtk_window_get_type$4=gtk_window_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
          return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_window_get_type$4);
          gtk_window_set_default_size((struct _GtkWindow *)return_value_g_type_check_instance_cast$5, w, h);
          unsigned long int return_value_gtk_window_get_type$6;
          return_value_gtk_window_get_type$6=gtk_window_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
          return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)window_root, return_value_gtk_window_get_type$6);
          gtk_window_move((struct _GtkWindow *)return_value_g_type_check_instance_cast$7, x, y);
        }

        else
          LOG((enum LogLevel)LOG_ERROR, "config.c::load_window_positions", "Window size %s corrupt\n", cp);
      }

      else
      {
        return_value_strstr$15=strstr(buf, "paned_");
        if(!(return_value_strstr$15 == ((char *)NULL)))
        {
          struct _GObject *return_value_gtk_builder_get_object$9;
          return_value_gtk_builder_get_object$9=gtk_builder_get_object(window_xml, buf);
          unsigned long int return_value_gtk_widget_get_type$10;
          return_value_gtk_widget_get_type$10=gtk_widget_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
          return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$9, return_value_gtk_widget_get_type$10);
          widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$11;
          if(!(widget == ((struct _GtkWidget *)NULL)))
          {
            unsigned long int return_value_gtk_paned_get_type$12;
            return_value_gtk_paned_get_type$12=gtk_paned_get_type();
            struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
            return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_paned_get_type$12);
            signed int return_value_atoi$14;
            return_value_atoi$14=atoi(cp);
            gtk_paned_set_position((struct _GtkPaned *)return_value_g_type_check_instance_cast$13, return_value_atoi$14);
          }

          else
            LOG((enum LogLevel)LOG_INFO, "config.c::load_window_positions", "%s in %s not found in this UI layout.\n", (const void *)buf, (const void *)loadname);
        }

        else
          LOG((enum LogLevel)LOG_ERROR, "config.c::load_window_positions", "Found unknown line %s in %s\n", (const void *)buf, (const void *)loadname);
      }
    }

  }
  while((_Bool)1);
  fclose(load);

__CPROVER_DUMP_L15:
  ;
}

// locate_item
// file ../../common/proto.h line 65
struct item_struct * locate_item(signed int tag)
{
  struct item_struct *op;
  if(tag == 0)
    return map;

  else
  {
    op=locate_item_from_item(map->inv, tag);
    if(!(op == ((struct item_struct *)NULL)))
      return op;

    else
    {
      op=locate_item_from_item(player, tag);
      if(!(op == ((struct item_struct *)NULL)))
        return op;

      else
        if(!(cpl.container == ((struct item_struct *)NULL)))
        {
          if(!(cpl.container->tag == tag))
            goto __CPROVER_DUMP_L4;

          return cpl.container;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          if(!(cpl.container == ((struct item_struct *)NULL)))
          {
            op=locate_item_from_item(cpl.container->inv, tag);
            if(op == ((struct item_struct *)NULL))
              goto __CPROVER_DUMP_L5;

            return op;
          }

          else
          {

          __CPROVER_DUMP_L5:
            ;
            return (struct item_struct *)(void *)0;
          }
        }
    }
  }
}

// locate_item_from_item
// file item.c line 281
static struct item_struct * locate_item_from_item(struct item_struct *op, signed int tag)
{
  struct item_struct *tmp;
  for( ; !(op == ((struct item_struct *)NULL)); op = op->next)
    if(op->tag == tag)
      return op;

    else
      if(!(op->inv == ((struct item_struct *)NULL)))
      {
        tmp=locate_item_from_item(op->inv, tag);
        if(!(tmp == ((struct item_struct *)NULL)))
          return tmp;

      }

  return (struct item_struct *)(void *)0;
}

// logChildPipe
// file ../../common/proto.h line 118
void logChildPipe(struct ChildProcess *child, enum LogLevel level, signed int flag)
{
  if(!((2 & child->flag & flag) == 0))
    logPipe(child, level, 1);

  if(!((4 & child->flag & flag) == 0))
    logPipe(child, level, 2);

}

// logPipe
// file misc.c line 287
void logPipe(struct ChildProcess *child, enum LogLevel level, signed int pipe)
{
  char buf[1024l];
  char *tmp_if_expr$1;
  if(!(pipe >= 3) && pipe >= 1)
  {
    if(child->logger[(signed long int)pipe].name == ((char *)NULL))
    {
      if(!(child->name == ((char *)NULL)))
        tmp_if_expr$1 = child->name;

      else
        tmp_if_expr$1 = "NONAME";
      snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "Child%d::%s::%d", child->pid, tmp_if_expr$1, pipe);
      child->logger[(signed long int)pipe].name=strdup(buf);
    }

    signed int return_value_fcntl$2;
    return_value_fcntl$2=fcntl(child->tube[(signed long int)pipe], 4, 04000);
    if(return_value_fcntl$2 == -1)
    {
      LOG((enum LogLevel)LOG_WARNING, "common::logPipe", "Error on fcntl.");
      child->logger[(signed long int)pipe].log = 0;
    }

    else
    {
      child->logger[(signed long int)pipe].log = 1;
      child->logger[(signed long int)pipe].level = level;
    }
  }

}

// look_at
// file ../../common/proto.h line 136
void look_at(signed int x, signed int y)
{
  cs_print_string(csocket.fd, "lookat %d %d", x, y);
}

// lua_draw
// file script_lua.c line 174
static signed int lua_draw(struct lua_State *L)
{
  signed int n;
  n=lua_gettop(L);
  const char *what;
  if(!(n == 1))
  {
    lua_pushstring(L, "draw what?");
    lua_error(L);
  }

  signed int return_value_lua_isstring$1;
  return_value_lua_isstring$1=lua_isstring(L, 1);
  if(return_value_lua_isstring$1 == 0)
  {
    lua_pushstring(L, "expected a string");
    lua_error(L);
  }

  what=lua_tolstring(L, 1, (unsigned long int *)(void *)0);
  draw_ext_info(3, 20, 8, what);
  return 0;
}

// lua_issue
// file script_lua.c line 193
static signed int lua_issue(struct lua_State *L)
{
  signed int n;
  n=lua_gettop(L);
  const char *what;
  signed int repeat;
  signed int must_send;
  if(!(n == 3))
  {
    lua_pushstring(L, "syntax is cfissue repeat must_send command");
    lua_error(L);
  }

  signed int return_value_lua_isnumber$1;
  return_value_lua_isnumber$1=lua_isnumber(L, 1);
  if(return_value_lua_isnumber$1 == 0)
  {
    lua_pushstring(L, "expected a number");
    lua_error(L);
  }

  signed int return_value_lua_isnumber$2;
  return_value_lua_isnumber$2=lua_isnumber(L, 2);
  if(return_value_lua_isnumber$2 == 0)
  {
    lua_pushstring(L, "expected a number");
    lua_error(L);
  }

  signed int return_value_lua_isstring$3;
  return_value_lua_isstring$3=lua_isstring(L, 3);
  if(return_value_lua_isstring$3 == 0)
  {
    lua_pushstring(L, "expected a number");
    lua_error(L);
  }

  double return_value_lua_tonumber$4;
  return_value_lua_tonumber$4=lua_tonumber(L, 1);
  repeat = (signed int)return_value_lua_tonumber$4;
  double return_value_lua_tonumber$5;
  return_value_lua_tonumber$5=lua_tonumber(L, 2);
  must_send = (signed int)return_value_lua_tonumber$5;
  what=lua_tolstring(L, 3, (unsigned long int *)(void *)0);
  send_command(what, repeat, must_send);
  return 0;
}

// magic_map_flash_pos
// file magicmap.c line 114
void magic_map_flash_pos(void)
{
  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)map_notebook, return_value_gtk_notebook_get_type$1);
  signed int return_value_gtk_notebook_get_current_page$3;
  return_value_gtk_notebook_get_current_page$3=gtk_notebook_get_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2);
  if(!(return_value_gtk_notebook_get_current_page$3 == 1))
    cpl.showmagic = (unsigned char)0;

  if(!(cpl.showmagic == 0))
  {
    cpl.showmagic = cpl.showmagic ^ (unsigned char)2;
    if(!((2 & (signed int)cpl.showmagic) == 0))
      gdk_gc_set_foreground(magic_map_gc, &root_color[(signed long int)0]);

    else
      gdk_gc_set_foreground(magic_map_gc, &root_color[(signed long int)1]);
    gdk_draw_rectangle(magic_map->window, magic_map_gc, (signed int)!(0 != 0), (signed int)cpl.mapxres * (signed int)cpl.pmapx, (signed int)cpl.mapyres * (signed int)cpl.pmapy, (signed int)cpl.mapxres, (signed int)cpl.mapyres);
  }

}

// main
// file main.c line 789
extern signed int main(signed int argc, char **argv)
{
  gtk_init(&argc, &argv);
  init_client_vars();
  want_config[(signed long int)19] = (signed short int)25;
  use_config[(signed long int)19] = want_config[(signed long int)19];
  want_config[(signed long int)20] = (signed short int)25;
  use_config[(signed long int)20] = want_config[(signed long int)20];
  parse_args(argc, argv);
  init_ui();
  init_sockets();
  signed int return_value_init_sounds$1;
  return_value_init_sounds$1=init_sounds();
  if(return_value_init_sounds$1 == -1)
    use_config[(signed long int)13] = (signed short int)0;

  else
    use_config[(signed long int)13] = (signed short int)!(0 != 0);
  init_image_cache_data();
  gtk_widget_show(window_root);
  map_init(window_root);
  while((_Bool)1)
  {
    reset_client_vars();
    clear_stat_mapping();
    csocket.inbuf.len = 0;
    csocket.cs_version = 0;
    if(server == ((char *)NULL))
    {
      draw_splash();
      metaserver_get_info(meta_server, meta_port);
      get_metaserver();
    }

    else
    {
      csocket.fd=init_connection(server, (signed int)use_config[(signed long int)23]);
      server = (char *)(void *)0;
      if(csocket.fd == -1)
        continue;

    }
    negotiate_connection((signed int)use_config[(signed long int)13]);
    event_loop();
    remove_item_inventory(cpl.ob);
    struct item_struct *return_value_locate_item$2;
    return_value_locate_item$2=locate_item(0);
    remove_item_inventory(return_value_locate_item$2);
    draw_look_list();
    mapdata_reset();
    reset_image_data();
  }
  exit(0);
}

// make_path_to_dir
// file ./proto.h line 111
signed int make_path_to_dir(char *directory)
{
  char buf[256l];
  char *cp = buf;
  struct stat statbuf;
  _Bool tmp_if_expr$1;
  if(directory == ((char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(*directory != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return -1;

  else
  {
    strcpy(buf, directory);
    do
    {
      cp=strchr(cp + (signed long int)1, (signed int)47);
      if(cp == ((char *)NULL))
        break;

      *cp = (char)0;
      signed int return_value_stat$3;
      return_value_stat$3=stat(buf, &statbuf);
      if(!((61440u & statbuf.st_mode) == 16384u) || !(return_value_stat$3 == 0))
      {
        signed int return_value_mkdir$2;
        return_value_mkdir$2=mkdir(buf, (unsigned int)0777);
        if(!(return_value_mkdir$2 == 0))
        {
          perror("Couldn't make path to file");
          return -1;
        }

      }

      else
        *cp = (char)47;
    }
    while((_Bool)1);
    signed int return_value_stat$5;
    return_value_stat$5=stat(buf, &statbuf);
    if(!((61440u & statbuf.st_mode) == 16384u) || !(return_value_stat$5 == 0))
    {
      signed int return_value_mkdir$4;
      return_value_mkdir$4=mkdir(buf, (unsigned int)0777);
      if(!(return_value_mkdir$4 == 0))
      {
        perror("Couldn't make path to file");
        return -1;
      }

    }

    return 0;
  }
}

// make_path_to_file
// file ../../common/proto.h line 112
signed int make_path_to_file(char *filename)
{
  char buf[256l];
  char *cp = buf;
  struct stat statbuf;
  _Bool tmp_if_expr$1;
  if(filename == ((char *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(*filename != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return -1;

  else
  {
    strcpy(buf, filename);
    do
    {
      cp=strchr(cp + (signed long int)1, (signed int)47);
      if(cp == ((char *)NULL))
        break;

      *cp = (char)0;
      signed int return_value_stat$3;
      return_value_stat$3=stat(buf, &statbuf);
      if(!((61440u & statbuf.st_mode) == 16384u) || !(return_value_stat$3 == 0))
      {
        signed int return_value_mkdir$2;
        return_value_mkdir$2=mkdir(buf, (unsigned int)0777);
        if(!(return_value_mkdir$2 == 0))
        {
          perror("Couldn't make path to file");
          return -1;
        }

      }

      *cp = (char)47;
    }
    while((_Bool)1);
    return 0;
  }
}

// map_init
// file gtk2proto.h line 153
extern void map_init(struct _GtkWidget *window_root)
{
  struct _GObject *return_value_gtk_builder_get_object$1;
  return_value_gtk_builder_get_object$1=gtk_builder_get_object(window_xml, "drawingarea_map");
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
  map_drawing_area = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
  struct _GObject *return_value_gtk_builder_get_object$4;
  return_value_gtk_builder_get_object$4=gtk_builder_get_object(window_xml, "map_notebook");
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$4, return_value_gtk_widget_get_type$5);
  map_notebook = (struct _GtkWidget *)return_value_g_type_check_instance_cast$6;
  g_signal_connect_data((void *)map_drawing_area, "expose_event", (void (*)(void))on_drawingarea_map_expose_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)map_drawing_area, "button_press_event", (void (*)(void))on_drawingarea_map_button_press_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  g_signal_connect_data((void *)map_drawing_area, "configure_event", (void (*)(void))on_drawingarea_map_configure_event, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  mapgc=gdk_gc_new(map_drawing_area->window);
  gtk_widget_show(map_drawing_area);
  gtk_widget_add_events(map_drawing_area, 256);
  if((signed int)use_config[10l] == 0)
  {
    signed int x;
    signed int y;
    struct _GdkGC *darkgc;
    dark=gdk_pixmap_new(map_drawing_area->window, map_image_size, map_image_size, -1);
    gdk_draw_rectangle(dark, map_drawing_area->style->black_gc, (signed int)!(0 != 0), 0, 0, map_image_size, map_image_size);
    dark1=gdk_pixmap_new(map_drawing_area->window, map_image_size, map_image_size, 1);
    dark2=gdk_pixmap_new(map_drawing_area->window, map_image_size, map_image_size, 1);
    dark3=gdk_pixmap_new(map_drawing_area->window, map_image_size, map_image_size, 1);
    darkgc=gdk_gc_new(dark1);
    gdk_gc_set_foreground(darkgc, &root_color[(signed long int)1]);
    gdk_draw_rectangle(dark1, darkgc, (signed int)!(0 != 0), 0, 0, map_image_size, map_image_size);
    gdk_draw_rectangle(dark2, darkgc, (signed int)!(0 != 0), 0, 0, map_image_size, map_image_size);
    gdk_draw_rectangle(dark3, darkgc, (signed int)!(0 != 0), 0, 0, map_image_size, map_image_size);
    gdk_gc_set_foreground(darkgc, &root_color[(signed long int)0]);
    x = 0;
    for( ; !(x >= map_image_size); x = x + 1)
    {
      y = 0;
      for( ; !(y >= map_image_size); y = y + 1)
      {
        if(!((x + y) % 2 == 0))
          gdk_draw_point(dark1, darkgc, x, y);

        if(!((x + y) % 3 == 0))
          gdk_draw_point(dark2, darkgc, x, y);

        if(!((x + y) % 4 == 0))
          gdk_draw_point(dark3, darkgc, x, y);

      }
    }
    gdk_gc_unref(darkgc);
  }

  else
    if((signed int)use_config[10l] == 1)
      init_SDL(map_drawing_area, 0);

    else
      if((signed int)use_config[10l] == 2)
        init_opengl(map_drawing_area);

}

// map_item
// file ./proto.h line 74
struct item_struct * map_item(void)
{
  map=new_item();
  map->weight = (float)-1;
  return map;
}

// map_scrollCmd
// file ./proto.h line 33
void map_scrollCmd(char *data, signed int len)
{
  signed int map_scrollCmd$$1$$dx;
  signed int map_scrollCmd$$1$$dy;
  char *buf;
  (void)len;
  map_scrollCmd$$1$$dx=atoi(data);
  buf=strchr(data, 32);
  if(buf == ((char *)NULL))
    LOG((enum LogLevel)LOG_WARNING, "common::map_scrollCmd", "Got short packet.");

  else
  {
    buf = buf + 1l;
    map_scrollCmd$$1$$dy=atoi(buf);
    display_map_startupdate();
    mapdata_scroll(map_scrollCmd$$1$$dx, map_scrollCmd$$1$$dy);
    display_map_doneupdate(0, 1);
  }
}

// mapdata_animation
// file ../../common/proto.h line 97
void mapdata_animation(void)
{
  signed int x;
  signed int y;
  signed int layer;
  signed int face;
  struct MapCellLayer *cell;
  x = 0;
  for( ; !(x >= 2000); x = x + 1)
    if(!(animations[(signed long int)x].speed == 0))
    {
      animations[(signed long int)x].speed_left = animations[(signed long int)x].speed_left + 1;
      if((signed int)animations[(signed long int)x].speed_left >= (signed int)animations[(signed long int)x].speed)
      {
        animations[(signed long int)x].speed_left = (unsigned char)0;
        animations[(signed long int)x].phase = animations[(signed long int)x].phase + 1;
        if((signed int)animations[(signed long int)x].phase >= (signed int)animations[(signed long int)x].num_animations)
          animations[(signed long int)x].phase = (unsigned char)0;

      }

    }

  x = 0;
  for( ; !(x >= 33); x = x + 1)
  {
    y = 0;
    for( ; !(y >= 33); y = y + 1)
      if((the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->cleared == 0)
      {
        layer = 0;
        for( ; !(layer >= 10); layer = layer + 1)
        {
          cell = &(the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->heads[(signed long int)layer];
          if(!(cell->animation == 0))
          {
            cell->animation_left = cell->animation_left + 1;
            if((signed int)cell->animation_left >= (signed int)cell->animation_speed)
            {
              cell->animation_left = (unsigned char)0;
              cell->animation_phase = cell->animation_phase + 1;
              if((signed int)cell->animation_phase >= (signed int)animations[(signed long int)cell->animation].num_animations)
                cell->animation_phase = (unsigned char)0;

              face = (signed int)animations[(signed long int)cell->animation].faces[(signed long int)cell->animation_phase];
              if(face >= 1)
                expand_set_face(pl_pos.x + x, pl_pos.y + y, layer, (signed short int)face, 0);

              else
                expand_clear_face_from_layer(pl_pos.x + x, pl_pos.y + y, layer);
            }

          }

          cell = &bigfaces[(signed long int)x][(signed long int)y][(signed long int)layer].head;
          if(!(cell->animation == 0))
          {
            cell->animation_left = cell->animation_left + 1;
            if((signed int)cell->animation_left >= (signed int)cell->animation_speed)
            {
              cell->animation_left = (unsigned char)0;
              cell->animation_phase = cell->animation_phase + 1;
              if((signed int)cell->animation_phase >= (signed int)animations[(signed long int)cell->animation].num_animations)
                cell->animation_phase = (unsigned char)0;

              face = (signed int)animations[(signed long int)cell->animation].faces[(signed long int)cell->animation_phase];
              expand_set_bigface(x, y, layer, (signed short int)face, 0);
            }

          }

        }
      }

  }
}

// mapdata_bigface
// file ../../common/proto.h line 95
signed short int mapdata_bigface(signed int x, signed int y, signed int layer, signed int *ww, signed int *hh)
{
  signed short int result;
  if(!(width$link1 >= 1))
    return (signed short int)0;

  else
  {
    /* assertion 0 <= x && x < width */
    assert(0 <= x && x < width$link1);
    /* assertion 0 <= y && y < height */
    assert(0 <= y && y < height$link1);
    /* assertion 0 <= layer && layer < 10 */
    assert(0 <= layer && layer < 10);
    result = (the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->tails[(signed long int)layer].face;
    if(!((signed int)result == 0))
    {
      signed int clear_bigface;
      signed int mapdata_bigface$$1$$2$$dx = (signed int)(the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->tails[(signed long int)layer].size_x;
      signed int mapdata_bigface$$1$$2$$dy = (signed int)(the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->tails[(signed long int)layer].size_y;
      signed int mapdata_bigface$$1$$2$$w = (signed int)(the_map.cells[(signed long int)(pl_pos.x + x + mapdata_bigface$$1$$2$$dx)] + (signed long int)(pl_pos.y + y + mapdata_bigface$$1$$2$$dy))->heads[(signed long int)layer].size_x;
      signed int mapdata_bigface$$1$$2$$h = (signed int)(the_map.cells[(signed long int)(pl_pos.x + x + mapdata_bigface$$1$$2$$dx)] + (signed long int)(pl_pos.y + y + mapdata_bigface$$1$$2$$dy))->heads[(signed long int)layer].size_y;
      /* assertion 1 <= w && w <= 16 */
      assert(1 <= mapdata_bigface$$1$$2$$w && mapdata_bigface$$1$$2$$w <= 16);
      /* assertion 1 <= h && h <= 16 */
      assert(1 <= mapdata_bigface$$1$$2$$h && mapdata_bigface$$1$$2$$h <= 16);
      /* assertion 0 <= dx && dx < w */
      assert(0 <= mapdata_bigface$$1$$2$$dx && mapdata_bigface$$1$$2$$dx < mapdata_bigface$$1$$2$$w);
      /* assertion 0 <= dy && dy < h */
      assert(0 <= mapdata_bigface$$1$$2$$dy && mapdata_bigface$$1$$2$$dy < mapdata_bigface$$1$$2$$h);
      if(!((the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->cleared == 0))
        clear_bigface = 0;

      else
        if(!(mapdata_bigface$$1$$2$$dx + x >= width$link1) && !(mapdata_bigface$$1$$2$$dy + y >= height$link1))
          clear_bigface = (signed int)(the_map.cells[(signed long int)(pl_pos.x + x + mapdata_bigface$$1$$2$$dx)] + (signed long int)(pl_pos.y + y + mapdata_bigface$$1$$2$$dy))->cleared;

        else
          clear_bigface = (signed int)((signed int)bigfaces[(signed long int)(x + mapdata_bigface$$1$$2$$dx)][(signed long int)(y + mapdata_bigface$$1$$2$$dy)][(signed long int)layer].head.face == 0);
      if(clear_bigface == 0)
      {
        *ww = (mapdata_bigface$$1$$2$$w - 1) - mapdata_bigface$$1$$2$$dx;
        *hh = (mapdata_bigface$$1$$2$$h - 1) - mapdata_bigface$$1$$2$$dy;
        return result;
      }

      /* assertion the_map.cells[pl_pos.x+x][pl_pos.y+y].tails[layer].face == result */
      assert((the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->tails[(signed long int)layer].face == result);
      expand_clear_face_from_layer(pl_pos.x + x + mapdata_bigface$$1$$2$$dx, pl_pos.y + y + mapdata_bigface$$1$$2$$dy, layer);
      /* assertion the_map.cells[pl_pos.x+x][pl_pos.y+y].tails[layer].face == 0 */
      assert((signed int)(the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->tails[(signed long int)layer].face == 0);
    }

    result = bigfaces[(signed long int)x][(signed long int)y][(signed long int)layer].tail.face;
    if(!((signed int)result == 0))
    {
      signed int mapdata_bigface$$1$$3$$dx = (signed int)bigfaces[(signed long int)x][(signed long int)y][(signed long int)layer].tail.size_x;
      signed int mapdata_bigface$$1$$3$$dy = (signed int)bigfaces[(signed long int)x][(signed long int)y][(signed long int)layer].tail.size_y;
      signed int w = (signed int)bigfaces[(signed long int)(x + mapdata_bigface$$1$$3$$dx)][(signed long int)(y + mapdata_bigface$$1$$3$$dy)][(signed long int)layer].head.size_x;
      signed int h = (signed int)bigfaces[(signed long int)(x + mapdata_bigface$$1$$3$$dx)][(signed long int)(y + mapdata_bigface$$1$$3$$dy)][(signed long int)layer].head.size_y;
      /* assertion 0 <= dx && dx < w */
      assert(0 <= mapdata_bigface$$1$$3$$dx && mapdata_bigface$$1$$3$$dx < w);
      /* assertion 0 <= dy && dy < h */
      assert(0 <= mapdata_bigface$$1$$3$$dy && mapdata_bigface$$1$$3$$dy < h);
      *ww = (w - 1) - mapdata_bigface$$1$$3$$dx;
      *hh = (h - 1) - mapdata_bigface$$1$$3$$dy;
      return result;
    }

    *ww = 1;
    *hh = 1;
    return (signed short int)0;
  }
}

// mapdata_bigface_head
// file ../../common/proto.h line 96
signed short int mapdata_bigface_head(signed int x, signed int y, signed int layer, signed int *ww, signed int *hh)
{
  signed short int result;
  if(!(width$link1 >= 1))
    return (signed short int)0;

  else
  {
    /* assertion 0 <= x && x < 64 */
    assert(0 <= x && x < 64);
    /* assertion 0 <= y && y < 64 */
    assert(0 <= y && y < 64);
    /* assertion 0 <= layer && layer < 10 */
    assert(0 <= layer && layer < 10);
    result = bigfaces[(signed long int)x][(signed long int)y][(signed long int)layer].head.face;
    if(!((signed int)result == 0))
    {
      signed int w = (signed int)bigfaces[(signed long int)x][(signed long int)y][(signed long int)layer].head.size_x;
      signed int h = (signed int)bigfaces[(signed long int)x][(signed long int)y][(signed long int)layer].head.size_y;
      *ww = w;
      *hh = h;
      return result;
    }

    *ww = 1;
    *hh = 1;
    return (signed short int)0;
  }
}

// mapdata_clear_old
// file ./proto.h line 89
void mapdata_clear_old(signed int x, signed int y)
{
  signed int px;
  signed int py;
  signed int i;
  /* assertion 0 <= x && x < 64 */
  assert(0 <= x && x < 64);
  /* assertion 0 <= y && y < 64 */
  assert(0 <= y && y < 64);
  px = pl_pos.x + x;
  py = pl_pos.y + y;
  /* assertion 0 <= px && px < 512 */
  assert(0 <= px && px < 512);
  /* assertion 0 <= py && py < 512 */
  assert(0 <= py && py < 512);
  if(!(x >= width$link1) && !(y >= height$link1))
  {
    if(!((the_map.cells[(signed long int)px] + (signed long int)py)->cleared == 0))
    {
      i = 0;
      for( ; !(i >= 10); i = i + 1)
        expand_clear_face_from_layer(px, py, i);
      (the_map.cells[(signed long int)px] + (signed long int)py)->darkness = (unsigned char)0;
      (the_map.cells[(signed long int)px] + (signed long int)py)->have_darkness = (unsigned char)0;
    }

  }

}

// mapdata_clear_space
// file ./proto.h line 85
void mapdata_clear_space(signed int x, signed int y)
{
  signed int px;
  signed int py;
  signed int i;
  /* assertion 0 <= x && x < 64 */
  assert(0 <= x && x < 64);
  /* assertion 0 <= y && y < 64 */
  assert(0 <= y && y < 64);
  px = pl_pos.x + x;
  py = pl_pos.y + y;
  /* assertion 0 <= px && px < 512 */
  assert(0 <= px && px < 512);
  /* assertion 0 <= py && py < 512 */
  assert(0 <= py && py < 512);
  if(!(x >= width$link1) && !(y >= height$link1))
  {
    if((the_map.cells[(signed long int)px] + (signed long int)py)->cleared == 0)
    {
      (the_map.cells[(signed long int)px] + (signed long int)py)->cleared = (unsigned char)1;
      (the_map.cells[(signed long int)px] + (signed long int)py)->need_update = (unsigned char)1;
      i = 0;
      for( ; !(i >= 10); i = i + 1)
        if(!((the_map.cells[(signed long int)px] + (signed long int)py)->heads[(signed long int)i].face == 0))
          expand_need_update_from_layer(px, py, i);

    }

  }

  else
  {
    i = 0;
    for( ; !(i >= 10); i = i + 1)
      expand_set_bigface(x, y, i, (signed short int)0, 1);
  }
}

// mapdata_face
// file ../../common/proto.h line 94
signed short int mapdata_face(signed int x, signed int y, signed int layer)
{
  if(!(width$link1 >= 1))
    return (signed short int)0;

  else
  {
    /* assertion 0 <= x && x < width */
    assert(0 <= x && x < width$link1);
    /* assertion 0 <= y && y < height */
    assert(0 <= y && y < height$link1);
    /* assertion 0 <= layer && layer < 10 */
    assert(0 <= layer && layer < 10);
    return (the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->heads[(signed long int)layer].face;
  }
}

// mapdata_get_image_size
// file mapdata.c line 1256
static void mapdata_get_image_size(signed int face, unsigned char *w, unsigned char *h)
{
  get_map_image_size(face, w, h);
  if(!((signed int)*w >= 1))
    *w = (unsigned char)1;

  if(!((signed int)*h >= 1))
    *h = (unsigned char)1;

  if((signed int)*w >= 17)
    *w = (unsigned char)16;

  if((signed int)*h >= 17)
    *h = (unsigned char)16;

}

// mapdata_init
// file ../../common/proto.h line 81
void mapdata_init(void)
{
  signed int x;
  signed int y;
  signed int i;
  if(the_map.cells == ((struct MapCell **)NULL))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct MapCell *) /*8ul*/  * (unsigned long int)512 + sizeof(struct MapCell) /*222ul*/  * (unsigned long int)512 * (unsigned long int)512);
    the_map.cells = (struct MapCell **)return_value_malloc$1;
    if(the_map.cells == ((struct MapCell **)NULL))
    {
      LOG((enum LogLevel)LOG_ERROR, "mapdata_init", "%s\n", (const void *)"out of memory");
      exit(1);
    }

    the_map.cells[(signed long int)0] = (struct MapCell *)((char *)the_map.cells + (signed long int)(sizeof(struct MapCell *) /*8ul*/  * (unsigned long int)512));
    i = 0;
    for( ; !(i >= 512); i = i + 1)
      the_map.cells[(signed long int)i] = the_map.cells[(signed long int)0] + (signed long int)(i * 512);
    the_map.x = 512;
    the_map.y = 512;
  }

  width$link1 = 0;
  height$link1 = 0;
  pl_pos.x = 512 / 2 - width$link1 / 2;
  pl_pos.y = 512 / 2 - height$link1 / 2;
  x = 0;
  for( ; !(x >= 512); x = x + 1)
    do
    {
      signed int clear_cells_i;
      signed int j;
      memset((void *)&the_map.cells[(signed long int)x][(signed long int)0], 0, sizeof(struct MapCell) /*222ul*/  * (unsigned long int)512);
      clear_cells_i = 0;
      for( ; !(clear_cells_i >= 512); clear_cells_i = clear_cells_i + 1)
      {
        j = 0;
        for( ; !(j >= 10); j = j + 1)
        {
          (the_map.cells[(signed long int)x] + (signed long int)(0 + clear_cells_i))->heads[(signed long int)j].size_x = (signed char)1;
          (the_map.cells[(signed long int)x] + (signed long int)(0 + clear_cells_i))->heads[(signed long int)j].size_y = (signed char)1;
        }
      }
    }
    while((_Bool)0);
  y = 0;
  for( ; !(y >= 64); y = y + 1)
  {
    x = 0;
    for( ; !(x >= 64); x = x + 1)
    {
      i = 0;
      for( ; !(i >= 10); i = i + 1)
      {
        bigfaces[(signed long int)x][(signed long int)y][(signed long int)i].next = (struct BigCell *)(void *)0;
        bigfaces[(signed long int)x][(signed long int)y][(signed long int)i].prev = (struct BigCell *)(void *)0;
        bigfaces[(signed long int)x][(signed long int)y][(signed long int)i].head.face = (signed short int)0;
        bigfaces[(signed long int)x][(signed long int)y][(signed long int)i].head.size_x = (signed char)1;
        bigfaces[(signed long int)x][(signed long int)y][(signed long int)i].head.size_y = (signed char)1;
        bigfaces[(signed long int)x][(signed long int)y][(signed long int)i].tail.face = (signed short int)0;
        bigfaces[(signed long int)x][(signed long int)y][(signed long int)i].tail.size_x = (signed char)0;
        bigfaces[(signed long int)x][(signed long int)y][(signed long int)i].tail.size_y = (signed char)0;
        bigfaces[(signed long int)x][(signed long int)y][(signed long int)i].x = (unsigned short int)x;
        bigfaces[(signed long int)x][(signed long int)y][(signed long int)i].y = (unsigned short int)y;
        bigfaces[(signed long int)x][(signed long int)y][(signed long int)i].layer = (unsigned char)i;
      }
    }
  }
  bigfaces_head = (struct BigCell *)(void *)0;
}

// mapdata_is_inside
// file mapdata.c line 595
signed int mapdata_is_inside(signed int x, signed int y)
{
  return (signed int)(x >= 0 && x < width$link1 && y >= 0 && y < height$link1);
}

// mapdata_newmap
// file ./proto.h line 93
void mapdata_newmap(void)
{
  signed int x;
  signed int y;
  x = 0;
  for( ; !(x >= 512); x = x + 1)
  {
    do
    {
      signed int clear_cells_i;
      signed int j;
      memset((void *)&the_map.cells[(signed long int)x][(signed long int)0], 0, sizeof(struct MapCell) /*222ul*/  * (unsigned long int)512);
      clear_cells_i = 0;
      for( ; !(clear_cells_i >= 512); clear_cells_i = clear_cells_i + 1)
      {
        j = 0;
        for( ; !(j >= 10); j = j + 1)
        {
          (the_map.cells[(signed long int)x] + (signed long int)(0 + clear_cells_i))->heads[(signed long int)j].size_x = (signed char)1;
          (the_map.cells[(signed long int)x] + (signed long int)(0 + clear_cells_i))->heads[(signed long int)j].size_y = (signed char)1;
        }
      }
    }
    while((_Bool)0);
    y = 0;
    for( ; !(y >= 512); y = y + 1)
      (the_map.cells[(signed long int)x] + (signed long int)y)->need_update = (unsigned char)1;
  }
  while(!(bigfaces_head == ((struct BigCell *)NULL)))
    expand_clear_bigface_from_layer((signed int)bigfaces_head->x, (signed int)bigfaces_head->y, (signed int)bigfaces_head->layer, 0);
  display_map_newmap();
}

// mapdata_reset
// file ../../common/proto.h line 82
void mapdata_reset(void)
{
  mapdata_init();
}

// mapdata_scroll
// file ./proto.h line 92
void mapdata_scroll(signed int dx, signed int dy)
{
  signed int x;
  signed int y;
  recenter_virtual_map_view(dx, dy);
  _Bool tmp_if_expr$2;
  signed int return_value_display_mapscroll$1;
  if(!(want_config[29l] == 0))
  {
    return_value_display_mapscroll$1=display_mapscroll(dx, dy);
    tmp_if_expr$2 = return_value_display_mapscroll$1 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  if(tmp_if_expr$2)
  {
    struct BigCell *cell = bigfaces_head;
    for( ; !(cell == ((struct BigCell *)NULL)); cell = cell->next)
    {
      x = 0;
      for( ; !(x >= (signed int)cell->head.size_x); x = x + 1)
      {
        y = (signed int)!(x != 0);
        for( ; !(y >= (signed int)cell->head.size_y); y = y + 1)
          if((signed int)cell->x + -x >= 0)
          {
            if(!((signed int)cell->x + -x >= width$link1))
            {
              if((signed int)cell->y + -y >= 0)
              {
                if(!((signed int)cell->y + -y >= height$link1))
                  (the_map.cells[(signed long int)((pl_pos.x + (signed int)cell->x) - x)] + (signed long int)((pl_pos.y + (signed int)cell->y) - y))->need_update = (unsigned char)1;

              }

            }

          }

      }
    }
  }

  else
  {
    x = 0;
    for( ; !(x >= width$link1); x = x + 1)
    {
      y = 0;
      for( ; !(y >= height$link1); y = y + 1)
        (the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->need_update = (unsigned char)1;
    }
  }
  pl_pos.x = pl_pos.x + dx;
  pl_pos.y = pl_pos.y + dy;
  if(dx >= 1)
  {
    y = 0;
    for( ; !(y >= height$link1); y = y + 1)
    {
      x = width$link1 - dx;
      for( ; !(x >= width$link1); x = x + 1)
      {
        (the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->cleared = (unsigned char)1;
        (the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->need_update = (unsigned char)1;
      }
    }
  }

  else
  {
    y = 0;
    for( ; !(y >= height$link1); y = y + 1)
    {
      x = 0;
      for( ; !(x >= -dx); x = x + 1)
      {
        (the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->cleared = (unsigned char)1;
        (the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->need_update = (unsigned char)1;
      }
    }
  }
  if(dy >= 1)
  {
    x = 0;
    for( ; !(x >= width$link1); x = x + 1)
    {
      y = height$link1 - dy;
      for( ; !(y >= height$link1); y = y + 1)
      {
        (the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->cleared = (unsigned char)1;
        (the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->need_update = (unsigned char)1;
      }
    }
  }

  else
  {
    x = 0;
    for( ; !(x >= width$link1); x = x + 1)
    {
      y = 0;
      for( ; !(y >= -dy); y = y + 1)
      {
        (the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->cleared = (unsigned char)1;
        (the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->need_update = (unsigned char)1;
      }
    }
  }
  while(!(bigfaces_head == ((struct BigCell *)NULL)))
    expand_clear_bigface_from_layer((signed int)bigfaces_head->x, (signed int)bigfaces_head->y, (signed int)bigfaces_head->layer, 0);
}

// mapdata_set_anim_layer
// file ./proto.h line 91
void mapdata_set_anim_layer(signed int x, signed int y, unsigned short int anim, unsigned char anim_speed, signed int layer)
{
  signed int px;
  signed int py;
  signed int i;
  signed int face;
  signed int animation;
  signed int phase;
  signed int speed_left;
  /* assertion 0 <= x && x < 64 */
  assert(0 <= x && x < 64);
  /* assertion 0 <= y && y < 64 */
  assert(0 <= y && y < 64);
  px = pl_pos.x + x;
  py = pl_pos.y + y;
  /* assertion 0 <= px && px < 512 */
  assert(0 <= px && px < 512);
  /* assertion 0 <= py && py < 512 */
  assert(0 <= py && py < 512);
  animation = (signed int)anim & 0x1fff;
  face = 0;
  if((0x6000 & (signed int)anim) == 8192)
  {
    signed long int return_value_random$1;
    return_value_random$1=random();
    phase = (signed int)(return_value_random$1 % (signed long int)animations[(signed long int)animation].num_animations);
    face = (signed int)animations[(signed long int)animation].faces[(signed long int)phase];
    signed long int return_value_random$2;
    return_value_random$2=random();
    speed_left = (signed int)((signed long int)anim_speed % return_value_random$2);
  }

  else
    if((0x6000 & (signed int)anim) == 16384)
    {
      animations[(signed long int)animation].speed = anim_speed;
      phase = (signed int)animations[(signed long int)animation].phase;
      speed_left = (signed int)animations[(signed long int)animation].speed_left;
      face = (signed int)animations[(signed long int)animation].faces[(signed long int)phase];
    }

  if(!(x >= width$link1) && !(y >= height$link1))
  {
    (the_map.cells[(signed long int)px] + (signed long int)py)->need_update = (unsigned char)1;
    if(!((the_map.cells[(signed long int)px] + (signed long int)py)->cleared == 0))
    {
      i = 0;
      for( ; !(i >= 10); i = i + 1)
        expand_clear_face_from_layer(px, py, i);
      (the_map.cells[(signed long int)px] + (signed long int)py)->darkness = (unsigned char)0;
      (the_map.cells[(signed long int)px] + (signed long int)py)->have_darkness = (unsigned char)0;
    }

    if(face >= 1)
    {
      expand_set_face(px, py, layer, (signed short int)face, 1);
      (the_map.cells[(signed long int)px] + (signed long int)py)->heads[(signed long int)layer].animation = (signed short int)animation;
      (the_map.cells[(signed long int)px] + (signed long int)py)->heads[(signed long int)layer].animation_phase = (unsigned char)phase;
      (the_map.cells[(signed long int)px] + (signed long int)py)->heads[(signed long int)layer].animation_speed = anim_speed;
      (the_map.cells[(signed long int)px] + (signed long int)py)->heads[(signed long int)layer].animation_left = (unsigned char)speed_left;
    }

    else
      expand_clear_face_from_layer(px, py, layer);
    (the_map.cells[(signed long int)px] + (signed long int)py)->cleared = (unsigned char)0;
  }

  else
    expand_set_bigface(x, y, layer, (signed short int)face, 1);
}

// mapdata_set_check_space
// file ./proto.h line 86
void mapdata_set_check_space(signed int x, signed int y)
{
  signed int px;
  signed int py;
  signed int is_blank;
  signed int i;
  struct MapCell *cell;
  /* assertion 0 <= x && x < 64 */
  assert(0 <= x && x < 64);
  /* assertion 0 <= y && y < 64 */
  assert(0 <= y && y < 64);
  px = pl_pos.x + x;
  py = pl_pos.y + y;
  /* assertion 0 <= px && px < 512 */
  assert(0 <= px && px < 512);
  /* assertion 0 <= py && py < 512 */
  assert(0 <= py && py < 512);
  is_blank = 1;
  cell = &the_map.cells[(signed long int)px][(signed long int)py];
  i = 0;
  _Bool tmp_if_expr$1;
  for( ; !(i >= 10); i = i + 1)
  {
    if((signed int)cell->heads[(signed long int)i].face >= 1)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)cell->tails[(signed long int)i].face > 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
    {
      is_blank = 0;
      break;
    }

  }
  if(!(cell->have_darkness == 0))
    is_blank = 0;

  if(!(is_blank == 0))
  {
    if(!(x >= width$link1) && !(y >= height$link1))
    {
      if((the_map.cells[(signed long int)px] + (signed long int)py)->cleared == 0)
      {
        (the_map.cells[(signed long int)px] + (signed long int)py)->cleared = (unsigned char)1;
        (the_map.cells[(signed long int)px] + (signed long int)py)->need_update = (unsigned char)1;
        i = 0;
        for( ; !(i >= 10); i = i + 1)
          expand_need_update_from_layer(px, py, i);
      }

    }

  }

}

// mapdata_set_darkness
// file ./proto.h line 87
void mapdata_set_darkness(signed int x, signed int y, signed int darkness)
{
  signed int px;
  signed int py;
  /* assertion 0 <= x && x < 64 */
  assert(0 <= x && x < 64);
  /* assertion 0 <= y && y < 64 */
  assert(0 <= y && y < 64);
  px = pl_pos.x + x;
  py = pl_pos.y + y;
  /* assertion 0 <= px && px < 512 */
  assert(0 <= px && px < 512);
  /* assertion 0 <= py && py < 512 */
  assert(0 <= py && py < 512);
  if(!(darkness == -1) && !(x >= width$link1) && !(y >= height$link1))
    set_darkness(px, py, 255 - darkness);

}

// mapdata_set_face_layer
// file ./proto.h line 90
void mapdata_set_face_layer(signed int x, signed int y, signed short int face, signed int layer)
{
  signed int px;
  signed int py;
  /* assertion 0 <= x && x < 64 */
  assert(0 <= x && x < 64);
  /* assertion 0 <= y && y < 64 */
  assert(0 <= y && y < 64);
  px = pl_pos.x + x;
  py = pl_pos.y + y;
  /* assertion 0 <= px && px < 512 */
  assert(0 <= px && px < 512);
  /* assertion 0 <= py && py < 512 */
  assert(0 <= py && py < 512);
  if(!(x >= width$link1) && !(y >= height$link1))
  {
    (the_map.cells[(signed long int)px] + (signed long int)py)->need_update = (unsigned char)1;
    if((signed int)face >= 1)
      expand_set_face(px, py, layer, face, 1);

    else
      expand_clear_face_from_layer(px, py, layer);
    (the_map.cells[(signed long int)px] + (signed long int)py)->cleared = (unsigned char)0;
  }

  else
    expand_set_bigface(x, y, layer, face, 1);
}

// mapdata_set_size
// file ../../common/proto.h line 83
void mapdata_set_size(signed int viewx, signed int viewy)
{
  mapdata_init();
  width$link1 = viewx;
  height$link1 = viewy;
  pl_pos.x = 512 / 2 - width$link1 / 2;
  pl_pos.y = 512 / 2 - height$link1 / 2;
}

// mapdata_set_smooth
// file ./proto.h line 88
void mapdata_set_smooth(signed int x, signed int y, signed int smooth, signed int layer)
{
  signed int rx;
  signed int ry;
  signed int px;
  signed int py;
  signed int i;
  /* assertion 0 <= x && x < 64 */
  assert(0 <= x && x < 64);
  /* assertion 0 <= y && y < 64 */
  assert(0 <= y && y < 64);
  px = pl_pos.x + x;
  py = pl_pos.y + y;
  /* assertion 0 <= px && px < 512 */
  assert(0 <= px && px < 512);
  /* assertion 0 <= py && py < 512 */
  assert(0 <= py && py < 512);
  if(!((signed int)(the_map.cells[(signed long int)px] + (signed long int)py)->smooth[(signed long int)layer] == smooth))
  {
    i = 0;
    for( ; !(i >= 8); i = i + 1)
    {
      static signed int mapdata_set_smooth$$1$$dx[8l] = { 0, 1, 1, 1, 0, -1, -1, -1 };
      rx = px + mapdata_set_smooth$$1$$dx[(signed long int)i];
      static signed int mapdata_set_smooth$$1$$dy[8l] = { -1, -1, 0, 1, 1, 1, 0, -1 };
      ry = py + mapdata_set_smooth$$1$$dy[(signed long int)i];
      if(!(rx >= the_map.x) && !(ry >= the_map.y) && rx >= 0 && ry >= 0)
        (the_map.cells[(signed long int)rx] + (signed long int)ry)->need_resmooth = (unsigned char)1;

    }
    (the_map.cells[(signed long int)px] + (signed long int)py)->need_resmooth = (unsigned char)1;
    (the_map.cells[(signed long int)px] + (signed long int)py)->smooth[(signed long int)layer] = (unsigned short int)smooth;
  }

}

// mapping_sort
// file stats.c line 515
static signed int mapping_sort(struct anonymous$66 *a, struct anonymous$66 *b)
{
  if(a->name == ((const char *)NULL))
  {
    if(!(b->name == ((const char *)NULL)))
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(a->name == ((const char *)NULL))
      return 1;

    else
      if(b->name == ((const char *)NULL))
        return -1;

      else
      {
        signed int return_value_strcasecmp$1;
        return_value_strcasecmp$1=strcasecmp(a->name, b->name);
        return return_value_strcasecmp$1;
      }
  }
}

// mark_resmooth
// file mapdata.c line 158
static void mark_resmooth(signed int x, signed int y, signed int layer)
{
  signed int sdx;
  signed int sdy;
  if((signed int)(the_map.cells[(signed long int)x] + (signed long int)y)->smooth[(signed long int)layer] >= 2)
  {
    sdx = -1;
    for( ; !(sdx >= 2); sdx = sdx + 1)
    {
      sdy = -1;
      for( ; !(sdy >= 2); sdy = sdy + 1)
        if(sdx + x >= 1 && sdy + y >= 1 && !(sdx + x >= 512) && !(sdy + y >= 512) && (!(sdx == 0) || !(sdy == 0)))
          (the_map.cells[(signed long int)(x + sdx)] + (signed long int)(y + sdy))->need_resmooth = (unsigned char)1;

    }
  }

}

// menu_about
// file about.c line 41
extern void menu_about(struct _GtkMenuItem *menuitem, void *user_data)
{
  if(about_window == ((struct _GtkWidget *)NULL))
  {
    struct _GtkImage *about_image;
    struct _GObject *return_value_gtk_builder_get_object$1;
    return_value_gtk_builder_get_object$1=gtk_builder_get_object(dialog_xml, "about_window");
    unsigned long int return_value_gtk_widget_get_type$2;
    return_value_gtk_widget_get_type$2=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
    about_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
    struct _GObject *return_value_gtk_builder_get_object$4;
    return_value_gtk_builder_get_object$4=gtk_builder_get_object(dialog_xml, "about_image");
    unsigned long int return_value_gtk_image_get_type$5;
    return_value_gtk_image_get_type$5=gtk_image_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$4, return_value_gtk_image_get_type$5);
    about_image = (struct _GtkImage *)return_value_g_type_check_instance_cast$6;
    g_signal_connect_data((void *)about_window, "delete_event", (void (*)(void))gtk_widget_hide_on_delete, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    struct _GdkPixbuf *return_value_gdk_pixbuf_new_from_xpm_data$7;
    return_value_gdk_pixbuf_new_from_xpm_data$7=gdk_pixbuf_new_from_xpm_data((const char **)crossfiretitle_xpm);
    gtk_image_set_from_pixbuf(about_image, return_value_gdk_pixbuf_new_from_xpm_data$7);
    gtk_widget_show(about_window);
  }

  else
    gtk_widget_show(about_window);
}

// menu_clear
// file info.c line 1278
extern void menu_clear(void)
{
  signed int i = 0;
  for( ; !(i >= 2); i = i + 1)
    gtk_text_buffer_set_text(info_pane[(signed long int)i].textbuffer, "", 0);
}

// menu_quit_character
// file menubar.c line 88
extern void menu_quit_character(struct _GtkMenuItem *menuitem, void *user_data)
{
  extended_command("quit");
}

// menu_quit_program
// file menubar.c line 68
extern void menu_quit_program(struct _GtkMenuItem *menuitem, void *user_data)
{
  LOG((enum LogLevel)LOG_INFO, "gtk-v2::client_exit", "Exiting with return value 0.");
  exit(0);
}

// message_callback
// file info.c line 1110
static void message_callback(signed int orig_color, signed int type, signed int subtype, char *message)
{
  signed int search;
  signed int found;
  signed int empty;
  signed int oldest;
  signed int empty_age;
  signed int oldest_age;
  _Bool tmp_if_expr$3;
  if(orig_color == 0x100 || type >= 21 || !(type >= 1))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = msgctrl_widgets[(signed long int)(type - 1)].buffer.state == 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$5;
  unsigned long int return_value_strlen$4;
  if(tmp_if_expr$3)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_strlen$4=strlen(message);
    tmp_if_expr$5 = return_value_strlen$4 >= (unsigned long int)56 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
    draw_ext_info(orig_color, type, subtype, message);

  else
  {
    empty = -1;
    found = -1;
    oldest = -1;
    empty_age = -1;
    oldest_age = -1;
    search = 0;
    for( ; !(search >= 10); search = search + 1)
    {
      if(!(info_buffer[(signed long int)search].count >= 0))
      {
        if(!(empty_age >= info_buffer[(signed long int)search].age))
        {
          empty_age = info_buffer[(signed long int)search].age;
          empty = search;
        }

      }

      else
        if(!(oldest_age >= info_buffer[(signed long int)search].age))
        {
          oldest_age = info_buffer[(signed long int)search].age;
          oldest = search;
        }

      if(!(found >= 0))
      {
        signed int return_value_strcmp$1;
        return_value_strcmp$1=strcmp(message, info_buffer[(signed long int)search].message);
        if(return_value_strcmp$1 == 0)
          found = search;

      }

    }
    if(found >= 0)
    {
      if(info_buffer[(signed long int)found].count == -1)
      {
        info_buffer[(signed long int)found].count = info_buffer[(signed long int)found].count + 1;
        info_buffer[(signed long int)found].age = 0;
      }

      info_buffer[(signed long int)found].count = info_buffer[(signed long int)found].count + 1;
    }

    else
    {
      if(empty == -1)
      {
        if(oldest >= 0)
          info_buffer_flush(oldest);

        else
        {
          unsigned long int return_value_strlen$2;
          return_value_strlen$2=strlen(message);
          LOG((enum LogLevel)LOG_ERROR, "info.c::message_callback", "Buffer full; oldest unknown", return_value_strlen$2);
        }
      }

      draw_ext_info(orig_color, type, subtype, message);
      if(empty >= 0)
      {
        info_buffer[(signed long int)empty].age = 0;
        info_buffer[(signed long int)empty].count = 0;
        info_buffer[(signed long int)empty].orig_color = orig_color;
        info_buffer[(signed long int)empty].type = type;
        info_buffer[(signed long int)empty].subtype = subtype;
        strcpy(info_buffer[(signed long int)empty].message, message);
      }

    }
  }
}

// meta_sort
// file ../../common/metaserver.h line 80
extern signed int meta_sort(struct Meta_Info *m1, struct Meta_Info *m2)
{
  signed int return_value_strcasecmp$1;
  return_value_strcasecmp$1=strcasecmp(m1->hostname, m2->hostname);
  return return_value_strcasecmp$1;
}

// metaserver1_get_info
// file metaserver.c line 822
signed int metaserver1_get_info(void)
{
  unsigned long int thread_id;
  signed int ret;
  if(metaserver_on == 0)
    return 0;

  else
  {
    metaserver_load_cache();
    pthread_mutex_lock(&ms2_info_mutex);
    if(meta_servers == ((struct Meta_Info *)NULL))
    {
      void *return_value_calloc$1;
      return_value_calloc$1=calloc((unsigned long int)100, sizeof(struct Meta_Info) /*1928ul*/ );
      meta_servers = (struct Meta_Info *)return_value_calloc$1;
    }

    ms1_is_running = 1;
    pthread_mutex_unlock(&ms2_info_mutex);
    ret=pthread_create(&thread_id, (const union pthread_attr_t *)(void *)0, metaserver1_thread, (void *)0);
    if(!(ret == 0))
    {
      LOG((enum LogLevel)LOG_ERROR, "common::metaserver1_get_info", "Thread creation failed.");
      pthread_mutex_lock(&ms2_info_mutex);
      ms1_is_running = 0;
      pthread_mutex_unlock(&ms2_info_mutex);
    }

    return 0;
  }
}

// metaserver1_thread
// file metaserver.c line 636
void * metaserver1_thread(void *junk)
{
  struct protoent *protox;
  signed int fd;
  struct sockaddr_in insock;
  struct _IO_FILE *fp;
  char inbuf[2048l];
  struct Meta_Info *current;
  protox=getprotobyname("tcp");
  if(protox == ((struct protoent *)NULL))
  {
    LOG((enum LogLevel)LOG_WARNING, "common::metaserver_get_info", "Error getting protobyname (tcp)");
    pthread_mutex_lock(&ms2_info_mutex);
    ms1_is_running = 0;
    pthread_mutex_unlock(&ms2_info_mutex);
    pthread_exit((void *)0);
  }

  fd=socket(2, 1, protox->p_proto);
  if(fd == -1)
  {
    perror("get_metaserver_info:  Error on socket command.\n");
    pthread_mutex_lock(&ms2_info_mutex);
    ms1_is_running = 0;
    pthread_mutex_unlock(&ms2_info_mutex);
    pthread_exit((void *)0);
  }

  insock.sin_family = (unsigned short int)2;
  insock.sin_port=htons((unsigned short int)meta_port);
  const unsigned short int **return_value___ctype_b_loc$1;
  return_value___ctype_b_loc$1=__ctype_b_loc();
  if(!((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*meta_server]) == 0))
    insock.sin_addr.s_addr=inet_addr(meta_server);

  else
  {
    struct hostent *hostbn;
    hostbn=gethostbyname(meta_server);
    if(hostbn == ((struct hostent *)NULL))
    {
      LOG((enum LogLevel)LOG_WARNING, "common::metaserver_get_info", "Unknown metaserver hostname: %s", meta_server);
      pthread_mutex_lock(&ms2_info_mutex);
      ms1_is_running = 0;
      pthread_mutex_unlock(&ms2_info_mutex);
      pthread_exit((void *)0);
    }

    memcpy((void *)&insock.sin_addr, (const void *)hostbn->h_addr_list[(signed long int)0], (unsigned long int)hostbn->h_length);
  }
  signed int return_value_connect$2;
  return_value_connect$2=connect(fd, (struct sockaddr *)&insock, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
  if(return_value_connect$2 == -1)
  {
    perror("Can't connect to metaserver");
    draw_ext_info(0, 20, 7, "\nCan't connect to metaserver.");
    pthread_mutex_lock(&ms2_info_mutex);
    ms1_is_running = 0;
    pthread_mutex_unlock(&ms2_info_mutex);
    pthread_exit((void *)0);
  }

  fp=fdopen(fd, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    perror("fdopen failed.");
    pthread_mutex_lock(&ms2_info_mutex);
    ms1_is_running = 0;
    pthread_mutex_unlock(&ms2_info_mutex);
    pthread_exit((void *)0);
  }

  pthread_mutex_lock(&ms2_info_mutex);
  if(meta_servers == ((struct Meta_Info *)NULL))
  {
    void *return_value_calloc$3;
    return_value_calloc$3=calloc((unsigned long int)100, sizeof(struct Meta_Info) /*1928ul*/ );
    meta_servers = (struct Meta_Info *)return_value_calloc$3;
  }

  char *return_value_fgets$4;
  char *tmp_post$5;
  char *tmp_post$6;
  char *tmp_post$7;
  char *tmp_post$8;
  char *tmp_post$9;
  do
  {
    return_value_fgets$4=fgets(inbuf, 512 * 4 - 1, fp);
    if(return_value_fgets$4 == ((char *)NULL))
      break;

    char *cp;
    char *cp1;
    cp=strchr(inbuf, 124);
    if(cp == ((char *)NULL))
    {
      LOG((enum LogLevel)LOG_WARNING, "common::metaserver_get_info", "Corrupt line from server: %s", (const void *)inbuf);
      break;
    }

    *cp = (char)0;
    current = &meta_servers[(signed long int)meta_numservers];
    strncpy(current->ip_addr, inbuf, sizeof(char [60l]) /*60ul*/  - (unsigned long int)1);
    current->ip_addr[(signed long int)(sizeof(char [60l]) /*60ul*/  - (unsigned long int)1)] = (char)0;
    tmp_post$5 = cp;
    cp = cp + 1l;
    *tmp_post$5 = (char)124;
    current->idle_time=atoi(cp);
    cp1=strchr(cp, 124);
    if(cp1 == ((char *)NULL))
    {
      LOG((enum LogLevel)LOG_WARNING, "common::metaserver_get_info", "Corrupt line from server: %s", (const void *)inbuf);
      break;
    }

    *cp1 = (char)0;
    cp=strchr(cp1 + (signed long int)1, 124);
    if(cp == ((char *)NULL))
    {
      LOG((enum LogLevel)LOG_WARNING, "common::metaserver_get_info", "Corrupt line from server: %s", (const void *)inbuf);
      break;
    }

    *cp = (char)0;
    strncpy(current->hostname, cp1 + (signed long int)1, sizeof(char [512l]) /*512ul*/  - (unsigned long int)1);
    current->hostname[(signed long int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1)] = (char)0;
    tmp_post$6 = cp1;
    cp1 = cp1 + 1l;
    *tmp_post$6 = (char)124;
    tmp_post$7 = cp;
    cp = cp + 1l;
    *tmp_post$7 = (char)124;
    current->num_players=atoi(cp);
    cp1=strchr(cp, 124);
    if(cp1 == ((char *)NULL))
    {
      LOG((enum LogLevel)LOG_WARNING, "common::metaserver_get_info", "Corrupt line from server: %s", (const void *)inbuf);
      break;
    }

    *cp1 = (char)0;
    cp=strchr(cp1 + (signed long int)1, 124);
    if(cp == ((char *)NULL))
    {
      LOG((enum LogLevel)LOG_WARNING, "common::metaserver_get_info", "Corrupt line from server: %s", (const void *)inbuf);
      break;
    }

    *cp = (char)0;
    strncpy(current->version, cp1 + (signed long int)1, sizeof(char [60l]) /*60ul*/  - (unsigned long int)1);
    current->version[(signed long int)(sizeof(char [60l]) /*60ul*/  - (unsigned long int)1)] = (char)0;
    tmp_post$8 = cp1;
    cp1 = cp1 + 1l;
    *tmp_post$8 = (char)124;
    tmp_post$9 = cp;
    cp = cp + 1l;
    *tmp_post$9 = (char)124;
    cp1=strchr(cp, 10);
    if(cp1 == ((char *)NULL))
    {
      LOG((enum LogLevel)LOG_WARNING, "common::metaserver_get_info", "Corrupt line from server: %s", (const void *)inbuf);
      break;
    }

    *cp1 = (char)0;
    cp1=strchr(cp, 124);
    if(!(cp1 == ((char *)NULL)))
      *cp1 = (char)0;

    strncpy(current->text_comment, cp, sizeof(char [512l]) /*512ul*/  - (unsigned long int)1);
    current->text_comment[(signed long int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1)] = (char)0;
    meta_numservers = meta_numservers + 1;
    if(meta_numservers >= 100)
    {
      LOG((enum LogLevel)LOG_WARNING, "common:metaserver_get_info", "Have reached maximum metaserver count\n");
      break;
    }

  }
  while((_Bool)1);
  fclose(fp);
  qsort((void *)meta_servers, (unsigned long int)meta_numservers, sizeof(struct Meta_Info) /*1928ul*/ , (signed int (*)(const void *, const void *))meta_sort);
  ms1_is_running = 0;
  pthread_mutex_unlock(&ms2_info_mutex);
  pthread_exit((void *)0);
  return (void *)0;
}

// metaserver2_get_info
// file metaserver.c line 502
signed int metaserver2_get_info(void)
{
  unsigned long int thread_id;
  signed int ret;
  if(metaserver2_on == 0)
    return 0;

  else
  {
    metaserver_load_cache();
    pthread_mutex_lock(&ms2_info_mutex);
    if(meta_servers == ((struct Meta_Info *)NULL))
    {
      void *return_value_calloc$1;
      return_value_calloc$1=calloc((unsigned long int)100, sizeof(struct Meta_Info) /*1928ul*/ );
      meta_servers = (struct Meta_Info *)return_value_calloc$1;
    }

    ms2_is_running = 1;
    pthread_mutex_unlock(&ms2_info_mutex);
    ret=pthread_create(&thread_id, (const union pthread_attr_t *)(void *)0, metaserver2_thread, (void *)0);
    if(!(ret == 0))
    {
      LOG((enum LogLevel)LOG_ERROR, "common::metaserver2_get_info", "Thread creation failed.");
      pthread_mutex_lock(&ms2_info_mutex);
      ms2_is_running = 0;
      pthread_mutex_unlock(&ms2_info_mutex);
    }

    return 0;
  }
}

// metaserver2_thread
// file metaserver.c line 472
void * metaserver2_thread(void *junk)
{
  signed int metaserver_choice;
  signed int tries = 0;
  signed int return_value_get_metaserver2_data$1;
  do
  {
    signed long int return_value_random$2;
    return_value_random$2=random();
    metaserver_choice = (signed int)((unsigned long int)return_value_random$2 % (sizeof(char *[1l]) /*8ul*/  / sizeof(char *) /*8ul*/ ));
    tries = tries + 1;
    if(tries >= 6)
      break;

    return_value_get_metaserver2_data$1=get_metaserver2_data(metaservers[(signed long int)metaserver_choice]);
  }
  while(return_value_get_metaserver2_data$1 == 0);
  pthread_mutex_lock(&ms2_info_mutex);
  qsort((void *)meta_servers, (unsigned long int)meta_numservers, sizeof(struct Meta_Info) /*1928ul*/ , (signed int (*)(const void *, const void *))meta_sort);
  ms2_is_running = 0;
  pthread_mutex_unlock(&ms2_info_mutex);
  pthread_exit((void *)0);
  return (void *)0;
}

// metaserver2_writer
// file metaserver.c line 298
unsigned long int metaserver2_writer(void *ptr, unsigned long int size, unsigned long int nmemb, void *data)
{
  unsigned long int realsize = size * nmemb;
  char *cp;
  char *newline;
  char *eq;
  char inbuf[32769l];
  char *leftover = (char *)data;
  if(realsize >= 16385ul)
    LOG((enum LogLevel)LOG_CRITICAL, "common::metaserver2_writer", "Function called with more data than allowed!");

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(leftover);
  memcpy((void *)inbuf, (const void *)leftover, return_value_strlen$1);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(leftover);
  memcpy((void *)(inbuf + (signed long int)return_value_strlen$2), ptr, realsize);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(leftover);
  inbuf[(signed long int)(return_value_strlen$3 + realsize)] = (char)0;
  leftover[(signed long int)0] = (char)0;
  pthread_mutex_lock(&ms2_info_mutex);
  cp = inbuf;
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp$26;
  signed int return_value_strcmp$24;
  signed int return_value_strcmp$23;
  signed int return_value_strcmp$22;
  signed int return_value_strcmp$21;
  signed int return_value_strcmp$20;
  signed int return_value_strcmp$19;
  signed int return_value_strcmp$18;
  signed int return_value_strcmp$17;
  signed int return_value_strcmp$16;
  signed int return_value_strcmp$15;
  signed int return_value_strcmp$14;
  signed int return_value_strcmp$13;
  signed int return_value_strcmp$12;
  signed int return_value_strcmp$11;
  signed int return_value_strcmp$10;
  do
  {
    if(!(cp == ((char *)NULL)))
      tmp_if_expr$4 = (signed int)*cp != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(!tmp_if_expr$4)
      break;

    newline=strchr(cp, 10);
    if(!(newline == ((char *)NULL)))
    {
      *newline = (char)0;
      newline = newline + 1l;
    }

    else
    {
      strncpy(leftover, cp, (unsigned long int)(16384 - 1));
      leftover[(signed long int)(16384 - 1)] = (char)0;
      break;
    }
    eq=strchr(cp, 61);
    if(!(eq == ((char *)NULL)))
    {
      *eq = (char)0;
      eq = eq + 1l;
    }

    signed int return_value_strcmp$27;
    return_value_strcmp$27=strcmp(cp, "START_SERVER_DATA");
    if(return_value_strcmp$27 == 0)
      memset((void *)&meta_servers[(signed long int)meta_numservers], 0, sizeof(struct Meta_Info) /*1928ul*/ );

    else
    {
      return_value_strcmp$26=strcmp(cp, "END_SERVER_DATA");
      if(return_value_strcmp$26 == 0)
      {
        signed int i = 0;
        for( ; !(i >= meta_numservers); i = i + 1)
        {
          signed int return_value_strcasecmp$5;
          return_value_strcasecmp$5=strcasecmp((meta_servers + (signed long int)i)->hostname, (meta_servers + (signed long int)meta_numservers)->hostname);
          if(return_value_strcasecmp$5 == 0)
          {
            memcpy((void *)&meta_servers[(signed long int)i], (const void *)&meta_servers[(signed long int)meta_numservers], sizeof(struct Meta_Info) /*1928ul*/ );
            break;
          }

        }
        if(i >= meta_numservers)
          meta_numservers = meta_numservers + 1;

      }

      else
      {
        if(eq == ((char *)NULL))
        {
          LOG((enum LogLevel)LOG_ERROR, "common::metaserver2_writer", "Unknown line: %s", cp);
          goto __CPROVER_DUMP_L34;
        }

        signed int return_value_strcmp$25;
        return_value_strcmp$25=strcmp(cp, "hostname");
        if(return_value_strcmp$25 == 0)
          strncpy((meta_servers + (signed long int)meta_numservers)->hostname, eq, sizeof(char [512l]) /*512ul*/ );

        else
        {
          return_value_strcmp$24=strcmp(cp, "port");
          if(return_value_strcmp$24 == 0)
            (meta_servers + (signed long int)meta_numservers)->port=atoi(eq);

          else
          {
            return_value_strcmp$23=strcmp(cp, "html_comment");
            if(return_value_strcmp$23 == 0)
              strncpy((meta_servers + (signed long int)meta_numservers)->html_comment, eq, sizeof(char [512l]) /*512ul*/ );

            else
            {
              return_value_strcmp$22=strcmp(cp, "text_comment");
              if(return_value_strcmp$22 == 0)
                strncpy((meta_servers + (signed long int)meta_numservers)->text_comment, eq, sizeof(char [512l]) /*512ul*/ );

              else
              {
                return_value_strcmp$21=strcmp(cp, "archbase");
                if(return_value_strcmp$21 == 0)
                  strncpy((meta_servers + (signed long int)meta_numservers)->archbase, eq, sizeof(char [60l]) /*60ul*/ );

                else
                {
                  return_value_strcmp$20=strcmp(cp, "mapbase");
                  if(return_value_strcmp$20 == 0)
                    strncpy((meta_servers + (signed long int)meta_numservers)->mapbase, eq, sizeof(char [60l]) /*60ul*/ );

                  else
                  {
                    return_value_strcmp$19=strcmp(cp, "codebase");
                    if(return_value_strcmp$19 == 0)
                      strncpy((meta_servers + (signed long int)meta_numservers)->codebase, eq, sizeof(char [60l]) /*60ul*/ );

                    else
                    {
                      return_value_strcmp$18=strcmp(cp, "flags");
                      if(return_value_strcmp$18 == 0)
                        strncpy((meta_servers + (signed long int)meta_numservers)->flags, eq, sizeof(char [60l]) /*60ul*/ );

                      else
                      {
                        return_value_strcmp$17=strcmp(cp, "version");
                        if(return_value_strcmp$17 == 0)
                          strncpy((meta_servers + (signed long int)meta_numservers)->version, eq, sizeof(char [60l]) /*60ul*/ );

                        else
                        {
                          return_value_strcmp$16=strcmp(cp, "num_players");
                          if(return_value_strcmp$16 == 0)
                            (meta_servers + (signed long int)meta_numservers)->num_players=atoi(eq);

                          else
                          {
                            return_value_strcmp$15=strcmp(cp, "in_bytes");
                            if(return_value_strcmp$15 == 0)
                            {
                              signed int return_value_atoi$6;
                              return_value_atoi$6=atoi(eq);
                              (meta_servers + (signed long int)meta_numservers)->in_bytes = (unsigned int)return_value_atoi$6;
                            }

                            else
                            {
                              return_value_strcmp$14=strcmp(cp, "out_bytes");
                              if(return_value_strcmp$14 == 0)
                              {
                                signed int return_value_atoi$7;
                                return_value_atoi$7=atoi(eq);
                                (meta_servers + (signed long int)meta_numservers)->out_bytes = (unsigned int)return_value_atoi$7;
                              }

                              else
                              {
                                return_value_strcmp$13=strcmp(cp, "uptime");
                                if(return_value_strcmp$13 == 0)
                                  (meta_servers + (signed long int)meta_numservers)->uptime=atoi(eq);

                                else
                                {
                                  return_value_strcmp$12=strcmp(cp, "sc_version");
                                  if(return_value_strcmp$12 == 0)
                                    (meta_servers + (signed long int)meta_numservers)->sc_version=atoi(eq);

                                  else
                                  {
                                    return_value_strcmp$11=strcmp(cp, "cs_version");
                                    if(return_value_strcmp$11 == 0)
                                      (meta_servers + (signed long int)meta_numservers)->cs_version=atoi(eq);

                                    else
                                    {
                                      return_value_strcmp$10=strcmp(cp, "last_update");
                                      if(return_value_strcmp$10 == 0)
                                      {
                                        signed long int return_value_time$8;
                                        return_value_time$8=time((signed long int *)(void *)0);
                                        signed int return_value_atoi$9;
                                        return_value_atoi$9=atoi(eq);
                                        (meta_servers + (signed long int)meta_numservers)->idle_time = (signed int)(return_value_time$8 - (signed long int)return_value_atoi$9);
                                        if(!((meta_servers + (signed long int)meta_numservers)->idle_time >= 0))
                                          (meta_servers + (signed long int)meta_numservers)->idle_time = 0;

                                      }

                                      else
                                        LOG((enum LogLevel)LOG_ERROR, "common::metaserver2_writer", "Unknown line: %s=%s", cp, eq);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

  __CPROVER_DUMP_L34:
    ;
    cp = newline;
  }
  while((_Bool)1);
  pthread_mutex_unlock(&ms2_info_mutex);
  return realsize;
}

// metaserver_check_status
// file ../../common/proto.h line 106
signed int metaserver_check_status(void)
{
  signed int status;
  pthread_mutex_lock(&ms2_info_mutex);
  status = ms2_is_running | ms1_is_running;
  pthread_mutex_unlock(&ms2_info_mutex);
  return status;
}

// metaserver_connect_to
// file metaserver.c line 246
static void metaserver_connect_to(const char *name)
{
  char buf[256l];
  char *next_token = (char *)name;
  char *hostname;
  signed int port = (signed int)use_config[(signed long int)23];
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Connecting to '%s'...", name);
  unsigned long int return_value_gtk_label_get_type$1;
  return_value_gtk_label_get_type$1=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)metaserver_status, return_value_gtk_label_get_type$1);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, buf);
  gtk_main_iteration();
  hostname=strsep(&next_token, ":");
  if(!(next_token == ((char *)NULL)))
    port=atoi(next_token);

  csocket.fd=init_connection(hostname, port);
  if(!(csocket.fd == -1))
  {
    LOG((enum LogLevel)LOG_DEBUG, "gtk-v2::metaserver_connect_to", "Connected to '%s'!", name);
    metaserver_update_cache(name, name);
    gtk_main_quit();
    cpl.input_state = (enum Input_State)Playing;
  }

  else
  {
    snprintf(buf, (unsigned long int)255, "Unable to connect to %s!", name);
    unsigned long int return_value_gtk_label_get_type$3;
    return_value_gtk_label_get_type$3=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)metaserver_status, return_value_gtk_label_get_type$3);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, buf);
  }
}

// metaserver_get_info
// file ../../common/proto.h line 107
signed int metaserver_get_info(char *metaserver, signed int meta_port)
{
  meta_numservers = 0;
  metaserver2_get_info();
  if(!(metaserver_on == 0))
    metaserver1_get_info();

  return 0;
}

// metaserver_load_cache
// file metaserver.c line 122
static void metaserver_load_cache(void)
{
  char name[512l];
  char ip[512l];
  struct _IO_FILE *cache;
  char *return_value_fgets$1;
  char *return_value_fgets$2;
  signed int tmp_post$5;
  if(!(cached_server_file == ((const char *)NULL)) && cached_servers_loaded == 0)
  {
    cached_servers_loaded = 1;
    cached_servers_num = 0;
    cache=fopen(cached_server_file, "r");
    if(!(cache == ((struct _IO_FILE *)NULL)))
    {
      while(!(cached_servers_num >= 10))
      {
        return_value_fgets$1=fgets(name, 512, cache);
        if(return_value_fgets$1 == ((char *)NULL))
          break;

        return_value_fgets$2=fgets(ip, 512, cache);
        if(return_value_fgets$2 == ((char *)NULL))
          break;

        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(ip);
        ip[(signed long int)(return_value_strlen$3 - (unsigned long int)1)] = (char)0;
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(name);
        name[(signed long int)(return_value_strlen$4 - (unsigned long int)1)] = (char)0;
        cached_servers_ip[(signed long int)cached_servers_num]=strdup(ip);
        tmp_post$5 = cached_servers_num;
        cached_servers_num = cached_servers_num + 1;
        cached_servers_name[(signed long int)tmp_post$5]=strdup(name);
      }
      fclose(cache);
    }

  }

}

// metaserver_save_cache
// file metaserver.c line 154
static void metaserver_save_cache(void)
{
  struct _IO_FILE *cache;
  signed int metaserver_save_cache$$1$$server;
  if(!(cached_server_file == ((const char *)NULL)))
  {
    cache=fopen(cached_server_file, "w");
    if(!(cache == ((struct _IO_FILE *)NULL)))
    {
      metaserver_save_cache$$1$$server = 0;
      for( ; !(metaserver_save_cache$$1$$server >= cached_servers_num); metaserver_save_cache$$1$$server = metaserver_save_cache$$1$$server + 1)
      {
        fprintf(cache, "%s\n", cached_servers_name[(signed long int)metaserver_save_cache$$1$$server]);
        fprintf(cache, "%s\n", cached_servers_ip[(signed long int)metaserver_save_cache$$1$$server]);
      }
      fclose(cache);
    }

  }

}

// metaserver_select
// file metaserver.c line 971
signed int metaserver_select(char *sel)
{
  signed int num;
  num=atoi(sel);
  signed int port = 0;
  char buf[256l];
  char buf2[256l];
  char *server_name = (char *)(void *)0;
  char *server_ip;
  _Bool tmp_if_expr$2;
  char *return_value_strchr$1;
  _Bool tmp_if_expr$3;
  if((signed int)*sel == 0)
  {
    metaserver_get_info(meta_server, meta_port);
    metaserver_show(1);
    return 1;
  }

  else
  {
    if(num == 0)
    {
      if((signed int)*sel == 48)
        exit(0);

    }

    pthread_mutex_lock(&ms2_info_mutex);
    if(num == 0)
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_strchr$1=strchr(sel, 46);
      tmp_if_expr$2 = return_value_strchr$1 != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
    {
      server_name = sel;
      server_ip = sel;
    }

    else
    {
      if(!(1 + cached_servers_num + meta_numservers >= num) || !(num >= 1))
      {
        draw_ext_info(0, 20, 7, "Invalid selection. Try again");
        return 1;
      }

      if(num == 1 + cached_servers_num + meta_numservers)
      {
        server_name = server;
        server_ip = server;
      }

      else
        if(!(cached_servers_num >= num))
        {
          server_name = (meta_servers + (signed long int)((num - cached_servers_num) - 1))->hostname;
          server_ip = (meta_servers + (signed long int)((num - cached_servers_num) - 1))->ip_addr;
          port = (meta_servers + (signed long int)((num - cached_servers_num) - 1))->port;
        }

        else
        {
          server_name = cached_servers_name[(signed long int)(num - 1)];
          server_ip = cached_servers_ip[(signed long int)(num - 1)];
        }
    }
    pthread_mutex_unlock(&ms2_info_mutex);
    if(server_name == ((char *)NULL))
    {
      draw_ext_info(0, 20, 7, "Bad selection. Try again");
      return 1;
    }

    else
    {
      if(port == 0)
      {
        sel=strrchr(server_name, 58);
        if(!(sel == ((char *)NULL)))
        {
          port=atoi(sel + (signed long int)1);
          tmp_if_expr$3 = port > 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$3 = (_Bool)0;
        if(tmp_if_expr$3)
        {
          snprintf(buf2, sizeof(char [256l]) /*256ul*/ , "%s", server_name);
          buf2[sel - server_name] = (char)0;
          server_name = buf2;
        }

        else
          port = (signed int)use_config[(signed long int)23];
      }

      snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Trying to connect to %s:%d", server_name, port);
      draw_ext_info(0, 20, 7, buf);
      csocket.fd=init_connection(server_name, port);
      if(csocket.fd == -1)
      {
        draw_ext_info(0, 20, 7, "Unable to connect to server.");
        return 1;
      }

      else
      {
        if(meta_numservers >= num && !(num == 1 + cached_servers_num + meta_numservers))
          metaserver_update_cache(server_name, server_ip);

        return 0;
      }
    }
  }
}

// metaserver_selection_func
// file metaserver.c line 53
extern signed int metaserver_selection_func(struct _GtkTreeSelection *selection, struct _GtkTreeModel *model, struct _GtkTreePath *path, signed int path_currently_selected, void *userdata)
{
  gtk_widget_set_sensitive(metaserver_button, (signed int)!(0 != 0));
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)metaserver_entry, return_value_gtk_entry_get_type$1);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2, "");
  return (signed int)!(0 != 0);
}

// metaserver_show
// file metaserver.c line 905
void metaserver_show(signed int show_selection)
{
  signed int i;
  char buf[256l];
  if(!(cached_servers_num == 0))
  {
    draw_ext_info(0, 20, 7, "\nLast servers you connected to:\n");
    i = 0;
    for( ; !(i >= cached_servers_num); i = i + 1)
    {
      snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%2d) %-20.20s %-20.20s", i + 1, cached_servers_name[(signed long int)i], cached_servers_ip[(signed long int)i]);
      draw_ext_info(0, 20, 7, buf);
    }
    draw_ext_info(0, 20, 7, " ");
  }

  signed int return_value_metaserver_check_status$1;
  do
  {
    return_value_metaserver_check_status$1=metaserver_check_status();
    if(return_value_metaserver_check_status$1 == 0)
      break;

    usleep((unsigned int)100);
  }
  while((_Bool)1);
  draw_ext_info(0, 20, 7, " #)     Server        #     version   idle");
  draw_ext_info(0, 20, 7, "         Name      players           seconds");
  pthread_mutex_lock(&ms2_info_mutex);
  qsort((void *)meta_servers, (unsigned long int)meta_numservers, sizeof(struct Meta_Info) /*1928ul*/ , (signed int (*)(const void *, const void *))meta_sort);
  i = 0;
  for( ; !(i >= meta_numservers); i = i + 1)
  {
    signed int return_value_check_server_version$2;
    return_value_check_server_version$2=check_server_version(i);
    if(!(return_value_check_server_version$2 == 0))
    {
      snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%2d)  %-15.15s %2d   %-12.12s %2d", i + 1 + cached_servers_num, (const void *)(meta_servers + (signed long int)i)->hostname, (meta_servers + (signed long int)i)->num_players, (const void *)(meta_servers + (signed long int)i)->version, (meta_servers + (signed long int)i)->idle_time);
      draw_ext_info(0, 20, 7, buf);
    }

  }
  if(!(show_selection == 0))
  {
    if(!(server == ((char *)NULL)))
    {
      snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%2d)  %s (default)", meta_numservers + 1 + cached_servers_num, server);
      draw_ext_info(0, 20, 7, buf);
    }

    draw_ext_info(0, 20, 7, "Choose one of the entries above");
    draw_ext_info(0, 20, 7, "or type in a hostname/ip address");
    draw_ext_info(0, 20, 7, "Hit enter to re-update this list");
    draw_ext_info(0, 20, 7, "Enter 0 to exit the program.");
  }

  pthread_mutex_unlock(&ms2_info_mutex);
}

// metaserver_update_cache
// file ../../common/metaserver.h line 93
extern void metaserver_update_cache(const char *server_name, const char *server_ip)
{
  signed int index = 0;
  for( ; !(index >= cached_servers_num); index = index + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(server_name, cached_servers_name[(signed long int)index]);
    if(return_value_strcmp$1 == 0)
      break;

  }
  if(cached_servers_num == 0 || !(index == 0))
  {
    char *name;
    char *ip;
    signed int copy;
    if(index == cached_servers_num)
    {
      name=strdup(server_name);
      ip=strdup(server_ip);
      cached_servers_num = cached_servers_num + 1;
      if(cached_servers_num >= 11)
      {
        cached_servers_num = cached_servers_num - 1;
        free((void *)cached_servers_name[(signed long int)(cached_servers_num - 1)]);
        free((void *)cached_servers_ip[(signed long int)(cached_servers_num - 1)]);
      }

    }

    else
    {
      name = cached_servers_name[(signed long int)index];
      ip = cached_servers_ip[(signed long int)index];
    }
    copy = index < 10 - 1 ? index : 10 - 1;
    for( ; copy >= 1; copy = copy - 1)
    {
      cached_servers_name[(signed long int)copy] = cached_servers_name[(signed long int)(copy - 1)];
      cached_servers_ip[(signed long int)copy] = cached_servers_ip[(signed long int)(copy - 1)];
    }
    cached_servers_name[(signed long int)0] = name;
    cached_servers_ip[(signed long int)0] = ip;
    metaserver_save_cache();
  }

}

// monitorChilds
// file misc.c line 246
void monitorChilds(void)
{
  struct ChildProcess *cp = FirstChild;
  struct ChildProcess *last = (struct ChildProcess *)(void *)0;
  char *tmp_if_expr$1;
  while((_Bool)1)
  {
    if(cp == ((struct ChildProcess *)NULL))
      goto __CPROVER_DUMP_L12;

    signed int return_value_waitpid$2;
    return_value_waitpid$2=waitpid(cp->pid, (signed int *)(void *)0, 1);
    if(!(return_value_waitpid$2 == 0))
    {
      struct ChildProcess *next;
      if(!(cp->name == ((char *)NULL)))
        tmp_if_expr$1 = cp->name;

      else
        tmp_if_expr$1 = "UNKNOWN";
      LOG((enum LogLevel)LOG_INFO, "common::monitorChilds", "Child %s died. Removing and closing pipes", tmp_if_expr$1);
      if(cp == LastChild)
        LastChild = last;

      next = cp->next;
      if(!(last == ((struct ChildProcess *)NULL)))
        last->next = next;

      else
        FirstChild = cp->next;
      cp = next;
      continue;
    }

    if(!(cp->logger[1l].log == 0))
      purgePipe(cp, 1);

    if(!(cp->logger[2l].log == 0))
      purgePipe(cp, 2);

    last = cp;
    cp = cp->next;
  }

__CPROVER_DUMP_L12:
  ;
}

// move_player
// file ../../common/proto.h line 140
void move_player(signed int dir)
{
  send_command(directions[(signed long int)dir], -1, 0);
}

// msgctrl_init
// file info.c line 1340
extern void msgctrl_init(struct _GtkWidget *window_root)
{
  struct _GtkTableChild *child;
  struct _GtkWidget *widget;
  struct _GtkTable *table;
  struct _GList *list;
  unsigned int pane;
  unsigned int type;
  unsigned int row;
  signed int title_rows = -1;
  struct _GObject *return_value_gtk_builder_get_object$1;
  return_value_gtk_builder_get_object$1=gtk_builder_get_object(dialog_xml, "msgctrl_window");
  unsigned long int return_value_gtk_widget_get_type$2;
  return_value_gtk_widget_get_type$2=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
  msgctrl_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
  g_signal_connect_data((void *)msgctrl_window, "delete_event", (void (*)(void))gtk_widget_hide_on_delete, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$4;
  return_value_gtk_builder_get_object$4=gtk_builder_get_object(dialog_xml, "msgctrl_spinbutton_count");
  unsigned long int return_value_gtk_widget_get_type$5;
  return_value_gtk_widget_get_type$5=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$4, return_value_gtk_widget_get_type$5);
  buffer_control.count.ptr = (struct _GtkWidget *)return_value_g_type_check_instance_cast$6;
  struct _GObject *return_value_gtk_builder_get_object$7;
  return_value_gtk_builder_get_object$7=gtk_builder_get_object(dialog_xml, "msgctrl_spinbutton_timer");
  unsigned long int return_value_gtk_widget_get_type$8;
  return_value_gtk_widget_get_type$8=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$7, return_value_gtk_widget_get_type$8);
  buffer_control.timer.ptr = (struct _GtkWidget *)return_value_g_type_check_instance_cast$9;
  struct _GObject *return_value_gtk_builder_get_object$10;
  return_value_gtk_builder_get_object$10=gtk_builder_get_object(dialog_xml, "msgctrl_table");
  unsigned long int return_value_gtk_widget_get_type$11;
  return_value_gtk_widget_get_type$11=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$10, return_value_gtk_widget_get_type$11);
  msgctrl_table = (struct _GtkWidget *)return_value_g_type_check_instance_cast$12;
  unsigned long int return_value_gtk_table_get_type$13;
  return_value_gtk_table_get_type$13=gtk_table_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)msgctrl_table, return_value_gtk_table_get_type$13);
  table = (struct _GtkTable *)return_value_g_type_check_instance_cast$14;
  list = table->children;
  for( ; !(list == ((struct _GList *)NULL)); list = list->next)
  {
    child = (struct _GtkTableChild *)list->data;
    if(!(child->widget == ((struct _GtkWidget *)NULL)))
    {
      if(!(title_rows >= (signed int)child->top_attach))
        title_rows = (signed int)child->top_attach;

    }

  }
  gtk_table_resize(table, (unsigned int)(21 + title_rows), (unsigned int)(1 + 1 + 2));
  title_rows = title_rows + 1;
  type = (unsigned int)0;
  for( ; !(type >= 20u); type = type + (unsigned int)1)
  {
    row = type + (unsigned int)title_rows;
    widget=gtk_label_new(msgctrl_defaults[(signed long int)type].description);
    unsigned long int return_value_gtk_misc_get_type$15;
    return_value_gtk_misc_get_type$15=gtk_misc_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_misc_get_type$15);
    gtk_misc_set_alignment((struct _GtkMisc *)return_value_g_type_check_instance_cast$16, 0.0f, 0.5f);
    unsigned long int return_value_gtk_misc_get_type$17;
    return_value_gtk_misc_get_type$17=gtk_misc_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)widget, return_value_gtk_misc_get_type$17);
    gtk_misc_set_padding((struct _GtkMisc *)return_value_g_type_check_instance_cast$18, 2, 0);
    gtk_table_attach_defaults(table, widget, (unsigned int)0, (unsigned int)1, row, row + (unsigned int)1);
    gtk_widget_show(widget);
    msgctrl_widgets[(signed long int)type].buffer.ptr=gtk_check_button_new();
    gtk_table_attach_defaults(table, msgctrl_widgets[(signed long int)type].buffer.ptr, (unsigned int)1, (unsigned int)2, row, row + (unsigned int)1);
    gtk_widget_show(msgctrl_widgets[(signed long int)type].buffer.ptr);
    pane = (unsigned int)0;
    for( ; !(pane >= 2u); pane = pane + (unsigned int)1)
    {
      msgctrl_widgets[(signed long int)type].pane[(signed long int)pane].ptr=gtk_check_button_new();
      gtk_table_attach_defaults(table, msgctrl_widgets[(signed long int)type].pane[(signed long int)pane].ptr, pane + (unsigned int)2, pane + (unsigned int)3, row, row + (unsigned int)1);
      gtk_widget_show(msgctrl_widgets[(signed long int)type].pane[(signed long int)pane].ptr);
    }
  }
  default_msgctrl_configuration();
  load_msgctrl_configuration();
  struct _GObject *return_value_gtk_builder_get_object$19;
  return_value_gtk_builder_get_object$19=gtk_builder_get_object(dialog_xml, "msgctrl_button_save");
  unsigned long int return_value_gtk_widget_get_type$20;
  return_value_gtk_widget_get_type$20=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
  return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$19, return_value_gtk_widget_get_type$20);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$21;
  g_signal_connect_data((void *)widget, "clicked", (void (*)(void))on_msgctrl_button_save_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$22;
  return_value_gtk_builder_get_object$22=gtk_builder_get_object(dialog_xml, "msgctrl_button_load");
  unsigned long int return_value_gtk_widget_get_type$23;
  return_value_gtk_widget_get_type$23=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$22, return_value_gtk_widget_get_type$23);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$24;
  g_signal_connect_data((void *)widget, "clicked", (void (*)(void))on_msgctrl_button_load_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$25;
  return_value_gtk_builder_get_object$25=gtk_builder_get_object(dialog_xml, "msgctrl_button_defaults");
  unsigned long int return_value_gtk_widget_get_type$26;
  return_value_gtk_widget_get_type$26=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
  return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$25, return_value_gtk_widget_get_type$26);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$27;
  g_signal_connect_data((void *)widget, "clicked", (void (*)(void))on_msgctrl_button_defaults_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$28;
  return_value_gtk_builder_get_object$28=gtk_builder_get_object(dialog_xml, "msgctrl_button_apply");
  unsigned long int return_value_gtk_widget_get_type$29;
  return_value_gtk_widget_get_type$29=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$28, return_value_gtk_widget_get_type$29);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$30;
  g_signal_connect_data((void *)widget, "clicked", (void (*)(void))on_msgctrl_button_apply_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  struct _GObject *return_value_gtk_builder_get_object$31;
  return_value_gtk_builder_get_object$31=gtk_builder_get_object(dialog_xml, "msgctrl_button_close");
  unsigned long int return_value_gtk_widget_get_type$32;
  return_value_gtk_widget_get_type$32=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
  return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$31, return_value_gtk_widget_get_type$32);
  widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$33;
  g_signal_connect_data((void *)widget, "clicked", (void (*)(void))on_msgctrl_button_close_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
}

// my_log_handler
// file main.c line 655
extern void my_log_handler(const char *log_domain, enum anonymous$52 log_level, const char *message, void *user_data)
{
  sleep((unsigned int)1);
}

// negotiate_connection
// file ../../common/proto.h line 4
void negotiate_connection(signed int sound)
{
  signed int tries;
  SendVersion(csocket);
  tries = 0;
  while(csocket.cs_version == 0)
  {
    DoClient(&csocket);
    if(csocket.fd == -1)
      goto __CPROVER_DUMP_L19;

    usleep((unsigned int)(10 * 1000));
    tries = tries + 1;
    if(tries >= 1001)
    {
      close_server_connection();
      goto __CPROVER_DUMP_L19;
    }

  }
  if(!(csocket.sc_version >= 1023))
  {
    LOG((enum LogLevel)LOG_WARNING, "common::negotiate_connection", "Server does not support PNG images, yet that is all this client");
    LOG((enum LogLevel)LOG_WARNING, "common::negotiate_connection", "supports.  Either the server needs to be upgraded, or you need to");
    LOG((enum LogLevel)LOG_WARNING, "common::negotiate_connection", "downgrade your client.");
    exit(1);
  }

  if(!(face_info.want_faceset == ((char *)NULL)))
  {
    signed int return_value_atoi$1;
    return_value_atoi$1=atoi(face_info.want_faceset);
    face_info.faceset = (unsigned char)return_value_atoi$1;
  }

  cs_print_string(csocket.fd, "setup map2cmd 1 tick 1 sound2 %d darkness %d spellmon 1 spellmon 2 faceset %d facecache %d want_pickup 1 loginmethod %d newmapcmd 1", sound >= 0 ? 3 : 0, want_config[(signed long int)17] != 0 ? 1 : 0, face_info.faceset, want_config[(signed long int)5], wantloginmethod);
  cs_print_string(csocket.fd, "requestinfo skill_info");
  cs_print_string(csocket.fd, "requestinfo exp_table");
  cs_print_string(csocket.fd, "requestinfo motd");
  cs_print_string(csocket.fd, "requestinfo news");
  cs_print_string(csocket.fd, "requestinfo rules");
  use_config[(signed long int)20] = want_config[(signed long int)20];
  use_config[(signed long int)19] = want_config[(signed long int)19];
  mapdata_set_size((signed int)use_config[(signed long int)19], (signed int)use_config[(signed long int)20]);
  _Bool tmp_if_expr$2;
  if(!((signed int)use_config[20l] == 11))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)use_config[(signed long int)19] != 11 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    cs_print_string(csocket.fd, "setup mapsize %dx%d", use_config[(signed long int)19], use_config[(signed long int)20]);

  use_config[(signed long int)26] = want_config[(signed long int)26];
  if(csocket.sc_version >= 1027)
  {
    signed int last_end = 0;
    signed int last_start = -99;
    cs_print_string(csocket.fd, "requestinfo image_info");
    requestinfo_sent = 0x1;
    replyinfo_status = 0;
    replyinfo_last_face = 0;
    do
    {
      DoClient(&csocket);
      if(csocket.fd == -1)
        goto __CPROVER_DUMP_L19;

      if(!(use_config[1l] == 0))
      {
        requestinfo_sent = requestinfo_sent | 0x2;
        if(!((signed int)face_info.num_images == 0))
        {
          if(last_end == (signed int)face_info.num_images)
          {
            if(replyinfo_last_face == last_end)
            {
              replyinfo_status = replyinfo_status | 0x2;
              image_update_download_status((signed int)face_info.num_images, (signed int)face_info.num_images, (signed int)face_info.num_images);
            }

          }

          else
            if(100 + replyinfo_last_face >= last_end)
            {
              last_start = last_start + 100;
              last_end = last_end + 100;
              if(!((signed int)face_info.num_images >= last_end))
                last_end = (signed int)face_info.num_images;

              cs_print_string(csocket.fd, "requestinfo image_sums %d %d", last_start, last_end);
              image_update_download_status(last_start, last_end, (signed int)face_info.num_images);
            }

        }

      }

      usleep((unsigned int)(10 * 1000));
    }
    while(!(replyinfo_status == requestinfo_sent));
  }

  if(!(use_config[1l] == 0))
  {
    char buf[256l];
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Download of images complete.  Found %d locally, downloaded %d from server\n", face_info.cache_hits, face_info.cache_misses);
    draw_ext_info(11, 20, 1, buf);
  }

  if(serverloginmethod == 0)
    SendAddMe(csocket);


__CPROVER_DUMP_L19:
  ;
}

// new_char_window_update_info
// file create_char.c line 636
void new_char_window_update_info()
{
  char buf[256l];
  struct _GtkListStore *store;
  struct _GtkTreeIter iter;
  struct _GtkCellRenderer *renderer;
  signed int i;
  if(!(stat_points == 0) && num_classes == used_classes && num_races == used_races)
  {
    unsigned long int return_value_gtk_label_get_type$1;
    return_value_gtk_label_get_type$1=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)label_cc_status_update, return_value_gtk_label_get_type$1);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, "Waiting for player selections");
    sprintf(buf, "%d", stat_points);
    unsigned long int return_value_gtk_label_get_type$3;
    return_value_gtk_label_get_type$3=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)label_cc_unspent, return_value_gtk_label_get_type$3);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, buf);
    store=gtk_list_store_new(1, (unsigned long int)(16 << 2));
    i = 0;
    for( ; !(i >= num_races); i = i + 1)
    {
      gtk_list_store_append(store, &iter);
      gtk_list_store_set(store, &iter, 0, (races + (signed long int)i)->public_name, -1);
    }
    unsigned long int return_value_gtk_combo_box_get_type$5;
    return_value_gtk_combo_box_get_type$5=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)combobox_rs, return_value_gtk_combo_box_get_type$5);
    unsigned long int return_value_gtk_tree_model_get_type$7;
    return_value_gtk_tree_model_get_type$7=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_tree_model_get_type$7);
    gtk_combo_box_set_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$6, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$8);
    unsigned long int return_value_gtk_cell_layout_get_type$9;
    return_value_gtk_cell_layout_get_type$9=gtk_cell_layout_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)combobox_rs, return_value_gtk_cell_layout_get_type$9);
    gtk_cell_layout_clear((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$10);
    renderer=gtk_cell_renderer_text_new();
    unsigned long int return_value_gtk_cell_layout_get_type$11;
    return_value_gtk_cell_layout_get_type$11=gtk_cell_layout_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)combobox_rs, return_value_gtk_cell_layout_get_type$11);
    gtk_cell_layout_pack_start((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$12, renderer, 0);
    unsigned long int return_value_gtk_cell_layout_get_type$13;
    return_value_gtk_cell_layout_get_type$13=gtk_cell_layout_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
    return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)combobox_rs, return_value_gtk_cell_layout_get_type$13);
    gtk_cell_layout_set_attributes((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$14, renderer, (const void *)"text", 0, (void *)0);
    g_signal_connect_data((void *)combobox_rs, "changed", (void (*)(void))on_combobox_rcs_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    unsigned long int return_value_gtk_combo_box_get_type$15;
    return_value_gtk_combo_box_get_type$15=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)combobox_rs, return_value_gtk_combo_box_get_type$15);
    gtk_combo_box_set_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$16, 0);
    store=gtk_list_store_new(1, (unsigned long int)(16 << 2));
    i = 0;
    for( ; !(i >= num_classes); i = i + 1)
    {
      gtk_list_store_append(store, &iter);
      gtk_list_store_set(store, &iter, 0, (classes + (signed long int)i)->public_name, -1);
    }
    unsigned long int return_value_gtk_combo_box_get_type$17;
    return_value_gtk_combo_box_get_type$17=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)combobox_cs, return_value_gtk_combo_box_get_type$17);
    unsigned long int return_value_gtk_tree_model_get_type$19;
    return_value_gtk_tree_model_get_type$19=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
    return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_tree_model_get_type$19);
    gtk_combo_box_set_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$18, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$20);
    unsigned long int return_value_gtk_cell_layout_get_type$21;
    return_value_gtk_cell_layout_get_type$21=gtk_cell_layout_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
    return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)combobox_cs, return_value_gtk_cell_layout_get_type$21);
    gtk_cell_layout_clear((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$22);
    renderer=gtk_cell_renderer_text_new();
    unsigned long int return_value_gtk_cell_layout_get_type$23;
    return_value_gtk_cell_layout_get_type$23=gtk_cell_layout_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
    return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)combobox_cs, return_value_gtk_cell_layout_get_type$23);
    gtk_cell_layout_pack_start((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$24, renderer, 0);
    unsigned long int return_value_gtk_cell_layout_get_type$25;
    return_value_gtk_cell_layout_get_type$25=gtk_cell_layout_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
    return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)combobox_cs, return_value_gtk_cell_layout_get_type$25);
    gtk_cell_layout_set_attributes((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$26, renderer, (const void *)"text", 0, (void *)0);
    g_signal_connect_data((void *)combobox_cs, "changed", (void (*)(void))on_combobox_rcs_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    unsigned long int return_value_gtk_combo_box_get_type$27;
    return_value_gtk_combo_box_get_type$27=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
    return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)combobox_cs, return_value_gtk_combo_box_get_type$27);
    gtk_combo_box_set_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$28, 0);
    i = 0;
    for( ; !(i >= 7); i = i + 1)
    {
      unsigned long int return_value_gtk_spin_button_get_type$29;
      return_value_gtk_spin_button_get_type$29=gtk_spin_button_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
      return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)spinbutton_cc[(signed long int)i], return_value_gtk_spin_button_get_type$29);
      gtk_spin_button_set_value((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$30, (double)stat_min);
      unsigned long int return_value_gtk_spin_button_get_type$31;
      return_value_gtk_spin_button_get_type$31=gtk_spin_button_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
      return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)spinbutton_cc[(signed long int)i], return_value_gtk_spin_button_get_type$31);
      gtk_spin_button_set_range((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$32, (double)stat_min, (double)stat_maximum);
    }
    create_character_set_sensitive((signed int)!(0 != 0));
  }

}

// new_item
// file item.c line 213
static struct item_struct * new_item(void)
{
  struct item_struct *op;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct item_struct) /*576ul*/ );
  op = (struct item_struct *)return_value_malloc$1;
  if(op == ((struct item_struct *)NULL))
    exit(0);

  op->prev = (struct item_struct *)(void *)0;
  op->next = op->prev;
  strncpy(op->d_name, "", (unsigned long int)(128 - 1));
  op->d_name[(signed long int)(128 - 1)] = (char)0;
  strncpy(op->s_name, "", (unsigned long int)(128 - 1));
  op->s_name[(signed long int)(128 - 1)] = (char)0;
  strncpy(op->p_name, "", (unsigned long int)(128 - 1));
  op->p_name[(signed long int)(128 - 1)] = (char)0;
  op->inv = (struct item_struct *)(void *)0;
  op->env = (struct item_struct *)(void *)0;
  op->tag = 0;
  op->face = (signed short int)0;
  op->weight = (float)0;
  op->damned = (unsigned short int)0;
  op->cursed = (unsigned short int)op->damned;
  op->magical = (unsigned short int)op->cursed;
  op->applied = (unsigned short int)0;
  op->locked = (unsigned short int)op->applied;
  op->unpaid = (unsigned short int)op->locked;
  op->flagsval = (unsigned int)0;
  op->animation_id = (unsigned short int)0;
  op->last_anim = (unsigned short int)0;
  op->anim_state = (unsigned char)0;
  op->nrof = (unsigned int)0;
  op->open = (unsigned short int)0;
  op->type = (unsigned short int)30000;
  op->inv_updated = (unsigned short int)0;
  return op;
}

// new_menu_pickup
// file pickup.c line 96
static void new_menu_pickup(signed int on, signed int val)
{
  char modestr[128l];
  if(no_recurse == 0u)
  {
    if(!(on == 0))
      pmode = pmode | (unsigned int)val | 0x80000000;

    else
      pmode = pmode & (unsigned int)~val;
    draw_ext_info(0, 20, 6, "To set this pickup mode to a key, use:");
    snprintf(modestr, sizeof(char [128l]) /*128ul*/ , "bind pickup %u", pmode);
    draw_ext_info(0, 20, 6, modestr);
    snprintf(modestr, sizeof(char [128l]) /*128ul*/ , "pickup %u", pmode);
    send_command(modestr, -1, 0);
  }

}

// new_player
// file ./proto.h line 135
void new_player(signed long int tag, char *name, signed long int weight, signed long int face)
{
  struct Spell_struct *spell;
  struct Spell_struct *spnext;
  cpl.ob->tag = (signed int)tag;
  cpl.ob->nrof = (unsigned int)1;
  strncpy(cpl.ob->d_name, name, (unsigned long int)(128 - 1));
  cpl.ob->d_name[(signed long int)(128 - 1)] = (char)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(name);
  if(!(return_value_strlen$1 == 0ul))
    keybindings_init(name);

  cpl.ob->weight = (float)weight / (float)1000;
  cpl.ob->face = (signed short int)face;
  if(!(cpl.spelldata == ((struct Spell_struct *)NULL)))
  {
    spell = cpl.spelldata;
    for( ; !(spell == ((struct Spell_struct *)NULL)); spell = spnext)
    {
      spnext = spell->next;
      free((void *)spell);
    }
    cpl.spelldata = (struct Spell_struct *)(void *)0;
  }

}

// num_free_items
// file item.c line 458
signed int num_free_items(void)
{
  struct item_struct *tmp;
  signed int count = 0;
  tmp = free_items;
  for( ; !(tmp == ((struct item_struct *)NULL)); tmp = tmp->next)
    count = count + 1;
  return count;
}

// on_about_close_clicked
// file about.c line 67
extern void on_about_close_clicked(struct _GtkButton *button, void *user_data)
{
  gtk_widget_hide(about_window);
}

// on_button_account_password_cancel_clicked
// file account.c line 1194
void on_button_account_password_cancel_clicked(struct _GtkButton *button, void *user_data)
{
  gtk_widget_hide(account_password_window);
  gtk_widget_show(choose_char_window);
}

// on_button_account_password_clicked
// file account.c line 549
void on_button_account_password_clicked(struct _GtkButton *button, void *user_data)
{
  gtk_widget_hide(choose_char_window);
  gtk_widget_show(account_password_window);
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password_current, return_value_gtk_entry_get_type$1);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2, "");
  unsigned long int return_value_gtk_entry_get_type$3;
  return_value_gtk_entry_get_type$3=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password_new, return_value_gtk_entry_get_type$3);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4, "");
  unsigned long int return_value_gtk_entry_get_type$5;
  return_value_gtk_entry_get_type$5=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password_confirm, return_value_gtk_entry_get_type$5);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$6, "");
}

// on_button_account_password_confirm_clicked
// file account.c line 1206
void on_button_account_password_confirm_clicked(struct _GtkButton *button, void *user_data)
{
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password_current, return_value_gtk_entry_get_type$1);
  const char *return_value_gtk_entry_get_text$3;
  return_value_gtk_entry_get_text$3=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gtk_entry_get_type$4;
  return_value_gtk_entry_get_type$4=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password_new, return_value_gtk_entry_get_type$4);
  const char *return_value_gtk_entry_get_text$6;
  return_value_gtk_entry_get_text$6=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$5);
  unsigned long int return_value_gtk_entry_get_type$7;
  return_value_gtk_entry_get_type$7=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password_confirm, return_value_gtk_entry_get_type$7);
  const char *return_value_gtk_entry_get_text$9;
  return_value_gtk_entry_get_text$9=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$8);
  do_account_change(return_value_gtk_entry_get_text$3, return_value_gtk_entry_get_text$6, return_value_gtk_entry_get_text$9);
}

// on_button_add_character_clicked
// file account.c line 522
extern void on_button_add_character_clicked(struct _GtkButton *button, void *user_data)
{
  gtk_widget_hide(choose_char_window);
  gtk_widget_show(add_character_window);
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_character_name, return_value_gtk_entry_get_type$1);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2, "");
  unsigned long int return_value_gtk_entry_get_type$3;
  return_value_gtk_entry_get_type$3=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry_character_password, return_value_gtk_entry_get_type$3);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4, "");
  gtk_widget_grab_focus(entry_character_name);
}

// on_button_cc_cancel
// file create_char.c line 370
void on_button_cc_cancel(struct _GtkButton *button, void *user_data)
{
  show_window(0);
  choose_char_window_show();
}

// on_button_cc_done
// file create_char.c line 501
void on_button_cc_done(struct _GtkButton *button, void *user_data)
{
  signed int return_value_character_data_ok$3;
  return_value_character_data_ok$3=character_data_ok();
  if(!(return_value_character_data_ok$3 == 0))
  {
    unsigned long int return_value_gtk_label_get_type$1;
    return_value_gtk_label_get_type$1=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)label_cc_status_update, return_value_gtk_label_get_type$1);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, "Sending new character information to server");
    show_window(1);
    send_create_player_to_server();
  }

}

// on_button_choose_starting_map
// file create_char.c line 385
void on_button_choose_starting_map(struct _GtkButton *button, void *user_data)
{
  show_window(2);
}

// on_button_create_account_clicked
// file account.c line 955
extern void on_button_create_account_clicked(struct _GtkButton *button, void *user_data)
{
  gtk_widget_hide(login_window);
  unsigned long int return_value_gtk_label_get_type$1;
  return_value_gtk_label_get_type$1=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)label_create_account_status, return_value_gtk_label_get_type$1);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, "");
  unsigned long int return_value_gtk_entry_get_type$3;
  return_value_gtk_entry_get_type$3=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_account_name, return_value_gtk_entry_get_type$3);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4, "");
  unsigned long int return_value_gtk_entry_get_type$5;
  return_value_gtk_entry_get_type$5=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_account_password, return_value_gtk_entry_get_type$5);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$6, "");
  unsigned long int return_value_gtk_entry_get_type$7;
  return_value_gtk_entry_get_type$7=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_confirm_password, return_value_gtk_entry_get_type$7);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$8, "");
  gtk_widget_show(create_account_window);
}

// on_button_create_character_clicked
// file account.c line 505
extern void on_button_create_character_clicked(struct _GtkButton *button, void *user_data)
{
  gtk_widget_hide(choose_char_window);
  if(serverloginmethod >= 2)
    create_character_window_show();

  else
  {
    gtk_widget_show(new_character_window);
    unsigned long int return_value_gtk_entry_get_type$1;
    return_value_gtk_entry_get_type$1=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_character_name, return_value_gtk_entry_get_type$1);
    gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2, "");
  }
}

// on_button_create_new_char_clicked
// file account.c line 194
extern void on_button_create_new_char_clicked(struct _GtkButton *button, void *user_data)
{
  create_new_character();
}

// on_button_csm_cancel
// file create_char.c line 724
void on_button_csm_cancel(struct _GtkButton *button, void *user_data)
{
  show_window(1);
}

// on_button_do_add_character_clicked
// file account.c line 344
extern void on_button_do_add_character_clicked(struct _GtkButton *button, void *user_data)
{
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_character_name, return_value_gtk_entry_get_type$1);
  const char *return_value_gtk_entry_get_text$3;
  return_value_gtk_entry_get_text$3=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gtk_entry_get_type$4;
  return_value_gtk_entry_get_type$4=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)entry_character_password, return_value_gtk_entry_get_type$4);
  const char *return_value_gtk_entry_get_text$6;
  return_value_gtk_entry_get_text$6=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$5);
  add_character_to_account(return_value_gtk_entry_get_text$3, return_value_gtk_entry_get_text$6, 0);
}

// on_button_exit_client_clicked
// file account.c line 988
extern void on_button_exit_client_clicked(struct _GtkButton *button, void *user_data)
{
  exit(0);
}

// on_button_go_metaserver_clicked
// file account.c line 972
extern void on_button_go_metaserver_clicked(struct _GtkButton *button, void *user_data)
{
  close_server_connection();
  if(!(csocket_fd == 0))
  {
    gdk_input_remove(csocket_fd);
    csocket_fd = 0;
    gtk_main_quit();
  }

}

// on_button_login_clicked
// file account.c line 1030
extern void on_button_login_clicked(struct _GtkButton *button, void *user_data)
{
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_name, return_value_gtk_entry_get_type$1);
  const char *return_value_gtk_entry_get_text$3;
  return_value_gtk_entry_get_text$3=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gtk_entry_get_type$4;
  return_value_gtk_entry_get_type$4=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password, return_value_gtk_entry_get_type$4);
  const char *return_value_gtk_entry_get_text$6;
  return_value_gtk_entry_get_text$6=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$5);
  do_account_login(return_value_gtk_entry_get_text$3, return_value_gtk_entry_get_text$6);
}

// on_button_metaserver_quit_pressed
// file metaserver.c line 355
extern void on_button_metaserver_quit_pressed(struct _GtkButton *button, void *user_data)
{
  unsigned long int return_value_gtk_object_get_type$1;
  return_value_gtk_object_get_type$1=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)button, return_value_gtk_object_get_type$1);
  on_window_destroy_event((struct _GtkObject *)return_value_g_type_check_instance_cast$2, user_data);
}

// on_button_new_cancel_clicked
// file account.c line 826
extern void on_button_new_cancel_clicked(struct _GtkButton *button, void *user_data)
{
  gtk_widget_hide(create_account_window);
  gtk_widget_show(login_window);
}

// on_button_new_char_cancel_clicked
// file account.c line 215
extern void on_button_new_char_cancel_clicked(struct _GtkButton *button, void *user_data)
{
  gtk_widget_hide(new_character_window);
  gtk_widget_show(choose_char_window);
}

// on_button_new_create_account_clicked
// file account.c line 805
extern void on_button_new_create_account_clicked(struct _GtkButton *button, void *user_data)
{
  const char *password1;
  const char *password2;
  const char *name;
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_account_password, return_value_gtk_entry_get_type$1);
  password1=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gtk_entry_get_type$3;
  return_value_gtk_entry_get_type$3=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_confirm_password, return_value_gtk_entry_get_type$3);
  password2=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4);
  unsigned long int return_value_gtk_entry_get_type$5;
  return_value_gtk_entry_get_type$5=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_account_name, return_value_gtk_entry_get_type$5);
  name=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$6);
  _Bool tmp_if_expr$9;
  if(!(name == ((const char *)NULL)))
    tmp_if_expr$9 = name[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$9 = (_Bool)0;
  _Bool tmp_if_expr$10;
  if(!(password1 == ((const char *)NULL)) && tmp_if_expr$9)
    tmp_if_expr$10 = password1[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$10 = (_Bool)0;
  _Bool tmp_if_expr$11;
  if(!(password2 == ((const char *)NULL)) && tmp_if_expr$10)
    tmp_if_expr$11 = password2[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$11 = (_Bool)0;
  if(tmp_if_expr$11)
    do_account_create(name, password1, password2);

  else
  {
    unsigned long int return_value_gtk_label_get_type$7;
    return_value_gtk_label_get_type$7=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)label_create_account_status, return_value_gtk_label_get_type$7);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$8, "You must fill in all three entries!");
  }
}

// on_button_play_character_clicked
// file account.c line 483
extern void on_button_play_character_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GtkTreeSelection *selected;
  struct _GtkTreeModel *model;
  struct _GtkTreeIter iter;
  char *name;
  unsigned long int return_value_gtk_tree_view_get_type$1;
  return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)treeview_choose_character, return_value_gtk_tree_view_get_type$1);
  selected=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$2);
  signed int return_value_gtk_tree_selection_get_selected$3;
  return_value_gtk_tree_selection_get_selected$3=gtk_tree_selection_get_selected(selected, &model, &iter);
  if(!(return_value_gtk_tree_selection_get_selected$3 == 0))
  {
    gtk_tree_model_get(model, &iter, 1, &name, -1);
    play_character(name);
  }

}

// on_button_return_character_select_clicked
// file account.c line 358
extern void on_button_return_character_select_clicked(struct _GtkButton *button, void *user_data)
{
  gtk_widget_hide(add_character_window);
  gtk_widget_show(choose_char_window);
}

// on_button_return_login_clicked
// file account.c line 537
extern void on_button_return_login_clicked(struct _GtkButton *button, void *user_data)
{
  gtk_widget_hide(choose_char_window);
  gtk_widget_show(login_window);
}

// on_combobox_rcs_changed
// file create_char.c line 538
void on_combobox_rcs_changed(struct _GtkComboBox *box, void *user_data)
{
  signed int active_entry;
  signed int i;
  signed int opt_start;
  struct _GtkWidget **label_stat;
  struct Race_Class_Info *rc;
  char buf[256l];
  active_entry=gtk_combo_box_get_active(box);
  unsigned long int return_value_gtk_combo_box_get_type$13;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  if(!(active_entry == -1))
  {
    unsigned long int return_value_gtk_combo_box_get_type$15;
    return_value_gtk_combo_box_get_type$15=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)combobox_cs, return_value_gtk_combo_box_get_type$15);
    if(box == (struct _GtkComboBox *)return_value_g_type_check_instance_cast$16)
    {
      unsigned long int return_value_gtk_text_view_get_type$1;
      return_value_gtk_text_view_get_type$1=gtk_text_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
      return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)textview_cs_desc, return_value_gtk_text_view_get_type$1);
      struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$3;
      return_value_gtk_text_view_get_buffer$3=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$2);
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen((classes + (signed long int)active_entry)->description);
      gtk_text_buffer_set_text(return_value_gtk_text_view_get_buffer$3, (classes + (signed long int)active_entry)->description, (signed int)return_value_strlen$4);
      unsigned long int return_value_gtk_text_view_get_type$5;
      return_value_gtk_text_view_get_type$5=gtk_text_view_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)textview_cs_desc, return_value_gtk_text_view_get_type$5);
      gtk_text_view_scroll_to_mark((struct _GtkTextView *)return_value_g_type_check_instance_cast$6, text_mark_cs, 0.0, (signed int)!(0 != 0), 0.0, 0.0);
      rc = &classes[(signed long int)active_entry];
      label_stat = label_cs;
      opt_start = 6 / 2;
    }

    else
    {
      return_value_gtk_combo_box_get_type$13=gtk_combo_box_get_type();
      return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)combobox_rs, return_value_gtk_combo_box_get_type$13);
      if(box == (struct _GtkComboBox *)return_value_g_type_check_instance_cast$14)
      {
        unsigned long int return_value_gtk_text_view_get_type$7;
        return_value_gtk_text_view_get_type$7=gtk_text_view_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
        return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)textview_rs_desc, return_value_gtk_text_view_get_type$7);
        struct _GtkTextBuffer *return_value_gtk_text_view_get_buffer$9;
        return_value_gtk_text_view_get_buffer$9=gtk_text_view_get_buffer((struct _GtkTextView *)return_value_g_type_check_instance_cast$8);
        unsigned long int return_value_strlen$10;
        return_value_strlen$10=strlen((races + (signed long int)active_entry)->description);
        gtk_text_buffer_set_text(return_value_gtk_text_view_get_buffer$9, (races + (signed long int)active_entry)->description, (signed int)return_value_strlen$10);
        unsigned long int return_value_gtk_text_view_get_type$11;
        return_value_gtk_text_view_get_type$11=gtk_text_view_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
        return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)textview_rs_desc, return_value_gtk_text_view_get_type$11);
        gtk_text_view_scroll_to_mark((struct _GtkTextView *)return_value_g_type_check_instance_cast$12, text_mark_rs, 0.0, (signed int)!(0 != 0), 0.0, 0.0);
        rc = &races[(signed long int)active_entry];
        label_stat = label_rs;
        opt_start = 0;
      }

      else
      {
        LOG((enum LogLevel)LOG_ERROR, "gtk-v2/src/create_char.c:on_combobox_rcs_changed", "Passed in combobox does not match any combobox");
        goto __CPROVER_DUMP_L13;
      }
    }
    i = 0;
    for( ; !(i >= rc->num_rc_choice); i = i + 1)
    {
      signed int j;
      struct _GtkTreeModel *store;
      struct _GtkTreeIter iter;
      if(i == 3)
      {
        LOG((enum LogLevel)LOG_ERROR, "gtk-v2/src/create_char.c:on_combobox_rcs_changed", "Number of racial option exceeds allocated amount (%d > %d)", i, 6 / 2);
        break;
      }

      unsigned long int return_value_gtk_combo_box_get_type$17;
      return_value_gtk_combo_box_get_type$17=gtk_combo_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
      return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)opt_combobox[(signed long int)(i + opt_start)], return_value_gtk_combo_box_get_type$17);
      store=gtk_combo_box_get_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$18);
      unsigned long int return_value_gtk_list_store_get_type$19;
      return_value_gtk_list_store_get_type$19=gtk_list_store_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
      return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_list_store_get_type$19);
      gtk_list_store_clear((struct _GtkListStore *)return_value_g_type_check_instance_cast$20);
      j = 0;
      for( ; !(j >= (rc->rc_choice + (signed long int)i)->num_values); j = j + 1)
      {
        unsigned long int return_value_gtk_list_store_get_type$21;
        return_value_gtk_list_store_get_type$21=gtk_list_store_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
        return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_list_store_get_type$21);
        gtk_list_store_append((struct _GtkListStore *)return_value_g_type_check_instance_cast$22, &iter);
        unsigned long int return_value_gtk_list_store_get_type$23;
        return_value_gtk_list_store_get_type$23=gtk_list_store_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
        return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_list_store_get_type$23);
        gtk_list_store_set((struct _GtkListStore *)return_value_g_type_check_instance_cast$24, &iter, 0, (rc->rc_choice + (signed long int)i)->value_desc[(signed long int)j], -1);
      }
      unsigned long int return_value_gtk_combo_box_get_type$25;
      return_value_gtk_combo_box_get_type$25=gtk_combo_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
      return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)opt_combobox[(signed long int)(i + opt_start)], return_value_gtk_combo_box_get_type$25);
      gtk_combo_box_set_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$26, 0);
      unsigned long int return_value_gtk_label_get_type$27;
      return_value_gtk_label_get_type$27=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
      return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)opt_label[(signed long int)(i + opt_start)], return_value_gtk_label_get_type$27);
      gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$28, (rc->rc_choice + (signed long int)i)->choice_desc);
      gtk_widget_show(opt_label[(signed long int)(i + opt_start)]);
      gtk_widget_show(opt_combobox[(signed long int)(i + opt_start)]);
    }
    for( ; !(i >= 3); i = i + 1)
    {
      gtk_widget_hide(opt_label[(signed long int)(i + opt_start)]);
      gtk_widget_hide(opt_combobox[(signed long int)(i + opt_start)]);
    }
    i = 0;
    for( ; !(i >= 7); i = i + 1)
    {
      sprintf(buf, "%+d", rc->stat_adj[(signed long int)stat_mapping[(signed long int)i].rc_offset]);
      unsigned long int return_value_gtk_label_get_type$29;
      return_value_gtk_label_get_type$29=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
      return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)label_stat[(signed long int)i], return_value_gtk_label_get_type$29);
      gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$30, buf);
    }
    update_all_stats();
  }


__CPROVER_DUMP_L13:
  ;
}

// on_combobox_starting_map_changed
// file create_char.c line 731
void on_combobox_starting_map_changed(struct _GtkComboBox *box, void *user_data)
{
  signed int active_entry;
  active_entry=gtk_combo_box_get_active(box);
  if(!(active_entry == -1))
  {
    gtk_text_buffer_set_text(textbuf_starting_map, "", 0);
    add_marked_text_to_pane(&create_char_pane[(signed long int)0], (starting_map_info + (signed long int)active_entry)->description, 0, 0, 0);
  }

}

// on_config_button_apply_clicked
// file config.c line 1065
extern void on_config_button_apply_clicked(struct _GtkButton *button, void *user_data)
{
  read_config_window();
}

// on_config_button_close_clicked
// file config.c line 1076
extern void on_config_button_close_clicked(struct _GtkButton *button, void *user_data)
{
  gtk_widget_hide(config_window);
}

// on_config_button_save_clicked
// file config.c line 1053
extern void on_config_button_save_clicked(struct _GtkButton *button, void *user_data)
{
  read_config_window();
  save_defaults();
}

// on_configure_activate
// file config.c line 1086
extern void on_configure_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  gtk_widget_show(config_window);
  setup_config_window();
}

// on_disconnect_activate
// file menubar.c line 48
void on_disconnect_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  close_server_connection();
  if(!(csocket_fd == 0))
  {
    gdk_input_remove(csocket_fd);
    csocket_fd = 0;
    gtk_main_quit();
  }

}

// on_drawingarea_magic_map_expose_event
// file magicmap.c line 150
signed int on_drawingarea_magic_map_expose_event(struct _GtkWidget *widget, struct _GdkEventExpose *event, void *user_data)
{
  draw_magic_map();
  return 0;
}

// on_drawingarea_map_button_press_event
// file map.c line 697
extern signed int on_drawingarea_map_button_press_event(struct _GtkWidget *widget, struct _GdkEventButton *event, void *user_data)
{
  signed int on_drawingarea_map_button_press_event$$1$$dx;
  signed int on_drawingarea_map_button_press_event$$1$$dy;
  signed int i;
  signed int x;
  signed int y;
  signed int xmidl;
  signed int xmidh;
  signed int ymidl;
  signed int ymidh;
  x = (signed int)event->x;
  y = (signed int)event->y;
  on_drawingarea_map_button_press_event$$1$$dx = (x - 2) / map_image_size - (signed int)use_config[(signed long int)19] / 2;
  on_drawingarea_map_button_press_event$$1$$dy = (y - 2) / map_image_size - (signed int)use_config[(signed long int)20] / 2;
  xmidl = ((signed int)use_config[(signed long int)19] / 2) * map_image_size;
  xmidh = ((signed int)use_config[(signed long int)19] / 2 + 1) * map_image_size;
  ymidl = ((signed int)use_config[(signed long int)20] / 2) * map_image_size;
  ymidh = ((signed int)use_config[(signed long int)20] / 2 + 1) * map_image_size;
  switch(event->button)
  {
    case (unsigned int)1:
    {
      look_at(on_drawingarea_map_button_press_event$$1$$dx, on_drawingarea_map_button_press_event$$1$$dy);
      goto __CPROVER_DUMP_L26;
    }
    case (unsigned int)2:

    case (unsigned int)3:
    {
      if(!(x >= xmidl))
        i = 0;

      else
        if(!(xmidh >= x))
          i = 6;

        else
          i = 3;
      if(!(ymidh >= y))
        i = i + 2;

      else
        if(!(ymidl >= y))
          i = i + 1;

      if(event->button == 2u)
      {
        switch(i)
        {
          case 0:
          {
            fire_dir(8);
            break;
          }
          case 1:
          {
            fire_dir(7);
            break;
          }
          case 2:
          {
            fire_dir(6);
            break;
          }
          case 3:
          {
            fire_dir(1);
            break;
          }
          case 5:
          {
            fire_dir(5);
            break;
          }
          case 6:
          {
            fire_dir(2);
            break;
          }
          case 7:
          {
            fire_dir(3);
            break;
          }
          case 8:
            fire_dir(4);
        }
        clear_fire();
      }

      else
        switch(i)
        {
          case 0:
          {
            move_player(8);
            break;
          }
          case 1:
          {
            move_player(7);
            break;
          }
          case 2:
          {
            move_player(6);
            break;
          }
          case 3:
          {
            move_player(1);
            break;
          }
          case 5:
          {
            move_player(5);
            break;
          }
          case 6:
          {
            move_player(2);
            break;
          }
          case 7:
          {
            move_player(3);
            break;
          }
          case 8:
            move_player(4);
        }
    }
    default:
    {

    __CPROVER_DUMP_L26:
      ;
      return 0;
    }
  }
}

// on_drawingarea_map_configure_event
// file map.c line 580
extern signed int on_drawingarea_map_configure_event(struct _GtkWidget *widget, struct _GdkEventConfigure *event, void *user_data)
{
  signed short int w = (signed short int)(event->width / map_image_size);
  signed short int h = (signed short int)(event->height / map_image_size);
  if((signed int)w >= 32)
    w = (signed short int)31;

  if((signed int)h >= 32)
    h = (signed short int)31;

  _Bool tmp_if_expr$1;
  if(!(w == use_config[19l]))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = h != use_config[(signed long int)20] ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    use_config[(signed long int)19] = w;
    use_config[(signed long int)20] = h;
    mapdata_set_size((signed int)use_config[(signed long int)19], (signed int)use_config[(signed long int)20]);
    cs_print_string(csocket.fd, "setup mapsize %dx%d", use_config[(signed long int)19], use_config[(signed long int)20]);
  }

  return 0;
}

// on_drawingarea_map_expose_event
// file map.c line 681
extern signed int on_drawingarea_map_expose_event(struct _GtkWidget *widget, struct _GdkEventExpose *event, void *user_data)
{
  draw_map((signed int)!(0 != 0));
  return 0;
}

// on_entry_account_name_activate
// file account.c line 1042
extern void on_entry_account_name_activate(struct _GtkEntry *entry, void *user_data)
{
  const char *password;
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password, return_value_gtk_entry_get_type$1);
  password=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  _Bool tmp_if_expr$6;
  if(password == ((const char *)NULL))
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = (signed int)*password == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$6)
    gtk_widget_grab_focus(entry_account_password);

  else
  {
    unsigned long int return_value_gtk_entry_get_type$3;
    return_value_gtk_entry_get_type$3=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_name, return_value_gtk_entry_get_type$3);
    const char *return_value_gtk_entry_get_text$5;
    return_value_gtk_entry_get_text$5=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4);
    do_account_login(return_value_gtk_entry_get_text$5, password);
  }
}

// on_entry_account_password
// file account.c line 1223
void on_entry_account_password(struct _GtkEntry *entry, void *user_data)
{
  const char *old;
  const char *password1;
  const char *password2;
  const char *cp;
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password_current, return_value_gtk_entry_get_type$1);
  old=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gtk_entry_get_type$3;
  return_value_gtk_entry_get_type$3=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password_new, return_value_gtk_entry_get_type$3);
  password1=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4);
  unsigned long int return_value_gtk_entry_get_type$5;
  return_value_gtk_entry_get_type$5=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password_confirm, return_value_gtk_entry_get_type$5);
  password2=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$6);
  _Bool tmp_if_expr$14;
  if(!(old == ((const char *)NULL)))
    tmp_if_expr$14 = old[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$14 = (_Bool)0;
  _Bool tmp_if_expr$15;
  if(!(password1 == ((const char *)NULL)) && tmp_if_expr$14)
    tmp_if_expr$15 = password1[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$15 = (_Bool)0;
  _Bool tmp_if_expr$16;
  if(!(password2 == ((const char *)NULL)) && tmp_if_expr$15)
    tmp_if_expr$16 = password2[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$16 = (_Bool)0;
  _Bool tmp_if_expr$7;
  unsigned long int return_value_gtk_entry_get_type$10;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  unsigned long int return_value_gtk_entry_get_type$8;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  if(tmp_if_expr$16)
    do_account_change(old, password1, password2);

  else
  {
    cp=gtk_entry_get_text(entry);
    if(cp == ((const char *)NULL))
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = !(cp[(signed long int)0] != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
      goto __CPROVER_DUMP_L15;

    unsigned long int return_value_gtk_entry_get_type$12;
    return_value_gtk_entry_get_type$12=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password_current, return_value_gtk_entry_get_type$12);
    if(entry == (struct _GtkEntry *)return_value_g_type_check_instance_cast$13)
      gtk_widget_grab_focus(entry_account_password_new);

    else
    {
      return_value_gtk_entry_get_type$10=gtk_entry_get_type();
      return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password_new, return_value_gtk_entry_get_type$10);
      if(entry == (struct _GtkEntry *)return_value_g_type_check_instance_cast$11)
        gtk_widget_grab_focus(entry_account_password_confirm);

      else
      {
        return_value_gtk_entry_get_type$8=gtk_entry_get_type();
        return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password_confirm, return_value_gtk_entry_get_type$8);
        if(entry == (struct _GtkEntry *)return_value_g_type_check_instance_cast$9)
          gtk_widget_grab_focus(entry_account_password_current);

      }
    }
  }

__CPROVER_DUMP_L15:
  ;
}

// on_entry_account_password_activate
// file account.c line 1061
extern void on_entry_account_password_activate(struct _GtkEntry *entry, void *user_data)
{
  const char *name;
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_name, return_value_gtk_entry_get_type$1);
  name=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  _Bool tmp_if_expr$6;
  if(name == ((const char *)NULL))
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = (signed int)*name == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$6)
    gtk_widget_grab_focus(entry_account_name);

  else
  {
    unsigned long int return_value_gtk_entry_get_type$3;
    return_value_gtk_entry_get_type$3=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password, return_value_gtk_entry_get_type$3);
    const char *return_value_gtk_entry_get_text$5;
    return_value_gtk_entry_get_text$5=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4);
    do_account_login(name, return_value_gtk_entry_get_text$5);
  }
}

// on_entry_character
// file account.c line 372
extern void on_entry_character(struct _GtkEntry *entry, void *user_data)
{
  const char *name;
  const char *password;
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_character_name, return_value_gtk_entry_get_type$1);
  name=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gtk_entry_get_type$3;
  return_value_gtk_entry_get_type$3=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry_character_password, return_value_gtk_entry_get_type$3);
  password=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4);
  _Bool tmp_if_expr$8;
  if(!(name == ((const char *)NULL)))
    tmp_if_expr$8 = name[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$8 = (_Bool)0;
  _Bool tmp_if_expr$9;
  if(!(password == ((const char *)NULL)) && tmp_if_expr$8)
    tmp_if_expr$9 = password[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$9 = (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$9)
    add_character_to_account(name, password, 0);

  else
  {
    const char *cp;
    cp=gtk_entry_get_text(entry);
    if(cp == ((const char *)NULL))
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = !(cp[(signed long int)0] != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      goto __CPROVER_DUMP_L12;

    unsigned long int return_value_gtk_entry_get_type$6;
    return_value_gtk_entry_get_type$6=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)entry_character_name, return_value_gtk_entry_get_type$6);
    if(entry == (struct _GtkEntry *)return_value_g_type_check_instance_cast$7)
      gtk_widget_grab_focus(entry_character_password);

    else
      gtk_widget_grab_focus(entry_character_name);
  }

__CPROVER_DUMP_L12:
  ;
}

// on_entry_commands_activate
// file keys.c line 1835
extern void on_entry_commands_activate(struct _GtkEntry *entry, void *user_data)
{
  const char *entry_text;
  if(use_config[9l] == 0)
  {
    unsigned long int return_value_gtk_entry_get_type$1;
    return_value_gtk_entry_get_type$1=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry, return_value_gtk_entry_get_type$1);
    gtk_entry_set_visibility((struct _GtkEntry *)return_value_g_type_check_instance_cast$2, (signed int)!(0 != 0));
  }

  unsigned long int return_value_gtk_entry_get_type$3;
  return_value_gtk_entry_get_type$3=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry, return_value_gtk_entry_get_type$3);
  entry_text=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4);
  if((signed int)cpl.input_state == Metaserver_Select)
    strcpy(cpl.input_text, entry_text);

  else
    if((signed int)cpl.input_state == Reply_One || (signed int)cpl.input_state == Reply_Many)
    {
      cpl.input_state = (enum Input_State)Playing;
      strcpy(cpl.input_text, entry_text);
      if((signed int)cpl.input_state == Reply_One)
        cpl.input_text[(signed long int)1] = (char)0;

      send_reply(cpl.input_text);
    }

    else
    {
      cpl.input_state = (enum Input_State)Playing;
      unsigned long int return_value_gtk_spin_button_get_type$5;
      return_value_gtk_spin_button_get_type$5=gtk_spin_button_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)spinbutton_count, return_value_gtk_spin_button_get_type$5);
      signed int return_value_gtk_spin_button_get_value_as_int$7;
      return_value_gtk_spin_button_get_value_as_int$7=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$6);
      cpl.count = (unsigned int)return_value_gtk_spin_button_get_value_as_int$7;
      if(!((signed int)*entry_text == 0))
      {
        strncpy(history[(signed long int)cur_history_position], entry_text, (unsigned long int)256);
        history[(signed long int)cur_history_position][(signed long int)(256 - 1)] = (char)0;
        cur_history_position = cur_history_position + 1;
        cur_history_position = cur_history_position % 50;
        scroll_history_position = cur_history_position;
        extended_command(entry_text);
      }

    }
  unsigned long int return_value_gtk_entry_get_type$8;
  return_value_gtk_entry_get_type$8=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)entry, return_value_gtk_entry_get_type$8);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$9, "");
  unsigned long int return_value_gtk_widget_get_type$10;
  return_value_gtk_widget_get_type$10=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)treeview_look, return_value_gtk_widget_get_type$10);
  gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$11);
  if((signed int)cpl.input_state == Metaserver_Select)
  {
    cpl.input_state = (enum Input_State)Playing;
    gtk_main_quit();
  }

}

// on_entry_new_account
// file account.c line 841
extern void on_entry_new_account(struct _GtkEntry *entry, void *user_data)
{
  const char *password1;
  const char *password2;
  const char *name;
  const char *cp;
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_account_password, return_value_gtk_entry_get_type$1);
  password1=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gtk_entry_get_type$3;
  return_value_gtk_entry_get_type$3=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_confirm_password, return_value_gtk_entry_get_type$3);
  password2=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4);
  unsigned long int return_value_gtk_entry_get_type$5;
  return_value_gtk_entry_get_type$5=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_account_name, return_value_gtk_entry_get_type$5);
  name=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$6);
  _Bool tmp_if_expr$14;
  if(!(name == ((const char *)NULL)))
    tmp_if_expr$14 = name[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$14 = (_Bool)0;
  _Bool tmp_if_expr$15;
  if(!(password1 == ((const char *)NULL)) && tmp_if_expr$14)
    tmp_if_expr$15 = password1[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$15 = (_Bool)0;
  _Bool tmp_if_expr$16;
  if(!(password2 == ((const char *)NULL)) && tmp_if_expr$15)
    tmp_if_expr$16 = password2[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$16 = (_Bool)0;
  _Bool tmp_if_expr$7;
  unsigned long int return_value_gtk_entry_get_type$10;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  unsigned long int return_value_gtk_entry_get_type$8;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  if(tmp_if_expr$16)
    do_account_create(name, password1, password2);

  else
  {
    cp=gtk_entry_get_text(entry);
    if(cp == ((const char *)NULL))
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = !(cp[(signed long int)0] != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
      goto __CPROVER_DUMP_L15;

    unsigned long int return_value_gtk_entry_get_type$12;
    return_value_gtk_entry_get_type$12=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
    return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_account_name, return_value_gtk_entry_get_type$12);
    if(entry == (struct _GtkEntry *)return_value_g_type_check_instance_cast$13)
      gtk_widget_grab_focus(entry_new_account_password);

    else
    {
      return_value_gtk_entry_get_type$10=gtk_entry_get_type();
      return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_account_password, return_value_gtk_entry_get_type$10);
      if(entry == (struct _GtkEntry *)return_value_g_type_check_instance_cast$11)
        gtk_widget_grab_focus(entry_new_confirm_password);

      else
      {
        return_value_gtk_entry_get_type$8=gtk_entry_get_type();
        return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_confirm_password, return_value_gtk_entry_get_type$8);
        if(entry == (struct _GtkEntry *)return_value_g_type_check_instance_cast$9)
          gtk_widget_grab_focus(entry_new_account_name);

      }
    }
  }

__CPROVER_DUMP_L15:
  ;
}

// on_entry_new_character_name
// file account.c line 204
extern void on_entry_new_character_name(struct _GtkEntry *entry, void *user_data)
{
  create_new_character();
}

// on_inv_table_expose_event
// file inventory.c line 1152
extern signed int on_inv_table_expose_event(struct _GtkWidget *widget, struct _GdkEventExpose *event, void *user_data)
{
  draw_inv_table(0);
  return (signed int)!(0 != 0);
}

// on_kb_scope_togglebutton_character_toggled
// file keys.c line 2196
extern void on_kb_scope_togglebutton_character_toggled(struct _GtkToggleButton *toggle_button, void *user_data)
{
  struct _GtkTreeModel *model;
  struct _GtkTreeIter iter;
  struct keybind *kb;
  signed int scope;
  signed int return_value_gtk_tree_selection_get_selected$4;
  return_value_gtk_tree_selection_get_selected$4=gtk_tree_selection_get_selected(keybinding_selection, &model, &iter);
  if(!(return_value_gtk_tree_selection_get_selected$4 == 0))
  {
    gtk_tree_model_get(model, &iter, 6, &kb, -1);
    unsigned long int return_value_gtk_toggle_button_get_type$1;
    return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)kb_scope_togglebutton_character, return_value_gtk_toggle_button_get_type$1);
    signed int return_value_gtk_toggle_button_get_active$3;
    return_value_gtk_toggle_button_get_active$3=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2);
    scope = (signed int)!(return_value_gtk_toggle_button_get_active$3 != 0);
    toggle_buttons_scope(scope);
    toggle_keybind_scope(scope, kb);
  }

}

// on_kb_scope_togglebutton_global_toggled
// file keys.c line 2218
extern void on_kb_scope_togglebutton_global_toggled(struct _GtkToggleButton *toggle_button, void *user_data)
{
  struct _GtkTreeModel *model;
  struct _GtkTreeIter iter;
  struct keybind *kb;
  signed int scope;
  signed int return_value_gtk_tree_selection_get_selected$3;
  return_value_gtk_tree_selection_get_selected$3=gtk_tree_selection_get_selected(keybinding_selection, &model, &iter);
  if(!(return_value_gtk_tree_selection_get_selected$3 == 0))
  {
    gtk_tree_model_get(model, &iter, 6, &kb, -1);
    unsigned long int return_value_gtk_toggle_button_get_type$1;
    return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)kb_scope_togglebutton_global, return_value_gtk_toggle_button_get_type$1);
    scope=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2);
    toggle_buttons_scope(scope);
    toggle_keybind_scope(scope, kb);
  }

}

// on_keybinding_button_bind_clicked
// file keys.c line 2339
extern void on_keybinding_button_bind_clicked(struct _GtkButton *button, void *user_data)
{
  unsigned int keysym;
  unsigned char flags;
  const char *command;
  struct keybind *kb;
  keybinding_get_data(&keysym, &flags, &command);
  kb=keybind_find(keysym, (unsigned int)flags, (signed int)flags & 1 << 6);
  signed int return_value_keybind_overwrite_confirm$1;
  if(!(kb == ((struct keybind *)NULL)))
  {
    return_value_keybind_overwrite_confirm$1=keybind_overwrite_confirm(kb);
    if(!(return_value_keybind_overwrite_confirm$1 == 0))
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    keybind_insert(keysym, (unsigned int)flags, command);
    reset_keybinding_status();
    save_keys();
    update_keybinding_list();
  }
}

// on_keybinding_button_clear_clicked
// file keys.c line 2564
extern void on_keybinding_button_clear_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GtkTreeModel *model;
  struct _GtkTreeIter iter;
  signed int return_value_gtk_tree_selection_get_selected$1;
  return_value_gtk_tree_selection_get_selected$1=gtk_tree_selection_get_selected(keybinding_selection, &model, &iter);
  if(!(return_value_gtk_tree_selection_get_selected$1 == 0))
    gtk_tree_selection_unselect_iter(keybinding_selection, &iter);

  reset_keybinding_status();
}

// on_keybinding_button_close_clicked
// file keys.c line 2422
extern void on_keybinding_button_close_clicked(struct _GtkButton *button, void *user_data)
{
  gtk_widget_hide(keybinding_window);
}

// on_keybinding_button_remove_clicked
// file keys.c line 2240
extern void on_keybinding_button_remove_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GtkTreeModel *model;
  struct _GtkTreeIter iter;
  struct keybind *kb;
  signed int res;
  signed int return_value_gtk_tree_selection_get_selected$1;
  return_value_gtk_tree_selection_get_selected$1=gtk_tree_selection_get_selected(keybinding_selection, &model, &iter);
  if(return_value_gtk_tree_selection_get_selected$1 == 0)
    LOG((enum LogLevel)LOG_ERROR, "keys.c::on_keybinding_button_remove_clicked", "Function called with nothing selected\n");

  else
  {
    gtk_tree_model_get(model, &iter, 6, &kb, -1);
    res=keybind_remove(kb);
    if(!(res >= 0))
      LOG((enum LogLevel)LOG_ERROR, "keys.c::on_keybinding_button_remove_clicked", "Unable to find matching key entry\n");

    keybind_free(&kb);
    save_keys();
    update_keybinding_list();
  }
}

// on_keybinding_button_update_clicked
// file keys.c line 2373
extern void on_keybinding_button_update_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GtkTreeIter iter;
  struct keybind *kb;
  struct _GtkTreeModel *model;
  unsigned int keysym;
  unsigned char flags;
  const char *buf;
  signed int res;
  signed int return_value_gtk_tree_selection_get_selected$1;
  return_value_gtk_tree_selection_get_selected$1=gtk_tree_selection_get_selected(keybinding_selection, &model, &iter);
  if(!(return_value_gtk_tree_selection_get_selected$1 == 0))
  {
    gtk_tree_model_get(model, &iter, 6, &kb, -1);
    if(kb == ((struct keybind *)NULL))
    {
      LOG((enum LogLevel)LOG_ERROR, "keys.c::on_keybinding_button_update_clicked", "Unable to get key_entry structure\n");
      goto __CPROVER_DUMP_L6;
    }

    keybind_remove(kb);
    keybinding_get_data(&keysym, &flags, &buf);
    res=keybind_insert(keysym, (unsigned int)flags, buf);
    if(res == 0)
      keybind_free(&kb);

    else
      keybind_insert(kb->keysym, (unsigned int)kb->flags, kb->command);
    save_keys();
    update_keybinding_list();
  }

  else
    LOG((enum LogLevel)LOG_ERROR, "keys.c::on_keybinding_button_update_clicked", "Nothing selected to update\n");

__CPROVER_DUMP_L6:
  ;
}

// on_keybinding_checkbutton_any_clicked
// file keys.c line 2432
extern void on_keybinding_checkbutton_any_clicked(struct _GtkCheckButton *cb, void *user_data)
{
  signed int enabled;
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)cb, return_value_gtk_toggle_button_get_type$1);
  signed int return_value_gtk_toggle_button_get_active$3;
  return_value_gtk_toggle_button_get_active$3=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2);
  enabled = (signed int)!(return_value_gtk_toggle_button_get_active$3 != 0);
  unsigned long int return_value_gtk_widget_get_type$4;
  return_value_gtk_widget_get_type$4=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_control, return_value_gtk_widget_get_type$4);
  gtk_widget_set_sensitive((struct _GtkWidget *)return_value_g_type_check_instance_cast$5, enabled);
  unsigned long int return_value_gtk_widget_get_type$6;
  return_value_gtk_widget_get_type$6=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_shift, return_value_gtk_widget_get_type$6);
  gtk_widget_set_sensitive((struct _GtkWidget *)return_value_g_type_check_instance_cast$7, enabled);
  unsigned long int return_value_gtk_widget_get_type$8;
  return_value_gtk_widget_get_type$8=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_alt, return_value_gtk_widget_get_type$8);
  gtk_widget_set_sensitive((struct _GtkWidget *)return_value_g_type_check_instance_cast$9, enabled);
  unsigned long int return_value_gtk_widget_get_type$10;
  return_value_gtk_widget_get_type$10=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_meta, return_value_gtk_widget_get_type$10);
  gtk_widget_set_sensitive((struct _GtkWidget *)return_value_g_type_check_instance_cast$11, enabled);
}

// on_keybinding_entry_key_key_press_event
// file keys.c line 1992
extern signed int on_keybinding_entry_key_key_press_event(struct _GtkWidget *widget, struct _GdkEventKey *event, void *user_data)
{
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_entry_key, return_value_gtk_entry_get_type$1);
  char *return_value_gdk_keyval_name$3;
  return_value_gdk_keyval_name$3=gdk_keyval_name(event->keyval);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2, return_value_gdk_keyval_name$3);
  unsigned long int return_value_gtk_toggle_button_get_type$4;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  if(!((4u & event->state) == 0u))
  {
    return_value_gtk_toggle_button_get_type$4=gtk_toggle_button_get_type();
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_control, return_value_gtk_toggle_button_get_type$4);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$5, (signed int)!(0 != 0));
  }

  unsigned long int return_value_gtk_toggle_button_get_type$6;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  if(!((1u & event->state) == 0u))
  {
    return_value_gtk_toggle_button_get_type$6=gtk_toggle_button_get_type();
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_shift, return_value_gtk_toggle_button_get_type$6);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$7, (signed int)!(0 != 0));
  }

  return (signed int)!(0 != 0);
}

// on_keybindings_activate
// file keys.c line 1974
extern void on_keybindings_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  gtk_widget_show(keybinding_window);
  update_keybinding_list();
}

// on_menu_all_weapons_activate
// file gtk2proto.h line 213
extern void on_menu_all_weapons_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00020000);
}

// on_menu_arrows_activate
// file gtk2proto.h line 216
extern void on_menu_arrows_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00000100);
}

// on_menu_body_armor_activate
// file gtk2proto.h line 193
extern void on_menu_body_armor_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00000800);
}

// on_menu_boots_activate
// file gtk2proto.h line 194
extern void on_menu_boots_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00001000);
}

// on_menu_bows_activate
// file gtk2proto.h line 215
extern void on_menu_bows_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00000080);
}

// on_menu_cloaks_activate
// file gtk2proto.h line 195
extern void on_menu_cloaks_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00004000);
}

// on_menu_containers_activate
// file gtk2proto.h line 211
extern void on_menu_containers_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x08000000);
}

// on_menu_dont_pickup_activate
// file gtk2proto.h line 191
extern void on_menu_dont_pickup_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x20000000);
}

// on_menu_drinks_activate
// file gtk2proto.h line 202
extern void on_menu_drinks_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00000020);
}

// on_menu_flesh_activate
// file gtk2proto.h line 212
extern void on_menu_flesh_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x04000000);
}

// on_menu_food_activate
// file gtk2proto.h line 203
extern void on_menu_food_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00000010);
}

// on_menu_gloves_activate
// file gtk2proto.h line 196
extern void on_menu_gloves_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00002000);
}

// on_menu_helmets_activate
// file gtk2proto.h line 197
extern void on_menu_helmets_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00000200);
}

// on_menu_jewels_activate
// file gtk2proto.h line 210
extern void on_menu_jewels_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x02000000);
}

// on_menu_keys_activate
// file gtk2proto.h line 204
extern void on_menu_keys_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00008000);
}

// on_menu_magical_items_activate
// file gtk2proto.h line 205
extern void on_menu_magical_items_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00040000);
}

// on_menu_missile_weapons_activate
// file gtk2proto.h line 214
extern void on_menu_missile_weapons_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00010000);
}

// on_menu_normal_book_scrolls_activate
// file gtk2proto.h line 200
extern void on_menu_normal_book_scrolls_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00400000);
}

// on_menu_not_cursed_activate
// file gtk2proto.h line 209
extern void on_menu_not_cursed_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x01000000);
}

// on_menu_potions_activate
// file gtk2proto.h line 206
extern void on_menu_potions_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00080000);
}

// on_menu_ratio_10_activate
// file gtk2proto.h line 219
extern void on_menu_ratio_10_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 2);
}

// on_menu_ratio_15_activate
// file gtk2proto.h line 220
extern void on_menu_ratio_15_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 3);
}

// on_menu_ratio_20_activate
// file gtk2proto.h line 221
extern void on_menu_ratio_20_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 4);
}

// on_menu_ratio_25_activate
// file gtk2proto.h line 222
extern void on_menu_ratio_25_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 5);
}

// on_menu_ratio_30_activate
// file pickup.c line 364
extern void on_menu_ratio_30_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 6);
}

// on_menu_ratio_35_activate
// file gtk2proto.h line 224
extern void on_menu_ratio_35_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 7);
}

// on_menu_ratio_40_activate
// file gtk2proto.h line 225
extern void on_menu_ratio_40_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 8);
}

// on_menu_ratio_45_activate
// file gtk2proto.h line 226
extern void on_menu_ratio_45_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 9);
}

// on_menu_ratio_50_activate
// file gtk2proto.h line 227
extern void on_menu_ratio_50_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 10);
}

// on_menu_ratio_5_activate
// file gtk2proto.h line 218
extern void on_menu_ratio_5_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 1);
}

// on_menu_ratio_pickup_off_activate
// file gtk2proto.h line 217
extern void on_menu_ratio_pickup_off_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0);
}

// on_menu_shields_activate
// file gtk2proto.h line 198
extern void on_menu_shields_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00000400);
}

// on_menu_skillscrolls_activate
// file gtk2proto.h line 199
extern void on_menu_skillscrolls_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00200000);
}

// on_menu_spellbooks_activate
// file gtk2proto.h line 201
extern void on_menu_spellbooks_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00100000);
}

// on_menu_stop_before_pickup_activate
// file gtk2proto.h line 192
extern void on_menu_stop_before_pickup_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x40000000);
}

// on_menu_valuables_activate
// file gtk2proto.h line 207
extern void on_menu_valuables_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00000040);
}

// on_menu_wands_rods_horns_activate
// file gtk2proto.h line 208
extern void on_menu_wands_rods_horns_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  unsigned long int return_value_gtk_check_menu_item_get_type$1;
  return_value_gtk_check_menu_item_get_type$1=gtk_check_menu_item_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_check_menu_item_get_type$1);
  signed int return_value_gtk_check_menu_item_get_active$3;
  return_value_gtk_check_menu_item_get_active$3=gtk_check_menu_item_get_active((struct _GtkCheckMenuItem *)return_value_g_type_check_instance_cast$2);
  new_menu_pickup(return_value_gtk_check_menu_item_get_active$3, 0x00800000);
}

// on_metaserver_select_clicked
// file metaserver.c line 283
extern void on_metaserver_select_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GtkTreeModel *model;
  struct _GtkTreeIter iter;
  char *name = (char *)(void *)0;
  char *ip = (char *)(void *)0;
  char *metaserver_txt;
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)metaserver_entry, return_value_gtk_entry_get_type$1);
  const char *return_value_gtk_entry_get_text$3;
  return_value_gtk_entry_get_text$3=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  metaserver_txt = (char *)return_value_gtk_entry_get_text$3;
  signed int return_value_gtk_tree_selection_get_selected$8;
  return_value_gtk_tree_selection_get_selected$8=gtk_tree_selection_get_selected(metaserver_selection, &model, &iter);
  if(!(return_value_gtk_tree_selection_get_selected$8 == 0))
    gtk_tree_model_get(model, &iter, 0, &name, 1, &ip, -1);

  else
    if((signed int)*metaserver_txt == 0)
    {
      unsigned long int return_value_gtk_label_get_type$4;
      return_value_gtk_label_get_type$4=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
      return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)metaserver_status, return_value_gtk_label_get_type$4);
      gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$5, "Error - nothing selected!\n");
      gtk_widget_set_sensitive(metaserver_button, 0);
      goto __CPROVER_DUMP_L5;
    }

    else
    {
      unsigned long int return_value_gtk_label_get_type$6;
      return_value_gtk_label_get_type$6=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
      return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)metaserver_status, return_value_gtk_label_get_type$6);
      gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$7, "Error - nothing selected!\n");
    }
  if(name == ((char *)NULL))
    name = metaserver_txt;

  metaserver_connect_to(name);

__CPROVER_DUMP_L5:
  ;
}

// on_metaserver_text_entry_activate
// file metaserver.c line 342
extern void on_metaserver_text_entry_activate(struct _GtkEntry *entry, void *user_data)
{
  const char *entry_text;
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry, return_value_gtk_entry_get_type$1);
  entry_text=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  metaserver_connect_to(entry_text);
}

// on_metaserver_text_entry_key_press_event
// file metaserver.c line 368
extern signed int on_metaserver_text_entry_key_press_event(struct _GtkWidget *widget, struct _GdkEventKey *event, void *user_data)
{
  gtk_widget_set_sensitive(metaserver_button, (signed int)!(0 != 0));
  gtk_tree_selection_unselect_all(metaserver_selection);
  return 0;
}

// on_msgctrl_activate
// file info.c line 1907
extern void on_msgctrl_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  gtk_widget_show(msgctrl_window);
}

// on_msgctrl_button_apply_clicked
// file info.c line 1877
extern void on_msgctrl_button_apply_clicked(struct _GtkButton *button, void *user_data)
{
  read_msgctrl_configuration();
}

// on_msgctrl_button_close_clicked
// file info.c line 1891
extern void on_msgctrl_button_close_clicked(struct _GtkButton *button, void *user_data)
{
  read_msgctrl_configuration();
  gtk_widget_hide(msgctrl_window);
}

// on_msgctrl_button_defaults_clicked
// file info.c line 1862
extern void on_msgctrl_button_defaults_clicked(struct _GtkButton *button, void *user_data)
{
  default_msgctrl_configuration();
}

// on_msgctrl_button_load_clicked
// file info.c line 1848
extern void on_msgctrl_button_load_clicked(struct _GtkButton *button, void *user_data)
{
  load_msgctrl_configuration();
}

// on_msgctrl_button_save_clicked
// file info.c line 1832
extern void on_msgctrl_button_save_clicked(struct _GtkButton *button, void *user_data)
{
  read_msgctrl_configuration();
  save_msgctrl_configuration();
}

// on_notebook_switch_page
// file inventory.c line 1130
extern void on_notebook_switch_page(struct _GtkNotebook *notebook, struct _GtkNotebookPage *page, unsigned int page_num, void *user_data)
{
  signed int oldpage;
  unsigned long int return_value_gtk_notebook_get_type$1;
  return_value_gtk_notebook_get_type$1=gtk_notebook_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)notebook, return_value_gtk_notebook_get_type$1);
  oldpage=gtk_notebook_get_current_page((struct _GtkNotebook *)return_value_g_type_check_instance_cast$2);
  if(!((unsigned int)oldpage == page_num))
  {
    if(inv_notebooks[(signed long int)oldpage].type == 0)
      gtk_tree_store_clear(inv_notebooks[(signed long int)oldpage].treestore);

  }

  cpl.ob->inv_updated = (unsigned short int)1;
}

// on_save_window_position_activate
// file config.c line 1150
extern void on_save_window_position_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  save_winpos();
  unsigned long int return_value_gtk_object_get_type$1;
  return_value_gtk_object_get_type$1=gtk_object_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)menuitem, return_value_gtk_object_get_type$1);
  g_signal_stop_emission_by_name((void *)(struct _GtkObject *)return_value_g_type_check_instance_cast$2, "activate");
}

// on_skill_close_clicked
// file skills.c line 271
extern void on_skill_close_clicked(struct _GtkButton *button, void *user_data)
{
  gtk_widget_hide(skill_window);
}

// on_skill_ready_clicked
// file skills.c line 242
extern void on_skill_ready_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GtkTreeIter iter;
  struct _GtkTreeModel *model;
  signed int return_value_gtk_tree_selection_get_selected$1;
  return_value_gtk_tree_selection_get_selected$1=gtk_tree_selection_get_selected(skill_selection, &model, &iter);
  if(!(return_value_gtk_tree_selection_get_selected$1 == 0))
    trigger_skill(iter, model, 0);

  gtk_widget_hide(skill_window);
}

// on_skill_treeview_row_activated
// file skills.c line 225
extern void on_skill_treeview_row_activated(struct _GtkTreeView *treeview, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data)
{
  struct _GtkTreeIter iter;
  struct _GtkTreeModel *model;
  model=gtk_tree_view_get_model(treeview);
  signed int return_value_gtk_tree_model_get_iter$1;
  return_value_gtk_tree_model_get_iter$1=gtk_tree_model_get_iter(model, &iter, path);
  if(!(return_value_gtk_tree_model_get_iter$1 == 0))
    trigger_skill(iter, model, 0);

  gtk_widget_hide(skill_window);
}

// on_skill_use_clicked
// file skills.c line 257
extern void on_skill_use_clicked(struct _GtkButton *button, void *user_data)
{
  struct _GtkTreeIter iter;
  struct _GtkTreeModel *model;
  signed int return_value_gtk_tree_selection_get_selected$1;
  return_value_gtk_tree_selection_get_selected$1=gtk_tree_selection_get_selected(skill_selection, &model, &iter);
  if(!(return_value_gtk_tree_selection_get_selected$1 == 0))
    trigger_skill(iter, model, 1);

}

// on_skills_activate
// file gtk2proto.h line 243
extern void on_skills_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  struct _GtkWidget *widget;
  if(has_init$link2 == 0)
  {
    struct _GtkCellRenderer *renderer;
    struct _GtkTreeViewColumn *column;
    struct _GObject *return_value_gtk_builder_get_object$1;
    return_value_gtk_builder_get_object$1=gtk_builder_get_object(dialog_xml, "skill_window");
    unsigned long int return_value_gtk_widget_get_type$2;
    return_value_gtk_widget_get_type$2=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
    skill_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
    struct _GObject *return_value_gtk_builder_get_object$4;
    return_value_gtk_builder_get_object$4=gtk_builder_get_object(dialog_xml, "skill_use");
    unsigned long int return_value_gtk_widget_get_type$5;
    return_value_gtk_widget_get_type$5=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$4, return_value_gtk_widget_get_type$5);
    skill_use = (struct _GtkWidget *)return_value_g_type_check_instance_cast$6;
    struct _GObject *return_value_gtk_builder_get_object$7;
    return_value_gtk_builder_get_object$7=gtk_builder_get_object(dialog_xml, "skill_ready");
    unsigned long int return_value_gtk_widget_get_type$8;
    return_value_gtk_widget_get_type$8=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$7, return_value_gtk_widget_get_type$8);
    skill_ready = (struct _GtkWidget *)return_value_g_type_check_instance_cast$9;
    struct _GObject *return_value_gtk_builder_get_object$10;
    return_value_gtk_builder_get_object$10=gtk_builder_get_object(dialog_xml, "skill_treeview");
    unsigned long int return_value_gtk_widget_get_type$11;
    return_value_gtk_widget_get_type$11=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$10, return_value_gtk_widget_get_type$11);
    skill_treeview = (struct _GtkWidget *)return_value_g_type_check_instance_cast$12;
    g_signal_connect_data((void *)skill_window, "delete_event", (void (*)(void))gtk_widget_hide_on_delete, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)skill_treeview, "row_activated", (void (*)(void))on_skill_treeview_row_activated, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)skill_ready, "clicked", (void (*)(void))on_skill_ready_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)skill_use, "clicked", (void (*)(void))on_skill_use_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    struct _GObject *return_value_gtk_builder_get_object$13;
    return_value_gtk_builder_get_object$13=gtk_builder_get_object(dialog_xml, "skill_close");
    unsigned long int return_value_gtk_widget_get_type$14;
    return_value_gtk_widget_get_type$14=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$13, return_value_gtk_widget_get_type$14);
    widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$15;
    g_signal_connect_data((void *)widget, "clicked", (void (*)(void))on_skill_close_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    skill_store=gtk_list_store_new(4, (unsigned long int)(16 << 2), (unsigned long int)(6 << 2), (unsigned long int)(10 << 2), (unsigned long int)(10 << 2));
    unsigned long int return_value_gtk_tree_view_get_type$16;
    return_value_gtk_tree_view_get_type$16=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
    return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)skill_treeview, return_value_gtk_tree_view_get_type$16);
    unsigned long int return_value_gtk_tree_model_get_type$18;
    return_value_gtk_tree_model_get_type$18=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$19;
    return_value_g_type_check_instance_cast$19=g_type_check_instance_cast((struct _GTypeInstance *)skill_store, return_value_gtk_tree_model_get_type$18);
    gtk_tree_view_set_model((struct _GtkTreeView *)return_value_g_type_check_instance_cast$17, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$19);
    unsigned long int return_value_gtk_tree_view_get_type$20;
    return_value_gtk_tree_view_get_type$20=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
    return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)skill_treeview, return_value_gtk_tree_view_get_type$20);
    gtk_tree_view_set_rules_hint((struct _GtkTreeView *)return_value_g_type_check_instance_cast$21, (signed int)!(0 != 0));
    renderer=gtk_cell_renderer_text_new();
    column=gtk_tree_view_column_new_with_attributes("Skill", renderer, (const void *)"text", 0, (void *)0);
    unsigned long int return_value_gtk_tree_view_get_type$22;
    return_value_gtk_tree_view_get_type$22=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
    return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)skill_treeview, return_value_gtk_tree_view_get_type$22);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$23, column);
    gtk_tree_view_column_set_sort_column_id(column, 0);
    renderer=gtk_cell_renderer_text_new();
    column=gtk_tree_view_column_new_with_attributes("Level", renderer, (const void *)"text", 1, (void *)0);
    unsigned long int return_value_gtk_tree_view_get_type$24;
    return_value_gtk_tree_view_get_type$24=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
    return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)skill_treeview, return_value_gtk_tree_view_get_type$24);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$25, column);
    gtk_tree_view_column_set_sort_column_id(column, 1);
    renderer=gtk_cell_renderer_text_new();
    column=gtk_tree_view_column_new_with_attributes("Exp", renderer, (const void *)"text", 2, (void *)0);
    unsigned long int return_value_gtk_tree_view_get_type$26;
    return_value_gtk_tree_view_get_type$26=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
    return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)skill_treeview, return_value_gtk_tree_view_get_type$26);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$27, column);
    gtk_tree_view_column_set_sort_column_id(column, 2);
    renderer=gtk_cell_renderer_text_new();
    column=gtk_tree_view_column_new_with_attributes("Needed for next level", renderer, (const void *)"text", 3, (void *)0);
    unsigned long int return_value_gtk_tree_view_get_type$28;
    return_value_gtk_tree_view_get_type$28=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
    return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)skill_treeview, return_value_gtk_tree_view_get_type$28);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$29, column);
    gtk_tree_view_column_set_sort_column_id(column, 3);
    unsigned long int return_value_gtk_tree_view_get_type$30;
    return_value_gtk_tree_view_get_type$30=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$31;
    return_value_g_type_check_instance_cast$31=g_type_check_instance_cast((struct _GTypeInstance *)skill_treeview, return_value_gtk_tree_view_get_type$30);
    skill_selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$31);
    gtk_tree_selection_set_mode(skill_selection, (enum anonymous$24)GTK_SELECTION_BROWSE);
    gtk_tree_selection_set_select_function(skill_selection, skill_selection_func, (void *)0, (void (*)(void *))(void *)0);
    unsigned long int return_value_gtk_tree_sortable_get_type$32;
    return_value_gtk_tree_sortable_get_type$32=gtk_tree_sortable_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
    return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)skill_store, return_value_gtk_tree_sortable_get_type$32);
    gtk_tree_sortable_set_sort_column_id((struct _GtkTreeSortable *)return_value_g_type_check_instance_cast$33, 0, (enum anonymous$26)GTK_SORT_ASCENDING);
  }

  gtk_widget_set_sensitive(skill_ready, 0);
  gtk_widget_set_sensitive(skill_use, 0);
  gtk_widget_show(skill_window);
  has_init$link2 = 1;
  update_skill_information();
}

// on_spell_cast_clicked
// file spells.c line 527
extern void on_spell_cast_clicked(struct _GtkButton *button, void *user_data)
{
  signed int tag;
  char command[256l];
  const char *options = (const char *)(void *)0;
  struct _GtkTreeIter iter;
  struct _GtkTreeModel *model;
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)spell_options, return_value_gtk_entry_get_type$1);
  options=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  signed int return_value_gtk_tree_selection_get_selected$3;
  return_value_gtk_tree_selection_get_selected$3=gtk_tree_selection_get_selected(spell_selection, &model, &iter);
  if(!(return_value_gtk_tree_selection_get_selected$3 == 0))
  {
    gtk_tree_model_get(model, &iter, 11, &tag, -1);
    if(tag == 0)
    {
      LOG((enum LogLevel)LOG_ERROR, "spells.c::on_spell_cast_clicked", "Unable to get spell tag\n");
      goto __CPROVER_DUMP_L3;
    }

    snprintf(command, (unsigned long int)(256 - 1), "cast %d %s", tag, options);
    send_command(command, -1, 1);
  }


__CPROVER_DUMP_L3:
  ;
}

// on_spell_close_clicked
// file spells.c line 583
extern void on_spell_close_clicked(struct _GtkButton *button, void *user_data)
{
  gtk_widget_hide(spell_window);
}

// on_spell_invoke_clicked
// file spells.c line 555
extern void on_spell_invoke_clicked(struct _GtkButton *button, void *user_data)
{
  signed int tag;
  char command[256l];
  const char *options = (const char *)(void *)0;
  struct _GtkTreeIter iter;
  struct _GtkTreeModel *model;
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)spell_options, return_value_gtk_entry_get_type$1);
  options=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  signed int return_value_gtk_tree_selection_get_selected$3;
  return_value_gtk_tree_selection_get_selected$3=gtk_tree_selection_get_selected(spell_selection, &model, &iter);
  if(!(return_value_gtk_tree_selection_get_selected$3 == 0))
  {
    gtk_tree_model_get(model, &iter, 11, &tag, -1);
    if(tag == 0)
    {
      LOG((enum LogLevel)LOG_ERROR, "spells.c::on_spell_invoke_clicked", "Unable to get spell tag\n");
      goto __CPROVER_DUMP_L3;
    }

    snprintf(command, (unsigned long int)(256 - 1), "invoke %d %s", tag, options);
    send_command(command, -1, 1);
  }


__CPROVER_DUMP_L3:
  ;
}

// on_spell_treeview_row_activated
// file spells.c line 495
extern void on_spell_treeview_row_activated(struct _GtkTreeView *treeview, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data)
{
  signed int tag;
  char command[256l];
  const char *options = (const char *)(void *)0;
  struct _GtkTreeIter iter;
  struct _GtkTreeModel *model;
  model=gtk_tree_view_get_model(treeview);
  signed int return_value_gtk_tree_model_get_iter$1;
  return_value_gtk_tree_model_get_iter$1=gtk_tree_model_get_iter(model, &iter, path);
  if(!(return_value_gtk_tree_model_get_iter$1 == 0))
  {
    gtk_tree_model_get(model, &iter, 11, &tag, -1);
    if(tag == 0)
    {
      LOG((enum LogLevel)LOG_ERROR, "spells.c::on_spell_cast_clicked", "Unable to get spell tag\n");
      goto __CPROVER_DUMP_L3;
    }

    /* assertion options != ((void *)0) */
    assert(options != (const char *)(void *)0);
    snprintf(command, (unsigned long int)(256 - 1), "cast %d %s", tag, options);
    send_command(command, -1, 1);
  }


__CPROVER_DUMP_L3:
  ;
}

// on_spell_window_size_allocate
// file spells.c line 127
extern void on_spell_window_size_allocate(struct _GtkWidget *widget, void *user_data)
{
  unsigned int i;
  unsigned int on_spell_window_size_allocate$$1$$width;
  signed int valid;
  struct _GtkTreeIter iter;
  unsigned int column_count;
  struct _GList *column_list;
  struct _GtkTreeViewColumn *column;
  if(!(has_init$link3 == 0))
  {
    on_spell_window_size_allocate$$1$$width = (unsigned int)spell_treeview->allocation.width;
    unsigned long int return_value_gtk_tree_view_get_type$1;
    return_value_gtk_tree_view_get_type$1=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)spell_treeview, return_value_gtk_tree_view_get_type$1);
    column_list=gtk_tree_view_get_columns((struct _GtkTreeView *)return_value_g_type_check_instance_cast$2);
    column_count=g_list_length(column_list);
    i = (unsigned int)0;
    for( ; !(i >= column_count + 4294967295u); i = i + (unsigned int)1)
    {
      void *return_value_g_list_nth_data$3;
      return_value_g_list_nth_data$3=g_list_nth_data(column_list, i);
      column = (struct _GtkTreeViewColumn *)return_value_g_list_nth_data$3;
      signed int return_value_gtk_tree_view_column_get_width$4;
      return_value_gtk_tree_view_column_get_width$4=gtk_tree_view_column_get_width(column);
      on_spell_window_size_allocate$$1$$width = on_spell_window_size_allocate$$1$$width - (unsigned int)return_value_gtk_tree_view_column_get_width$4;
    }
    g_list_free(column_list);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)description_renderer, (unsigned long int)(20 << 2));
    g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$5, "wrap-width", on_spell_window_size_allocate$$1$$width, (void *)0);
    unsigned long int return_value_gtk_tree_model_get_type$6;
    return_value_gtk_tree_model_get_type$6=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)spell_store, return_value_gtk_tree_model_get_type$6);
    valid=gtk_tree_model_get_iter_first((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$7, &iter);
    while(!(valid == 0))
    {
      struct _GtkTreePath *tree_path;
      unsigned long int return_value_gtk_tree_model_get_type$8;
      return_value_gtk_tree_model_get_type$8=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
      return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)spell_store, return_value_gtk_tree_model_get_type$8);
      tree_path=gtk_tree_model_get_path((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$9, &iter);
      unsigned long int return_value_gtk_tree_model_get_type$10;
      return_value_gtk_tree_model_get_type$10=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
      return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)spell_store, return_value_gtk_tree_model_get_type$10);
      gtk_tree_model_row_changed((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$11, tree_path, &iter);
      gtk_tree_path_free(tree_path);
      unsigned long int return_value_gtk_tree_model_get_type$12;
      return_value_gtk_tree_model_get_type$12=gtk_tree_model_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$13;
      return_value_g_type_check_instance_cast$13=g_type_check_instance_cast((struct _GTypeInstance *)spell_store, return_value_gtk_tree_model_get_type$12);
      valid=gtk_tree_model_iter_next((struct _GtkTreeModel *)return_value_g_type_check_instance_cast$13, &iter);
    }
  }

}

// on_spells_activate
// file gtk2proto.h line 258
extern void on_spells_activate(struct _GtkMenuItem *menuitem, void *user_data)
{
  struct _GtkWidget *widget;
  if(has_init$link3 == 0)
  {
    struct _GtkCellRenderer *renderer;
    struct _GtkTreeViewColumn *column;
    struct _GObject *return_value_gtk_builder_get_object$1;
    return_value_gtk_builder_get_object$1=gtk_builder_get_object(dialog_xml, "spell_window");
    unsigned long int return_value_gtk_widget_get_type$2;
    return_value_gtk_widget_get_type$2=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
    spell_window = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
    struct _GObject *return_value_gtk_builder_get_object$4;
    return_value_gtk_builder_get_object$4=gtk_builder_get_object(dialog_xml, "spell_invoke");
    unsigned long int return_value_gtk_widget_get_type$5;
    return_value_gtk_widget_get_type$5=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$4, return_value_gtk_widget_get_type$5);
    spell_invoke = (struct _GtkWidget *)return_value_g_type_check_instance_cast$6;
    struct _GObject *return_value_gtk_builder_get_object$7;
    return_value_gtk_builder_get_object$7=gtk_builder_get_object(dialog_xml, "spell_cast");
    unsigned long int return_value_gtk_widget_get_type$8;
    return_value_gtk_widget_get_type$8=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$7, return_value_gtk_widget_get_type$8);
    spell_cast = (struct _GtkWidget *)return_value_g_type_check_instance_cast$9;
    struct _GObject *return_value_gtk_builder_get_object$10;
    return_value_gtk_builder_get_object$10=gtk_builder_get_object(dialog_xml, "spell_options");
    unsigned long int return_value_gtk_widget_get_type$11;
    return_value_gtk_widget_get_type$11=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$10, return_value_gtk_widget_get_type$11);
    spell_options = (struct _GtkWidget *)return_value_g_type_check_instance_cast$12;
    struct _GObject *return_value_gtk_builder_get_object$13;
    return_value_gtk_builder_get_object$13=gtk_builder_get_object(dialog_xml, "spell_treeview");
    unsigned long int return_value_gtk_widget_get_type$14;
    return_value_gtk_widget_get_type$14=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$13, return_value_gtk_widget_get_type$14);
    spell_treeview = (struct _GtkWidget *)return_value_g_type_check_instance_cast$15;
    g_signal_connect_data((void *)spell_window, "size-allocate", (void (*)(void))on_spell_window_size_allocate, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)spell_window, "delete-event", (void (*)(void))gtk_widget_hide_on_delete, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)spell_treeview, "row_activated", (void (*)(void))on_spell_treeview_row_activated, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)spell_cast, "clicked", (void (*)(void))on_spell_cast_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    g_signal_connect_data((void *)spell_invoke, "clicked", (void (*)(void))on_spell_invoke_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    struct _GObject *return_value_gtk_builder_get_object$16;
    return_value_gtk_builder_get_object$16=gtk_builder_get_object(dialog_xml, "spell_close");
    unsigned long int return_value_gtk_widget_get_type$17;
    return_value_gtk_widget_get_type$17=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$16, return_value_gtk_widget_get_type$17);
    widget = (struct _GtkWidget *)return_value_g_type_check_instance_cast$18;
    g_signal_connect_data((void *)widget, "clicked", (void (*)(void))on_spell_close_clicked, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
    unsigned long int return_value_gdk_color_get_type$19;
    return_value_gdk_color_get_type$19=gdk_color_get_type();
    unsigned long int return_value_gdk_color_get_type$20;
    return_value_gdk_color_get_type$20=gdk_color_get_type();
    unsigned long int return_value_pango_font_description_get_type$21;
    return_value_pango_font_description_get_type$21=pango_font_description_get_type();
    spell_store=gtk_list_store_new(14, (unsigned long int)(20 << 2), (unsigned long int)(16 << 2), (unsigned long int)(6 << 2), (unsigned long int)(6 << 2), (unsigned long int)(16 << 2), (unsigned long int)(6 << 2), (unsigned long int)(16 << 2), (unsigned long int)(6 << 2), (unsigned long int)(16 << 2), return_value_gdk_color_get_type$19, (unsigned long int)(6 << 2), (unsigned long int)(6 << 2), return_value_gdk_color_get_type$20, return_value_pango_font_description_get_type$21);
    unsigned long int return_value_gtk_tree_view_get_type$22;
    return_value_gtk_tree_view_get_type$22=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
    return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)spell_treeview, return_value_gtk_tree_view_get_type$22);
    unsigned long int return_value_gtk_tree_model_get_type$24;
    return_value_gtk_tree_model_get_type$24=gtk_tree_model_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
    return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)spell_store, return_value_gtk_tree_model_get_type$24);
    gtk_tree_view_set_model((struct _GtkTreeView *)return_value_g_type_check_instance_cast$23, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$25);
    unsigned long int return_value_gtk_tree_view_get_type$26;
    return_value_gtk_tree_view_get_type$26=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
    return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)spell_treeview, return_value_gtk_tree_view_get_type$26);
    gtk_tree_view_set_rules_hint((struct _GtkTreeView *)return_value_g_type_check_instance_cast$27, (signed int)!(0 != 0));
    renderer=gtk_cell_renderer_text_new();
    renderer->xalign = (float)0;
    renderer->yalign = (float)0;
    column=gtk_tree_view_column_new_with_attributes("Spell", renderer, (const void *)"text", 1, (void *)0);
    unsigned long int return_value_gtk_tree_view_get_type$28;
    return_value_gtk_tree_view_get_type$28=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
    return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)spell_treeview, return_value_gtk_tree_view_get_type$28);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$29, column);
    gtk_tree_view_column_set_sort_column_id(column, 1);
    gtk_tree_view_column_add_attribute(column, renderer, "background-gdk", 9);
    gtk_tree_view_column_add_attribute(column, renderer, "foreground-gdk", 12);
    gtk_tree_view_column_add_attribute(column, renderer, "font-desc", 13);
    renderer=gtk_cell_renderer_text_new();
    renderer->xalign = (float)0.4;
    renderer->yalign = (float)0;
    column=gtk_tree_view_column_new_with_attributes("Level", renderer, (const void *)"text", 2, (void *)0);
    unsigned long int return_value_gtk_tree_view_get_type$30;
    return_value_gtk_tree_view_get_type$30=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$31;
    return_value_g_type_check_instance_cast$31=g_type_check_instance_cast((struct _GTypeInstance *)spell_treeview, return_value_gtk_tree_view_get_type$30);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$31, column);
    gtk_tree_view_column_set_sort_column_id(column, 2);
    gtk_tree_view_column_add_attribute(column, renderer, "background-gdk", 9);
    gtk_tree_view_column_add_attribute(column, renderer, "foreground-gdk", 12);
    gtk_tree_view_column_add_attribute(column, renderer, "font-desc", 13);
    renderer=gtk_cell_renderer_text_new();
    renderer->xalign = (float)0.4;
    renderer->yalign = (float)0;
    column=gtk_tree_view_column_new_with_attributes("Cost/Cast", renderer, (const void *)"text", 4, (void *)0);
    unsigned long int return_value_gtk_tree_view_get_type$32;
    return_value_gtk_tree_view_get_type$32=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
    return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)spell_treeview, return_value_gtk_tree_view_get_type$32);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$33, column);
    gtk_tree_view_column_set_sort_column_id(column, 10);
    gtk_tree_view_column_add_attribute(column, renderer, "background-gdk", 9);
    gtk_tree_view_column_add_attribute(column, renderer, "foreground-gdk", 12);
    gtk_tree_view_column_add_attribute(column, renderer, "font-desc", 13);
    renderer=gtk_cell_renderer_text_new();
    renderer->xalign = (float)0.4;
    renderer->yalign = (float)0;
    column=gtk_tree_view_column_new_with_attributes("Damage", renderer, (const void *)"text", 5, (void *)0);
    unsigned long int return_value_gtk_tree_view_get_type$34;
    return_value_gtk_tree_view_get_type$34=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$35;
    return_value_g_type_check_instance_cast$35=g_type_check_instance_cast((struct _GTypeInstance *)spell_treeview, return_value_gtk_tree_view_get_type$34);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$35, column);
    gtk_tree_view_column_set_sort_column_id(column, 5);
    gtk_tree_view_column_add_attribute(column, renderer, "background-gdk", 9);
    gtk_tree_view_column_add_attribute(column, renderer, "foreground-gdk", 12);
    gtk_tree_view_column_add_attribute(column, renderer, "font-desc", 13);
    column=gtk_tree_view_column_new_with_attributes("Skill", renderer, (const void *)"text", 6, (void *)0);
    unsigned long int return_value_gtk_tree_view_get_type$36;
    return_value_gtk_tree_view_get_type$36=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$37;
    return_value_g_type_check_instance_cast$37=g_type_check_instance_cast((struct _GTypeInstance *)spell_treeview, return_value_gtk_tree_view_get_type$36);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$37, column);
    gtk_tree_view_column_set_sort_column_id(column, 6);
    gtk_tree_view_column_add_attribute(column, renderer, "background-gdk", 9);
    gtk_tree_view_column_add_attribute(column, renderer, "foreground-gdk", 12);
    gtk_tree_view_column_add_attribute(column, renderer, "font-desc", 13);
    renderer=gtk_cell_renderer_text_new();
    renderer->xalign = (float)0;
    renderer->yalign = (float)0;
    column=gtk_tree_view_column_new_with_attributes("Description", renderer, (const void *)"text", 8, (void *)0);
    unsigned long int return_value_gtk_tree_view_get_type$38;
    return_value_gtk_tree_view_get_type$38=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$39;
    return_value_g_type_check_instance_cast$39=g_type_check_instance_cast((struct _GTypeInstance *)spell_treeview, return_value_gtk_tree_view_get_type$38);
    gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$39, column);
    gtk_tree_view_column_add_attribute(column, renderer, "background-gdk", 9);
    gtk_tree_view_column_add_attribute(column, renderer, "foreground-gdk", 12);
    gtk_tree_view_column_add_attribute(column, renderer, "font-desc", 13);
    struct _GTypeInstance *return_value_g_type_check_instance_cast$40;
    return_value_g_type_check_instance_cast$40=g_type_check_instance_cast((struct _GTypeInstance *)renderer, (unsigned long int)(20 << 2));
    g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$40, "wrap-width", 300, (const void *)"wrap-mode", 0, (void *)0);
    description_renderer = (void *)renderer;
    unsigned long int return_value_gtk_tree_view_get_type$41;
    return_value_gtk_tree_view_get_type$41=gtk_tree_view_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$42;
    return_value_g_type_check_instance_cast$42=g_type_check_instance_cast((struct _GTypeInstance *)spell_treeview, return_value_gtk_tree_view_get_type$41);
    spell_selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$42);
    gtk_tree_selection_set_mode(spell_selection, (enum anonymous$24)GTK_SELECTION_BROWSE);
    gtk_tree_selection_set_select_function(spell_selection, spell_selection_func, (void *)0, (void (*)(void *))(void *)0);
    unsigned long int return_value_gtk_tree_sortable_get_type$43;
    return_value_gtk_tree_sortable_get_type$43=gtk_tree_sortable_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$44;
    return_value_g_type_check_instance_cast$44=g_type_check_instance_cast((struct _GTypeInstance *)spell_store, return_value_gtk_tree_sortable_get_type$43);
    gtk_tree_sortable_set_sort_column_id((struct _GtkTreeSortable *)return_value_g_type_check_instance_cast$44, 1, (enum anonymous$26)GTK_SORT_ASCENDING);
    struct _GObject *return_value_gtk_builder_get_object$45;
    return_value_gtk_builder_get_object$45=gtk_builder_get_object(dialog_xml, "spell_label_attuned");
    unsigned long int return_value_gtk_widget_get_type$46;
    return_value_gtk_widget_get_type$46=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$47;
    return_value_g_type_check_instance_cast$47=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$45, return_value_gtk_widget_get_type$46);
    spell_label[(signed long int)0] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$47;
    struct _GObject *return_value_gtk_builder_get_object$48;
    return_value_gtk_builder_get_object$48=gtk_builder_get_object(dialog_xml, "spell_label_repelled");
    unsigned long int return_value_gtk_widget_get_type$49;
    return_value_gtk_widget_get_type$49=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$50;
    return_value_g_type_check_instance_cast$50=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$48, return_value_gtk_widget_get_type$49);
    spell_label[(signed long int)1] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$50;
    struct _GObject *return_value_gtk_builder_get_object$51;
    return_value_gtk_builder_get_object$51=gtk_builder_get_object(dialog_xml, "spell_label_denied");
    unsigned long int return_value_gtk_widget_get_type$52;
    return_value_gtk_widget_get_type$52=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$53;
    return_value_g_type_check_instance_cast$53=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$51, return_value_gtk_widget_get_type$52);
    spell_label[(signed long int)2] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$53;
    struct _GObject *return_value_gtk_builder_get_object$54;
    return_value_gtk_builder_get_object$54=gtk_builder_get_object(dialog_xml, "spell_label_normal");
    unsigned long int return_value_gtk_widget_get_type$55;
    return_value_gtk_widget_get_type$55=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$56;
    return_value_g_type_check_instance_cast$56=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$54, return_value_gtk_widget_get_type$55);
    spell_label[(signed long int)3] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$56;
    struct _GObject *return_value_gtk_builder_get_object$57;
    return_value_gtk_builder_get_object$57=gtk_builder_get_object(dialog_xml, "spell_eventbox_attuned");
    unsigned long int return_value_gtk_widget_get_type$58;
    return_value_gtk_widget_get_type$58=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$59;
    return_value_g_type_check_instance_cast$59=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$57, return_value_gtk_widget_get_type$58);
    spell_eventbox[(signed long int)0] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$59;
    struct _GObject *return_value_gtk_builder_get_object$60;
    return_value_gtk_builder_get_object$60=gtk_builder_get_object(dialog_xml, "spell_eventbox_repelled");
    unsigned long int return_value_gtk_widget_get_type$61;
    return_value_gtk_widget_get_type$61=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$62;
    return_value_g_type_check_instance_cast$62=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$60, return_value_gtk_widget_get_type$61);
    spell_eventbox[(signed long int)1] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$62;
    struct _GObject *return_value_gtk_builder_get_object$63;
    return_value_gtk_builder_get_object$63=gtk_builder_get_object(dialog_xml, "spell_eventbox_denied");
    unsigned long int return_value_gtk_widget_get_type$64;
    return_value_gtk_widget_get_type$64=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$65;
    return_value_g_type_check_instance_cast$65=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$63, return_value_gtk_widget_get_type$64);
    spell_eventbox[(signed long int)2] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$65;
    struct _GObject *return_value_gtk_builder_get_object$66;
    return_value_gtk_builder_get_object$66=gtk_builder_get_object(dialog_xml, "spell_eventbox_normal");
    unsigned long int return_value_gtk_widget_get_type$67;
    return_value_gtk_widget_get_type$67=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$68;
    return_value_g_type_check_instance_cast$68=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$66, return_value_gtk_widget_get_type$67);
    spell_eventbox[(signed long int)3] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$68;
  }

  gtk_widget_set_sensitive(spell_invoke, 0);
  gtk_widget_set_sensitive(spell_cast, 0);
  gtk_widget_show(spell_window);
  spell_get_styles();
  has_init$link3 = 1;
  update_spell_information();
}

// on_spinbutton_cc
// file create_char.c line 519
void on_spinbutton_cc(struct _GtkSpinButton *spinbutton, void *user_data)
{
  update_all_stats();
}

// on_treeview_choose_character_activated
// file account.c line 618
extern void on_treeview_choose_character_activated(struct _GtkTreeView *treeview, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data)
{
  struct _GtkTreeIter iter;
  struct _GtkTreeModel *model;
  char *name;
  model=gtk_tree_view_get_model(treeview);
  signed int return_value_gtk_tree_model_get_iter$1;
  return_value_gtk_tree_model_get_iter$1=gtk_tree_model_get_iter(model, &iter, path);
  if(!(return_value_gtk_tree_model_get_iter$1 == 0))
  {
    gtk_tree_model_get(model, &iter, 1, &name, -1);
    if(name == ((char *)NULL))
    {
      LOG((enum LogLevel)LOG_ERROR, "account.c::on_treeview_choose_character_activated", "unable to get character name");
      goto __CPROVER_DUMP_L3;
    }

    play_character(name);
  }


__CPROVER_DUMP_L3:
  ;
}

// on_treeview_metaserver_row_activated
// file metaserver.c line 322
extern void on_treeview_metaserver_row_activated(struct _GtkTreeView *treeview, struct _GtkTreePath *path, struct _GtkTreeViewColumn *column, void *user_data)
{
  struct _GtkTreeIter iter;
  struct _GtkTreeModel *model;
  char *name;
  char *ip;
  model=gtk_tree_view_get_model(treeview);
  signed int return_value_gtk_tree_model_get_iter$1;
  return_value_gtk_tree_model_get_iter$1=gtk_tree_model_get_iter(model, &iter, path);
  if(!(return_value_gtk_tree_model_get_iter$1 == 0))
  {
    gtk_tree_model_get(model, &iter, 0, &name, 1, &ip, -1);
    metaserver_connect_to(name);
  }

}

// on_window_delete_event
// file account.c line 134
extern signed int on_window_delete_event(struct _GtkWidget *window, void **user_data)
{
  return (signed int)!(0 != 0);
}

// on_window_destroy_event
// file main.c line 165
extern void on_window_destroy_event(struct _GtkObject *object, void *user_data)
{
  LOG((enum LogLevel)LOG_INFO, "main.c::client_exit", "Exiting with return value 0.");
  exit(0);
}

// open_container
// file inventory.c line 604
extern void open_container(struct item_struct *op)
{
  draw_lists();
}

// opengl_free_pixmap
// file gtk2proto.h line 188
extern void opengl_free_pixmap(struct PixmapInfo *pi)
{
  if(!(pi->map_texture == 0u))
  {
    glDeleteTextures(1, &pi->map_texture);
    pi->map_texture = (unsigned int)0;
  }

  if(!(pi->fog_texture == 0u))
  {
    glDeleteTextures(1, &pi->fog_texture);
    pi->fog_texture = (unsigned int)0;
  }

}

// opengl_gen_map
// file gtk2proto.h line 186
extern void opengl_gen_map(signed int redraw)
{
  signed long int elapsed1;
  signed long int elapsed2;
  struct timeval tv1;
  struct timeval tv2;
  struct timeval tv3;
  signed int mx;
  signed int my;
  signed int layer;
  signed int x;
  signed int y;
  signed int d1;
  signed int d2;
  signed int d3;
  signed int num_dark;
  signed int got_smooth;
  signed int face;
  signed int t1;
  signed int t2;
  if(!(time_map_redraw == 0))
    gettimeofday(&tv1, (struct timezone *)(void *)0);

  glClear((unsigned int)0x00004000);
  glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
  got_smooth = 0;
  layer = 0;
  _Bool tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$3;
  signed int tmp_if_expr$5;
  signed int tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  for( ; !(layer >= 11); layer = layer + 1)
  {
    if(layer == 10)
      glBindTexture((unsigned int)0x0DE1, (unsigned int)0);

    y = (signed int)use_config[(signed long int)20] + 8;
    for( ; y >= 0; y = y - 1)
    {
      x = (signed int)use_config[(signed long int)19] + 8;
      for( ; x >= 0; x = x - 1)
      {
        mx = x + pl_pos.x;
        my = y + pl_pos.y;
        if(layer == 10)
        {
          if(x >= (signed int)use_config[19l])
            tmp_if_expr$1 = (_Bool)1;

          else
            tmp_if_expr$1 = y >= (signed int)use_config[(signed long int)20] ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$1)
            goto __CPROVER_DUMP_L37;

          if(!(use_config[22l] == 0))
            opengl_light_space(x, y, mx, my);

        }

        else
        {
          if(layer == 0)
          {
            if((signed int)use_config[22l] >= 2)
            {
              if((signed int)use_config[19l] >= ~x)
              {
                if((signed int)use_config[20l] >= y)
                {
                  if(!((the_map.cells[(signed long int)mx] + (signed long int)my)->have_darkness == 0))
                    map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2 + 1)] = (unsigned short int)(the_map.cells[(signed long int)mx] + (signed long int)my)->darkness;

                  else
                    map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2 + 1)] = (unsigned short int)0;
                  d1 = 0;
                  d2 = 0;
                  d3 = 0;
                  num_dark = 1;
                  if(x >= 1)
                  {
                    if(!((the_map.cells[(signed long int)(mx + -1)] + (signed long int)my)->have_darkness == 0))
                    {
                      d1 = (signed int)(the_map.cells[(signed long int)(mx - 1)] + (signed long int)my)->darkness;
                      num_dark = num_dark + 1;
                    }

                  }

                  if(x >= 1 && y >= 1)
                  {
                    if(!((the_map.cells[(signed long int)(mx + -1)] + (signed long int)(my + -1))->have_darkness == 0))
                    {
                      d2 = (signed int)(the_map.cells[(signed long int)(mx - 1)] + (signed long int)(my - 1))->darkness;
                      num_dark = num_dark + 1;
                    }

                  }

                  if(y >= 1)
                  {
                    if(!((the_map.cells[(signed long int)mx] + (signed long int)(my + -1))->have_darkness == 0))
                    {
                      d3 = (signed int)(the_map.cells[(signed long int)mx] + (signed long int)(my - 1))->darkness;
                      num_dark = num_dark + 1;
                    }

                  }

                  if(!((signed int)map_darkness[(signed long int)(2 * x + 1)][(signed long int)(2 * y + 1)] >= d3))
                    tmp_if_expr$2 = d3;

                  else
                    tmp_if_expr$2 = (signed int)map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2 + 1)];
                  if(d2 >= d1 ? !(tmp_if_expr$2 >= d2) : !(tmp_if_expr$2 >= d1))
                    tmp_if_expr$4 = d1 > d2 ? d1 : d2;

                  else
                  {
                    if(!((signed int)map_darkness[(signed long int)(2 * x + 1)][(signed long int)(2 * y + 1)] >= d3))
                      tmp_if_expr$3 = d3;

                    else
                      tmp_if_expr$3 = (signed int)map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2 + 1)];
                    tmp_if_expr$4 = tmp_if_expr$3;
                  }
                  map_darkness[(signed long int)(x * 2)][(signed long int)(y * 2)] = (unsigned short int)tmp_if_expr$4;
                  if(!((signed int)map_darkness[(signed long int)(2 * x + 1)][(signed long int)(2 * y + 1)] >= d1))
                    tmp_if_expr$5 = d1;

                  else
                    tmp_if_expr$5 = (signed int)map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2 + 1)];
                  map_darkness[(signed long int)(x * 2)][(signed long int)(y * 2 + 1)] = (unsigned short int)tmp_if_expr$5;
                  if(!((signed int)map_darkness[(signed long int)(2 * x + 1)][(signed long int)(2 * y + 1)] >= d3))
                    tmp_if_expr$6 = d3;

                  else
                    tmp_if_expr$6 = (signed int)map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2 + 1)];
                  map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2)] = (unsigned short int)tmp_if_expr$6;
                }

              }

            }

          }

          if(!((the_map.cells[(signed long int)mx] + (signed long int)my)->heads[(signed long int)layer].face == 0))
          {
            if(!(pixmaps[(signed long int)(the_map.cells[(signed long int)mx] + (signed long int)my)->heads[(signed long int)layer].face]->map_texture == 0u))
            {
              signed int nx;
              signed int ny;
              nx = (x + 1) * map_image_size - (signed int)pixmaps[(signed long int)(the_map.cells[(signed long int)mx] + (signed long int)my)->heads[(signed long int)layer].face]->map_width;
              ny = (y + 1) * map_image_size - (signed int)pixmaps[(signed long int)(the_map.cells[(signed long int)mx] + (signed long int)my)->heads[(signed long int)layer].face]->map_height;
              if(!(height >= ny) && !(width >= nx))
                goto __CPROVER_DUMP_L37;

              if(!((the_map.cells[(signed long int)mx] + (signed long int)my)->cleared == 0))
                glBindTexture((unsigned int)0x0DE1, pixmaps[(signed long int)(the_map.cells[(signed long int)mx] + (signed long int)my)->heads[(signed long int)layer].face]->fog_texture);

              else
                glBindTexture((unsigned int)0x0DE1, pixmaps[(signed long int)(the_map.cells[(signed long int)mx] + (signed long int)my)->heads[(signed long int)layer].face]->map_texture);
              glBegin((unsigned int)0x0007);
              glTexCoord2f(0.0f, 0.0f);
              glVertex3i(nx, ny, 0);
              glTexCoord2f(1.0f, 0.0f);
              glVertex3i((x + 1) * map_image_size, ny, 0);
              glTexCoord2f(1.0f, 1.0f);
              glVertex3i((x + 1) * map_image_size, (y + 1) * map_image_size, 0);
              glTexCoord2f(0.0f, 1.0f);
              glVertex3i(nx, (y + 1) * map_image_size, 0);
              glEnd();
            }

            if(!(use_config[26l] == 0))
            {
              if((signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->heads[(signed long int)layer].face == 0 && layer >= 1)
                tmp_if_expr$7 = (_Bool)1;

              else
                tmp_if_expr$7 = (the_map.cells[(signed long int)mx] + (signed long int)my)->smooth[(signed long int)layer] != 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$7)
              {
                if(!((signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->heads[(signed long int)layer].face == 0))
                  got_smooth = 1;

              }

            }

          }

          signed short int return_value_mapdata_bigface_head$8;
          return_value_mapdata_bigface_head$8=mapdata_bigface_head(x, y, layer, &t1, &t2);
          face = (signed int)return_value_mapdata_bigface_head$8;
          if(!(face == 0))
          {
            if(!(pixmaps[(signed long int)face]->map_texture == 0u))
            {
              signed int opengl_gen_map$$1$$2$$1$$2$$1$$1$$1$$2$$3$$1$$nx;
              signed int opengl_gen_map$$1$$2$$1$$2$$1$$1$$1$$2$$3$$1$$ny;
              opengl_gen_map$$1$$2$$1$$2$$1$$1$$1$$2$$3$$1$$nx = (x + 1) * map_image_size - (signed int)pixmaps[(signed long int)face]->map_width;
              opengl_gen_map$$1$$2$$1$$2$$1$$1$$1$$2$$3$$1$$ny = (y + 1) * map_image_size - (signed int)pixmaps[(signed long int)face]->map_height;
              if(!(height >= opengl_gen_map$$1$$2$$1$$2$$1$$1$$1$$2$$3$$1$$ny) && !(width >= opengl_gen_map$$1$$2$$1$$2$$1$$1$$1$$2$$3$$1$$nx))
                goto __CPROVER_DUMP_L37;

              if(!((the_map.cells[(signed long int)mx] + (signed long int)my)->cleared == 0))
                glBindTexture((unsigned int)0x0DE1, pixmaps[(signed long int)face]->fog_texture);

              else
                glBindTexture((unsigned int)0x0DE1, pixmaps[(signed long int)face]->map_texture);
              glBegin((unsigned int)0x0007);
              glTexCoord2f(0.0f, 0.0f);
              glVertex3i(opengl_gen_map$$1$$2$$1$$2$$1$$1$$1$$2$$3$$1$$nx, opengl_gen_map$$1$$2$$1$$2$$1$$1$$1$$2$$3$$1$$ny, 0);
              glTexCoord2f(1.0f, 0.0f);
              glVertex3i((x + 1) * map_image_size, opengl_gen_map$$1$$2$$1$$2$$1$$1$$1$$2$$3$$1$$ny, 0);
              glTexCoord2f(1.0f, 1.0f);
              glVertex3i((x + 1) * map_image_size, (y + 1) * map_image_size, 0);
              glTexCoord2f(0.0f, 1.0f);
              glVertex3i(opengl_gen_map$$1$$2$$1$$2$$1$$1$$1$$2$$3$$1$$nx, (y + 1) * map_image_size, 0);
              glEnd();
            }

          }

        }

      __CPROVER_DUMP_L37:
        ;
      }
    }
    if(!(got_smooth == 0))
      draw_smoothing(layer);

  }
  if(!(time_map_redraw == 0))
    gettimeofday(&tv2, (struct timezone *)(void *)0);

  glXSwapBuffers(display, window);
  if(!(time_map_redraw == 0))
  {
    gettimeofday(&tv3, (struct timezone *)(void *)0);
    elapsed1 = (tv2.tv_sec - tv1.tv_sec) * (signed long int)1000000 + (tv2.tv_usec - tv1.tv_usec);
    elapsed2 = (tv3.tv_sec - tv2.tv_sec) * (signed long int)1000000 + (tv3.tv_usec - tv2.tv_usec);
    if(elapsed1 + elapsed2 >= 10001l)
      LOG((enum LogLevel)LOG_INFO, "gtk-v2::opengl_gen_map", "gen took %7ld, flip took %7ld, total = %7ld", elapsed1, elapsed2, elapsed1 + elapsed2);

  }

}

// opengl_light_space
// file opengl.c line 281
static void opengl_light_space(signed int x, signed int y, signed int mx, signed int my)
{
  _Bool tmp_if_expr$1;
  if((signed int)use_config[22l] == 1)
  {
    if((the_map.cells[(signed long int)mx] + (signed long int)my)->have_darkness == 0)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (signed int)(the_map.cells[(signed long int)mx] + (signed long int)my)->darkness == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      goto __CPROVER_DUMP_L4;

    glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (the_map.cells[(signed long int)mx] + (signed long int)my)->darkness);
    glBegin((unsigned int)0x0007);
    glVertex3i(x * map_image_size, y * map_image_size, 0);
    glVertex3i((x + 1) * map_image_size, y * map_image_size, 0);
    glVertex3i((x + 1) * map_image_size, (y + 1) * map_image_size, 0);
    glVertex3i(x * map_image_size, (y + 1) * map_image_size, 0);
    glEnd();
  }

  glBegin((unsigned int)0x0007);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2)][(signed long int)(y * 2)]);
  glVertex3i(x * map_image_size, y * map_image_size, 0);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2)]);
  glVertex3i(x * map_image_size + map_image_half_size, y * map_image_size, 0);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2 + 1)]);
  glVertex3i(x * map_image_size + map_image_half_size, y * map_image_size + map_image_half_size, 0);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2)][(signed long int)(y * 2 + 1)]);
  glVertex3i(x * map_image_size, y * map_image_size + map_image_half_size, 0);
  glEnd();
  glBegin((unsigned int)0x0007);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2)]);
  glVertex3i(x * map_image_size + map_image_half_size, y * map_image_size, 0);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2 + 2)][(signed long int)(y * 2)]);
  glVertex3i((x + 1) * map_image_size, y * map_image_size, 0);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2 + 2)][(signed long int)(y * 2 + 1)]);
  glVertex3i((x + 1) * map_image_size, y * map_image_size + map_image_half_size, 0);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2 + 1)]);
  glVertex3i(x * map_image_size + map_image_half_size, y * map_image_size + map_image_half_size, 0);
  glEnd();
  glBegin((unsigned int)0x0007);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2)][(signed long int)(y * 2 + 1)]);
  glVertex3i(x * map_image_size, y * map_image_size + map_image_half_size, 0);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2 + 1)]);
  glVertex3i(x * map_image_size + map_image_half_size, y * map_image_size + map_image_half_size, 0);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2 + 2)]);
  glVertex3i(x * map_image_size + map_image_half_size, (y + 1) * map_image_size, 0);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2)][(signed long int)(y * 2 + 2)]);
  glVertex3i(x * map_image_size, (y + 1) * map_image_size, 0);
  glEnd();
  glBegin((unsigned int)0x0007);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2 + 1)]);
  glVertex3i(x * map_image_size + map_image_half_size, y * map_image_size + map_image_half_size, 0);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2 + 2)][(signed long int)(y * 2 + 1)]);
  glVertex3i((x + 1) * map_image_size, y * map_image_size + map_image_half_size, 0);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2 + 2)][(signed long int)(y * 2 + 2)]);
  glVertex3i((x + 1) * map_image_size, (y + 1) * map_image_size, 0);
  glColor4ub((unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)map_darkness[(signed long int)(x * 2 + 1)][(signed long int)(y * 2 + 2)]);
  glVertex3i(x * map_image_size + map_image_half_size, (y + 1) * map_image_size, 0);
  glEnd();

__CPROVER_DUMP_L4:
  ;
}

// overlay_grid
// file sdl.c line 117
static void overlay_grid(signed int re_init, signed int ax, signed int ay)
{
  signed int x = 0;
  signed int y = 0;
  struct SDL_Rect dst;
  unsigned int *pixel;
  struct SDL_PixelFormat *fmt;
  ax = ax - pl_pos.x;
  ay = ay - pl_pos.y;
  static signed int first_pass;
  static struct SDL_Surface *grid_overlay;
  if(re_init == 1)
  {
    if(!(grid_overlay == ((struct SDL_Surface *)NULL)))
      SDL_FreeSurface(grid_overlay);

    first_pass = 0;
    grid_overlay = (struct SDL_Surface *)(void *)0;
  }

  if(grid_overlay == ((struct SDL_Surface *)NULL))
  {
    grid_overlay=SDL_CreateRGBSurface((unsigned int)(0x00000001 | 0x00010000), (signed int)use_config[(signed long int)19] * map_image_size, (signed int)use_config[(signed long int)20] * map_image_size, (signed int)mapsurface->format->BitsPerPixel, mapsurface->format->Rmask, mapsurface->format->Gmask, mapsurface->format->Bmask, mapsurface->format->Amask);
    if(grid_overlay == ((struct SDL_Surface *)NULL))
      do_SDL_error("CreateRGBSurface", "sdl.c", 153);

    grid_overlay=SDL_DisplayFormatAlpha(grid_overlay);
    first_pass = 0;
  }

  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(first_pass == 0)
  {
    fmt = grid_overlay->format;
    x = 0;
    for( ; !(x >= map_image_size * (signed int)use_config[19l]); x = x + 1)
    {
      y = 0;
      for( ; !(y >= map_image_size * (signed int)use_config[20l]); y = y + 1)
      {
        pixel = (unsigned int *)grid_overlay->pixels + (signed long int)((y * (signed int)grid_overlay->pitch) / 4) + (signed long int)x;
        if(x % map_image_size == 0 || y % map_image_size == 0 || x == 0 || y == 0)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = y == (signed int)use_config[(signed long int)20] * map_image_size - 1 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = x == (signed int)use_config[(signed long int)19] * map_image_size - 1 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
          *pixel=SDL_MapRGBA(fmt, (const unsigned char)255, (const unsigned char)0, (const unsigned char)0, (const unsigned char)255);

        else
          *pixel=SDL_MapRGBA(fmt, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0);
      }
    }
    first_pass = 1;
    dst.x = (signed short int)0;
    dst.y = (signed short int)0;
    dst.w = (unsigned short int)(map_image_size * (signed int)use_config[(signed long int)19]);
    dst.h = (unsigned short int)(map_image_size * (signed int)use_config[(signed long int)20]);
    SDL_UpperBlit(grid_overlay, (struct SDL_Rect *)(void *)0, mapsurface, &dst);
  }

  else
  {
    dst.x = (signed short int)(ax * map_image_size);
    dst.y = (signed short int)(ay * map_image_size);
    dst.w = (unsigned short int)map_image_size;
    dst.h = (unsigned short int)map_image_size;
    SDL_UpperBlit(grid_overlay, &dst, mapsurface, &dst);
  }
  goto __CPROVER_DUMP_L17;

__CPROVER_DUMP_L17:
  ;
}

// parse_args
// file main.c line 350
static signed int parse_args(signed int argc, char **argv)
{
  signed int on_arg = 1;
  load_defaults();
  snprintf(VERSION_INFO, (unsigned long int)256, "GTKv2 Client %s (%s)", (const void *)"1.71.0", (const void *)window_xml_file);
  on_arg = 1;
  signed int return_value_strcmp$49;
  signed int return_value_strcmp$48;
  signed int return_value_strcmp$47;
  signed int return_value_strcmp$46;
  signed int return_value_strcmp$45;
  signed int return_value_strcmp$44;
  signed int return_value_strcmp$43;
  signed int return_value_strcmp$42;
  signed int return_value_strcmp$41;
  signed int return_value_strcmp$40;
  signed int return_value_strcmp$39;
  signed int return_value_strcmp$38;
  _Bool tmp_if_expr$2;
  signed int return_value_strcmp$37;
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp$36;
  _Bool tmp_if_expr$6;
  signed int return_value_strcmp$35;
  signed int return_value_strcmp$34;
  signed int return_value_strcmp$33;
  signed int return_value_strcmp$32;
  signed int return_value_strcmp$31;
  signed int return_value_strcmp$30;
  signed int return_value_strcmp$29;
  signed int return_value_strcmp$28;
  signed int return_value_strcmp$27;
  signed int return_value_strcmp$26;
  signed int return_value_strcmp$25;
  signed int return_value_strcmp$24;
  signed int return_value_strcmp$23;
  signed int return_value_strcmp$22;
  signed int return_value_strcmp$21;
  signed int return_value_strcmp$20;
  signed int return_value_strcmp$19;
  signed int return_value_strcmp$18;
  signed int return_value_strcmp$17;
  signed int return_value_strcmp$16;
  signed int return_value_strcmp$15;
  signed int return_value_strcmp$14;
  signed int return_value_strcmp$13;
  signed int return_value_strcmp$12;
  signed int return_value_strcmp$11;
  signed int return_value_strcmp$10;
  for( ; !(on_arg >= argc); on_arg = on_arg + 1)
  {
    signed int return_value_strcmp$50;
    return_value_strcmp$50=strcmp(argv[(signed long int)on_arg], "-cache");
    if(return_value_strcmp$50 == 0)
    {
      want_config[(signed long int)5] = (signed short int)!(0 != 0);
      goto __CPROVER_DUMP_L71;
    }

    else
    {
      return_value_strcmp$49=strcmp(argv[(signed long int)on_arg], "-nocache");
      if(return_value_strcmp$49 == 0)
      {
        want_config[(signed long int)5] = (signed short int)0;
        goto __CPROVER_DUMP_L71;
      }

      else
      {
        return_value_strcmp$48=strcmp(argv[(signed long int)on_arg], "-darkness");
        if(return_value_strcmp$48 == 0)
        {
          want_config[(signed long int)22] = (signed short int)!(0 != 0);
          goto __CPROVER_DUMP_L71;
        }

        else
        {
          return_value_strcmp$47=strcmp(argv[(signed long int)on_arg], "-nodarkness");
          if(return_value_strcmp$47 == 0)
          {
            want_config[(signed long int)22] = (signed short int)0;
            goto __CPROVER_DUMP_L71;
          }

          else
          {
            return_value_strcmp$46=strcmp(argv[(signed long int)on_arg], "-display");
            if(return_value_strcmp$46 == 0)
            {
              on_arg = on_arg + 1;
              if(on_arg == argc)
              {
                LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "-display requires a display name");
                return 1;
              }

              goto __CPROVER_DUMP_L71;
            }

            else
            {
              return_value_strcmp$45=strcmp(argv[(signed long int)on_arg], "-download_all_faces");
              if(return_value_strcmp$45 == 0)
              {
                want_config[(signed long int)1] = (signed short int)!(0 != 0);
                goto __CPROVER_DUMP_L71;
              }

              else
              {
                return_value_strcmp$44=strcmp(argv[(signed long int)on_arg], "-echo");
                if(return_value_strcmp$44 == 0)
                {
                  want_config[(signed long int)2] = (signed short int)!(0 != 0);
                  goto __CPROVER_DUMP_L71;
                }

                else
                {
                  return_value_strcmp$43=strcmp(argv[(signed long int)on_arg], "-noecho");
                  if(return_value_strcmp$43 == 0)
                  {
                    want_config[(signed long int)2] = (signed short int)0;
                    goto __CPROVER_DUMP_L71;
                  }

                  else
                  {
                    return_value_strcmp$42=strcmp(argv[(signed long int)on_arg], "-faceset");
                    if(return_value_strcmp$42 == 0)
                    {
                      on_arg = on_arg + 1;
                      if(on_arg == argc)
                      {
                        LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "-faceset requires a faceset name/number");
                        return 1;
                      }

                      face_info.want_faceset = argv[(signed long int)on_arg];
                      goto __CPROVER_DUMP_L71;
                    }

                    else
                    {
                      return_value_strcmp$41=strcmp(argv[(signed long int)on_arg], "-fog");
                      if(return_value_strcmp$41 == 0)
                      {
                        want_config[(signed long int)6] = (signed short int)!(0 != 0);
                        goto __CPROVER_DUMP_L71;
                      }

                      else
                      {
                        return_value_strcmp$40=strcmp(argv[(signed long int)on_arg], "-nofog");
                        if(return_value_strcmp$40 == 0)
                        {
                          want_config[(signed long int)6] = (signed short int)0;
                          goto __CPROVER_DUMP_L71;
                        }

                        else
                        {
                          return_value_strcmp$39=strcmp(argv[(signed long int)on_arg], "-help");
                          if(return_value_strcmp$39 == 0)
                          {
                            usage(argv[(signed long int)0]);
                            goto __CPROVER_DUMP_L71;
                          }

                          else
                          {
                            return_value_strcmp$38=strcmp(argv[(signed long int)on_arg], "-iconscale");
                            if(return_value_strcmp$38 == 0)
                            {
                              on_arg = on_arg + 1;
                              if(on_arg == argc)
                              {
                                LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "-iconscale requires a percentage value");
                                return 1;
                              }

                              signed int return_value_atoi$1;
                              return_value_atoi$1=atoi(argv[(signed long int)on_arg]);
                              want_config[(signed long int)7] = (signed short int)return_value_atoi$1;
                              if(!((signed int)want_config[7l] >= 25))
                                tmp_if_expr$2 = (_Bool)1;

                              else
                                tmp_if_expr$2 = (signed int)want_config[(signed long int)7] > 200 ? (_Bool)1 : (_Bool)0;
                              if(tmp_if_expr$2)
                              {
                                LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "Valid range for -iconscale is 25 through 200");
                                want_config[(signed long int)7] = (signed short int)100;
                                return 1;
                              }

                              goto __CPROVER_DUMP_L71;
                            }

                            else
                            {
                              return_value_strcmp$37=strcmp(argv[(signed long int)on_arg], "-mapscale");
                              if(return_value_strcmp$37 == 0)
                              {
                                on_arg = on_arg + 1;
                                if(on_arg == argc)
                                {
                                  LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "-mapscale requires a percentage value");
                                  return 1;
                                }

                                signed int return_value_atoi$3;
                                return_value_atoi$3=atoi(argv[(signed long int)on_arg]);
                                want_config[(signed long int)8] = (signed short int)return_value_atoi$3;
                                if(!((signed int)want_config[8l] >= 25))
                                  tmp_if_expr$4 = (_Bool)1;

                                else
                                  tmp_if_expr$4 = (signed int)want_config[(signed long int)8] > 200 ? (_Bool)1 : (_Bool)0;
                                if(tmp_if_expr$4)
                                {
                                  LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "Valid range for -mapscale is 25 through 200");
                                  want_config[(signed long int)8] = (signed short int)100;
                                  return 1;
                                }

                                goto __CPROVER_DUMP_L71;
                              }

                              else
                              {
                                return_value_strcmp$36=strcmp(argv[(signed long int)on_arg], "-mapsize");
                                if(return_value_strcmp$36 == 0)
                                {
                                  char *cp;
                                  char x;
                                  char y = (char)0;
                                  on_arg = on_arg + 1;
                                  if(on_arg == argc)
                                  {
                                    LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "-mapsize requires a XxY value");
                                    return 1;
                                  }

                                  signed int return_value_atoi$5;
                                  return_value_atoi$5=atoi(argv[(signed long int)on_arg]);
                                  x = (char)return_value_atoi$5;
                                  cp = argv[(signed long int)on_arg];
                                  for( ; !((signed int)*cp == 0); cp = cp + 1l)
                                  {
                                    if((signed int)*cp == 120)
                                      tmp_if_expr$6 = (_Bool)1;

                                    else
                                      tmp_if_expr$6 = (signed int)*cp == 88 ? (_Bool)1 : (_Bool)0;
                                    if(tmp_if_expr$6)
                                      break;

                                  }
                                  if((signed int)*cp == 0)
                                    LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "-mapsize requires both X and Y values (ie, XxY - note the\nx in between.");

                                  else
                                  {
                                    signed int return_value_atoi$7;
                                    return_value_atoi$7=atoi(cp + (signed long int)1);
                                    y = (char)return_value_atoi$7;
                                  }
                                  if(!((signed int)x >= 9) || !((signed int)y >= 9))
                                    LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "Map size must be positive values of at least 9");

                                  else
                                    if((signed int)x >= 32 || (signed int)y >= 32)
                                      LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "Map size cannot be larger than %d x %d", 31, 31);

                                    else
                                    {
                                      want_config[(signed long int)19] = (signed short int)x;
                                      want_config[(signed long int)20] = (signed short int)y;
                                    }
                                  goto __CPROVER_DUMP_L71;
                                }

                                else
                                {
                                  return_value_strcmp$35=strcmp(argv[(signed long int)on_arg], "-fasttcpsend");
                                  if(return_value_strcmp$35 == 0)
                                  {
                                    want_config[(signed long int)3] = (signed short int)!(0 != 0);
                                    goto __CPROVER_DUMP_L71;
                                  }

                                  else
                                  {
                                    return_value_strcmp$34=strcmp(argv[(signed long int)on_arg], "-nofasttcpsend");
                                    if(return_value_strcmp$34 == 0)
                                    {
                                      want_config[(signed long int)3] = (signed short int)0;
                                      goto __CPROVER_DUMP_L71;
                                    }

                                    else
                                    {
                                      return_value_strcmp$33=strcmp(argv[(signed long int)on_arg], "-opengl");
                                      if(return_value_strcmp$33 == 0)
                                      {
                                        want_config[(signed long int)10] = (signed short int)2;
                                        goto __CPROVER_DUMP_L71;
                                      }

                                      else
                                      {
                                        return_value_strcmp$32=strcmp(argv[(signed long int)on_arg], "-pixmap");
                                        if(return_value_strcmp$32 == 0)
                                          want_config[(signed long int)10] = (signed short int)0;

                                        else
                                        {
                                          return_value_strcmp$31=strcmp(argv[(signed long int)on_arg], "-port");
                                          if(return_value_strcmp$31 == 0)
                                          {
                                            on_arg = on_arg + 1;
                                            if(on_arg == argc)
                                            {
                                              LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "-port requires a port number");
                                              return 1;
                                            }

                                            signed int return_value_atoi$8;
                                            return_value_atoi$8=atoi(argv[(signed long int)on_arg]);
                                            want_config[(signed long int)23] = (signed short int)return_value_atoi$8;
                                            goto __CPROVER_DUMP_L71;
                                          }

                                          else
                                          {
                                            return_value_strcmp$30=strcmp(argv[(signed long int)on_arg], "-sdl");
                                            if(return_value_strcmp$30 == 0)
                                            {
                                              want_config[(signed long int)10] = (signed short int)1;
                                              goto __CPROVER_DUMP_L71;
                                            }

                                            else
                                            {
                                              return_value_strcmp$29=strcmp(argv[(signed long int)on_arg], "-server");
                                              if(return_value_strcmp$29 == 0)
                                              {
                                                on_arg = on_arg + 1;
                                                if(on_arg == argc)
                                                {
                                                  LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "-server requires a host name");
                                                  return 1;
                                                }

                                                server = argv[(signed long int)on_arg];
                                                goto __CPROVER_DUMP_L71;
                                              }

                                              else
                                              {
                                                return_value_strcmp$28=strcmp(argv[(signed long int)on_arg], "-showicon");
                                                if(return_value_strcmp$28 == 0)
                                                {
                                                  want_config[(signed long int)11] = (signed short int)!(0 != 0);
                                                  goto __CPROVER_DUMP_L71;
                                                }

                                                else
                                                {
                                                  return_value_strcmp$27=strcmp(argv[(signed long int)on_arg], "-smooth");
                                                  if(return_value_strcmp$27 == 0)
                                                    want_config[(signed long int)26] = (signed short int)!(0 != 0);

                                                  else
                                                  {
                                                    return_value_strcmp$26=strcmp(argv[(signed long int)on_arg], "-nosmooth");
                                                    if(return_value_strcmp$26 == 0)
                                                      want_config[(signed long int)26] = (signed short int)0;

                                                    else
                                                    {
                                                      return_value_strcmp$25=strcmp(argv[(signed long int)on_arg], "-sound");
                                                      if(return_value_strcmp$25 == 0)
                                                      {
                                                        want_config[(signed long int)13] = (signed short int)!(0 != 0);
                                                        goto __CPROVER_DUMP_L71;
                                                      }

                                                      else
                                                      {
                                                        return_value_strcmp$24=strcmp(argv[(signed long int)on_arg], "-nosound");
                                                        if(return_value_strcmp$24 == 0)
                                                        {
                                                          want_config[(signed long int)13] = (signed short int)0;
                                                          goto __CPROVER_DUMP_L71;
                                                        }

                                                        else
                                                        {
                                                          return_value_strcmp$23=strcmp(argv[(signed long int)on_arg], "-sound_server");
                                                          if(return_value_strcmp$23 == 0)
                                                          {
                                                            on_arg = on_arg + 1;
                                                            if(on_arg == argc)
                                                            {
                                                              LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "-sound_server requires an executable pathname");
                                                              return 1;
                                                            }

                                                            sound_server = argv[(signed long int)on_arg];
                                                            goto __CPROVER_DUMP_L71;
                                                          }

                                                          else
                                                          {
                                                            return_value_strcmp$22=strcmp(argv[(signed long int)on_arg], "-split");
                                                            if(return_value_strcmp$22 == 0)
                                                            {
                                                              want_config[(signed long int)15] = (signed short int)!(0 != 0);
                                                              goto __CPROVER_DUMP_L71;
                                                            }

                                                            else
                                                            {
                                                              return_value_strcmp$21=strcmp(argv[(signed long int)on_arg], "-nosplit");
                                                              if(return_value_strcmp$21 == 0)
                                                              {
                                                                want_config[(signed long int)15] = (signed short int)0;
                                                                goto __CPROVER_DUMP_L71;
                                                              }

                                                              else
                                                              {
                                                                return_value_strcmp$20=strcmp(argv[(signed long int)on_arg], "-resists");
                                                                if(return_value_strcmp$20 == 0)
                                                                {
                                                                  on_arg = on_arg + 1;
                                                                  if(on_arg == argc)
                                                                  {
                                                                    LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "-resists requires a value");
                                                                    return 1;
                                                                  }

                                                                  signed int return_value_atoi$9;
                                                                  return_value_atoi$9=atoi(argv[(signed long int)on_arg]);
                                                                  want_config[(signed long int)25] = (signed short int)return_value_atoi$9;
                                                                  goto __CPROVER_DUMP_L71;
                                                                }

                                                                else
                                                                {
                                                                  return_value_strcmp$19=strcmp(argv[(signed long int)on_arg], "-loglevel");
                                                                  if(return_value_strcmp$19 == 0)
                                                                  {
                                                                    on_arg = on_arg + 1;
                                                                    if(on_arg == argc)
                                                                    {
                                                                      LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "-loglevel requires a value");
                                                                      return 1;
                                                                    }

                                                                    MINLOG=atoi(argv[(signed long int)on_arg]);
                                                                    goto __CPROVER_DUMP_L71;
                                                                  }

                                                                  else
                                                                  {
                                                                    return_value_strcmp$18=strcmp(argv[(signed long int)on_arg], "-splitinfo");
                                                                    if(return_value_strcmp$18 == 0)
                                                                    {
                                                                      want_config[(signed long int)14] = (signed short int)!(0 != 0);
                                                                      goto __CPROVER_DUMP_L71;
                                                                    }

                                                                    else
                                                                    {
                                                                      return_value_strcmp$17=strcmp(argv[(signed long int)on_arg], "-timemapredraw");
                                                                      if(return_value_strcmp$17 == 0)
                                                                      {
                                                                        time_map_redraw = (signed int)!(0 != 0);
                                                                        goto __CPROVER_DUMP_L71;
                                                                      }

                                                                      else
                                                                      {
                                                                        return_value_strcmp$16=strcmp(argv[(signed long int)on_arg], "-triminfowindow");
                                                                        if(return_value_strcmp$16 == 0)
                                                                        {
                                                                          want_config[(signed long int)18] = (signed short int)!(0 != 0);
                                                                          goto __CPROVER_DUMP_L71;
                                                                        }

                                                                        else
                                                                        {
                                                                          return_value_strcmp$15=strcmp(argv[(signed long int)on_arg], "-notriminfowindow");
                                                                          if(return_value_strcmp$15 == 0)
                                                                          {
                                                                            want_config[(signed long int)18] = (signed short int)0;
                                                                            goto __CPROVER_DUMP_L71;
                                                                          }

                                                                          else
                                                                          {
                                                                            return_value_strcmp$14=strcmp(argv[(signed long int)on_arg], "-updatekeycodes");
                                                                            if(return_value_strcmp$14 == 0)
                                                                            {
                                                                              updatekeycodes = (unsigned char)!(0 != 0);
                                                                              goto __CPROVER_DUMP_L71;
                                                                            }

                                                                            else
                                                                            {
                                                                              return_value_strcmp$13=strcmp(argv[(signed long int)on_arg], "-splash");
                                                                              if(return_value_strcmp$13 == 0)
                                                                              {
                                                                                want_config[(signed long int)27] = (signed short int)!(0 != 0);
                                                                                goto __CPROVER_DUMP_L71;
                                                                              }

                                                                              else
                                                                              {
                                                                                return_value_strcmp$12=strcmp(argv[(signed long int)on_arg], "-nosplash");
                                                                                if(return_value_strcmp$12 == 0)
                                                                                {
                                                                                  want_config[(signed long int)27] = (signed short int)0;
                                                                                  goto __CPROVER_DUMP_L71;
                                                                                }

                                                                                else
                                                                                {
                                                                                  return_value_strcmp$11=strcmp(argv[(signed long int)on_arg], "-window_xml");
                                                                                  if(return_value_strcmp$11 == 0)
                                                                                  {
                                                                                    on_arg = on_arg + 1;
                                                                                    if(on_arg == argc)
                                                                                    {
                                                                                      LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "-window_xml requires a xml file name");
                                                                                      return 1;
                                                                                    }

                                                                                    strncpy(window_xml_path, argv[(signed long int)on_arg], (unsigned long int)(256 - 1));
                                                                                    goto __CPROVER_DUMP_L71;
                                                                                  }

                                                                                  else
                                                                                  {
                                                                                    return_value_strcmp$10=strcmp(argv[(signed long int)on_arg], "-dialog_xml");
                                                                                    if(return_value_strcmp$10 == 0)
                                                                                    {
                                                                                      on_arg = on_arg + 1;
                                                                                      if(on_arg == argc)
                                                                                      {
                                                                                        LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "-dialog_xml requires a xml file name");
                                                                                        return 1;
                                                                                      }

                                                                                      strncpy(dialog_xml_path, argv[(signed long int)on_arg], (unsigned long int)(256 - 1));
                                                                                      goto __CPROVER_DUMP_L71;
                                                                                    }

                                                                                    else
                                                                                    {
                                                                                      LOG((enum LogLevel)LOG_WARNING, "main.c::init_windows", "Do not understand option %s", argv[(signed long int)on_arg]);
                                                                                      usage(argv[(signed long int)0]);
                                                                                      return 1;
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

  __CPROVER_DUMP_L71:
    ;
  }
  LOG((enum LogLevel)LOG_INFO, "Client Version", VERSION_INFO);
  on_arg = 0;
  for( ; !(on_arg >= 32); on_arg = on_arg + 1)
    use_config[(signed long int)on_arg] = want_config[(signed long int)on_arg];
  image_size = (32 * (signed int)use_config[(signed long int)7]) / 100;
  map_image_size = (32 * (signed int)use_config[(signed long int)8]) / 100;
  map_image_half_size = (32 * (signed int)use_config[(signed long int)8]) / 200;
  if(use_config[5l] == 0)
    use_config[(signed long int)1] = (signed short int)0;

  mapdata_init();
  return 0;
}

// parse_key
// file keys.c line 826
static void parse_key(char key, unsigned int keysym)
{
  struct keybind *kb;
  signed int present_flags = 0;
  char buf[256l];
  char tmpbuf[256l];
  keysym=gdk_keyval_to_lower(keysym);
  if(keysym == commandkeysym)
  {
    unsigned long int return_value_gtk_widget_get_type$1;
    return_value_gtk_widget_get_type$1=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_widget_get_type$1);
    gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$2);
    unsigned long int return_value_gtk_entry_get_type$3;
    return_value_gtk_entry_get_type$3=gtk_entry_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_entry_get_type$3);
    gtk_entry_set_visibility((struct _GtkEntry *)return_value_g_type_check_instance_cast$4, 1);
    cpl.input_state = (enum Input_State)Command_Mode;
    cpl.no_echo = (unsigned int)0;
    goto __CPROVER_DUMP_L36;
  }

  _Bool tmp_if_expr$5;
  if(keysym == altkeysym[0l])
    tmp_if_expr$5 = (_Bool)1;

  else
    tmp_if_expr$5 = keysym == altkeysym[(signed long int)1] ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$12;
  char *tmp_if_expr$27;
  char *return_value_gdk_keyval_name$26;
  if(tmp_if_expr$5)
    cpl.alt_on = (unsigned int)1;

  else
  {
    if(keysym == metakeysym[0l])
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = keysym == metakeysym[(signed long int)1] ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
      cpl.meta_on = (unsigned int)1;

    else
    {
      if(keysym == firekeysym[0l])
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = keysym == firekeysym[(signed long int)1] ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$9)
      {
        cpl.fire_on = (unsigned int)1;
        unsigned long int return_value_gtk_label_get_type$7;
        return_value_gtk_label_get_type$7=gtk_label_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
        return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)fire_label, return_value_gtk_label_get_type$7);
        gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$8, "Fire");
        goto __CPROVER_DUMP_L36;
      }

      if(keysym == runkeysym[0l])
        tmp_if_expr$12 = (_Bool)1;

      else
        tmp_if_expr$12 = keysym == runkeysym[(signed long int)1] ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$12)
      {
        cpl.run_on = (unsigned int)1;
        unsigned long int return_value_gtk_label_get_type$10;
        return_value_gtk_label_get_type$10=gtk_label_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
        return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)run_label, return_value_gtk_label_get_type$10);
        gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$11, "Run");
        goto __CPROVER_DUMP_L36;
      }

      present_flags = 0;
      if(!(cpl.run_on == 0u))
        present_flags = present_flags | 1 << 1;

      if(!(cpl.fire_on == 0u))
        present_flags = present_flags | 1 << 0;

      if(!(cpl.alt_on == 0u))
        present_flags = present_flags | 1 << 2;

      if(!(cpl.meta_on == 0u))
        present_flags = present_flags | 1 << 3;

      kb=keybind_find(keysym, (unsigned int)present_flags, 0);
      if(kb == ((struct keybind *)NULL))
        kb=keybind_find(keysym, (unsigned int)present_flags, 1);

      if(!(kb == ((struct keybind *)NULL)))
      {
        if(!((32 & (signed int)kb->flags) == 0))
        {
          strcpy(cpl.input_text, kb->command);
          cpl.input_state = (enum Input_State)Command_Mode;
          unsigned long int return_value_gtk_entry_get_type$13;
          return_value_gtk_entry_get_type$13=gtk_entry_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
          return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_entry_get_type$13);
          gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$14, cpl.input_text);
          unsigned long int return_value_gtk_widget_get_type$15;
          return_value_gtk_widget_get_type$15=gtk_widget_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
          return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_widget_get_type$15);
          gtk_widget_grab_focus((struct _GtkWidget *)return_value_g_type_check_instance_cast$16);
          unsigned long int return_value_gtk_editable_get_type$17;
          return_value_gtk_editable_get_type$17=gtk_editable_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
          return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_editable_get_type$17);
          gtk_editable_select_region((struct _GtkEditable *)return_value_g_type_check_instance_cast$18, 0, 0);
          unsigned long int return_value_gtk_editable_get_type$19;
          return_value_gtk_editable_get_type$19=gtk_editable_get_type();
          struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
          return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_editable_get_type$19);
          gtk_editable_set_position((struct _GtkEditable *)return_value_g_type_check_instance_cast$20, -1);
          goto __CPROVER_DUMP_L36;
        }

        unsigned long int return_value_gtk_spin_button_get_type$21;
        return_value_gtk_spin_button_get_type$21=gtk_spin_button_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
        return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)spinbutton_count, return_value_gtk_spin_button_get_type$21);
        signed int return_value_gtk_spin_button_get_value_as_int$23;
        return_value_gtk_spin_button_get_value_as_int$23=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$22);
        cpl.count = (unsigned int)return_value_gtk_spin_button_get_value_as_int$23;
        if((signed int)kb->direction >= 0)
        {
          if(!(cpl.fire_on == 0u))
          {
            snprintf(buf, sizeof(char [256l]) /*256ul*/ , "fire %s", kb->command);
            fire_dir((signed int)kb->direction);
          }

          else
            if(!(cpl.run_on == 0u))
            {
              snprintf(buf, sizeof(char [256l]) /*256ul*/ , "run %s", kb->command);
              run_dir((signed int)kb->direction);
            }

            else
              extended_command(kb->command);
          if(!(use_config[2l] == 0))
            draw_ext_info(0, 20, 6, kb->command);

        }

        else
        {
          if(!(use_config[2l] == 0))
            draw_ext_info(0, 20, 6, kb->command);

          extended_command(kb->command);
        }
        goto __CPROVER_DUMP_L36;
      }

      if((signed int)key >= 48 && !((signed int)key >= 58))
      {
        cpl.count = cpl.count * (unsigned int)10 + (unsigned int)((signed int)key - 48);
        if(cpl.count >= 100001u)
          cpl.count = cpl.count % (unsigned int)100000;

        unsigned long int return_value_gtk_spin_button_get_type$24;
        return_value_gtk_spin_button_get_type$24=gtk_spin_button_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$25;
        return_value_g_type_check_instance_cast$25=g_type_check_instance_cast((struct _GTypeInstance *)spinbutton_count, return_value_gtk_spin_button_get_type$24);
        gtk_spin_button_set_value((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$25, (double)(float)cpl.count);
        goto __CPROVER_DUMP_L36;
      }

      tmpbuf[(signed long int)0] = (char)0;
      if(!(cpl.fire_on == 0u))
        strcat(tmpbuf, "fire+");

      if(!(cpl.run_on == 0u))
        strcat(tmpbuf, "run+");

      if(!(cpl.alt_on == 0u))
        strcat(tmpbuf, "alt+");

      if(!(cpl.meta_on == 0u))
        strcat(tmpbuf, "meta+");

      if((signed long int)keysym == 0L)
        tmp_if_expr$27 = "unknown";

      else
      {
        return_value_gdk_keyval_name$26=gdk_keyval_name(keysym);
        tmp_if_expr$27 = return_value_gdk_keyval_name$26;
      }
      snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Key %s%s is not bound to any command. Use 'bind' to associate this keypress with a command", (const void *)tmpbuf, tmp_if_expr$27);
      draw_ext_info(0, 20, 6, buf);
      cpl.count = (unsigned int)0;
    }
  }

__CPROVER_DUMP_L36:
  ;
}

// parse_key_release
// file keys.c line 787
static void parse_key_release(unsigned int keysym)
{
  _Bool tmp_if_expr$8;
  if(keysym == firekeysym[0l])
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = keysym == firekeysym[(signed long int)1] ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$8)
  {
    cpl.fire_on = (unsigned int)0;
    clear_fire();
    unsigned long int return_value_gtk_label_get_type$1;
    return_value_gtk_label_get_type$1=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)fire_label, return_value_gtk_label_get_type$1);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$2, "    ");
  }

  else
  {
    if(keysym == runkeysym[0l])
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = keysym == runkeysym[(signed long int)1] ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
    {
      cpl.run_on = (unsigned int)0;
      if(!(use_config[2l] == 0))
        draw_ext_info(0, 20, 6, "stop run");

      clear_run();
      unsigned long int return_value_gtk_label_get_type$3;
      return_value_gtk_label_get_type$3=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)run_label, return_value_gtk_label_get_type$3);
      gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, "   ");
    }

    else
    {
      if(keysym == altkeysym[0l])
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = keysym == altkeysym[(signed long int)1] ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$6)
        cpl.alt_on = (unsigned int)0;

      else
      {
        if(keysym == metakeysym[0l])
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = keysym == metakeysym[(signed long int)1] ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
          cpl.meta_on = (unsigned int)0;

        else
          if(!(cpl.fire_on == 0u))
            clear_fire();

      }
    }
  }
}

// parse_keybind_line
// file keys.c line 316
static void parse_keybind_line(char *buf, signed int line, unsigned int scope_flag)
{
  char *cp;
  char *cpnext;
  unsigned int keysym;
  unsigned int low_keysym;
  signed int flags;
  cp = (char *)(void *)0;
  _Bool tmp_if_expr$1;
  if((signed int)*buf == 35)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)buf[(signed long int)0] == 10 ? (_Bool)1 : (_Bool)0;
  char *tmp_post$2;
  char *tmp_post$3;
  char *tmp_post$16;
  char *tmp_post$17;
  char *tmp_post$18;
  if(!tmp_if_expr$1)
  {
    cpnext=strchr(buf, 32);
    if(cpnext == ((char *)NULL))
      LOG((enum LogLevel)LOG_WARNING, "gtk-v2::parse_keybind_line", "Line %d (%s) corrupted in keybinding file.", line, buf);

    else
      if((signed int)*buf == 33)
      {
        char *cp1;
        for( ; (signed int)*cpnext == 32; cpnext = cpnext + 1l)
          ;
        cp=strchr(cpnext, 32);
        if(cp == ((char *)NULL))
        {
          LOG((enum LogLevel)LOG_WARNING, "gtk-v2::parse_keybind_line", "Line %d (%s) corrupted in keybinding file.", line, buf);
          goto __CPROVER_DUMP_L40;
        }

        tmp_post$2 = cp;
        cp = cp + 1l;
        *tmp_post$2 = (char)0;
        cp1=strchr(cp, 32);
        if(cp1 == ((char *)NULL))
        {
          LOG((enum LogLevel)LOG_WARNING, "gtk-v2::parse_keybind_line", "Line %d (%s) corrupted in keybinding file.", line, buf);
          goto __CPROVER_DUMP_L40;
        }

        tmp_post$3 = cp1;
        cp1 = cp1 + 1l;
        *tmp_post$3 = (char)0;
        keysym=gdk_keyval_from_name(cp);
        if(keysym == 0u)
        {
          LOG((enum LogLevel)LOG_WARNING, "gtk-v2::parse_keybind_line", "Could not convert %s into keysym", cp);
          goto __CPROVER_DUMP_L40;
        }

        signed int return_value_strcmp$4;
        return_value_strcmp$4=strcmp(cpnext, "commandkey");
        if(return_value_strcmp$4 == 0)
        {
          commandkeysym = keysym;
          goto __CPROVER_DUMP_L40;
        }

        signed int return_value_strcmp$5;
        return_value_strcmp$5=strcmp(cpnext, "altkey0");
        if(return_value_strcmp$5 == 0)
        {
          altkeysym[(signed long int)0] = keysym;
          goto __CPROVER_DUMP_L40;
        }

        signed int return_value_strcmp$6;
        return_value_strcmp$6=strcmp(cpnext, "altkey1");
        if(return_value_strcmp$6 == 0)
        {
          altkeysym[(signed long int)1] = keysym;
          goto __CPROVER_DUMP_L40;
        }

        signed int return_value_strcmp$7;
        return_value_strcmp$7=strcmp(cpnext, "firekey0");
        if(return_value_strcmp$7 == 0)
        {
          firekeysym[(signed long int)0] = keysym;
          goto __CPROVER_DUMP_L40;
        }

        signed int return_value_strcmp$8;
        return_value_strcmp$8=strcmp(cpnext, "firekey1");
        if(return_value_strcmp$8 == 0)
        {
          firekeysym[(signed long int)1] = keysym;
          goto __CPROVER_DUMP_L40;
        }

        signed int return_value_strcmp$9;
        return_value_strcmp$9=strcmp(cpnext, "metakey0");
        if(return_value_strcmp$9 == 0)
        {
          metakeysym[(signed long int)0] = keysym;
          goto __CPROVER_DUMP_L40;
        }

        signed int return_value_strcmp$10;
        return_value_strcmp$10=strcmp(cpnext, "metakey1");
        if(return_value_strcmp$10 == 0)
        {
          metakeysym[(signed long int)1] = keysym;
          goto __CPROVER_DUMP_L40;
        }

        signed int return_value_strcmp$11;
        return_value_strcmp$11=strcmp(cpnext, "runkey0");
        if(return_value_strcmp$11 == 0)
        {
          runkeysym[(signed long int)0] = keysym;
          goto __CPROVER_DUMP_L40;
        }

        signed int return_value_strcmp$12;
        return_value_strcmp$12=strcmp(cpnext, "runkey1");
        if(return_value_strcmp$12 == 0)
        {
          runkeysym[(signed long int)1] = keysym;
          goto __CPROVER_DUMP_L40;
        }

        signed int return_value_strcmp$13;
        return_value_strcmp$13=strcmp(cpnext, "completekey");
        if(return_value_strcmp$13 == 0)
        {
          completekeysym = keysym;
          goto __CPROVER_DUMP_L40;
        }

        signed int return_value_strcmp$14;
        return_value_strcmp$14=strcmp(cpnext, "nextkey");
        if(return_value_strcmp$14 == 0)
        {
          nextkeysym = keysym;
          goto __CPROVER_DUMP_L40;
        }

        signed int return_value_strcmp$15;
        return_value_strcmp$15=strcmp(cpnext, "prevkey");
        if(return_value_strcmp$15 == 0)
        {
          prevkeysym = keysym;
          goto __CPROVER_DUMP_L40;
        }

      }

      else
      {
        tmp_post$16 = cpnext;
        cpnext = cpnext + 1l;
        *tmp_post$16 = (char)0;
        keysym=gdk_keyval_from_name(buf);
        if(keysym == 0u)
        {
          LOG((enum LogLevel)LOG_WARNING, "gtk-v2::parse_keybind_line", "Unable to convert line %d (%s) into keysym", line, cp);
          goto __CPROVER_DUMP_L40;
        }

        cp = cpnext;
        cpnext=strchr(cp, 32);
        if(cpnext == ((char *)NULL))
        {
          LOG((enum LogLevel)LOG_WARNING, "gtk-v2::parse_keybind_line", "Line %d (%s) corrupted in keybinding file.", line, cp);
          goto __CPROVER_DUMP_L40;
        }

        tmp_post$17 = cpnext;
        cpnext = cpnext + 1l;
        *tmp_post$17 = (char)0;
        cp = cpnext;
        cpnext=strchr(cp, 32);
        if(cpnext == ((char *)NULL))
        {
          LOG((enum LogLevel)LOG_WARNING, "gtk-v2::parse_keybind_line", "Line %d (%s) corrupted in keybinding file.", line, cp);
          goto __CPROVER_DUMP_L40;
        }

        tmp_post$18 = cpnext;
        cpnext = cpnext + 1l;
        *tmp_post$18 = (char)0;
        flags = 0;
        low_keysym=gdk_keyval_to_lower(keysym);
        if(!(low_keysym == keysym))
        {
          flags = flags | 1 << 0;
          keysym = low_keysym;
        }

        for( ; !((signed int)*cp == 0); cp = cp + 1l)
          switch((signed int)*cp)
          {
            case 65:
            {
              flags = flags | 1 << 4;
              break;
            }
            case 69:
            {
              flags = flags | 1 << 5;
              break;
            }
            case 70:
            {
              flags = flags | 1 << 0;
              break;
            }
            case 76:
            {
              flags = flags | 1 << 2;
              break;
            }
            case 77:
            {
              flags = flags | 1 << 3;
              break;
            }
            case 78:
              break;
            case 82:
            {
              flags = flags | 1 << 1;
              break;
            }
            case 83:
            {
              LOG((enum LogLevel)LOG_WARNING, "gtk-v2::parse_keybind_line", "Deprecated flag (S) ignored at line %d in key binding file", line);
              break;
            }
            default:
              LOG((enum LogLevel)LOG_WARNING, "gtk-v2::parse_keybind_line", "Unknown flag (%c) line %d in key binding file", *cp, line);
          }
        unsigned long int return_value_strlen$19;
        return_value_strlen$19=strlen(cpnext);
        cpnext[(signed long int)(return_value_strlen$19 - (unsigned long int)1)] = (char)0;
        unsigned long int return_value_strlen$20;
        return_value_strlen$20=strlen(cpnext);
        if(return_value_strlen$20 >= 256ul)
        {
          cpnext[(signed long int)(sizeof(char [256l]) /*256ul*/  - (unsigned long int)1)] = (char)0;
          LOG((enum LogLevel)LOG_WARNING, "gtk-v2::parse_keybind_line", "Command too long! Truncated.");
        }

        flags = flags | (signed int)scope_flag;
        keybind_insert(keysym, (unsigned int)flags, cpnext);
      }
  }


__CPROVER_DUMP_L40:
  ;
}

// parse_keys_file
// file keys.c line 517
static signed int parse_keys_file(char *filename, unsigned int scope_flag)
{
  struct _IO_FILE *fp;
  char buf[1024l];
  signed int line = 0;
  fp=fopen(filename, "r");
  char *return_value_fgets$1;
  if(fp == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    LOG((enum LogLevel)LOG_DEBUG, "init_keys", "Reading %s keybindings from '%s'", scope_flag == (unsigned int)(1 << 6) ? "global" : "character", filename);
    do
    {
      return_value_fgets$1=fgets(buf, 1024, fp);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      line = line + 1;
      buf[(signed long int)(1024 - 1)] = (char)0;
      parse_keybind_line(buf, line, scope_flag);
    }
    while((_Bool)1);
    fclose(fp);
    return 0;
  }
}

// pickup_init
// file gtk2proto.h line 228
extern void pickup_init(struct _GtkWidget *window_root)
{
  static signed int pickup_init$$1$$has_init = 0;
  if(pickup_init$$1$$has_init == 0)
  {
    pickup_init$$1$$has_init = 1;
    struct _GObject *return_value_gtk_builder_get_object$1;
    return_value_gtk_builder_get_object$1=gtk_builder_get_object(window_xml, "do_not_pickup");
    unsigned long int return_value_gtk_widget_get_type$2;
    return_value_gtk_widget_get_type$2=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x20000000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$4;
    return_value_gtk_builder_get_object$4=gtk_builder_get_object(window_xml, "stop_before_pickup");
    unsigned long int return_value_gtk_widget_get_type$5;
    return_value_gtk_widget_get_type$5=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$4, return_value_gtk_widget_get_type$5);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$6;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x40000000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$7;
    return_value_gtk_builder_get_object$7=gtk_builder_get_object(window_xml, "body_armor");
    unsigned long int return_value_gtk_widget_get_type$8;
    return_value_gtk_widget_get_type$8=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$7, return_value_gtk_widget_get_type$8);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$9;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00000800;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$10;
    return_value_gtk_builder_get_object$10=gtk_builder_get_object(window_xml, "boots");
    unsigned long int return_value_gtk_widget_get_type$11;
    return_value_gtk_widget_get_type$11=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$10, return_value_gtk_widget_get_type$11);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$12;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00001000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$13;
    return_value_gtk_builder_get_object$13=gtk_builder_get_object(window_xml, "cloaks");
    unsigned long int return_value_gtk_widget_get_type$14;
    return_value_gtk_widget_get_type$14=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$13, return_value_gtk_widget_get_type$14);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$15;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00004000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$16;
    return_value_gtk_builder_get_object$16=gtk_builder_get_object(window_xml, "gloves");
    unsigned long int return_value_gtk_widget_get_type$17;
    return_value_gtk_widget_get_type$17=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$16, return_value_gtk_widget_get_type$17);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$18;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00002000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$19;
    return_value_gtk_builder_get_object$19=gtk_builder_get_object(window_xml, "helmets");
    unsigned long int return_value_gtk_widget_get_type$20;
    return_value_gtk_widget_get_type$20=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
    return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$19, return_value_gtk_widget_get_type$20);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$21;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00000200;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$22;
    return_value_gtk_builder_get_object$22=gtk_builder_get_object(window_xml, "shields");
    unsigned long int return_value_gtk_widget_get_type$23;
    return_value_gtk_widget_get_type$23=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
    return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$22, return_value_gtk_widget_get_type$23);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$24;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00000400;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$25;
    return_value_gtk_builder_get_object$25=gtk_builder_get_object(window_xml, "skillscrolls");
    unsigned long int return_value_gtk_widget_get_type$26;
    return_value_gtk_widget_get_type$26=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
    return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$25, return_value_gtk_widget_get_type$26);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$27;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00200000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$28;
    return_value_gtk_builder_get_object$28=gtk_builder_get_object(window_xml, "normal_book_scrolls");
    unsigned long int return_value_gtk_widget_get_type$29;
    return_value_gtk_widget_get_type$29=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
    return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$28, return_value_gtk_widget_get_type$29);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$30;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00400000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$31;
    return_value_gtk_builder_get_object$31=gtk_builder_get_object(window_xml, "spellbooks");
    unsigned long int return_value_gtk_widget_get_type$32;
    return_value_gtk_widget_get_type$32=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
    return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$31, return_value_gtk_widget_get_type$32);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$33;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00100000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$34;
    return_value_gtk_builder_get_object$34=gtk_builder_get_object(window_xml, "drinks");
    unsigned long int return_value_gtk_widget_get_type$35;
    return_value_gtk_widget_get_type$35=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
    return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$34, return_value_gtk_widget_get_type$35);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$36;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00000020;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$37;
    return_value_gtk_builder_get_object$37=gtk_builder_get_object(window_xml, "food");
    unsigned long int return_value_gtk_widget_get_type$38;
    return_value_gtk_widget_get_type$38=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$39;
    return_value_g_type_check_instance_cast$39=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$37, return_value_gtk_widget_get_type$38);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$39;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00000010;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$40;
    return_value_gtk_builder_get_object$40=gtk_builder_get_object(window_xml, "flesh");
    unsigned long int return_value_gtk_widget_get_type$41;
    return_value_gtk_widget_get_type$41=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$42;
    return_value_g_type_check_instance_cast$42=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$40, return_value_gtk_widget_get_type$41);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$42;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x04000000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$43;
    return_value_gtk_builder_get_object$43=gtk_builder_get_object(window_xml, "keys");
    unsigned long int return_value_gtk_widget_get_type$44;
    return_value_gtk_widget_get_type$44=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$45;
    return_value_g_type_check_instance_cast$45=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$43, return_value_gtk_widget_get_type$44);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$45;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00008000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$46;
    return_value_gtk_builder_get_object$46=gtk_builder_get_object(window_xml, "magical_items");
    unsigned long int return_value_gtk_widget_get_type$47;
    return_value_gtk_widget_get_type$47=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$48;
    return_value_g_type_check_instance_cast$48=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$46, return_value_gtk_widget_get_type$47);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$48;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00040000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$49;
    return_value_gtk_builder_get_object$49=gtk_builder_get_object(window_xml, "potions");
    unsigned long int return_value_gtk_widget_get_type$50;
    return_value_gtk_widget_get_type$50=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$51;
    return_value_g_type_check_instance_cast$51=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$49, return_value_gtk_widget_get_type$50);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$51;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00080000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$52;
    return_value_gtk_builder_get_object$52=gtk_builder_get_object(window_xml, "valuables");
    unsigned long int return_value_gtk_widget_get_type$53;
    return_value_gtk_widget_get_type$53=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$54;
    return_value_g_type_check_instance_cast$54=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$52, return_value_gtk_widget_get_type$53);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$54;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00000040;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$55;
    return_value_gtk_builder_get_object$55=gtk_builder_get_object(window_xml, "wands_rods_horns");
    unsigned long int return_value_gtk_widget_get_type$56;
    return_value_gtk_widget_get_type$56=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$57;
    return_value_g_type_check_instance_cast$57=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$55, return_value_gtk_widget_get_type$56);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$57;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00800000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$58;
    return_value_gtk_builder_get_object$58=gtk_builder_get_object(window_xml, "jewels");
    unsigned long int return_value_gtk_widget_get_type$59;
    return_value_gtk_widget_get_type$59=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$60;
    return_value_g_type_check_instance_cast$60=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$58, return_value_gtk_widget_get_type$59);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$60;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x02000000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$61;
    return_value_gtk_builder_get_object$61=gtk_builder_get_object(window_xml, "containers");
    unsigned long int return_value_gtk_widget_get_type$62;
    return_value_gtk_widget_get_type$62=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$63;
    return_value_g_type_check_instance_cast$63=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$61, return_value_gtk_widget_get_type$62);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$63;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x08000000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$64;
    return_value_gtk_builder_get_object$64=gtk_builder_get_object(window_xml, "all_weapons");
    unsigned long int return_value_gtk_widget_get_type$65;
    return_value_gtk_widget_get_type$65=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$66;
    return_value_g_type_check_instance_cast$66=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$64, return_value_gtk_widget_get_type$65);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$66;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00020000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$67;
    return_value_gtk_builder_get_object$67=gtk_builder_get_object(window_xml, "missile_weapons");
    unsigned long int return_value_gtk_widget_get_type$68;
    return_value_gtk_widget_get_type$68=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$69;
    return_value_g_type_check_instance_cast$69=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$67, return_value_gtk_widget_get_type$68);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$69;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00010000;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$70;
    return_value_gtk_builder_get_object$70=gtk_builder_get_object(window_xml, "bows");
    unsigned long int return_value_gtk_widget_get_type$71;
    return_value_gtk_widget_get_type$71=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$72;
    return_value_g_type_check_instance_cast$72=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$70, return_value_gtk_widget_get_type$71);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$72;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00000080;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$73;
    return_value_gtk_builder_get_object$73=gtk_builder_get_object(window_xml, "arrows");
    unsigned long int return_value_gtk_widget_get_type$74;
    return_value_gtk_widget_get_type$74=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$75;
    return_value_g_type_check_instance_cast$75=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$73, return_value_gtk_widget_get_type$74);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$75;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x00000100;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$76;
    return_value_gtk_builder_get_object$76=gtk_builder_get_object(window_xml, "ratio_pickup_off");
    unsigned long int return_value_gtk_widget_get_type$77;
    return_value_gtk_widget_get_type$77=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$78;
    return_value_g_type_check_instance_cast$78=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$76, return_value_gtk_widget_get_type$77);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$78;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)~0x0000000F;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$79;
    return_value_gtk_builder_get_object$79=gtk_builder_get_object(window_xml, "ratio_5");
    unsigned long int return_value_gtk_widget_get_type$80;
    return_value_gtk_widget_get_type$80=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$81;
    return_value_g_type_check_instance_cast$81=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$79, return_value_gtk_widget_get_type$80);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$81;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)1;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$82;
    return_value_gtk_builder_get_object$82=gtk_builder_get_object(window_xml, "ratio_10");
    unsigned long int return_value_gtk_widget_get_type$83;
    return_value_gtk_widget_get_type$83=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$84;
    return_value_g_type_check_instance_cast$84=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$82, return_value_gtk_widget_get_type$83);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$84;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)2;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$85;
    return_value_gtk_builder_get_object$85=gtk_builder_get_object(window_xml, "ratio_15");
    unsigned long int return_value_gtk_widget_get_type$86;
    return_value_gtk_widget_get_type$86=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$87;
    return_value_g_type_check_instance_cast$87=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$85, return_value_gtk_widget_get_type$86);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$87;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)3;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$88;
    return_value_gtk_builder_get_object$88=gtk_builder_get_object(window_xml, "ratio_20");
    unsigned long int return_value_gtk_widget_get_type$89;
    return_value_gtk_widget_get_type$89=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$90;
    return_value_g_type_check_instance_cast$90=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$88, return_value_gtk_widget_get_type$89);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$90;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)4;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$91;
    return_value_gtk_builder_get_object$91=gtk_builder_get_object(window_xml, "ratio_25");
    unsigned long int return_value_gtk_widget_get_type$92;
    return_value_gtk_widget_get_type$92=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$93;
    return_value_g_type_check_instance_cast$93=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$91, return_value_gtk_widget_get_type$92);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$93;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)5;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$94;
    return_value_gtk_builder_get_object$94=gtk_builder_get_object(window_xml, "ratio_30");
    unsigned long int return_value_gtk_widget_get_type$95;
    return_value_gtk_widget_get_type$95=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$96;
    return_value_g_type_check_instance_cast$96=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$94, return_value_gtk_widget_get_type$95);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$96;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)6;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$97;
    return_value_gtk_builder_get_object$97=gtk_builder_get_object(window_xml, "ratio_35");
    unsigned long int return_value_gtk_widget_get_type$98;
    return_value_gtk_widget_get_type$98=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$99;
    return_value_g_type_check_instance_cast$99=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$97, return_value_gtk_widget_get_type$98);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$99;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)7;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$100;
    return_value_gtk_builder_get_object$100=gtk_builder_get_object(window_xml, "ratio_40");
    unsigned long int return_value_gtk_widget_get_type$101;
    return_value_gtk_widget_get_type$101=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$102;
    return_value_g_type_check_instance_cast$102=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$100, return_value_gtk_widget_get_type$101);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$102;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)8;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$103;
    return_value_gtk_builder_get_object$103=gtk_builder_get_object(window_xml, "ratio_45");
    unsigned long int return_value_gtk_widget_get_type$104;
    return_value_gtk_widget_get_type$104=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$105;
    return_value_g_type_check_instance_cast$105=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$103, return_value_gtk_widget_get_type$104);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$105;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)9;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$106;
    return_value_gtk_builder_get_object$106=gtk_builder_get_object(window_xml, "ratio_50");
    unsigned long int return_value_gtk_widget_get_type$107;
    return_value_gtk_widget_get_type$107=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$108;
    return_value_g_type_check_instance_cast$108=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$106, return_value_gtk_widget_get_type$107);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$108;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)10;
    num_pickups = num_pickups + 1;
    struct _GObject *return_value_gtk_builder_get_object$109;
    return_value_gtk_builder_get_object$109=gtk_builder_get_object(window_xml, "not_cursed");
    unsigned long int return_value_gtk_widget_get_type$110;
    return_value_gtk_widget_get_type$110=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$111;
    return_value_g_type_check_instance_cast$111=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$109, return_value_gtk_widget_get_type$110);
    pickup_mapping[(signed long int)num_pickups].menuitem = (struct _GtkWidget *)return_value_g_type_check_instance_cast$111;
    pickup_mapping[(signed long int)num_pickups].pickup_mode = (unsigned int)0x01000000;
    num_pickups = num_pickups + 1;
    if(num_pickups >= 50)
    {
      LOG((enum LogLevel)LOG_ERROR, "pickup.c::pickup_init", "num_pickups (%d) >= MAX_PICKUPS (%d)\n", num_pickups, 50);
      exit(1);
    }

  }

}

// play_character
// file account.c line 466
static void play_character(const char *name)
{
  struct SockList sl;
  unsigned char buf[256l];
  SockList_Init(&sl, buf);
  SockList_AddString(&sl, "accountplay ");
  SockList_AddString(&sl, name);
  SockList_Send(&sl, csocket.fd);
}

// play_sound_effect
// file sound.c line 117
void play_sound_effect(signed char x, signed char y, unsigned char dir, unsigned char vol, unsigned char type, const char *sound, const char *source)
{
  _Bool tmp_if_expr$4;
  signed int return_value_fflush$3;
  if(!(use_config[13l] == 0))
  {
    signed int return_value_fprintf$2;
    return_value_fprintf$2=fprintf(sound_pipe, format, x, y, dir, vol, type, source, sound);
    if(!(return_value_fprintf$2 >= 1))
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_fflush$3=fflush(sound_pipe);
      tmp_if_expr$4 = return_value_fflush$3 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      LOG((enum LogLevel)LOG_ERROR, "gtk-v2::play_sound_effect", "Cannot write sound pipe: %d", *return_value___errno_location$1);
      use_config[(signed long int)13] = (signed short int)0;
      fclose(sound_pipe);
      sound_process = (struct ChildProcess *)(void *)0;
      goto __CPROVER_DUMP_L5;
    }

    else
      LOG((enum LogLevel)LOG_DEBUG, "gtk-v2::play_sound_effect", format, x, y, dir, vol, type, sound, source);
  }


__CPROVER_DUMP_L5:
  ;
}

// player_item
// file ./proto.h line 73
struct item_struct * player_item(void)
{
  player=new_item();
  return player;
}

// png_to_data
// file png.c line 71
unsigned char * png_to_data(unsigned char *data, signed int len, unsigned int *width, unsigned int *height)
{
  unsigned char *pixels = (unsigned char *)(void *)0;
  struct png_struct_def *png_ptr;
  struct png_info_struct *info_ptr;
  signed int bit_depth;
  signed int color_type;
  signed int interlace_type;
  signed int y;
  data_len = len;
  data_cp = data;
  data_start = 0;
  png_ptr=png_create_read_struct("1.2.54", (void *)0, (void (*)(struct png_struct_def *, const char *))(void *)0, (void (*)(struct png_struct_def *, const char *))(void *)0);
  unsigned long int return_value_png_get_valid$7;
  if(png_ptr == ((struct png_struct_def *)NULL))
    return (unsigned char *)(void *)0;

  else
  {
    info_ptr=png_create_info_struct(png_ptr);
    if(info_ptr == ((struct png_info_struct *)NULL))
    {
      png_destroy_read_struct(&png_ptr, (struct png_info_struct **)(void *)0, (struct png_info_struct **)(void *)0);
      return (unsigned char *)(void *)0;
    }

    else
    {
      signed int return_value__setjmp$1;
      return_value__setjmp$1=_setjmp(png_ptr->jmpbuf);
      if(!(return_value__setjmp$1 == 0))
      {
        png_destroy_read_struct(&png_ptr, &info_ptr, (struct png_info_struct **)(void *)0);
        return (unsigned char *)(void *)0;
      }

      else
      {
        png_set_read_fn(png_ptr, (void *)0, user_read_data);
        png_read_info(png_ptr, info_ptr);
        unsigned long int return_value_png_get_image_width$2;
        return_value_png_get_image_width$2=png_get_image_width(png_ptr, info_ptr);
        *width = (unsigned int)return_value_png_get_image_width$2;
        unsigned long int return_value_png_get_image_height$3;
        return_value_png_get_image_height$3=png_get_image_height(png_ptr, info_ptr);
        *height = (unsigned int)return_value_png_get_image_height$3;
        unsigned char return_value_png_get_bit_depth$4;
        return_value_png_get_bit_depth$4=png_get_bit_depth(png_ptr, info_ptr);
        bit_depth = (signed int)return_value_png_get_bit_depth$4;
        unsigned char return_value_png_get_color_type$5;
        return_value_png_get_color_type$5=png_get_color_type(png_ptr, info_ptr);
        color_type = (signed int)return_value_png_get_color_type$5;
        unsigned char return_value_png_get_interlace_type$6;
        return_value_png_get_interlace_type$6=png_get_interlace_type(png_ptr, info_ptr);
        interlace_type = (signed int)return_value_png_get_interlace_type$6;
        if(color_type == 3 && !(bit_depth >= 9))
          png_set_expand(png_ptr);

        else
          if(color_type == 0 && !(bit_depth >= 8))
            png_set_expand(png_ptr);

          else
          {
            return_value_png_get_valid$7=png_get_valid(png_ptr, info_ptr, (unsigned long int)0x0010);
            if(!(return_value_png_get_valid$7 == 0ul))
              png_set_expand(png_ptr);

            else
              if(!(bit_depth >= 8))
                png_set_expand(png_ptr);

          }
        if(bit_depth == 16)
          png_set_strip_16(png_ptr);

        if(color_type == 0 || color_type == 4)
          png_set_gray_to_rgb(png_ptr);

        if(!(interlace_type == 0))
          png_set_interlace_handling(png_ptr);

        if((4 & color_type) == 0)
          png_set_filler(png_ptr, (unsigned long int)255, 1);

        png_read_update_info(png_ptr, info_ptr);
        unsigned long int return_value_png_get_image_width$8;
        return_value_png_get_image_width$8=png_get_image_width(png_ptr, info_ptr);
        *width = (unsigned int)return_value_png_get_image_width$8;
        unsigned long int return_value_png_get_image_height$9;
        return_value_png_get_image_height$9=png_get_image_height(png_ptr, info_ptr);
        *height = (unsigned int)return_value_png_get_image_height$9;
        void *return_value_malloc$10;
        return_value_malloc$10=malloc((unsigned long int)(*width * *height * (unsigned int)4));
        pixels = (unsigned char *)return_value_malloc$10;
        if(pixels == ((unsigned char *)NULL))
        {
          png_destroy_read_struct(&png_ptr, &info_ptr, (struct png_info_struct **)(void *)0);
          LOG((enum LogLevel)LOG_CRITICAL, "gtk-v2::png_to_data", "Out of memory - exiting");
          exit(1);
        }

        static unsigned char **rows = (unsigned char **)(void *)0;
        static signed int rows_byte = 0;
        if(rows_byte == 0)
        {
          void *return_value_malloc$11;
          return_value_malloc$11=malloc(sizeof(unsigned char *) /*8ul*/  * (unsigned long int)*height);
          rows = (unsigned char **)return_value_malloc$11;
          rows_byte = (signed int)*height;
        }

        else
          if(!((unsigned int)rows_byte >= *height))
          {
            void *return_value_realloc$12;
            return_value_realloc$12=realloc((void *)rows, sizeof(unsigned char *) /*8ul*/  * (unsigned long int)*height);
            rows = (unsigned char **)return_value_realloc$12;
            if(rows == ((unsigned char **)NULL))
            {
              signed int *return_value___errno_location$13;
              return_value___errno_location$13=__errno_location();
              char *return_value_strerror$14;
              return_value_strerror$14=strerror(*return_value___errno_location$13);
              LOG((enum LogLevel)LOG_ERROR, "png_to_data", "Could not allocate memory: %s", return_value_strerror$14);
              exit(1);
            }

            rows_byte = (signed int)*height;
          }

        if(rows == ((unsigned char **)NULL))
        {
          png_destroy_read_struct(&png_ptr, &info_ptr, (struct png_info_struct **)(void *)0);
          free((void *)pixels);
          return (unsigned char *)(void *)0;
        }

        else
        {
          y = 0;
          for( ; !((unsigned int)y >= *height); y = y + 1)
            rows[(signed long int)y] = pixels + (signed long int)((unsigned int)y * *width * (unsigned int)4);
          png_read_image(png_ptr, rows);
          png_destroy_read_struct(&png_ptr, &info_ptr, (struct png_info_struct **)(void *)0);
          return pixels;
        }
      }
    }
  }
}

// png_to_gdkpixmap
// file png.c line 558
signed int png_to_gdkpixmap(struct _GdkDrawable *window, unsigned char *data, signed int len, struct _GdkDrawable **pix, struct _GdkDrawable **mask, struct _GdkColormap *colormap)
{
  unsigned long int png_to_gdkpixmap$$1$$width;
  unsigned long int png_to_gdkpixmap$$1$$height;
  struct png_struct_def *png_ptr;
  struct png_info_struct *info_ptr;
  signed int bit_depth;
  signed int color_type;
  signed int interlace_type;
  signed int filter_type;
  signed int bpp;
  signed int x;
  signed int y;
  signed int has_alpha;
  signed int i;
  signed int alpha;
  struct _GdkColor scolor;
  struct _GdkGC *gc;
  struct _GdkGC *gc_alpha;
  data_len = len;
  data_cp = data;
  data_start = 0;
  png_ptr=png_create_read_struct("1.2.54", (void *)0, (void (*)(struct png_struct_def *, const char *))(void *)0, (void (*)(struct png_struct_def *, const char *))(void *)0);
  unsigned long int return_value_png_get_valid$2;
  signed int tmp_post$9;
  signed int tmp_post$10;
  signed int tmp_post$11;
  if(png_ptr == ((struct png_struct_def *)NULL))
    return 2;

  else
  {
    info_ptr=png_create_info_struct(png_ptr);
    if(info_ptr == ((struct png_info_struct *)NULL))
    {
      png_destroy_read_struct(&png_ptr, (struct png_info_struct **)(void *)0, (struct png_info_struct **)(void *)0);
      return 2;
    }

    else
    {
      signed int return_value__setjmp$1;
      return_value__setjmp$1=_setjmp(png_ptr->jmpbuf);
      if(!(return_value__setjmp$1 == 0))
      {
        png_destroy_read_struct(&png_ptr, &info_ptr, (struct png_info_struct **)(void *)0);
        return 3;
      }

      else
      {
        has_alpha = 0;
        png_set_read_fn(png_ptr, (void *)0, user_read_data);
        png_read_info(png_ptr, info_ptr);
        png_get_IHDR(png_ptr, info_ptr, &png_to_gdkpixmap$$1$$width, &png_to_gdkpixmap$$1$$height, &bit_depth, &color_type, &interlace_type, (signed int *)(void *)0, &filter_type);
        if(color_type == 3 && !(bit_depth >= 9))
          png_set_expand(png_ptr);

        else
          if(color_type == 0 && !(bit_depth >= 8))
            png_set_expand(png_ptr);

          else
          {
            return_value_png_get_valid$2=png_get_valid(png_ptr, info_ptr, (unsigned long int)0x0010);
            if(!(return_value_png_get_valid$2 == 0ul))
              png_set_expand(png_ptr);

            else
              if(!(bit_depth >= 8))
                png_set_expand(png_ptr);

          }
        if(bit_depth == 16)
          png_set_strip_16(png_ptr);

        if(color_type == 0 || color_type == 4)
          png_set_gray_to_rgb(png_ptr);

        if(!(interlace_type == 0))
          png_set_interlace_handling(png_ptr);

        png_read_update_info(png_ptr, info_ptr);
        png_get_IHDR(png_ptr, info_ptr, &png_to_gdkpixmap$$1$$width, &png_to_gdkpixmap$$1$$height, &bit_depth, &color_type, &interlace_type, (signed int *)(void *)0, &filter_type);
        if(!((4 & color_type) == 0))
          bpp = 4;

        else
          bpp = 3;
        static unsigned char *pixels = (unsigned char *)(void *)0;
        static signed int pixels_byte = 0;
        if(pixels_byte == 0)
        {
          pixels_byte = (signed int)(png_to_gdkpixmap$$1$$width * png_to_gdkpixmap$$1$$height * (unsigned long int)bpp);
          void *return_value_malloc$3;
          return_value_malloc$3=malloc((unsigned long int)pixels_byte);
          pixels = (unsigned char *)return_value_malloc$3;
        }

        else
          if(!((unsigned long int)pixels_byte >= png_to_gdkpixmap$$1$$height * png_to_gdkpixmap$$1$$width * (unsigned long int)bpp))
          {
            pixels_byte = (signed int)(png_to_gdkpixmap$$1$$width * png_to_gdkpixmap$$1$$height * (unsigned long int)bpp);
            free((void *)pixels);
            void *return_value_malloc$4;
            return_value_malloc$4=malloc((unsigned long int)pixels_byte);
            pixels = (unsigned char *)return_value_malloc$4;
          }

        if(pixels == ((unsigned char *)NULL))
        {
          png_destroy_read_struct(&png_ptr, &info_ptr, (struct png_info_struct **)(void *)0);
          pixels_byte = 0;
          return 2;
        }

        else
        {
          static unsigned char **rows = (unsigned char **)(void *)0;
          static signed int rows_byte = 0;
          if(rows_byte == 0)
          {
            void *return_value_malloc$5;
            return_value_malloc$5=malloc(sizeof(unsigned char *) /*8ul*/  * png_to_gdkpixmap$$1$$height);
            rows = (unsigned char **)return_value_malloc$5;
            rows_byte = (signed int)png_to_gdkpixmap$$1$$height;
          }

          else
            if(!((unsigned long int)rows_byte >= png_to_gdkpixmap$$1$$height))
            {
              void *return_value_realloc$6;
              return_value_realloc$6=realloc((void *)rows, sizeof(unsigned char *) /*8ul*/  * png_to_gdkpixmap$$1$$height);
              rows = (unsigned char **)return_value_realloc$6;
              if(rows == ((unsigned char **)NULL))
              {
                signed int *return_value___errno_location$7;
                return_value___errno_location$7=__errno_location();
                char *return_value_strerror$8;
                return_value_strerror$8=strerror(*return_value___errno_location$7);
                LOG((enum LogLevel)LOG_ERROR, "png_to_gdkpixmap", "Could not allocate memory: %s", return_value_strerror$8);
                exit(1);
              }

              rows_byte = (signed int)png_to_gdkpixmap$$1$$height;
            }

          if(rows == ((unsigned char **)NULL))
          {
            png_destroy_read_struct(&png_ptr, &info_ptr, (struct png_info_struct **)(void *)0);
            pixels_byte = 0;
            return 2;
          }

          else
          {
            y = 0;
            for( ; !((unsigned long int)y >= png_to_gdkpixmap$$1$$height); y = y + 1)
              rows[(signed long int)y] = pixels + (signed long int)((unsigned long int)y * png_to_gdkpixmap$$1$$width * (unsigned long int)bpp);
            png_read_image(png_ptr, rows);
            *pix=gdk_pixmap_new(window, (signed int)png_to_gdkpixmap$$1$$width, (signed int)png_to_gdkpixmap$$1$$height, -1);
            gc=gdk_gc_new(*pix);
            gdk_gc_set_function(gc, (enum anonymous$65)GDK_COPY);
            if(!((4 & color_type) == 0))
            {
              *mask=gdk_pixmap_new(window, (signed int)png_to_gdkpixmap$$1$$width, (signed int)png_to_gdkpixmap$$1$$height, 1);
              gc_alpha=gdk_gc_new(*mask);
              gdk_gc_set_function(gc_alpha, (enum anonymous$65)GDK_COPY);
              scolor.pixel = (unsigned int)1;
              gdk_gc_set_foreground(gc_alpha, &scolor);
              gdk_draw_rectangle(*mask, gc_alpha, 1, 0, 0, (signed int)png_to_gdkpixmap$$1$$width, (signed int)png_to_gdkpixmap$$1$$height);
              scolor.pixel = (unsigned int)0;
              gdk_gc_set_foreground(gc_alpha, &scolor);
              has_alpha = 1;
            }

            else
            {
              *mask = (struct _GdkDrawable *)(void *)0;
              gc_alpha = (struct _GdkGC *)(void *)0;
            }
            i = 0;
            y = 0;
            for( ; !((unsigned long int)y >= png_to_gdkpixmap$$1$$height); y = y + 1)
            {
              x = 0;
              for( ; !((unsigned long int)x >= png_to_gdkpixmap$$1$$width); x = x + 1)
              {
                tmp_post$9 = i;
                i = i + 1;
                rgb[(signed long int)tmp_post$9] = rows[(signed long int)y][(signed long int)(x * bpp)];
                tmp_post$10 = i;
                i = i + 1;
                rgb[(signed long int)tmp_post$10] = rows[(signed long int)y][(signed long int)(x * bpp + 1)];
                tmp_post$11 = i;
                i = i + 1;
                rgb[(signed long int)tmp_post$11] = rows[(signed long int)y][(signed long int)(x * bpp + 2)];
                if(!(has_alpha == 0))
                {
                  alpha = (signed int)rows[(signed long int)y][(signed long int)(x * bpp + 3)];
                  if(alpha == 0)
                    gdk_draw_point(*mask, gc_alpha, x, y);

                }

              }
            }
            gdk_draw_rgb_image(*pix, gc, 0, 0, 32, 32, (enum anonymous$15)GDK_RGB_DITHER_NONE, rgb, 32 * 3);
            png_destroy_read_struct(&png_ptr, &info_ptr, (struct png_info_struct **)(void *)0);
            if(!(has_alpha == 0))
              g_object_unref((void *)gc_alpha);

            g_object_unref((void *)gc);
            return 0;
          }
        }
      }
    }
  }
}

// print_inventory
// file item.c line 678
void print_inventory(struct item_struct *op)
{
  char buf[256l];
  char buf2[256l];
  struct item_struct *tmp;
  signed int info_width = 40;
  static signed int l = 0;
  if(l == 0)
  {
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%s's inventory (%d):", (const void *)op->d_name, op->tag);
    snprintf(buf2, sizeof(char [256l]) /*256ul*/ , "%-*s%6.1f kg", info_width - 10, (const void *)buf, op->weight);
    draw_ext_info(0, 20, 5, buf2);
  }

  l = l + 2;
  tmp = op->inv;
  for( ; !(tmp == ((struct item_struct *)NULL)); tmp = tmp->next)
  {
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%*s- %d %s%s (%d)", l - 2, (const void *)"", tmp->nrof, (const void *)tmp->d_name, (const void *)tmp->flags, tmp->tag);
    snprintf(buf2, sizeof(char [256l]) /*256ul*/ , "%-*s%6.1f kg", (info_width - 8) - l, (const void *)buf, (float)tmp->nrof * tmp->weight);
    draw_ext_info(0, 20, 5, buf2);
    if(!(tmp->inv == ((struct item_struct *)NULL)))
      print_inventory(tmp);

  }
  l = l - 2;
}

// process_race_class_info
// file commands.c line 470
static void process_race_class_info(char *data, signed int len, struct Race_Class_Info *rci)
{
  char *cp;
  char *nl;
  cp = data;
  nl=strchr(cp, 10);
  if(!(nl == ((char *)NULL)))
  {
    *nl = (char)0;
    rci->arch_name=strdup(cp);
    cp = nl + (signed long int)1;
  }

  else
  {
    LOG((enum LogLevel)LOG_WARNING, "common::process_race_class_info", "Did not find archetype name");
    goto __CPROVER_DUMP_L25;
  }
  signed int return_value_strcmp$19;
  signed int return_value_strcmp$18;
  signed int return_value_strcmp$17;
  do
  {
    nl=strchr(cp, 32);
    if(nl == ((char *)NULL))
      break;

    if(!(nl == ((char *)NULL)))
    {
      *nl = (char)0;
      nl = nl + 1l;
    }

    signed int return_value_strcmp$20;
    return_value_strcmp$20=strcmp(cp, "name");
    if(return_value_strcmp$20 == 0)
    {
      signed int namelen;
      char return_value_GetChar_String$1;
      return_value_GetChar_String$1=GetChar_String((const unsigned char *)nl);
      namelen = (signed int)return_value_GetChar_String$1;
      if(!(data + (signed long int)len >= nl + (signed long int)namelen))
      {
        LOG((enum LogLevel)LOG_WARNING, "common::process_race_class_info", "Data goes beyond length of buffer (%d>%d)", nl + (signed long int)namelen, data + (signed long int)len);
        break;
      }

      nl = nl + 1l;
      void *return_value_malloc$2;
      return_value_malloc$2=malloc((unsigned long int)(namelen + 1));
      rci->public_name = (char *)return_value_malloc$2;
      strncpy(rci->public_name, nl, (unsigned long int)namelen);
      rci->public_name[(signed long int)namelen] = (char)0;
      cp = nl + (signed long int)namelen;
    }

    else
    {
      return_value_strcmp$19=strcmp(cp, "stats");
      if(return_value_strcmp$19 == 0)
      {
        cp = nl;
        while(!(cp >= data + (signed long int)len))
        {
          if((signed int)*cp == 0)
            break;

          signed int i = 0;
          for( ; !(i >= 7); i = i + 1)
            if((signed int)stat_mapping[(signed long int)i].cs_value == (signed int)*cp)
              break;

          if(i == 7)
          {
            LOG((enum LogLevel)LOG_WARNING, "common::process_race_class_info", "Unknown stat value: %d", cp);
            goto __CPROVER_DUMP_L25;
          }

          signed short int return_value_GetShort_String$3;
          return_value_GetShort_String$3=GetShort_String((const unsigned char *)(cp + (signed long int)1));
          rci->stat_adj[(signed long int)stat_mapping[(signed long int)i].rc_offset] = (signed char)return_value_GetShort_String$3;
          cp = cp + (signed long int)3;
        }
        cp = cp + 1l;
      }

      else
      {
        return_value_strcmp$18=strcmp(cp, "msg");
        if(return_value_strcmp$18 == 0)
        {
          signed int msglen;
          signed short int return_value_GetShort_String$4;
          return_value_GetShort_String$4=GetShort_String((const unsigned char *)nl);
          msglen = (signed int)return_value_GetShort_String$4;
          if(!(data + (signed long int)len >= nl + (signed long int)msglen))
          {
            LOG((enum LogLevel)LOG_WARNING, "common::process_race_class_info", "Data goes beyond length of buffer (%d>%d)", nl + (signed long int)msglen, data + (signed long int)len);
            break;
          }

          nl = nl + (signed long int)2;
          void *return_value_malloc$5;
          return_value_malloc$5=malloc((unsigned long int)(msglen + 1));
          rci->description = (char *)return_value_malloc$5;
          strncpy(rci->description, nl, (unsigned long int)msglen);
          rci->description[(signed long int)msglen] = (char)0;
          cp = nl + (signed long int)msglen;
        }

        else
        {
          return_value_strcmp$17=strcmp(cp, "choice");
          if(return_value_strcmp$17 == 0)
          {
            signed int oc = rci->num_rc_choice;
            signed int clen;
            rci->num_rc_choice = rci->num_rc_choice + 1;
            void *return_value_realloc$6;
            return_value_realloc$6=realloc((void *)rci->rc_choice, sizeof(struct RC_Choice) /*40ul*/  * (unsigned long int)rci->num_rc_choice);
            rci->rc_choice = (struct RC_Choice *)return_value_realloc$6;
            memset((void *)&rci->rc_choice[(signed long int)oc], 0, sizeof(struct RC_Choice) /*40ul*/ );
            cp = nl;
            char return_value_GetChar_String$7;
            return_value_GetChar_String$7=GetChar_String((const unsigned char *)cp);
            clen = (signed int)return_value_GetChar_String$7;
            cp = cp + 1l;
            if(!(data + (signed long int)len >= cp + (signed long int)clen))
            {
              LOG((enum LogLevel)LOG_WARNING, "common::process_race_class_info", "Data goes beyond length of buffer (%d>%d)", cp + (signed long int)clen, data + (signed long int)len);
              break;
            }

            void *return_value_malloc$8;
            return_value_malloc$8=malloc((unsigned long int)(clen + 1));
            (rci->rc_choice + (signed long int)oc)->choice_name = (char *)return_value_malloc$8;
            strncpy((rci->rc_choice + (signed long int)oc)->choice_name, cp, (unsigned long int)clen);
            (rci->rc_choice + (signed long int)oc)->choice_name[(signed long int)clen] = (char)0;
            cp = cp + (signed long int)clen;
            char return_value_GetChar_String$9;
            return_value_GetChar_String$9=GetChar_String((const unsigned char *)cp);
            clen = (signed int)return_value_GetChar_String$9;
            cp = cp + 1l;
            if(!(data + (signed long int)len >= cp + (signed long int)clen))
            {
              LOG((enum LogLevel)LOG_WARNING, "common::process_race_class_info", "Data goes beyond length of buffer (%d>%d)", cp + (signed long int)clen, data + (signed long int)len);
              break;
            }

            void *return_value_malloc$10;
            return_value_malloc$10=malloc((unsigned long int)(clen + 1));
            (rci->rc_choice + (signed long int)oc)->choice_desc = (char *)return_value_malloc$10;
            strncpy((rci->rc_choice + (signed long int)oc)->choice_desc, cp, (unsigned long int)clen);
            (rci->rc_choice + (signed long int)oc)->choice_desc[(signed long int)clen] = (char)0;
            cp = cp + (signed long int)clen;
            while((_Bool)1)
            {
              signed int vn;
              char return_value_GetChar_String$11;
              return_value_GetChar_String$11=GetChar_String((const unsigned char *)cp);
              clen = (signed int)return_value_GetChar_String$11;
              cp = cp + 1l;
              if(clen == 0)
                break;

              vn = (rci->rc_choice + (signed long int)oc)->num_values;
              (rci->rc_choice + (signed long int)oc)->num_values = (rci->rc_choice + (signed long int)oc)->num_values + 1;
              void *return_value_realloc$12;
              return_value_realloc$12=realloc((void *)(rci->rc_choice + (signed long int)oc)->value_arch, sizeof(char *) /*8ul*/  * (unsigned long int)(rci->rc_choice + (signed long int)oc)->num_values);
              (rci->rc_choice + (signed long int)oc)->value_arch = (char **)return_value_realloc$12;
              void *return_value_realloc$13;
              return_value_realloc$13=realloc((void *)(rci->rc_choice + (signed long int)oc)->value_desc, sizeof(char *) /*8ul*/  * (unsigned long int)(rci->rc_choice + (signed long int)oc)->num_values);
              (rci->rc_choice + (signed long int)oc)->value_desc = (char **)return_value_realloc$13;
              if(!(data + (signed long int)len >= cp + (signed long int)clen))
              {
                LOG((enum LogLevel)LOG_WARNING, "common::process_race_class_info", "Data goes beyond length of buffer (%d>%d)", cp + (signed long int)clen, data + (signed long int)len);
                break;
              }

              void *return_value_malloc$14;
              return_value_malloc$14=malloc((unsigned long int)(clen + 1));
              (rci->rc_choice + (signed long int)oc)->value_arch[(signed long int)vn] = (char *)return_value_malloc$14;
              strncpy((rci->rc_choice + (signed long int)oc)->value_arch[(signed long int)vn], cp, (unsigned long int)clen);
              (rci->rc_choice + (signed long int)oc)->value_arch[(signed long int)vn][(signed long int)clen] = (char)0;
              cp = cp + (signed long int)clen;
              char return_value_GetChar_String$15;
              return_value_GetChar_String$15=GetChar_String((const unsigned char *)cp);
              clen = (signed int)return_value_GetChar_String$15;
              cp = cp + 1l;
              if(!(data + (signed long int)len >= cp + (signed long int)clen))
              {
                LOG((enum LogLevel)LOG_WARNING, "common::process_race_class_info", "Data goes beyond length of buffer (%d>%d)", cp + (signed long int)clen, data + (signed long int)len);
                break;
              }

              void *return_value_malloc$16;
              return_value_malloc$16=malloc((unsigned long int)(clen + 1));
              (rci->rc_choice + (signed long int)oc)->value_desc[(signed long int)vn] = (char *)return_value_malloc$16;
              strncpy((rci->rc_choice + (signed long int)oc)->value_desc[(signed long int)vn], cp, (unsigned long int)clen);
              (rci->rc_choice + (signed long int)oc)->value_desc[(signed long int)vn][(signed long int)clen] = (char)0;
              cp = cp + (signed long int)clen;
            }
          }

          else
          {
            LOG((enum LogLevel)LOG_WARNING, "common::process_race_class_info", "Got unknown keyword: %s", cp);
            break;
          }
        }
      }
    }
  }
  while(!(cp >= data + (signed long int)len));
  if(rci->description == ((char *)NULL))
    rci->description=strdup("");


__CPROVER_DUMP_L25:
  ;
}

// purgePipe
// file misc.c line 210
void purgePipe(struct ChildProcess *cp, signed int pipe)
{
  char buf[512l];
  signed int len;
  signed long int return_value_read$1;
  return_value_read$1=read(cp->tube[(signed long int)pipe], (void *)buf, (unsigned long int)511);
  len = (signed int)return_value_read$1;
  char *tmp_if_expr$3;
  if(!(len >= 1))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 11)
      goto __CPROVER_DUMP_L9;

    if(!(cp->name == ((char *)NULL)))
      tmp_if_expr$3 = cp->name;

    else
      tmp_if_expr$3 = "UNKNOWN";
    LOG((enum LogLevel)LOG_ERROR, "common::purgePipe", "Child %s: could not read from pipe %d!", tmp_if_expr$3, pipe);
  }

  if(len >= 1)
  {
    char *next;
    char *current = buf;
    buf[(signed long int)(len < 512 ? len : 511)] = (char)0;
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(buf);
    if(return_value_strlen$4 == 0ul)
      goto __CPROVER_DUMP_L9;

    for( ; (_Bool)1; current = next)
    {
      if(current == ((char *)NULL))
        goto __CPROVER_DUMP_L9;

      next=strstr(current, "\n");
      if(!(next == ((char *)NULL)))
      {
        next[(signed long int)0] = (char)0;
        unsigned long int return_value_strlen$5;
        return_value_strlen$5=strlen("\n");
        next = next + (signed long int)return_value_strlen$5;
      }

      LOG(cp->logger[(signed long int)pipe].level, cp->logger[(signed long int)pipe].name, current);
    }
  }


__CPROVER_DUMP_L9:
  ;
}

// putpixel
// file sdl.c line 78
static void putpixel(struct SDL_Surface *surface, signed int x, signed int y, unsigned int pixel)
{
  signed int bpp = (signed int)surface->format->BytesPerPixel;
  unsigned char *p = (unsigned char *)surface->pixels + (signed long int)(y * (signed int)surface->pitch) + (signed long int)(x * bpp);
  switch(bpp)
  {
    case 1:
    {
      *p = (unsigned char)pixel;
      break;
    }
    case 2:
    {
      *((unsigned short int *)p) = (unsigned short int)pixel;
      break;
    }
    case 3:
    {
      p[(signed long int)0] = (unsigned char)(pixel & (unsigned int)0xff);
      p[(signed long int)1] = (unsigned char)(pixel >> 8 & (unsigned int)0xff);
      p[(signed long int)2] = (unsigned char)(pixel >> 16 & (unsigned int)0xff);
      break;
    }
    case 4:
      *((unsigned int *)p) = pixel;
  }
}

// raiseChild
// file ../../common/proto.h line 119
struct ChildProcess * raiseChild(char *name, signed int flag)
{
  struct ChildProcess *cp;
  signed int pipe_in[2l];
  signed int pipe_out[2l];
  signed int pipe_err[2l];
  signed int pid;
  char *args;
  LOG((enum LogLevel)LOG_INFO, "common::raiseChild", "Raising %s with flags %d", name, flag);
  flag = flag & ~8;
  signed int return_value_pipe$2;
  signed int return_value_pipe$3;
  signed int return_value_pipe$4;
  if(!((-8 & flag) == 0))
  {
    LOG((enum LogLevel)LOG_ERROR, "common::raiseChild", "Serious CHILD error, unknown pipe requested: 0x%X for %s", flag, name);
    return (struct ChildProcess *)(void *)0;
  }

  else
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct ChildProcess) /*88ul*/ );
    cp = (struct ChildProcess *)return_value_calloc$1;
    if(cp == ((struct ChildProcess *)NULL))
      return (struct ChildProcess *)(void *)0;

    else
    {
      args = name;
      for( ; !(*args == 0); args = args + 1l)
        if((signed int)*args == 32)
          break;

      for( ; !(*args == 0); args = args + 1l)
        if(!((signed int)*args == 32))
          break;

      if((signed int)*args == 0)
        args = (char *)(void *)0;

      else
        args[(signed long int)-1] = (char)0;
      if(!((4 & flag) == 0))
      {
        return_value_pipe$2=pipe(pipe_err);
        if(return_value_pipe$2 == 0)
          goto __CPROVER_DUMP_L8;

        LOG((enum LogLevel)LOG_ERROR, "common::raiseChild", "Couldn't create stderr pipe for %s", name);
        free((void *)cp);
        return (struct ChildProcess *)(void *)0;
      }

      else
      {

      __CPROVER_DUMP_L8:
        ;
        if(!((1 & flag) == 0))
        {
          return_value_pipe$3=pipe(pipe_in);
          if(return_value_pipe$3 == 0)
            goto __CPROVER_DUMP_L10;

          LOG((enum LogLevel)LOG_ERROR, "common::raiseChild", "Couldn't create stdin pipe for %s", name);
          if(!((4 & flag) == 0))
          {
            close(pipe_err[(signed long int)0]);
            close(pipe_err[(signed long int)1]);
          }

          free((void *)cp);
          return (struct ChildProcess *)(void *)0;
        }

        else
        {

        __CPROVER_DUMP_L10:
          ;
          if(!((2 & flag) == 0))
          {
            return_value_pipe$4=pipe(pipe_out);
            if(return_value_pipe$4 == 0)
              goto __CPROVER_DUMP_L13;

            LOG((enum LogLevel)LOG_ERROR, "common::raiseChild", "Couldn't create stdout pipe for %s", name);
            if(!((4 & flag) == 0))
            {
              close(pipe_err[(signed long int)0]);
              close(pipe_err[(signed long int)1]);
            }

            if(!((1 & flag) == 0))
            {
              close(pipe_in[(signed long int)0]);
              close(pipe_in[(signed long int)1]);
            }

            free((void *)cp);
            return (struct ChildProcess *)(void *)0;
          }

          else
          {

          __CPROVER_DUMP_L13:
            ;
            pid=fork();
            if(pid == -1)
            {
              LOG((enum LogLevel)LOG_ERROR, "common::raiseChild", "Couldn't create child for %s. Closing pipes", name);
              if(!((1 & flag) == 0))
              {
                close(pipe_in[(signed long int)0]);
                close(pipe_in[(signed long int)1]);
              }

              if(!((2 & flag) == 0))
              {
                close(pipe_out[(signed long int)0]);
                close(pipe_out[(signed long int)1]);
              }

              if(!((4 & flag) == 0))
              {
                close(pipe_err[(signed long int)0]);
                close(pipe_err[(signed long int)1]);
              }

              free((void *)cp);
              return (struct ChildProcess *)(void *)0;
            }

            else
            {
              if(pid == 0)
              {
                signed int i;
                signed int r;
                char *argv[256l];
                argv[(signed long int)0] = name;
                i = 1;
                while(!(args == ((char *)NULL)))
                {
                  if(*args == 0)
                    break;

                  argv[(signed long int)i] = args;
                  i = i + 1;
                  for( ; !(*args == 0); args = args + 1l)
                    if((signed int)*args == 32)
                      break;

                  if(!(*args == 0))
                  {
                    *args = (char)0;
                    args = args + 1l;
                  }

                  for( ; !(*args == 0); args = args + 1l)
                    if(!((signed int)*args == 32))
                      break;

                }
                argv[(signed long int)i] = (char *)(void *)0;
                if(!((4 & flag) == 0))
                {
                  r=dup2(pipe_err[(signed long int)1], 2);
                  close(pipe_err[(signed long int)0]);
                  if(!(r == 2))
                    fprintf(stderr, "common::raiseChild Failed to set pipe_err as stderr\n");

                }

                if(!((2 & flag) == 0))
                {
                  r=dup2(pipe_out[(signed long int)1], 1);
                  close(pipe_out[(signed long int)0]);
                  if(!(r == 1))
                    fprintf(stderr, "common::raiseChild Failed to set pipe_out as stdout\n");

                }

                if(!((1 & flag) == 0))
                {
                  r=dup2(pipe_in[(signed long int)0], 0);
                  close(pipe_in[(signed long int)1]);
                  if(!(r == 0))
                    fprintf(stderr, "common::raiseChild Failed to set pipe_in as stdin\n");

                }

                i = 3;
                for( ; !(i >= 100); i = i + 1)
                  close(i);
                execvp(argv[(signed long int)0], argv);
                exit(-1);
              }

              if(!((1 & flag) == 0))
              {
                close(pipe_in[(signed long int)0]);
                cp->tube[(signed long int)0] = pipe_in[(signed long int)1];
              }

              else
                cp->tube[(signed long int)0] = -1;
              if(!((2 & flag) == 0))
              {
                close(pipe_out[(signed long int)1]);
                cp->tube[(signed long int)1] = pipe_out[(signed long int)0];
              }

              else
                cp->tube[(signed long int)1] = -1;
              if(!((4 & flag) == 0))
              {
                close(pipe_err[(signed long int)1]);
                cp->tube[(signed long int)2] = pipe_err[(signed long int)0];
              }

              else
                cp->tube[(signed long int)2] = -1;
              cp->pid = pid;
              cp->name=strdup(name);
              cp->flag = flag;
              if(!(FirstChild == ((struct ChildProcess *)NULL)))
                LastChild->next = cp;

              else
                FirstChild = cp;
              LastChild = cp;
              cp->next = (struct ChildProcess *)(void *)0;
              return cp;
            }
          }
        }
      }
    }
  }
}

// rc_compar
// file commands.c line 406
static signed int rc_compar(const struct Race_Class_Info *a, const struct Race_Class_Info *b)
{
  signed int return_value_strcasecmp$1;
  return_value_strcasecmp$1=strcasecmp(a->public_name, b->public_name);
  return return_value_strcasecmp$1;
}

// read_config_window
// file config.c line 886
static void read_config_window(void)
{
  char *buf;
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)config_button_echo, return_value_gtk_toggle_button_get_type$1);
  signed int return_value_gtk_toggle_button_get_active$3;
  return_value_gtk_toggle_button_get_active$3=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2);
  want_config[(signed long int)2] = (signed short int)return_value_gtk_toggle_button_get_active$3;
  unsigned long int return_value_gtk_toggle_button_get_type$4;
  return_value_gtk_toggle_button_get_type$4=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)config_button_fasttcp, return_value_gtk_toggle_button_get_type$4);
  signed int return_value_gtk_toggle_button_get_active$6;
  return_value_gtk_toggle_button_get_active$6=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$5);
  want_config[(signed long int)3] = (signed short int)return_value_gtk_toggle_button_get_active$6;
  unsigned long int return_value_gtk_toggle_button_get_type$7;
  return_value_gtk_toggle_button_get_type$7=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)config_button_timestamp, return_value_gtk_toggle_button_get_type$7);
  signed int return_value_gtk_toggle_button_get_active$9;
  return_value_gtk_toggle_button_get_active$9=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$8);
  want_config[(signed long int)31] = (signed short int)return_value_gtk_toggle_button_get_active$9;
  unsigned long int return_value_gtk_toggle_button_get_type$10;
  return_value_gtk_toggle_button_get_type$10=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)config_button_grad_color, return_value_gtk_toggle_button_get_type$10);
  signed int return_value_gtk_toggle_button_get_active$12;
  return_value_gtk_toggle_button_get_active$12=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$11);
  want_config[(signed long int)24] = (signed short int)return_value_gtk_toggle_button_get_active$12;
  unsigned long int return_value_gtk_toggle_button_get_type$13;
  return_value_gtk_toggle_button_get_type$13=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)config_button_foodbeep, return_value_gtk_toggle_button_get_type$13);
  signed int return_value_gtk_toggle_button_get_active$15;
  return_value_gtk_toggle_button_get_active$15=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$14);
  want_config[(signed long int)21] = (signed short int)return_value_gtk_toggle_button_get_active$15;
  unsigned long int return_value_gtk_toggle_button_get_type$16;
  return_value_gtk_toggle_button_get_type$16=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$17;
  return_value_g_type_check_instance_cast$17=g_type_check_instance_cast((struct _GTypeInstance *)config_button_sound, return_value_gtk_toggle_button_get_type$16);
  signed int return_value_gtk_toggle_button_get_active$18;
  return_value_gtk_toggle_button_get_active$18=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$17);
  want_config[(signed long int)13] = (signed short int)return_value_gtk_toggle_button_get_active$18;
  unsigned long int return_value_gtk_toggle_button_get_type$19;
  return_value_gtk_toggle_button_get_type$19=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)config_button_cache, return_value_gtk_toggle_button_get_type$19);
  signed int return_value_gtk_toggle_button_get_active$21;
  return_value_gtk_toggle_button_get_active$21=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$20);
  want_config[(signed long int)5] = (signed short int)return_value_gtk_toggle_button_get_active$21;
  unsigned long int return_value_gtk_toggle_button_get_type$22;
  return_value_gtk_toggle_button_get_type$22=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$23;
  return_value_g_type_check_instance_cast$23=g_type_check_instance_cast((struct _GTypeInstance *)config_button_download, return_value_gtk_toggle_button_get_type$22);
  signed int return_value_gtk_toggle_button_get_active$24;
  return_value_gtk_toggle_button_get_active$24=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$23);
  want_config[(signed long int)1] = (signed short int)return_value_gtk_toggle_button_get_active$24;
  unsigned long int return_value_gtk_toggle_button_get_type$25;
  return_value_gtk_toggle_button_get_type$25=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)config_button_fog, return_value_gtk_toggle_button_get_type$25);
  signed int return_value_gtk_toggle_button_get_active$27;
  return_value_gtk_toggle_button_get_active$27=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$26);
  want_config[(signed long int)6] = (signed short int)return_value_gtk_toggle_button_get_active$27;
  unsigned long int return_value_gtk_toggle_button_get_type$28;
  return_value_gtk_toggle_button_get_type$28=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$29;
  return_value_g_type_check_instance_cast$29=g_type_check_instance_cast((struct _GTypeInstance *)config_button_smoothing, return_value_gtk_toggle_button_get_type$28);
  signed int return_value_gtk_toggle_button_get_active$30;
  return_value_gtk_toggle_button_get_active$30=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$29);
  want_config[(signed long int)26] = (signed short int)return_value_gtk_toggle_button_get_active$30;
  unsigned long int return_value_gtk_spin_button_get_type$31;
  return_value_gtk_spin_button_get_type$31=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
  return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)config_spinbutton_cwindow, return_value_gtk_spin_button_get_type$31);
  signed int return_value_gtk_spin_button_get_value_as_int$33;
  return_value_gtk_spin_button_get_value_as_int$33=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$32);
  want_config[(signed long int)4] = (signed short int)return_value_gtk_spin_button_get_value_as_int$33;
  unsigned long int return_value_gtk_spin_button_get_type$34;
  return_value_gtk_spin_button_get_type$34=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$35;
  return_value_g_type_check_instance_cast$35=g_type_check_instance_cast((struct _GTypeInstance *)config_spinbutton_iconscale, return_value_gtk_spin_button_get_type$34);
  signed int return_value_gtk_spin_button_get_value_as_int$36;
  return_value_gtk_spin_button_get_value_as_int$36=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$35);
  want_config[(signed long int)7] = (signed short int)return_value_gtk_spin_button_get_value_as_int$36;
  unsigned long int return_value_gtk_spin_button_get_type$37;
  return_value_gtk_spin_button_get_type$37=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$38;
  return_value_g_type_check_instance_cast$38=g_type_check_instance_cast((struct _GTypeInstance *)config_spinbutton_mapscale, return_value_gtk_spin_button_get_type$37);
  signed int return_value_gtk_spin_button_get_value_as_int$39;
  return_value_gtk_spin_button_get_value_as_int$39=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$38);
  want_config[(signed long int)8] = (signed short int)return_value_gtk_spin_button_get_value_as_int$39;
  unsigned long int return_value_gtk_spin_button_get_type$40;
  return_value_gtk_spin_button_get_type$40=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$41;
  return_value_g_type_check_instance_cast$41=g_type_check_instance_cast((struct _GTypeInstance *)config_spinbutton_mapwidth, return_value_gtk_spin_button_get_type$40);
  signed int return_value_gtk_spin_button_get_value_as_int$42;
  return_value_gtk_spin_button_get_value_as_int$42=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$41);
  want_config[(signed long int)19] = (signed short int)return_value_gtk_spin_button_get_value_as_int$42;
  unsigned long int return_value_gtk_spin_button_get_type$43;
  return_value_gtk_spin_button_get_type$43=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$44;
  return_value_g_type_check_instance_cast$44=g_type_check_instance_cast((struct _GTypeInstance *)config_spinbutton_mapheight, return_value_gtk_spin_button_get_type$43);
  signed int return_value_gtk_spin_button_get_value_as_int$45;
  return_value_gtk_spin_button_get_value_as_int$45=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$44);
  want_config[(signed long int)20] = (signed short int)return_value_gtk_spin_button_get_value_as_int$45;
  unsigned long int return_value_gtk_combo_box_get_type$46;
  return_value_gtk_combo_box_get_type$46=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$47;
  return_value_g_type_check_instance_cast$47=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_faceset, return_value_gtk_combo_box_get_type$46);
  buf=gtk_combo_box_get_active_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$47);
  if(!(buf == ((char *)NULL)))
  {
    free((void *)face_info.want_faceset);
    face_info.want_faceset=strdup_local(buf);
    g_free((void *)buf);
  }

  unsigned long int return_value_gtk_combo_box_get_type$48;
  return_value_gtk_combo_box_get_type$48=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$49;
  return_value_g_type_check_instance_cast$49=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_displaymode, return_value_gtk_combo_box_get_type$48);
  buf=gtk_combo_box_get_active_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$49);
  signed int return_value_strcasecmp$51;
  signed int return_value_strcasecmp$50;
  if(!(buf == ((char *)NULL)))
  {
    signed int return_value_strcasecmp$52;
    return_value_strcasecmp$52=strcasecmp(buf, "OpenGL");
    if(return_value_strcasecmp$52 == 0)
      want_config[(signed long int)10] = (signed short int)2;

    else
    {
      return_value_strcasecmp$51=strcasecmp(buf, "SDL");
      if(return_value_strcasecmp$51 == 0)
        want_config[(signed long int)10] = (signed short int)1;

      else
      {
        return_value_strcasecmp$50=strcasecmp(buf, "Pixmap");
        if(return_value_strcasecmp$50 == 0)
          want_config[(signed long int)10] = (signed short int)0;

      }
    }
    g_free((void *)buf);
  }

  unsigned long int return_value_gtk_combo_box_get_type$53;
  return_value_gtk_combo_box_get_type$53=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$54;
  return_value_g_type_check_instance_cast$54=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_lighting, return_value_gtk_combo_box_get_type$53);
  buf=gtk_combo_box_get_active_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$54);
  signed int return_value_strcasecmp$57;
  signed int return_value_strcasecmp$56;
  signed int return_value_strcasecmp$55;
  if(!(buf == ((char *)NULL)))
  {
    signed int return_value_strcasecmp$58;
    return_value_strcasecmp$58=strcasecmp(buf, "Per Tile");
    if(return_value_strcasecmp$58 == 0)
      want_config[(signed long int)17] = (signed short int)1;

    else
    {
      return_value_strcasecmp$57=strcasecmp(buf, "Fast Per Pixel");
      if(return_value_strcasecmp$57 == 0)
        want_config[(signed long int)17] = (signed short int)2;

      else
      {
        return_value_strcasecmp$56=strcasecmp(buf, "Best Per Pixel");
        if(return_value_strcasecmp$56 == 0)
          want_config[(signed long int)17] = (signed short int)3;

        else
        {
          return_value_strcasecmp$55=strcasecmp(buf, "None");
          if(return_value_strcasecmp$55 == 0)
            want_config[(signed long int)17] = (signed short int)0;

        }
      }
    }
    if(!((signed int)want_config[17l] == 0))
    {
      want_config[(signed long int)22] = (signed short int)1;
      use_config[(signed long int)22] = (signed short int)1;
    }

    g_free((void *)buf);
  }

  unsigned long int return_value_gtk_combo_box_get_type$59;
  return_value_gtk_combo_box_get_type$59=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$60;
  return_value_g_type_check_instance_cast$60=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_theme, return_value_gtk_combo_box_get_type$59);
  buf=gtk_combo_box_get_active_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$60);
  if(!(buf == ((char *)NULL)))
  {
    signed int return_value_strcmp$61;
    return_value_strcmp$61=strcmp(buf, theme);
    if(!(return_value_strcmp$61 == 0))
    {
      theme = buf;
      load_theme((signed int)!(0 != 0));
    }

    else
      g_free((void *)buf);
  }

  else
    theme = "None";
  unsigned long int return_value_gtk_combo_box_get_type$62;
  return_value_gtk_combo_box_get_type$62=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$63;
  return_value_g_type_check_instance_cast$63=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_layout, return_value_gtk_combo_box_get_type$62);
  buf=gtk_combo_box_get_active_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$63);
  signed int return_value_strcmp$64;
  if(!(buf == ((char *)NULL)))
  {
    return_value_strcmp$64=strcmp(buf, window_xml_file);
    if(!(return_value_strcmp$64 == 0))
      strncpy(window_xml_file, buf, (unsigned long int)256);

  }

  if(!(want_config[13l] == use_config[13l]))
  {
    signed int tmp;
    if(!(want_config[13l] == 0))
    {
      tmp=init_sounds();
      if(!(csocket.fd == 0))
        cs_print_string(csocket.fd, "setup sound %d", tmp >= 0);

    }

    else
      if(!(csocket.fd == 0))
        cs_print_string(csocket.fd, "setup sound 0");

    use_config[(signed long int)13] = want_config[(signed long int)13];
  }

  if(!(want_config[3l] == use_config[3l]))
    use_config[(signed long int)3] = want_config[(signed long int)3];

  if(!(want_config[17l] == use_config[17l]))
  {
    if((signed int)use_config[10l] == 1)
      init_SDL((struct _GtkWidget *)(void *)0, 1);

  }

  if(!(want_config[24l] == use_config[24l]))
  {
    use_config[(signed long int)24] = want_config[(signed long int)24];
    draw_stats((signed int)!(0 != 0));
  }

}

// read_msgctrl_configuration
// file info.c line 1793
extern void read_msgctrl_configuration(void)
{
  unsigned int pane;
  unsigned int type;
  unsigned long int return_value_gtk_spin_button_get_type$1;
  return_value_gtk_spin_button_get_type$1=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)buffer_control.count.ptr, return_value_gtk_spin_button_get_type$1);
  signed int return_value_gtk_spin_button_get_value_as_int$3;
  return_value_gtk_spin_button_get_value_as_int$3=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$2);
  buffer_control.count.state = (unsigned int)return_value_gtk_spin_button_get_value_as_int$3;
  unsigned long int return_value_gtk_spin_button_get_type$4;
  return_value_gtk_spin_button_get_type$4=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)buffer_control.timer.ptr, return_value_gtk_spin_button_get_type$4);
  signed int return_value_gtk_spin_button_get_value_as_int$6;
  return_value_gtk_spin_button_get_value_as_int$6=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$5);
  buffer_control.timer.state = (unsigned int)return_value_gtk_spin_button_get_value_as_int$6;
  type = (unsigned int)0;
  for( ; !(type >= 20u); type = type + (unsigned int)1)
  {
    unsigned long int return_value_gtk_toggle_button_get_type$7;
    return_value_gtk_toggle_button_get_type$7=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)msgctrl_widgets[(signed long int)type].buffer.ptr, return_value_gtk_toggle_button_get_type$7);
    msgctrl_widgets[(signed long int)type].buffer.state=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$8);
    pane = (unsigned int)0;
    for( ; !(pane >= 2u); pane = pane + (unsigned int)1)
    {
      unsigned long int return_value_gtk_toggle_button_get_type$9;
      return_value_gtk_toggle_button_get_type$9=gtk_toggle_button_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
      return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)msgctrl_widgets[(signed long int)type].pane[(signed long int)pane].ptr, return_value_gtk_toggle_button_get_type$9);
      msgctrl_widgets[(signed long int)type].pane[(signed long int)pane].state=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$10);
    }
  }
}

// recenter_virtual_map_view
// file mapdata.c line 1099
static void recenter_virtual_map_view(signed int diff_x, signed int diff_y)
{
  signed int new_x;
  signed int new_y;
  signed int shift_x;
  signed int shift_y;
  signed int src_x;
  signed int src_y;
  signed int dst_x;
  signed int dst_y;
  signed int len_x;
  signed int len_y;
  signed int sx;
  signed int recenter_virtual_map_view$$1$$dx;
  signed int i;
  new_x = pl_pos.x + diff_x;
  new_y = pl_pos.y + diff_y;
  if(!(new_x >= 16))
    shift_x = (128 + 16) - new_x;

  else
    if(64 + new_x >= 513)
      shift_x = ((512 - 128) - 64) - new_x;

    else
      shift_x = 0;
  if(!(new_y >= 16))
    shift_y = (128 + 16) - new_y;

  else
    if(64 + new_y >= 513)
      shift_y = ((512 - 128) - 64) - new_y;

    else
      shift_y = 0;
  if(!(shift_x == 0) || !(shift_y == 0))
  {
    if(shift_x == 0)
    {
      if(!(new_x >= 16))
        shift_x = (128 + 16) - new_x;

      else
        if(64 + new_x >= 513)
          shift_x = ((512 - 128) - 64) - new_x;

    }

    if(shift_y == 0)
    {
      if(!(new_y >= 16))
        shift_y = (128 + 16) - new_y;

      else
        if(64 + new_y >= 513)
          shift_y = ((512 - 128) - 64) - new_y;

    }

    if(shift_x >= 512 || shift_y >= 512 || !(shift_x >= -511) || !(shift_y >= -511))
    {
      recenter_virtual_map_view$$1$$dx = 0;
      for( ; !(recenter_virtual_map_view$$1$$dx >= 512); recenter_virtual_map_view$$1$$dx = recenter_virtual_map_view$$1$$dx + 1)
        do
        {
          signed int recenter_virtual_map_view$$1$$10$$1$$1$$1$$clear_cells_i;
          signed int recenter_virtual_map_view$$1$$10$$1$$1$$1$$j;
          memset((void *)&the_map.cells[(signed long int)recenter_virtual_map_view$$1$$dx][(signed long int)0], 0, sizeof(struct MapCell) /*222ul*/  * (unsigned long int)512);
          recenter_virtual_map_view$$1$$10$$1$$1$$1$$clear_cells_i = 0;
          for( ; !(recenter_virtual_map_view$$1$$10$$1$$1$$1$$clear_cells_i >= 512); recenter_virtual_map_view$$1$$10$$1$$1$$1$$clear_cells_i = recenter_virtual_map_view$$1$$10$$1$$1$$1$$clear_cells_i + 1)
          {
            recenter_virtual_map_view$$1$$10$$1$$1$$1$$j = 0;
            for( ; !(recenter_virtual_map_view$$1$$10$$1$$1$$1$$j >= 10); recenter_virtual_map_view$$1$$10$$1$$1$$1$$j = recenter_virtual_map_view$$1$$10$$1$$1$$1$$j + 1)
            {
              (the_map.cells[(signed long int)recenter_virtual_map_view$$1$$dx] + (signed long int)(0 + recenter_virtual_map_view$$1$$10$$1$$1$$1$$clear_cells_i))->heads[(signed long int)recenter_virtual_map_view$$1$$10$$1$$1$$1$$j].size_x = (signed char)1;
              (the_map.cells[(signed long int)recenter_virtual_map_view$$1$$dx] + (signed long int)(0 + recenter_virtual_map_view$$1$$10$$1$$1$$1$$clear_cells_i))->heads[(signed long int)recenter_virtual_map_view$$1$$10$$1$$1$$1$$j].size_y = (signed char)1;
            }
          }
        }
        while((_Bool)0);
      pl_pos.x = 512 / 2 - width$link1 / 2;
      pl_pos.y = 512 / 2 - height$link1 / 2;
    }

    else
    {
      pl_pos.x = pl_pos.x + shift_x;
      pl_pos.y = pl_pos.y + shift_y;
      if(!(shift_x >= 0))
      {
        src_x = -shift_x;
        dst_x = 0;
        len_x = 512 + shift_x;
      }

      else
      {
        src_x = 0;
        dst_x = shift_x;
        len_x = 512 - shift_x;
      }
      if(!(shift_y >= 0))
      {
        src_y = -shift_y;
        dst_y = 0;
        len_y = 512 + shift_y;
      }

      else
      {
        src_y = 0;
        dst_y = shift_y;
        len_y = 512 - shift_y;
      }
      if(!(shift_x >= 0))
      {
        sx = src_x;
        recenter_virtual_map_view$$1$$dx = dst_x;
        i = 0;
        for( ; !(i >= len_x); i = i + 1)
        {
          memcpy((void *)&the_map.cells[(signed long int)recenter_virtual_map_view$$1$$dx][(signed long int)dst_y], (const void *)&the_map.cells[(signed long int)sx][(signed long int)src_y], (unsigned long int)len_y * sizeof(struct MapCell) /*222ul*/ );
          sx = sx + 1;
          recenter_virtual_map_view$$1$$dx = recenter_virtual_map_view$$1$$dx + 1;
        }
      }

      else
        if(shift_x >= 1)
        {
          sx = (src_x + len_x) - 1;
          recenter_virtual_map_view$$1$$dx = (dst_x + len_x) - 1;
          i = 0;
          for( ; !(i >= len_x); i = i + 1)
          {
            memcpy((void *)&the_map.cells[(signed long int)recenter_virtual_map_view$$1$$dx][(signed long int)dst_y], (const void *)&the_map.cells[(signed long int)sx][(signed long int)src_y], (unsigned long int)len_y * sizeof(struct MapCell) /*222ul*/ );
            sx = sx - 1;
            recenter_virtual_map_view$$1$$dx = recenter_virtual_map_view$$1$$dx - 1;
          }
        }

        else
        {
          /* assertion src_x == dst_x */
          assert(src_x == dst_x);
          recenter_virtual_map_view$$1$$dx = src_x;
          i = 0;
          for( ; !(i >= len_x); i = i + 1)
          {
            memmove((void *)&the_map.cells[(signed long int)recenter_virtual_map_view$$1$$dx][(signed long int)dst_y], (const void *)&the_map.cells[(signed long int)recenter_virtual_map_view$$1$$dx][(signed long int)src_y], (unsigned long int)len_y * sizeof(struct MapCell) /*222ul*/ );
            recenter_virtual_map_view$$1$$dx = recenter_virtual_map_view$$1$$dx + 1;
          }
        }
      recenter_virtual_map_view$$1$$dx = 0;
      for( ; !(recenter_virtual_map_view$$1$$dx >= dst_x); recenter_virtual_map_view$$1$$dx = recenter_virtual_map_view$$1$$dx + 1)
        do
        {
          signed int recenter_virtual_map_view$$1$$18$$1$$1$$clear_cells_i;
          signed int j;
          memset((void *)&the_map.cells[(signed long int)recenter_virtual_map_view$$1$$dx][(signed long int)0], 0, sizeof(struct MapCell) /*222ul*/  * (unsigned long int)512);
          recenter_virtual_map_view$$1$$18$$1$$1$$clear_cells_i = 0;
          for( ; !(recenter_virtual_map_view$$1$$18$$1$$1$$clear_cells_i >= 512); recenter_virtual_map_view$$1$$18$$1$$1$$clear_cells_i = recenter_virtual_map_view$$1$$18$$1$$1$$clear_cells_i + 1)
          {
            j = 0;
            for( ; !(j >= 10); j = j + 1)
            {
              (the_map.cells[(signed long int)recenter_virtual_map_view$$1$$dx] + (signed long int)(0 + recenter_virtual_map_view$$1$$18$$1$$1$$clear_cells_i))->heads[(signed long int)j].size_x = (signed char)1;
              (the_map.cells[(signed long int)recenter_virtual_map_view$$1$$dx] + (signed long int)(0 + recenter_virtual_map_view$$1$$18$$1$$1$$clear_cells_i))->heads[(signed long int)j].size_y = (signed char)1;
            }
          }
        }
        while((_Bool)0);
      recenter_virtual_map_view$$1$$dx = dst_x + len_x;
      for( ; !(recenter_virtual_map_view$$1$$dx >= 512); recenter_virtual_map_view$$1$$dx = recenter_virtual_map_view$$1$$dx + 1)
        do
        {
          signed int clear_cells_i;
          signed int recenter_virtual_map_view$$1$$19$$1$$1$$j;
          memset((void *)&the_map.cells[(signed long int)recenter_virtual_map_view$$1$$dx][(signed long int)0], 0, sizeof(struct MapCell) /*222ul*/  * (unsigned long int)512);
          clear_cells_i = 0;
          for( ; !(clear_cells_i >= 512); clear_cells_i = clear_cells_i + 1)
          {
            recenter_virtual_map_view$$1$$19$$1$$1$$j = 0;
            for( ; !(recenter_virtual_map_view$$1$$19$$1$$1$$j >= 10); recenter_virtual_map_view$$1$$19$$1$$1$$j = recenter_virtual_map_view$$1$$19$$1$$1$$j + 1)
            {
              (the_map.cells[(signed long int)recenter_virtual_map_view$$1$$dx] + (signed long int)(0 + clear_cells_i))->heads[(signed long int)recenter_virtual_map_view$$1$$19$$1$$1$$j].size_x = (signed char)1;
              (the_map.cells[(signed long int)recenter_virtual_map_view$$1$$dx] + (signed long int)(0 + clear_cells_i))->heads[(signed long int)recenter_virtual_map_view$$1$$19$$1$$1$$j].size_y = (signed char)1;
            }
          }
        }
        while((_Bool)0);
      if(shift_y >= 1)
      {
        recenter_virtual_map_view$$1$$dx = 0;
        for( ; !(recenter_virtual_map_view$$1$$dx >= len_x); recenter_virtual_map_view$$1$$dx = recenter_virtual_map_view$$1$$dx + 1)
          do
          {
            signed int recenter_virtual_map_view$$1$$20$$1$$1$$1$$clear_cells_i;
            signed int recenter_virtual_map_view$$1$$20$$1$$1$$1$$j;
            memset((void *)&the_map.cells[(signed long int)(recenter_virtual_map_view$$1$$dx + dst_x)][(signed long int)0], 0, sizeof(struct MapCell) /*222ul*/  * (unsigned long int)shift_y);
            recenter_virtual_map_view$$1$$20$$1$$1$$1$$clear_cells_i = 0;
            for( ; !(recenter_virtual_map_view$$1$$20$$1$$1$$1$$clear_cells_i >= shift_y); recenter_virtual_map_view$$1$$20$$1$$1$$1$$clear_cells_i = recenter_virtual_map_view$$1$$20$$1$$1$$1$$clear_cells_i + 1)
            {
              recenter_virtual_map_view$$1$$20$$1$$1$$1$$j = 0;
              for( ; !(recenter_virtual_map_view$$1$$20$$1$$1$$1$$j >= 10); recenter_virtual_map_view$$1$$20$$1$$1$$1$$j = recenter_virtual_map_view$$1$$20$$1$$1$$1$$j + 1)
              {
                (the_map.cells[(signed long int)(recenter_virtual_map_view$$1$$dx + dst_x)] + (signed long int)(0 + recenter_virtual_map_view$$1$$20$$1$$1$$1$$clear_cells_i))->heads[(signed long int)recenter_virtual_map_view$$1$$20$$1$$1$$1$$j].size_x = (signed char)1;
                (the_map.cells[(signed long int)(recenter_virtual_map_view$$1$$dx + dst_x)] + (signed long int)(0 + recenter_virtual_map_view$$1$$20$$1$$1$$1$$clear_cells_i))->heads[(signed long int)recenter_virtual_map_view$$1$$20$$1$$1$$1$$j].size_y = (signed char)1;
              }
            }
          }
          while((_Bool)0);
      }

      else
        if(!(shift_y >= 0))
        {
          recenter_virtual_map_view$$1$$dx = 0;
          for( ; !(recenter_virtual_map_view$$1$$dx >= len_x); recenter_virtual_map_view$$1$$dx = recenter_virtual_map_view$$1$$dx + 1)
            do
            {
              signed int recenter_virtual_map_view$$1$$21$$1$$1$$1$$clear_cells_i;
              signed int recenter_virtual_map_view$$1$$21$$1$$1$$1$$j;
              memset((void *)&the_map.cells[(signed long int)(recenter_virtual_map_view$$1$$dx + dst_x)][(signed long int)(512 + shift_y)], 0, sizeof(struct MapCell) /*222ul*/  * (unsigned long int)-shift_y);
              recenter_virtual_map_view$$1$$21$$1$$1$$1$$clear_cells_i = 0;
              for( ; !(recenter_virtual_map_view$$1$$21$$1$$1$$1$$clear_cells_i >= -shift_y); recenter_virtual_map_view$$1$$21$$1$$1$$1$$clear_cells_i = recenter_virtual_map_view$$1$$21$$1$$1$$1$$clear_cells_i + 1)
              {
                recenter_virtual_map_view$$1$$21$$1$$1$$1$$j = 0;
                for( ; !(recenter_virtual_map_view$$1$$21$$1$$1$$1$$j >= 10); recenter_virtual_map_view$$1$$21$$1$$1$$1$$j = recenter_virtual_map_view$$1$$21$$1$$1$$1$$j + 1)
                {
                  (the_map.cells[(signed long int)(recenter_virtual_map_view$$1$$dx + dst_x)] + (signed long int)(512 + shift_y + recenter_virtual_map_view$$1$$21$$1$$1$$1$$clear_cells_i))->heads[(signed long int)recenter_virtual_map_view$$1$$21$$1$$1$$1$$j].size_x = (signed char)1;
                  (the_map.cells[(signed long int)(recenter_virtual_map_view$$1$$dx + dst_x)] + (signed long int)(512 + shift_y + recenter_virtual_map_view$$1$$21$$1$$1$$1$$clear_cells_i))->heads[(signed long int)recenter_virtual_map_view$$1$$21$$1$$1$$1$$j].size_y = (signed char)1;
                }
              }
            }
            while((_Bool)0);
        }

    }
  }

}

// remove_item
// file ./proto.h line 66
void remove_item(struct item_struct *op)
{
  if(!(op == ((struct item_struct *)NULL)) && !(op == map) && !(op == player))
  {
    item_event_item_deleting(op);
    op->env->inv_updated = (unsigned short int)1;
    if(!(op->inv == ((struct item_struct *)NULL)))
    {
      if(!(op == cpl.container))
        remove_item_inventory(op);

    }

    if(!(op->prev == ((struct item_struct *)NULL)))
      op->prev->next = op->next;

    else
      op->env->inv = op->next;
    if(!(op->next == ((struct item_struct *)NULL)))
      op->next->prev = op->prev;

    if(!(cpl.container == op))
    {
      op->next = free_items;
      if(!(op->next == ((struct item_struct *)NULL)))
        op->next->prev = op;

      free_items = op;
      op->prev = (struct item_struct *)(void *)0;
      op->env = (struct item_struct *)(void *)0;
      op->tag = 0;
      strncpy(op->d_name, "", (unsigned long int)(128 - 1));
      op->d_name[(signed long int)(128 - 1)] = (char)0;
      strncpy(op->s_name, "", (unsigned long int)(128 - 1));
      op->s_name[(signed long int)(128 - 1)] = (char)0;
      strncpy(op->p_name, "", (unsigned long int)(128 - 1));
      op->p_name[(signed long int)(128 - 1)] = (char)0;
      op->inv = (struct item_struct *)(void *)0;
      op->env = (struct item_struct *)(void *)0;
      op->tag = 0;
      op->face = (signed short int)0;
      op->weight = (float)0;
      op->damned = (unsigned short int)0;
      op->cursed = (unsigned short int)op->damned;
      op->magical = (unsigned short int)op->cursed;
      op->applied = (unsigned short int)0;
      op->locked = (unsigned short int)op->applied;
      op->unpaid = (unsigned short int)op->locked;
      op->flagsval = (unsigned int)0;
      op->animation_id = (unsigned short int)0;
      op->last_anim = (unsigned short int)0;
      op->anim_state = (unsigned char)0;
      op->nrof = (unsigned int)0;
      op->open = (unsigned short int)0;
      op->type = (unsigned short int)30000;
    }

  }

}

// remove_item_inventory
// file ../../common/proto.h line 67
void remove_item_inventory(struct item_struct *op)
{
  if(!(op == ((struct item_struct *)NULL)))
  {
    item_event_container_clearing(op);
    op->inv_updated = (unsigned short int)1;
    while(!(op->inv == ((struct item_struct *)NULL)))
      remove_item(op->inv);
  }

}

// replace_chars_with_string
// file misc.c line 49
void replace_chars_with_string(char *buffer, const unsigned short int buffer_size, const char find, const char *replace)
{
  unsigned short int buffer_len;
  unsigned short int expand;
  unsigned short int i;
  unsigned short int replace_len;
  unsigned short int replace_limit;
  unsigned short int template_len;
  char *template;
  replace_limit = (unsigned short int)((signed int)buffer_size - 1);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(replace);
  replace_len = (unsigned short int)return_value_strlen$1;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(buffer);
  template_len = (unsigned short int)return_value_strlen$2;
  template=strdup(buffer);
  buffer[(signed long int)0] = (char)0;
  buffer_len = (unsigned short int)0;
  i = (unsigned short int)0;
  unsigned short int tmp_post$3;
  for( ; (signed int)template_len >= (signed int)i; i = i + 1)
  {
    expand = (unsigned short int)((signed int)buffer_len + (signed int)replace_len < (signed int)replace_limit ? (signed int)replace_len : 1);
    if(buffer_len == replace_limit && (signed int)expand == 1)
      break;

    if(!(template[(signed long int)i] == find) || (signed int)expand == 1 && (signed int)replace_len >= 2)
    {
      tmp_post$3 = buffer_len;
      buffer_len = buffer_len + 1;
      buffer[(signed long int)tmp_post$3] = template[(signed long int)i];
      buffer[(signed long int)buffer_len] = (char)0;
      goto __CPROVER_DUMP_L4;
    }

    strcat(buffer, replace);
    buffer_len = buffer_len + replace_len;

  __CPROVER_DUMP_L4:
    ;
  }
  free((void *)template);
}

// requestface
// file image.c line 415
void requestface(signed int pnum, char *facename)
{
  face_info.cache_misses = face_info.cache_misses + 1;
  facetoname[(signed long int)pnum]=strdup_local(facename);
  cs_print_string(csocket.fd, "askface %d", pnum);
}

// rescale_rgba_data
// file png.c line 262
unsigned char * rescale_rgba_data(unsigned char *data, signed int *width, signed int *height, signed int scale)
{
  signed int new_width = (*width * scale) / 100;
  signed int new_height = (*height * scale) / 100;
  signed int sourcerow = 0;
  signed int ytoleft;
  signed int ytofill;
  signed int xtoleft;
  signed int xtofill;
  signed int dest_column = 0;
  signed int source_column = 0;
  signed int needcol;
  signed int destrow = 0;
  signed int x;
  signed int y;
  unsigned char *ndata;
  unsigned char r;
  unsigned char g;
  unsigned char b;
  unsigned char a;
  _Bool tmp_if_expr$1;
  if(*width >= 1025 || new_width >= 1025)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = *height > 1024 ? (_Bool)1 : (_Bool)0;
  if(new_height >= 1025 || tmp_if_expr$1)
  {
    LOG((enum LogLevel)LOG_CRITICAL, "gtk-v2::rescale_rgba_data", "Image too big");
    exit(0);
  }

  static signed int yrow[4096l];
  memset((void *)yrow, 0, sizeof(signed int) /*4ul*/  * (unsigned long int)*height * (unsigned long int)4);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)(new_width * new_height * 4));
  ndata = (unsigned char *)return_value_malloc$2;
  y = 0;
  static unsigned char *nrows[1024l];
  for( ; !(y >= new_height); y = y + 1)
    nrows[(signed long int)y] = (unsigned char *)(ndata + (signed long int)(y * new_width * 4));
  ytoleft = scale;
  ytofill = 100;
  y = 0;
  sourcerow = 0;
  for( ; !(y >= new_height); y = y + 1)
  {
    static signed int xrow[4096l];
    memset((void *)xrow, 0, sizeof(signed int) /*4ul*/  * (unsigned long int)*width * (unsigned long int)4);
    while(!(ytoleft >= ytofill))
    {
      x = 0;
      for( ; !(x >= *width); x = x + 1)
      {
        if((signed int)data[(signed long int)((*width * sourcerow + x) * 4 + 3)] >= 1)
        {
          yrow[(signed long int)(x * 4)] = yrow[(signed long int)(x * 4)] + (ytoleft * (signed int)data[(signed long int)((sourcerow * *width + x) * 4)]) / 100;
          yrow[(signed long int)(x * 4 + 1)] = yrow[(signed long int)(x * 4 + 1)] + (ytoleft * (signed int)data[(signed long int)((sourcerow * *width + x) * 4 + 1)]) / 100;
          yrow[(signed long int)(x * 4 + 2)] = yrow[(signed long int)(x * 4 + 2)] + (ytoleft * (signed int)data[(signed long int)((sourcerow * *width + x) * 4 + 2)]) / 100;
        }

        if(!(yrow[(signed long int)(4 * x + 3)] >= (signed int)data[(signed long int)((*width * sourcerow + x) * 4 + 3)]))
          yrow[(signed long int)(x * 4 + 3)] = (signed int)data[(signed long int)((sourcerow * *width + x) * 4 + 3)];

      }
      ytofill = ytofill - ytoleft;
      ytoleft = scale;
      if(!(sourcerow >= *height))
        sourcerow = sourcerow + 1;

    }
    x = 0;
    for( ; !(x >= *width); x = x + 1)
    {
      if((signed int)data[(signed long int)((*width * sourcerow + x) * 4 + 3)] >= 1)
      {
        xrow[(signed long int)(x * 4)] = yrow[(signed long int)(x * 4)] + (ytofill * (signed int)data[(signed long int)((sourcerow * *width + x) * 4)]) / 100;
        xrow[(signed long int)(x * 4 + 1)] = yrow[(signed long int)(x * 4 + 1)] + (ytofill * (signed int)data[(signed long int)((sourcerow * *width + x) * 4 + 1)]) / 100;
        xrow[(signed long int)(x * 4 + 2)] = yrow[(signed long int)(x * 4 + 2)] + (ytofill * (signed int)data[(signed long int)((sourcerow * *width + x) * 4 + 2)]) / 100;
      }

      if(!(xrow[(signed long int)(4 * x + 3)] >= (signed int)data[(signed long int)((*width * sourcerow + x) * 4 + 3)]))
        xrow[(signed long int)(x * 4 + 3)] = (signed int)data[(signed long int)((sourcerow * *width + x) * 4 + 3)];

      yrow[(signed long int)(x * 4)] = 0;
      yrow[(signed long int)(x * 4 + 1)] = 0;
      yrow[(signed long int)(x * 4 + 2)] = 0;
      yrow[(signed long int)(x * 4 + 3)] = 0;
    }
    ytoleft = ytoleft - ytofill;
    if(!(ytoleft >= 1))
    {
      ytoleft = scale;
      if(!(sourcerow >= *height))
        sourcerow = sourcerow + 1;

    }

    ytofill = 100;
    xtofill = 100;
    dest_column = 0;
    source_column = 0;
    needcol = 0;
    r = (unsigned char)0;
    g = (unsigned char)0;
    b = (unsigned char)0;
    a = (unsigned char)0;
    x = 0;
    for( ; !(x >= *width); x = x + 1)
    {
      xtoleft = scale;
      for( ; xtoleft >= xtofill; needcol = 1)
      {
        if(!(needcol == 0))
        {
          dest_column = dest_column + 1;
          r = (unsigned char)0;
          g = (unsigned char)0;
          b = (unsigned char)0;
          a = (unsigned char)0;
        }

        if(xrow[(signed long int)(4 * source_column + 3)] >= 1)
        {
          r = r + (unsigned char)((xtofill * xrow[(signed long int)(source_column * 4)]) / 100);
          g = g + (unsigned char)((xtofill * xrow[(signed long int)(1 + source_column * 4)]) / 100);
          b = b + (unsigned char)((xtofill * xrow[(signed long int)(2 + source_column * 4)]) / 100);
        }

        if(!((signed int)a >= xrow[(signed long int)(4 * source_column + 3)]))
          a = (unsigned char)xrow[(signed long int)(3 + source_column * 4)];

        nrows[(signed long int)destrow][(signed long int)(dest_column * 4)] = r;
        nrows[(signed long int)destrow][(signed long int)(1 + dest_column * 4)] = g;
        nrows[(signed long int)destrow][(signed long int)(2 + dest_column * 4)] = b;
        nrows[(signed long int)destrow][(signed long int)(3 + dest_column * 4)] = a;
        xtoleft = xtoleft - xtofill;
        xtofill = 100;
      }
      if(xtoleft >= 1)
      {
        if(!(needcol == 0))
        {
          dest_column = dest_column + 1;
          r = (unsigned char)0;
          g = (unsigned char)0;
          b = (unsigned char)0;
          a = (unsigned char)0;
          needcol = 0;
        }

        if(xrow[(signed long int)(4 * source_column + 3)] >= 1)
        {
          r = r + (unsigned char)((xtoleft * xrow[(signed long int)(source_column * 4)]) / 100);
          g = g + (unsigned char)((xtoleft * xrow[(signed long int)(1 + source_column * 4)]) / 100);
          b = b + (unsigned char)((xtoleft * xrow[(signed long int)(2 + source_column * 4)]) / 100);
        }

        if(!((signed int)a >= xrow[(signed long int)(4 * source_column + 3)]))
          a = (unsigned char)xrow[(signed long int)(3 + source_column * 4)];

        xtofill = xtofill - xtoleft;
      }

      source_column = source_column + 1;
    }
    if(xtofill >= 1)
    {
      source_column = source_column - 1;
      if(xrow[(signed long int)(4 * source_column + 3)] >= 1)
      {
        r = r + (unsigned char)((xtofill * xrow[(signed long int)(source_column * 4)]) / 100);
        g = g + (unsigned char)((xtofill * xrow[(signed long int)(1 + source_column * 4)]) / 100);
        b = b + (unsigned char)((xtofill * xrow[(signed long int)(2 + source_column * 4)]) / 100);
      }

      if(!((signed int)a >= xrow[(signed long int)(4 * source_column + 3)]))
        a = (unsigned char)xrow[(signed long int)(3 + source_column * 4)];

    }

    if(needcol == 0 && !(dest_column >= new_width))
    {
      nrows[(signed long int)destrow][(signed long int)(dest_column * 4)] = r;
      nrows[(signed long int)destrow][(signed long int)(1 + dest_column * 4)] = g;
      nrows[(signed long int)destrow][(signed long int)(2 + dest_column * 4)] = b;
      nrows[(signed long int)destrow][(signed long int)(3 + dest_column * 4)] = a;
    }

    destrow = destrow + 1;
  }
  *width = new_width;
  *height = new_height;
  return ndata;
}

// reset_client_vars
// file ../../common/proto.h line 59
void reset_client_vars(void)
{
  signed int i;
  cpl.count_left = (unsigned short int)0;
  cpl.container = (struct item_struct *)(void *)0;
  memset((void *)&cpl.stats, 0, sizeof(struct Stat_struct) /*632ul*/ );
  cpl.stats.maxsp = (signed short int)1;
  cpl.stats.maxhp = (signed short int)1;
  cpl.stats.maxgrace = (signed short int)1;
  cpl.stats.speed = 1;
  cpl.input_text[(signed long int)0] = (char)0;
  cpl.title[(signed long int)0] = (char)0;
  cpl.range[(signed long int)0] = (char)0;
  cpl.last_command[(signed long int)0] = (char)0;
  i = 0;
  for( ; !(i >= 8); i = i + 1)
    cpl.ranges[(signed long int)i] = (struct item_struct *)(void *)0;
  cpl.magicmap = (unsigned char *)(void *)0;
  cpl.showmagic = (unsigned char)0;
  csocket.command_sent = 0;
  csocket.command_received = 0;
  csocket.command_time = 0;
  face_info.faceset = (unsigned char)0;
  face_info.num_images = (signed short int)0;
  face_info.old_bmaps_checksum = face_info.bmaps_checksum;
  face_info.bmaps_checksum = (unsigned int)0;
  face_info.cache_hits = (signed short int)0;
  face_info.cache_misses = (signed short int)0;
  face_info.have_faceset_info = (unsigned char)0;
  i = 0;
  for( ; !(i >= 20); i = i + 1)
  {
    free((void *)face_info.facesets[(signed long int)i].prefix);
    face_info.facesets[(signed long int)i].prefix = (char *)(void *)0;
    free((void *)face_info.facesets[(signed long int)i].fullname);
    face_info.facesets[(signed long int)i].fullname = (char *)(void *)0;
    face_info.facesets[(signed long int)i].fallback = (unsigned char)0;
    free((void *)face_info.facesets[(signed long int)i].size);
    face_info.facesets[(signed long int)i].size = (char *)(void *)0;
    free((void *)face_info.facesets[(signed long int)i].extension);
    face_info.facesets[(signed long int)i].extension = (char *)(void *)0;
    free((void *)face_info.facesets[(signed long int)i].comment);
    face_info.facesets[(signed long int)i].comment = (char *)(void *)0;
  }
  reset_player_data();
  i = 0;
  for( ; !(i >= 50); i = i + 1)
  {
    free((void *)skill_names[(signed long int)i]);
    skill_names[(signed long int)i] = (char *)(void *)0;
  }
  if(!(motd == ((char *)NULL)))
  {
    free((void *)motd);
    motd = (char *)(void *)0;
  }

  if(!(news == ((char *)NULL)))
  {
    free((void *)news);
    news = (char *)(void *)0;
  }

  if(!(rules == ((char *)NULL)))
  {
    free((void *)rules);
    rules = (char *)(void *)0;
  }

  if(!(races == ((struct Race_Class_Info *)NULL)))
  {
    free_all_race_class_info(races, num_races);
    num_races = 0;
    used_races = 0;
    races = (struct Race_Class_Info *)(void *)0;
  }

  if(!(classes == ((struct Race_Class_Info *)NULL)))
  {
    free_all_race_class_info(classes, num_classes);
    num_classes = 0;
    used_classes = 0;
    classes = (struct Race_Class_Info *)(void *)0;
  }

  stat_points = 0;
  stat_min = 0;
  stat_maximum = 0;
  serverloginmethod = 0;
}

// reset_image_cache_data
// file ../../common/proto.h line 47
void reset_image_cache_data(void)
{
  signed int i;
  if(!(want_config[5l] == 0))
  {
    i = 1;
    for( ; !(i >= 10000); i = i + 1)
    {
      free((void *)facetoname[(signed long int)i]);
      facetoname[(signed long int)i] = (char *)(void *)0;
    }
  }

}

// reset_image_data
// file image.c line 459
extern void reset_image_data(void)
{
  signed int i;
  reset_image_cache_data();
  i = 1;
  for( ; !(i >= 10000); i = i + 1)
    if(want_config[5l] == 0)
    {
      if(!(pixmaps[(signed long int)i] == pixmaps[0l]))
      {
        free_pixmap(pixmaps[(signed long int)i]);
        free((void *)pixmaps[(signed long int)i]);
        pixmaps[(signed long int)i] = pixmaps[(signed long int)0];
      }

    }

}

// reset_keybinding_status
// file keys.c line 2534
extern void reset_keybinding_status(void)
{
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_any, return_value_gtk_toggle_button_get_type$1);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2, 0);
  unsigned long int return_value_gtk_toggle_button_get_type$3;
  return_value_gtk_toggle_button_get_type$3=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_control, return_value_gtk_toggle_button_get_type$3);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$4, 0);
  unsigned long int return_value_gtk_toggle_button_get_type$5;
  return_value_gtk_toggle_button_get_type$5=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_shift, return_value_gtk_toggle_button_get_type$5);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$6, 0);
  unsigned long int return_value_gtk_toggle_button_get_type$7;
  return_value_gtk_toggle_button_get_type$7=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_alt, return_value_gtk_toggle_button_get_type$7);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$8, 0);
  unsigned long int return_value_gtk_toggle_button_get_type$9;
  return_value_gtk_toggle_button_get_type$9=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_meta, return_value_gtk_toggle_button_get_type$9);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$10, 0);
  unsigned long int return_value_gtk_toggle_button_get_type$11;
  return_value_gtk_toggle_button_get_type$11=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_checkbutton_edit, return_value_gtk_toggle_button_get_type$11);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$12, 0);
  unsigned long int return_value_gtk_entry_get_type$13;
  return_value_gtk_entry_get_type$13=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_entry_key, return_value_gtk_entry_get_type$13);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$14, "");
  unsigned long int return_value_gtk_entry_get_type$15;
  return_value_gtk_entry_get_type$15=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)keybinding_entry_command, return_value_gtk_entry_get_type$15);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$16, "");
  toggle_buttons_scope(0);
  gtk_widget_set_sensitive(keybinding_button_remove, 0);
  gtk_widget_set_sensitive(keybinding_button_update, 0);
}

// reset_map
// file gtk2proto.h line 154
extern void reset_map(void)
{
  ;
}

// reset_player_data
// file ./proto.h line 58
void reset_player_data(void)
{
  signed int i = 0;
  for( ; !(i >= 50); i = i + 1)
  {
    cpl.stats.skill_exp[(signed long int)i] = (signed long int)0;
    cpl.stats.skill_level[(signed long int)i] = (signed short int)0;
  }
}

// resize_map_window
// file map.c line 569
extern void resize_map_window(signed int x, signed int y)
{
  gdk_window_clear(map_drawing_area->window);
  draw_map((signed int)!(0 != 0));
}

// rgba_to_gdkpixbuf
// file png.c line 514
signed int rgba_to_gdkpixbuf(unsigned char *data, signed int width, signed int height, struct _GdkPixbuf **pix)
{
  signed int rowstride;
  unsigned char *pixels;
  unsigned char *p;
  signed int x;
  signed int y;
  *pix=gdk_pixbuf_new((enum anonymous$63)GDK_COLORSPACE_RGB, (signed int)!(0 != 0), 8, width, height);
  rowstride=gdk_pixbuf_get_rowstride(*pix);
  pixels=gdk_pixbuf_get_pixels(*pix);
  y = 0;
  for( ; !(y >= height); y = y + 1)
  {
    x = 0;
    for( ; !(x >= width); x = x + 1)
    {
      p = pixels + (signed long int)(y * rowstride) + (signed long int)(x * 4);
      p[(signed long int)0] = data[(signed long int)(4 * (x + y * width))];
      p[(signed long int)1] = data[(signed long int)(4 * (x + y * width) + 1)];
      p[(signed long int)2] = data[(signed long int)(4 * (x + y * width) + 2)];
      p[(signed long int)3] = data[(signed long int)(4 * (x + y * width) + 3)];
    }
  }
  return 0;
}

// rgba_to_gdkpixmap
// file png.c line 455
signed int rgba_to_gdkpixmap(struct _GdkDrawable *window, unsigned char *data, signed int width, signed int height, struct _GdkDrawable **pix, struct _GdkDrawable **mask, struct _GdkColormap *colormap)
{
  struct _GdkGC *gc;
  struct _GdkGC *gc_alpha;
  signed int has_alpha = 0;
  signed int alpha;
  struct _GdkColor scolor;
  signed int x;
  signed int y;
  *pix=gdk_pixmap_new(window, width, height, -1);
  gc=gdk_gc_new(*pix);
  gdk_gc_set_function(gc, (enum anonymous$65)GDK_COPY);
  *mask=gdk_pixmap_new(window, width, height, 1);
  gc_alpha=gdk_gc_new(*mask);
  scolor.pixel = (unsigned int)1;
  gdk_gc_set_foreground(gc_alpha, &scolor);
  gdk_draw_rectangle(*mask, gc_alpha, 1, 0, 0, width, height);
  scolor.pixel = (unsigned int)0;
  gdk_gc_set_foreground(gc_alpha, &scolor);
  y = 0;
  for( ; !(y >= height); y = y + 1)
  {
    x = 0;
    for( ; !(x >= width); x = x + 1)
    {
      alpha = (signed int)data[(signed long int)((y * width + x) * 4 + 3)];
      if(alpha == 0)
      {
        gdk_draw_point(*mask, gc_alpha, x, y);
        has_alpha = 1;
      }

    }
  }
  gdk_draw_rgb_32_image(*pix, gc, 0, 0, width, height, (enum anonymous$15)GDK_RGB_DITHER_NONE, data, width * 4);
  if(has_alpha == 0)
  {
    g_object_unref((void *)*mask);
    *mask = (struct _GdkDrawable *)(void *)0;
  }

  g_object_unref((void *)gc_alpha);
  g_object_unref((void *)gc);
  return 0;
}

// run_dir
// file ../../common/proto.h line 147
void run_dir(signed int dir)
{
  char buf[256l];
  if(!(dir == drun))
  {
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "run %d", dir);
    signed int return_value_send_command$1;
    return_value_send_command$1=send_command(buf, -1, 0);
    if(!(return_value_send_command$1 == 0))
      drun = dir;

  }

  else
    drun = drun & 0xff;
}

// save_defaults
// file config.c line 450
extern void save_defaults(void)
{
  char path[256l];
  char buf[256l];
  struct _IO_FILE *fp;
  signed int i;
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("HOME");
  snprintf(path, sizeof(char [256l]) /*256ul*/ , "%s/.crossfire/gdefaults2", return_value_getenv$1);
  signed int return_value_make_path_to_file$2;
  return_value_make_path_to_file$2=make_path_to_file(path);
  if(return_value_make_path_to_file$2 == -1)
    LOG((enum LogLevel)LOG_ERROR, "config.c::save_defaults", "Could not create %s", (const void *)path);

  else
  {
    fp=fopen(path, "w");
    if(fp == ((struct _IO_FILE *)NULL))
      LOG((enum LogLevel)LOG_ERROR, "config.c::save_defaults", "Could not open %s", (const void *)path);

    else
    {
      fprintf(fp, "# crossfire-client-gtk2 automatically generates this file.\n");
      fprintf(fp, "# Manual editing is allowed, but the client may be a bit\n");
      fprintf(fp, "# finicky about the keys and values.  Comparisons are case\n");
      fprintf(fp, "# sensitive.  'True' and 'False' are the proper case, but\n");
      fprintf(fp, "# have been replaced with 1 and 0 respectively.\n#\n");
      fprintf(fp, "theme: %s\n", theme);
      fprintf(fp, "faceset: %s\n", face_info.want_faceset);
      fprintf(fp, "window_layout: %s\n", (const void *)window_xml_file);
      i = 1;
      for( ; !(i >= 32); i = i + 1)
        fprintf(fp, "%s: %d\n", config_names[(signed long int)i], want_config[(signed long int)i]);
      fclose(fp);
      snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Client configuration saved!");
      draw_ext_info(5, 20, 1, buf);
    }
  }
}

// save_individual_key
// file keys.c line 1256
static void save_individual_key(struct _IO_FILE *fp, struct keybind *kb, unsigned char kc)
{
  while(!(kb == ((struct keybind *)NULL)))
  {
    char *return_value_get_key_info$1;
    return_value_get_key_info$1=get_key_info(kb, 1);
    fprintf(fp, "%s\n", return_value_get_key_info$1);
    kb = kb->next;
  }
}

// save_keys
// file keys.c line 1270
static void save_keys(void)
{
  char buf[256l];
  char buf2[256l];
  signed int i;
  struct _IO_FILE *fp;
  if(!(cpl.name == ((char *)NULL)))
  {
    char *return_value_getenv$1;
    return_value_getenv$1=getenv("HOME");
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%s/.crossfire/%s.%s.keys", return_value_getenv$1, csocket.servername, cpl.name);
    LOG((enum LogLevel)LOG_INFO, "gtk-v2::save_keys", "Saving character specific keybindings to %s", (const void *)buf);
    signed int return_value_make_path_to_file$2;
    return_value_make_path_to_file$2=make_path_to_file(buf);
    if(return_value_make_path_to_file$2 == -1)
      LOG((enum LogLevel)LOG_WARNING, "gtk-v2::save_keys", "Could not create %s", (const void *)buf);

    fp=fopen(buf, "w");
    if(fp == ((struct _IO_FILE *)NULL))
    {
      snprintf(buf2, sizeof(char [256l]) /*256ul*/ , "Could not open %s, character bindings not saved\n", (const void *)buf);
      draw_ext_info(0, 20, 9, buf2);
    }

    else
    {
      i = 0;
      for( ; !(i >= 257); i = i + 1)
        save_individual_key(fp, keys_char[(signed long int)i], (unsigned char)0);
      fclose(fp);
    }
  }

  char *return_value_getenv$3;
  return_value_getenv$3=getenv("HOME");
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%s/.crossfire/keys", return_value_getenv$3);
  LOG((enum LogLevel)LOG_INFO, "gtk-v2::save_keys", "Saving global user's keybindings to %s", (const void *)buf);
  signed int return_value_make_path_to_file$15;
  return_value_make_path_to_file$15=make_path_to_file(buf);
  char *return_value_gdk_keyval_name$4;
  char *return_value_gdk_keyval_name$5;
  char *return_value_gdk_keyval_name$6;
  char *return_value_gdk_keyval_name$7;
  char *return_value_gdk_keyval_name$8;
  char *return_value_gdk_keyval_name$9;
  char *return_value_gdk_keyval_name$10;
  char *return_value_gdk_keyval_name$11;
  char *return_value_gdk_keyval_name$12;
  char *return_value_gdk_keyval_name$13;
  char *return_value_gdk_keyval_name$14;
  if(return_value_make_path_to_file$15 == -1)
    LOG((enum LogLevel)LOG_WARNING, "gtk-v2::save_keys", "Could not create %s", (const void *)buf);

  else
  {
    fp=fopen(buf, "w");
    if(fp == ((struct _IO_FILE *)NULL))
    {
      snprintf(buf2, sizeof(char [256l]) /*256ul*/ , "Could not open %s, global key bindings not saved\n", (const void *)buf);
      draw_ext_info(0, 20, 9, buf2);
    }

    else
    {
      if(!(firekeysym[0l] == 65505u))
      {
        if(!((signed long int)firekeysym[0l] == 0L))
        {
          return_value_gdk_keyval_name$4=gdk_keyval_name(firekeysym[(signed long int)0]);
          fprintf(fp, "! firekey0 %s %d\n", return_value_gdk_keyval_name$4, 0);
        }

      }

      if(!(firekeysym[1l] == 65506u))
      {
        if(!((signed long int)firekeysym[1l] == 0L))
        {
          return_value_gdk_keyval_name$5=gdk_keyval_name(firekeysym[(signed long int)1]);
          fprintf(fp, "! firekey1 %s %d\n", return_value_gdk_keyval_name$5, 0);
        }

      }

      if(!(metakeysym[0l] == 65505u))
      {
        if(!((signed long int)metakeysym[0l] == 0L))
        {
          return_value_gdk_keyval_name$6=gdk_keyval_name(metakeysym[(signed long int)0]);
          fprintf(fp, "! metakey0 %s %d\n", return_value_gdk_keyval_name$6, 0);
        }

      }

      if(!(metakeysym[1l] == 65506u))
      {
        if(!((signed long int)metakeysym[1l] == 0L))
        {
          return_value_gdk_keyval_name$7=gdk_keyval_name(metakeysym[(signed long int)1]);
          fprintf(fp, "! metakey1 %s %d\n", return_value_gdk_keyval_name$7, 0);
        }

      }

      if(!(altkeysym[0l] == 65505u))
      {
        if(!((signed long int)altkeysym[0l] == 0L))
        {
          return_value_gdk_keyval_name$8=gdk_keyval_name(altkeysym[(signed long int)0]);
          fprintf(fp, "! altkey0 %s %d\n", return_value_gdk_keyval_name$8, 0);
        }

      }

      if(!(altkeysym[1l] == 65506u))
      {
        if(!((signed long int)altkeysym[1l] == 0L))
        {
          return_value_gdk_keyval_name$9=gdk_keyval_name(altkeysym[(signed long int)1]);
          fprintf(fp, "! altkey1 %s %d\n", return_value_gdk_keyval_name$9, 0);
        }

      }

      if(!(runkeysym[0l] == 65507u))
      {
        if(!((signed long int)runkeysym[0l] == 0L))
        {
          return_value_gdk_keyval_name$10=gdk_keyval_name(runkeysym[(signed long int)0]);
          fprintf(fp, "! runkey0 %s %d\n", return_value_gdk_keyval_name$10, 0);
        }

      }

      if(!(runkeysym[1l] == 65508u))
      {
        if(!((signed long int)runkeysym[1l] == 0L))
        {
          return_value_gdk_keyval_name$11=gdk_keyval_name(runkeysym[(signed long int)1]);
          fprintf(fp, "! runkey1 %s %d\n", return_value_gdk_keyval_name$11, 0);
        }

      }

      if(!(completekeysym == 65289u) && !((signed long int)completekeysym == 0L))
      {
        return_value_gdk_keyval_name$12=gdk_keyval_name(completekeysym);
        fprintf(fp, "! completekey %s %d\n", return_value_gdk_keyval_name$12, 0);
      }

      if(!((signed long int)nextkeysym == 0L))
      {
        return_value_gdk_keyval_name$13=gdk_keyval_name(nextkeysym);
        fprintf(fp, "! nextkey %s %d\n", return_value_gdk_keyval_name$13, 0);
      }

      if(!((signed long int)prevkeysym == 0L))
      {
        return_value_gdk_keyval_name$14=gdk_keyval_name(prevkeysym);
        fprintf(fp, "! prevkey %s %d\n", return_value_gdk_keyval_name$14, 0);
      }

      i = 0;
      for( ; !(i >= 257); i = i + 1)
        save_individual_key(fp, keys_global[(signed long int)i], (unsigned char)0);
      fclose(fp);
    }
  }
  draw_ext_info(0, 20, 1, "Key bindings saved.");
}

// save_msgctrl_configuration
// file info.c line 1520
extern void save_msgctrl_configuration(void)
{
  char pathbuf[256l];
  char textbuf[256l];
  struct _IO_FILE *fptr;
  unsigned int pane;
  unsigned int type;
  read_msgctrl_configuration();
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("HOME");
  snprintf(pathbuf, sizeof(char [256l]) /*256ul*/ , "%s/.crossfire/msgs", return_value_getenv$1);
  signed int return_value_make_path_to_file$2;
  return_value_make_path_to_file$2=make_path_to_file(pathbuf);
  if(return_value_make_path_to_file$2 == -1)
  {
    LOG((enum LogLevel)LOG_WARNING, "gtk-v2::save_msgctrl_configuration", "Error creating %s", (const void *)pathbuf);
    snprintf(textbuf, sizeof(char [256l]) /*256ul*/ , "Error creating %s, Message Control settings not saved.", (const void *)pathbuf);
    draw_ext_info(3, 20, 9, textbuf);
  }

  else
  {
    fptr=fopen(pathbuf, "w");
    if(fptr == ((struct _IO_FILE *)NULL))
    {
      snprintf(textbuf, sizeof(char [256l]) /*256ul*/ , "Error opening %s, Message Control settings not saved.", (const void *)pathbuf);
      draw_ext_info(3, 20, 9, textbuf);
    }

    else
    {
      fprintf(fptr, "# Message Control System Configuration\n");
      fprintf(fptr, "#\n");
      fprintf(fptr, "# Count:  1-96\n");
      fprintf(fptr, "#\n");
      fprintf(fptr, "C %u\n", buffer_control.count.state);
      fprintf(fptr, "#\n");
      fprintf(fptr, "# Timer:  1-96 (8 ~= one second)\n");
      fprintf(fptr, "#\n");
      fprintf(fptr, "T %u\n", buffer_control.timer.state);
      fprintf(fptr, "#\n");
      fprintf(fptr, "# type, buffer, pane[0], pane[1]...\n");
      fprintf(fptr, "# Do not edit the 'type' field.\n");
      fprintf(fptr, "# 0 == disable; 1 == enable.\n");
      fprintf(fptr, "#\n");
      type = (unsigned int)0;
      for( ; !(type >= 20u); type = type + (unsigned int)1)
      {
        fprintf(fptr, "M %02d %d ", type + (unsigned int)1, msgctrl_widgets[(signed long int)type].buffer.state);
        pane = (unsigned int)0;
        for( ; !(pane >= 2u); pane = pane + (unsigned int)1)
          fprintf(fptr, "%d ", msgctrl_widgets[(signed long int)type].pane[(signed long int)pane].state);
        fprintf(fptr, "\n");
      }
      fprintf(fptr, "#\n# End of Message Control System Configuration\n");
      fclose(fptr);
      LOG((enum LogLevel)LOG_DEBUG, "gtk-v2::save_msgctrl_configuration", "Message control settings saved to '%s'", (const void *)pathbuf);
      snprintf(textbuf, sizeof(char [256l]) /*256ul*/ , "Message control settings saved!");
      draw_ext_info(5, 20, 1, textbuf);
    }
  }
}

// save_winpos
// file config.c line 1094
extern void save_winpos(void)
{
  struct _IO_FILE *file;
  struct _GSList *pane_list;
  struct _GSList *list_loop;
  char *cp;
  char buf[256l];
  char savename[256l];
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  signed int wx;
  signed int wy;
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%s", (const void *)window_xml_file);
  cp=strrchr(buf, 46);
  if(!(cp == ((char *)NULL)))
    cp[(signed long int)0] = (char)0;

  char *return_value_getenv$1;
  return_value_getenv$1=getenv("HOME");
  snprintf(savename, sizeof(char [256l]) /*256ul*/ , "%s/.crossfire/%s.pos", return_value_getenv$1, (const void *)buf);
  file=fopen(savename, "w");
  _Bool tmp_if_expr$8;
  unsigned long int return_value_gtk_vpaned_get_type$7;
  if(file == ((struct _IO_FILE *)NULL))
  {
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Cannot open %s - window positions not saved!", (const void *)savename);
    draw_ext_info(3, 20, 9, buf);
  }

  else
  {
    get_window_coord(window_root, &x, &y, &wx, &wy, &w, &h);
    fprintf(file, "window_root: +%d+%dx%dx%d\n", wx, wy, w, h);
    pane_list=gtk_builder_get_objects(window_xml);
    list_loop = pane_list;
    for( ; !(list_loop == ((struct _GSList *)NULL)); list_loop = list_loop->next)
    {
      unsigned long int type = ((struct _GTypeClass *)((struct _GTypeInstance *)list_loop->data)->g_class)->g_type;
      unsigned long int return_value_gtk_hpaned_get_type$6;
      return_value_gtk_hpaned_get_type$6=gtk_hpaned_get_type();
      if(type == return_value_gtk_hpaned_get_type$6)
        tmp_if_expr$8 = (_Bool)1;

      else
      {
        return_value_gtk_vpaned_get_type$7=gtk_vpaned_get_type();
        tmp_if_expr$8 = type == return_value_gtk_vpaned_get_type$7 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$8)
      {
        const char *return_value_gtk_buildable_get_name$2;
        return_value_gtk_buildable_get_name$2=gtk_buildable_get_name((struct _GtkBuildable *)list_loop->data);
        unsigned long int return_value_gtk_paned_get_type$3;
        return_value_gtk_paned_get_type$3=gtk_paned_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
        return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)list_loop->data, return_value_gtk_paned_get_type$3);
        signed int return_value_gtk_paned_get_position$5;
        return_value_gtk_paned_get_position$5=gtk_paned_get_position((struct _GtkPaned *)return_value_g_type_check_instance_cast$4);
        fprintf(file, "%s: %d\n", return_value_gtk_buildable_get_name$2, return_value_gtk_paned_get_position$5);
      }

    }
    g_slist_free(pane_list);
    fclose(file);
    draw_ext_info(5, 20, 1, "Window positions saved!");
  }
}

// scandir_theme_filter
// file config.c line 589
static signed int scandir_theme_filter(struct dirent *d)
{
  if((signed int)d->d_name[0l] == 46)
    return 0;

  else
    return 1;
}

// scandir_ui_filter
// file config.c line 607
static signed int scandir_ui_filter(struct dirent *d)
{
  char *token = (char *)(void *)0;
  char *extok = (char *)(void *)0;
  char delim[2l] = { '.', 0 };
  char exten[3l] = { 'u', 'i', 0 };
  char parse[256l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  strncpy(parse, d->d_name, (unsigned long int)256);
  token=strtok(parse, delim);
  while(!(token == ((char *)NULL)))
  {
    extok = token;
    token=strtok((char *)(void *)0, delim);
  }
  unsigned long int return_value_strlen$3;
  signed int return_value_strncmp$4;
  if(!(extok == ((char *)NULL)))
  {
    return_value_strlen$3=strlen(exten);
    return_value_strncmp$4=strncmp(exten, extok, return_value_strlen$3);
    if(return_value_strncmp$4 == 0)
    {
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(parse);
      signed int return_value_strncmp$2;
      return_value_strncmp$2=strncmp(parse, "dialogs.ui", return_value_strlen$1);
      if(return_value_strncmp$2 == 0)
        return 0;

      return 1;
    }

  }

  return 0;
}

// script_by_name
// file script.c line 989
static signed int script_by_name(const char *name)
{
  signed int i;
  signed int l;
  if(name == ((const char *)NULL))
    return num_scripts == 1 ? 0 : -1;

  else
  {
    const unsigned short int **return_value___ctype_b_loc$1;
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if(!((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*name]) == 0))
    {
      i=atoi(name);
      i = i - 1;
      if(!(i >= 0) || i >= num_scripts)
        goto __CPROVER_DUMP_L2;

      return i;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      l = 0;
      for( ; !(name[(signed long int)l] == 0); l = l + 1)
        if((signed int)name[(signed long int)l] == 32)
          break;

      i = 0;
      for( ; !(i >= num_scripts); i = i + 1)
      {
        signed int return_value_strncmp$2;
        return_value_strncmp$2=strncmp(name, (scripts + (signed long int)i)->name, (unsigned long int)l);
        if(return_value_strncmp$2 == 0)
          return i;

      }
      return -1;
    }
  }
}

// script_dead
// file script.c line 1020
static void script_dead(signed int i)
{
  signed int w;
  close((scripts + (signed long int)i)->in_fd);
  close((scripts + (signed long int)i)->out_fd);
  free((void *)(scripts + (signed long int)i)->name);
  free((void *)(scripts + (signed long int)i)->params);
  w = 0;
  for( ; !(w >= (scripts + (signed long int)i)->num_watch); w = w + 1)
    free((void *)(scripts + (signed long int)i)->watch[(signed long int)w]);
  free((void *)(scripts + (signed long int)i)->watch);
  waitpid(-1, (signed int *)(void *)0, 1);
  if(!(i >= num_scripts + -1))
    memmove((void *)&scripts[(signed long int)i], (const void *)&scripts[(signed long int)(i + 1)], sizeof(struct script) /*1080ul*/  * (unsigned long int)((num_scripts - i) - 1));

  num_scripts = num_scripts - 1;
}

// script_fdset
// file ../../common/script.h line 60
void script_fdset(signed int *maxfd, struct anonymous$51 *set)
{
  signed int i = 0;
  for( ; !(i >= num_scripts); i = i + 1)
  {
    set->fds_bits[(signed long int)((scripts + (signed long int)i)->in_fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = set->fds_bits[(signed long int)((scripts + (signed long int)i)->in_fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << (scripts + (signed long int)i)->in_fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    if((scripts + (signed long int)i)->in_fd >= *maxfd)
      *maxfd = (scripts + (signed long int)i)->in_fd + 1;

  }
}

// script_init
// file ./script.h line 53
void script_init(const char *cparams)
{
  signed int pipe1[2l];
  signed int pipe2[2l];
  signed int pid;
  char *name;
  char *args;
  char params[256l];
  char *tmp_post$1;
  signed int tmp_post$4;
  char *tmp_post$5;
  char *tmp_if_expr$13;
  char *return_value_strdup$12;
  if(cparams == ((const char *)NULL))
    draw_ext_info(3, 20, 8, "Please specify a script to start. For help, type 'help script'.");

  else
  {
    strncpy(params, cparams, (unsigned long int)(256 - 1));
    params[(signed long int)(256 - 1)] = (char)0;
    name = params;
    args = name;
    for( ; !(*args == 0); args = args + 1l)
      if((signed int)*args == 32)
        break;

    for( ; !(*args == 0); *tmp_post$1 = (char)0)
    {
      if(!((signed int)*args == 32))
        break;

      tmp_post$1 = args;
      args = args + 1l;
    }
    if((signed int)*args == 0)
      args = (char *)(void *)0;

    signed int return_value_pipe$2;
    return_value_pipe$2=pipe(pipe1);
    if(!(return_value_pipe$2 == 0))
      draw_ext_info(3, 20, 8, "Unable to start script--pipe failed");

    else
    {
      signed int return_value_pipe$3;
      return_value_pipe$3=pipe(pipe2);
      if(!(return_value_pipe$3 == 0))
      {
        close(pipe1[(signed long int)0]);
        close(pipe1[(signed long int)1]);
        draw_ext_info(3, 20, 8, "Unable to start script--pipe failed");
      }

      else
      {
        pid=fork();
        if(pid == -1)
        {
          close(pipe1[(signed long int)0]);
          close(pipe1[(signed long int)1]);
          close(pipe2[(signed long int)0]);
          close(pipe2[(signed long int)1]);
          draw_ext_info(3, 20, 8, "Unable to start script--fork failed");
        }

        else
        {
          if(pid == 0)
          {
            signed int i;
            signed int r;
            char *argv[256l];
            argv[(signed long int)0] = name;
            i = 1;
            while(!(args == ((char *)NULL)))
            {
              if(*args == 0)
                break;

              if((unsigned long int)i >= 255ul)
                break;

              tmp_post$4 = i;
              i = i + 1;
              argv[(signed long int)tmp_post$4] = args;
              for( ; !(*args == 0); args = args + 1l)
                if((signed int)*args == 32)
                  break;

              for( ; !(*args == 0); *tmp_post$5 = (char)0)
              {
                if(!((signed int)*args == 32))
                  break;

                tmp_post$5 = args;
                args = args + 1l;
              }
            }
            argv[(signed long int)i] = (char *)(void *)0;
            r=dup2(pipe1[(signed long int)0], 0);
            if(!(r == 0))
              fprintf(stderr, "Script Child: Failed to set pipe1 as stdin\n");

            r=dup2(pipe2[(signed long int)1], 1);
            if(!(r == 1))
              fprintf(stderr, "Script Child: Failed to set pipe2 as stdout\n");

            i = 3;
            for( ; !(i >= 100); i = i + 1)
              close(i);
            r=execvp(argv[(signed long int)0], argv);
            if(!(r == -1))
              printf("draw %d Script child: no error, but no execvp().\n", 3);

            else
            {
              signed int *return_value___errno_location$6;
              return_value___errno_location$6=__errno_location();
              char *return_value_strerror$7;
              return_value_strerror$7=strerror(*return_value___errno_location$6);
              printf("draw %d Script child failed to start: %s\n", 3, return_value_strerror$7);
            }
            exit(1);
          }

          close(pipe1[(signed long int)0]);
          close(pipe2[(signed long int)1]);
          signed int return_value_fcntl$8;
          return_value_fcntl$8=fcntl(pipe1[(signed long int)1], 4, 04000);
          if(return_value_fcntl$8 == -1)
            LOG((enum LogLevel)LOG_WARNING, "common::script_init", "Error on fcntl.");

          void *return_value_realloc$9;
          return_value_realloc$9=realloc((void *)scripts, sizeof(struct script) /*1080ul*/  * (unsigned long int)(num_scripts + 1));
          scripts = (struct script *)return_value_realloc$9;
          if(scripts == ((struct script *)NULL))
          {
            signed int *return_value___errno_location$10;
            return_value___errno_location$10=__errno_location();
            char *return_value_strerror$11;
            return_value_strerror$11=strerror(*return_value___errno_location$10);
            LOG((enum LogLevel)LOG_ERROR, "script_init", "Could not allocate memory: %s", return_value_strerror$11);
            exit(1);
          }

          (scripts + (signed long int)num_scripts)->name=strdup(name);
          if(!(args == ((char *)NULL)))
          {
            return_value_strdup$12=strdup(args);
            tmp_if_expr$13 = return_value_strdup$12;
          }

          else
            tmp_if_expr$13 = (char *)(void *)0;
          (scripts + (signed long int)num_scripts)->params = tmp_if_expr$13;
          (scripts + (signed long int)num_scripts)->out_fd = pipe1[(signed long int)1];
          (scripts + (signed long int)num_scripts)->in_fd = pipe2[(signed long int)0];
          (scripts + (signed long int)num_scripts)->monitor = 0;
          (scripts + (signed long int)num_scripts)->num_watch = 0;
          (scripts + (signed long int)num_scripts)->watch = (char **)(void *)0;
          (scripts + (signed long int)num_scripts)->cmd_count = 0;
          (scripts + (signed long int)num_scripts)->pid = pid;
          (scripts + (signed long int)num_scripts)->sync_watch = -1;
          num_scripts = num_scripts + 1;
        }
      }
    }
  }
}

// script_kill
// file ./script.h line 56
void script_kill(const char *params)
{
  signed int i;
  i=script_by_name(params);
  if(i >= num_scripts || !(i >= 0))
    draw_ext_info(0, 20, 8, "No such running script");

  else
  {
    kill((scripts + (signed long int)i)->pid, 1);
    draw_ext_info(3, 20, 8, "Killed script.");
    script_dead(i);
  }
}

// script_list
// file ./script.h line 54
void script_list(void)
{
  if(num_scripts == 0)
    draw_ext_info(0, 20, 8, "No scripts are currently running");

  else
  {
    signed int i;
    char buf[1024l];
    snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%d scripts currently running:", num_scripts);
    draw_ext_info(0, 20, 8, buf);
    i = 0;
    for( ; !(i >= num_scripts); i = i + 1)
    {
      if(!((scripts + (signed long int)i)->params == ((char *)NULL)))
        snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%d %s  %s", i + 1, (scripts + (signed long int)i)->name, (scripts + (signed long int)i)->params);

      else
        snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%d %s", i + 1, (scripts + (signed long int)i)->name);
      draw_ext_info(0, 20, 8, buf);
    }
  }
}

// script_lua_command
// file ./proto.h line 157
signed int script_lua_command(const char *command, const char *param)
{
  signed int script;
  struct lua_State *lua;
  signed int ret = 0;
  script = 0;
  for( ; !(script >= script_count); script = script + 1)
  {
    lua = (scripts$link1 + (signed long int)script)->state;
    lua_pushstring(lua, "event_command");
    lua_gettable(lua, -10002);
    signed int return_value_lua_gettop$3;
    return_value_lua_gettop$3=lua_gettop(lua);
    signed int return_value_lua_type$4;
    return_value_lua_type$4=lua_type(lua, return_value_lua_gettop$3);
    if(return_value_lua_type$4 == 6)
    {
      signed int luaerror;
      update_player(lua);
      update_inv(lua);
      update_ground(lua);
      lua_pushstring(lua, command);
      lua_pushstring(lua, param != ((const char *)NULL) ? param : "");
      luaerror=lua_pcall(lua, 2, 1, 0);
      if(!(luaerror == 0))
      {
        const char *what;
        signed int return_value_lua_gettop$1;
        return_value_lua_gettop$1=lua_gettop(lua);
        what=lua_tolstring(lua, return_value_lua_gettop$1, (unsigned long int *)(void *)0);
        draw_ext_info(3, 20, 8, what);
        lua_settop(lua, -1 - 1);
      }

      else
      {
        double return_value_lua_tonumber$2;
        return_value_lua_tonumber$2=lua_tonumber(lua, 1);
        ret = (signed int)return_value_lua_tonumber$2;
        lua_settop(lua, -1 - 1);
      }
    }

    else
      lua_settop(lua, -1 - 1);
  }
  return ret;
}

// script_lua_kill
// file ./proto.h line 155
void script_lua_kill(const char *param)
{
  signed int i;
  signed int return_value_atoi$1;
  return_value_atoi$1=atoi(param);
  i = return_value_atoi$1 - 1;
  if(i >= script_count || !(i >= 0))
    draw_ext_info(0, 20, 8, "Invalid script index!");

  else
  {
    lua_close((scripts$link1 + (signed long int)i)->state);
    if(!(i >= script_count + -1))
      memmove((void *)&scripts$link1[(signed long int)i], (const void *)&scripts$link1[(signed long int)(i + 1)], sizeof(struct script_state) /*16ul*/  * (unsigned long int)((script_count - i) - 1));

    script_count = script_count - 1;
  }
}

// script_lua_list
// file ./proto.h line 154
void script_lua_list(const char *param)
{
  if(script_count == 0)
    draw_ext_info(0, 20, 8, "No LUA scripts are currently running");

  else
  {
    signed int i;
    char buf[1024l];
    snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%d LUA scripts currently running:", script_count);
    draw_ext_info(0, 20, 8, buf);
    i = 0;
    for( ; !(i >= script_count); i = i + 1)
    {
      snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "%d %s", i + 1, (scripts$link1 + (signed long int)i)->filename);
      draw_ext_info(0, 20, 8, buf);
    }
  }
}

// script_lua_load
// file ./proto.h line 153
void script_lua_load(const char *name)
{
  struct lua_State *lua;
  struct _IO_FILE *file;
  signed int load;
  signed int index = script_count;
  file=fopen(name, "r");
  if(file == ((struct _IO_FILE *)NULL))
    draw_ext_info(3, 20, 8, "Invalid file");

  else
  {
    lua=luaL_newstate();
    if(lua == ((struct lua_State *)NULL))
    {
      draw_ext_info(3, 20, 8, "Memory allocation error.");
      fclose(file);
    }

    else
    {
      luaopen_base(lua);
      lua_settop(lua, -1 - 1);
      luaopen_table(lua);
      lua_settop(lua, -1 - 1);
      load=lua_load(lua, l_readerfile, (void *)file, name);
      if(!(load == 0))
      {
        draw_ext_info(3, 20, 8, "Load error!");
        if(load == 3)
          draw_ext_info(3, 20, 8, "Syntax error!");

        fclose(file);
        lua_close(lua);
      }

      else
      {
        fclose(file);
        lua_pushcclosure(lua, lua_draw, 0);
        lua_setfield(lua, -10002, "cfdraw");
        lua_pushcclosure(lua, lua_issue, 0);
        lua_setfield(lua, -10002, "cfissue");
        lua_pushstring(lua, "player");
        lua_createtable(lua, 0, 0);
        lua_settable(lua, -10002);
        update_player(lua);
        update_inv(lua);
        update_ground(lua);
        signed int return_value_lua_pcall$1;
        return_value_lua_pcall$1=lua_pcall(lua, 0, 0, 0);
        if(!(return_value_lua_pcall$1 == 0))
        {
          draw_ext_info(3, 20, 8, "Init error!");
          lua_close(lua);
        }

        else
        {
          void *return_value_realloc$2;
          return_value_realloc$2=realloc((void *)scripts$link1, sizeof(struct script_state) /*16ul*/  * (unsigned long int)(script_count + 1));
          scripts$link1 = (struct script_state *)return_value_realloc$2;
          if(scripts$link1 == ((struct script_state *)NULL))
          {
            signed int *return_value___errno_location$3;
            return_value___errno_location$3=__errno_location();
            char *return_value_strerror$4;
            return_value_strerror$4=strerror(*return_value___errno_location$3);
            LOG((enum LogLevel)LOG_ERROR, "script_lua_load", "Could not allocate memory: %s", return_value_strerror$4);
            exit(1);
          }

          script_count = script_count + 1;
          (scripts$link1 + (signed long int)index)->filename=strdup_local(name);
          (scripts$link1 + (signed long int)index)->state = lua;
        }
      }
    }
  }
}

// script_lua_stats
// file ./proto.h line 156
void script_lua_stats(void)
{
  signed int script;
  struct lua_State *lua;
  script = 0;
  for( ; !(script >= script_count); script = script + 1)
  {
    lua = (scripts$link1 + (signed long int)script)->state;
    lua_pushstring(lua, "event_stats");
    lua_gettable(lua, -10002);
    signed int return_value_lua_gettop$2;
    return_value_lua_gettop$2=lua_gettop(lua);
    signed int return_value_lua_type$3;
    return_value_lua_type$3=lua_type(lua, return_value_lua_gettop$2);
    if(return_value_lua_type$3 == 6)
    {
      signed int luaerror;
      update_player(lua);
      update_inv(lua);
      update_ground(lua);
      luaerror=lua_pcall(lua, 0, 0, 0);
      if(!(luaerror == 0))
      {
        const char *what;
        signed int return_value_lua_gettop$1;
        return_value_lua_gettop$1=lua_gettop(lua);
        what=lua_tolstring(lua, return_value_lua_gettop$1, (unsigned long int *)(void *)0);
        draw_ext_info(3, 20, 8, what);
        lua_settop(lua, -1 - 1);
      }

    }

    else
      lua_settop(lua, -1 - 1);
  }
}

// script_monitor
// file ./script.h line 63
void script_monitor(const char *command, signed int repeat, signed int must_send)
{
  signed int i = 0;
  for( ; !(i >= num_scripts); i = i + 1)
    if(!((scripts + (signed long int)i)->monitor == 0))
    {
      char buf[1024l];
      snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "monitor %d %d %s\n", repeat, must_send, command);
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(buf);
      write((scripts + (signed long int)i)->out_fd, (const void *)buf, return_value_strlen$1);
    }

}

// script_monitor_str
// file ./script.h line 64
void script_monitor_str(const char *command)
{
  signed int i = 0;
  for( ; !(i >= num_scripts); i = i + 1)
    if(!((scripts + (signed long int)i)->monitor == 0))
    {
      char buf[1024l];
      snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "monitor %s\n", command);
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(buf);
      write((scripts + (signed long int)i)->out_fd, (const void *)buf, return_value_strlen$1);
    }

}

// script_process
// file ../../common/script.h line 61
void script_process(struct anonymous$51 *set)
{
  signed int i;
  signed int r;
  i = 0;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  char *return_value_strchr$4;
  for( ; !(i >= num_scripts); i = i + 1)
    if(!((set->fds_bits[(signed long int)((scripts + (signed long int)i)->in_fd / 8)] & (signed long int)(1UL << (scripts + (signed long int)i)->in_fd % 8)) == 0l))
    {
      signed long int return_value_read$1;
      return_value_read$1=read((scripts + (signed long int)i)->in_fd, (void *)((scripts + (signed long int)i)->cmd + (signed long int)(scripts + (signed long int)i)->cmd_count), (sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)(scripts + (signed long int)i)->cmd_count) - (unsigned long int)1);
      r = (signed int)return_value_read$1;
      if(r >= 1)
        (scripts + (signed long int)i)->cmd_count = (scripts + (signed long int)i)->cmd_count + r;

      else
      {
        if(r == 0)
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          return_value___errno_location$2=__errno_location();
          tmp_if_expr$3 = *return_value___errno_location$2 == 9 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$3)
        {
          script_dead(i);
          goto __CPROVER_DUMP_L11;
        }

      }
      (scripts + (signed long int)i)->cmd[(signed long int)(scripts + (signed long int)i)->cmd_count] = (char)0;
      for( ; (_Bool)1; (scripts + (signed long int)i)->cmd[(signed long int)(scripts + (signed long int)i)->cmd_count] = (char)0)
      {
        if(!((unsigned long int)(scripts + (signed long int)i)->cmd_count == 1023ul))
        {
          return_value_strchr$4=strchr((scripts + (signed long int)i)->cmd, 10);
          if(return_value_strchr$4 == ((char *)NULL))
            goto __CPROVER_DUMP_L8;

        }

        script_process_cmd(i);
      }

    __CPROVER_DUMP_L8:
      ;
      goto __CPROVER_DUMP_L11;
    }


__CPROVER_DUMP_L11:
  ;
}

// script_process_cmd
// file script.c line 1076
static void script_process_cmd(signed int i)
{
  char cmd[1024l];
  char *c;
  signed int l = 0;
  for( ; !(l >= (scripts + (signed long int)i)->cmd_count); l = l + 1)
    if((signed int)(scripts + (signed long int)i)->cmd[(signed long int)l] == 10)
      break;

  l = l + 1;
  memcpy((void *)cmd, (const void *)(scripts + (signed long int)i)->cmd, (unsigned long int)l);
  cmd[(signed long int)(l - 1)] = (char)0;
  if(!(l >= (scripts + (signed long int)i)->cmd_count))
  {
    memmove((void *)(scripts + (signed long int)i)->cmd, (const void *)((scripts + (signed long int)i)->cmd + (signed long int)l), (unsigned long int)((scripts + (signed long int)i)->cmd_count - l));
    (scripts + (signed long int)i)->cmd_count = (scripts + (signed long int)i)->cmd_count - l;
  }

  else
    (scripts + (signed long int)i)->cmd_count = 0;
  signed int return_value_strncmp$69;
  return_value_strncmp$69=strncmp(cmd, "sync", (unsigned long int)4);
  signed int return_value_strncmp$68;
  signed int return_value_strncmp$67;
  signed int return_value_strncmp$66;
  signed int return_value_strncmp$48;
  signed int return_value_strncmp$47;
  signed int return_value_strncmp$46;
  signed int return_value_strncmp$19;
  signed int return_value_strncmp$18;
  signed int return_value_strncmp$17;
  signed int return_value_strncmp$16;
  signed int return_value_strncmp$15;
  signed int return_value_strncmp$45;
  signed int return_value_strncmp$44;
  signed int return_value_strncmp$43;
  signed int return_value_strncmp$35;
  signed int return_value_strncmp$34;
  const unsigned short int **return_value___ctype_b_loc$32;
  const unsigned short int **return_value___ctype_b_loc$33;
  signed int return_value_strncmp$42;
  signed int return_value_strncmp$41;
  signed int return_value_strncmp$65;
  _Bool tmp_if_expr$58;
  const unsigned short int **return_value___ctype_b_loc$56;
  _Bool tmp_if_expr$57;
  const unsigned short int **return_value___ctype_b_loc$50;
  const unsigned short int **return_value___ctype_b_loc$51;
  signed int return_value_strncmp$54;
  const unsigned short int **return_value___ctype_b_loc$52;
  const unsigned short int **return_value___ctype_b_loc$53;
  signed int return_value_strncmp$64;
  signed int return_value_strncmp$63;
  const unsigned short int **return_value___ctype_b_loc$60;
  signed int return_value_strncmp$62;
  signed int return_value_strncmp$61;
  if(return_value_strncmp$69 == 0)
  {
    c = cmd + (signed long int)4;
    for( ; !(*c == 0); c = c + 1l)
      if((signed int)*c == 32)
        break;

    for( ; (signed int)*c == 32; c = c + 1l)
      ;
    (scripts + (signed long int)i)->sync_watch = -1;
    const unsigned short int **return_value___ctype_b_loc$1;
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if(!((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)*c]) == 0))
      (scripts + (signed long int)i)->sync_watch=atoi(c);

    script_sync(csocket.command_sent - csocket.command_received);
  }

  else
  {
    return_value_strncmp$68=strncmp(cmd, "watch", (unsigned long int)5);
    if(return_value_strncmp$68 == 0)
    {
      c = cmd + (signed long int)5;
      for( ; !(*c == 0); c = c + 1l)
        if((signed int)*c == 32)
          break;

      for( ; (signed int)*c == 32; c = c + 1l)
        ;
      c=strdup(c);
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)(scripts + (signed long int)i)->watch, (unsigned long int)((scripts + (signed long int)i)->num_watch + 1) * sizeof(char *) /*8ul*/ );
      (scripts + (signed long int)i)->watch = (char **)return_value_realloc$2;
      (scripts + (signed long int)i)->watch[(signed long int)(scripts + (signed long int)i)->num_watch] = c;
      (scripts + (signed long int)i)->num_watch = (scripts + (signed long int)i)->num_watch + 1;
    }

    else
    {
      return_value_strncmp$67=strncmp(cmd, "unwatch", (unsigned long int)7);
      if(return_value_strncmp$67 == 0)
      {
        signed int w;
        c = cmd + (signed long int)7;
        for( ; !(*c == 0); c = c + 1l)
          if((signed int)*c == 32)
            break;

        for( ; (signed int)*c == 32; c = c + 1l)
          ;
        w = 0;
        for( ; !(w >= (scripts + (signed long int)i)->num_watch); w = w + 1)
        {
          signed int return_value_strcmp$3;
          return_value_strcmp$3=strcmp(c, (scripts + (signed long int)i)->watch[(signed long int)w]);
          if(return_value_strcmp$3 == 0)
          {
            free((void *)(scripts + (signed long int)i)->watch[(signed long int)w]);
            for( ; !(1 + w >= (scripts + (signed long int)i)->num_watch); w = w + 1)
              (scripts + (signed long int)i)->watch[(signed long int)w] = (scripts + (signed long int)i)->watch[(signed long int)(w + 1)];
            (scripts + (signed long int)i)->num_watch = (scripts + (signed long int)i)->num_watch - 1;
            break;
          }

        }
      }

      else
      {
        return_value_strncmp$66=strncmp(cmd, "request", (unsigned long int)7);
        if(return_value_strncmp$66 == 0)
        {
          c = cmd + (signed long int)7;
          for( ; !(*c == 0); c = c + 1l)
            if((signed int)*c == 32)
              break;

          for( ; (signed int)*c == 32; c = c + 1l)
            ;
          if(*c == 0)
            goto __CPROVER_DUMP_L150;

          signed int return_value_strncmp$49;
          return_value_strncmp$49=strncmp(c, "player", (unsigned long int)6);
          if(return_value_strncmp$49 == 0)
          {
            char script_process_cmd$$1$$7$$4$$buf[1024l];
            snprintf(script_process_cmd$$1$$7$$4$$buf, sizeof(char [1024l]) /*1024ul*/ , "request player %d %s\n", cpl.ob->tag, (const void *)cpl.title);
            unsigned long int return_value_strlen$4;
            return_value_strlen$4=strlen(script_process_cmd$$1$$7$$4$$buf);
            write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$4$$buf, return_value_strlen$4);
          }

          else
          {
            return_value_strncmp$48=strncmp(c, "range", (unsigned long int)5);
            if(return_value_strncmp$48 == 0)
            {
              char script_process_cmd$$1$$7$$5$$buf[1024l];
              snprintf(script_process_cmd$$1$$7$$5$$buf, sizeof(char [1024l]) /*1024ul*/ , "request range %s\n", (const void *)cpl.range);
              unsigned long int return_value_strlen$5;
              return_value_strlen$5=strlen(script_process_cmd$$1$$7$$5$$buf);
              write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$5$$buf, return_value_strlen$5);
            }

            else
            {
              return_value_strncmp$47=strncmp(c, "weight", (unsigned long int)5);
              if(return_value_strncmp$47 == 0)
              {
                char script_process_cmd$$1$$7$$6$$buf[1024l];
                snprintf(script_process_cmd$$1$$7$$6$$buf, sizeof(char [1024l]) /*1024ul*/ , "request weight %d %d\n", cpl.stats.weight_limit, (signed int)(cpl.ob->weight * (float)1000));
                unsigned long int return_value_strlen$6;
                return_value_strlen$6=strlen(script_process_cmd$$1$$7$$6$$buf);
                write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$6$$buf, return_value_strlen$6);
              }

              else
              {
                return_value_strncmp$46=strncmp(c, "stat ", (unsigned long int)5);
                if(return_value_strncmp$46 == 0)
                {
                  c = c + (signed long int)4;
                  for( ; !(*c == 0); c = c + 1l)
                    if((signed int)*c == 32)
                      break;

                  for( ; (signed int)*c == 32; c = c + 1l)
                    ;
                  if(*c == 0)
                    goto __CPROVER_DUMP_L150;

                  signed int return_value_strncmp$20;
                  return_value_strncmp$20=strncmp(c, "stats", (unsigned long int)5);
                  if(return_value_strncmp$20 == 0)
                  {
                    char script_process_cmd$$1$$7$$7$$4$$buf[1024l];
                    snprintf(script_process_cmd$$1$$7$$7$$4$$buf, sizeof(char [1024l]) /*1024ul*/ , "request stat stats %d %d %d %d %d %d %d\n", cpl.stats.Str, cpl.stats.Con, cpl.stats.Dex, cpl.stats.Int, cpl.stats.Wis, cpl.stats.Pow, cpl.stats.Cha);
                    unsigned long int return_value_strlen$7;
                    return_value_strlen$7=strlen(script_process_cmd$$1$$7$$7$$4$$buf);
                    write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$7$$4$$buf, return_value_strlen$7);
                  }

                  else
                  {
                    return_value_strncmp$19=strncmp(c, "cmbt", (unsigned long int)4);
                    if(return_value_strncmp$19 == 0)
                    {
                      char script_process_cmd$$1$$7$$7$$5$$buf[1024l];
                      snprintf(script_process_cmd$$1$$7$$7$$5$$buf, sizeof(char [1024l]) /*1024ul*/ , "request stat cmbt %d %d %d %d %d\n", cpl.stats.wc, cpl.stats.ac, cpl.stats.dam, cpl.stats.speed, cpl.stats.weapon_sp);
                      unsigned long int return_value_strlen$8;
                      return_value_strlen$8=strlen(script_process_cmd$$1$$7$$7$$5$$buf);
                      write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$7$$5$$buf, return_value_strlen$8);
                    }

                    else
                    {
                      return_value_strncmp$18=strncmp(c, "hp", (unsigned long int)2);
                      if(return_value_strncmp$18 == 0)
                      {
                        char script_process_cmd$$1$$7$$7$$6$$buf[1024l];
                        snprintf(script_process_cmd$$1$$7$$7$$6$$buf, sizeof(char [1024l]) /*1024ul*/ , "request stat hp %d %d %d %d %d %d %d\n", cpl.stats.hp, cpl.stats.maxhp, cpl.stats.sp, cpl.stats.maxsp, cpl.stats.grace, cpl.stats.maxgrace, cpl.stats.food);
                        unsigned long int return_value_strlen$9;
                        return_value_strlen$9=strlen(script_process_cmd$$1$$7$$7$$6$$buf);
                        write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$7$$6$$buf, return_value_strlen$9);
                      }

                      else
                      {
                        return_value_strncmp$17=strncmp(c, "xp", (unsigned long int)2);
                        if(return_value_strncmp$17 == 0)
                        {
                          char script_process_cmd$$1$$7$$7$$7$$buf[1024l];
                          signed int s;
                          snprintf(script_process_cmd$$1$$7$$7$$7$$buf, sizeof(char [1024l]) /*1024ul*/ , "request stat xp %d %ld", cpl.stats.level, cpl.stats.exp);
                          unsigned long int return_value_strlen$10;
                          return_value_strlen$10=strlen(script_process_cmd$$1$$7$$7$$7$$buf);
                          write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$7$$7$$buf, return_value_strlen$10);
                          s = 0;
                          for( ; !(s >= 50); s = s + 1)
                          {
                            snprintf(script_process_cmd$$1$$7$$7$$7$$buf, sizeof(char [1024l]) /*1024ul*/ , " %d %ld", cpl.stats.skill_level[(signed long int)s], cpl.stats.skill_exp[(signed long int)s]);
                            unsigned long int return_value_strlen$11;
                            return_value_strlen$11=strlen(script_process_cmd$$1$$7$$7$$7$$buf);
                            write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$7$$7$$buf, return_value_strlen$11);
                          }
                          write((scripts + (signed long int)i)->out_fd, (const void *)"\n", (unsigned long int)1);
                        }

                        else
                        {
                          return_value_strncmp$16=strncmp(c, "resists", (unsigned long int)7);
                          if(return_value_strncmp$16 == 0)
                          {
                            char script_process_cmd$$1$$7$$7$$8$$buf[1024l];
                            signed int script_process_cmd$$1$$7$$7$$8$$s;
                            snprintf(script_process_cmd$$1$$7$$7$$8$$buf, sizeof(char [1024l]) /*1024ul*/ , "request stat resists");
                            unsigned long int return_value_strlen$12;
                            return_value_strlen$12=strlen(script_process_cmd$$1$$7$$7$$8$$buf);
                            write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$7$$8$$buf, return_value_strlen$12);
                            script_process_cmd$$1$$7$$7$$8$$s = 0;
                            for( ; !(script_process_cmd$$1$$7$$7$$8$$s >= 30); script_process_cmd$$1$$7$$7$$8$$s = script_process_cmd$$1$$7$$7$$8$$s + 1)
                            {
                              snprintf(script_process_cmd$$1$$7$$7$$8$$buf, sizeof(char [1024l]) /*1024ul*/ , " %d", cpl.stats.resists[(signed long int)script_process_cmd$$1$$7$$7$$8$$s]);
                              unsigned long int return_value_strlen$13;
                              return_value_strlen$13=strlen(script_process_cmd$$1$$7$$7$$8$$buf);
                              write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$7$$8$$buf, return_value_strlen$13);
                            }
                            write((scripts + (signed long int)i)->out_fd, (const void *)"\n", (unsigned long int)1);
                          }

                          else
                          {
                            return_value_strncmp$15=strncmp(c, "paths", (unsigned long int)2);
                            if(return_value_strncmp$15 == 0)
                            {
                              char script_process_cmd$$1$$7$$7$$9$$buf[1024l];
                              snprintf(script_process_cmd$$1$$7$$7$$9$$buf, sizeof(char [1024l]) /*1024ul*/ , "request stat paths %d %d %d\n", cpl.stats.attuned, cpl.stats.repelled, cpl.stats.denied);
                              unsigned long int return_value_strlen$14;
                              return_value_strlen$14=strlen(script_process_cmd$$1$$7$$7$$9$$buf);
                              write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$7$$9$$buf, return_value_strlen$14);
                            }

                          }
                        }
                      }
                    }
                  }
                }

                else
                {
                  return_value_strncmp$45=strncmp(c, "flags", (unsigned long int)5);
                  if(return_value_strncmp$45 == 0)
                  {
                    char script_process_cmd$$1$$7$$8$$buf[1024l];
                    snprintf(script_process_cmd$$1$$7$$8$$buf, sizeof(char [1024l]) /*1024ul*/ , "request flags %d %d %d %d\n", cpl.stats.flags, cpl.fire_on, cpl.run_on, cpl.no_echo);
                    unsigned long int return_value_strlen$21;
                    return_value_strlen$21=strlen(script_process_cmd$$1$$7$$8$$buf);
                    write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$8$$buf, return_value_strlen$21);
                  }

                  else
                  {
                    return_value_strncmp$44=strncmp(c, "items ", (unsigned long int)6);
                    if(return_value_strncmp$44 == 0)
                    {
                      c = c + (signed long int)5;
                      for( ; !(*c == 0); c = c + 1l)
                        if((signed int)*c == 32)
                          break;

                      for( ; (signed int)*c == 32; c = c + 1l)
                        ;
                      if(*c == 0)
                        goto __CPROVER_DUMP_L150;

                      signed int return_value_strncmp$23;
                      return_value_strncmp$23=strncmp(c, "inv", (unsigned long int)3);
                      if(return_value_strncmp$23 == 0)
                      {
                        char *script_process_cmd$$1$$7$$9$$4$$buf;
                        struct item_struct *it = cpl.ob->inv;
                        for( ; !(it == ((struct item_struct *)NULL)); it = it->next)
                          script_send_item(i, "request items inv ", it);
                        script_process_cmd$$1$$7$$9$$4$$buf = "request items inv end\n";
                        unsigned long int return_value_strlen$22;
                        return_value_strlen$22=strlen(script_process_cmd$$1$$7$$9$$4$$buf);
                        write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$9$$4$$buf, return_value_strlen$22);
                      }

                      signed int return_value_strncmp$25;
                      return_value_strncmp$25=strncmp(c, "actv", (unsigned long int)4);
                      if(return_value_strncmp$25 == 0)
                      {
                        char *script_process_cmd$$1$$7$$9$$5$$buf;
                        struct item_struct *script_process_cmd$$1$$7$$9$$5$$it = cpl.ob->inv;
                        for( ; !(script_process_cmd$$1$$7$$9$$5$$it == ((struct item_struct *)NULL)); script_process_cmd$$1$$7$$9$$5$$it = script_process_cmd$$1$$7$$9$$5$$it->next)
                          if(!(script_process_cmd$$1$$7$$9$$5$$it->applied == 0))
                            script_send_item(i, "request items actv ", script_process_cmd$$1$$7$$9$$5$$it);

                        script_process_cmd$$1$$7$$9$$5$$buf = "request items actv end\n";
                        unsigned long int return_value_strlen$24;
                        return_value_strlen$24=strlen(script_process_cmd$$1$$7$$9$$5$$buf);
                        write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$9$$5$$buf, return_value_strlen$24);
                      }

                      signed int return_value_strncmp$27;
                      return_value_strncmp$27=strncmp(c, "on", (unsigned long int)2);
                      if(return_value_strncmp$27 == 0)
                      {
                        char *script_process_cmd$$1$$7$$9$$6$$buf;
                        struct item_struct *script_process_cmd$$1$$7$$9$$6$$it = cpl.below->inv;
                        for( ; !(script_process_cmd$$1$$7$$9$$6$$it == ((struct item_struct *)NULL)); script_process_cmd$$1$$7$$9$$6$$it = script_process_cmd$$1$$7$$9$$6$$it->next)
                          script_send_item(i, "request items on ", script_process_cmd$$1$$7$$9$$6$$it);
                        script_process_cmd$$1$$7$$9$$6$$buf = "request items on end\n";
                        unsigned long int return_value_strlen$26;
                        return_value_strlen$26=strlen(script_process_cmd$$1$$7$$9$$6$$buf);
                        write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$9$$6$$buf, return_value_strlen$26);
                      }

                      signed int return_value_strncmp$29;
                      return_value_strncmp$29=strncmp(c, "cont", (unsigned long int)4);
                      if(return_value_strncmp$29 == 0)
                      {
                        char *script_process_cmd$$1$$7$$9$$7$$buf;
                        struct item_struct *script_process_cmd$$1$$7$$9$$7$$it;
                        if(!(cpl.container == ((struct item_struct *)NULL)))
                        {
                          script_process_cmd$$1$$7$$9$$7$$it = cpl.container->inv;
                          for( ; !(script_process_cmd$$1$$7$$9$$7$$it == ((struct item_struct *)NULL)); script_process_cmd$$1$$7$$9$$7$$it = script_process_cmd$$1$$7$$9$$7$$it->next)
                            script_send_item(i, "request items cont ", script_process_cmd$$1$$7$$9$$7$$it);
                        }

                        script_process_cmd$$1$$7$$9$$7$$buf = "request items cont end\n";
                        unsigned long int return_value_strlen$28;
                        return_value_strlen$28=strlen(script_process_cmd$$1$$7$$9$$7$$buf);
                        write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$9$$7$$buf, return_value_strlen$28);
                      }

                    }

                    else
                    {
                      return_value_strncmp$43=strncmp(c, "map ", (unsigned long int)4);
                      if(return_value_strncmp$43 == 0)
                      {
                        signed int x;
                        signed int y;
                        c = c + (signed long int)3;
                        for( ; !(*c == 0); c = c + 1l)
                          if((signed int)*c == 32)
                            break;

                        for( ; (signed int)*c == 32; c = c + 1l)
                          ;
                        if(*c == 0)
                          goto __CPROVER_DUMP_L150;

                        signed int return_value_strncmp$36;
                        return_value_strncmp$36=strncmp(c, "pos", (unsigned long int)3);
                        if(return_value_strncmp$36 == 0)
                        {
                          char script_process_cmd$$1$$7$$10$$4$$buf[1024l];
                          snprintf(script_process_cmd$$1$$7$$10$$4$$buf, sizeof(char [1024l]) /*1024ul*/ , "request map pos %d %d\n", pl_pos.x + (signed int)use_config[(signed long int)19] / 2, pl_pos.y + (signed int)use_config[(signed long int)20] / 2);
                          unsigned long int return_value_strlen$30;
                          return_value_strlen$30=strlen(script_process_cmd$$1$$7$$10$$4$$buf);
                          write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$10$$4$$buf, return_value_strlen$30);
                        }

                        else
                        {
                          return_value_strncmp$35=strncmp(c, "near", (unsigned long int)4);
                          if(return_value_strncmp$35 == 0)
                          {
                            y = 0;
                            for( ; !(y >= 3); y = y + 1)
                            {
                              x = 0;
                              for( ; !(x >= 3); x = x + 1)
                                send_map(i, (x + pl_pos.x + (signed int)use_config[(signed long int)19] / 2) - 1, (y + pl_pos.y + (signed int)use_config[(signed long int)20] / 2) - 1);
                            }
                          }

                          else
                          {
                            return_value_strncmp$34=strncmp(c, "all", (unsigned long int)3);
                            if(return_value_strncmp$34 == 0)
                            {
                              char script_process_cmd$$1$$7$$10$$6$$buf[1024l];
                              y = 0;
                              for( ; !(y >= the_map.y); y = y + 1)
                              {
                                x = 0;
                                for( ; !(x >= the_map.x); x = x + 1)
                                  send_map(i, x, y);
                              }
                              snprintf(script_process_cmd$$1$$7$$10$$6$$buf, sizeof(char [1024l]) /*1024ul*/ , "request map end\n");
                              unsigned long int return_value_strlen$31;
                              return_value_strlen$31=strlen(script_process_cmd$$1$$7$$10$$6$$buf);
                              write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$10$$6$$buf, return_value_strlen$31);
                            }

                            else
                            {
                              for( ; !(*c == 0); c = c + 1l)
                              {
                                return_value___ctype_b_loc$32=__ctype_b_loc();
                                if(!((2048 & (signed int)(*return_value___ctype_b_loc$32)[(signed long int)(signed int)*c]) == 0))
                                  break;

                              }
                              if(*c == 0)
                                goto __CPROVER_DUMP_L150;

                              x=atoi(c);
                              for( ; !(*c == 0); c = c + 1l)
                                if((signed int)*c == 32)
                                  break;

                              for( ; !(*c == 0); c = c + 1l)
                              {
                                return_value___ctype_b_loc$33=__ctype_b_loc();
                                if(!((2048 & (signed int)(*return_value___ctype_b_loc$33)[(signed long int)(signed int)*c]) == 0))
                                  break;

                              }
                              if(*c == 0)
                                goto __CPROVER_DUMP_L150;

                              y=atoi(c);
                              send_map(i, x, y);
                            }
                          }
                        }
                      }

                      else
                      {
                        return_value_strncmp$42=strncmp(c, "skills", (unsigned long int)6);
                        if(return_value_strncmp$42 == 0)
                        {
                          char script_process_cmd$$1$$7$$11$$buf[1024l];
                          signed int script_process_cmd$$1$$7$$11$$s = 0;
                          for( ; !(script_process_cmd$$1$$7$$11$$s >= 50); script_process_cmd$$1$$7$$11$$s = script_process_cmd$$1$$7$$11$$s + 1)
                            if(!(skill_names[(signed long int)script_process_cmd$$1$$7$$11$$s] == ((char *)NULL)))
                            {
                              sprintf(script_process_cmd$$1$$7$$11$$buf, "request skills %d %s\n", 140 + script_process_cmd$$1$$7$$11$$s, skill_names[(signed long int)script_process_cmd$$1$$7$$11$$s]);
                              unsigned long int return_value_strlen$37;
                              return_value_strlen$37=strlen(script_process_cmd$$1$$7$$11$$buf);
                              write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$11$$buf, return_value_strlen$37);
                            }

                          sprintf(script_process_cmd$$1$$7$$11$$buf, "request skills end\n");
                          unsigned long int return_value_strlen$38;
                          return_value_strlen$38=strlen(script_process_cmd$$1$$7$$11$$buf);
                          write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$11$$buf, return_value_strlen$38);
                        }

                        else
                        {
                          return_value_strncmp$41=strncmp(c, "spells", (unsigned long int)6);
                          if(return_value_strncmp$41 == 0)
                          {
                            char script_process_cmd$$1$$7$$12$$buf[1024l];
                            struct Spell_struct *spell = cpl.spelldata;
                            for( ; !(spell == ((struct Spell_struct *)NULL)); spell = spell->next)
                            {
                              sprintf(script_process_cmd$$1$$7$$12$$buf, "request spells %d %d %d %d %d %d %d %d %s\n", spell->tag, spell->level, spell->sp, spell->grace, spell->skill_number, spell->path, spell->time, spell->dam, (const void *)spell->name);
                              unsigned long int return_value_strlen$39;
                              return_value_strlen$39=strlen(script_process_cmd$$1$$7$$12$$buf);
                              write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$12$$buf, return_value_strlen$39);
                            }
                            sprintf(script_process_cmd$$1$$7$$12$$buf, "request spells end\n");
                            unsigned long int return_value_strlen$40;
                            return_value_strlen$40=strlen(script_process_cmd$$1$$7$$12$$buf);
                            write((scripts + (signed long int)i)->out_fd, (const void *)script_process_cmd$$1$$7$$12$$buf, return_value_strlen$40);
                          }

                          else
                          {
                            char buf[1024l];
                            snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "Script %d %s malfunction; unimplemented request:", i + 1, (scripts + (signed long int)i)->name);
                            draw_ext_info(3, 20, 8, buf);
                            draw_ext_info(3, 20, 8, cmd);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        else
        {
          return_value_strncmp$65=strncmp(cmd, "issue", (unsigned long int)5);
          if(return_value_strncmp$65 == 0)
          {
            signed int repeat;
            signed int must_send;
            c = cmd + (signed long int)5;
            for( ; !(*c == 0); c = c + 1l)
              if(!((signed int)*c == 32))
                break;

            if(!(*c == 0))
            {
              return_value___ctype_b_loc$56=__ctype_b_loc();
              if(!((2048 & (signed int)(*return_value___ctype_b_loc$56)[(signed long int)(signed int)*c]) == 0))
                tmp_if_expr$57 = (_Bool)1;

              else
                tmp_if_expr$57 = (signed int)*c == 45 ? (_Bool)1 : (_Bool)0;
              tmp_if_expr$58 = tmp_if_expr$57 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$58 = (_Bool)0;
            if(tmp_if_expr$58)
            {
              repeat=atoi(c);
              for( ; !(*c == 0); c = c + 1l)
                if((signed int)*c == 32)
                  break;

              for( ; !(*c == 0); c = c + 1l)
              {
                return_value___ctype_b_loc$50=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc$50)[(signed long int)(signed int)*c]) == 0))
                  break;

                if((signed int)*c == 45)
                  break;

              }
              if(*c == 0)
                goto __CPROVER_DUMP_L150;

              must_send=atoi(c);
              for( ; !(*c == 0); c = c + 1l)
                if((signed int)*c == 32)
                  break;

              if(*c == 0)
                goto __CPROVER_DUMP_L150;

              for( ; (signed int)*c == 32; c = c + 1l)
                ;
              if(!(repeat == -1))
              {
                signed int r;
                r=send_command(c, repeat, must_send);
                if(!(r == 1))
                {
                  char script_process_cmd$$1$$8$$2$$7$$1$$buf[1024l];
                  snprintf(script_process_cmd$$1$$8$$2$$7$$1$$buf, sizeof(char [1024l]) /*1024ul*/ , "Script %d %s malfunction; command not sent", i + 1, (scripts + (signed long int)i)->name);
                  draw_ext_info(3, 20, 8, script_process_cmd$$1$$8$$2$$7$$1$$buf);
                  draw_ext_info(3, 20, 8, cmd);
                }

              }

            }

            else
            {
              c = cmd + (signed long int)5;
              for( ; !(*c == 0); c = c + 1l)
                if((signed int)*c == 32)
                  break;

              for( ; (signed int)*c == 32; c = c + 1l)
                ;
              signed int return_value_strncmp$55;
              return_value_strncmp$55=strncmp(c, "mark", (unsigned long int)4);
              if(return_value_strncmp$55 == 0)
              {
                signed int tag;
                struct SockList sl;
                unsigned char script_process_cmd$$1$$8$$3$$3$$buf[256l];
                c = c + (signed long int)4;
                for( ; !(*c == 0); c = c + 1l)
                {
                  return_value___ctype_b_loc$51=__ctype_b_loc();
                  if(!((2048 & (signed int)(*return_value___ctype_b_loc$51)[(signed long int)(signed int)*c]) == 0))
                    break;

                }
                if(*c == 0)
                  goto __CPROVER_DUMP_L150;

                tag=atoi(c);
                SockList_Init(&sl, script_process_cmd$$1$$8$$3$$3$$buf);
                SockList_AddString(&sl, "mark ");
                SockList_AddInt(&sl, (unsigned int)tag);
                SockList_Send(&sl, csocket.fd);
              }

              else
              {
                return_value_strncmp$54=strncmp(c, "lock", (unsigned long int)4);
                if(return_value_strncmp$54 == 0)
                {
                  signed int script_process_cmd$$1$$8$$3$$4$$tag;
                  signed int locked;
                  struct SockList script_process_cmd$$1$$8$$3$$4$$sl;
                  unsigned char script_process_cmd$$1$$8$$3$$4$$buf[256l];
                  c = c + (signed long int)4;
                  for( ; !(*c == 0); c = c + 1l)
                  {
                    return_value___ctype_b_loc$52=__ctype_b_loc();
                    if(!((2048 & (signed int)(*return_value___ctype_b_loc$52)[(signed long int)(signed int)*c]) == 0))
                      break;

                  }
                  if(*c == 0)
                    goto __CPROVER_DUMP_L150;

                  locked=atoi(c);
                  for( ; !(*c == 0); c = c + 1l)
                    if((signed int)*c == 32)
                      break;

                  for( ; !(*c == 0); c = c + 1l)
                  {
                    return_value___ctype_b_loc$53=__ctype_b_loc();
                    if(!((2048 & (signed int)(*return_value___ctype_b_loc$53)[(signed long int)(signed int)*c]) == 0))
                      break;

                  }
                  if(*c == 0)
                    goto __CPROVER_DUMP_L150;

                  script_process_cmd$$1$$8$$3$$4$$tag=atoi(c);
                  SockList_Init(&script_process_cmd$$1$$8$$3$$4$$sl, script_process_cmd$$1$$8$$3$$4$$buf);
                  SockList_AddString(&script_process_cmd$$1$$8$$3$$4$$sl, "lock ");
                  SockList_AddChar(&script_process_cmd$$1$$8$$3$$4$$sl, (char)locked);
                  SockList_AddInt(&script_process_cmd$$1$$8$$3$$4$$sl, (unsigned int)script_process_cmd$$1$$8$$3$$4$$tag);
                  SockList_Send(&script_process_cmd$$1$$8$$3$$4$$sl, csocket.fd);
                }

                else
                  cs_print_string(csocket.fd, "%s", c);
              }
            }
          }

          else
          {
            return_value_strncmp$64=strncmp(cmd, "localcmd", (unsigned long int)8);
            if(return_value_strncmp$64 == 0)
            {
              char *param;
              c = cmd + (signed long int)8;
              for( ; (signed int)*c == 32; c = c + 1l)
                ;
              param = c;
              for( ; !((signed int)*param == 0); param = param + 1l)
                if((signed int)*param == 32)
                  break;

              if((signed int)*param == 32)
              {
                *param = (char)0;
                param = param + 1l;
              }

              else
                param = (char *)(void *)0;
              signed int return_value_handle_local_command$59;
              return_value_handle_local_command$59=handle_local_command(c, param);
              if(return_value_handle_local_command$59 == 0)
              {
                char script_process_cmd$$1$$9$$5$$buf[1024l];
                snprintf(script_process_cmd$$1$$9$$5$$buf, sizeof(char [1024l]) /*1024ul*/ , "Script %s malfunction; localcmd not understood", (scripts + (signed long int)i)->name);
                draw_ext_info(3, 20, 8, script_process_cmd$$1$$9$$5$$buf);
                snprintf(script_process_cmd$$1$$9$$5$$buf, sizeof(char [1024l]) /*1024ul*/ , "Script <<localcmd %s %s>>", c, param == (char *)(void *)0 ? "" : param);
                draw_ext_info(3, 20, 8, script_process_cmd$$1$$9$$5$$buf);
              }

            }

            else
            {
              return_value_strncmp$63=strncmp(cmd, "draw", (unsigned long int)4);
              if(return_value_strncmp$63 == 0)
              {
                signed int color;
                c = cmd + (signed long int)4;
                for( ; !(*c == 0); c = c + 1l)
                {
                  return_value___ctype_b_loc$60=__ctype_b_loc();
                  if(!((2048 & (signed int)(*return_value___ctype_b_loc$60)[(signed long int)(signed int)*c]) == 0))
                    break;

                }
                if(*c == 0)
                  goto __CPROVER_DUMP_L150;

                color=atoi(c);
                for( ; !(*c == 0); c = c + 1l)
                  if((signed int)*c == 32)
                    break;

                if(*c == 0)
                  goto __CPROVER_DUMP_L150;

                for( ; (signed int)*c == 32; c = c + 1l)
                  ;
                draw_ext_info(color, 20, 8, c);
              }

              else
              {
                return_value_strncmp$62=strncmp(cmd, "monitor", (unsigned long int)7);
                if(return_value_strncmp$62 == 0)
                  (scripts + (signed long int)i)->monitor = 1;

                else
                {
                  return_value_strncmp$61=strncmp(cmd, "unmonitor", (unsigned long int)9);
                  if(return_value_strncmp$61 == 0)
                    (scripts + (signed long int)i)->monitor = 0;

                  else
                  {
                    char script_process_cmd$$1$$13$$buf[1024l];
                    snprintf(script_process_cmd$$1$$13$$buf, sizeof(char [1024l]) /*1024ul*/ , "Script %d %s malfunction; invalid command:", i + 1, (scripts + (signed long int)i)->name);
                    draw_ext_info(3, 20, 8, script_process_cmd$$1$$13$$buf);
                    draw_ext_info(3, 20, 8, cmd);
                  }
                }
              }
            }
          }
        }
      }
    }
  }

__CPROVER_DUMP_L150:
  ;
}

// script_send_item
// file script.c line 1621
static void script_send_item(signed int i, const char *head, const struct item_struct *it)
{
  char buf[4096l];
  signed int flags = (it->flagsval & (unsigned int)0x0010) != 0u ? 1 : 0;
  flags = flags << 1 | (signed int)it->magical;
  flags = flags << 1 | (signed int)it->cursed;
  flags = flags << 1 | (signed int)it->damned;
  flags = flags << 1 | (signed int)it->unpaid;
  flags = flags << 1 | (signed int)it->locked;
  flags = flags << 1 | (signed int)it->applied;
  flags = flags << 1 | (signed int)it->open;
  flags = flags << 1 | (signed int)it->was_open;
  flags = flags << 1 | (signed int)it->inv_updated;
  snprintf(buf, sizeof(char [4096l]) /*4096ul*/ , "%s%d %d %d %d %d %s\n", head, it->tag, it->nrof, (signed int)((double)(it->weight * (float)1000) + 0.5), flags, it->type, (const void *)it->d_name);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(buf);
  write((scripts + (signed long int)i)->out_fd, (const void *)buf, return_value_strlen$1);
}

// script_sync
// file ./script.h line 55
void script_sync(signed int commdiff)
{
  signed int i;
  if(!(commdiff >= 0))
    commdiff = commdiff + 256;

  i = 0;
  for( ; !(i >= num_scripts); i = i + 1)
    if((scripts + (signed long int)i)->sync_watch >= commdiff)
    {
      if((scripts + (signed long int)i)->sync_watch >= 0)
      {
        char buf[1024l];
        snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "sync %d\n", commdiff);
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(buf);
        write((scripts + (signed long int)i)->out_fd, (const void *)buf, return_value_strlen$1);
        (scripts + (signed long int)i)->sync_watch = -1;
      }

    }

}

// script_tell
// file ./script.h line 65
void script_tell(const char *params)
{
  signed int i;
  char *p;
  char *tmp_post$1;
  if(params == ((const char *)NULL))
    draw_ext_info(3, 20, 8, "Which script do you want to talk to?");

  else
  {
    char params_cpy[256l];
    snprintf(params_cpy, (unsigned long int)(256 - 1), "%s", params);
    p=strchr(params_cpy, 32);
    if(p == ((char *)NULL))
      draw_ext_info(3, 20, 8, "What do you want to tell the script?");

    else
    {
      for( ; (signed int)*p == 32; *tmp_post$1 = (char)0)
      {
        tmp_post$1 = p;
        p = p + 1l;
      }
      i=script_by_name(params_cpy);
      if(!(i >= 0))
        draw_ext_info(0, 20, 8, "No such running script");

      else
      {
        write((scripts + (signed long int)i)->out_fd, (const void *)"scripttell ", (unsigned long int)11);
        unsigned long int return_value_strlen$2;
        return_value_strlen$2=strlen(p);
        write((scripts + (signed long int)i)->out_fd, (const void *)p, return_value_strlen$2);
        write((scripts + (signed long int)i)->out_fd, (const void *)"\n", (unsigned long int)1);
      }
    }
  }
}

// script_watch
// file ./script.h line 62
void script_watch(const char *cmd, const unsigned char *data_initial, const signed int data_len, const enum CmdFormat format)
{
  signed int i;
  signed int w;
  signed int l;
  signed int len;
  const unsigned char *data;
  i = 0;
  _Bool tmp_if_expr$72;
  signed int return_value_strncmp$71;
  signed short int return_value_GetShort_String$2;
  signed int return_value_GetInt_String$3;
  signed short int return_value_GetShort_String$15;
  signed int return_value_snprintf$16;
  signed short int return_value_GetShort_String$17;
  signed int return_value_snprintf$18;
  signed short int return_value_GetShort_String$19;
  signed int return_value_snprintf$20;
  signed short int return_value_GetShort_String$21;
  signed int return_value_snprintf$22;
  signed short int return_value_GetShort_String$23;
  signed int return_value_snprintf$24;
  signed short int return_value_GetShort_String$25;
  signed int return_value_snprintf$26;
  signed short int return_value_GetShort_String$27;
  signed int return_value_snprintf$28;
  signed short int return_value_GetShort_String$29;
  signed int return_value_snprintf$30;
  signed short int return_value_GetShort_String$31;
  signed int return_value_snprintf$32;
  signed short int return_value_GetShort_String$33;
  signed int return_value_snprintf$34;
  signed short int return_value_GetShort_String$35;
  signed int return_value_snprintf$36;
  signed short int return_value_GetShort_String$37;
  signed int return_value_snprintf$38;
  signed short int return_value_GetShort_String$39;
  signed int return_value_snprintf$40;
  signed int return_value_GetInt_String$41;
  signed int return_value_snprintf$42;
  signed long int return_value_GetInt64_String$43;
  signed int return_value_snprintf$44;
  signed short int return_value_GetShort_String$45;
  signed int return_value_snprintf$46;
  signed short int return_value_GetShort_String$47;
  signed int return_value_snprintf$48;
  signed short int return_value_GetShort_String$49;
  signed int return_value_snprintf$50;
  signed short int return_value_GetShort_String$51;
  signed int return_value_snprintf$52;
  signed short int return_value_GetShort_String$53;
  signed int return_value_snprintf$54;
  signed int return_value_GetInt_String$55;
  signed int return_value_snprintf$56;
  signed short int return_value_GetShort_String$57;
  signed int return_value_snprintf$58;
  signed int return_value_GetInt_String$59;
  signed int return_value_snprintf$60;
  signed short int return_value_GetShort_String$61;
  signed int return_value_snprintf$62;
  signed int return_value_GetInt_String$63;
  signed int return_value_snprintf$64;
  signed int rlen;
  signed int return_value_snprintf$65;
  signed int script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$1$$3$$2$$rlen;
  signed int return_value_snprintf$66;
  for( ; !(i >= num_scripts); i = i + 1)
  {
    w = 0;
    for( ; !(w >= (scripts + (signed long int)i)->num_watch); w = w + 1)
    {
      len = data_len;
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen((scripts + (signed long int)i)->watch[(signed long int)w]);
      l = (signed int)return_value_strlen$1;
      if(l == 0)
        tmp_if_expr$72 = (_Bool)1;

      else
      {
        return_value_strncmp$71=strncmp(cmd, (scripts + (signed long int)i)->watch[(signed long int)w], (unsigned long int)l);
        tmp_if_expr$72 = return_value_strncmp$71 == 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$72)
      {
        char buf[10240l];
        data = data_initial;
        if(len == 0)
          snprintf(buf, sizeof(char [10240l]) /*10240ul*/ , "watch %s\n", cmd);

        else
          switch((signed int)format)
          {
            case ASCII:
            {
              snprintf(buf, sizeof(char [10240l]) /*10240ul*/ , "watch %s %s\n", cmd, data);
              break;
            }
            case SHORT_INT:
            {
              return_value_GetShort_String$2=GetShort_String(data);
              return_value_GetInt_String$3=GetInt_String(data + (signed long int)2);
              snprintf(buf, sizeof(char [10240l]) /*10240ul*/ , "watch %s %d %d\n", cmd, return_value_GetShort_String$2, return_value_GetInt_String$3);
              break;
            }
            case SHORT_ARRAY:
            {
              signed int script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$be;
              signed int script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$p;
              script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$be=snprintf(buf, sizeof(char [10240l]) /*10240ul*/ , "watch %s", cmd);
              script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$p = 0;
              for( ; !(2 * script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$p >= len) && !(script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$p >= 100); script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$p = script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$p + 1)
              {
                signed short int return_value_GetShort_String$4;
                return_value_GetShort_String$4=GetShort_String(data + (signed long int)(script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$p * 2));
                signed int return_value_snprintf$5;
                return_value_snprintf$5=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$be, " %d", return_value_GetShort_String$4);
                script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$be + return_value_snprintf$5;
              }
              signed int return_value_snprintf$6;
              return_value_snprintf$6=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$be, "\n");
              script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$1$$be + return_value_snprintf$6;
              break;
            }
            case INT_ARRAY:
            {
              signed int be;
              signed int p;
              be=snprintf(buf, sizeof(char [10240l]) /*10240ul*/ , "watch %s", cmd);
              p = 0;
              for( ; !(4 * p >= len); p = p + 1)
              {
                signed int return_value_GetInt_String$7;
                return_value_GetInt_String$7=GetInt_String(data + (signed long int)(p * 4));
                signed int return_value_snprintf$8;
                return_value_snprintf$8=snprintf(buf + (signed long int)be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)be, " %d", return_value_GetInt_String$7);
                be = be + return_value_snprintf$8;
              }
              signed int return_value_snprintf$9;
              return_value_snprintf$9=snprintf(buf + (signed long int)be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)be, "\n");
              be = be + return_value_snprintf$9;
              break;
            }
            case STATS:
            {
              signed int script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = 0;
              while(!(len == 0))
              {
                signed int c;
                signed int return_value_snprintf$10;
                return_value_snprintf$10=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, "watch %s", cmd);
                script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$10;
                c = (signed int)*data;
                data = data + 1l;
                len = len - 1;
                if(c >= 100 && !(c >= 118))
                {
                  signed short int return_value_GetShort_String$11;
                  return_value_GetShort_String$11=GetShort_String(data);
                  signed int return_value_snprintf$12;
                  return_value_snprintf$12=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " resists %d %d\n", c, return_value_GetShort_String$11);
                  script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$12;
                  data = data + (signed long int)2;
                  len = len - 2;
                }

                else
                  if(c >= 140 && !(c >= 50))
                  {
                    signed long int return_value_GetInt64_String$13;
                    return_value_GetInt64_String$13=GetInt64_String(data + (signed long int)1);
                    signed int return_value_snprintf$14;
                    return_value_snprintf$14=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " skill %d %d %ld\n", c, *data, return_value_GetInt64_String$13);
                    script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$14;
                    data = data + (signed long int)9;
                    len = len - 9;
                  }

                  else
                    switch(c)
                    {
                      case 1:
                      {
                        return_value_GetShort_String$15=GetShort_String(data);
                        return_value_snprintf$16=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " hp %d\n", return_value_GetShort_String$15);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$16;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 2:
                      {
                        return_value_GetShort_String$17=GetShort_String(data);
                        return_value_snprintf$18=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " maxhp %d\n", return_value_GetShort_String$17);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$18;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 3:
                      {
                        return_value_GetShort_String$19=GetShort_String(data);
                        return_value_snprintf$20=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " sp %d\n", return_value_GetShort_String$19);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$20;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 4:
                      {
                        return_value_GetShort_String$21=GetShort_String(data);
                        return_value_snprintf$22=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " maxsp %d\n", return_value_GetShort_String$21);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$22;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 23:
                      {
                        return_value_GetShort_String$23=GetShort_String(data);
                        return_value_snprintf$24=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " grace %d\n", return_value_GetShort_String$23);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$24;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 24:
                      {
                        return_value_GetShort_String$25=GetShort_String(data);
                        return_value_snprintf$26=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " maxgrace %d\n", return_value_GetShort_String$25);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$26;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 5:
                      {
                        return_value_GetShort_String$27=GetShort_String(data);
                        return_value_snprintf$28=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " str %d\n", return_value_GetShort_String$27);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$28;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 6:
                      {
                        return_value_GetShort_String$29=GetShort_String(data);
                        return_value_snprintf$30=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " int %d\n", return_value_GetShort_String$29);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$30;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 22:
                      {
                        return_value_GetShort_String$31=GetShort_String(data);
                        return_value_snprintf$32=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " pow %d\n", return_value_GetShort_String$31);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$32;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 7:
                      {
                        return_value_GetShort_String$33=GetShort_String(data);
                        return_value_snprintf$34=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " wis %d\n", return_value_GetShort_String$33);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$34;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 8:
                      {
                        return_value_GetShort_String$35=GetShort_String(data);
                        return_value_snprintf$36=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " dex %d\n", return_value_GetShort_String$35);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$36;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 9:
                      {
                        return_value_GetShort_String$37=GetShort_String(data);
                        return_value_snprintf$38=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " con %d\n", return_value_GetShort_String$37);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$38;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 10:
                      {
                        return_value_GetShort_String$39=GetShort_String(data);
                        return_value_snprintf$40=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " cha %d\n", return_value_GetShort_String$39);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$40;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 11:
                      {
                        return_value_GetInt_String$41=GetInt_String(data);
                        return_value_snprintf$42=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " exp %d\n", return_value_GetInt_String$41);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$42;
                        data = data + (signed long int)4;
                        len = len - 4;
                        break;
                      }
                      case 28:
                      {
                        return_value_GetInt64_String$43=GetInt64_String(data);
                        return_value_snprintf$44=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " exp %ld\n", return_value_GetInt64_String$43);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$44;
                        data = data + (signed long int)8;
                        len = len - 8;
                        break;
                      }
                      case 12:
                      {
                        return_value_GetShort_String$45=GetShort_String(data);
                        return_value_snprintf$46=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " level %d\n", return_value_GetShort_String$45);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$46;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 13:
                      {
                        return_value_GetShort_String$47=GetShort_String(data);
                        return_value_snprintf$48=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " wc %d\n", return_value_GetShort_String$47);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$48;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 14:
                      {
                        return_value_GetShort_String$49=GetShort_String(data);
                        return_value_snprintf$50=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " ac %d\n", return_value_GetShort_String$49);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$50;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 15:
                      {
                        return_value_GetShort_String$51=GetShort_String(data);
                        return_value_snprintf$52=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " dam %d\n", return_value_GetShort_String$51);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$52;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 16:
                      {
                        return_value_GetShort_String$53=GetShort_String(data);
                        return_value_snprintf$54=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " armour %d\n", return_value_GetShort_String$53);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$54;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 17:
                      {
                        return_value_GetInt_String$55=GetInt_String(data);
                        return_value_snprintf$56=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " speed %d\n", return_value_GetInt_String$55);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$56;
                        data = data + (signed long int)4;
                        len = len - 4;
                        break;
                      }
                      case 18:
                      {
                        return_value_GetShort_String$57=GetShort_String(data);
                        return_value_snprintf$58=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " food %d\n", return_value_GetShort_String$57);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$58;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 19:
                      {
                        return_value_GetInt_String$59=GetInt_String(data);
                        return_value_snprintf$60=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " weap_sp %d\n", return_value_GetInt_String$59);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$60;
                        data = data + (signed long int)4;
                        len = len - 4;
                        break;
                      }
                      case 25:
                      {
                        return_value_GetShort_String$61=GetShort_String(data);
                        return_value_snprintf$62=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " flags %d\n", return_value_GetShort_String$61);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$62;
                        data = data + (signed long int)2;
                        len = len - 2;
                        break;
                      }
                      case 26:
                      {
                        return_value_GetInt_String$63=GetInt_String(data);
                        return_value_snprintf$64=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " weight_lim %d\n", return_value_GetInt_String$63);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$64;
                        data = data + (signed long int)4;
                        len = len - 4;
                        break;
                      }
                      case 20:
                      {
                        rlen = (signed int)*data;
                        data = data + 1l;
                        len = len - 1;
                        return_value_snprintf$65=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " range %*.*s\n", rlen, rlen, data);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$65;
                        data = data + (signed long int)rlen;
                        len = len - rlen;
                        break;
                      }
                      case 21:
                      {
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$1$$3$$2$$rlen = (signed int)*data;
                        data = data + 1l;
                        len = len - 1;
                        return_value_snprintf$66=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " title %*.*s\n", script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$1$$3$$2$$rlen, script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$1$$3$$2$$rlen, data);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$66;
                        data = data + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$1$$3$$2$$rlen;
                        len = len - script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$1$$3$$2$$rlen;
                        break;
                      }
                      default:
                      {
                        signed int return_value_snprintf$67;
                        return_value_snprintf$67=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be, " unknown %d %d bytes left\n", c, len);
                        script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$3$$be + return_value_snprintf$67;
                        len = 0;
                      }
                    }
              }
              break;
            }
            case MIXED:

            case NODATA:

            default:
            {
              signed int script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$be;
              signed int script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$p;
              if(data == ((const unsigned char *)NULL))
                len = 0;

              script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$be=snprintf(buf, sizeof(char [10240l]) /*10240ul*/ , "watch %s %d bytes unparsed:", cmd, len);
              script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$p = 0;
              for( ; !(script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$p >= 100) && !(script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$p >= len); script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$p = script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$p + 1)
              {
                signed int return_value_snprintf$68;
                return_value_snprintf$68=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$be, " %02x", data[(signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$p]);
                script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$be + return_value_snprintf$68;
              }
              signed int return_value_snprintf$69;
              return_value_snprintf$69=snprintf(buf + (signed long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$be, sizeof(char [10240l]) /*10240ul*/  - (unsigned long int)script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$be, "\n");
              script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$be = script_watch$$1$$1$$1$$1$$1$$1$$2$$4$$be + return_value_snprintf$69;
            }
          }
        unsigned long int return_value_strlen$70;
        return_value_strlen$70=strlen(buf);
        write((scripts + (signed long int)i)->out_fd, (const void *)buf, return_value_strlen$70);
      }

    }
  }
}

// sdl_gen_map
// file gtk2proto.h line 239
extern void sdl_gen_map(signed int redraw)
{
  signed int x;
  signed int y;
  signed int num_spaces = 0;
  signed int num_drawn = 0;
  struct timeval tv1;
  struct timeval tv2;
  struct timeval tv3;
  signed long int elapsed1;
  signed long int elapsed2;
  if(!(time_map_redraw == 0))
    gettimeofday(&tv1, (struct timezone *)(void *)0);

  update_redrawbitmap();
  x = 0;
  _Bool tmp_if_expr$1;
  for( ; !(x >= (signed int)use_config[19l]); x = x + 1)
  {
    y = 0;
    for( ; !(y >= (signed int)use_config[20l]); y = y + 1)
    {
      num_spaces = num_spaces + 1;
      if(!(redraw == 0))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = redrawbitmap[(signed long int)(x + 1 + (y + 1) * (signed int)use_config[(signed long int)19])] != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        num_drawn = num_drawn + 1;
        display_mapcell$link1(x, y, pl_pos.x + x, pl_pos.y + y);
        (the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->need_update = (unsigned char)0;
        (the_map.cells[(signed long int)(pl_pos.x + x)] + (signed long int)(pl_pos.y + y))->need_resmooth = (unsigned char)0;
      }

    }
  }
  if(!(time_map_redraw == 0))
    gettimeofday(&tv2, (struct timezone *)(void *)0);

  SDL_Flip(mapsurface);
  if(!(time_map_redraw == 0))
  {
    gettimeofday(&tv3, (struct timezone *)(void *)0);
    elapsed1 = (tv2.tv_sec - tv1.tv_sec) * (signed long int)1000000 + (tv2.tv_usec - tv1.tv_usec);
    elapsed2 = (tv3.tv_sec - tv2.tv_sec) * (signed long int)1000000 + (tv3.tv_usec - tv2.tv_usec);
    if(elapsed1 + elapsed2 >= 10001l)
      LOG((enum LogLevel)LOG_INFO, "gtk-v2::sdl_gen_map", "gen took %7ld, flip took %7ld, total = %7ld", elapsed1, elapsed2, elapsed1 + elapsed2);

  }

}

// sdl_mapscroll
// file gtk2proto.h line 240
extern signed int sdl_mapscroll(signed int dx, signed int dy)
{
  SDL_LockSurface(mapsurface);
  if(!(dy >= 0))
  {
    signed int offset = (signed int)mapsurface->pitch * -dy * map_image_size;
    memmove(mapsurface->pixels + (signed long int)offset, mapsurface->pixels, (unsigned long int)((signed int)mapsurface->pitch * (mapsurface->h + dy * map_image_size)));
  }

  else
    if(dy >= 1)
    {
      signed int sdl_mapscroll$$1$$2$$offset = (signed int)mapsurface->pitch * dy * map_image_size;
      memmove(mapsurface->pixels, mapsurface->pixels + (signed long int)sdl_mapscroll$$1$$2$$offset, (unsigned long int)((signed int)mapsurface->pitch * (mapsurface->h - dy * map_image_size)));
    }

  if(!(dx == 0))
  {
    signed int y = 0;
    for( ; !(y >= mapsurface->h); y = y + 1)
      if(!(dx >= 0))
      {
        char *start_of_row = (char *)(mapsurface->pixels + (signed long int)((signed int)mapsurface->pitch * y));
        signed int sdl_mapscroll$$1$$3$$1$$1$$1$$offset = (signed int)mapsurface->format->BytesPerPixel * map_image_size * -dx;
        memmove((void *)(start_of_row + (signed long int)sdl_mapscroll$$1$$3$$1$$1$$1$$offset), (const void *)start_of_row, (unsigned long int)((signed int)mapsurface->pitch - sdl_mapscroll$$1$$3$$1$$1$$1$$offset));
      }

      else
      {
        char *sdl_mapscroll$$1$$3$$1$$1$$2$$start_of_row = (char *)(mapsurface->pixels + (signed long int)((signed int)mapsurface->pitch * y));
        signed int sdl_mapscroll$$1$$3$$1$$1$$2$$offset = (signed int)mapsurface->format->BytesPerPixel * map_image_size * dx;
        memmove((void *)sdl_mapscroll$$1$$3$$1$$1$$2$$start_of_row, (const void *)(sdl_mapscroll$$1$$3$$1$$1$$2$$start_of_row + (signed long int)sdl_mapscroll$$1$$3$$1$$1$$2$$offset), (unsigned long int)((signed int)mapsurface->pitch - sdl_mapscroll$$1$$3$$1$$1$$2$$offset));
      }
  }

  SDL_UnlockSurface(mapsurface);
  return 1;
}

// send_command
// file ../../common/proto.h line 148
signed int send_command(const char *command, signed int repeat, signed int must_send)
{
  script_monitor(command, repeat, must_send);
  _Bool tmp_if_expr$2;
  signed int return_value_strcmp$1;
  if((signed int)cpl.input_state == Reply_One)
  {
    LOG((enum LogLevel)LOG_ERROR, "common::send_command", "Wont send command '%s' - since in reply mode!", command);
    cpl.count = (unsigned int)0;
    return 0;
  }

  else
  {
    if(csocket.cs_version >= 1021)
    {
      signed int commdiff = csocket.command_sent - csocket.command_received;
      if(!(commdiff >= 0))
        commdiff = commdiff + 256;

      static char last_command[256l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
      if(must_send == 0 && !((signed int)use_config[4l] >= commdiff))
      {
        return_value_strcmp$1=strcmp(command, last_command);
        tmp_if_expr$2 = !(return_value_strcmp$1 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
      {
        if(!(repeat == -1))
          cpl.count = (unsigned int)0;

        return 0;
      }

      else
      {
        struct SockList sl;
        unsigned char buf[256l];
        if(must_send == 0)
          strcpy(last_command, command);

        csocket.command_sent = csocket.command_sent + 1;
        csocket.command_sent = csocket.command_sent & 0xff;
        SockList_Init(&sl, buf);
        SockList_AddString(&sl, "ncom ");
        SockList_AddShort(&sl, (unsigned short int)csocket.command_sent);
        SockList_AddInt(&sl, (unsigned int)repeat);
        SockList_AddString(&sl, command);
        SockList_Send(&sl, csocket.fd);
      }
    }

    else
      cs_print_string(csocket.fd, "command %d %s", repeat, command);
    if(!(repeat == -1))
      cpl.count = (unsigned int)0;

    return 1;
  }
}

// send_create_player_to_server
// file create_char.c line 268
static void send_create_player_to_server()
{
  const char *char_name;
  signed int i;
  signed int on_choice;
  signed int tmp;
  struct SockList sl;
  char buf[256l];
  unsigned char sockbuf[256l];
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_new_character_name$link1, return_value_gtk_entry_get_type$1);
  char_name=gtk_entry_get_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2);
  SockList_Init(&sl, sockbuf);
  SockList_AddString(&sl, "createplayer ");
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(char_name);
  SockList_AddChar(&sl, (char)return_value_strlen$3);
  SockList_AddString(&sl, char_name);
  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(account_password);
  SockList_AddChar(&sl, (char)return_value_strlen$4);
  SockList_AddString(&sl, account_password);
  unsigned long int return_value_gtk_combo_box_get_type$5;
  return_value_gtk_combo_box_get_type$5=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)combobox_rs, return_value_gtk_combo_box_get_type$5);
  i=gtk_combo_box_get_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$6);
  snprintf(buf, (unsigned long int)256, "race %s", (races + (signed long int)i)->arch_name);
  unsigned long int return_value_strlen$7;
  return_value_strlen$7=strlen(buf);
  SockList_AddChar(&sl, (char)(return_value_strlen$7 + (unsigned long int)1));
  SockList_AddString(&sl, buf);
  SockList_AddChar(&sl, (char)0);
  on_choice = 0;
  for( ; !(on_choice >= (races + (signed long int)i)->num_rc_choice); on_choice = on_choice + 1)
  {
    signed int j;
    unsigned long int return_value_gtk_combo_box_get_type$8;
    return_value_gtk_combo_box_get_type$8=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)opt_combobox[(signed long int)(on_choice + 0)], return_value_gtk_combo_box_get_type$8);
    j=gtk_combo_box_get_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$9);
    snprintf(buf, (unsigned long int)256, "choice %s %s", ((races + (signed long int)i)->rc_choice + (signed long int)on_choice)->choice_name, ((races + (signed long int)i)->rc_choice + (signed long int)on_choice)->value_arch[(signed long int)j]);
    unsigned long int return_value_strlen$10;
    return_value_strlen$10=strlen(buf);
    SockList_AddChar(&sl, (char)(return_value_strlen$10 + (unsigned long int)1));
    SockList_AddString(&sl, buf);
    SockList_AddChar(&sl, (char)0);
  }
  unsigned long int return_value_gtk_combo_box_get_type$11;
  return_value_gtk_combo_box_get_type$11=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)combobox_cs, return_value_gtk_combo_box_get_type$11);
  i=gtk_combo_box_get_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$12);
  snprintf(buf, (unsigned long int)256, "class %s", (classes + (signed long int)i)->arch_name);
  unsigned long int return_value_strlen$13;
  return_value_strlen$13=strlen(buf);
  SockList_AddChar(&sl, (char)(return_value_strlen$13 + (unsigned long int)1));
  SockList_AddString(&sl, buf);
  SockList_AddChar(&sl, (char)0);
  on_choice = 0;
  for( ; !(on_choice >= (classes + (signed long int)i)->num_rc_choice); on_choice = on_choice + 1)
  {
    signed int send_create_player_to_server$$1$$2$$1$$j;
    unsigned long int return_value_gtk_combo_box_get_type$14;
    return_value_gtk_combo_box_get_type$14=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
    return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)opt_combobox[(signed long int)(on_choice + 6 / 2)], return_value_gtk_combo_box_get_type$14);
    send_create_player_to_server$$1$$2$$1$$j=gtk_combo_box_get_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$15);
    snprintf(buf, (unsigned long int)256, "choice %s %s", ((classes + (signed long int)i)->rc_choice + (signed long int)on_choice)->choice_name, ((classes + (signed long int)i)->rc_choice + (signed long int)on_choice)->value_arch[(signed long int)send_create_player_to_server$$1$$2$$1$$j]);
    unsigned long int return_value_strlen$16;
    return_value_strlen$16=strlen(buf);
    SockList_AddChar(&sl, (char)(return_value_strlen$16 + (unsigned long int)1));
    SockList_AddString(&sl, buf);
    SockList_AddChar(&sl, (char)0);
  }
  if(!(starting_map_number == 0))
  {
    unsigned long int return_value_gtk_combo_box_get_type$17;
    return_value_gtk_combo_box_get_type$17=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
    return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)combobox_starting_map, return_value_gtk_combo_box_get_type$17);
    i=gtk_combo_box_get_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$18);
    if(!(i == -1))
    {
      snprintf(buf, (unsigned long int)256, "starting_map %s", (starting_map_info + (signed long int)i)->arch_name);
      unsigned long int return_value_strlen$19;
      return_value_strlen$19=strlen(buf);
      SockList_AddChar(&sl, (char)(return_value_strlen$19 + (unsigned long int)1));
      SockList_AddString(&sl, buf);
      SockList_AddChar(&sl, (char)0);
    }

  }

  i = 0;
  for( ; !(i >= 7); i = i + 1)
  {
    unsigned long int return_value_gtk_spin_button_get_type$20;
    return_value_gtk_spin_button_get_type$20=gtk_spin_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
    return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)spinbutton_cc[(signed long int)i], return_value_gtk_spin_button_get_type$20);
    tmp=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$21);
    snprintf(buf, (unsigned long int)256, "%s %d", stat_mapping[(signed long int)i].widget_suffix, tmp);
    unsigned long int return_value_strlen$22;
    return_value_strlen$22=strlen(buf);
    SockList_AddChar(&sl, (char)(return_value_strlen$22 + (unsigned long int)1));
    SockList_AddString(&sl, buf);
    SockList_AddChar(&sl, (char)0);
  }
  SockList_Send(&sl, csocket.fd);
  keybindings_init(char_name);
}

// send_map
// file script.c line 1053
static void send_map(signed int i, signed int x, signed int y)
{
  char buf[1024l];
  if(x >= the_map.x || y >= the_map.y || !(x >= 0) || !(y >= 0))
  {
    snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "request map %d %d unknown\n", x, y);
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(buf);
    write((scripts + (signed long int)i)->out_fd, (const void *)buf, return_value_strlen$1);
  }

  snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "request map %d %d  %d %c %c %c %c smooth %d %d %d heads %d %d %d tails %d %d %d\n", x, y, (the_map.cells[(signed long int)x] + (signed long int)y)->darkness, (the_map.cells[(signed long int)x] + (signed long int)y)->need_update != 0 ? 121 : 110, (the_map.cells[(signed long int)x] + (signed long int)y)->have_darkness != 0 ? 121 : 110, (the_map.cells[(signed long int)x] + (signed long int)y)->need_resmooth != 0 ? 121 : 110, (the_map.cells[(signed long int)x] + (signed long int)y)->cleared != 0 ? 121 : 110, (the_map.cells[(signed long int)x] + (signed long int)y)->smooth[(signed long int)0], (the_map.cells[(signed long int)x] + (signed long int)y)->smooth[(signed long int)1], (the_map.cells[(signed long int)x] + (signed long int)y)->smooth[(signed long int)2], (the_map.cells[(signed long int)x] + (signed long int)y)->heads[(signed long int)0].face, (the_map.cells[(signed long int)x] + (signed long int)y)->heads[(signed long int)1].face, (the_map.cells[(signed long int)x] + (signed long int)y)->heads[(signed long int)2].face, (the_map.cells[(signed long int)x] + (signed long int)y)->tails[(signed long int)0].face, (the_map.cells[(signed long int)x] + (signed long int)y)->tails[(signed long int)1].face, (the_map.cells[(signed long int)x] + (signed long int)y)->tails[(signed long int)2].face);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(buf);
  write((scripts + (signed long int)i)->out_fd, (const void *)buf, return_value_strlen$2);
}

// send_mark_obj
// file ../../common/proto.h line 72
void send_mark_obj(struct item_struct *op)
{
  struct SockList sl;
  unsigned char buf[256l];
  if(!(op->env->tag == 0))
  {
    snprintf((char *)buf, sizeof(unsigned char [256l]) /*256ul*/ , "mark %d", op->tag);
    script_monitor_str((char *)buf);
    SockList_Init(&sl, buf);
    SockList_AddString(&sl, "mark ");
    SockList_AddInt(&sl, (unsigned int)op->tag);
    SockList_Send(&sl, csocket.fd);
  }

}

// send_reply
// file ../../common/proto.h line 21
void send_reply(const char *text)
{
  cs_print_string(csocket.fd, "reply %s", text);
  cpl.no_echo = (unsigned int)0;
  x_set_echo();
}

// setTextManager
// file ../../common/proto.h line 16
void setTextManager(signed int type, void (*callback)(signed int, signed int, signed int, char *))
{
  struct TextManager *current = firstTextManager;
  for( ; !(current == ((struct TextManager *)NULL)); current = current->next)
    if(current->type == type)
    {
      current->callback = callback;
      goto __CPROVER_DUMP_L4;
    }

  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct TextManager) /*24ul*/ );
  current = (struct TextManager *)return_value_malloc$1;
  current->type = type;
  current->callback = callback;
  current->next = firstTextManager;
  firstTextManager = current;

__CPROVER_DUMP_L4:
  ;
}

// set_autorepeat
// file info.c line 1309
extern void set_autorepeat(const char *s)
{
  ;
}

// set_command_window
// file p_cmd.c line 328
static void set_command_window(const char *cpnext)
{
  _Bool tmp_if_expr$2;
  if(cpnext == ((const char *)NULL))
    draw_ext_info(0, 20, 6, "cwindow command requires a number parameter");

  else
  {
    signed int return_value_atoi$1;
    return_value_atoi$1=atoi(cpnext);
    want_config[(signed long int)4] = (signed short int)return_value_atoi$1;
    if(!((signed int)want_config[4l] >= 1))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)want_config[(signed long int)4] > 127 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      want_config[(signed long int)4] = (signed short int)10;

    else
      use_config[(signed long int)4] = want_config[(signed long int)4];
  }
}

// set_darkness
// file mapdata.c line 126
static void set_darkness(signed int x, signed int y, signed int darkness)
{
  (the_map.cells[(signed long int)x] + (signed long int)y)->have_darkness = (unsigned char)1;
  _Bool tmp_if_expr$1;
  if(!((signed int)(the_map.cells[(signed long int)x] + (signed long int)y)->darkness == darkness))
  {
    (the_map.cells[(signed long int)x] + (signed long int)y)->darkness = (unsigned char)darkness;
    (the_map.cells[(signed long int)x] + (signed long int)y)->need_update = (unsigned char)1;
    if((signed int)use_config[10l] == 1)
    {
      if((signed int)use_config[17l] == 2)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)use_config[(signed long int)17] == 3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        if(x >= 2)
          (the_map.cells[(signed long int)(x - 1)] + (signed long int)y)->need_update = (unsigned char)1;

        if(y >= 2)
          (the_map.cells[(signed long int)x] + (signed long int)(y - 1))->need_update = (unsigned char)1;

        if(!(x >= width$link1 + -1))
          (the_map.cells[(signed long int)(x + 1)] + (signed long int)y)->need_update = (unsigned char)1;

        if(!(y >= height$link1 + -1))
          (the_map.cells[(signed long int)x] + (signed long int)(y + 1))->need_update = (unsigned char)1;

      }

    }

  }

}

// set_flag_string
// file item.c line 477
static void set_flag_string(struct item_struct *op)
{
  op->flags[(signed long int)0] = (char)0;
  if(!(op->locked == 0))
    strcat(op->flags, " *");

  if(!(op->apply_type == 0))
  {
    if(!((unsigned long int)op->apply_type >= 6ul))
      strcat(op->flags, apply_string[(signed long int)op->apply_type]);

    else
      strcat(op->flags, " (undefined)");
  }

  if(!(op->open == 0))
    strcat(op->flags, " (open)");

  if(!(op->damned == 0))
    strcat(op->flags, " (damned)");

  if(!(op->cursed == 0))
    strcat(op->flags, " (cursed)");

  if(!(op->magical == 0))
    strcat(op->flags, " (magic)");

  if(!(op->unpaid == 0))
    strcat(op->flags, " (unpaid)");

}

// set_item_values
// file item.c line 523
void set_item_values(struct item_struct *op, char *name, signed int weight, unsigned short int face, unsigned short int flags, unsigned short int anim, unsigned short int animspeed, unsigned int nrof, unsigned short int type)
{
  signed int resort = 1;
  if(op == ((struct item_struct *)NULL))
    printf("Error in set_item_values(): item pointer is NULL.\n");

  else
  {
    if(nrof == 0u)
      nrof = (unsigned int)1;

    if(!((signed int)*name == 0))
    {
      strncpy(op->s_name, name, (unsigned long int)(128 - 1));
      op->s_name[(signed long int)(128 - 1)] = (char)0;
      if(csocket.sc_version >= 1024)
      {
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(name);
        strncpy(op->p_name, name + (signed long int)return_value_strlen$1 + (signed long int)1, (unsigned long int)(128 - 1));
        op->p_name[(signed long int)(128 - 1)] = (char)0;
      }

      else
      {
        strncpy(op->p_name, name, (unsigned long int)(128 - 1));
        op->p_name[(signed long int)(128 - 1)] = (char)0;
      }
      op->nrof = nrof + (unsigned int)1;
    }

    else
      resort = 0;
    if(!(op->nrof == nrof))
    {
      if(!(nrof == 1u))
      {
        const char *return_value_get_number$2;
        return_value_get_number$2=get_number(nrof);
        snprintf(op->d_name, sizeof(char [128l]) /*128ul*/ , "%s %s", return_value_get_number$2, (const void *)op->p_name);
      }

      else
        strcpy(op->d_name, op->s_name);
      op->nrof = nrof;
    }

    if(!(op->env == ((struct item_struct *)NULL)))
      op->env->inv_updated = (unsigned short int)1;

    op->weight = (float)weight / (float)1000;
    op->face = (signed short int)face;
    op->animation_id = anim;
    op->anim_speed = (unsigned char)animspeed;
    op->type = type;
    get_flags(op, flags);
    if(!(op->env == map))
    {
      if((signed int)op->type == 30000)
      {
        unsigned char return_value_get_type_from_name$3;
        return_value_get_type_from_name$3=get_type_from_name(op->s_name);
        op->type = (unsigned short int)return_value_get_type_from_name$3;
      }

    }

    if(!(resort == 0))
      update_item_sort(op);

    item_event_item_changed(op);
  }
}

// set_scroll
// file info.c line 1296
extern void set_scroll(const char *s)
{
  ;
}

// set_show_icon
// file inventory.c line 575
extern void set_show_icon(const char *s)
{
  ;
}

// set_show_weight
// file inventory.c line 583
extern void set_show_weight(const char *s)
{
  ;
}

// set_text_tag_from_style
// file info.c line 301
extern void set_text_tag_from_style(struct _GtkTextTag *tag, struct _GtkStyle *style, struct _GtkStyle *base_style)
{
  g_object_set((void *)tag, "foreground-set", 0, (void *)0);
  g_object_set((void *)tag, "background-set", 0, (void *)0);
  g_object_set((void *)tag, "font-desc", (void *)0, (void *)0);
  signed int return_value_memcmp$1;
  return_value_memcmp$1=memcmp((const void *)&style->fg[(signed long int)GTK_STATE_NORMAL], (const void *)&base_style->fg[(signed long int)GTK_STATE_NORMAL], sizeof(struct _GdkColor) /*12ul*/ );
  if(!(return_value_memcmp$1 == 0))
    g_object_set((void *)tag, "foreground-gdk", &style->fg[(signed long int)GTK_STATE_NORMAL], (void *)0);

  signed int return_value_memcmp$2;
  return_value_memcmp$2=memcmp((const void *)&style->bg[(signed long int)GTK_STATE_NORMAL], (const void *)&base_style->bg[(signed long int)GTK_STATE_NORMAL], sizeof(struct _GdkColor) /*12ul*/ );
  if(!(return_value_memcmp$2 == 0))
    g_object_set((void *)tag, "background-gdk", &style->bg[(signed long int)GTK_STATE_NORMAL], (void *)0);

  if(!(style->font_desc == base_style->font_desc))
    g_object_set((void *)tag, "font-desc", style->font_desc, (void *)0);

}

// set_weight_limit
// file inventory.c line 646
extern void set_weight_limit(unsigned int wlim)
{
  weight_limit = (double)wlim / 1000.0;
}

// setup_config_window
// file config.c line 720
static void setup_config_window()
{
  signed int count;
  signed int i;
  struct _GtkTreeModel *model;
  char *buf;
  struct _GtkTreeIter iter;
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)config_button_echo, return_value_gtk_toggle_button_get_type$1);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2, (signed int)want_config[(signed long int)2]);
  unsigned long int return_value_gtk_toggle_button_get_type$3;
  return_value_gtk_toggle_button_get_type$3=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)config_button_fasttcp, return_value_gtk_toggle_button_get_type$3);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$4, (signed int)want_config[(signed long int)3]);
  unsigned long int return_value_gtk_toggle_button_get_type$5;
  return_value_gtk_toggle_button_get_type$5=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)config_button_timestamp, return_value_gtk_toggle_button_get_type$5);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$6, (signed int)want_config[(signed long int)31]);
  unsigned long int return_value_gtk_toggle_button_get_type$7;
  return_value_gtk_toggle_button_get_type$7=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)config_button_grad_color, return_value_gtk_toggle_button_get_type$7);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$8, (signed int)want_config[(signed long int)24]);
  unsigned long int return_value_gtk_toggle_button_get_type$9;
  return_value_gtk_toggle_button_get_type$9=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)config_button_foodbeep, return_value_gtk_toggle_button_get_type$9);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$10, (signed int)want_config[(signed long int)21]);
  unsigned long int return_value_gtk_toggle_button_get_type$11;
  return_value_gtk_toggle_button_get_type$11=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)config_button_sound, return_value_gtk_toggle_button_get_type$11);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$12, (signed int)want_config[(signed long int)13]);
  unsigned long int return_value_gtk_toggle_button_get_type$13;
  return_value_gtk_toggle_button_get_type$13=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
  return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)config_button_cache, return_value_gtk_toggle_button_get_type$13);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$14, (signed int)want_config[(signed long int)5]);
  unsigned long int return_value_gtk_toggle_button_get_type$15;
  return_value_gtk_toggle_button_get_type$15=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
  return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)config_button_download, return_value_gtk_toggle_button_get_type$15);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$16, (signed int)want_config[(signed long int)1]);
  unsigned long int return_value_gtk_toggle_button_get_type$17;
  return_value_gtk_toggle_button_get_type$17=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)config_button_fog, return_value_gtk_toggle_button_get_type$17);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$18, (signed int)want_config[(signed long int)6]);
  unsigned long int return_value_gtk_toggle_button_get_type$19;
  return_value_gtk_toggle_button_get_type$19=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$20;
  return_value_g_type_check_instance_cast$20=g_type_check_instance_cast((struct _GTypeInstance *)config_button_smoothing, return_value_gtk_toggle_button_get_type$19);
  gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$20, (signed int)want_config[(signed long int)26]);
  unsigned long int return_value_gtk_spin_button_get_type$21;
  return_value_gtk_spin_button_get_type$21=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$22;
  return_value_g_type_check_instance_cast$22=g_type_check_instance_cast((struct _GTypeInstance *)config_spinbutton_cwindow, return_value_gtk_spin_button_get_type$21);
  gtk_spin_button_set_value((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$22, (double)(float)want_config[(signed long int)4]);
  unsigned long int return_value_gtk_spin_button_get_type$23;
  return_value_gtk_spin_button_get_type$23=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)config_spinbutton_iconscale, return_value_gtk_spin_button_get_type$23);
  gtk_spin_button_set_value((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$24, (double)(float)want_config[(signed long int)7]);
  unsigned long int return_value_gtk_spin_button_get_type$25;
  return_value_gtk_spin_button_get_type$25=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$26;
  return_value_g_type_check_instance_cast$26=g_type_check_instance_cast((struct _GTypeInstance *)config_spinbutton_mapscale, return_value_gtk_spin_button_get_type$25);
  gtk_spin_button_set_value((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$26, (double)(float)want_config[(signed long int)8]);
  unsigned long int return_value_gtk_spin_button_get_type$27;
  return_value_gtk_spin_button_get_type$27=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$28;
  return_value_g_type_check_instance_cast$28=g_type_check_instance_cast((struct _GTypeInstance *)config_spinbutton_mapwidth, return_value_gtk_spin_button_get_type$27);
  gtk_spin_button_set_value((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$28, (double)(float)want_config[(signed long int)19]);
  unsigned long int return_value_gtk_spin_button_get_type$29;
  return_value_gtk_spin_button_get_type$29=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)config_spinbutton_mapheight, return_value_gtk_spin_button_get_type$29);
  gtk_spin_button_set_value((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$30, (double)(float)want_config[(signed long int)20]);
  unsigned long int return_value_gtk_combo_box_get_type$31;
  return_value_gtk_combo_box_get_type$31=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$32;
  return_value_g_type_check_instance_cast$32=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_faceset, return_value_gtk_combo_box_get_type$31);
  model=gtk_combo_box_get_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$32);
  count=gtk_tree_model_iter_n_children(model, (struct _GtkTreeIter *)(void *)0);
  i = 0;
  for( ; !(i >= count); i = i + 1)
  {
    unsigned long int return_value_gtk_combo_box_get_type$33;
    return_value_gtk_combo_box_get_type$33=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$34;
    return_value_g_type_check_instance_cast$34=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_faceset, return_value_gtk_combo_box_get_type$33);
    gtk_combo_box_remove_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$34, 0);
  }
  unsigned long int return_value_gtk_combo_box_get_type$35;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
  if(!(face_info.have_faceset_info == 0))
  {
    i = 0;
    for( ; !(i >= 20); i = i + 1)
      if(!(face_info.facesets[(signed long int)i].fullname == ((char *)NULL)))
      {
        return_value_gtk_combo_box_get_type$35=gtk_combo_box_get_type();
        return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_faceset, return_value_gtk_combo_box_get_type$35);
        gtk_combo_box_append_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$36, face_info.facesets[(signed long int)i].fullname);
      }

  }

  else
  {
    unsigned long int return_value_gtk_combo_box_get_type$37;
    return_value_gtk_combo_box_get_type$37=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$38;
    return_value_g_type_check_instance_cast$38=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_faceset, return_value_gtk_combo_box_get_type$37);
    gtk_combo_box_append_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$38, "Standard");
    unsigned long int return_value_gtk_combo_box_get_type$39;
    return_value_gtk_combo_box_get_type$39=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$40;
    return_value_g_type_check_instance_cast$40=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_faceset, return_value_gtk_combo_box_get_type$39);
    gtk_combo_box_append_text((struct _GtkComboBox *)return_value_g_type_check_instance_cast$40, "Classic");
  }
  count=gtk_tree_model_iter_n_children(model, (struct _GtkTreeIter *)(void *)0);
  i = 0;
  signed int return_value_strcasecmp$44;
  for( ; !(i >= count); i = i + 1)
  {
    signed int return_value_gtk_tree_model_iter_nth_child$41;
    return_value_gtk_tree_model_iter_nth_child$41=gtk_tree_model_iter_nth_child(model, &iter, (struct _GtkTreeIter *)(void *)0, i);
    if(return_value_gtk_tree_model_iter_nth_child$41 == 0)
    {
      LOG((enum LogLevel)LOG_ERROR, "config.c::setup_config_window", "Unable to get faceset iter\n");
      break;
    }

    gtk_tree_model_get(model, &iter, 0, &buf, -1);
    if(!(face_info.want_faceset == ((char *)NULL)))
    {
      return_value_strcasecmp$44=strcasecmp(face_info.want_faceset, buf);
      if(return_value_strcasecmp$44 == 0)
      {
        unsigned long int return_value_gtk_combo_box_get_type$42;
        return_value_gtk_combo_box_get_type$42=gtk_combo_box_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$43;
        return_value_g_type_check_instance_cast$43=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_faceset, return_value_gtk_combo_box_get_type$42);
        gtk_combo_box_set_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$43, i);
        g_free((void *)buf);
        break;
      }

    }

    g_free((void *)buf);
  }
  if((unsigned long int)want_config[10l] >= 25ul)
    LOG((enum LogLevel)LOG_ERROR, "config.c::setup_config_window", "Player display mode not in display_modes range\n");

  else
  {
    unsigned long int return_value_gtk_combo_box_get_type$45;
    return_value_gtk_combo_box_get_type$45=gtk_combo_box_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$46;
    return_value_g_type_check_instance_cast$46=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_displaymode, return_value_gtk_combo_box_get_type$45);
    model=gtk_combo_box_get_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$46);
    count=gtk_tree_model_iter_n_children(model, (struct _GtkTreeIter *)(void *)0);
    i = 0;
    for( ; !(i >= count); i = i + 1)
    {
      signed int return_value_gtk_tree_model_iter_nth_child$47;
      return_value_gtk_tree_model_iter_nth_child$47=gtk_tree_model_iter_nth_child(model, &iter, (struct _GtkTreeIter *)(void *)0, i);
      if(return_value_gtk_tree_model_iter_nth_child$47 == 0)
      {
        LOG((enum LogLevel)LOG_ERROR, "config.c::setup_config_window", "Unable to get faceset iter\n");
        break;
      }

      gtk_tree_model_get(model, &iter, 0, &buf, -1);
      signed int return_value_strcasecmp$50;
      return_value_strcasecmp$50=strcasecmp(display_modes[(signed long int)want_config[(signed long int)10]], buf);
      if(return_value_strcasecmp$50 == 0)
      {
        unsigned long int return_value_gtk_combo_box_get_type$48;
        return_value_gtk_combo_box_get_type$48=gtk_combo_box_get_type();
        struct _GTypeInstance *return_value_g_type_check_instance_cast$49;
        return_value_g_type_check_instance_cast$49=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_displaymode, return_value_gtk_combo_box_get_type$48);
        gtk_combo_box_set_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$49, i);
        g_free((void *)buf);
        break;
      }

      g_free((void *)buf);
    }
  }
  unsigned long int return_value_gtk_combo_box_get_type$51;
  return_value_gtk_combo_box_get_type$51=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$52;
  return_value_g_type_check_instance_cast$52=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_lighting, return_value_gtk_combo_box_get_type$51);
  model=gtk_combo_box_get_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$52);
  count=gtk_tree_model_iter_n_children(model, (struct _GtkTreeIter *)(void *)0);
  i = 0;
  _Bool tmp_if_expr$57;
  signed int return_value_strcasecmp$56;
  _Bool tmp_if_expr$60;
  _Bool tmp_if_expr$59;
  signed int return_value_strcasecmp$58;
  _Bool tmp_if_expr$63;
  _Bool tmp_if_expr$62;
  signed int return_value_strcasecmp$61;
  _Bool tmp_if_expr$66;
  _Bool tmp_if_expr$65;
  signed int return_value_strcasecmp$64;
  for( ; !(i >= count); i = i + 1)
  {
    signed int return_value_gtk_tree_model_iter_nth_child$53;
    return_value_gtk_tree_model_iter_nth_child$53=gtk_tree_model_iter_nth_child(model, &iter, (struct _GtkTreeIter *)(void *)0, i);
    if(return_value_gtk_tree_model_iter_nth_child$53 == 0)
    {
      LOG((enum LogLevel)LOG_ERROR, "config.c::setup_config_window", "Unable to get lighting iter\n");
      break;
    }

    gtk_tree_model_get(model, &iter, 0, &buf, -1);
    if((signed int)want_config[17l] == 1)
    {
      return_value_strcasecmp$56=strcasecmp(buf, "Per Tile");
      tmp_if_expr$57 = !(return_value_strcasecmp$56 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$57 = (_Bool)0;
    if(tmp_if_expr$57)
      tmp_if_expr$60 = (_Bool)1;

    else
    {
      if((signed int)want_config[17l] == 2)
      {
        return_value_strcasecmp$58=strcasecmp(buf, "Fast Per Pixel");
        tmp_if_expr$59 = !(return_value_strcasecmp$58 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$59 = (_Bool)0;
      tmp_if_expr$60 = tmp_if_expr$59 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$60)
      tmp_if_expr$63 = (_Bool)1;

    else
    {
      if((signed int)want_config[17l] == 3)
      {
        return_value_strcasecmp$61=strcasecmp(buf, "Best Per Pixel");
        tmp_if_expr$62 = !(return_value_strcasecmp$61 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$62 = (_Bool)0;
      tmp_if_expr$63 = tmp_if_expr$62 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$63)
      tmp_if_expr$66 = (_Bool)1;

    else
    {
      if((signed int)want_config[17l] == 0)
      {
        return_value_strcasecmp$64=strcasecmp(buf, "None");
        tmp_if_expr$65 = !(return_value_strcasecmp$64 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$65 = (_Bool)0;
      tmp_if_expr$66 = tmp_if_expr$65 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$66)
    {
      unsigned long int return_value_gtk_combo_box_get_type$54;
      return_value_gtk_combo_box_get_type$54=gtk_combo_box_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$55;
      return_value_g_type_check_instance_cast$55=g_type_check_instance_cast((struct _GTypeInstance *)config_combobox_lighting, return_value_gtk_combo_box_get_type$54);
      gtk_combo_box_set_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$55, i);
      g_free((void *)buf);
      break;
    }

    g_free((void *)buf);
  }
  fill_combobox_from_datadir(config_combobox_theme, theme, (unsigned long int)1, themedir, (signed int (*)())scandir_theme_filter);
  fill_combobox_from_datadir(config_combobox_layout, window_xml_file, (unsigned long int)0, layoutdir, (signed int (*)())scandir_ui_filter);
}

// setup_list_columns
// file inventory.c line 332
static void setup_list_columns(struct _GtkWidget *treeview)
{
  struct _GtkCellRenderer *renderer;
  struct _GtkTreeViewColumn *column;
  struct _GtkTreeSelection *selection;
  renderer=gtk_cell_renderer_pixbuf_new();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$1;
  return_value_g_type_check_instance_cast$1=g_type_check_instance_cast((struct _GTypeInstance *)renderer, (unsigned long int)(20 << 2));
  g_object_set((void *)(struct _GObject *)return_value_g_type_check_instance_cast$1, "xalign", 0.0, (void *)0);
  column=gtk_tree_view_column_new_with_attributes("?", renderer, (const void *)"pixbuf", 1, (void *)0);
  gtk_tree_view_column_set_min_width(column, image_size);
  gtk_tree_view_column_set_sort_column_id(column, 6);
  unsigned long int return_value_gtk_tree_view_get_type$2;
  return_value_gtk_tree_view_get_type$2=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)treeview, return_value_gtk_tree_view_get_type$2);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$3, column);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes("Name", renderer, (const void *)"text", 2, (void *)0);
  gtk_tree_view_column_set_expand(column, (signed int)!(0 != 0));
  gtk_tree_view_column_set_sort_column_id(column, 7);
  unsigned long int return_value_gtk_tree_view_get_type$4;
  return_value_gtk_tree_view_get_type$4=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)treeview, return_value_gtk_tree_view_get_type$4);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$5, column);
  gtk_tree_view_column_add_attribute(column, renderer, "background-gdk", 5);
  gtk_tree_view_column_add_attribute(column, renderer, "foreground-gdk", 8);
  gtk_tree_view_column_add_attribute(column, renderer, "font-desc", 9);
  unsigned long int return_value_gtk_tree_view_get_type$6;
  return_value_gtk_tree_view_get_type$6=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
  return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)treeview, return_value_gtk_tree_view_get_type$6);
  gtk_tree_view_set_expander_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$7, column);
  gtk_tree_view_column_set_sizing(column, (enum anonymous$18)GTK_TREE_VIEW_COLUMN_FIXED);
  renderer=gtk_cell_renderer_text_new();
  column=gtk_tree_view_column_new_with_attributes("Weight", renderer, (const void *)"text", 3, (void *)0);
  gtk_tree_view_column_set_min_width(column, 64);
  gtk_tree_view_column_set_sizing(column, (enum anonymous$18)GTK_TREE_VIEW_COLUMN_FIXED);
  gtk_tree_view_column_set_sort_column_id(column, 3);
  unsigned long int return_value_gtk_tree_view_get_type$8;
  return_value_gtk_tree_view_get_type$8=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
  return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)treeview, return_value_gtk_tree_view_get_type$8);
  gtk_tree_view_append_column((struct _GtkTreeView *)return_value_g_type_check_instance_cast$9, column);
  gtk_tree_view_column_add_attribute(column, renderer, "background-gdk", 5);
  gtk_tree_view_column_add_attribute(column, renderer, "foreground-gdk", 8);
  gtk_tree_view_column_add_attribute(column, renderer, "font-desc", 9);
  unsigned long int return_value_gtk_tree_view_get_type$10;
  return_value_gtk_tree_view_get_type$10=gtk_tree_view_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$11;
  return_value_g_type_check_instance_cast$11=g_type_check_instance_cast((struct _GTypeInstance *)treeview, return_value_gtk_tree_view_get_type$10);
  selection=gtk_tree_view_get_selection((struct _GtkTreeView *)return_value_g_type_check_instance_cast$11);
  gtk_tree_selection_set_select_function(selection, list_selection_func, (void *)0, (void (*)(void *))(void *)0);
}

// show_all
// file inventory.c line 106
static signed int show_all(struct item_struct *it)
{
  return 0x1 | 0x2;
}

// show_applied
// file inventory.c line 110
static signed int show_applied(struct item_struct *it)
{
  return it->applied != 0 ? 0x1 : 0;
}

// show_cursed
// file inventory.c line 122
static signed int show_cursed(struct item_struct *it)
{
  return ((signed int)it->cursed | (signed int)it->damned) != 0 ? 0x1 : 0;
}

// show_help
// file p_cmd.c line 158
static void show_help(const struct anonymous$47 *cc)
{
  char buf[256l];
  if(!(cc->desc == ((const char *)NULL)))
  {
    snprintf(buf, (unsigned long int)(256 - 1), "%s - %s", cc->name, cc->desc);
    draw_ext_info(0, 20, 6, buf);
  }

  else
  {
    snprintf(buf, (unsigned long int)(256 - 1), "Help for '%s':", cc->name);
    draw_ext_info(0, 20, 6, buf);
  }
  if(!(cc->helpfunc == ((const char * (*)(void))NULL)))
  {
    const char *long_help = (const char *)(void *)0;
    long_help=cc->helpfunc();
    if(!(long_help == ((const char *)NULL)))
      draw_ext_info(0, 20, 6, long_help);

    else
      draw_ext_info(0, 20, 6, "Extended help for this command is broken.");
  }

  else
    draw_ext_info(0, 20, 6, "No extended help is available for this command.");
}

// show_keys
// file keys.c line 1024
static void show_keys(void)
{
  signed int i;
  signed int j;
  signed int count = 1;
  struct keybind *kb;
  char buf[256l];
  char *tmp_if_expr$2;
  char *return_value_gdk_keyval_name$1;
  if((signed long int)commandkeysym == 0L)
    tmp_if_expr$2 = "unknown";

  else
  {
    return_value_gdk_keyval_name$1=gdk_keyval_name(commandkeysym);
    tmp_if_expr$2 = return_value_gdk_keyval_name$1;
  }
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Commandkey %s", tmp_if_expr$2);
  draw_ext_info(0, 20, 6, buf);
  char *tmp_if_expr$4;
  char *return_value_gdk_keyval_name$3;
  if((signed long int)firekeysym[0l] == 0L)
    tmp_if_expr$4 = "unknown";

  else
  {
    return_value_gdk_keyval_name$3=gdk_keyval_name(firekeysym[(signed long int)0]);
    tmp_if_expr$4 = return_value_gdk_keyval_name$3;
  }
  char *tmp_if_expr$6;
  char *return_value_gdk_keyval_name$5;
  if((signed long int)firekeysym[1l] == 0L)
    tmp_if_expr$6 = "unknown";

  else
  {
    return_value_gdk_keyval_name$5=gdk_keyval_name(firekeysym[(signed long int)1]);
    tmp_if_expr$6 = return_value_gdk_keyval_name$5;
  }
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Firekeys 1: %s, 2: %s", tmp_if_expr$4, tmp_if_expr$6);
  draw_ext_info(0, 20, 6, buf);
  char *tmp_if_expr$8;
  char *return_value_gdk_keyval_name$7;
  if((signed long int)altkeysym[0l] == 0L)
    tmp_if_expr$8 = "unknown";

  else
  {
    return_value_gdk_keyval_name$7=gdk_keyval_name(altkeysym[(signed long int)0]);
    tmp_if_expr$8 = return_value_gdk_keyval_name$7;
  }
  char *tmp_if_expr$10;
  char *return_value_gdk_keyval_name$9;
  if((signed long int)altkeysym[1l] == 0L)
    tmp_if_expr$10 = "unknown";

  else
  {
    return_value_gdk_keyval_name$9=gdk_keyval_name(altkeysym[(signed long int)1]);
    tmp_if_expr$10 = return_value_gdk_keyval_name$9;
  }
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Altkeys 1: %s, 2: %s", tmp_if_expr$8, tmp_if_expr$10);
  draw_ext_info(0, 20, 6, buf);
  char *tmp_if_expr$12;
  char *return_value_gdk_keyval_name$11;
  if((signed long int)metakeysym[0l] == 0L)
    tmp_if_expr$12 = "unknown";

  else
  {
    return_value_gdk_keyval_name$11=gdk_keyval_name(metakeysym[(signed long int)0]);
    tmp_if_expr$12 = return_value_gdk_keyval_name$11;
  }
  char *tmp_if_expr$14;
  char *return_value_gdk_keyval_name$13;
  if((signed long int)metakeysym[1l] == 0L)
    tmp_if_expr$14 = "unknown";

  else
  {
    return_value_gdk_keyval_name$13=gdk_keyval_name(metakeysym[(signed long int)1]);
    tmp_if_expr$14 = return_value_gdk_keyval_name$13;
  }
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Metakeys 1: %s, 2: %s", tmp_if_expr$12, tmp_if_expr$14);
  draw_ext_info(0, 20, 6, buf);
  char *tmp_if_expr$16;
  char *return_value_gdk_keyval_name$15;
  if((signed long int)runkeysym[0l] == 0L)
    tmp_if_expr$16 = "unknown";

  else
  {
    return_value_gdk_keyval_name$15=gdk_keyval_name(runkeysym[(signed long int)0]);
    tmp_if_expr$16 = return_value_gdk_keyval_name$15;
  }
  char *tmp_if_expr$18;
  char *return_value_gdk_keyval_name$17;
  if((signed long int)runkeysym[1l] == 0L)
    tmp_if_expr$18 = "unknown";

  else
  {
    return_value_gdk_keyval_name$17=gdk_keyval_name(runkeysym[(signed long int)1]);
    tmp_if_expr$18 = return_value_gdk_keyval_name$17;
  }
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Runkeys 1: %s, 2: %s", tmp_if_expr$16, tmp_if_expr$18);
  draw_ext_info(0, 20, 6, buf);
  char *tmp_if_expr$20;
  char *return_value_gdk_keyval_name$19;
  if((signed long int)completekeysym == 0L)
    tmp_if_expr$20 = "unknown";

  else
  {
    return_value_gdk_keyval_name$19=gdk_keyval_name(completekeysym);
    tmp_if_expr$20 = return_value_gdk_keyval_name$19;
  }
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Command Completion Key %s", tmp_if_expr$20);
  draw_ext_info(0, 20, 6, buf);
  char *tmp_if_expr$22;
  char *return_value_gdk_keyval_name$21;
  if((signed long int)nextkeysym == 0L)
    tmp_if_expr$22 = "unknown";

  else
  {
    return_value_gdk_keyval_name$21=gdk_keyval_name(nextkeysym);
    tmp_if_expr$22 = return_value_gdk_keyval_name$21;
  }
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Next Command in History Key %s", tmp_if_expr$22);
  draw_ext_info(0, 20, 6, buf);
  char *tmp_if_expr$24;
  char *return_value_gdk_keyval_name$23;
  if((signed long int)prevkeysym == 0L)
    tmp_if_expr$24 = "unknown";

  else
  {
    return_value_gdk_keyval_name$23=gdk_keyval_name(prevkeysym);
    tmp_if_expr$24 = return_value_gdk_keyval_name$23;
  }
  snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Previous Command in History Key %s", tmp_if_expr$24);
  draw_ext_info(0, 20, 6, buf);
  i = 0;
  struct keybind *tmp_if_expr$25;
  for( ; !(i >= 257); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 2); j = j + 1)
    {
      if(j == 0)
        tmp_if_expr$25 = keys_global[(signed long int)i];

      else
        tmp_if_expr$25 = keys_char[(signed long int)i];
      kb = tmp_if_expr$25;
      for( ; !(kb == ((struct keybind *)NULL)); kb = kb->next)
      {
        char *return_value_get_key_info$26;
        return_value_get_key_info$26=get_key_info(kb, 0);
        snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%3d %s", count, return_value_get_key_info$26);
        draw_ext_info(0, 20, 6, buf);
        count = count + 1;
      }
    }
  }
}

// show_locked
// file inventory.c line 134
static signed int show_locked(struct item_struct *it)
{
  return it->locked != 0 ? 0x1 | 0x2 : 0;
}

// show_magical
// file inventory.c line 126
static signed int show_magical(struct item_struct *it)
{
  return it->magical != 0 ? 0x1 : 0;
}

// show_nonmagical
// file inventory.c line 130
static signed int show_nonmagical(struct item_struct *it)
{
  return it->magical != 0 ? 0 : 0x1;
}

// show_unapplied
// file inventory.c line 114
static signed int show_unapplied(struct item_struct *it)
{
  return it->applied != 0 ? 0 : 0x1;
}

// show_unidentified
// file inventory.c line 142
static signed int show_unidentified(struct item_struct *it)
{
  return (it->flagsval & (unsigned int)0x0010) != 0u ? 0x1 : 0;
}

// show_unlocked
// file inventory.c line 138
static signed int show_unlocked(struct item_struct *it)
{
  return it->locked != 0 ? 0 : 0x1 | 0x2;
}

// show_unpaid
// file inventory.c line 118
static signed int show_unpaid(struct item_struct *it)
{
  return it->unpaid != 0 ? 0x1 : 0;
}

// show_window
// file create_char.c line 92
static void show_window(signed int window)
{
  switch(window)
  {
    case 0:
    {
      gtk_widget_hide(create_character_window);
      gtk_widget_hide(choose_starting_map_window);
      break;
    }
    case 1:
    {
      gtk_widget_show(create_character_window);
      gtk_widget_hide(choose_starting_map_window);
      break;
    }
    case 2:
    {
      gtk_widget_hide(create_character_window);
      gtk_widget_show(choose_starting_map_window);
    }
  }
}

// sigpipe_handler
// file main.c line 288
static void sigpipe_handler(signed int sig)
{
  ;
}

// skill_selection_func
// file skills.c line 50
static signed int skill_selection_func(struct _GtkTreeSelection *selection, struct _GtkTreeModel *model, struct _GtkTreePath *path, signed int path_currently_selected, void *userdata)
{
  gtk_widget_set_sensitive(skill_ready, (signed int)!(0 != 0));
  gtk_widget_set_sensitive(skill_use, (signed int)!(0 != 0));
  return (signed int)!(0 != 0);
}

// sort_by_category
// file p_cmd.c line 930
static signed int sort_by_category(const void *a_, const void *b_)
{
  struct anonymous$47 *a = *((struct anonymous$47 **)a_);
  struct anonymous$47 *b = *((struct anonymous$47 **)b_);
  if(a->cat == b->cat)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(a->name, b->name);
    return return_value_strcmp$1;
  }

  return (signed int)a->cat - (signed int)b->cat;
}

// sort_by_name
// file p_cmd.c line 913
static signed int sort_by_name(const void *a_, const void *b_)
{
  struct anonymous$47 *a = *((struct anonymous$47 **)a_);
  struct anonymous$47 *b = *((struct anonymous$47 **)b_);
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(a->name, b->name);
  return return_value_strcmp$1;
}

// spell_get_styles
// file gtk2proto.h line 255
extern void spell_get_styles(void)
{
  signed int i;
  struct _GtkStyle *tmp_style;
  i = 0;
  static signed int style_has_init = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    if(!(style_has_init == 0))
    {
      if(!(spell_styles[(signed long int)i] == ((struct _GtkStyle *)NULL)))
        g_object_unref((void *)spell_styles[(signed long int)i]);

    }

    struct _GtkSettings *return_value_gtk_settings_get_default$1;
    return_value_gtk_settings_get_default$1=gtk_settings_get_default();
    tmp_style=gtk_rc_get_style_by_paths(return_value_gtk_settings_get_default$1, (const char *)(void *)0, Style_Names$link1[(signed long int)i], (unsigned long int)(1 << 2));
    if(!(tmp_style == ((struct _GtkStyle *)NULL)))
    {
      void *return_value_g_object_ref$2;
      return_value_g_object_ref$2=g_object_ref((void *)tmp_style);
      spell_styles[(signed long int)i] = (struct _GtkStyle *)return_value_g_object_ref$2;
    }

    else
    {
      LOG((enum LogLevel)LOG_INFO, "spells.c::spell_get_styles", "Unable to find style for %s", Style_Names$link1[(signed long int)i]);
      spell_styles[(signed long int)i] = (struct _GtkStyle *)(void *)0;
    }
  }
  style_has_init = 1;
}

// spell_selection_func
// file spells.c line 103
static signed int spell_selection_func(struct _GtkTreeSelection *selection, struct _GtkTreeModel *model, struct _GtkTreePath *path, signed int path_currently_selected, void *userdata)
{
  gtk_widget_set_sensitive(spell_invoke, (signed int)!(0 != 0));
  gtk_widget_set_sensitive(spell_cast, (signed int)!(0 != 0));
  return (signed int)!(0 != 0);
}

// start_login
// file account.c line 1404
extern void start_login(signed int method)
{
  serverloginmethod = method;
  if(has_init == 0)
  {
    init_login_window();
    init_add_character_window();
    init_choose_char_window();
    init_create_account_window();
    init_new_character_window();
    init_account_password_window();
    has_init = 1;
    update_login_info(1);
    update_login_info(3);
    update_login_info(2);
  }

  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_name, return_value_gtk_entry_get_type$1);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$2, "");
  unsigned long int return_value_gtk_entry_get_type$3;
  return_value_gtk_entry_get_type$3=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)entry_account_password, return_value_gtk_entry_get_type$3);
  gtk_entry_set_text((struct _GtkEntry *)return_value_g_type_check_instance_cast$4, "");
  gtk_widget_grab_focus(entry_account_name);
  gtk_widget_show(login_window);
}

// starting_map_update_info
// file create_char.c line 756
void starting_map_update_info()
{
  struct _GtkListStore *store;
  struct _GtkTreeIter iter;
  struct _GtkCellRenderer *renderer;
  signed int i;
  store=gtk_list_store_new(2, (unsigned long int)(16 << 2), (unsigned long int)(16 << 2));
  i = 0;
  for( ; starting_map_number >= i; i = i + 1)
  {
    gtk_list_store_append(store, &iter);
    gtk_list_store_set(store, &iter, 0, (starting_map_info + (signed long int)i)->public_name, -1);
    gtk_list_store_set(store, &iter, 1, (starting_map_info + (signed long int)i)->arch_name, -1);
  }
  unsigned long int return_value_gtk_combo_box_get_type$1;
  return_value_gtk_combo_box_get_type$1=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)combobox_starting_map, return_value_gtk_combo_box_get_type$1);
  unsigned long int return_value_gtk_tree_model_get_type$3;
  return_value_gtk_tree_model_get_type$3=gtk_tree_model_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)store, return_value_gtk_tree_model_get_type$3);
  gtk_combo_box_set_model((struct _GtkComboBox *)return_value_g_type_check_instance_cast$2, (struct _GtkTreeModel *)return_value_g_type_check_instance_cast$4);
  unsigned long int return_value_gtk_cell_layout_get_type$5;
  return_value_gtk_cell_layout_get_type$5=gtk_cell_layout_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
  return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)combobox_starting_map, return_value_gtk_cell_layout_get_type$5);
  gtk_cell_layout_clear((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$6);
  renderer=gtk_cell_renderer_text_new();
  unsigned long int return_value_gtk_cell_layout_get_type$7;
  return_value_gtk_cell_layout_get_type$7=gtk_cell_layout_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
  return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)combobox_starting_map, return_value_gtk_cell_layout_get_type$7);
  gtk_cell_layout_pack_start((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$8, renderer, 0);
  unsigned long int return_value_gtk_cell_layout_get_type$9;
  return_value_gtk_cell_layout_get_type$9=gtk_cell_layout_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
  return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)combobox_starting_map, return_value_gtk_cell_layout_get_type$9);
  gtk_cell_layout_set_attributes((struct _GtkCellLayout *)return_value_g_type_check_instance_cast$10, renderer, (const void *)"text", 0, (void *)0);
  g_signal_connect_data((void *)combobox_starting_map, "changed", (void (*)(void))on_combobox_starting_map_changed, (void *)0, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$36)0);
  unsigned long int return_value_gtk_combo_box_get_type$11;
  return_value_gtk_combo_box_get_type$11=gtk_combo_box_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)combobox_starting_map, return_value_gtk_combo_box_get_type$11);
  gtk_combo_box_set_active((struct _GtkComboBox *)return_value_g_type_check_instance_cast$12, -1);
  gtk_widget_show(button_choose_starting_map);
}

// stats_get_styles
// file gtk2proto.h line 264
extern void stats_get_styles(void)
{
  signed int stats_get_styles$$1$$stat_bar;
  signed int sub_style;
  char buf[256l];
  struct _GtkStyle *tmp_style;
  static signed int stats_get_styles$$1$$has_init = 0;
  if(stats_get_styles$$1$$has_init == 0)
    memset((void *)bar_colors, 0, sizeof(struct _GdkColor *) /*8ul*/  * (unsigned long int)5 * (unsigned long int)6);

  stats_get_styles$$1$$stat_bar = 0;
  for( ; !(stats_get_styles$$1$$stat_bar >= 5); stats_get_styles$$1$$stat_bar = stats_get_styles$$1$$stat_bar + 1)
  {
    sub_style = 0;
    for( ; !(sub_style >= 6); sub_style = sub_style + 1)
    {
      snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%s_%s", stat_bar_names[(signed long int)stats_get_styles$$1$$stat_bar], stat_style_names[(signed long int)sub_style]);
      struct _GtkSettings *return_value_gtk_settings_get_default$1;
      return_value_gtk_settings_get_default$1=gtk_settings_get_default();
      tmp_style=gtk_rc_get_style_by_paths(return_value_gtk_settings_get_default$1, (const char *)(void *)0, buf, (unsigned long int)(1 << 2));
      if(tmp_style == ((struct _GtkStyle *)NULL))
      {
        if(!(bar_colors[(signed long int)stats_get_styles$$1$$stat_bar][(signed long int)sub_style] == ((struct _GdkColor *)NULL)))
        {
          free((void *)bar_colors[(signed long int)stats_get_styles$$1$$stat_bar][(signed long int)sub_style]);
          bar_colors[(signed long int)stats_get_styles$$1$$stat_bar][(signed long int)sub_style] = (struct _GdkColor *)(void *)0;
        }

        LOG((enum LogLevel)LOG_INFO, "stats.c::stats_get_styles()", "Unable to find style '%s'", (const void *)buf);
      }

      else
      {
        if(bar_colors[(signed long int)stats_get_styles$$1$$stat_bar][(signed long int)sub_style] == ((struct _GdkColor *)NULL))
        {
          void *return_value_calloc$2;
          return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct _GdkColor) /*12ul*/ );
          bar_colors[(signed long int)stats_get_styles$$1$$stat_bar][(signed long int)sub_style] = (struct _GdkColor *)return_value_calloc$2;
        }

        memcpy((void *)bar_colors[(signed long int)stats_get_styles$$1$$stat_bar][(signed long int)sub_style], (const void *)&tmp_style->base[(signed long int)GTK_STATE_SELECTED], sizeof(struct _GdkColor) /*12ul*/ );
      }
    }
  }
}

// stats_init
// file gtk2proto.h line 265
extern void stats_init(struct _GtkWidget *window_root)
{
  signed int i;
  signed int x;
  signed int y;
  char buf[256l];
  i = 0;
  for( ; !(i >= 5); i = i + 1)
  {
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "label_stat_current_%s", stat_bar_names[(signed long int)i]);
    struct _GObject *return_value_gtk_builder_get_object$1;
    return_value_gtk_builder_get_object$1=gtk_builder_get_object(window_xml, buf);
    unsigned long int return_value_gtk_widget_get_type$2;
    return_value_gtk_widget_get_type$2=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
    stat_current[(signed long int)i] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$3;
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "label_stat_max_%s", stat_bar_names[(signed long int)i]);
    struct _GObject *return_value_gtk_builder_get_object$4;
    return_value_gtk_builder_get_object$4=gtk_builder_get_object(window_xml, buf);
    unsigned long int return_value_gtk_widget_get_type$5;
    return_value_gtk_widget_get_type$5=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$4, return_value_gtk_widget_get_type$5);
    stat_max[(signed long int)i] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$6;
    snprintf(buf, sizeof(char [256l]) /*256ul*/ , "progressbar_%s", stat_bar_names[(signed long int)i]);
    struct _GObject *return_value_gtk_builder_get_object$7;
    return_value_gtk_builder_get_object$7=gtk_builder_get_object(window_xml, buf);
    unsigned long int return_value_gtk_widget_get_type$8;
    return_value_gtk_widget_get_type$8=gtk_widget_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$9;
    return_value_g_type_check_instance_cast$9=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$7, return_value_gtk_widget_get_type$8);
    stat_bar[(signed long int)i] = (struct _GtkWidget *)return_value_g_type_check_instance_cast$9;
    lastval[(signed long int)i] = -1;
    lastmax[(signed long int)i] = -1;
  }
  struct _GObject *return_value_gtk_builder_get_object$10;
  return_value_gtk_builder_get_object$10=gtk_builder_get_object(window_xml, "label_playername");
  unsigned long int return_value_gtk_widget_get_type$11;
  return_value_gtk_widget_get_type$11=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$10, return_value_gtk_widget_get_type$11);
  statwindow.playername = (struct _GtkWidget *)return_value_g_type_check_instance_cast$12;
  struct _GObject *return_value_gtk_builder_get_object$13;
  return_value_gtk_builder_get_object$13=gtk_builder_get_object(window_xml, "label_str");
  unsigned long int return_value_gtk_widget_get_type$14;
  return_value_gtk_widget_get_type$14=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$15;
  return_value_g_type_check_instance_cast$15=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$13, return_value_gtk_widget_get_type$14);
  statwindow.Str = (struct _GtkWidget *)return_value_g_type_check_instance_cast$15;
  struct _GObject *return_value_gtk_builder_get_object$16;
  return_value_gtk_builder_get_object$16=gtk_builder_get_object(window_xml, "label_dex");
  unsigned long int return_value_gtk_widget_get_type$17;
  return_value_gtk_widget_get_type$17=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
  return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$16, return_value_gtk_widget_get_type$17);
  statwindow.Dex = (struct _GtkWidget *)return_value_g_type_check_instance_cast$18;
  struct _GObject *return_value_gtk_builder_get_object$19;
  return_value_gtk_builder_get_object$19=gtk_builder_get_object(window_xml, "label_con");
  unsigned long int return_value_gtk_widget_get_type$20;
  return_value_gtk_widget_get_type$20=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$21;
  return_value_g_type_check_instance_cast$21=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$19, return_value_gtk_widget_get_type$20);
  statwindow.Con = (struct _GtkWidget *)return_value_g_type_check_instance_cast$21;
  struct _GObject *return_value_gtk_builder_get_object$22;
  return_value_gtk_builder_get_object$22=gtk_builder_get_object(window_xml, "label_int");
  unsigned long int return_value_gtk_widget_get_type$23;
  return_value_gtk_widget_get_type$23=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$24;
  return_value_g_type_check_instance_cast$24=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$22, return_value_gtk_widget_get_type$23);
  statwindow.Int = (struct _GtkWidget *)return_value_g_type_check_instance_cast$24;
  struct _GObject *return_value_gtk_builder_get_object$25;
  return_value_gtk_builder_get_object$25=gtk_builder_get_object(window_xml, "label_wis");
  unsigned long int return_value_gtk_widget_get_type$26;
  return_value_gtk_widget_get_type$26=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$27;
  return_value_g_type_check_instance_cast$27=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$25, return_value_gtk_widget_get_type$26);
  statwindow.Wis = (struct _GtkWidget *)return_value_g_type_check_instance_cast$27;
  struct _GObject *return_value_gtk_builder_get_object$28;
  return_value_gtk_builder_get_object$28=gtk_builder_get_object(window_xml, "label_pow");
  unsigned long int return_value_gtk_widget_get_type$29;
  return_value_gtk_widget_get_type$29=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$30;
  return_value_g_type_check_instance_cast$30=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$28, return_value_gtk_widget_get_type$29);
  statwindow.Pow = (struct _GtkWidget *)return_value_g_type_check_instance_cast$30;
  struct _GObject *return_value_gtk_builder_get_object$31;
  return_value_gtk_builder_get_object$31=gtk_builder_get_object(window_xml, "label_cha");
  unsigned long int return_value_gtk_widget_get_type$32;
  return_value_gtk_widget_get_type$32=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$33;
  return_value_g_type_check_instance_cast$33=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$31, return_value_gtk_widget_get_type$32);
  statwindow.Cha = (struct _GtkWidget *)return_value_g_type_check_instance_cast$33;
  struct _GObject *return_value_gtk_builder_get_object$34;
  return_value_gtk_builder_get_object$34=gtk_builder_get_object(window_xml, "label_wc");
  unsigned long int return_value_gtk_widget_get_type$35;
  return_value_gtk_widget_get_type$35=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$36;
  return_value_g_type_check_instance_cast$36=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$34, return_value_gtk_widget_get_type$35);
  statwindow.wc = (struct _GtkWidget *)return_value_g_type_check_instance_cast$36;
  struct _GObject *return_value_gtk_builder_get_object$37;
  return_value_gtk_builder_get_object$37=gtk_builder_get_object(window_xml, "label_dam");
  unsigned long int return_value_gtk_widget_get_type$38;
  return_value_gtk_widget_get_type$38=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$39;
  return_value_g_type_check_instance_cast$39=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$37, return_value_gtk_widget_get_type$38);
  statwindow.dam = (struct _GtkWidget *)return_value_g_type_check_instance_cast$39;
  struct _GObject *return_value_gtk_builder_get_object$40;
  return_value_gtk_builder_get_object$40=gtk_builder_get_object(window_xml, "label_ac");
  unsigned long int return_value_gtk_widget_get_type$41;
  return_value_gtk_widget_get_type$41=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$42;
  return_value_g_type_check_instance_cast$42=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$40, return_value_gtk_widget_get_type$41);
  statwindow.ac = (struct _GtkWidget *)return_value_g_type_check_instance_cast$42;
  struct _GObject *return_value_gtk_builder_get_object$43;
  return_value_gtk_builder_get_object$43=gtk_builder_get_object(window_xml, "label_armor");
  unsigned long int return_value_gtk_widget_get_type$44;
  return_value_gtk_widget_get_type$44=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$45;
  return_value_g_type_check_instance_cast$45=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$43, return_value_gtk_widget_get_type$44);
  statwindow.armor = (struct _GtkWidget *)return_value_g_type_check_instance_cast$45;
  struct _GObject *return_value_gtk_builder_get_object$46;
  return_value_gtk_builder_get_object$46=gtk_builder_get_object(window_xml, "label_speed");
  unsigned long int return_value_gtk_widget_get_type$47;
  return_value_gtk_widget_get_type$47=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$48;
  return_value_g_type_check_instance_cast$48=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$46, return_value_gtk_widget_get_type$47);
  statwindow.speed = (struct _GtkWidget *)return_value_g_type_check_instance_cast$48;
  struct _GObject *return_value_gtk_builder_get_object$49;
  return_value_gtk_builder_get_object$49=gtk_builder_get_object(window_xml, "label_weapon_speed");
  unsigned long int return_value_gtk_widget_get_type$50;
  return_value_gtk_widget_get_type$50=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$51;
  return_value_g_type_check_instance_cast$51=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$49, return_value_gtk_widget_get_type$50);
  statwindow.weapon_speed = (struct _GtkWidget *)return_value_g_type_check_instance_cast$51;
  struct _GObject *return_value_gtk_builder_get_object$52;
  return_value_gtk_builder_get_object$52=gtk_builder_get_object(window_xml, "label_range");
  unsigned long int return_value_gtk_widget_get_type$53;
  return_value_gtk_widget_get_type$53=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$54;
  return_value_g_type_check_instance_cast$54=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$52, return_value_gtk_widget_get_type$53);
  statwindow.range = (struct _GtkWidget *)return_value_g_type_check_instance_cast$54;
  struct _GObject *return_value_gtk_builder_get_object$55;
  return_value_gtk_builder_get_object$55=gtk_builder_get_object(window_xml, "label_exp");
  unsigned long int return_value_gtk_widget_get_type$56;
  return_value_gtk_widget_get_type$56=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$57;
  return_value_g_type_check_instance_cast$57=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$55, return_value_gtk_widget_get_type$56);
  statwindow.exp = (struct _GtkWidget *)return_value_g_type_check_instance_cast$57;
  struct _GObject *return_value_gtk_builder_get_object$58;
  return_value_gtk_builder_get_object$58=gtk_builder_get_object(window_xml, "label_level");
  unsigned long int return_value_gtk_widget_get_type$59;
  return_value_gtk_widget_get_type$59=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$60;
  return_value_g_type_check_instance_cast$60=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$58, return_value_gtk_widget_get_type$59);
  statwindow.level = (struct _GtkWidget *)return_value_g_type_check_instance_cast$60;
  struct _GObject *return_value_gtk_builder_get_object$61;
  return_value_gtk_builder_get_object$61=gtk_builder_get_object(window_xml, "table_skills_exp");
  unsigned long int return_value_gtk_widget_get_type$62;
  return_value_gtk_widget_get_type$62=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$63;
  return_value_g_type_check_instance_cast$63=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$61, return_value_gtk_widget_get_type$62);
  statwindow.table_skills_exp = (struct _GtkWidget *)return_value_g_type_check_instance_cast$63;
  if(!(statwindow.table_skills_exp == ((struct _GtkWidget *)NULL)))
  {
    i = 0;
    x = 0;
    y = 0;
    for( ; !(i >= 6); i = i + 1)
    {
      statwindow.skill_exp[(signed long int)i]=gtk_label_new("");
      unsigned long int return_value_gtk_table_get_type$64;
      return_value_gtk_table_get_type$64=gtk_table_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$65;
      return_value_g_type_check_instance_cast$65=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.table_skills_exp, return_value_gtk_table_get_type$64);
      gtk_table_attach((struct _GtkTable *)return_value_g_type_check_instance_cast$65, statwindow.skill_exp[(signed long int)i], (unsigned int)x, (unsigned int)(x + 1), (unsigned int)y, (unsigned int)(y + 1), (enum anonymous$16)GTK_EXPAND, (enum anonymous$16)0, (unsigned int)0, (unsigned int)0);
      gtk_widget_show(statwindow.skill_exp[(signed long int)i]);
      x = x + 1;
      if(x == 6)
      {
        x = 0;
        y = y + 1;
      }

    }
  }

  struct _GObject *return_value_gtk_builder_get_object$66;
  return_value_gtk_builder_get_object$66=gtk_builder_get_object(window_xml, "table_protections");
  unsigned long int return_value_gtk_widget_get_type$67;
  return_value_gtk_widget_get_type$67=gtk_widget_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$68;
  return_value_g_type_check_instance_cast$68=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$66, return_value_gtk_widget_get_type$67);
  statwindow.table_protections = (struct _GtkWidget *)return_value_g_type_check_instance_cast$68;
  i = 0;
  x = 0;
  y = 0;
  for( ; !(i >= 6); i = i + 1)
  {
    statwindow.resists[(signed long int)i]=gtk_label_new("");
    unsigned long int return_value_gtk_table_get_type$69;
    return_value_gtk_table_get_type$69=gtk_table_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$70;
    return_value_g_type_check_instance_cast$70=g_type_check_instance_cast((struct _GTypeInstance *)statwindow.table_protections, return_value_gtk_table_get_type$69);
    gtk_table_attach((struct _GtkTable *)return_value_g_type_check_instance_cast$70, statwindow.resists[(signed long int)i], (unsigned int)x, (unsigned int)(x + 1), (unsigned int)y, (unsigned int)(y + 1), (enum anonymous$16)GTK_EXPAND, (enum anonymous$16)0, (unsigned int)0, (unsigned int)0);
    gtk_widget_show(statwindow.resists[(signed long int)i]);
    x = x + 1;
    if(x == 6)
    {
      x = 0;
      y = y + 1;
    }

  }
}

// stop_fire
// file ../../common/proto.h line 141
void stop_fire(void)
{
  if((signed int)cpl.input_state == Playing)
    dfire = dfire | 0x100;

}

// stop_run
// file ../../common/proto.h line 146
void stop_run(void)
{
  send_command("run_stop", -1, 1);
  drun = drun | 0x100;
}

// strdup_local
// file ../../common/proto.h line 113
char * strdup_local(const char *str)
{
  char *c;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(str);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(char) /*1ul*/  * return_value_strlen$1 + (unsigned long int)1);
  c = (char *)return_value_malloc$2;
  strcpy(c, str);
  return c;
}

// toggle_buttons_scope
// file keys.c line 2045
void toggle_buttons_scope(signed int scope)
{
  signed int state_u;
  signed int state_c;
  unsigned long int return_value_gtk_toggle_button_get_type$1;
  return_value_gtk_toggle_button_get_type$1=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)kb_scope_togglebutton_global, return_value_gtk_toggle_button_get_type$1);
  state_u=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$2);
  unsigned long int return_value_gtk_toggle_button_get_type$3;
  return_value_gtk_toggle_button_get_type$3=gtk_toggle_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)kb_scope_togglebutton_character, return_value_gtk_toggle_button_get_type$3);
  state_c=gtk_toggle_button_get_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$4);
  if(state_u == state_c || !(state_u == scope))
  {
    unsigned long int return_value_gtk_toggle_button_get_type$5;
    return_value_gtk_toggle_button_get_type$5=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)kb_scope_togglebutton_character, return_value_gtk_toggle_button_get_type$5);
    g_signal_handlers_block_matched((void *)(struct _GtkToggleButton *)return_value_g_type_check_instance_cast$6, (enum anonymous$7)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_kb_scope_togglebutton_character_toggled, (void *)0);
    unsigned long int return_value_gtk_toggle_button_get_type$7;
    return_value_gtk_toggle_button_get_type$7=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
    return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)kb_scope_togglebutton_global, return_value_gtk_toggle_button_get_type$7);
    g_signal_handlers_block_matched((void *)(struct _GtkToggleButton *)return_value_g_type_check_instance_cast$8, (enum anonymous$7)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_kb_scope_togglebutton_global_toggled, (void *)0);
    unsigned long int return_value_gtk_toggle_button_get_type$9;
    return_value_gtk_toggle_button_get_type$9=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)kb_scope_togglebutton_character, return_value_gtk_toggle_button_get_type$9);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$10, (signed int)!(scope != 0));
    unsigned long int return_value_gtk_toggle_button_get_type$11;
    return_value_gtk_toggle_button_get_type$11=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
    return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)kb_scope_togglebutton_global, return_value_gtk_toggle_button_get_type$11);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$12, scope);
    unsigned long int return_value_gtk_toggle_button_get_type$13;
    return_value_gtk_toggle_button_get_type$13=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
    return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)kb_scope_togglebutton_character, return_value_gtk_toggle_button_get_type$13);
    g_signal_handlers_unblock_matched((void *)(struct _GtkToggleButton *)return_value_g_type_check_instance_cast$14, (enum anonymous$7)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_kb_scope_togglebutton_character_toggled, (void *)0);
    unsigned long int return_value_gtk_toggle_button_get_type$15;
    return_value_gtk_toggle_button_get_type$15=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
    return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)kb_scope_togglebutton_global, return_value_gtk_toggle_button_get_type$15);
    g_signal_handlers_unblock_matched((void *)(struct _GtkToggleButton *)return_value_g_type_check_instance_cast$16, (enum anonymous$7)(G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), (unsigned int)0, (unsigned int)0, (struct _GClosure *)(void *)0, (void *)(void (*)(void))on_kb_scope_togglebutton_global_toggled, (void *)0);
  }

}

// toggle_keybind_scope
// file keys.c line 2120
void toggle_keybind_scope(signed int scope, struct keybind *kb)
{
  struct keybind *kb_old;
  struct keybind **next_ptr;
  signed int ret;
  signed int flags;
  char buf[256l];
  kb_old=keybind_find(kb->keysym, (unsigned int)kb->flags, scope);
  while(!(kb_old == ((struct keybind *)NULL)))
  {
    signed int return_value_keybind_overwrite_confirm$1;
    return_value_keybind_overwrite_confirm$1=keybind_overwrite_confirm(kb_old);
    if(return_value_keybind_overwrite_confirm$1 == 0)
    {
      toggle_buttons_scope((signed int)!(scope != 0));
      keybindings_init(cpl.name);
      update_keybinding_list();
      goto __CPROVER_DUMP_L11;
    }

    keybind_remove(kb_old);
    keybind_free(&kb_old);
    kb_old=keybind_find(kb->keysym, (unsigned int)kb->flags, scope);
  }
  if(!(scope == 0))
  {
    if((64 & (signed int)kb->flags) == 0)
    {
      ret=keybind_remove(kb);
      if(ret == -1)
      {
        draw_ext_info(0, 20, 9, "\nCould not remove keybind. Operation failed.\n");
        toggle_buttons_scope((signed int)!(scope != 0));
        keybindings_init(cpl.name);
        update_keybinding_list();
        goto __CPROVER_DUMP_L11;
      }

      kb->flags = kb->flags ^ (unsigned char)(1 << 7);
      kb->flags = kb->flags | (unsigned char)(1 << 6);
      next_ptr = &keys_global[(signed long int)(kb->keysym % (unsigned int)257)];
      kb->next = (struct keybind *)(void *)0;
      if(!(*next_ptr == ((struct keybind *)NULL)))
      {
        for( ; !((*next_ptr)->next == ((struct keybind *)NULL)); next_ptr = &(*next_ptr)->next)
          ;
        (*next_ptr)->next = kb;
      }

      else
        keys_global[(signed long int)(kb->keysym % (unsigned int)257)] = kb;
    }

  }

  else
    if(!((64 & (signed int)kb->flags) == 0))
    {
      snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%s", kb->command);
      flags = (signed int)kb->flags;
      flags = flags | 1 << 7;
      flags = flags ^ 1 << 6;
      keybind_insert(kb->keysym, (unsigned int)flags, buf);
    }

  save_keys();
  update_keybinding_list();

__CPROVER_DUMP_L11:
  ;
}

// toggle_locked
// file ../../common/proto.h line 71
void toggle_locked(struct item_struct *op)
{
  struct SockList sl;
  unsigned char buf[256l];
  if(!(op->env->tag == 0))
  {
    snprintf((char *)buf, sizeof(unsigned char [256l]) /*256ul*/ , "lock %c %d", !(op->locked != 0), op->tag);
    script_monitor_str((char *)buf);
    SockList_Init(&sl, buf);
    SockList_AddString(&sl, "lock ");
    SockList_AddChar(&sl, (char)!(op->locked != 0));
    SockList_AddInt(&sl, (unsigned int)op->tag);
    SockList_Send(&sl, csocket.fd);
  }

}

// trigger_skill
// file skills.c line 201
extern void trigger_skill(struct _GtkTreeIter iter, struct _GtkTreeModel *model, signed int use_skill)
{
  char *skname;
  char command[256l];
  char *commandname;
  gtk_tree_model_get(model, &iter, 0, &skname, -1);
  if(skname == ((char *)NULL))
    LOG((enum LogLevel)LOG_ERROR, "skills.c::trigger_skill", "Unable to get skill name\n");

  else
  {
    commandname = use_skill != 0 ? "use_skill" : "ready_skill";
    snprintf(command, (unsigned long int)(256 - 1), "%s %s", commandname, skname);
    send_command(command, -1, 1);
    g_free((void *)skname);
  }
}

// unbind_key
// file keys.c line 1466
extern void unbind_key(const char *params)
{
  signed int count = 0;
  signed int keyentry;
  signed int slot;
  signed int j;
  signed int res;
  struct keybind *kb;
  char buf[256l];
  struct keybind *tmp_if_expr$1;
  if(params == ((const char *)NULL))
    show_keys();

  else
  {
    for( ; (signed int)*params == 32; params = params + 1l)
      ;
    if((signed int)*params == 0)
      show_keys();

    else
    {
      keyentry=atoi(params);
      if(keyentry == 0)
        unbind_usage();

      else
      {
        slot = 0;
        for( ; !(slot >= 257); slot = slot + 1)
        {
          j = 0;
          for( ; !(j >= 2); j = j + 1)
          {
            if(j == 0)
              tmp_if_expr$1 = keys_global[(signed long int)slot];

            else
              tmp_if_expr$1 = keys_char[(signed long int)slot];
            kb = tmp_if_expr$1;
            for( ; !(kb == ((struct keybind *)NULL)); kb = kb->next)
            {
              count = count + 1;
              if(keyentry == count)
              {
                char *return_value_get_key_info$2;
                return_value_get_key_info$2=get_key_info(kb, 0);
                snprintf(buf, sizeof(char [256l]) /*256ul*/ , "Removing binding: %3d %s", count, return_value_get_key_info$2);
                draw_ext_info(0, 20, 1, buf);
                res=keybind_remove(kb);
                if(!(res >= 0))
                  LOG((enum LogLevel)LOG_ERROR, "gtk-v2::unbind_key", "found number entry, but could not find actual key");

                keybind_free(&kb);
                save_keys();
                goto __CPROVER_DUMP_L15;
              }

            }
          }
        }
        draw_ext_info(0, 20, 6, "");
        draw_ext_info(0, 20, 6, "Not found. Try 'unbind' with no options to find entry.");
        goto __CPROVER_DUMP_L15;
      }
    }
  }

__CPROVER_DUMP_L15:
  ;
}

// unbind_usage
// file keys.c line 1455
static void unbind_usage(void)
{
  draw_ext_info(0, 20, 6, "Usage: 'unbind <entry_number>' or");
  draw_ext_info(0, 20, 6, "Usage: 'unbind' to show existing bindings");
}

// update_all_stats
// file create_char.c line 211
static void update_all_stats()
{
  signed int i;
  signed int stat_points_used = 0;
  signed int statval;
  signed int tmp;
  const char *tval;
  char buf[256l];
  negative_stat = 0;
  i = 0;
  for( ; !(i >= 7); i = i + 1)
  {
    unsigned long int return_value_gtk_spin_button_get_type$1;
    return_value_gtk_spin_button_get_type$1=gtk_spin_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)spinbutton_cc[(signed long int)i], return_value_gtk_spin_button_get_type$1);
    tmp=gtk_spin_button_get_value_as_int((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$2);
    stat_points_used = stat_points_used + tmp;
    statval = tmp;
    unsigned long int return_value_gtk_label_get_type$3;
    return_value_gtk_label_get_type$3=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
    return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)label_cs[(signed long int)i], return_value_gtk_label_get_type$3);
    tval=gtk_label_get_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4);
    signed int return_value_atoi$5;
    return_value_atoi$5=atoi(tval);
    statval = statval + return_value_atoi$5;
    unsigned long int return_value_gtk_label_get_type$6;
    return_value_gtk_label_get_type$6=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$7;
    return_value_g_type_check_instance_cast$7=g_type_check_instance_cast((struct _GTypeInstance *)label_rs[(signed long int)i], return_value_gtk_label_get_type$6);
    tval=gtk_label_get_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$7);
    signed int return_value_atoi$8;
    return_value_atoi$8=atoi(tval);
    statval = statval + return_value_atoi$8;
    if(!(statval >= 1))
      negative_stat = 1;

    sprintf(buf, "%d", statval);
    unsigned long int return_value_gtk_label_get_type$9;
    return_value_gtk_label_get_type$9=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
    return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)label_tot[(signed long int)i], return_value_gtk_label_get_type$9);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$10, buf);
  }
  tmp = stat_points - stat_points_used;
  sprintf(buf, "%d", tmp);
  unsigned long int return_value_gtk_label_get_type$11;
  return_value_gtk_label_get_type$11=gtk_label_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$12;
  return_value_g_type_check_instance_cast$12=g_type_check_instance_cast((struct _GTypeInstance *)label_cc_unspent, return_value_gtk_label_get_type$11);
  gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$12, buf);
  if(!(tmp >= 0))
  {
    unsigned long int return_value_gtk_label_get_type$13;
    return_value_gtk_label_get_type$13=gtk_label_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$14;
    return_value_g_type_check_instance_cast$14=g_type_check_instance_cast((struct _GTypeInstance *)label_cc_status_update, return_value_gtk_label_get_type$13);
    gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$14, "You have used more than your allotted total attribute points");
  }

  else
    if(!(negative_stat == 0))
    {
      unsigned long int return_value_gtk_label_get_type$15;
      return_value_gtk_label_get_type$15=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$16;
      return_value_g_type_check_instance_cast$16=g_type_check_instance_cast((struct _GTypeInstance *)label_cc_status_update, return_value_gtk_label_get_type$15);
      gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$16, "Attributes less than 1 are not allowed - adjust your selections before finishing");
    }

    else
    {
      unsigned long int return_value_gtk_label_get_type$17;
      return_value_gtk_label_get_type$17=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$18;
      return_value_g_type_check_instance_cast$18=g_type_check_instance_cast((struct _GTypeInstance *)label_cc_status_update, return_value_gtk_label_get_type$17);
      gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$18, "Waiting for player selections");
    }
}

// update_character_choose
// file account.c line 572
extern void update_character_choose(const char *name, const char *class, const char *race, const char *face, const char *party, const char *map, signed int level, signed int faceno)
{
  struct _GtkTreeIter iter;
  gtk_list_store_append(character_store, &iter);
  if(pixmaps[(signed long int)faceno] == pixmaps[0l])
    gtk_list_store_set(character_store, &iter, 1, name, 2, class, 3, race, 0, face, 5, party, 6, map, 4, level, -1);

  else
    gtk_list_store_set(character_store, &iter, 7, pixmaps[(signed long int)faceno]->icon_image, 1, name, 2, class, 3, race, 0, face, 5, party, 6, map, 4, level, -1);
}

// update_ground
// file script_lua.c line 150
static void update_ground(struct lua_State *lua)
{
  struct item_struct *it;
  signed int index = 1;
  lua_pushstring(lua, "ground");
  lua_createtable(lua, 0, 0);
  lua_settable(lua, -10002);
  lua_pushstring(lua, "ground");
  lua_gettable(lua, -10002);
  it = cpl.below->inv;
  _Bool tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  signed int tmp_post$3;
  for( ; !(it == ((struct item_struct *)NULL)); it = it->next)
  {
    if(it->tag == 0)
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      return_value_strlen$1=strlen(it->s_name);
      tmp_if_expr$2 = return_value_strlen$1 == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr$2)
    {
      tmp_post$3 = index;
      index = index + 1;
      lua_pushnumber(lua, (double)tmp_post$3);
      do_item(lua, it);
      lua_settable(lua, -3);
    }

  }
  lua_settop(lua, -1 - 1);
}

// update_inv
// file script_lua.c line 132
static void update_inv(struct lua_State *lua)
{
  struct item_struct *it;
  signed int index = 1;
  lua_pushstring(lua, "inv");
  lua_createtable(lua, 0, 0);
  lua_settable(lua, -10002);
  lua_pushstring(lua, "inv");
  lua_gettable(lua, -10002);
  it = cpl.ob->inv;
  signed int tmp_post$1;
  for( ; !(it == ((struct item_struct *)NULL)); it = it->next)
  {
    tmp_post$1 = index;
    index = index + 1;
    lua_pushnumber(lua, (double)tmp_post$1);
    do_item(lua, it);
    lua_settable(lua, -3);
  }
  lua_settop(lua, -1 - 1);
}

// update_item
// file ./proto.h line 75
void update_item(signed int tag, signed int loc, char *name, signed int weight, signed int face, signed int flags, signed int anim, signed int animspeed, unsigned int nrof, signed int type)
{
  struct item_struct *ip;
  ip=locate_item(tag);
  struct item_struct *env;
  env=locate_item(loc);
  struct item_struct *tmp_if_expr$2;
  struct item_struct *return_value_create_new_item$1;
  if(player->tag == tag)
  {
    strncpy(player->d_name, name, (unsigned long int)(128 - 1));
    player->d_name[(signed long int)(128 - 1)] = (char)0;
    player->nrof = nrof;
    player->weight = (float)weight / (float)1000;
    player->face = (signed short int)face;
    get_flags(player, (unsigned short int)flags);
    if(!(player->inv == ((struct item_struct *)NULL)))
      player->inv->inv_updated = (unsigned short int)1;

    player->animation_id = (unsigned short int)anim;
    player->anim_speed = (unsigned char)animspeed;
    player->nrof = nrof;
  }

  else
  {
    if(!(ip == ((struct item_struct *)NULL)))
    {
      if(!(ip->env == env))
      {
        remove_item(ip);
        ip = (struct item_struct *)(void *)0;
      }

    }

    if(!(ip == ((struct item_struct *)NULL)))
      tmp_if_expr$2 = ip;

    else
    {
      return_value_create_new_item$1=create_new_item(env, tag);
      tmp_if_expr$2 = return_value_create_new_item$1;
    }
    set_item_values(tmp_if_expr$2, name, weight, (unsigned short int)face, (unsigned short int)flags, (unsigned short int)anim, (unsigned short int)animspeed, nrof, (unsigned short int)type);
  }
}

// update_item_sort
// file item.c line 91
void update_item_sort(struct item_struct *it)
{
  struct item_struct *itmp;
  struct item_struct *last = (struct item_struct *)(void *)0;
  _Bool tmp_if_expr$1;
  if(it->env == ((struct item_struct *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = it->env == it ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = it->env == map ? (_Bool)1 : (_Bool)0;
  signed int return_value_strcasecmp$3;
  signed int return_value_strcasecmp$4;
  if(!tmp_if_expr$2)
  {
    if(!(it->prev == ((struct item_struct *)NULL)))
    {
      if(!(it->prev->type == it->type))
        goto __CPROVER_DUMP_L6;

      if(!(it->prev->locked == it->locked))
        goto __CPROVER_DUMP_L6;

      return_value_strcasecmp$3=strcasecmp(it->prev->s_name, it->s_name);
      if(!(return_value_strcasecmp$3 == 0))
        goto __CPROVER_DUMP_L6;

    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      if(!(it->next == ((struct item_struct *)NULL)))
      {
        if(!(it->next->type == it->type))
          goto __CPROVER_DUMP_L7;

        if(!(it->next->locked == it->locked))
          goto __CPROVER_DUMP_L7;

        return_value_strcasecmp$4=strcasecmp(it->next->s_name, it->s_name);
        if(!(return_value_strcasecmp$4 == 0))
          goto __CPROVER_DUMP_L7;

      }

      else
      {

      __CPROVER_DUMP_L7:
        ;
        if(!(it->prev == ((struct item_struct *)NULL)))
          it->prev->next = it->next;

        if(!(it->next == ((struct item_struct *)NULL)))
          it->next->prev = it->prev;

        if(it->env->inv == it)
          it->env->inv = it->next;

        itmp = it->env->inv;
        for( ; !(itmp == ((struct item_struct *)NULL)); itmp = itmp->next)
        {
          last = itmp;
          if(!((signed int)it->type >= (signed int)itmp->type))
          {
            insert_item_before_item(it, itmp);
            goto __CPROVER_DUMP_L17;
          }

          else
            if(itmp->type == it->type)
            {
              signed int return_value_strcasecmp$5;
              return_value_strcasecmp$5=strcasecmp(itmp->s_name, it->s_name);
              if(return_value_strcasecmp$5 >= 0)
              {
                insert_item_before_item(it, itmp);
                goto __CPROVER_DUMP_L17;
              }

            }

        }
        if(!(last == ((struct item_struct *)NULL)))
          last->next = it;

        else
          it->env->inv = it;
        it->prev = last;
        it->next = (struct item_struct *)(void *)0;
      }
    }
  }


__CPROVER_DUMP_L17:
  ;
}

// update_keybinding_list
// file keys.c line 1904
extern void update_keybinding_list(void)
{
  signed int i;
  signed int j;
  struct keybind *kb;
  char *modifier_label;
  char *scope_label;
  struct _GtkTreeIter iter;
  gtk_list_store_clear(keybinding_store);
  i = 0;
  struct keybind *tmp_if_expr$1;
  for( ; !(i >= 257); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 2); j = j + 1)
    {
      if(j == 0)
        tmp_if_expr$1 = keys_global[(signed long int)i];

      else
        tmp_if_expr$1 = keys_char[(signed long int)i];
      kb = tmp_if_expr$1;
      for( ; !(kb == ((struct keybind *)NULL)); kb = kb->next)
      {
        if(j == 0)
          kb->flags = kb->flags | (unsigned char)(1 << 6);

        else
          kb->flags = kb->flags | (unsigned char)(1 << 7);
        if(!((16 & (signed int)kb->flags) == 0))
          modifier_label = "Any";

        else
          if((15 & (signed int)kb->flags) == 0)
            modifier_label = "None";

          else
          {
            if(!((4 & (signed int)kb->flags) == 0))
            {
              modifier_label = "Alt";
              if(!((11 & (signed int)kb->flags) == 0))
                modifier_label = " + ";

            }

            if(!((1 & (signed int)kb->flags) == 0))
            {
              modifier_label = "Fire";
              if(!((10 & (signed int)kb->flags) == 0))
                modifier_label = " + ";

            }

            if(!((2 & (signed int)kb->flags) == 0))
            {
              modifier_label = "Run";
              if(!((8 & (signed int)kb->flags) == 0))
                modifier_label = " + ";

            }

            if(!((8 & (signed int)kb->flags) == 0))
              modifier_label = "Meta";

          }
        if((64 & (signed int)kb->flags) == 0)
          scope_label = "char";

        else
          scope_label = "global";
        gtk_list_store_append(keybinding_store, &iter);
        char *return_value_gdk_keyval_name$2;
        return_value_gdk_keyval_name$2=gdk_keyval_name(kb->keysym);
        gtk_list_store_set(keybinding_store, &iter, 0, i, 1, return_value_gdk_keyval_name$2, 2, modifier_label, 3, scope_label, 4, ((signed int)kb->flags & 1 << 5) != 0 ? "Yes" : "No", 5, kb->command, 6, kb, -1);
      }
    }
  }
  reset_keybinding_status();
}

// update_login_info
// file account.c line 1315
extern void update_login_info(signed int type)
{
  const unsigned short int **return_value___ctype_b_loc$2;
  if(!(has_init == 0))
  {
    if(type == 1)
    {
      gtk_text_buffer_set_text(textbuf_news, "", 0);
      if(!(news == ((char *)NULL)))
      {
        char *mynews;
        char *cp;
        char *el;
        char big_buf[1024l];
        char *cp1;
        mynews=strdup(news);
        unsigned long int return_value_strlen$1;
        return_value_strlen$1=strlen(mynews);
        cp = mynews + (signed long int)return_value_strlen$1;
        for( ; !(mynews >= cp); cp = cp - 1l)
          if((signed int)*cp == 37)
          {
            if(cp == mynews || (signed int)cp[-1l] == 10)
            {
              el=strchr(cp, 10);
              if(!(el == ((char *)NULL)))
              {
                *el = (char)0;
                el = el + 1l;
              }

              cp1 = cp + (signed long int)1;
              do
              {
                return_value___ctype_b_loc$2=__ctype_b_loc();
                if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*cp1]) == 0)
                  break;

                cp1 = cp1 + 1l;
              }
              while((_Bool)1);
              snprintf(big_buf, (unsigned long int)1024, "[b]%s[/b]", cp1);
              add_marked_text_to_pane(&login_pane[(signed long int)1], big_buf, 0, 0, 0);
              if(!(el == ((char *)NULL)))
                add_marked_text_to_pane(&login_pane[(signed long int)1], el, 0, 0, 0);

              *cp = (char)0;
            }

          }

        if(!((signed int)*mynews == 0))
          add_marked_text_to_pane(&login_pane[(signed long int)1], mynews, 0, 0, 0);

      }

    }

    else
      if(type == 2)
      {
        gtk_text_buffer_set_text(textbuf_motd, "", 0);
        if(!(motd == ((char *)NULL)))
          add_marked_text_to_pane(&login_pane[(signed long int)0], motd, 0, 0, 0);

      }

      else
        if(type == 3)
        {
          gtk_text_buffer_set_text(textbuf_rules_account, "", 0);
          gtk_text_buffer_set_text(textbuf_rules_char, "", 0);
          if(!(rules == ((char *)NULL)))
          {
            add_marked_text_to_pane(&login_pane[(signed long int)2], rules, 0, 0, 0);
            add_marked_text_to_pane(&login_pane[(signed long int)3], rules, 0, 0, 0);
          }

        }

  }

}

// update_msgctrl_configuration
// file info.c line 1490
extern void update_msgctrl_configuration(void)
{
  unsigned int pane;
  unsigned int type;
  unsigned long int return_value_gtk_spin_button_get_type$1;
  return_value_gtk_spin_button_get_type$1=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)buffer_control.count.ptr, return_value_gtk_spin_button_get_type$1);
  gtk_spin_button_set_value((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$2, (double)buffer_control.count.state);
  unsigned long int return_value_gtk_spin_button_get_type$3;
  return_value_gtk_spin_button_get_type$3=gtk_spin_button_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
  return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)buffer_control.timer.ptr, return_value_gtk_spin_button_get_type$3);
  gtk_spin_button_set_value((struct _GtkSpinButton *)return_value_g_type_check_instance_cast$4, (double)buffer_control.timer.state);
  type = (unsigned int)0;
  for( ; !(type >= 20u); type = type + (unsigned int)1)
  {
    unsigned long int return_value_gtk_toggle_button_get_type$5;
    return_value_gtk_toggle_button_get_type$5=gtk_toggle_button_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
    return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)msgctrl_widgets[(signed long int)type].buffer.ptr, return_value_gtk_toggle_button_get_type$5);
    gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$6, msgctrl_widgets[(signed long int)type].buffer.state);
    pane = (unsigned int)0;
    for( ; !(pane >= 2u); pane = pane + (unsigned int)1)
    {
      unsigned long int return_value_gtk_toggle_button_get_type$7;
      return_value_gtk_toggle_button_get_type$7=gtk_toggle_button_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)msgctrl_widgets[(signed long int)type].pane[(signed long int)pane].ptr, return_value_gtk_toggle_button_get_type$7);
      gtk_toggle_button_set_active((struct _GtkToggleButton *)return_value_g_type_check_instance_cast$8, msgctrl_widgets[(signed long int)type].pane[(signed long int)pane].state);
    }
  }
}

// update_player
// file script_lua.c line 78
static void update_player(struct lua_State *lua)
{
  lua_pushstring(lua, "player");
  lua_gettable(lua, -10002);
  signed int return_value_lua_type$1;
  return_value_lua_type$1=lua_type(lua, -1);
  if(!(return_value_lua_type$1 == 5))
    lua_settop(lua, -1 - 1);

  else
  {
    lua_pushstring(lua, "hp");
    lua_pushnumber(lua, (double)cpl.stats.hp);
    lua_settable(lua, -3);
    lua_pushstring(lua, "gr");
    lua_pushnumber(lua, (double)cpl.stats.grace);
    lua_settable(lua, -3);
    lua_pushstring(lua, "sp");
    lua_pushnumber(lua, (double)cpl.stats.sp);
    lua_settable(lua, -3);
    lua_pushstring(lua, "food");
    lua_pushnumber(lua, (double)cpl.stats.food);
    lua_settable(lua, -3);
    lua_settop(lua, -1 - 1);
  }
}

// update_redrawbitmap
// file sdl.c line 830
static void update_redrawbitmap(void)
{
  signed int mx;
  signed int my;
  signed int x;
  signed int y;
  memset((void *)redrawbitmap, 0, (unsigned long int)(((signed int)use_config[(signed long int)19] + 2) * ((signed int)use_config[(signed long int)20] + 2)));
  x = 0;
  _Bool tmp_if_expr$1;
  for( ; !(x >= (signed int)use_config[19l]); x = x + 1)
  {
    y = 0;
    for( ; !(y >= (signed int)use_config[20l]); y = y + 1)
    {
      mx = x + pl_pos.x;
      my = y + pl_pos.y;
      if(!((the_map.cells[(signed long int)mx] + (signed long int)my)->need_update == 0))
      {
        redrawbitmap[(signed long int)(x + 1 + (y + 1) * (signed int)use_config[(signed long int)19])] = (char)1;
        if((signed int)use_config[17l] == 2)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = (signed int)use_config[(signed long int)17] == 3 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
        {
          redrawbitmap[(signed long int)(x + (y + 1) * (signed int)use_config[(signed long int)19])] = (char)1;
          redrawbitmap[(signed long int)(x + 2 + (y + 1) * (signed int)use_config[(signed long int)19])] = (char)1;
          redrawbitmap[(signed long int)(x + 1 + y * (signed int)use_config[(signed long int)19])] = (char)1;
          redrawbitmap[(signed long int)(x + 1 + (y + 2) * (signed int)use_config[(signed long int)19])] = (char)1;
        }

        if((signed int)use_config[17l] == 3)
        {
          redrawbitmap[(signed long int)(x + y * (signed int)use_config[(signed long int)19])] = (char)1;
          redrawbitmap[(signed long int)(x + 2 + y * (signed int)use_config[(signed long int)19])] = (char)1;
          redrawbitmap[(signed long int)(x + (y + 2) * (signed int)use_config[(signed long int)19])] = (char)1;
          redrawbitmap[(signed long int)(x + 2 + (y + 2) * (signed int)use_config[(signed long int)19])] = (char)1;
        }

      }

      else
        if(!((the_map.cells[(signed long int)mx] + (signed long int)my)->need_resmooth == 0))
          redrawbitmap[(signed long int)(x + 1 + (y + 1) * (signed int)use_config[(signed long int)19])] = (char)1;

    }
  }
}

// update_skill_information
// file skills.c line 66
extern void update_skill_information(void)
{
  struct _GtkTreeIter iter;
  char buf[256l];
  signed int i;
  signed int sk;
  signed int level;
  unsigned long int exp_to_next_level;
  _Bool tmp_if_expr$6;
  struct _GObject *return_value_gtk_builder_get_object$1;
  unsigned long int return_value_gtk_widget_get_type$2;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$3;
  unsigned long int return_value_gtk_object_get_type$4;
  struct _GTypeInstance *return_value_g_type_check_instance_cast$5;
  if(has_init$link2 == 0)
    tmp_if_expr$6 = (_Bool)1;

  else
  {
    return_value_gtk_builder_get_object$1=gtk_builder_get_object(dialog_xml, "skill_window");
    return_value_gtk_widget_get_type$2=gtk_widget_get_type();
    return_value_g_type_check_instance_cast$3=g_type_check_instance_cast((struct _GTypeInstance *)return_value_gtk_builder_get_object$1, return_value_gtk_widget_get_type$2);
    return_value_gtk_object_get_type$4=gtk_object_get_type();
    return_value_g_type_check_instance_cast$5=g_type_check_instance_cast((struct _GTypeInstance *)(struct _GtkWidget *)return_value_g_type_check_instance_cast$3, return_value_gtk_object_get_type$4);
    tmp_if_expr$6 = !((((struct _GtkObject *)return_value_g_type_check_instance_cast$5)->flags & (unsigned int)256) != (unsigned int)0) ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr$6)
  {
    gtk_list_store_clear(skill_store);
    i = 0;
    for( ; !(i >= 50); i = i + 1)
    {
      sk = skill_mapping[(signed long int)i].value;
      level = (signed int)cpl.stats.skill_level[(signed long int)sk];
      if(level >= 1)
      {
        gtk_list_store_append(skill_store, &iter);
        buf[(signed long int)0] = (char)0;
        if(level >= (signed int)exp_table_max)
          exp_to_next_level = (unsigned long int)0;

        else
          exp_to_next_level = exp_table[(signed long int)(level + 1)] - (unsigned long int)cpl.stats.skill_exp[(signed long int)sk];
        gtk_list_store_set(skill_store, &iter, 0, skill_mapping[(signed long int)i].name, 1, level, 2, cpl.stats.skill_exp[(signed long int)sk], 3, exp_to_next_level, -1);
      }

    }
  }

}

// update_spell_information
// file gtk2proto.h line 257
extern void update_spell_information(void)
{
  signed int i;
  struct Spell_struct *spell;
  struct _GtkTreeIter iter;
  char buf[256l];
  struct _GtkStyle *row_style;
  struct _GdkColor *foreground = (struct _GdkColor *)(void *)0;
  struct _GdkColor *background = (struct _GdkColor *)(void *)0;
  struct _PangoFontDescription *font = (struct _PangoFontDescription *)(void *)0;
  unsigned long int return_value_strlen$1;
  unsigned long int return_value_strlen$2;
  signed int tmp_if_expr$3;
  if(!(has_init$link3 == 0))
  {
    cpl.spells_updated = (unsigned int)0;
    i = 0;
    for( ; !(i >= 4); i = i + 1)
      if(!(spell_styles[(signed long int)i] == ((struct _GtkStyle *)NULL)))
      {
        gtk_widget_modify_fg(spell_label[(signed long int)i], (enum anonymous$25)GTK_STATE_NORMAL, &spell_styles[(signed long int)i]->text[(signed long int)GTK_STATE_NORMAL]);
        gtk_widget_modify_font(spell_label[(signed long int)i], spell_styles[(signed long int)i]->font_desc);
        gtk_widget_modify_bg(spell_eventbox[(signed long int)i], (enum anonymous$25)GTK_STATE_NORMAL, &spell_styles[(signed long int)i]->base[(signed long int)GTK_STATE_NORMAL]);
      }

      else
      {
        gtk_widget_modify_fg(spell_label[(signed long int)i], (enum anonymous$25)GTK_STATE_NORMAL, (const struct _GdkColor *)(void *)0);
        gtk_widget_modify_font(spell_label[(signed long int)i], (struct _PangoFontDescription *)(void *)0);
        gtk_widget_modify_bg(spell_eventbox[(signed long int)i], (enum anonymous$25)GTK_STATE_NORMAL, (const struct _GdkColor *)(void *)0);
      }
    gtk_list_store_clear(spell_store);
    spell = cpl.spelldata;
    for( ; !(spell == ((struct Spell_struct *)NULL)); spell = spell->next)
    {
      gtk_list_store_append(spell_store, &iter);
      buf[(signed long int)0] = (char)0;
      if(!(spell->sp == 0))
        snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%d Mana ", spell->sp);

      if(!(spell->grace == 0))
      {
        return_value_strlen$1=strlen(buf);
        return_value_strlen$2=strlen(buf);
        snprintf(buf + (signed long int)return_value_strlen$1, sizeof(char [256l]) /*256ul*/  - return_value_strlen$2, "%d Grace", spell->grace);
      }

      if(!((spell->path & cpl.stats.denied) == 0u))
        row_style = spell_styles[(signed long int)2];

      else
        if(!((spell->path & cpl.stats.repelled) == 0u))
          row_style = spell_styles[(signed long int)1];

        else
          if(!((spell->path & cpl.stats.attuned) == 0u))
            row_style = spell_styles[(signed long int)0];

          else
            row_style = spell_styles[(signed long int)3];
      if(!(row_style == ((struct _GtkStyle *)NULL)))
      {
        foreground = &row_style->text[(signed long int)GTK_STATE_NORMAL];
        background = &row_style->base[(signed long int)GTK_STATE_NORMAL];
        font = row_style->font_desc;
      }

      else
      {
        foreground = (struct _GdkColor *)(void *)0;
        background = (struct _GdkColor *)(void *)0;
        font = (struct _PangoFontDescription *)(void *)0;
      }
      if(!((signed int)spell->grace >= (signed int)spell->sp))
        tmp_if_expr$3 = (signed int)spell->sp;

      else
        tmp_if_expr$3 = (signed int)spell->grace;
      gtk_list_store_set(spell_store, &iter, 1, (const void *)spell->name, 2, spell->level, 4, (const void *)buf, 5, spell->dam, 6, spell->skill, 8, (const void *)spell->message, 9, background, 12, foreground, 13, font, 10, tmp_if_expr$3, 11, spell->tag, -1);
    }
  }

}

// update_stat
// file stats.c line 307
extern void update_stat(signed int stat_no, signed long int max_stat, signed long int current_stat, signed long int statbar_max, signed long int statbar_stat, signed int can_alert)
{
  float bar;
  char buf[256l];
  struct _GdkColor ncolor;
  struct _GdkColor *set_color = (struct _GdkColor *)(void *)0;
  if((signed long int)lastval[(signed long int)stat_no] == current_stat)
  {
    if(!((signed long int)lastmax[(signed long int)stat_no] == max_stat))
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    lastval[(signed long int)stat_no] = (signed int)current_stat;
    lastmax[(signed long int)stat_no] = (signed int)max_stat;
    if(statbar_max >= 1l)
      bar = (float)statbar_stat / (float)statbar_max;

    else
      bar = (float)0.0;
    if(!(use_config[24l] == 0))
    {
      struct _GdkColor *hcolor;
      struct _GdkColor *lcolor;
      float diff;
      if(bar > 1.000000f)
      {
        if(bar > 2.000000f)
          bar = (float)2.0;

        hcolor = bar_colors[(signed long int)stat_no][(signed long int)5];
        lcolor = bar_colors[(signed long int)stat_no][(signed long int)3];
        diff = (float)((double)bar - 1.0);
      }

      else
      {
        if(bar < 0.000000f)
          bar = (float)0.0;

        hcolor = bar_colors[(signed long int)stat_no][(signed long int)3];
        lcolor = bar_colors[(signed long int)stat_no][(signed long int)4];
        diff = bar;
      }
      if(!(hcolor == ((struct _GdkColor *)NULL)) && !(lcolor == ((struct _GdkColor *)NULL)))
      {
        memcpy((void *)&ncolor, (const void *)lcolor, sizeof(struct _GdkColor) /*12ul*/ );
        ncolor.red = ncolor.red + (unsigned short int)((float)((signed int)hcolor->red - (signed int)lcolor->red) * diff);
        ncolor.green = ncolor.green + (unsigned short int)((float)((signed int)hcolor->green - (signed int)lcolor->green) * diff);
        ncolor.blue = ncolor.blue + (unsigned short int)((float)((signed int)hcolor->blue - (signed int)lcolor->blue) * diff);
        set_color = &ncolor;
      }

    }

    else
      if(!(4l * statbar_stat >= statbar_max))
        set_color = bar_colors[(signed long int)stat_no][(signed long int)1];

      else
        if(!(statbar_max >= statbar_stat))
          set_color = bar_colors[(signed long int)stat_no][(signed long int)2];

        else
          set_color = bar_colors[(signed long int)stat_no][(signed long int)0];
    if(bar > 1.000000f)
      bar = (float)1.0;

    if(bar < 0.000000f)
      bar = (float)0.0;

    gtk_widget_modify_base(stat_bar[(signed long int)stat_no], (enum anonymous$25)GTK_STATE_SELECTED, set_color);
    gtk_widget_modify_bg(stat_bar[(signed long int)stat_no], (enum anonymous$25)GTK_STATE_PRELIGHT, set_color);
    unsigned long int return_value_gtk_progress_get_type$1;
    return_value_gtk_progress_get_type$1=gtk_progress_get_type();
    struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
    return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)stat_bar[(signed long int)stat_no], return_value_gtk_progress_get_type$1);
    gtk_progress_set_percentage((struct _GtkProgress *)return_value_g_type_check_instance_cast$2, (double)bar);
    if(stat_no == 4)
    {
      format_si_number(current_stat, buf, (signed int)sizeof(char [256l]) /*256ul*/ );
      unsigned long int return_value_gtk_label_get_type$3;
      return_value_gtk_label_get_type$3=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$4;
      return_value_g_type_check_instance_cast$4=g_type_check_instance_cast((struct _GTypeInstance *)stat_current[(signed long int)stat_no], return_value_gtk_label_get_type$3);
      gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$4, buf);
      format_si_number(max_stat, buf, (signed int)sizeof(char [256l]) /*256ul*/ );
      unsigned long int return_value_gtk_label_get_type$5;
      return_value_gtk_label_get_type$5=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$6;
      return_value_g_type_check_instance_cast$6=g_type_check_instance_cast((struct _GTypeInstance *)stat_max[(signed long int)stat_no], return_value_gtk_label_get_type$5);
      gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$6, buf);
    }

    else
    {
      snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%ld", current_stat);
      unsigned long int return_value_gtk_label_get_type$7;
      return_value_gtk_label_get_type$7=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$8;
      return_value_g_type_check_instance_cast$8=g_type_check_instance_cast((struct _GTypeInstance *)stat_current[(signed long int)stat_no], return_value_gtk_label_get_type$7);
      gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$8, buf);
      snprintf(buf, sizeof(char [256l]) /*256ul*/ , "%ld", max_stat);
      unsigned long int return_value_gtk_label_get_type$9;
      return_value_gtk_label_get_type$9=gtk_label_get_type();
      struct _GTypeInstance *return_value_g_type_check_instance_cast$10;
      return_value_g_type_check_instance_cast$10=g_type_check_instance_cast((struct _GTypeInstance *)stat_max[(signed long int)stat_no], return_value_gtk_label_get_type$9);
      gtk_label_set_text((struct _GtkLabel *)return_value_g_type_check_instance_cast$10, buf);
    }
  }
}

// update_stat_mapping
// file stats.c line 533
static void update_stat_mapping(void)
{
  signed int i = 0;
  for( ; !(i >= 50); i = i + 1)
  {
    skill_mapping[(signed long int)i].value = i;
    if(!(skill_names[(signed long int)i] == ((char *)NULL)))
      skill_mapping[(signed long int)i].name = skill_names[(signed long int)i];

    else
      skill_mapping[(signed long int)i].name = (const char *)(void *)0;
  }
  qsort((void *)skill_mapping, (unsigned long int)50, sizeof(struct anonymous$66) /*16ul*/ , (signed int (*)(const void *, const void *))mapping_sort);
  i = 0;
  for( ; !(i >= 18); i = i + 1)
  {
    resist_mapping[(signed long int)i].value = i;
    if(!(resists_name[(signed long int)i] == ((const char *)NULL)))
      resist_mapping[(signed long int)i].name = resists_name[(signed long int)i];

    else
      resist_mapping[(signed long int)i].name = (const char *)(void *)0;
  }
  qsort((void *)resist_mapping, (unsigned long int)18, sizeof(struct anonymous$66) /*16ul*/ , (signed int (*)(const void *, const void *))mapping_sort);
  need_mapping_update = 0;
}

// usage
// file main.c line 299
static void usage(char *progname)
{
  puts("Usage of crossfire-client-gtk2:\n");
  puts("-cache           - Cache images for future use.");
  puts("-nocache         - Do not cache images (default action).");
  puts("-darkness        - Enables darkness code (default)");
  puts("-nodarkness      - Disables darkness code");
  puts("-display <name>  - Use <name> instead if DISPLAY environment variable.");
  puts("-download_all_faces - Download all needed faces before play starts");
  puts("-echo            - Echo the bound commands");
  puts("-noecho          - Do not echo the bound commands (default)");
  puts("-faceset <name>  - Use faceset <name> if available");
  puts("-fasttcpsend     - Send data immediately to server, may increase bandwidth");
  puts("-nofasttcpsend   - Disables fasttcpsend");
  puts("-fog             - Enable fog of war code");
  puts("-help            - Display this message.");
  puts("-loglevel <val>  - Set default logging level (0 is most verbose)");
  puts("-iconscale %%    - Set icon scale percentage");
  puts("-mapscale %%     - Set map scale percentage");
  puts("-mapsize xXy     - Set the mapsize to be X by Y spaces. (default 11x11)");
  puts("-splash          - Display the splash screen (default)");
  puts("-nosplash        - Don't display the splash screen (startup logo)");
  puts("-opengl          - Use opengl drawing code");
  puts("-pixmap          - Use pixmap drawing code");
  puts("-port <number>   - Use port <number> instead of the standard port number");
  puts("-sdl             - Use sdl for drawing png (may not work on all hardware");
  puts("-server <name>   - Connect to <name> instead of localhost.");
  puts("-showicon        - Print status icons in inventory window");
  puts("-smooth          - Enable smooth");
  puts("-nosmooth        - Disable smooth (default)");
  puts("-sound           - Enable sound output (default).");
  puts("-nosound         - Disable sound output.");
  puts("-sound_server <path> - Executable to use to play sounds.");
  puts("-resists <val>   - Control look of resistances.");
  puts("-split           - Use split windows.");
  puts("-splitinfo       - Use two information windows, segregated by information type.");
  puts("-timemapredraw   - Print out timing information for map generation");
  puts("-triminfowindow  - Trims size of information window(s)");
  puts("-notriminfowindow  - Do not trims size of information window(s) (default)");
  puts("-updatekeycodes  - Update the saved bindings for this keyboard.");
  puts("-window_xml <file> - Glade Designer client UI layout XML file.");
  puts("-dialog_xml <file> - Glade Designer popup dialog XML file.");
  exit(0);
}

// use_skill
// file commands.c line 1316
void use_skill(signed int skill_id)
{
  signed int i = 0;
  signed int next;
  signed int prev = last_used_skills[(signed long int)0];
  if(!(last_used_skills[0l] == skill_id))
  {
    do
    {
      next = last_used_skills[(signed long int)(i + 1)];
      last_used_skills[(signed long int)(i + 1)] = prev;
      prev = next;
      i = i + 1;
    }
    while(next >= 0 && !(next == skill_id));
    last_used_skills[(signed long int)0] = skill_id;
  }

}

// user_read_data
// file png.c line 58
static void user_read_data(struct png_struct_def *png_ptr, unsigned char *data, unsigned long int length)
{
  memcpy((void *)data, (const void *)(data_cp + (signed long int)data_start), length);
  data_start = data_start + (signed int)length;
}

// write_socket
// file newsocket.c line 54
static signed int write_socket(signed int fd, const unsigned char *buf, signed int len)
{
  signed int amt = 0;
  const unsigned char *pos = buf;
  _Bool tmp_if_expr$4;
  signed int *return_value___errno_location$1;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  while(len >= 1)
  {
    do
    {
      signed long int return_value_write$5;
      return_value_write$5=write(fd, (const void *)pos, (unsigned long int)len);
      amt = (signed int)return_value_write$5;
      if(!(amt >= 0))
      {
        return_value___errno_location$1=__errno_location();
        if(*return_value___errno_location$1 == 4)
          tmp_if_expr$3 = (_Bool)1;

        else
        {
          return_value___errno_location$2=__errno_location();
          tmp_if_expr$3 = *return_value___errno_location$2 == 11 ? (_Bool)1 : (_Bool)0;
        }
        tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
    }
    while(tmp_if_expr$4);
    if(!(amt >= 0))
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      LOG((enum LogLevel)LOG_ERROR, "write_socket", "New socket (fd=%d) write failed: %s.\n", fd, return_value_strerror$7);
      return -1;
    }

    if(amt == 0)
      LOG((enum LogLevel)LOG_ERROR, "write_socket", "Write_To_Socket: No data written out.\n");

    len = len - amt;
    pos = pos + (signed long int)amt;
  }
  return 0;
}

// x_set_echo
// file keys.c line 1748
extern void x_set_echo(void)
{
  unsigned long int return_value_gtk_entry_get_type$1;
  return_value_gtk_entry_get_type$1=gtk_entry_get_type();
  struct _GTypeInstance *return_value_g_type_check_instance_cast$2;
  return_value_g_type_check_instance_cast$2=g_type_check_instance_cast((struct _GTypeInstance *)entry_commands, return_value_gtk_entry_get_type$1);
  gtk_entry_set_visibility((struct _GtkEntry *)return_value_g_type_check_instance_cast$2, (signed int)!(cpl.no_echo != 0u));
}

