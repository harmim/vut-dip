// tag-#anon#ST[*{S8}$S8$'cacertificateFile'||*{S8}$S8$'cacertificatePath'||*{S8}$S8$'sCertificateDepth'||S32'certificateDepth'||U32'$pad0'||*{S8}$S8$'certificateFile'||*{S8}$S8$'keysFile'||*{S8}$S8$'dateFormat'||S32'realmsNumber'||U32'$pad1'||S64'startTime'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'hostName'||*{S8}$S8$'sUsersLimit'||*{S8}$S8$'sClientsLimit'||*{S8}$S8$'sRaClientsLimit'||*{S8}$S8$'sUsersPerClient'||*{S8}$S8$'sClientMode'||*{S8}$S8$'sTimeout'||*{S8}$S8$'sMaxIdle'||*{S8}$S8$'realmName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'$pad0'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$$'usersClientsTable'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'hostName'||*{S8}$S8$'sUsersLimit'||*{S8}$S8$'sClientsLimit'||*{S8}$S8$'sRaClientsLimit'||*{S8}$S8$'sUsersPerClient'||*{S8}$S8$'sClientMode'||*{S8}$S8$'sTimeout'||*{S8}$S8$'sMaxIdle'||*{S8}$S8$'realmName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'$pad0'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$$'usersClientsTable'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'hostName'||*{S8}$S8$'sUsersLimit'||*{S8}$S8$'sClientsLimit'||*{S8}$S8$'sRaClientsLimit'||*{S8}$S8$'sUsersPerClient'||*{S8}$S8$'sClientMode'||*{S8}$S8$'sTimeout'||*{S8}$S8$'sMaxIdle'||*{S8}$S8$'realmName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'$pad0'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$$'usersClientsTable'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'hostName'||*{S8}$S8$'sUsersLimit'||*{S8}$S8$'sClientsLimit'||*{S8}$S8$'sRaClientsLimit'||*{S8}$S8$'sUsersPerClient'||*{S8}$S8$'sClientMode'||*{S8}$S8$'sTimeout'||*{S8}$S8$'sMaxIdle'||*{S8}$S8$'realmName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'$pad0'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$$'usersClientsTable'|]#$$'realmsTable'|]
// file server_configuration_struct.h line 27
struct anonymous$2;

// tag-#anon#ST[*{S8}$S8$'hostName'||*{S8}$S8$'sUsersLimit'||*{S8}$S8$'sClientsLimit'||*{S8}$S8$'sRaClientsLimit'||*{S8}$S8$'sUsersPerClient'||*{S8}$S8$'sClientMode'||*{S8}$S8$'sTimeout'||*{S8}$S8$'sMaxIdle'||*{S8}$S8$'realmName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'$pad0'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$$'usersClientsTable'|]
// file server_realm_struct.h line 26
struct anonymous$5;

// tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]
// file usr_cli_struct.h line 25
struct anonymous$7;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'cacertificateFile'||*{S8}$S8$'cacertificatePath'||*{S8}$S8$'sCertificateDepth'||S32'certificateDepth'||U32'$pad0'||*{S8}$S8$'certificateFile'||*{S8}$S8$'keysFile'||*{S8}$S8$'dateFormat'||S32'realmsNumber'||U32'$pad1'||S64'startTime'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'hostName'||*{S8}$S8$'sUsersLimit'||*{S8}$S8$'sClientsLimit'||*{S8}$S8$'sRaClientsLimit'||*{S8}$S8$'sUsersPerClient'||*{S8}$S8$'sClientMode'||*{S8}$S8$'sTimeout'||*{S8}$S8$'sMaxIdle'||*{S8}$S8$'realmName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'$pad0'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$$'usersClientsTable'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'hostName'||*{S8}$S8$'sUsersLimit'||*{S8}$S8$'sClientsLimit'||*{S8}$S8$'sRaClientsLimit'||*{S8}$S8$'sUsersPerClient'||*{S8}$S8$'sClientMode'||*{S8}$S8$'sTimeout'||*{S8}$S8$'sMaxIdle'||*{S8}$S8$'realmName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'$pad0'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$$'usersClientsTable'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'hostName'||*{S8}$S8$'sUsersLimit'||*{S8}$S8$'sClientsLimit'||*{S8}$S8$'sRaClientsLimit'||*{S8}$S8$'sUsersPerClient'||*{S8}$S8$'sClientMode'||*{S8}$S8$'sTimeout'||*{S8}$S8$'sMaxIdle'||*{S8}$S8$'realmName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'$pad0'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$$'usersClientsTable'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'hostName'||*{S8}$S8$'sUsersLimit'||*{S8}$S8$'sClientsLimit'||*{S8}$S8$'sRaClientsLimit'||*{S8}$S8$'sUsersPerClient'||*{S8}$S8$'sClientMode'||*{S8}$S8$'sTimeout'||*{S8}$S8$'sMaxIdle'||*{S8}$S8$'realmName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'$pad0'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$$'usersClientsTable'|]#$$'realmsTable'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'cacertificateFile'||*{S8}$S8$'cacertificatePath'||*{S8}$S8$'sCertificateDepth'||S32'certificateDepth'||U32'$pad0'||*{S8}$S8$'certificateFile'||*{S8}$S8$'keysFile'||*{S8}$S8$'dateFormat'||S32'realmsNumber'||U32'$pad1'||S64'startTime'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'hostName'||*{S8}$S8$'sUsersLimit'||*{S8}$S8$'sClientsLimit'||*{S8}$S8$'sRaClientsLimit'||*{S8}$S8$'sUsersPerClient'||*{S8}$S8$'sClientMode'||*{S8}$S8$'sTimeout'||*{S8}$S8$'sMaxIdle'||*{S8}$S8$'realmName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'$pad0'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$$'usersClientsTable'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'hostName'||*{S8}$S8$'sUsersLimit'||*{S8}$S8$'sClientsLimit'||*{S8}$S8$'sRaClientsLimit'||*{S8}$S8$'sUsersPerClient'||*{S8}$S8$'sClientMode'||*{S8}$S8$'sTimeout'||*{S8}$S8$'sMaxIdle'||*{S8}$S8$'realmName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'$pad0'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$$'usersClientsTable'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'hostName'||*{S8}$S8$'sUsersLimit'||*{S8}$S8$'sClientsLimit'||*{S8}$S8$'sRaClientsLimit'||*{S8}$S8$'sUsersPerClient'||*{S8}$S8$'sClientMode'||*{S8}$S8$'sTimeout'||*{S8}$S8$'sMaxIdle'||*{S8}$S8$'realmName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'$pad0'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$$'usersClientsTable'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'hostName'||*{S8}$S8$'sUsersLimit'||*{S8}$S8$'sClientsLimit'||*{S8}$S8$'sRaClientsLimit'||*{S8}$S8$'sUsersPerClient'||*{S8}$S8$'sClientMode'||*{S8}$S8$'sTimeout'||*{S8}$S8$'sMaxIdle'||*{S8}$S8$'realmName'||ARR4{U8}$U8$'password'||S32'connectedUsers'||S32'usersLimit'||S32'connectedClients'||S32'clientsLimit'||S32'connectedRaClients'||S32'raClientsLimit'||S32'usersPerClient'||S32'timeout'||S32'maxIdle'||S32'clientMode'||S32'userClientPairs'||S32'clientsCounter'||S32'usersCounter'||S8'realmType'||S8'tunnelType'||S8'dnsLookupsOn'||S8'basePortOn'||S8'auditOn'||U24'$pad0'||U32'addressLength'||U32'$pad1'||*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'clientAddress'||*{*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#}$SYM#tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]#$$'usersTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'clientsTable'||*{*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$}$*{SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#}$SYM#tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]#$$'raClientsTable'||*{*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$}$*{SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'listenHostName'||*{S8}$S8$'manageHostName'||*{S8}$S8$'listenPortName'||*{S8}$S8$'managePortName'||S32'listenFd'||S32'manageFd'||S32'number'||U32'$pad0'|]#$$'usersClientsTable'|]#$$'realmsTable'|]#$'config'||S32'realm'||S32'client'||S8'ra'||S8'reason'||U48'$pad0'||*{SYM#tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]#}$SYM#tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]#$'set'||*{SYM#tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]#}$SYM#tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]#$'wset'|]
// file remove_client_task.h line 29
struct anonymous$25;

// tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]
// file task_struct.h line 24
struct anonymous$13;

// tag-#anon#ST[*{SYM#tag-tlnode#}$SYM#tag-tlnode#$'head'||S32'numberOfTasks'||U32'$pad0'||*{SYM#tag-tlnode#}$SYM#tag-tlnode#$'actualTask'||SYM#tag-timeval#'delta'|]
// file task_scheduler_struct.h line 26
struct anonymous$16;

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$17;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$14;

// tag-#anon#ST[ARR128{U8}$U8$'cert_verify_md'||ARR128{U8}$U8$'finish_md'||S32'finish_md_len'||ARR128{U8}$U8$'peer_finish_md'||S32'peer_finish_md_len'||U64'message_size'||S32'message_type'||U32'$pad0'||*{cSYM#tag-ssl_cipher_st#}$cSYM#tag-ssl_cipher_st#$'new_cipher'||*{SYM#tag-dh_st#}$SYM#tag-dh_st#$'dh'||*{SYM#tag-ec_key_st#}$SYM#tag-ec_key_st#$'ecdh'||S32'next_state'||S32'reuse_message'||S32'cert_req'||S32'ctype_num'||ARR9{S8}$S8$'ctype'||U56'$pad1'||*{SYM#tag-stack_st_X509_NAME#}$SYM#tag-stack_st_X509_NAME#$'ca_names'||S32'use_rsa_tmp'||S32'key_block_length'||*{U8}$U8$'key_block'||*{cSYM#tag-evp_cipher_st#}$cSYM#tag-evp_cipher_st#$'new_sym_enc'||*{cSYM#tag-env_md_st#}$cSYM#tag-env_md_st#$'new_hash'||S32'new_mac_pkey_type'||S32'new_mac_secret_size'||*{cSYM#tag-ssl_comp_st#}$cSYM#tag-ssl_comp_st#$'new_compression'||S32'cert_request'||U32'$pad2'|]
// file /usr/include/openssl/ssl3.h line 553
struct anonymous$0;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$22;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$19;

// tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]
// file header_buffer_struct.h line 24
struct anonymous$8;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 140
struct anonymous$30;

// tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]
// file ssl_fd_struct.h line 27
struct anonymous$1;

// tag-#anon#ST[S32'sess_connect'||S32'sess_connect_renegotiate'||S32'sess_connect_good'||S32'sess_accept'||S32'sess_accept_renegotiate'||S32'sess_accept_good'||S32'sess_miss'||S32'sess_timeout'||S32'sess_cache_full'||S32'sess_hit'||S32'sess_cb_hit'|]
// file /usr/include/openssl/ssl.h line 964
struct anonymous$24;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$9;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$12;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$11;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$21;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$10;

// tag-#anon#ST[S32'sockfd'||U32'$pad0'||*{S8}$S8$'host'||*{S8}$S8$'serv'||*{U32}$U32$'addrlenp'||S8'type'||U24'$pad1'||S32'limit'||S8'https'||U56'$pad2'||*{SYM#tag-ssl_ctx_st#}$SYM#tag-ssl_ctx_st#$'ctx'|]
// file http_proxy_server.c line 32
struct anonymous$28;

// tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]
// file user_stats_struct.h line 27
struct anonymous$6;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$15;

// tag-#anon#ST[S8'read_state'||ARR4{S8}$S8$'readed_length'||S8'state'||ARR10{S8}$S8$'id'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'postFd'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'getFd'||S32'sent_ptr'||S32'sockfd'||ARR9000{S8}$S8$'buf'||ARR9000{S8}$S8$'tmpbuf'||S8'tmpstate'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'tmpFd'||S8'type'||U24'$pad1'||SYM#tag-#anon#ST[S8'type'||ARR10{S8}$S8$'id'||U8'$pad0'||S32'ptr'||S32'length'||S32'allreaded'|]#'tmpheader'||S32'ptr'||S32'length'||S32'curreceived'||S32'toreceive'||S32'received'|]
// file http_proxy_functions.h line 52
struct anonymous$27;

// tag-#anon#ST[S8'state'||U24'$pad0'||S32'connFd'||S32'whatClient'||S32'userId'||S64'connectTime'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||U8'$pad1'||*{SYM#tag-buflist#}$SYM#tag-buflist#$'bufList'||*{SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#}$SYM#tag-#anon#ST[S64'lastActivity'||S64'lastUSQChange'||S64'lastDSQChange'||S32'totalDownloadedBytes'||S32'totalUploadedBytes'||S32'uploadSQP'||ARR3{S32}$S32$'uploadSpeedQueue'||S32'downloadSQP'||ARR3{S32}$S32$'downloadSpeedQueue'|]#$'stats'|]
// file connect_user_struct.h line 30
struct anonymous$4;

// tag-#anon#ST[S8'state'||U56'$pad0'||*{SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#}$SYM#tag-#anon#ST[S32'fd'||U32'$pad0'||*{SYM#tag-ssl_st#}$SYM#tag-ssl_st#$'ssl'|]#$'sslFd'||SYM#tag-timeval#'timer'||*{S32}$S32$'users'||S32'connected'||S32'limit'||S32'listenFd'||S32'usrCliPair'||S32'clientId'||U32'$pad1'||S64'connectTime'||S64'lastActivity'||*{S8}$S8$'sClientId'||ARR128{S8}$S8$'nameBuf'||ARR7{S8}$S8$'portBuf'||S8'tunnelType'||S8'multi'||U56'$pad2'||*{SYM#tag-auditlist#}$SYM#tag-auditlist#$'auditList'||*{SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#}$SYM#tag-#anon#ST[ARR5{U8}$U8$'tab'||U24'$pad0'||S32'readed'|]#$'header'||*{SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#}$SYM#tag-#anon#ST[*{SYM#tag-timeval#}$SYM#tag-timeval#$'timerp'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'function'||*{V}$V$'data'||*{V(*{*{V}$V$}$*{V}$V$$)->V}$V(*{*{V}$V$}$*{V}$V$$)->V$'clean'|]#$'task'|]
// file connect_client_struct.h line 46
struct anonymous$3;

// tag-#anon#ST[S8'type'||ARR10{S8}$S8$'id'||U8'$pad0'||S32'ptr'||S32'length'||S32'allreaded'|]
// file http_proxy_functions.h line 44
struct anonymous$26;

// tag-#anon#ST[U32'conn_id_length'||U32'cert_type'||U32'cert_length'||U32'csl'||U32'clear'||U32'enc'||ARR32{U8}$U8$'ccl'||U32'cipher_spec_length'||U32'session_id_length'||U32'clen'||U32'rlen'|]
// file /usr/include/openssl/ssl2.h line 203
struct anonymous;

// tag-#anon#UN[*{S8}$S8$'ptr'||*{SYM#tag-rsa_st#}$SYM#tag-rsa_st#$'rsa'||*{SYM#tag-dsa_st#}$SYM#tag-dsa_st#$'dsa'||*{SYM#tag-dh_st#}$SYM#tag-dh_st#$'dh'||*{SYM#tag-ec_key_st#}$SYM#tag-ec_key_st#$'ec'|]
// file /usr/include/openssl/evp.h line 135
union anonymous$34;

// tag-#anon#UN[*{S8}$S8$'ptr'||S32'boolean'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'asn1_string'||*{SYM#tag-asn1_object_st#}$SYM#tag-asn1_object_st#$'object'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'integer'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'enumerated'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'bit_string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'octet_string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'printablestring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'t61string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'ia5string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'generalstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'bmpstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'universalstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'utctime'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'generalizedtime'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'visiblestring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'utf8string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'set'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'sequence'||*{SYM#tag-ASN1_VALUE_st#}$SYM#tag-ASN1_VALUE_st#$'asn1_value'|]
// file /usr/include/openssl/asn1.h line 526
union anonymous$32;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$18;

// tag-#anon#UN[*{V(S32|S32|*{V}$V$)->V}$V(S32|S32|*{V}$V$)->V$'cb_1'||*{S32(S32|S32|*{SYM#tag-bn_gencb_st#}$SYM#tag-bn_gencb_st#$)->S32}$S32(S32|S32|*{SYM#tag-bn_gencb_st#}$SYM#tag-bn_gencb_st#$)->S32$'cb_2'|]
// file /usr/include/openssl/bn.h line 351
union anonymous$33;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$23;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$20;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 138
union anonymous$31;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$29;

// tag-ASN1_ENCODING_st
// file /usr/include/openssl/asn1.h line 257
struct ASN1_ENCODING_st;

// tag-ASN1_VALUE_st
// file /usr/include/openssl/asn1.h line 299
struct ASN1_VALUE_st;

// tag-AUTHORITY_KEYID_st
// file /usr/include/openssl/ossl_typ.h line 186
struct AUTHORITY_KEYID_st;

// tag-DSA_SIG_st
// file /usr/include/openssl/dsa.h line 124
struct DSA_SIG_st;

// tag-ISSUING_DIST_POINT_st
// file /usr/include/openssl/ossl_typ.h line 188
struct ISSUING_DIST_POINT_st;

// tag-NAME_CONSTRAINTS_st
// file /usr/include/openssl/ossl_typ.h line 189
struct NAME_CONSTRAINTS_st;

// tag-X509_POLICY_CACHE_st
// file /usr/include/openssl/ossl_typ.h line 184
struct X509_POLICY_CACHE_st;

// tag-X509_POLICY_TREE_st
// file /usr/include/openssl/ossl_typ.h line 183
struct X509_POLICY_TREE_st;

// tag-X509_VERIFY_PARAM_ID_st
// file /usr/include/openssl/x509_vfy.h line 159
struct X509_VERIFY_PARAM_ID_st;

// tag-X509_VERIFY_PARAM_st
// file /usr/include/openssl/x509_vfy.h line 167
struct X509_VERIFY_PARAM_st;

// tag-X509_algor_st
// file /usr/include/openssl/ossl_typ.h line 155
struct X509_algor_st;

// tag-X509_crl_info_st
// file /usr/include/openssl/x509.h line 441
struct X509_crl_info_st;

// tag-X509_crl_st
// file /usr/include/openssl/ossl_typ.h line 156
struct X509_crl_st;

// tag-X509_name_entry_st
// file /usr/include/openssl/x509.h line 168
struct X509_name_entry_st;

// tag-X509_name_st
// file /usr/include/openssl/ossl_typ.h line 159
struct X509_name_st;

// tag-X509_pubkey_st
// file /usr/include/openssl/ossl_typ.h line 160
struct X509_pubkey_st;

// tag-X509_req_info_st
// file /usr/include/openssl/x509.h line 226
struct X509_req_info_st;

// tag-X509_req_st
// file /usr/include/openssl/x509.h line 235
struct X509_req_st;

// tag-X509_val_st
// file /usr/include/openssl/x509.h line 152
struct X509_val_st;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_pqueue
// file /usr/include/openssl/pqueue.h line 70
struct _pqueue;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-alnode
// file audit_list_node_struct.h line 26
struct alnode;

// tag-asn1_object_st
// file /usr/include/openssl/ossl_typ.h line 103
struct asn1_object_st;

// tag-asn1_string_st
// file /usr/include/openssl/ossl_typ.h line 83
struct asn1_string_st;

// tag-asn1_type_st
// file /usr/include/openssl/asn1.h line 524
struct asn1_type_st;

// tag-auditlist
// file audit_list_struct.h line 26
struct auditlist;

// tag-bignum_ctx
// file /usr/include/openssl/ossl_typ.h line 121
struct bignum_ctx;

// tag-bignum_st
// file /usr/include/openssl/ossl_typ.h line 120
struct bignum_st;

// tag-bio_method_st
// file /usr/include/openssl/bio.h line 312
struct bio_method_st;

// tag-bio_st
// file /usr/include/openssl/crypto.h line 290
struct bio_st;

// tag-blnode
// file buf_list_node_struct.h line 24
struct blnode;

// tag-bn_blinding_st
// file /usr/include/openssl/ossl_typ.h line 122
struct bn_blinding_st;

// tag-bn_gencb_st
// file /usr/include/openssl/ossl_typ.h line 125
struct bn_gencb_st;

// tag-bn_mont_ctx_st
// file /usr/include/openssl/ossl_typ.h line 123
struct bn_mont_ctx_st;

// tag-buf_mem_st
// file /usr/include/openssl/ossl_typ.h line 127
struct buf_mem_st;

// tag-buflist
// file buf_list_struct.h line 26
struct buflist;

// tag-cert_st
// file /usr/include/openssl/ssl.h line 1035
struct cert_st;

// tag-comp_ctx_st
// file /usr/include/openssl/comp.h line 11
struct comp_ctx_st;

// tag-comp_method_st
// file /usr/include/openssl/comp.h line 13
struct comp_method_st;

// tag-crypto_ex_data_st
// file /usr/include/openssl/ossl_typ.h line 195
struct crypto_ex_data_st;

// tag-dh_method
// file /usr/include/openssl/ossl_typ.h line 141
struct dh_method;

// tag-dh_st
// file /usr/include/openssl/ossl_typ.h line 140
struct dh_st;

// tag-dsa_method
// file /usr/include/openssl/ossl_typ.h line 144
struct dsa_method;

// tag-dsa_st
// file /usr/include/openssl/ossl_typ.h line 143
struct dsa_st;

// tag-dtls1_bitmap_st
// file /usr/include/openssl/dtls1.h line 128
struct dtls1_bitmap_st;

// tag-dtls1_retransmit_state
// file /usr/include/openssl/dtls1.h line 135
struct dtls1_retransmit_state;

// tag-dtls1_state_st
// file /usr/include/openssl/ssl.h line 1493
struct dtls1_state_st;

// tag-dtls1_timeout_st
// file /usr/include/openssl/dtls1.h line 162
struct dtls1_timeout_st;

// tag-ec_key_st
// file /usr/include/openssl/evp.h line 147
struct ec_key_st;

// tag-engine_st
// file /usr/include/openssl/ossl_typ.h line 177
struct engine_st;

// tag-entry
// file first_run.c line 40
struct entry;

// tag-env_md_ctx_st
// file /usr/include/openssl/ossl_typ.h line 132
struct env_md_ctx_st;

// tag-env_md_st
// file /usr/include/openssl/ossl_typ.h line 131
struct env_md_st;

// tag-evp_cipher_ctx_st
// file /usr/include/openssl/ossl_typ.h line 130
struct evp_cipher_ctx_st;

// tag-evp_cipher_st
// file /usr/include/openssl/ossl_typ.h line 129
struct evp_cipher_st;

// tag-evp_pkey_asn1_method_st
// file /usr/include/openssl/ossl_typ.h line 135
struct evp_pkey_asn1_method_st;

// tag-evp_pkey_ctx_st
// file /usr/include/openssl/ossl_typ.h line 138
struct evp_pkey_ctx_st;

// tag-evp_pkey_st
// file /usr/include/openssl/ossl_typ.h line 133
struct evp_pkey_st;

// tag-hm_header_st
// file /usr/include/openssl/dtls1.h line 147
struct hm_header_st;

// tag-hmac_ctx_st
// file /usr/include/openssl/hmac.h line 75
struct hmac_ctx_st;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-lhash_st_SSL_SESSION
// file /usr/include/openssl/ssl.h line 923
struct lhash_st_SSL_SESSION;

// tag-llnode
// file logging.h line 54
struct llnode;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-record_pqueue_st
// file /usr/include/openssl/dtls1.h line 171
struct record_pqueue_st;

// tag-rsa_meth_st
// file /usr/include/openssl/ossl_typ.h line 147
struct rsa_meth_st;

// tag-rsa_st
// file /usr/include/openssl/ossl_typ.h line 146
struct rsa_st;

// tag-sess_cert_st
// file /usr/include/openssl/ssl.h line 531
struct sess_cert_st;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-srp_ctx_st
// file /usr/include/openssl/ssl.h line 849
struct srp_ctx_st;

// tag-srtp_protection_profile_st
// file /usr/include/openssl/ssl.h line 383
struct srtp_protection_profile_st;

// tag-ssl2_state_st
// file /usr/include/openssl/ssl.h line 1491
struct ssl2_state_st;

// tag-ssl3_buf_freelist_st
// file /usr/include/openssl/ssl.h line 1114
struct ssl3_buf_freelist_st;

// tag-ssl3_buffer_st
// file /usr/include/openssl/ssl3.h line 438
struct ssl3_buffer_st;

// tag-ssl3_enc_method
// file /usr/include/openssl/ssl.h line 466
struct ssl3_enc_method;

// tag-ssl3_record_st
// file /usr/include/openssl/ssl3.h line 403
struct ssl3_record_st;

// tag-ssl3_state_st
// file /usr/include/openssl/ssl.h line 1492
struct ssl3_state_st;

// tag-ssl_cipher_st
// file /usr/include/openssl/ssl.h line 375
struct ssl_cipher_st;

// tag-ssl_comp_st
// file /usr/include/openssl/ssl.h line 908
struct ssl_comp_st;

// tag-ssl_ctx_st
// file /usr/include/openssl/ossl_typ.h line 179
struct ssl_ctx_st;

// tag-ssl_method_st
// file /usr/include/openssl/ssl.h line 374
struct ssl_method_st;

// tag-ssl_session_st
// file /usr/include/openssl/ssl.h line 376
struct ssl_session_st;

// tag-ssl_st
// file /usr/include/openssl/ossl_typ.h line 178
struct ssl_st;

// tag-stack_st
// file /usr/include/openssl/stack.h line 66
struct stack_st;

// tag-stack_st_ASN1_OBJECT
// file /usr/include/openssl/asn1.h line 793
struct stack_st_ASN1_OBJECT;

// tag-stack_st_DIST_POINT
// file /usr/include/openssl/x509.h line 288
struct stack_st_DIST_POINT;

// tag-stack_st_GENERAL_NAME
// file /usr/include/openssl/x509.h line 289
struct stack_st_GENERAL_NAME;

// tag-stack_st_GENERAL_NAMES
// file /usr/include/openssl/x509.h line 471
struct stack_st_GENERAL_NAMES;

// tag-stack_st_OCSP_RESPID
// file /usr/include/openssl/ssl.h line 1610
struct stack_st_OCSP_RESPID;

// tag-stack_st_SRTP_PROTECTION_PROFILE
// file /usr/include/openssl/ssl.h line 388
struct stack_st_SRTP_PROTECTION_PROFILE;

// tag-stack_st_SSL_CIPHER
// file /usr/include/openssl/ssl.h line 380
struct stack_st_SSL_CIPHER;

// tag-stack_st_SSL_COMP
// file /usr/include/openssl/ssl.h line 922
struct stack_st_SSL_COMP;

// tag-stack_st_X509
// file /usr/include/openssl/x509.h line 301
struct stack_st_X509;

// tag-stack_st_X509_ALGOR
// file /usr/include/openssl/asn1.h line 162
struct stack_st_X509_ALGOR;

// tag-stack_st_X509_ATTRIBUTE
// file /usr/include/openssl/evp.h line 151
struct stack_st_X509_ATTRIBUTE;

// tag-stack_st_X509_CRL
// file /usr/include/openssl/x509.h line 476
struct stack_st_X509_CRL;

// tag-stack_st_X509_EXTENSION
// file /usr/include/openssl/x509.h line 202
struct stack_st_X509_EXTENSION;

// tag-stack_st_X509_LOOKUP
// file /usr/include/openssl/x509_vfy.h line 136
struct stack_st_X509_LOOKUP;

// tag-stack_st_X509_NAME
// file /usr/include/openssl/x509.h line 192
struct stack_st_X509_NAME;

// tag-stack_st_X509_NAME_ENTRY
// file /usr/include/openssl/x509.h line 175
struct stack_st_X509_NAME_ENTRY;

// tag-stack_st_X509_OBJECT
// file /usr/include/openssl/x509_vfy.h line 137
struct stack_st_X509_OBJECT;

// tag-stack_st_X509_REVOKED
// file /usr/include/openssl/x509.h line 438
struct stack_st_X509_REVOKED;

// tag-stack_st_void
// file /usr/include/openssl/crypto.h line 293
struct stack_st_void;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tlnode
// file task_list_node_struct.h line 26
struct tlnode;

// tag-tls_session_ticket_ext_st
// file /usr/include/openssl/ssl.h line 373
struct tls_session_ticket_ext_st;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-x509_cert_aux_st
// file /usr/include/openssl/x509.h line 262
struct x509_cert_aux_st;

// tag-x509_cinf_st
// file /usr/include/openssl/x509.h line 242
struct x509_cinf_st;

// tag-x509_crl_method_st
// file /usr/include/openssl/ossl_typ.h line 157
struct x509_crl_method_st;

// tag-x509_st
// file /usr/include/openssl/ossl_typ.h line 154
struct x509_st;

// tag-x509_store_ctx_st
// file /usr/include/openssl/ossl_typ.h line 162
struct x509_store_ctx_st;

// tag-x509_store_st
// file /usr/include/openssl/ossl_typ.h line 161
struct x509_store_st;

#ifndef NULL
#define NULL ((void*)0)
#endif

// ASN1_INTEGER_set
// file /usr/include/openssl/asn1.h line 927
signed int ASN1_INTEGER_set(struct asn1_string_st *, signed long int);
// AuditListNode_free
// file audit_list_node_struct.c line 81
void AuditListNode_free(struct alnode **aln);
// AuditListNode_get_connectTime
// file audit_list_node_struct.c line 258
signed long int AuditListNode_get_connectTime(struct alnode *aln);
// AuditListNode_get_connectTimep
// file audit_list_node_struct.h line 56
signed long int * AuditListNode_get_connectTimep(struct alnode *aln);
// AuditListNode_get_duration
// file audit_list_node_struct.h line 53
signed long int AuditListNode_get_duration(struct alnode *aln);
// AuditListNode_get_nameBuf
// file audit_list_node_struct.h line 50
char * AuditListNode_get_nameBuf(struct alnode *aln);
// AuditListNode_get_nextNode
// file audit_list_node_struct.h line 54
struct alnode * AuditListNode_get_nextNode(struct alnode *aln);
// AuditListNode_get_portBuf
// file audit_list_node_struct.h line 51
char * AuditListNode_get_portBuf(struct alnode *aln);
// AuditListNode_get_userId
// file audit_list_node_struct.h line 49
signed int AuditListNode_get_userId(struct alnode *aln);
// AuditListNode_new
// file audit_list_node_struct.c line 36
struct alnode * AuditListNode_new();
// AuditListNode_new_entry
// file audit_list_node_struct.h line 37
struct alnode * AuditListNode_new_entry(signed int userId, char *nameBuf, char *portBuf, signed long int connectTime, signed long int duration);
// AuditListNode_set_connectTime
// file audit_list_node_struct.c line 156
void AuditListNode_set_connectTime(struct alnode *aln, signed long int connectTime);
// AuditListNode_set_duration
// file audit_list_node_struct.c line 173
void AuditListNode_set_duration(struct alnode *aln, signed long int duration);
// AuditListNode_set_nameBuf
// file audit_list_node_struct.c line 120
void AuditListNode_set_nameBuf(struct alnode *aln, char *nameBuf);
// AuditListNode_set_nextNode
// file audit_list_node_struct.c line 190
void AuditListNode_set_nextNode(struct alnode *aln, struct alnode *nextNode);
// AuditListNode_set_portBuf
// file audit_list_node_struct.c line 138
void AuditListNode_set_portBuf(struct alnode *aln, char *portBuf);
// AuditListNode_set_userId
// file audit_list_node_struct.c line 103
void AuditListNode_set_userId(struct alnode *aln, signed int userId);
// AuditList_clear
// file audit_list_struct.h line 39
void AuditList_clear(struct auditlist *al);
// AuditList_delete_first
// file audit_list_struct.h line 38
void AuditList_delete_first(struct auditlist *al);
// AuditList_free
// file audit_list_struct.c line 53
void AuditList_free(struct auditlist **al);
// AuditList_get_first
// file audit_list_struct.h line 37
struct alnode * AuditList_get_first(struct auditlist *al);
// AuditList_insert_back
// file audit_list_struct.h line 36
void AuditList_insert_back(struct auditlist *al, struct alnode *aln);
// AuditList_new
// file audit_list_struct.c line 36
struct auditlist * AuditList_new();
// BufListNode_free
// file buf_list_node_struct.c line 76
void BufListNode_free(struct blnode **bln);
// BufListNode_get_actPtr
// file buf_list_node_struct.h line 42
signed int BufListNode_get_actPtr(struct blnode *bln);
// BufListNode_get_message
// file buf_list_node_struct.c line 221
unsigned char * BufListNode_get_message(struct blnode *bln);
// BufListNode_get_msgLen
// file buf_list_node_struct.c line 204
signed int BufListNode_get_msgLen(struct blnode *bln);
// BufListNode_get_nextNode
// file buf_list_node_struct.c line 238
struct blnode * BufListNode_get_nextNode(struct blnode *bln);
// BufListNode_new
// file buf_list_node_struct.c line 36
struct blnode * BufListNode_new();
// BufListNode_new_message
// file buf_list_node_struct.h line 33
struct blnode * BufListNode_new_message(signed int actPtr, signed int msgLen, unsigned char *message);
// BufListNode_readMessage
// file buf_list_node_struct.h line 47
unsigned char * BufListNode_readMessage(struct blnode *bln);
// BufListNode_readMessageLength
// file buf_list_node_struct.h line 48
signed int BufListNode_readMessageLength(struct blnode *bln);
// BufListNode_set_actPtr
// file buf_list_node_struct.h line 37
void BufListNode_set_actPtr(struct blnode *bln, signed int actPtr);
// BufListNode_set_message
// file buf_list_node_struct.c line 137
void BufListNode_set_message(struct blnode *bln, unsigned char *message, signed int msgLen);
// BufListNode_set_msgLen
// file buf_list_node_struct.c line 119
void BufListNode_set_msgLen(struct blnode *bln, signed int msgLen);
// BufListNode_set_nextNode
// file buf_list_node_struct.c line 170
void BufListNode_set_nextNode(struct blnode *bln, struct blnode *nextNode);
// BufList_clear
// file buf_list_struct.h line 39
void BufList_clear(struct buflist *bl);
// BufList_delete_first
// file buf_list_struct.h line 38
void BufList_delete_first(struct buflist *bl);
// BufList_free
// file buf_list_struct.c line 53
void BufList_free(struct buflist **bl);
// BufList_get_first
// file buf_list_struct.h line 37
struct blnode * BufList_get_first(struct buflist *bl);
// BufList_insert_back
// file buf_list_struct.h line 36
void BufList_insert_back(struct buflist *bl, struct blnode *bln);
// BufList_new
// file buf_list_struct.c line 36
struct buflist * BufList_new();
// ConnectClient_create_users
// file connect_client_struct.h line 113
signed int ConnectClient_create_users(struct anonymous$3 *cc);
// ConnectClient_decrease_connected
// file connect_client_struct.h line 116
void ConnectClient_decrease_connected(struct anonymous$3 *cc);
// ConnectClient_free
// file connect_client_struct.c line 73
void ConnectClient_free(struct anonymous$3 **cc);
// ConnectClient_get_auditList
// file connect_client_struct.h line 109
struct auditlist * ConnectClient_get_auditList(struct anonymous$3 *cc);
// ConnectClient_get_clientId
// file connect_client_struct.h line 101
signed int ConnectClient_get_clientId(struct anonymous$3 *cc);
// ConnectClient_get_connectTime
// file connect_client_struct.h line 102
signed long int ConnectClient_get_connectTime(struct anonymous$3 *cc);
// ConnectClient_get_connected
// file connect_client_struct.h line 97
signed int ConnectClient_get_connected(struct anonymous$3 *cc);
// ConnectClient_get_header
// file connect_client_struct.h line 110
struct anonymous$8 * ConnectClient_get_header(struct anonymous$3 *cc);
// ConnectClient_get_lastActivity
// file connect_client_struct.h line 103
signed long int ConnectClient_get_lastActivity(struct anonymous$3 *cc);
// ConnectClient_get_limit
// file connect_client_struct.h line 98
signed int ConnectClient_get_limit(struct anonymous$3 *cc);
// ConnectClient_get_listenFd
// file connect_client_struct.h line 99
signed int ConnectClient_get_listenFd(struct anonymous$3 *cc);
// ConnectClient_get_listenFdp
// file connect_client_struct.h line 117
signed int * ConnectClient_get_listenFdp(struct anonymous$3 *cc);
// ConnectClient_get_multi
// file connect_client_struct.h line 108
char ConnectClient_get_multi(struct anonymous$3 *cc);
// ConnectClient_get_nameBuf
// file connect_client_struct.h line 105
char * ConnectClient_get_nameBuf(struct anonymous$3 *cc);
// ConnectClient_get_portBuf
// file connect_client_struct.h line 106
char * ConnectClient_get_portBuf(struct anonymous$3 *cc);
// ConnectClient_get_sClientId
// file connect_client_struct.h line 104
char * ConnectClient_get_sClientId(struct anonymous$3 *cc);
// ConnectClient_get_sslFd
// file connect_client_struct.h line 94
struct anonymous$1 * ConnectClient_get_sslFd(struct anonymous$3 *cc);
// ConnectClient_get_state
// file connect_client_struct.h line 93
char ConnectClient_get_state(struct anonymous$3 *cc);
// ConnectClient_get_task
// file connect_client_struct.h line 111
struct anonymous$13 * ConnectClient_get_task(struct anonymous$3 *cc);
// ConnectClient_get_timer
// file connect_client_struct.c line 484
struct timeval ConnectClient_get_timer(struct anonymous$3 *cc);
// ConnectClient_get_timerp
// file connect_client_struct.h line 114
struct timeval * ConnectClient_get_timerp(struct anonymous$3 *cc);
// ConnectClient_get_tunnelType
// file connect_client_struct.h line 107
char ConnectClient_get_tunnelType(struct anonymous$3 *cc);
// ConnectClient_get_users
// file connect_client_struct.h line 96
signed int * ConnectClient_get_users(struct anonymous$3 *cc);
// ConnectClient_get_usrCliPair
// file connect_client_struct.h line 100
signed int ConnectClient_get_usrCliPair(struct anonymous$3 *cc);
// ConnectClient_increase_connected
// file connect_client_struct.h line 115
void ConnectClient_increase_connected(struct anonymous$3 *cc);
// ConnectClient_new
// file connect_client_struct.h line 69
struct anonymous$3 * ConnectClient_new();
// ConnectClient_set_auditList
// file connect_client_struct.c line 390
void ConnectClient_set_auditList(struct anonymous$3 *cc, struct auditlist *al);
// ConnectClient_set_clientId
// file connect_client_struct.h line 81
void ConnectClient_set_clientId(struct anonymous$3 *cc, signed int clientId);
// ConnectClient_set_connectTime
// file connect_client_struct.h line 82
void ConnectClient_set_connectTime(struct anonymous$3 *cc, signed long int connectTime);
// ConnectClient_set_connected
// file connect_client_struct.h line 77
void ConnectClient_set_connected(struct anonymous$3 *cc, signed int connected);
// ConnectClient_set_header
// file connect_client_struct.c line 410
void ConnectClient_set_header(struct anonymous$3 *cc, struct anonymous$8 *hb);
// ConnectClient_set_lastActivity
// file connect_client_struct.h line 83
void ConnectClient_set_lastActivity(struct anonymous$3 *cc, signed long int lastActivity);
// ConnectClient_set_limit
// file connect_client_struct.h line 78
void ConnectClient_set_limit(struct anonymous$3 *cc, signed int limit);
// ConnectClient_set_listenFd
// file connect_client_struct.c line 217
void ConnectClient_set_listenFd(struct anonymous$3 *cc, signed int listenFd);
// ConnectClient_set_multi
// file connect_client_struct.h line 88
void ConnectClient_set_multi(struct anonymous$3 *cc, char multi);
// ConnectClient_set_nameBuf
// file connect_client_struct.h line 85
void ConnectClient_set_nameBuf(struct anonymous$3 *cc, char *nameBuf);
// ConnectClient_set_portBuf
// file connect_client_struct.h line 86
void ConnectClient_set_portBuf(struct anonymous$3 *cc, char *portBuf);
// ConnectClient_set_sClientId
// file connect_client_struct.h line 84
void ConnectClient_set_sClientId(struct anonymous$3 *cc, char *sClientId);
// ConnectClient_set_sslFd
// file connect_client_struct.c line 126
void ConnectClient_set_sslFd(struct anonymous$3 *cc, struct anonymous$1 *sf);
// ConnectClient_set_state
// file connect_client_struct.h line 73
void ConnectClient_set_state(struct anonymous$3 *cc, char state);
// ConnectClient_set_task
// file connect_client_struct.h line 91
void ConnectClient_set_task(struct anonymous$3 *cc, struct anonymous$13 *task);
// ConnectClient_set_timer
// file connect_client_struct.h line 75
void ConnectClient_set_timer(struct anonymous$3 *cc, struct timeval timer);
// ConnectClient_set_tunnelType
// file connect_client_struct.h line 87
void ConnectClient_set_tunnelType(struct anonymous$3 *cc, char tunnelType);
// ConnectClient_set_users
// file connect_client_struct.c line 163
void ConnectClient_set_users(struct anonymous$3 *cc, signed int *users);
// ConnectClient_set_usrCliPair
// file connect_client_struct.h line 80
void ConnectClient_set_usrCliPair(struct anonymous$3 *cc, signed int usrCliPair);
// ConnectUser_free
// file connect_user_struct.c line 66
void ConnectUser_free(struct anonymous$4 **cu);
// ConnectUser_get_bufList
// file connect_user_struct.h line 64
struct buflist * ConnectUser_get_bufList(struct anonymous$4 *cu);
// ConnectUser_get_connFd
// file connect_user_struct.h line 58
signed int ConnectUser_get_connFd(struct anonymous$4 *cu);
// ConnectUser_get_connectTime
// file connect_user_struct.h line 61
signed long int ConnectUser_get_connectTime(struct anonymous$4 *cu);
// ConnectUser_get_nameBuf
// file connect_user_struct.h line 62
char * ConnectUser_get_nameBuf(struct anonymous$4 *cu);
// ConnectUser_get_portBuf
// file connect_user_struct.h line 63
char * ConnectUser_get_portBuf(struct anonymous$4 *cu);
// ConnectUser_get_state
// file connect_user_struct.h line 57
char ConnectUser_get_state(struct anonymous$4 *cu);
// ConnectUser_get_stats
// file connect_user_struct.h line 65
struct anonymous$6 * ConnectUser_get_stats(struct anonymous$4 *cu);
// ConnectUser_get_userId
// file connect_user_struct.h line 60
signed int ConnectUser_get_userId(struct anonymous$4 *cu);
// ConnectUser_get_whatClient
// file connect_user_struct.h line 59
signed int ConnectUser_get_whatClient(struct anonymous$4 *cu);
// ConnectUser_new
// file connect_user_struct.h line 43
struct anonymous$4 * ConnectUser_new();
// ConnectUser_set_bufList
// file connect_user_struct.c line 215
void ConnectUser_set_bufList(struct anonymous$4 *cu, struct buflist *bufList);
// ConnectUser_set_connFd
// file connect_user_struct.h line 48
void ConnectUser_set_connFd(struct anonymous$4 *cu, signed int connFd);
// ConnectUser_set_connectTime
// file connect_user_struct.h line 51
void ConnectUser_set_connectTime(struct anonymous$4 *cu, signed long int connectTime);
// ConnectUser_set_nameBuf
// file connect_user_struct.c line 179
void ConnectUser_set_nameBuf(struct anonymous$4 *cu, char *nameBuf);
// ConnectUser_set_portBuf
// file connect_user_struct.c line 197
void ConnectUser_set_portBuf(struct anonymous$4 *cu, char *portBuf);
// ConnectUser_set_state
// file connect_user_struct.h line 47
void ConnectUser_set_state(struct anonymous$4 *cu, char state);
// ConnectUser_set_stats
// file connect_user_struct.c line 235
void ConnectUser_set_stats(struct anonymous$4 *cu, struct anonymous$6 *stats);
// ConnectUser_set_userId
// file connect_user_struct.h line 50
void ConnectUser_set_userId(struct anonymous$4 *cu, signed int userId);
// ConnectUser_set_whatClient
// file connect_user_struct.h line 49
void ConnectUser_set_whatClient(struct anonymous$4 *cu, signed int whatClient);
// ERR_error_string
// file /usr/include/openssl/err.h line 334
char * ERR_error_string(unsigned long int, char *);
// ERR_get_error
// file /usr/include/openssl/err.h line 321
unsigned long int ERR_get_error(void);
// EVP_PKEY_free
// file /usr/include/openssl/evp.h line 981
void EVP_PKEY_free(struct evp_pkey_st *);
// EVP_PKEY_new
// file /usr/include/openssl/evp.h line 980
struct evp_pkey_st * EVP_PKEY_new(void);
// EVP_PKEY_set1_RSA
// file /usr/include/openssl/evp.h line 961
signed int EVP_PKEY_set1_RSA(struct evp_pkey_st *, struct rsa_st *);
// EVP_sha1
// file /usr/include/openssl/evp.h line 720
const struct env_md_st * EVP_sha1(void);
// HeaderBuffer_free
// file header_buffer_struct.h line 32
void HeaderBuffer_free(struct anonymous$8 **hb);
// HeaderBuffer_new
// file header_buffer_struct.h line 30
struct anonymous$8 * HeaderBuffer_new();
// HeaderBuffer_restore
// file header_buffer_struct.h line 36
void HeaderBuffer_restore(struct anonymous$8 *hb, unsigned char *buff);
// HeaderBuffer_store
// file header_buffer_struct.h line 35
void HeaderBuffer_store(struct anonymous$8 *hb, unsigned char *buff, signed int n);
// HeaderBuffer_to_read
// file header_buffer_struct.h line 34
signed int HeaderBuffer_to_read(struct anonymous$8 *hb);
// OBJ_txt2nid
// file /usr/include/openssl/objects.h line 1014
signed int OBJ_txt2nid(const char *);
// PEM_read_RSAPrivateKey
// file /usr/include/openssl/pem.h line 462
struct rsa_st * PEM_read_RSAPrivateKey(struct _IO_FILE *, struct rsa_st **, signed int (*)(char *, signed int, signed int, void *), void *);
// PEM_write_RSAPrivateKey
// file /usr/include/openssl/pem.h line 462
signed int PEM_write_RSAPrivateKey(struct _IO_FILE *, struct rsa_st *, const struct evp_cipher_st *, unsigned char *, signed int, signed int (*)(char *, signed int, signed int, void *), void *);
// PEM_write_X509
// file /usr/include/openssl/pem.h line 451
signed int PEM_write_X509(struct _IO_FILE *, struct x509_st *);
// RCTdata_free
// file remove_client_task.h line 43
void RCTdata_free(void **ptr);
// RCTdata_new
// file remove_client_task.h line 40
struct anonymous$25 * RCTdata_new(struct anonymous$2 *config, signed int realm, signed int client, char ra, char reason, struct anonymous$22 *set, struct anonymous$22 *wset);
// RCTfunction
// file remove_client_task.h line 45
void RCTfunction(void *data);
// RSA_check_key
// file /usr/include/openssl/rsa.h line 333
signed int RSA_check_key(const struct rsa_st *);
// RSA_generate_key
// file /usr/include/openssl/rsa.h line 326
struct rsa_st * RSA_generate_key(signed int, unsigned long int, void (*)(signed int, signed int, void *), void *);
// SSL_CTX_load_verify_locations
// file /usr/include/openssl/ssl.h line 2442
signed int SSL_CTX_load_verify_locations(struct ssl_ctx_st *, const char *, const char *);
// SSL_CTX_new
// file /usr/include/openssl/ssl.h line 2131
struct ssl_ctx_st * SSL_CTX_new(const struct ssl_method_st *);
// SSL_CTX_set_cipher_list
// file /usr/include/openssl/ssl.h line 2130
signed int SSL_CTX_set_cipher_list(struct ssl_ctx_st *, const char *);
// SSL_CTX_set_verify
// file /usr/include/openssl/ssl.h line 2262
void SSL_CTX_set_verify(struct ssl_ctx_st *, signed int, signed int (*)(signed int, struct x509_store_ctx_st *));
// SSL_CTX_set_verify_depth
// file /usr/include/openssl/ssl.h line 2264
void SSL_CTX_set_verify_depth(struct ssl_ctx_st *, signed int);
// SSL_CTX_use_RSAPrivateKey_file
// file /usr/include/openssl/ssl.h line 2198
signed int SSL_CTX_use_RSAPrivateKey_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_CTX_use_certificate_file
// file /usr/include/openssl/ssl.h line 2200
signed int SSL_CTX_use_certificate_file(struct ssl_ctx_st *, const char *, signed int);
// SSL_accept
// file /usr/include/openssl/ssl.h line 2332
signed int SSL_accept(struct ssl_st *);
// SSL_clear
// file /usr/include/openssl/ssl.h line 2138
signed int SSL_clear(struct ssl_st *);
// SSL_free
// file /usr/include/openssl/ssl.h line 2331
void SSL_free(struct ssl_st *);
// SSL_get_error
// file /usr/include/openssl/ssl.h line 2342
signed int SSL_get_error(const struct ssl_st *, signed int);
// SSL_library_init
// file /usr/include/openssl/ssl.h line 2419
signed int SSL_library_init(void);
// SSL_load_error_strings
// file /usr/include/openssl/ssl.h line 2216
void SSL_load_error_strings(void);
// SSL_new
// file /usr/include/openssl/ssl.h line 2291
struct ssl_st * SSL_new(struct ssl_ctx_st *);
// SSL_read
// file /usr/include/openssl/ssl.h line 2334
signed int SSL_read(struct ssl_st *, void *, signed int);
// SSL_readn
// file network.c line 483
signed int SSL_readn(struct ssl_st *fd, unsigned char *buf, signed int amount);
// SSL_set_fd
// file /usr/include/openssl/ssl.h line 2156
signed int SSL_set_fd(struct ssl_st *, signed int);
// SSL_write
// file /usr/include/openssl/ssl.h line 2336
signed int SSL_write(struct ssl_st *, const void *, signed int);
// SSL_writen
// file network.c line 454
signed int SSL_writen(struct ssl_st *fd, unsigned char *buf, signed int amount);
// SSLv3_server_method
// file /usr/include/openssl/ssl.h line 2356
const struct ssl_method_st * SSLv3_server_method(void);
// ServerConfiguration_free
// file server_configuration_struct.c line 54
void ServerConfiguration_free(struct anonymous$2 **sc);
// ServerConfiguration_get_cacertificateFile
// file server_configuration_struct.h line 57
char * ServerConfiguration_get_cacertificateFile(struct anonymous$2 *sc);
// ServerConfiguration_get_cacertificatePath
// file server_configuration_struct.c line 309
char * ServerConfiguration_get_cacertificatePath(struct anonymous$2 *sc);
// ServerConfiguration_get_certificateDepth
// file server_configuration_struct.c line 329
signed int ServerConfiguration_get_certificateDepth(struct anonymous$2 *sc);
// ServerConfiguration_get_certificateFile
// file server_configuration_struct.h line 56
char * ServerConfiguration_get_certificateFile(struct anonymous$2 *sc);
// ServerConfiguration_get_dateFormat
// file server_configuration_struct.h line 62
char * ServerConfiguration_get_dateFormat(struct anonymous$2 *sc);
// ServerConfiguration_get_keysFile
// file server_configuration_struct.h line 61
char * ServerConfiguration_get_keysFile(struct anonymous$2 *sc);
// ServerConfiguration_get_realmsNumber
// file server_configuration_struct.h line 63
signed int ServerConfiguration_get_realmsNumber(struct anonymous$2 *sc);
// ServerConfiguration_get_realmsTable
// file server_configuration_struct.h line 65
struct anonymous$5 ** ServerConfiguration_get_realmsTable(struct anonymous$2 *sc);
// ServerConfiguration_get_sCertificateDepth
// file server_configuration_struct.h line 59
char * ServerConfiguration_get_sCertificateDepth(struct anonymous$2 *sc);
// ServerConfiguration_get_startTime
// file server_configuration_struct.h line 64
signed long int ServerConfiguration_get_startTime(struct anonymous$2 *sc);
// ServerConfiguration_new
// file server_configuration_struct.h line 41
struct anonymous$2 * ServerConfiguration_new();
// ServerConfiguration_set_cacertificateFile
// file server_configuration_struct.h line 46
void ServerConfiguration_set_cacertificateFile(struct anonymous$2 *sc, char *cacertificateFile);
// ServerConfiguration_set_cacertificatePath
// file server_configuration_struct.c line 144
void ServerConfiguration_set_cacertificatePath(struct anonymous$2 *sc, char *cacertificatePath);
// ServerConfiguration_set_certificateDepth
// file server_configuration_struct.c line 163
void ServerConfiguration_set_certificateDepth(struct anonymous$2 *sc, signed int certificateDepth);
// ServerConfiguration_set_certificateFile
// file server_configuration_struct.h line 45
void ServerConfiguration_set_certificateFile(struct anonymous$2 *sc, char *certificateFile);
// ServerConfiguration_set_dateFormat
// file server_configuration_struct.h line 51
void ServerConfiguration_set_dateFormat(struct anonymous$2 *sc, char *dateFormat);
// ServerConfiguration_set_keysFile
// file server_configuration_struct.h line 50
void ServerConfiguration_set_keysFile(struct anonymous$2 *sc, char *keysFile);
// ServerConfiguration_set_realmsNumber
// file server_configuration_struct.h line 52
void ServerConfiguration_set_realmsNumber(struct anonymous$2 *sc, signed int realmsNumber);
// ServerConfiguration_set_realmsTable
// file server_configuration_struct.h line 54
void ServerConfiguration_set_realmsTable(struct anonymous$2 *sc, struct anonymous$5 **realmsTable);
// ServerConfiguration_set_sCertificateDepth
// file server_configuration_struct.h line 48
void ServerConfiguration_set_sCertificateDepth(struct anonymous$2 *sc, char *sCertificateDepth);
// ServerConfiguration_set_startTime
// file server_configuration_struct.h line 53
void ServerConfiguration_set_startTime(struct anonymous$2 *sc, signed long int startTime);
// ServerRealm_decrease_connectedClients
// file server_realm_struct.h line 141
void ServerRealm_decrease_connectedClients(struct anonymous$5 *sr);
// ServerRealm_decrease_connectedRaClients
// file server_realm_struct.h line 143
void ServerRealm_decrease_connectedRaClients(struct anonymous$5 *sr);
// ServerRealm_decrease_connectedUsers
// file server_realm_struct.h line 139
void ServerRealm_decrease_connectedUsers(struct anonymous$5 *sr);
// ServerRealm_free
// file server_realm_struct.c line 58
void ServerRealm_free(struct anonymous$5 **sr);
// ServerRealm_get_addressLength
// file server_realm_struct.h line 131
unsigned int ServerRealm_get_addressLength(struct anonymous$5 *sr);
// ServerRealm_get_auditOn
// file server_realm_struct.h line 130
char ServerRealm_get_auditOn(struct anonymous$5 *sr);
// ServerRealm_get_basePortOn
// file server_realm_struct.h line 129
char ServerRealm_get_basePortOn(struct anonymous$5 *sr);
// ServerRealm_get_clientAddress
// file server_realm_struct.h line 132
struct sockaddr * ServerRealm_get_clientAddress(struct anonymous$5 *sr);
// ServerRealm_get_clientMode
// file server_realm_struct.h line 122
signed int ServerRealm_get_clientMode(struct anonymous$5 *sr);
// ServerRealm_get_clientsCounter
// file server_realm_struct.h line 124
signed int ServerRealm_get_clientsCounter(struct anonymous$5 *sr);
// ServerRealm_get_clientsLimit
// file server_realm_struct.h line 116
signed int ServerRealm_get_clientsLimit(struct anonymous$5 *sr);
// ServerRealm_get_clientsTable
// file server_realm_struct.h line 134
struct anonymous$3 ** ServerRealm_get_clientsTable(struct anonymous$5 *sr);
// ServerRealm_get_connectedClients
// file server_realm_struct.h line 115
signed int ServerRealm_get_connectedClients(struct anonymous$5 *sr);
// ServerRealm_get_connectedRaClients
// file server_realm_struct.h line 117
signed int ServerRealm_get_connectedRaClients(struct anonymous$5 *sr);
// ServerRealm_get_connectedUsers
// file server_realm_struct.h line 113
signed int ServerRealm_get_connectedUsers(struct anonymous$5 *sr);
// ServerRealm_get_dnsLookupsOn
// file server_realm_struct.h line 128
char ServerRealm_get_dnsLookupsOn(struct anonymous$5 *sr);
// ServerRealm_get_hostName
// file server_realm_struct.h line 103
char * ServerRealm_get_hostName(struct anonymous$5 *sr);
// ServerRealm_get_maxIdle
// file server_realm_struct.h line 121
signed int ServerRealm_get_maxIdle(struct anonymous$5 *sr);
// ServerRealm_get_password
// file server_realm_struct.h line 112
unsigned char * ServerRealm_get_password(struct anonymous$5 *sr);
// ServerRealm_get_raClientsLimit
// file server_realm_struct.h line 118
signed int ServerRealm_get_raClientsLimit(struct anonymous$5 *sr);
// ServerRealm_get_raClientsTable
// file server_realm_struct.h line 135
struct anonymous$3 ** ServerRealm_get_raClientsTable(struct anonymous$5 *sr);
// ServerRealm_get_realmName
// file server_realm_struct.h line 111
char * ServerRealm_get_realmName(struct anonymous$5 *sr);
// ServerRealm_get_realmType
// file server_realm_struct.h line 126
char ServerRealm_get_realmType(struct anonymous$5 *sr);
// ServerRealm_get_sClientMode
// file server_realm_struct.h line 108
char * ServerRealm_get_sClientMode(struct anonymous$5 *sr);
// ServerRealm_get_sClientsLimit
// file server_realm_struct.h line 105
char * ServerRealm_get_sClientsLimit(struct anonymous$5 *sr);
// ServerRealm_get_sMaxIdle
// file server_realm_struct.h line 110
char * ServerRealm_get_sMaxIdle(struct anonymous$5 *sr);
// ServerRealm_get_sRaClientsLimit
// file server_realm_struct.h line 106
char * ServerRealm_get_sRaClientsLimit(struct anonymous$5 *sr);
// ServerRealm_get_sTimeout
// file server_realm_struct.h line 109
char * ServerRealm_get_sTimeout(struct anonymous$5 *sr);
// ServerRealm_get_sUsersLimit
// file server_realm_struct.h line 104
char * ServerRealm_get_sUsersLimit(struct anonymous$5 *sr);
// ServerRealm_get_sUsersPerClient
// file server_realm_struct.h line 107
char * ServerRealm_get_sUsersPerClient(struct anonymous$5 *sr);
// ServerRealm_get_timeout
// file server_realm_struct.h line 120
signed int ServerRealm_get_timeout(struct anonymous$5 *sr);
// ServerRealm_get_tunnelType
// file server_realm_struct.h line 127
char ServerRealm_get_tunnelType(struct anonymous$5 *sr);
// ServerRealm_get_userClientPairs
// file server_realm_struct.h line 123
signed int ServerRealm_get_userClientPairs(struct anonymous$5 *sr);
// ServerRealm_get_usersClientsTable
// file server_realm_struct.h line 136
struct anonymous$7 ** ServerRealm_get_usersClientsTable(struct anonymous$5 *sr);
// ServerRealm_get_usersCounter
// file server_realm_struct.h line 125
signed int ServerRealm_get_usersCounter(struct anonymous$5 *sr);
// ServerRealm_get_usersLimit
// file server_realm_struct.h line 114
signed int ServerRealm_get_usersLimit(struct anonymous$5 *sr);
// ServerRealm_get_usersPerClient
// file server_realm_struct.h line 119
signed int ServerRealm_get_usersPerClient(struct anonymous$5 *sr);
// ServerRealm_get_usersTable
// file server_realm_struct.h line 133
struct anonymous$4 ** ServerRealm_get_usersTable(struct anonymous$5 *sr);
// ServerRealm_increase_clientsCounter
// file server_realm_struct.h line 145
void ServerRealm_increase_clientsCounter(struct anonymous$5 *sr);
// ServerRealm_increase_connectedClients
// file server_realm_struct.h line 140
void ServerRealm_increase_connectedClients(struct anonymous$5 *sr);
// ServerRealm_increase_connectedRaClients
// file server_realm_struct.h line 142
void ServerRealm_increase_connectedRaClients(struct anonymous$5 *sr);
// ServerRealm_increase_connectedUsers
// file server_realm_struct.h line 138
void ServerRealm_increase_connectedUsers(struct anonymous$5 *sr);
// ServerRealm_increase_usersCounter
// file server_realm_struct.h line 144
void ServerRealm_increase_usersCounter(struct anonymous$5 *sr);
// ServerRealm_new
// file server_realm_struct.h line 64
struct anonymous$5 * ServerRealm_new();
// ServerRealm_set_addressLength
// file server_realm_struct.h line 96
void ServerRealm_set_addressLength(struct anonymous$5 *sr, unsigned int addressLength);
// ServerRealm_set_auditOn
// file server_realm_struct.h line 95
void ServerRealm_set_auditOn(struct anonymous$5 *sr, char auditOn);
// ServerRealm_set_basePortOn
// file server_realm_struct.h line 94
void ServerRealm_set_basePortOn(struct anonymous$5 *sr, char basePortOn);
// ServerRealm_set_clientAddress
// file server_realm_struct.h line 97
void ServerRealm_set_clientAddress(struct anonymous$5 *sr, struct sockaddr *clientAddress);
// ServerRealm_set_clientMode
// file server_realm_struct.h line 87
void ServerRealm_set_clientMode(struct anonymous$5 *sr, signed int clientMode);
// ServerRealm_set_clientsCounter
// file server_realm_struct.c line 510
void ServerRealm_set_clientsCounter(struct anonymous$5 *sr, signed int clientsCounter);
// ServerRealm_set_clientsLimit
// file server_realm_struct.h line 81
void ServerRealm_set_clientsLimit(struct anonymous$5 *sr, signed int clientsLimit);
// ServerRealm_set_clientsTable
// file server_realm_struct.h line 99
void ServerRealm_set_clientsTable(struct anonymous$5 *sr, struct anonymous$3 **clientsTable);
// ServerRealm_set_connectedClients
// file server_realm_struct.h line 80
void ServerRealm_set_connectedClients(struct anonymous$5 *sr, signed int connectedClients);
// ServerRealm_set_connectedRaClients
// file server_realm_struct.h line 82
void ServerRealm_set_connectedRaClients(struct anonymous$5 *sr, signed int connectedRaClients);
// ServerRealm_set_connectedUsers
// file server_realm_struct.h line 78
void ServerRealm_set_connectedUsers(struct anonymous$5 *sr, signed int connectedUsers);
// ServerRealm_set_dnsLookupsOn
// file server_realm_struct.h line 93
void ServerRealm_set_dnsLookupsOn(struct anonymous$5 *sr, char dnsLookupsOn);
// ServerRealm_set_hostName
// file server_realm_struct.h line 68
void ServerRealm_set_hostName(struct anonymous$5 *sr, char *hostName);
// ServerRealm_set_maxIdle
// file server_realm_struct.h line 86
void ServerRealm_set_maxIdle(struct anonymous$5 *sr, signed int maxIdle);
// ServerRealm_set_password
// file server_realm_struct.h line 77
void ServerRealm_set_password(struct anonymous$5 *sr, unsigned char *password);
// ServerRealm_set_raClientsLimit
// file server_realm_struct.h line 83
void ServerRealm_set_raClientsLimit(struct anonymous$5 *sr, signed int raClientsLimit);
// ServerRealm_set_raClientsTable
// file server_realm_struct.h line 100
void ServerRealm_set_raClientsTable(struct anonymous$5 *sr, struct anonymous$3 **raClientsTable);
// ServerRealm_set_realmName
// file server_realm_struct.h line 76
void ServerRealm_set_realmName(struct anonymous$5 *sr, char *realmName);
// ServerRealm_set_realmType
// file server_realm_struct.h line 91
void ServerRealm_set_realmType(struct anonymous$5 *sr, char realmType);
// ServerRealm_set_sClientMode
// file server_realm_struct.h line 73
void ServerRealm_set_sClientMode(struct anonymous$5 *sr, char *sClientMode);
// ServerRealm_set_sClientsLimit
// file server_realm_struct.h line 70
void ServerRealm_set_sClientsLimit(struct anonymous$5 *sr, char *sClientsLimit);
// ServerRealm_set_sMaxIdle
// file server_realm_struct.h line 75
void ServerRealm_set_sMaxIdle(struct anonymous$5 *sr, char *sMaxIdle);
// ServerRealm_set_sRaClientsLimit
// file server_realm_struct.h line 71
void ServerRealm_set_sRaClientsLimit(struct anonymous$5 *sr, char *sRaClientsLimit);
// ServerRealm_set_sTimeout
// file server_realm_struct.h line 74
void ServerRealm_set_sTimeout(struct anonymous$5 *sr, char *sTimeout);
// ServerRealm_set_sUsersLimit
// file server_realm_struct.h line 69
void ServerRealm_set_sUsersLimit(struct anonymous$5 *sr, char *sUsersLimit);
// ServerRealm_set_sUsersPerClient
// file server_realm_struct.h line 72
void ServerRealm_set_sUsersPerClient(struct anonymous$5 *sr, char *sUsersPerClient);
// ServerRealm_set_timeout
// file server_realm_struct.h line 85
void ServerRealm_set_timeout(struct anonymous$5 *sr, signed int timeout);
// ServerRealm_set_tunnelType
// file server_realm_struct.h line 92
void ServerRealm_set_tunnelType(struct anonymous$5 *sr, char tunnelType);
// ServerRealm_set_userClientPairs
// file server_realm_struct.h line 88
void ServerRealm_set_userClientPairs(struct anonymous$5 *sr, signed int userClientPairs);
// ServerRealm_set_usersClientsTable
// file server_realm_struct.h line 101
void ServerRealm_set_usersClientsTable(struct anonymous$5 *sr, struct anonymous$7 **usersClientsTable);
// ServerRealm_set_usersCounter
// file server_realm_struct.c line 527
void ServerRealm_set_usersCounter(struct anonymous$5 *sr, signed int usersCounter);
// ServerRealm_set_usersLimit
// file server_realm_struct.h line 79
void ServerRealm_set_usersLimit(struct anonymous$5 *sr, signed int usersLimit);
// ServerRealm_set_usersPerClient
// file server_realm_struct.h line 84
void ServerRealm_set_usersPerClient(struct anonymous$5 *sr, signed int usersPerClient);
// ServerRealm_set_usersTable
// file server_realm_struct.h line 98
void ServerRealm_set_usersTable(struct anonymous$5 *sr, struct anonymous$4 **usersTable);
// SslFd_free
// file ssl_fd_struct.c line 54
void SslFd_free(struct anonymous$1 **sf);
// SslFd_get_fd
// file ssl_fd_struct.h line 41
signed int SslFd_get_fd(struct anonymous$1 *sf);
// SslFd_get_message
// file ssl_fd_struct.h line 45
signed int SslFd_get_message(char type, struct anonymous$1 *sf, unsigned char *buf, signed int amount);
// SslFd_get_ssl
// file ssl_fd_struct.h line 42
struct ssl_st * SslFd_get_ssl(struct anonymous$1 *sf);
// SslFd_new
// file ssl_fd_struct.h line 33
struct anonymous$1 * SslFd_new();
// SslFd_send_message
// file ssl_fd_struct.h line 44
signed int SslFd_send_message(char type, struct anonymous$1 *sf, unsigned char *buf, signed int amount);
// SslFd_set_fd
// file ssl_fd_struct.h line 37
void SslFd_set_fd(struct anonymous$1 *sf, signed int fd);
// SslFd_set_ssl
// file ssl_fd_struct.h line 38
void SslFd_set_ssl(struct anonymous$1 *sf, struct ssl_st *ssl);
// SslFd_set_ssl_general
// file ssl_fd_struct.c line 98
void SslFd_set_ssl_general(struct anonymous$1 *sf, struct ssl_st *ssl, signed int free);
// SslFd_set_ssl_nf
// file ssl_fd_struct.h line 39
void SslFd_set_ssl_nf(struct anonymous$1 *sf, struct ssl_st *ssl);
// SslFd_swap_content
// file ssl_fd_struct.h line 46
void SslFd_swap_content(struct anonymous$1 *sf1, struct anonymous$1 *sf2);
// TaskListNode_free
// file task_list_node_struct.c line 60
void TaskListNode_free(struct tlnode **node);
// TaskListNode_get_task
// file task_list_node_struct.c line 117
struct anonymous$13 * TaskListNode_get_task(struct tlnode *node);
// TaskListNode_new
// file task_list_node_struct.c line 37
struct tlnode * TaskListNode_new(struct anonymous$13 *task);
// TaskListNode_set_next
// file task_list_node_struct.c line 83
void TaskListNode_set_next(struct tlnode *node, struct tlnode *next);
// TaskListNode_set_previous
// file task_list_node_struct.c line 100
void TaskListNode_set_previous(struct tlnode *node, struct tlnode *previous);
// TaskScheduler_addTask
// file task_scheduler_struct.h line 41
signed int TaskScheduler_addTask(struct anonymous$16 *scheduler, struct anonymous$13 *task);
// TaskScheduler_free
// file task_scheduler_struct.c line 54
void TaskScheduler_free(struct anonymous$16 **scheduler);
// TaskScheduler_get_actualTimer
// file task_scheduler_struct.h line 38
struct timeval * TaskScheduler_get_actualTimer(struct anonymous$16 *scheduler);
// TaskScheduler_hasMoreTasks
// file task_scheduler_struct.h line 40
signed int TaskScheduler_hasMoreTasks(struct anonymous$16 *scheduler);
// TaskScheduler_new
// file task_scheduler_struct.h line 34
struct anonymous$16 * TaskScheduler_new();
// TaskScheduler_removeTask
// file task_scheduler_struct.h line 42
signed int TaskScheduler_removeTask(struct anonymous$16 *scheduler, struct anonymous$13 *task);
// TaskScheduler_startWatching
// file task_scheduler_struct.h line 43
signed int TaskScheduler_startWatching(struct anonymous$16 *scheduler);
// TaskScheduler_stopWatching
// file task_scheduler_struct.h line 44
signed int TaskScheduler_stopWatching(struct anonymous$16 *scheduler);
// TaskScheduler_update
// file task_scheduler_struct.h line 45
signed int TaskScheduler_update(struct anonymous$16 *scheduler);
// Task_exec
// file task_struct.c line 113
void Task_exec(struct anonymous$13 *task);
// Task_free
// file task_struct.h line 34
void Task_free(struct anonymous$13 **task);
// Task_get_timer
// file task_struct.c line 97
struct timeval * Task_get_timer(struct anonymous$13 *task);
// Task_new
// file task_struct.h line 32
struct anonymous$13 * Task_new(struct timeval *timerp, void (*function)(void *), void *data, void (*clean)(void **));
// Task_new::clean$object
// 
void clean$object(void **);
// Task_new::function$object
// 
void function$object(void *);
// UserStats_add_download
// file user_stats_struct.h line 52
void UserStats_add_download(struct anonymous$6 *us, signed int bytes);
// UserStats_add_upload
// file user_stats_struct.h line 53
void UserStats_add_upload(struct anonymous$6 *us, signed int bytes);
// UserStats_clear
// file user_stats_struct.h line 57
void UserStats_clear(struct anonymous$6 *us);
// UserStats_free
// file user_stats_struct.c line 53
void UserStats_free(struct anonymous$6 **us);
// UserStats_get_downloadSpeed
// file user_stats_struct.h line 54
double UserStats_get_downloadSpeed(struct anonymous$6 *us);
// UserStats_get_lastActivity
// file user_stats_struct.h line 48
signed long int UserStats_get_lastActivity(struct anonymous$6 *us);
// UserStats_get_totalDownloadedBytes
// file user_stats_struct.h line 49
signed int UserStats_get_totalDownloadedBytes(struct anonymous$6 *us);
// UserStats_get_totalUploadedBytes
// file user_stats_struct.h line 50
signed int UserStats_get_totalUploadedBytes(struct anonymous$6 *us);
// UserStats_get_uploadSpeed
// file user_stats_struct.h line 55
double UserStats_get_uploadSpeed(struct anonymous$6 *us);
// UserStats_new
// file user_stats_struct.c line 36
struct anonymous$6 * UserStats_new();
// UserStats_set_lastActivity
// file user_stats_struct.h line 44
void UserStats_set_lastActivity(struct anonymous$6 *us, signed long int lastActivity);
// UserStats_set_totalDownloadedBytes
// file user_stats_struct.c line 92
void UserStats_set_totalDownloadedBytes(struct anonymous$6 *us, signed int totalDownloadedBytes);
// UserStats_set_totalUploadedBytes
// file user_stats_struct.c line 109
void UserStats_set_totalUploadedBytes(struct anonymous$6 *us, signed int totalUploadedBytes);
// UsrCli_free
// file usr_cli_struct.c line 54
void UsrCli_free(struct anonymous$7 **uc);
// UsrCli_get_listenFd
// file usr_cli_struct.h line 48
signed int UsrCli_get_listenFd(struct anonymous$7 *uc);
// UsrCli_get_listenHostName
// file usr_cli_struct.h line 50
char * UsrCli_get_listenHostName(struct anonymous$7 *uc);
// UsrCli_get_listenPortName
// file usr_cli_struct.h line 46
char * UsrCli_get_listenPortName(struct anonymous$7 *uc);
// UsrCli_get_manageFd
// file usr_cli_struct.h line 49
signed int UsrCli_get_manageFd(struct anonymous$7 *uc);
// UsrCli_get_manageHostName
// file usr_cli_struct.h line 51
char * UsrCli_get_manageHostName(struct anonymous$7 *uc);
// UsrCli_get_managePortName
// file usr_cli_struct.h line 47
char * UsrCli_get_managePortName(struct anonymous$7 *uc);
// UsrCli_get_number
// file usr_cli_struct.h line 52
signed int UsrCli_get_number(struct anonymous$7 *uc);
// UsrCli_new
// file usr_cli_struct.h line 36
struct anonymous$7 * UsrCli_new();
// UsrCli_set_listenFd
// file usr_cli_struct.h line 42
void UsrCli_set_listenFd(struct anonymous$7 *uc, signed int listenFd);
// UsrCli_set_listenPortName
// file usr_cli_struct.h line 40
void UsrCli_set_listenPortName(struct anonymous$7 *uc, char *listenPortName);
// UsrCli_set_manageFd
// file usr_cli_struct.h line 43
void UsrCli_set_manageFd(struct anonymous$7 *uc, signed int manageFd);
// UsrCli_set_managePortName
// file usr_cli_struct.h line 41
void UsrCli_set_managePortName(struct anonymous$7 *uc, char *managePortName);
// UsrCli_set_number
// file usr_cli_struct.h line 44
void UsrCli_set_number(struct anonymous$7 *uc, signed int number);
// X509_NAME_ENTRY_create_by_NID
// file /usr/include/openssl/x509.h line 1036
struct X509_name_entry_st * X509_NAME_ENTRY_create_by_NID(struct X509_name_entry_st **, signed int, signed int, unsigned char *, signed int);
// X509_NAME_add_entry
// file /usr/include/openssl/x509.h line 1024
signed int X509_NAME_add_entry(struct X509_name_st *, struct X509_name_entry_st *, signed int, signed int);
// X509_NAME_new
// file /usr/include/openssl/x509.h line 817
struct X509_name_st * X509_NAME_new(void);
// X509_REQ_free
// file /usr/include/openssl/x509.h line 807
void X509_REQ_free(struct X509_req_st *);
// X509_REQ_new
// file /usr/include/openssl/x509.h line 807
struct X509_req_st * X509_REQ_new(void);
// X509_REQ_set_pubkey
// file /usr/include/openssl/x509.h line 917
signed int X509_REQ_set_pubkey(struct X509_req_st *, struct evp_pkey_st *);
// X509_REQ_set_subject_name
// file /usr/include/openssl/x509.h line 916
signed int X509_REQ_set_subject_name(struct X509_req_st *, struct X509_name_st *);
// X509_REQ_sign
// file /usr/include/openssl/x509.h line 650
signed int X509_REQ_sign(struct X509_req_st *, struct evp_pkey_st *, const struct env_md_st *);
// X509_REQ_to_X509
// file /usr/include/openssl/x509.h line 779
struct x509_st * X509_REQ_to_X509(struct X509_req_st *, signed int, struct evp_pkey_st *);
// X509_free
// file /usr/include/openssl/x509.h line 823
void X509_free(struct x509_st *);
// X509_get_serialNumber
// file /usr/include/openssl/x509.h line 903
struct asn1_string_st * X509_get_serialNumber(struct x509_st *);
// X509_set_version
// file /usr/include/openssl/x509.h line 901
signed int X509_set_version(struct x509_st *, signed long int);
// X509_sign
// file /usr/include/openssl/x509.h line 647
signed int X509_sign(struct x509_st *, struct evp_pkey_st *, const struct env_md_st *);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __bswap_32$link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32$link1(unsigned int __bsx$link1);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 401
extern signed int __xstat(signed int, const char *, struct stat *);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// add_to_message
// file server_remoteadmin.c line 188
static void add_to_message(unsigned char *buff, const char *format, ...);
// add_uptime_to_message
// file server_remoteadmin.c line 221
static void add_uptime_to_message(unsigned char *buff, char *info, signed long int period);
// addlogtarget
// file logging.h line 69
void addlogtarget(char *cmdline);
// addtocg
// file stats.c line 61
void addtocg(signed int amount);
// aflog
// file logging.h line 73
void aflog(char type, char importance, const char *form, ...);
// afserver_connect
// file http_proxy_server.c line 54
signed int afserver_connect(signed int *sockfd, signed int afserverfd, struct sockaddr *cliaddr, unsigned int *addrlenp, char type);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// broadcast_condition
// file thread_management.h line 31
void broadcast_condition(void);
// bzero
// file /usr/include/strings.h line 50
extern void bzero(void *, unsigned long int);
// callback
// file first_run.c line 63
static void callback(signed int i, signed int j, void *k);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_long
// file server_check.h line 26
signed int check_long(char *text, signed long int *number);
// check_value
// file server_check.h line 24
signed int check_value(char *what, char *info);
// check_value_liberal
// file server_check.h line 25
signed int check_value_liberal(char *what, char *info);
// checklogtarget
// file logging.c line 175
signed int checklogtarget(struct llnode *target);
// checkmsgti
// file logging.c line 119
signed int checkmsgti(struct llnode *target, char *tab);
// clear_fd
// file http_proxy_functions.c line 261
void clear_fd(signed int *fd, struct anonymous$22 *set);
// clear_sslFd
// file http_proxy_functions.c line 362
void clear_sslFd(struct anonymous$1 *sf, struct anonymous$22 *set);
// client_long_usage
// file usage.c line 148
void client_long_usage(char *info);
// client_short_usage
// file usage.c line 132
void client_short_usage(char *info);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_fd
// file http_proxy_functions.c line 248
void close_fd(signed int *fd);
// compress
// file /usr/include/zlib.h line 1160
extern signed int compress(unsigned char *, unsigned long int *, const unsigned char *, unsigned long int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// create_apf_dir
// file first_run.h line 24
signed int create_apf_dir(char type);
// create_publickey_store
// file first_run.c line 147
signed int create_publickey_store(char **storefile);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// datum
// file logging.c line 85
char * datum(void);
// delete_user
// file http_proxy_functions.c line 77
void delete_user(struct anonymous$27 *cnts, signed int i, struct anonymous$22 *allset);
// end_critical_section
// file thread_management.h line 29
void end_critical_section(void);
// eval_UsrCliPair
// file server_eval.h line 29
signed int eval_UsrCliPair(struct anonymous$7 **table, signed int index, char *host, char *serv);
// eval_numofcon
// file server_eval.h line 27
signed int eval_numofcon(struct anonymous$5 *ptr, signed int client, signed int numofcon);
// eval_usernum
// file server_eval.h line 28
signed int eval_usernum(struct anonymous$3 *ptr, signed int usernum);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// find_client
// file server_find.h line 27
signed int find_client(struct anonymous$5 *ptr, char mode, signed int usrclipair);
// find_previousFd
// file server_find.h line 29
signed int find_previousFd(struct anonymous$7 **table, signed int index, char *host, char *serv);
// find_tasknode_with_minimal_timer
// file task_scheduler_struct.c line 158
static struct tlnode * find_tasknode_with_minimal_timer(struct anonymous$16 *scheduler);
// find_usernum
// file server_find.h line 28
signed int find_usernum(struct anonymous$3 *ptr, signed int usernum);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// generate_certificate
// file first_run.h line 27
signed int generate_certificate(char **cerfile, char *keyfile);
// generate_rsa_key
// file first_run.h line 26
signed int generate_rsa_key(char **keyfile);
// get_cer_filename
// file first_run.c line 400
char * get_cer_filename();
// get_clientid
// file clientnames.c line 48
signed int get_clientid(struct anonymous$5 *pointer, char *clientname);
// get_clientname
// file clientnames.h line 27
char * get_clientname(struct anonymous$5 *pointer, signed int client);
// get_clientnumber
// file clientnames.h line 29
signed int get_clientnumber(struct anonymous$5 *pointer, signed int clientid);
// get_key_filename
// file first_run.c line 388
char * get_key_filename();
// get_new_socket
// file server_get.h line 28
signed int get_new_socket(signed int sockfd, char type, struct sockaddr *addr, unsigned int *addrlen, char *tunneltype);
// get_raclientid
// file clientnames.c line 121
signed int get_raclientid(struct anonymous$5 *pointer, char *clientname);
// get_raclientname
// file clientnames.h line 31
char * get_raclientname(struct anonymous$5 *pointer, signed int client);
// get_raclientnumber
// file clientnames.c line 157
signed int get_raclientnumber(struct anonymous$5 *pointer, signed int clientid);
// get_realmname
// file realmnames.h line 27
char * get_realmname(struct anonymous$2 *config, signed int realm);
// get_realmnumber
// file realmnames.h line 28
signed int get_realmnumber(struct anonymous$2 *config, char *realmname);
// get_ssl_error
// file make_ssl_handshake.c line 75
signed int get_ssl_error(struct anonymous$1 *sf, char *info, signed int result);
// get_store_filename
// file first_run.c line 376
char * get_store_filename();
// get_username
// file usernames.h line 27
signed int get_username(struct anonymous$5 *pointer, signed int user);
// get_usernumber
// file usernames.h line 28
signed int get_usernumber(struct anonymous$5 *pointer, signed int userid);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getcg
// file stats.c line 73
signed long int getcg(void);
// getdateformat
// file logging.h line 65
char * getdateformat();
// getloglisthead
// file logging.h line 67
struct llnode * getloglisthead();
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// http_proxy_server
// file http_proxy_server.c line 83
void * http_proxy_server(void *vptr);
// http_read
// file http_proxy_functions.c line 402
signed int http_read(char https, struct anonymous$1 *sf, unsigned char *buf, signed int amount);
// http_write
// file http_proxy_functions.c line 381
signed int http_write(char https, struct anonymous$1 *sf, unsigned char *buf, signed int amount);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// initialize_http_proxy_server
// file http_proxy_server.h line 27
signed int initialize_http_proxy_server(signed int *sockfd, const char *host, const char *serv, unsigned int *addrlenp, const char type, signed int limit, char https, struct ssl_ctx_st *ctx);
// initializelogging
// file logging.h line 71
void initializelogging(char verl, char *dateformat);
// ip_connect
// file network.c line 186
signed int ip_connect(signed int *sockfd, const char *host, const char *serv, const char type, const char *lhost, const char *lserv);
// ip_listen
// file network.h line 39
signed int ip_listen(signed int *sockfd, const char *host, const char *serv, unsigned int *addrlenp, const char type);
// is_this_a_mainthread
// file thread_management.c line 50
signed int is_this_a_mainthread(void);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localdate
// file logging.h line 75
char * localdate(signed long int *sec);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// loginit
// file logging.c line 334
signed int loginit(char verl, char *dateformat);
// make_ssl_accept
// file make_ssl_handshake.h line 28
signed int make_ssl_accept(struct anonymous$1 *sf);
// make_ssl_initialize
// file make_ssl_handshake.h line 27
void make_ssl_initialize(struct anonymous$1 *sf);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 321
extern signed int mkdir(const char *, unsigned int);
// myrand
// file http_proxy_functions.c line 42
signed int myrand(signed int down, signed int up);
// mysleep
// file http_proxy_functions.c line 60
void mysleep(double time);
// parse_cmd
// file server_remoteadmin.c line 89
static signed int parse_cmd(unsigned char *buff, signed int *ret);
// parse_header
// file http_proxy_functions.c line 105
signed int parse_header(struct anonymous$1 *sf, char *tab, struct anonymous$26 *hdr, char https);
// parse_int
// file server_remoteadmin.c line 38
static signed int parse_int(unsigned char *buff, signed int *ret);
// parse_line
// file file.c line 45
signed int parse_line(char *buff, char *tab1, char *tab2);
// parsefile
// file file.h line 37
struct anonymous$2 * parsefile(char *name, signed int *status);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 992
extern signed int pthread_cond_broadcast(union anonymous$31 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 1000
extern signed int pthread_cond_wait(union anonymous$31 *, union anonymous$29 *);
// pthread_create
// file /usr/include/pthread.h line 244
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_lock(union anonymous$29 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 784
extern signed int pthread_mutex_unlock(union anonymous$29 *);
// pthread_self
// file /usr/include/pthread.h line 286
extern unsigned long int pthread_self(void);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_message
// file http_proxy_functions.c line 281
signed int read_message(signed int fd, signed int length, struct anonymous$27 *client, char *tab, signed int ptr);
// readn
// file network.h line 47
signed int readn(signed int fd, unsigned char *buf, signed int amount);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// remember_mainthread
// file thread_management.h line 26
void remember_mainthread(void);
// remove_client
// file server_remove.h line 27
void remove_client(struct anonymous$5 *ptr, signed int client, struct anonymous$22 *set, struct anonymous$22 *wset, struct anonymous$16 *scheduler);
// remove_raclient
// file server_remove.h line 28
void remove_raclient(struct anonymous$5 *ptr, signed int client, struct anonymous$22 *set, struct anonymous$22 *wset, struct anonymous$16 *scheduler);
// resetcg
// file stats.c line 84
void resetcg(void);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// rindex
// file /usr/include/string.h line 517
extern char * rindex(const char *, signed int);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$22 *, struct anonymous$22 *, struct anonymous$22 *, struct timeval *);
// send_adm_message
// file server_remoteadmin.c line 158
static void send_adm_message(char type, struct anonymous$1 *master, unsigned char *buff, unsigned char st);
// serve_admin
// file server_remoteadmin.h line 35
signed int serve_admin(struct anonymous$2 *config, signed int realm, signed int client, unsigned char *buff);
// server_long_usage
// file usage.h line 25
void server_long_usage(char *info);
// server_short_usage
// file usage.h line 24
void server_short_usage(char *info);
// server_sig_int
// file server_signals.h line 24
void server_sig_int(signed int signo);
// set_fd
// file http_proxy_functions.c line 235
void set_fd(signed int fd, signed int *maxfdp1, struct anonymous$22 *allset);
// set_value
// file server_set.h line 24
void set_value(char **dest, char *from, char *def);
// setdateformat
// file logging.h line 63
void setdateformat(char *dateformat);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous$19 *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sock_ntop
// file network.h line 42
char * sock_ntop(struct sockaddr *sa, unsigned int salen, char *namebuf, char *portbuf, char type);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socketpair
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 119
extern signed int socketpair(signed int, signed int, signed int, signed int *);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_critical_section
// file thread_management.h line 28
void start_critical_section(void);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 453
static inline signed int stat(const char *__path, struct stat *__statbuf);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// string_cp
// file string_functions.h line 24
char * string_cp(char **dest, char *src);
// strlen
// file /usr/include/string.h line 399
extern unsigned long int strlen(const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timeperiod
// file stats.h line 29
char * timeperiod(signed long int period);
// timeval_compare
// file timeval_functions.c line 56
signed int timeval_compare(struct timeval *first, struct timeval *second);
// timeval_create
// file timeval_functions.h line 26
struct timeval timeval_create(signed long int tv_sec, signed long int tv_usec);
// timeval_lq_zero
// file timeval_functions.c line 121
signed int timeval_lq_zero(struct timeval *timer);
// timeval_subtract
// file timeval_functions.c line 94
signed int timeval_subtract(struct timeval *first, struct timeval *second);
// uncompress
// file /usr/include/zlib.h line 1197
extern signed int uncompress(unsigned char *, unsigned long int *, const unsigned char *, unsigned long int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsprintf
// file /usr/include/stdio.h line 379
extern signed int vsprintf(char *, const char *, void **);
// wait_for_condition
// file thread_management.h line 30
void wait_for_condition(void);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// writen
// file network.c line 513
signed int writen(signed int fd, unsigned char *buf, signed int amount);

struct anonymous$2
{
  // cacertificateFile
  char *cacertificateFile;
  // cacertificatePath
  char *cacertificatePath;
  // sCertificateDepth
  char *sCertificateDepth;
  // certificateDepth
  signed int certificateDepth;
  // certificateFile
  char *certificateFile;
  // keysFile
  char *keysFile;
  // dateFormat
  char *dateFormat;
  // realmsNumber
  signed int realmsNumber;
  // startTime
  signed long int startTime;
  // realmsTable
  struct anonymous$5 **realmsTable;
};

struct anonymous$5
{
  // hostName
  char *hostName;
  // sUsersLimit
  char *sUsersLimit;
  // sClientsLimit
  char *sClientsLimit;
  // sRaClientsLimit
  char *sRaClientsLimit;
  // sUsersPerClient
  char *sUsersPerClient;
  // sClientMode
  char *sClientMode;
  // sTimeout
  char *sTimeout;
  // sMaxIdle
  char *sMaxIdle;
  // realmName
  char *realmName;
  // password
  unsigned char password[4l];
  // connectedUsers
  signed int connectedUsers;
  // usersLimit
  signed int usersLimit;
  // connectedClients
  signed int connectedClients;
  // clientsLimit
  signed int clientsLimit;
  // connectedRaClients
  signed int connectedRaClients;
  // raClientsLimit
  signed int raClientsLimit;
  // usersPerClient
  signed int usersPerClient;
  // timeout
  signed int timeout;
  // maxIdle
  signed int maxIdle;
  // clientMode
  signed int clientMode;
  // userClientPairs
  signed int userClientPairs;
  // clientsCounter
  signed int clientsCounter;
  // usersCounter
  signed int usersCounter;
  // realmType
  char realmType;
  // tunnelType
  char tunnelType;
  // dnsLookupsOn
  char dnsLookupsOn;
  // basePortOn
  char basePortOn;
  // auditOn
  char auditOn;
  // addressLength
  unsigned int addressLength;
  // clientAddress
  struct sockaddr *clientAddress;
  // usersTable
  struct anonymous$4 **usersTable;
  // clientsTable
  struct anonymous$3 **clientsTable;
  // raClientsTable
  struct anonymous$3 **raClientsTable;
  // usersClientsTable
  struct anonymous$7 **usersClientsTable;
};

struct anonymous$7
{
  // listenHostName
  char *listenHostName;
  // manageHostName
  char *manageHostName;
  // listenPortName
  char *listenPortName;
  // managePortName
  char *managePortName;
  // listenFd
  signed int listenFd;
  // manageFd
  signed int manageFd;
  // number
  signed int number;
};

struct anonymous$25
{
  // config
  struct anonymous$2 *config;
  // realm
  signed int realm;
  // client
  signed int client;
  // ra
  char ra;
  // reason
  char reason;
  // set
  struct anonymous$22 *set;
  // wset
  struct anonymous$22 *wset;
};

struct anonymous$13
{
  // timerp
  struct timeval *timerp;
  // function
  void (*function)(void *);
  // data
  void *data;
  // clean
  void (*clean)(void **);
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct anonymous$16
{
  // head
  struct tlnode *head;
  // numberOfTasks
  signed int numberOfTasks;
  // actualTask
  struct tlnode *actualTask;
  // delta
  struct timeval delta;
};

struct anonymous$17
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$14
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$0
{
  // cert_verify_md
  unsigned char cert_verify_md[128l];
  // finish_md
  unsigned char finish_md[128l];
  // finish_md_len
  signed int finish_md_len;
  // peer_finish_md
  unsigned char peer_finish_md[128l];
  // peer_finish_md_len
  signed int peer_finish_md_len;
  // message_size
  unsigned long int message_size;
  // message_type
  signed int message_type;
  // new_cipher
  const struct ssl_cipher_st *new_cipher;
  // dh
  struct dh_st *dh;
  // ecdh
  struct ec_key_st *ecdh;
  // next_state
  signed int next_state;
  // reuse_message
  signed int reuse_message;
  // cert_req
  signed int cert_req;
  // ctype_num
  signed int ctype_num;
  // ctype
  char ctype[9l];
  // ca_names
  struct stack_st_X509_NAME *ca_names;
  // use_rsa_tmp
  signed int use_rsa_tmp;
  // key_block_length
  signed int key_block_length;
  // key_block
  unsigned char *key_block;
  // new_sym_enc
  const struct evp_cipher_st *new_sym_enc;
  // new_hash
  const struct env_md_st *new_hash;
  // new_mac_pkey_type
  signed int new_mac_pkey_type;
  // new_mac_secret_size
  signed int new_mac_secret_size;
  // new_compression
  const struct ssl_comp_st *new_compression;
  // cert_request
  signed int cert_request;
};

struct anonymous$22
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$19
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$8
{
  // tab
  unsigned char tab[5l];
  // readed
  signed int readed;
};

struct anonymous$30
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$1
{
  // fd
  signed int fd;
  // ssl
  struct ssl_st *ssl;
};

struct anonymous$24
{
  // sess_connect
  signed int sess_connect;
  // sess_connect_renegotiate
  signed int sess_connect_renegotiate;
  // sess_connect_good
  signed int sess_connect_good;
  // sess_accept
  signed int sess_accept;
  // sess_accept_renegotiate
  signed int sess_accept_renegotiate;
  // sess_accept_good
  signed int sess_accept_good;
  // sess_miss
  signed int sess_miss;
  // sess_timeout
  signed int sess_timeout;
  // sess_cache_full
  signed int sess_cache_full;
  // sess_hit
  signed int sess_hit;
  // sess_cb_hit
  signed int sess_cb_hit;
};

struct anonymous$9
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$12
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$11
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$10
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$15
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$20
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$9 _kill;
  // _timer
  struct anonymous$10 _timer;
  // _rt
  struct anonymous$11 _rt;
  // _sigchld
  struct anonymous$12 _sigchld;
  // _sigfault
  struct anonymous$14 _sigfault;
  // _sigpoll
  struct anonymous$15 _sigpoll;
  // _sigsys
  struct anonymous$17 _sigsys;
};

struct anonymous$21
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$20 _sifields;
};

struct anonymous$28
{
  // sockfd
  signed int sockfd;
  // host
  char *host;
  // serv
  char *serv;
  // addrlenp
  unsigned int *addrlenp;
  // type
  char type;
  // limit
  signed int limit;
  // https
  char https;
  // ctx
  struct ssl_ctx_st *ctx;
};

struct anonymous$6
{
  // lastActivity
  signed long int lastActivity;
  // lastUSQChange
  signed long int lastUSQChange;
  // lastDSQChange
  signed long int lastDSQChange;
  // totalDownloadedBytes
  signed int totalDownloadedBytes;
  // totalUploadedBytes
  signed int totalUploadedBytes;
  // uploadSQP
  signed int uploadSQP;
  // uploadSpeedQueue
  signed int uploadSpeedQueue[3l];
  // downloadSQP
  signed int downloadSQP;
  // downloadSpeedQueue
  signed int downloadSpeedQueue[3l];
};

struct anonymous$26
{
  // type
  char type;
  // id
  char id[10l];
  // ptr
  signed int ptr;
  // length
  signed int length;
  // allreaded
  signed int allreaded;
};

struct anonymous$27
{
  // read_state
  char read_state;
  // readed_length
  char readed_length[4l];
  // state
  char state;
  // id
  char id[10l];
  // postFd
  struct anonymous$1 *postFd;
  // getFd
  struct anonymous$1 *getFd;
  // sent_ptr
  signed int sent_ptr;
  // sockfd
  signed int sockfd;
  // buf
  char buf[9000l];
  // tmpbuf
  char tmpbuf[9000l];
  // tmpstate
  char tmpstate;
  // tmpFd
  struct anonymous$1 *tmpFd;
  // type
  char type;
  // tmpheader
  struct anonymous$26 tmpheader;
  // ptr
  signed int ptr;
  // length
  signed int length;
  // curreceived
  signed int curreceived;
  // toreceive
  signed int toreceive;
  // received
  signed int received;
};

struct anonymous$4
{
  // state
  char state;
  // connFd
  signed int connFd;
  // whatClient
  signed int whatClient;
  // userId
  signed int userId;
  // connectTime
  signed long int connectTime;
  // nameBuf
  char nameBuf[128l];
  // portBuf
  char portBuf[7l];
  // bufList
  struct buflist *bufList;
  // stats
  struct anonymous$6 *stats;
};

struct anonymous$3
{
  // state
  char state;
  // sslFd
  struct anonymous$1 *sslFd;
  // timer
  struct timeval timer;
  // users
  signed int *users;
  // connected
  signed int connected;
  // limit
  signed int limit;
  // listenFd
  signed int listenFd;
  // usrCliPair
  signed int usrCliPair;
  // clientId
  signed int clientId;
  // connectTime
  signed long int connectTime;
  // lastActivity
  signed long int lastActivity;
  // sClientId
  char *sClientId;
  // nameBuf
  char nameBuf[128l];
  // portBuf
  char portBuf[7l];
  // tunnelType
  char tunnelType;
  // multi
  char multi;
  // auditList
  struct auditlist *auditList;
  // header
  struct anonymous$8 *header;
  // task
  struct anonymous$13 *task;
};

struct anonymous
{
  // conn_id_length
  unsigned int conn_id_length;
  // cert_type
  unsigned int cert_type;
  // cert_length
  unsigned int cert_length;
  // csl
  unsigned int csl;
  // clear
  unsigned int clear;
  // enc
  unsigned int enc;
  // ccl
  unsigned char ccl[32l];
  // cipher_spec_length
  unsigned int cipher_spec_length;
  // session_id_length
  unsigned int session_id_length;
  // clen
  unsigned int clen;
  // rlen
  unsigned int rlen;
};

union anonymous$34
{
  // ptr
  char *ptr;
  // rsa
  struct rsa_st *rsa;
  // dsa
  struct dsa_st *dsa;
  // dh
  struct dh_st *dh;
  // ec
  struct ec_key_st *ec;
};

union anonymous$32
{
  // ptr
  char *ptr;
  // boolean
  signed int boolean;
  // asn1_string
  struct asn1_string_st *asn1_string;
  // object
  struct asn1_object_st *object;
  // integer
  struct asn1_string_st *integer;
  // enumerated
  struct asn1_string_st *enumerated;
  // bit_string
  struct asn1_string_st *bit_string;
  // octet_string
  struct asn1_string_st *octet_string;
  // printablestring
  struct asn1_string_st *printablestring;
  // t61string
  struct asn1_string_st *t61string;
  // ia5string
  struct asn1_string_st *ia5string;
  // generalstring
  struct asn1_string_st *generalstring;
  // bmpstring
  struct asn1_string_st *bmpstring;
  // universalstring
  struct asn1_string_st *universalstring;
  // utctime
  struct asn1_string_st *utctime;
  // generalizedtime
  struct asn1_string_st *generalizedtime;
  // visiblestring
  struct asn1_string_st *visiblestring;
  // utf8string
  struct asn1_string_st *utf8string;
  // set
  struct asn1_string_st *set;
  // sequence
  struct asn1_string_st *sequence;
  // asn1_value
  struct ASN1_VALUE_st *asn1_value;
};

union anonymous$18
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$21 *, void *);
};

union anonymous$33
{
  // cb_1
  void (*cb_1)(signed int, signed int, void *);
  // cb_2
  signed int (*cb_2)(signed int, signed int, struct bn_gencb_st *);
};

union anonymous$23
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$31
{
  // __data
  struct anonymous$30 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$29
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ASN1_ENCODING_st
{
  // enc
  unsigned char *enc;
  // len
  signed long int len;
  // modified
  signed int modified;
};

struct DSA_SIG_st
{
  // r
  struct bignum_st *r;
  // s
  struct bignum_st *s;
};

struct X509_VERIFY_PARAM_st
{
  // name
  char *name;
  // check_time
  signed long int check_time;
  // inh_flags
  unsigned long int inh_flags;
  // flags
  unsigned long int flags;
  // purpose
  signed int purpose;
  // trust
  signed int trust;
  // depth
  signed int depth;
  // policies
  struct stack_st_ASN1_OBJECT *policies;
  // id
  struct X509_VERIFY_PARAM_ID_st *id;
};

struct X509_algor_st
{
  // algorithm
  struct asn1_object_st *algorithm;
  // parameter
  struct asn1_type_st *parameter;
};

struct X509_crl_info_st
{
  // version
  struct asn1_string_st *version;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // issuer
  struct X509_name_st *issuer;
  // lastUpdate
  struct asn1_string_st *lastUpdate;
  // nextUpdate
  struct asn1_string_st *nextUpdate;
  // revoked
  struct stack_st_X509_REVOKED *revoked;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct X509_crl_st
{
  // crl
  struct X509_crl_info_st *crl;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
  // flags
  signed int flags;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // idp
  struct ISSUING_DIST_POINT_st *idp;
  // idp_flags
  signed int idp_flags;
  // idp_reasons
  signed int idp_reasons;
  // crl_number
  struct asn1_string_st *crl_number;
  // base_crl_number
  struct asn1_string_st *base_crl_number;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // issuers
  struct stack_st_GENERAL_NAMES *issuers;
  // meth
  const struct x509_crl_method_st *meth;
  // meth_data
  void *meth_data;
};

struct X509_name_entry_st
{
  // object
  struct asn1_object_st *object;
  // value
  struct asn1_string_st *value;
  // set
  signed int set;
  // size
  signed int size;
};

struct X509_name_st
{
  // entries
  struct stack_st_X509_NAME_ENTRY *entries;
  // modified
  signed int modified;
  // bytes
  struct buf_mem_st *bytes;
  // canon_enc
  unsigned char *canon_enc;
  // canon_enclen
  signed int canon_enclen;
};

struct X509_pubkey_st
{
  // algor
  struct X509_algor_st *algor;
  // public_key
  struct asn1_string_st *public_key;
  // pkey
  struct evp_pkey_st *pkey;
};

struct X509_req_info_st
{
  // enc
  struct ASN1_ENCODING_st enc;
  // version
  struct asn1_string_st *version;
  // subject
  struct X509_name_st *subject;
  // pubkey
  struct X509_pubkey_st *pubkey;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct X509_req_st
{
  // req_info
  struct X509_req_info_st *req_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // references
  signed int references;
};

struct X509_val_st
{
  // notBefore
  struct asn1_string_st *notBefore;
  // notAfter
  struct asn1_string_st *notAfter;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct alnode
{
  // userId
  signed int userId;
  // nameBuf
  char nameBuf[128l];
  // portBuf
  char portBuf[7l];
  // connectTime
  signed long int connectTime;
  // duration
  signed long int duration;
  // nextNode
  struct alnode *nextNode;
};

struct asn1_object_st
{
  // sn
  const char *sn;
  // ln
  const char *ln;
  // nid
  signed int nid;
  // length
  signed int length;
  // data
  const unsigned char *data;
  // flags
  signed int flags;
};

struct asn1_string_st
{
  // length
  signed int length;
  // type
  signed int type;
  // data
  unsigned char *data;
  // flags
  signed long int flags;
};

struct asn1_type_st
{
  // type
  signed int type;
  // value
  union anonymous$32 value;
};

struct auditlist
{
  // head
  struct alnode *head;
  // tail
  struct alnode *tail;
};

struct bignum_st
{
  // d
  unsigned long int *d;
  // top
  signed int top;
  // dmax
  signed int dmax;
  // neg
  signed int neg;
  // flags
  signed int flags;
};

struct bio_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // bwrite
  signed int (*bwrite)(struct bio_st *, const char *, signed int);
  // bread
  signed int (*bread)(struct bio_st *, char *, signed int);
  // bputs
  signed int (*bputs)(struct bio_st *, const char *);
  // bgets
  signed int (*bgets)(struct bio_st *, char *, signed int);
  // ctrl
  signed long int (*ctrl)(struct bio_st *, signed int, signed long int, void *);
  // create
  signed int (*create)(struct bio_st *);
  // destroy
  signed int (*destroy)(struct bio_st *);
  // callback_ctrl
  signed long int (*callback_ctrl)(struct bio_st *, signed int, void (*)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int));
};

struct crypto_ex_data_st
{
  // sk
  struct stack_st_void *sk;
  // dummy
  signed int dummy;
};

struct bio_st
{
  // method
  struct bio_method_st *method;
  // callback
  signed long int (*callback)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int);
  // cb_arg
  char *cb_arg;
  // init
  signed int init;
  // shutdown
  signed int shutdown;
  // flags
  signed int flags;
  // retry_reason
  signed int retry_reason;
  // num
  signed int num;
  // ptr
  void *ptr;
  // next_bio
  struct bio_st *next_bio;
  // prev_bio
  struct bio_st *prev_bio;
  // references
  signed int references;
  // num_read
  unsigned long int num_read;
  // num_write
  unsigned long int num_write;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct blnode
{
  // actPtr
  signed int actPtr;
  // msgLen
  signed int msgLen;
  // message
  unsigned char *message;
  // nextNode
  struct blnode *nextNode;
};

struct bn_gencb_st
{
  // ver
  unsigned int ver;
  // arg
  void *arg;
  // cb
  union anonymous$33 cb;
};

struct bn_mont_ctx_st
{
  // ri
  signed int ri;
  // RR
  struct bignum_st RR;
  // N
  struct bignum_st N;
  // Ni
  struct bignum_st Ni;
  // n0
  unsigned long int n0[2l];
  // flags
  signed int flags;
};

struct buf_mem_st
{
  // length
  unsigned long int length;
  // data
  char *data;
  // max
  unsigned long int max;
};

struct buflist
{
  // head
  struct blnode *head;
  // tail
  struct blnode *tail;
};

struct comp_ctx_st
{
  // meth
  struct comp_method_st *meth;
  // compress_in
  unsigned long int compress_in;
  // compress_out
  unsigned long int compress_out;
  // expand_in
  unsigned long int expand_in;
  // expand_out
  unsigned long int expand_out;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct comp_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // init
  signed int (*init)(struct comp_ctx_st *);
  // finish
  void (*finish)(struct comp_ctx_st *);
  // compress
  signed int (*compress)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // expand
  signed int (*expand)(struct comp_ctx_st *, unsigned char *, unsigned int, unsigned char *, unsigned int);
  // ctrl
  signed long int (*ctrl)(void);
  // callback_ctrl
  signed long int (*callback_ctrl)(void);
};

struct dh_method
{
  // name
  const char *name;
  // generate_key
  signed int (*generate_key)(struct dh_st *);
  // compute_key
  signed int (*compute_key)(unsigned char *, const struct bignum_st *, struct dh_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(const struct dh_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dh_st *);
  // finish
  signed int (*finish)(struct dh_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // generate_params
  signed int (*generate_params)(struct dh_st *, signed int, signed int, struct bn_gencb_st *);
};

struct dh_st
{
  // pad
  signed int pad;
  // version
  signed int version;
  // p
  struct bignum_st *p;
  // g
  struct bignum_st *g;
  // length
  signed long int length;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // q
  struct bignum_st *q;
  // j
  struct bignum_st *j;
  // seed
  unsigned char *seed;
  // seedlen
  signed int seedlen;
  // counter
  struct bignum_st *counter;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dh_method *meth;
  // engine
  struct engine_st *engine;
};

struct dsa_method
{
  // name
  const char *name;
  // dsa_do_sign
  struct DSA_SIG_st * (*dsa_do_sign)(const unsigned char *, signed int, struct dsa_st *);
  // dsa_sign_setup
  signed int (*dsa_sign_setup)(struct dsa_st *, struct bignum_ctx *, struct bignum_st **, struct bignum_st **);
  // dsa_do_verify
  signed int (*dsa_do_verify)(const unsigned char *, signed int, struct DSA_SIG_st *, struct dsa_st *);
  // dsa_mod_exp
  signed int (*dsa_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct dsa_st *, struct bignum_st *, struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct dsa_st *);
  // finish
  signed int (*finish)(struct dsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // dsa_paramgen
  signed int (*dsa_paramgen)(struct dsa_st *, signed int, const unsigned char *, signed int, signed int *, unsigned long int *, struct bn_gencb_st *);
  // dsa_keygen
  signed int (*dsa_keygen)(struct dsa_st *);
};

struct dsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // write_params
  signed int write_params;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // g
  struct bignum_st *g;
  // pub_key
  struct bignum_st *pub_key;
  // priv_key
  struct bignum_st *priv_key;
  // kinv
  struct bignum_st *kinv;
  // r
  struct bignum_st *r;
  // flags
  signed int flags;
  // method_mont_p
  struct bn_mont_ctx_st *method_mont_p;
  // references
  signed int references;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // meth
  const struct dsa_method *meth;
  // engine
  struct engine_st *engine;
};

struct dtls1_bitmap_st
{
  // map
  unsigned long int map;
  // max_seq_num
  unsigned char max_seq_num[8l];
};

struct dtls1_retransmit_state
{
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // session
  struct ssl_session_st *session;
  // epoch
  unsigned short int epoch;
};

struct record_pqueue_st
{
  // epoch
  unsigned short int epoch;
  // q
  struct _pqueue *q;
};

struct hm_header_st
{
  // type
  unsigned char type;
  // msg_len
  unsigned long int msg_len;
  // seq
  unsigned short int seq;
  // frag_off
  unsigned long int frag_off;
  // frag_len
  unsigned long int frag_len;
  // is_ccs
  unsigned int is_ccs;
  // saved_retransmit_state
  struct dtls1_retransmit_state saved_retransmit_state;
};

struct dtls1_timeout_st
{
  // read_timeouts
  unsigned int read_timeouts;
  // write_timeouts
  unsigned int write_timeouts;
  // num_alerts
  unsigned int num_alerts;
};

struct dtls1_state_st
{
  // send_cookie
  unsigned int send_cookie;
  // cookie
  unsigned char cookie[256l];
  // rcvd_cookie
  unsigned char rcvd_cookie[256l];
  // cookie_len
  unsigned int cookie_len;
  // r_epoch
  unsigned short int r_epoch;
  // w_epoch
  unsigned short int w_epoch;
  // bitmap
  struct dtls1_bitmap_st bitmap;
  // next_bitmap
  struct dtls1_bitmap_st next_bitmap;
  // handshake_write_seq
  unsigned short int handshake_write_seq;
  // next_handshake_write_seq
  unsigned short int next_handshake_write_seq;
  // handshake_read_seq
  unsigned short int handshake_read_seq;
  // last_write_sequence
  unsigned char last_write_sequence[8l];
  // unprocessed_rcds
  struct record_pqueue_st unprocessed_rcds;
  // processed_rcds
  struct record_pqueue_st processed_rcds;
  // buffered_messages
  struct _pqueue *buffered_messages;
  // sent_messages
  struct _pqueue *sent_messages;
  // buffered_app_data
  struct record_pqueue_st buffered_app_data;
  // listen
  unsigned int listen;
  // link_mtu
  unsigned int link_mtu;
  // mtu
  unsigned int mtu;
  // w_msg_hdr
  struct hm_header_st w_msg_hdr;
  // r_msg_hdr
  struct hm_header_st r_msg_hdr;
  // timeout
  struct dtls1_timeout_st timeout;
  // next_timeout
  struct timeval next_timeout;
  // timeout_duration
  unsigned short int timeout_duration;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[12l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // retransmitting
  unsigned int retransmitting;
  // change_cipher_spec_ok
  unsigned int change_cipher_spec_ok;
};

struct entry
{
  // key
  char *key;
  // value
  unsigned char *value;
};

struct env_md_ctx_st
{
  // digest
  const struct env_md_st *digest;
  // engine
  struct engine_st *engine;
  // flags
  unsigned long int flags;
  // md_data
  void *md_data;
  // pctx
  struct evp_pkey_ctx_st *pctx;
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
};

struct env_md_st
{
  // type
  signed int type;
  // pkey_type
  signed int pkey_type;
  // md_size
  signed int md_size;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct env_md_ctx_st *);
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
  // final
  signed int (*final)(struct env_md_ctx_st *, unsigned char *);
  // copy
  signed int (*copy)(struct env_md_ctx_st *, const struct env_md_ctx_st *);
  // cleanup
  signed int (*cleanup)(struct env_md_ctx_st *);
  // sign
  signed int (*sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, void *);
  // verify
  signed int (*verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, void *);
  // required_pkey_type
  signed int required_pkey_type[5l];
  // block_size
  signed int block_size;
  // ctx_size
  signed int ctx_size;
  // md_ctrl
  signed int (*md_ctrl)(struct env_md_ctx_st *, signed int, signed int, void *);
};

struct evp_cipher_ctx_st
{
  // cipher
  const struct evp_cipher_st *cipher;
  // engine
  struct engine_st *engine;
  // encrypt
  signed int encrypt;
  // buf_len
  signed int buf_len;
  // oiv
  unsigned char oiv[16l];
  // iv
  unsigned char iv[16l];
  // buf
  unsigned char buf[32l];
  // num
  signed int num;
  // app_data
  void *app_data;
  // key_len
  signed int key_len;
  // flags
  unsigned long int flags;
  // cipher_data
  void *cipher_data;
  // final_used
  signed int final_used;
  // block_mask
  signed int block_mask;
  // final
  unsigned char final[32l];
};

struct evp_cipher_st
{
  // nid
  signed int nid;
  // block_size
  signed int block_size;
  // key_len
  signed int key_len;
  // iv_len
  signed int iv_len;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct evp_cipher_ctx_st *, const unsigned char *, const unsigned char *, signed int);
  // do_cipher
  signed int (*do_cipher)(struct evp_cipher_ctx_st *, unsigned char *, const unsigned char *, unsigned long int);
  // cleanup
  signed int (*cleanup)(struct evp_cipher_ctx_st *);
  // ctx_size
  signed int ctx_size;
  // set_asn1_parameters
  signed int (*set_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // get_asn1_parameters
  signed int (*get_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // ctrl
  signed int (*ctrl)(struct evp_cipher_ctx_st *, signed int, signed int, void *);
  // app_data
  void *app_data;
};

struct evp_pkey_st
{
  // type
  signed int type;
  // save_type
  signed int save_type;
  // references
  signed int references;
  // ameth
  const struct evp_pkey_asn1_method_st *ameth;
  // engine
  struct engine_st *engine;
  // pkey
  union anonymous$34 pkey;
  // save_parameters
  signed int save_parameters;
  // attributes
  struct stack_st_X509_ATTRIBUTE *attributes;
};

struct hmac_ctx_st
{
  // md
  const struct env_md_st *md;
  // md_ctx
  struct env_md_ctx_st md_ctx;
  // i_ctx
  struct env_md_ctx_st i_ctx;
  // o_ctx
  struct env_md_ctx_st o_ctx;
  // key_length
  unsigned int key_length;
  // key
  unsigned char key[128l];
};

struct in6_addr
{
  // __in6_u
  union anonymous$23 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct lhash_st_SSL_SESSION
{
  // dummy
  signed int dummy;
};

struct llnode
{
  // cmdline
  char *cmdline;
  // msgtype
  char msgtype;
  // importance
  char importance;
  // logfd
  struct _IO_FILE *logfd;
  // next
  struct llnode *next;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rsa_meth_st
{
  // name
  const char *name;
  // rsa_pub_enc
  signed int (*rsa_pub_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_pub_dec
  signed int (*rsa_pub_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_enc
  signed int (*rsa_priv_enc)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_priv_dec
  signed int (*rsa_priv_dec)(signed int, const unsigned char *, unsigned char *, struct rsa_st *, signed int);
  // rsa_mod_exp
  signed int (*rsa_mod_exp)(struct bignum_st *, const struct bignum_st *, struct rsa_st *, struct bignum_ctx *);
  // bn_mod_exp
  signed int (*bn_mod_exp)(struct bignum_st *, const struct bignum_st *, const struct bignum_st *, const struct bignum_st *, struct bignum_ctx *, struct bn_mont_ctx_st *);
  // init
  signed int (*init)(struct rsa_st *);
  // finish
  signed int (*finish)(struct rsa_st *);
  // flags
  signed int flags;
  // app_data
  char *app_data;
  // rsa_sign
  signed int (*rsa_sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, const struct rsa_st *);
  // rsa_verify
  signed int (*rsa_verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, const struct rsa_st *);
  // rsa_keygen
  signed int (*rsa_keygen)(struct rsa_st *, signed int, struct bignum_st *, struct bn_gencb_st *);
};

struct rsa_st
{
  // pad
  signed int pad;
  // version
  signed long int version;
  // meth
  const struct rsa_meth_st *meth;
  // engine
  struct engine_st *engine;
  // n
  struct bignum_st *n;
  // e
  struct bignum_st *e;
  // d
  struct bignum_st *d;
  // p
  struct bignum_st *p;
  // q
  struct bignum_st *q;
  // dmp1
  struct bignum_st *dmp1;
  // dmq1
  struct bignum_st *dmq1;
  // iqmp
  struct bignum_st *iqmp;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
  // flags
  signed int flags;
  // _method_mod_n
  struct bn_mont_ctx_st *_method_mod_n;
  // _method_mod_p
  struct bn_mont_ctx_st *_method_mod_p;
  // _method_mod_q
  struct bn_mont_ctx_st *_method_mod_q;
  // bignum_data
  char *bignum_data;
  // blinding
  struct bn_blinding_st *blinding;
  // mt_blinding
  struct bn_blinding_st *mt_blinding;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$18 __sigaction_handler;
  // sa_mask
  struct anonymous$19 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct srp_ctx_st
{
  // SRP_cb_arg
  void *SRP_cb_arg;
  // TLS_ext_srp_username_callback
  signed int (*TLS_ext_srp_username_callback)(struct ssl_st *, signed int *, void *);
  // SRP_verify_param_callback
  signed int (*SRP_verify_param_callback)(struct ssl_st *, void *);
  // SRP_give_srp_client_pwd_callback
  char * (*SRP_give_srp_client_pwd_callback)(struct ssl_st *, void *);
  // login
  char *login;
  // N
  struct bignum_st *N;
  // g
  struct bignum_st *g;
  // s
  struct bignum_st *s;
  // B
  struct bignum_st *B;
  // A
  struct bignum_st *A;
  // a
  struct bignum_st *a;
  // b
  struct bignum_st *b;
  // v
  struct bignum_st *v;
  // info
  char *info;
  // strength
  signed int strength;
  // srp_Mask
  unsigned long int srp_Mask;
};

struct srtp_protection_profile_st
{
  // name
  const char *name;
  // id
  unsigned long int id;
};

struct ssl2_state_st
{
  // three_byte_header
  signed int three_byte_header;
  // clear_text
  signed int clear_text;
  // escape
  signed int escape;
  // ssl2_rollback
  signed int ssl2_rollback;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_buf
  const unsigned char *wpend_buf;
  // wpend_off
  signed int wpend_off;
  // wpend_len
  signed int wpend_len;
  // wpend_ret
  signed int wpend_ret;
  // rbuf_left
  signed int rbuf_left;
  // rbuf_offs
  signed int rbuf_offs;
  // rbuf
  unsigned char *rbuf;
  // wbuf
  unsigned char *wbuf;
  // write_ptr
  unsigned char *write_ptr;
  // padding
  unsigned int padding;
  // rlength
  unsigned int rlength;
  // ract_data_length
  signed int ract_data_length;
  // wlength
  unsigned int wlength;
  // wact_data_length
  signed int wact_data_length;
  // ract_data
  unsigned char *ract_data;
  // wact_data
  unsigned char *wact_data;
  // mac_data
  unsigned char *mac_data;
  // read_key
  unsigned char *read_key;
  // write_key
  unsigned char *write_key;
  // challenge_length
  unsigned int challenge_length;
  // challenge
  unsigned char challenge[32l];
  // conn_id_length
  unsigned int conn_id_length;
  // conn_id
  unsigned char conn_id[16l];
  // key_material_length
  unsigned int key_material_length;
  // key_material
  unsigned char key_material[48l];
  // read_sequence
  unsigned long int read_sequence;
  // write_sequence
  unsigned long int write_sequence;
  // tmp
  struct anonymous tmp;
};

struct ssl3_buffer_st
{
  // buf
  unsigned char *buf;
  // len
  unsigned long int len;
  // offset
  signed int offset;
  // left
  signed int left;
};

struct ssl3_record_st
{
  // type
  signed int type;
  // length
  unsigned int length;
  // off
  unsigned int off;
  // data
  unsigned char *data;
  // input
  unsigned char *input;
  // comp
  unsigned char *comp;
  // epoch
  unsigned long int epoch;
  // seq_num
  unsigned char seq_num[8l];
};

struct ssl3_state_st
{
  // flags
  signed long int flags;
  // delay_buf_pop_ret
  signed int delay_buf_pop_ret;
  // read_sequence
  unsigned char read_sequence[8l];
  // read_mac_secret_size
  signed int read_mac_secret_size;
  // read_mac_secret
  unsigned char read_mac_secret[64l];
  // write_sequence
  unsigned char write_sequence[8l];
  // write_mac_secret_size
  signed int write_mac_secret_size;
  // write_mac_secret
  unsigned char write_mac_secret[64l];
  // server_random
  unsigned char server_random[32l];
  // client_random
  unsigned char client_random[32l];
  // need_empty_fragments
  signed int need_empty_fragments;
  // empty_fragment_done
  signed int empty_fragment_done;
  // init_extra
  signed int init_extra;
  // rbuf
  struct ssl3_buffer_st rbuf;
  // wbuf
  struct ssl3_buffer_st wbuf;
  // rrec
  struct ssl3_record_st rrec;
  // wrec
  struct ssl3_record_st wrec;
  // alert_fragment
  unsigned char alert_fragment[2l];
  // alert_fragment_len
  unsigned int alert_fragment_len;
  // handshake_fragment
  unsigned char handshake_fragment[4l];
  // handshake_fragment_len
  unsigned int handshake_fragment_len;
  // wnum
  unsigned int wnum;
  // wpend_tot
  signed int wpend_tot;
  // wpend_type
  signed int wpend_type;
  // wpend_ret
  signed int wpend_ret;
  // wpend_buf
  const unsigned char *wpend_buf;
  // handshake_buffer
  struct bio_st *handshake_buffer;
  // handshake_dgst
  struct env_md_ctx_st **handshake_dgst;
  // change_cipher_spec
  signed int change_cipher_spec;
  // warn_alert
  signed int warn_alert;
  // fatal_alert
  signed int fatal_alert;
  // alert_dispatch
  signed int alert_dispatch;
  // send_alert
  unsigned char send_alert[2l];
  // renegotiate
  signed int renegotiate;
  // total_renegotiations
  signed int total_renegotiations;
  // num_renegotiations
  signed int num_renegotiations;
  // in_read_app_data
  signed int in_read_app_data;
  // client_opaque_prf_input
  void *client_opaque_prf_input;
  // client_opaque_prf_input_len
  unsigned long int client_opaque_prf_input_len;
  // server_opaque_prf_input
  void *server_opaque_prf_input;
  // server_opaque_prf_input_len
  unsigned long int server_opaque_prf_input_len;
  // tmp
  struct anonymous$0 tmp;
  // previous_client_finished
  unsigned char previous_client_finished[64l];
  // previous_client_finished_len
  unsigned char previous_client_finished_len;
  // previous_server_finished
  unsigned char previous_server_finished[64l];
  // previous_server_finished_len
  unsigned char previous_server_finished_len;
  // send_connection_binding
  signed int send_connection_binding;
  // next_proto_neg_seen
  signed int next_proto_neg_seen;
  // is_probably_safari
  char is_probably_safari;
  // alpn_selected
  unsigned char *alpn_selected;
  // alpn_selected_len
  unsigned int alpn_selected_len;
};

struct ssl_cipher_st
{
  // valid
  signed int valid;
  // name
  const char *name;
  // id
  unsigned long int id;
  // algorithm_mkey
  unsigned long int algorithm_mkey;
  // algorithm_auth
  unsigned long int algorithm_auth;
  // algorithm_enc
  unsigned long int algorithm_enc;
  // algorithm_mac
  unsigned long int algorithm_mac;
  // algorithm_ssl
  unsigned long int algorithm_ssl;
  // algo_strength
  unsigned long int algo_strength;
  // algorithm2
  unsigned long int algorithm2;
  // strength_bits
  signed int strength_bits;
  // alg_bits
  signed int alg_bits;
};

struct ssl_comp_st
{
  // id
  signed int id;
  // name
  const char *name;
  // method
  struct comp_method_st *method;
};

struct ssl_ctx_st
{
  // method
  const struct ssl_method_st *method;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // cert_store
  struct x509_store_st *cert_store;
  // sessions
  struct lhash_st_SSL_SESSION *sessions;
  // session_cache_size
  unsigned long int session_cache_size;
  // session_cache_head
  struct ssl_session_st *session_cache_head;
  // session_cache_tail
  struct ssl_session_st *session_cache_tail;
  // session_cache_mode
  signed int session_cache_mode;
  // session_timeout
  signed long int session_timeout;
  // new_session_cb
  signed int (*new_session_cb)(struct ssl_st *, struct ssl_session_st *);
  // remove_session_cb
  void (*remove_session_cb)(struct ssl_ctx_st *, struct ssl_session_st *);
  // get_session_cb
  struct ssl_session_st * (*get_session_cb)(struct ssl_st *, unsigned char *, signed int, signed int *);
  // stats
  struct anonymous$24 stats;
  // references
  signed int references;
  // app_verify_callback
  signed int (*app_verify_callback)(struct x509_store_ctx_st *, void *);
  // app_verify_arg
  void *app_verify_arg;
  // default_passwd_callback
  signed int (*default_passwd_callback)(char *, signed int, signed int, void *);
  // default_passwd_callback_userdata
  void *default_passwd_callback_userdata;
  // client_cert_cb
  signed int (*client_cert_cb)(struct ssl_st *, struct x509_st **, struct evp_pkey_st **);
  // app_gen_cookie_cb
  signed int (*app_gen_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int *);
  // app_verify_cookie_cb
  signed int (*app_verify_cookie_cb)(struct ssl_st *, unsigned char *, unsigned int);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // rsa_md5
  const struct env_md_st *rsa_md5;
  // md5
  const struct env_md_st *md5;
  // sha1
  const struct env_md_st *sha1;
  // extra_certs
  struct stack_st_X509 *extra_certs;
  // comp_methods
  struct stack_st_SSL_COMP *comp_methods;
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // cert
  struct cert_st *cert;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // verify_mode
  signed int verify_mode;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // default_verify_callback
  signed int (*default_verify_callback)(signed int, struct x509_store_ctx_st *);
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // param
  struct X509_VERIFY_PARAM_st *param;
  // quiet_shutdown
  signed int quiet_shutdown;
  // max_send_fragment
  unsigned int max_send_fragment;
  // client_cert_engine
  struct engine_st *client_cert_engine;
  // tlsext_servername_callback
  signed int (*tlsext_servername_callback)(struct ssl_st *, signed int *, void *);
  // tlsext_servername_arg
  void *tlsext_servername_arg;
  // tlsext_tick_key_name
  unsigned char tlsext_tick_key_name[16l];
  // tlsext_tick_hmac_key
  unsigned char tlsext_tick_hmac_key[16l];
  // tlsext_tick_aes_key
  unsigned char tlsext_tick_aes_key[16l];
  // tlsext_ticket_key_cb
  signed int (*tlsext_ticket_key_cb)(struct ssl_st *, unsigned char *, unsigned char *, struct evp_cipher_ctx_st *, struct hmac_ctx_st *, signed int);
  // tlsext_status_cb
  signed int (*tlsext_status_cb)(struct ssl_st *, void *);
  // tlsext_status_arg
  void *tlsext_status_arg;
  // tlsext_opaque_prf_input_callback
  signed int (*tlsext_opaque_prf_input_callback)(struct ssl_st *, void *, unsigned long int, void *);
  // tlsext_opaque_prf_input_callback_arg
  void *tlsext_opaque_prf_input_callback_arg;
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // freelist_max_len
  unsigned int freelist_max_len;
  // wbuf_freelist
  struct ssl3_buf_freelist_st *wbuf_freelist;
  // rbuf_freelist
  struct ssl3_buf_freelist_st *rbuf_freelist;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // next_protos_advertised_cb
  signed int (*next_protos_advertised_cb)(struct ssl_st *, const unsigned char **, unsigned int *, void *);
  // next_protos_advertised_cb_arg
  void *next_protos_advertised_cb_arg;
  // next_proto_select_cb
  signed int (*next_proto_select_cb)(struct ssl_st *, unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // next_proto_select_cb_arg
  void *next_proto_select_cb_arg;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // alpn_select_cb
  signed int (*alpn_select_cb)(struct ssl_st *, const unsigned char **, unsigned char *, const unsigned char *, unsigned int, void *);
  // alpn_select_cb_arg
  void *alpn_select_cb_arg;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
};

struct ssl_method_st
{
  // version
  signed int version;
  // ssl_new
  signed int (*ssl_new)(struct ssl_st *);
  // ssl_clear
  void (*ssl_clear)(struct ssl_st *);
  // ssl_free
  void (*ssl_free)(struct ssl_st *);
  // ssl_accept
  signed int (*ssl_accept)(struct ssl_st *);
  // ssl_connect
  signed int (*ssl_connect)(struct ssl_st *);
  // ssl_read
  signed int (*ssl_read)(struct ssl_st *, void *, signed int);
  // ssl_peek
  signed int (*ssl_peek)(struct ssl_st *, void *, signed int);
  // ssl_write
  signed int (*ssl_write)(struct ssl_st *, const void *, signed int);
  // ssl_shutdown
  signed int (*ssl_shutdown)(struct ssl_st *);
  // ssl_renegotiate
  signed int (*ssl_renegotiate)(struct ssl_st *);
  // ssl_renegotiate_check
  signed int (*ssl_renegotiate_check)(struct ssl_st *);
  // ssl_get_message
  signed long int (*ssl_get_message)(struct ssl_st *, signed int, signed int, signed int, signed long int, signed int *);
  // ssl_read_bytes
  signed int (*ssl_read_bytes)(struct ssl_st *, signed int, unsigned char *, signed int, signed int);
  // ssl_write_bytes
  signed int (*ssl_write_bytes)(struct ssl_st *, signed int, const void *, signed int);
  // ssl_dispatch_alert
  signed int (*ssl_dispatch_alert)(struct ssl_st *);
  // ssl_ctrl
  signed long int (*ssl_ctrl)(struct ssl_st *, signed int, signed long int, void *);
  // ssl_ctx_ctrl
  signed long int (*ssl_ctx_ctrl)(struct ssl_ctx_st *, signed int, signed long int, void *);
  // get_cipher_by_char
  const struct ssl_cipher_st * (*get_cipher_by_char)(const unsigned char *);
  // put_cipher_by_char
  signed int (*put_cipher_by_char)(const struct ssl_cipher_st *, unsigned char *);
  // ssl_pending
  signed int (*ssl_pending)(const struct ssl_st *);
  // num_ciphers
  signed int (*num_ciphers)(void);
  // get_cipher
  const struct ssl_cipher_st * (*get_cipher)(unsigned int);
  // get_ssl_method
  struct ssl_method_st * (*get_ssl_method)(signed int);
  // get_timeout
  signed long int (*get_timeout)(void);
  // ssl3_enc
  struct ssl3_enc_method *ssl3_enc;
  // ssl_version
  signed int (*ssl_version)(void);
  // ssl_callback_ctrl
  signed long int (*ssl_callback_ctrl)(struct ssl_st *, signed int, void (*)(void));
  // ssl_ctx_callback_ctrl
  signed long int (*ssl_ctx_callback_ctrl)(struct ssl_ctx_st *, signed int, void (*)(void));
};

struct ssl_session_st
{
  // ssl_version
  signed int ssl_version;
  // key_arg_length
  unsigned int key_arg_length;
  // key_arg
  unsigned char key_arg[8l];
  // master_key_length
  signed int master_key_length;
  // master_key
  unsigned char master_key[48l];
  // session_id_length
  unsigned int session_id_length;
  // session_id
  unsigned char session_id[32l];
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // psk_identity_hint
  char *psk_identity_hint;
  // psk_identity
  char *psk_identity;
  // not_resumable
  signed int not_resumable;
  // sess_cert
  struct sess_cert_st *sess_cert;
  // peer
  struct x509_st *peer;
  // verify_result
  signed long int verify_result;
  // references
  signed int references;
  // timeout
  signed long int timeout;
  // time
  signed long int time;
  // compress_meth
  unsigned int compress_meth;
  // cipher
  const struct ssl_cipher_st *cipher;
  // cipher_id
  unsigned long int cipher_id;
  // ciphers
  struct stack_st_SSL_CIPHER *ciphers;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // prev
  struct ssl_session_st *prev;
  // next
  struct ssl_session_st *next;
  // tlsext_hostname
  char *tlsext_hostname;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_tick
  unsigned char *tlsext_tick;
  // tlsext_ticklen
  unsigned long int tlsext_ticklen;
  // tlsext_tick_lifetime_hint
  signed long int tlsext_tick_lifetime_hint;
  // srp_username
  char *srp_username;
};

struct ssl_st
{
  // version
  signed int version;
  // type
  signed int type;
  // method
  const struct ssl_method_st *method;
  // rbio
  struct bio_st *rbio;
  // wbio
  struct bio_st *wbio;
  // bbio
  struct bio_st *bbio;
  // rwstate
  signed int rwstate;
  // in_handshake
  signed int in_handshake;
  // handshake_func
  signed int (*handshake_func)(struct ssl_st *);
  // server
  signed int server;
  // new_session
  signed int new_session;
  // quiet_shutdown
  signed int quiet_shutdown;
  // shutdown
  signed int shutdown;
  // state
  signed int state;
  // rstate
  signed int rstate;
  // init_buf
  struct buf_mem_st *init_buf;
  // init_msg
  void *init_msg;
  // init_num
  signed int init_num;
  // init_off
  signed int init_off;
  // packet
  unsigned char *packet;
  // packet_length
  unsigned int packet_length;
  // s2
  struct ssl2_state_st *s2;
  // s3
  struct ssl3_state_st *s3;
  // d1
  struct dtls1_state_st *d1;
  // read_ahead
  signed int read_ahead;
  // msg_callback
  void (*msg_callback)(signed int, signed int, signed int, const void *, unsigned long int, struct ssl_st *, void *);
  // msg_callback_arg
  void *msg_callback_arg;
  // hit
  signed int hit;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // cipher_list
  struct stack_st_SSL_CIPHER *cipher_list;
  // cipher_list_by_id
  struct stack_st_SSL_CIPHER *cipher_list_by_id;
  // mac_flags
  signed int mac_flags;
  // enc_read_ctx
  struct evp_cipher_ctx_st *enc_read_ctx;
  // read_hash
  struct env_md_ctx_st *read_hash;
  // expand
  struct comp_ctx_st *expand;
  // enc_write_ctx
  struct evp_cipher_ctx_st *enc_write_ctx;
  // write_hash
  struct env_md_ctx_st *write_hash;
  // compress
  struct comp_ctx_st *compress;
  // cert
  struct cert_st *cert;
  // sid_ctx_length
  unsigned int sid_ctx_length;
  // sid_ctx
  unsigned char sid_ctx[32l];
  // session
  struct ssl_session_st *session;
  // generate_session_id
  signed int (*generate_session_id)(const struct ssl_st *, unsigned char *, unsigned int *);
  // verify_mode
  signed int verify_mode;
  // verify_callback
  signed int (*verify_callback)(signed int, struct x509_store_ctx_st *);
  // info_callback
  void (*info_callback)(const struct ssl_st *, signed int, signed int);
  // error
  signed int error;
  // error_code
  signed int error_code;
  // psk_client_callback
  unsigned int (*psk_client_callback)(struct ssl_st *, const char *, char *, unsigned int, unsigned char *, unsigned int);
  // psk_server_callback
  unsigned int (*psk_server_callback)(struct ssl_st *, const char *, unsigned char *, unsigned int);
  // ctx
  struct ssl_ctx_st *ctx;
  // debug
  signed int debug;
  // verify_result
  signed long int verify_result;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // client_CA
  struct stack_st_X509_NAME *client_CA;
  // references
  signed int references;
  // options
  unsigned long int options;
  // mode
  unsigned long int mode;
  // max_cert_list
  signed long int max_cert_list;
  // first_packet
  signed int first_packet;
  // client_version
  signed int client_version;
  // max_send_fragment
  unsigned int max_send_fragment;
  // tlsext_debug_cb
  void (*tlsext_debug_cb)(struct ssl_st *, signed int, signed int, unsigned char *, signed int, void *);
  // tlsext_debug_arg
  void *tlsext_debug_arg;
  // tlsext_hostname
  char *tlsext_hostname;
  // servername_done
  signed int servername_done;
  // tlsext_status_type
  signed int tlsext_status_type;
  // tlsext_status_expected
  signed int tlsext_status_expected;
  // tlsext_ocsp_ids
  struct stack_st_OCSP_RESPID *tlsext_ocsp_ids;
  // tlsext_ocsp_exts
  struct stack_st_X509_EXTENSION *tlsext_ocsp_exts;
  // tlsext_ocsp_resp
  unsigned char *tlsext_ocsp_resp;
  // tlsext_ocsp_resplen
  signed int tlsext_ocsp_resplen;
  // tlsext_ticket_expected
  signed int tlsext_ticket_expected;
  // tlsext_ecpointformatlist_length
  unsigned long int tlsext_ecpointformatlist_length;
  // tlsext_ecpointformatlist
  unsigned char *tlsext_ecpointformatlist;
  // tlsext_ellipticcurvelist_length
  unsigned long int tlsext_ellipticcurvelist_length;
  // tlsext_ellipticcurvelist
  unsigned char *tlsext_ellipticcurvelist;
  // tlsext_opaque_prf_input
  void *tlsext_opaque_prf_input;
  // tlsext_opaque_prf_input_len
  unsigned long int tlsext_opaque_prf_input_len;
  // tlsext_session_ticket
  struct tls_session_ticket_ext_st *tlsext_session_ticket;
  // tls_session_ticket_ext_cb
  signed int (*tls_session_ticket_ext_cb)(struct ssl_st *, const unsigned char *, signed int, void *);
  // tls_session_ticket_ext_cb_arg
  void *tls_session_ticket_ext_cb_arg;
  // tls_session_secret_cb
  signed int (*tls_session_secret_cb)(struct ssl_st *, void *, signed int *, struct stack_st_SSL_CIPHER *, struct ssl_cipher_st **, void *);
  // tls_session_secret_cb_arg
  void *tls_session_secret_cb_arg;
  // initial_ctx
  struct ssl_ctx_st *initial_ctx;
  // next_proto_negotiated
  unsigned char *next_proto_negotiated;
  // next_proto_negotiated_len
  unsigned char next_proto_negotiated_len;
  // srtp_profiles
  struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles;
  // srtp_profile
  struct srtp_protection_profile_st *srtp_profile;
  // tlsext_heartbeat
  unsigned int tlsext_heartbeat;
  // tlsext_hb_pending
  unsigned int tlsext_hb_pending;
  // tlsext_hb_seq
  unsigned int tlsext_hb_seq;
  // renegotiate
  signed int renegotiate;
  // srp_ctx
  struct srp_ctx_st srp_ctx;
  // alpn_client_proto_list
  unsigned char *alpn_client_proto_list;
  // alpn_client_proto_list_len
  unsigned int alpn_client_proto_list_len;
};

struct stack_st
{
  // num
  signed int num;
  // data
  char **data;
  // sorted
  signed int sorted;
  // num_alloc
  signed int num_alloc;
  // comp
  signed int (*comp)(const void *, const void *);
};

struct stack_st_ASN1_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_SRTP_PROTECTION_PROFILE
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_CIPHER
{
  // stack
  struct stack_st stack;
};

struct stack_st_SSL_COMP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ALGOR
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_ATTRIBUTE
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_CRL
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_EXTENSION
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_LOOKUP
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_NAME_ENTRY
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_OBJECT
{
  // stack
  struct stack_st stack;
};

struct stack_st_X509_REVOKED
{
  // stack
  struct stack_st stack;
};

struct stack_st_void
{
  // stack
  struct stack_st stack;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tlnode
{
  // task
  struct anonymous$13 *task;
  // previous
  struct tlnode *previous;
  // next
  struct tlnode *next;
};

struct tls_session_ticket_ext_st
{
  // length
  unsigned short int length;
  // data
  void *data;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct x509_cert_aux_st
{
  // trust
  struct stack_st_ASN1_OBJECT *trust;
  // reject
  struct stack_st_ASN1_OBJECT *reject;
  // alias
  struct asn1_string_st *alias;
  // keyid
  struct asn1_string_st *keyid;
  // other
  struct stack_st_X509_ALGOR *other;
};

struct x509_cinf_st
{
  // version
  struct asn1_string_st *version;
  // serialNumber
  struct asn1_string_st *serialNumber;
  // signature
  struct X509_algor_st *signature;
  // issuer
  struct X509_name_st *issuer;
  // validity
  struct X509_val_st *validity;
  // subject
  struct X509_name_st *subject;
  // key
  struct X509_pubkey_st *key;
  // issuerUID
  struct asn1_string_st *issuerUID;
  // subjectUID
  struct asn1_string_st *subjectUID;
  // extensions
  struct stack_st_X509_EXTENSION *extensions;
  // enc
  struct ASN1_ENCODING_st enc;
};

struct x509_st
{
  // cert_info
  struct x509_cinf_st *cert_info;
  // sig_alg
  struct X509_algor_st *sig_alg;
  // signature
  struct asn1_string_st *signature;
  // valid
  signed int valid;
  // references
  signed int references;
  // name
  char *name;
  // ex_data
  struct crypto_ex_data_st ex_data;
  // ex_pathlen
  signed long int ex_pathlen;
  // ex_pcpathlen
  signed long int ex_pcpathlen;
  // ex_flags
  unsigned long int ex_flags;
  // ex_kusage
  unsigned long int ex_kusage;
  // ex_xkusage
  unsigned long int ex_xkusage;
  // ex_nscert
  unsigned long int ex_nscert;
  // skid
  struct asn1_string_st *skid;
  // akid
  struct AUTHORITY_KEYID_st *akid;
  // policy_cache
  struct X509_POLICY_CACHE_st *policy_cache;
  // crldp
  struct stack_st_DIST_POINT *crldp;
  // altname
  struct stack_st_GENERAL_NAME *altname;
  // nc
  struct NAME_CONSTRAINTS_st *nc;
  // sha1_hash
  unsigned char sha1_hash[20l];
  // aux
  struct x509_cert_aux_st *aux;
};

struct x509_store_ctx_st
{
  // ctx
  struct x509_store_st *ctx;
  // current_method
  signed int current_method;
  // cert
  struct x509_st *cert;
  // untrusted
  struct stack_st_X509 *untrusted;
  // crls
  struct stack_st_X509_CRL *crls;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // other_ctx
  void *other_ctx;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // check_policy
  signed int (*check_policy)(struct x509_store_ctx_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // valid
  signed int valid;
  // last_untrusted
  signed int last_untrusted;
  // chain
  struct stack_st_X509 *chain;
  // tree
  struct X509_POLICY_TREE_st *tree;
  // explicit_policy
  signed int explicit_policy;
  // error_depth
  signed int error_depth;
  // error
  signed int error;
  // current_cert
  struct x509_st *current_cert;
  // current_issuer
  struct x509_st *current_issuer;
  // current_crl
  struct X509_crl_st *current_crl;
  // current_crl_score
  signed int current_crl_score;
  // current_reasons
  unsigned int current_reasons;
  // parent
  struct x509_store_ctx_st *parent;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct x509_store_st
{
  // cache
  signed int cache;
  // objs
  struct stack_st_X509_OBJECT *objs;
  // get_cert_methods
  struct stack_st_X509_LOOKUP *get_cert_methods;
  // param
  struct X509_VERIFY_PARAM_st *param;
  // verify
  signed int (*verify)(struct x509_store_ctx_st *);
  // verify_cb
  signed int (*verify_cb)(signed int, struct x509_store_ctx_st *);
  // get_issuer
  signed int (*get_issuer)(struct x509_st **, struct x509_store_ctx_st *, struct x509_st *);
  // check_issued
  signed int (*check_issued)(struct x509_store_ctx_st *, struct x509_st *, struct x509_st *);
  // check_revocation
  signed int (*check_revocation)(struct x509_store_ctx_st *);
  // get_crl
  signed int (*get_crl)(struct x509_store_ctx_st *, struct X509_crl_st **, struct x509_st *);
  // check_crl
  signed int (*check_crl)(struct x509_store_ctx_st *, struct X509_crl_st *);
  // cert_crl
  signed int (*cert_crl)(struct x509_store_ctx_st *, struct X509_crl_st *, struct x509_st *);
  // lookup_certs
  struct stack_st_X509 * (*lookup_certs)(struct x509_store_ctx_st *, struct X509_name_st *);
  // lookup_crls
  struct stack_st_X509_CRL * (*lookup_crls)(struct x509_store_ctx_st *, struct X509_name_st *);
  // cleanup
  signed int (*cleanup)(struct x509_store_ctx_st *);
  // ex_data
  struct crypto_ex_data_st ex_data;
  // references
  signed int references;
};


// compressgained
// file stats.c line 25
static signed long int compressgained;
// config
// file afserver.c line 67
struct anonymous$2 *config;
// entries
// file first_run.c line 47
static struct entry entries[6l] = { { .key="countryName", .value=(unsigned char *)"PL" }, 
    { .key="stateOrProvinceName", .value=(unsigned char *)"War-Maz" }, 
    { .key="localityName", .value=(unsigned char *)"Olsztyn" }, 
    { .key="organizationName", .value=(unsigned char *)"gray-world.net" }, 
    { .key="organizationalUnitName", .value=(unsigned char *)"APF team" }, 
    { .key="commonName", .value=(unsigned char *)"Jeremian <jeremian [at] poczta [dot] fm>" } };
// format
// file logging.c line 32
static char format[51l] = { '%', 'Y', '-', '%', 'm', '-', '%', 'd', ' ', '%', 'H', ':', '%', 'M', ':', '%', 'S', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// head
// file logging.c line 30
static struct llnode *head = (struct llnode *)(void *)0;
// home_dir
// file first_run.c line 35
static char *home_dir = (char *)(void *)0;
// home_dir_cer
// file first_run.c line 38
static char *home_dir_cer = (char *)(void *)0;
// home_dir_key
// file first_run.c line 37
static char *home_dir_key = (char *)(void *)0;
// home_dir_store
// file first_run.c line 36
static char *home_dir_store = (char *)(void *)0;
// isseed
// file http_proxy_functions.c line 28
static char isseed;
// long_options
// file afserver.c line 25
static struct option long_options[32l] = { { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 }, 
    { .name="hostname", .has_arg=1, .flag=((signed int *)NULL), .val=110 }, 
    { .name="listenport", .has_arg=1, .flag=((signed int *)NULL), .val=108 }, 
    { .name="manageport", .has_arg=1, .flag=((signed int *)NULL), .val=109 }, 
    { .name="timeout", .has_arg=1, .flag=((signed int *)NULL), .val=116 }, 
    { .name="maxidle", .has_arg=1, .flag=((signed int *)NULL), .val=321 }, 
    { .name="verbose", .has_arg=0, .flag=((signed int *)NULL), .val=118 }, 
    { .name="users", .has_arg=1, .flag=((signed int *)NULL), .val=117 }, 
    { .name="clients", .has_arg=1, .flag=((signed int *)NULL), .val=67 }, 
    { .name="realm", .has_arg=1, .flag=((signed int *)NULL), .val=114 }, 
    { .name="raclients", .has_arg=1, .flag=((signed int *)NULL), .val=82 }, 
    { .name="usrpcli", .has_arg=1, .flag=((signed int *)NULL), .val=85 }, 
    { .name="climode", .has_arg=1, .flag=((signed int *)NULL), .val=77 }, 
    { .name="cerfile", .has_arg=1, .flag=((signed int *)NULL), .val=99 }, 
    { .name="cacerfile", .has_arg=1, .flag=((signed int *)NULL), .val=65 }, 
    { .name="cerdepth", .has_arg=1, .flag=((signed int *)NULL), .val=100 }, 
    { .name="keyfile", .has_arg=1, .flag=((signed int *)NULL), .val=107 }, 
    { .name="cfgfile", .has_arg=1, .flag=((signed int *)NULL), .val=102 }, 
    { .name="proto", .has_arg=1, .flag=((signed int *)NULL), .val=112 }, 
    { .name="log", .has_arg=1, .flag=((signed int *)NULL), .val=111 }, 
    { .name="audit", .has_arg=0, .flag=((signed int *)NULL), .val=97 }, 
    { .name="nossl", .has_arg=0, .flag=((signed int *)NULL), .val=301 }, 
    { .name="nozlib", .has_arg=0, .flag=((signed int *)NULL), .val=302 }, 
    { .name="pass", .has_arg=1, .flag=((signed int *)NULL), .val=303 }, 
    { .name="ipv4", .has_arg=0, .flag=((signed int *)NULL), .val=52 }, 
    { .name="ipv6", .has_arg=0, .flag=((signed int *)NULL), .val=54 }, 
    { .name="baseport", .has_arg=0, .flag=((signed int *)NULL), .val=98 }, 
    { .name="dnslookups", .has_arg=0, .flag=((signed int *)NULL), .val=311 }, 
    { .name="dateformat", .has_arg=1, .flag=((signed int *)NULL), .val=68 }, 
    { .name="enableproxy", .has_arg=0, .flag=((signed int *)NULL), .val=80 }, 
    { .name="version", .has_arg=0, .flag=((signed int *)NULL), .val=86 }, 
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
// maincond
// file thread_management.c line 29
static union anonymous$31 maincond = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// mainmutex
// file thread_management.c line 28
static union anonymous$29 mainmutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// mainthread
// file thread_management.c line 27
static unsigned long int mainthread;
// newmessage
// file server_remoteadmin.c line 26
static char newmessage;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// verlev
// file logging.c line 31
static char verlev;

// AuditListNode_free
// file audit_list_node_struct.c line 81
void AuditListNode_free(struct alnode **aln)
{
  if(!(aln == ((struct alnode **)NULL)))
  {
    if(!(*aln == ((struct alnode *)NULL)))
    {
      free((void *)*aln);
      *aln = (struct alnode *)(void *)0;
    }

  }

}

// AuditListNode_get_connectTime
// file audit_list_node_struct.c line 258
signed long int AuditListNode_get_connectTime(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (signed long int)0;

  else
    return aln->connectTime;
}

// AuditListNode_get_connectTimep
// file audit_list_node_struct.h line 56
signed long int * AuditListNode_get_connectTimep(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return ((signed long int *)NULL);

  else
    return &aln->connectTime;
}

// AuditListNode_get_duration
// file audit_list_node_struct.h line 53
signed long int AuditListNode_get_duration(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (signed long int)0;

  else
    return aln->duration;
}

// AuditListNode_get_nameBuf
// file audit_list_node_struct.h line 50
char * AuditListNode_get_nameBuf(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (char *)(void *)0;

  else
    return aln->nameBuf;
}

// AuditListNode_get_nextNode
// file audit_list_node_struct.h line 54
struct alnode * AuditListNode_get_nextNode(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (struct alnode *)(void *)0;

  else
    return aln->nextNode;
}

// AuditListNode_get_portBuf
// file audit_list_node_struct.h line 51
char * AuditListNode_get_portBuf(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return (char *)(void *)0;

  else
    return aln->portBuf;
}

// AuditListNode_get_userId
// file audit_list_node_struct.h line 49
signed int AuditListNode_get_userId(struct alnode *aln)
{
  if(aln == ((struct alnode *)NULL))
    return -1;

  else
    return aln->userId;
}

// AuditListNode_new
// file audit_list_node_struct.c line 36
struct alnode * AuditListNode_new()
{
  struct alnode *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct alnode) /*168ul*/ );
  tmp = (struct alnode *)return_value_calloc$1;
  if(tmp == ((struct alnode *)NULL))
    return (struct alnode *)(void *)0;

  else
    return tmp;
}

// AuditListNode_new_entry
// file audit_list_node_struct.h line 37
struct alnode * AuditListNode_new_entry(signed int userId, char *nameBuf, char *portBuf, signed long int connectTime, signed long int duration)
{
  struct alnode *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct alnode) /*168ul*/ );
  tmp = (struct alnode *)return_value_calloc$1;
  if(tmp == ((struct alnode *)NULL))
    return (struct alnode *)(void *)0;

  else
  {
    AuditListNode_set_userId(tmp, userId);
    AuditListNode_set_nameBuf(tmp, nameBuf);
    AuditListNode_set_portBuf(tmp, portBuf);
    AuditListNode_set_connectTime(tmp, connectTime);
    AuditListNode_set_duration(tmp, duration);
    return tmp;
  }
}

// AuditListNode_set_connectTime
// file audit_list_node_struct.c line 156
void AuditListNode_set_connectTime(struct alnode *aln, signed long int connectTime)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->connectTime = connectTime;

}

// AuditListNode_set_duration
// file audit_list_node_struct.c line 173
void AuditListNode_set_duration(struct alnode *aln, signed long int duration)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->duration = duration;

}

// AuditListNode_set_nameBuf
// file audit_list_node_struct.c line 120
void AuditListNode_set_nameBuf(struct alnode *aln, char *nameBuf)
{
  if(!(aln == ((struct alnode *)NULL)))
  {
    memset((void *)aln->nameBuf, 0, (unsigned long int)7);
    __builtin_strncpy(aln->nameBuf, nameBuf, (unsigned long int)6);
  }

}

// AuditListNode_set_nextNode
// file audit_list_node_struct.c line 190
void AuditListNode_set_nextNode(struct alnode *aln, struct alnode *nextNode)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->nextNode = nextNode;

}

// AuditListNode_set_portBuf
// file audit_list_node_struct.c line 138
void AuditListNode_set_portBuf(struct alnode *aln, char *portBuf)
{
  if(!(aln == ((struct alnode *)NULL)))
  {
    memset((void *)aln->portBuf, 0, (unsigned long int)7);
    __builtin_strncpy(aln->portBuf, portBuf, (unsigned long int)6);
  }

}

// AuditListNode_set_userId
// file audit_list_node_struct.c line 103
void AuditListNode_set_userId(struct alnode *aln, signed int userId)
{
  if(!(aln == ((struct alnode *)NULL)))
    aln->userId = userId;

}

// AuditList_clear
// file audit_list_struct.h line 39
void AuditList_clear(struct auditlist *al)
{
  struct alnode *return_value_AuditList_get_first$1;
  if(!(al == ((struct auditlist *)NULL)))
    do
    {
      return_value_AuditList_get_first$1=AuditList_get_first(al);
      if(return_value_AuditList_get_first$1 == ((struct alnode *)NULL))
        break;

      AuditList_delete_first(al);
    }
    while((_Bool)1);

}

// AuditList_delete_first
// file audit_list_struct.h line 38
void AuditList_delete_first(struct auditlist *al)
{
  struct alnode *tmp;
  tmp=AuditList_get_first(al);
  if(!(tmp == ((struct alnode *)NULL)))
  {
    if(tmp == al->tail)
    {
      al->tail = (struct alnode *)(void *)0;
      al->head = al->tail;
    }

    else
      al->head=AuditListNode_get_nextNode(tmp);
    AuditListNode_free(&tmp);
  }

}

// AuditList_free
// file audit_list_struct.c line 53
void AuditList_free(struct auditlist **al)
{
  if(!(al == ((struct auditlist **)NULL)))
  {
    if(!(*al == ((struct auditlist *)NULL)))
    {
      AuditList_clear(*al);
      free((void *)*al);
      *al = (struct auditlist *)(void *)0;
    }

  }

}

// AuditList_get_first
// file audit_list_struct.h line 37
struct alnode * AuditList_get_first(struct auditlist *al)
{
  if(al == ((struct auditlist *)NULL))
    return (struct alnode *)(void *)0;

  else
    return al->head;
}

// AuditList_insert_back
// file audit_list_struct.h line 36
void AuditList_insert_back(struct auditlist *al, struct alnode *aln)
{
  if(!(al == ((struct auditlist *)NULL)))
  {
    if(!(aln == ((struct alnode *)NULL)))
    {
      if(!(al->tail == ((struct alnode *)NULL)))
        al->tail->nextNode = aln;

      else
        al->head = aln;
      al->tail = aln;
      aln->nextNode = (struct alnode *)(void *)0;
    }

  }

}

// AuditList_new
// file audit_list_struct.c line 36
struct auditlist * AuditList_new()
{
  struct auditlist *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct auditlist) /*16ul*/ );
  tmp = (struct auditlist *)return_value_calloc$1;
  if(tmp == ((struct auditlist *)NULL))
    return (struct auditlist *)(void *)0;

  else
    return tmp;
}

// BufListNode_free
// file buf_list_node_struct.c line 76
void BufListNode_free(struct blnode **bln)
{
  if(!(bln == ((struct blnode **)NULL)))
  {
    if(!(*bln == ((struct blnode *)NULL)))
    {
      if(!((*bln)->message == ((unsigned char *)NULL)))
      {
        free((void *)(*bln)->message);
        (*bln)->message = (unsigned char *)(void *)0;
      }

      free((void *)*bln);
      *bln = (struct blnode *)(void *)0;
    }

  }

}

// BufListNode_get_actPtr
// file buf_list_node_struct.h line 42
signed int BufListNode_get_actPtr(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return -1;

  else
    return bln->actPtr;
}

// BufListNode_get_message
// file buf_list_node_struct.c line 221
unsigned char * BufListNode_get_message(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return (unsigned char *)(void *)0;

  else
    return bln->message;
}

// BufListNode_get_msgLen
// file buf_list_node_struct.c line 204
signed int BufListNode_get_msgLen(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return -1;

  else
    return bln->msgLen;
}

// BufListNode_get_nextNode
// file buf_list_node_struct.c line 238
struct blnode * BufListNode_get_nextNode(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return (struct blnode *)(void *)0;

  else
    return bln->nextNode;
}

// BufListNode_new
// file buf_list_node_struct.c line 36
struct blnode * BufListNode_new()
{
  struct blnode *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct blnode) /*24ul*/ );
  tmp = (struct blnode *)return_value_calloc$1;
  if(tmp == ((struct blnode *)NULL))
    return (struct blnode *)(void *)0;

  else
    return tmp;
}

// BufListNode_new_message
// file buf_list_node_struct.h line 33
struct blnode * BufListNode_new_message(signed int actPtr, signed int msgLen, unsigned char *message)
{
  struct blnode *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct blnode) /*24ul*/ );
  tmp = (struct blnode *)return_value_calloc$1;
  if(tmp == ((struct blnode *)NULL))
    return (struct blnode *)(void *)0;

  else
  {
    BufListNode_set_message(tmp, message, msgLen);
    BufListNode_set_actPtr(tmp, actPtr);
    return tmp;
  }
}

// BufListNode_readMessage
// file buf_list_node_struct.h line 47
unsigned char * BufListNode_readMessage(struct blnode *bln)
{
  if(bln == ((struct blnode *)NULL))
    return (unsigned char *)(void *)0;

  else
  {
    signed int return_value_BufListNode_get_actPtr$1;
    return_value_BufListNode_get_actPtr$1=BufListNode_get_actPtr(bln);
    return &bln->message[(signed long int)return_value_BufListNode_get_actPtr$1];
  }
}

// BufListNode_readMessageLength
// file buf_list_node_struct.h line 48
signed int BufListNode_readMessageLength(struct blnode *bln)
{
  signed int tmp = 0;
  if(bln == ((struct blnode *)NULL))
    return -1;

  else
  {
    unsigned char *return_value_BufListNode_get_message$1;
    return_value_BufListNode_get_message$1=BufListNode_get_message(bln);
    if(return_value_BufListNode_get_message$1 == ((unsigned char *)NULL))
      return -1;

    else
    {
      signed int return_value_BufListNode_get_msgLen$2;
      return_value_BufListNode_get_msgLen$2=BufListNode_get_msgLen(bln);
      signed int return_value_BufListNode_get_actPtr$3;
      return_value_BufListNode_get_actPtr$3=BufListNode_get_actPtr(bln);
      tmp = return_value_BufListNode_get_msgLen$2 - return_value_BufListNode_get_actPtr$3;
      if(!(tmp >= 0))
        return 0;

      else
        return tmp;
    }
  }
}

// BufListNode_set_actPtr
// file buf_list_node_struct.h line 37
void BufListNode_set_actPtr(struct blnode *bln, signed int actPtr)
{
  if(!(bln == ((struct blnode *)NULL)))
    bln->actPtr = actPtr;

}

// BufListNode_set_message
// file buf_list_node_struct.c line 137
void BufListNode_set_message(struct blnode *bln, unsigned char *message, signed int msgLen)
{
  if(!(bln == ((struct blnode *)NULL)))
  {
    if(!(bln->message == ((unsigned char *)NULL)))
    {
      free((void *)bln->message);
      bln->message = (unsigned char *)(void *)0;
    }

    BufListNode_set_actPtr(bln, 0);
    BufListNode_set_msgLen(bln, 0);
    if(!(message == ((unsigned char *)NULL)))
    {
      void *return_value_calloc$1;
      return_value_calloc$1=calloc((unsigned long int)1, (unsigned long int)msgLen);
      bln->message = (unsigned char *)return_value_calloc$1;
      if(!(bln->message == ((unsigned char *)NULL)))
      {
        memcpy((void *)bln->message, (const void *)message, (unsigned long int)msgLen);
        BufListNode_set_msgLen(bln, msgLen);
      }

    }

  }

}

// BufListNode_set_msgLen
// file buf_list_node_struct.c line 119
void BufListNode_set_msgLen(struct blnode *bln, signed int msgLen)
{
  if(!(bln == ((struct blnode *)NULL)))
    bln->msgLen = msgLen;

}

// BufListNode_set_nextNode
// file buf_list_node_struct.c line 170
void BufListNode_set_nextNode(struct blnode *bln, struct blnode *nextNode)
{
  if(!(bln == ((struct blnode *)NULL)))
    bln->nextNode = nextNode;

}

// BufList_clear
// file buf_list_struct.h line 39
void BufList_clear(struct buflist *bl)
{
  struct blnode *return_value_BufList_get_first$1;
  if(!(bl == ((struct buflist *)NULL)))
    do
    {
      return_value_BufList_get_first$1=BufList_get_first(bl);
      if(return_value_BufList_get_first$1 == ((struct blnode *)NULL))
        break;

      BufList_delete_first(bl);
    }
    while((_Bool)1);

}

// BufList_delete_first
// file buf_list_struct.h line 38
void BufList_delete_first(struct buflist *bl)
{
  struct blnode *tmp;
  tmp=BufList_get_first(bl);
  if(!(tmp == ((struct blnode *)NULL)))
  {
    if(tmp == bl->tail)
    {
      bl->tail = (struct blnode *)(void *)0;
      bl->head = bl->tail;
    }

    else
      bl->head=BufListNode_get_nextNode(tmp);
    BufListNode_free(&tmp);
  }

}

// BufList_free
// file buf_list_struct.c line 53
void BufList_free(struct buflist **bl)
{
  if(!(bl == ((struct buflist **)NULL)))
  {
    if(!(*bl == ((struct buflist *)NULL)))
    {
      BufList_clear(*bl);
      free((void *)*bl);
      *bl = (struct buflist *)(void *)0;
    }

  }

}

// BufList_get_first
// file buf_list_struct.h line 37
struct blnode * BufList_get_first(struct buflist *bl)
{
  if(bl == ((struct buflist *)NULL))
    return (struct blnode *)(void *)0;

  else
    return bl->head;
}

// BufList_insert_back
// file buf_list_struct.h line 36
void BufList_insert_back(struct buflist *bl, struct blnode *bln)
{
  if(!(bl == ((struct buflist *)NULL)))
  {
    if(!(bln == ((struct blnode *)NULL)))
    {
      if(!(bl->tail == ((struct blnode *)NULL)))
        bl->tail->nextNode = bln;

      else
        bl->head = bln;
      bl->tail = bln;
      bln->nextNode = (struct blnode *)(void *)0;
    }

  }

}

// BufList_new
// file buf_list_struct.c line 36
struct buflist * BufList_new()
{
  struct buflist *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct buflist) /*16ul*/ );
  tmp = (struct buflist *)return_value_calloc$1;
  if(tmp == ((struct buflist *)NULL))
    return (struct buflist *)(void *)0;

  else
    return tmp;
}

// ConnectClient_create_users
// file connect_client_struct.h line 113
signed int ConnectClient_create_users(struct anonymous$3 *cc)
{
  signed int i;
  signed int limit;
  if(cc == ((struct anonymous$3 *)NULL))
    return 1;

  else
  {
    limit=ConnectClient_get_limit(cc);
    if(limit == -1)
      return 2;

    else
    {
      void *return_value_malloc$1;
      return_value_malloc$1=malloc((unsigned long int)limit * sizeof(signed int) /*4ul*/ );
      cc->users = (signed int *)return_value_malloc$1;
      if(cc->users == ((signed int *)NULL))
        return 3;

      else
      {
        i = 0;
        for( ; !(i >= limit); i = i + 1)
          cc->users[(signed long int)i] = -1;
        return 0;
      }
    }
  }
}

// ConnectClient_decrease_connected
// file connect_client_struct.h line 116
void ConnectClient_decrease_connected(struct anonymous$3 *cc)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
  {
    signed int return_value_ConnectClient_get_connected$1;
    return_value_ConnectClient_get_connected$1=ConnectClient_get_connected(cc);
    ConnectClient_set_connected(cc, return_value_ConnectClient_get_connected$1 - 1);
  }

}

// ConnectClient_free
// file connect_client_struct.c line 73
void ConnectClient_free(struct anonymous$3 **cc)
{
  struct anonymous$1 *sftmp;
  struct auditlist *altmp;
  if(!(cc == ((struct anonymous$3 **)NULL)))
  {
    if(!(*cc == ((struct anonymous$3 *)NULL)))
    {
      sftmp=ConnectClient_get_sslFd(*cc);
      altmp=ConnectClient_get_auditList(*cc);
      SslFd_free(&sftmp);
      AuditList_free(&altmp);
      if(!((*cc)->users == ((signed int *)NULL)))
      {
        free((void *)(*cc)->users);
        (*cc)->users = (signed int *)(void *)0;
      }

      if(!((*cc)->sClientId == ((char *)NULL)))
      {
        free((void *)(*cc)->sClientId);
        (*cc)->sClientId = (char *)(void *)0;
      }

      free((void *)*cc);
      *cc = (struct anonymous$3 *)(void *)0;
    }

  }

}

// ConnectClient_get_auditList
// file connect_client_struct.h line 109
struct auditlist * ConnectClient_get_auditList(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (struct auditlist *)(void *)0;

  else
    return cc->auditList;
}

// ConnectClient_get_clientId
// file connect_client_struct.h line 101
signed int ConnectClient_get_clientId(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return -1;

  else
    return cc->clientId;
}

// ConnectClient_get_connectTime
// file connect_client_struct.h line 102
signed long int ConnectClient_get_connectTime(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (signed long int)0;

  else
    return cc->connectTime;
}

// ConnectClient_get_connected
// file connect_client_struct.h line 97
signed int ConnectClient_get_connected(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return -1;

  else
    return cc->connected;
}

// ConnectClient_get_header
// file connect_client_struct.h line 110
struct anonymous$8 * ConnectClient_get_header(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (struct anonymous$8 *)(void *)0;

  else
    return cc->header;
}

// ConnectClient_get_lastActivity
// file connect_client_struct.h line 103
signed long int ConnectClient_get_lastActivity(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (signed long int)0;

  else
    return cc->lastActivity;
}

// ConnectClient_get_limit
// file connect_client_struct.h line 98
signed int ConnectClient_get_limit(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return -1;

  else
    return cc->limit;
}

// ConnectClient_get_listenFd
// file connect_client_struct.h line 99
signed int ConnectClient_get_listenFd(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return -1;

  else
    return cc->listenFd;
}

// ConnectClient_get_listenFdp
// file connect_client_struct.h line 117
signed int * ConnectClient_get_listenFdp(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (signed int *)(void *)0;

  else
    return &cc->listenFd;
}

// ConnectClient_get_multi
// file connect_client_struct.h line 108
char ConnectClient_get_multi(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (char)0;

  else
    return cc->multi;
}

// ConnectClient_get_nameBuf
// file connect_client_struct.h line 105
char * ConnectClient_get_nameBuf(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (char *)(void *)0;

  else
    return cc->nameBuf;
}

// ConnectClient_get_portBuf
// file connect_client_struct.h line 106
char * ConnectClient_get_portBuf(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (char *)(void *)0;

  else
    return cc->portBuf;
}

// ConnectClient_get_sClientId
// file connect_client_struct.h line 104
char * ConnectClient_get_sClientId(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (char *)(void *)0;

  else
    return cc->sClientId;
}

// ConnectClient_get_sslFd
// file connect_client_struct.h line 94
struct anonymous$1 * ConnectClient_get_sslFd(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (struct anonymous$1 *)(void *)0;

  else
    return cc->sslFd;
}

// ConnectClient_get_state
// file connect_client_struct.h line 93
char ConnectClient_get_state(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (char)-1;

  else
    return cc->state;
}

// ConnectClient_get_task
// file connect_client_struct.h line 111
struct anonymous$13 * ConnectClient_get_task(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (struct anonymous$13 *)(void *)0;

  else
    return cc->task;
}

// ConnectClient_get_timer
// file connect_client_struct.c line 484
struct timeval ConnectClient_get_timer(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
  {
    struct timeval return_value_timeval_create$1;
    return_value_timeval_create$1=timeval_create((signed long int)0, (signed long int)0);
    return return_value_timeval_create$1;
  }

  return cc->timer;
}

// ConnectClient_get_timerp
// file connect_client_struct.h line 114
struct timeval * ConnectClient_get_timerp(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (struct timeval *)(void *)0;

  else
    return &cc->timer;
}

// ConnectClient_get_tunnelType
// file connect_client_struct.h line 107
char ConnectClient_get_tunnelType(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (char)-1;

  else
    return cc->tunnelType;
}

// ConnectClient_get_users
// file connect_client_struct.h line 96
signed int * ConnectClient_get_users(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return (signed int *)(void *)0;

  else
    return cc->users;
}

// ConnectClient_get_usrCliPair
// file connect_client_struct.h line 100
signed int ConnectClient_get_usrCliPair(struct anonymous$3 *cc)
{
  if(cc == ((struct anonymous$3 *)NULL))
    return -1;

  else
    return cc->usrCliPair;
}

// ConnectClient_increase_connected
// file connect_client_struct.h line 115
void ConnectClient_increase_connected(struct anonymous$3 *cc)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
  {
    signed int return_value_ConnectClient_get_connected$1;
    return_value_ConnectClient_get_connected$1=ConnectClient_get_connected(cc);
    ConnectClient_set_connected(cc, return_value_ConnectClient_get_connected$1 + 1);
  }

}

// ConnectClient_new
// file connect_client_struct.h line 69
struct anonymous$3 * ConnectClient_new()
{
  struct anonymous$3 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$3) /*256ul*/ );
  tmp = (struct anonymous$3 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$3 *)NULL))
    return (struct anonymous$3 *)(void *)0;

  else
  {
    tmp->sslFd=SslFd_new();
    if(tmp->sslFd == ((struct anonymous$1 *)NULL))
    {
      ConnectClient_free(&tmp);
      return (struct anonymous$3 *)(void *)0;
    }

    else
    {
      tmp->auditList=AuditList_new();
      if(tmp->auditList == ((struct auditlist *)NULL))
      {
        ConnectClient_free(&tmp);
        return (struct anonymous$3 *)(void *)0;
      }

      else
      {
        tmp->header=HeaderBuffer_new();
        if(tmp->header == ((struct anonymous$8 *)NULL))
        {
          ConnectClient_free(&tmp);
          return (struct anonymous$3 *)(void *)0;
        }

        else
          return tmp;
      }
    }
  }
}

// ConnectClient_set_auditList
// file connect_client_struct.c line 390
void ConnectClient_set_auditList(struct anonymous$3 *cc, struct auditlist *al)
{
  struct auditlist *altmp;
  if(!(cc == ((struct anonymous$3 *)NULL)))
  {
    altmp=ConnectClient_get_auditList(cc);
    AuditList_free(&altmp);
    cc->auditList = al;
  }

}

// ConnectClient_set_clientId
// file connect_client_struct.h line 81
void ConnectClient_set_clientId(struct anonymous$3 *cc, signed int clientId)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
    cc->clientId = clientId;

}

// ConnectClient_set_connectTime
// file connect_client_struct.h line 82
void ConnectClient_set_connectTime(struct anonymous$3 *cc, signed long int connectTime)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
    cc->connectTime = connectTime;

}

// ConnectClient_set_connected
// file connect_client_struct.h line 77
void ConnectClient_set_connected(struct anonymous$3 *cc, signed int connected)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
    cc->connected = connected;

}

// ConnectClient_set_header
// file connect_client_struct.c line 410
void ConnectClient_set_header(struct anonymous$3 *cc, struct anonymous$8 *hb)
{
  struct anonymous$8 *hbtmp;
  if(!(cc == ((struct anonymous$3 *)NULL)))
  {
    hbtmp=ConnectClient_get_header(cc);
    HeaderBuffer_free(&hbtmp);
    cc->header = hb;
  }

}

// ConnectClient_set_lastActivity
// file connect_client_struct.h line 83
void ConnectClient_set_lastActivity(struct anonymous$3 *cc, signed long int lastActivity)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
    cc->lastActivity = lastActivity;

}

// ConnectClient_set_limit
// file connect_client_struct.h line 78
void ConnectClient_set_limit(struct anonymous$3 *cc, signed int limit)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
    cc->limit = limit;

}

// ConnectClient_set_listenFd
// file connect_client_struct.c line 217
void ConnectClient_set_listenFd(struct anonymous$3 *cc, signed int listenFd)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
    cc->listenFd = listenFd;

}

// ConnectClient_set_multi
// file connect_client_struct.h line 88
void ConnectClient_set_multi(struct anonymous$3 *cc, char multi)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
    cc->multi = multi;

}

// ConnectClient_set_nameBuf
// file connect_client_struct.h line 85
void ConnectClient_set_nameBuf(struct anonymous$3 *cc, char *nameBuf)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
  {
    memset((void *)cc->nameBuf, 0, (unsigned long int)128);
    __builtin_strncpy(cc->nameBuf, nameBuf, (unsigned long int)127);
  }

}

// ConnectClient_set_portBuf
// file connect_client_struct.h line 86
void ConnectClient_set_portBuf(struct anonymous$3 *cc, char *portBuf)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
  {
    memset((void *)cc->portBuf, 0, (unsigned long int)7);
    __builtin_strncpy(cc->portBuf, portBuf, (unsigned long int)6);
  }

}

// ConnectClient_set_sClientId
// file connect_client_struct.h line 84
void ConnectClient_set_sClientId(struct anonymous$3 *cc, char *sClientId)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
    string_cp(&cc->sClientId, sClientId);

}

// ConnectClient_set_sslFd
// file connect_client_struct.c line 126
void ConnectClient_set_sslFd(struct anonymous$3 *cc, struct anonymous$1 *sf)
{
  struct anonymous$1 *sftmp;
  if(!(cc == ((struct anonymous$3 *)NULL)))
  {
    sftmp=ConnectClient_get_sslFd(cc);
    SslFd_free(&sftmp);
    cc->sslFd = sf;
  }

}

// ConnectClient_set_state
// file connect_client_struct.h line 73
void ConnectClient_set_state(struct anonymous$3 *cc, char state)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
    cc->state = state;

}

// ConnectClient_set_task
// file connect_client_struct.h line 91
void ConnectClient_set_task(struct anonymous$3 *cc, struct anonymous$13 *task)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
  {
    if(!(cc->task == ((struct anonymous$13 *)NULL)))
      Task_free(&cc->task);

    cc->task = task;
  }

}

// ConnectClient_set_timer
// file connect_client_struct.h line 75
void ConnectClient_set_timer(struct anonymous$3 *cc, struct timeval timer)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
    cc->timer = timer;

}

// ConnectClient_set_tunnelType
// file connect_client_struct.h line 87
void ConnectClient_set_tunnelType(struct anonymous$3 *cc, char tunnelType)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
    cc->tunnelType = tunnelType;

}

// ConnectClient_set_users
// file connect_client_struct.c line 163
void ConnectClient_set_users(struct anonymous$3 *cc, signed int *users)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
  {
    if(!(cc->users == ((signed int *)NULL)))
      free((void *)cc->users);

    cc->users = users;
  }

}

// ConnectClient_set_usrCliPair
// file connect_client_struct.h line 80
void ConnectClient_set_usrCliPair(struct anonymous$3 *cc, signed int usrCliPair)
{
  if(!(cc == ((struct anonymous$3 *)NULL)))
    cc->usrCliPair = usrCliPair;

}

// ConnectUser_free
// file connect_user_struct.c line 66
void ConnectUser_free(struct anonymous$4 **cu)
{
  struct buflist *bftmp;
  struct anonymous$6 *ustmp;
  if(!(cu == ((struct anonymous$4 **)NULL)))
  {
    if(!(*cu == ((struct anonymous$4 *)NULL)))
    {
      bftmp=ConnectUser_get_bufList(*cu);
      ustmp=ConnectUser_get_stats(*cu);
      BufList_free(&bftmp);
      UserStats_free(&ustmp);
      free((void *)*cu);
      *cu = (struct anonymous$4 *)(void *)0;
    }

  }

}

// ConnectUser_get_bufList
// file connect_user_struct.h line 64
struct buflist * ConnectUser_get_bufList(struct anonymous$4 *cu)
{
  if(cu == ((struct anonymous$4 *)NULL))
    return (struct buflist *)(void *)0;

  else
    return cu->bufList;
}

// ConnectUser_get_connFd
// file connect_user_struct.h line 58
signed int ConnectUser_get_connFd(struct anonymous$4 *cu)
{
  if(cu == ((struct anonymous$4 *)NULL))
    return -1;

  else
    return cu->connFd;
}

// ConnectUser_get_connectTime
// file connect_user_struct.h line 61
signed long int ConnectUser_get_connectTime(struct anonymous$4 *cu)
{
  if(cu == ((struct anonymous$4 *)NULL))
    return (signed long int)0;

  else
    return cu->connectTime;
}

// ConnectUser_get_nameBuf
// file connect_user_struct.h line 62
char * ConnectUser_get_nameBuf(struct anonymous$4 *cu)
{
  if(cu == ((struct anonymous$4 *)NULL))
    return (char *)(void *)0;

  else
    return cu->nameBuf;
}

// ConnectUser_get_portBuf
// file connect_user_struct.h line 63
char * ConnectUser_get_portBuf(struct anonymous$4 *cu)
{
  if(cu == ((struct anonymous$4 *)NULL))
    return (char *)(void *)0;

  else
    return cu->portBuf;
}

// ConnectUser_get_state
// file connect_user_struct.h line 57
char ConnectUser_get_state(struct anonymous$4 *cu)
{
  if(cu == ((struct anonymous$4 *)NULL))
    return (char)0;

  else
    return cu->state;
}

// ConnectUser_get_stats
// file connect_user_struct.h line 65
struct anonymous$6 * ConnectUser_get_stats(struct anonymous$4 *cu)
{
  if(cu == ((struct anonymous$4 *)NULL))
    return (struct anonymous$6 *)(void *)0;

  else
    return cu->stats;
}

// ConnectUser_get_userId
// file connect_user_struct.h line 60
signed int ConnectUser_get_userId(struct anonymous$4 *cu)
{
  if(cu == ((struct anonymous$4 *)NULL))
    return -1;

  else
    return cu->userId;
}

// ConnectUser_get_whatClient
// file connect_user_struct.h line 59
signed int ConnectUser_get_whatClient(struct anonymous$4 *cu)
{
  if(cu == ((struct anonymous$4 *)NULL))
    return -1;

  else
    return cu->whatClient;
}

// ConnectUser_new
// file connect_user_struct.h line 43
struct anonymous$4 * ConnectUser_new()
{
  struct anonymous$4 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$4) /*176ul*/ );
  tmp = (struct anonymous$4 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$4 *)NULL))
    return (struct anonymous$4 *)(void *)0;

  else
  {
    tmp->bufList=BufList_new();
    if(tmp->bufList == ((struct buflist *)NULL))
    {
      ConnectUser_free(&tmp);
      return (struct anonymous$4 *)(void *)0;
    }

    else
    {
      tmp->stats=UserStats_new();
      if(tmp->stats == ((struct anonymous$6 *)NULL))
      {
        ConnectUser_free(&tmp);
        return (struct anonymous$4 *)(void *)0;
      }

      else
        return tmp;
    }
  }
}

// ConnectUser_set_bufList
// file connect_user_struct.c line 215
void ConnectUser_set_bufList(struct anonymous$4 *cu, struct buflist *bufList)
{
  struct buflist *bftmp;
  if(!(cu == ((struct anonymous$4 *)NULL)))
  {
    bftmp=ConnectUser_get_bufList(cu);
    BufList_free(&bftmp);
    cu->bufList = bufList;
  }

}

// ConnectUser_set_connFd
// file connect_user_struct.h line 48
void ConnectUser_set_connFd(struct anonymous$4 *cu, signed int connFd)
{
  if(!(cu == ((struct anonymous$4 *)NULL)))
    cu->connFd = connFd;

}

// ConnectUser_set_connectTime
// file connect_user_struct.h line 51
void ConnectUser_set_connectTime(struct anonymous$4 *cu, signed long int connectTime)
{
  if(!(cu == ((struct anonymous$4 *)NULL)))
    cu->connectTime = connectTime;

}

// ConnectUser_set_nameBuf
// file connect_user_struct.c line 179
void ConnectUser_set_nameBuf(struct anonymous$4 *cu, char *nameBuf)
{
  if(!(cu == ((struct anonymous$4 *)NULL)))
  {
    memset((void *)cu->nameBuf, 0, (unsigned long int)128);
    __builtin_strncpy(cu->nameBuf, nameBuf, (unsigned long int)127);
  }

}

// ConnectUser_set_portBuf
// file connect_user_struct.c line 197
void ConnectUser_set_portBuf(struct anonymous$4 *cu, char *portBuf)
{
  if(!(cu == ((struct anonymous$4 *)NULL)))
  {
    memset((void *)cu->portBuf, 0, (unsigned long int)7);
    __builtin_strncpy(cu->portBuf, portBuf, (unsigned long int)6);
  }

}

// ConnectUser_set_state
// file connect_user_struct.h line 47
void ConnectUser_set_state(struct anonymous$4 *cu, char state)
{
  if(!(cu == ((struct anonymous$4 *)NULL)))
    cu->state = state;

}

// ConnectUser_set_stats
// file connect_user_struct.c line 235
void ConnectUser_set_stats(struct anonymous$4 *cu, struct anonymous$6 *stats)
{
  struct anonymous$6 *ustmp;
  if(!(cu == ((struct anonymous$4 *)NULL)))
  {
    ustmp=ConnectUser_get_stats(cu);
    UserStats_free(&ustmp);
    cu->stats = stats;
  }

}

// ConnectUser_set_userId
// file connect_user_struct.h line 50
void ConnectUser_set_userId(struct anonymous$4 *cu, signed int userId)
{
  if(!(cu == ((struct anonymous$4 *)NULL)))
    cu->userId = userId;

}

// ConnectUser_set_whatClient
// file connect_user_struct.h line 49
void ConnectUser_set_whatClient(struct anonymous$4 *cu, signed int whatClient)
{
  if(!(cu == ((struct anonymous$4 *)NULL)))
    cu->whatClient = whatClient;

}

// HeaderBuffer_free
// file header_buffer_struct.h line 32
void HeaderBuffer_free(struct anonymous$8 **hb)
{
  if(!(hb == ((struct anonymous$8 **)NULL)))
  {
    if(!(*hb == ((struct anonymous$8 *)NULL)))
    {
      free((void *)*hb);
      *hb = (struct anonymous$8 *)(void *)0;
    }

  }

}

// HeaderBuffer_new
// file header_buffer_struct.h line 30
struct anonymous$8 * HeaderBuffer_new()
{
  struct anonymous$8 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$8) /*12ul*/ );
  tmp = (struct anonymous$8 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$8 *)NULL))
    return (struct anonymous$8 *)(void *)0;

  else
    return tmp;
}

// HeaderBuffer_restore
// file header_buffer_struct.h line 36
void HeaderBuffer_restore(struct anonymous$8 *hb, unsigned char *buff)
{
  if(!(hb == ((struct anonymous$8 *)NULL)))
  {
    memcpy((void *)buff, (const void *)hb->tab, (unsigned long int)5);
    hb->readed = 0;
  }

}

// HeaderBuffer_store
// file header_buffer_struct.h line 35
void HeaderBuffer_store(struct anonymous$8 *hb, unsigned char *buff, signed int n)
{
  if(!(hb == ((struct anonymous$8 *)NULL)))
  {
    if(!(hb->readed + n >= 6))
    {
      if(n >= 1)
      {
        memcpy((void *)&hb->tab[(signed long int)hb->readed], (const void *)buff, (unsigned long int)n);
        hb->readed = hb->readed + n;
      }

    }

  }

}

// HeaderBuffer_to_read
// file header_buffer_struct.h line 34
signed int HeaderBuffer_to_read(struct anonymous$8 *hb)
{
  if(hb == ((struct anonymous$8 *)NULL))
    return -1;

  else
    return 5 - hb->readed;
}

// RCTdata_free
// file remove_client_task.h line 43
void RCTdata_free(void **ptr)
{
  struct anonymous$25 **data = (struct anonymous$25 **)ptr;
  if(!(data == ((struct anonymous$25 **)NULL)))
  {
    if(!(*data == ((struct anonymous$25 *)NULL)))
    {
      free((void *)*data);
      *data = (struct anonymous$25 *)(void *)0;
    }

  }

}

// RCTdata_new
// file remove_client_task.h line 40
struct anonymous$25 * RCTdata_new(struct anonymous$2 *config, signed int realm, signed int client, char ra, char reason, struct anonymous$22 *set, struct anonymous$22 *wset)
{
  struct anonymous$25 *tmp;
  if(config == ((struct anonymous$2 *)NULL))
    return (struct anonymous$25 *)(void *)0;

  else
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$25) /*40ul*/ );
    tmp = (struct anonymous$25 *)return_value_calloc$1;
    if(tmp == ((struct anonymous$25 *)NULL))
      return (struct anonymous$25 *)(void *)0;

    else
    {
      tmp->config = config;
      tmp->realm = realm;
      tmp->client = client;
      tmp->ra = ra;
      tmp->reason = reason;
      tmp->set = set;
      tmp->wset = wset;
      return tmp;
    }
  }
}

// RCTfunction
// file remove_client_task.h line 45
void RCTfunction(void *data)
{
  struct anonymous$3 **clientsTable;
  struct anonymous$5 **realmsTable;
  struct anonymous$25 *ptr;
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$1;
  signed int return_value_SslFd_get_fd$2;
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$3;
  signed int return_value_SslFd_get_fd$4;
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$5;
  signed int return_value_SslFd_get_fd$6;
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$7;
  struct ssl_st *return_value_SslFd_get_ssl$8;
  char *return_value_get_realmname$9;
  char *tmp_if_expr$12;
  char *return_value_get_raclientname$10;
  char *return_value_get_clientname$11;
  if(!(data == NULL))
  {
    ptr = (struct anonymous$25 *)data;
    realmsTable=ServerConfiguration_get_realmsTable(ptr->config);
    if(!(ptr->ra == 0))
      clientsTable=ServerRealm_get_raClientsTable(realmsTable[(signed long int)ptr->realm]);

    else
      clientsTable=ServerRealm_get_clientsTable(realmsTable[(signed long int)ptr->realm]);
    switch((signed int)ptr->reason)
    {
      case 0:
      {
        return_value_ConnectClient_get_sslFd$1=ConnectClient_get_sslFd(clientsTable[(signed long int)ptr->client]);
        return_value_SslFd_get_fd$2=SslFd_get_fd(return_value_ConnectClient_get_sslFd$1);
        close(return_value_SslFd_get_fd$2);
        return_value_ConnectClient_get_sslFd$3=ConnectClient_get_sslFd(clientsTable[(signed long int)ptr->client]);
        return_value_SslFd_get_fd$4=SslFd_get_fd(return_value_ConnectClient_get_sslFd$3);
        return_value_ConnectClient_get_sslFd$5=ConnectClient_get_sslFd(clientsTable[(signed long int)ptr->client]);
        return_value_SslFd_get_fd$6=SslFd_get_fd(return_value_ConnectClient_get_sslFd$5);
        ptr->set->__fds_bits[(signed long int)(return_value_SslFd_get_fd$4 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = ptr->set->__fds_bits[(signed long int)(return_value_SslFd_get_fd$4 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_SslFd_get_fd$6 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
        return_value_ConnectClient_get_sslFd$7=ConnectClient_get_sslFd(clientsTable[(signed long int)ptr->client]);
        return_value_SslFd_get_ssl$8=SslFd_get_ssl(return_value_ConnectClient_get_sslFd$7);
        SSL_clear(return_value_SslFd_get_ssl$8);
        ConnectClient_set_state(clientsTable[(signed long int)ptr->client], (char)0);
        ServerRealm_decrease_connectedClients(realmsTable[(signed long int)ptr->realm]);
        return_value_get_realmname$9=get_realmname(ptr->config, ptr->realm);
        if(!(ptr->ra == 0))
        {
          return_value_get_raclientname$10=get_raclientname(realmsTable[(signed long int)ptr->realm], ptr->client);
          tmp_if_expr$12 = return_value_get_raclientname$10;
        }

        else
        {
          return_value_get_clientname$11=get_clientname(realmsTable[(signed long int)ptr->realm], ptr->client);
          tmp_if_expr$12 = return_value_get_clientname$11;
        }
        aflog((char)2, (char)32, "realm[%s]: Client[%s]%s: SSL_accept failed (timeout)", return_value_get_realmname$9, tmp_if_expr$12, ptr->ra != 0 ? " (ra)" : "");
        break;
      }
      case 1:
      {
        char *return_value_get_realmname$13;
        return_value_get_realmname$13=get_realmname(ptr->config, ptr->realm);
        char *return_value_get_clientname$14;
        return_value_get_clientname$14=get_clientname(realmsTable[(signed long int)ptr->realm], ptr->client);
        aflog((char)2, (char)32, "realm[%s]: Client[%s]: too long idle --> DROPPING", return_value_get_realmname$13, return_value_get_clientname$14);
        remove_client(realmsTable[(signed long int)ptr->realm], ptr->client, ptr->set, ptr->wset, (struct anonymous$16 *)(void *)0);
      }
    }
    ConnectClient_set_task(clientsTable[(signed long int)ptr->client], (struct anonymous$13 *)(void *)0);
  }

}

// SSL_readn
// file network.c line 483
signed int SSL_readn(struct ssl_st *fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    n=SSL_read(fd, (void *)(buf + (signed long int)sent), amount - sent);
    if(!(n == -1))
      sent = sent + n;

    if(n == 0)
      return 0;

    if(n == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      if(!(*return_value___errno_location$1 == 11))
        return 0;

    }

  }
  return amount;
}

// SSL_writen
// file network.c line 454
signed int SSL_writen(struct ssl_st *fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    n=SSL_write(fd, (const void *)(buf + (signed long int)sent), amount - sent);
    if(!(n == -1))
      sent = sent + n;

    if(n == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      if(!(*return_value___errno_location$1 == 11))
        return 0;

    }

  }
  return amount;
}

// ServerConfiguration_free
// file server_configuration_struct.c line 54
void ServerConfiguration_free(struct anonymous$2 **sc)
{
  signed int i;
  if(!(sc == ((struct anonymous$2 **)NULL)))
  {
    if(!(*sc == ((struct anonymous$2 *)NULL)))
    {
      if(!((*sc)->certificateFile == ((char *)NULL)))
      {
        free((void *)(*sc)->certificateFile);
        (*sc)->certificateFile = (char *)(void *)0;
      }

      if(!((*sc)->cacertificateFile == ((char *)NULL)))
      {
        free((void *)(*sc)->cacertificateFile);
        (*sc)->cacertificateFile = (char *)(void *)0;
      }

      if(!((*sc)->cacertificatePath == ((char *)NULL)))
      {
        free((void *)(*sc)->cacertificatePath);
        (*sc)->cacertificatePath = (char *)(void *)0;
      }

      if(!((*sc)->sCertificateDepth == ((char *)NULL)))
      {
        free((void *)(*sc)->sCertificateDepth);
        (*sc)->sCertificateDepth = (char *)(void *)0;
      }

      if(!((*sc)->keysFile == ((char *)NULL)))
      {
        free((void *)(*sc)->keysFile);
        (*sc)->keysFile = (char *)(void *)0;
      }

      if(!((*sc)->dateFormat == ((char *)NULL)))
      {
        free((void *)(*sc)->dateFormat);
        (*sc)->dateFormat = (char *)(void *)0;
      }

      if(!((*sc)->realmsTable == ((struct anonymous$5 **)NULL)))
      {
        i = 0;
        for( ; !(i >= (*sc)->realmsNumber); i = i + 1)
          if(!((*sc)->realmsTable[(signed long int)i] == ((struct anonymous$5 *)NULL)))
            ServerRealm_free(&(*sc)->realmsTable[(signed long int)i]);

        free((void *)(*sc)->realmsTable);
        (*sc)->realmsTable = (struct anonymous$5 **)(void *)0;
      }

      free((void *)*sc);
      *sc = (struct anonymous$2 *)(void *)0;
    }

  }

}

// ServerConfiguration_get_cacertificateFile
// file server_configuration_struct.h line 57
char * ServerConfiguration_get_cacertificateFile(struct anonymous$2 *sc)
{
  if(sc == ((struct anonymous$2 *)NULL))
    return (char *)(void *)0;

  else
    return sc->cacertificateFile;
}

// ServerConfiguration_get_cacertificatePath
// file server_configuration_struct.c line 309
char * ServerConfiguration_get_cacertificatePath(struct anonymous$2 *sc)
{
  if(sc == ((struct anonymous$2 *)NULL))
    return (char *)(void *)0;

  else
    return sc->cacertificatePath;
}

// ServerConfiguration_get_certificateDepth
// file server_configuration_struct.c line 329
signed int ServerConfiguration_get_certificateDepth(struct anonymous$2 *sc)
{
  if(sc == ((struct anonymous$2 *)NULL))
    return -1;

  else
    return sc->certificateDepth;
}

// ServerConfiguration_get_certificateFile
// file server_configuration_struct.h line 56
char * ServerConfiguration_get_certificateFile(struct anonymous$2 *sc)
{
  if(sc == ((struct anonymous$2 *)NULL))
    return (char *)(void *)0;

  else
    return sc->certificateFile;
}

// ServerConfiguration_get_dateFormat
// file server_configuration_struct.h line 62
char * ServerConfiguration_get_dateFormat(struct anonymous$2 *sc)
{
  if(sc == ((struct anonymous$2 *)NULL))
    return (char *)(void *)0;

  else
    return sc->dateFormat;
}

// ServerConfiguration_get_keysFile
// file server_configuration_struct.h line 61
char * ServerConfiguration_get_keysFile(struct anonymous$2 *sc)
{
  if(sc == ((struct anonymous$2 *)NULL))
    return (char *)(void *)0;

  else
    return sc->keysFile;
}

// ServerConfiguration_get_realmsNumber
// file server_configuration_struct.h line 63
signed int ServerConfiguration_get_realmsNumber(struct anonymous$2 *sc)
{
  if(sc == ((struct anonymous$2 *)NULL))
    return -1;

  else
    return sc->realmsNumber;
}

// ServerConfiguration_get_realmsTable
// file server_configuration_struct.h line 65
struct anonymous$5 ** ServerConfiguration_get_realmsTable(struct anonymous$2 *sc)
{
  if(sc == ((struct anonymous$2 *)NULL))
    return (struct anonymous$5 **)(void *)0;

  else
    return sc->realmsTable;
}

// ServerConfiguration_get_sCertificateDepth
// file server_configuration_struct.h line 59
char * ServerConfiguration_get_sCertificateDepth(struct anonymous$2 *sc)
{
  if(sc == ((struct anonymous$2 *)NULL))
    return (char *)(void *)0;

  else
    return sc->sCertificateDepth;
}

// ServerConfiguration_get_startTime
// file server_configuration_struct.h line 64
signed long int ServerConfiguration_get_startTime(struct anonymous$2 *sc)
{
  if(sc == ((struct anonymous$2 *)NULL))
    return (signed long int)0;

  else
    return sc->startTime;
}

// ServerConfiguration_new
// file server_configuration_struct.h line 41
struct anonymous$2 * ServerConfiguration_new()
{
  struct anonymous$2 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$2) /*80ul*/ );
  tmp = (struct anonymous$2 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$2 *)NULL))
    return (struct anonymous$2 *)(void *)0;

  else
    return tmp;
}

// ServerConfiguration_set_cacertificateFile
// file server_configuration_struct.h line 46
void ServerConfiguration_set_cacertificateFile(struct anonymous$2 *sc, char *cacertificateFile)
{
  if(!(sc == ((struct anonymous$2 *)NULL)))
    string_cp(&sc->cacertificateFile, cacertificateFile);

}

// ServerConfiguration_set_cacertificatePath
// file server_configuration_struct.c line 144
void ServerConfiguration_set_cacertificatePath(struct anonymous$2 *sc, char *cacertificatePath)
{
  if(!(sc == ((struct anonymous$2 *)NULL)))
    string_cp(&sc->cacertificatePath, cacertificatePath);

}

// ServerConfiguration_set_certificateDepth
// file server_configuration_struct.c line 163
void ServerConfiguration_set_certificateDepth(struct anonymous$2 *sc, signed int certificateDepth)
{
  if(!(sc == ((struct anonymous$2 *)NULL)))
    sc->certificateDepth = certificateDepth;

}

// ServerConfiguration_set_certificateFile
// file server_configuration_struct.h line 45
void ServerConfiguration_set_certificateFile(struct anonymous$2 *sc, char *certificateFile)
{
  if(!(sc == ((struct anonymous$2 *)NULL)))
    string_cp(&sc->certificateFile, certificateFile);

}

// ServerConfiguration_set_dateFormat
// file server_configuration_struct.h line 51
void ServerConfiguration_set_dateFormat(struct anonymous$2 *sc, char *dateFormat)
{
  if(!(sc == ((struct anonymous$2 *)NULL)))
    string_cp(&sc->dateFormat, dateFormat);

}

// ServerConfiguration_set_keysFile
// file server_configuration_struct.h line 50
void ServerConfiguration_set_keysFile(struct anonymous$2 *sc, char *keysFile)
{
  if(!(sc == ((struct anonymous$2 *)NULL)))
    string_cp(&sc->keysFile, keysFile);

}

// ServerConfiguration_set_realmsNumber
// file server_configuration_struct.h line 52
void ServerConfiguration_set_realmsNumber(struct anonymous$2 *sc, signed int realmsNumber)
{
  if(!(sc == ((struct anonymous$2 *)NULL)))
    sc->realmsNumber = realmsNumber;

}

// ServerConfiguration_set_realmsTable
// file server_configuration_struct.h line 54
void ServerConfiguration_set_realmsTable(struct anonymous$2 *sc, struct anonymous$5 **realmsTable)
{
  signed int i;
  if(!(sc == ((struct anonymous$2 *)NULL)))
  {
    if(!(sc->realmsTable == ((struct anonymous$5 **)NULL)))
    {
      i = 0;
      for( ; !(i >= sc->realmsNumber); i = i + 1)
        if(!(sc->realmsTable[(signed long int)i] == ((struct anonymous$5 *)NULL)))
          ServerRealm_free(&sc->realmsTable[(signed long int)i]);

      free((void *)sc->realmsTable);
      sc->realmsTable = (struct anonymous$5 **)(void *)0;
    }

    sc->realmsTable = realmsTable;
  }

}

// ServerConfiguration_set_sCertificateDepth
// file server_configuration_struct.h line 48
void ServerConfiguration_set_sCertificateDepth(struct anonymous$2 *sc, char *sCertificateDepth)
{
  if(!(sc == ((struct anonymous$2 *)NULL)))
    string_cp(&sc->sCertificateDepth, sCertificateDepth);

}

// ServerConfiguration_set_startTime
// file server_configuration_struct.h line 53
void ServerConfiguration_set_startTime(struct anonymous$2 *sc, signed long int startTime)
{
  if(!(sc == ((struct anonymous$2 *)NULL)))
    sc->startTime = startTime;

}

// ServerRealm_decrease_connectedClients
// file server_realm_struct.h line 141
void ServerRealm_decrease_connectedClients(struct anonymous$5 *sr)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_connectedClients$1;
    return_value_ServerRealm_get_connectedClients$1=ServerRealm_get_connectedClients(sr);
    ServerRealm_set_connectedClients(sr, return_value_ServerRealm_get_connectedClients$1 - 1);
  }

}

// ServerRealm_decrease_connectedRaClients
// file server_realm_struct.h line 143
void ServerRealm_decrease_connectedRaClients(struct anonymous$5 *sr)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_connectedRaClients$1;
    return_value_ServerRealm_get_connectedRaClients$1=ServerRealm_get_connectedRaClients(sr);
    ServerRealm_set_connectedRaClients(sr, return_value_ServerRealm_get_connectedRaClients$1 - 1);
  }

}

// ServerRealm_decrease_connectedUsers
// file server_realm_struct.h line 139
void ServerRealm_decrease_connectedUsers(struct anonymous$5 *sr)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_connectedUsers$1;
    return_value_ServerRealm_get_connectedUsers$1=ServerRealm_get_connectedUsers(sr);
    ServerRealm_set_connectedUsers(sr, return_value_ServerRealm_get_connectedUsers$1 - 1);
  }

}

// ServerRealm_free
// file server_realm_struct.c line 58
void ServerRealm_free(struct anonymous$5 **sr)
{
  signed int i;
  if(!(sr == ((struct anonymous$5 **)NULL)))
  {
    if(!(*sr == ((struct anonymous$5 *)NULL)))
    {
      if(!((*sr)->hostName == ((char *)NULL)))
      {
        free((void *)(*sr)->hostName);
        (*sr)->hostName = (char *)(void *)0;
      }

      if(!((*sr)->sUsersLimit == ((char *)NULL)))
      {
        free((void *)(*sr)->sUsersLimit);
        (*sr)->sUsersLimit = (char *)(void *)0;
      }

      if(!((*sr)->sClientsLimit == ((char *)NULL)))
      {
        free((void *)(*sr)->sClientsLimit);
        (*sr)->sClientsLimit = (char *)(void *)0;
      }

      if(!((*sr)->sRaClientsLimit == ((char *)NULL)))
      {
        free((void *)(*sr)->sRaClientsLimit);
        (*sr)->sRaClientsLimit = (char *)(void *)0;
      }

      if(!((*sr)->sUsersPerClient == ((char *)NULL)))
      {
        free((void *)(*sr)->sUsersPerClient);
        (*sr)->sUsersPerClient = (char *)(void *)0;
      }

      if(!((*sr)->sClientMode == ((char *)NULL)))
      {
        free((void *)(*sr)->sClientMode);
        (*sr)->sClientMode = (char *)(void *)0;
      }

      if(!((*sr)->sTimeout == ((char *)NULL)))
      {
        free((void *)(*sr)->sTimeout);
        (*sr)->sTimeout = (char *)(void *)0;
      }

      if(!((*sr)->realmName == ((char *)NULL)))
      {
        free((void *)(*sr)->realmName);
        (*sr)->realmName = (char *)(void *)0;
      }

      if(!((*sr)->clientAddress == ((struct sockaddr *)NULL)))
      {
        free((void *)(*sr)->clientAddress);
        (*sr)->clientAddress = (struct sockaddr *)(void *)0;
      }

      if(!((*sr)->usersTable == ((struct anonymous$4 **)NULL)))
      {
        i = 0;
        for( ; !(i >= (*sr)->usersLimit); i = i + 1)
          if(!((*sr)->usersTable[(signed long int)i] == ((struct anonymous$4 *)NULL)))
            ConnectUser_free(&(*sr)->usersTable[(signed long int)i]);

        free((void *)(*sr)->usersTable);
        (*sr)->usersTable = (struct anonymous$4 **)(void *)0;
      }

      if(!((*sr)->clientsTable == ((struct anonymous$3 **)NULL)))
      {
        i = 0;
        for( ; !(i >= (*sr)->clientsLimit); i = i + 1)
          if(!((*sr)->clientsTable[(signed long int)i] == ((struct anonymous$3 *)NULL)))
            ConnectClient_free(&(*sr)->clientsTable[(signed long int)i]);

        free((void *)(*sr)->clientsTable);
        (*sr)->clientsTable = (struct anonymous$3 **)(void *)0;
      }

      if(!((*sr)->raClientsTable == ((struct anonymous$3 **)NULL)))
      {
        i = 0;
        for( ; !(i >= (*sr)->raClientsLimit); i = i + 1)
          if(!((*sr)->raClientsTable[(signed long int)i] == ((struct anonymous$3 *)NULL)))
            ConnectClient_free(&(*sr)->raClientsTable[(signed long int)i]);

        free((void *)(*sr)->raClientsTable);
        (*sr)->raClientsTable = (struct anonymous$3 **)(void *)0;
      }

      if(!((*sr)->usersClientsTable == ((struct anonymous$7 **)NULL)))
      {
        i = 0;
        for( ; !(i >= (*sr)->userClientPairs); i = i + 1)
          if(!((*sr)->usersClientsTable[(signed long int)i] == ((struct anonymous$7 *)NULL)))
            UsrCli_free(&(*sr)->usersClientsTable[(signed long int)i]);

        free((void *)(*sr)->usersClientsTable);
        (*sr)->usersClientsTable = (struct anonymous$7 **)(void *)0;
      }

      free((void *)*sr);
      *sr = (struct anonymous$5 *)(void *)0;
    }

  }

}

// ServerRealm_get_addressLength
// file server_realm_struct.h line 131
unsigned int ServerRealm_get_addressLength(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (unsigned int)0;

  else
    return sr->addressLength;
}

// ServerRealm_get_auditOn
// file server_realm_struct.h line 130
char ServerRealm_get_auditOn(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (char)0;

  else
    return sr->auditOn;
}

// ServerRealm_get_basePortOn
// file server_realm_struct.h line 129
char ServerRealm_get_basePortOn(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (char)0;

  else
    return sr->basePortOn;
}

// ServerRealm_get_clientAddress
// file server_realm_struct.h line 132
struct sockaddr * ServerRealm_get_clientAddress(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (struct sockaddr *)(void *)0;

  else
    return sr->clientAddress;
}

// ServerRealm_get_clientMode
// file server_realm_struct.h line 122
signed int ServerRealm_get_clientMode(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return 0;

  else
    return sr->clientMode;
}

// ServerRealm_get_clientsCounter
// file server_realm_struct.h line 124
signed int ServerRealm_get_clientsCounter(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return -1;

  else
    return sr->clientsCounter;
}

// ServerRealm_get_clientsLimit
// file server_realm_struct.h line 116
signed int ServerRealm_get_clientsLimit(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return -1;

  else
    return sr->clientsLimit;
}

// ServerRealm_get_clientsTable
// file server_realm_struct.h line 134
struct anonymous$3 ** ServerRealm_get_clientsTable(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (struct anonymous$3 **)(void *)0;

  else
    return sr->clientsTable;
}

// ServerRealm_get_connectedClients
// file server_realm_struct.h line 115
signed int ServerRealm_get_connectedClients(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return -1;

  else
    return sr->connectedClients;
}

// ServerRealm_get_connectedRaClients
// file server_realm_struct.h line 117
signed int ServerRealm_get_connectedRaClients(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return -1;

  else
    return sr->connectedRaClients;
}

// ServerRealm_get_connectedUsers
// file server_realm_struct.h line 113
signed int ServerRealm_get_connectedUsers(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return -1;

  else
    return sr->connectedUsers;
}

// ServerRealm_get_dnsLookupsOn
// file server_realm_struct.h line 128
char ServerRealm_get_dnsLookupsOn(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (char)0;

  else
    return sr->dnsLookupsOn;
}

// ServerRealm_get_hostName
// file server_realm_struct.h line 103
char * ServerRealm_get_hostName(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->hostName;
}

// ServerRealm_get_maxIdle
// file server_realm_struct.h line 121
signed int ServerRealm_get_maxIdle(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return 0;

  else
    return sr->maxIdle;
}

// ServerRealm_get_password
// file server_realm_struct.h line 112
unsigned char * ServerRealm_get_password(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (unsigned char *)(void *)0;

  else
    return sr->password;
}

// ServerRealm_get_raClientsLimit
// file server_realm_struct.h line 118
signed int ServerRealm_get_raClientsLimit(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return -1;

  else
    return sr->raClientsLimit;
}

// ServerRealm_get_raClientsTable
// file server_realm_struct.h line 135
struct anonymous$3 ** ServerRealm_get_raClientsTable(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (struct anonymous$3 **)(void *)0;

  else
    return sr->raClientsTable;
}

// ServerRealm_get_realmName
// file server_realm_struct.h line 111
char * ServerRealm_get_realmName(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->realmName;
}

// ServerRealm_get_realmType
// file server_realm_struct.h line 126
char ServerRealm_get_realmType(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (char)0;

  else
    return sr->realmType;
}

// ServerRealm_get_sClientMode
// file server_realm_struct.h line 108
char * ServerRealm_get_sClientMode(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->sClientMode;
}

// ServerRealm_get_sClientsLimit
// file server_realm_struct.h line 105
char * ServerRealm_get_sClientsLimit(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->sClientsLimit;
}

// ServerRealm_get_sMaxIdle
// file server_realm_struct.h line 110
char * ServerRealm_get_sMaxIdle(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->sMaxIdle;
}

// ServerRealm_get_sRaClientsLimit
// file server_realm_struct.h line 106
char * ServerRealm_get_sRaClientsLimit(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->sRaClientsLimit;
}

// ServerRealm_get_sTimeout
// file server_realm_struct.h line 109
char * ServerRealm_get_sTimeout(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->sTimeout;
}

// ServerRealm_get_sUsersLimit
// file server_realm_struct.h line 104
char * ServerRealm_get_sUsersLimit(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->sUsersLimit;
}

// ServerRealm_get_sUsersPerClient
// file server_realm_struct.h line 107
char * ServerRealm_get_sUsersPerClient(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
    return sr->sUsersPerClient;
}

// ServerRealm_get_timeout
// file server_realm_struct.h line 120
signed int ServerRealm_get_timeout(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return 0;

  else
    return sr->timeout;
}

// ServerRealm_get_tunnelType
// file server_realm_struct.h line 127
char ServerRealm_get_tunnelType(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (char)0;

  else
    return sr->tunnelType;
}

// ServerRealm_get_userClientPairs
// file server_realm_struct.h line 123
signed int ServerRealm_get_userClientPairs(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return 0;

  else
    return sr->userClientPairs;
}

// ServerRealm_get_usersClientsTable
// file server_realm_struct.h line 136
struct anonymous$7 ** ServerRealm_get_usersClientsTable(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (struct anonymous$7 **)(void *)0;

  else
    return sr->usersClientsTable;
}

// ServerRealm_get_usersCounter
// file server_realm_struct.h line 125
signed int ServerRealm_get_usersCounter(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return -1;

  else
    return sr->usersCounter;
}

// ServerRealm_get_usersLimit
// file server_realm_struct.h line 114
signed int ServerRealm_get_usersLimit(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return -1;

  else
    return sr->usersLimit;
}

// ServerRealm_get_usersPerClient
// file server_realm_struct.h line 119
signed int ServerRealm_get_usersPerClient(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return -1;

  else
    return sr->usersPerClient;
}

// ServerRealm_get_usersTable
// file server_realm_struct.h line 133
struct anonymous$4 ** ServerRealm_get_usersTable(struct anonymous$5 *sr)
{
  if(sr == ((struct anonymous$5 *)NULL))
    return (struct anonymous$4 **)(void *)0;

  else
    return sr->usersTable;
}

// ServerRealm_increase_clientsCounter
// file server_realm_struct.h line 145
void ServerRealm_increase_clientsCounter(struct anonymous$5 *sr)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_clientsCounter$1;
    return_value_ServerRealm_get_clientsCounter$1=ServerRealm_get_clientsCounter(sr);
    ServerRealm_set_clientsCounter(sr, return_value_ServerRealm_get_clientsCounter$1 + 1);
  }

}

// ServerRealm_increase_connectedClients
// file server_realm_struct.h line 140
void ServerRealm_increase_connectedClients(struct anonymous$5 *sr)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_connectedClients$1;
    return_value_ServerRealm_get_connectedClients$1=ServerRealm_get_connectedClients(sr);
    ServerRealm_set_connectedClients(sr, return_value_ServerRealm_get_connectedClients$1 + 1);
  }

}

// ServerRealm_increase_connectedRaClients
// file server_realm_struct.h line 142
void ServerRealm_increase_connectedRaClients(struct anonymous$5 *sr)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_connectedRaClients$1;
    return_value_ServerRealm_get_connectedRaClients$1=ServerRealm_get_connectedRaClients(sr);
    ServerRealm_set_connectedRaClients(sr, return_value_ServerRealm_get_connectedRaClients$1 + 1);
  }

}

// ServerRealm_increase_connectedUsers
// file server_realm_struct.h line 138
void ServerRealm_increase_connectedUsers(struct anonymous$5 *sr)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_connectedUsers$1;
    return_value_ServerRealm_get_connectedUsers$1=ServerRealm_get_connectedUsers(sr);
    ServerRealm_set_connectedUsers(sr, return_value_ServerRealm_get_connectedUsers$1 + 1);
  }

}

// ServerRealm_increase_usersCounter
// file server_realm_struct.h line 144
void ServerRealm_increase_usersCounter(struct anonymous$5 *sr)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
  {
    signed int return_value_ServerRealm_get_usersCounter$1;
    return_value_ServerRealm_get_usersCounter$1=ServerRealm_get_usersCounter(sr);
    ServerRealm_set_usersCounter(sr, return_value_ServerRealm_get_usersCounter$1 + 1);
  }

}

// ServerRealm_new
// file server_realm_struct.h line 64
struct anonymous$5 * ServerRealm_new()
{
  struct anonymous$5 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$5) /*184ul*/ );
  tmp = (struct anonymous$5 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$5 *)NULL))
    return (struct anonymous$5 *)(void *)0;

  else
  {
    tmp->password[(signed long int)0] = (unsigned char)1;
    tmp->password[(signed long int)1] = (unsigned char)2;
    tmp->password[(signed long int)2] = (unsigned char)3;
    tmp->password[(signed long int)3] = (unsigned char)4;
    return tmp;
  }
}

// ServerRealm_set_addressLength
// file server_realm_struct.h line 96
void ServerRealm_set_addressLength(struct anonymous$5 *sr, unsigned int addressLength)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->addressLength = addressLength;

}

// ServerRealm_set_auditOn
// file server_realm_struct.h line 95
void ServerRealm_set_auditOn(struct anonymous$5 *sr, char auditOn)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->auditOn = auditOn;

}

// ServerRealm_set_basePortOn
// file server_realm_struct.h line 94
void ServerRealm_set_basePortOn(struct anonymous$5 *sr, char basePortOn)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->basePortOn = basePortOn;

}

// ServerRealm_set_clientAddress
// file server_realm_struct.h line 97
void ServerRealm_set_clientAddress(struct anonymous$5 *sr, struct sockaddr *clientAddress)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
  {
    if(!(sr->clientAddress == ((struct sockaddr *)NULL)))
    {
      free((void *)sr->clientAddress);
      sr->clientAddress = (struct sockaddr *)(void *)0;
    }

    sr->clientAddress = clientAddress;
  }

}

// ServerRealm_set_clientMode
// file server_realm_struct.h line 87
void ServerRealm_set_clientMode(struct anonymous$5 *sr, signed int clientMode)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->clientMode = clientMode;

}

// ServerRealm_set_clientsCounter
// file server_realm_struct.c line 510
void ServerRealm_set_clientsCounter(struct anonymous$5 *sr, signed int clientsCounter)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->clientsCounter = clientsCounter;

}

// ServerRealm_set_clientsLimit
// file server_realm_struct.h line 81
void ServerRealm_set_clientsLimit(struct anonymous$5 *sr, signed int clientsLimit)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->clientsLimit = clientsLimit;

}

// ServerRealm_set_clientsTable
// file server_realm_struct.h line 99
void ServerRealm_set_clientsTable(struct anonymous$5 *sr, struct anonymous$3 **clientsTable)
{
  signed int i;
  if(!(sr == ((struct anonymous$5 *)NULL)))
  {
    if(!(sr->clientsTable == ((struct anonymous$3 **)NULL)))
    {
      i = 0;
      for( ; !(i >= sr->clientsLimit); i = i + 1)
        if(!(sr->clientsTable[(signed long int)i] == ((struct anonymous$3 *)NULL)))
          ConnectClient_free(&sr->clientsTable[(signed long int)i]);

      free((void *)sr->clientsTable);
      sr->clientsTable = (struct anonymous$3 **)(void *)0;
    }

    sr->clientsTable = clientsTable;
  }

}

// ServerRealm_set_connectedClients
// file server_realm_struct.h line 80
void ServerRealm_set_connectedClients(struct anonymous$5 *sr, signed int connectedClients)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->connectedClients = connectedClients;

}

// ServerRealm_set_connectedRaClients
// file server_realm_struct.h line 82
void ServerRealm_set_connectedRaClients(struct anonymous$5 *sr, signed int connectedRaClients)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->connectedRaClients = connectedRaClients;

}

// ServerRealm_set_connectedUsers
// file server_realm_struct.h line 78
void ServerRealm_set_connectedUsers(struct anonymous$5 *sr, signed int connectedUsers)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->connectedUsers = connectedUsers;

}

// ServerRealm_set_dnsLookupsOn
// file server_realm_struct.h line 93
void ServerRealm_set_dnsLookupsOn(struct anonymous$5 *sr, char dnsLookupsOn)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->dnsLookupsOn = dnsLookupsOn;

}

// ServerRealm_set_hostName
// file server_realm_struct.h line 68
void ServerRealm_set_hostName(struct anonymous$5 *sr, char *hostName)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    string_cp(&sr->hostName, hostName);

}

// ServerRealm_set_maxIdle
// file server_realm_struct.h line 86
void ServerRealm_set_maxIdle(struct anonymous$5 *sr, signed int maxIdle)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->maxIdle = maxIdle;

}

// ServerRealm_set_password
// file server_realm_struct.h line 77
void ServerRealm_set_password(struct anonymous$5 *sr, unsigned char *password)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    memcpy((void *)sr->password, (const void *)password, (unsigned long int)4);

}

// ServerRealm_set_raClientsLimit
// file server_realm_struct.h line 83
void ServerRealm_set_raClientsLimit(struct anonymous$5 *sr, signed int raClientsLimit)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->raClientsLimit = raClientsLimit;

}

// ServerRealm_set_raClientsTable
// file server_realm_struct.h line 100
void ServerRealm_set_raClientsTable(struct anonymous$5 *sr, struct anonymous$3 **raClientsTable)
{
  signed int i;
  if(!(sr == ((struct anonymous$5 *)NULL)))
  {
    if(!(sr->raClientsTable == ((struct anonymous$3 **)NULL)))
    {
      i = 0;
      for( ; !(i >= sr->raClientsLimit); i = i + 1)
        if(!(sr->raClientsTable[(signed long int)i] == ((struct anonymous$3 *)NULL)))
          ConnectClient_free(&sr->raClientsTable[(signed long int)i]);

      free((void *)sr->raClientsTable);
      sr->raClientsTable = (struct anonymous$3 **)(void *)0;
    }

    sr->raClientsTable = raClientsTable;
  }

}

// ServerRealm_set_realmName
// file server_realm_struct.h line 76
void ServerRealm_set_realmName(struct anonymous$5 *sr, char *realmName)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    string_cp(&sr->realmName, realmName);

}

// ServerRealm_set_realmType
// file server_realm_struct.h line 91
void ServerRealm_set_realmType(struct anonymous$5 *sr, char realmType)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->realmType = realmType;

}

// ServerRealm_set_sClientMode
// file server_realm_struct.h line 73
void ServerRealm_set_sClientMode(struct anonymous$5 *sr, char *sClientMode)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    string_cp(&sr->sClientMode, sClientMode);

}

// ServerRealm_set_sClientsLimit
// file server_realm_struct.h line 70
void ServerRealm_set_sClientsLimit(struct anonymous$5 *sr, char *sClientsLimit)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    string_cp(&sr->sClientsLimit, sClientsLimit);

}

// ServerRealm_set_sMaxIdle
// file server_realm_struct.h line 75
void ServerRealm_set_sMaxIdle(struct anonymous$5 *sr, char *sMaxIdle)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    string_cp(&sr->sMaxIdle, sMaxIdle);

}

// ServerRealm_set_sRaClientsLimit
// file server_realm_struct.h line 71
void ServerRealm_set_sRaClientsLimit(struct anonymous$5 *sr, char *sRaClientsLimit)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    string_cp(&sr->sRaClientsLimit, sRaClientsLimit);

}

// ServerRealm_set_sTimeout
// file server_realm_struct.h line 74
void ServerRealm_set_sTimeout(struct anonymous$5 *sr, char *sTimeout)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    string_cp(&sr->sTimeout, sTimeout);

}

// ServerRealm_set_sUsersLimit
// file server_realm_struct.h line 69
void ServerRealm_set_sUsersLimit(struct anonymous$5 *sr, char *sUsersLimit)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    string_cp(&sr->sUsersLimit, sUsersLimit);

}

// ServerRealm_set_sUsersPerClient
// file server_realm_struct.h line 72
void ServerRealm_set_sUsersPerClient(struct anonymous$5 *sr, char *sUsersPerClient)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    string_cp(&sr->sUsersPerClient, sUsersPerClient);

}

// ServerRealm_set_timeout
// file server_realm_struct.h line 85
void ServerRealm_set_timeout(struct anonymous$5 *sr, signed int timeout)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->timeout = timeout;

}

// ServerRealm_set_tunnelType
// file server_realm_struct.h line 92
void ServerRealm_set_tunnelType(struct anonymous$5 *sr, char tunnelType)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->tunnelType = tunnelType;

}

// ServerRealm_set_userClientPairs
// file server_realm_struct.h line 88
void ServerRealm_set_userClientPairs(struct anonymous$5 *sr, signed int userClientPairs)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->userClientPairs = userClientPairs;

}

// ServerRealm_set_usersClientsTable
// file server_realm_struct.h line 101
void ServerRealm_set_usersClientsTable(struct anonymous$5 *sr, struct anonymous$7 **usersClientsTable)
{
  signed int i;
  if(!(sr == ((struct anonymous$5 *)NULL)))
  {
    if(!(sr->usersClientsTable == ((struct anonymous$7 **)NULL)))
    {
      i = 0;
      for( ; !(i >= sr->userClientPairs); i = i + 1)
        if(!(sr->usersClientsTable[(signed long int)i] == ((struct anonymous$7 *)NULL)))
          UsrCli_free(&sr->usersClientsTable[(signed long int)i]);

      free((void *)sr->usersClientsTable);
      sr->usersClientsTable = (struct anonymous$7 **)(void *)0;
    }

    sr->usersClientsTable = usersClientsTable;
  }

}

// ServerRealm_set_usersCounter
// file server_realm_struct.c line 527
void ServerRealm_set_usersCounter(struct anonymous$5 *sr, signed int usersCounter)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->usersCounter = usersCounter;

}

// ServerRealm_set_usersLimit
// file server_realm_struct.h line 79
void ServerRealm_set_usersLimit(struct anonymous$5 *sr, signed int usersLimit)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->usersLimit = usersLimit;

}

// ServerRealm_set_usersPerClient
// file server_realm_struct.h line 84
void ServerRealm_set_usersPerClient(struct anonymous$5 *sr, signed int usersPerClient)
{
  if(!(sr == ((struct anonymous$5 *)NULL)))
    sr->usersPerClient = usersPerClient;

}

// ServerRealm_set_usersTable
// file server_realm_struct.h line 98
void ServerRealm_set_usersTable(struct anonymous$5 *sr, struct anonymous$4 **usersTable)
{
  signed int i;
  if(!(sr == ((struct anonymous$5 *)NULL)))
  {
    if(!(sr->usersTable == ((struct anonymous$4 **)NULL)))
    {
      i = 0;
      for( ; !(i >= sr->usersLimit); i = i + 1)
        if(!(sr->usersTable[(signed long int)i] == ((struct anonymous$4 *)NULL)))
          ConnectUser_free(&sr->usersTable[(signed long int)i]);

      free((void *)sr->usersTable);
      sr->usersTable = (struct anonymous$4 **)(void *)0;
    }

    sr->usersTable = usersTable;
  }

}

// SslFd_free
// file ssl_fd_struct.c line 54
void SslFd_free(struct anonymous$1 **sf)
{
  if(!(sf == ((struct anonymous$1 **)NULL)))
  {
    if(!(*sf == ((struct anonymous$1 *)NULL)))
    {
      if(!((*sf)->ssl == ((struct ssl_st *)NULL)))
      {
        SSL_free((*sf)->ssl);
        (*sf)->ssl = (struct ssl_st *)(void *)0;
      }

      free((void *)*sf);
      *sf = (struct anonymous$1 *)(void *)0;
    }

  }

}

// SslFd_get_fd
// file ssl_fd_struct.h line 41
signed int SslFd_get_fd(struct anonymous$1 *sf)
{
  if(sf == ((struct anonymous$1 *)NULL))
    return -1;

  else
    return sf->fd;
}

// SslFd_get_message
// file ssl_fd_struct.h line 45
signed int SslFd_get_message(char type, struct anonymous$1 *sf, unsigned char *buf, signed int amount)
{
  signed int length;
  unsigned long int elen;
  if(sf == ((struct anonymous$1 *)NULL) || buf == ((unsigned char *)NULL))
    return -1;

  else
  {
    aflog((char)16, (char)2, "get_message: ssl:%s zlib:%s length:%d", ((signed int)type & 4) != 0 ? "yes" : "no", ((signed int)type & 8) != 0 ? "yes" : "no", amount);
    if(!(amount >= 0))
    {
      if(!((4 & (signed int)type) == 0))
      {
        signed int return_value_SSL_read$1;
        return_value_SSL_read$1=SSL_read(sf->ssl, (void *)buf, -amount);
        return return_value_SSL_read$1;
      }

      else
      {
        signed long int return_value_read$2;
        return_value_read$2=read(sf->fd, (void *)buf, (unsigned long int)-amount);
        return (signed int)return_value_read$2;
      }
    }

    if(!((8 & (signed int)type) == 0))
    {
      static unsigned char bufor[9000l];
      if(!((4 & (signed int)type) == 0))
        length=SSL_readn(sf->ssl, bufor, amount & 0xBFFF);

      else
        length=readn(sf->fd, bufor, amount & 0xBFFF);
      if(!(length >= 1))
        return length;

      elen = (unsigned long int)8096;
      if(!((0x4000 & amount) == 0))
        uncompress(buf, &elen, bufor, (unsigned long int)length);

      else
      {
        memcpy((void *)buf, (const void *)bufor, (unsigned long int)length);
        elen = (unsigned long int)length;
      }
      return (signed int)elen;
    }

    else
      if(!((4 & (signed int)type) == 0))
      {
        signed int return_value_SSL_readn$3;
        return_value_SSL_readn$3=SSL_readn(sf->ssl, buf, amount);
        return return_value_SSL_readn$3;
      }

      else
      {
        signed int return_value_readn$4;
        return_value_readn$4=readn(sf->fd, buf, amount);
        return return_value_readn$4;
      }
  }
}

// SslFd_get_ssl
// file ssl_fd_struct.h line 42
struct ssl_st * SslFd_get_ssl(struct anonymous$1 *sf)
{
  if(sf == ((struct anonymous$1 *)NULL))
    return (struct ssl_st *)(void *)0;

  else
    return sf->ssl;
}

// SslFd_new
// file ssl_fd_struct.h line 33
struct anonymous$1 * SslFd_new()
{
  struct anonymous$1 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$1) /*16ul*/ );
  tmp = (struct anonymous$1 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$1 *)NULL))
    return (struct anonymous$1 *)(void *)0;

  else
    return tmp;
}

// SslFd_send_message
// file ssl_fd_struct.h line 44
signed int SslFd_send_message(char type, struct anonymous$1 *sf, unsigned char *buf, signed int amount)
{
  unsigned long int clen;
  signed int length;
  if(sf == ((struct anonymous$1 *)NULL) || buf == ((unsigned char *)NULL))
    return -1;

  else
  {
    aflog((char)16, (char)2, "send_message: ssl:%s zlib:%s length:%d", ((signed int)type & 4) != 0 ? "yes" : "no", ((signed int)type & 8) != 0 ? "yes" : "no", amount);
    clen = (unsigned long int)8995;
    length = amount - 5;
    if(!((8 & (signed int)type) == 0))
    {
      static unsigned char buffer[9000l];
      memcpy((void *)buffer, (const void *)buf, (unsigned long int)5);
      if(amount >= 6)
      {
        compress(&buffer[(signed long int)5], &clen, &buf[(signed long int)5], (unsigned long int)length);
        if(!(clen >= (unsigned long int)length))
        {
          length = (signed int)clen;
          length = length | 0x4000;
          buffer[(signed long int)3] = (unsigned char)(length >> 8);
          buffer[(signed long int)4] = (unsigned char)length;
          addtocg((signed int)((unsigned long int)(amount - 5) - clen));
        }

      }

      if(!((4 & (signed int)type) == 0))
      {
        if(!((0x4000 & length) == 0))
        {
          signed int return_value_SSL_writen$1;
          return_value_SSL_writen$1=SSL_writen(sf->ssl, buffer, (signed int)(clen + (unsigned long int)5));
          return return_value_SSL_writen$1;
        }

        else
        {
          signed int return_value_SSL_writen$2;
          return_value_SSL_writen$2=SSL_writen(sf->ssl, buf, amount);
          return return_value_SSL_writen$2;
        }
      }

      else
        if(!((0x4000 & length) == 0))
        {
          signed int return_value_writen$3;
          return_value_writen$3=writen(sf->fd, buffer, (signed int)(clen + (unsigned long int)5));
          return return_value_writen$3;
        }

        else
        {
          signed int return_value_writen$4;
          return_value_writen$4=writen(sf->fd, buf, amount);
          return return_value_writen$4;
        }
    }

    else
      if(!((4 & (signed int)type) == 0))
      {
        signed int return_value_SSL_writen$5;
        return_value_SSL_writen$5=SSL_writen(sf->ssl, buf, amount);
        return return_value_SSL_writen$5;
      }

      else
      {
        signed int return_value_writen$6;
        return_value_writen$6=writen(sf->fd, buf, amount);
        return return_value_writen$6;
      }
  }
}

// SslFd_set_fd
// file ssl_fd_struct.h line 37
void SslFd_set_fd(struct anonymous$1 *sf, signed int fd)
{
  if(!(sf == ((struct anonymous$1 *)NULL)))
    sf->fd = fd;

}

// SslFd_set_ssl
// file ssl_fd_struct.h line 38
void SslFd_set_ssl(struct anonymous$1 *sf, struct ssl_st *ssl)
{
  SslFd_set_ssl_general(sf, ssl, 1);
}

// SslFd_set_ssl_general
// file ssl_fd_struct.c line 98
void SslFd_set_ssl_general(struct anonymous$1 *sf, struct ssl_st *ssl, signed int free)
{
  if(!(sf == ((struct anonymous$1 *)NULL)))
  {
    if(!(free == 0))
    {
      if(!(sf->ssl == ((struct ssl_st *)NULL)))
        SSL_free(sf->ssl);

    }

    sf->ssl = ssl;
  }

}

// SslFd_set_ssl_nf
// file ssl_fd_struct.h line 39
void SslFd_set_ssl_nf(struct anonymous$1 *sf, struct ssl_st *ssl)
{
  SslFd_set_ssl_general(sf, ssl, 0);
}

// SslFd_swap_content
// file ssl_fd_struct.h line 46
void SslFd_swap_content(struct anonymous$1 *sf1, struct anonymous$1 *sf2)
{
  signed int tmpfd;
  struct ssl_st *tmpssl;
  tmpfd=SslFd_get_fd(sf1);
  tmpssl=SslFd_get_ssl(sf2);
  signed int return_value_SslFd_get_fd$1;
  return_value_SslFd_get_fd$1=SslFd_get_fd(sf2);
  SslFd_set_fd(sf1, return_value_SslFd_get_fd$1);
  struct ssl_st *return_value_SslFd_get_ssl$2;
  return_value_SslFd_get_ssl$2=SslFd_get_ssl(sf2);
  SslFd_set_ssl(sf1, return_value_SslFd_get_ssl$2);
  SslFd_set_fd(sf2, tmpfd);
  SslFd_set_ssl(sf2, tmpssl);
}

// TaskListNode_free
// file task_list_node_struct.c line 60
void TaskListNode_free(struct tlnode **node)
{
  if(!(node == ((struct tlnode **)NULL)))
  {
    if(!(*node == ((struct tlnode *)NULL)))
    {
      free((void *)*node);
      *node = (struct tlnode *)(void *)0;
    }

  }

}

// TaskListNode_get_task
// file task_list_node_struct.c line 117
struct anonymous$13 * TaskListNode_get_task(struct tlnode *node)
{
  if(node == ((struct tlnode *)NULL))
    return (struct anonymous$13 *)(void *)0;

  else
    return node->task;
}

// TaskListNode_new
// file task_list_node_struct.c line 37
struct tlnode * TaskListNode_new(struct anonymous$13 *task)
{
  struct tlnode *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct tlnode) /*24ul*/ );
  tmp = (struct tlnode *)return_value_calloc$1;
  if(task == ((struct anonymous$13 *)NULL))
    return (struct tlnode *)(void *)0;

  else
    if(tmp == ((struct tlnode *)NULL))
      return (struct tlnode *)(void *)0;

    else
    {
      tmp->task = task;
      return tmp;
    }
}

// TaskListNode_set_next
// file task_list_node_struct.c line 83
void TaskListNode_set_next(struct tlnode *node, struct tlnode *next)
{
  if(!(node == ((struct tlnode *)NULL)))
    node->next = next;

}

// TaskListNode_set_previous
// file task_list_node_struct.c line 100
void TaskListNode_set_previous(struct tlnode *node, struct tlnode *previous)
{
  if(!(node == ((struct tlnode *)NULL)))
    node->previous = previous;

}

// TaskScheduler_addTask
// file task_scheduler_struct.h line 41
signed int TaskScheduler_addTask(struct anonymous$16 *scheduler, struct anonymous$13 *task)
{
  struct tlnode *tmp;
  if(scheduler == ((struct anonymous$16 *)NULL))
    return 1;

  else
    if(task == ((struct anonymous$13 *)NULL))
      return 1;

    else
    {
      tmp=TaskListNode_new(task);
      if(tmp == ((struct tlnode *)NULL))
        return 1;

      else
      {
        if(!(scheduler->head == ((struct tlnode *)NULL)))
        {
          TaskListNode_set_next(tmp, scheduler->head);
          TaskListNode_set_previous(scheduler->head, tmp);
        }

        scheduler->head = tmp;
        scheduler->numberOfTasks = scheduler->numberOfTasks + 1;
        if(!(scheduler->actualTask == ((struct tlnode *)NULL)))
        {
          struct timeval *return_value_TaskScheduler_get_actualTimer$1;
          return_value_TaskScheduler_get_actualTimer$1=TaskScheduler_get_actualTimer(scheduler);
          struct timeval *return_value_Task_get_timer$2;
          return_value_Task_get_timer$2=Task_get_timer(task);
          signed int return_value_timeval_compare$3;
          return_value_timeval_compare$3=timeval_compare(return_value_TaskScheduler_get_actualTimer$1, return_value_Task_get_timer$2);
          if(return_value_timeval_compare$3 >= 1)
            scheduler->actualTask = tmp;

        }

        else
          scheduler->actualTask = tmp;
        return 0;
      }
    }
}

// TaskScheduler_free
// file task_scheduler_struct.c line 54
void TaskScheduler_free(struct anonymous$16 **scheduler)
{
  if(!(scheduler == ((struct anonymous$16 **)NULL)))
  {
    if(!(*scheduler == ((struct anonymous$16 *)NULL)))
    {
      while(!((*scheduler)->head == ((struct tlnode *)NULL)))
      {
        struct anonymous$13 *return_value_TaskListNode_get_task$1;
        return_value_TaskListNode_get_task$1=TaskListNode_get_task((*scheduler)->head);
        TaskScheduler_removeTask(*scheduler, return_value_TaskListNode_get_task$1);
      }
      free((void *)*scheduler);
      *scheduler = (struct anonymous$16 *)(void *)0;
    }

  }

}

// TaskScheduler_get_actualTimer
// file task_scheduler_struct.h line 38
struct timeval * TaskScheduler_get_actualTimer(struct anonymous$16 *scheduler)
{
  if(scheduler == ((struct anonymous$16 *)NULL))
    return (struct timeval *)(void *)0;

  else
  {
    struct anonymous$13 *return_value_TaskListNode_get_task$1;
    return_value_TaskListNode_get_task$1=TaskListNode_get_task(scheduler->actualTask);
    struct timeval *return_value_Task_get_timer$2;
    return_value_Task_get_timer$2=Task_get_timer(return_value_TaskListNode_get_task$1);
    return return_value_Task_get_timer$2;
  }
}

// TaskScheduler_hasMoreTasks
// file task_scheduler_struct.h line 40
signed int TaskScheduler_hasMoreTasks(struct anonymous$16 *scheduler)
{
  if(scheduler == ((struct anonymous$16 *)NULL))
    return 0;

  else
    return scheduler->numberOfTasks;
}

// TaskScheduler_new
// file task_scheduler_struct.h line 34
struct anonymous$16 * TaskScheduler_new()
{
  struct anonymous$16 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$16) /*40ul*/ );
  tmp = (struct anonymous$16 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$16 *)NULL))
    return (struct anonymous$16 *)(void *)0;

  else
    return tmp;
}

// TaskScheduler_removeTask
// file task_scheduler_struct.h line 42
signed int TaskScheduler_removeTask(struct anonymous$16 *scheduler, struct anonymous$13 *task)
{
  struct tlnode *iterator;
  struct anonymous$13 *tmp;
  if(scheduler == ((struct anonymous$16 *)NULL))
    return 1;

  else
    if(task == ((struct anonymous$13 *)NULL))
      return 1;

    else
    {
      iterator = scheduler->head;
      for( ; !(iterator == ((struct tlnode *)NULL)); iterator = iterator->next)
      {
        tmp=TaskListNode_get_task(iterator);
        if(tmp == task)
        {
          if(!(iterator->previous == ((struct tlnode *)NULL)))
            TaskListNode_set_next(iterator->previous, iterator->next);

          if(!(iterator->next == ((struct tlnode *)NULL)))
            TaskListNode_set_previous(iterator->next, iterator->previous);

          if(iterator == scheduler->head)
            scheduler->head = iterator->next;

          if(iterator == scheduler->actualTask)
            scheduler->actualTask=find_tasknode_with_minimal_timer(scheduler);

          scheduler->numberOfTasks = scheduler->numberOfTasks - 1;
          TaskListNode_free(&iterator);
          return 0;
        }

      }
      return 1;
    }
}

// TaskScheduler_startWatching
// file task_scheduler_struct.h line 43
signed int TaskScheduler_startWatching(struct anonymous$16 *scheduler)
{
  struct timeval *tmp;
  if(scheduler == ((struct anonymous$16 *)NULL))
    return 1;

  else
  {
    tmp=TaskScheduler_get_actualTimer(scheduler);
    if(tmp == ((struct timeval *)NULL))
      return 1;

    else
    {
      scheduler->delta = *tmp;
      return 0;
    }
  }
}

// TaskScheduler_stopWatching
// file task_scheduler_struct.h line 44
signed int TaskScheduler_stopWatching(struct anonymous$16 *scheduler)
{
  struct tlnode *iterator;
  struct tlnode *actualTask;
  struct anonymous$13 *backup;
  struct timeval *tmp;
  signed int result;
  if(scheduler == ((struct anonymous$16 *)NULL))
    return 1;

  else
  {
    tmp=TaskScheduler_get_actualTimer(scheduler);
    if(tmp == ((struct timeval *)NULL))
      return 1;

    else
    {
      signed int return_value_timeval_subtract$1;
      return_value_timeval_subtract$1=timeval_subtract(&scheduler->delta, tmp);
      if(!(return_value_timeval_subtract$1 == 0))
        return 1;

      else
      {
        actualTask = scheduler->actualTask;
        iterator = scheduler->head;
        while(!(iterator == ((struct tlnode *)NULL)))
        {
          if(!(iterator == actualTask))
          {
            struct anonymous$13 *return_value_TaskListNode_get_task$2;
            return_value_TaskListNode_get_task$2=TaskListNode_get_task(iterator);
            struct timeval *return_value_Task_get_timer$3;
            return_value_Task_get_timer$3=Task_get_timer(return_value_TaskListNode_get_task$2);
            result=timeval_subtract(return_value_Task_get_timer$3, &scheduler->delta);
          }

          struct anonymous$13 *return_value_TaskListNode_get_task$5;
          return_value_TaskListNode_get_task$5=TaskListNode_get_task(iterator);
          struct timeval *return_value_Task_get_timer$6;
          return_value_Task_get_timer$6=Task_get_timer(return_value_TaskListNode_get_task$5);
          signed int return_value_timeval_lq_zero$7;
          return_value_timeval_lq_zero$7=timeval_lq_zero(return_value_Task_get_timer$6);
          if(!(return_value_timeval_lq_zero$7 == 0))
          {
            struct anonymous$13 *return_value_TaskListNode_get_task$4;
            return_value_TaskListNode_get_task$4=TaskListNode_get_task(iterator);
            Task_exec(return_value_TaskListNode_get_task$4);
            backup=TaskListNode_get_task(iterator);
            iterator = iterator->next;
            TaskScheduler_removeTask(scheduler, backup);
            continue;
          }

          iterator = iterator->next;
        }
        TaskScheduler_update(scheduler);
        return 0;
      }
    }
  }
}

// TaskScheduler_update
// file task_scheduler_struct.h line 45
signed int TaskScheduler_update(struct anonymous$16 *scheduler)
{
  if(scheduler == ((struct anonymous$16 *)NULL))
    return 1;

  else
  {
    scheduler->actualTask=find_tasknode_with_minimal_timer(scheduler);
    return 0;
  }
}

// Task_exec
// file task_struct.c line 113
void Task_exec(struct anonymous$13 *task)
{
  if(!(task == ((struct anonymous$13 *)NULL)))
  {
    if(!(task->function == ((void (*)(void *))NULL)))
      task->function(task->data);

  }

}

// Task_free
// file task_struct.h line 34
void Task_free(struct anonymous$13 **task)
{
  if(!(task == ((struct anonymous$13 **)NULL)))
  {
    if(!(*task == ((struct anonymous$13 *)NULL)))
    {
      if(!((*task)->clean == ((void (*)(void **))NULL)))
      {
        if(!((*task)->data == NULL))
          (*task)->clean(&(*task)->data);

      }

      free((void *)*task);
      *task = (struct anonymous$13 *)(void *)0;
    }

  }

}

// Task_get_timer
// file task_struct.c line 97
struct timeval * Task_get_timer(struct anonymous$13 *task)
{
  if(task == ((struct anonymous$13 *)NULL))
    return (struct timeval *)(void *)0;

  else
    return task->timerp;
}

// Task_new
// file task_struct.h line 32
struct anonymous$13 * Task_new(struct timeval *timerp, void (*function)(void *), void *data, void (*clean)(void **))
{
  struct anonymous$13 *tmp;
  if(timerp == ((struct timeval *)NULL))
    return (struct anonymous$13 *)(void *)0;

  else
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$13) /*32ul*/ );
    tmp = (struct anonymous$13 *)return_value_calloc$1;
    if(tmp == ((struct anonymous$13 *)NULL))
      return (struct anonymous$13 *)(void *)0;

    else
    {
      tmp->timerp = timerp;
      tmp->function = function;
      tmp->data = data;
      tmp->clean = clean;
      return tmp;
    }
  }
}

// UserStats_add_download
// file user_stats_struct.h line 52
void UserStats_add_download(struct anonymous$6 *us, signed int bytes)
{
  signed long int now;
  if(!(us == ((struct anonymous$6 *)NULL)))
  {
    time(&now);
    switch(now - us->lastDSQChange)
    {
      case (signed long int)0:
      {
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = us->downloadSpeedQueue[(signed long int)us->downloadSQP] + bytes;
        break;
      }
      case (signed long int)2:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = bytes;
        break;
      }
      default:
      {
        us->downloadSpeedQueue[(signed long int)2] = 0;
        us->downloadSpeedQueue[(signed long int)1] = us->downloadSpeedQueue[(signed long int)2];
        us->downloadSpeedQueue[(signed long int)0] = us->downloadSpeedQueue[(signed long int)1];
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = bytes;
      }
    }
    us->totalDownloadedBytes = us->totalDownloadedBytes + bytes;
    us->lastActivity = now;
    us->lastDSQChange = now;
  }

}

// UserStats_add_upload
// file user_stats_struct.h line 53
void UserStats_add_upload(struct anonymous$6 *us, signed int bytes)
{
  signed long int now;
  if(!(us == ((struct anonymous$6 *)NULL)))
  {
    time(&now);
    switch(now - us->lastUSQChange)
    {
      case (signed long int)0:
      {
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = us->uploadSpeedQueue[(signed long int)us->uploadSQP] + bytes;
        break;
      }
      case (signed long int)2:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = bytes;
        break;
      }
      default:
      {
        us->uploadSpeedQueue[(signed long int)2] = 0;
        us->uploadSpeedQueue[(signed long int)1] = us->uploadSpeedQueue[(signed long int)2];
        us->uploadSpeedQueue[(signed long int)0] = us->uploadSpeedQueue[(signed long int)1];
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = bytes;
      }
    }
    us->totalUploadedBytes = us->totalUploadedBytes + bytes;
    us->lastActivity = now;
    us->lastUSQChange = now;
  }

}

// UserStats_clear
// file user_stats_struct.h line 57
void UserStats_clear(struct anonymous$6 *us)
{
  if(!(us == ((struct anonymous$6 *)NULL)))
  {
    us->lastActivity = (signed long int)0;
    us->lastUSQChange = (signed long int)0;
    us->lastDSQChange = (signed long int)0;
    us->totalDownloadedBytes = 0;
    us->totalUploadedBytes = 0;
    us->uploadSQP = 0;
    us->uploadSpeedQueue[(signed long int)2] = 0;
    us->uploadSpeedQueue[(signed long int)1] = us->uploadSpeedQueue[(signed long int)2];
    us->uploadSpeedQueue[(signed long int)0] = us->uploadSpeedQueue[(signed long int)1];
    us->downloadSQP = 0;
    us->downloadSpeedQueue[(signed long int)2] = 0;
    us->downloadSpeedQueue[(signed long int)1] = us->downloadSpeedQueue[(signed long int)2];
    us->downloadSpeedQueue[(signed long int)0] = us->downloadSpeedQueue[(signed long int)1];
  }

}

// UserStats_free
// file user_stats_struct.c line 53
void UserStats_free(struct anonymous$6 **us)
{
  if(!(us == ((struct anonymous$6 **)NULL)))
  {
    if(!(*us == ((struct anonymous$6 *)NULL)))
    {
      free((void *)*us);
      *us = (struct anonymous$6 *)(void *)0;
    }

  }

}

// UserStats_get_downloadSpeed
// file user_stats_struct.h line 54
double UserStats_get_downloadSpeed(struct anonymous$6 *us)
{
  signed long int now;
  if(us == ((struct anonymous$6 *)NULL))
    return 0.0;

  else
  {
    time(&now);
    switch(now - us->lastDSQChange)
    {
      case (signed long int)0:
        break;
      case (signed long int)2:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->downloadSQP = (us->downloadSQP + 1) % 3;
        us->downloadSpeedQueue[(signed long int)us->downloadSQP] = 0;
        break;
      }
      default:
      {
        us->downloadSpeedQueue[(signed long int)2] = 0;
        us->downloadSpeedQueue[(signed long int)1] = us->downloadSpeedQueue[(signed long int)2];
        us->downloadSpeedQueue[(signed long int)0] = us->downloadSpeedQueue[(signed long int)1];
      }
    }
    us->lastDSQChange = now;
    return (double)(us->downloadSpeedQueue[(signed long int)0] + us->downloadSpeedQueue[(signed long int)1] + us->downloadSpeedQueue[(signed long int)2]) / 3.0;
  }
}

// UserStats_get_lastActivity
// file user_stats_struct.h line 48
signed long int UserStats_get_lastActivity(struct anonymous$6 *us)
{
  if(us == ((struct anonymous$6 *)NULL))
    return (signed long int)0;

  else
    return us->lastActivity;
}

// UserStats_get_totalDownloadedBytes
// file user_stats_struct.h line 49
signed int UserStats_get_totalDownloadedBytes(struct anonymous$6 *us)
{
  if(us == ((struct anonymous$6 *)NULL))
    return 0;

  else
    return us->totalDownloadedBytes;
}

// UserStats_get_totalUploadedBytes
// file user_stats_struct.h line 50
signed int UserStats_get_totalUploadedBytes(struct anonymous$6 *us)
{
  if(us == ((struct anonymous$6 *)NULL))
    return 0;

  else
    return us->totalUploadedBytes;
}

// UserStats_get_uploadSpeed
// file user_stats_struct.h line 55
double UserStats_get_uploadSpeed(struct anonymous$6 *us)
{
  signed long int now;
  if(us == ((struct anonymous$6 *)NULL))
    return 0.0;

  else
  {
    time(&now);
    switch(now - us->lastUSQChange)
    {
      case (signed long int)0:
        break;
      case (signed long int)2:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = 0;
      }
      case (signed long int)1:
      {
        us->uploadSQP = (us->uploadSQP + 1) % 3;
        us->uploadSpeedQueue[(signed long int)us->uploadSQP] = 0;
        break;
      }
      default:
      {
        us->uploadSpeedQueue[(signed long int)2] = 0;
        us->uploadSpeedQueue[(signed long int)1] = us->uploadSpeedQueue[(signed long int)2];
        us->uploadSpeedQueue[(signed long int)0] = us->uploadSpeedQueue[(signed long int)1];
      }
    }
    us->lastUSQChange = now;
    return (double)(us->uploadSpeedQueue[(signed long int)0] + us->uploadSpeedQueue[(signed long int)1] + us->uploadSpeedQueue[(signed long int)2]) / 3.0;
  }
}

// UserStats_new
// file user_stats_struct.c line 36
struct anonymous$6 * UserStats_new()
{
  struct anonymous$6 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$6) /*64ul*/ );
  tmp = (struct anonymous$6 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$6 *)NULL))
    return (struct anonymous$6 *)(void *)0;

  else
    return tmp;
}

// UserStats_set_lastActivity
// file user_stats_struct.h line 44
void UserStats_set_lastActivity(struct anonymous$6 *us, signed long int lastActivity)
{
  if(!(us == ((struct anonymous$6 *)NULL)))
    us->lastActivity = lastActivity;

}

// UserStats_set_totalDownloadedBytes
// file user_stats_struct.c line 92
void UserStats_set_totalDownloadedBytes(struct anonymous$6 *us, signed int totalDownloadedBytes)
{
  if(!(us == ((struct anonymous$6 *)NULL)))
    us->totalDownloadedBytes = totalDownloadedBytes;

}

// UserStats_set_totalUploadedBytes
// file user_stats_struct.c line 109
void UserStats_set_totalUploadedBytes(struct anonymous$6 *us, signed int totalUploadedBytes)
{
  if(!(us == ((struct anonymous$6 *)NULL)))
    us->totalUploadedBytes = totalUploadedBytes;

}

// UsrCli_free
// file usr_cli_struct.c line 54
void UsrCli_free(struct anonymous$7 **uc)
{
  if(!(uc == ((struct anonymous$7 **)NULL)))
  {
    if(!(*uc == ((struct anonymous$7 *)NULL)))
    {
      if(!((*uc)->listenPortName == ((char *)NULL)))
      {
        free((void *)(*uc)->listenPortName);
        (*uc)->listenPortName = (char *)(void *)0;
      }

      if(!((*uc)->managePortName == ((char *)NULL)))
      {
        free((void *)(*uc)->managePortName);
        (*uc)->managePortName = (char *)(void *)0;
      }

      free((void *)*uc);
      *uc = (struct anonymous$7 *)(void *)0;
    }

  }

}

// UsrCli_get_listenFd
// file usr_cli_struct.h line 48
signed int UsrCli_get_listenFd(struct anonymous$7 *uc)
{
  if(uc == ((struct anonymous$7 *)NULL))
    return -1;

  else
    return uc->listenFd;
}

// UsrCli_get_listenHostName
// file usr_cli_struct.h line 50
char * UsrCli_get_listenHostName(struct anonymous$7 *uc)
{
  if(uc == ((struct anonymous$7 *)NULL))
    return (char *)(void *)0;

  else
    return uc->listenHostName;
}

// UsrCli_get_listenPortName
// file usr_cli_struct.h line 46
char * UsrCli_get_listenPortName(struct anonymous$7 *uc)
{
  if(uc == ((struct anonymous$7 *)NULL))
    return (char *)(void *)0;

  else
    return uc->listenPortName;
}

// UsrCli_get_manageFd
// file usr_cli_struct.h line 49
signed int UsrCli_get_manageFd(struct anonymous$7 *uc)
{
  if(uc == ((struct anonymous$7 *)NULL))
    return -1;

  else
    return uc->manageFd;
}

// UsrCli_get_manageHostName
// file usr_cli_struct.h line 51
char * UsrCli_get_manageHostName(struct anonymous$7 *uc)
{
  if(uc == ((struct anonymous$7 *)NULL))
    return (char *)(void *)0;

  else
    return uc->manageHostName;
}

// UsrCli_get_managePortName
// file usr_cli_struct.h line 47
char * UsrCli_get_managePortName(struct anonymous$7 *uc)
{
  if(uc == ((struct anonymous$7 *)NULL))
    return (char *)(void *)0;

  else
    return uc->managePortName;
}

// UsrCli_get_number
// file usr_cli_struct.h line 52
signed int UsrCli_get_number(struct anonymous$7 *uc)
{
  if(uc == ((struct anonymous$7 *)NULL))
    return -1;

  else
    return uc->number;
}

// UsrCli_new
// file usr_cli_struct.h line 36
struct anonymous$7 * UsrCli_new()
{
  struct anonymous$7 *tmp;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$7) /*48ul*/ );
  tmp = (struct anonymous$7 *)return_value_calloc$1;
  if(tmp == ((struct anonymous$7 *)NULL))
    return (struct anonymous$7 *)(void *)0;

  else
    return tmp;
}

// UsrCli_set_listenFd
// file usr_cli_struct.h line 42
void UsrCli_set_listenFd(struct anonymous$7 *uc, signed int listenFd)
{
  if(!(uc == ((struct anonymous$7 *)NULL)))
    uc->listenFd = listenFd;

}

// UsrCli_set_listenPortName
// file usr_cli_struct.h line 40
void UsrCli_set_listenPortName(struct anonymous$7 *uc, char *listenPortName)
{
  char *tmp;
  if(!(uc == ((struct anonymous$7 *)NULL)))
  {
    tmp=rindex(listenPortName, 58);
    if(!(tmp == ((char *)NULL)))
    {
      *tmp = (char)0;
      tmp = tmp + 1l;
      string_cp(&uc->listenHostName, listenPortName);
      string_cp(&uc->listenPortName, tmp);
    }

    else
      string_cp(&uc->listenPortName, listenPortName);
  }

}

// UsrCli_set_manageFd
// file usr_cli_struct.h line 43
void UsrCli_set_manageFd(struct anonymous$7 *uc, signed int manageFd)
{
  if(!(uc == ((struct anonymous$7 *)NULL)))
    uc->manageFd = manageFd;

}

// UsrCli_set_managePortName
// file usr_cli_struct.h line 41
void UsrCli_set_managePortName(struct anonymous$7 *uc, char *managePortName)
{
  char *tmp;
  if(!(uc == ((struct anonymous$7 *)NULL)))
  {
    tmp=rindex(managePortName, 58);
    if(!(tmp == ((char *)NULL)))
    {
      *tmp = (char)0;
      tmp = tmp + 1l;
      string_cp(&uc->manageHostName, managePortName);
      string_cp(&uc->managePortName, tmp);
    }

    else
      string_cp(&uc->managePortName, managePortName);
  }

}

// UsrCli_set_number
// file usr_cli_struct.h line 44
void UsrCli_set_number(struct anonymous$7 *uc, signed int number)
{
  if(!(uc == ((struct anonymous$7 *)NULL)))
    uc->number = number;

}

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32$1;
  return_value___builtin_bswap32$1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32$1;
}

// __bswap_32$link1
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32$link1(unsigned int __bsx$link1)
{
  signed long int return_value___builtin_bswap32$1$link1;
  return_value___builtin_bswap32$1$link1=__builtin_bswap32((signed long int)__bsx$link1);
  return (unsigned int)return_value___builtin_bswap32$1$link1;
}

// add_to_message
// file server_remoteadmin.c line 188
static void add_to_message(unsigned char *buff, const char *format, ...)
{
  void **ap;
  signed int n;
  if(newmessage == 0)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen((char *)&buff[(signed long int)5]);
    n = (signed int)return_value_strlen$1;
  }

  else
    n = 0;
  newmessage = (char)0;
  ap = (void **)&format;
  vsprintf((char *)&buff[(signed long int)(5 + n)], format, ap);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen((char *)&buff[(signed long int)5]);
  n = (signed int)return_value_strlen$2;
  sprintf((char *)&buff[(signed long int)(5 + n)], "\n");
  ap = ((void **)NULL);
}

// add_uptime_to_message
// file server_remoteadmin.c line 221
static void add_uptime_to_message(unsigned char *buff, char *info, signed long int period)
{
  signed int hours;
  signed int minutes;
  signed int seconds;
  hours = (signed int)(period / (signed long int)3600);
  minutes = (signed int)((period / (signed long int)60) % (signed long int)60);
  seconds = (signed int)(period % (signed long int)60);
  if(!(hours == 0))
    add_to_message(buff, "%s: %d:%02d:%02d", info, hours, minutes, seconds);

  else
    add_to_message(buff, "%s: %d:%02d", info, minutes, seconds);
}

// addlogtarget
// file logging.h line 69
void addlogtarget(char *cmdline)
{
  struct llnode *newnode;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct llnode) /*32ul*/ );
  newnode = (struct llnode *)return_value_calloc$1;
  newnode->cmdline = cmdline;
  newnode->next = head;
  head = newnode;
}

// addtocg
// file stats.c line 61
void addtocg(signed int amount)
{
  compressgained = compressgained + (signed long int)amount;
}

// aflog
// file logging.h line 73
void aflog(char type, char importance, const char *form, ...)
{
  struct llnode *ptr;
  void **ap;
  if(!(((signed int)importance & (signed int)verlev) == 0))
  {
    if(!((signed int)format[0l] == 0))
    {
      char *return_value_datum$1;
      return_value_datum$1=datum();
      printf("[%s] ", return_value_datum$1);
    }

    ap = (void **)&form;
    vfprintf(stdout, form, ap);
    ap = ((void **)NULL);
    printf("\n");
  }

  ptr = head;
  for( ; !(ptr == ((struct llnode *)NULL)); ptr = ptr->next)
    if(!(((signed int)ptr->msgtype & (signed int)type) == 0))
    {
      if(!(((signed int)ptr->importance & (signed int)importance) == 0))
      {
        if(!((signed int)format[0l] == 0))
        {
          char *return_value_datum$2;
          return_value_datum$2=datum();
          fprintf(ptr->logfd, "[%s] ", return_value_datum$2);
        }

        ap = (void **)&form;
        vfprintf(ptr->logfd, form, ap);
        ap = ((void **)NULL);
        fprintf(ptr->logfd, "\n");
        fflush(ptr->logfd);
      }

    }

}

// afserver_connect
// file http_proxy_server.c line 54
signed int afserver_connect(signed int *sockfd, signed int afserverfd, struct sockaddr *cliaddr, unsigned int *addrlenp, char type)
{
  signed int sockets[2l];
  signed int return_value_socketpair$1;
  return_value_socketpair$1=socketpair(1, 1, 0, sockets);
  if(!(return_value_socketpair$1 == 0))
    return 1;

  else
  {
    signed long int return_value_write$2;
    return_value_write$2=write(afserverfd, (const void *)&sockets[(signed long int)0], (unsigned long int)4);
    if(!(return_value_write$2 == 4l))
      return 2;

    else
    {
      signed long int return_value_write$3;
      return_value_write$3=write(afserverfd, (const void *)&type, (unsigned long int)1);
      if(!(return_value_write$3 == 1l))
        return 3;

      else
      {
        signed long int return_value_write$4;
        return_value_write$4=write(afserverfd, (const void *)addrlenp, (unsigned long int)4);
        if(!(return_value_write$4 == 4l))
          return 4;

        else
        {
          signed long int return_value_write$5;
          return_value_write$5=write(afserverfd, (const void *)cliaddr, (unsigned long int)*addrlenp);
          if(!(return_value_write$5 == (signed long int)*addrlenp))
            return 5;

          else
          {
            *sockfd = sockets[(signed long int)1];
            return 0;
          }
        }
      }
    }
  }
}

// broadcast_condition
// file thread_management.h line 31
void broadcast_condition(void)
{
  pthread_cond_broadcast(&maincond);
}

// callback
// file first_run.c line 63
static void callback(signed int i, signed int j, void *k)
{
  if(k == NULL)
  {
    printf("%d", i);
    fflush(stdout);
  }

}

// check_long
// file server_check.h line 26
signed int check_long(char *text, signed long int *number)
{
  char *tmp;
  *number=strtol(text, &tmp, 10);
  _Bool tmp_if_expr$1;
  if(*number == 0x7fffffffffffffffL)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = *number == -0x7fffffffffffffffL - 1L ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    return 1;

  else
  {
    if(!((signed int)*text == 0))
      tmp_if_expr$2 = (signed int)*tmp == 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      return 0;

    else
      return 2;
  }
}

// check_value
// file server_check.h line 24
signed int check_value(char *what, char *info)
{
  signed long int tmp;
  signed int return_value_check_value_liberal$1;
  return_value_check_value_liberal$1=check_value_liberal(what, info);
  tmp = (signed long int)return_value_check_value_liberal$1;
  if(!(tmp >= 1l))
  {
    aflog((char)4, (char)1, "%s: %d\n", info, tmp);
    exit(1);
  }

  return (signed int)tmp;
}

// check_value_liberal
// file server_check.h line 25
signed int check_value_liberal(char *what, char *info)
{
  char *znak;
  signed long int tmp;
  tmp=strtol(what, &znak, 10);
  if(tmp >= 2147483647l)
  {
    aflog((char)4, (char)1, "%s: %s\n", info, what);
    exit(1);
  }

  _Bool tmp_if_expr$1;
  if((signed int)*what == 0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)*znak != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
  {
    aflog((char)4, (char)1, "%s: %s\n", info, what);
    exit(1);
  }

  return (signed int)tmp;
}

// checklogtarget
// file logging.c line 175
signed int checklogtarget(struct llnode *target)
{
  char *ptr;
  char desc[100l];
  char type = (char)0;
  char tab[100l];
  signed int tmpfd;
  signed int state;
  signed int i;
  _Bool tmp_if_expr$1;
  if(target == ((struct llnode *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = target->cmdline == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  signed int tmp_statement_expression$4;
  signed int tmp_statement_expression$2;
  if(tmp_if_expr$1)
    return 1;

  else
  {
    state = 0;
    memset((void *)tab, 0, (unsigned long int)100);
    i = 0;
    ptr = target->cmdline;
    for( ; !((signed int)*ptr == 0); ptr = ptr + 1l)
      switch(state)
      {
        case 0:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp$5;
            return_value___builtin_strcmp$5=__builtin_strcmp(tab, "file");
            tmp_statement_expression$4 = return_value___builtin_strcmp$5;
            if(tmp_statement_expression$4 == 0)
              type = (char)1;

            else
            {
              unsigned long int checklogtarget$$1$$2$$1$$1$$1$$3$$__s1_len;
              unsigned long int checklogtarget$$1$$2$$1$$1$$1$$3$$__s2_len;
              signed int return_value___builtin_strcmp$3;
              return_value___builtin_strcmp$3=__builtin_strcmp(tab, "sock");
              tmp_statement_expression$2 = return_value___builtin_strcmp$3;
              if(tmp_statement_expression$2 == 0)
                type = (char)2;

              else
                return 2;
            }
            state = 1;
            memset((void *)tab, 0, (unsigned long int)100);
            memset((void *)desc, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 2;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
          break;
        }
        case 1:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            switch((signed int)type)
            {
              case 1:
              {
                target->logfd=fopen(tab, "a");
                if(target->logfd == ((struct _IO_FILE *)NULL))
                  return 4;

                state = 3;
                break;
              }
              case 2:
              {
                __builtin_strncpy(desc, tab, (unsigned long int)99);
                state = 2;
                break;
              }
              default:
                return 2;
            }
            memset((void *)tab, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 3;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
          break;
        }
        case 2:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            signed int return_value_ip_connect$6;
            return_value_ip_connect$6=ip_connect(&tmpfd, desc, tab, (const char)1, (const char *)(void *)0, (const char *)(void *)0);
            if(!(return_value_ip_connect$6 == 0))
              return 5;

            target->logfd=fdopen(tmpfd, "a");
            if(target->logfd == ((struct _IO_FILE *)NULL))
              return 4;

            state = 3;
            memset((void *)tab, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 3;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
          break;
        }
        case 3:
        {
          if((signed int)*ptr == 44)
          {
            tab[(signed long int)i] = (char)0;
            signed int return_value_checkmsgti$7;
            return_value_checkmsgti$7=checkmsgti(target, tab);
            if(!(return_value_checkmsgti$7 == 0))
              return 6;

            memset((void *)tab, 0, (unsigned long int)100);
            i = 0;
            break;
          }

          if(i == 98)
            return 6;

          tab[(signed long int)i] = *ptr;
          i = i + 1;
        }
      }
    if(!(i == 0))
    {
      if(state == 3)
      {
        tab[(signed long int)i] = (char)0;
        signed int return_value_checkmsgti$8;
        return_value_checkmsgti$8=checkmsgti(target, tab);
        if(!(return_value_checkmsgti$8 == 0))
          return 6;

        goto __CPROVER_DUMP_L32;
      }

      return 1;
    }

    else
    {

    __CPROVER_DUMP_L32:
      ;
      return 0;
    }
  }
}

// checkmsgti
// file logging.c line 119
signed int checkmsgti(struct llnode *target, char *tab)
{
  signed int tmp_statement_expression$25;
  unsigned long int checkmsgti$$1$$1$$__s1_len;
  unsigned long int checkmsgti$$1$$1$$__s2_len;
  signed int return_value___builtin_strcmp$26;
  return_value___builtin_strcmp$26=__builtin_strcmp(tab, "LOG_T_ALL");
  tmp_statement_expression$25 = return_value___builtin_strcmp$26;
  signed int tmp_statement_expression$23;
  signed int tmp_statement_expression$21;
  signed int tmp_statement_expression$19;
  signed int tmp_statement_expression$17;
  signed int tmp_statement_expression$15;
  signed int tmp_statement_expression$13;
  signed int tmp_statement_expression$11;
  signed int tmp_statement_expression$9;
  signed int tmp_statement_expression$7;
  signed int tmp_statement_expression$5;
  signed int tmp_statement_expression$3;
  signed int tmp_statement_expression$1;
  if(tmp_statement_expression$25 == 0)
    target->msgtype = target->msgtype | (char)(1 | 2 | 4 | 8 | 16);

  else
  {
    unsigned long int checkmsgti$$1$$3$$__s1_len;
    unsigned long int checkmsgti$$1$$3$$__s2_len;
    signed int return_value___builtin_strcmp$24;
    return_value___builtin_strcmp$24=__builtin_strcmp(tab, "LOG_T_USER");
    tmp_statement_expression$23 = return_value___builtin_strcmp$24;
    if(tmp_statement_expression$23 == 0)
      target->msgtype = target->msgtype | (char)1;

    else
    {
      unsigned long int checkmsgti$$1$$5$$__s1_len;
      unsigned long int checkmsgti$$1$$5$$__s2_len;
      signed int return_value___builtin_strcmp$22;
      return_value___builtin_strcmp$22=__builtin_strcmp(tab, "LOG_T_CLIENT");
      tmp_statement_expression$21 = return_value___builtin_strcmp$22;
      if(tmp_statement_expression$21 == 0)
        target->msgtype = target->msgtype | (char)2;

      else
      {
        unsigned long int checkmsgti$$1$$7$$__s1_len;
        unsigned long int checkmsgti$$1$$7$$__s2_len;
        signed int return_value___builtin_strcmp$20;
        return_value___builtin_strcmp$20=__builtin_strcmp(tab, "LOG_T_INIT");
        tmp_statement_expression$19 = return_value___builtin_strcmp$20;
        if(tmp_statement_expression$19 == 0)
          target->msgtype = target->msgtype | (char)4;

        else
        {
          unsigned long int checkmsgti$$1$$9$$__s1_len;
          unsigned long int checkmsgti$$1$$9$$__s2_len;
          signed int return_value___builtin_strcmp$18;
          return_value___builtin_strcmp$18=__builtin_strcmp(tab, "LOG_T_MANAGE");
          tmp_statement_expression$17 = return_value___builtin_strcmp$18;
          if(tmp_statement_expression$17 == 0)
            target->msgtype = target->msgtype | (char)8;

          else
          {
            unsigned long int checkmsgti$$1$$11$$__s1_len;
            unsigned long int checkmsgti$$1$$11$$__s2_len;
            signed int return_value___builtin_strcmp$16;
            return_value___builtin_strcmp$16=__builtin_strcmp(tab, "LOG_T_MAIN");
            tmp_statement_expression$15 = return_value___builtin_strcmp$16;
            if(tmp_statement_expression$15 == 0)
              target->msgtype = target->msgtype | (char)16;

            else
            {
              unsigned long int __s1_len;
              unsigned long int __s2_len;
              signed int return_value___builtin_strcmp$14;
              return_value___builtin_strcmp$14=__builtin_strcmp(tab, "LOG_I_ALL");
              tmp_statement_expression$13 = return_value___builtin_strcmp$14;
              if(tmp_statement_expression$13 == 0)
                target->importance = target->importance | (char)(1 | 2 | 4 | 8 | 16 | 32 | 64);

              else
              {
                unsigned long int checkmsgti$$1$$15$$__s1_len;
                unsigned long int checkmsgti$$1$$15$$__s2_len;
                signed int return_value___builtin_strcmp$12;
                return_value___builtin_strcmp$12=__builtin_strcmp(tab, "LOG_I_CRIT");
                tmp_statement_expression$11 = return_value___builtin_strcmp$12;
                if(tmp_statement_expression$11 == 0)
                  target->importance = target->importance | (char)1;

                else
                {
                  unsigned long int checkmsgti$$1$$17$$__s1_len;
                  unsigned long int checkmsgti$$1$$17$$__s2_len;
                  signed int return_value___builtin_strcmp$10;
                  return_value___builtin_strcmp$10=__builtin_strcmp(tab, "LOG_I_DEBUG");
                  tmp_statement_expression$9 = return_value___builtin_strcmp$10;
                  if(tmp_statement_expression$9 == 0)
                    target->importance = target->importance | (char)2;

                  else
                  {
                    unsigned long int checkmsgti$$1$$19$$__s1_len;
                    unsigned long int checkmsgti$$1$$19$$__s2_len;
                    signed int return_value___builtin_strcmp$8;
                    return_value___builtin_strcmp$8=__builtin_strcmp(tab, "LOG_I_INFO");
                    tmp_statement_expression$7 = return_value___builtin_strcmp$8;
                    if(tmp_statement_expression$7 == 0)
                      target->importance = target->importance | (char)8;

                    else
                    {
                      unsigned long int checkmsgti$$1$$21$$__s1_len;
                      unsigned long int checkmsgti$$1$$21$$__s2_len;
                      signed int return_value___builtin_strcmp$6;
                      return_value___builtin_strcmp$6=__builtin_strcmp(tab, "LOG_I_NOTICE");
                      tmp_statement_expression$5 = return_value___builtin_strcmp$6;
                      if(tmp_statement_expression$5 == 0)
                        target->importance = target->importance | (char)16;

                      else
                      {
                        unsigned long int checkmsgti$$1$$23$$__s1_len;
                        unsigned long int checkmsgti$$1$$23$$__s2_len;
                        signed int return_value___builtin_strcmp$4;
                        return_value___builtin_strcmp$4=__builtin_strcmp(tab, "LOG_I_WARNING");
                        tmp_statement_expression$3 = return_value___builtin_strcmp$4;
                        if(tmp_statement_expression$3 == 0)
                          target->importance = target->importance | (char)32;

                        else
                        {
                          unsigned long int checkmsgti$$1$$25$$__s1_len;
                          unsigned long int checkmsgti$$1$$25$$__s2_len;
                          signed int return_value___builtin_strcmp$2;
                          return_value___builtin_strcmp$2=__builtin_strcmp(tab, "LOG_I_ERR");
                          tmp_statement_expression$1 = return_value___builtin_strcmp$2;
                          if(tmp_statement_expression$1 == 0)
                            target->importance = target->importance | (char)64;

                          else
                            return 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

// clear_fd
// file http_proxy_functions.c line 261
void clear_fd(signed int *fd, struct anonymous$22 *set)
{
  set->__fds_bits[(signed long int)(*fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = set->__fds_bits[(signed long int)(*fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << *fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  close_fd(fd);
}

// clear_sslFd
// file http_proxy_functions.c line 362
void clear_sslFd(struct anonymous$1 *sf, struct anonymous$22 *set)
{
  clear_fd(&sf->fd, set);
  struct ssl_st *return_value_SslFd_get_ssl$2;
  return_value_SslFd_get_ssl$2=SslFd_get_ssl(sf);
  if(!(return_value_SslFd_get_ssl$2 == ((struct ssl_st *)NULL)))
  {
    struct ssl_st *return_value_SslFd_get_ssl$1;
    return_value_SslFd_get_ssl$1=SslFd_get_ssl(sf);
    SSL_clear(return_value_SslFd_get_ssl$1);
  }

}

// client_long_usage
// file usage.c line 148
void client_long_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf(" Basic options:\n\n");
  printf("  -n, --servername    - where the second part of the active\n");
  printf("                        port forwarder is running (required)\n");
  printf("  -m, --manageport    - manage port number - server must be\n");
  printf("                        listening on it (default: 50126)\n");
  printf("  -d, --hostname      - the name of this host/remote host - the final\n");
  printf("                        destination of the packets (default: the name\n");
  printf("                        returned by hostname function)\n");
  printf("  -p, --portnum       - the port we are forwarding connection to (required)\n");
  printf("  --localname         - local machine name for connection with afserver\n");
  printf("                        (used to bind socket to different interfaces)\n");
  printf("  --localport         - local port name for connection with afserver\n");
  printf("                        (used to bind socket to different addressees)\n");
  printf("  --localdesname      - local machine name for connections with destination\n");
  printf("                        application (used to bind socket to different interfaces)\n");
  printf("  -V, --version       - display version number\n");
  printf("  -h, --help          - prints this help\n\n");
  printf(" Authorization:\n\n");
  printf("  -i, --id            - sends the id string to afserver\n");
  printf("  --pass              - set the password used for client identification\n");
  printf("                        (default: no password)\n");
  printf("  --ignorepkeys       - ignore invalid server's public keys\n\n");
  printf(" Configuration:\n\n");
  printf("  -k, --keyfile       - the name of the file with RSA key (default: client.rsa)\n");
  printf("  -c, --cerfile       - the name of the file with certificate\n");
  printf("                        (default: no certificate used)\n");
  printf("  -f, --cfgfile       - the name of the file with the configuration for the\n");
  printf("                        active forwarder (client)\n");
  printf("  -s, --storefile     - the name of the file with stored public keys\n");
  printf("                        (default: known_hosts)\n");
  printf("  -D, --dateformat    - format of the date printed in logs (see 'man strftime'\n");
  printf("                        for details) (default: %%Y-%%m-%%d %%H:%%M:%%S)\n");
  printf("  -K, --keep-alive N  - send keepalive packets every N seconds\n");
  printf("                        (default: not send keepalive packets)\n\n");
  printf(" Auto-reconnection:\n\n");
  printf("  --ar-start          - enable auto-reconnection when afserver is not\n");
  printf("                        reachable on start (default: disabled)\n");
  printf("  --ar-quit           - enable auto-reconnection after normal afserver quit\n");
  printf("                        (default: disabled)\n");
  printf("  --noar              - disable auto-reconnection after premature afserver\n");
  printf("                        quit (default: enabled)\n");
  printf("  -A, --ar-tries N    - try N times to reconnect (default: unlimited)\n");
  printf("  -T, --ar-delay N    - wait N seconds between reconnect tries (default: 5)\n\n");
  printf(" Modes:\n\n");
  printf("  -u, --udpmode       - udp mode - client will use udp protocol to\n");
  printf("                        communicate with the hostname:portnum\n");
  printf("  -U, --reverseudp    - reverse udp forwarding. Udp packets will be forwarded\n");
  printf("                        from hostname:portnum to the server name:manageport\n");
  printf("  -r, --remoteadmin   - remote administration mode. (using '-p #port' will\n");
  printf("                        force afclient to use port rather than stdin-stdout)\n\n");
  printf(" Logging:\n\n");
  printf("  -o, --log           - log choosen information to file/socket\n");
  printf("  -v, --verbose       - to be verbose - program won't enter the daemon mode\n");
  printf("                        (use several times for greater effect)\n\n");
  printf(" IP family:\n\n");
  printf("  -4, --ipv4          - use ipv4 only\n");
  printf("  -6, --ipv6          - use ipv6 only\n\n");
  printf(" Modules:\n\n");
  printf("  -l, --load          - load a module for user's packets filtering\n");
  printf("  -L, --Load          - load a module for service's packets filtering\n\n");
  printf(" HTTP/HTTPS PROXY:\n\n");
  printf("  -S, --use-https     - use https proxy instead of http proxy\n");
  printf("  -P, --proxyname     - the name of the machine with proxy server\n");
  printf("  -X, --proxyport     - the port used by proxy server (default: 8080)\n");
  printf("  -C, --pa-cred  U:P  - the user (U) and password (P) used in proxy\n");
  printf("                        authorization\n");
  printf("  -B, --pa-t-basic    - the Basic type of proxy authorization (default)\n\n");
  exit(0);
}

// client_short_usage
// file usage.c line 132
void client_short_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf("Try `afclient --help' for more information.\n");
  exit(1);
}

// close_fd
// file http_proxy_functions.c line 248
void close_fd(signed int *fd)
{
  close(*fd);
}

// create_apf_dir
// file first_run.h line 24
signed int create_apf_dir(char type)
{
  signed int length;
  struct stat buf;
  struct passwd *user;
  unsigned int return_value_getuid$1;
  return_value_getuid$1=getuid();
  user=getpwuid(return_value_getuid$1);
  if((signed int)type == 0)
  {
    if(user == ((struct passwd *)NULL))
      return 1;

    if(user->pw_dir == ((char *)NULL))
      return 2;

    if(!(home_dir == ((char *)NULL)))
    {
      free((void *)home_dir);
      home_dir = (char *)(void *)0;
    }

    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(user->pw_dir);
    length = (signed int)return_value_strlen$2;
    void *return_value_calloc$3;
    return_value_calloc$3=calloc((unsigned long int)1, (unsigned long int)(length + 6));
    home_dir = (char *)return_value_calloc$3;
    if(home_dir == ((char *)NULL))
      return 3;

    strcpy(home_dir, user->pw_dir);
    if((signed int)home_dir[(signed long int)length] == 47)
      strcpy(&home_dir[(signed long int)length], ".apf");

    else
      strcpy(&home_dir[(signed long int)length], "/.apf");
    signed int return_value_stat$5;
    return_value_stat$5=stat(home_dir, &buf);
    if(!(return_value_stat$5 == 0))
    {
      signed int return_value_mkdir$4;
      return_value_mkdir$4=mkdir(home_dir, (unsigned int)0700);
      if(!(return_value_mkdir$4 == 0))
        return 4;

    }

  }

  else
  {
    if(!(home_dir == ((char *)NULL)))
    {
      free((void *)home_dir);
      home_dir = (char *)(void *)0;
    }

    void *return_value_calloc$6;
    return_value_calloc$6=calloc((unsigned long int)1, (unsigned long int)4);
    home_dir = (char *)return_value_calloc$6;
    if(home_dir == ((char *)NULL))
      return 3;

    strcpy(home_dir, "apf");
    signed int return_value_stat$8;
    return_value_stat$8=stat(home_dir, &buf);
    if(!(return_value_stat$8 == 0))
    {
      signed int return_value_mkdir$7;
      return_value_mkdir$7=mkdir(home_dir, (unsigned int)0700);
      if(!(return_value_mkdir$7 == 0))
        return 4;

    }

  }
  return 0;
}

// create_publickey_store
// file first_run.c line 147
signed int create_publickey_store(char **storefile)
{
  signed int store_length;
  signed int home_length;
  struct stat buf;
  struct _IO_FILE *store_file;
  signed int return_value_stat$1;
  return_value_stat$1=stat(*storefile, &buf);
  if(return_value_stat$1 == 0)
    return 0;

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(*storefile);
    store_length = (signed int)return_value_strlen$2;
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(home_dir);
    home_length = (signed int)return_value_strlen$3;
    if(!(home_dir_store == ((char *)NULL)))
    {
      free((void *)home_dir_store);
      home_dir_store = (char *)(void *)0;
    }

    void *return_value_calloc$4;
    return_value_calloc$4=calloc((unsigned long int)1, (unsigned long int)(home_length + store_length + 2));
    home_dir_store = (char *)return_value_calloc$4;
    if(home_dir_store == ((char *)NULL))
      return 1;

    else
    {
      strcpy(home_dir_store, home_dir);
      home_dir_store[(signed long int)home_length] = (char)47;
      strcpy(&home_dir_store[(signed long int)(home_length + 1)], *storefile);
      *storefile = home_dir_store;
      store_file=fopen(home_dir_store, "a");
      if(store_file == ((struct _IO_FILE *)NULL))
        return 1;

      else
      {
        fclose(store_file);
        signed int return_value_stat$5;
        return_value_stat$5=stat(home_dir_store, &buf);
        if(return_value_stat$5 == 0)
          return 0;

        else
          return 2;
      }
    }
  }
}

// datum
// file logging.c line 85
char * datum(void)
{
  signed long int sec;
  struct tm *tm;
  time(&sec);
  tm=localtime(&sec);
  static char timedat[31l];
  memset((void *)timedat, 0, (unsigned long int)31);
  strftime(timedat, (unsigned long int)30, format, tm);
  return timedat;
}

// delete_user
// file http_proxy_functions.c line 77
void delete_user(struct anonymous$27 *cnts, signed int i, struct anonymous$22 *allset)
{
  aflog((char)16, (char)2, "http proxy: delete_user(%d)", i);
  clear_fd(&(cnts + (signed long int)i)->sockfd, allset);
  if((1 & (signed int)(cnts + (signed long int)i)->state) == 0)
    clear_sslFd((cnts + (signed long int)i)->postFd, allset);

  if((signed int)(cnts + (signed long int)i)->type == 0)
  {
    if((2 & (signed int)(cnts + (signed long int)i)->state) == 0)
      clear_sslFd((cnts + (signed long int)i)->getFd, allset);

  }

  (cnts + (signed long int)i)->state = (char)0;
  (cnts + (signed long int)i)->length = 0;
  (cnts + (signed long int)i)->ptr = (cnts + (signed long int)i)->length;
  (cnts + (signed long int)i)->sent_ptr = (cnts + (signed long int)i)->ptr;
  (cnts + (signed long int)i)->type = (char)0;
}

// end_critical_section
// file thread_management.h line 29
void end_critical_section(void)
{
  pthread_mutex_unlock(&mainmutex);
}

// eval_UsrCliPair
// file server_eval.h line 29
signed int eval_UsrCliPair(struct anonymous$7 **table, signed int index, char *host, char *serv)
{
  signed int i;
  signed int result = 0;
  i = 0;
  signed int tmp_statement_expression$1;
  signed int tmp_statement_expression$5;
  for( ; !(i >= index); i = i + 1)
  {
    char *return_value_UsrCli_get_manageHostName$4;
    return_value_UsrCli_get_manageHostName$4=UsrCli_get_manageHostName(table[(signed long int)i]);
    if(!(return_value_UsrCli_get_manageHostName$4 == ((char *)NULL)))
    {
      if(!(host == ((char *)NULL)))
      {
        unsigned long int eval_UsrCliPair$$1$$1$$1$$1$$1$$__s1_len;
        unsigned long int eval_UsrCliPair$$1$$1$$1$$1$$1$$__s2_len;
        char *return_value_UsrCli_get_listenHostName$2;
        return_value_UsrCli_get_listenHostName$2=UsrCli_get_listenHostName(table[(signed long int)i]);
        signed int return_value___builtin_strcmp$3;
        return_value___builtin_strcmp$3=__builtin_strcmp(return_value_UsrCli_get_listenHostName$2, host);
        tmp_statement_expression$1 = return_value___builtin_strcmp$3;
        if(!(tmp_statement_expression$1 == 0))
          goto __CPROVER_DUMP_L11;

      }

      else
        goto __CPROVER_DUMP_L11;
    }

    else
      if(!(host == ((char *)NULL)))
        goto __CPROVER_DUMP_L11;

    char *return_value_UsrCli_get_managePortName$8;
    return_value_UsrCli_get_managePortName$8=UsrCli_get_managePortName(table[(signed long int)i]);
    if(!(return_value_UsrCli_get_managePortName$8 == ((char *)NULL)))
    {
      if(!(serv == ((char *)NULL)))
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        char *return_value_UsrCli_get_managePortName$6;
        return_value_UsrCli_get_managePortName$6=UsrCli_get_managePortName(table[(signed long int)i]);
        signed int return_value___builtin_strcmp$7;
        return_value___builtin_strcmp$7=__builtin_strcmp(return_value_UsrCli_get_managePortName$6, serv);
        tmp_statement_expression$5 = return_value___builtin_strcmp$7;
        if(!(tmp_statement_expression$5 == 0))
          goto __CPROVER_DUMP_L11;

      }

      else
        goto __CPROVER_DUMP_L11;
    }

    else
      if(!(serv == ((char *)NULL)))
        goto __CPROVER_DUMP_L11;

    result = result + 1;

  __CPROVER_DUMP_L11:
    ;
  }
  return result;
}

// eval_numofcon
// file server_eval.h line 27
signed int eval_numofcon(struct anonymous$5 *ptr, signed int client, signed int numofcon)
{
  _Bool tmp_if_expr$5;
  struct anonymous$3 **return_value_ServerRealm_get_clientsTable$3;
  signed int return_value_ConnectClient_get_limit$4;
  if(numofcon >= 0)
  {
    return_value_ServerRealm_get_clientsTable$3=ServerRealm_get_clientsTable(ptr);
    return_value_ConnectClient_get_limit$4=ConnectClient_get_limit(return_value_ServerRealm_get_clientsTable$3[(signed long int)client]);
    tmp_if_expr$5 = numofcon < return_value_ConnectClient_get_limit$4 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$5 = (_Bool)0;
  if(tmp_if_expr$5)
  {
    struct anonymous$3 **return_value_ServerRealm_get_clientsTable$1;
    return_value_ServerRealm_get_clientsTable$1=ServerRealm_get_clientsTable(ptr);
    signed int *return_value_ConnectClient_get_users$2;
    return_value_ConnectClient_get_users$2=ConnectClient_get_users(return_value_ServerRealm_get_clientsTable$1[(signed long int)client]);
    numofcon = return_value_ConnectClient_get_users$2[(signed long int)numofcon];
  }

  else
    numofcon = -1;
  return numofcon;
}

// eval_usernum
// file server_eval.h line 28
signed int eval_usernum(struct anonymous$3 *ptr, signed int usernum)
{
  signed int i = 0;
  signed int return_value_ConnectClient_get_limit$1;
  do
  {
    return_value_ConnectClient_get_limit$1=ConnectClient_get_limit(ptr);
    if(i >= return_value_ConnectClient_get_limit$1)
      break;

    signed int *return_value_ConnectClient_get_users$2;
    return_value_ConnectClient_get_users$2=ConnectClient_get_users(ptr);
    if(return_value_ConnectClient_get_users$2[(signed long int)i] == usernum)
      return i;

    i = i + 1;
  }
  while((_Bool)1);
  return -1;
}

// find_client
// file server_find.h line 27
signed int find_client(struct anonymous$5 *ptr, char mode, signed int usrclipair)
{
  signed int i;
  signed int return_value_ServerRealm_get_clientsLimit$1;
  struct anonymous$3 **return_value_ServerRealm_get_clientsTable$6;
  signed int return_value_ConnectClient_get_usrCliPair$7;
  if((signed int)mode == 1)
  {
    i = 0;
    do
    {
      return_value_ServerRealm_get_clientsLimit$1=ServerRealm_get_clientsLimit(ptr);
      if(i >= return_value_ServerRealm_get_clientsLimit$1)
        break;

      struct anonymous$3 **return_value_ServerRealm_get_clientsTable$8;
      return_value_ServerRealm_get_clientsTable$8=ServerRealm_get_clientsTable(ptr);
      char return_value_ConnectClient_get_state$9;
      return_value_ConnectClient_get_state$9=ConnectClient_get_state(return_value_ServerRealm_get_clientsTable$8[(signed long int)i]);
      if((signed int)return_value_ConnectClient_get_state$9 == 3)
      {
        return_value_ServerRealm_get_clientsTable$6=ServerRealm_get_clientsTable(ptr);
        return_value_ConnectClient_get_usrCliPair$7=ConnectClient_get_usrCliPair(return_value_ServerRealm_get_clientsTable$6[(signed long int)i]);
        if(return_value_ConnectClient_get_usrCliPair$7 == usrclipair)
        {
          struct anonymous$3 **return_value_ServerRealm_get_clientsTable$2;
          return_value_ServerRealm_get_clientsTable$2=ServerRealm_get_clientsTable(ptr);
          signed int return_value_ConnectClient_get_connected$3;
          return_value_ConnectClient_get_connected$3=ConnectClient_get_connected(return_value_ServerRealm_get_clientsTable$2[(signed long int)i]);
          struct anonymous$3 **return_value_ServerRealm_get_clientsTable$4;
          return_value_ServerRealm_get_clientsTable$4=ServerRealm_get_clientsTable(ptr);
          signed int return_value_ConnectClient_get_limit$5;
          return_value_ConnectClient_get_limit$5=ConnectClient_get_limit(return_value_ServerRealm_get_clientsTable$4[(signed long int)i]);
          if(!(return_value_ConnectClient_get_connected$3 >= return_value_ConnectClient_get_limit$5))
            return i;

        }

      }

      i = i + 1;
    }
    while((_Bool)1);
    goto __CPROVER_DUMP_L7;
  }

  return 0;

__CPROVER_DUMP_L7:
  ;
  return 0;
}

// find_previousFd
// file server_find.h line 29
signed int find_previousFd(struct anonymous$7 **table, signed int index, char *host, char *serv)
{
  signed int i = 0;
  signed int tmp_statement_expression$1;
  signed int tmp_statement_expression$5;
  for( ; !(i >= index); i = i + 1)
  {
    char *return_value_UsrCli_get_manageHostName$4;
    return_value_UsrCli_get_manageHostName$4=UsrCli_get_manageHostName(table[(signed long int)i]);
    if(!(return_value_UsrCli_get_manageHostName$4 == ((char *)NULL)))
    {
      if(!(host == ((char *)NULL)))
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        char *return_value_UsrCli_get_listenHostName$2;
        return_value_UsrCli_get_listenHostName$2=UsrCli_get_listenHostName(table[(signed long int)i]);
        signed int return_value___builtin_strcmp$3;
        return_value___builtin_strcmp$3=__builtin_strcmp(return_value_UsrCli_get_listenHostName$2, host);
        tmp_statement_expression$1 = return_value___builtin_strcmp$3;
        if(!(tmp_statement_expression$1 == 0))
          goto __CPROVER_DUMP_L11;

      }

      else
        goto __CPROVER_DUMP_L11;
    }

    else
      if(!(host == ((char *)NULL)))
        goto __CPROVER_DUMP_L11;

    char *return_value_UsrCli_get_managePortName$8;
    return_value_UsrCli_get_managePortName$8=UsrCli_get_managePortName(table[(signed long int)i]);
    if(!(return_value_UsrCli_get_managePortName$8 == ((char *)NULL)))
    {
      if(!(serv == ((char *)NULL)))
      {
        unsigned long int find_previousFd$$1$$1$$3$$1$$1$$__s1_len;
        unsigned long int find_previousFd$$1$$1$$3$$1$$1$$__s2_len;
        char *return_value_UsrCli_get_managePortName$6;
        return_value_UsrCli_get_managePortName$6=UsrCli_get_managePortName(table[(signed long int)i]);
        signed int return_value___builtin_strcmp$7;
        return_value___builtin_strcmp$7=__builtin_strcmp(return_value_UsrCli_get_managePortName$6, serv);
        tmp_statement_expression$5 = return_value___builtin_strcmp$7;
        if(!(tmp_statement_expression$5 == 0))
          goto __CPROVER_DUMP_L11;

      }

      else
        goto __CPROVER_DUMP_L11;
    }

    else
      if(!(serv == ((char *)NULL)))
        goto __CPROVER_DUMP_L11;

    signed int return_value_UsrCli_get_manageFd$9;
    return_value_UsrCli_get_manageFd$9=UsrCli_get_manageFd(table[(signed long int)i]);
    return return_value_UsrCli_get_manageFd$9;

  __CPROVER_DUMP_L11:
    ;
  }
  return -1;
}

// find_tasknode_with_minimal_timer
// file task_scheduler_struct.c line 158
static struct tlnode * find_tasknode_with_minimal_timer(struct anonymous$16 *scheduler)
{
  struct tlnode *iterator;
  struct tlnode *candidate;
  if(scheduler == ((struct anonymous$16 *)NULL))
    return (struct tlnode *)(void *)0;

  else
    if(scheduler->head == ((struct tlnode *)NULL))
      return (struct tlnode *)(void *)0;

    else
    {
      candidate = scheduler->head;
      iterator = scheduler->head;
      iterator = iterator->next;
      while(!(iterator == ((struct tlnode *)NULL)))
      {
        struct anonymous$13 *return_value_TaskListNode_get_task$1;
        return_value_TaskListNode_get_task$1=TaskListNode_get_task(iterator);
        struct timeval *return_value_Task_get_timer$2;
        return_value_Task_get_timer$2=Task_get_timer(return_value_TaskListNode_get_task$1);
        struct anonymous$13 *return_value_TaskListNode_get_task$3;
        return_value_TaskListNode_get_task$3=TaskListNode_get_task(candidate);
        struct timeval *return_value_Task_get_timer$4;
        return_value_Task_get_timer$4=Task_get_timer(return_value_TaskListNode_get_task$3);
        signed int return_value_timeval_compare$5;
        return_value_timeval_compare$5=timeval_compare(return_value_Task_get_timer$2, return_value_Task_get_timer$4);
        if(return_value_timeval_compare$5 == -1)
          candidate = iterator;

        iterator = iterator->next;
      }
      return candidate;
    }
}

// find_usernum
// file server_find.h line 28
signed int find_usernum(struct anonymous$3 *ptr, signed int usernum)
{
  signed int i = 0;
  signed int return_value_ConnectClient_get_limit$1;
  do
  {
    return_value_ConnectClient_get_limit$1=ConnectClient_get_limit(ptr);
    if(i >= return_value_ConnectClient_get_limit$1)
      break;

    signed int *return_value_ConnectClient_get_users$3;
    return_value_ConnectClient_get_users$3=ConnectClient_get_users(ptr);
    if(return_value_ConnectClient_get_users$3[(signed long int)i] == -1)
    {
      signed int *return_value_ConnectClient_get_users$2;
      return_value_ConnectClient_get_users$2=ConnectClient_get_users(ptr);
      return_value_ConnectClient_get_users$2[(signed long int)i] = usernum;
      return i;
    }

    i = i + 1;
  }
  while((_Bool)1);
  return -1;
}

// generate_certificate
// file first_run.h line 27
signed int generate_certificate(char **cerfile, char *keyfile)
{
  signed int cer_length;
  signed int home_length;
  signed int i;
  struct stat buf;
  struct x509_st *cert;
  struct X509_req_st *req;
  struct X509_name_st *subj;
  struct rsa_st *rsa_key;
  struct evp_pkey_st *pkey;
  const struct env_md_st *digest;
  struct _IO_FILE *fp;
  signed int return_value_stat$1;
  return_value_stat$1=stat(*cerfile, &buf);
  if(return_value_stat$1 == 0)
    return 0;

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(*cerfile);
    cer_length = (signed int)return_value_strlen$2;
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(home_dir);
    home_length = (signed int)return_value_strlen$3;
    if(!(home_dir_cer == ((char *)NULL)))
    {
      free((void *)home_dir_cer);
      home_dir_cer = (char *)(void *)0;
    }

    void *return_value_calloc$4;
    return_value_calloc$4=calloc((unsigned long int)1, (unsigned long int)(home_length + cer_length + 2));
    home_dir_cer = (char *)return_value_calloc$4;
    if(home_dir_cer == ((char *)NULL))
      return 1;

    else
    {
      strcpy(home_dir_cer, home_dir);
      home_dir_cer[(signed long int)home_length] = (char)47;
      strcpy(&home_dir_cer[(signed long int)(home_length + 1)], *cerfile);
      *cerfile = home_dir_cer;
      signed int return_value_stat$5;
      return_value_stat$5=stat(home_dir_cer, &buf);
      if(return_value_stat$5 == 0)
        return 0;

      else
      {
        printf("generating self signed certificate\n");
        fp=fopen(keyfile, "r");
        if(fp == ((struct _IO_FILE *)NULL))
          return 2;

        else
        {
          rsa_key=PEM_read_RSAPrivateKey(fp, (struct rsa_st **)(void *)0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
          fclose(fp);
          if(rsa_key == ((struct rsa_st *)NULL))
            return 3;

          else
          {
            pkey=EVP_PKEY_new();
            if(pkey == ((struct evp_pkey_st *)NULL))
              return 4;

            else
            {
              signed int return_value_EVP_PKEY_set1_RSA$6;
              return_value_EVP_PKEY_set1_RSA$6=EVP_PKEY_set1_RSA(pkey, rsa_key);
              if(return_value_EVP_PKEY_set1_RSA$6 == 0)
                return 5;

              else
              {
                req=X509_REQ_new();
                if(req == ((struct X509_req_st *)NULL))
                  return 6;

                else
                {
                  X509_REQ_set_pubkey(req, pkey);
                  subj=X509_NAME_new();
                  if(subj == ((struct X509_name_st *)NULL))
                    return 7;

                  else
                  {
                    i = 0;
                    for( ; !(i >= 6); i = i + 1)
                    {
                      signed int nid;
                      struct X509_name_entry_st *ent;
                      nid=OBJ_txt2nid(entries[(signed long int)i].key);
                      if(nid == 0)
                        return 8;

                      ent=X509_NAME_ENTRY_create_by_NID((struct X509_name_entry_st **)(void *)0, nid, 0x1000 | 1, entries[(signed long int)i].value, -1);
                      if(ent == ((struct X509_name_entry_st *)NULL))
                        return 9;

                      signed int return_value_X509_NAME_add_entry$7;
                      return_value_X509_NAME_add_entry$7=X509_NAME_add_entry(subj, ent, -1, 0);
                      if(return_value_X509_NAME_add_entry$7 == 0)
                        return 10;

                    }
                    signed int return_value_X509_REQ_set_subject_name$8;
                    return_value_X509_REQ_set_subject_name$8=X509_REQ_set_subject_name(req, subj);
                    if(return_value_X509_REQ_set_subject_name$8 == 0)
                      return 11;

                    else
                    {
                      digest=EVP_sha1();
                      signed int return_value_X509_REQ_sign$9;
                      return_value_X509_REQ_sign$9=X509_REQ_sign(req, pkey, digest);
                      if(return_value_X509_REQ_sign$9 == 0)
                        return 12;

                      else
                      {
                        cert=X509_REQ_to_X509(req, 1000, pkey);
                        signed int return_value_X509_set_version$10;
                        return_value_X509_set_version$10=X509_set_version(cert, 2L);
                        if(return_value_X509_set_version$10 == 0)
                          return 13;

                        else
                        {
                          struct asn1_string_st *return_value_X509_get_serialNumber$11;
                          return_value_X509_get_serialNumber$11=X509_get_serialNumber(cert);
                          ASN1_INTEGER_set(return_value_X509_get_serialNumber$11, (signed long int)1);
                          if(cert == ((struct x509_st *)NULL))
                            return 14;

                          else
                          {
                            signed int return_value_X509_sign$12;
                            return_value_X509_sign$12=X509_sign(cert, pkey, digest);
                            if(return_value_X509_sign$12 == 0)
                              return 15;

                            else
                            {
                              fp=fopen(home_dir_cer, "w");
                              if(fp == ((struct _IO_FILE *)NULL))
                                return 16;

                              else
                              {
                                PEM_write_X509(fp, cert);
                                fclose(fp);
                                EVP_PKEY_free(pkey);
                                X509_REQ_free(req);
                                X509_free(cert);
                                return 0;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// generate_rsa_key
// file first_run.h line 26
signed int generate_rsa_key(char **keyfile)
{
  signed int key_length;
  signed int home_length;
  struct rsa_st *rsa_key;
  struct _IO_FILE *rsa_file;
  struct stat buf;
  signed int return_value_stat$1;
  return_value_stat$1=stat(*keyfile, &buf);
  if(return_value_stat$1 == 0)
    return 0;

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(*keyfile);
    key_length = (signed int)return_value_strlen$2;
    unsigned long int return_value_strlen$3;
    return_value_strlen$3=strlen(home_dir);
    home_length = (signed int)return_value_strlen$3;
    if(!(home_dir_key == ((char *)NULL)))
    {
      free((void *)home_dir_key);
      home_dir_key = (char *)(void *)0;
    }

    void *return_value_calloc$4;
    return_value_calloc$4=calloc((unsigned long int)1, (unsigned long int)(home_length + key_length + 2));
    home_dir_key = (char *)return_value_calloc$4;
    if(home_dir_key == ((char *)NULL))
      return 1;

    else
    {
      strcpy(home_dir_key, home_dir);
      home_dir_key[(signed long int)home_length] = (char)47;
      strcpy(&home_dir_key[(signed long int)(home_length + 1)], *keyfile);
      *keyfile = home_dir_key;
      signed int return_value_stat$5;
      return_value_stat$5=stat(home_dir_key, &buf);
      if(return_value_stat$5 == 0)
        return 0;

      else
      {
        printf("generating rsa key: 2048 bits\n");
        rsa_key=RSA_generate_key(2048, (unsigned long int)65537, callback, (void *)0);
        signed int return_value_RSA_check_key$6;
        return_value_RSA_check_key$6=RSA_check_key(rsa_key);
        if(return_value_RSA_check_key$6 == 1)
          printf("   OK!\n");

        else
        {
          printf("   FAILED!\n");
          return 1;
        }
        rsa_file=fopen(home_dir_key, "a");
        PEM_write_RSAPrivateKey(rsa_file, rsa_key, (const struct evp_cipher_st *)(void *)0, (unsigned char *)(void *)0, 0, (signed int (*)(char *, signed int, signed int, void *))(void *)0, (void *)0);
        fclose(rsa_file);
        return 0;
      }
    }
  }
}

// get_cer_filename
// file first_run.c line 400
char * get_cer_filename()
{
  return home_dir_cer;
}

// get_clientid
// file clientnames.c line 48
signed int get_clientid(struct anonymous$5 *pointer, char *clientname)
{
  signed int i;
  signed int n;
  char guard;
  signed int return_value_ServerRealm_get_clientsLimit$1;
  signed int tmp_statement_expression$4;
  signed int return_value_ServerRealm_get_clientsLimit$12;
  if(pointer == ((struct anonymous$5 *)NULL))
    return -1;

  else
    if(clientname == ((char *)NULL))
      return -1;

    else
    {
      i = 0;
      do
      {
        return_value_ServerRealm_get_clientsLimit$1=ServerRealm_get_clientsLimit(pointer);
        if(i >= return_value_ServerRealm_get_clientsLimit$1)
          break;

        struct anonymous$3 **return_value_ServerRealm_get_clientsTable$8;
        return_value_ServerRealm_get_clientsTable$8=ServerRealm_get_clientsTable(pointer);
        char *return_value_ConnectClient_get_sClientId$9;
        return_value_ConnectClient_get_sClientId$9=ConnectClient_get_sClientId(return_value_ServerRealm_get_clientsTable$8[(signed long int)i]);
        if(!(return_value_ConnectClient_get_sClientId$9 == ((char *)NULL)))
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          struct anonymous$3 **return_value_ServerRealm_get_clientsTable$5;
          return_value_ServerRealm_get_clientsTable$5=ServerRealm_get_clientsTable(pointer);
          char *return_value_ConnectClient_get_sClientId$6;
          return_value_ConnectClient_get_sClientId$6=ConnectClient_get_sClientId(return_value_ServerRealm_get_clientsTable$5[(signed long int)i]);
          signed int return_value___builtin_strcmp$7;
          return_value___builtin_strcmp$7=__builtin_strcmp(clientname, return_value_ConnectClient_get_sClientId$6);
          tmp_statement_expression$4 = return_value___builtin_strcmp$7;
          if(tmp_statement_expression$4 == 0)
          {
            struct anonymous$3 **return_value_ServerRealm_get_clientsTable$2;
            return_value_ServerRealm_get_clientsTable$2=ServerRealm_get_clientsTable(pointer);
            signed int return_value_ConnectClient_get_clientId$3;
            return_value_ConnectClient_get_clientId$3=ConnectClient_get_clientId(return_value_ServerRealm_get_clientsTable$2[(signed long int)i]);
            return return_value_ConnectClient_get_clientId$3;
          }

        }

        i = i + 1;
      }
      while((_Bool)1);
      signed int return_value_sscanf$13;
      return_value_sscanf$13=sscanf(clientname, "%d%c", &i, &guard);
      if(return_value_sscanf$13 == 1)
      {
        n=get_clientnumber(pointer, i);
        if(n >= 0)
        {
          return_value_ServerRealm_get_clientsLimit$12=ServerRealm_get_clientsLimit(pointer);
          if(!(n >= return_value_ServerRealm_get_clientsLimit$12))
          {
            struct anonymous$3 **return_value_ServerRealm_get_clientsTable$10;
            return_value_ServerRealm_get_clientsTable$10=ServerRealm_get_clientsTable(pointer);
            char *return_value_ConnectClient_get_sClientId$11;
            return_value_ConnectClient_get_sClientId$11=ConnectClient_get_sClientId(return_value_ServerRealm_get_clientsTable$10[(signed long int)n]);
            if(return_value_ConnectClient_get_sClientId$11 == ((char *)NULL))
              return i;

          }

        }

      }

      return -1;
    }
}

// get_clientname
// file clientnames.h line 27
char * get_clientname(struct anonymous$5 *pointer, signed int client)
{
  if(pointer == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
  {
    struct anonymous$3 **return_value_ServerRealm_get_clientsTable$3;
    return_value_ServerRealm_get_clientsTable$3=ServerRealm_get_clientsTable(pointer);
    char *return_value_ConnectClient_get_sClientId$4;
    return_value_ConnectClient_get_sClientId$4=ConnectClient_get_sClientId(return_value_ServerRealm_get_clientsTable$3[(signed long int)client]);
    if(return_value_ConnectClient_get_sClientId$4 == ((char *)NULL))
    {
      static char clientname[10l];
      memset((void *)clientname, 0, (unsigned long int)10);
      struct anonymous$3 **return_value_ServerRealm_get_clientsTable$1;
      return_value_ServerRealm_get_clientsTable$1=ServerRealm_get_clientsTable(pointer);
      signed int return_value_ConnectClient_get_clientId$2;
      return_value_ConnectClient_get_clientId$2=ConnectClient_get_clientId(return_value_ServerRealm_get_clientsTable$1[(signed long int)client]);
      sprintf(clientname, "%d", return_value_ConnectClient_get_clientId$2);
      return clientname;
    }

    struct anonymous$3 **return_value_ServerRealm_get_clientsTable$5;
    return_value_ServerRealm_get_clientsTable$5=ServerRealm_get_clientsTable(pointer);
    char *return_value_ConnectClient_get_sClientId$6;
    return_value_ConnectClient_get_sClientId$6=ConnectClient_get_sClientId(return_value_ServerRealm_get_clientsTable$5[(signed long int)client]);
    return return_value_ConnectClient_get_sClientId$6;
  }
}

// get_clientnumber
// file clientnames.h line 29
signed int get_clientnumber(struct anonymous$5 *pointer, signed int clientid)
{
  signed int i;
  signed int return_value_ServerRealm_get_clientsLimit$1;
  if(pointer == ((struct anonymous$5 *)NULL))
    return -1;

  else
  {
    i = 0;
    do
    {
      return_value_ServerRealm_get_clientsLimit$1=ServerRealm_get_clientsLimit(pointer);
      if(i >= return_value_ServerRealm_get_clientsLimit$1)
        break;

      struct anonymous$3 **return_value_ServerRealm_get_clientsTable$2;
      return_value_ServerRealm_get_clientsTable$2=ServerRealm_get_clientsTable(pointer);
      signed int return_value_ConnectClient_get_clientId$3;
      return_value_ConnectClient_get_clientId$3=ConnectClient_get_clientId(return_value_ServerRealm_get_clientsTable$2[(signed long int)i]);
      if(return_value_ConnectClient_get_clientId$3 == clientid)
        return i;

      i = i + 1;
    }
    while((_Bool)1);
    return -1;
  }
}

// get_key_filename
// file first_run.c line 388
char * get_key_filename()
{
  return home_dir_key;
}

// get_new_socket
// file server_get.h line 28
signed int get_new_socket(signed int sockfd, char type, struct sockaddr *addr, unsigned int *addrlen, char *tunneltype)
{
  signed int tmp;
  signed int n;
  signed int i;
  signed int return_value_accept$1;
  signed int *return_value___errno_location$2;
  signed int *return_value___errno_location$4;
  signed int *return_value___errno_location$6;
  signed int *return_value___errno_location$8;
  switch((signed int)type)
  {
    case 0:
    {
      return_value_accept$1=accept(sockfd, addr, addrlen);
      return return_value_accept$1;
    }
    case 1:
    {
      i = 0;
      while(!(i >= 4))
      {
        signed long int return_value_read$3;
        return_value_read$3=read(sockfd, (void *)(&tmp + (signed long int)i), (unsigned long int)(4 - i));
        n = (signed int)return_value_read$3;
        if(!(n == 4 + -i))
        {
          sleep((unsigned int)2);
          if(n >= 1 && !(n >= 4))
          {
            i = i + n;
            continue;
          }

          if(n == -1)
          {
            return_value___errno_location$2=__errno_location();
            if(*return_value___errno_location$2 == 11)
              continue;

          }

          return -1;
        }

        else
          break;
      }
      i = 0;
      while(!(i >= 1))
      {
        signed long int return_value_read$5;
        return_value_read$5=read(sockfd, (void *)(tunneltype + (signed long int)i), (unsigned long int)(1 - i));
        n = (signed int)return_value_read$5;
        if(!(n == 1 + -i))
        {
          if(n == -1)
          {
            return_value___errno_location$4=__errno_location();
            if(*return_value___errno_location$4 == 11)
              continue;

          }

          return -1;
        }

        else
          break;
      }
      i = 0;
      while(!(i >= 4))
      {
        signed long int return_value_read$7;
        return_value_read$7=read(sockfd, (void *)(addrlen + (signed long int)i), (unsigned long int)(4 - i));
        n = (signed int)return_value_read$7;
        if(!(n == 4 + -i))
        {
          if(n >= 1 && !(n >= 4))
          {
            i = i + n;
            continue;
          }

          if(n == -1)
          {
            return_value___errno_location$6=__errno_location();
            if(*return_value___errno_location$6 == 11)
              continue;

          }

          return -1;
        }

        else
          break;
      }
      i = 0;
      while(!((unsigned int)i >= *addrlen))
      {
        signed long int return_value_read$9;
        return_value_read$9=read(sockfd, (void *)(addr + (signed long int)i), (unsigned long int)(*addrlen - (unsigned int)i));
        n = (signed int)return_value_read$9;
        if(!((unsigned int)n == *addrlen + -((unsigned int)i)))
        {
          if(n >= 1)
          {
            if(!((unsigned int)n >= *addrlen))
            {
              i = i + n;
              continue;
            }

          }

          if(n == -1)
          {
            return_value___errno_location$8=__errno_location();
            if(*return_value___errno_location$8 == 11)
              continue;

          }

          return -1;
        }

        else
          break;
      }
      return tmp;
    }
    default:
      return -1;
  }
}

// get_raclientid
// file clientnames.c line 121
signed int get_raclientid(struct anonymous$5 *pointer, char *clientname)
{
  signed int i;
  signed int n;
  char guard;
  signed int return_value_ServerRealm_get_raClientsLimit$1;
  signed int tmp_statement_expression$4;
  signed int return_value_ServerRealm_get_raClientsLimit$12;
  if(pointer == ((struct anonymous$5 *)NULL))
    return -1;

  else
    if(clientname == ((char *)NULL))
      return -1;

    else
    {
      i = 0;
      do
      {
        return_value_ServerRealm_get_raClientsLimit$1=ServerRealm_get_raClientsLimit(pointer);
        if(i >= return_value_ServerRealm_get_raClientsLimit$1)
          break;

        struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$8;
        return_value_ServerRealm_get_raClientsTable$8=ServerRealm_get_raClientsTable(pointer);
        char *return_value_ConnectClient_get_sClientId$9;
        return_value_ConnectClient_get_sClientId$9=ConnectClient_get_sClientId(return_value_ServerRealm_get_raClientsTable$8[(signed long int)i]);
        if(!(return_value_ConnectClient_get_sClientId$9 == ((char *)NULL)))
        {
          unsigned long int __s1_len;
          unsigned long int __s2_len;
          struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$5;
          return_value_ServerRealm_get_raClientsTable$5=ServerRealm_get_raClientsTable(pointer);
          char *return_value_ConnectClient_get_sClientId$6;
          return_value_ConnectClient_get_sClientId$6=ConnectClient_get_sClientId(return_value_ServerRealm_get_raClientsTable$5[(signed long int)i]);
          signed int return_value___builtin_strcmp$7;
          return_value___builtin_strcmp$7=__builtin_strcmp(clientname, return_value_ConnectClient_get_sClientId$6);
          tmp_statement_expression$4 = return_value___builtin_strcmp$7;
          if(tmp_statement_expression$4 == 0)
          {
            struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$2;
            return_value_ServerRealm_get_raClientsTable$2=ServerRealm_get_raClientsTable(pointer);
            signed int return_value_ConnectClient_get_clientId$3;
            return_value_ConnectClient_get_clientId$3=ConnectClient_get_clientId(return_value_ServerRealm_get_raClientsTable$2[(signed long int)i]);
            return return_value_ConnectClient_get_clientId$3;
          }

        }

        i = i + 1;
      }
      while((_Bool)1);
      signed int return_value_sscanf$13;
      return_value_sscanf$13=sscanf(clientname, "%d%c", &i, &guard);
      if(return_value_sscanf$13 == 1)
      {
        n=get_raclientnumber(pointer, i);
        if(n >= 0)
        {
          return_value_ServerRealm_get_raClientsLimit$12=ServerRealm_get_raClientsLimit(pointer);
          if(!(n >= return_value_ServerRealm_get_raClientsLimit$12))
          {
            struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$10;
            return_value_ServerRealm_get_raClientsTable$10=ServerRealm_get_raClientsTable(pointer);
            char *return_value_ConnectClient_get_sClientId$11;
            return_value_ConnectClient_get_sClientId$11=ConnectClient_get_sClientId(return_value_ServerRealm_get_raClientsTable$10[(signed long int)n]);
            if(return_value_ConnectClient_get_sClientId$11 == ((char *)NULL))
              return i;

          }

        }

      }

      return -1;
    }
}

// get_raclientname
// file clientnames.h line 31
char * get_raclientname(struct anonymous$5 *pointer, signed int client)
{
  if(pointer == ((struct anonymous$5 *)NULL))
    return (char *)(void *)0;

  else
  {
    struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$3;
    return_value_ServerRealm_get_raClientsTable$3=ServerRealm_get_raClientsTable(pointer);
    char *return_value_ConnectClient_get_sClientId$4;
    return_value_ConnectClient_get_sClientId$4=ConnectClient_get_sClientId(return_value_ServerRealm_get_raClientsTable$3[(signed long int)client]);
    if(return_value_ConnectClient_get_sClientId$4 == ((char *)NULL))
    {
      static char clientname[10l];
      memset((void *)clientname, 0, (unsigned long int)10);
      struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$1;
      return_value_ServerRealm_get_raClientsTable$1=ServerRealm_get_raClientsTable(pointer);
      signed int return_value_ConnectClient_get_clientId$2;
      return_value_ConnectClient_get_clientId$2=ConnectClient_get_clientId(return_value_ServerRealm_get_raClientsTable$1[(signed long int)client]);
      sprintf(clientname, "%d", return_value_ConnectClient_get_clientId$2);
      return clientname;
    }

    struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$5;
    return_value_ServerRealm_get_raClientsTable$5=ServerRealm_get_raClientsTable(pointer);
    char *return_value_ConnectClient_get_sClientId$6;
    return_value_ConnectClient_get_sClientId$6=ConnectClient_get_sClientId(return_value_ServerRealm_get_raClientsTable$5[(signed long int)client]);
    return return_value_ConnectClient_get_sClientId$6;
  }
}

// get_raclientnumber
// file clientnames.c line 157
signed int get_raclientnumber(struct anonymous$5 *pointer, signed int clientid)
{
  signed int i;
  signed int return_value_ServerRealm_get_raClientsLimit$1;
  if(pointer == ((struct anonymous$5 *)NULL))
    return -1;

  else
  {
    i = 0;
    do
    {
      return_value_ServerRealm_get_raClientsLimit$1=ServerRealm_get_raClientsLimit(pointer);
      if(i >= return_value_ServerRealm_get_raClientsLimit$1)
        break;

      struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$2;
      return_value_ServerRealm_get_raClientsTable$2=ServerRealm_get_raClientsTable(pointer);
      signed int return_value_ConnectClient_get_clientId$3;
      return_value_ConnectClient_get_clientId$3=ConnectClient_get_clientId(return_value_ServerRealm_get_raClientsTable$2[(signed long int)i]);
      if(return_value_ConnectClient_get_clientId$3 == clientid)
        return i;

      i = i + 1;
    }
    while((_Bool)1);
    return -1;
  }
}

// get_realmname
// file realmnames.h line 27
char * get_realmname(struct anonymous$2 *config, signed int realm)
{
  struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$1;
  return_value_ServerConfiguration_get_realmsTable$1=ServerConfiguration_get_realmsTable(config);
  char *return_value_ServerRealm_get_realmName$2;
  return_value_ServerRealm_get_realmName$2=ServerRealm_get_realmName(return_value_ServerConfiguration_get_realmsTable$1[(signed long int)realm]);
  if(return_value_ServerRealm_get_realmName$2 == ((char *)NULL))
  {
    static char realmname[10l];
    memset((void *)realmname, 0, (unsigned long int)10);
    sprintf(realmname, "%d", realm);
    return realmname;
  }

  else
  {
    struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$3;
    return_value_ServerConfiguration_get_realmsTable$3=ServerConfiguration_get_realmsTable(config);
    char *return_value_ServerRealm_get_realmName$4;
    return_value_ServerRealm_get_realmName$4=ServerRealm_get_realmName(return_value_ServerConfiguration_get_realmsTable$3[(signed long int)realm]);
    return return_value_ServerRealm_get_realmName$4;
  }
}

// get_realmnumber
// file realmnames.h line 28
signed int get_realmnumber(struct anonymous$2 *config, char *realmname)
{
  signed int i;
  char guard;
  i = 0;
  signed int return_value_ServerConfiguration_get_realmsNumber$1;
  signed int tmp_statement_expression$2;
  do
  {
    return_value_ServerConfiguration_get_realmsNumber$1=ServerConfiguration_get_realmsNumber(config);
    if(i >= return_value_ServerConfiguration_get_realmsNumber$1)
      break;

    struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$6;
    return_value_ServerConfiguration_get_realmsTable$6=ServerConfiguration_get_realmsTable(config);
    char *return_value_ServerRealm_get_realmName$7;
    return_value_ServerRealm_get_realmName$7=ServerRealm_get_realmName(return_value_ServerConfiguration_get_realmsTable$6[(signed long int)i]);
    if(!(return_value_ServerRealm_get_realmName$7 == ((char *)NULL)))
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$3;
      return_value_ServerConfiguration_get_realmsTable$3=ServerConfiguration_get_realmsTable(config);
      char *return_value_ServerRealm_get_realmName$4;
      return_value_ServerRealm_get_realmName$4=ServerRealm_get_realmName(return_value_ServerConfiguration_get_realmsTable$3[(signed long int)i]);
      signed int return_value___builtin_strcmp$5;
      return_value___builtin_strcmp$5=__builtin_strcmp(realmname, return_value_ServerRealm_get_realmName$4);
      tmp_statement_expression$2 = return_value___builtin_strcmp$5;
      if(tmp_statement_expression$2 == 0)
        return i;

    }

    i = i + 1;
  }
  while((_Bool)1);
  signed int return_value_sscanf$11;
  return_value_sscanf$11=sscanf(realmname, "%d%c", &i, &guard);
  signed int return_value_ServerConfiguration_get_realmsNumber$10;
  if(return_value_sscanf$11 == 1)
  {
    if(i >= 0)
    {
      return_value_ServerConfiguration_get_realmsNumber$10=ServerConfiguration_get_realmsNumber(config);
      if(!(i >= return_value_ServerConfiguration_get_realmsNumber$10))
      {
        struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$8;
        return_value_ServerConfiguration_get_realmsTable$8=ServerConfiguration_get_realmsTable(config);
        char *return_value_ServerRealm_get_realmName$9;
        return_value_ServerRealm_get_realmName$9=ServerRealm_get_realmName(return_value_ServerConfiguration_get_realmsTable$8[(signed long int)i]);
        if(return_value_ServerRealm_get_realmName$9 == ((char *)NULL))
          return i;

      }

    }

  }

  return -1;
}

// get_ssl_error
// file make_ssl_handshake.c line 75
signed int get_ssl_error(struct anonymous$1 *sf, char *info, signed int result)
{
  signed int merror;
  char err_buff[200l];
  struct ssl_st *return_value_SslFd_get_ssl$1;
  return_value_SslFd_get_ssl$1=SslFd_get_ssl(sf);
  merror=SSL_get_error(return_value_SslFd_get_ssl$1, result);
  unsigned long int return_value_ERR_get_error$2;
  char *return_value_ERR_error_string$3;
  switch(merror)
  {
    case 0:
    {
      aflog((char)16, (char)32, "%s(%d): none", info, result);
      break;
    }
    case 6:
    {
      aflog((char)16, (char)32, "%s(%d): zero", info, result);
      break;
    }
    case 2:
    {
      aflog((char)16, (char)32, "%s(%d): w_read", info, result);
      break;
    }
    case 3:
    {
      aflog((char)16, (char)32, "%s(%d): w_write", info, result);
      break;
    }
    case 7:
    {
      aflog((char)16, (char)32, "%s(%d): w_connect", info, result);
      break;
    }
    case 4:
    {
      aflog((char)16, (char)32, "%s(%d): w_x509_lookup", info, result);
      break;
    }
    case 5:
    {
      aflog((char)16, (char)32, "%s(%d): syscall", info, result);
      break;
    }
    case 1:
    {
      SSL_load_error_strings();
      return_value_ERR_get_error$2=ERR_get_error();
      return_value_ERR_error_string$3=ERR_error_string(return_value_ERR_get_error$2, err_buff);
      aflog((char)16, (char)32, "%s(%d): ssl:%s", info, result, return_value_ERR_error_string$3);
      break;
    }
    default:
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      aflog((char)16, (char)32, "%s(%d): unrecognized error (%d)", info, result, *return_value___errno_location$4);
    }
  }
  if(merror == 2 || merror == 3)
    return 1;

  else
    return 2;
}

// get_store_filename
// file first_run.c line 376
char * get_store_filename()
{
  return home_dir_store;
}

// get_username
// file usernames.h line 27
signed int get_username(struct anonymous$5 *pointer, signed int user)
{
  struct anonymous$4 **return_value_ServerRealm_get_usersTable$1;
  return_value_ServerRealm_get_usersTable$1=ServerRealm_get_usersTable(pointer);
  signed int return_value_ConnectUser_get_userId$2;
  return_value_ConnectUser_get_userId$2=ConnectUser_get_userId(return_value_ServerRealm_get_usersTable$1[(signed long int)user]);
  return return_value_ConnectUser_get_userId$2;
}

// get_usernumber
// file usernames.h line 28
signed int get_usernumber(struct anonymous$5 *pointer, signed int userid)
{
  signed int i = 0;
  signed int return_value_ServerRealm_get_usersLimit$1;
  do
  {
    return_value_ServerRealm_get_usersLimit$1=ServerRealm_get_usersLimit(pointer);
    if(i >= return_value_ServerRealm_get_usersLimit$1)
      break;

    struct anonymous$4 **return_value_ServerRealm_get_usersTable$2;
    return_value_ServerRealm_get_usersTable$2=ServerRealm_get_usersTable(pointer);
    signed int return_value_ConnectUser_get_userId$3;
    return_value_ConnectUser_get_userId$3=ConnectUser_get_userId(return_value_ServerRealm_get_usersTable$2[(signed long int)i]);
    if(userid == return_value_ConnectUser_get_userId$3)
      return i;

    i = i + 1;
  }
  while((_Bool)1);
  return -1;
}

// getcg
// file stats.c line 73
signed long int getcg(void)
{
  return compressgained;
}

// getdateformat
// file logging.h line 65
char * getdateformat()
{
  return format;
}

// getloglisthead
// file logging.h line 67
struct llnode * getloglisthead()
{
  return head;
}

// http_proxy_server
// file http_proxy_server.c line 83
void * http_proxy_server(void *vptr)
{
  signed int listenfd;
  signed int afserverfd;
  struct anonymous$1 *connFd;
  struct sockaddr *cliaddr;
  char tab[9000l];
  struct anonymous$27 *table;
  struct anonymous$26 hdr;
  signed int i;
  signed int n;
  signed int maxfdp1;
  struct anonymous$22 rset;
  struct anonymous$22 allset;
  struct timeval tv;
  signed int maxclients;
  signed int tmp;
  signed int timeout = 5;
  unsigned int *addrlenp;
  unsigned int addrlen;
  char type;
  char nothttp;
  char https;
  char *host;
  char *serv;
  char *name = "";
  struct ssl_ctx_st *ctx;
  struct anonymous$28 *proxy_argptr;
  start_critical_section();
  proxy_argptr = (struct anonymous$28 *)vptr;
  afserverfd = proxy_argptr->sockfd;
  host = proxy_argptr->host;
  serv = proxy_argptr->serv;
  addrlenp = proxy_argptr->addrlenp;
  type = proxy_argptr->type;
  maxclients = proxy_argptr->limit + 1;
  https = proxy_argptr->https;
  ctx = proxy_argptr->ctx;
  if(!(https == 0))
    name = "s";

  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)maxclients, sizeof(struct anonymous$27) /*18104ul*/ );
  table = (struct anonymous$27 *)return_value_calloc$1;
  if(table == ((struct anonymous$27 *)NULL))
  {
    aflog((char)4, (char)1, "http%s proxy: Can't allocate memory... exiting.", name);
    exit(1);
  }

  i = 0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$9;
  struct ssl_st *return_value_SslFd_get_ssl$8;
  _Bool tmp_if_expr$11;
  struct ssl_st *return_value_SslFd_get_ssl$10;
  for( ; !(i >= maxclients); i = i + 1)
  {
    (table + (signed long int)i)->postFd=SslFd_new();
    (table + (signed long int)i)->getFd=SslFd_new();
    (table + (signed long int)i)->tmpFd=SslFd_new();
    if((table + (signed long int)i)->postFd == ((struct anonymous$1 *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (table + (signed long int)i)->getFd == (struct anonymous$1 *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (table + (signed long int)i)->tmpFd == (struct anonymous$1 *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      aflog((char)4, (char)1, "http%s proxy: Can't allocate memory... exiting.", name);
      exit(1);
    }

    if(!(https == 0))
    {
      struct ssl_st *return_value_SSL_new$4;
      return_value_SSL_new$4=SSL_new(ctx);
      SslFd_set_ssl((table + (signed long int)i)->postFd, return_value_SSL_new$4);
      struct ssl_st *return_value_SSL_new$5;
      return_value_SSL_new$5=SSL_new(ctx);
      SslFd_set_ssl((table + (signed long int)i)->getFd, return_value_SSL_new$5);
      struct ssl_st *return_value_SSL_new$6;
      return_value_SSL_new$6=SSL_new(ctx);
      SslFd_set_ssl((table + (signed long int)i)->tmpFd, return_value_SSL_new$6);
      struct ssl_st *return_value_SslFd_get_ssl$7;
      return_value_SslFd_get_ssl$7=SslFd_get_ssl((table + (signed long int)i)->postFd);
      if(return_value_SslFd_get_ssl$7 == ((struct ssl_st *)NULL))
        tmp_if_expr$9 = (_Bool)1;

      else
      {
        return_value_SslFd_get_ssl$8=SslFd_get_ssl((table + (signed long int)i)->getFd);
        tmp_if_expr$9 = return_value_SslFd_get_ssl$8 == (struct ssl_st *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$9)
        tmp_if_expr$11 = (_Bool)1;

      else
      {
        return_value_SslFd_get_ssl$10=SslFd_get_ssl((table + (signed long int)i)->tmpFd);
        tmp_if_expr$11 = return_value_SslFd_get_ssl$10 == (struct ssl_st *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$11)
      {
        aflog((char)4, (char)1, "http%s proxy: Can't allocate memory... exiting.", name);
        exit(1);
      }

    }

  }
  connFd=SslFd_new();
  if(connFd == ((struct anonymous$1 *)NULL))
  {
    aflog((char)4, (char)1, "http%s proxy: Can't allocate memory... exiting.", name);
    exit(1);
  }

  if(!(https == 0))
  {
    struct ssl_st *return_value_SSL_new$12;
    return_value_SSL_new$12=SSL_new(ctx);
    SslFd_set_ssl(connFd, return_value_SSL_new$12);
    struct ssl_st *return_value_SslFd_get_ssl$13;
    return_value_SslFd_get_ssl$13=SslFd_get_ssl(connFd);
    if(return_value_SslFd_get_ssl$13 == ((struct ssl_st *)NULL))
    {
      aflog((char)4, (char)1, "http%s proxy: Can't allocate memory... exiting.", name);
      exit(1);
    }

  }

  signed int return_value_ip_listen$14;
  return_value_ip_listen$14=ip_listen(&listenfd, host, serv, addrlenp, type);
  if(!(return_value_ip_listen$14 == 0))
  {
    aflog((char)4, (char)1, "http%s proxy: Can't listen on %s:%s", name, host, serv);
    exit(1);
  }

  void *return_value_malloc$15;
  return_value_malloc$15=malloc((unsigned long int)*addrlenp);
  cliaddr = (struct sockaddr *)return_value_malloc$15;
  addrlen = *addrlenp;
  addrlenp = &addrlen;
  broadcast_condition();
  end_critical_section();
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$22) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&allset)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&allset)->__fds_bits[(signed long int)(listenfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(listenfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << listenfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
  maxfdp1 = listenfd + 1;
  tv.tv_usec = (signed long int)0;
  tv.tv_sec = (signed long int)timeout;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$17;
  _Bool tmp_if_expr$19;
  _Bool tmp_if_expr$27;
  signed int tmp_statement_expression$40;
  while((_Bool)1)
  {
    rset = allset;
    signed int return_value_select$18;
    return_value_select$18=select(maxfdp1, &rset, (struct anonymous$22 *)(void *)0, (struct anonymous$22 *)(void *)0, &tv);
    if(return_value_select$18 == 0)
    {
      aflog((char)16, (char)4, "http%s proxy: timeout", name);
      tv.tv_sec = (signed long int)timeout;
      i = 0;
      for( ; !(i >= maxclients); i = i + 1)
      {
        if((signed int)(table + (signed long int)i)->state == 0)
          tmp_if_expr$16 = (_Bool)1;

        else
          tmp_if_expr$16 = ((signed int)(table + (signed long int)i)->state & 2) != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$16)
          tmp_if_expr$17 = (_Bool)1;

        else
          tmp_if_expr$17 = (signed int)(table + (signed long int)i)->type == 1 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$17)
        {
          aflog((char)16, (char)4, "http%s proxy: send T to table[%d].getfd", name, i);
          if(1 + (table + (signed long int)i)->sent_ptr >= 90000)
          {
            http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)"T", 1);
            (table + (signed long int)i)->sent_ptr = 0;
            clear_sslFd((table + (signed long int)i)->getFd, &allset);
            (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << (table + (signed long int)i)->sockfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
            (table + (signed long int)i)->state = (table + (signed long int)i)->state | (char)2;
          }

          else
          {
            http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)"T", 1);
            (table + (signed long int)i)->sent_ptr = (table + (signed long int)i)->sent_ptr + 1;
          }
        }

      }
    }

    else
    {
      i = 0;
      for( ; !(i >= maxclients); i = i + 1)
      {
        if((signed int)(table + (signed long int)i)->state == 0)
          tmp_if_expr$19 = (_Bool)1;

        else
          tmp_if_expr$19 = (signed int)(table + (signed long int)i)->type == 1 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr$19)
        {
          if((2 & (signed int)(table + (signed long int)i)->state) == 0)
          {
            if(!((rset.__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / 8)] & 1l << (table + (signed long int)i)->sockfd % 8) == 0l))
            {
              aflog((char)16, (char)4, "http%s proxy: FD_ISSET(table[%d].sockfd)", name, i);
              signed long int return_value_read$20;
              return_value_read$20=read((table + (signed long int)i)->sockfd, (void *)((table + (signed long int)i)->buf + (signed long int)5), (unsigned long int)8995);
              n = (signed int)return_value_read$20;
              if(!(n >= 1))
              {
                http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)"Q", 1);
                delete_user(table, i, &allset);
                goto __CPROVER_DUMP_L51;
              }

              (table + (signed long int)i)->buf[(signed long int)0] = (char)77;
              unsigned int return_value___bswap_32$21;
              return_value___bswap_32$21=__bswap_32$link1((unsigned int)n);
              tmp = (signed int)return_value___bswap_32$21;
              memcpy((void *)&(table + (signed long int)i)->buf[(signed long int)1], (const void *)&tmp, (unsigned long int)4);
              if(5 + (table + (signed long int)i)->sent_ptr + n >= 90000)
              {
                http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)(table + (signed long int)i)->buf, 90000 - (table + (signed long int)i)->sent_ptr);
                (table + (signed long int)i)->ptr = 90000 - (table + (signed long int)i)->sent_ptr;
                (table + (signed long int)i)->length = (5 + n) - (table + (signed long int)i)->ptr;
                (table + (signed long int)i)->sent_ptr = 0;
                clear_sslFd((table + (signed long int)i)->getFd, &allset);
                (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << (table + (signed long int)i)->sockfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                (table + (signed long int)i)->state = (table + (signed long int)i)->state | (char)2;
                goto __CPROVER_DUMP_L51;
              }

              else
              {
                http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)(table + (signed long int)i)->buf, n + 5);
                (table + (signed long int)i)->sent_ptr = (table + (signed long int)i)->sent_ptr + n + 5;
              }
            }

          }

          signed int return_value_SslFd_get_fd$22;
          return_value_SslFd_get_fd$22=SslFd_get_fd((table + (signed long int)i)->getFd);
          signed int return_value_SslFd_get_fd$23;
          return_value_SslFd_get_fd$23=SslFd_get_fd((table + (signed long int)i)->getFd);
          if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd$22 / 8)] & 1l << return_value_SslFd_get_fd$23 % 8) == 0l))
          {
            aflog((char)16, (char)4, "http%s proxy: FD_ISSET(table[%d].getfd)", name, i);
            delete_user(table, i, &allset);
          }

          else
          {
            signed int return_value_SslFd_get_fd$28;
            return_value_SslFd_get_fd$28=SslFd_get_fd((table + (signed long int)i)->postFd);
            signed int return_value_SslFd_get_fd$29;
            return_value_SslFd_get_fd$29=SslFd_get_fd((table + (signed long int)i)->postFd);
            if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd$28 / 8)] & 1l << return_value_SslFd_get_fd$29 % 8) == 0l))
            {
              aflog((char)16, (char)4, "http%s proxy: FD_ISSET(table[%d].postfd)", name, i);
              n=http_read(https, (table + (signed long int)i)->postFd, (unsigned char *)tab, 9000);
              if(!(n == 0))
              {
                (table + (signed long int)i)->received = (table + (signed long int)i)->received + n;
                signed int return_value_read_message$24;
                return_value_read_message$24=read_message((table + (signed long int)i)->sockfd, n, &table[(signed long int)i], tab, 0);
                if(!(return_value_read_message$24 == 0))
                  delete_user(table, i, &allset);

              }

              if(n == 0)
                tmp_if_expr$27 = (_Bool)1;

              else
                tmp_if_expr$27 = (table + (signed long int)i)->received == 90000 ? (_Bool)1 : (_Bool)0;
              if(!tmp_if_expr$27)
                goto __CPROVER_DUMP_L50;

              (table + (signed long int)i)->received = 0;
              clear_sslFd((table + (signed long int)i)->postFd, &allset);
              (table + (signed long int)i)->state = (table + (signed long int)i)->state | (char)1;
              if((2 & (signed int)(table + (signed long int)i)->state) == 0)
              {
                aflog((char)16, (char)4, "http%s proxy: send A to table[%d].getfd", name, i);
                if(1 + (table + (signed long int)i)->sent_ptr >= 90000)
                {
                  http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)"A", 1);
                  (table + (signed long int)i)->sent_ptr = 0;
                  clear_sslFd((table + (signed long int)i)->getFd, &allset);
                  (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << (table + (signed long int)i)->sockfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  (table + (signed long int)i)->state = (table + (signed long int)i)->state | (char)2;
                }

                else
                {
                  http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)"A", 1);
                  (table + (signed long int)i)->sent_ptr = (table + (signed long int)i)->sent_ptr + 1;
                }
              }

              else
                (table + (signed long int)i)->state = (table + (signed long int)i)->state | (char)8;
              if((signed int)(table + (signed long int)i)->tmpstate == 1)
              {
                aflog((char)16, (char)2, "http%s proxy: get old POST request...", name);
                (table + (signed long int)i)->state = (table + (signed long int)i)->state & (char)~1;
                SslFd_swap_content((table + (signed long int)i)->postFd, (table + (signed long int)i)->tmpFd);
                signed int return_value_SslFd_get_fd$25;
                return_value_SslFd_get_fd$25=SslFd_get_fd((table + (signed long int)i)->postFd);
                set_fd(return_value_SslFd_get_fd$25, &maxfdp1, &allset);
                (table + (signed long int)i)->tmpstate = (char)0;
                if(!((table + (signed long int)i)->tmpheader.length == 0))
                {
                  (table + (signed long int)i)->received = (table + (signed long int)i)->received + (table + (signed long int)i)->tmpheader.length;
                  signed int return_value_read_message$26;
                  return_value_read_message$26=read_message((table + (signed long int)i)->sockfd, (table + (signed long int)i)->tmpheader.length, &table[(signed long int)i], (table + (signed long int)i)->tmpbuf, (table + (signed long int)i)->tmpheader.ptr);
                  if(!(return_value_read_message$26 == 0))
                    delete_user(table, i, &allset);

                }

              }

            }

            else

              __CPROVER_DUMP_L50:
                ;
          }
        }


      __CPROVER_DUMP_L51:
        ;
      }
      i = 0;
      for( ; !(i >= maxclients); i = i + 1)
      {
        if((signed int)(table + (signed long int)i)->state == 4)
        {
          if((signed int)(table + (signed long int)i)->type == 1)
          {
            if(!((rset.__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / 8)] & 1l << (table + (signed long int)i)->sockfd % 8) == 0l))
            {
              signed long int return_value_read$30;
              return_value_read$30=read((table + (signed long int)i)->sockfd, (void *)(table + (signed long int)i)->buf, (unsigned long int)9000);
              n = (signed int)return_value_read$30;
              if(n >= 1)
              {
                signed int return_value_SslFd_get_fd$31;
                return_value_SslFd_get_fd$31=SslFd_get_fd((table + (signed long int)i)->postFd);
                writen(return_value_SslFd_get_fd$31, (unsigned char *)(table + (signed long int)i)->buf, n);
              }

              else
              {
                delete_user(table, i, &allset);
                goto __CPROVER_DUMP_L60;
              }
            }

            signed int return_value_SslFd_get_fd$34;
            return_value_SslFd_get_fd$34=SslFd_get_fd((table + (signed long int)i)->postFd);
            signed int return_value_SslFd_get_fd$35;
            return_value_SslFd_get_fd$35=SslFd_get_fd((table + (signed long int)i)->postFd);
            if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd$34 / 8)] & 1l << return_value_SslFd_get_fd$35 % 8) == 0l))
            {
              signed int return_value_SslFd_get_fd$32;
              return_value_SslFd_get_fd$32=SslFd_get_fd((table + (signed long int)i)->postFd);
              signed long int return_value_read$33;
              return_value_read$33=read(return_value_SslFd_get_fd$32, (void *)tab, (unsigned long int)9000);
              n = (signed int)return_value_read$33;
              if(n >= 1)
                writen((table + (signed long int)i)->sockfd, (unsigned char *)tab, n);

              else
              {
                delete_user(table, i, &allset);
                goto __CPROVER_DUMP_L60;
              }
            }

          }

        }


      __CPROVER_DUMP_L60:
        ;
      }
      if(!((rset.__fds_bits[(signed long int)(listenfd / 8)] & 1l << listenfd % 8) == 0l))
      {
        aflog((char)16, (char)4, "http%s proxy: FD_ISSET(listenfd)", name);
        tmp=accept(listenfd, cliaddr, addrlenp);
        if(!(tmp == -1))
        {
          aflog((char)16, (char)2, "http%s proxy: New connection...", name);
          SslFd_set_fd(connFd, tmp);
          if(!(https == 0))
          {
            make_ssl_initialize(connFd);
            signed int return_value_make_ssl_accept$38;
            return_value_make_ssl_accept$38=make_ssl_accept(connFd);
            if(!(return_value_make_ssl_accept$38 == 0))
            {
              aflog((char)16, (char)2, "https proxy: DENIED by SSL_accept");
              signed int return_value_SslFd_get_fd$36;
              return_value_SslFd_get_fd$36=SslFd_get_fd(connFd);
              close(return_value_SslFd_get_fd$36);
              struct ssl_st *return_value_SslFd_get_ssl$37;
              return_value_SslFd_get_ssl$37=SslFd_get_ssl(connFd);
              SSL_clear(return_value_SslFd_get_ssl$37);
              continue;
            }

          }

        }

        else
        {
          aflog((char)16, (char)2, "http%s proxy: New connection --> EAGAIN", name);
          continue;
        }
        memset((void *)tab, 0, (unsigned long int)9000);
        nothttp = (char)0;
        signed int return_value_parse_header$39;
        return_value_parse_header$39=parse_header(connFd, tab, &hdr, https);
        if(!(return_value_parse_header$39 == 0))
        {
          nothttp = (char)1;
          aflog((char)16, (char)2, "http%s proxy: no http header...", name);
        }

        n = -1;
        i = 0;
        for( ; !(i >= maxclients); i = i + 1)
          if((signed int)(table + (signed long int)i)->state == 0)
          {
            if(n == -1)
              n = i;

          }

          else
            if(nothttp == 0)
            {
              unsigned long int __s1_len;
              unsigned long int __s2_len;
              signed int return_value___builtin_strcmp$41;
              return_value___builtin_strcmp$41=__builtin_strcmp((table + (signed long int)i)->id, hdr.id);
              tmp_statement_expression$40 = return_value___builtin_strcmp$41;
              if(tmp_statement_expression$40 == 0)
                break;

            }

        if(!(i >= maxclients))
        {
          aflog((char)16, (char)2, "http%s proxy: the client exist...", name);
          if((signed int)hdr.type == 0)
          {
            aflog((char)16, (char)2, "http%s proxy: type GET...", name);
            if((2 & (signed int)(table + (signed long int)i)->state) == 0)
            {
              aflog((char)16, (char)2, "http%s proxy: not waiting for GET...", name);
              (table + (signed long int)i)->sent_ptr = 0;
              (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)((table + (signed long int)i)->sockfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << (table + (signed long int)i)->sockfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
              clear_sslFd((table + (signed long int)i)->getFd, &allset);
              (table + (signed long int)i)->state = (table + (signed long int)i)->state | (char)2;
            }

            if((4 & (signed int)(table + (signed long int)i)->state) == 0)
            {
              aflog((char)16, (char)2, "http%s proxy: not opened...", name);
              signed int return_value_afserver_connect$44;
              return_value_afserver_connect$44=afserver_connect(&(table + (signed long int)i)->sockfd, afserverfd, cliaddr, addrlenp, (char)1);
              if(!(return_value_afserver_connect$44 == 0))
              {
                memset((void *)tab, 0, (unsigned long int)9000);
                sprintf(tab, "HTTP/1.1 400 Bad Request\r\n\r\n");
                unsigned long int return_value_strlen$42;
                return_value_strlen$42=strlen(tab);
                n = (signed int)return_value_strlen$42;
                http_write(https, connFd, (unsigned char *)tab, n);
                close_fd(&connFd->fd);
                struct ssl_st *return_value_SslFd_get_ssl$43;
                return_value_SslFd_get_ssl$43=SslFd_get_ssl(connFd);
                SSL_clear(return_value_SslFd_get_ssl$43);
                clear_sslFd((table + (signed long int)i)->postFd, &allset);
                (table + (signed long int)i)->state = (char)0;
                continue;
              }

              (table + (signed long int)i)->state = (table + (signed long int)i)->state | (char)4;
              aflog((char)16, (char)2, "http%s proxy: OPEN...", name);
            }

            (table + (signed long int)i)->state = (table + (signed long int)i)->state & (char)~2;
            (table + (signed long int)i)->sent_ptr = 0;
            SslFd_swap_content((table + (signed long int)i)->getFd, connFd);
            set_fd((table + (signed long int)i)->sockfd, &maxfdp1, &allset);
            signed int return_value_SslFd_get_fd$45;
            return_value_SslFd_get_fd$45=SslFd_get_fd((table + (signed long int)i)->getFd);
            set_fd(return_value_SslFd_get_fd$45, &maxfdp1, &allset);
            memset((void *)tab, 0, (unsigned long int)9000);
            sprintf(tab, "HTTP/1.1 200 OK\r\nContent-Length: 90000\r\nConnection: close\r\nPragma: no-cache\r\nCache-Control: no-cache, no-store, must-revalidate\r\nExpires: 0\r\nContent-Type: text/html\r\n\r\n");
            unsigned long int return_value_strlen$46;
            return_value_strlen$46=strlen(tab);
            n = (signed int)return_value_strlen$46;
            signed int return_value_SslFd_get_fd$47;
            return_value_SslFd_get_fd$47=SslFd_get_fd((table + (signed long int)i)->getFd);
            signed int return_value_writen$48;
            return_value_writen$48=writen(return_value_SslFd_get_fd$47, (unsigned char *)tab, n);
            if(!(return_value_writen$48 >= 1))
            {
              delete_user(table, i, &allset);
              continue;
            }

            if(!((table + (signed long int)i)->length == 0))
            {
              signed int return_value_SslFd_get_fd$49;
              return_value_SslFd_get_fd$49=SslFd_get_fd((table + (signed long int)i)->getFd);
              signed int return_value_writen$50;
              return_value_writen$50=writen(return_value_SslFd_get_fd$49, (unsigned char *)((table + (signed long int)i)->buf + (signed long int)(table + (signed long int)i)->ptr), (table + (signed long int)i)->length);
              if(!(return_value_writen$50 >= 1))
              {
                delete_user(table, i, &allset);
                continue;
              }

            }

            (table + (signed long int)i)->sent_ptr = (table + (signed long int)i)->length;
            (table + (signed long int)i)->ptr = 0;
            (table + (signed long int)i)->length = 0;
            if(!((8 & (signed int)(table + (signed long int)i)->state) == 0))
            {
              aflog((char)16, (char)4, "http%s proxy: send A to table[%d].getfd", name, i);
              http_write(https, (table + (signed long int)i)->getFd, (unsigned char *)"A", 1);
              (table + (signed long int)i)->sent_ptr = (table + (signed long int)i)->sent_ptr + 1;
              (table + (signed long int)i)->state = (table + (signed long int)i)->state & (char)~8;
            }

          }

          else
            if((signed int)hdr.type == 1)
            {
              aflog((char)16, (char)2, "http%s proxy: type POST...", name);
              if((1 & (signed int)(table + (signed long int)i)->state) == 0)
              {
                aflog((char)16, (char)2, "http%s proxy: unexpected POST request...", name);
                if((signed int)(table + (signed long int)i)->tmpstate == 0)
                {
                  aflog((char)16, (char)2, "http%s proxy: buffering POST request...", name);
                  (table + (signed long int)i)->tmpstate = (char)1;
                  SslFd_swap_content((table + (signed long int)i)->tmpFd, connFd);
                  memcpy((void *)(table + (signed long int)i)->tmpbuf, (const void *)tab, (unsigned long int)9000);
                  (table + (signed long int)i)->tmpheader = hdr;
                }

                else
                {
                  aflog((char)16, (char)2, "http%s proxy: no space to buffer POST request (received from first postfd: %d)", name, (table + (signed long int)i)->received);
                  delete_user(table, i, &allset);
                }
              }

              else
              {
                if(!(hdr.length == 0))
                {
                  (table + (signed long int)i)->received = (table + (signed long int)i)->received + hdr.length;
                  signed int return_value_read_message$51;
                  return_value_read_message$51=read_message((table + (signed long int)i)->sockfd, hdr.length, &table[(signed long int)i], tab, hdr.ptr);
                  if(!(return_value_read_message$51 == 0))
                    delete_user(table, i, &allset);

                }

                (table + (signed long int)i)->state = (table + (signed long int)i)->state & (char)~1;
                SslFd_swap_content((table + (signed long int)i)->postFd, connFd);
                signed int return_value_SslFd_get_fd$52;
                return_value_SslFd_get_fd$52=SslFd_get_fd((table + (signed long int)i)->postFd);
                set_fd(return_value_SslFd_get_fd$52, &maxfdp1, &allset);
              }
            }

            else
            {
              aflog((char)16, (char)2, "http%s proxy: unrecognized type...", name);
              delete_user(table, i, &allset);
            }
        }

        else
          if(!(n == -1))
          {
            aflog((char)16, (char)2, "http%s proxy: there are free slots...", name);
            if(nothttp == 0)
            {
              aflog((char)16, (char)2, "http%s proxy: http header...", name);
              if((signed int)hdr.type == 1)
              {
                aflog((char)16, (char)2, "http%s proxy: type POST...", name);
                (table + (signed long int)n)->state = (char)2;
                memcpy((void *)(table + (signed long int)n)->id, (const void *)hdr.id, (unsigned long int)9);
                SslFd_swap_content((table + (signed long int)n)->postFd, connFd);
                signed int return_value_SslFd_get_fd$53;
                return_value_SslFd_get_fd$53=SslFd_get_fd((table + (signed long int)n)->postFd);
                set_fd(return_value_SslFd_get_fd$53, &maxfdp1, &allset);
              }

              else
              {
                aflog((char)16, (char)2, "http%s proxy: closing this connection... (not POST type)", name);
                close_fd(&connFd->fd);
                if(!(https == 0))
                {
                  struct ssl_st *return_value_SslFd_get_ssl$54;
                  return_value_SslFd_get_ssl$54=SslFd_get_ssl(connFd);
                  SSL_clear(return_value_SslFd_get_ssl$54);
                }

                continue;
              }
            }

            else
            {
              (table + (signed long int)n)->state = (char)4;
              signed int return_value_SslFd_get_fd$55;
              return_value_SslFd_get_fd$55=SslFd_get_fd(connFd);
              SslFd_set_fd((table + (signed long int)n)->postFd, return_value_SslFd_get_fd$55);
              (table + (signed long int)n)->type = (char)1;
              signed int return_value_SslFd_get_fd$56;
              return_value_SslFd_get_fd$56=SslFd_get_fd((table + (signed long int)n)->postFd);
              set_fd(return_value_SslFd_get_fd$56, &maxfdp1, &allset);
              signed int return_value_afserver_connect$57;
              return_value_afserver_connect$57=afserver_connect(&(table + (signed long int)n)->sockfd, afserverfd, cliaddr, addrlenp, (char)0);
              if(!(return_value_afserver_connect$57 == 0))
              {
                clear_sslFd((table + (signed long int)n)->postFd, &allset);
                (table + (signed long int)n)->state = (char)0;
                continue;
              }

              set_fd((table + (signed long int)n)->sockfd, &maxfdp1, &allset);
              write((table + (signed long int)n)->sockfd, (const void *)tab, (unsigned long int)hdr.allreaded);
            }
          }

          else
          {
            aflog((char)16, (char)2, "http%s proxy: closing this connection... (no free slots)", name);
            close_fd(&connFd->fd);
            continue;
          }
      }

    }
  }
  return NULL;
}

// http_read
// file http_proxy_functions.c line 402
signed int http_read(char https, struct anonymous$1 *sf, unsigned char *buf, signed int amount)
{
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl$1;
    return_value_SslFd_get_ssl$1=SslFd_get_ssl(sf);
    signed int return_value_SSL_read$2;
    return_value_SSL_read$2=SSL_read(return_value_SslFd_get_ssl$1, (void *)buf, amount);
    return return_value_SSL_read$2;
  }

  else
  {
    signed int return_value_SslFd_get_fd$3;
    return_value_SslFd_get_fd$3=SslFd_get_fd(sf);
    signed long int return_value_read$4;
    return_value_read$4=read(return_value_SslFd_get_fd$3, (void *)buf, (unsigned long int)amount);
    return (signed int)return_value_read$4;
  }
}

// http_write
// file http_proxy_functions.c line 381
signed int http_write(char https, struct anonymous$1 *sf, unsigned char *buf, signed int amount)
{
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl$1;
    return_value_SslFd_get_ssl$1=SslFd_get_ssl(sf);
    signed int return_value_SSL_writen$2;
    return_value_SSL_writen$2=SSL_writen(return_value_SslFd_get_ssl$1, buf, amount);
    return return_value_SSL_writen$2;
  }

  else
  {
    signed int return_value_SslFd_get_fd$3;
    return_value_SslFd_get_fd$3=SslFd_get_fd(sf);
    signed int return_value_writen$4;
    return_value_writen$4=writen(return_value_SslFd_get_fd$3, buf, amount);
    return return_value_writen$4;
  }
}

// initialize_http_proxy_server
// file http_proxy_server.h line 27
signed int initialize_http_proxy_server(signed int *sockfd, const char *host, const char *serv, unsigned int *addrlenp, const char type, signed int limit, char https, struct ssl_ctx_st *ctx)
{
  signed int retval;
  signed int sockets[2l];
  unsigned long int proxy_thread;
  signed int return_value_socketpair$1;
  return_value_socketpair$1=socketpair(1, 1, 0, sockets);
  if(!(return_value_socketpair$1 == 0))
    return 1;

  else
  {
    *sockfd = sockets[(signed long int)0];
    start_critical_section();
    static struct anonymous$28 arg;
    arg.host = (char *)host;
    arg.serv = (char *)serv;
    arg.addrlenp = addrlenp;
    arg.limit = limit;
    arg.type = (char)type;
    arg.sockfd = sockets[(signed long int)1];
    arg.https = https;
    arg.ctx = ctx;
    retval=pthread_create(&proxy_thread, (const union pthread_attr_t *)(void *)0, http_proxy_server, (void *)&arg);
    wait_for_condition();
    end_critical_section();
    return retval;
  }
}

// initializelogging
// file logging.h line 71
void initializelogging(char verl, char *dateformat)
{
  signed int k;
  k=loginit(verl, dateformat);
  if(!(k == 0))
  {
    switch(k)
    {
      case 1:
      {
        printf("Wrong format of the logcmd\n");
        break;
      }
      case 2:
      {
        printf("Unknown type of the logging target\n");
        break;
      }
      case 3:
      {
        printf("Wrong description of the logging target (name too long)\n");
        break;
      }
      case 4:
      {
        printf("Can't open file to log to\n");
        break;
      }
      case 5:
      {
        printf("Can't connect to target host\n");
        break;
      }
      case 6:
        printf("Wrong msgtype/importance description\n");
    }
    exit(1);
  }

}

// ip_connect
// file network.c line 186
signed int ip_connect(signed int *sockfd, const char *host, const char *serv, const char type, const char *lhost, const char *lserv)
{
  const signed int on = 1;
  signed int n;
  signed int bindFailed;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *ressave;
  struct addrinfo lhints;
  struct addrinfo *lres;
  struct addrinfo *lressave = (struct addrinfo *)(void *)0;
  aflog((char)4, (char)4, "ip_connect: host=[%s] serv=[%s], type=[%d], lhost=[%s], lserv=[%s]", host, serv, type, lhost, lserv);
  bzero((void *)&hints, sizeof(struct addrinfo) /*48ul*/ );
  if(!((0x02 & (signed int)type) == 0))
    hints.ai_family = 2;

  else
    if(!((0x04 & (signed int)type) == 0))
      hints.ai_family = 10;

    else
      hints.ai_family = 0;
  if(!((0x01 & (signed int)type) == 0))
    hints.ai_socktype = 1;

  else
    hints.ai_socktype = 2;
  lhints = hints;
  if(!(lhost == ((const char *)NULL)) || !(lserv == ((const char *)NULL)))
  {
    n=getaddrinfo(lhost, lserv, &lhints, &lres);
    if(!(n == 0))
      return n;

    lressave = lres;
  }

  n=getaddrinfo(host, serv, &hints, &res);
  if(!(n == 0))
    return n;

  else
  {
    ressave = res;
    do
    {
      *sockfd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
      if(*sockfd >= 0)
      {
        if(!((0x01 & (signed int)type) == 0))
          setsockopt(*sockfd, 1, 9, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );

        bindFailed = 0;
        if(!(lhost == ((const char *)NULL)) || !(lserv == ((const char *)NULL)))
        {
          bindFailed = 1;
          lres = lressave;
          do
          {
            signed int return_value_bind$1;
            return_value_bind$1=bind(*sockfd, lres->ai_addr, lres->ai_addrlen);
            if(return_value_bind$1 == 0)
            {
              bindFailed = 0;
              break;
            }

            lres = lres->ai_next;
          }
          while(!(lres == ((struct addrinfo *)NULL)));
        }

        if(bindFailed == 1)
          close(*sockfd);

        else
        {
          signed int return_value_connect$2;
          return_value_connect$2=connect(*sockfd, res->ai_addr, res->ai_addrlen);
          if(return_value_connect$2 == 0)
            break;

          close(*sockfd);
        }
      }

      res = res->ai_next;
    }
    while(!(res == ((struct addrinfo *)NULL)));
    if(res == ((struct addrinfo *)NULL))
      return 1;

    else
    {
      if(!(lhost == ((const char *)NULL)) || !(lserv == ((const char *)NULL)))
        freeaddrinfo(lressave);

      freeaddrinfo(ressave);
      return 0;
    }
  }
}

// ip_listen
// file network.h line 39
signed int ip_listen(signed int *sockfd, const char *host, const char *serv, unsigned int *addrlenp, const char type)
{
  const signed int on = 1;
  signed int n;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *ressave;
  aflog((char)4, (char)4, "ip_listen: host=[%s] serv=[%s], type=[%d]", host, serv, type);
  bzero((void *)&hints, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_flags = 0x0001;
  if(!((0x02 & (signed int)type) == 0))
    hints.ai_family = 2;

  else
    if(!((0x04 & (signed int)type) == 0))
      hints.ai_family = 10;

    else
      hints.ai_family = 0;
  if(!((0x01 & (signed int)type) == 0))
    hints.ai_socktype = 1;

  else
    hints.ai_socktype = 2;
  n=getaddrinfo(host, serv, &hints, &res);
  if(!(n == 0))
    return n;

  else
  {
    ressave = res;
    do
    {
      *sockfd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
      if(*sockfd >= 0)
      {
        if(!((0x01 & (signed int)type) == 0))
        {
          setsockopt(*sockfd, 1, 2, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );
          setsockopt(*sockfd, 1, 9, (const void *)&on, (unsigned int)sizeof(const signed int) /*4ul*/ );
        }

        signed int return_value_bind$1;
        return_value_bind$1=bind(*sockfd, res->ai_addr, res->ai_addrlen);
        if(return_value_bind$1 == 0)
          break;

        close(*sockfd);
      }

      res = res->ai_next;
    }
    while(!(res == ((struct addrinfo *)NULL)));
    if(res == ((struct addrinfo *)NULL))
      return 1;

    else
    {
      if(!((0x01 & (signed int)type) == 0))
        listen(*sockfd, 1);

      if(!(addrlenp == ((unsigned int *)NULL)))
        *addrlenp = res->ai_addrlen;

      freeaddrinfo(ressave);
      return 0;
    }
  }
}

// is_this_a_mainthread
// file thread_management.c line 50
signed int is_this_a_mainthread(void)
{
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  if(return_value_pthread_self$1 == mainthread)
    return 1;

  else
    return 0;
}

// localdate
// file logging.h line 75
char * localdate(signed long int *sec)
{
  struct tm *tm;
  tm=localtime(sec);
  static char localdat[31l];
  memset((void *)localdat, 0, (unsigned long int)31);
  strftime(localdat, (unsigned long int)30, format, tm);
  return localdat;
}

// loginit
// file logging.c line 334
signed int loginit(char verl, char *dateformat)
{
  struct llnode *ptr;
  signed int n;
  verlev = (char)0;
  if(!(verl == 0))
    switch((signed int)verl)
    {
      case 1:
      {
        verlev = (char)(16 | 1);
        break;
      }
      case 2:
      {
        verlev = (char)(8 | 16 | 1);
        break;
      }
      case 3:
      {
        verlev = (char)(8 | 16 | 32 | 1);
        break;
      }
      case 4:
      {
        verlev = (char)(8 | 16 | 32 | 64 | 1);
        break;
      }
      case 5:
      {
        verlev = (char)(8 | 16 | 32 | 64 | 1 | 2);
        break;
      }
      default:
        verlev = (char)(1 | 2 | 4 | 8 | 16 | 32 | 64);
    }

  setdateformat(dateformat);
  ptr = head;
  for( ; !(ptr == ((struct llnode *)NULL)); ptr = ptr->next)
  {
    n=checklogtarget(ptr);
    if(!(n == 0))
      return n;

  }
  return 0;
}

// main
// file afserver.c line 70
signed int main(signed int argc, char **argv)
{
  signed int i;
  signed int j = 0;
  signed int k;
  signed int l;
  signed int n;
  signed int flags;
  signed int sent = 0;
  signed int temp;
  unsigned int len;
  unsigned char buff[9000l];
  signed int maxfdp1;
  struct anonymous$22 rset;
  struct anonymous$22 allset;
  struct anonymous$22 wset;
  struct anonymous$22 tmpset;
  signed int numofcon;
  signed int length;
  char *name = (char *)(void *)0;
  char **main$$1$$listen = (char **)(void *)0;
  signed int listencount = 0;
  char **manage = (char **)(void *)0;
  signed int managecount = 0;
  char *amount = (char *)(void *)0;
  char *clients = (char *)(void *)0;
  char *raclients = (char *)(void *)0;
  char *usrpcli = (char *)(void *)0;
  char *clim = (char *)(void *)0;
  char *filenam = (char *)(void *)0;
  char *type = (char *)(void *)0;
  char *timeout = (char *)(void *)0;
  char *maxidle = (char *)(void *)0;
  char *realmname = (char *)(void *)0;
  unsigned char pass[4l] = { (unsigned char)1, (unsigned char)2, (unsigned char)3, (unsigned char)4 };
  char verbose = (char)0;
  char mode = (char)0;
  char tunneltype = (char)0;
  char ipfam = (char)0;
  char baseport = (char)0;
  char audit = (char)0;
  char dnslookups = (char)0;
  struct anonymous$5 *pointer = (struct anonymous$5 *)(void *)0;
  struct anonymous$16 *scheduler;
  struct anonymous$13 *task;
  struct sigaction act;
  signed long int now;
  struct anonymous$5 **scRealmsTable;
  struct anonymous$7 **srUsersClientsTable;
  struct anonymous$4 **srUsersTable;
  struct anonymous$3 **srClientsTable;
  struct anonymous$3 **srRaClientsTable;
  char *certif = (char *)(void *)0;
  char *cacertif = (char *)(void *)0;
  char *cerdepth = (char *)(void *)0;
  char *keys = (char *)(void *)0;
  char *dateformat = (char *)(void *)0;
  struct ssl_method_st *method;
  struct ssl_ctx_st *ctx;
  struct ssl_st *tmp_ssl;
  sigfillset(&act.sa_mask);
  act.sa_flags = 0;
  act.__sigaction_handler.sa_handler = (void (*)(signed int))1;
  sigaction(13, &act, (struct sigaction *)(void *)0);
  act.__sigaction_handler.sa_handler = server_sig_int;
  sigaction(2, &act, (struct sigaction *)(void *)0);
  sigaction(15, &act, (struct sigaction *)(void *)0);
  mode = mode | (char)4;
  mode = mode | (char)8;
  mode = mode | (char)64;
  remember_mainthread();
  void *return_value_realloc$1;
  void *return_value_realloc$2;
  unsigned long int return_value_strlen$3;
  do
  {
    n=getopt_long(argc, argv, "P46hn:l:m:vu:c:A:d:k:f:p:o:t:C:U:M:abD:R:r:V", long_options, ((signed int *)NULL));
    if(n == -1)
      break;

    switch(n)
    {
      case 104:
      {
        server_long_usage("Active port forwarder (server) v0.8.4");
        break;
      }
      case 110:
      {
        name = optarg;
        break;
      }
      case 108:
      {
        listencount = listencount + 1;
        return_value_realloc$1=realloc((void *)main$$1$$listen, sizeof(char *) /*8ul*/ );
        main$$1$$listen = (char **)return_value_realloc$1;
        main$$1$$listen[(signed long int)(listencount - 1)] = optarg;
        break;
      }
      case 109:
      {
        managecount = managecount + 1;
        return_value_realloc$2=realloc((void *)manage, sizeof(char *) /*8ul*/ );
        manage = (char **)return_value_realloc$2;
        manage[(signed long int)(managecount - 1)] = optarg;
        break;
      }
      case 116:
      {
        timeout = optarg;
        break;
      }
      case 321:
      {
        maxidle = optarg;
        break;
      }
      case 118:
      {
        verbose = verbose + 1;
        break;
      }
      case 117:
      {
        amount = optarg;
        break;
      }
      case 67:
      {
        clients = optarg;
        break;
      }
      case 114:
      {
        realmname = optarg;
        break;
      }
      case 82:
      {
        raclients = optarg;
        break;
      }
      case 85:
      {
        usrpcli = optarg;
        break;
      }
      case 77:
      {
        clim = optarg;
        break;
      }
      case 99:
      {
        certif = optarg;
        break;
      }
      case 65:
      {
        cacertif = optarg;
        break;
      }
      case 100:
      {
        cerdepth = optarg;
        break;
      }
      case 107:
      {
        keys = optarg;
        break;
      }
      case 112:
      {
        type = optarg;
        break;
      }
      case 102:
      {
        filenam = optarg;
        break;
      }
      case 111:
      {
        addlogtarget(optarg);
        break;
      }
      case 301:
      {
        mode = mode & (char)~4;
        break;
      }
      case 302:
      {
        mode = mode & (char)~8;
        break;
      }
      case 303:
      {
        return_value_strlen$3=strlen(optarg);
        n = (signed int)return_value_strlen$3;
        memset((void *)pass, 0, (unsigned long int)4);
        i = 0;
        for( ; !(i >= n); i = i + 1)
          pass[(signed long int)(i % 4)] = pass[(signed long int)(i % 4)] + (unsigned char)optarg[(signed long int)i];
        sent = 1;
        break;
      }
      case 52:
      {
        if(!((signed int)ipfam == 0))
          ipfam = (char)-1;

        else
          ipfam = (char)4;
        break;
      }
      case 54:
      {
        if(!((signed int)ipfam == 0))
          ipfam = (char)-1;

        else
          ipfam = (char)6;
        break;
      }
      case 98:
      {
        baseport = (char)1;
        break;
      }
      case 97:
      {
        audit = (char)1;
        break;
      }
      case 311:
      {
        dnslookups = (char)1;
        break;
      }
      case 68:
      {
        dateformat = optarg;
        break;
      }
      case 80:
      {
        if((signed int)tunneltype >= 3 || !((signed int)tunneltype >= 0))
          tunneltype = (char)-1;

        else
          if(!((signed int)tunneltype == 2))
            tunneltype = (char)1;

        break;
      }
      case 86:
      {
        printf("%s\n", (const void *)"Active port forwarder (server) v0.8.4");
        exit(0);
        break;
      }
      case 63:
        server_short_usage("");
    }
  }
  while((_Bool)1);
  if(!(optind >= argc))
    server_short_usage("Unrecognized non-option elements");

  signed int tmp_statement_expression$20;
  signed int tmp_statement_expression$18;
  if(!(filenam == ((char *)NULL)))
  {
    config=parsefile(filenam, &n);
    if(!(n == 0))
    {
      printf("parsing failed! line:%d\n", n);
      exit(1);
    }

    else
    {
      if(certif == ((char *)NULL))
      {
        char *return_value_ServerConfiguration_get_certificateFile$4;
        return_value_ServerConfiguration_get_certificateFile$4=ServerConfiguration_get_certificateFile(config);
        if(return_value_ServerConfiguration_get_certificateFile$4 == ((char *)NULL))
          ServerConfiguration_set_certificateFile(config, "server-cert.pem");

      }

      else
        ServerConfiguration_set_certificateFile(config, certif);
      if(!(cacertif == ((char *)NULL)))
        ServerConfiguration_set_cacertificateFile(config, cacertif);

      if(!(cerdepth == ((char *)NULL)))
        ServerConfiguration_set_sCertificateDepth(config, cerdepth);

      if(keys == ((char *)NULL))
      {
        char *return_value_ServerConfiguration_get_keysFile$5;
        return_value_ServerConfiguration_get_keysFile$5=ServerConfiguration_get_keysFile(config);
        if(return_value_ServerConfiguration_get_keysFile$5 == ((char *)NULL))
          ServerConfiguration_set_keysFile(config, "server.rsa");

      }

      else
        ServerConfiguration_set_keysFile(config, keys);
      if(!(dateformat == ((char *)NULL)))
        ServerConfiguration_set_dateFormat(config, dateformat);

      char *return_value_ServerConfiguration_get_dateFormat$6;
      return_value_ServerConfiguration_get_dateFormat$6=ServerConfiguration_get_dateFormat(config);
      initializelogging(verbose, return_value_ServerConfiguration_get_dateFormat$6);
      signed int return_value_ServerConfiguration_get_realmsNumber$7;
      return_value_ServerConfiguration_get_realmsNumber$7=ServerConfiguration_get_realmsNumber(config);
      aflog((char)4, (char)8, "cfg file OK! (readed realms: %d)", return_value_ServerConfiguration_get_realmsNumber$7);
      if(!(name == ((char *)NULL)))
        aflog((char)4, (char)32, "Warning: hostname=%s will be ignored", name);

      if(!(main$$1$$listen == ((char **)NULL)))
        aflog((char)4, (char)32, "Warning: listenport will be ignored");

      if(!(manage == ((char **)NULL)))
        aflog((char)4, (char)32, "Warning: manageport will be ignored");

      if(!(realmname == ((char *)NULL)))
        aflog((char)4, (char)32, "Warning: realmname=%s will be ignored", realmname);

      if(sent == 1)
        aflog((char)4, (char)32, "Warning: password from command line will be ignored");

    }
  }

  else
  {
    config=ServerConfiguration_new();
    if(config == ((struct anonymous$2 *)NULL))
    {
      printf("Can't allocate memory for server configuration... exiting\n");
      exit(1);
    }

    ServerConfiguration_set_certificateFile(config, certif);
    ServerConfiguration_set_cacertificateFile(config, cacertif);
    ServerConfiguration_set_sCertificateDepth(config, cerdepth);
    ServerConfiguration_set_keysFile(config, keys);
    ServerConfiguration_set_dateFormat(config, dateformat);
    char *return_value_ServerConfiguration_get_dateFormat$8;
    return_value_ServerConfiguration_get_dateFormat$8=ServerConfiguration_get_dateFormat(config);
    initializelogging(verbose, return_value_ServerConfiguration_get_dateFormat$8);
    if(main$$1$$listen == ((char **)NULL))
    {
      listencount = 1;
      void *return_value_calloc$9;
      return_value_calloc$9=calloc((unsigned long int)1, sizeof(char *) /*8ul*/ );
      main$$1$$listen = (char **)return_value_calloc$9;
      main$$1$$listen[(signed long int)0] = "50127";
    }

    if(manage == ((char **)NULL))
    {
      managecount = 1;
      void *return_value_calloc$10;
      return_value_calloc$10=calloc((unsigned long int)1, sizeof(char *) /*8ul*/ );
      manage = (char **)return_value_calloc$10;
      manage[(signed long int)0] = "50126";
    }

    if(!(managecount == listencount))
    {
      aflog((char)4, (char)1, "Number of listen and manage options are not the same... exiting");
      exit(1);
    }

    char *return_value_ServerConfiguration_get_certificateFile$11;
    return_value_ServerConfiguration_get_certificateFile$11=ServerConfiguration_get_certificateFile(config);
    if(return_value_ServerConfiguration_get_certificateFile$11 == ((char *)NULL))
      ServerConfiguration_set_certificateFile(config, "server-cert.pem");

    char *return_value_ServerConfiguration_get_keysFile$12;
    return_value_ServerConfiguration_get_keysFile$12=ServerConfiguration_get_keysFile(config);
    if(return_value_ServerConfiguration_get_keysFile$12 == ((char *)NULL))
      ServerConfiguration_set_keysFile(config, "server.rsa");

    if(type == ((char *)NULL))
      type = "tcp";

    ServerConfiguration_set_realmsNumber(config, 1);
    void *return_value_calloc$13;
    return_value_calloc$13=calloc((unsigned long int)1, sizeof(struct anonymous$5 *) /*8ul*/ );
    scRealmsTable = (struct anonymous$5 **)return_value_calloc$13;
    if(scRealmsTable == ((struct anonymous$5 **)NULL))
    {
      aflog((char)4, (char)1, "Problem with allocating memory for ServerRealm* table... exiting");
      exit(1);
    }

    ServerConfiguration_set_realmsTable(config, scRealmsTable);
    pointer=ServerRealm_new();
    if(pointer == ((struct anonymous$5 *)NULL))
    {
      aflog((char)4, (char)1, "Problem with allocating memory for ServerRealm structure... exiting");
      exit(1);
    }

    scRealmsTable[(signed long int)0] = pointer;
    ServerRealm_set_hostName(pointer, name);
    ServerRealm_set_userClientPairs(pointer, managecount);
    void *return_value_calloc$14;
    return_value_calloc$14=calloc((unsigned long int)managecount, sizeof(struct anonymous$7 *) /*8ul*/ );
    srUsersClientsTable = (struct anonymous$7 **)return_value_calloc$14;
    if(srUsersClientsTable == ((struct anonymous$7 **)NULL))
    {
      aflog((char)4, (char)1, "Problem with allocating memory for UsrCli* table... exiting");
      exit(1);
    }

    ServerRealm_set_usersClientsTable(pointer, srUsersClientsTable);
    i = 0;
    for( ; !(i >= managecount); i = i + 1)
    {
      srUsersClientsTable[(signed long int)i]=UsrCli_new();
      if(srUsersClientsTable[(signed long int)i] == ((struct anonymous$7 *)NULL))
      {
        aflog((char)4, (char)1, "Problem with allocating memory for UsrCli structure... exiting");
        exit(1);
      }

      UsrCli_set_listenPortName(srUsersClientsTable[(signed long int)i], main$$1$$listen[(signed long int)i]);
      UsrCli_set_managePortName(srUsersClientsTable[(signed long int)i], manage[(signed long int)i]);
    }
    ServerRealm_set_sUsersLimit(pointer, amount);
    ServerRealm_set_sClientsLimit(pointer, clients);
    ServerRealm_set_sRaClientsLimit(pointer, raclients);
    ServerRealm_set_sTimeout(pointer, timeout);
    ServerRealm_set_sMaxIdle(pointer, maxidle);
    ServerRealm_set_sUsersPerClient(pointer, usrpcli);
    ServerRealm_set_sClientMode(pointer, clim);
    ServerRealm_set_basePortOn(pointer, baseport);
    ServerRealm_set_auditOn(pointer, audit);
    ServerRealm_set_tunnelType(pointer, tunneltype);
    ServerRealm_set_dnsLookupsOn(pointer, dnslookups);
    ServerRealm_set_realmName(pointer, realmname);
    ServerRealm_set_password(pointer, pass);
    unsigned long int main$$1$$4$$12$$__s1_len;
    unsigned long int main$$1$$4$$12$$__s2_len;
    signed int return_value___builtin_strcmp$21;
    return_value___builtin_strcmp$21=__builtin_strcmp(type, "tcp");
    tmp_statement_expression$20 = return_value___builtin_strcmp$21;
    if(tmp_statement_expression$20 == 0)
    {
      char return_value_ServerRealm_get_realmType$15;
      return_value_ServerRealm_get_realmType$15=ServerRealm_get_realmType(pointer);
      temp = (signed int)return_value_ServerRealm_get_realmType$15;
      temp = temp | 1;
      ServerRealm_set_realmType(pointer, (char)temp);
    }

    else
    {
      unsigned long int main$$1$$4$$14$$__s1_len;
      unsigned long int main$$1$$4$$14$$__s2_len;
      signed int return_value___builtin_strcmp$19;
      return_value___builtin_strcmp$19=__builtin_strcmp(type, "udp");
      tmp_statement_expression$18 = return_value___builtin_strcmp$19;
      if(tmp_statement_expression$18 == 0)
      {
        char return_value_ServerRealm_get_realmType$16;
        return_value_ServerRealm_get_realmType$16=ServerRealm_get_realmType(pointer);
        temp = (signed int)return_value_ServerRealm_get_realmType$16;
        temp = temp | 3;
        ServerRealm_set_realmType(pointer, (char)temp);
      }

      else
      {
        char return_value_ServerRealm_get_realmType$17;
        return_value_ServerRealm_get_realmType$17=ServerRealm_get_realmType(pointer);
        temp = (signed int)return_value_ServerRealm_get_realmType$17;
        temp = 0;
        ServerRealm_set_realmType(pointer, (char)temp);
      }
    }
    if((signed int)ipfam == -1)
    {
      aflog((char)4, (char)1, "Conflicting types of ip protocol family... exiting");
      exit(1);
    }

    else
      if((signed int)ipfam == 4)
      {
        char return_value_ServerRealm_get_realmType$22;
        return_value_ServerRealm_get_realmType$22=ServerRealm_get_realmType(pointer);
        temp = (signed int)return_value_ServerRealm_get_realmType$22;
        temp = temp | 16;
        ServerRealm_set_realmType(pointer, (char)temp);
      }

      else
        if((signed int)ipfam == 6)
        {
          char return_value_ServerRealm_get_realmType$23;
          return_value_ServerRealm_get_realmType$23=ServerRealm_get_realmType(pointer);
          temp = (signed int)return_value_ServerRealm_get_realmType$23;
          temp = temp | 32;
          ServerRealm_set_realmType(pointer, (char)temp);
        }

    char return_value_ServerRealm_get_realmType$24;
    return_value_ServerRealm_get_realmType$24=ServerRealm_get_realmType(pointer);
    temp = (signed int)return_value_ServerRealm_get_realmType$24;
    temp = temp | (signed int)mode;
    ServerRealm_set_realmType(pointer, (char)temp);
  }
  maxfdp1 = 0;
  SSL_library_init();
  method=SSLv3_server_method();
  ctx=SSL_CTX_new(method);
  signed int return_value_SSL_CTX_set_cipher_list$25;
  return_value_SSL_CTX_set_cipher_list$25=SSL_CTX_set_cipher_list(ctx, "ALL:@STRENGTH");
  if(return_value_SSL_CTX_set_cipher_list$25 == 0)
  {
    aflog((char)4, (char)1, "Setting ciphers list failed... exiting");
    exit(1);
  }

  flags=create_apf_dir((char)0);
  if(!(flags == 0))
  {
    aflog((char)4, (char)32, "Warning: Creating ~/.apf directory failed (%d)", flags);
    flags=create_apf_dir((char)1);
    if(!(flags == 0))
      aflog((char)4, (char)32, "Warning: Creating ./apf directory failed (%d)", flags);

  }

  keys=ServerConfiguration_get_keysFile(config);
  flags=generate_rsa_key(&keys);
  if(!(flags == 0))
    aflog((char)4, (char)32, "Warning: Something bad happened when generating rsa keys... (%d)", flags);

  ServerConfiguration_set_keysFile(config, keys);
  char *return_value_ServerConfiguration_get_keysFile$27;
  return_value_ServerConfiguration_get_keysFile$27=ServerConfiguration_get_keysFile(config);
  signed int return_value_SSL_CTX_use_RSAPrivateKey_file$28;
  return_value_SSL_CTX_use_RSAPrivateKey_file$28=SSL_CTX_use_RSAPrivateKey_file(ctx, return_value_ServerConfiguration_get_keysFile$27, 1);
  if(!(return_value_SSL_CTX_use_RSAPrivateKey_file$28 == 1))
  {
    char *return_value_ServerConfiguration_get_keysFile$26;
    return_value_ServerConfiguration_get_keysFile$26=ServerConfiguration_get_keysFile(config);
    aflog((char)4, (char)1, "Setting rsa key failed (%s)... exiting", return_value_ServerConfiguration_get_keysFile$26);
    exit(1);
  }

  certif=ServerConfiguration_get_certificateFile(config);
  char *return_value_ServerConfiguration_get_keysFile$29;
  return_value_ServerConfiguration_get_keysFile$29=ServerConfiguration_get_keysFile(config);
  flags=generate_certificate(&certif, return_value_ServerConfiguration_get_keysFile$29);
  if(!(flags == 0))
    aflog((char)4, (char)32, "Warning: Something bad happened when generating certificate... (%d)", flags);

  ServerConfiguration_set_certificateFile(config, certif);
  char *return_value_ServerConfiguration_get_certificateFile$31;
  return_value_ServerConfiguration_get_certificateFile$31=ServerConfiguration_get_certificateFile(config);
  signed int return_value_SSL_CTX_use_certificate_file$32;
  return_value_SSL_CTX_use_certificate_file$32=SSL_CTX_use_certificate_file(ctx, return_value_ServerConfiguration_get_certificateFile$31, 1);
  if(!(return_value_SSL_CTX_use_certificate_file$32 == 1))
  {
    char *return_value_ServerConfiguration_get_certificateFile$30;
    return_value_ServerConfiguration_get_certificateFile$30=ServerConfiguration_get_certificateFile(config);
    aflog((char)4, (char)1, "Setting certificate failed (%s)... exiting", return_value_ServerConfiguration_get_certificateFile$30);
    exit(1);
  }

  cacertif=ServerConfiguration_get_cacertificateFile(config);
  if(!(cacertif == ((char *)NULL)))
  {
    signed int return_value_SSL_CTX_load_verify_locations$33;
    return_value_SSL_CTX_load_verify_locations$33=SSL_CTX_load_verify_locations(ctx, cacertif, (const char *)(void *)0);
    if(!(return_value_SSL_CTX_load_verify_locations$33 == 1))
    {
      aflog((char)4, (char)1, "Setting CA certificate failed (%s)... exiting", cacertif);
      exit(1);
    }

    SSL_CTX_set_verify(ctx, 0x01 | 0x02, (signed int (*)(signed int, struct x509_store_ctx_st *))(void *)0);
    cerdepth=ServerConfiguration_get_sCertificateDepth(config);
    if(cerdepth == ((char *)NULL))
      cerdepth = "9";

    signed int return_value_check_value_liberal$34;
    return_value_check_value_liberal$34=check_value_liberal(cerdepth, "Invalid max certificate-depth");
    SSL_CTX_set_verify_depth(ctx, return_value_check_value_liberal$34);
  }

  signed int return_value_ServerConfiguration_get_realmsNumber$35;
  return_value_ServerConfiguration_get_realmsNumber$35=ServerConfiguration_get_realmsNumber(config);
  if(return_value_ServerConfiguration_get_realmsNumber$35 == 0)
  {
    aflog((char)4, (char)1, "Working without sense is really without sense...");
    exit(1);
  }

  do
  {
    signed int main$$1$$13$$__d0;
    signed int main$$1$$13$$__d1;
    asm("cld; rep; stosq" : "=c"(main$$1$$13$$__d0), "=D"(main$$1$$13$$__d1) : "a"(0), "0"(sizeof(struct anonymous$22) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&allset)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$22) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wset)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  if(verbose == 0)
    daemon(0, 0);

  scheduler=TaskScheduler_new();
  if(scheduler == ((struct anonymous$16 *)NULL))
  {
    aflog((char)4, (char)1, "Problems with creating task scheduler... exiting");
    exit(1);
  }

  scRealmsTable=ServerConfiguration_get_realmsTable(config);
  i = 0;
  signed int return_value_ServerConfiguration_get_realmsNumber$36;
  signed int return_value_ServerRealm_get_userClientPairs$38;
  _Bool tmp_if_expr$43;
  char *return_value_UsrCli_get_managePortName$42;
  signed int tmp_statement_expression$49;
  signed int tmp_statement_expression$47;
  signed int return_value_ServerRealm_get_usersLimit$78;
  signed int return_value_ServerRealm_get_clientsLimit$81;
  signed int return_value_ServerRealm_get_raClientsLimit$84;
  char return_value_ServerRealm_get_realmType$85;
  signed int return_value_ServerRealm_get_userClientPairs$87;
  char *tmp_if_expr$96;
  char *return_value_UsrCli_get_listenHostName$94;
  char *return_value_ServerRealm_get_hostName$95;
  char *tmp_if_expr$91;
  char *return_value_UsrCli_get_listenHostName$89;
  char *return_value_ServerRealm_get_hostName$90;
  signed int return_value_ServerRealm_get_userClientPairs$102;
  char *return_value_UsrCli_get_manageHostName$104;
  char *return_value_UsrCli_get_managePortName$105;
  char *tmp_if_expr$114;
  char *return_value_UsrCli_get_manageHostName$112;
  char *return_value_ServerRealm_get_hostName$113;
  char *tmp_if_expr$109;
  char *return_value_UsrCli_get_manageHostName$107;
  char *return_value_ServerRealm_get_hostName$108;
  signed int return_value_UsrCli_get_manageFd$117;
  signed int return_value_UsrCli_get_manageFd$118;
  char *return_value_UsrCli_get_manageHostName$119;
  char *return_value_UsrCli_get_managePortName$120;
  signed int return_value_eval_UsrCliPair$121;
  char *return_value_UsrCli_get_manageHostName$122;
  char *return_value_UsrCli_get_managePortName$123;
  char *tmp_if_expr$133;
  char *return_value_UsrCli_get_manageHostName$131;
  char *return_value_ServerRealm_get_hostName$132;
  char *tmp_if_expr$128;
  char *return_value_UsrCli_get_manageHostName$126;
  char *return_value_ServerRealm_get_hostName$127;
  signed int return_value_UsrCli_get_manageFd$139;
  signed int return_value_UsrCli_get_manageFd$140;
  char *return_value_UsrCli_get_manageHostName$141;
  char *return_value_UsrCli_get_managePortName$142;
  signed int return_value_eval_UsrCliPair$143;
  signed int return_value_ServerRealm_get_clientsLimit$147;
  signed int return_value_ServerRealm_get_raClientsLimit$152;
  signed int return_value_ServerRealm_get_userClientPairs$157;
  signed int tmp_if_expr$162;
  signed int return_value_UsrCli_get_manageFd$161;
  signed int return_value_ServerRealm_get_userClientPairs$163;
  signed int tmp_if_expr$168;
  signed int return_value_UsrCli_get_listenFd$167;
  signed int return_value_ServerRealm_get_clientsLimit$170;
  signed int return_value_ServerRealm_get_raClientsLimit$175;
  do
  {
    return_value_ServerConfiguration_get_realmsNumber$36=ServerConfiguration_get_realmsNumber(config);
    if(i >= return_value_ServerConfiguration_get_realmsNumber$36)
      break;

    signed int return_value_ServerRealm_get_userClientPairs$37;
    return_value_ServerRealm_get_userClientPairs$37=ServerRealm_get_userClientPairs(scRealmsTable[(signed long int)i]);
    if(return_value_ServerRealm_get_userClientPairs$37 == 0)
    {
      aflog((char)4, (char)1, "You have to specify at least one listen port and one manage port in each realm");
      exit(1);
    }

    srUsersClientsTable=ServerRealm_get_usersClientsTable(scRealmsTable[(signed long int)i]);
    j = 0;
    do
    {
      return_value_ServerRealm_get_userClientPairs$38=ServerRealm_get_userClientPairs(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_userClientPairs$38)
        break;

      char *return_value_UsrCli_get_listenPortName$41;
      return_value_UsrCli_get_listenPortName$41=UsrCli_get_listenPortName(srUsersClientsTable[(signed long int)j]);
      if(return_value_UsrCli_get_listenPortName$41 == ((char *)NULL))
        tmp_if_expr$43 = (_Bool)1;

      else
      {
        return_value_UsrCli_get_managePortName$42=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
        tmp_if_expr$43 = return_value_UsrCli_get_managePortName$42 == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$43)
      {
        char *return_value_UsrCli_get_listenPortName$39;
        return_value_UsrCli_get_listenPortName$39=UsrCli_get_listenPortName(srUsersClientsTable[(signed long int)j]);
        char *return_value_UsrCli_get_managePortName$40;
        return_value_UsrCli_get_managePortName$40=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
        aflog((char)4, (char)1, "Missing some of the variables...\nRealm: %d\nlistenport[%d]: %s\nmanageport[%d]: %s", i, j, return_value_UsrCli_get_listenPortName$39, j, return_value_UsrCli_get_managePortName$40);
        exit(1);
      }

      j = j + 1;
    }
    while((_Bool)1);
    char return_value_ServerRealm_get_realmType$52;
    return_value_ServerRealm_get_realmType$52=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
    if((1 & (signed int)return_value_ServerRealm_get_realmType$52) == 0)
    {
      if(!(type == ((char *)NULL)))
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp$50;
        return_value___builtin_strcmp$50=__builtin_strcmp(type, "tcp");
        tmp_statement_expression$49 = return_value___builtin_strcmp$50;
        if(tmp_statement_expression$49 == 0)
        {
          char return_value_ServerRealm_get_realmType$44;
          return_value_ServerRealm_get_realmType$44=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
          temp = (signed int)return_value_ServerRealm_get_realmType$44;
          temp = temp | 1;
          ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
        }

        else
        {
          unsigned long int main$$1$$16$$3$$1$$3$$__s1_len;
          unsigned long int main$$1$$16$$3$$1$$3$$__s2_len;
          signed int return_value___builtin_strcmp$48;
          return_value___builtin_strcmp$48=__builtin_strcmp(type, "udp");
          tmp_statement_expression$47 = return_value___builtin_strcmp$48;
          if(tmp_statement_expression$47 == 0)
          {
            char return_value_ServerRealm_get_realmType$45;
            return_value_ServerRealm_get_realmType$45=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
            temp = (signed int)return_value_ServerRealm_get_realmType$45;
            temp = temp | 3;
            ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
          }

          else
          {
            char return_value_ServerRealm_get_realmType$46;
            return_value_ServerRealm_get_realmType$46=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
            temp = (signed int)return_value_ServerRealm_get_realmType$46;
            temp = temp | 1;
            ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
          }
        }
      }

      else
      {
        char return_value_ServerRealm_get_realmType$51;
        return_value_ServerRealm_get_realmType$51=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
        temp = (signed int)return_value_ServerRealm_get_realmType$51;
        temp = temp | 1;
        ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
      }
    }

    char return_value_ServerRealm_get_realmType$55;
    return_value_ServerRealm_get_realmType$55=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
    if((48 & (signed int)return_value_ServerRealm_get_realmType$55) == 0)
    {
      if((signed int)ipfam == -1)
      {
        aflog((char)4, (char)1, "Conflicting types of ip protocol family... exiting");
        exit(1);
      }

      else
        if((signed int)ipfam == 4)
        {
          char return_value_ServerRealm_get_realmType$53;
          return_value_ServerRealm_get_realmType$53=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
          temp = (signed int)return_value_ServerRealm_get_realmType$53;
          temp = temp | 16;
          ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
        }

        else
          if((signed int)ipfam == 6)
          {
            char return_value_ServerRealm_get_realmType$54;
            return_value_ServerRealm_get_realmType$54=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
            temp = (signed int)return_value_ServerRealm_get_realmType$54;
            temp = temp | 32;
            ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
          }

    }

    if((4 & (signed int)mode) == 0)
    {
      char return_value_ServerRealm_get_realmType$56;
      return_value_ServerRealm_get_realmType$56=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
      temp = (signed int)return_value_ServerRealm_get_realmType$56;
      temp = temp & ~4;
      ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
    }

    if((8 & (signed int)mode) == 0)
    {
      char return_value_ServerRealm_get_realmType$57;
      return_value_ServerRealm_get_realmType$57=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
      temp = (signed int)return_value_ServerRealm_get_realmType$57;
      temp = temp & ~8;
      ServerRealm_set_realmType(scRealmsTable[(signed long int)i], (char)temp);
    }

    char return_value_ServerRealm_get_basePortOn$58;
    return_value_ServerRealm_get_basePortOn$58=ServerRealm_get_basePortOn(scRealmsTable[(signed long int)i]);
    if((signed int)return_value_ServerRealm_get_basePortOn$58 == 0)
      ServerRealm_set_basePortOn(scRealmsTable[(signed long int)i], baseport);

    char return_value_ServerRealm_get_auditOn$59;
    return_value_ServerRealm_get_auditOn$59=ServerRealm_get_auditOn(scRealmsTable[(signed long int)i]);
    if((signed int)return_value_ServerRealm_get_auditOn$59 == 0)
      ServerRealm_set_auditOn(scRealmsTable[(signed long int)i], audit);

    char return_value_ServerRealm_get_tunnelType$60;
    return_value_ServerRealm_get_tunnelType$60=ServerRealm_get_tunnelType(scRealmsTable[(signed long int)i]);
    if((signed int)return_value_ServerRealm_get_tunnelType$60 == 0)
    {
      if((signed int)tunneltype == -1)
      {
        aflog((char)4, (char)1, "Conflicting types of tunnel type... exiting");
        exit(1);
      }

      ServerRealm_set_tunnelType(scRealmsTable[(signed long int)i], tunneltype);
    }

    char return_value_ServerRealm_get_dnsLookupsOn$61;
    return_value_ServerRealm_get_dnsLookupsOn$61=ServerRealm_get_dnsLookupsOn(scRealmsTable[(signed long int)i]);
    if((signed int)return_value_ServerRealm_get_dnsLookupsOn$61 == 0)
      ServerRealm_set_dnsLookupsOn(scRealmsTable[(signed long int)i], dnslookups);

    static char *stemp = (char *)(void *)0;
    stemp=ServerRealm_get_sUsersLimit(scRealmsTable[(signed long int)i]);
    set_value(&stemp, amount, "5");
    ServerRealm_set_sUsersLimit(scRealmsTable[(signed long int)i], stemp);
    char *return_value_ServerRealm_get_sUsersLimit$62;
    return_value_ServerRealm_get_sUsersLimit$62=ServerRealm_get_sUsersLimit(scRealmsTable[(signed long int)i]);
    signed int return_value_check_value$63;
    return_value_check_value$63=check_value(return_value_ServerRealm_get_sUsersLimit$62, "Invalid users amount");
    ServerRealm_set_usersLimit(scRealmsTable[(signed long int)i], return_value_check_value$63);
    stemp=ServerRealm_get_sClientsLimit(scRealmsTable[(signed long int)i]);
    set_value(&stemp, clients, "1");
    ServerRealm_set_sClientsLimit(scRealmsTable[(signed long int)i], stemp);
    char *return_value_ServerRealm_get_sClientsLimit$64;
    return_value_ServerRealm_get_sClientsLimit$64=ServerRealm_get_sClientsLimit(scRealmsTable[(signed long int)i]);
    signed int return_value_check_value$65;
    return_value_check_value$65=check_value(return_value_ServerRealm_get_sClientsLimit$64, "Invalid clients amount");
    ServerRealm_set_clientsLimit(scRealmsTable[(signed long int)i], return_value_check_value$65);
    stemp=ServerRealm_get_sRaClientsLimit(scRealmsTable[(signed long int)i]);
    set_value(&stemp, raclients, "1");
    ServerRealm_set_sRaClientsLimit(scRealmsTable[(signed long int)i], stemp);
    char *return_value_ServerRealm_get_sRaClientsLimit$66;
    return_value_ServerRealm_get_sRaClientsLimit$66=ServerRealm_get_sRaClientsLimit(scRealmsTable[(signed long int)i]);
    signed int return_value_check_value$67;
    return_value_check_value$67=check_value(return_value_ServerRealm_get_sRaClientsLimit$66, "Invalid raclients amount");
    ServerRealm_set_raClientsLimit(scRealmsTable[(signed long int)i], return_value_check_value$67);
    stemp=ServerRealm_get_sUsersPerClient(scRealmsTable[(signed long int)i]);
    char *return_value_ServerRealm_get_sUsersLimit$68;
    return_value_ServerRealm_get_sUsersLimit$68=ServerRealm_get_sUsersLimit(scRealmsTable[(signed long int)i]);
    set_value(&stemp, usrpcli, return_value_ServerRealm_get_sUsersLimit$68);
    ServerRealm_set_sUsersPerClient(scRealmsTable[(signed long int)i], stemp);
    char *return_value_ServerRealm_get_sUsersPerClient$69;
    return_value_ServerRealm_get_sUsersPerClient$69=ServerRealm_get_sUsersPerClient(scRealmsTable[(signed long int)i]);
    signed int return_value_check_value$70;
    return_value_check_value$70=check_value(return_value_ServerRealm_get_sUsersPerClient$69, "Invalid usrpcli value");
    ServerRealm_set_usersPerClient(scRealmsTable[(signed long int)i], return_value_check_value$70);
    stemp=ServerRealm_get_sTimeout(scRealmsTable[(signed long int)i]);
    set_value(&stemp, timeout, "5");
    ServerRealm_set_sTimeout(scRealmsTable[(signed long int)i], stemp);
    char *return_value_ServerRealm_get_sTimeout$71;
    return_value_ServerRealm_get_sTimeout$71=ServerRealm_get_sTimeout(scRealmsTable[(signed long int)i]);
    signed int return_value_check_value$72;
    return_value_check_value$72=check_value(return_value_ServerRealm_get_sTimeout$71, "Invalid timeout value");
    ServerRealm_set_timeout(scRealmsTable[(signed long int)i], return_value_check_value$72);
    stemp=ServerRealm_get_sMaxIdle(scRealmsTable[(signed long int)i]);
    set_value(&stemp, maxidle, "0");
    ServerRealm_set_sMaxIdle(scRealmsTable[(signed long int)i], stemp);
    char *return_value_ServerRealm_get_sMaxIdle$73;
    return_value_ServerRealm_get_sMaxIdle$73=ServerRealm_get_sMaxIdle(scRealmsTable[(signed long int)i]);
    temp=check_value_liberal(return_value_ServerRealm_get_sMaxIdle$73, "Invalid maxidle value");
    if(!(temp >= 0))
    {
      aflog((char)4, (char)1, "Invalid maxidle value: %d\n", temp);
      exit(1);
    }

    ServerRealm_set_maxIdle(scRealmsTable[(signed long int)i], temp);
    stemp=ServerRealm_get_sClientMode(scRealmsTable[(signed long int)i]);
    set_value(&stemp, clim, "1");
    ServerRealm_set_sClientMode(scRealmsTable[(signed long int)i], stemp);
    char *return_value_ServerRealm_get_sClientMode$74;
    return_value_ServerRealm_get_sClientMode$74=ServerRealm_get_sClientMode(scRealmsTable[(signed long int)i]);
    signed int return_value_check_value$75;
    return_value_check_value$75=check_value(return_value_ServerRealm_get_sClientMode$74, "Invalid climode value");
    ServerRealm_set_clientMode(scRealmsTable[(signed long int)i], return_value_check_value$75);
    signed int return_value_ServerRealm_get_usersLimit$76;
    return_value_ServerRealm_get_usersLimit$76=ServerRealm_get_usersLimit(scRealmsTable[(signed long int)i]);
    void *return_value_calloc$77;
    return_value_calloc$77=calloc((unsigned long int)return_value_ServerRealm_get_usersLimit$76, sizeof(struct anonymous$4 *) /*8ul*/ );
    srUsersTable = (struct anonymous$4 **)return_value_calloc$77;
    if(srUsersTable == ((struct anonymous$4 **)NULL))
    {
      aflog((char)4, (char)1, "Calloc error - try define smaller amount of users");
      exit(1);
    }

    ServerRealm_set_usersTable(scRealmsTable[(signed long int)i], srUsersTable);
    j = 0;
    do
    {
      return_value_ServerRealm_get_usersLimit$78=ServerRealm_get_usersLimit(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_usersLimit$78)
        break;

      srUsersTable[(signed long int)j]=ConnectUser_new();
      if(srUsersTable[(signed long int)j] == ((struct anonymous$4 *)NULL))
      {
        aflog((char)4, (char)1, "Calloc error - try define smaller amount of users");
        exit(1);
      }

      j = j + 1;
    }
    while((_Bool)1);
    signed int return_value_ServerRealm_get_clientsLimit$79;
    return_value_ServerRealm_get_clientsLimit$79=ServerRealm_get_clientsLimit(scRealmsTable[(signed long int)i]);
    void *return_value_calloc$80;
    return_value_calloc$80=calloc((unsigned long int)return_value_ServerRealm_get_clientsLimit$79, sizeof(struct anonymous$3 *) /*8ul*/ );
    srClientsTable = (struct anonymous$3 **)return_value_calloc$80;
    if(srClientsTable == ((struct anonymous$3 **)NULL))
    {
      aflog((char)4, (char)1, "Calloc error - try define smaller amount of clients");
      exit(1);
    }

    ServerRealm_set_clientsTable(scRealmsTable[(signed long int)i], srClientsTable);
    j = 0;
    do
    {
      return_value_ServerRealm_get_clientsLimit$81=ServerRealm_get_clientsLimit(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_clientsLimit$81)
        break;

      srClientsTable[(signed long int)j]=ConnectClient_new();
      if(srClientsTable[(signed long int)j] == ((struct anonymous$3 *)NULL))
      {
        aflog((char)4, (char)1, "Calloc error - try define smaller amount of clients");
        exit(1);
      }

      j = j + 1;
    }
    while((_Bool)1);
    signed int return_value_ServerRealm_get_raClientsLimit$82;
    return_value_ServerRealm_get_raClientsLimit$82=ServerRealm_get_raClientsLimit(scRealmsTable[(signed long int)i]);
    void *return_value_calloc$83;
    return_value_calloc$83=calloc((unsigned long int)return_value_ServerRealm_get_raClientsLimit$82, sizeof(struct anonymous$3 *) /*8ul*/ );
    srRaClientsTable = (struct anonymous$3 **)return_value_calloc$83;
    if(srRaClientsTable == ((struct anonymous$3 **)NULL))
    {
      aflog((char)4, (char)1, "Calloc error - try define smaller amount of raclients");
      exit(1);
    }

    ServerRealm_set_raClientsTable(scRealmsTable[(signed long int)i], srRaClientsTable);
    j = 0;
    do
    {
      return_value_ServerRealm_get_raClientsLimit$84=ServerRealm_get_raClientsLimit(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_raClientsLimit$84)
        break;

      srRaClientsTable[(signed long int)j]=ConnectClient_new();
      if(srRaClientsTable[(signed long int)j] == ((struct anonymous$3 *)NULL))
      {
        aflog((char)4, (char)1, "Calloc error - try define smaller amount of raclients");
        exit(1);
      }

      j = j + 1;
    }
    while((_Bool)1);
    ipfam = (char)0x01;
    char return_value_ServerRealm_get_realmType$86;
    return_value_ServerRealm_get_realmType$86=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
    if(!((16 & (signed int)return_value_ServerRealm_get_realmType$86) == 0))
      ipfam = ipfam | (char)0x02;

    else
    {
      return_value_ServerRealm_get_realmType$85=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
      if(!((32 & (signed int)return_value_ServerRealm_get_realmType$85) == 0))
        ipfam = ipfam | (char)0x04;

    }
    char return_value_ServerRealm_get_basePortOn$101;
    return_value_ServerRealm_get_basePortOn$101=ServerRealm_get_basePortOn(scRealmsTable[(signed long int)i]);
    if((signed int)return_value_ServerRealm_get_basePortOn$101 == 0)
    {
      j = 0;
      do
      {
        return_value_ServerRealm_get_userClientPairs$87=ServerRealm_get_userClientPairs(scRealmsTable[(signed long int)i]);
        if(j >= return_value_ServerRealm_get_userClientPairs$87)
          break;

        char *return_value_UsrCli_get_listenHostName$93;
        return_value_UsrCli_get_listenHostName$93=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)j]);
        if(!(return_value_UsrCli_get_listenHostName$93 == ((char *)NULL)))
        {
          return_value_UsrCli_get_listenHostName$94=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)j]);
          tmp_if_expr$96 = return_value_UsrCli_get_listenHostName$94;
        }

        else
        {
          return_value_ServerRealm_get_hostName$95=ServerRealm_get_hostName(scRealmsTable[(signed long int)i]);
          tmp_if_expr$96 = return_value_ServerRealm_get_hostName$95;
        }
        char *return_value_UsrCli_get_listenPortName$97;
        return_value_UsrCli_get_listenPortName$97=UsrCli_get_listenPortName(srUsersClientsTable[(signed long int)j]);
        signed int return_value_ip_listen$98;
        return_value_ip_listen$98=ip_listen(&temp, tmp_if_expr$96, return_value_UsrCli_get_listenPortName$97, &len, ipfam);
        if(!(return_value_ip_listen$98 == 0))
        {
          char *return_value_UsrCli_get_listenHostName$88;
          return_value_UsrCli_get_listenHostName$88=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)j]);
          if(!(return_value_UsrCli_get_listenHostName$88 == ((char *)NULL)))
          {
            return_value_UsrCli_get_listenHostName$89=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)j]);
            tmp_if_expr$91 = return_value_UsrCli_get_listenHostName$89;
          }

          else
          {
            return_value_ServerRealm_get_hostName$90=ServerRealm_get_hostName(scRealmsTable[(signed long int)i]);
            tmp_if_expr$91 = return_value_ServerRealm_get_hostName$90;
          }
          char *return_value_UsrCli_get_listenPortName$92;
          return_value_UsrCli_get_listenPortName$92=UsrCli_get_listenPortName(srUsersClientsTable[(signed long int)j]);
          aflog((char)4, (char)1, "tcp_listen_%s error for %s, %s", ((signed int)ipfam & 0x02) != 0 ? "ipv4" : (((signed int)ipfam & 0x04) != 0 ? "ipv6" : "unspec"), tmp_if_expr$91, return_value_UsrCli_get_listenPortName$92);
          exit(1);
        }

        ServerRealm_set_addressLength(scRealmsTable[(signed long int)i], len);
        UsrCli_set_listenFd(srUsersClientsTable[(signed long int)j], temp);
        signed int return_value_UsrCli_get_listenFd$99;
        return_value_UsrCli_get_listenFd$99=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)j]);
        flags=fcntl(return_value_UsrCli_get_listenFd$99, 3, 0);
        signed int return_value_UsrCli_get_listenFd$100;
        return_value_UsrCli_get_listenFd$100=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)j]);
        fcntl(return_value_UsrCli_get_listenFd$100, 4, flags | 04000);
        j = j + 1;
      }
      while((_Bool)1);
    }

    j = 0;
    do
    {
      return_value_ServerRealm_get_userClientPairs$102=ServerRealm_get_userClientPairs(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_userClientPairs$102)
        break;

      char return_value_ServerRealm_get_tunnelType$103;
      return_value_ServerRealm_get_tunnelType$103=ServerRealm_get_tunnelType(scRealmsTable[(signed long int)i]);
      switch((signed int)return_value_ServerRealm_get_tunnelType$103)
      {
        case 0:
        {
          return_value_UsrCli_get_manageHostName$104=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
          return_value_UsrCli_get_managePortName$105=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
          temp=find_previousFd(srUsersClientsTable, j, return_value_UsrCli_get_manageHostName$104, return_value_UsrCli_get_managePortName$105);
          if(temp == -1)
          {
            char *return_value_UsrCli_get_manageHostName$111;
            return_value_UsrCli_get_manageHostName$111=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
            if(!(return_value_UsrCli_get_manageHostName$111 == ((char *)NULL)))
            {
              return_value_UsrCli_get_manageHostName$112=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
              tmp_if_expr$114 = return_value_UsrCli_get_manageHostName$112;
            }

            else
            {
              return_value_ServerRealm_get_hostName$113=ServerRealm_get_hostName(scRealmsTable[(signed long int)i]);
              tmp_if_expr$114 = return_value_ServerRealm_get_hostName$113;
            }
            char *return_value_UsrCli_get_managePortName$115;
            return_value_UsrCli_get_managePortName$115=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
            signed int return_value_ip_listen$116;
            return_value_ip_listen$116=ip_listen(&temp, tmp_if_expr$114, return_value_UsrCli_get_managePortName$115, &len, ipfam);
            if(!(return_value_ip_listen$116 == 0))
            {
              char *return_value_UsrCli_get_manageHostName$106;
              return_value_UsrCli_get_manageHostName$106=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
              if(!(return_value_UsrCli_get_manageHostName$106 == ((char *)NULL)))
              {
                return_value_UsrCli_get_manageHostName$107=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
                tmp_if_expr$109 = return_value_UsrCli_get_manageHostName$107;
              }

              else
              {
                return_value_ServerRealm_get_hostName$108=ServerRealm_get_hostName(scRealmsTable[(signed long int)i]);
                tmp_if_expr$109 = return_value_ServerRealm_get_hostName$108;
              }
              char *return_value_UsrCli_get_managePortName$110;
              return_value_UsrCli_get_managePortName$110=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
              aflog((char)4, (char)1, "tcp_listen_%s error for %s, %s", ((signed int)ipfam & 0x02) != 0 ? "ipv4" : (((signed int)ipfam & 0x04) != 0 ? "ipv6" : "unspec"), tmp_if_expr$109, return_value_UsrCli_get_managePortName$110);
              exit(1);
            }

          }

          ServerRealm_set_addressLength(scRealmsTable[(signed long int)i], len);
          UsrCli_set_manageFd(srUsersClientsTable[(signed long int)j], temp);
          return_value_UsrCli_get_manageFd$117=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
          flags=fcntl(return_value_UsrCli_get_manageFd$117, 3, 0);
          return_value_UsrCli_get_manageFd$118=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
          fcntl(return_value_UsrCli_get_manageFd$118, 4, flags | 04000);
          return_value_UsrCli_get_manageHostName$119=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
          return_value_UsrCli_get_managePortName$120=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
          return_value_eval_UsrCliPair$121=eval_UsrCliPair(srUsersClientsTable, j, return_value_UsrCli_get_manageHostName$119, return_value_UsrCli_get_managePortName$120);
          UsrCli_set_number(srUsersClientsTable[(signed long int)j], return_value_eval_UsrCliPair$121);
          break;
        }
        case 1:

        case 2:
        {
          return_value_UsrCli_get_manageHostName$122=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
          return_value_UsrCli_get_managePortName$123=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
          temp=find_previousFd(srUsersClientsTable, j, return_value_UsrCli_get_manageHostName$122, return_value_UsrCli_get_managePortName$123);
          if(temp == -1)
          {
            char *return_value_UsrCli_get_manageHostName$130;
            return_value_UsrCli_get_manageHostName$130=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
            if(!(return_value_UsrCli_get_manageHostName$130 == ((char *)NULL)))
            {
              return_value_UsrCli_get_manageHostName$131=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
              tmp_if_expr$133 = return_value_UsrCli_get_manageHostName$131;
            }

            else
            {
              return_value_ServerRealm_get_hostName$132=ServerRealm_get_hostName(scRealmsTable[(signed long int)i]);
              tmp_if_expr$133 = return_value_ServerRealm_get_hostName$132;
            }
            char *return_value_UsrCli_get_managePortName$134;
            return_value_UsrCli_get_managePortName$134=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
            signed int return_value_ServerRealm_get_clientsLimit$135;
            return_value_ServerRealm_get_clientsLimit$135=ServerRealm_get_clientsLimit(scRealmsTable[(signed long int)i]);
            signed int return_value_ServerRealm_get_raClientsLimit$136;
            return_value_ServerRealm_get_raClientsLimit$136=ServerRealm_get_raClientsLimit(scRealmsTable[(signed long int)i]);
            char return_value_ServerRealm_get_tunnelType$137;
            return_value_ServerRealm_get_tunnelType$137=ServerRealm_get_tunnelType(scRealmsTable[(signed long int)i]);
            signed int return_value_initialize_http_proxy_server$138;
            return_value_initialize_http_proxy_server$138=initialize_http_proxy_server(&temp, tmp_if_expr$133, return_value_UsrCli_get_managePortName$134, &len, ipfam, return_value_ServerRealm_get_clientsLimit$135 + return_value_ServerRealm_get_raClientsLimit$136, (char)((signed int)return_value_ServerRealm_get_tunnelType$137 - 1), ctx);
            if(!(return_value_initialize_http_proxy_server$138 == 0))
            {
              char return_value_ServerRealm_get_tunnelType$124;
              return_value_ServerRealm_get_tunnelType$124=ServerRealm_get_tunnelType(scRealmsTable[(signed long int)i]);
              char *return_value_UsrCli_get_manageHostName$125;
              return_value_UsrCli_get_manageHostName$125=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
              if(!(return_value_UsrCli_get_manageHostName$125 == ((char *)NULL)))
              {
                return_value_UsrCli_get_manageHostName$126=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
                tmp_if_expr$128 = return_value_UsrCli_get_manageHostName$126;
              }

              else
              {
                return_value_ServerRealm_get_hostName$127=ServerRealm_get_hostName(scRealmsTable[(signed long int)i]);
                tmp_if_expr$128 = return_value_ServerRealm_get_hostName$127;
              }
              char *return_value_UsrCli_get_managePortName$129;
              return_value_UsrCli_get_managePortName$129=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
              aflog((char)4, (char)1, "http%s_proxy_listen_%s error for %s, %s", (signed int)return_value_ServerRealm_get_tunnelType$124 == 2 ? "s" : "", ((signed int)ipfam & 0x02) != 0 ? "ipv4" : (((signed int)ipfam & 0x04) != 0 ? "ipv6" : "unspec"), tmp_if_expr$128, return_value_UsrCli_get_managePortName$129);
              exit(1);
            }

          }

          ServerRealm_set_addressLength(scRealmsTable[(signed long int)i], len);
          UsrCli_set_manageFd(srUsersClientsTable[(signed long int)j], temp);
          return_value_UsrCli_get_manageFd$139=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
          flags=fcntl(return_value_UsrCli_get_manageFd$139, 3, 0);
          return_value_UsrCli_get_manageFd$140=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
          fcntl(return_value_UsrCli_get_manageFd$140, 4, flags | 04000);
          return_value_UsrCli_get_manageHostName$141=UsrCli_get_manageHostName(srUsersClientsTable[(signed long int)j]);
          return_value_UsrCli_get_managePortName$142=UsrCli_get_managePortName(srUsersClientsTable[(signed long int)j]);
          return_value_eval_UsrCliPair$143=eval_UsrCliPair(srUsersClientsTable, j, return_value_UsrCli_get_manageHostName$141, return_value_UsrCli_get_managePortName$142);
          UsrCli_set_number(srUsersClientsTable[(signed long int)j], return_value_eval_UsrCliPair$143);
          break;
        }
        default:
        {
          aflog((char)4, (char)1, "Unknown tunnel type");
          exit(1);
        }
      }
      j = j + 1;
    }
    while((_Bool)1);
    unsigned int return_value_ServerRealm_get_addressLength$144;
    return_value_ServerRealm_get_addressLength$144=ServerRealm_get_addressLength(scRealmsTable[(signed long int)i]);
    void *return_value_malloc$145;
    return_value_malloc$145=malloc((unsigned long int)return_value_ServerRealm_get_addressLength$144);
    ServerRealm_set_clientAddress(scRealmsTable[(signed long int)i], (struct sockaddr *)return_value_malloc$145);
    struct sockaddr *return_value_ServerRealm_get_clientAddress$146;
    return_value_ServerRealm_get_clientAddress$146=ServerRealm_get_clientAddress(scRealmsTable[(signed long int)i]);
    if(return_value_ServerRealm_get_clientAddress$146 == ((struct sockaddr *)NULL))
    {
      aflog((char)4, (char)1, "Allocating memory for client addresses failed... exiting");
      exit(1);
    }

    j = 0;
    do
    {
      return_value_ServerRealm_get_clientsLimit$147=ServerRealm_get_clientsLimit(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_clientsLimit$147)
        break;

      struct anonymous$1 *return_value_ConnectClient_get_sslFd$148;
      return_value_ConnectClient_get_sslFd$148=ConnectClient_get_sslFd(srClientsTable[(signed long int)j]);
      struct ssl_st *return_value_SSL_new$149;
      return_value_SSL_new$149=SSL_new(ctx);
      SslFd_set_ssl(return_value_ConnectClient_get_sslFd$148, return_value_SSL_new$149);
      struct anonymous$1 *return_value_ConnectClient_get_sslFd$150;
      return_value_ConnectClient_get_sslFd$150=ConnectClient_get_sslFd(srClientsTable[(signed long int)j]);
      struct ssl_st *return_value_SslFd_get_ssl$151;
      return_value_SslFd_get_ssl$151=SslFd_get_ssl(return_value_ConnectClient_get_sslFd$150);
      if(return_value_SslFd_get_ssl$151 == ((struct ssl_st *)NULL))
      {
        aflog((char)4, (char)1, "Creation of ssl object failed... exiting");
        exit(1);
      }

      j = j + 1;
    }
    while((_Bool)1);
    j = 0;
    do
    {
      return_value_ServerRealm_get_raClientsLimit$152=ServerRealm_get_raClientsLimit(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_raClientsLimit$152)
        break;

      struct anonymous$1 *return_value_ConnectClient_get_sslFd$153;
      return_value_ConnectClient_get_sslFd$153=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)j]);
      struct ssl_st *return_value_SSL_new$154;
      return_value_SSL_new$154=SSL_new(ctx);
      SslFd_set_ssl(return_value_ConnectClient_get_sslFd$153, return_value_SSL_new$154);
      struct anonymous$1 *return_value_ConnectClient_get_sslFd$155;
      return_value_ConnectClient_get_sslFd$155=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)j]);
      struct ssl_st *return_value_SslFd_get_ssl$156;
      return_value_SslFd_get_ssl$156=SslFd_get_ssl(return_value_ConnectClient_get_sslFd$155);
      if(return_value_SslFd_get_ssl$156 == ((struct ssl_st *)NULL))
      {
        aflog((char)4, (char)1, "Creation of ssl object failed... exiting");
        exit(1);
      }

      j = j + 1;
    }
    while((_Bool)1);
    j = 0;
    do
    {
      return_value_ServerRealm_get_userClientPairs$157=ServerRealm_get_userClientPairs(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_userClientPairs$157)
        break;

      signed int return_value_UsrCli_get_manageFd$158;
      return_value_UsrCli_get_manageFd$158=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
      signed int return_value_UsrCli_get_manageFd$159;
      return_value_UsrCli_get_manageFd$159=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
      (&allset)->__fds_bits[(signed long int)(return_value_UsrCli_get_manageFd$158 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_UsrCli_get_manageFd$158 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_UsrCli_get_manageFd$159 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
      signed int return_value_UsrCli_get_manageFd$160;
      return_value_UsrCli_get_manageFd$160=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
      if(!(1 + return_value_UsrCli_get_manageFd$160 >= maxfdp1))
        tmp_if_expr$162 = maxfdp1;

      else
      {
        return_value_UsrCli_get_manageFd$161=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)j]);
        tmp_if_expr$162 = return_value_UsrCli_get_manageFd$161 + 1;
      }
      maxfdp1 = tmp_if_expr$162;
      j = j + 1;
    }
    while((_Bool)1);
    char return_value_ServerRealm_get_basePortOn$169;
    return_value_ServerRealm_get_basePortOn$169=ServerRealm_get_basePortOn(scRealmsTable[(signed long int)i]);
    if((signed int)return_value_ServerRealm_get_basePortOn$169 == 0)
    {
      j = 0;
      do
      {
        return_value_ServerRealm_get_userClientPairs$163=ServerRealm_get_userClientPairs(scRealmsTable[(signed long int)i]);
        if(j >= return_value_ServerRealm_get_userClientPairs$163)
          break;

        signed int return_value_UsrCli_get_listenFd$164;
        return_value_UsrCli_get_listenFd$164=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)j]);
        signed int return_value_UsrCli_get_listenFd$165;
        return_value_UsrCli_get_listenFd$165=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)j]);
        (&allset)->__fds_bits[(signed long int)(return_value_UsrCli_get_listenFd$164 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_UsrCli_get_listenFd$164 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_UsrCli_get_listenFd$165 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
        signed int return_value_UsrCli_get_listenFd$166;
        return_value_UsrCli_get_listenFd$166=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)j]);
        if(!(1 + return_value_UsrCli_get_listenFd$166 >= maxfdp1))
          tmp_if_expr$168 = maxfdp1;

        else
        {
          return_value_UsrCli_get_listenFd$167=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)j]);
          tmp_if_expr$168 = return_value_UsrCli_get_listenFd$167 + 1;
        }
        maxfdp1 = tmp_if_expr$168;
        j = j + 1;
      }
      while((_Bool)1);
    }

    ServerRealm_set_connectedUsers(scRealmsTable[(signed long int)i], 0);
    ServerRealm_set_connectedClients(scRealmsTable[(signed long int)i], 0);
    ServerRealm_set_connectedRaClients(scRealmsTable[(signed long int)i], 0);
    j = 0;
    do
    {
      return_value_ServerRealm_get_clientsLimit$170=ServerRealm_get_clientsLimit(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_clientsLimit$170)
        break;

      signed int return_value_ServerRealm_get_timeout$171;
      return_value_ServerRealm_get_timeout$171=ServerRealm_get_timeout(scRealmsTable[(signed long int)i]);
      struct timeval return_value_timeval_create$172;
      return_value_timeval_create$172=timeval_create((signed long int)return_value_ServerRealm_get_timeout$171, (signed long int)0);
      ConnectClient_set_timer(srClientsTable[(signed long int)j], return_value_timeval_create$172);
      signed int return_value_ServerRealm_get_usersPerClient$173;
      return_value_ServerRealm_get_usersPerClient$173=ServerRealm_get_usersPerClient(scRealmsTable[(signed long int)i]);
      ConnectClient_set_limit(srClientsTable[(signed long int)j], return_value_ServerRealm_get_usersPerClient$173);
      signed int return_value_ConnectClient_create_users$174;
      return_value_ConnectClient_create_users$174=ConnectClient_create_users(srClientsTable[(signed long int)j]);
      if(!(return_value_ConnectClient_create_users$174 == 0))
      {
        aflog((char)4, (char)1, "Calloc error - try define smaller amount of usrpcli (or users)");
        exit(1);
      }

      j = j + 1;
    }
    while((_Bool)1);
    j = 0;
    do
    {
      return_value_ServerRealm_get_raClientsLimit$175=ServerRealm_get_raClientsLimit(scRealmsTable[(signed long int)i]);
      if(j >= return_value_ServerRealm_get_raClientsLimit$175)
        break;

      signed int return_value_ServerRealm_get_timeout$176;
      return_value_ServerRealm_get_timeout$176=ServerRealm_get_timeout(scRealmsTable[(signed long int)i]);
      struct timeval return_value_timeval_create$177;
      return_value_timeval_create$177=timeval_create((signed long int)return_value_ServerRealm_get_timeout$176, (signed long int)0);
      ConnectClient_set_timer(srRaClientsTable[(signed long int)j], return_value_timeval_create$177);
      j = j + 1;
    }
    while((_Bool)1);
    i = i + 1;
  }
  while((_Bool)1);
  signed int return_value_ServerConfiguration_get_realmsNumber$178;
  return_value_ServerConfiguration_get_realmsNumber$178=ServerConfiguration_get_realmsNumber(config);
  aflog((char)16, (char)8, "SERVER STARTED realms: %d", return_value_ServerConfiguration_get_realmsNumber$178);
  time(&now);
  ServerConfiguration_set_startTime(config, now);
  signed int return_value_ServerConfiguration_get_realmsNumber$181;
  signed int return_value_ServerRealm_get_usersLimit$182;
  _Bool tmp_if_expr$277;
  char return_value_ConnectUser_get_state$276;
  _Bool tmp_if_expr$279;
  char return_value_ConnectUser_get_state$278;
  _Bool tmp_if_expr$272;
  char return_value_ServerRealm_get_realmType$271;
  _Bool tmp_if_expr$247;
  _Bool tmp_if_expr$248;
  signed int return_value_ServerRealm_get_usersLimit$280;
  _Bool tmp_if_expr$378;
  char return_value_ConnectUser_get_state$377;
  signed int return_value_ConnectUser_get_connFd$374;
  signed int return_value_ConnectUser_get_connFd$375;
  _Bool tmp_if_expr$373;
  signed int *return_value___errno_location$372;
  signed int return_value_ServerRealm_get_userClientPairs$379;
  signed int return_value_ConnectClient_get_connected$409;
  signed int return_value_ConnectClient_get_limit$410;
  signed int return_value_ServerRealm_get_usersLimit$391;
  signed int return_value_ServerRealm_get_clientsLimit$418;
  signed int return_value_ConnectClient_get_connected$446;
  signed int return_value_ConnectClient_get_limit$447;
  signed int return_value_ServerRealm_get_usersLimit$430;
  signed int return_value_ServerRealm_get_clientsLimit$454;
  char return_value_ConnectClient_get_state$794;
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$790;
  signed int return_value_SslFd_get_fd$791;
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$792;
  signed int return_value_SslFd_get_fd$793;
  char *return_value_get_realmname$470;
  char *return_value_get_clientname$471;
  struct auditlist *return_value_ConnectClient_get_auditList$504;
  struct alnode *return_value_AuditList_get_first$505;
  _Bool tmp_if_expr$558;
  signed int return_value_ServerRealm_get_usersLimit$557;
  _Bool tmp_if_expr$560;
  char return_value_ConnectClient_get_state$559;
  char return_value_ConnectUser_get_state$554;
  _Bool tmp_if_expr$575;
  signed int return_value_ServerRealm_get_usersLimit$574;
  _Bool tmp_if_expr$577;
  char return_value_ConnectClient_get_state$576;
  signed int tmp_if_expr$567;
  signed int return_value_ConnectUser_get_connFd$566;
  _Bool tmp_if_expr$587;
  signed int return_value_ServerRealm_get_usersLimit$586;
  _Bool tmp_if_expr$589;
  char return_value_ConnectClient_get_state$588;
  _Bool tmp_if_expr$585;
  char return_value_ConnectUser_get_state$584;
  char return_value_ConnectClient_get_state$590;
  char return_value_ServerRealm_get_realmType$595;
  _Bool tmp_if_expr$597;
  char return_value_ServerRealm_get_realmType$596;
  _Bool tmp_if_expr$676;
  signed int return_value_ServerRealm_get_usersLimit$675;
  _Bool tmp_if_expr$657;
  char return_value_ServerRealm_get_realmType$656;
  _Bool tmp_if_expr$654;
  signed int *return_value___errno_location$653;
  char return_value_ConnectUser_get_state$672;
  _Bool tmp_if_expr$666;
  char return_value_ServerRealm_get_realmType$665;
  char return_value_ConnectUser_get_state$671;
  char return_value_ConnectClient_get_state$725;
  _Bool tmp_if_expr$728;
  unsigned char *return_value_ServerRealm_get_password$726;
  unsigned char *return_value_ServerRealm_get_password$727;
  _Bool tmp_if_expr$731;
  unsigned char *return_value_ServerRealm_get_password$729;
  unsigned char *return_value_ServerRealm_get_password$730;
  char return_value_ServerRealm_get_realmType$694;
  signed int *return_value_ConnectClient_get_listenFdp$696;
  signed int return_value_ConnectClient_get_usrCliPair$697;
  char *return_value_UsrCli_get_listenHostName$698;
  char *tmp_if_expr$702;
  signed int return_value_ConnectClient_get_usrCliPair$699;
  char *return_value_UsrCli_get_listenHostName$700;
  char *return_value_ServerRealm_get_hostName$701;
  signed int return_value_ip_listen$703;
  signed int tmp_if_expr$708;
  signed int return_value_ConnectClient_get_listenFd$707;
  char return_value_ConnectClient_get_state$724;
  char return_value_ConnectUser_get_state$738;
  _Bool tmp_if_expr$740;
  char return_value_ConnectUser_get_state$739;
  char return_value_ConnectUser_get_state$747;
  _Bool tmp_if_expr$749;
  char return_value_ConnectUser_get_state$748;
  char *return_value_get_realmname$750;
  char *return_value_get_clientname$751;
  char return_value_ConnectClient_get_state$783;
  unsigned char *return_value_ServerRealm_get_password$781;
  unsigned char *return_value_ServerRealm_get_password$782;
  unsigned char *return_value_ServerRealm_get_password$779;
  unsigned char *return_value_ServerRealm_get_password$780;
  signed int return_value_ServerRealm_get_raClientsLimit$754;
  char *return_value_get_realmname$784;
  char *return_value_get_clientname$785;
  char *return_value_get_realmname$786;
  char *return_value_get_clientname$787;
  signed int return_value_ServerRealm_get_raClientsLimit$795;
  char return_value_ConnectClient_get_state$971;
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$967;
  signed int return_value_SslFd_get_fd$968;
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$969;
  signed int return_value_SslFd_get_fd$970;
  char *return_value_get_realmname$811;
  char *return_value_get_raclientname$812;
  char return_value_ConnectClient_get_state$904;
  _Bool tmp_if_expr$907;
  unsigned char *return_value_ServerRealm_get_password$905;
  unsigned char *return_value_ServerRealm_get_password$906;
  _Bool tmp_if_expr$910;
  unsigned char *return_value_ServerRealm_get_password$908;
  unsigned char *return_value_ServerRealm_get_password$909;
  signed int return_value_ServerRealm_get_clientsLimit$838;
  char return_value_ServerRealm_get_realmType$875;
  signed int *return_value_ConnectClient_get_listenFdp$877;
  signed int return_value_ConnectClient_get_usrCliPair$878;
  char *return_value_UsrCli_get_listenHostName$879;
  char *tmp_if_expr$883;
  signed int return_value_ConnectClient_get_usrCliPair$880;
  char *return_value_UsrCli_get_listenHostName$881;
  char *return_value_ServerRealm_get_hostName$882;
  signed int return_value_ip_listen$884;
  signed int tmp_if_expr$889;
  signed int return_value_ConnectClient_get_listenFd$888;
  char return_value_ConnectClient_get_state$903;
  char *return_value_get_realmname$911;
  char *return_value_get_raclientname$912;
  char return_value_ConnectClient_get_state$923;
  unsigned char *return_value_ServerRealm_get_password$921;
  unsigned char *return_value_ServerRealm_get_password$922;
  unsigned char *return_value_ServerRealm_get_password$919;
  unsigned char *return_value_ServerRealm_get_password$920;
  char return_value_ConnectClient_get_state$962;
  signed int return_value_ServerConfiguration_get_realmsNumber$926;
  struct auditlist *return_value_ConnectClient_get_auditList$939;
  struct alnode *return_value_AuditList_get_first$940;
  char *return_value_get_realmname$963;
  char *return_value_get_raclientname$964;
  signed int return_value_ServerRealm_get_userClientPairs$972;
  signed int return_value_ServerRealm_get_clientsLimit$981;
  signed int tmp_if_expr$1001;
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$999;
  signed int return_value_SslFd_get_fd$1000;
  signed int return_value_ServerRealm_get_raClientsLimit$1007;
  signed int tmp_if_expr$1027;
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$1025;
  signed int return_value_SslFd_get_fd$1026;
  do
  {
    rset = allset;
    tmpset = wset;
    aflog((char)16, (char)4, "select, maxfdp1: %d", maxfdp1);
    signed int return_value_TaskScheduler_hasMoreTasks$180;
    return_value_TaskScheduler_hasMoreTasks$180=TaskScheduler_hasMoreTasks(scheduler);
    if(!(return_value_TaskScheduler_hasMoreTasks$180 == 0))
    {
      TaskScheduler_startWatching(scheduler);
      struct timeval *return_value_TaskScheduler_get_actualTimer$179;
      return_value_TaskScheduler_get_actualTimer$179=TaskScheduler_get_actualTimer(scheduler);
      select(maxfdp1, &rset, &tmpset, (struct anonymous$22 *)(void *)0, return_value_TaskScheduler_get_actualTimer$179);
      TaskScheduler_stopWatching(scheduler);
    }

    else
      select(maxfdp1, &rset, &tmpset, (struct anonymous$22 *)(void *)0, (struct timeval *)(void *)0);
    aflog((char)16, (char)4, "after select...");
    j = 0;
    do
    {
      return_value_ServerConfiguration_get_realmsNumber$181=ServerConfiguration_get_realmsNumber(config);
      if(j >= return_value_ServerConfiguration_get_realmsNumber$181)
        break;

      pointer = scRealmsTable[(signed long int)j];
      srUsersTable=ServerRealm_get_usersTable(pointer);
      srClientsTable=ServerRealm_get_clientsTable(pointer);
      srRaClientsTable=ServerRealm_get_raClientsTable(pointer);
      srUsersClientsTable=ServerRealm_get_usersClientsTable(pointer);
      i = 0;
      do
      {
        return_value_ServerRealm_get_usersLimit$182=ServerRealm_get_usersLimit(pointer);
        if(i >= return_value_ServerRealm_get_usersLimit$182)
          break;

        char return_value_ConnectUser_get_state$275;
        return_value_ConnectUser_get_state$275=ConnectUser_get_state(srUsersTable[(signed long int)i]);
        if((signed int)return_value_ConnectUser_get_state$275 == 7)
          tmp_if_expr$277 = (_Bool)1;

        else
        {
          return_value_ConnectUser_get_state$276=ConnectUser_get_state(srUsersTable[(signed long int)i]);
          tmp_if_expr$277 = (signed int)return_value_ConnectUser_get_state$276 == 11 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$277)
          tmp_if_expr$279 = (_Bool)1;

        else
        {
          return_value_ConnectUser_get_state$278=ConnectUser_get_state(srUsersTable[(signed long int)i]);
          tmp_if_expr$279 = (signed int)return_value_ConnectUser_get_state$278 == 19 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$279)
        {
          signed int return_value_ConnectUser_get_connFd$273;
          return_value_ConnectUser_get_connFd$273=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
          signed int return_value_ConnectUser_get_connFd$274;
          return_value_ConnectUser_get_connFd$274=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
          if(!((rset.__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$273 / 8)] & 1l << return_value_ConnectUser_get_connFd$274 % 8) == 0l))
          {
            signed int return_value_ConnectUser_get_whatClient$183;
            return_value_ConnectUser_get_whatClient$183=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
            k=eval_usernum(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$183], i);
            char *return_value_get_realmname$184;
            return_value_get_realmname$184=get_realmname(config, j);
            signed int return_value_ConnectUser_get_whatClient$185;
            return_value_ConnectUser_get_whatClient$185=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
            char *return_value_get_clientname$186;
            return_value_get_clientname$186=get_clientname(pointer, return_value_ConnectUser_get_whatClient$185);
            signed int return_value_get_username$187;
            return_value_get_username$187=get_username(pointer, i);
            aflog((char)1, (char)4, "realm[%s]: Client[%s]: user[%d]: FD_ISSET", return_value_get_realmname$184, return_value_get_clientname$186, return_value_get_username$187);
            char return_value_ServerRealm_get_realmType$270;
            return_value_ServerRealm_get_realmType$270=ServerRealm_get_realmType(pointer);
            if(!((1 & (signed int)return_value_ServerRealm_get_realmType$270) == 0))
            {
              return_value_ServerRealm_get_realmType$271=ServerRealm_get_realmType(pointer);
              tmp_if_expr$272 = !(((signed int)return_value_ServerRealm_get_realmType$271 & 2) != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$272 = (_Bool)0;
            if(tmp_if_expr$272)
            {
              signed int return_value_ConnectUser_get_connFd$188;
              return_value_ConnectUser_get_connFd$188=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
              signed long int return_value_read$189;
              return_value_read$189=read(return_value_ConnectUser_get_connFd$188, (void *)&buff[(signed long int)5], (unsigned long int)8091);
              n = (signed int)return_value_read$189;
              if(n == -1)
              {
                signed int *return_value___errno_location$190;
                return_value___errno_location$190=__errno_location();
                if(*return_value___errno_location$190 == 11)
                  goto __CPROVER_DUMP_L212;

                char *return_value_get_realmname$191;
                return_value_get_realmname$191=get_realmname(config, j);
                signed int return_value_ConnectUser_get_whatClient$192;
                return_value_ConnectUser_get_whatClient$192=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                char *return_value_get_clientname$193;
                return_value_get_clientname$193=get_clientname(pointer, return_value_ConnectUser_get_whatClient$192);
                signed int return_value_get_username$194;
                return_value_get_username$194=get_username(pointer, i);
                signed int *return_value___errno_location$195;
                return_value___errno_location$195=__errno_location();
                aflog((char)1, (char)64, "realm[%s]: Client[%s]: user[%d]: READ ERROR (%d)", return_value_get_realmname$191, return_value_get_clientname$193, return_value_get_username$194, *return_value___errno_location$195);
                n = 0;
              }

              if(!(n == 0))
              {
                char *return_value_get_realmname$196;
                return_value_get_realmname$196=get_realmname(config, j);
                signed int return_value_ConnectUser_get_whatClient$197;
                return_value_ConnectUser_get_whatClient$197=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                char *return_value_get_clientname$198;
                return_value_get_clientname$198=get_clientname(pointer, return_value_ConnectUser_get_whatClient$197);
                signed int return_value_get_username$199;
                return_value_get_username$199=get_username(pointer, i);
                aflog((char)1, (char)2, "realm[%s]: Client[%s]: FROM user[%d]: MESSAGE length=%d", return_value_get_realmname$196, return_value_get_clientname$198, return_value_get_username$199, n);
                struct anonymous$6 *return_value_ConnectUser_get_stats$200;
                return_value_ConnectUser_get_stats$200=ConnectUser_get_stats(srUsersTable[(signed long int)i]);
                UserStats_add_upload(return_value_ConnectUser_get_stats$200, n);
                if((signed int)buff[5l] == 3)
                {
                  if((signed int)buff[6l] == 8)
                  {
                    if((signed int)buff[7l] == 3)
                      aflog((char)1, (char)32, "WARNING: got packet similiar to udp");

                  }

                }

                buff[(signed long int)0] = (unsigned char)3;
                buff[(signed long int)1] = (unsigned char)(k >> 8);
                buff[(signed long int)2] = (unsigned char)k;
                buff[(signed long int)3] = (unsigned char)(n >> 8);
                buff[(signed long int)4] = (unsigned char)n;
                char return_value_ServerRealm_get_realmType$201;
                return_value_ServerRealm_get_realmType$201=ServerRealm_get_realmType(pointer);
                signed int return_value_ConnectUser_get_whatClient$202;
                return_value_ConnectUser_get_whatClient$202=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                struct anonymous$1 *return_value_ConnectClient_get_sslFd$203;
                return_value_ConnectClient_get_sslFd$203=ConnectClient_get_sslFd(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$202]);
                SslFd_send_message(return_value_ServerRealm_get_realmType$201, return_value_ConnectClient_get_sslFd$203, buff, n + 5);
              }

              else
              {
                char *return_value_get_realmname$204;
                return_value_get_realmname$204=get_realmname(config, j);
                signed int return_value_ConnectUser_get_whatClient$205;
                return_value_ConnectUser_get_whatClient$205=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                char *return_value_get_clientname$206;
                return_value_get_clientname$206=get_clientname(pointer, return_value_ConnectUser_get_whatClient$205);
                signed int return_value_get_username$207;
                return_value_get_username$207=get_username(pointer, i);
                aflog((char)1, (char)8, "realm[%s]: Client[%s]: user[%d]: CLOSED", return_value_get_realmname$204, return_value_get_clientname$206, return_value_get_username$207);
                time(&now);
                char *return_value_get_realmname$208;
                return_value_get_realmname$208=get_realmname(config, j);
                signed int return_value_ConnectUser_get_whatClient$209;
                return_value_ConnectUser_get_whatClient$209=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                char *return_value_get_clientname$210;
                return_value_get_clientname$210=get_clientname(pointer, return_value_ConnectUser_get_whatClient$209);
                signed int return_value_get_username$211;
                return_value_get_username$211=get_username(pointer, i);
                char *return_value_ConnectUser_get_nameBuf$212;
                return_value_ConnectUser_get_nameBuf$212=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                char *return_value_ConnectUser_get_portBuf$213;
                return_value_ConnectUser_get_portBuf$213=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                signed long int return_value_ConnectUser_get_connectTime$214;
                return_value_ConnectUser_get_connectTime$214=ConnectUser_get_connectTime(srUsersTable[(signed long int)i]);
                char *return_value_timeperiod$215;
                return_value_timeperiod$215=timeperiod(now - return_value_ConnectUser_get_connectTime$214);
                aflog((char)1, (char)16, "REALM: %s CLIENT: %s USER: %d IP: %s PORT: %s DURATION: %s", return_value_get_realmname$208, return_value_get_clientname$210, return_value_get_username$211, return_value_ConnectUser_get_nameBuf$212, return_value_ConnectUser_get_portBuf$213, return_value_timeperiod$215);
                char return_value_ServerRealm_get_auditOn$224;
                return_value_ServerRealm_get_auditOn$224=ServerRealm_get_auditOn(pointer);
                if(!(return_value_ServerRealm_get_auditOn$224 == 0))
                {
                  signed int return_value_ConnectUser_get_whatClient$216;
                  return_value_ConnectUser_get_whatClient$216=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                  struct auditlist *return_value_ConnectClient_get_auditList$217;
                  return_value_ConnectClient_get_auditList$217=ConnectClient_get_auditList(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$216]);
                  signed int return_value_get_username$218;
                  return_value_get_username$218=get_username(pointer, i);
                  char *return_value_ConnectUser_get_nameBuf$219;
                  return_value_ConnectUser_get_nameBuf$219=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                  char *return_value_ConnectUser_get_portBuf$220;
                  return_value_ConnectUser_get_portBuf$220=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                  signed long int return_value_ConnectUser_get_connectTime$221;
                  return_value_ConnectUser_get_connectTime$221=ConnectUser_get_connectTime(srUsersTable[(signed long int)i]);
                  signed long int return_value_ConnectUser_get_connectTime$222;
                  return_value_ConnectUser_get_connectTime$222=ConnectUser_get_connectTime(srUsersTable[(signed long int)i]);
                  struct alnode *return_value_AuditListNode_new_entry$223;
                  return_value_AuditListNode_new_entry$223=AuditListNode_new_entry(return_value_get_username$218, return_value_ConnectUser_get_nameBuf$219, return_value_ConnectUser_get_portBuf$220, return_value_ConnectUser_get_connectTime$221, now - return_value_ConnectUser_get_connectTime$222);
                  AuditList_insert_back(return_value_ConnectClient_get_auditList$217, return_value_AuditListNode_new_entry$223);
                }

                signed int return_value_ConnectUser_get_connFd$225;
                return_value_ConnectUser_get_connFd$225=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                close(return_value_ConnectUser_get_connFd$225);
                signed int return_value_ConnectUser_get_connFd$226;
                return_value_ConnectUser_get_connFd$226=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                signed int return_value_ConnectUser_get_connFd$227;
                return_value_ConnectUser_get_connFd$227=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$226 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$226 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$227 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                signed int return_value_ConnectUser_get_connFd$228;
                return_value_ConnectUser_get_connFd$228=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                signed int return_value_ConnectUser_get_connFd$229;
                return_value_ConnectUser_get_connFd$229=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$228 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$228 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$229 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                char return_value_ConnectUser_get_state$233;
                return_value_ConnectUser_get_state$233=ConnectUser_get_state(srUsersTable[(signed long int)i]);
                if((signed int)return_value_ConnectUser_get_state$233 == 19)
                {
                  ConnectUser_set_state(srUsersTable[(signed long int)i], (char)0);
                  ServerRealm_decrease_connectedUsers(pointer);
                  signed int return_value_ConnectUser_get_whatClient$230;
                  return_value_ConnectUser_get_whatClient$230=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                  ConnectClient_decrease_connected(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$230]);
                  signed int return_value_ConnectUser_get_whatClient$231;
                  return_value_ConnectUser_get_whatClient$231=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                  signed int *return_value_ConnectClient_get_users$232;
                  return_value_ConnectClient_get_users$232=ConnectClient_get_users(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$231]);
                  return_value_ConnectClient_get_users$232[(signed long int)k] = -1;
                }

                else
                  ConnectUser_set_state(srUsersTable[(signed long int)i], (char)5);
                struct buflist *return_value_ConnectUser_get_bufList$234;
                return_value_ConnectUser_get_bufList$234=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
                BufList_clear(return_value_ConnectUser_get_bufList$234);
                buff[(signed long int)0] = (unsigned char)1;
                buff[(signed long int)1] = (unsigned char)(k >> 8);
                buff[(signed long int)2] = (unsigned char)k;
                char return_value_ServerRealm_get_realmType$235;
                return_value_ServerRealm_get_realmType$235=ServerRealm_get_realmType(pointer);
                signed int return_value_ConnectUser_get_whatClient$236;
                return_value_ConnectUser_get_whatClient$236=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                struct anonymous$1 *return_value_ConnectClient_get_sslFd$237;
                return_value_ConnectClient_get_sslFd$237=ConnectClient_get_sslFd(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$236]);
                SslFd_send_message(return_value_ServerRealm_get_realmType$235, return_value_ConnectClient_get_sslFd$237, buff, 5);
              }
            }

            else
            {
              signed int return_value_ConnectUser_get_connFd$238;
              return_value_ConnectUser_get_connFd$238=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
              n=readn(return_value_ConnectUser_get_connFd$238, buff, 5);
              if(!(n == 5))
                n = 0;

              if(!(n == 0))
              {
                if((signed int)buff[0l] == 3)
                  tmp_if_expr$247 = (signed int)buff[(signed long int)1] == 8 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$247 = (_Bool)0;
                if(tmp_if_expr$247)
                  tmp_if_expr$248 = (signed int)buff[(signed long int)2] == 3 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$248 = (_Bool)0;
                if(tmp_if_expr$248)
                {
                  length = (signed int)buff[(signed long int)3];
                  length = length << 8;
                  length = length + (signed int)buff[(signed long int)4];
                  signed int return_value_ConnectUser_get_connFd$246;
                  return_value_ConnectUser_get_connFd$246=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                  n=readn(return_value_ConnectUser_get_connFd$246, &buff[(signed long int)5], length);
                  if(!(n == 0))
                  {
                    char *return_value_get_realmname$239;
                    return_value_get_realmname$239=get_realmname(config, j);
                    signed int return_value_ConnectUser_get_whatClient$240;
                    return_value_ConnectUser_get_whatClient$240=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                    char *return_value_get_clientname$241;
                    return_value_get_clientname$241=get_clientname(pointer, return_value_ConnectUser_get_whatClient$240);
                    signed int return_value_get_username$242;
                    return_value_get_username$242=get_username(pointer, i);
                    aflog((char)1, (char)2, "realm[%s]: Client[%s]: FROM user[%d]: MESSAGE length=%d", return_value_get_realmname$239, return_value_get_clientname$241, return_value_get_username$242, n);
                    buff[(signed long int)1] = (unsigned char)(k >> 8);
                    buff[(signed long int)2] = (unsigned char)k;
                    char return_value_ServerRealm_get_realmType$243;
                    return_value_ServerRealm_get_realmType$243=ServerRealm_get_realmType(pointer);
                    signed int return_value_ConnectUser_get_whatClient$244;
                    return_value_ConnectUser_get_whatClient$244=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                    struct anonymous$1 *return_value_ConnectClient_get_sslFd$245;
                    return_value_ConnectClient_get_sslFd$245=ConnectClient_get_sslFd(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$244]);
                    SslFd_send_message(return_value_ServerRealm_get_realmType$243, return_value_ConnectClient_get_sslFd$245, buff, n + 5);
                  }

                }

                else
                  n = 0;
              }

              if(n == 0)
              {
                char *return_value_get_realmname$249;
                return_value_get_realmname$249=get_realmname(config, j);
                signed int return_value_ConnectUser_get_whatClient$250;
                return_value_ConnectUser_get_whatClient$250=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                char *return_value_get_clientname$251;
                return_value_get_clientname$251=get_clientname(pointer, return_value_ConnectUser_get_whatClient$250);
                signed int return_value_get_username$252;
                return_value_get_username$252=get_username(pointer, i);
                aflog((char)1, (char)8, "realm[%s]: Client[%s]: user[%d]: CLOSED (udp mode)", return_value_get_realmname$249, return_value_get_clientname$251, return_value_get_username$252);
                time(&now);
                char *return_value_get_realmname$253;
                return_value_get_realmname$253=get_realmname(config, j);
                signed int return_value_ConnectUser_get_whatClient$254;
                return_value_ConnectUser_get_whatClient$254=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                char *return_value_get_clientname$255;
                return_value_get_clientname$255=get_clientname(pointer, return_value_ConnectUser_get_whatClient$254);
                signed int return_value_get_username$256;
                return_value_get_username$256=get_username(pointer, i);
                char *return_value_ConnectUser_get_nameBuf$257;
                return_value_ConnectUser_get_nameBuf$257=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                char *return_value_ConnectUser_get_portBuf$258;
                return_value_ConnectUser_get_portBuf$258=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                signed long int return_value_ConnectUser_get_connectTime$259;
                return_value_ConnectUser_get_connectTime$259=ConnectUser_get_connectTime(srUsersTable[(signed long int)i]);
                char *return_value_timeperiod$260;
                return_value_timeperiod$260=timeperiod(now - return_value_ConnectUser_get_connectTime$259);
                aflog((char)1, (char)16, "REALM: %s CLIENT: %s USER: %d IP: %s PORT: %s DURATION: %s", return_value_get_realmname$253, return_value_get_clientname$255, return_value_get_username$256, return_value_ConnectUser_get_nameBuf$257, return_value_ConnectUser_get_portBuf$258, return_value_timeperiod$260);
                signed int return_value_ConnectUser_get_connFd$261;
                return_value_ConnectUser_get_connFd$261=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                close(return_value_ConnectUser_get_connFd$261);
                signed int return_value_ConnectUser_get_connFd$262;
                return_value_ConnectUser_get_connFd$262=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                signed int return_value_ConnectUser_get_connFd$263;
                return_value_ConnectUser_get_connFd$263=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$262 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$262 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$263 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                signed int return_value_ConnectUser_get_connFd$264;
                return_value_ConnectUser_get_connFd$264=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                signed int return_value_ConnectUser_get_connFd$265;
                return_value_ConnectUser_get_connFd$265=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$264 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$264 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$265 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                ConnectUser_set_state(srUsersTable[(signed long int)i], (char)5);
                struct buflist *return_value_ConnectUser_get_bufList$266;
                return_value_ConnectUser_get_bufList$266=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
                BufList_clear(return_value_ConnectUser_get_bufList$266);
                buff[(signed long int)0] = (unsigned char)1;
                buff[(signed long int)1] = (unsigned char)(k >> 8);
                buff[(signed long int)2] = (unsigned char)k;
                char return_value_ServerRealm_get_realmType$267;
                return_value_ServerRealm_get_realmType$267=ServerRealm_get_realmType(pointer);
                signed int return_value_ConnectUser_get_whatClient$268;
                return_value_ConnectUser_get_whatClient$268=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                struct anonymous$1 *return_value_ConnectClient_get_sslFd$269;
                return_value_ConnectClient_get_sslFd$269=ConnectClient_get_sslFd(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$268]);
                SslFd_send_message(return_value_ServerRealm_get_realmType$267, return_value_ConnectClient_get_sslFd$269, buff, 5);
              }

            }
          }

        }


      __CPROVER_DUMP_L212:
        ;
        i = i + 1;
      }
      while((_Bool)1);
      i = 0;
      do
      {
        return_value_ServerRealm_get_usersLimit$280=ServerRealm_get_usersLimit(pointer);
        if(i >= return_value_ServerRealm_get_usersLimit$280)
          break;

        char return_value_ConnectUser_get_state$376;
        return_value_ConnectUser_get_state$376=ConnectUser_get_state(srUsersTable[(signed long int)i]);
        if((signed int)return_value_ConnectUser_get_state$376 == 11)
          tmp_if_expr$378 = (_Bool)1;

        else
        {
          return_value_ConnectUser_get_state$377=ConnectUser_get_state(srUsersTable[(signed long int)i]);
          tmp_if_expr$378 = (signed int)return_value_ConnectUser_get_state$377 == 19 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$378)
        {
          return_value_ConnectUser_get_connFd$374=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
          return_value_ConnectUser_get_connFd$375=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
          if(!((tmpset.__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$374 / 8)] & 1l << return_value_ConnectUser_get_connFd$375 % 8) == 0l))
          {
            signed int return_value_ConnectUser_get_whatClient$281;
            return_value_ConnectUser_get_whatClient$281=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
            k=eval_usernum(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$281], i);
            char *return_value_get_realmname$282;
            return_value_get_realmname$282=get_realmname(config, j);
            signed int return_value_ConnectUser_get_whatClient$283;
            return_value_ConnectUser_get_whatClient$283=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
            char *return_value_get_clientname$284;
            return_value_get_clientname$284=get_clientname(pointer, return_value_ConnectUser_get_whatClient$283);
            signed int return_value_get_username$285;
            return_value_get_username$285=get_username(pointer, i);
            aflog((char)1, (char)4, "realm[%s]: Client[%s]: user[%d]: FD_ISSET - WRITE", return_value_get_realmname$282, return_value_get_clientname$284, return_value_get_username$285);
            struct buflist *return_value_ConnectUser_get_bufList$286;
            return_value_ConnectUser_get_bufList$286=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
            struct blnode *return_value_BufList_get_first$287;
            return_value_BufList_get_first$287=BufList_get_first(return_value_ConnectUser_get_bufList$286);
            n=BufListNode_readMessageLength(return_value_BufList_get_first$287);
            signed int return_value_ConnectUser_get_connFd$288;
            return_value_ConnectUser_get_connFd$288=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
            struct buflist *return_value_ConnectUser_get_bufList$289;
            return_value_ConnectUser_get_bufList$289=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
            struct blnode *return_value_BufList_get_first$290;
            return_value_BufList_get_first$290=BufList_get_first(return_value_ConnectUser_get_bufList$289);
            unsigned char *return_value_BufListNode_readMessage$291;
            return_value_BufListNode_readMessage$291=BufListNode_readMessage(return_value_BufList_get_first$290);
            signed long int return_value_write$292;
            return_value_write$292=write(return_value_ConnectUser_get_connFd$288, (const void *)return_value_BufListNode_readMessage$291, (unsigned long int)n);
            sent = (signed int)return_value_write$292;
            if(sent >= 1 && !(sent == n))
            {
              struct buflist *return_value_ConnectUser_get_bufList$293;
              return_value_ConnectUser_get_bufList$293=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
              struct blnode *return_value_BufList_get_first$294;
              return_value_BufList_get_first$294=BufList_get_first(return_value_ConnectUser_get_bufList$293);
              struct buflist *return_value_ConnectUser_get_bufList$295;
              return_value_ConnectUser_get_bufList$295=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
              struct blnode *return_value_BufList_get_first$296;
              return_value_BufList_get_first$296=BufList_get_first(return_value_ConnectUser_get_bufList$295);
              signed int return_value_BufListNode_get_actPtr$297;
              return_value_BufListNode_get_actPtr$297=BufListNode_get_actPtr(return_value_BufList_get_first$296);
              BufListNode_set_actPtr(return_value_BufList_get_first$294, return_value_BufListNode_get_actPtr$297 + sent);
              char *return_value_get_realmname$298;
              return_value_get_realmname$298=get_realmname(config, j);
              signed int return_value_ConnectUser_get_whatClient$299;
              return_value_ConnectUser_get_whatClient$299=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
              char *return_value_get_clientname$300;
              return_value_get_clientname$300=get_clientname(pointer, return_value_ConnectUser_get_whatClient$299);
              signed int return_value_get_username$301;
              return_value_get_username$301=get_username(pointer, i);
              aflog((char)1, (char)4, "realm[%s]: Client[%s]: user[%d]: (%d/%d)", return_value_get_realmname$298, return_value_get_clientname$300, return_value_get_username$301, sent, n);
            }

            else
            {
              if(sent == -1)
              {
                return_value___errno_location$372=__errno_location();
                tmp_if_expr$373 = *return_value___errno_location$372 == 11 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$373 = (_Bool)0;
              if(tmp_if_expr$373)
              {
                char *return_value_get_realmname$302;
                return_value_get_realmname$302=get_realmname(config, j);
                signed int return_value_ConnectUser_get_whatClient$303;
                return_value_ConnectUser_get_whatClient$303=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                char *return_value_get_clientname$304;
                return_value_get_clientname$304=get_clientname(pointer, return_value_ConnectUser_get_whatClient$303);
                signed int return_value_get_username$305;
                return_value_get_username$305=get_username(pointer, i);
                aflog((char)1, (char)4, "realm[%s]: Client[%s]: user[%d]: EAGAIN", return_value_get_realmname$302, return_value_get_clientname$304, return_value_get_username$305);
              }

              else
                if(sent == -1)
                {
                  char *return_value_get_realmname$306;
                  return_value_get_realmname$306=get_realmname(config, j);
                  signed int return_value_ConnectUser_get_whatClient$307;
                  return_value_ConnectUser_get_whatClient$307=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                  char *return_value_get_clientname$308;
                  return_value_get_clientname$308=get_clientname(pointer, return_value_ConnectUser_get_whatClient$307);
                  signed int return_value_get_username$309;
                  return_value_get_username$309=get_username(pointer, i);
                  aflog((char)1, (char)8, "realm[%s]: Client[%s]: user[%d]: CLOSED", return_value_get_realmname$306, return_value_get_clientname$308, return_value_get_username$309);
                  time(&now);
                  char *return_value_get_realmname$310;
                  return_value_get_realmname$310=get_realmname(config, j);
                  signed int return_value_ConnectUser_get_whatClient$311;
                  return_value_ConnectUser_get_whatClient$311=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                  char *return_value_get_clientname$312;
                  return_value_get_clientname$312=get_clientname(pointer, return_value_ConnectUser_get_whatClient$311);
                  signed int return_value_get_username$313;
                  return_value_get_username$313=get_username(pointer, i);
                  char *return_value_ConnectUser_get_nameBuf$314;
                  return_value_ConnectUser_get_nameBuf$314=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                  char *return_value_ConnectUser_get_portBuf$315;
                  return_value_ConnectUser_get_portBuf$315=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                  signed long int return_value_ConnectUser_get_connectTime$316;
                  return_value_ConnectUser_get_connectTime$316=ConnectUser_get_connectTime(srUsersTable[(signed long int)i]);
                  char *return_value_timeperiod$317;
                  return_value_timeperiod$317=timeperiod(now - return_value_ConnectUser_get_connectTime$316);
                  aflog((char)1, (char)16, "REALM: %s CLIENT: %s USER: %d IP: %s PORT: %s DURATION: %s", return_value_get_realmname$310, return_value_get_clientname$312, return_value_get_username$313, return_value_ConnectUser_get_nameBuf$314, return_value_ConnectUser_get_portBuf$315, return_value_timeperiod$317);
                  signed int return_value_ConnectUser_get_connFd$318;
                  return_value_ConnectUser_get_connFd$318=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                  close(return_value_ConnectUser_get_connFd$318);
                  signed int return_value_ConnectUser_get_connFd$319;
                  return_value_ConnectUser_get_connFd$319=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                  signed int return_value_ConnectUser_get_connFd$320;
                  return_value_ConnectUser_get_connFd$320=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                  (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$319 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$319 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$320 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  signed int return_value_ConnectUser_get_connFd$321;
                  return_value_ConnectUser_get_connFd$321=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                  signed int return_value_ConnectUser_get_connFd$322;
                  return_value_ConnectUser_get_connFd$322=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                  (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$321 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$321 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$322 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  char return_value_ConnectUser_get_state$326;
                  return_value_ConnectUser_get_state$326=ConnectUser_get_state(srUsersTable[(signed long int)i]);
                  if((signed int)return_value_ConnectUser_get_state$326 == 19)
                  {
                    ConnectUser_set_state(srUsersTable[(signed long int)i], (char)0);
                    ServerRealm_decrease_connectedUsers(pointer);
                    signed int return_value_ConnectUser_get_whatClient$323;
                    return_value_ConnectUser_get_whatClient$323=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                    ConnectClient_decrease_connected(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$323]);
                    signed int return_value_ConnectUser_get_whatClient$324;
                    return_value_ConnectUser_get_whatClient$324=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                    signed int *return_value_ConnectClient_get_users$325;
                    return_value_ConnectClient_get_users$325=ConnectClient_get_users(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$324]);
                    return_value_ConnectClient_get_users$325[(signed long int)k] = -1;
                  }

                  else
                    ConnectUser_set_state(srUsersTable[(signed long int)i], (char)5);
                  struct buflist *return_value_ConnectUser_get_bufList$327;
                  return_value_ConnectUser_get_bufList$327=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
                  BufList_clear(return_value_ConnectUser_get_bufList$327);
                  buff[(signed long int)0] = (unsigned char)1;
                  buff[(signed long int)1] = (unsigned char)(k >> 8);
                  buff[(signed long int)2] = (unsigned char)k;
                  char return_value_ServerRealm_get_realmType$328;
                  return_value_ServerRealm_get_realmType$328=ServerRealm_get_realmType(pointer);
                  signed int return_value_ConnectUser_get_whatClient$329;
                  return_value_ConnectUser_get_whatClient$329=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                  struct anonymous$1 *return_value_ConnectClient_get_sslFd$330;
                  return_value_ConnectClient_get_sslFd$330=ConnectClient_get_sslFd(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$329]);
                  SslFd_send_message(return_value_ServerRealm_get_realmType$328, return_value_ConnectClient_get_sslFd$330, buff, 5);
                }

                else
                {
                  char *return_value_get_realmname$331;
                  return_value_get_realmname$331=get_realmname(config, j);
                  signed int return_value_ConnectUser_get_whatClient$332;
                  return_value_ConnectUser_get_whatClient$332=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                  char *return_value_get_clientname$333;
                  return_value_get_clientname$333=get_clientname(pointer, return_value_ConnectUser_get_whatClient$332);
                  signed int return_value_get_username$334;
                  return_value_get_username$334=get_username(pointer, i);
                  aflog((char)1, (char)4, "realm[%s]: Client[%s]: user[%d]: (%d/%d)", return_value_get_realmname$331, return_value_get_clientname$333, return_value_get_username$334, sent, n);
                  struct buflist *return_value_ConnectUser_get_bufList$335;
                  return_value_ConnectUser_get_bufList$335=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
                  BufList_delete_first(return_value_ConnectUser_get_bufList$335);
                  struct buflist *return_value_ConnectUser_get_bufList$370;
                  return_value_ConnectUser_get_bufList$370=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
                  struct blnode *return_value_BufList_get_first$371;
                  return_value_BufList_get_first$371=BufList_get_first(return_value_ConnectUser_get_bufList$370);
                  if(return_value_BufList_get_first$371 == ((struct blnode *)NULL))
                  {
                    signed int return_value_ConnectUser_get_connFd$336;
                    return_value_ConnectUser_get_connFd$336=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                    signed int return_value_ConnectUser_get_connFd$337;
                    return_value_ConnectUser_get_connFd$337=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                    (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$336 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$336 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$337 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                    buff[(signed long int)0] = (unsigned char)10;
                    buff[(signed long int)1] = (unsigned char)(k >> 8);
                    buff[(signed long int)2] = (unsigned char)k;
                    char *return_value_get_realmname$338;
                    return_value_get_realmname$338=get_realmname(config, j);
                    signed int return_value_ConnectUser_get_whatClient$339;
                    return_value_ConnectUser_get_whatClient$339=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                    char *return_value_get_clientname$340;
                    return_value_get_clientname$340=get_clientname(pointer, return_value_ConnectUser_get_whatClient$339);
                    signed int return_value_get_username$341;
                    return_value_get_username$341=get_username(pointer, i);
                    aflog((char)1, (char)4, "realm[%s]: Client[%s]: TO user[%d]: BUFFERING MESSAGE ENDED", return_value_get_realmname$338, return_value_get_clientname$340, return_value_get_username$341);
                    char return_value_ServerRealm_get_realmType$342;
                    return_value_ServerRealm_get_realmType$342=ServerRealm_get_realmType(pointer);
                    signed int return_value_ConnectUser_get_whatClient$343;
                    return_value_ConnectUser_get_whatClient$343=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                    struct anonymous$1 *return_value_ConnectClient_get_sslFd$344;
                    return_value_ConnectClient_get_sslFd$344=ConnectClient_get_sslFd(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$343]);
                    SslFd_send_message(return_value_ServerRealm_get_realmType$342, return_value_ConnectClient_get_sslFd$344, buff, 5);
                    char return_value_ConnectUser_get_state$369;
                    return_value_ConnectUser_get_state$369=ConnectUser_get_state(srUsersTable[(signed long int)i]);
                    if((signed int)return_value_ConnectUser_get_state$369 == 19)
                    {
                      char *return_value_get_realmname$345;
                      return_value_get_realmname$345=get_realmname(config, j);
                      signed int return_value_ConnectUser_get_whatClient$346;
                      return_value_ConnectUser_get_whatClient$346=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                      char *return_value_get_clientname$347;
                      return_value_get_clientname$347=get_clientname(pointer, return_value_ConnectUser_get_whatClient$346);
                      signed int return_value_get_username$348;
                      return_value_get_username$348=get_username(pointer, i);
                      aflog((char)1, (char)8, "realm[%s]: Client[%s]: user[%d]: delayed CLOSED", return_value_get_realmname$345, return_value_get_clientname$347, return_value_get_username$348);
                      time(&now);
                      char *return_value_get_realmname$349;
                      return_value_get_realmname$349=get_realmname(config, j);
                      signed int return_value_ConnectUser_get_whatClient$350;
                      return_value_ConnectUser_get_whatClient$350=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                      char *return_value_get_clientname$351;
                      return_value_get_clientname$351=get_clientname(pointer, return_value_ConnectUser_get_whatClient$350);
                      signed int return_value_get_username$352;
                      return_value_get_username$352=get_username(pointer, i);
                      char *return_value_ConnectUser_get_nameBuf$353;
                      return_value_ConnectUser_get_nameBuf$353=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                      char *return_value_ConnectUser_get_portBuf$354;
                      return_value_ConnectUser_get_portBuf$354=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                      signed long int return_value_ConnectUser_get_connectTime$355;
                      return_value_ConnectUser_get_connectTime$355=ConnectUser_get_connectTime(srUsersTable[(signed long int)i]);
                      char *return_value_timeperiod$356;
                      return_value_timeperiod$356=timeperiod(now - return_value_ConnectUser_get_connectTime$355);
                      aflog((char)1, (char)16, "REALM: %s CLIENT: %s USER: %d IP: %s PORT: %s DURATION: %s", return_value_get_realmname$349, return_value_get_clientname$351, return_value_get_username$352, return_value_ConnectUser_get_nameBuf$353, return_value_ConnectUser_get_portBuf$354, return_value_timeperiod$356);
                      signed int return_value_ConnectUser_get_connFd$357;
                      return_value_ConnectUser_get_connFd$357=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                      close(return_value_ConnectUser_get_connFd$357);
                      signed int return_value_ConnectUser_get_connFd$358;
                      return_value_ConnectUser_get_connFd$358=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                      signed int return_value_ConnectUser_get_connFd$359;
                      return_value_ConnectUser_get_connFd$359=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                      (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$358 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$358 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$359 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                      signed int return_value_ConnectUser_get_connFd$360;
                      return_value_ConnectUser_get_connFd$360=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                      signed int return_value_ConnectUser_get_connFd$361;
                      return_value_ConnectUser_get_connFd$361=ConnectUser_get_connFd(srUsersTable[(signed long int)i]);
                      (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$360 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$360 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$361 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                      ConnectUser_set_state(srUsersTable[(signed long int)i], (char)0);
                      ServerRealm_decrease_connectedUsers(pointer);
                      signed int return_value_ConnectUser_get_whatClient$362;
                      return_value_ConnectUser_get_whatClient$362=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                      ConnectClient_decrease_connected(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$362]);
                      signed int return_value_ConnectUser_get_whatClient$363;
                      return_value_ConnectUser_get_whatClient$363=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                      signed int *return_value_ConnectClient_get_users$364;
                      return_value_ConnectClient_get_users$364=ConnectClient_get_users(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$363]);
                      return_value_ConnectClient_get_users$364[(signed long int)k] = -1;
                      struct buflist *return_value_ConnectUser_get_bufList$365;
                      return_value_ConnectUser_get_bufList$365=ConnectUser_get_bufList(srUsersTable[(signed long int)i]);
                      BufList_clear(return_value_ConnectUser_get_bufList$365);
                      buff[(signed long int)0] = (unsigned char)1;
                      buff[(signed long int)1] = (unsigned char)(k >> 8);
                      buff[(signed long int)2] = (unsigned char)k;
                      char return_value_ServerRealm_get_realmType$366;
                      return_value_ServerRealm_get_realmType$366=ServerRealm_get_realmType(pointer);
                      signed int return_value_ConnectUser_get_whatClient$367;
                      return_value_ConnectUser_get_whatClient$367=ConnectUser_get_whatClient(srUsersTable[(signed long int)i]);
                      struct anonymous$1 *return_value_ConnectClient_get_sslFd$368;
                      return_value_ConnectClient_get_sslFd$368=ConnectClient_get_sslFd(srClientsTable[(signed long int)return_value_ConnectUser_get_whatClient$367]);
                      SslFd_send_message(return_value_ServerRealm_get_realmType$366, return_value_ConnectClient_get_sslFd$368, buff, 5);
                    }

                    else
                      ConnectUser_set_state(srUsersTable[(signed long int)i], (char)7);
                  }

                }
            }
          }

        }

        i = i + 1;
      }
      while((_Bool)1);
      char return_value_ServerRealm_get_basePortOn$417;
      return_value_ServerRealm_get_basePortOn$417=ServerRealm_get_basePortOn(pointer);
      if((signed int)return_value_ServerRealm_get_basePortOn$417 == 0)
      {
        l = 0;
        do
        {
          return_value_ServerRealm_get_userClientPairs$379=ServerRealm_get_userClientPairs(pointer);
          if(l >= return_value_ServerRealm_get_userClientPairs$379)
            break;

          signed int return_value_UsrCli_get_listenFd$415;
          return_value_UsrCli_get_listenFd$415=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)l]);
          signed int return_value_UsrCli_get_listenFd$416;
          return_value_UsrCli_get_listenFd$416=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)l]);
          if(!((rset.__fds_bits[(signed long int)(return_value_UsrCli_get_listenFd$415 / 8)] & 1l << return_value_UsrCli_get_listenFd$416 % 8) == 0l))
          {
            len=ServerRealm_get_addressLength(pointer);
            signed int return_value_UsrCli_get_listenFd$380;
            return_value_UsrCli_get_listenFd$380=UsrCli_get_listenFd(srUsersClientsTable[(signed long int)l]);
            struct sockaddr *return_value_ServerRealm_get_clientAddress$381;
            return_value_ServerRealm_get_clientAddress$381=ServerRealm_get_clientAddress(pointer);
            sent=accept(return_value_UsrCli_get_listenFd$380, return_value_ServerRealm_get_clientAddress$381, &len);
            if(sent == -1)
            {
              signed int *return_value___errno_location$385;
              return_value___errno_location$385=__errno_location();
              if(*return_value___errno_location$385 == 11)
              {
                char *return_value_get_realmname$382;
                return_value_get_realmname$382=get_realmname(config, j);
                aflog((char)1, (char)4, "realm[%s]: listenfd: FD_ISSET --> EAGAIN", return_value_get_realmname$382);
              }

              else
              {
                char *return_value_get_realmname$383;
                return_value_get_realmname$383=get_realmname(config, j);
                signed int *return_value___errno_location$384;
                return_value___errno_location$384=__errno_location();
                aflog((char)1, (char)4, "realm[%s]: listenfd: FD_ISSET --> errno=%d", return_value_get_realmname$383, *return_value___errno_location$384);
              }
              goto __CPROVER_DUMP_L244;
            }

            flags=fcntl(sent, 3, 0);
            fcntl(sent, 4, flags | 04000);
            char *return_value_get_realmname$386;
            return_value_get_realmname$386=get_realmname(config, j);
            aflog((char)1, (char)4, "realm[%s]: listenfd: FD_ISSET", return_value_get_realmname$386);
            signed int return_value_ServerRealm_get_clientMode$387;
            return_value_ServerRealm_get_clientMode$387=ServerRealm_get_clientMode(pointer);
            k=find_client(pointer, (char)return_value_ServerRealm_get_clientMode$387, l);
            char return_value_ConnectClient_get_state$414;
            return_value_ConnectClient_get_state$414=ConnectClient_get_state(srClientsTable[(signed long int)k]);
            if((signed int)return_value_ConnectClient_get_state$414 == 3)
            {
              signed int return_value_ServerRealm_get_connectedUsers$411;
              return_value_ServerRealm_get_connectedUsers$411=ServerRealm_get_connectedUsers(pointer);
              signed int return_value_ServerRealm_get_usersLimit$412;
              return_value_ServerRealm_get_usersLimit$412=ServerRealm_get_usersLimit(pointer);
              if(return_value_ServerRealm_get_connectedUsers$411 == return_value_ServerRealm_get_usersLimit$412)
              {
                close(sent);
                char *return_value_get_realmname$388;
                return_value_get_realmname$388=get_realmname(config, j);
                aflog((char)1, (char)32, "realm[%s]: user limit EXCEEDED", return_value_get_realmname$388);
              }

              else
              {
                return_value_ConnectClient_get_connected$409=ConnectClient_get_connected(srClientsTable[(signed long int)k]);
                return_value_ConnectClient_get_limit$410=ConnectClient_get_limit(srClientsTable[(signed long int)k]);
                if(return_value_ConnectClient_get_connected$409 == return_value_ConnectClient_get_limit$410)
                {
                  close(sent);
                  char *return_value_get_realmname$389;
                  return_value_get_realmname$389=get_realmname(config, j);
                  char *return_value_get_clientname$390;
                  return_value_get_clientname$390=get_clientname(pointer, k);
                  aflog((char)1, (char)32, "realm[%s]: Client[%s]: usrpcli limit EXCEEDED", return_value_get_realmname$389, return_value_get_clientname$390);
                }

                else
                {
                  i = 0;
                  do
                  {
                    return_value_ServerRealm_get_usersLimit$391=ServerRealm_get_usersLimit(pointer);
                    if(i >= return_value_ServerRealm_get_usersLimit$391)
                      break;

                    char return_value_ConnectUser_get_state$408;
                    return_value_ConnectUser_get_state$408=ConnectUser_get_state(srUsersTable[(signed long int)i]);
                    if((signed int)return_value_ConnectUser_get_state$408 == 0)
                    {
                      signed int return_value_ServerRealm_get_usersCounter$392;
                      return_value_ServerRealm_get_usersCounter$392=ServerRealm_get_usersCounter(pointer);
                      ConnectUser_set_userId(srUsersTable[(signed long int)i], return_value_ServerRealm_get_usersCounter$392);
                      ServerRealm_increase_usersCounter(pointer);
                      char *return_value_get_realmname$393;
                      return_value_get_realmname$393=get_realmname(config, j);
                      char *return_value_get_clientname$394;
                      return_value_get_clientname$394=get_clientname(pointer, k);
                      struct sockaddr *return_value_ServerRealm_get_clientAddress$395;
                      return_value_ServerRealm_get_clientAddress$395=ServerRealm_get_clientAddress(pointer);
                      char *return_value_ConnectUser_get_nameBuf$396;
                      return_value_ConnectUser_get_nameBuf$396=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                      char *return_value_ConnectUser_get_portBuf$397;
                      return_value_ConnectUser_get_portBuf$397=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                      char return_value_ServerRealm_get_dnsLookupsOn$398;
                      return_value_ServerRealm_get_dnsLookupsOn$398=ServerRealm_get_dnsLookupsOn(pointer);
                      char *return_value_sock_ntop$399;
                      return_value_sock_ntop$399=sock_ntop(return_value_ServerRealm_get_clientAddress$395, len, return_value_ConnectUser_get_nameBuf$396, return_value_ConnectUser_get_portBuf$397, return_value_ServerRealm_get_dnsLookupsOn$398);
                      aflog((char)1, (char)8, "realm[%s]: Client[%s]: new user: CONNECTING from IP: %s", return_value_get_realmname$393, return_value_get_clientname$394, return_value_sock_ntop$399);
                      ConnectUser_set_connFd(srUsersTable[(signed long int)i], sent);
                      ConnectUser_set_state(srUsersTable[(signed long int)i], (char)6);
                      ConnectUser_set_whatClient(srUsersTable[(signed long int)i], k);
                      time(&now);
                      ConnectUser_set_connectTime(srUsersTable[(signed long int)i], now);
                      struct anonymous$6 *return_value_ConnectUser_get_stats$400;
                      return_value_ConnectUser_get_stats$400=ConnectUser_get_stats(srUsersTable[(signed long int)i]);
                      UserStats_clear(return_value_ConnectUser_get_stats$400);
                      struct anonymous$6 *return_value_ConnectUser_get_stats$401;
                      return_value_ConnectUser_get_stats$401=ConnectUser_get_stats(srUsersTable[(signed long int)i]);
                      UserStats_set_lastActivity(return_value_ConnectUser_get_stats$401, now);
                      ServerRealm_increase_connectedUsers(pointer);
                      ConnectClient_increase_connected(srClientsTable[(signed long int)k]);
                      char *return_value_ConnectUser_get_nameBuf$402;
                      return_value_ConnectUser_get_nameBuf$402=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                      memcpy((void *)&buff[(signed long int)5], (const void *)return_value_ConnectUser_get_nameBuf$402, (unsigned long int)128);
                      char *return_value_ConnectUser_get_portBuf$403;
                      return_value_ConnectUser_get_portBuf$403=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                      memcpy((void *)&buff[(signed long int)133], (const void *)return_value_ConnectUser_get_portBuf$403, (unsigned long int)7);
                      n = 135;
                      char return_value_ConnectClient_get_multi$405;
                      return_value_ConnectClient_get_multi$405=ConnectClient_get_multi(srClientsTable[(signed long int)k]);
                      if((signed int)return_value_ConnectClient_get_multi$405 == 1)
                      {
                        n = 136;
                        signed int return_value_UsrCli_get_number$404;
                        return_value_UsrCli_get_number$404=UsrCli_get_number(srUsersClientsTable[(signed long int)l]);
                        buff[(signed long int)140] = (unsigned char)return_value_UsrCli_get_number$404;
                      }

                      i=find_usernum(srClientsTable[(signed long int)k], i);
                      buff[(signed long int)0] = (unsigned char)2;
                      buff[(signed long int)1] = (unsigned char)(i >> 8);
                      buff[(signed long int)2] = (unsigned char)i;
                      buff[(signed long int)3] = (unsigned char)(n >> 8);
                      buff[(signed long int)4] = (unsigned char)n;
                      char return_value_ServerRealm_get_realmType$406;
                      return_value_ServerRealm_get_realmType$406=ServerRealm_get_realmType(pointer);
                      struct anonymous$1 *return_value_ConnectClient_get_sslFd$407;
                      return_value_ConnectClient_get_sslFd$407=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                      SslFd_send_message(return_value_ServerRealm_get_realmType$406, return_value_ConnectClient_get_sslFd$407, buff, n + 5);
                      break;
                    }

                    i = i + 1;
                  }
                  while((_Bool)1);
                }
              }
            }

            else
            {
              close(sent);
              char *return_value_get_realmname$413;
              return_value_get_realmname$413=get_realmname(config, j);
              aflog((char)1, (char)64, "realm[%s]: Client(%d) is NOT CONNECTED", return_value_get_realmname$413, k);
            }
          }


        __CPROVER_DUMP_L244:
          ;
          l = l + 1;
        }
        while((_Bool)1);
      }

      char return_value_ServerRealm_get_basePortOn$453;
      return_value_ServerRealm_get_basePortOn$453=ServerRealm_get_basePortOn(pointer);
      if((signed int)return_value_ServerRealm_get_basePortOn$453 == 1)
      {
        k = 0;
        do
        {
          return_value_ServerRealm_get_clientsLimit$418=ServerRealm_get_clientsLimit(pointer);
          if(k >= return_value_ServerRealm_get_clientsLimit$418)
            break;

          char return_value_ConnectClient_get_state$452;
          return_value_ConnectClient_get_state$452=ConnectClient_get_state(srClientsTable[(signed long int)k]);
          if((signed int)return_value_ConnectClient_get_state$452 == 3)
          {
            signed int return_value_ConnectClient_get_listenFd$450;
            return_value_ConnectClient_get_listenFd$450=ConnectClient_get_listenFd(srClientsTable[(signed long int)k]);
            signed int return_value_ConnectClient_get_listenFd$451;
            return_value_ConnectClient_get_listenFd$451=ConnectClient_get_listenFd(srClientsTable[(signed long int)k]);
            if(!((rset.__fds_bits[(signed long int)(return_value_ConnectClient_get_listenFd$450 / 8)] & 1l << return_value_ConnectClient_get_listenFd$451 % 8) == 0l))
            {
              len=ServerRealm_get_addressLength(pointer);
              signed int return_value_ConnectClient_get_listenFd$419;
              return_value_ConnectClient_get_listenFd$419=ConnectClient_get_listenFd(srClientsTable[(signed long int)k]);
              struct sockaddr *return_value_ServerRealm_get_clientAddress$420;
              return_value_ServerRealm_get_clientAddress$420=ServerRealm_get_clientAddress(pointer);
              sent=accept(return_value_ConnectClient_get_listenFd$419, return_value_ServerRealm_get_clientAddress$420, &len);
              if(sent == -1)
              {
                signed int *return_value___errno_location$424;
                return_value___errno_location$424=__errno_location();
                if(*return_value___errno_location$424 == 11)
                {
                  char *return_value_get_realmname$421;
                  return_value_get_realmname$421=get_realmname(config, j);
                  aflog((char)1, (char)4, "realm[%s]: listenfd: FD_ISSET --> EAGAIN", return_value_get_realmname$421);
                }

                else
                {
                  char *return_value_get_realmname$422;
                  return_value_get_realmname$422=get_realmname(config, j);
                  signed int *return_value___errno_location$423;
                  return_value___errno_location$423=__errno_location();
                  aflog((char)1, (char)4, "realm[%s]: listenfd: FD_ISSET --> errno=%d", return_value_get_realmname$422, *return_value___errno_location$423);
                }
                goto __CPROVER_DUMP_L259;
              }

              flags=fcntl(sent, 3, 0);
              fcntl(sent, 4, flags | 04000);
              char *return_value_get_realmname$425;
              return_value_get_realmname$425=get_realmname(config, j);
              char *return_value_get_clientname$426;
              return_value_get_clientname$426=get_clientname(pointer, k);
              aflog((char)1, (char)4, "realm[%s]: Client[%s]: listenfd: FD_ISSET", return_value_get_realmname$425, return_value_get_clientname$426);
              signed int return_value_ServerRealm_get_connectedUsers$448;
              return_value_ServerRealm_get_connectedUsers$448=ServerRealm_get_connectedUsers(pointer);
              signed int return_value_ServerRealm_get_usersLimit$449;
              return_value_ServerRealm_get_usersLimit$449=ServerRealm_get_usersLimit(pointer);
              if(return_value_ServerRealm_get_connectedUsers$448 == return_value_ServerRealm_get_usersLimit$449)
              {
                close(sent);
                char *return_value_get_realmname$427;
                return_value_get_realmname$427=get_realmname(config, j);
                aflog((char)1, (char)32, "realm[%s]: user limit EXCEEDED", return_value_get_realmname$427);
              }

              else
              {
                return_value_ConnectClient_get_connected$446=ConnectClient_get_connected(srClientsTable[(signed long int)k]);
                return_value_ConnectClient_get_limit$447=ConnectClient_get_limit(srClientsTable[(signed long int)k]);
                if(return_value_ConnectClient_get_connected$446 == return_value_ConnectClient_get_limit$447)
                {
                  close(sent);
                  char *return_value_get_realmname$428;
                  return_value_get_realmname$428=get_realmname(config, j);
                  char *return_value_get_clientname$429;
                  return_value_get_clientname$429=get_clientname(pointer, k);
                  aflog((char)1, (char)32, "realm[%s]: Client[%s]: usrpcli limit EXCEEDED", return_value_get_realmname$428, return_value_get_clientname$429);
                }

                else
                {
                  i = 0;
                  do
                  {
                    return_value_ServerRealm_get_usersLimit$430=ServerRealm_get_usersLimit(pointer);
                    if(i >= return_value_ServerRealm_get_usersLimit$430)
                      break;

                    char return_value_ConnectUser_get_state$445;
                    return_value_ConnectUser_get_state$445=ConnectUser_get_state(srUsersTable[(signed long int)i]);
                    if((signed int)return_value_ConnectUser_get_state$445 == 0)
                    {
                      signed int return_value_ServerRealm_get_usersCounter$431;
                      return_value_ServerRealm_get_usersCounter$431=ServerRealm_get_usersCounter(pointer);
                      ConnectUser_set_userId(srUsersTable[(signed long int)i], return_value_ServerRealm_get_usersCounter$431);
                      ServerRealm_increase_usersCounter(pointer);
                      char *return_value_get_realmname$432;
                      return_value_get_realmname$432=get_realmname(config, j);
                      char *return_value_get_clientname$433;
                      return_value_get_clientname$433=get_clientname(pointer, k);
                      struct sockaddr *return_value_ServerRealm_get_clientAddress$434;
                      return_value_ServerRealm_get_clientAddress$434=ServerRealm_get_clientAddress(pointer);
                      char *return_value_ConnectUser_get_nameBuf$435;
                      return_value_ConnectUser_get_nameBuf$435=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                      char *return_value_ConnectUser_get_portBuf$436;
                      return_value_ConnectUser_get_portBuf$436=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                      char return_value_ServerRealm_get_dnsLookupsOn$437;
                      return_value_ServerRealm_get_dnsLookupsOn$437=ServerRealm_get_dnsLookupsOn(pointer);
                      char *return_value_sock_ntop$438;
                      return_value_sock_ntop$438=sock_ntop(return_value_ServerRealm_get_clientAddress$434, len, return_value_ConnectUser_get_nameBuf$435, return_value_ConnectUser_get_portBuf$436, return_value_ServerRealm_get_dnsLookupsOn$437);
                      aflog((char)1, (char)8, "realm[%s]: Client[%s]: new user: CONNECTING from IP: %s", return_value_get_realmname$432, return_value_get_clientname$433, return_value_sock_ntop$438);
                      ConnectUser_set_connFd(srUsersTable[(signed long int)i], sent);
                      ConnectUser_set_state(srUsersTable[(signed long int)i], (char)6);
                      ConnectUser_set_whatClient(srUsersTable[(signed long int)i], k);
                      time(&now);
                      ConnectUser_set_connectTime(srUsersTable[(signed long int)i], now);
                      struct anonymous$6 *return_value_ConnectUser_get_stats$439;
                      return_value_ConnectUser_get_stats$439=ConnectUser_get_stats(srUsersTable[(signed long int)i]);
                      UserStats_clear(return_value_ConnectUser_get_stats$439);
                      struct anonymous$6 *return_value_ConnectUser_get_stats$440;
                      return_value_ConnectUser_get_stats$440=ConnectUser_get_stats(srUsersTable[(signed long int)i]);
                      UserStats_set_lastActivity(return_value_ConnectUser_get_stats$440, now);
                      ServerRealm_increase_connectedUsers(pointer);
                      ConnectClient_increase_connected(srClientsTable[(signed long int)k]);
                      char *return_value_ConnectUser_get_nameBuf$441;
                      return_value_ConnectUser_get_nameBuf$441=ConnectUser_get_nameBuf(srUsersTable[(signed long int)i]);
                      memcpy((void *)&buff[(signed long int)5], (const void *)return_value_ConnectUser_get_nameBuf$441, (unsigned long int)128);
                      char *return_value_ConnectUser_get_portBuf$442;
                      return_value_ConnectUser_get_portBuf$442=ConnectUser_get_portBuf(srUsersTable[(signed long int)i]);
                      memcpy((void *)&buff[(signed long int)133], (const void *)return_value_ConnectUser_get_portBuf$442, (unsigned long int)7);
                      n = 135;
                      i=find_usernum(srClientsTable[(signed long int)k], i);
                      buff[(signed long int)0] = (unsigned char)2;
                      buff[(signed long int)1] = (unsigned char)(i >> 8);
                      buff[(signed long int)2] = (unsigned char)i;
                      buff[(signed long int)3] = (unsigned char)(n >> 8);
                      buff[(signed long int)4] = (unsigned char)n;
                      char return_value_ServerRealm_get_realmType$443;
                      return_value_ServerRealm_get_realmType$443=ServerRealm_get_realmType(pointer);
                      struct anonymous$1 *return_value_ConnectClient_get_sslFd$444;
                      return_value_ConnectClient_get_sslFd$444=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                      SslFd_send_message(return_value_ServerRealm_get_realmType$443, return_value_ConnectClient_get_sslFd$444, buff, n + 5);
                      break;
                    }

                    i = i + 1;
                  }
                  while((_Bool)1);
                }
              }
            }

          }


        __CPROVER_DUMP_L259:
          ;
          k = k + 1;
        }
        while((_Bool)1);
      }

      k = 0;
      do
      {
        return_value_ServerRealm_get_clientsLimit$454=ServerRealm_get_clientsLimit(pointer);
        if(k >= return_value_ServerRealm_get_clientsLimit$454)
          break;

        return_value_ConnectClient_get_state$794=ConnectClient_get_state(srClientsTable[(signed long int)k]);
        if((signed int)return_value_ConnectClient_get_state$794 >= 1)
        {
          return_value_ConnectClient_get_sslFd$790=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
          return_value_SslFd_get_fd$791=SslFd_get_fd(return_value_ConnectClient_get_sslFd$790);
          return_value_ConnectClient_get_sslFd$792=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
          return_value_SslFd_get_fd$793=SslFd_get_fd(return_value_ConnectClient_get_sslFd$792);
          if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd$791 / 8)] & 1l << return_value_SslFd_get_fd$793 % 8) == 0l))
          {
            char return_value_ConnectClient_get_state$472;
            return_value_ConnectClient_get_state$472=ConnectClient_get_state(srClientsTable[(signed long int)k]);
            if((signed int)return_value_ConnectClient_get_state$472 == 1)
            {
              struct anonymous$1 *return_value_ConnectClient_get_sslFd$455;
              return_value_ConnectClient_get_sslFd$455=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              make_ssl_initialize(return_value_ConnectClient_get_sslFd$455);
              char *return_value_get_realmname$456;
              return_value_get_realmname$456=get_realmname(config, j);
              char *return_value_get_clientname$457;
              return_value_get_clientname$457=get_clientname(pointer, k);
              aflog((char)2, (char)4, "realm[%s]: new Client[%s]: SSL_accept", return_value_get_realmname$456, return_value_get_clientname$457);
              struct anonymous$1 *return_value_ConnectClient_get_sslFd$458;
              return_value_ConnectClient_get_sslFd$458=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              signed int return_value_make_ssl_accept$459;
              return_value_make_ssl_accept$459=make_ssl_accept(return_value_ConnectClient_get_sslFd$458);
              switch(return_value_make_ssl_accept$459)
              {
                case 2:
                {
                  struct anonymous$1 *return_value_ConnectClient_get_sslFd$460;
                  return_value_ConnectClient_get_sslFd$460=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                  signed int return_value_SslFd_get_fd$461;
                  return_value_SslFd_get_fd$461=SslFd_get_fd(return_value_ConnectClient_get_sslFd$460);
                  close(return_value_SslFd_get_fd$461);
                  struct anonymous$1 *return_value_ConnectClient_get_sslFd$462;
                  return_value_ConnectClient_get_sslFd$462=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                  signed int return_value_SslFd_get_fd$463;
                  return_value_SslFd_get_fd$463=SslFd_get_fd(return_value_ConnectClient_get_sslFd$462);
                  struct anonymous$1 *return_value_ConnectClient_get_sslFd$464;
                  return_value_ConnectClient_get_sslFd$464=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                  signed int return_value_SslFd_get_fd$465;
                  return_value_SslFd_get_fd$465=SslFd_get_fd(return_value_ConnectClient_get_sslFd$464);
                  (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd$463 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd$463 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_SslFd_get_fd$465 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  struct anonymous$1 *return_value_ConnectClient_get_sslFd$466;
                  return_value_ConnectClient_get_sslFd$466=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                  struct ssl_st *return_value_SSL_new$467;
                  return_value_SSL_new$467=SSL_new(ctx);
                  SslFd_set_ssl(return_value_ConnectClient_get_sslFd$466, return_value_SSL_new$467);
                  ConnectClient_set_state(srClientsTable[(signed long int)k], (char)0);
                  task=ConnectClient_get_task(srClientsTable[(signed long int)k]);
                  if(!(task == ((struct anonymous$13 *)NULL)))
                  {
                    TaskScheduler_removeTask(scheduler, task);
                    ConnectClient_set_task(srClientsTable[(signed long int)k], (struct anonymous$13 *)(void *)0);
                  }

                  ServerRealm_decrease_connectedClients(pointer);
                  char *return_value_get_realmname$468;
                  return_value_get_realmname$468=get_realmname(config, j);
                  char *return_value_get_clientname$469;
                  return_value_get_clientname$469=get_clientname(pointer, k);
                  aflog((char)2, (char)64, "realm[%s]: new Client[%s]: DENIED by SSL_accept", return_value_get_realmname$468, return_value_get_clientname$469);
                }
                case 1:
                  goto __CPROVER_DUMP_L389;
                default:
                {
                  return_value_get_realmname$470=get_realmname(config, j);
                  return_value_get_clientname$471=get_clientname(pointer, k);
                  aflog((char)2, (char)2, "realm[%s]: new Client[%s]: ACCEPTED by SSL_accept", return_value_get_realmname$470, return_value_get_clientname$471);
                  ConnectClient_set_state(srClientsTable[(signed long int)k], (char)2);
                  goto __CPROVER_DUMP_L389;
                }
              }
            }

            char *return_value_get_realmname$473;
            return_value_get_realmname$473=get_realmname(config, j);
            char *return_value_get_clientname$474;
            return_value_get_clientname$474=get_clientname(pointer, k);
            aflog((char)2, (char)4, "realm[%s]: Client[%s]: commfd: FD_ISSET", return_value_get_realmname$473, return_value_get_clientname$474);
            char return_value_ConnectClient_get_state$483;
            return_value_ConnectClient_get_state$483=ConnectClient_get_state(srClientsTable[(signed long int)k]);
            if((signed int)return_value_ConnectClient_get_state$483 == 2)
            {
              char return_value_ServerRealm_get_realmType$475;
              return_value_ServerRealm_get_realmType$475=ServerRealm_get_realmType(pointer);
              struct anonymous$1 *return_value_ConnectClient_get_sslFd$476;
              return_value_ConnectClient_get_sslFd$476=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              struct anonymous$8 *return_value_ConnectClient_get_header$477;
              return_value_ConnectClient_get_header$477=ConnectClient_get_header(srClientsTable[(signed long int)k]);
              signed int return_value_HeaderBuffer_to_read$478;
              return_value_HeaderBuffer_to_read$478=HeaderBuffer_to_read(return_value_ConnectClient_get_header$477);
              n=SslFd_get_message((char)((signed int)return_value_ServerRealm_get_realmType$475 | 4 | 8), return_value_ConnectClient_get_sslFd$476, buff, -1 * return_value_HeaderBuffer_to_read$478);
            }

            else
            {
              char return_value_ServerRealm_get_realmType$479;
              return_value_ServerRealm_get_realmType$479=ServerRealm_get_realmType(pointer);
              struct anonymous$1 *return_value_ConnectClient_get_sslFd$480;
              return_value_ConnectClient_get_sslFd$480=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              struct anonymous$8 *return_value_ConnectClient_get_header$481;
              return_value_ConnectClient_get_header$481=ConnectClient_get_header(srClientsTable[(signed long int)k]);
              signed int return_value_HeaderBuffer_to_read$482;
              return_value_HeaderBuffer_to_read$482=HeaderBuffer_to_read(return_value_ConnectClient_get_header$481);
              n=SslFd_get_message(return_value_ServerRealm_get_realmType$479, return_value_ConnectClient_get_sslFd$480, buff, -1 * return_value_HeaderBuffer_to_read$482);
            }
            if(n == -1)
            {
              signed int *return_value___errno_location$489;
              return_value___errno_location$489=__errno_location();
              if(*return_value___errno_location$489 == 11)
              {
                char *return_value_get_realmname$484;
                return_value_get_realmname$484=get_realmname(config, j);
                char *return_value_get_clientname$485;
                return_value_get_clientname$485=get_clientname(pointer, k);
                aflog((char)2, (char)4, "realm[%s]: Client[%s]: commfd: EAGAIN", return_value_get_realmname$484, return_value_get_clientname$485);
                goto __CPROVER_DUMP_L389;
              }

              else
              {
                char *return_value_get_realmname$486;
                return_value_get_realmname$486=get_realmname(config, j);
                char *return_value_get_clientname$487;
                return_value_get_clientname$487=get_clientname(pointer, k);
                signed int *return_value___errno_location$488;
                return_value___errno_location$488=__errno_location();
                aflog((char)2, (char)64, "realm[%s]: Client[%s]: commfd: ERROR: %d", return_value_get_realmname$486, return_value_get_clientname$487, *return_value___errno_location$488);
                n = 0;
              }
            }

            else
              if(!(n == 5))
              {
                if(!(n == 0))
                {
                  char *return_value_get_realmname$490;
                  return_value_get_realmname$490=get_realmname(config, j);
                  char *return_value_get_clientname$491;
                  return_value_get_clientname$491=get_clientname(pointer, k);
                  aflog((char)2, (char)2, "realm[%s]: Client[%s]: header length = %d --> buffering", return_value_get_realmname$490, return_value_get_clientname$491, n);
                  struct anonymous$8 *return_value_ConnectClient_get_header$492;
                  return_value_ConnectClient_get_header$492=ConnectClient_get_header(srClientsTable[(signed long int)k]);
                  HeaderBuffer_store(return_value_ConnectClient_get_header$492, buff, n);
                  struct anonymous$8 *return_value_ConnectClient_get_header$494;
                  return_value_ConnectClient_get_header$494=ConnectClient_get_header(srClientsTable[(signed long int)k]);
                  signed int return_value_HeaderBuffer_to_read$495;
                  return_value_HeaderBuffer_to_read$495=HeaderBuffer_to_read(return_value_ConnectClient_get_header$494);
                  if(return_value_HeaderBuffer_to_read$495 == 0)
                  {
                    struct anonymous$8 *return_value_ConnectClient_get_header$493;
                    return_value_ConnectClient_get_header$493=ConnectClient_get_header(srClientsTable[(signed long int)k]);
                    HeaderBuffer_restore(return_value_ConnectClient_get_header$493, buff);
                    n = 5;
                  }

                  else
                    goto __CPROVER_DUMP_L389;
                }

              }

            if(n == 0)
            {
              char *return_value_get_realmname$496;
              return_value_get_realmname$496=get_realmname(config, j);
              char *return_value_get_clientname$497;
              return_value_get_clientname$497=get_clientname(pointer, k);
              aflog((char)2, (char)8, "realm[%s]: Client[%s]: commfd: CLOSED", return_value_get_realmname$496, return_value_get_clientname$497);
              time(&now);
              char *return_value_get_realmname$498;
              return_value_get_realmname$498=get_realmname(config, j);
              char *return_value_get_clientname$499;
              return_value_get_clientname$499=get_clientname(pointer, k);
              char *return_value_ConnectClient_get_nameBuf$500;
              return_value_ConnectClient_get_nameBuf$500=ConnectClient_get_nameBuf(srClientsTable[(signed long int)k]);
              char *return_value_ConnectClient_get_portBuf$501;
              return_value_ConnectClient_get_portBuf$501=ConnectClient_get_portBuf(srClientsTable[(signed long int)k]);
              signed long int return_value_ConnectClient_get_connectTime$502;
              return_value_ConnectClient_get_connectTime$502=ConnectClient_get_connectTime(srClientsTable[(signed long int)k]);
              char *return_value_timeperiod$503;
              return_value_timeperiod$503=timeperiod(now - return_value_ConnectClient_get_connectTime$502);
              aflog((char)2, (char)16, "REALM: %s CLIENT: %s IP: %s PORT: %s DURATION: %s", return_value_get_realmname$498, return_value_get_clientname$499, return_value_ConnectClient_get_nameBuf$500, return_value_ConnectClient_get_portBuf$501, return_value_timeperiod$503);
              char return_value_ServerRealm_get_auditOn$524;
              return_value_ServerRealm_get_auditOn$524=ServerRealm_get_auditOn(pointer);
              if(!(return_value_ServerRealm_get_auditOn$524 == 0))
                do
                {
                  return_value_ConnectClient_get_auditList$504=ConnectClient_get_auditList(srClientsTable[(signed long int)k]);
                  return_value_AuditList_get_first$505=AuditList_get_first(return_value_ConnectClient_get_auditList$504);
                  if(return_value_AuditList_get_first$505 == ((struct alnode *)NULL))
                    break;

                  struct auditlist *return_value_ConnectClient_get_auditList$506;
                  return_value_ConnectClient_get_auditList$506=ConnectClient_get_auditList(srClientsTable[(signed long int)k]);
                  struct alnode *return_value_AuditList_get_first$507;
                  return_value_AuditList_get_first$507=AuditList_get_first(return_value_ConnectClient_get_auditList$506);
                  signed int return_value_AuditListNode_get_userId$508;
                  return_value_AuditListNode_get_userId$508=AuditListNode_get_userId(return_value_AuditList_get_first$507);
                  struct auditlist *return_value_ConnectClient_get_auditList$509;
                  return_value_ConnectClient_get_auditList$509=ConnectClient_get_auditList(srClientsTable[(signed long int)k]);
                  struct alnode *return_value_AuditList_get_first$510;
                  return_value_AuditList_get_first$510=AuditList_get_first(return_value_ConnectClient_get_auditList$509);
                  char *return_value_AuditListNode_get_nameBuf$511;
                  return_value_AuditListNode_get_nameBuf$511=AuditListNode_get_nameBuf(return_value_AuditList_get_first$510);
                  struct auditlist *return_value_ConnectClient_get_auditList$512;
                  return_value_ConnectClient_get_auditList$512=ConnectClient_get_auditList(srClientsTable[(signed long int)k]);
                  struct alnode *return_value_AuditList_get_first$513;
                  return_value_AuditList_get_first$513=AuditList_get_first(return_value_ConnectClient_get_auditList$512);
                  char *return_value_AuditListNode_get_portBuf$514;
                  return_value_AuditListNode_get_portBuf$514=AuditListNode_get_portBuf(return_value_AuditList_get_first$513);
                  struct auditlist *return_value_ConnectClient_get_auditList$515;
                  return_value_ConnectClient_get_auditList$515=ConnectClient_get_auditList(srClientsTable[(signed long int)k]);
                  struct alnode *return_value_AuditList_get_first$516;
                  return_value_AuditList_get_first$516=AuditList_get_first(return_value_ConnectClient_get_auditList$515);
                  signed long int *return_value_AuditListNode_get_connectTimep$517;
                  return_value_AuditListNode_get_connectTimep$517=AuditListNode_get_connectTimep(return_value_AuditList_get_first$516);
                  char *return_value_localdate$518;
                  return_value_localdate$518=localdate(return_value_AuditListNode_get_connectTimep$517);
                  struct auditlist *return_value_ConnectClient_get_auditList$519;
                  return_value_ConnectClient_get_auditList$519=ConnectClient_get_auditList(srClientsTable[(signed long int)k]);
                  struct alnode *return_value_AuditList_get_first$520;
                  return_value_AuditList_get_first$520=AuditList_get_first(return_value_ConnectClient_get_auditList$519);
                  signed long int return_value_AuditListNode_get_duration$521;
                  return_value_AuditListNode_get_duration$521=AuditListNode_get_duration(return_value_AuditList_get_first$520);
                  char *return_value_timeperiod$522;
                  return_value_timeperiod$522=timeperiod(return_value_AuditListNode_get_duration$521);
                  aflog((char)2, (char)16, "USERID: %d IP: %s PORT: %s CONNECTED: %s DURATION: %s", return_value_AuditListNode_get_userId$508, return_value_AuditListNode_get_nameBuf$511, return_value_AuditListNode_get_portBuf$514, return_value_localdate$518, return_value_timeperiod$522);
                  struct auditlist *return_value_ConnectClient_get_auditList$523;
                  return_value_ConnectClient_get_auditList$523=ConnectClient_get_auditList(srClientsTable[(signed long int)k]);
                  AuditList_delete_first(return_value_ConnectClient_get_auditList$523);
                }
                while((_Bool)1);

              remove_client(pointer, k, &allset, &wset, scheduler);
              goto __CPROVER_DUMP_L389;
            }

            numofcon = (signed int)buff[(signed long int)1];
            numofcon = numofcon << 8;
            numofcon = numofcon + (signed int)buff[(signed long int)2];
            length = (signed int)buff[(signed long int)3];
            length = length << 8;
            length = length + (signed int)buff[(signed long int)4];
            signed int return_value_ServerRealm_get_clientsLimit$525;
            return_value_ServerRealm_get_clientsLimit$525=ServerRealm_get_clientsLimit(pointer);
            if(k == return_value_ServerRealm_get_clientsLimit$525)
            {
              if(!((signed int)buff[0l] == 8))
              {
                if(!((signed int)buff[0l] == 14))
                {
                  if(!((signed int)buff[0l] == 15))
                    buff[(signed long int)0] = (unsigned char)13;

                }

              }

            }

            char return_value_ConnectClient_get_state$528;
            return_value_ConnectClient_get_state$528=ConnectClient_get_state(srClientsTable[(signed long int)k]);
            if(!((signed int)return_value_ConnectClient_get_state$528 >= 2))
            {
              char *return_value_get_realmname$526;
              return_value_get_realmname$526=get_realmname(config, j);
              char *return_value_get_clientname$527;
              return_value_get_clientname$527=get_clientname(pointer, k);
              aflog((char)2, (char)32, "realm[%s]: Client[%s]: Impossible behaviour --> ignoring", return_value_get_realmname$526, return_value_get_clientname$527);
              goto __CPROVER_DUMP_L389;
            }

            char return_value_ConnectClient_get_state$529;
            return_value_ConnectClient_get_state$529=ConnectClient_get_state(srClientsTable[(signed long int)k]);
            if((signed int)return_value_ConnectClient_get_state$529 == 2)
            {
              if(!((signed int)buff[0l] == 8))
              {
                if(!((signed int)buff[0l] == 14))
                  buff[(signed long int)0] = (unsigned char)13;

              }

            }

            time(&now);
            ConnectClient_set_lastActivity(srClientsTable[(signed long int)k], now);
            signed int return_value_ServerRealm_get_maxIdle$532;
            return_value_ServerRealm_get_maxIdle$532=ServerRealm_get_maxIdle(pointer);
            if(!(return_value_ServerRealm_get_maxIdle$532 == 0))
            {
              signed int return_value_ServerRealm_get_maxIdle$530;
              return_value_ServerRealm_get_maxIdle$530=ServerRealm_get_maxIdle(pointer);
              struct timeval return_value_timeval_create$531;
              return_value_timeval_create$531=timeval_create((signed long int)return_value_ServerRealm_get_maxIdle$530, (signed long int)0);
              ConnectClient_set_timer(srClientsTable[(signed long int)k], return_value_timeval_create$531);
              TaskScheduler_update(scheduler);
            }

            switch((signed int)buff[(signed long int)0])
            {
              case 1:
              {
                n = numofcon;
                numofcon=eval_numofcon(pointer, k, numofcon);
                if(numofcon >= 0)
                {
                  return_value_ServerRealm_get_usersLimit$557=ServerRealm_get_usersLimit(pointer);
                  tmp_if_expr$558 = numofcon < return_value_ServerRealm_get_usersLimit$557 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$558 = (_Bool)0;
                if(tmp_if_expr$558)
                {
                  return_value_ConnectClient_get_state$559=ConnectClient_get_state(srClientsTable[(signed long int)k]);
                  tmp_if_expr$560 = (signed int)return_value_ConnectClient_get_state$559 == 3 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$560 = (_Bool)0;
                if(tmp_if_expr$560)
                {
                  char return_value_ConnectUser_get_state$556;
                  return_value_ConnectUser_get_state$556=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                  if((signed int)return_value_ConnectUser_get_state$556 == 11)
                  {
                    ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)19);
                    char *return_value_get_realmname$533;
                    return_value_get_realmname$533=get_realmname(config, j);
                    signed int return_value_get_username$534;
                    return_value_get_username$534=get_username(pointer, numofcon);
                    aflog((char)1, (char)8, "realm[%s]: user[%d]: KICKING...", return_value_get_realmname$533, return_value_get_username$534);
                  }

                  else
                  {
                    ServerRealm_decrease_connectedUsers(pointer);
                    ConnectClient_decrease_connected(srClientsTable[(signed long int)k]);
                    signed int *return_value_ConnectClient_get_users$535;
                    return_value_ConnectClient_get_users$535=ConnectClient_get_users(srClientsTable[(signed long int)k]);
                    return_value_ConnectClient_get_users$535[(signed long int)n] = -1;
                    char return_value_ConnectUser_get_state$555;
                    return_value_ConnectUser_get_state$555=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                    if((signed int)return_value_ConnectUser_get_state$555 == 5)
                    {
                      ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)0);
                      char *return_value_get_realmname$536;
                      return_value_get_realmname$536=get_realmname(config, j);
                      signed int return_value_get_username$537;
                      return_value_get_username$537=get_username(pointer, numofcon);
                      aflog((char)1, (char)2, "realm[%s]: user[%d]: CLOSE CONFIRMED", return_value_get_realmname$536, return_value_get_username$537);
                    }

                    else
                    {
                      return_value_ConnectUser_get_state$554=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                      if((signed int)return_value_ConnectUser_get_state$554 == 7)
                      {
                        char *return_value_get_realmname$538;
                        return_value_get_realmname$538=get_realmname(config, j);
                        signed int return_value_get_username$539;
                        return_value_get_username$539=get_username(pointer, numofcon);
                        aflog((char)1, (char)8, "realm[%s]: user[%d]: KICKED", return_value_get_realmname$538, return_value_get_username$539);
                        time(&now);
                        char *return_value_get_realmname$540;
                        return_value_get_realmname$540=get_realmname(config, j);
                        signed int return_value_get_username$541;
                        return_value_get_username$541=get_username(pointer, numofcon);
                        char *return_value_ConnectUser_get_nameBuf$542;
                        return_value_ConnectUser_get_nameBuf$542=ConnectUser_get_nameBuf(srUsersTable[(signed long int)numofcon]);
                        char *return_value_ConnectUser_get_portBuf$543;
                        return_value_ConnectUser_get_portBuf$543=ConnectUser_get_portBuf(srUsersTable[(signed long int)numofcon]);
                        signed long int return_value_ConnectUser_get_connectTime$544;
                        return_value_ConnectUser_get_connectTime$544=ConnectUser_get_connectTime(srUsersTable[(signed long int)numofcon]);
                        char *return_value_timeperiod$545;
                        return_value_timeperiod$545=timeperiod(now - return_value_ConnectUser_get_connectTime$544);
                        aflog((char)1, (char)16, "REALM: %s USER: %d IP: %s PORT: %s DURATION: %s", return_value_get_realmname$540, return_value_get_username$541, return_value_ConnectUser_get_nameBuf$542, return_value_ConnectUser_get_portBuf$543, return_value_timeperiod$545);
                        signed int return_value_ConnectUser_get_connFd$546;
                        return_value_ConnectUser_get_connFd$546=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        close(return_value_ConnectUser_get_connFd$546);
                        signed int return_value_ConnectUser_get_connFd$547;
                        return_value_ConnectUser_get_connFd$547=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        signed int return_value_ConnectUser_get_connFd$548;
                        return_value_ConnectUser_get_connFd$548=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$547 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$547 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$548 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                        signed int return_value_ConnectUser_get_connFd$549;
                        return_value_ConnectUser_get_connFd$549=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        signed int return_value_ConnectUser_get_connFd$550;
                        return_value_ConnectUser_get_connFd$550=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$549 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$549 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$550 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                        ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)0);
                        struct buflist *return_value_ConnectUser_get_bufList$551;
                        return_value_ConnectUser_get_bufList$551=ConnectUser_get_bufList(srUsersTable[(signed long int)numofcon]);
                        BufList_clear(return_value_ConnectUser_get_bufList$551);
                        buff[(signed long int)0] = (unsigned char)1;
                        buff[(signed long int)1] = (unsigned char)(n >> 8);
                        buff[(signed long int)2] = (unsigned char)n;
                        char return_value_ServerRealm_get_realmType$552;
                        return_value_ServerRealm_get_realmType$552=ServerRealm_get_realmType(pointer);
                        struct anonymous$1 *return_value_ConnectClient_get_sslFd$553;
                        return_value_ConnectClient_get_sslFd$553=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                        SslFd_send_message(return_value_ServerRealm_get_realmType$552, return_value_ConnectClient_get_sslFd$553, buff, 5);
                      }

                    }
                  }
                }

                else
                  remove_client(pointer, k, &allset, &wset, scheduler);
                break;
              }
              case 2:
              {
                n = numofcon;
                numofcon=eval_numofcon(pointer, k, numofcon);
                if(numofcon >= 0)
                {
                  return_value_ServerRealm_get_usersLimit$574=ServerRealm_get_usersLimit(pointer);
                  tmp_if_expr$575 = numofcon < return_value_ServerRealm_get_usersLimit$574 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$575 = (_Bool)0;
                if(tmp_if_expr$575)
                {
                  return_value_ConnectClient_get_state$576=ConnectClient_get_state(srClientsTable[(signed long int)k]);
                  tmp_if_expr$577 = (signed int)return_value_ConnectClient_get_state$576 == 3 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$577 = (_Bool)0;
                if(tmp_if_expr$577)
                {
                  char return_value_ConnectUser_get_state$568;
                  return_value_ConnectUser_get_state$568=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                  if((signed int)return_value_ConnectUser_get_state$568 == 6)
                  {
                    char *return_value_get_realmname$561;
                    return_value_get_realmname$561=get_realmname(config, j);
                    signed int return_value_get_username$562;
                    return_value_get_username$562=get_username(pointer, numofcon);
                    aflog((char)1, (char)8, "realm[%s]: user[%d]: NEW", return_value_get_realmname$561, return_value_get_username$562);
                    signed int return_value_ConnectUser_get_connFd$563;
                    return_value_ConnectUser_get_connFd$563=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                    signed int return_value_ConnectUser_get_connFd$564;
                    return_value_ConnectUser_get_connFd$564=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                    (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$563 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$563 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd$564 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                    signed int return_value_ConnectUser_get_connFd$565;
                    return_value_ConnectUser_get_connFd$565=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                    if(!(1 + return_value_ConnectUser_get_connFd$565 >= maxfdp1))
                      tmp_if_expr$567 = maxfdp1;

                    else
                    {
                      return_value_ConnectUser_get_connFd$566=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                      tmp_if_expr$567 = return_value_ConnectUser_get_connFd$566 + 1;
                    }
                    maxfdp1 = tmp_if_expr$567;
                    ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)7);
                  }

                  char return_value_ConnectUser_get_state$573;
                  return_value_ConnectUser_get_state$573=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                  if((signed int)return_value_ConnectUser_get_state$573 == 17)
                  {
                    char *return_value_get_realmname$569;
                    return_value_get_realmname$569=get_realmname(config, j);
                    signed int return_value_get_username$570;
                    return_value_get_username$570=get_username(pointer, numofcon);
                    aflog((char)1, (char)8, "realm[%s]: user[%d]: delayed CLOSING", return_value_get_realmname$569, return_value_get_username$570);
                    ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)5);
                    buff[(signed long int)0] = (unsigned char)1;
                    buff[(signed long int)1] = (unsigned char)(n >> 8);
                    buff[(signed long int)2] = (unsigned char)n;
                    char return_value_ServerRealm_get_realmType$571;
                    return_value_ServerRealm_get_realmType$571=ServerRealm_get_realmType(pointer);
                    struct anonymous$1 *return_value_ConnectClient_get_sslFd$572;
                    return_value_ConnectClient_get_sslFd$572=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                    SslFd_send_message(return_value_ServerRealm_get_realmType$571, return_value_ConnectClient_get_sslFd$572, buff, 5);
                  }

                }

                else
                  remove_client(pointer, k, &allset, &wset, scheduler);
                break;
              }
              case 12:
              {
                n = numofcon;
                numofcon=eval_numofcon(pointer, k, numofcon);
                if(numofcon >= 0)
                {
                  return_value_ServerRealm_get_usersLimit$586=ServerRealm_get_usersLimit(pointer);
                  tmp_if_expr$587 = numofcon < return_value_ServerRealm_get_usersLimit$586 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$587 = (_Bool)0;
                if(tmp_if_expr$587)
                {
                  return_value_ConnectClient_get_state$588=ConnectClient_get_state(srClientsTable[(signed long int)k]);
                  tmp_if_expr$589 = (signed int)return_value_ConnectClient_get_state$588 == 3 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$589 = (_Bool)0;
                if(tmp_if_expr$589)
                {
                  char return_value_ConnectUser_get_state$583;
                  return_value_ConnectUser_get_state$583=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                  if((signed int)return_value_ConnectUser_get_state$583 == 6)
                    tmp_if_expr$585 = (_Bool)1;

                  else
                  {
                    return_value_ConnectUser_get_state$584=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                    tmp_if_expr$585 = (signed int)return_value_ConnectUser_get_state$584 == 17 ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr$585)
                  {
                    char *return_value_get_realmname$578;
                    return_value_get_realmname$578=get_realmname(config, j);
                    signed int return_value_get_username$579;
                    return_value_get_username$579=get_username(pointer, numofcon);
                    aflog((char)1, (char)8, "realm[%s]: user[%d]: DROPPED", return_value_get_realmname$578, return_value_get_username$579);
                    ServerRealm_decrease_connectedUsers(pointer);
                    ConnectClient_decrease_connected(srClientsTable[(signed long int)k]);
                    signed int *return_value_ConnectClient_get_users$580;
                    return_value_ConnectClient_get_users$580=ConnectClient_get_users(srClientsTable[(signed long int)k]);
                    return_value_ConnectClient_get_users$580[(signed long int)n] = -1;
                    char return_value_ConnectUser_get_state$582;
                    return_value_ConnectUser_get_state$582=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                    if((signed int)return_value_ConnectUser_get_state$582 == 6)
                    {
                      signed int return_value_ConnectUser_get_connFd$581;
                      return_value_ConnectUser_get_connFd$581=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                      close(return_value_ConnectUser_get_connFd$581);
                    }

                    ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)0);
                  }

                }

                else
                  remove_client(pointer, k, &allset, &wset, scheduler);
                break;
              }
              case 3:
              {
                return_value_ConnectClient_get_state$590=ConnectClient_get_state(srClientsTable[(signed long int)k]);
                if(!((signed int)return_value_ConnectClient_get_state$590 == 3))
                {
                  remove_client(pointer, k, &allset, &wset, scheduler);
                  break;
                }

                return_value_ServerRealm_get_realmType$595=ServerRealm_get_realmType(pointer);
                if(!((1 & (signed int)return_value_ServerRealm_get_realmType$595) == 0))
                {
                  return_value_ServerRealm_get_realmType$596=ServerRealm_get_realmType(pointer);
                  tmp_if_expr$597 = ((signed int)return_value_ServerRealm_get_realmType$596 & 2) != 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$597 = (_Bool)0;
                if(tmp_if_expr$597)
                {
                  char return_value_ServerRealm_get_realmType$591;
                  return_value_ServerRealm_get_realmType$591=ServerRealm_get_realmType(pointer);
                  struct anonymous$1 *return_value_ConnectClient_get_sslFd$592;
                  return_value_ConnectClient_get_sslFd$592=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                  n=SslFd_get_message(return_value_ServerRealm_get_realmType$591, return_value_ConnectClient_get_sslFd$592, &buff[(signed long int)5], length);
                }

                else
                {
                  char return_value_ServerRealm_get_realmType$593;
                  return_value_ServerRealm_get_realmType$593=ServerRealm_get_realmType(pointer);
                  struct anonymous$1 *return_value_ConnectClient_get_sslFd$594;
                  return_value_ConnectClient_get_sslFd$594=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                  n=SslFd_get_message(return_value_ServerRealm_get_realmType$593, return_value_ConnectClient_get_sslFd$594, buff, length);
                }
                temp = numofcon;
                numofcon=eval_numofcon(pointer, k, numofcon);
                if(numofcon >= 0)
                {
                  return_value_ServerRealm_get_usersLimit$675=ServerRealm_get_usersLimit(pointer);
                  tmp_if_expr$676 = numofcon < return_value_ServerRealm_get_usersLimit$675 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$676 = (_Bool)0;
                if(tmp_if_expr$676)
                {
                  char return_value_ConnectUser_get_state$673;
                  return_value_ConnectUser_get_state$673=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                  if((signed int)return_value_ConnectUser_get_state$673 == 7)
                  {
                    char *return_value_get_realmname$598;
                    return_value_get_realmname$598=get_realmname(config, j);
                    signed int return_value_get_username$599;
                    return_value_get_username$599=get_username(pointer, numofcon);
                    aflog((char)1, (char)2, "realm[%s]: TO user[%d]: MESSAGE length=%d", return_value_get_realmname$598, return_value_get_username$599, n);
                    struct anonymous$6 *return_value_ConnectUser_get_stats$600;
                    return_value_ConnectUser_get_stats$600=ConnectUser_get_stats(srUsersTable[(signed long int)numofcon]);
                    UserStats_add_download(return_value_ConnectUser_get_stats$600, n);
                    char return_value_ServerRealm_get_realmType$655;
                    return_value_ServerRealm_get_realmType$655=ServerRealm_get_realmType(pointer);
                    if(!((1 & (signed int)return_value_ServerRealm_get_realmType$655) == 0))
                    {
                      return_value_ServerRealm_get_realmType$656=ServerRealm_get_realmType(pointer);
                      tmp_if_expr$657 = ((signed int)return_value_ServerRealm_get_realmType$656 & 2) != 0 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr$657 = (_Bool)0;
                    if(tmp_if_expr$657)
                    {
                      buff[(signed long int)1] = (unsigned char)8;
                      buff[(signed long int)2] = (unsigned char)3;
                      buff[(signed long int)3] = (unsigned char)(n >> 8);
                      buff[(signed long int)4] = (unsigned char)n;
                      signed int return_value_ConnectUser_get_connFd$601;
                      return_value_ConnectUser_get_connFd$601=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                      signed long int return_value_write$602;
                      return_value_write$602=write(return_value_ConnectUser_get_connFd$601, (const void *)buff, (unsigned long int)(n + 5));
                      sent = (signed int)return_value_write$602;
                      if(sent == -1)
                      {
                        char *return_value_get_realmname$603;
                        return_value_get_realmname$603=get_realmname(config, j);
                        signed int return_value_get_username$604;
                        return_value_get_username$604=get_username(pointer, numofcon);
                        aflog((char)1, (char)8, "realm[%s]: user[%d]: CLOSED (write-udp)", return_value_get_realmname$603, return_value_get_username$604);
                        time(&now);
                        char *return_value_get_realmname$605;
                        return_value_get_realmname$605=get_realmname(config, j);
                        signed int return_value_get_username$606;
                        return_value_get_username$606=get_username(pointer, numofcon);
                        char *return_value_ConnectUser_get_nameBuf$607;
                        return_value_ConnectUser_get_nameBuf$607=ConnectUser_get_nameBuf(srUsersTable[(signed long int)numofcon]);
                        char *return_value_ConnectUser_get_portBuf$608;
                        return_value_ConnectUser_get_portBuf$608=ConnectUser_get_portBuf(srUsersTable[(signed long int)numofcon]);
                        signed long int return_value_ConnectUser_get_connectTime$609;
                        return_value_ConnectUser_get_connectTime$609=ConnectUser_get_connectTime(srUsersTable[(signed long int)numofcon]);
                        char *return_value_timeperiod$610;
                        return_value_timeperiod$610=timeperiod(now - return_value_ConnectUser_get_connectTime$609);
                        aflog((char)1, (char)16, "REALM: %s USER: %d IP: %s PORT: %s DURATION: %s", return_value_get_realmname$605, return_value_get_username$606, return_value_ConnectUser_get_nameBuf$607, return_value_ConnectUser_get_portBuf$608, return_value_timeperiod$610);
                        signed int return_value_ConnectUser_get_connFd$611;
                        return_value_ConnectUser_get_connFd$611=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        close(return_value_ConnectUser_get_connFd$611);
                        signed int return_value_ConnectUser_get_connFd$612;
                        return_value_ConnectUser_get_connFd$612=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        signed int return_value_ConnectUser_get_connFd$613;
                        return_value_ConnectUser_get_connFd$613=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$612 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$612 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$613 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                        signed int return_value_ConnectUser_get_connFd$614;
                        return_value_ConnectUser_get_connFd$614=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        signed int return_value_ConnectUser_get_connFd$615;
                        return_value_ConnectUser_get_connFd$615=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$614 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$614 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$615 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                        ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)5);
                        struct buflist *return_value_ConnectUser_get_bufList$616;
                        return_value_ConnectUser_get_bufList$616=ConnectUser_get_bufList(srUsersTable[(signed long int)numofcon]);
                        BufList_clear(return_value_ConnectUser_get_bufList$616);
                        buff[(signed long int)0] = (unsigned char)1;
                        buff[(signed long int)1] = (unsigned char)(temp >> 8);
                        buff[(signed long int)2] = (unsigned char)temp;
                        char return_value_ServerRealm_get_realmType$617;
                        return_value_ServerRealm_get_realmType$617=ServerRealm_get_realmType(pointer);
                        struct anonymous$1 *return_value_ConnectClient_get_sslFd$618;
                        return_value_ConnectClient_get_sslFd$618=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                        SslFd_send_message(return_value_ServerRealm_get_realmType$617, return_value_ConnectClient_get_sslFd$618, buff, 5);
                      }

                    }

                    else
                    {
                      signed int return_value_ConnectUser_get_connFd$619;
                      return_value_ConnectUser_get_connFd$619=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                      signed long int return_value_write$620;
                      return_value_write$620=write(return_value_ConnectUser_get_connFd$619, (const void *)buff, (unsigned long int)n);
                      sent = (signed int)return_value_write$620;
                      if(sent >= 1 && !(sent == n))
                      {
                        struct buflist *return_value_ConnectUser_get_bufList$621;
                        return_value_ConnectUser_get_bufList$621=ConnectUser_get_bufList(srUsersTable[(signed long int)numofcon]);
                        struct blnode *return_value_BufListNode_new_message$622;
                        return_value_BufListNode_new_message$622=BufListNode_new_message(sent, n, buff);
                        BufList_insert_back(return_value_ConnectUser_get_bufList$621, return_value_BufListNode_new_message$622);
                        ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)11);
                        signed int return_value_ConnectUser_get_connFd$623;
                        return_value_ConnectUser_get_connFd$623=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        signed int return_value_ConnectUser_get_connFd$624;
                        return_value_ConnectUser_get_connFd$624=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                        (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$623 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$623 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd$624 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                        buff[(signed long int)0] = (unsigned char)9;
                        buff[(signed long int)1] = (unsigned char)(temp >> 8);
                        buff[(signed long int)2] = (unsigned char)temp;
                        char *return_value_get_realmname$625;
                        return_value_get_realmname$625=get_realmname(config, j);
                        signed int return_value_get_username$626;
                        return_value_get_username$626=get_username(pointer, numofcon);
                        aflog((char)1, (char)4, "realm[%s]: TO user[%d]: BUFFERING MESSAGE STARTED (%d/%d)", return_value_get_realmname$625, return_value_get_username$626, sent, n);
                        char return_value_ServerRealm_get_realmType$627;
                        return_value_ServerRealm_get_realmType$627=ServerRealm_get_realmType(pointer);
                        struct anonymous$1 *return_value_ConnectClient_get_sslFd$628;
                        return_value_ConnectClient_get_sslFd$628=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                        SslFd_send_message(return_value_ServerRealm_get_realmType$627, return_value_ConnectClient_get_sslFd$628, buff, 5);
                      }

                      else
                      {
                        if(sent == -1)
                        {
                          return_value___errno_location$653=__errno_location();
                          tmp_if_expr$654 = *return_value___errno_location$653 == 11 ? (_Bool)1 : (_Bool)0;
                        }

                        else
                          tmp_if_expr$654 = (_Bool)0;
                        if(tmp_if_expr$654)
                        {
                          struct buflist *return_value_ConnectUser_get_bufList$629;
                          return_value_ConnectUser_get_bufList$629=ConnectUser_get_bufList(srUsersTable[(signed long int)numofcon]);
                          struct blnode *return_value_BufListNode_new_message$630;
                          return_value_BufListNode_new_message$630=BufListNode_new_message(0, n, buff);
                          BufList_insert_back(return_value_ConnectUser_get_bufList$629, return_value_BufListNode_new_message$630);
                          ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)11);
                          signed int return_value_ConnectUser_get_connFd$631;
                          return_value_ConnectUser_get_connFd$631=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                          signed int return_value_ConnectUser_get_connFd$632;
                          return_value_ConnectUser_get_connFd$632=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                          (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$631 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$631 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd$632 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                          buff[(signed long int)0] = (unsigned char)9;
                          buff[(signed long int)1] = (unsigned char)(temp >> 8);
                          buff[(signed long int)2] = (unsigned char)temp;
                          char *return_value_get_realmname$633;
                          return_value_get_realmname$633=get_realmname(config, j);
                          signed int return_value_get_username$634;
                          return_value_get_username$634=get_username(pointer, numofcon);
                          aflog((char)1, (char)4, "realm[%s]: TO user[%d]: BUFFERING MESSAGE STARTED (%d/%d)", return_value_get_realmname$633, return_value_get_username$634, sent, n);
                          char return_value_ServerRealm_get_realmType$635;
                          return_value_ServerRealm_get_realmType$635=ServerRealm_get_realmType(pointer);
                          struct anonymous$1 *return_value_ConnectClient_get_sslFd$636;
                          return_value_ConnectClient_get_sslFd$636=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                          SslFd_send_message(return_value_ServerRealm_get_realmType$635, return_value_ConnectClient_get_sslFd$636, buff, 5);
                        }

                        else
                          if(sent == -1)
                          {
                            char *return_value_get_realmname$637;
                            return_value_get_realmname$637=get_realmname(config, j);
                            signed int return_value_get_username$638;
                            return_value_get_username$638=get_username(pointer, numofcon);
                            aflog((char)1, (char)8, "realm[%s]: user[%d]: CLOSED (write-tcp)", return_value_get_realmname$637, return_value_get_username$638);
                            time(&now);
                            char *return_value_get_realmname$639;
                            return_value_get_realmname$639=get_realmname(config, j);
                            signed int return_value_get_username$640;
                            return_value_get_username$640=get_username(pointer, numofcon);
                            char *return_value_ConnectUser_get_nameBuf$641;
                            return_value_ConnectUser_get_nameBuf$641=ConnectUser_get_nameBuf(srUsersTable[(signed long int)numofcon]);
                            char *return_value_ConnectUser_get_portBuf$642;
                            return_value_ConnectUser_get_portBuf$642=ConnectUser_get_portBuf(srUsersTable[(signed long int)numofcon]);
                            signed long int return_value_ConnectUser_get_connectTime$643;
                            return_value_ConnectUser_get_connectTime$643=ConnectUser_get_connectTime(srUsersTable[(signed long int)numofcon]);
                            char *return_value_timeperiod$644;
                            return_value_timeperiod$644=timeperiod(now - return_value_ConnectUser_get_connectTime$643);
                            aflog((char)1, (char)16, "REALM: %s USER: %d IP: %s PORT: %s DURATION: %s", return_value_get_realmname$639, return_value_get_username$640, return_value_ConnectUser_get_nameBuf$641, return_value_ConnectUser_get_portBuf$642, return_value_timeperiod$644);
                            signed int return_value_ConnectUser_get_connFd$645;
                            return_value_ConnectUser_get_connFd$645=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                            close(return_value_ConnectUser_get_connFd$645);
                            signed int return_value_ConnectUser_get_connFd$646;
                            return_value_ConnectUser_get_connFd$646=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                            signed int return_value_ConnectUser_get_connFd$647;
                            return_value_ConnectUser_get_connFd$647=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                            (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$646 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$646 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$647 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                            signed int return_value_ConnectUser_get_connFd$648;
                            return_value_ConnectUser_get_connFd$648=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                            signed int return_value_ConnectUser_get_connFd$649;
                            return_value_ConnectUser_get_connFd$649=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                            (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$648 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$648 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$649 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                            ConnectUser_set_state(srUsersTable[(signed long int)numofcon], (char)5);
                            struct buflist *return_value_ConnectUser_get_bufList$650;
                            return_value_ConnectUser_get_bufList$650=ConnectUser_get_bufList(srUsersTable[(signed long int)numofcon]);
                            BufList_clear(return_value_ConnectUser_get_bufList$650);
                            buff[(signed long int)0] = (unsigned char)1;
                            buff[(signed long int)1] = (unsigned char)(temp >> 8);
                            buff[(signed long int)2] = (unsigned char)temp;
                            char return_value_ServerRealm_get_realmType$651;
                            return_value_ServerRealm_get_realmType$651=ServerRealm_get_realmType(pointer);
                            struct anonymous$1 *return_value_ConnectClient_get_sslFd$652;
                            return_value_ConnectClient_get_sslFd$652=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                            SslFd_send_message(return_value_ServerRealm_get_realmType$651, return_value_ConnectClient_get_sslFd$652, buff, 5);
                          }

                      }
                    }
                  }

                  else
                  {
                    return_value_ConnectUser_get_state$672=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                    if((signed int)return_value_ConnectUser_get_state$672 == 11)
                    {
                      char *return_value_get_realmname$658;
                      return_value_get_realmname$658=get_realmname(config, j);
                      signed int return_value_get_username$659;
                      return_value_get_username$659=get_username(pointer, numofcon);
                      aflog((char)1, (char)4, "realm[%s]: TO user[%d]: BUFFERING MESSAGE (%d)", return_value_get_realmname$658, return_value_get_username$659, n);
                      char return_value_ServerRealm_get_realmType$664;
                      return_value_ServerRealm_get_realmType$664=ServerRealm_get_realmType(pointer);
                      if(!((1 & (signed int)return_value_ServerRealm_get_realmType$664) == 0))
                      {
                        return_value_ServerRealm_get_realmType$665=ServerRealm_get_realmType(pointer);
                        tmp_if_expr$666 = ((signed int)return_value_ServerRealm_get_realmType$665 & 2) != 0 ? (_Bool)1 : (_Bool)0;
                      }

                      else
                        tmp_if_expr$666 = (_Bool)0;
                      if(tmp_if_expr$666)
                      {
                        buff[(signed long int)1] = (unsigned char)8;
                        buff[(signed long int)2] = (unsigned char)3;
                        buff[(signed long int)3] = (unsigned char)(n >> 8);
                        buff[(signed long int)4] = (unsigned char)n;
                        struct buflist *return_value_ConnectUser_get_bufList$660;
                        return_value_ConnectUser_get_bufList$660=ConnectUser_get_bufList(srUsersTable[(signed long int)numofcon]);
                        struct blnode *return_value_BufListNode_new_message$661;
                        return_value_BufListNode_new_message$661=BufListNode_new_message(0, n + 5, buff);
                        BufList_insert_back(return_value_ConnectUser_get_bufList$660, return_value_BufListNode_new_message$661);
                      }

                      else
                      {
                        struct buflist *return_value_ConnectUser_get_bufList$662;
                        return_value_ConnectUser_get_bufList$662=ConnectUser_get_bufList(srUsersTable[(signed long int)numofcon]);
                        struct blnode *return_value_BufListNode_new_message$663;
                        return_value_BufListNode_new_message$663=BufListNode_new_message(0, n, buff);
                        BufList_insert_back(return_value_ConnectUser_get_bufList$662, return_value_BufListNode_new_message$663);
                      }
                    }

                    else
                    {
                      return_value_ConnectUser_get_state$671=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                      if((signed int)return_value_ConnectUser_get_state$671 == 5)
                      {
                        char *return_value_get_realmname$667;
                        return_value_get_realmname$667=get_realmname(config, j);
                        signed int return_value_get_username$668;
                        return_value_get_username$668=get_username(pointer, numofcon);
                        aflog((char)1, (char)32, "realm[%s]: TO user[%d]: IGNORED message length=%d", return_value_get_realmname$667, return_value_get_username$668, n);
                      }

                      else
                      {
                        char *return_value_get_realmname$669;
                        return_value_get_realmname$669=get_realmname(config, j);
                        signed int return_value_get_username$670;
                        return_value_get_username$670=get_username(pointer, numofcon);
                        aflog((char)1, (char)32, "realm[%s]: TO user[%d]: user in wrong state - IGNORED", return_value_get_realmname$669, return_value_get_username$670);
                      }
                    }
                  }
                }

                else
                {
                  char *return_value_get_realmname$674;
                  return_value_get_realmname$674=get_realmname(config, j);
                  aflog((char)1, (char)32, "realm[%s]: message to non-existing user - IGNORED", return_value_get_realmname$674);
                }
                break;
              }
              case 8:
              {
                return_value_ConnectClient_get_state$725=ConnectClient_get_state(srClientsTable[(signed long int)k]);
                if((signed int)return_value_ConnectClient_get_state$725 == 2)
                {
                  return_value_ServerRealm_get_password$726=ServerRealm_get_password(pointer);
                  return_value_ServerRealm_get_password$727=ServerRealm_get_password(pointer);
                  tmp_if_expr$728 = numofcon == (signed int)return_value_ServerRealm_get_password$726[(signed long int)0] * 256 + (signed int)return_value_ServerRealm_get_password$727[(signed long int)1] ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$728 = (_Bool)0;
                if(tmp_if_expr$728)
                {
                  return_value_ServerRealm_get_password$729=ServerRealm_get_password(pointer);
                  return_value_ServerRealm_get_password$730=ServerRealm_get_password(pointer);
                  tmp_if_expr$731 = length == (signed int)return_value_ServerRealm_get_password$729[(signed long int)2] * 256 + (signed int)return_value_ServerRealm_get_password$730[(signed long int)3] ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$731 = (_Bool)0;
                if(tmp_if_expr$731)
                {
                  ConnectClient_set_multi(srClientsTable[(signed long int)k], (char)0);
                  signed int return_value_ServerRealm_get_clientsLimit$715;
                  return_value_ServerRealm_get_clientsLimit$715=ServerRealm_get_clientsLimit(pointer);
                  if(!(k == return_value_ServerRealm_get_clientsLimit$715))
                  {
                    ConnectClient_set_state(srClientsTable[(signed long int)k], (char)3);
                    char *return_value_get_realmname$677;
                    return_value_get_realmname$677=get_realmname(config, j);
                    char *return_value_get_clientname$678;
                    return_value_get_clientname$678=get_clientname(pointer, k);
                    aflog((char)2, (char)8, "realm[%s]: Client[%s]: pass ok - ACCESS GRANTED", return_value_get_realmname$677, return_value_get_clientname$678);
                    buff[(signed long int)0] = (unsigned char)8;
                    signed int return_value_ConnectClient_get_limit$679;
                    return_value_ConnectClient_get_limit$679=ConnectClient_get_limit(srClientsTable[(signed long int)k]);
                    buff[(signed long int)1] = (unsigned char)(return_value_ConnectClient_get_limit$679 >> 8);
                    signed int return_value_ConnectClient_get_limit$680;
                    return_value_ConnectClient_get_limit$680=ConnectClient_get_limit(srClientsTable[(signed long int)k]);
                    buff[(signed long int)2] = (unsigned char)return_value_ConnectClient_get_limit$680;
                    char return_value_ServerRealm_get_realmType$681;
                    return_value_ServerRealm_get_realmType$681=ServerRealm_get_realmType(pointer);
                    buff[(signed long int)3] = (unsigned char)return_value_ServerRealm_get_realmType$681;
                    char return_value_ServerRealm_get_realmType$682;
                    return_value_ServerRealm_get_realmType$682=ServerRealm_get_realmType(pointer);
                    struct anonymous$1 *return_value_ConnectClient_get_sslFd$683;
                    return_value_ConnectClient_get_sslFd$683=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                    SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType$682 | 4 | 8), return_value_ConnectClient_get_sslFd$683, buff, 5);
                    task=ConnectClient_get_task(srClientsTable[(signed long int)k]);
                    if(!(task == ((struct anonymous$13 *)NULL)))
                    {
                      TaskScheduler_removeTask(scheduler, task);
                      ConnectClient_set_task(srClientsTable[(signed long int)k], (struct anonymous$13 *)(void *)0);
                    }

                    signed int return_value_ServerRealm_get_maxIdle$688;
                    return_value_ServerRealm_get_maxIdle$688=ServerRealm_get_maxIdle(pointer);
                    if(!(return_value_ServerRealm_get_maxIdle$688 == 0))
                    {
                      signed int return_value_ServerRealm_get_maxIdle$684;
                      return_value_ServerRealm_get_maxIdle$684=ServerRealm_get_maxIdle(pointer);
                      struct timeval return_value_timeval_create$685;
                      return_value_timeval_create$685=timeval_create((signed long int)return_value_ServerRealm_get_maxIdle$684, (signed long int)0);
                      ConnectClient_set_timer(srClientsTable[(signed long int)k], return_value_timeval_create$685);
                      struct timeval *return_value_ConnectClient_get_timerp$686;
                      return_value_ConnectClient_get_timerp$686=ConnectClient_get_timerp(srClientsTable[(signed long int)k]);
                      struct anonymous$25 *return_value_RCTdata_new$687;
                      return_value_RCTdata_new$687=RCTdata_new(config, j, k, (char)0, (char)1, &allset, &wset);
                      task=Task_new(return_value_ConnectClient_get_timerp$686, RCTfunction, (void *)return_value_RCTdata_new$687, RCTdata_free);
                      ConnectClient_set_task(srClientsTable[(signed long int)k], task);
                      TaskScheduler_addTask(scheduler, task);
                    }

                    char return_value_ServerRealm_get_basePortOn$711;
                    return_value_ServerRealm_get_basePortOn$711=ServerRealm_get_basePortOn(pointer);
                    if((signed int)return_value_ServerRealm_get_basePortOn$711 == 1)
                    {
                      signed long int tmp_val;
                      char tmp_tab[6l];
                      signed int return_value_ConnectClient_get_usrCliPair$691;
                      return_value_ConnectClient_get_usrCliPair$691=ConnectClient_get_usrCliPair(srClientsTable[(signed long int)k]);
                      char *return_value_UsrCli_get_listenPortName$692;
                      return_value_UsrCli_get_listenPortName$692=UsrCli_get_listenPortName(srUsersClientsTable[(signed long int)return_value_ConnectClient_get_usrCliPair$691]);
                      signed int return_value_check_long$693;
                      return_value_check_long$693=check_long(return_value_UsrCli_get_listenPortName$692, &tmp_val);
                      if(!(return_value_check_long$693 == 0))
                      {
                        char *return_value_get_realmname$689;
                        return_value_get_realmname$689=get_realmname(config, j);
                        char *return_value_get_clientname$690;
                        return_value_get_clientname$690=get_clientname(pointer, k);
                        aflog((char)2, (char)64, "realm[%s]: INVALID listenport - removing Client[%s]", return_value_get_realmname$689, return_value_get_clientname$690);
                        remove_client(pointer, k, &allset, &wset, scheduler);
                        break;
                      }

                      tmp_val = tmp_val % (signed long int)65536;
                      memset((void *)tmp_tab, 0, (unsigned long int)6);
                      sprintf(tmp_tab, "%d", (signed int)tmp_val);
                      ipfam = (char)0x01;
                      char return_value_ServerRealm_get_realmType$695;
                      return_value_ServerRealm_get_realmType$695=ServerRealm_get_realmType(pointer);
                      if(!((16 & (signed int)return_value_ServerRealm_get_realmType$695) == 0))
                        ipfam = ipfam | (char)0x02;

                      else
                      {
                        return_value_ServerRealm_get_realmType$694=ServerRealm_get_realmType(pointer);
                        if(!((32 & (signed int)return_value_ServerRealm_get_realmType$694) == 0))
                          ipfam = ipfam | (char)0x04;

                      }
                      do
                      {
                        return_value_ConnectClient_get_listenFdp$696=ConnectClient_get_listenFdp(srClientsTable[(signed long int)k]);
                        return_value_ConnectClient_get_usrCliPair$697=ConnectClient_get_usrCliPair(srClientsTable[(signed long int)k]);
                        return_value_UsrCli_get_listenHostName$698=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)return_value_ConnectClient_get_usrCliPair$697]);
                        if(!(return_value_UsrCli_get_listenHostName$698 == ((char *)NULL)))
                        {
                          return_value_ConnectClient_get_usrCliPair$699=ConnectClient_get_usrCliPair(srClientsTable[(signed long int)k]);
                          return_value_UsrCli_get_listenHostName$700=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)return_value_ConnectClient_get_usrCliPair$699]);
                          tmp_if_expr$702 = return_value_UsrCli_get_listenHostName$700;
                        }

                        else
                        {
                          return_value_ServerRealm_get_hostName$701=ServerRealm_get_hostName(pointer);
                          tmp_if_expr$702 = return_value_ServerRealm_get_hostName$701;
                        }
                        return_value_ip_listen$703=ip_listen(return_value_ConnectClient_get_listenFdp$696, tmp_if_expr$702, tmp_tab, &len, ipfam);
                        if(return_value_ip_listen$703 == 0)
                          break;

                        tmp_val = (tmp_val + (signed long int)1) % (signed long int)65536;
                        memset((void *)tmp_tab, 0, (unsigned long int)6);
                        sprintf(tmp_tab, "%d", (signed int)tmp_val);
                      }
                      while((_Bool)1);
                      ServerRealm_set_addressLength(pointer, len);
                      signed int return_value_ConnectClient_get_listenFd$704;
                      return_value_ConnectClient_get_listenFd$704=ConnectClient_get_listenFd(srClientsTable[(signed long int)k]);
                      signed int return_value_ConnectClient_get_listenFd$705;
                      return_value_ConnectClient_get_listenFd$705=ConnectClient_get_listenFd(srClientsTable[(signed long int)k]);
                      (&allset)->__fds_bits[(signed long int)(return_value_ConnectClient_get_listenFd$704 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectClient_get_listenFd$704 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectClient_get_listenFd$705 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                      signed int return_value_ConnectClient_get_listenFd$706;
                      return_value_ConnectClient_get_listenFd$706=ConnectClient_get_listenFd(srClientsTable[(signed long int)k]);
                      if(!(1 + return_value_ConnectClient_get_listenFd$706 >= maxfdp1))
                        tmp_if_expr$708 = maxfdp1;

                      else
                      {
                        return_value_ConnectClient_get_listenFd$707=ConnectClient_get_listenFd(srClientsTable[(signed long int)k]);
                        tmp_if_expr$708 = return_value_ConnectClient_get_listenFd$707 + 1;
                      }
                      maxfdp1 = tmp_if_expr$708;
                      char *return_value_get_realmname$709;
                      return_value_get_realmname$709=get_realmname(config, j);
                      char *return_value_get_clientname$710;
                      return_value_get_clientname$710=get_clientname(pointer, k);
                      aflog((char)2, (char)8, "realm[%s]: Client[%s]: listenport=%s", return_value_get_realmname$709, return_value_get_clientname$710, (const void *)tmp_tab);
                    }

                  }

                  else
                  {
                    char *return_value_get_realmname$712;
                    return_value_get_realmname$712=get_realmname(config, j);
                    aflog((char)2, (char)32, "realm[%s]: client limit EXCEEDED", return_value_get_realmname$712);
                    buff[(signed long int)0] = (unsigned char)12;
                    char return_value_ServerRealm_get_realmType$713;
                    return_value_ServerRealm_get_realmType$713=ServerRealm_get_realmType(pointer);
                    struct anonymous$1 *return_value_ConnectClient_get_sslFd$714;
                    return_value_ConnectClient_get_sslFd$714=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                    SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType$713 | 4), return_value_ConnectClient_get_sslFd$714, buff, 5);
                    remove_client(pointer, k, &allset, &wset, scheduler);
                  }
                }

                else
                {
                  return_value_ConnectClient_get_state$724=ConnectClient_get_state(srClientsTable[(signed long int)k]);
                  if(numofcon == 0 && (signed int)return_value_ConnectClient_get_state$724 == 3)
                  {
                    char return_value_ServerRealm_get_realmType$716;
                    return_value_ServerRealm_get_realmType$716=ServerRealm_get_realmType(pointer);
                    struct anonymous$1 *return_value_ConnectClient_get_sslFd$717;
                    return_value_ConnectClient_get_sslFd$717=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                    n=SslFd_get_message(return_value_ServerRealm_get_realmType$716, return_value_ConnectClient_get_sslFd$717, buff, length);
                    buff[(signed long int)n] = (unsigned char)0;
                    char *return_value_get_realmname$718;
                    return_value_get_realmname$718=get_realmname(config, j);
                    char *return_value_get_clientname$719;
                    return_value_get_clientname$719=get_clientname(pointer, k);
                    aflog((char)2, (char)8, "realm[%s]: Client[%s]: ID received: %s", return_value_get_realmname$718, return_value_get_clientname$719, (const void *)buff);
                    ConnectClient_set_sClientId(srClientsTable[(signed long int)k], (char *)buff);
                  }

                  else
                  {
                    char *return_value_get_realmname$720;
                    return_value_get_realmname$720=get_realmname(config, j);
                    char *return_value_get_clientname$721;
                    return_value_get_clientname$721=get_clientname(pointer, k);
                    aflog((char)2, (char)64, "realm[%s]: Client[%s]: Wrong password - CLOSING", return_value_get_realmname$720, return_value_get_clientname$721);
                    buff[(signed long int)0] = (unsigned char)13;
                    char return_value_ServerRealm_get_realmType$722;
                    return_value_ServerRealm_get_realmType$722=ServerRealm_get_realmType(pointer);
                    struct anonymous$1 *return_value_ConnectClient_get_sslFd$723;
                    return_value_ConnectClient_get_sslFd$723=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                    SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType$722 | 4), return_value_ConnectClient_get_sslFd$723, buff, 5);
                    remove_client(pointer, k, &allset, &wset, scheduler);
                  }
                }
                break;
              }
              case 9:
              {
                return_value_ConnectUser_get_state$738=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                if((signed int)return_value_ConnectUser_get_state$738 == 7)
                  tmp_if_expr$740 = (_Bool)1;

                else
                {
                  return_value_ConnectUser_get_state$739=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                  tmp_if_expr$740 = (signed int)return_value_ConnectUser_get_state$739 == 11 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$740)
                {
                  char *return_value_get_realmname$732;
                  return_value_get_realmname$732=get_realmname(config, j);
                  signed int return_value_get_username$733;
                  return_value_get_username$733=get_username(pointer, numofcon);
                  aflog((char)2, (char)2, "realm[%s]: user[%d]: STOP READING", return_value_get_realmname$732, return_value_get_username$733);
                  signed int return_value_ConnectUser_get_connFd$734;
                  return_value_ConnectUser_get_connFd$734=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                  signed int return_value_ConnectUser_get_connFd$735;
                  return_value_ConnectUser_get_connFd$735=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                  (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$734 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$734 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$735 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                }

                else
                {
                  char *return_value_get_realmname$736;
                  return_value_get_realmname$736=get_realmname(config, j);
                  signed int return_value_get_username$737;
                  return_value_get_username$737=get_username(pointer, numofcon);
                  aflog((char)2, (char)4, "realm[%s]: user[%d]: STOP READING - ignored", return_value_get_realmname$736, return_value_get_username$737);
                }
                break;
              }
              case 10:
              {
                return_value_ConnectUser_get_state$747=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                if((signed int)return_value_ConnectUser_get_state$747 == 7)
                  tmp_if_expr$749 = (_Bool)1;

                else
                {
                  return_value_ConnectUser_get_state$748=ConnectUser_get_state(srUsersTable[(signed long int)numofcon]);
                  tmp_if_expr$749 = (signed int)return_value_ConnectUser_get_state$748 == 11 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$749)
                {
                  char *return_value_get_realmname$741;
                  return_value_get_realmname$741=get_realmname(config, j);
                  signed int return_value_get_username$742;
                  return_value_get_username$742=get_username(pointer, numofcon);
                  aflog((char)2, (char)2, "realm[%s]: user[%d]: START READING", return_value_get_realmname$741, return_value_get_username$742);
                  signed int return_value_ConnectUser_get_connFd$743;
                  return_value_ConnectUser_get_connFd$743=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                  signed int return_value_ConnectUser_get_connFd$744;
                  return_value_ConnectUser_get_connFd$744=ConnectUser_get_connFd(srUsersTable[(signed long int)numofcon]);
                  (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$743 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$743 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectUser_get_connFd$744 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                }

                else
                {
                  char *return_value_get_realmname$745;
                  return_value_get_realmname$745=get_realmname(config, j);
                  signed int return_value_get_username$746;
                  return_value_get_username$746=get_username(pointer, numofcon);
                  aflog((char)2, (char)4, "realm[%s]: user[%d]: START READING - ignored", return_value_get_realmname$745, return_value_get_username$746);
                }
                break;
              }
              case 13:
              {
                return_value_get_realmname$750=get_realmname(config, j);
                return_value_get_clientname$751=get_clientname(pointer, k);
                aflog((char)2, (char)64, "realm[%s]: Client[%s]: Wrong message - CLOSING", return_value_get_realmname$750, return_value_get_clientname$751);
                remove_client(pointer, k, &allset, &wset, scheduler);
                break;
              }
              case 14:
              {
                return_value_ConnectClient_get_state$783=ConnectClient_get_state(srClientsTable[(signed long int)k]);
                if((signed int)return_value_ConnectClient_get_state$783 == 2)
                {
                  return_value_ServerRealm_get_password$781=ServerRealm_get_password(pointer);
                  return_value_ServerRealm_get_password$782=ServerRealm_get_password(pointer);
                  if(numofcon == 256 * (signed int)*return_value_ServerRealm_get_password$781 + (signed int)return_value_ServerRealm_get_password$782[1l])
                  {
                    return_value_ServerRealm_get_password$779=ServerRealm_get_password(pointer);
                    return_value_ServerRealm_get_password$780=ServerRealm_get_password(pointer);
                    if(length == 256 * (signed int)return_value_ServerRealm_get_password$779[2l] + (signed int)return_value_ServerRealm_get_password$780[3l])
                    {
                      char *return_value_get_realmname$752;
                      return_value_get_realmname$752=get_realmname(config, j);
                      char *return_value_get_clientname$753;
                      return_value_get_clientname$753=get_clientname(pointer, k);
                      aflog((char)8, (char)8, "realm[%s]: Client[%s]: NEW remote admin -- pass OK", return_value_get_realmname$752, return_value_get_clientname$753);
                      l = 0;
                      do
                      {
                        return_value_ServerRealm_get_raClientsLimit$754=ServerRealm_get_raClientsLimit(pointer);
                        if(l >= return_value_ServerRealm_get_raClientsLimit$754)
                          break;

                        char return_value_ConnectClient_get_state$769;
                        return_value_ConnectClient_get_state$769=ConnectClient_get_state(srRaClientsTable[(signed long int)l]);
                        if((signed int)return_value_ConnectClient_get_state$769 == 0)
                        {
                          struct anonymous$1 *return_value_ConnectClient_get_sslFd$755;
                          return_value_ConnectClient_get_sslFd$755=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)l]);
                          struct anonymous$1 *return_value_ConnectClient_get_sslFd$756;
                          return_value_ConnectClient_get_sslFd$756=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                          signed int return_value_SslFd_get_fd$757;
                          return_value_SslFd_get_fd$757=SslFd_get_fd(return_value_ConnectClient_get_sslFd$756);
                          SslFd_set_fd(return_value_ConnectClient_get_sslFd$755, return_value_SslFd_get_fd$757);
                          signed long int return_value_ConnectClient_get_connectTime$758;
                          return_value_ConnectClient_get_connectTime$758=ConnectClient_get_connectTime(srClientsTable[(signed long int)k]);
                          ConnectClient_set_connectTime(srRaClientsTable[(signed long int)l], return_value_ConnectClient_get_connectTime$758);
                          signed long int return_value_ConnectClient_get_lastActivity$759;
                          return_value_ConnectClient_get_lastActivity$759=ConnectClient_get_lastActivity(srClientsTable[(signed long int)k]);
                          ConnectClient_set_lastActivity(srRaClientsTable[(signed long int)l], return_value_ConnectClient_get_lastActivity$759);
                          char return_value_ConnectClient_get_tunnelType$760;
                          return_value_ConnectClient_get_tunnelType$760=ConnectClient_get_tunnelType(srClientsTable[(signed long int)k]);
                          ConnectClient_set_tunnelType(srRaClientsTable[(signed long int)l], return_value_ConnectClient_get_tunnelType$760);
                          signed int return_value_ConnectClient_get_clientId$761;
                          return_value_ConnectClient_get_clientId$761=ConnectClient_get_clientId(srClientsTable[(signed long int)k]);
                          ConnectClient_set_clientId(srRaClientsTable[(signed long int)l], return_value_ConnectClient_get_clientId$761);
                          char *return_value_ConnectClient_get_nameBuf$762;
                          return_value_ConnectClient_get_nameBuf$762=ConnectClient_get_nameBuf(srClientsTable[(signed long int)k]);
                          ConnectClient_set_nameBuf(srRaClientsTable[(signed long int)l], return_value_ConnectClient_get_nameBuf$762);
                          char *return_value_ConnectClient_get_portBuf$763;
                          return_value_ConnectClient_get_portBuf$763=ConnectClient_get_portBuf(srClientsTable[(signed long int)k]);
                          ConnectClient_set_portBuf(srRaClientsTable[(signed long int)l], return_value_ConnectClient_get_portBuf$763);
                          struct anonymous$1 *return_value_ConnectClient_get_sslFd$764;
                          return_value_ConnectClient_get_sslFd$764=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)l]);
                          tmp_ssl=SslFd_get_ssl(return_value_ConnectClient_get_sslFd$764);
                          struct anonymous$1 *return_value_ConnectClient_get_sslFd$765;
                          return_value_ConnectClient_get_sslFd$765=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)l]);
                          struct anonymous$1 *return_value_ConnectClient_get_sslFd$766;
                          return_value_ConnectClient_get_sslFd$766=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                          struct ssl_st *return_value_SslFd_get_ssl$767;
                          return_value_SslFd_get_ssl$767=SslFd_get_ssl(return_value_ConnectClient_get_sslFd$766);
                          SslFd_set_ssl_nf(return_value_ConnectClient_get_sslFd$765, return_value_SslFd_get_ssl$767);
                          struct anonymous$1 *return_value_ConnectClient_get_sslFd$768;
                          return_value_ConnectClient_get_sslFd$768=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                          SslFd_set_ssl_nf(return_value_ConnectClient_get_sslFd$768, tmp_ssl);
                          ConnectClient_set_state(srClientsTable[(signed long int)k], (char)0);
                          break;
                        }

                        l = l + 1;
                      }
                      while((_Bool)1);
                      signed int return_value_ServerRealm_get_raClientsLimit$778;
                      return_value_ServerRealm_get_raClientsLimit$778=ServerRealm_get_raClientsLimit(pointer);
                      if(!(l == return_value_ServerRealm_get_raClientsLimit$778))
                      {
                        ConnectClient_set_state(srRaClientsTable[(signed long int)l], (char)3);
                        ServerRealm_increase_connectedRaClients(pointer);
                        task=ConnectClient_get_task(srClientsTable[(signed long int)k]);
                        if(!(task == ((struct anonymous$13 *)NULL)))
                        {
                          TaskScheduler_removeTask(scheduler, task);
                          ConnectClient_set_task(srClientsTable[(signed long int)k], (struct anonymous$13 *)(void *)0);
                        }

                        sprintf((char *)&buff[(signed long int)5], "AFSERVER v0.8.4");
                        unsigned long int return_value_strlen$770;
                        return_value_strlen$770=strlen((char *)&buff[(signed long int)5]);
                        n = (signed int)return_value_strlen$770;
                        buff[(signed long int)0] = (unsigned char)14;
                        char return_value_ServerRealm_get_realmType$771;
                        return_value_ServerRealm_get_realmType$771=ServerRealm_get_realmType(pointer);
                        buff[(signed long int)1] = (unsigned char)return_value_ServerRealm_get_realmType$771;
                        buff[(signed long int)2] = (unsigned char)0;
                        buff[(signed long int)3] = (unsigned char)(n >> 8);
                        buff[(signed long int)4] = (unsigned char)n;
                        char return_value_ServerRealm_get_realmType$772;
                        return_value_ServerRealm_get_realmType$772=ServerRealm_get_realmType(pointer);
                        struct anonymous$1 *return_value_ConnectClient_get_sslFd$773;
                        return_value_ConnectClient_get_sslFd$773=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)l]);
                        SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType$772 | 4), return_value_ConnectClient_get_sslFd$773, buff, n + 5);
                      }

                      else
                      {
                        char *return_value_get_realmname$774;
                        return_value_get_realmname$774=get_realmname(config, j);
                        char *return_value_get_clientname$775;
                        return_value_get_clientname$775=get_clientname(pointer, k);
                        aflog((char)8, (char)32, "realm[%s]: Client[%s]: remote admin -- limit EXCEEDED", return_value_get_realmname$774, return_value_get_clientname$775);
                        buff[(signed long int)0] = (unsigned char)12;
                        char return_value_ServerRealm_get_realmType$776;
                        return_value_ServerRealm_get_realmType$776=ServerRealm_get_realmType(pointer);
                        struct anonymous$1 *return_value_ConnectClient_get_sslFd$777;
                        return_value_ConnectClient_get_sslFd$777=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                        SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType$776 | 4 | 8), return_value_ConnectClient_get_sslFd$777, buff, 5);
                        remove_client(pointer, k, &allset, &wset, scheduler);
                      }
                    }

                  }

                }

                break;
              }
              case 16:
              {
                return_value_get_realmname$784=get_realmname(config, j);
                return_value_get_clientname$785=get_clientname(pointer, k);
                aflog((char)2, (char)2, "realm[%s]: Client[%s]: Keep alive packet", return_value_get_realmname$784, return_value_get_clientname$785);
                break;
              }
              case 18:
              {
                return_value_get_realmname$786=get_realmname(config, j);
                return_value_get_clientname$787=get_clientname(pointer, k);
                aflog((char)2, (char)8, "realm[%s]: Client[%s]: MULTI enabled: %d", return_value_get_realmname$786, return_value_get_clientname$787, buff[(signed long int)1]);
                ConnectClient_set_multi(srClientsTable[(signed long int)k], (char)1);
                break;
              }
              default:
              {
                char *return_value_get_realmname$788;
                return_value_get_realmname$788=get_realmname(config, j);
                char *return_value_get_clientname$789;
                return_value_get_clientname$789=get_clientname(pointer, k);
                aflog((char)2, (char)64, "realm[%s]: Client[%s]: Unrecognized message - CLOSING", return_value_get_realmname$788, return_value_get_clientname$789);
                remove_client(pointer, k, &allset, &wset, scheduler);
              }
            }
          }

        }


      __CPROVER_DUMP_L389:
        ;
        k = k + 1;
      }
      while((_Bool)1);
      k = 0;
      do
      {
        return_value_ServerRealm_get_raClientsLimit$795=ServerRealm_get_raClientsLimit(pointer);
        if(k >= return_value_ServerRealm_get_raClientsLimit$795)
          break;

        return_value_ConnectClient_get_state$971=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
        if((signed int)return_value_ConnectClient_get_state$971 >= 1)
        {
          return_value_ConnectClient_get_sslFd$967=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
          return_value_SslFd_get_fd$968=SslFd_get_fd(return_value_ConnectClient_get_sslFd$967);
          return_value_ConnectClient_get_sslFd$969=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
          return_value_SslFd_get_fd$970=SslFd_get_fd(return_value_ConnectClient_get_sslFd$969);
          if(!((rset.__fds_bits[(signed long int)(return_value_SslFd_get_fd$968 / 8)] & 1l << return_value_SslFd_get_fd$970 % 8) == 0l))
          {
            char return_value_ConnectClient_get_state$813;
            return_value_ConnectClient_get_state$813=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
            if((signed int)return_value_ConnectClient_get_state$813 == 1)
            {
              struct anonymous$1 *return_value_ConnectClient_get_sslFd$796;
              return_value_ConnectClient_get_sslFd$796=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
              make_ssl_initialize(return_value_ConnectClient_get_sslFd$796);
              char *return_value_get_realmname$797;
              return_value_get_realmname$797=get_realmname(config, j);
              char *return_value_get_raclientname$798;
              return_value_get_raclientname$798=get_raclientname(pointer, k);
              aflog((char)8, (char)4, "realm[%s]: new Client[%s] (ra): SSL_accept", return_value_get_realmname$797, return_value_get_raclientname$798);
              struct anonymous$1 *return_value_ConnectClient_get_sslFd$799;
              return_value_ConnectClient_get_sslFd$799=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
              signed int return_value_make_ssl_accept$800;
              return_value_make_ssl_accept$800=make_ssl_accept(return_value_ConnectClient_get_sslFd$799);
              switch(return_value_make_ssl_accept$800)
              {
                case 2:
                {
                  struct anonymous$1 *return_value_ConnectClient_get_sslFd$801;
                  return_value_ConnectClient_get_sslFd$801=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                  signed int return_value_SslFd_get_fd$802;
                  return_value_SslFd_get_fd$802=SslFd_get_fd(return_value_ConnectClient_get_sslFd$801);
                  close(return_value_SslFd_get_fd$802);
                  struct anonymous$1 *return_value_ConnectClient_get_sslFd$803;
                  return_value_ConnectClient_get_sslFd$803=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                  signed int return_value_SslFd_get_fd$804;
                  return_value_SslFd_get_fd$804=SslFd_get_fd(return_value_ConnectClient_get_sslFd$803);
                  struct anonymous$1 *return_value_ConnectClient_get_sslFd$805;
                  return_value_ConnectClient_get_sslFd$805=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                  signed int return_value_SslFd_get_fd$806;
                  return_value_SslFd_get_fd$806=SslFd_get_fd(return_value_ConnectClient_get_sslFd$805);
                  (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd$804 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd$804 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_SslFd_get_fd$806 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
                  struct anonymous$1 *return_value_ConnectClient_get_sslFd$807;
                  return_value_ConnectClient_get_sslFd$807=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                  struct ssl_st *return_value_SslFd_get_ssl$808;
                  return_value_SslFd_get_ssl$808=SslFd_get_ssl(return_value_ConnectClient_get_sslFd$807);
                  SSL_clear(return_value_SslFd_get_ssl$808);
                  ConnectClient_set_state(srRaClientsTable[(signed long int)k], (char)0);
                  task=ConnectClient_get_task(srRaClientsTable[(signed long int)k]);
                  if(!(task == ((struct anonymous$13 *)NULL)))
                  {
                    TaskScheduler_removeTask(scheduler, task);
                    ConnectClient_set_task(srRaClientsTable[(signed long int)k], (struct anonymous$13 *)(void *)0);
                  }

                  ServerRealm_decrease_connectedClients(pointer);
                  char *return_value_get_realmname$809;
                  return_value_get_realmname$809=get_realmname(config, j);
                  char *return_value_get_raclientname$810;
                  return_value_get_raclientname$810=get_raclientname(pointer, k);
                  aflog((char)8, (char)64, "realm[%s]: new Client[%s] (ra): DENIED by SSL_accept", return_value_get_realmname$809, return_value_get_raclientname$810);
                }
                case 1:
                  goto __CPROVER_DUMP_L448;
                default:
                {
                  return_value_get_realmname$811=get_realmname(config, j);
                  return_value_get_raclientname$812=get_raclientname(pointer, k);
                  aflog((char)8, (char)2, "realm[%s]: new Client[%s] (ra): ACCEPTED by SSL_accept", return_value_get_realmname$811, return_value_get_raclientname$812);
                  ConnectClient_set_state(srRaClientsTable[(signed long int)k], (char)2);
                  goto __CPROVER_DUMP_L448;
                }
              }
            }

            char *return_value_get_realmname$814;
            return_value_get_realmname$814=get_realmname(config, j);
            char *return_value_get_raclientname$815;
            return_value_get_raclientname$815=get_raclientname(pointer, k);
            aflog((char)8, (char)4, "realm[%s]: Client[%s] (ra): commfd: FD_ISSET", return_value_get_realmname$814, return_value_get_raclientname$815);
            char return_value_ServerRealm_get_realmType$816;
            return_value_ServerRealm_get_realmType$816=ServerRealm_get_realmType(pointer);
            struct anonymous$1 *return_value_ConnectClient_get_sslFd$817;
            return_value_ConnectClient_get_sslFd$817=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
            struct anonymous$8 *return_value_ConnectClient_get_header$818;
            return_value_ConnectClient_get_header$818=ConnectClient_get_header(srRaClientsTable[(signed long int)k]);
            signed int return_value_HeaderBuffer_to_read$819;
            return_value_HeaderBuffer_to_read$819=HeaderBuffer_to_read(return_value_ConnectClient_get_header$818);
            n=SslFd_get_message((char)((signed int)return_value_ServerRealm_get_realmType$816 | 4 | 8), return_value_ConnectClient_get_sslFd$817, buff, -1 * return_value_HeaderBuffer_to_read$819);
            if(n == -1)
            {
              signed int *return_value___errno_location$825;
              return_value___errno_location$825=__errno_location();
              if(*return_value___errno_location$825 == 11)
              {
                char *return_value_get_realmname$820;
                return_value_get_realmname$820=get_realmname(config, j);
                char *return_value_get_raclientname$821;
                return_value_get_raclientname$821=get_raclientname(pointer, k);
                aflog((char)8, (char)4, "realm[%s]: Client[%s] (ra): commfd: EAGAIN", return_value_get_realmname$820, return_value_get_raclientname$821);
                goto __CPROVER_DUMP_L448;
              }

              else
              {
                char *return_value_get_realmname$822;
                return_value_get_realmname$822=get_realmname(config, j);
                char *return_value_get_raclientname$823;
                return_value_get_raclientname$823=get_raclientname(pointer, k);
                signed int *return_value___errno_location$824;
                return_value___errno_location$824=__errno_location();
                aflog((char)8, (char)64, "realm[%s]: Client[%s] (ra): commfd: ERROR: %d", return_value_get_realmname$822, return_value_get_raclientname$823, *return_value___errno_location$824);
                n = 0;
              }
            }

            else
              if(!(n == 5))
              {
                if(!(n == 0))
                {
                  char *return_value_get_realmname$826;
                  return_value_get_realmname$826=get_realmname(config, j);
                  char *return_value_get_raclientname$827;
                  return_value_get_raclientname$827=get_raclientname(pointer, k);
                  aflog((char)8, (char)32, "realm[%s]: Client[%s] (ra): header length = %d --> buffering", return_value_get_realmname$826, return_value_get_raclientname$827, n);
                  struct anonymous$8 *return_value_ConnectClient_get_header$828;
                  return_value_ConnectClient_get_header$828=ConnectClient_get_header(srRaClientsTable[(signed long int)k]);
                  HeaderBuffer_store(return_value_ConnectClient_get_header$828, buff, n);
                  struct anonymous$8 *return_value_ConnectClient_get_header$830;
                  return_value_ConnectClient_get_header$830=ConnectClient_get_header(srRaClientsTable[(signed long int)k]);
                  signed int return_value_HeaderBuffer_to_read$831;
                  return_value_HeaderBuffer_to_read$831=HeaderBuffer_to_read(return_value_ConnectClient_get_header$830);
                  if(return_value_HeaderBuffer_to_read$831 == 0)
                  {
                    struct anonymous$8 *return_value_ConnectClient_get_header$829;
                    return_value_ConnectClient_get_header$829=ConnectClient_get_header(srRaClientsTable[(signed long int)k]);
                    HeaderBuffer_restore(return_value_ConnectClient_get_header$829, buff);
                    n = 5;
                  }

                  else
                    goto __CPROVER_DUMP_L448;
                }

              }

            if(n == 0)
            {
              remove_raclient(pointer, k, &allset, &wset, scheduler);
              char *return_value_get_realmname$832;
              return_value_get_realmname$832=get_realmname(config, j);
              char *return_value_get_raclientname$833;
              return_value_get_raclientname$833=get_raclientname(pointer, k);
              aflog((char)8, (char)8, "realm[%s]: Client[%s] (ra): commfd: CLOSED", return_value_get_realmname$832, return_value_get_raclientname$833);
              goto __CPROVER_DUMP_L448;
            }

            numofcon = (signed int)buff[(signed long int)1];
            numofcon = numofcon << 8;
            numofcon = numofcon + (signed int)buff[(signed long int)2];
            length = (signed int)buff[(signed long int)3];
            length = length << 8;
            length = length + (signed int)buff[(signed long int)4];
            char return_value_ConnectClient_get_state$836;
            return_value_ConnectClient_get_state$836=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
            if(!((signed int)return_value_ConnectClient_get_state$836 >= 2))
            {
              char *return_value_get_realmname$834;
              return_value_get_realmname$834=get_realmname(config, j);
              char *return_value_get_raclientname$835;
              return_value_get_raclientname$835=get_raclientname(pointer, k);
              aflog((char)8, (char)32, "realm[%s]: Client[%s] (ra): Impossible behaviour --> ignoring", return_value_get_realmname$834, return_value_get_raclientname$835);
              goto __CPROVER_DUMP_L448;
            }

            char return_value_ConnectClient_get_state$837;
            return_value_ConnectClient_get_state$837=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
            if((signed int)return_value_ConnectClient_get_state$837 == 2)
            {
              if(!((signed int)buff[0l] == 8))
              {
                if(!((signed int)buff[0l] == 14))
                  buff[(signed long int)0] = (unsigned char)13;

              }

            }

            time(&now);
            ConnectClient_set_lastActivity(srRaClientsTable[(signed long int)k], now);
            switch((signed int)buff[(signed long int)0])
            {
              case 8:
              {
                return_value_ConnectClient_get_state$904=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
                if((signed int)return_value_ConnectClient_get_state$904 == 2)
                {
                  return_value_ServerRealm_get_password$905=ServerRealm_get_password(pointer);
                  return_value_ServerRealm_get_password$906=ServerRealm_get_password(pointer);
                  tmp_if_expr$907 = numofcon == (signed int)return_value_ServerRealm_get_password$905[(signed long int)0] * 256 + (signed int)return_value_ServerRealm_get_password$906[(signed long int)1] ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$907 = (_Bool)0;
                if(tmp_if_expr$907)
                {
                  return_value_ServerRealm_get_password$908=ServerRealm_get_password(pointer);
                  return_value_ServerRealm_get_password$909=ServerRealm_get_password(pointer);
                  tmp_if_expr$910 = length == (signed int)return_value_ServerRealm_get_password$908[(signed long int)2] * 256 + (signed int)return_value_ServerRealm_get_password$909[(signed long int)3] ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$910 = (_Bool)0;
                if(tmp_if_expr$910)
                {
                  ConnectClient_set_multi(srRaClientsTable[(signed long int)k], (char)0);
                  l = 0;
                  do
                  {
                    return_value_ServerRealm_get_clientsLimit$838=ServerRealm_get_clientsLimit(pointer);
                    if(l >= return_value_ServerRealm_get_clientsLimit$838)
                      break;

                    char return_value_ConnectClient_get_state$857;
                    return_value_ConnectClient_get_state$857=ConnectClient_get_state(srClientsTable[(signed long int)l]);
                    if((signed int)return_value_ConnectClient_get_state$857 == 0)
                    {
                      char *return_value_get_realmname$839;
                      return_value_get_realmname$839=get_realmname(config, j);
                      char *return_value_get_raclientname$840;
                      return_value_get_raclientname$840=get_raclientname(pointer, k);
                      char *return_value_get_clientname$841;
                      return_value_get_clientname$841=get_clientname(pointer, l);
                      aflog((char)(8 | 2), (char)8, "realm[%s]: Client[%s] (ra) --> Client[%s]", return_value_get_realmname$839, return_value_get_raclientname$840, return_value_get_clientname$841);
                      struct anonymous$1 *return_value_ConnectClient_get_sslFd$842;
                      return_value_ConnectClient_get_sslFd$842=ConnectClient_get_sslFd(srClientsTable[(signed long int)l]);
                      struct anonymous$1 *return_value_ConnectClient_get_sslFd$843;
                      return_value_ConnectClient_get_sslFd$843=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                      signed int return_value_SslFd_get_fd$844;
                      return_value_SslFd_get_fd$844=SslFd_get_fd(return_value_ConnectClient_get_sslFd$843);
                      SslFd_set_fd(return_value_ConnectClient_get_sslFd$842, return_value_SslFd_get_fd$844);
                      signed long int return_value_ConnectClient_get_connectTime$845;
                      return_value_ConnectClient_get_connectTime$845=ConnectClient_get_connectTime(srRaClientsTable[(signed long int)k]);
                      ConnectClient_set_connectTime(srClientsTable[(signed long int)l], return_value_ConnectClient_get_connectTime$845);
                      signed long int return_value_ConnectClient_get_lastActivity$846;
                      return_value_ConnectClient_get_lastActivity$846=ConnectClient_get_lastActivity(srRaClientsTable[(signed long int)k]);
                      ConnectClient_set_lastActivity(srClientsTable[(signed long int)l], return_value_ConnectClient_get_lastActivity$846);
                      char return_value_ConnectClient_get_tunnelType$847;
                      return_value_ConnectClient_get_tunnelType$847=ConnectClient_get_tunnelType(srRaClientsTable[(signed long int)k]);
                      ConnectClient_set_tunnelType(srClientsTable[(signed long int)l], return_value_ConnectClient_get_tunnelType$847);
                      signed int return_value_ConnectClient_get_clientId$848;
                      return_value_ConnectClient_get_clientId$848=ConnectClient_get_clientId(srRaClientsTable[(signed long int)k]);
                      ConnectClient_set_clientId(srClientsTable[(signed long int)l], return_value_ConnectClient_get_clientId$848);
                      char *return_value_ConnectClient_get_nameBuf$849;
                      return_value_ConnectClient_get_nameBuf$849=ConnectClient_get_nameBuf(srRaClientsTable[(signed long int)k]);
                      ConnectClient_set_nameBuf(srClientsTable[(signed long int)l], return_value_ConnectClient_get_nameBuf$849);
                      char *return_value_ConnectClient_get_portBuf$850;
                      return_value_ConnectClient_get_portBuf$850=ConnectClient_get_portBuf(srRaClientsTable[(signed long int)k]);
                      ConnectClient_set_portBuf(srClientsTable[(signed long int)l], return_value_ConnectClient_get_portBuf$850);
                      struct anonymous$1 *return_value_ConnectClient_get_sslFd$851;
                      return_value_ConnectClient_get_sslFd$851=ConnectClient_get_sslFd(srClientsTable[(signed long int)l]);
                      tmp_ssl=SslFd_get_ssl(return_value_ConnectClient_get_sslFd$851);
                      struct anonymous$1 *return_value_ConnectClient_get_sslFd$852;
                      return_value_ConnectClient_get_sslFd$852=ConnectClient_get_sslFd(srClientsTable[(signed long int)l]);
                      struct anonymous$1 *return_value_ConnectClient_get_sslFd$853;
                      return_value_ConnectClient_get_sslFd$853=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                      struct ssl_st *return_value_SslFd_get_ssl$854;
                      return_value_SslFd_get_ssl$854=SslFd_get_ssl(return_value_ConnectClient_get_sslFd$853);
                      SslFd_set_ssl_nf(return_value_ConnectClient_get_sslFd$852, return_value_SslFd_get_ssl$854);
                      struct anonymous$1 *return_value_ConnectClient_get_sslFd$855;
                      return_value_ConnectClient_get_sslFd$855=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                      SslFd_set_ssl_nf(return_value_ConnectClient_get_sslFd$855, tmp_ssl);
                      signed int return_value_ConnectClient_get_usrCliPair$856;
                      return_value_ConnectClient_get_usrCliPair$856=ConnectClient_get_usrCliPair(srRaClientsTable[(signed long int)k]);
                      ConnectClient_set_usrCliPair(srClientsTable[(signed long int)l], return_value_ConnectClient_get_usrCliPair$856);
                      ConnectClient_set_state(srRaClientsTable[(signed long int)k], (char)0);
                      break;
                    }

                    l = l + 1;
                  }
                  while((_Bool)1);
                  signed int return_value_ServerRealm_get_clientsLimit$896;
                  return_value_ServerRealm_get_clientsLimit$896=ServerRealm_get_clientsLimit(pointer);
                  if(!(l == return_value_ServerRealm_get_clientsLimit$896))
                  {
                    ConnectClient_set_state(srClientsTable[(signed long int)l], (char)3);
                    char *return_value_get_realmname$858;
                    return_value_get_realmname$858=get_realmname(config, j);
                    char *return_value_get_clientname$859;
                    return_value_get_clientname$859=get_clientname(pointer, l);
                    aflog((char)2, (char)8, "realm[%s]: Client[%s]: pass ok - ACCESS GRANTED", return_value_get_realmname$858, return_value_get_clientname$859);
                    buff[(signed long int)0] = (unsigned char)8;
                    signed int return_value_ConnectClient_get_limit$860;
                    return_value_ConnectClient_get_limit$860=ConnectClient_get_limit(srClientsTable[(signed long int)l]);
                    buff[(signed long int)1] = (unsigned char)(return_value_ConnectClient_get_limit$860 >> 8);
                    signed int return_value_ConnectClient_get_limit$861;
                    return_value_ConnectClient_get_limit$861=ConnectClient_get_limit(srClientsTable[(signed long int)l]);
                    buff[(signed long int)2] = (unsigned char)return_value_ConnectClient_get_limit$861;
                    char return_value_ServerRealm_get_realmType$862;
                    return_value_ServerRealm_get_realmType$862=ServerRealm_get_realmType(pointer);
                    buff[(signed long int)3] = (unsigned char)return_value_ServerRealm_get_realmType$862;
                    char return_value_ServerRealm_get_realmType$863;
                    return_value_ServerRealm_get_realmType$863=ServerRealm_get_realmType(pointer);
                    struct anonymous$1 *return_value_ConnectClient_get_sslFd$864;
                    return_value_ConnectClient_get_sslFd$864=ConnectClient_get_sslFd(srClientsTable[(signed long int)l]);
                    SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType$863 | 4 | 8), return_value_ConnectClient_get_sslFd$864, buff, 5);
                    task=ConnectClient_get_task(srRaClientsTable[(signed long int)k]);
                    if(!(task == ((struct anonymous$13 *)NULL)))
                    {
                      TaskScheduler_removeTask(scheduler, task);
                      ConnectClient_set_task(srRaClientsTable[(signed long int)k], (struct anonymous$13 *)(void *)0);
                    }

                    signed int return_value_ServerRealm_get_maxIdle$869;
                    return_value_ServerRealm_get_maxIdle$869=ServerRealm_get_maxIdle(pointer);
                    if(!(return_value_ServerRealm_get_maxIdle$869 == 0))
                    {
                      signed int return_value_ServerRealm_get_maxIdle$865;
                      return_value_ServerRealm_get_maxIdle$865=ServerRealm_get_maxIdle(pointer);
                      struct timeval return_value_timeval_create$866;
                      return_value_timeval_create$866=timeval_create((signed long int)return_value_ServerRealm_get_maxIdle$865, (signed long int)0);
                      ConnectClient_set_timer(srClientsTable[(signed long int)l], return_value_timeval_create$866);
                      struct timeval *return_value_ConnectClient_get_timerp$867;
                      return_value_ConnectClient_get_timerp$867=ConnectClient_get_timerp(srClientsTable[(signed long int)l]);
                      struct anonymous$25 *return_value_RCTdata_new$868;
                      return_value_RCTdata_new$868=RCTdata_new(config, j, l, (char)0, (char)1, &allset, &wset);
                      task=Task_new(return_value_ConnectClient_get_timerp$867, RCTfunction, (void *)return_value_RCTdata_new$868, RCTdata_free);
                      ConnectClient_set_task(srClientsTable[(signed long int)l], task);
                      TaskScheduler_addTask(scheduler, task);
                    }

                    char return_value_ServerRealm_get_basePortOn$892;
                    return_value_ServerRealm_get_basePortOn$892=ServerRealm_get_basePortOn(pointer);
                    if((signed int)return_value_ServerRealm_get_basePortOn$892 == 1)
                    {
                      signed long int main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_val;
                      char main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_tab[6l];
                      signed int return_value_ConnectClient_get_usrCliPair$872;
                      return_value_ConnectClient_get_usrCliPair$872=ConnectClient_get_usrCliPair(srClientsTable[(signed long int)l]);
                      char *return_value_UsrCli_get_listenPortName$873;
                      return_value_UsrCli_get_listenPortName$873=UsrCli_get_listenPortName(srUsersClientsTable[(signed long int)return_value_ConnectClient_get_usrCliPair$872]);
                      signed int return_value_check_long$874;
                      return_value_check_long$874=check_long(return_value_UsrCli_get_listenPortName$873, &main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_val);
                      if(!(return_value_check_long$874 == 0))
                      {
                        char *return_value_get_realmname$870;
                        return_value_get_realmname$870=get_realmname(config, j);
                        char *return_value_get_clientname$871;
                        return_value_get_clientname$871=get_clientname(pointer, l);
                        aflog((char)2, (char)64, "realm[%s]: INVALID listenport - removing Client[%s]", return_value_get_realmname$870, return_value_get_clientname$871);
                        remove_client(pointer, l, &allset, &wset, scheduler);
                        break;
                      }

                      main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_val = main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_val % (signed long int)65536;
                      memset((void *)main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_tab, 0, (unsigned long int)6);
                      sprintf(main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_tab, "%d", (signed int)main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_val);
                      ipfam = (char)0x01;
                      char return_value_ServerRealm_get_realmType$876;
                      return_value_ServerRealm_get_realmType$876=ServerRealm_get_realmType(pointer);
                      if(!((16 & (signed int)return_value_ServerRealm_get_realmType$876) == 0))
                        ipfam = ipfam | (char)0x02;

                      else
                      {
                        return_value_ServerRealm_get_realmType$875=ServerRealm_get_realmType(pointer);
                        if(!((32 & (signed int)return_value_ServerRealm_get_realmType$875) == 0))
                          ipfam = ipfam | (char)0x04;

                      }
                      do
                      {
                        return_value_ConnectClient_get_listenFdp$877=ConnectClient_get_listenFdp(srClientsTable[(signed long int)l]);
                        return_value_ConnectClient_get_usrCliPair$878=ConnectClient_get_usrCliPair(srClientsTable[(signed long int)l]);
                        return_value_UsrCli_get_listenHostName$879=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)return_value_ConnectClient_get_usrCliPair$878]);
                        if(!(return_value_UsrCli_get_listenHostName$879 == ((char *)NULL)))
                        {
                          return_value_ConnectClient_get_usrCliPair$880=ConnectClient_get_usrCliPair(srClientsTable[(signed long int)l]);
                          return_value_UsrCli_get_listenHostName$881=UsrCli_get_listenHostName(srUsersClientsTable[(signed long int)return_value_ConnectClient_get_usrCliPair$880]);
                          tmp_if_expr$883 = return_value_UsrCli_get_listenHostName$881;
                        }

                        else
                        {
                          return_value_ServerRealm_get_hostName$882=ServerRealm_get_hostName(pointer);
                          tmp_if_expr$883 = return_value_ServerRealm_get_hostName$882;
                        }
                        return_value_ip_listen$884=ip_listen(return_value_ConnectClient_get_listenFdp$877, tmp_if_expr$883, main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_tab, &len, ipfam);
                        if(return_value_ip_listen$884 == 0)
                          break;

                        main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_val = (main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_val + (signed long int)1) % (signed long int)65536;
                        memset((void *)main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_tab, 0, (unsigned long int)6);
                        sprintf(main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_tab, "%d", (signed int)main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_val);
                      }
                      while((_Bool)1);
                      ServerRealm_set_addressLength(pointer, len);
                      signed int return_value_ConnectClient_get_listenFd$885;
                      return_value_ConnectClient_get_listenFd$885=ConnectClient_get_listenFd(srClientsTable[(signed long int)l]);
                      signed int return_value_ConnectClient_get_listenFd$886;
                      return_value_ConnectClient_get_listenFd$886=ConnectClient_get_listenFd(srClientsTable[(signed long int)l]);
                      (&allset)->__fds_bits[(signed long int)(return_value_ConnectClient_get_listenFd$885 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_ConnectClient_get_listenFd$885 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_ConnectClient_get_listenFd$886 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                      signed int return_value_ConnectClient_get_listenFd$887;
                      return_value_ConnectClient_get_listenFd$887=ConnectClient_get_listenFd(srClientsTable[(signed long int)l]);
                      if(!(1 + return_value_ConnectClient_get_listenFd$887 >= maxfdp1))
                        tmp_if_expr$889 = maxfdp1;

                      else
                      {
                        return_value_ConnectClient_get_listenFd$888=ConnectClient_get_listenFd(srClientsTable[(signed long int)l]);
                        tmp_if_expr$889 = return_value_ConnectClient_get_listenFd$888 + 1;
                      }
                      maxfdp1 = tmp_if_expr$889;
                      char *return_value_get_realmname$890;
                      return_value_get_realmname$890=get_realmname(config, j);
                      char *return_value_get_clientname$891;
                      return_value_get_clientname$891=get_clientname(pointer, l);
                      aflog((char)2, (char)8, "realm[%s]: Client[%s]: listenport=%s", return_value_get_realmname$890, return_value_get_clientname$891, (const void *)main$$1$$17$$3$$6$$7$$1$$1$$2$$3$$tmp_tab);
                    }

                  }

                  else
                  {
                    char *return_value_get_realmname$893;
                    return_value_get_realmname$893=get_realmname(config, j);
                    aflog((char)2, (char)32, "realm[%s]: client limit EXCEEDED", return_value_get_realmname$893);
                    buff[(signed long int)0] = (unsigned char)12;
                    char return_value_ServerRealm_get_realmType$894;
                    return_value_ServerRealm_get_realmType$894=ServerRealm_get_realmType(pointer);
                    struct anonymous$1 *return_value_ConnectClient_get_sslFd$895;
                    return_value_ConnectClient_get_sslFd$895=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                    SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType$894 | 4 | 8), return_value_ConnectClient_get_sslFd$895, buff, 5);
                    remove_raclient(pointer, k, &allset, &wset, scheduler);
                  }
                }

                else
                {
                  return_value_ConnectClient_get_state$903=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
                  if(numofcon == 0 && (signed int)return_value_ConnectClient_get_state$903 == 3)
                  {
                    char return_value_ServerRealm_get_realmType$897;
                    return_value_ServerRealm_get_realmType$897=ServerRealm_get_realmType(pointer);
                    struct anonymous$1 *return_value_ConnectClient_get_sslFd$898;
                    return_value_ConnectClient_get_sslFd$898=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                    n=SslFd_get_message(return_value_ServerRealm_get_realmType$897, return_value_ConnectClient_get_sslFd$898, buff, length);
                    buff[(signed long int)n] = (unsigned char)0;
                    char *return_value_get_realmname$899;
                    return_value_get_realmname$899=get_realmname(config, j);
                    char *return_value_get_raclientname$900;
                    return_value_get_raclientname$900=get_raclientname(pointer, k);
                    aflog((char)8, (char)8, "realm[%s]: Client[%s] (ra): ID received: %s", return_value_get_realmname$899, return_value_get_raclientname$900, (const void *)buff);
                    ConnectClient_set_sClientId(srRaClientsTable[(signed long int)k], (char *)buff);
                  }

                  else
                  {
                    char *return_value_get_realmname$901;
                    return_value_get_realmname$901=get_realmname(config, j);
                    char *return_value_get_raclientname$902;
                    return_value_get_raclientname$902=get_raclientname(pointer, k);
                    aflog((char)8, (char)64, "realm[%s]: Client[%s] (ra): Wrong password - CLOSING", return_value_get_realmname$901, return_value_get_raclientname$902);
                    remove_raclient(pointer, k, &allset, &wset, scheduler);
                  }
                }
                break;
              }
              case 13:
              {
                return_value_get_realmname$911=get_realmname(config, j);
                return_value_get_raclientname$912=get_raclientname(pointer, k);
                aflog((char)8, (char)64, "realm[%s]: Client[%s] (ra): Wrong message - CLOSING", return_value_get_realmname$911, return_value_get_raclientname$912);
                remove_raclient(pointer, k, &allset, &wset, scheduler);
                break;
              }
              case 14:
              {
                return_value_ConnectClient_get_state$923=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
                if((signed int)return_value_ConnectClient_get_state$923 == 2)
                {
                  return_value_ServerRealm_get_password$921=ServerRealm_get_password(pointer);
                  return_value_ServerRealm_get_password$922=ServerRealm_get_password(pointer);
                  if(numofcon == 256 * (signed int)*return_value_ServerRealm_get_password$921 + (signed int)return_value_ServerRealm_get_password$922[1l])
                  {
                    return_value_ServerRealm_get_password$919=ServerRealm_get_password(pointer);
                    return_value_ServerRealm_get_password$920=ServerRealm_get_password(pointer);
                    if(length == 256 * (signed int)return_value_ServerRealm_get_password$919[2l] + (signed int)return_value_ServerRealm_get_password$920[3l])
                    {
                      char *return_value_get_realmname$913;
                      return_value_get_realmname$913=get_realmname(config, j);
                      char *return_value_get_raclientname$914;
                      return_value_get_raclientname$914=get_raclientname(pointer, k);
                      aflog((char)8, (char)8, "realm[%s]: Client[%s] (ra): NEW remote admin -- pass OK", return_value_get_realmname$913, return_value_get_raclientname$914);
                      ConnectClient_set_state(srRaClientsTable[(signed long int)k], (char)3);
                      ServerRealm_increase_connectedRaClients(pointer);
                      task=ConnectClient_get_task(srRaClientsTable[(signed long int)k]);
                      if(!(task == ((struct anonymous$13 *)NULL)))
                      {
                        TaskScheduler_removeTask(scheduler, task);
                        ConnectClient_set_task(srRaClientsTable[(signed long int)k], (struct anonymous$13 *)(void *)0);
                      }

                      sprintf((char *)&buff[(signed long int)5], "AFSERVER v0.8.4");
                      unsigned long int return_value_strlen$915;
                      return_value_strlen$915=strlen((char *)&buff[(signed long int)5]);
                      n = (signed int)return_value_strlen$915;
                      buff[(signed long int)0] = (unsigned char)14;
                      char return_value_ServerRealm_get_realmType$916;
                      return_value_ServerRealm_get_realmType$916=ServerRealm_get_realmType(pointer);
                      buff[(signed long int)1] = (unsigned char)return_value_ServerRealm_get_realmType$916;
                      buff[(signed long int)2] = (unsigned char)0;
                      buff[(signed long int)3] = (unsigned char)(n >> 8);
                      buff[(signed long int)4] = (unsigned char)n;
                      char return_value_ServerRealm_get_realmType$917;
                      return_value_ServerRealm_get_realmType$917=ServerRealm_get_realmType(pointer);
                      struct anonymous$1 *return_value_ConnectClient_get_sslFd$918;
                      return_value_ConnectClient_get_sslFd$918=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                      SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType$917 | 4 | 8), return_value_ConnectClient_get_sslFd$918, buff, n + 5);
                    }

                  }

                }

                break;
              }
              case 15:
              {
                return_value_ConnectClient_get_state$962=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
                if((signed int)return_value_ConnectClient_get_state$962 == 3)
                {
                  n=serve_admin(config, j, k, buff);
                  if(!(n == 0))
                  {
                    if(n == 1)
                    {
                      char *return_value_get_realmname$924;
                      return_value_get_realmname$924=get_realmname(config, j);
                      char *return_value_get_raclientname$925;
                      return_value_get_raclientname$925=get_raclientname(pointer, k);
                      aflog((char)8, (char)16, "realm[%s]: Client[%s] (ra): remote admin -- closing", return_value_get_realmname$924, return_value_get_raclientname$925);
                      remove_raclient(pointer, k, &allset, &wset, scheduler);
                    }

                    else
                    {
                      i = 0;
                      do
                      {
                        return_value_ServerConfiguration_get_realmsNumber$926=ServerConfiguration_get_realmsNumber(config);
                        if(i >= return_value_ServerConfiguration_get_realmsNumber$926)
                          break;

                        srClientsTable=ServerRealm_get_clientsTable(scRealmsTable[(signed long int)i]);
                        l=get_clientnumber(scRealmsTable[(signed long int)i], n - 2);
                        if(!(l == -1))
                        {
                          char *return_value_get_realmname$927;
                          return_value_get_realmname$927=get_realmname(config, j);
                          char *return_value_get_raclientname$928;
                          return_value_get_raclientname$928=get_raclientname(pointer, k);
                          char *return_value_get_realmname$929;
                          return_value_get_realmname$929=get_realmname(config, i);
                          char *return_value_get_clientname$930;
                          return_value_get_clientname$930=get_clientname(scRealmsTable[(signed long int)i], l);
                          aflog((char)8, (char)16, "realm[%s]: Client[%s] (ra): remote admin: KICKING realm[%s]: Client[%s]", return_value_get_realmname$927, return_value_get_raclientname$928, return_value_get_realmname$929, return_value_get_clientname$930);
                          buff[(signed long int)0] = (unsigned char)4;
                          char return_value_ServerRealm_get_realmType$931;
                          return_value_ServerRealm_get_realmType$931=ServerRealm_get_realmType(scRealmsTable[(signed long int)i]);
                          struct anonymous$1 *return_value_ConnectClient_get_sslFd$932;
                          return_value_ConnectClient_get_sslFd$932=ConnectClient_get_sslFd(srClientsTable[(signed long int)l]);
                          SslFd_send_message(return_value_ServerRealm_get_realmType$931, return_value_ConnectClient_get_sslFd$932, buff, 5);
                          time(&now);
                          char *return_value_get_realmname$933;
                          return_value_get_realmname$933=get_realmname(config, j);
                          char *return_value_get_clientname$934;
                          return_value_get_clientname$934=get_clientname(scRealmsTable[(signed long int)i], l);
                          char *return_value_ConnectClient_get_nameBuf$935;
                          return_value_ConnectClient_get_nameBuf$935=ConnectClient_get_nameBuf(srClientsTable[(signed long int)l]);
                          char *return_value_ConnectClient_get_portBuf$936;
                          return_value_ConnectClient_get_portBuf$936=ConnectClient_get_portBuf(srClientsTable[(signed long int)l]);
                          signed long int return_value_ConnectClient_get_connectTime$937;
                          return_value_ConnectClient_get_connectTime$937=ConnectClient_get_connectTime(srClientsTable[(signed long int)l]);
                          char *return_value_timeperiod$938;
                          return_value_timeperiod$938=timeperiod(now - return_value_ConnectClient_get_connectTime$937);
                          aflog((char)2, (char)16, "REALM: %s CLIENT: %s IP: %s PORT: %s DURATION: %s", return_value_get_realmname$933, return_value_get_clientname$934, return_value_ConnectClient_get_nameBuf$935, return_value_ConnectClient_get_portBuf$936, return_value_timeperiod$938);
                          char return_value_ServerRealm_get_auditOn$959;
                          return_value_ServerRealm_get_auditOn$959=ServerRealm_get_auditOn(scRealmsTable[(signed long int)i]);
                          if(!(return_value_ServerRealm_get_auditOn$959 == 0))
                            do
                            {
                              return_value_ConnectClient_get_auditList$939=ConnectClient_get_auditList(srClientsTable[(signed long int)l]);
                              return_value_AuditList_get_first$940=AuditList_get_first(return_value_ConnectClient_get_auditList$939);
                              if(return_value_AuditList_get_first$940 == ((struct alnode *)NULL))
                                break;

                              struct auditlist *return_value_ConnectClient_get_auditList$941;
                              return_value_ConnectClient_get_auditList$941=ConnectClient_get_auditList(srClientsTable[(signed long int)l]);
                              struct alnode *return_value_AuditList_get_first$942;
                              return_value_AuditList_get_first$942=AuditList_get_first(return_value_ConnectClient_get_auditList$941);
                              signed int return_value_AuditListNode_get_userId$943;
                              return_value_AuditListNode_get_userId$943=AuditListNode_get_userId(return_value_AuditList_get_first$942);
                              struct auditlist *return_value_ConnectClient_get_auditList$944;
                              return_value_ConnectClient_get_auditList$944=ConnectClient_get_auditList(srClientsTable[(signed long int)l]);
                              struct alnode *return_value_AuditList_get_first$945;
                              return_value_AuditList_get_first$945=AuditList_get_first(return_value_ConnectClient_get_auditList$944);
                              char *return_value_AuditListNode_get_nameBuf$946;
                              return_value_AuditListNode_get_nameBuf$946=AuditListNode_get_nameBuf(return_value_AuditList_get_first$945);
                              struct auditlist *return_value_ConnectClient_get_auditList$947;
                              return_value_ConnectClient_get_auditList$947=ConnectClient_get_auditList(srClientsTable[(signed long int)l]);
                              struct alnode *return_value_AuditList_get_first$948;
                              return_value_AuditList_get_first$948=AuditList_get_first(return_value_ConnectClient_get_auditList$947);
                              char *return_value_AuditListNode_get_portBuf$949;
                              return_value_AuditListNode_get_portBuf$949=AuditListNode_get_portBuf(return_value_AuditList_get_first$948);
                              struct auditlist *return_value_ConnectClient_get_auditList$950;
                              return_value_ConnectClient_get_auditList$950=ConnectClient_get_auditList(srClientsTable[(signed long int)l]);
                              struct alnode *return_value_AuditList_get_first$951;
                              return_value_AuditList_get_first$951=AuditList_get_first(return_value_ConnectClient_get_auditList$950);
                              signed long int *return_value_AuditListNode_get_connectTimep$952;
                              return_value_AuditListNode_get_connectTimep$952=AuditListNode_get_connectTimep(return_value_AuditList_get_first$951);
                              char *return_value_localdate$953;
                              return_value_localdate$953=localdate(return_value_AuditListNode_get_connectTimep$952);
                              struct auditlist *return_value_ConnectClient_get_auditList$954;
                              return_value_ConnectClient_get_auditList$954=ConnectClient_get_auditList(srClientsTable[(signed long int)l]);
                              struct alnode *return_value_AuditList_get_first$955;
                              return_value_AuditList_get_first$955=AuditList_get_first(return_value_ConnectClient_get_auditList$954);
                              signed long int return_value_AuditListNode_get_duration$956;
                              return_value_AuditListNode_get_duration$956=AuditListNode_get_duration(return_value_AuditList_get_first$955);
                              char *return_value_timeperiod$957;
                              return_value_timeperiod$957=timeperiod(return_value_AuditListNode_get_duration$956);
                              aflog((char)2, (char)16, "USERID: %d IP: %s PORT: %s CONNECTED: %s DURATION: %s", return_value_AuditListNode_get_userId$943, return_value_AuditListNode_get_nameBuf$946, return_value_AuditListNode_get_portBuf$949, return_value_localdate$953, return_value_timeperiod$957);
                              struct auditlist *return_value_ConnectClient_get_auditList$958;
                              return_value_ConnectClient_get_auditList$958=ConnectClient_get_auditList(srClientsTable[(signed long int)l]);
                              AuditList_delete_first(return_value_ConnectClient_get_auditList$958);
                            }
                            while((_Bool)1);

                          remove_client(scRealmsTable[(signed long int)i], l, &allset, &wset, scheduler);
                          break;
                        }

                        i = i + 1;
                      }
                      while((_Bool)1);
                    }
                  }

                }

                else
                {
                  char *return_value_get_realmname$960;
                  return_value_get_realmname$960=get_realmname(config, j);
                  char *return_value_get_raclientname$961;
                  return_value_get_raclientname$961=get_raclientname(pointer, k);
                  aflog((char)8, (char)64, "realm[%s]: Client[%s] (ra): remote admin -- security VIOLATION", return_value_get_realmname$960, return_value_get_raclientname$961);
                  remove_raclient(pointer, k, &allset, &wset, scheduler);
                }
                break;
              }
              case 16:
              {
                return_value_get_realmname$963=get_realmname(config, j);
                return_value_get_raclientname$964=get_raclientname(pointer, k);
                aflog((char)8, (char)2, "realm[%s]: Client[%s] (ra): Keep alive packet", return_value_get_realmname$963, return_value_get_raclientname$964);
                break;
              }
              default:
              {
                char *return_value_get_realmname$965;
                return_value_get_realmname$965=get_realmname(config, j);
                char *return_value_get_raclientname$966;
                return_value_get_raclientname$966=get_raclientname(pointer, k);
                aflog((char)8, (char)64, "realm[%s]: Client[%s] (ra): Unrecognized message - CLOSING", return_value_get_realmname$965, return_value_get_raclientname$966);
                remove_raclient(pointer, k, &allset, &wset, scheduler);
              }
            }
          }

        }


      __CPROVER_DUMP_L448:
        ;
        k = k + 1;
      }
      while((_Bool)1);
      l = 0;
      do
      {
        return_value_ServerRealm_get_userClientPairs$972=ServerRealm_get_userClientPairs(pointer);
        if(l >= return_value_ServerRealm_get_userClientPairs$972)
          break;

        signed int return_value_UsrCli_get_manageFd$1036;
        return_value_UsrCli_get_manageFd$1036=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)l]);
        signed int return_value_UsrCli_get_manageFd$1037;
        return_value_UsrCli_get_manageFd$1037=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)l]);
        if(!((rset.__fds_bits[(signed long int)(return_value_UsrCli_get_manageFd$1036 / 8)] & 1l << return_value_UsrCli_get_manageFd$1037 % 8) == 0l))
        {
          char *return_value_get_realmname$973;
          return_value_get_realmname$973=get_realmname(config, j);
          aflog((char)2, (char)4, "realm[%s]: managefd: FD_ISSET", return_value_get_realmname$973);
          len=ServerRealm_get_addressLength(pointer);
          signed int return_value_UsrCli_get_manageFd$974;
          return_value_UsrCli_get_manageFd$974=UsrCli_get_manageFd(srUsersClientsTable[(signed long int)l]);
          char return_value_ServerRealm_get_tunnelType$975;
          return_value_ServerRealm_get_tunnelType$975=ServerRealm_get_tunnelType(pointer);
          struct sockaddr *return_value_ServerRealm_get_clientAddress$976;
          return_value_ServerRealm_get_clientAddress$976=ServerRealm_get_clientAddress(pointer);
          sent=get_new_socket(return_value_UsrCli_get_manageFd$974, return_value_ServerRealm_get_tunnelType$975, return_value_ServerRealm_get_clientAddress$976, &len, &tunneltype);
          if(sent == -1)
          {
            signed int *return_value___errno_location$980;
            return_value___errno_location$980=__errno_location();
            if(*return_value___errno_location$980 == 11)
            {
              char *return_value_get_realmname$977;
              return_value_get_realmname$977=get_realmname(config, j);
              aflog((char)1, (char)4, "realm[%s]: managefd: FD_ISSET --> EAGAIN", return_value_get_realmname$977);
            }

            else
            {
              char *return_value_get_realmname$978;
              return_value_get_realmname$978=get_realmname(config, j);
              signed int *return_value___errno_location$979;
              return_value___errno_location$979=__errno_location();
              aflog((char)1, (char)4, "realm[%s]: managefd: FD_ISSET --> errno=%d", return_value_get_realmname$978, *return_value___errno_location$979);
            }
            break;
          }

          flags=fcntl(sent, 3, 0);
          fcntl(sent, 4, flags | 04000);
          k = 0;
          do
          {
            return_value_ServerRealm_get_clientsLimit$981=ServerRealm_get_clientsLimit(pointer);
            if(k >= return_value_ServerRealm_get_clientsLimit$981)
              break;

            char return_value_ConnectClient_get_state$1006;
            return_value_ConnectClient_get_state$1006=ConnectClient_get_state(srClientsTable[(signed long int)k]);
            if((signed int)return_value_ConnectClient_get_state$1006 == 0)
            {
              signed int return_value_ServerRealm_get_clientsCounter$982;
              return_value_ServerRealm_get_clientsCounter$982=ServerRealm_get_clientsCounter(pointer);
              ConnectClient_set_clientId(srClientsTable[(signed long int)k], return_value_ServerRealm_get_clientsCounter$982);
              ServerRealm_increase_clientsCounter(pointer);
              char *return_value_get_realmname$983;
              return_value_get_realmname$983=get_realmname(config, j);
              char *return_value_get_clientname$984;
              return_value_get_clientname$984=get_clientname(pointer, k);
              aflog((char)2, (char)8, "realm[%s]: new Client[%s]: CONNECTING", return_value_get_realmname$983, return_value_get_clientname$984);
              struct anonymous$1 *return_value_ConnectClient_get_sslFd$985;
              return_value_ConnectClient_get_sslFd$985=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              SslFd_set_fd(return_value_ConnectClient_get_sslFd$985, sent);
              ConnectClient_set_usrCliPair(srClientsTable[(signed long int)k], l);
              time(&now);
              ConnectClient_set_connectTime(srClientsTable[(signed long int)k], now);
              ConnectClient_set_lastActivity(srClientsTable[(signed long int)k], now);
              ConnectClient_set_tunnelType(srClientsTable[(signed long int)k], tunneltype);
              char *return_value_get_realmname$986;
              return_value_get_realmname$986=get_realmname(config, j);
              char *return_value_get_clientname$987;
              return_value_get_clientname$987=get_clientname(pointer, k);
              struct sockaddr *return_value_ServerRealm_get_clientAddress$988;
              return_value_ServerRealm_get_clientAddress$988=ServerRealm_get_clientAddress(pointer);
              char *return_value_ConnectClient_get_nameBuf$989;
              return_value_ConnectClient_get_nameBuf$989=ConnectClient_get_nameBuf(srClientsTable[(signed long int)k]);
              char *return_value_ConnectClient_get_portBuf$990;
              return_value_ConnectClient_get_portBuf$990=ConnectClient_get_portBuf(srClientsTable[(signed long int)k]);
              char return_value_ServerRealm_get_dnsLookupsOn$991;
              return_value_ServerRealm_get_dnsLookupsOn$991=ServerRealm_get_dnsLookupsOn(pointer);
              char *return_value_sock_ntop$992;
              return_value_sock_ntop$992=sock_ntop(return_value_ServerRealm_get_clientAddress$988, len, return_value_ConnectClient_get_nameBuf$989, return_value_ConnectClient_get_portBuf$990, return_value_ServerRealm_get_dnsLookupsOn$991);
              aflog((char)2, (char)8, "realm[%s]: new Client[%s] IP:%s", return_value_get_realmname$986, return_value_get_clientname$987, return_value_sock_ntop$992);
              struct anonymous$1 *return_value_ConnectClient_get_sslFd$993;
              return_value_ConnectClient_get_sslFd$993=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              signed int return_value_SslFd_get_fd$994;
              return_value_SslFd_get_fd$994=SslFd_get_fd(return_value_ConnectClient_get_sslFd$993);
              struct anonymous$1 *return_value_ConnectClient_get_sslFd$995;
              return_value_ConnectClient_get_sslFd$995=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              signed int return_value_SslFd_get_fd$996;
              return_value_SslFd_get_fd$996=SslFd_get_fd(return_value_ConnectClient_get_sslFd$995);
              (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd$994 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd$994 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_SslFd_get_fd$996 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
              struct anonymous$1 *return_value_ConnectClient_get_sslFd$997;
              return_value_ConnectClient_get_sslFd$997=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
              signed int return_value_SslFd_get_fd$998;
              return_value_SslFd_get_fd$998=SslFd_get_fd(return_value_ConnectClient_get_sslFd$997);
              if(!(1 + return_value_SslFd_get_fd$998 >= maxfdp1))
                tmp_if_expr$1001 = maxfdp1;

              else
              {
                return_value_ConnectClient_get_sslFd$999=ConnectClient_get_sslFd(srClientsTable[(signed long int)k]);
                return_value_SslFd_get_fd$1000=SslFd_get_fd(return_value_ConnectClient_get_sslFd$999);
                tmp_if_expr$1001 = return_value_SslFd_get_fd$1000 + 1;
              }
              maxfdp1 = tmp_if_expr$1001;
              ServerRealm_increase_connectedClients(pointer);
              signed int return_value_ServerRealm_get_timeout$1002;
              return_value_ServerRealm_get_timeout$1002=ServerRealm_get_timeout(pointer);
              struct timeval return_value_timeval_create$1003;
              return_value_timeval_create$1003=timeval_create((signed long int)return_value_ServerRealm_get_timeout$1002, (signed long int)0);
              ConnectClient_set_timer(srClientsTable[(signed long int)k], return_value_timeval_create$1003);
              struct timeval *return_value_ConnectClient_get_timerp$1004;
              return_value_ConnectClient_get_timerp$1004=ConnectClient_get_timerp(srClientsTable[(signed long int)k]);
              struct anonymous$25 *return_value_RCTdata_new$1005;
              return_value_RCTdata_new$1005=RCTdata_new(config, j, k, (char)0, (char)0, &allset, &wset);
              task=Task_new(return_value_ConnectClient_get_timerp$1004, RCTfunction, (void *)return_value_RCTdata_new$1005, RCTdata_free);
              ConnectClient_set_task(srClientsTable[(signed long int)k], task);
              TaskScheduler_addTask(scheduler, task);
              ConnectClient_set_state(srClientsTable[(signed long int)k], (char)1);
              break;
            }

            k = k + 1;
          }
          while((_Bool)1);
          signed int return_value_ServerRealm_get_clientsLimit$1035;
          return_value_ServerRealm_get_clientsLimit$1035=ServerRealm_get_clientsLimit(pointer);
          if(k == return_value_ServerRealm_get_clientsLimit$1035)
          {
            k = 0;
            do
            {
              return_value_ServerRealm_get_raClientsLimit$1007=ServerRealm_get_raClientsLimit(pointer);
              if(k >= return_value_ServerRealm_get_raClientsLimit$1007)
                break;

              char return_value_ConnectClient_get_state$1032;
              return_value_ConnectClient_get_state$1032=ConnectClient_get_state(srRaClientsTable[(signed long int)k]);
              if((signed int)return_value_ConnectClient_get_state$1032 == 0)
              {
                signed int return_value_ServerRealm_get_clientsCounter$1008;
                return_value_ServerRealm_get_clientsCounter$1008=ServerRealm_get_clientsCounter(pointer);
                ConnectClient_set_clientId(srRaClientsTable[(signed long int)k], return_value_ServerRealm_get_clientsCounter$1008);
                ServerRealm_increase_clientsCounter(pointer);
                char *return_value_get_realmname$1009;
                return_value_get_realmname$1009=get_realmname(config, j);
                char *return_value_get_raclientname$1010;
                return_value_get_raclientname$1010=get_raclientname(pointer, k);
                aflog((char)8, (char)8, "realm[%s]: new Client[%s] (ra): CONNECTING", return_value_get_realmname$1009, return_value_get_raclientname$1010);
                struct anonymous$1 *return_value_ConnectClient_get_sslFd$1011;
                return_value_ConnectClient_get_sslFd$1011=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                SslFd_set_fd(return_value_ConnectClient_get_sslFd$1011, sent);
                ConnectClient_set_usrCliPair(srRaClientsTable[(signed long int)k], l);
                time(&now);
                ConnectClient_set_connectTime(srRaClientsTable[(signed long int)k], now);
                ConnectClient_set_lastActivity(srRaClientsTable[(signed long int)k], now);
                ConnectClient_set_tunnelType(srRaClientsTable[(signed long int)k], tunneltype);
                char *return_value_get_realmname$1012;
                return_value_get_realmname$1012=get_realmname(config, j);
                char *return_value_get_raclientname$1013;
                return_value_get_raclientname$1013=get_raclientname(pointer, k);
                struct sockaddr *return_value_ServerRealm_get_clientAddress$1014;
                return_value_ServerRealm_get_clientAddress$1014=ServerRealm_get_clientAddress(pointer);
                char *return_value_ConnectClient_get_nameBuf$1015;
                return_value_ConnectClient_get_nameBuf$1015=ConnectClient_get_nameBuf(srRaClientsTable[(signed long int)k]);
                char *return_value_ConnectClient_get_portBuf$1016;
                return_value_ConnectClient_get_portBuf$1016=ConnectClient_get_portBuf(srRaClientsTable[(signed long int)k]);
                char return_value_ServerRealm_get_dnsLookupsOn$1017;
                return_value_ServerRealm_get_dnsLookupsOn$1017=ServerRealm_get_dnsLookupsOn(pointer);
                char *return_value_sock_ntop$1018;
                return_value_sock_ntop$1018=sock_ntop(return_value_ServerRealm_get_clientAddress$1014, len, return_value_ConnectClient_get_nameBuf$1015, return_value_ConnectClient_get_portBuf$1016, return_value_ServerRealm_get_dnsLookupsOn$1017);
                aflog((char)8, (char)8, "realm[%s]: new Client[%s] (ra) IP:%s", return_value_get_realmname$1012, return_value_get_raclientname$1013, return_value_sock_ntop$1018);
                struct anonymous$1 *return_value_ConnectClient_get_sslFd$1019;
                return_value_ConnectClient_get_sslFd$1019=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                signed int return_value_SslFd_get_fd$1020;
                return_value_SslFd_get_fd$1020=SslFd_get_fd(return_value_ConnectClient_get_sslFd$1019);
                struct anonymous$1 *return_value_ConnectClient_get_sslFd$1021;
                return_value_ConnectClient_get_sslFd$1021=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                signed int return_value_SslFd_get_fd$1022;
                return_value_SslFd_get_fd$1022=SslFd_get_fd(return_value_ConnectClient_get_sslFd$1021);
                (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd$1020 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&allset)->__fds_bits[(signed long int)(return_value_SslFd_get_fd$1020 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << return_value_SslFd_get_fd$1022 % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
                struct anonymous$1 *return_value_ConnectClient_get_sslFd$1023;
                return_value_ConnectClient_get_sslFd$1023=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                signed int return_value_SslFd_get_fd$1024;
                return_value_SslFd_get_fd$1024=SslFd_get_fd(return_value_ConnectClient_get_sslFd$1023);
                if(!(1 + return_value_SslFd_get_fd$1024 >= maxfdp1))
                  tmp_if_expr$1027 = maxfdp1;

                else
                {
                  return_value_ConnectClient_get_sslFd$1025=ConnectClient_get_sslFd(srRaClientsTable[(signed long int)k]);
                  return_value_SslFd_get_fd$1026=SslFd_get_fd(return_value_ConnectClient_get_sslFd$1025);
                  tmp_if_expr$1027 = return_value_SslFd_get_fd$1026 + 1;
                }
                maxfdp1 = tmp_if_expr$1027;
                ServerRealm_increase_connectedClients(pointer);
                signed int return_value_ServerRealm_get_timeout$1028;
                return_value_ServerRealm_get_timeout$1028=ServerRealm_get_timeout(pointer);
                struct timeval return_value_timeval_create$1029;
                return_value_timeval_create$1029=timeval_create((signed long int)return_value_ServerRealm_get_timeout$1028, (signed long int)0);
                ConnectClient_set_timer(srRaClientsTable[(signed long int)k], return_value_timeval_create$1029);
                struct timeval *return_value_ConnectClient_get_timerp$1030;
                return_value_ConnectClient_get_timerp$1030=ConnectClient_get_timerp(srRaClientsTable[(signed long int)k]);
                struct anonymous$25 *return_value_RCTdata_new$1031;
                return_value_RCTdata_new$1031=RCTdata_new(config, j, k, (char)1, (char)0, &allset, &wset);
                task=Task_new(return_value_ConnectClient_get_timerp$1030, RCTfunction, (void *)return_value_RCTdata_new$1031, RCTdata_free);
                ConnectClient_set_task(srRaClientsTable[(signed long int)k], task);
                TaskScheduler_addTask(scheduler, task);
                ConnectClient_set_state(srRaClientsTable[(signed long int)k], (char)1);
                break;
              }

              k = k + 1;
            }
            while((_Bool)1);
            signed int return_value_ServerRealm_get_raClientsLimit$1034;
            return_value_ServerRealm_get_raClientsLimit$1034=ServerRealm_get_raClientsLimit(pointer);
            if(k == return_value_ServerRealm_get_raClientsLimit$1034)
            {
              char *return_value_get_realmname$1033;
              return_value_get_realmname$1033=get_realmname(config, j);
              aflog((char)(2 | 8), (char)32, "realm[%s]: client limit EXCEEDED", return_value_get_realmname$1033);
              close(sent);
            }

          }

          break;
        }

        l = l + 1;
      }
      while((_Bool)1);
      j = j + 1;
    }
    while((_Bool)1);
  }
  while((_Bool)1);
}

// make_ssl_accept
// file make_ssl_handshake.h line 28
signed int make_ssl_accept(struct anonymous$1 *sf)
{
  signed int result;
  struct ssl_st *return_value_SslFd_get_ssl$2;
  return_value_SslFd_get_ssl$2=SslFd_get_ssl(sf);
  result=SSL_accept(return_value_SslFd_get_ssl$2);
  if(!(result == 1))
  {
    signed int return_value_get_ssl_error$1;
    return_value_get_ssl_error$1=get_ssl_error(sf, "SSL_accept has failed", result);
    return return_value_get_ssl_error$1;
  }

  return 0;
}

// make_ssl_initialize
// file make_ssl_handshake.h line 27
void make_ssl_initialize(struct anonymous$1 *sf)
{
  struct ssl_st *return_value_SslFd_get_ssl$1;
  return_value_SslFd_get_ssl$1=SslFd_get_ssl(sf);
  signed int return_value_SslFd_get_fd$2;
  return_value_SslFd_get_fd$2=SslFd_get_fd(sf);
  signed int return_value_SSL_set_fd$3;
  return_value_SSL_set_fd$3=SSL_set_fd(return_value_SslFd_get_ssl$1, return_value_SslFd_get_fd$2);
  if(!(return_value_SSL_set_fd$3 == 1))
  {
    aflog((char)4, (char)1, "Problem with initializing ssl... exiting");
    exit(1);
  }

}

// myrand
// file http_proxy_functions.c line 42
signed int myrand(signed int down, signed int up)
{
  struct timeval tv;
  if(isseed == 0)
  {
    gettimeofday(&tv, ((struct timezone *)NULL));
    srand((unsigned int)tv.tv_sec);
    isseed = (char)1;
  }

  signed int return_value_rand$1;
  return_value_rand$1=rand();
  return down + return_value_rand$1 % ((up - down) + 1);
}

// mysleep
// file http_proxy_functions.c line 60
void mysleep(double time)
{
  struct timeval tv;
  tv.tv_sec = (signed long int)(signed int)time;
  tv.tv_usec = (signed long int)((signed int)(time * (double)1000000) % 1000000);
  select(0, (struct anonymous$22 *)(void *)0, (struct anonymous$22 *)(void *)0, (struct anonymous$22 *)(void *)0, &tv);
}

// parse_cmd
// file server_remoteadmin.c line 89
static signed int parse_cmd(unsigned char *buff, signed int *ret)
{
  signed int i;
  signed int j;
  signed int state;
  char cmd[31l];
  state = 0;
  j = state;
  i = j;
  newmessage = (char)1;
  for( ; !((signed int)buff[(signed long int)i] == 0); i = i + 1)
  {
    if(state == 1)
    {
      const unsigned short int **return_value___ctype_b_loc$1;
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)buff[(signed long int)i]]) == 0))
        break;

      else
      {
        if(j == 30)
          return 0;

        cmd[(signed long int)j] = (char)buff[(signed long int)i];
        j = j + 1;
      }
    }

    if(state == 0)
    {
      const unsigned short int **return_value___ctype_b_loc$2;
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
      {
        cmd[(signed long int)j] = (char)buff[(signed long int)i];
        j = 1;
        state = 1;
      }

    }

  }
  const unsigned short int **return_value___ctype_b_loc$3;
  signed int tmp_statement_expression$4;
  signed int tmp_statement_expression$6;
  signed int tmp_statement_expression$8;
  signed int tmp_statement_expression$10;
  signed int tmp_statement_expression$12;
  signed int tmp_statement_expression$14;
  signed int tmp_statement_expression$16;
  signed int tmp_statement_expression$18;
  signed int tmp_statement_expression$20;
  signed int tmp_statement_expression$22;
  signed int tmp_statement_expression$24;
  signed int tmp_statement_expression$26;
  signed int tmp_statement_expression$28;
  if(state == 0)
    return 0;

  else
  {
    do
    {
      return_value___ctype_b_loc$3=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    if((signed int)buff[(signed long int)i] == 46)
      i = i + 1;

    *ret = i;
    cmd[(signed long int)j] = (char)0;
    unsigned long int parse_cmd$$1$$5$$__s1_len;
    unsigned long int parse_cmd$$1$$5$$__s2_len;
    signed int return_value___builtin_strcmp$5;
    return_value___builtin_strcmp$5=__builtin_strcmp(cmd, "help");
    tmp_statement_expression$4 = return_value___builtin_strcmp$5;
    if(tmp_statement_expression$4 == 0)
      return 1;

    else
    {
      unsigned long int parse_cmd$$1$$7$$__s1_len;
      unsigned long int parse_cmd$$1$$7$$__s2_len;
      signed int return_value___builtin_strcmp$7;
      return_value___builtin_strcmp$7=__builtin_strcmp(cmd, "lcmd");
      tmp_statement_expression$6 = return_value___builtin_strcmp$7;
      if(tmp_statement_expression$6 == 0)
        return 2;

      else
      {
        unsigned long int parse_cmd$$1$$9$$__s1_len;
        unsigned long int parse_cmd$$1$$9$$__s2_len;
        signed int return_value___builtin_strcmp$9;
        return_value___builtin_strcmp$9=__builtin_strcmp(cmd, "info");
        tmp_statement_expression$8 = return_value___builtin_strcmp$9;
        if(tmp_statement_expression$8 == 0)
          return 3;

        else
        {
          unsigned long int parse_cmd$$1$$11$$__s1_len;
          unsigned long int parse_cmd$$1$$11$$__s2_len;
          signed int return_value___builtin_strcmp$11;
          return_value___builtin_strcmp$11=__builtin_strcmp(cmd, "rshow");
          tmp_statement_expression$10 = return_value___builtin_strcmp$11;
          if(tmp_statement_expression$10 == 0)
            return 4;

          else
          {
            unsigned long int parse_cmd$$1$$13$$__s1_len;
            unsigned long int parse_cmd$$1$$13$$__s2_len;
            signed int return_value___builtin_strcmp$13;
            return_value___builtin_strcmp$13=__builtin_strcmp(cmd, "cshow");
            tmp_statement_expression$12 = return_value___builtin_strcmp$13;
            if(tmp_statement_expression$12 == 0)
              return 5;

            else
            {
              unsigned long int __s1_len;
              unsigned long int __s2_len;
              signed int return_value___builtin_strcmp$15;
              return_value___builtin_strcmp$15=__builtin_strcmp(cmd, "ushow");
              tmp_statement_expression$14 = return_value___builtin_strcmp$15;
              if(tmp_statement_expression$14 == 0)
                return 6;

              else
              {
                unsigned long int parse_cmd$$1$$17$$__s1_len;
                unsigned long int parse_cmd$$1$$17$$__s2_len;
                signed int return_value___builtin_strcmp$17;
                return_value___builtin_strcmp$17=__builtin_strcmp(cmd, "quit");
                tmp_statement_expression$16 = return_value___builtin_strcmp$17;
                if(tmp_statement_expression$16 == 0)
                  return 7;

                else
                {
                  unsigned long int parse_cmd$$1$$19$$__s1_len;
                  unsigned long int parse_cmd$$1$$19$$__s2_len;
                  signed int return_value___builtin_strcmp$19;
                  return_value___builtin_strcmp$19=__builtin_strcmp(cmd, "timeout");
                  tmp_statement_expression$18 = return_value___builtin_strcmp$19;
                  if(tmp_statement_expression$18 == 0)
                    return 8;

                  else
                  {
                    unsigned long int parse_cmd$$1$$21$$__s1_len;
                    unsigned long int parse_cmd$$1$$21$$__s2_len;
                    signed int return_value___builtin_strcmp$21;
                    return_value___builtin_strcmp$21=__builtin_strcmp(cmd, "audit");
                    tmp_statement_expression$20 = return_value___builtin_strcmp$21;
                    if(tmp_statement_expression$20 == 0)
                      return 9;

                    else
                    {
                      unsigned long int parse_cmd$$1$$23$$__s1_len;
                      unsigned long int parse_cmd$$1$$23$$__s2_len;
                      signed int return_value___builtin_strcmp$23;
                      return_value___builtin_strcmp$23=__builtin_strcmp(cmd, "dnslookups");
                      tmp_statement_expression$22 = return_value___builtin_strcmp$23;
                      if(tmp_statement_expression$22 == 0)
                        return 10;

                      else
                      {
                        unsigned long int parse_cmd$$1$$25$$__s1_len;
                        unsigned long int parse_cmd$$1$$25$$__s2_len;
                        signed int return_value___builtin_strcmp$25;
                        return_value___builtin_strcmp$25=__builtin_strcmp(cmd, "dateformat");
                        tmp_statement_expression$24 = return_value___builtin_strcmp$25;
                        if(tmp_statement_expression$24 == 0)
                          return 11;

                        else
                        {
                          unsigned long int parse_cmd$$1$$27$$__s1_len;
                          unsigned long int parse_cmd$$1$$27$$__s2_len;
                          signed int return_value___builtin_strcmp$27;
                          return_value___builtin_strcmp$27=__builtin_strcmp(cmd, "kuser");
                          tmp_statement_expression$26 = return_value___builtin_strcmp$27;
                          if(tmp_statement_expression$26 == 0)
                            return 12;

                          else
                          {
                            unsigned long int parse_cmd$$1$$29$$__s1_len;
                            unsigned long int parse_cmd$$1$$29$$__s2_len;
                            signed int return_value___builtin_strcmp$29;
                            return_value___builtin_strcmp$29=__builtin_strcmp(cmd, "kclient");
                            tmp_statement_expression$28 = return_value___builtin_strcmp$29;
                            if(tmp_statement_expression$28 == 0)
                              return 13;

                            else
                              return 0;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// parse_header
// file http_proxy_functions.c line 105
signed int parse_header(struct anonymous$1 *sf, char *tab, struct anonymous$26 *hdr, char https)
{
  signed int n;
  signed int i;
  signed int j;
  signed int state = 0;
  char tmpt[100l];
  if(!(https == 0))
  {
    struct ssl_st *return_value_SslFd_get_ssl$1;
    return_value_SslFd_get_ssl$1=SslFd_get_ssl(sf);
    n=SSL_read(return_value_SslFd_get_ssl$1, (void *)tab, 9000);
  }

  else
  {
    signed int return_value_SslFd_get_fd$2;
    return_value_SslFd_get_fd$2=SslFd_get_fd(sf);
    signed long int return_value_read$3;
    return_value_read$3=read(return_value_SslFd_get_fd$2, (void *)tab, (unsigned long int)9000);
    n = (signed int)return_value_read$3;
  }
  hdr->allreaded = n;
  j = 0;
  i = j;
  memset((void *)tmpt, 0, (unsigned long int)100);
  hdr->ptr = 0;
  hdr->length = 0;
  _Bool tmp_if_expr$13;
  signed int tmp_statement_expression$4;
  signed int tmp_statement_expression$6;
  signed int tmp_statement_expression$8;
  _Bool tmp_if_expr$12;
  signed int tmp_statement_expression$10;
  signed int tmp_statement_expression$14;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$19;
  signed int tmp_statement_expression$17;
  for( ; !(i >= n); i = i + 1)
  {
    if(j == 99)
      return 1;

    switch(state)
    {
      case 0:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
          tmp_if_expr$13 = (signed int)tab[(signed long int)i] != 9 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$13 = (_Bool)0;
        if(tmp_if_expr$13)
        {
          tmpt[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }

        else
        {
          tmpt[(signed long int)j] = (char)0;
          unsigned long int parse_header$$1$$3$$1$$2$$1$$__s1_len;
          unsigned long int parse_header$$1$$3$$1$$2$$1$$__s2_len;
          signed int return_value___builtin_strcmp$5;
          return_value___builtin_strcmp$5=__builtin_strcmp(tmpt, "GET");
          tmp_statement_expression$4 = return_value___builtin_strcmp$5;
          if(tmp_statement_expression$4 == 0)
          {
            hdr->type = (char)0;
            state = 1;
            break;
          }

          unsigned long int parse_header$$1$$3$$1$$2$$3$$__s1_len;
          unsigned long int parse_header$$1$$3$$1$$2$$3$$__s2_len;
          signed int return_value___builtin_strcmp$7;
          return_value___builtin_strcmp$7=__builtin_strcmp(tmpt, "POST");
          tmp_statement_expression$6 = return_value___builtin_strcmp$7;
          if(tmp_statement_expression$6 == 0)
          {
            hdr->type = (char)1;
            state = 1;
            break;
          }

          unsigned long int parse_header$$1$$3$$1$$2$$5$$__s1_len;
          unsigned long int __s2_len;
          signed int return_value___builtin_strcmp$9;
          return_value___builtin_strcmp$9=__builtin_strcmp(tmpt, "HTTP/1.0");
          tmp_statement_expression$8 = return_value___builtin_strcmp$9;
          if(tmp_statement_expression$8 == 0)
            tmp_if_expr$12 = (_Bool)1;

          else
          {
            unsigned long int parse_header$$1$$3$$1$$2$$6$$__s1_len;
            unsigned long int parse_header$$1$$3$$1$$2$$6$$__s2_len;
            signed int return_value___builtin_strcmp$11;
            return_value___builtin_strcmp$11=__builtin_strcmp(tmpt, "HTTP/1.1");
            tmp_statement_expression$10 = return_value___builtin_strcmp$11;
            tmp_if_expr$12 = tmp_statement_expression$10 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$12)
          {
            hdr->type = (char)2;
            state = 6;
            break;
          }

          return 1;
        }
        break;
      }
      case 1:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
        {
          if(!((signed int)tab[(signed long int)i] == 9))
          {
            tmpt[(signed long int)0] = tab[(signed long int)i];
            j = 1;
            state = 2;
          }

        }

        break;
      }
      case 2:
      {
        if(!((signed int)tab[(signed long int)i] == 61))
        {
          tmpt[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }

        else
        {
          tmpt[(signed long int)j] = (char)0;
          unsigned long int parse_header$$1$$3$$1$$5$$1$$__s1_len;
          unsigned long int parse_header$$1$$3$$1$$5$$1$$__s2_len;
          signed int return_value___builtin_strcmp$15;
          return_value___builtin_strcmp$15=__builtin_strcmp(tmpt, "/yahpt.html?id");
          tmp_statement_expression$14 = return_value___builtin_strcmp$15;
          if(!(tmp_statement_expression$14 == 0))
            return 1;

          j = 0;
          state = 3;
        }
        break;
      }
      case 3:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
          tmp_if_expr$16 = (signed int)tab[(signed long int)i] != 9 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$16 = (_Bool)0;
        if(tmp_if_expr$16)
        {
          if(j == 9)
            return 1;

          hdr->id[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }

        else
        {
          if(!(j == 9))
            return 1;

          hdr->id[(signed long int)j] = (char)0;
          state = 4;
        }
        break;
      }
      case 4:
      {
        if((signed int)tab[(signed long int)i] == 10)
          state = 5;

        break;
      }
      case 5:
      {
        if((signed int)tab[(signed long int)i] == 10)
        {
          hdr->ptr = i + 1;
          hdr->length = n - hdr->ptr;
          return 0;
        }

        if(!((signed int)tab[(signed long int)i] == 13))
          state = 4;

        break;
      }
      case 6:
      {
        if(!((signed int)tab[(signed long int)i] == 32))
        {
          if(!((signed int)tab[(signed long int)i] == 9))
          {
            tmpt[(signed long int)0] = tab[(signed long int)i];
            j = 1;
            state = 7;
          }

        }

        break;
      }
      case 7:
      {
        if((signed int)tab[(signed long int)i] == 32)
          tmp_if_expr$19 = (_Bool)1;

        else
          tmp_if_expr$19 = (signed int)tab[(signed long int)i] == 9 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$19)
        {
          tmpt[(signed long int)j] = (char)0;
          unsigned long int __s1_len;
          unsigned long int parse_header$$1$$3$$1$$11$$1$$__s2_len;
          signed int return_value___builtin_strcmp$18;
          return_value___builtin_strcmp$18=__builtin_strcmp(tmpt, "200");
          tmp_statement_expression$17 = return_value___builtin_strcmp$18;
          if(!(tmp_statement_expression$17 == 0))
            return 1;

          state = 4;
        }

        else
        {
          tmpt[(signed long int)j] = tab[(signed long int)i];
          j = j + 1;
        }
      }
    }
  }
  return 1;
}

// parse_int
// file server_remoteadmin.c line 38
static signed int parse_int(unsigned char *buff, signed int *ret)
{
  signed int intarg;
  signed int i;
  char guard;
  i=sscanf((char *)&buff[(signed long int)*ret], "%d%c", &intarg, &guard);
  if(i == 1 || i == 2)
  {
    if(i == 1)
      guard = (char)32;

    const unsigned short int **return_value___ctype_b_loc$1;
    return_value___ctype_b_loc$1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)guard]) == 0)
      return -1;

    guard = (char)0;
    i = *ret;
    for( ; !((signed int)buff[(signed long int)i] == 0); i = i + 1)
      if((signed int)guard == 0)
      {
        const unsigned short int **return_value___ctype_b_loc$2;
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)buff[(signed long int)i]]) == 0))
          guard = (char)1;

      }

      else
      {
        const unsigned short int **return_value___ctype_b_loc$3;
        return_value___ctype_b_loc$3=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
          break;

      }
    if((signed int)buff[(signed long int)i] == 46)
      i = i + 1;

    *ret = i;
    return intarg;
  }

  else
    return -1;
}

// parse_line
// file file.c line 45
signed int parse_line(char *buff, char *tab1, char *tab2)
{
  signed int state;
  signed int i;
  signed int j;
  signed int lastDot;
  j = 0;
  i = j;
  state = i;
  lastDot = -1;
  _Bool tmp_if_expr$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  const unsigned short int **return_value___ctype_b_loc$3;
  const unsigned short int **return_value___ctype_b_loc$4;
  const unsigned short int **return_value___ctype_b_loc$5;
  for( ; !((signed int)buff[(signed long int)i] == 0); i = i + 1)
  {
    if((signed int)buff[(signed long int)i] == 35)
    {
      if(i >= 1)
        tmp_if_expr$1 = (signed int)buff[(signed long int)(i - 1)] == 92 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
        j = j - 1;

      else
        break;
    }

    switch(state)
    {
      case 0:
      {
        return_value___ctype_b_loc$2=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
        {
          tab1[(signed long int)j] = buff[(signed long int)i];
          j = 1;
          state = 1;
        }

        break;
      }
      case 1:
      {
        return_value___ctype_b_loc$3=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)buff[(signed long int)i]]) == 0))
        {
          tab1[(signed long int)j] = (char)0;
          state = 2;
          j = 0;
        }

        else
        {
          tab1[(signed long int)j] = buff[(signed long int)i];
          j = j + 1;
        }
        break;
      }
      case 2:
      {
        return_value___ctype_b_loc$4=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
        {
          if(!((signed int)buff[(signed long int)i] == 46))
          {
            tab2[(signed long int)j] = buff[(signed long int)i];
            j = 1;
          }

          state = 3;
        }

        break;
      }
      case 3:
      {
        if((signed int)buff[(signed long int)i] == 46)
          lastDot = j;

        else
        {
          return_value___ctype_b_loc$5=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc$5)[(signed long int)(signed int)buff[(signed long int)i]]) == 0)
            lastDot = -1;

          else
            if(lastDot == -1)
              lastDot = j;

        }
        tab2[(signed long int)j] = buff[(signed long int)i];
        j = j + 1;
      }
    }
  }
  if(!(lastDot == -1))
    tab2[(signed long int)lastDot] = (char)0;

  if(state == 3)
    return 2;

  else
    if(state == 0)
      return 0;

    else
      return 1;
}

// parsefile
// file file.h line 37
struct anonymous$2 * parsefile(char *name, signed int *status)
{
  struct anonymous$2 *cfg;
  struct _IO_FILE *file = (struct _IO_FILE *)(void *)0;
  signed int state;
  signed int i;
  signed int j;
  signed int n;
  signed int listencount;
  signed int managecount;
  signed int temp;
  char buff[256l];
  char helpbuf1[256l];
  char helpbuf2[256l];
  char *tmpbuf;
  unsigned char pass[4l] = { (unsigned char)1, (unsigned char)2, (unsigned char)3, (unsigned char)4 };
  *status = 1;
  memset((void *)buff, 0, (unsigned long int)256);
  cfg=ServerConfiguration_new();
  if(cfg == ((struct anonymous$2 *)NULL))
  {
    printf("Can't allocate memory for server configuration... exiting\n");
    exit(1);
  }

  state = 1;
  file=fopen(name, "r");
  char *return_value_fgets$1;
  signed int tmp_statement_expression$3;
  signed int return_value_ServerConfiguration_get_realmsNumber$8;
  char *return_value_fgets$12;
  signed int tmp_statement_expression$31;
  signed int tmp_statement_expression$26;
  _Bool tmp_if_expr$30;
  signed int tmp_statement_expression$28;
  signed int tmp_statement_expression$21;
  _Bool tmp_if_expr$25;
  signed int tmp_statement_expression$23;
  signed int return_value_ServerConfiguration_get_realmsNumber$33;
  struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$40;
  signed int return_value_ServerRealm_get_userClientPairs$41;
  char *return_value_fgets$46;
  signed int tmp_statement_expression$107;
  signed int return_value_ServerConfiguration_get_realmsNumber$106;
  signed int tmp_statement_expression$104;
  signed int tmp_statement_expression$102;
  signed int tmp_statement_expression$100;
  signed int tmp_statement_expression$98;
  signed int tmp_statement_expression$96;
  signed int tmp_statement_expression$94;
  signed int tmp_statement_expression$92;
  signed int tmp_statement_expression$90;
  signed int tmp_statement_expression$210;
  signed int tmp_statement_expression$205;
  _Bool tmp_if_expr$209;
  signed int tmp_statement_expression$207;
  signed int tmp_statement_expression$203;
  signed int tmp_statement_expression$201;
  signed int tmp_statement_expression$196;
  _Bool tmp_if_expr$200;
  signed int tmp_statement_expression$198;
  signed int tmp_statement_expression$194;
  signed int tmp_statement_expression$192;
  signed int return_value_ServerConfiguration_get_realmsNumber$191;
  signed int tmp_statement_expression$189;
  signed int tmp_statement_expression$184;
  _Bool tmp_if_expr$188;
  signed int tmp_statement_expression$186;
  signed int tmp_statement_expression$182;
  signed int tmp_statement_expression$177;
  _Bool tmp_if_expr$181;
  signed int tmp_statement_expression$179;
  signed int tmp_statement_expression$175;
  signed int tmp_statement_expression$173;
  signed int tmp_statement_expression$171;
  signed int tmp_statement_expression$169;
  signed int tmp_statement_expression$167;
  signed int tmp_statement_expression$165;
  signed int tmp_statement_expression$163;
  signed int tmp_statement_expression$161;
  signed int tmp_statement_expression$159;
  signed int tmp_statement_expression$157;
  if(file == ((struct _IO_FILE *)NULL))
    return cfg;

  else
  {
    do
    {
      return_value_fgets$1=fgets(buff, 256, file);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      helpbuf1[(signed long int)0] = (char)0;
      parse_line(buff, helpbuf1, helpbuf2);
      unsigned long int parsefile$$1$$3$$1$$__s1_len;
      unsigned long int parsefile$$1$$3$$1$$__s2_len;
      signed int return_value___builtin_strcmp$4;
      return_value___builtin_strcmp$4=__builtin_strcmp(helpbuf1, "realm");
      tmp_statement_expression$3 = return_value___builtin_strcmp$4;
      if(tmp_statement_expression$3 == 0)
      {
        signed int return_value_ServerConfiguration_get_realmsNumber$2;
        return_value_ServerConfiguration_get_realmsNumber$2=ServerConfiguration_get_realmsNumber(cfg);
        ServerConfiguration_set_realmsNumber(cfg, return_value_ServerConfiguration_get_realmsNumber$2 + 1);
      }

    }
    while((_Bool)1);
    rewind(file);
    signed int return_value_ServerConfiguration_get_realmsNumber$5;
    return_value_ServerConfiguration_get_realmsNumber$5=ServerConfiguration_get_realmsNumber(cfg);
    void *return_value_calloc$6;
    return_value_calloc$6=calloc((unsigned long int)return_value_ServerConfiguration_get_realmsNumber$5, sizeof(struct anonymous$5 *) /*8ul*/ );
    ServerConfiguration_set_realmsTable(cfg, (struct anonymous$5 **)return_value_calloc$6);
    struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$7;
    return_value_ServerConfiguration_get_realmsTable$7=ServerConfiguration_get_realmsTable(cfg);
    if(return_value_ServerConfiguration_get_realmsTable$7 == ((struct anonymous$5 **)NULL))
    {
      printf("Can't allocate memory for ServerRealm* table... exiting\n");
      exit(1);
    }

    i = 0;
    do
    {
      return_value_ServerConfiguration_get_realmsNumber$8=ServerConfiguration_get_realmsNumber(cfg);
      if(i >= return_value_ServerConfiguration_get_realmsNumber$8)
        break;

      struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$9;
      return_value_ServerConfiguration_get_realmsTable$9=ServerConfiguration_get_realmsTable(cfg);
      return_value_ServerConfiguration_get_realmsTable$9[(signed long int)i]=ServerRealm_new();
      struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$10;
      return_value_ServerConfiguration_get_realmsTable$10=ServerConfiguration_get_realmsTable(cfg);
      if(return_value_ServerConfiguration_get_realmsTable$10[(signed long int)i] == ((struct anonymous$5 *)NULL))
      {
        printf("Problem with allocating memory for ServerRealm structure... exiting");
        exit(1);
      }

      struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$11;
      return_value_ServerConfiguration_get_realmsTable$11=ServerConfiguration_get_realmsTable(cfg);
      ServerRealm_set_password(return_value_ServerConfiguration_get_realmsTable$11[(signed long int)i], pass);
      i = i + 1;
    }
    while((_Bool)1);
    ServerConfiguration_set_realmsNumber(cfg, 0);
    *status = 0;
    managecount = 0;
    listencount = managecount;
    do
    {
      return_value_fgets$12=fgets(buff, 256, file);
      if(return_value_fgets$12 == ((char *)NULL))
        break;

      *status = *status + 1;
      state=parse_line(buff, helpbuf1, helpbuf2);
      if(!(state == 0))
      {
        unsigned long int parsefile$$1$$6$$1$$1$$__s1_len;
        unsigned long int parsefile$$1$$6$$1$$1$$__s2_len;
        signed int return_value___builtin_strcmp$32;
        return_value___builtin_strcmp$32=__builtin_strcmp(helpbuf1, "realm");
        tmp_statement_expression$31 = return_value___builtin_strcmp$32;
        if(tmp_statement_expression$31 == 0)
        {
          signed int return_value_ServerConfiguration_get_realmsNumber$13;
          return_value_ServerConfiguration_get_realmsNumber$13=ServerConfiguration_get_realmsNumber(cfg);
          ServerConfiguration_set_realmsNumber(cfg, return_value_ServerConfiguration_get_realmsNumber$13 + 1);
          if(!(listencount == managecount))
            return cfg;

          managecount = 0;
          listencount = managecount;
        }

        else
        {
          unsigned long int parsefile$$1$$6$$1$$3$$__s1_len;
          unsigned long int parsefile$$1$$6$$1$$3$$__s2_len;
          signed int return_value___builtin_strcmp$27;
          return_value___builtin_strcmp$27=__builtin_strcmp(helpbuf1, "listen");
          tmp_statement_expression$26 = return_value___builtin_strcmp$27;
          if(tmp_statement_expression$26 == 0)
            tmp_if_expr$30 = (_Bool)1;

          else
          {
            unsigned long int parsefile$$1$$6$$1$$4$$__s1_len;
            unsigned long int parsefile$$1$$6$$1$$4$$__s2_len;
            signed int return_value___builtin_strcmp$29;
            return_value___builtin_strcmp$29=__builtin_strcmp(helpbuf1, "listenport");
            tmp_statement_expression$28 = return_value___builtin_strcmp$29;
            tmp_if_expr$30 = tmp_statement_expression$28 == 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$30)
          {
            signed int return_value_ServerConfiguration_get_realmsNumber$14;
            return_value_ServerConfiguration_get_realmsNumber$14=ServerConfiguration_get_realmsNumber(cfg);
            if(return_value_ServerConfiguration_get_realmsNumber$14 == 0)
              return cfg;

            struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$15;
            return_value_ServerConfiguration_get_realmsTable$15=ServerConfiguration_get_realmsTable(cfg);
            signed int return_value_ServerConfiguration_get_realmsNumber$16;
            return_value_ServerConfiguration_get_realmsNumber$16=ServerConfiguration_get_realmsNumber(cfg);
            struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$17;
            return_value_ServerConfiguration_get_realmsTable$17=ServerConfiguration_get_realmsTable(cfg);
            signed int return_value_ServerConfiguration_get_realmsNumber$18;
            return_value_ServerConfiguration_get_realmsNumber$18=ServerConfiguration_get_realmsNumber(cfg);
            signed int return_value_ServerRealm_get_userClientPairs$19;
            return_value_ServerRealm_get_userClientPairs$19=ServerRealm_get_userClientPairs(return_value_ServerConfiguration_get_realmsTable$17[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$18 - 1)]);
            ServerRealm_set_userClientPairs(return_value_ServerConfiguration_get_realmsTable$15[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$16 - 1)], return_value_ServerRealm_get_userClientPairs$19 + 1);
            listencount = listencount + 1;
          }

          else
          {
            unsigned long int parsefile$$1$$6$$1$$6$$__s1_len;
            unsigned long int parsefile$$1$$6$$1$$6$$__s2_len;
            signed int return_value___builtin_strcmp$22;
            return_value___builtin_strcmp$22=__builtin_strcmp(helpbuf1, "manage");
            tmp_statement_expression$21 = return_value___builtin_strcmp$22;
            if(tmp_statement_expression$21 == 0)
              tmp_if_expr$25 = (_Bool)1;

            else
            {
              unsigned long int parsefile$$1$$6$$1$$7$$__s1_len;
              unsigned long int parsefile$$1$$6$$1$$7$$__s2_len;
              signed int return_value___builtin_strcmp$24;
              return_value___builtin_strcmp$24=__builtin_strcmp(helpbuf1, "manageport");
              tmp_statement_expression$23 = return_value___builtin_strcmp$24;
              tmp_if_expr$25 = tmp_statement_expression$23 == 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$25)
            {
              signed int return_value_ServerConfiguration_get_realmsNumber$20;
              return_value_ServerConfiguration_get_realmsNumber$20=ServerConfiguration_get_realmsNumber(cfg);
              if(return_value_ServerConfiguration_get_realmsNumber$20 == 0)
                return cfg;

              managecount = managecount + 1;
            }

          }
        }
      }

    }
    while((_Bool)1);
    rewind(file);
    if(!(listencount == managecount))
      return cfg;

    else
    {
      i = 0;
      do
      {
        return_value_ServerConfiguration_get_realmsNumber$33=ServerConfiguration_get_realmsNumber(cfg);
        if(i >= return_value_ServerConfiguration_get_realmsNumber$33)
          break;

        struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$34;
        return_value_ServerConfiguration_get_realmsTable$34=ServerConfiguration_get_realmsTable(cfg);
        struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$35;
        return_value_ServerConfiguration_get_realmsTable$35=ServerConfiguration_get_realmsTable(cfg);
        signed int return_value_ServerRealm_get_userClientPairs$36;
        return_value_ServerRealm_get_userClientPairs$36=ServerRealm_get_userClientPairs(return_value_ServerConfiguration_get_realmsTable$35[(signed long int)i]);
        void *return_value_calloc$37;
        return_value_calloc$37=calloc((unsigned long int)return_value_ServerRealm_get_userClientPairs$36, sizeof(struct anonymous$7 *) /*8ul*/ );
        ServerRealm_set_usersClientsTable(return_value_ServerConfiguration_get_realmsTable$34[(signed long int)i], (struct anonymous$7 **)return_value_calloc$37);
        struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$38;
        return_value_ServerConfiguration_get_realmsTable$38=ServerConfiguration_get_realmsTable(cfg);
        struct anonymous$7 **return_value_ServerRealm_get_usersClientsTable$39;
        return_value_ServerRealm_get_usersClientsTable$39=ServerRealm_get_usersClientsTable(return_value_ServerConfiguration_get_realmsTable$38[(signed long int)i]);
        if(return_value_ServerRealm_get_usersClientsTable$39 == ((struct anonymous$7 **)NULL))
        {
          printf("Problem with allocating memory for UsrCli* table... exiting");
          return cfg;
        }

        j = 0;
        do
        {
          return_value_ServerConfiguration_get_realmsTable$40=ServerConfiguration_get_realmsTable(cfg);
          return_value_ServerRealm_get_userClientPairs$41=ServerRealm_get_userClientPairs(return_value_ServerConfiguration_get_realmsTable$40[(signed long int)i]);
          if(j >= return_value_ServerRealm_get_userClientPairs$41)
            break;

          struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$42;
          return_value_ServerConfiguration_get_realmsTable$42=ServerConfiguration_get_realmsTable(cfg);
          struct anonymous$7 **return_value_ServerRealm_get_usersClientsTable$43;
          return_value_ServerRealm_get_usersClientsTable$43=ServerRealm_get_usersClientsTable(return_value_ServerConfiguration_get_realmsTable$42[(signed long int)i]);
          return_value_ServerRealm_get_usersClientsTable$43[(signed long int)j]=UsrCli_new();
          struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$44;
          return_value_ServerConfiguration_get_realmsTable$44=ServerConfiguration_get_realmsTable(cfg);
          struct anonymous$7 **return_value_ServerRealm_get_usersClientsTable$45;
          return_value_ServerRealm_get_usersClientsTable$45=ServerRealm_get_usersClientsTable(return_value_ServerConfiguration_get_realmsTable$44[(signed long int)i]);
          if(return_value_ServerRealm_get_usersClientsTable$45[(signed long int)j] == ((struct anonymous$7 *)NULL))
          {
            printf("Problem with allocating memory for UsrCli structure... exiting");
            return cfg;
          }

          j = j + 1;
        }
        while((_Bool)1);
        i = i + 1;
      }
      while((_Bool)1);
      ServerConfiguration_set_realmsNumber(cfg, 0);
      *status = 0;
      do
      {
        return_value_fgets$46=fgets(buff, 256, file);
        if(return_value_fgets$46 == ((char *)NULL))
          break;

        *status = *status + 1;
        state=parse_line(buff, helpbuf1, helpbuf2);
        if((signed int)helpbuf1[0l] == 35)
          memset((void *)buff, 0, (unsigned long int)256);

        else
        {
          if(state == 1)
          {
            unsigned long int parsefile$$1$$9$$2$$1$$__s1_len;
            unsigned long int parsefile$$1$$9$$2$$1$$__s2_len;
            signed int return_value___builtin_strcmp$108;
            return_value___builtin_strcmp$108=__builtin_strcmp(helpbuf1, "realm");
            tmp_statement_expression$107 = return_value___builtin_strcmp$108;
            if(tmp_statement_expression$107 == 0)
            {
              signed int return_value_ServerConfiguration_get_realmsNumber$47;
              return_value_ServerConfiguration_get_realmsNumber$47=ServerConfiguration_get_realmsNumber(cfg);
              ServerConfiguration_set_realmsNumber(cfg, return_value_ServerConfiguration_get_realmsNumber$47 + 1);
              struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$48;
              return_value_ServerConfiguration_get_realmsTable$48=ServerConfiguration_get_realmsTable(cfg);
              signed int return_value_ServerConfiguration_get_realmsNumber$49;
              return_value_ServerConfiguration_get_realmsNumber$49=ServerConfiguration_get_realmsNumber(cfg);
              char return_value_ServerRealm_get_realmType$50;
              return_value_ServerRealm_get_realmType$50=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable$48[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$49 - 1)]);
              temp = (signed int)return_value_ServerRealm_get_realmType$50;
              temp = temp | 4;
              temp = temp | 8;
              temp = temp | 64;
              struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$51;
              return_value_ServerConfiguration_get_realmsTable$51=ServerConfiguration_get_realmsTable(cfg);
              signed int return_value_ServerConfiguration_get_realmsNumber$52;
              return_value_ServerConfiguration_get_realmsNumber$52=ServerConfiguration_get_realmsNumber(cfg);
              ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable$51[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$52 - 1)], (char)temp);
              managecount = 0;
              listencount = managecount;
            }

            else
            {
              return_value_ServerConfiguration_get_realmsNumber$106=ServerConfiguration_get_realmsNumber(cfg);
              if(return_value_ServerConfiguration_get_realmsNumber$106 == 0)
                return cfg;

              else
              {
                unsigned long int parsefile$$1$$9$$2$$4$$__s1_len;
                unsigned long int parsefile$$1$$9$$2$$4$$__s2_len;
                signed int return_value___builtin_strcmp$105;
                return_value___builtin_strcmp$105=__builtin_strcmp(helpbuf1, "nossl");
                tmp_statement_expression$104 = return_value___builtin_strcmp$105;
                if(tmp_statement_expression$104 == 0)
                {
                  struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$53;
                  return_value_ServerConfiguration_get_realmsTable$53=ServerConfiguration_get_realmsTable(cfg);
                  signed int return_value_ServerConfiguration_get_realmsNumber$54;
                  return_value_ServerConfiguration_get_realmsNumber$54=ServerConfiguration_get_realmsNumber(cfg);
                  char return_value_ServerRealm_get_realmType$55;
                  return_value_ServerRealm_get_realmType$55=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable$53[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$54 - 1)]);
                  temp = (signed int)return_value_ServerRealm_get_realmType$55;
                  temp = temp & ~4;
                  struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$56;
                  return_value_ServerConfiguration_get_realmsTable$56=ServerConfiguration_get_realmsTable(cfg);
                  signed int return_value_ServerConfiguration_get_realmsNumber$57;
                  return_value_ServerConfiguration_get_realmsNumber$57=ServerConfiguration_get_realmsNumber(cfg);
                  ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable$56[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$57 - 1)], (char)temp);
                }

                else
                {
                  unsigned long int parsefile$$1$$9$$2$$6$$__s1_len;
                  unsigned long int parsefile$$1$$9$$2$$6$$__s2_len;
                  signed int return_value___builtin_strcmp$103;
                  return_value___builtin_strcmp$103=__builtin_strcmp(helpbuf1, "nozlib");
                  tmp_statement_expression$102 = return_value___builtin_strcmp$103;
                  if(tmp_statement_expression$102 == 0)
                  {
                    struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$58;
                    return_value_ServerConfiguration_get_realmsTable$58=ServerConfiguration_get_realmsTable(cfg);
                    signed int return_value_ServerConfiguration_get_realmsNumber$59;
                    return_value_ServerConfiguration_get_realmsNumber$59=ServerConfiguration_get_realmsNumber(cfg);
                    char return_value_ServerRealm_get_realmType$60;
                    return_value_ServerRealm_get_realmType$60=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable$58[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$59 - 1)]);
                    temp = (signed int)return_value_ServerRealm_get_realmType$60;
                    temp = temp & ~8;
                    struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$61;
                    return_value_ServerConfiguration_get_realmsTable$61=ServerConfiguration_get_realmsTable(cfg);
                    signed int return_value_ServerConfiguration_get_realmsNumber$62;
                    return_value_ServerConfiguration_get_realmsNumber$62=ServerConfiguration_get_realmsNumber(cfg);
                    ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable$61[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$62 - 1)], (char)temp);
                  }

                  else
                  {
                    unsigned long int parsefile$$1$$9$$2$$8$$__s1_len;
                    unsigned long int parsefile$$1$$9$$2$$8$$__s2_len;
                    signed int return_value___builtin_strcmp$101;
                    return_value___builtin_strcmp$101=__builtin_strcmp(helpbuf1, "baseport");
                    tmp_statement_expression$100 = return_value___builtin_strcmp$101;
                    if(tmp_statement_expression$100 == 0)
                    {
                      struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$63;
                      return_value_ServerConfiguration_get_realmsTable$63=ServerConfiguration_get_realmsTable(cfg);
                      signed int return_value_ServerConfiguration_get_realmsNumber$64;
                      return_value_ServerConfiguration_get_realmsNumber$64=ServerConfiguration_get_realmsNumber(cfg);
                      ServerRealm_set_basePortOn(return_value_ServerConfiguration_get_realmsTable$63[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$64 - 1)], (char)1);
                    }

                    else
                    {
                      unsigned long int parsefile$$1$$9$$2$$10$$__s1_len;
                      unsigned long int parsefile$$1$$9$$2$$10$$__s2_len;
                      signed int return_value___builtin_strcmp$99;
                      return_value___builtin_strcmp$99=__builtin_strcmp(helpbuf1, "audit");
                      tmp_statement_expression$98 = return_value___builtin_strcmp$99;
                      if(tmp_statement_expression$98 == 0)
                      {
                        struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$65;
                        return_value_ServerConfiguration_get_realmsTable$65=ServerConfiguration_get_realmsTable(cfg);
                        signed int return_value_ServerConfiguration_get_realmsNumber$66;
                        return_value_ServerConfiguration_get_realmsNumber$66=ServerConfiguration_get_realmsNumber(cfg);
                        ServerRealm_set_auditOn(return_value_ServerConfiguration_get_realmsTable$65[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$66 - 1)], (char)1);
                      }

                      else
                      {
                        unsigned long int parsefile$$1$$9$$2$$12$$__s1_len;
                        unsigned long int parsefile$$1$$9$$2$$12$$__s2_len;
                        signed int return_value___builtin_strcmp$97;
                        return_value___builtin_strcmp$97=__builtin_strcmp(helpbuf1, "dnslookups");
                        tmp_statement_expression$96 = return_value___builtin_strcmp$97;
                        if(tmp_statement_expression$96 == 0)
                        {
                          struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$67;
                          return_value_ServerConfiguration_get_realmsTable$67=ServerConfiguration_get_realmsTable(cfg);
                          signed int return_value_ServerConfiguration_get_realmsNumber$68;
                          return_value_ServerConfiguration_get_realmsNumber$68=ServerConfiguration_get_realmsNumber(cfg);
                          ServerRealm_set_dnsLookupsOn(return_value_ServerConfiguration_get_realmsTable$67[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$68 - 1)], (char)1);
                        }

                        else
                        {
                          unsigned long int parsefile$$1$$9$$2$$14$$__s1_len;
                          unsigned long int parsefile$$1$$9$$2$$14$$__s2_len;
                          signed int return_value___builtin_strcmp$95;
                          return_value___builtin_strcmp$95=__builtin_strcmp(helpbuf1, "enableproxy");
                          tmp_statement_expression$94 = return_value___builtin_strcmp$95;
                          if(tmp_statement_expression$94 == 0)
                          {
                            struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$71;
                            return_value_ServerConfiguration_get_realmsTable$71=ServerConfiguration_get_realmsTable(cfg);
                            signed int return_value_ServerConfiguration_get_realmsNumber$72;
                            return_value_ServerConfiguration_get_realmsNumber$72=ServerConfiguration_get_realmsNumber(cfg);
                            char return_value_ServerRealm_get_tunnelType$73;
                            return_value_ServerRealm_get_tunnelType$73=ServerRealm_get_tunnelType(return_value_ServerConfiguration_get_realmsTable$71[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$72 - 1)]);
                            if((signed int)return_value_ServerRealm_get_tunnelType$73 == 0)
                            {
                              struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$69;
                              return_value_ServerConfiguration_get_realmsTable$69=ServerConfiguration_get_realmsTable(cfg);
                              signed int return_value_ServerConfiguration_get_realmsNumber$70;
                              return_value_ServerConfiguration_get_realmsNumber$70=ServerConfiguration_get_realmsNumber(cfg);
                              ServerRealm_set_tunnelType(return_value_ServerConfiguration_get_realmsTable$69[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$70 - 1)], (char)1);
                            }

                            else
                              return cfg;
                          }

                          else
                          {
                            unsigned long int parsefile$$1$$9$$2$$16$$__s1_len;
                            unsigned long int parsefile$$1$$9$$2$$16$$__s2_len;
                            signed int return_value___builtin_strcmp$93;
                            return_value___builtin_strcmp$93=__builtin_strcmp(helpbuf1, "ipv4");
                            tmp_statement_expression$92 = return_value___builtin_strcmp$93;
                            if(tmp_statement_expression$92 == 0)
                            {
                              struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$79;
                              return_value_ServerConfiguration_get_realmsTable$79=ServerConfiguration_get_realmsTable(cfg);
                              signed int return_value_ServerConfiguration_get_realmsNumber$80;
                              return_value_ServerConfiguration_get_realmsNumber$80=ServerConfiguration_get_realmsNumber(cfg);
                              char return_value_ServerRealm_get_realmType$81;
                              return_value_ServerRealm_get_realmType$81=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable$79[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$80 - 1)]);
                              if((48 & (signed int)return_value_ServerRealm_get_realmType$81) == 0)
                              {
                                struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$74;
                                return_value_ServerConfiguration_get_realmsTable$74=ServerConfiguration_get_realmsTable(cfg);
                                signed int return_value_ServerConfiguration_get_realmsNumber$75;
                                return_value_ServerConfiguration_get_realmsNumber$75=ServerConfiguration_get_realmsNumber(cfg);
                                char return_value_ServerRealm_get_realmType$76;
                                return_value_ServerRealm_get_realmType$76=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable$74[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$75 - 1)]);
                                temp = (signed int)return_value_ServerRealm_get_realmType$76;
                                temp = temp | 16;
                                struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$77;
                                return_value_ServerConfiguration_get_realmsTable$77=ServerConfiguration_get_realmsTable(cfg);
                                signed int return_value_ServerConfiguration_get_realmsNumber$78;
                                return_value_ServerConfiguration_get_realmsNumber$78=ServerConfiguration_get_realmsNumber(cfg);
                                ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable$77[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$78 - 1)], (char)temp);
                              }

                              else
                                return cfg;
                            }

                            else
                            {
                              unsigned long int parsefile$$1$$9$$2$$18$$__s1_len;
                              unsigned long int parsefile$$1$$9$$2$$18$$__s2_len;
                              signed int return_value___builtin_strcmp$91;
                              return_value___builtin_strcmp$91=__builtin_strcmp(helpbuf1, "ipv6");
                              tmp_statement_expression$90 = return_value___builtin_strcmp$91;
                              if(tmp_statement_expression$90 == 0)
                              {
                                struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$87;
                                return_value_ServerConfiguration_get_realmsTable$87=ServerConfiguration_get_realmsTable(cfg);
                                signed int return_value_ServerConfiguration_get_realmsNumber$88;
                                return_value_ServerConfiguration_get_realmsNumber$88=ServerConfiguration_get_realmsNumber(cfg);
                                char return_value_ServerRealm_get_realmType$89;
                                return_value_ServerRealm_get_realmType$89=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable$87[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$88 - 1)]);
                                if((48 & (signed int)return_value_ServerRealm_get_realmType$89) == 0)
                                {
                                  struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$82;
                                  return_value_ServerConfiguration_get_realmsTable$82=ServerConfiguration_get_realmsTable(cfg);
                                  signed int return_value_ServerConfiguration_get_realmsNumber$83;
                                  return_value_ServerConfiguration_get_realmsNumber$83=ServerConfiguration_get_realmsNumber(cfg);
                                  char return_value_ServerRealm_get_realmType$84;
                                  return_value_ServerRealm_get_realmType$84=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable$82[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$83 - 1)]);
                                  temp = (signed int)return_value_ServerRealm_get_realmType$84;
                                  temp = temp | 32;
                                  struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$85;
                                  return_value_ServerConfiguration_get_realmsTable$85=ServerConfiguration_get_realmsTable(cfg);
                                  signed int return_value_ServerConfiguration_get_realmsNumber$86;
                                  return_value_ServerConfiguration_get_realmsNumber$86=ServerConfiguration_get_realmsNumber(cfg);
                                  ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable$85[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$86 - 1)], (char)temp);
                                }

                                else
                                  return cfg;
                              }

                              else
                                return cfg;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          else
            if(state == 2)
            {
              unsigned long int parsefile$$1$$9$$3$$1$$__s1_len;
              unsigned long int parsefile$$1$$9$$3$$1$$__s2_len;
              signed int return_value___builtin_strcmp$211;
              return_value___builtin_strcmp$211=__builtin_strcmp(helpbuf1, "realm");
              tmp_statement_expression$210 = return_value___builtin_strcmp$211;
              if(tmp_statement_expression$210 == 0)
              {
                signed int return_value_ServerConfiguration_get_realmsNumber$109;
                return_value_ServerConfiguration_get_realmsNumber$109=ServerConfiguration_get_realmsNumber(cfg);
                ServerConfiguration_set_realmsNumber(cfg, return_value_ServerConfiguration_get_realmsNumber$109 + 1);
                struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$110;
                return_value_ServerConfiguration_get_realmsTable$110=ServerConfiguration_get_realmsTable(cfg);
                signed int return_value_ServerConfiguration_get_realmsNumber$111;
                return_value_ServerConfiguration_get_realmsNumber$111=ServerConfiguration_get_realmsNumber(cfg);
                char return_value_ServerRealm_get_realmType$112;
                return_value_ServerRealm_get_realmType$112=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable$110[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$111 - 1)]);
                temp = (signed int)return_value_ServerRealm_get_realmType$112;
                temp = temp | 4;
                temp = temp | 8;
                temp = temp | 64;
                struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$113;
                return_value_ServerConfiguration_get_realmsTable$113=ServerConfiguration_get_realmsTable(cfg);
                signed int return_value_ServerConfiguration_get_realmsNumber$114;
                return_value_ServerConfiguration_get_realmsNumber$114=ServerConfiguration_get_realmsNumber(cfg);
                ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable$113[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$114 - 1)], (char)temp);
                managecount = 0;
                listencount = managecount;
                struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$115;
                return_value_ServerConfiguration_get_realmsTable$115=ServerConfiguration_get_realmsTable(cfg);
                signed int return_value_ServerConfiguration_get_realmsNumber$116;
                return_value_ServerConfiguration_get_realmsNumber$116=ServerConfiguration_get_realmsNumber(cfg);
                ServerRealm_set_realmName(return_value_ServerConfiguration_get_realmsTable$115[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$116 - 1)], helpbuf2);
              }

              else
              {
                unsigned long int parsefile$$1$$9$$3$$3$$__s1_len;
                unsigned long int parsefile$$1$$9$$3$$3$$__s2_len;
                signed int return_value___builtin_strcmp$206;
                return_value___builtin_strcmp$206=__builtin_strcmp(helpbuf1, "certificate");
                tmp_statement_expression$205 = return_value___builtin_strcmp$206;
                if(tmp_statement_expression$205 == 0)
                  tmp_if_expr$209 = (_Bool)1;

                else
                {
                  unsigned long int parsefile$$1$$9$$3$$4$$__s1_len;
                  unsigned long int parsefile$$1$$9$$3$$4$$__s2_len;
                  signed int return_value___builtin_strcmp$208;
                  return_value___builtin_strcmp$208=__builtin_strcmp(helpbuf1, "cerfile");
                  tmp_statement_expression$207 = return_value___builtin_strcmp$208;
                  tmp_if_expr$209 = tmp_statement_expression$207 == 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$209)
                  ServerConfiguration_set_certificateFile(cfg, helpbuf2);

                else
                {
                  unsigned long int parsefile$$1$$9$$3$$6$$__s1_len;
                  unsigned long int parsefile$$1$$9$$3$$6$$__s2_len;
                  signed int return_value___builtin_strcmp$204;
                  return_value___builtin_strcmp$204=__builtin_strcmp(helpbuf1, "cacerfile");
                  tmp_statement_expression$203 = return_value___builtin_strcmp$204;
                  if(tmp_statement_expression$203 == 0)
                    ServerConfiguration_set_cacertificateFile(cfg, helpbuf2);

                  else
                  {
                    unsigned long int parsefile$$1$$9$$3$$8$$__s1_len;
                    unsigned long int parsefile$$1$$9$$3$$8$$__s2_len;
                    signed int return_value___builtin_strcmp$202;
                    return_value___builtin_strcmp$202=__builtin_strcmp(helpbuf1, "cerdepth");
                    tmp_statement_expression$201 = return_value___builtin_strcmp$202;
                    if(tmp_statement_expression$201 == 0)
                      ServerConfiguration_set_sCertificateDepth(cfg, helpbuf2);

                    else
                    {
                      unsigned long int parsefile$$1$$9$$3$$10$$__s1_len;
                      unsigned long int parsefile$$1$$9$$3$$10$$__s2_len;
                      signed int return_value___builtin_strcmp$197;
                      return_value___builtin_strcmp$197=__builtin_strcmp(helpbuf1, "key");
                      tmp_statement_expression$196 = return_value___builtin_strcmp$197;
                      if(tmp_statement_expression$196 == 0)
                        tmp_if_expr$200 = (_Bool)1;

                      else
                      {
                        unsigned long int parsefile$$1$$9$$3$$11$$__s1_len;
                        unsigned long int parsefile$$1$$9$$3$$11$$__s2_len;
                        signed int return_value___builtin_strcmp$199;
                        return_value___builtin_strcmp$199=__builtin_strcmp(helpbuf1, "keyfile");
                        tmp_statement_expression$198 = return_value___builtin_strcmp$199;
                        tmp_if_expr$200 = tmp_statement_expression$198 == 0 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr$200)
                        ServerConfiguration_set_keysFile(cfg, helpbuf2);

                      else
                      {
                        unsigned long int parsefile$$1$$9$$3$$13$$__s1_len;
                        unsigned long int parsefile$$1$$9$$3$$13$$__s2_len;
                        signed int return_value___builtin_strcmp$195;
                        return_value___builtin_strcmp$195=__builtin_strcmp(helpbuf1, "log");
                        tmp_statement_expression$194 = return_value___builtin_strcmp$195;
                        if(tmp_statement_expression$194 == 0)
                        {
                          unsigned long int return_value_strlen$117;
                          return_value_strlen$117=strlen(helpbuf2);
                          void *return_value_calloc$118;
                          return_value_calloc$118=calloc(return_value_strlen$117 + (unsigned long int)1, sizeof(char) /*1ul*/ );
                          tmpbuf = (char *)return_value_calloc$118;
                          strcpy(tmpbuf, helpbuf2);
                          addlogtarget(tmpbuf);
                        }

                        else
                        {
                          unsigned long int parsefile$$1$$9$$3$$15$$__s1_len;
                          unsigned long int parsefile$$1$$9$$3$$15$$__s2_len;
                          signed int return_value___builtin_strcmp$193;
                          return_value___builtin_strcmp$193=__builtin_strcmp(helpbuf1, "dateformat");
                          tmp_statement_expression$192 = return_value___builtin_strcmp$193;
                          if(tmp_statement_expression$192 == 0)
                            ServerConfiguration_set_dateFormat(cfg, helpbuf2);

                          else
                          {
                            return_value_ServerConfiguration_get_realmsNumber$191=ServerConfiguration_get_realmsNumber(cfg);
                            if(return_value_ServerConfiguration_get_realmsNumber$191 == 0)
                              return cfg;

                            else
                            {
                              unsigned long int parsefile$$1$$9$$3$$18$$__s1_len;
                              unsigned long int parsefile$$1$$9$$3$$18$$__s2_len;
                              signed int return_value___builtin_strcmp$190;
                              return_value___builtin_strcmp$190=__builtin_strcmp(helpbuf1, "hostname");
                              tmp_statement_expression$189 = return_value___builtin_strcmp$190;
                              if(tmp_statement_expression$189 == 0)
                              {
                                struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$119;
                                return_value_ServerConfiguration_get_realmsTable$119=ServerConfiguration_get_realmsTable(cfg);
                                signed int return_value_ServerConfiguration_get_realmsNumber$120;
                                return_value_ServerConfiguration_get_realmsNumber$120=ServerConfiguration_get_realmsNumber(cfg);
                                ServerRealm_set_hostName(return_value_ServerConfiguration_get_realmsTable$119[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$120 - 1)], helpbuf2);
                              }

                              else
                              {
                                unsigned long int parsefile$$1$$9$$3$$20$$__s1_len;
                                unsigned long int parsefile$$1$$9$$3$$20$$__s2_len;
                                signed int return_value___builtin_strcmp$185;
                                return_value___builtin_strcmp$185=__builtin_strcmp(helpbuf1, "listen");
                                tmp_statement_expression$184 = return_value___builtin_strcmp$185;
                                if(tmp_statement_expression$184 == 0)
                                  tmp_if_expr$188 = (_Bool)1;

                                else
                                {
                                  unsigned long int parsefile$$1$$9$$3$$21$$__s1_len;
                                  unsigned long int parsefile$$1$$9$$3$$21$$__s2_len;
                                  signed int return_value___builtin_strcmp$187;
                                  return_value___builtin_strcmp$187=__builtin_strcmp(helpbuf1, "listenport");
                                  tmp_statement_expression$186 = return_value___builtin_strcmp$187;
                                  tmp_if_expr$188 = tmp_statement_expression$186 == 0 ? (_Bool)1 : (_Bool)0;
                                }
                                if(tmp_if_expr$188)
                                {
                                  struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$121;
                                  return_value_ServerConfiguration_get_realmsTable$121=ServerConfiguration_get_realmsTable(cfg);
                                  signed int return_value_ServerConfiguration_get_realmsNumber$122;
                                  return_value_ServerConfiguration_get_realmsNumber$122=ServerConfiguration_get_realmsNumber(cfg);
                                  struct anonymous$7 **return_value_ServerRealm_get_usersClientsTable$123;
                                  return_value_ServerRealm_get_usersClientsTable$123=ServerRealm_get_usersClientsTable(return_value_ServerConfiguration_get_realmsTable$121[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$122 - 1)]);
                                  UsrCli_set_listenPortName(return_value_ServerRealm_get_usersClientsTable$123[(signed long int)listencount], helpbuf2);
                                  listencount = listencount + 1;
                                }

                                else
                                {
                                  unsigned long int parsefile$$1$$9$$3$$23$$__s1_len;
                                  unsigned long int parsefile$$1$$9$$3$$23$$__s2_len;
                                  signed int return_value___builtin_strcmp$183;
                                  return_value___builtin_strcmp$183=__builtin_strcmp(helpbuf1, "pass");
                                  tmp_statement_expression$182 = return_value___builtin_strcmp$183;
                                  if(tmp_statement_expression$182 == 0)
                                  {
                                    unsigned long int return_value_strlen$124;
                                    return_value_strlen$124=strlen(helpbuf2);
                                    n = (signed int)return_value_strlen$124;
                                    memset((void *)pass, 0, (unsigned long int)4);
                                    i = 0;
                                    for( ; !(i >= n); i = i + 1)
                                      pass[(signed long int)(i % 4)] = pass[(signed long int)(i % 4)] + (unsigned char)helpbuf2[(signed long int)i];
                                    struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$125;
                                    return_value_ServerConfiguration_get_realmsTable$125=ServerConfiguration_get_realmsTable(cfg);
                                    signed int return_value_ServerConfiguration_get_realmsNumber$126;
                                    return_value_ServerConfiguration_get_realmsNumber$126=ServerConfiguration_get_realmsNumber(cfg);
                                    ServerRealm_set_password(return_value_ServerConfiguration_get_realmsTable$125[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$126 - 1)], pass);
                                  }

                                  else
                                  {
                                    unsigned long int parsefile$$1$$9$$3$$25$$__s1_len;
                                    unsigned long int parsefile$$1$$9$$3$$25$$__s2_len;
                                    signed int return_value___builtin_strcmp$178;
                                    return_value___builtin_strcmp$178=__builtin_strcmp(helpbuf1, "manage");
                                    tmp_statement_expression$177 = return_value___builtin_strcmp$178;
                                    if(tmp_statement_expression$177 == 0)
                                      tmp_if_expr$181 = (_Bool)1;

                                    else
                                    {
                                      unsigned long int parsefile$$1$$9$$3$$26$$__s1_len;
                                      unsigned long int parsefile$$1$$9$$3$$26$$__s2_len;
                                      signed int return_value___builtin_strcmp$180;
                                      return_value___builtin_strcmp$180=__builtin_strcmp(helpbuf1, "manageport");
                                      tmp_statement_expression$179 = return_value___builtin_strcmp$180;
                                      tmp_if_expr$181 = tmp_statement_expression$179 == 0 ? (_Bool)1 : (_Bool)0;
                                    }
                                    if(tmp_if_expr$181)
                                    {
                                      struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$127;
                                      return_value_ServerConfiguration_get_realmsTable$127=ServerConfiguration_get_realmsTable(cfg);
                                      signed int return_value_ServerConfiguration_get_realmsNumber$128;
                                      return_value_ServerConfiguration_get_realmsNumber$128=ServerConfiguration_get_realmsNumber(cfg);
                                      struct anonymous$7 **return_value_ServerRealm_get_usersClientsTable$129;
                                      return_value_ServerRealm_get_usersClientsTable$129=ServerRealm_get_usersClientsTable(return_value_ServerConfiguration_get_realmsTable$127[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$128 - 1)]);
                                      UsrCli_set_managePortName(return_value_ServerRealm_get_usersClientsTable$129[(signed long int)managecount], helpbuf2);
                                      managecount = managecount + 1;
                                    }

                                    else
                                    {
                                      unsigned long int parsefile$$1$$9$$3$$28$$__s1_len;
                                      unsigned long int parsefile$$1$$9$$3$$28$$__s2_len;
                                      signed int return_value___builtin_strcmp$176;
                                      return_value___builtin_strcmp$176=__builtin_strcmp(helpbuf1, "users");
                                      tmp_statement_expression$175 = return_value___builtin_strcmp$176;
                                      if(tmp_statement_expression$175 == 0)
                                      {
                                        struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$130;
                                        return_value_ServerConfiguration_get_realmsTable$130=ServerConfiguration_get_realmsTable(cfg);
                                        signed int return_value_ServerConfiguration_get_realmsNumber$131;
                                        return_value_ServerConfiguration_get_realmsNumber$131=ServerConfiguration_get_realmsNumber(cfg);
                                        ServerRealm_set_sUsersLimit(return_value_ServerConfiguration_get_realmsTable$130[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$131 - 1)], helpbuf2);
                                      }

                                      else
                                      {
                                        unsigned long int parsefile$$1$$9$$3$$30$$__s1_len;
                                        unsigned long int parsefile$$1$$9$$3$$30$$__s2_len;
                                        signed int return_value___builtin_strcmp$174;
                                        return_value___builtin_strcmp$174=__builtin_strcmp(helpbuf1, "timeout");
                                        tmp_statement_expression$173 = return_value___builtin_strcmp$174;
                                        if(tmp_statement_expression$173 == 0)
                                        {
                                          struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$132;
                                          return_value_ServerConfiguration_get_realmsTable$132=ServerConfiguration_get_realmsTable(cfg);
                                          signed int return_value_ServerConfiguration_get_realmsNumber$133;
                                          return_value_ServerConfiguration_get_realmsNumber$133=ServerConfiguration_get_realmsNumber(cfg);
                                          ServerRealm_set_sTimeout(return_value_ServerConfiguration_get_realmsTable$132[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$133 - 1)], helpbuf2);
                                        }

                                        else
                                        {
                                          unsigned long int parsefile$$1$$9$$3$$32$$__s1_len;
                                          unsigned long int parsefile$$1$$9$$3$$32$$__s2_len;
                                          signed int return_value___builtin_strcmp$172;
                                          return_value___builtin_strcmp$172=__builtin_strcmp(helpbuf1, "maxidle");
                                          tmp_statement_expression$171 = return_value___builtin_strcmp$172;
                                          if(tmp_statement_expression$171 == 0)
                                          {
                                            struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$134;
                                            return_value_ServerConfiguration_get_realmsTable$134=ServerConfiguration_get_realmsTable(cfg);
                                            signed int return_value_ServerConfiguration_get_realmsNumber$135;
                                            return_value_ServerConfiguration_get_realmsNumber$135=ServerConfiguration_get_realmsNumber(cfg);
                                            ServerRealm_set_sMaxIdle(return_value_ServerConfiguration_get_realmsTable$134[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$135 - 1)], helpbuf2);
                                          }

                                          else
                                          {
                                            unsigned long int parsefile$$1$$9$$3$$34$$__s1_len;
                                            unsigned long int parsefile$$1$$9$$3$$34$$__s2_len;
                                            signed int return_value___builtin_strcmp$170;
                                            return_value___builtin_strcmp$170=__builtin_strcmp(helpbuf1, "clients");
                                            tmp_statement_expression$169 = return_value___builtin_strcmp$170;
                                            if(tmp_statement_expression$169 == 0)
                                            {
                                              struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$136;
                                              return_value_ServerConfiguration_get_realmsTable$136=ServerConfiguration_get_realmsTable(cfg);
                                              signed int return_value_ServerConfiguration_get_realmsNumber$137;
                                              return_value_ServerConfiguration_get_realmsNumber$137=ServerConfiguration_get_realmsNumber(cfg);
                                              ServerRealm_set_sClientsLimit(return_value_ServerConfiguration_get_realmsTable$136[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$137 - 1)], helpbuf2);
                                            }

                                            else
                                            {
                                              unsigned long int parsefile$$1$$9$$3$$36$$__s1_len;
                                              unsigned long int parsefile$$1$$9$$3$$36$$__s2_len;
                                              signed int return_value___builtin_strcmp$168;
                                              return_value___builtin_strcmp$168=__builtin_strcmp(helpbuf1, "raclients");
                                              tmp_statement_expression$167 = return_value___builtin_strcmp$168;
                                              if(tmp_statement_expression$167 == 0)
                                              {
                                                struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$138;
                                                return_value_ServerConfiguration_get_realmsTable$138=ServerConfiguration_get_realmsTable(cfg);
                                                signed int return_value_ServerConfiguration_get_realmsNumber$139;
                                                return_value_ServerConfiguration_get_realmsNumber$139=ServerConfiguration_get_realmsNumber(cfg);
                                                ServerRealm_set_sRaClientsLimit(return_value_ServerConfiguration_get_realmsTable$138[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$139 - 1)], helpbuf2);
                                              }

                                              else
                                              {
                                                unsigned long int parsefile$$1$$9$$3$$38$$__s1_len;
                                                unsigned long int parsefile$$1$$9$$3$$38$$__s2_len;
                                                signed int return_value___builtin_strcmp$166;
                                                return_value___builtin_strcmp$166=__builtin_strcmp(helpbuf1, "usrpcli");
                                                tmp_statement_expression$165 = return_value___builtin_strcmp$166;
                                                if(tmp_statement_expression$165 == 0)
                                                {
                                                  struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$140;
                                                  return_value_ServerConfiguration_get_realmsTable$140=ServerConfiguration_get_realmsTable(cfg);
                                                  signed int return_value_ServerConfiguration_get_realmsNumber$141;
                                                  return_value_ServerConfiguration_get_realmsNumber$141=ServerConfiguration_get_realmsNumber(cfg);
                                                  ServerRealm_set_sUsersPerClient(return_value_ServerConfiguration_get_realmsTable$140[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$141 - 1)], helpbuf2);
                                                }

                                                else
                                                {
                                                  unsigned long int parsefile$$1$$9$$3$$40$$__s1_len;
                                                  unsigned long int parsefile$$1$$9$$3$$40$$__s2_len;
                                                  signed int return_value___builtin_strcmp$164;
                                                  return_value___builtin_strcmp$164=__builtin_strcmp(helpbuf1, "climode");
                                                  tmp_statement_expression$163 = return_value___builtin_strcmp$164;
                                                  if(tmp_statement_expression$163 == 0)
                                                  {
                                                    struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$142;
                                                    return_value_ServerConfiguration_get_realmsTable$142=ServerConfiguration_get_realmsTable(cfg);
                                                    signed int return_value_ServerConfiguration_get_realmsNumber$143;
                                                    return_value_ServerConfiguration_get_realmsNumber$143=ServerConfiguration_get_realmsNumber(cfg);
                                                    ServerRealm_set_sClientMode(return_value_ServerConfiguration_get_realmsTable$142[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$143 - 1)], helpbuf2);
                                                  }

                                                  else
                                                  {
                                                    unsigned long int parsefile$$1$$9$$3$$42$$__s1_len;
                                                    unsigned long int parsefile$$1$$9$$3$$42$$__s2_len;
                                                    signed int return_value___builtin_strcmp$162;
                                                    return_value___builtin_strcmp$162=__builtin_strcmp(helpbuf1, "proto");
                                                    tmp_statement_expression$161 = return_value___builtin_strcmp$162;
                                                    if(tmp_statement_expression$161 == 0)
                                                    {
                                                      struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$144;
                                                      return_value_ServerConfiguration_get_realmsTable$144=ServerConfiguration_get_realmsTable(cfg);
                                                      signed int return_value_ServerConfiguration_get_realmsNumber$145;
                                                      return_value_ServerConfiguration_get_realmsNumber$145=ServerConfiguration_get_realmsNumber(cfg);
                                                      char return_value_ServerRealm_get_realmType$146;
                                                      return_value_ServerRealm_get_realmType$146=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable$144[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$145 - 1)]);
                                                      if(!((1 & (signed int)return_value_ServerRealm_get_realmType$146) == 0))
                                                        return cfg;

                                                      unsigned long int parsefile$$1$$9$$3$$43$$2$$__s1_len;
                                                      unsigned long int parsefile$$1$$9$$3$$43$$2$$__s2_len;
                                                      signed int return_value___builtin_strcmp$160;
                                                      return_value___builtin_strcmp$160=__builtin_strcmp(helpbuf2, "tcp");
                                                      tmp_statement_expression$159 = return_value___builtin_strcmp$160;
                                                      if(tmp_statement_expression$159 == 0)
                                                      {
                                                        struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$147;
                                                        return_value_ServerConfiguration_get_realmsTable$147=ServerConfiguration_get_realmsTable(cfg);
                                                        signed int return_value_ServerConfiguration_get_realmsNumber$148;
                                                        return_value_ServerConfiguration_get_realmsNumber$148=ServerConfiguration_get_realmsNumber(cfg);
                                                        char return_value_ServerRealm_get_realmType$149;
                                                        return_value_ServerRealm_get_realmType$149=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable$147[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$148 - 1)]);
                                                        temp = (signed int)return_value_ServerRealm_get_realmType$149;
                                                        temp = temp | 1;
                                                        struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$150;
                                                        return_value_ServerConfiguration_get_realmsTable$150=ServerConfiguration_get_realmsTable(cfg);
                                                        signed int return_value_ServerConfiguration_get_realmsNumber$151;
                                                        return_value_ServerConfiguration_get_realmsNumber$151=ServerConfiguration_get_realmsNumber(cfg);
                                                        ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable$150[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$151 - 1)], (char)temp);
                                                      }

                                                      else
                                                      {
                                                        unsigned long int __s1_len;
                                                        unsigned long int __s2_len;
                                                        signed int return_value___builtin_strcmp$158;
                                                        return_value___builtin_strcmp$158=__builtin_strcmp(helpbuf2, "udp");
                                                        tmp_statement_expression$157 = return_value___builtin_strcmp$158;
                                                        if(tmp_statement_expression$157 == 0)
                                                        {
                                                          struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$152;
                                                          return_value_ServerConfiguration_get_realmsTable$152=ServerConfiguration_get_realmsTable(cfg);
                                                          signed int return_value_ServerConfiguration_get_realmsNumber$153;
                                                          return_value_ServerConfiguration_get_realmsNumber$153=ServerConfiguration_get_realmsNumber(cfg);
                                                          char return_value_ServerRealm_get_realmType$154;
                                                          return_value_ServerRealm_get_realmType$154=ServerRealm_get_realmType(return_value_ServerConfiguration_get_realmsTable$152[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$153 - 1)]);
                                                          temp = (signed int)return_value_ServerRealm_get_realmType$154;
                                                          temp = temp | 3;
                                                          struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$155;
                                                          return_value_ServerConfiguration_get_realmsTable$155=ServerConfiguration_get_realmsTable(cfg);
                                                          signed int return_value_ServerConfiguration_get_realmsNumber$156;
                                                          return_value_ServerConfiguration_get_realmsNumber$156=ServerConfiguration_get_realmsNumber(cfg);
                                                          ServerRealm_set_realmType(return_value_ServerConfiguration_get_realmsTable$155[(signed long int)(return_value_ServerConfiguration_get_realmsNumber$156 - 1)], (char)temp);
                                                        }

                                                        else
                                                          return cfg;
                                                      }
                                                    }

                                                    else
                                                      return cfg;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }

          memset((void *)buff, 0, (unsigned long int)256);
        }
      }
      while((_Bool)1);
      fclose(file);
      *status = 0;
      return cfg;
    }
  }
}

// read_message
// file http_proxy_functions.c line 281
signed int read_message(signed int fd, signed int length, struct anonymous$27 *client, char *tab, signed int ptr)
{
  signed int j = 0;
  signed int tmp = 0;
  while(!(j >= length))
    if(!(client->toreceive >= client->curreceived + length + -j))
    {
      if(client->toreceive + -client->curreceived >= 1)
      {
        writen(fd, (unsigned char *)(tab + (signed long int)ptr + (signed long int)j), client->toreceive - client->curreceived);
        j = j + (client->toreceive - client->curreceived);
        client->curreceived = client->curreceived + (client->toreceive - client->curreceived);
      }

      if((signed int)client->read_state == 0)
        switch((signed int)tab[(signed long int)(ptr + j)])
        {
          case 77:
          {
            if(length >= 5 + j)
            {
              memcpy((void *)&tmp, (const void *)&tab[(signed long int)(ptr + j + 1)], (unsigned long int)4);
              unsigned int return_value___bswap_32$1;
              return_value___bswap_32$1=__bswap_32((unsigned int)tmp);
              client->toreceive = (signed int)return_value___bswap_32$1;
              client->curreceived = 0;
              j = j + 5;
            }

            else
              if(!(1 + j >= length))
              {
                memcpy((void *)client->readed_length, (const void *)&tab[(signed long int)(ptr + j + 1)], (unsigned long int)((length - j) - 1));
                client->read_state = (char)(length - j);
                j = j + (length - j);
              }

              else
              {
                j = j + 1;
                client->read_state = (char)1;
              }
            break;
          }
          case 84:
          {
            j = j + 1;
            break;
          }
          case 65:
          {
            j = j + 1;
            if((signed int)client->state == 0)
              client->state = (char)4;

            break;
          }
          default:
            return 1;
        }

      else
        if(length >= 5 + j + -((signed int)client->read_state))
        {
          memcpy((void *)&client->readed_length[(signed long int)((signed int)client->read_state - 1)], (const void *)&tab[(signed long int)(ptr + j)], (unsigned long int)(5 - (signed int)client->read_state));
          memcpy((void *)&tmp, (const void *)client->readed_length, (unsigned long int)4);
          unsigned int return_value___bswap_32$2;
          return_value___bswap_32$2=__bswap_32((unsigned int)tmp);
          client->toreceive = (signed int)return_value___bswap_32$2;
          client->curreceived = 0;
          j = j + (5 - (signed int)client->read_state);
          client->read_state = (char)0;
        }

        else
        {
          memcpy((void *)&client->readed_length[(signed long int)((signed int)client->read_state - 1)], (const void *)&tab[(signed long int)(ptr + j)], (unsigned long int)(length - j));
          client->read_state = client->read_state + (char)(length - j);
          j = j + (length - j);
        }
    }

    else
      if(length + -j >= 1)
      {
        client->curreceived = client->curreceived + (length - j);
        writen(fd, (unsigned char *)(tab + (signed long int)ptr + (signed long int)j), length - j);
        j = j + (length - j);
      }

  return 0;
}

// readn
// file network.h line 47
signed int readn(signed int fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    signed long int return_value_read$1;
    return_value_read$1=read(fd, (void *)(buf + (signed long int)sent), (unsigned long int)(amount - sent));
    n = (signed int)return_value_read$1;
    if(!(n == -1))
      sent = sent + n;

    if(n == 0)
      return 0;

    if(n == -1)
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      if(!(*return_value___errno_location$2 == 11))
        return 0;

    }

  }
  return amount;
}

// remember_mainthread
// file thread_management.h line 26
void remember_mainthread(void)
{
  mainthread=pthread_self();
}

// remove_client
// file server_remove.h line 27
void remove_client(struct anonymous$5 *ptr, signed int client, struct anonymous$22 *set, struct anonymous$22 *wset, struct anonymous$16 *scheduler)
{
  signed int i;
  struct anonymous$13 *task;
  struct anonymous$3 **return_value_ServerRealm_get_clientsTable$17;
  return_value_ServerRealm_get_clientsTable$17=ServerRealm_get_clientsTable(ptr);
  char return_value_ConnectClient_get_state$18;
  return_value_ConnectClient_get_state$18=ConnectClient_get_state(return_value_ServerRealm_get_clientsTable$17[(signed long int)client]);
  signed int return_value_ServerRealm_get_usersLimit$1;
  if((signed int)return_value_ConnectClient_get_state$18 == 3)
  {
    i = 0;
    do
    {
      return_value_ServerRealm_get_usersLimit$1=ServerRealm_get_usersLimit(ptr);
      if(i >= return_value_ServerRealm_get_usersLimit$1)
        break;

      struct anonymous$4 **return_value_ServerRealm_get_usersTable$15;
      return_value_ServerRealm_get_usersTable$15=ServerRealm_get_usersTable(ptr);
      signed int return_value_ConnectUser_get_whatClient$16;
      return_value_ConnectUser_get_whatClient$16=ConnectUser_get_whatClient(return_value_ServerRealm_get_usersTable$15[(signed long int)i]);
      if(return_value_ConnectUser_get_whatClient$16 == client)
      {
        struct anonymous$4 **return_value_ServerRealm_get_usersTable$13;
        return_value_ServerRealm_get_usersTable$13=ServerRealm_get_usersTable(ptr);
        char return_value_ConnectUser_get_state$14;
        return_value_ConnectUser_get_state$14=ConnectUser_get_state(return_value_ServerRealm_get_usersTable$13[(signed long int)i]);
        if(!((signed int)return_value_ConnectUser_get_state$14 == 0))
        {
          struct anonymous$4 **return_value_ServerRealm_get_usersTable$2;
          return_value_ServerRealm_get_usersTable$2=ServerRealm_get_usersTable(ptr);
          ConnectUser_set_state(return_value_ServerRealm_get_usersTable$2[(signed long int)i], (char)0);
          struct anonymous$4 **return_value_ServerRealm_get_usersTable$3;
          return_value_ServerRealm_get_usersTable$3=ServerRealm_get_usersTable(ptr);
          signed int return_value_ConnectUser_get_connFd$4;
          return_value_ConnectUser_get_connFd$4=ConnectUser_get_connFd(return_value_ServerRealm_get_usersTable$3[(signed long int)i]);
          struct anonymous$4 **return_value_ServerRealm_get_usersTable$5;
          return_value_ServerRealm_get_usersTable$5=ServerRealm_get_usersTable(ptr);
          signed int return_value_ConnectUser_get_connFd$6;
          return_value_ConnectUser_get_connFd$6=ConnectUser_get_connFd(return_value_ServerRealm_get_usersTable$5[(signed long int)i]);
          set->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$4 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = set->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$4 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$6 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
          struct anonymous$4 **return_value_ServerRealm_get_usersTable$7;
          return_value_ServerRealm_get_usersTable$7=ServerRealm_get_usersTable(ptr);
          signed int return_value_ConnectUser_get_connFd$8;
          return_value_ConnectUser_get_connFd$8=ConnectUser_get_connFd(return_value_ServerRealm_get_usersTable$7[(signed long int)i]);
          struct anonymous$4 **return_value_ServerRealm_get_usersTable$9;
          return_value_ServerRealm_get_usersTable$9=ServerRealm_get_usersTable(ptr);
          signed int return_value_ConnectUser_get_connFd$10;
          return_value_ConnectUser_get_connFd$10=ConnectUser_get_connFd(return_value_ServerRealm_get_usersTable$9[(signed long int)i]);
          wset->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$8 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = wset->__fds_bits[(signed long int)(return_value_ConnectUser_get_connFd$8 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectUser_get_connFd$10 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
          struct anonymous$4 **return_value_ServerRealm_get_usersTable$11;
          return_value_ServerRealm_get_usersTable$11=ServerRealm_get_usersTable(ptr);
          signed int return_value_ConnectUser_get_connFd$12;
          return_value_ConnectUser_get_connFd$12=ConnectUser_get_connFd(return_value_ServerRealm_get_usersTable$11[(signed long int)i]);
          close(return_value_ConnectUser_get_connFd$12);
          ServerRealm_decrease_connectedUsers(ptr);
        }

      }

      i = i + 1;
    }
    while((_Bool)1);
  }

  i = 0;
  struct anonymous$3 **return_value_ServerRealm_get_clientsTable$19;
  signed int return_value_ConnectClient_get_limit$20;
  do
  {
    return_value_ServerRealm_get_clientsTable$19=ServerRealm_get_clientsTable(ptr);
    return_value_ConnectClient_get_limit$20=ConnectClient_get_limit(return_value_ServerRealm_get_clientsTable$19[(signed long int)client]);
    if(i >= return_value_ConnectClient_get_limit$20)
      break;

    struct anonymous$3 **return_value_ServerRealm_get_clientsTable$21;
    return_value_ServerRealm_get_clientsTable$21=ServerRealm_get_clientsTable(ptr);
    signed int *return_value_ConnectClient_get_users$22;
    return_value_ConnectClient_get_users$22=ConnectClient_get_users(return_value_ServerRealm_get_clientsTable$21[(signed long int)client]);
    return_value_ConnectClient_get_users$22[(signed long int)i] = -1;
    i = i + 1;
  }
  while((_Bool)1);
  signed int return_value_ServerRealm_get_clientsLimit$30;
  return_value_ServerRealm_get_clientsLimit$30=ServerRealm_get_clientsLimit(ptr);
  char return_value_ServerRealm_get_basePortOn$29;
  if(!(return_value_ServerRealm_get_clientsLimit$30 == client))
  {
    return_value_ServerRealm_get_basePortOn$29=ServerRealm_get_basePortOn(ptr);
    if((signed int)return_value_ServerRealm_get_basePortOn$29 == 1)
    {
      struct anonymous$3 **return_value_ServerRealm_get_clientsTable$23;
      return_value_ServerRealm_get_clientsTable$23=ServerRealm_get_clientsTable(ptr);
      signed int return_value_ConnectClient_get_listenFd$24;
      return_value_ConnectClient_get_listenFd$24=ConnectClient_get_listenFd(return_value_ServerRealm_get_clientsTable$23[(signed long int)client]);
      close(return_value_ConnectClient_get_listenFd$24);
      struct anonymous$3 **return_value_ServerRealm_get_clientsTable$25;
      return_value_ServerRealm_get_clientsTable$25=ServerRealm_get_clientsTable(ptr);
      signed int return_value_ConnectClient_get_listenFd$26;
      return_value_ConnectClient_get_listenFd$26=ConnectClient_get_listenFd(return_value_ServerRealm_get_clientsTable$25[(signed long int)client]);
      struct anonymous$3 **return_value_ServerRealm_get_clientsTable$27;
      return_value_ServerRealm_get_clientsTable$27=ServerRealm_get_clientsTable(ptr);
      signed int return_value_ConnectClient_get_listenFd$28;
      return_value_ConnectClient_get_listenFd$28=ConnectClient_get_listenFd(return_value_ServerRealm_get_clientsTable$27[(signed long int)client]);
      set->__fds_bits[(signed long int)(return_value_ConnectClient_get_listenFd$26 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = set->__fds_bits[(signed long int)(return_value_ConnectClient_get_listenFd$26 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_ConnectClient_get_listenFd$28 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    }

  }

  struct anonymous$3 **return_value_ServerRealm_get_clientsTable$31;
  return_value_ServerRealm_get_clientsTable$31=ServerRealm_get_clientsTable(ptr);
  ConnectClient_set_sClientId(return_value_ServerRealm_get_clientsTable$31[(signed long int)client], (char *)(void *)0);
  struct anonymous$3 **return_value_ServerRealm_get_clientsTable$32;
  return_value_ServerRealm_get_clientsTable$32=ServerRealm_get_clientsTable(ptr);
  ConnectClient_set_connected(return_value_ServerRealm_get_clientsTable$32[(signed long int)client], 0);
  struct anonymous$3 **return_value_ServerRealm_get_clientsTable$33;
  return_value_ServerRealm_get_clientsTable$33=ServerRealm_get_clientsTable(ptr);
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$34;
  return_value_ConnectClient_get_sslFd$34=ConnectClient_get_sslFd(return_value_ServerRealm_get_clientsTable$33[(signed long int)client]);
  signed int return_value_SslFd_get_fd$35;
  return_value_SslFd_get_fd$35=SslFd_get_fd(return_value_ConnectClient_get_sslFd$34);
  close(return_value_SslFd_get_fd$35);
  struct anonymous$3 **return_value_ServerRealm_get_clientsTable$36;
  return_value_ServerRealm_get_clientsTable$36=ServerRealm_get_clientsTable(ptr);
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$37;
  return_value_ConnectClient_get_sslFd$37=ConnectClient_get_sslFd(return_value_ServerRealm_get_clientsTable$36[(signed long int)client]);
  signed int return_value_SslFd_get_fd$38;
  return_value_SslFd_get_fd$38=SslFd_get_fd(return_value_ConnectClient_get_sslFd$37);
  struct anonymous$3 **return_value_ServerRealm_get_clientsTable$39;
  return_value_ServerRealm_get_clientsTable$39=ServerRealm_get_clientsTable(ptr);
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$40;
  return_value_ConnectClient_get_sslFd$40=ConnectClient_get_sslFd(return_value_ServerRealm_get_clientsTable$39[(signed long int)client]);
  signed int return_value_SslFd_get_fd$41;
  return_value_SslFd_get_fd$41=SslFd_get_fd(return_value_ConnectClient_get_sslFd$40);
  set->__fds_bits[(signed long int)(return_value_SslFd_get_fd$38 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = set->__fds_bits[(signed long int)(return_value_SslFd_get_fd$38 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_SslFd_get_fd$41 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  if(!(scheduler == ((struct anonymous$16 *)NULL)))
  {
    struct anonymous$3 **return_value_ServerRealm_get_clientsTable$43;
    return_value_ServerRealm_get_clientsTable$43=ServerRealm_get_clientsTable(ptr);
    task=ConnectClient_get_task(return_value_ServerRealm_get_clientsTable$43[(signed long int)client]);
    if(!(task == ((struct anonymous$13 *)NULL)))
    {
      TaskScheduler_removeTask(scheduler, task);
      struct anonymous$3 **return_value_ServerRealm_get_clientsTable$42;
      return_value_ServerRealm_get_clientsTable$42=ServerRealm_get_clientsTable(ptr);
      ConnectClient_set_task(return_value_ServerRealm_get_clientsTable$42[(signed long int)client], (struct anonymous$13 *)(void *)0);
    }

  }

  struct anonymous$3 **return_value_ServerRealm_get_clientsTable$44;
  return_value_ServerRealm_get_clientsTable$44=ServerRealm_get_clientsTable(ptr);
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$45;
  return_value_ConnectClient_get_sslFd$45=ConnectClient_get_sslFd(return_value_ServerRealm_get_clientsTable$44[(signed long int)client]);
  struct ssl_st *return_value_SslFd_get_ssl$46;
  return_value_SslFd_get_ssl$46=SslFd_get_ssl(return_value_ConnectClient_get_sslFd$45);
  SSL_clear(return_value_SslFd_get_ssl$46);
  struct anonymous$3 **return_value_ServerRealm_get_clientsTable$47;
  return_value_ServerRealm_get_clientsTable$47=ServerRealm_get_clientsTable(ptr);
  ConnectClient_set_state(return_value_ServerRealm_get_clientsTable$47[(signed long int)client], (char)0);
  ServerRealm_decrease_connectedClients(ptr);
}

// remove_raclient
// file server_remove.h line 28
void remove_raclient(struct anonymous$5 *ptr, signed int client, struct anonymous$22 *set, struct anonymous$22 *wset, struct anonymous$16 *scheduler)
{
  signed int i;
  struct anonymous$13 *task;
  i = 0;
  struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$1;
  signed int return_value_ConnectClient_get_limit$2;
  do
  {
    return_value_ServerRealm_get_raClientsTable$1=ServerRealm_get_raClientsTable(ptr);
    return_value_ConnectClient_get_limit$2=ConnectClient_get_limit(return_value_ServerRealm_get_raClientsTable$1[(signed long int)client]);
    if(i >= return_value_ConnectClient_get_limit$2)
      break;

    struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$3;
    return_value_ServerRealm_get_raClientsTable$3=ServerRealm_get_raClientsTable(ptr);
    signed int *return_value_ConnectClient_get_users$4;
    return_value_ConnectClient_get_users$4=ConnectClient_get_users(return_value_ServerRealm_get_raClientsTable$3[(signed long int)client]);
    return_value_ConnectClient_get_users$4[(signed long int)i] = -1;
    i = i + 1;
  }
  while((_Bool)1);
  struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$5;
  return_value_ServerRealm_get_raClientsTable$5=ServerRealm_get_raClientsTable(ptr);
  ConnectClient_set_sClientId(return_value_ServerRealm_get_raClientsTable$5[(signed long int)client], (char *)(void *)0);
  struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$6;
  return_value_ServerRealm_get_raClientsTable$6=ServerRealm_get_raClientsTable(ptr);
  ConnectClient_set_connected(return_value_ServerRealm_get_raClientsTable$6[(signed long int)client], 0);
  struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$7;
  return_value_ServerRealm_get_raClientsTable$7=ServerRealm_get_raClientsTable(ptr);
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$8;
  return_value_ConnectClient_get_sslFd$8=ConnectClient_get_sslFd(return_value_ServerRealm_get_raClientsTable$7[(signed long int)client]);
  signed int return_value_SslFd_get_fd$9;
  return_value_SslFd_get_fd$9=SslFd_get_fd(return_value_ConnectClient_get_sslFd$8);
  close(return_value_SslFd_get_fd$9);
  struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$10;
  return_value_ServerRealm_get_raClientsTable$10=ServerRealm_get_raClientsTable(ptr);
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$11;
  return_value_ConnectClient_get_sslFd$11=ConnectClient_get_sslFd(return_value_ServerRealm_get_raClientsTable$10[(signed long int)client]);
  signed int return_value_SslFd_get_fd$12;
  return_value_SslFd_get_fd$12=SslFd_get_fd(return_value_ConnectClient_get_sslFd$11);
  struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$13;
  return_value_ServerRealm_get_raClientsTable$13=ServerRealm_get_raClientsTable(ptr);
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$14;
  return_value_ConnectClient_get_sslFd$14=ConnectClient_get_sslFd(return_value_ServerRealm_get_raClientsTable$13[(signed long int)client]);
  signed int return_value_SslFd_get_fd$15;
  return_value_SslFd_get_fd$15=SslFd_get_fd(return_value_ConnectClient_get_sslFd$14);
  set->__fds_bits[(signed long int)(return_value_SslFd_get_fd$12 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = set->__fds_bits[(signed long int)(return_value_SslFd_get_fd$12 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << return_value_SslFd_get_fd$15 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  if(!(scheduler == ((struct anonymous$16 *)NULL)))
  {
    struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$17;
    return_value_ServerRealm_get_raClientsTable$17=ServerRealm_get_raClientsTable(ptr);
    task=ConnectClient_get_task(return_value_ServerRealm_get_raClientsTable$17[(signed long int)client]);
    if(!(task == ((struct anonymous$13 *)NULL)))
    {
      TaskScheduler_removeTask(scheduler, task);
      struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$16;
      return_value_ServerRealm_get_raClientsTable$16=ServerRealm_get_raClientsTable(ptr);
      ConnectClient_set_task(return_value_ServerRealm_get_raClientsTable$16[(signed long int)client], (struct anonymous$13 *)(void *)0);
    }

  }

  struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$18;
  return_value_ServerRealm_get_raClientsTable$18=ServerRealm_get_raClientsTable(ptr);
  struct anonymous$1 *return_value_ConnectClient_get_sslFd$19;
  return_value_ConnectClient_get_sslFd$19=ConnectClient_get_sslFd(return_value_ServerRealm_get_raClientsTable$18[(signed long int)client]);
  struct ssl_st *return_value_SslFd_get_ssl$20;
  return_value_SslFd_get_ssl$20=SslFd_get_ssl(return_value_ConnectClient_get_sslFd$19);
  SSL_clear(return_value_SslFd_get_ssl$20);
  ServerRealm_decrease_connectedClients(ptr);
  struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$21;
  return_value_ServerRealm_get_raClientsTable$21=ServerRealm_get_raClientsTable(ptr);
  char return_value_ConnectClient_get_state$22;
  return_value_ConnectClient_get_state$22=ConnectClient_get_state(return_value_ServerRealm_get_raClientsTable$21[(signed long int)client]);
  if((signed int)return_value_ConnectClient_get_state$22 == 3)
    ServerRealm_decrease_connectedRaClients(ptr);

  struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$23;
  return_value_ServerRealm_get_raClientsTable$23=ServerRealm_get_raClientsTable(ptr);
  ConnectClient_set_state(return_value_ServerRealm_get_raClientsTable$23[(signed long int)client], (char)0);
}

// resetcg
// file stats.c line 84
void resetcg(void)
{
  compressgained = (signed long int)0;
}

// send_adm_message
// file server_remoteadmin.c line 158
static void send_adm_message(char type, struct anonymous$1 *master, unsigned char *buff, unsigned char st)
{
  signed int n;
  if(newmessage == 0)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen((char *)&buff[(signed long int)5]);
    n = (signed int)return_value_strlen$1;
  }

  else
    n = 0;
  buff[(signed long int)0] = (unsigned char)15;
  buff[(signed long int)1] = st;
  buff[(signed long int)2] = (unsigned char)0;
  buff[(signed long int)3] = (unsigned char)(n >> 8);
  buff[(signed long int)4] = (unsigned char)n;
  SslFd_send_message(type, master, buff, n + 5);
}

// serve_admin
// file server_remoteadmin.h line 35
signed int serve_admin(struct anonymous$2 *config, signed int realm, signed int client, unsigned char *buff)
{
  signed int length;
  signed int n;
  signed int i;
  signed int j;
  signed int ret;
  signed long int now;
  signed long int tmp;
  struct llnode *llptr;
  struct alnode *alptr;
  char olddf[51l];
  char newdf[51l];
  struct anonymous$3 *cpointer;
  struct anonymous$4 *upointer;
  struct anonymous$5 *pointer;
  struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$1;
  return_value_ServerConfiguration_get_realmsTable$1=ServerConfiguration_get_realmsTable(config);
  pointer = return_value_ServerConfiguration_get_realmsTable$1[(signed long int)realm];
  char type;
  char return_value_ServerRealm_get_realmType$2;
  return_value_ServerRealm_get_realmType$2=ServerRealm_get_realmType(pointer);
  type = (char)((signed int)return_value_ServerRealm_get_realmType$2 | 4 | 8);
  struct anonymous$1 *master;
  struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$3;
  return_value_ServerRealm_get_raClientsTable$3=ServerRealm_get_raClientsTable(pointer);
  master=ConnectClient_get_sslFd(return_value_ServerRealm_get_raClientsTable$3[(signed long int)client]);
  newdf[(signed long int)50] = (char)0;
  olddf[(signed long int)50] = newdf[(signed long int)50];
  length = (signed int)buff[(signed long int)3];
  length = length << 8;
  length = length + (signed int)buff[(signed long int)4];
  time(&now);
  char *return_value_get_realmname$4;
  signed int return_value_parse_cmd$5;
  signed int return_value_ServerConfiguration_get_realmsNumber$6;
  char *return_value_ServerConfiguration_get_certificateFile$7;
  char *return_value_ServerConfiguration_get_keysFile$8;
  signed long int return_value_ServerConfiguration_get_startTime$9;
  signed long int return_value_getcg$10;
  char *return_value_getdateformat$11;
  signed int return_value_ServerConfiguration_get_realmsNumber$12;
  signed int return_value_ServerRealm_get_userClientPairs$25;
  _Bool tmp_if_expr$41;
  char return_value_ServerRealm_get_realmType$40;
  signed int return_value_ServerConfiguration_get_realmsNumber$70;
  signed int return_value_ServerRealm_get_clientsLimit$44;
  char *tmp_if_expr$55;
  char *return_value_ConnectClient_get_sClientId$54;
  signed int return_value_ServerConfiguration_get_realmsNumber$92;
  signed int return_value_ServerRealm_get_usersLimit$72;
  char *return_value_get_realmname$93;
  char *return_value_get_raclientname$94;
  signed int return_value_ServerConfiguration_get_realmsNumber$98;
  signed int return_value_ServerConfiguration_get_realmsNumber$107;
  struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$102;
  signed int return_value_ServerRealm_get_clientsLimit$103;
  signed int return_value_ServerConfiguration_get_realmsNumber$111;
  char *return_value_getdateformat$112;
  signed int return_value_ServerConfiguration_get_realmsNumber$113;
  _Bool tmp_if_expr$122;
  char return_value_ConnectUser_get_state$121;
  _Bool tmp_if_expr$124;
  char return_value_ConnectUser_get_state$123;
  signed int return_value_ServerConfiguration_get_realmsNumber$125;
  switch((signed int)buff[(signed long int)1])
  {
    case 1:
    {
      n=SslFd_get_message(type, master, buff, length);
      buff[(signed long int)n] = (unsigned char)0;
      return_value_get_realmname$4=get_realmname(config, realm);
      aflog((char)8, (char)8, "realm[%s]: admin: message length = %d [%s]", return_value_get_realmname$4, n, buff);
      return_value_parse_cmd$5=parse_cmd(buff, &ret);
      switch(return_value_parse_cmd$5)
      {
        case 1:
        {
          add_to_message(buff, "AFSERVER v0.8.4");
          add_to_message(buff, "\nValid commands are:");
          add_to_message(buff, "  help                 display help");
          add_to_message(buff, "  lcmd                 lists available commands");
          add_to_message(buff, "  info                 prints info about server");
          add_to_message(buff, "  rshow                display realms");
          add_to_message(buff, "  cshow X              display clients in X realm");
          add_to_message(buff, "  ushow X              display users in X realm");
          add_to_message(buff, "  quit                 quit connection");
          add_to_message(buff, "  timeout N X          set timeout value in X realm");
          add_to_message(buff, "  audit {0|1} X        set audit mode in X realm");
          add_to_message(buff, "  dnslookups {0|1} X   set dnslookups mode in X realm");
          add_to_message(buff, "  dateformat S         set dateformat");
          add_to_message(buff, "  kuser S              kick user named S");
          add_to_message(buff, "  kclient N            kick client with number N");
          send_adm_message(type, master, buff, (unsigned char)3);
          break;
        }
        case 2:
        {
          add_to_message(buff, "help");
          add_to_message(buff, "lcmd");
          add_to_message(buff, "info");
          add_to_message(buff, "rshow");
          add_to_message(buff, "cshow");
          add_to_message(buff, "ushow");
          add_to_message(buff, "quit");
          add_to_message(buff, "timeout");
          add_to_message(buff, "audit");
          add_to_message(buff, "dnslookups");
          add_to_message(buff, "dateformat");
          add_to_message(buff, "kuser");
          add_to_message(buff, "kclient");
          send_adm_message(type, master, buff, (unsigned char)3);
          break;
        }
        case 3:
        {
          add_to_message(buff, "Version: v0.8.4");
          return_value_ServerConfiguration_get_realmsNumber$6=ServerConfiguration_get_realmsNumber(config);
          add_to_message(buff, "Realms: %d", return_value_ServerConfiguration_get_realmsNumber$6);
          return_value_ServerConfiguration_get_certificateFile$7=ServerConfiguration_get_certificateFile(config);
          add_to_message(buff, "Certificate: %s", return_value_ServerConfiguration_get_certificateFile$7);
          return_value_ServerConfiguration_get_keysFile$8=ServerConfiguration_get_keysFile(config);
          add_to_message(buff, "Key: %s", return_value_ServerConfiguration_get_keysFile$8);
          llptr=getloglisthead();
          i = 0;
          for( ; !(llptr == ((struct llnode *)NULL)); i = i + 1)
          {
            add_to_message(buff, "log[%d]: %s", i, llptr->cmdline);
            llptr = llptr->next;
          }
          return_value_ServerConfiguration_get_startTime$9=ServerConfiguration_get_startTime(config);
          tmp = now - return_value_ServerConfiguration_get_startTime$9;
          add_uptime_to_message(buff, "Uptime", tmp);
          return_value_getcg$10=getcg();
          add_to_message(buff, "Cg: %ld B", return_value_getcg$10);
          return_value_getdateformat$11=getdateformat();
          add_to_message(buff, "Dateformat: %s", return_value_getdateformat$11);
          send_adm_message(type, master, buff, (unsigned char)3);
          break;
        }
        case 4:
        {
          i = 0;
          do
          {
            return_value_ServerConfiguration_get_realmsNumber$12=ServerConfiguration_get_realmsNumber(config);
            if(i >= return_value_ServerConfiguration_get_realmsNumber$12)
              break;

            struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$13;
            return_value_ServerConfiguration_get_realmsTable$13=ServerConfiguration_get_realmsTable(config);
            pointer = return_value_ServerConfiguration_get_realmsTable$13[(signed long int)i];
            char *return_value_get_realmname$14;
            return_value_get_realmname$14=get_realmname(config, i);
            add_to_message(buff, "\nRealm[%s]:", return_value_get_realmname$14);
            char *return_value_ServerRealm_get_hostName$15;
            return_value_ServerRealm_get_hostName$15=ServerRealm_get_hostName(pointer);
            add_to_message(buff, "hostname: %s", return_value_ServerRealm_get_hostName$15);
            signed int return_value_ServerRealm_get_connectedUsers$16;
            return_value_ServerRealm_get_connectedUsers$16=ServerRealm_get_connectedUsers(pointer);
            signed int return_value_ServerRealm_get_usersLimit$17;
            return_value_ServerRealm_get_usersLimit$17=ServerRealm_get_usersLimit(pointer);
            add_to_message(buff, "users: %d (max: %d)", return_value_ServerRealm_get_connectedUsers$16, return_value_ServerRealm_get_usersLimit$17);
            signed int return_value_ServerRealm_get_connectedClients$18;
            return_value_ServerRealm_get_connectedClients$18=ServerRealm_get_connectedClients(pointer);
            signed int return_value_ServerRealm_get_connectedRaClients$19;
            return_value_ServerRealm_get_connectedRaClients$19=ServerRealm_get_connectedRaClients(pointer);
            signed int return_value_ServerRealm_get_clientsLimit$20;
            return_value_ServerRealm_get_clientsLimit$20=ServerRealm_get_clientsLimit(pointer);
            add_to_message(buff, "clients: %d (max: %d)", return_value_ServerRealm_get_connectedClients$18 - return_value_ServerRealm_get_connectedRaClients$19, return_value_ServerRealm_get_clientsLimit$20);
            signed int return_value_ServerRealm_get_connectedRaClients$21;
            return_value_ServerRealm_get_connectedRaClients$21=ServerRealm_get_connectedRaClients(pointer);
            signed int return_value_ServerRealm_get_raClientsLimit$22;
            return_value_ServerRealm_get_raClientsLimit$22=ServerRealm_get_raClientsLimit(pointer);
            add_to_message(buff, "raclients: %d (max: %d)", return_value_ServerRealm_get_connectedRaClients$21, return_value_ServerRealm_get_raClientsLimit$22);
            char *return_value_ServerRealm_get_sUsersPerClient$23;
            return_value_ServerRealm_get_sUsersPerClient$23=ServerRealm_get_sUsersPerClient(pointer);
            add_to_message(buff, "users per client: %s", return_value_ServerRealm_get_sUsersPerClient$23);
            signed int return_value_ServerRealm_get_userClientPairs$24;
            return_value_ServerRealm_get_userClientPairs$24=ServerRealm_get_userClientPairs(pointer);
            add_to_message(buff, "user-client pairs: %d", return_value_ServerRealm_get_userClientPairs$24);
            j = 0;
            do
            {
              return_value_ServerRealm_get_userClientPairs$25=ServerRealm_get_userClientPairs(pointer);
              if(j >= return_value_ServerRealm_get_userClientPairs$25)
                break;

              struct anonymous$7 **return_value_ServerRealm_get_usersClientsTable$26;
              return_value_ServerRealm_get_usersClientsTable$26=ServerRealm_get_usersClientsTable(pointer);
              char *return_value_UsrCli_get_listenPortName$27;
              return_value_UsrCli_get_listenPortName$27=UsrCli_get_listenPortName(return_value_ServerRealm_get_usersClientsTable$26[(signed long int)j]);
              struct anonymous$7 **return_value_ServerRealm_get_usersClientsTable$28;
              return_value_ServerRealm_get_usersClientsTable$28=ServerRealm_get_usersClientsTable(pointer);
              char *return_value_UsrCli_get_managePortName$29;
              return_value_UsrCli_get_managePortName$29=UsrCli_get_managePortName(return_value_ServerRealm_get_usersClientsTable$28[(signed long int)j]);
              add_to_message(buff, " pair[%d]: listenport: %s, manageport: %s", j, return_value_UsrCli_get_listenPortName$27, return_value_UsrCli_get_managePortName$29);
              j = j + 1;
            }
            while((_Bool)1);
            char *return_value_ServerRealm_get_sClientMode$30;
            return_value_ServerRealm_get_sClientMode$30=ServerRealm_get_sClientMode(pointer);
            add_to_message(buff, "climode: %s", return_value_ServerRealm_get_sClientMode$30);
            signed int return_value_ServerRealm_get_timeout$31;
            return_value_ServerRealm_get_timeout$31=ServerRealm_get_timeout(pointer);
            add_to_message(buff, "timeout: %d", return_value_ServerRealm_get_timeout$31);
            signed int return_value_ServerRealm_get_maxIdle$33;
            return_value_ServerRealm_get_maxIdle$33=ServerRealm_get_maxIdle(pointer);
            if(!(return_value_ServerRealm_get_maxIdle$33 == 0))
            {
              signed int return_value_ServerRealm_get_maxIdle$32;
              return_value_ServerRealm_get_maxIdle$32=ServerRealm_get_maxIdle(pointer);
              add_to_message(buff, "max idle: %d", return_value_ServerRealm_get_maxIdle$32);
            }

            else
              add_to_message(buff, "max idle: disabled");
            char return_value_ServerRealm_get_basePortOn$34;
            return_value_ServerRealm_get_basePortOn$34=ServerRealm_get_basePortOn(pointer);
            add_to_message(buff, "baseport: %s", return_value_ServerRealm_get_basePortOn$34 != 0 ? "yes" : "no");
            char return_value_ServerRealm_get_auditOn$35;
            return_value_ServerRealm_get_auditOn$35=ServerRealm_get_auditOn(pointer);
            add_to_message(buff, "audit: %s", return_value_ServerRealm_get_auditOn$35 != 0 ? "yes" : "no");
            char return_value_ServerRealm_get_dnsLookupsOn$36;
            return_value_ServerRealm_get_dnsLookupsOn$36=ServerRealm_get_dnsLookupsOn(pointer);
            add_to_message(buff, "dnslookups: %s", return_value_ServerRealm_get_dnsLookupsOn$36 != 0 ? "yes" : "no");
            char return_value_ServerRealm_get_realmType$37;
            return_value_ServerRealm_get_realmType$37=ServerRealm_get_realmType(pointer);
            char return_value_ServerRealm_get_realmType$38;
            return_value_ServerRealm_get_realmType$38=ServerRealm_get_realmType(pointer);
            char return_value_ServerRealm_get_realmType$39;
            return_value_ServerRealm_get_realmType$39=ServerRealm_get_realmType(pointer);
            if(!((1 & (signed int)return_value_ServerRealm_get_realmType$39) == 0))
            {
              return_value_ServerRealm_get_realmType$40=ServerRealm_get_realmType(pointer);
              tmp_if_expr$41 = !(((signed int)return_value_ServerRealm_get_realmType$40 & 2) != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$41 = (_Bool)0;
            add_to_message(buff, "ssl: %s, zlib: %s, mode: %s", ((signed int)return_value_ServerRealm_get_realmType$37 & 4) != 0 ? "yes" : "no", ((signed int)return_value_ServerRealm_get_realmType$38 & 8) != 0 ? "yes" : "no", tmp_if_expr$41 ? "tcp" : "udp");
            char return_value_ServerRealm_get_tunnelType$42;
            return_value_ServerRealm_get_tunnelType$42=ServerRealm_get_tunnelType(pointer);
            switch((signed int)return_value_ServerRealm_get_tunnelType$42)
            {
              case 0:
              {
                add_to_message(buff, "tunneltype: direct");
                break;
              }
              case 1:
              {
                add_to_message(buff, "tunneltype: http proxy");
                break;
              }
              case 2:
              {
                add_to_message(buff, "tunneltype: https proxy");
                break;
              }
              default:
                add_to_message(buff, "tunneltype: UNKNOWN");
            }
            i = i + 1;
          }
          while((_Bool)1);
          send_adm_message(type, master, buff, (unsigned char)3);
          break;
        }
        case 5:
        {
          n=get_realmnumber(config, (char *)&buff[(signed long int)ret]);
          if(n >= 0)
          {
            return_value_ServerConfiguration_get_realmsNumber$70=ServerConfiguration_get_realmsNumber(config);
            if(!(n >= return_value_ServerConfiguration_get_realmsNumber$70))
            {
              struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$43;
              return_value_ServerConfiguration_get_realmsTable$43=ServerConfiguration_get_realmsTable(config);
              pointer = return_value_ServerConfiguration_get_realmsTable$43[(signed long int)n];
              i = 0;
              do
              {
                return_value_ServerRealm_get_clientsLimit$44=ServerRealm_get_clientsLimit(pointer);
                if(i >= return_value_ServerRealm_get_clientsLimit$44)
                  break;

                struct anonymous$3 **return_value_ServerRealm_get_clientsTable$45;
                return_value_ServerRealm_get_clientsTable$45=ServerRealm_get_clientsTable(pointer);
                cpointer = return_value_ServerRealm_get_clientsTable$45[(signed long int)i];
                char return_value_ConnectClient_get_state$69;
                return_value_ConnectClient_get_state$69=ConnectClient_get_state(cpointer);
                if(!((signed int)return_value_ConnectClient_get_state$69 == 0))
                {
                  char *return_value_get_clientname$46;
                  return_value_get_clientname$46=get_clientname(pointer, i);
                  add_to_message(buff, "\nClient[%s]:", return_value_get_clientname$46);
                  char return_value_ConnectClient_get_state$47;
                  return_value_ConnectClient_get_state$47=ConnectClient_get_state(cpointer);
                  switch((signed int)return_value_ConnectClient_get_state$47)
                  {
                    case 1:
                    {
                      add_to_message(buff, "state: ssl handshake");
                      break;
                    }
                    case 2:
                    {
                      add_to_message(buff, "state: authorization");
                      break;
                    }
                    case 3:
                    {
                      add_to_message(buff, "state: running");
                      break;
                    }
                    default:
                      add_to_message(buff, "state: unknown");
                  }
                  signed int return_value_ConnectClient_get_connected$48;
                  return_value_ConnectClient_get_connected$48=ConnectClient_get_connected(cpointer);
                  signed int return_value_ConnectClient_get_limit$49;
                  return_value_ConnectClient_get_limit$49=ConnectClient_get_limit(cpointer);
                  add_to_message(buff, "users: %d (max: %d)", return_value_ConnectClient_get_connected$48, return_value_ConnectClient_get_limit$49);
                  signed int return_value_ConnectClient_get_usrCliPair$50;
                  return_value_ConnectClient_get_usrCliPair$50=ConnectClient_get_usrCliPair(cpointer);
                  add_to_message(buff, "user-client pair: %d", return_value_ConnectClient_get_usrCliPair$50);
                  signed long int return_value_ConnectClient_get_connectTime$51;
                  return_value_ConnectClient_get_connectTime$51=ConnectClient_get_connectTime(cpointer);
                  tmp = now - return_value_ConnectClient_get_connectTime$51;
                  add_uptime_to_message(buff, "Connection time", tmp);
                  signed long int return_value_ConnectClient_get_lastActivity$52;
                  return_value_ConnectClient_get_lastActivity$52=ConnectClient_get_lastActivity(cpointer);
                  tmp = now - return_value_ConnectClient_get_lastActivity$52;
                  add_uptime_to_message(buff, "Idle time", tmp);
                  char *return_value_ConnectClient_get_sClientId$53;
                  return_value_ConnectClient_get_sClientId$53=ConnectClient_get_sClientId(cpointer);
                  if(return_value_ConnectClient_get_sClientId$53 == ((char *)NULL))
                    tmp_if_expr$55 = "";

                  else
                  {
                    return_value_ConnectClient_get_sClientId$54=ConnectClient_get_sClientId(cpointer);
                    tmp_if_expr$55 = return_value_ConnectClient_get_sClientId$54;
                  }
                  add_to_message(buff, "Id: %s", tmp_if_expr$55);
                  signed int return_value_ConnectClient_get_clientId$56;
                  return_value_ConnectClient_get_clientId$56=ConnectClient_get_clientId(cpointer);
                  add_to_message(buff, "Number: %d", return_value_ConnectClient_get_clientId$56);
                  char *return_value_ConnectClient_get_nameBuf$57;
                  return_value_ConnectClient_get_nameBuf$57=ConnectClient_get_nameBuf(cpointer);
                  char *return_value_ConnectClient_get_portBuf$58;
                  return_value_ConnectClient_get_portBuf$58=ConnectClient_get_portBuf(cpointer);
                  add_to_message(buff, "IP: %s, port: %s", return_value_ConnectClient_get_nameBuf$57, return_value_ConnectClient_get_portBuf$58);
                  char return_value_ConnectClient_get_tunnelType$59;
                  return_value_ConnectClient_get_tunnelType$59=ConnectClient_get_tunnelType(cpointer);
                  switch((signed int)return_value_ConnectClient_get_tunnelType$59)
                  {
                    case 0:
                    {
                      add_to_message(buff, "tunneltype: direct");
                      break;
                    }
                    case 1:
                    {
                      add_to_message(buff, "tunneltype: http proxy");
                      break;
                    }
                    case 2:
                    {
                      add_to_message(buff, "tunneltype: https proxy");
                      break;
                    }
                    default:
                      add_to_message(buff, "tunneltype: UNKNOWN");
                  }
                  char return_value_ServerRealm_get_auditOn$68;
                  return_value_ServerRealm_get_auditOn$68=ServerRealm_get_auditOn(pointer);
                  if(!(return_value_ServerRealm_get_auditOn$68 == 0))
                  {
                    add_to_message(buff, "auditlog:");
                    struct auditlist *return_value_ConnectClient_get_auditList$60;
                    return_value_ConnectClient_get_auditList$60=ConnectClient_get_auditList(cpointer);
                    alptr=AuditList_get_first(return_value_ConnectClient_get_auditList$60);
                    while(!(alptr == ((struct alnode *)NULL)))
                    {
                      signed int return_value_AuditListNode_get_userId$61;
                      return_value_AuditListNode_get_userId$61=AuditListNode_get_userId(alptr);
                      char *return_value_AuditListNode_get_nameBuf$62;
                      return_value_AuditListNode_get_nameBuf$62=AuditListNode_get_nameBuf(alptr);
                      char *return_value_AuditListNode_get_portBuf$63;
                      return_value_AuditListNode_get_portBuf$63=AuditListNode_get_portBuf(alptr);
                      signed long int *return_value_AuditListNode_get_connectTimep$64;
                      return_value_AuditListNode_get_connectTimep$64=AuditListNode_get_connectTimep(alptr);
                      char *return_value_localdate$65;
                      return_value_localdate$65=localdate(return_value_AuditListNode_get_connectTimep$64);
                      signed long int return_value_AuditListNode_get_duration$66;
                      return_value_AuditListNode_get_duration$66=AuditListNode_get_duration(alptr);
                      char *return_value_timeperiod$67;
                      return_value_timeperiod$67=timeperiod(return_value_AuditListNode_get_duration$66);
                      add_to_message(buff, "userid: %d ip: %s port: %s connected: %s duration: %s", return_value_AuditListNode_get_userId$61, return_value_AuditListNode_get_nameBuf$62, return_value_AuditListNode_get_portBuf$63, return_value_localdate$65, return_value_timeperiod$67);
                      alptr=AuditListNode_get_nextNode(alptr);
                    }
                  }

                }

                i = i + 1;
              }
              while((_Bool)1);
              send_adm_message(type, master, buff, (unsigned char)3);
              break;
            }

          }

          add_to_message(buff, "Wrong realm name");
          add_to_message(buff, "Usage: cshow X      , X - realm name");
          send_adm_message(type, master, buff, (unsigned char)5);
          break;
        }
        case 6:
        {
          n=get_realmnumber(config, (char *)&buff[(signed long int)ret]);
          if(n >= 0)
          {
            return_value_ServerConfiguration_get_realmsNumber$92=ServerConfiguration_get_realmsNumber(config);
            if(!(n >= return_value_ServerConfiguration_get_realmsNumber$92))
            {
              struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$71;
              return_value_ServerConfiguration_get_realmsTable$71=ServerConfiguration_get_realmsTable(config);
              pointer = return_value_ServerConfiguration_get_realmsTable$71[(signed long int)n];
              i = 0;
              do
              {
                return_value_ServerRealm_get_usersLimit$72=ServerRealm_get_usersLimit(pointer);
                if(i >= return_value_ServerRealm_get_usersLimit$72)
                  break;

                struct anonymous$4 **return_value_ServerRealm_get_usersTable$73;
                return_value_ServerRealm_get_usersTable$73=ServerRealm_get_usersTable(pointer);
                upointer = return_value_ServerRealm_get_usersTable$73[(signed long int)i];
                char return_value_ConnectUser_get_state$91;
                return_value_ConnectUser_get_state$91=ConnectUser_get_state(upointer);
                if(!((signed int)return_value_ConnectUser_get_state$91 == 0))
                {
                  signed int return_value_get_username$74;
                  return_value_get_username$74=get_username(pointer, i);
                  add_to_message(buff, "\nUser[%d]:", return_value_get_username$74);
                  char return_value_ConnectUser_get_state$75;
                  return_value_ConnectUser_get_state$75=ConnectUser_get_state(upointer);
                  switch((signed int)return_value_ConnectUser_get_state$75)
                  {
                    case 5:
                    {
                      add_to_message(buff, "state: closing");
                      break;
                    }
                    case 6:
                    {
                      add_to_message(buff, "state: opening");
                      break;
                    }
                    case 17:
                    {
                      add_to_message(buff, "state: opening (closed)");
                      break;
                    }
                    case 7:
                    {
                      add_to_message(buff, "state: running");
                      break;
                    }
                    case 11:
                    {
                      add_to_message(buff, "state: stopped");
                      break;
                    }
                    default:
                      add_to_message(buff, "state: unknown");
                  }
                  signed int return_value_ConnectUser_get_whatClient$76;
                  return_value_ConnectUser_get_whatClient$76=ConnectUser_get_whatClient(upointer);
                  char *return_value_get_clientname$77;
                  return_value_get_clientname$77=get_clientname(pointer, return_value_ConnectUser_get_whatClient$76);
                  add_to_message(buff, "connected to: Client[%s]", return_value_get_clientname$77);
                  signed long int return_value_ConnectUser_get_connectTime$78;
                  return_value_ConnectUser_get_connectTime$78=ConnectUser_get_connectTime(upointer);
                  tmp = now - return_value_ConnectUser_get_connectTime$78;
                  add_uptime_to_message(buff, "Connection time", tmp);
                  struct anonymous$6 *return_value_ConnectUser_get_stats$79;
                  return_value_ConnectUser_get_stats$79=ConnectUser_get_stats(upointer);
                  signed long int return_value_UserStats_get_lastActivity$80;
                  return_value_UserStats_get_lastActivity$80=UserStats_get_lastActivity(return_value_ConnectUser_get_stats$79);
                  tmp = now - return_value_UserStats_get_lastActivity$80;
                  add_uptime_to_message(buff, "Idle time", tmp);
                  char *return_value_ConnectUser_get_nameBuf$81;
                  return_value_ConnectUser_get_nameBuf$81=ConnectUser_get_nameBuf(upointer);
                  char *return_value_ConnectUser_get_portBuf$82;
                  return_value_ConnectUser_get_portBuf$82=ConnectUser_get_portBuf(upointer);
                  add_to_message(buff, "IP: %s, port: %s", return_value_ConnectUser_get_nameBuf$81, return_value_ConnectUser_get_portBuf$82);
                  struct anonymous$6 *return_value_ConnectUser_get_stats$83;
                  return_value_ConnectUser_get_stats$83=ConnectUser_get_stats(upointer);
                  signed int return_value_UserStats_get_totalDownloadedBytes$84;
                  return_value_UserStats_get_totalDownloadedBytes$84=UserStats_get_totalDownloadedBytes(return_value_ConnectUser_get_stats$83);
                  add_to_message(buff, "Downloaded: %d bytes", return_value_UserStats_get_totalDownloadedBytes$84);
                  struct anonymous$6 *return_value_ConnectUser_get_stats$85;
                  return_value_ConnectUser_get_stats$85=ConnectUser_get_stats(upointer);
                  double return_value_UserStats_get_downloadSpeed$86;
                  return_value_UserStats_get_downloadSpeed$86=UserStats_get_downloadSpeed(return_value_ConnectUser_get_stats$85);
                  add_to_message(buff, "download speed: %.2f B/s", return_value_UserStats_get_downloadSpeed$86);
                  struct anonymous$6 *return_value_ConnectUser_get_stats$87;
                  return_value_ConnectUser_get_stats$87=ConnectUser_get_stats(upointer);
                  signed int return_value_UserStats_get_totalUploadedBytes$88;
                  return_value_UserStats_get_totalUploadedBytes$88=UserStats_get_totalUploadedBytes(return_value_ConnectUser_get_stats$87);
                  add_to_message(buff, "Uploaded: %d bytes", return_value_UserStats_get_totalUploadedBytes$88);
                  struct anonymous$6 *return_value_ConnectUser_get_stats$89;
                  return_value_ConnectUser_get_stats$89=ConnectUser_get_stats(upointer);
                  double return_value_UserStats_get_uploadSpeed$90;
                  return_value_UserStats_get_uploadSpeed$90=UserStats_get_uploadSpeed(return_value_ConnectUser_get_stats$89);
                  add_to_message(buff, "upload speed: %.2f B/s", return_value_UserStats_get_uploadSpeed$90);
                }

                i = i + 1;
              }
              while((_Bool)1);
              send_adm_message(type, master, buff, (unsigned char)3);
              break;
            }

          }

          add_to_message(buff, "Wrong realm name");
          add_to_message(buff, "Usage: ushow X      , X - realm name");
          send_adm_message(type, master, buff, (unsigned char)5);
          break;
        }
        case 7:
        {
          return_value_get_realmname$93=get_realmname(config, realm);
          return_value_get_raclientname$94=get_raclientname(pointer, client);
          aflog((char)8, (char)8, "realm[%s]: Client[%s] (ra): commfd: CLOSED", return_value_get_realmname$93, return_value_get_raclientname$94);
          send_adm_message(type, master, buff, (unsigned char)6);
          return 1;
        }
        case 8:
        {
          i=parse_int(buff, &ret);
          if(!(i >= 1))
          {
            add_to_message(buff, "Invalid timeout value");
            add_to_message(buff, "Usage: timeout N X      , N - new timeout value, X - realm name");
            send_adm_message(type, master, buff, (unsigned char)5);
            break;
          }

          n=get_realmnumber(config, (char *)&buff[(signed long int)ret]);
          if(n >= 0)
          {
            return_value_ServerConfiguration_get_realmsNumber$98=ServerConfiguration_get_realmsNumber(config);
            if(!(n >= return_value_ServerConfiguration_get_realmsNumber$98))
            {
              struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$95;
              return_value_ServerConfiguration_get_realmsTable$95=ServerConfiguration_get_realmsTable(config);
              signed int return_value_ServerRealm_get_timeout$96;
              return_value_ServerRealm_get_timeout$96=ServerRealm_get_timeout(return_value_ServerConfiguration_get_realmsTable$95[(signed long int)n]);
              add_to_message(buff, "changed timeout: %d --> %d", return_value_ServerRealm_get_timeout$96, i);
              struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$97;
              return_value_ServerConfiguration_get_realmsTable$97=ServerConfiguration_get_realmsTable(config);
              ServerRealm_set_timeout(return_value_ServerConfiguration_get_realmsTable$97[(signed long int)n], i);
              send_adm_message(type, master, buff, (unsigned char)3);
              break;
            }

          }

          add_to_message(buff, "Wrong realm name");
          add_to_message(buff, "Usage: timeout N X      , N - new timeout value, X - realm name");
          send_adm_message(type, master, buff, (unsigned char)5);
          break;
        }
        case 9:
        {
          i=parse_int(buff, &ret);
          if(!(i == 0) && !(i == 1))
          {
            add_to_message(buff, "Invalid audit value");
            add_to_message(buff, "Usage: audit {0|1} X      , N=0 off, N=1 on, X - realm name");
            send_adm_message(type, master, buff, (unsigned char)5);
            break;
          }

          n=get_realmnumber(config, (char *)&buff[(signed long int)ret]);
          if(n >= 0)
          {
            return_value_ServerConfiguration_get_realmsNumber$107=ServerConfiguration_get_realmsNumber(config);
            if(!(n >= return_value_ServerConfiguration_get_realmsNumber$107))
            {
              struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$99;
              return_value_ServerConfiguration_get_realmsTable$99=ServerConfiguration_get_realmsTable(config);
              char return_value_ServerRealm_get_auditOn$100;
              return_value_ServerRealm_get_auditOn$100=ServerRealm_get_auditOn(return_value_ServerConfiguration_get_realmsTable$99[(signed long int)n]);
              add_to_message(buff, "changed audit: %s --> %s", return_value_ServerRealm_get_auditOn$100 != 0 ? "yes" : "no", i != 0 ? "yes" : "no");
              struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$101;
              return_value_ServerConfiguration_get_realmsTable$101=ServerConfiguration_get_realmsTable(config);
              ServerRealm_set_auditOn(return_value_ServerConfiguration_get_realmsTable$101[(signed long int)n], (char)i);
              if(i == 0)
              {
                i = 0;
                do
                {
                  return_value_ServerConfiguration_get_realmsTable$102=ServerConfiguration_get_realmsTable(config);
                  return_value_ServerRealm_get_clientsLimit$103=ServerRealm_get_clientsLimit(return_value_ServerConfiguration_get_realmsTable$102[(signed long int)n]);
                  if(i >= return_value_ServerRealm_get_clientsLimit$103)
                    break;

                  struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$104;
                  return_value_ServerConfiguration_get_realmsTable$104=ServerConfiguration_get_realmsTable(config);
                  struct anonymous$3 **return_value_ServerRealm_get_clientsTable$105;
                  return_value_ServerRealm_get_clientsTable$105=ServerRealm_get_clientsTable(return_value_ServerConfiguration_get_realmsTable$104[(signed long int)n]);
                  struct auditlist *return_value_ConnectClient_get_auditList$106;
                  return_value_ConnectClient_get_auditList$106=ConnectClient_get_auditList(return_value_ServerRealm_get_clientsTable$105[(signed long int)i]);
                  AuditList_clear(return_value_ConnectClient_get_auditList$106);
                  i = i + 1;
                }
                while((_Bool)1);
              }

              send_adm_message(type, master, buff, (unsigned char)3);
              break;
            }

          }

          add_to_message(buff, "Wrong realm name");
          add_to_message(buff, "Usage: audit {0|1} X      , N=0 off, N=1 on, X - realm name");
          send_adm_message(type, master, buff, (unsigned char)5);
          break;
        }
        case 10:
        {
          i=parse_int(buff, &ret);
          if(!(i == 0) && !(i == 1))
          {
            add_to_message(buff, "Invalid dnslookups value");
            add_to_message(buff, "Usage: dnslookups {0|1} X      , N=0 off, N=1 on, X - realm name");
            send_adm_message(type, master, buff, (unsigned char)5);
            break;
          }

          n=get_realmnumber(config, (char *)&buff[(signed long int)ret]);
          if(n >= 0)
          {
            return_value_ServerConfiguration_get_realmsNumber$111=ServerConfiguration_get_realmsNumber(config);
            if(!(n >= return_value_ServerConfiguration_get_realmsNumber$111))
            {
              struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$108;
              return_value_ServerConfiguration_get_realmsTable$108=ServerConfiguration_get_realmsTable(config);
              char return_value_ServerRealm_get_dnsLookupsOn$109;
              return_value_ServerRealm_get_dnsLookupsOn$109=ServerRealm_get_dnsLookupsOn(return_value_ServerConfiguration_get_realmsTable$108[(signed long int)n]);
              add_to_message(buff, "changed dnslookups: %s --> %s", return_value_ServerRealm_get_dnsLookupsOn$109 != 0 ? "yes" : "no", i != 0 ? "yes" : "no");
              struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$110;
              return_value_ServerConfiguration_get_realmsTable$110=ServerConfiguration_get_realmsTable(config);
              ServerRealm_set_dnsLookupsOn(return_value_ServerConfiguration_get_realmsTable$110[(signed long int)n], (char)i);
              send_adm_message(type, master, buff, (unsigned char)3);
              break;
            }

          }

          add_to_message(buff, "Wrong realm name");
          add_to_message(buff, "Usage: dnslookups {0|1} X      , N=0 off, N=1 on, X - realm name");
          send_adm_message(type, master, buff, (unsigned char)5);
          break;
        }
        case 11:
        {
          return_value_getdateformat$112=getdateformat();
          __builtin_strncpy(olddf, return_value_getdateformat$112, (unsigned long int)50);
          __builtin_strncpy(newdf, (char *)&buff[(signed long int)ret], (unsigned long int)50);
          add_to_message(buff, "changed dateformat: %s --> %s", (const void *)olddf, (const void *)newdf);
          setdateformat(newdf);
          send_adm_message(type, master, buff, (unsigned char)3);
          break;
        }
        case 12:
        {
          i=parse_int(buff, &ret);
          if(!((signed int)buff[(signed long int)ret] == 0))
          {
            add_to_message(buff, "Invalid user name");
            add_to_message(buff, "Usage: kuser S      , S - user name");
            send_adm_message(type, master, buff, (unsigned char)5);
            break;
          }

          j = -1;
          n = 0;
          do
          {
            return_value_ServerConfiguration_get_realmsNumber$113=ServerConfiguration_get_realmsNumber(config);
            if(n >= return_value_ServerConfiguration_get_realmsNumber$113)
              break;

            struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$114;
            return_value_ServerConfiguration_get_realmsTable$114=ServerConfiguration_get_realmsTable(config);
            pointer = return_value_ServerConfiguration_get_realmsTable$114[(signed long int)n];
            j=get_usernumber(pointer, i);
            if(!(j == -1))
            {
              struct anonymous$4 **return_value_ServerRealm_get_usersTable$115;
              return_value_ServerRealm_get_usersTable$115=ServerRealm_get_usersTable(pointer);
              upointer = return_value_ServerRealm_get_usersTable$115[(signed long int)j];
              char return_value_ConnectUser_get_state$120;
              return_value_ConnectUser_get_state$120=ConnectUser_get_state(upointer);
              if((signed int)return_value_ConnectUser_get_state$120 == 7)
                tmp_if_expr$122 = (_Bool)1;

              else
              {
                return_value_ConnectUser_get_state$121=ConnectUser_get_state(upointer);
                tmp_if_expr$122 = (signed int)return_value_ConnectUser_get_state$121 == 6 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$122)
                tmp_if_expr$124 = (_Bool)1;

              else
              {
                return_value_ConnectUser_get_state$123=ConnectUser_get_state(upointer);
                tmp_if_expr$124 = (signed int)return_value_ConnectUser_get_state$123 == 11 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr$124)
              {
                char *return_value_get_realmname$116;
                return_value_get_realmname$116=get_realmname(config, n);
                signed int return_value_get_username$117;
                return_value_get_username$117=get_username(pointer, j);
                add_to_message(buff, "kicked: realm[%s] user[%d]", return_value_get_realmname$116, return_value_get_username$117);
                char return_value_ConnectUser_get_state$119;
                return_value_ConnectUser_get_state$119=ConnectUser_get_state(upointer);
                if((signed int)return_value_ConnectUser_get_state$119 == 6)
                  ConnectUser_set_state(upointer, (char)17);

                else
                {
                  signed int return_value_ConnectUser_get_connFd$118;
                  return_value_ConnectUser_get_connFd$118=ConnectUser_get_connFd(upointer);
                  close(return_value_ConnectUser_get_connFd$118);
                }
                send_adm_message(type, master, buff, (unsigned char)3);
              }

              else
              {
                add_to_message(buff, "Invalid user");
                add_to_message(buff, "Usage: kuser S      , S - user name");
                send_adm_message(type, master, buff, (unsigned char)5);
              }
              break;
            }

            n = n + 1;
          }
          while((_Bool)1);
          if(j == -1)
          {
            add_to_message(buff, "Invalid user name");
            add_to_message(buff, "Usage: kuser S      , S - user name");
            send_adm_message(type, master, buff, (unsigned char)5);
          }

          break;
        }
        case 13:
        {
          i=parse_int(buff, &ret);
          if(!((signed int)buff[(signed long int)ret] == 0))
          {
            add_to_message(buff, "Invalid client number");
            add_to_message(buff, "Usage: kclient N      , N - client number");
            send_adm_message(type, master, buff, (unsigned char)5);
            break;
          }

          j = -1;
          n = 0;
          do
          {
            return_value_ServerConfiguration_get_realmsNumber$125=ServerConfiguration_get_realmsNumber(config);
            if(n >= return_value_ServerConfiguration_get_realmsNumber$125)
              break;

            struct anonymous$5 **return_value_ServerConfiguration_get_realmsTable$126;
            return_value_ServerConfiguration_get_realmsTable$126=ServerConfiguration_get_realmsTable(config);
            pointer = return_value_ServerConfiguration_get_realmsTable$126[(signed long int)n];
            j=get_clientnumber(pointer, i);
            if(!(j == -1))
            {
              struct anonymous$3 **return_value_ServerRealm_get_clientsTable$129;
              return_value_ServerRealm_get_clientsTable$129=ServerRealm_get_clientsTable(pointer);
              char return_value_ConnectClient_get_state$130;
              return_value_ConnectClient_get_state$130=ConnectClient_get_state(return_value_ServerRealm_get_clientsTable$129[(signed long int)j]);
              if((signed int)return_value_ConnectClient_get_state$130 >= 1)
              {
                char *return_value_get_realmname$127;
                return_value_get_realmname$127=get_realmname(config, n);
                char *return_value_get_clientname$128;
                return_value_get_clientname$128=get_clientname(pointer, j);
                add_to_message(buff, "kicked: realm[%s] client[%s]", return_value_get_realmname$127, return_value_get_clientname$128);
                send_adm_message(type, master, buff, (unsigned char)3);
                return i + 2;
              }

              else
              {
                add_to_message(buff, "Invalid client");
                add_to_message(buff, "Usage: kclient N      , N - client number");
                send_adm_message(type, master, buff, (unsigned char)5);
              }
              break;
            }

            n = n + 1;
          }
          while((_Bool)1);
          if(j == -1)
          {
            add_to_message(buff, "Invalid client number");
            add_to_message(buff, "Usage: kclient N      , N - client number");
            send_adm_message(type, master, buff, (unsigned char)5);
          }

          break;
        }
        default:
        {
          char *return_value_get_realmname$131;
          return_value_get_realmname$131=get_realmname(config, realm);
          aflog((char)8, (char)32, "realm[%s]: admin: cmd ignored", return_value_get_realmname$131);
          send_adm_message(type, master, buff, (unsigned char)0);
        }
      }
      break;
    }
    case 2:
      break;
    default:
    {
      aflog((char)8, (char)64, "Unrecognized message from remote admin --> closing");
      return 1;
    }
  }
  return 0;
}

// server_long_usage
// file usage.h line 25
void server_long_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf(" Basic options:\n\n");
  printf("  -n, --hostname      - it's used when creating listening sockets\n");
  printf("                        (default: '')\n");
  printf("  -l, --listenport    - listening [host:]port - users connect to it\n");
  printf("                        (default: 50127)\n");
  printf("  -m, --manageport    - manage [host:]port - afclient connects to it\n");
  printf("                        (default: 50126)\n");
  printf("  -V, --version       - display version number\n");
  printf("  -h, --help          - prints this help\n\n");
  printf(" Authorization:\n\n");
  printf("  --pass              - set the password used for client identification\n");
  printf("                        (default: no password)\n\n");
  printf(" Configuration:\n\n");
  printf("  -c, --cerfile       - the name of the file with certificate\n");
  printf("                        (default: server-cert.pem)\n");
  printf("  -A, --cacerfile     - the name of the file with CA certificates\n");
  printf("                        (if used, require clients to have valid certificates)\n");
  printf("  -d, --cerdepth      - the maximum depth of valid certificate-chains\n");
  printf("  -k, --keyfile       - the name of the file with RSA key (default: server.rsa)\n");
  printf("  -f, --cfgfile       - the name of the file with the configuration for the\n");
  printf("                        active forwarder (server)\n");
  printf("  -D, --dateformat    - format of the date printed in logs (see 'man strftime'\n");
  printf("                        for details) (default: %%Y-%%m-%%d %%H:%%M:%%S)\n");
  printf("  -t, --timeout       - the timeout value for the client's connection\n");
  printf("                        (default: 5)\n");
  printf("  --maxidle           - the maximum idle time for the client's connection\n");
  printf("                        (default: disabled)\n");
  printf("  -u, --users         - the amount of users allowed to use this server\n");
  printf("                        (default: 5)\n");
  printf("  -C, --clients       - the number of allowed clients to use this server\n");
  printf("                        (default: 1)\n");
  printf("  -r, --realm         - set the realm name (default: none)\n");
  printf("  -R, --raclients     - the number of allowed clients in remote administration\n");
  printf("                        mode to use this server (default: 1)\n");
  printf("  -U, --usrpcli       - the number of allowed users per client (default: $users)\n");
  printf("  -M, --climode       - strategy used to connect users with clients (default: 1)\n");
  printf("                      Available strategies:\n");
  printf("                        1. fill first client before go to next\n\n");
  printf("  -p, --proto         - type of server (tcp|udp) - what protocol it will be\n");
  printf("                        operating for (default: tcp)\n");
  printf("  -b, --baseport      - listenports are temporary and differ for each client\n");
  printf("  -a, --audit         - additional information about connections are logged\n");
  printf("  --nossl             - ssl is not used to transfer data (but it's still used\n");
  printf("                        to establish a connection) (default: ssl is used)\n");
  printf("  --nozlib            - zlib is not used to compress data (default: zlib is\n");
  printf("                        used)\n");
  printf("  --dnslookups        - try to obtain dns names of the computers rather than\n");
  printf("                        their numeric IP\n\n");
  printf(" Logging:\n\n");
  printf("  -o, --log           - log choosen information to file/socket\n");
  printf("  -v, --verbose       - to be verbose - program won't enter the daemon mode\n");
  printf("                        (use several times for greater effect)\n\n");
  printf(" IP family:\n\n");
  printf("  -4, --ipv4          - use ipv4 only\n");
  printf("  -6, --ipv6          - use ipv6 only\n\n");
  printf(" HTTP PROXY:\n\n");
  printf("  -P, --enableproxy   - enable http proxy mode\n\n");
  exit(0);
}

// server_short_usage
// file usage.h line 24
void server_short_usage(char *info)
{
  printf("\n%s\n\n\n", info);
  printf("Try `afserver --help' for more information.\n");
  exit(1);
}

// server_sig_int
// file server_signals.h line 24
void server_sig_int(signed int signo)
{
  signed int i;
  signed int j;
  unsigned char buff[5l];
  struct anonymous$5 **scRealmsTable;
  signed int return_value_is_this_a_mainthread$1;
  return_value_is_this_a_mainthread$1=is_this_a_mainthread();
  signed int return_value_ServerConfiguration_get_realmsNumber$2;
  signed int return_value_ServerRealm_get_clientsLimit$3;
  signed int return_value_ServerRealm_get_raClientsLimit$12;
  if(!(return_value_is_this_a_mainthread$1 == 0))
  {
    j = 0;
    do
    {
      return_value_ServerConfiguration_get_realmsNumber$2=ServerConfiguration_get_realmsNumber(config);
      if(j >= return_value_ServerConfiguration_get_realmsNumber$2)
        break;

      scRealmsTable=ServerConfiguration_get_realmsTable(config);
      buff[(signed long int)0] = (unsigned char)4;
      i = 0;
      do
      {
        return_value_ServerRealm_get_clientsLimit$3=ServerRealm_get_clientsLimit(scRealmsTable[(signed long int)j]);
        if(i >= return_value_ServerRealm_get_clientsLimit$3)
          break;

        struct anonymous$3 **return_value_ServerRealm_get_clientsTable$10;
        return_value_ServerRealm_get_clientsTable$10=ServerRealm_get_clientsTable(scRealmsTable[(signed long int)j]);
        char return_value_ConnectClient_get_state$11;
        return_value_ConnectClient_get_state$11=ConnectClient_get_state(return_value_ServerRealm_get_clientsTable$10[(signed long int)i]);
        if((signed int)return_value_ConnectClient_get_state$11 == 3)
        {
          char return_value_ServerRealm_get_realmType$4;
          return_value_ServerRealm_get_realmType$4=ServerRealm_get_realmType(scRealmsTable[(signed long int)j]);
          struct anonymous$3 **return_value_ServerRealm_get_clientsTable$5;
          return_value_ServerRealm_get_clientsTable$5=ServerRealm_get_clientsTable(scRealmsTable[(signed long int)j]);
          struct anonymous$1 *return_value_ConnectClient_get_sslFd$6;
          return_value_ConnectClient_get_sslFd$6=ConnectClient_get_sslFd(return_value_ServerRealm_get_clientsTable$5[(signed long int)i]);
          SslFd_send_message(return_value_ServerRealm_get_realmType$4, return_value_ConnectClient_get_sslFd$6, buff, 5);
          struct anonymous$3 **return_value_ServerRealm_get_clientsTable$7;
          return_value_ServerRealm_get_clientsTable$7=ServerRealm_get_clientsTable(scRealmsTable[(signed long int)j]);
          struct anonymous$1 *return_value_ConnectClient_get_sslFd$8;
          return_value_ConnectClient_get_sslFd$8=ConnectClient_get_sslFd(return_value_ServerRealm_get_clientsTable$7[(signed long int)i]);
          signed int return_value_SslFd_get_fd$9;
          return_value_SslFd_get_fd$9=SslFd_get_fd(return_value_ConnectClient_get_sslFd$8);
          close(return_value_SslFd_get_fd$9);
        }

        i = i + 1;
      }
      while((_Bool)1);
      i = 0;
      do
      {
        return_value_ServerRealm_get_raClientsLimit$12=ServerRealm_get_raClientsLimit(scRealmsTable[(signed long int)j]);
        if(i >= return_value_ServerRealm_get_raClientsLimit$12)
          break;

        struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$19;
        return_value_ServerRealm_get_raClientsTable$19=ServerRealm_get_raClientsTable(scRealmsTable[(signed long int)j]);
        char return_value_ConnectClient_get_state$20;
        return_value_ConnectClient_get_state$20=ConnectClient_get_state(return_value_ServerRealm_get_raClientsTable$19[(signed long int)i]);
        if((signed int)return_value_ConnectClient_get_state$20 == 3)
        {
          char return_value_ServerRealm_get_realmType$13;
          return_value_ServerRealm_get_realmType$13=ServerRealm_get_realmType(scRealmsTable[(signed long int)j]);
          struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$14;
          return_value_ServerRealm_get_raClientsTable$14=ServerRealm_get_raClientsTable(scRealmsTable[(signed long int)j]);
          struct anonymous$1 *return_value_ConnectClient_get_sslFd$15;
          return_value_ConnectClient_get_sslFd$15=ConnectClient_get_sslFd(return_value_ServerRealm_get_raClientsTable$14[(signed long int)i]);
          SslFd_send_message((char)((signed int)return_value_ServerRealm_get_realmType$13 | 4), return_value_ConnectClient_get_sslFd$15, buff, 5);
          struct anonymous$3 **return_value_ServerRealm_get_raClientsTable$16;
          return_value_ServerRealm_get_raClientsTable$16=ServerRealm_get_raClientsTable(scRealmsTable[(signed long int)j]);
          struct anonymous$1 *return_value_ConnectClient_get_sslFd$17;
          return_value_ConnectClient_get_sslFd$17=ConnectClient_get_sslFd(return_value_ServerRealm_get_raClientsTable$16[(signed long int)i]);
          signed int return_value_SslFd_get_fd$18;
          return_value_SslFd_get_fd$18=SslFd_get_fd(return_value_ConnectClient_get_sslFd$17);
          close(return_value_SslFd_get_fd$18);
        }

        i = i + 1;
      }
      while((_Bool)1);
      j = j + 1;
    }
    while((_Bool)1);
    mysleep(0.1);
    signed long int return_value_getcg$21;
    return_value_getcg$21=getcg();
    aflog((char)16, (char)16, "SERVER CLOSED cg: %ld bytes", return_value_getcg$21);
    exit(0);
  }

}

// set_fd
// file http_proxy_functions.c line 235
void set_fd(signed int fd, signed int *maxfdp1, struct anonymous$22 *allset)
{
  allset->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = allset->__fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
  signed int tmp_if_expr$1;
  if(!(fd >= *maxfdp1))
    tmp_if_expr$1 = *maxfdp1;

  else
    tmp_if_expr$1 = fd + 1;
  *maxfdp1 = tmp_if_expr$1;
}

// set_value
// file server_set.h line 24
void set_value(char **dest, char *from, char *def)
{
  if(*dest == ((char *)NULL))
  {
    if(!(from == ((char *)NULL)))
      string_cp(dest, from);

    else
      *dest = def;
  }

}

// setdateformat
// file logging.h line 63
void setdateformat(char *dateformat)
{
  if(!(dateformat == ((char *)NULL)))
    __builtin_strncpy(format, dateformat, (unsigned long int)50);

}

// sock_ntop
// file network.h line 42
char * sock_ntop(struct sockaddr *sa, unsigned int salen, char *namebuf, char *portbuf, char type)
{
  char portstr[7l];
  struct sockaddr_in *sin;
  unsigned short int tmp_statement_expression$5;
  unsigned short int tmp_statement_expression$3;
  unsigned short int tmp_statement_expression$4;
  struct sockaddr_in6 *sin6;
  unsigned short int tmp_statement_expression$10;
  unsigned short int tmp_statement_expression$8;
  unsigned short int tmp_statement_expression$9;
  switch((signed int)sa->sa_family)
  {    static char str[136l];
    case 2:
    {
      sin = (struct sockaddr_in *)sa;
      if(!(type == 0))
      {
        signed int return_value_getnameinfo$1;
        return_value_getnameinfo$1=getnameinfo(sa, salen, str, (unsigned int)128, (char *)(void *)0, (unsigned int)0, 0);
        if(!(return_value_getnameinfo$1 == 0))
          return (char *)(void *)0;

      }

      else
      {
        const char *return_value_inet_ntop$2;
        return_value_inet_ntop$2=inet_ntop(2, (void *)&sin->sin_addr, str, (unsigned int)sizeof(char [136l]) /*136ul*/ );
        if(return_value_inet_ntop$2 == ((const char *)NULL))
          return (char *)(void *)0;

      }
      if(!(namebuf == ((char *)NULL)))
        memcpy((void *)namebuf, (const void *)str, (unsigned long int)128);

      unsigned short int sock_ntop$$1$$1$$1$$4$$__v;
      unsigned short int sock_ntop$$1$$1$$1$$4$$__x = (unsigned short int)sin->sin_port;
      asm("rorw $8, %w0" : "=r"(sock_ntop$$1$$1$$1$$4$$__v) : "0"(sock_ntop$$1$$1$$1$$4$$__x) : "cc");
      tmp_statement_expression$5 = sock_ntop$$1$$1$$1$$4$$__v;
      if(!((signed int)tmp_statement_expression$5 == 0))
      {
        unsigned short int sock_ntop$$1$$1$$1$$5$$1$$__v;
        unsigned short int sock_ntop$$1$$1$$1$$5$$1$$__x = (unsigned short int)sin->sin_port;
        asm("rorw $8, %w0" : "=r"(sock_ntop$$1$$1$$1$$5$$1$$__v) : "0"(sock_ntop$$1$$1$$1$$5$$1$$__x) : "cc");
        tmp_statement_expression$3 = sock_ntop$$1$$1$$1$$5$$1$$__v;
        snprintf(portstr, sizeof(char [7l]) /*7ul*/ , ".%d", tmp_statement_expression$3);
        if(!(portbuf == ((char *)NULL)))
        {
          unsigned short int sock_ntop$$1$$1$$1$$5$$2$$1$$__v;
          unsigned short int sock_ntop$$1$$1$$1$$5$$2$$1$$__x = (unsigned short int)sin->sin_port;
          asm("rorw $8, %w0" : "=r"(sock_ntop$$1$$1$$1$$5$$2$$1$$__v) : "0"(sock_ntop$$1$$1$$1$$5$$2$$1$$__x) : "cc");
          tmp_statement_expression$4 = sock_ntop$$1$$1$$1$$5$$2$$1$$__v;
          snprintf(portbuf, (unsigned long int)7, "%d", tmp_statement_expression$4);
        }

        strcat(str, portstr);
      }

      return str;
    }
    case 10:
    {
      sin6 = (struct sockaddr_in6 *)sa;
      if(!(type == 0))
      {
        signed int return_value_getnameinfo$6;
        return_value_getnameinfo$6=getnameinfo(sa, salen, str, (unsigned int)128, (char *)(void *)0, (unsigned int)0, 0);
        if(!(return_value_getnameinfo$6 == 0))
          return (char *)(void *)0;

      }

      else
      {
        const char *return_value_inet_ntop$7;
        return_value_inet_ntop$7=inet_ntop(10, (const void *)&sin6->sin6_addr, str, (unsigned int)sizeof(char [136l]) /*136ul*/ );
        if(return_value_inet_ntop$7 == ((const char *)NULL))
          return (char *)(void *)0;

      }
      if(!(namebuf == ((char *)NULL)))
        memcpy((void *)namebuf, (const void *)str, (unsigned long int)128);

      unsigned short int __v;
      unsigned short int __x = (unsigned short int)sin6->sin6_port;
      asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression$10 = __v;
      if(!((signed int)tmp_statement_expression$10 == 0))
      {
        unsigned short int sock_ntop$$1$$1$$2$$5$$1$$__v;
        unsigned short int sock_ntop$$1$$1$$2$$5$$1$$__x = (unsigned short int)sin6->sin6_port;
        asm("rorw $8, %w0" : "=r"(sock_ntop$$1$$1$$2$$5$$1$$__v) : "0"(sock_ntop$$1$$1$$2$$5$$1$$__x) : "cc");
        tmp_statement_expression$8 = sock_ntop$$1$$1$$2$$5$$1$$__v;
        snprintf(portstr, sizeof(char [7l]) /*7ul*/ , ".%d", tmp_statement_expression$8);
        if(!(portbuf == ((char *)NULL)))
        {
          unsigned short int sock_ntop$$1$$1$$2$$5$$2$$1$$__v;
          unsigned short int sock_ntop$$1$$1$$2$$5$$2$$1$$__x = (unsigned short int)sin6->sin6_port;
          asm("rorw $8, %w0" : "=r"(sock_ntop$$1$$1$$2$$5$$2$$1$$__v) : "0"(sock_ntop$$1$$1$$2$$5$$2$$1$$__x) : "cc");
          tmp_statement_expression$9 = sock_ntop$$1$$1$$2$$5$$2$$1$$__v;
          snprintf(portbuf, (unsigned long int)7, "%d", tmp_statement_expression$9);
        }

        strcat(str, portstr);
      }

      return str;
    }
    default:
    {
      snprintf(str, sizeof(char [136l]) /*136ul*/ , "sock_ntop: unknown AF_xxx: %d, len %d", sa->sa_family, salen);
      return str;
    }
  }
  return (char *)(void *)0;
}

// start_critical_section
// file thread_management.h line 28
void start_critical_section(void)
{
  pthread_mutex_lock(&mainmutex);
}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 453
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat$1;
  return_value___xstat$1=__xstat(1, __path, __statbuf);
  return return_value___xstat$1;
}

// string_cp
// file string_functions.h line 24
char * string_cp(char **dest, char *src)
{
  char *tmp;
  signed int len = 0;
  if(!(dest == ((char **)NULL)))
  {
    if(!(*dest == ((char *)NULL)))
    {
      if(*dest == src)
        return *dest;

      free((void *)*dest);
      *dest = (char *)(void *)0;
    }

  }

  if(src == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(src);
    len = (signed int)return_value_strlen$1;
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)1, (unsigned long int)(len + 1));
    tmp = (char *)return_value_calloc$2;
    if(tmp == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      __builtin_strncpy(tmp, src, (unsigned long int)len);
      if(!(dest == ((char **)NULL)))
        *dest = tmp;

      return tmp;
    }
  }
}

// timeperiod
// file stats.h line 29
char * timeperiod(signed long int period)
{
  signed int hours;
  signed int minutes;
  signed int seconds;
  static char timeper[41l];
  memset((void *)timeper, 0, (unsigned long int)41);
  hours = (signed int)(period / (signed long int)3600);
  minutes = (signed int)((period / (signed long int)60) % (signed long int)60);
  seconds = (signed int)(period % (signed long int)60);
  if(!(hours == 0))
    sprintf(timeper, "%d:%02d:%02d", hours, minutes, seconds);

  else
    sprintf(timeper, "%d:%02d", minutes, seconds);
  return timeper;
}

// timeval_compare
// file timeval_functions.c line 56
signed int timeval_compare(struct timeval *first, struct timeval *second)
{
  if(first == ((struct timeval *)NULL))
  {
    if(second == ((struct timeval *)NULL))
      return 0;

    return -1;
  }

  else
    if(second == ((struct timeval *)NULL))
      return 1;

    else
      if(!(first->tv_sec >= second->tv_sec))
        return -1;

      else
        if(!(second->tv_sec >= first->tv_sec))
          return 1;

        else
          if(!(first->tv_usec >= second->tv_usec))
            return -1;

          else
            if(!(second->tv_usec >= first->tv_usec))
              return 1;

            else
              return 0;
}

// timeval_create
// file timeval_functions.h line 26
struct timeval timeval_create(signed long int tv_sec, signed long int tv_usec)
{
  struct timeval tmp;
  tmp.tv_sec = tv_sec;
  tmp.tv_usec = tv_usec;
  return tmp;
}

// timeval_lq_zero
// file timeval_functions.c line 121
signed int timeval_lq_zero(struct timeval *timer)
{
  if(timer == ((struct timeval *)NULL))
    return 0;

  else
    if(!(timer->tv_sec >= 0l))
      return 1;

    else
      if(timer->tv_sec == 0l)
      {
        if(!(timer->tv_usec == 0l))
          goto __CPROVER_DUMP_L3;

        return 1;
      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        return 0;
      }
}

// timeval_subtract
// file timeval_functions.c line 94
signed int timeval_subtract(struct timeval *first, struct timeval *second)
{
  if(first == ((struct timeval *)NULL) || second == ((struct timeval *)NULL))
    return 1;

  else
  {
    if(!(first->tv_usec >= second->tv_usec))
    {
      first->tv_sec = first->tv_sec - (signed long int)1;
      first->tv_usec = ((signed long int)1000000 - second->tv_usec) + first->tv_usec;
    }

    else
      first->tv_usec = first->tv_usec - second->tv_usec;
    first->tv_sec = first->tv_sec - second->tv_sec;
    return 0;
  }
}

// wait_for_condition
// file thread_management.h line 30
void wait_for_condition(void)
{
  pthread_cond_wait(&maincond, &mainmutex);
}

// writen
// file network.c line 513
signed int writen(signed int fd, unsigned char *buf, signed int amount)
{
  signed int sent;
  signed int n;
  sent = 0;
  while(!(sent >= amount))
  {
    signed long int return_value_write$1;
    return_value_write$1=write(fd, (const void *)(buf + (signed long int)sent), (unsigned long int)(amount - sent));
    n = (signed int)return_value_write$1;
    if(!(n == -1))
      sent = sent + n;

    if(n == -1)
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      if(!(*return_value___errno_location$2 == 11))
        return 0;

    }

  }
  return amount;
}

